
build/zephyr/zephyr.elf:	file format elf32-littlearm

Disassembly of section rom_start:

08000000 <_vector_start>:
 8000000: 08 52 00 20  	.word	0x20005208
 8000004: 59 63 00 08  	.word	0x08006359
 8000008: c1 55 00 08  	.word	0x080055c1
 800000c: 45 63 00 08  	.word	0x08006345
 8000010: 45 63 00 08  	.word	0x08006345
 8000014: 45 63 00 08  	.word	0x08006345
 8000018: 45 63 00 08  	.word	0x08006345
 800001c: 00 00 00 00  	.word	0x00000000
 8000020: 00 00 00 00  	.word	0x00000000
 8000024: 00 00 00 00  	.word	0x00000000
 8000028: 00 00 00 00  	.word	0x00000000
 800002c: 05 65 00 08  	.word	0x08006505
 8000030: 45 63 00 08  	.word	0x08006345
 8000034: 00 00 00 00  	.word	0x00000000
 8000038: 59 64 00 08  	.word	0x08006459
 800003c: 59 f1 00 08  	.word	0x0800f159

08000040 <$d>:
 8000040: 3d 68 00 08  	.word	0x0800683d
 8000044: 3d 68 00 08  	.word	0x0800683d
 8000048: 3d 68 00 08  	.word	0x0800683d
 800004c: 3d 68 00 08  	.word	0x0800683d
 8000050: 3d 68 00 08  	.word	0x0800683d
 8000054: 3d 68 00 08  	.word	0x0800683d
 8000058: 3d 68 00 08  	.word	0x0800683d
 800005c: 3d 68 00 08  	.word	0x0800683d
 8000060: 3d 68 00 08  	.word	0x0800683d
 8000064: 3d 68 00 08  	.word	0x0800683d
 8000068: 3d 68 00 08  	.word	0x0800683d
 800006c: 3d 68 00 08  	.word	0x0800683d
 8000070: 3d 68 00 08  	.word	0x0800683d
 8000074: 3d 68 00 08  	.word	0x0800683d
 8000078: 3d 68 00 08  	.word	0x0800683d
 800007c: 3d 68 00 08  	.word	0x0800683d
 8000080: 3d 68 00 08  	.word	0x0800683d
 8000084: 3d 68 00 08  	.word	0x0800683d
 8000088: 3d 68 00 08  	.word	0x0800683d
 800008c: 3d 68 00 08  	.word	0x0800683d
 8000090: 3d 68 00 08  	.word	0x0800683d
 8000094: 3d 68 00 08  	.word	0x0800683d
 8000098: 3d 68 00 08  	.word	0x0800683d
 800009c: 3d 68 00 08  	.word	0x0800683d
 80000a0: 3d 68 00 08  	.word	0x0800683d
 80000a4: 3d 68 00 08  	.word	0x0800683d
 80000a8: 3d 68 00 08  	.word	0x0800683d
 80000ac: 3d 68 00 08  	.word	0x0800683d
 80000b0: 3d 68 00 08  	.word	0x0800683d
 80000b4: 3d 68 00 08  	.word	0x0800683d
 80000b8: 3d 68 00 08  	.word	0x0800683d
 80000bc: 3d 68 00 08  	.word	0x0800683d
 80000c0: 3d 68 00 08  	.word	0x0800683d
 80000c4: 3d 68 00 08  	.word	0x0800683d
 80000c8: 3d 68 00 08  	.word	0x0800683d
 80000cc: 3d 68 00 08  	.word	0x0800683d
 80000d0: 3d 68 00 08  	.word	0x0800683d
 80000d4: 3d 68 00 08  	.word	0x0800683d
 80000d8: 3d 68 00 08  	.word	0x0800683d
 80000dc: 3d 68 00 08  	.word	0x0800683d
 80000e0: 3d 68 00 08  	.word	0x0800683d
 80000e4: 3d 68 00 08  	.word	0x0800683d
 80000e8: 3d 68 00 08  	.word	0x0800683d
 80000ec: 3d 68 00 08  	.word	0x0800683d
 80000f0: 3d 68 00 08  	.word	0x0800683d
 80000f4: 3d 68 00 08  	.word	0x0800683d
 80000f8: 3d 68 00 08  	.word	0x0800683d
 80000fc: 3d 68 00 08  	.word	0x0800683d
 8000100: 3d 68 00 08  	.word	0x0800683d
 8000104: 3d 68 00 08  	.word	0x0800683d
 8000108: 3d 68 00 08  	.word	0x0800683d
 800010c: 3d 68 00 08  	.word	0x0800683d
 8000110: 3d 68 00 08  	.word	0x0800683d
 8000114: 3d 68 00 08  	.word	0x0800683d
 8000118: 3d 68 00 08  	.word	0x0800683d
 800011c: 3d 68 00 08  	.word	0x0800683d
 8000120: 3d 68 00 08  	.word	0x0800683d
 8000124: 3d 68 00 08  	.word	0x0800683d
 8000128: 3d 68 00 08  	.word	0x0800683d
 800012c: 3d 68 00 08  	.word	0x0800683d
 8000130: 3d 68 00 08  	.word	0x0800683d
 8000134: 3d 68 00 08  	.word	0x0800683d
 8000138: 3d 68 00 08  	.word	0x0800683d
 800013c: 3d 68 00 08  	.word	0x0800683d
 8000140: 3d 68 00 08  	.word	0x0800683d
 8000144: 3d 68 00 08  	.word	0x0800683d
 8000148: 3d 68 00 08  	.word	0x0800683d
 800014c: 3d 68 00 08  	.word	0x0800683d
 8000150: 3d 68 00 08  	.word	0x0800683d
 8000154: 3d 68 00 08  	.word	0x0800683d
 8000158: 3d 68 00 08  	.word	0x0800683d
 800015c: 3d 68 00 08  	.word	0x0800683d
 8000160: 3d 68 00 08  	.word	0x0800683d
 8000164: 3d 68 00 08  	.word	0x0800683d
 8000168: 3d 68 00 08  	.word	0x0800683d
 800016c: 3d 68 00 08  	.word	0x0800683d
 8000170: 3d 68 00 08  	.word	0x0800683d
 8000174: 3d 68 00 08  	.word	0x0800683d
 8000178: 3d 68 00 08  	.word	0x0800683d
 800017c: 3d 68 00 08  	.word	0x0800683d
 8000180: 3d 68 00 08  	.word	0x0800683d
 8000184: 3d 68 00 08  	.word	0x0800683d

Disassembly of section text:

08000188 <__text_region_start>:
 8000188: f081 4100    	eor	r1, r1, #0x80000000
 800018c: e002         	b	0x8000194 <__aeabi_dadd> @ imm = #0x4
 800018e: bf00         	nop

08000190 <__subdf3>:
 8000190: f083 4300    	eor	r3, r3, #0x80000000

08000194 <__aeabi_dadd>:
 8000194: b530         	push	{r4, r5, lr}
 8000196: ea4f 0441    	lsl.w	r4, r1, #0x1
 800019a: ea4f 0543    	lsl.w	r5, r3, #0x1
 800019e: ea94 0f05    	teq.w	r4, r5
 80001a2: bf08         	it	eq
 80001a4: ea90 0f02    	teqeq.w	r0, r2
 80001a8: bf1f         	itttt	ne
 80001aa: ea54 0c00    	orrsne.w	r12, r4, r0
 80001ae: ea55 0c02    	orrsne.w	r12, r5, r2
 80001b2: ea7f 5c64    	mvnsne.w	r12, r4, asr #21
 80001b6: ea7f 5c65    	mvnsne.w	r12, r5, asr #21
 80001ba: f000 80e2    	beq.w	0x8000382 <__aeabi_dadd+0x1ee> @ imm = #0x1c4
 80001be: ea4f 5454    	lsr.w	r4, r4, #0x15
 80001c2: ebd4 5555    	rsbs	r5, r4, r5, lsr #21
 80001c6: bfb8         	it	lt
 80001c8: 426d         	rsblt	r5, r5, #0
 80001ca: dd0c         	ble	0x80001e6 <__aeabi_dadd+0x52> @ imm = #0x18
 80001cc: 442c         	add	r4, r5
 80001ce: ea80 0202    	eor.w	r2, r0, r2
 80001d2: ea81 0303    	eor.w	r3, r1, r3
 80001d6: ea82 0000    	eor.w	r0, r2, r0
 80001da: ea83 0101    	eor.w	r1, r3, r1
 80001de: ea80 0202    	eor.w	r2, r0, r2
 80001e2: ea81 0303    	eor.w	r3, r1, r3
 80001e6: 2d36         	cmp	r5, #0x36
 80001e8: bf88         	it	hi
 80001ea: bd30         	pophi	{r4, r5, pc}
 80001ec: f011 4f00    	tst.w	r1, #0x80000000
 80001f0: ea4f 3101    	lsl.w	r1, r1, #0xc
 80001f4: f44f 1c80    	mov.w	r12, #0x100000
 80001f8: ea4c 3111    	orr.w	r1, r12, r1, lsr #12
 80001fc: d002         	beq	0x8000204 <__aeabi_dadd+0x70> @ imm = #0x4
 80001fe: 4240         	rsbs	r0, r0, #0
 8000200: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000204: f013 4f00    	tst.w	r3, #0x80000000
 8000208: ea4f 3303    	lsl.w	r3, r3, #0xc
 800020c: ea4c 3313    	orr.w	r3, r12, r3, lsr #12
 8000210: d002         	beq	0x8000218 <__aeabi_dadd+0x84> @ imm = #0x4
 8000212: 4252         	rsbs	r2, r2, #0
 8000214: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 8000218: ea94 0f05    	teq.w	r4, r5
 800021c: f000 80a7    	beq.w	0x800036e <__aeabi_dadd+0x1da> @ imm = #0x14e
 8000220: f1a4 0401    	sub.w	r4, r4, #0x1
 8000224: f1d5 0e20    	rsbs.w	lr, r5, #0x20
 8000228: db0d         	blt	0x8000246 <__aeabi_dadd+0xb2> @ imm = #0x1a
 800022a: fa02 fc0e    	lsl.w	r12, r2, lr
 800022e: fa22 f205    	lsr.w	r2, r2, r5
 8000232: 1880         	adds	r0, r0, r2
 8000234: f141 0100    	adc	r1, r1, #0x0
 8000238: fa03 f20e    	lsl.w	r2, r3, lr
 800023c: 1880         	adds	r0, r0, r2
 800023e: fa43 f305    	asr.w	r3, r3, r5
 8000242: 4159         	adcs	r1, r3
 8000244: e00e         	b	0x8000264 <__aeabi_dadd+0xd0> @ imm = #0x1c
 8000246: f1a5 0520    	sub.w	r5, r5, #0x20
 800024a: f10e 0e20    	add.w	lr, lr, #0x20
 800024e: 2a01         	cmp	r2, #0x1
 8000250: fa03 fc0e    	lsl.w	r12, r3, lr
 8000254: bf28         	it	hs
 8000256: f04c 0c02    	orrhs	r12, r12, #0x2
 800025a: fa43 f305    	asr.w	r3, r3, r5
 800025e: 18c0         	adds	r0, r0, r3
 8000260: eb51 71e3    	adcs.w	r1, r1, r3, asr #31
 8000264: f001 4500    	and	r5, r1, #0x80000000
 8000268: d507         	bpl	0x800027a <__aeabi_dadd+0xe6> @ imm = #0xe
 800026a: f04f 0e00    	mov.w	lr, #0x0
 800026e: f1dc 0c00    	rsbs.w	r12, r12, #0x0
 8000272: eb7e 0000    	sbcs.w	r0, lr, r0
 8000276: eb6e 0101    	sbc.w	r1, lr, r1
 800027a: f5b1 1f80    	cmp.w	r1, #0x100000
 800027e: d31b         	blo	0x80002b8 <__aeabi_dadd+0x124> @ imm = #0x36
 8000280: f5b1 1f00    	cmp.w	r1, #0x200000
 8000284: d30c         	blo	0x80002a0 <__aeabi_dadd+0x10c> @ imm = #0x18
 8000286: 0849         	lsrs	r1, r1, #0x1
 8000288: ea5f 0030    	rrxs	r0, r0
 800028c: ea4f 0c3c    	rrx	r12, r12
 8000290: f104 0401    	add.w	r4, r4, #0x1
 8000294: ea4f 5244    	lsl.w	r2, r4, #0x15
 8000298: f512 0f80    	cmn.w	r2, #0x400000
 800029c: f080 809a    	bhs.w	0x80003d4 <__aeabi_dadd+0x240> @ imm = #0x134
 80002a0: f1bc 4f00    	cmp.w	r12, #0x80000000
 80002a4: bf08         	it	eq
 80002a6: ea5f 0c50    	lsrseq.w	r12, r0, #0x1
 80002aa: f150 0000    	adcs	r0, r0, #0x0
 80002ae: eb41 5104    	adc.w	r1, r1, r4, lsl #20
 80002b2: ea41 0105    	orr.w	r1, r1, r5
 80002b6: bd30         	pop	{r4, r5, pc}
 80002b8: ea5f 0c4c    	lsls.w	r12, r12, #0x1
 80002bc: 4140         	adcs	r0, r0
 80002be: eb41 0101    	adc.w	r1, r1, r1
 80002c2: 3c01         	subs	r4, #0x1
 80002c4: bf28         	it	hs
 80002c6: f5b1 1f80    	cmphs.w	r1, #0x100000
 80002ca: d2e9         	bhs	0x80002a0 <__aeabi_dadd+0x10c> @ imm = #-0x2e
 80002cc: f091 0f00    	teq.w	r1, #0x0
 80002d0: bf04         	itt	eq
 80002d2: 4601         	moveq	r1, r0
 80002d4: 2000         	moveq	r0, #0x0
 80002d6: fab1 f381    	clz	r3, r1
 80002da: bf08         	it	eq
 80002dc: 3320         	addeq	r3, #0x20
 80002de: f1a3 030b    	sub.w	r3, r3, #0xb
 80002e2: f1b3 0220    	subs.w	r2, r3, #0x20
 80002e6: da0c         	bge	0x8000302 <__aeabi_dadd+0x16e> @ imm = #0x18
 80002e8: 320c         	adds	r2, #0xc
 80002ea: dd08         	ble	0x80002fe <__aeabi_dadd+0x16a> @ imm = #0x10
 80002ec: f102 0c14    	add.w	r12, r2, #0x14
 80002f0: f1c2 020c    	rsb.w	r2, r2, #0xc
 80002f4: fa01 f00c    	lsl.w	r0, r1, r12
 80002f8: fa21 f102    	lsr.w	r1, r1, r2
 80002fc: e00c         	b	0x8000318 <__aeabi_dadd+0x184> @ imm = #0x18
 80002fe: f102 0214    	add.w	r2, r2, #0x14
 8000302: bfd8         	it	le
 8000304: f1c2 0c20    	rsble.w	r12, r2, #0x20
 8000308: fa01 f102    	lsl.w	r1, r1, r2
 800030c: fa20 fc0c    	lsr.w	r12, r0, r12
 8000310: bfdc         	itt	le
 8000312: ea41 010c    	orrle.w	r1, r1, r12
 8000316: 4090         	lslle	r0, r2
 8000318: 1ae4         	subs	r4, r4, r3
 800031a: bfa2         	ittt	ge
 800031c: eb01 5104    	addge.w	r1, r1, r4, lsl #20
 8000320: 4329         	orrge	r1, r5
 8000322: bd30         	popge	{r4, r5, pc}
 8000324: ea6f 0404    	mvn.w	r4, r4
 8000328: 3c1f         	subs	r4, #0x1f
 800032a: da1c         	bge	0x8000366 <__aeabi_dadd+0x1d2> @ imm = #0x38
 800032c: 340c         	adds	r4, #0xc
 800032e: dc0e         	bgt	0x800034e <__aeabi_dadd+0x1ba> @ imm = #0x1c
 8000330: f104 0414    	add.w	r4, r4, #0x14
 8000334: f1c4 0220    	rsb.w	r2, r4, #0x20
 8000338: fa20 f004    	lsr.w	r0, r0, r4
 800033c: fa01 f302    	lsl.w	r3, r1, r2
 8000340: ea40 0003    	orr.w	r0, r0, r3
 8000344: fa21 f304    	lsr.w	r3, r1, r4
 8000348: ea45 0103    	orr.w	r1, r5, r3
 800034c: bd30         	pop	{r4, r5, pc}
 800034e: f1c4 040c    	rsb.w	r4, r4, #0xc
 8000352: f1c4 0220    	rsb.w	r2, r4, #0x20
 8000356: fa20 f002    	lsr.w	r0, r0, r2
 800035a: fa01 f304    	lsl.w	r3, r1, r4
 800035e: ea40 0003    	orr.w	r0, r0, r3
 8000362: 4629         	mov	r1, r5
 8000364: bd30         	pop	{r4, r5, pc}
 8000366: fa21 f004    	lsr.w	r0, r1, r4
 800036a: 4629         	mov	r1, r5
 800036c: bd30         	pop	{r4, r5, pc}
 800036e: f094 0f00    	teq.w	r4, #0x0
 8000372: f483 1380    	eor	r3, r3, #0x100000
 8000376: bf06         	itte	eq
 8000378: f481 1180    	eoreq	r1, r1, #0x100000
 800037c: 3401         	addeq	r4, #0x1
 800037e: 3d01         	subne	r5, #0x1
 8000380: e74e         	b	0x8000220 <__aeabi_dadd+0x8c> @ imm = #-0x164
 8000382: ea7f 5c64    	mvns.w	r12, r4, asr #21
 8000386: bf18         	it	ne
 8000388: ea7f 5c65    	mvnsne.w	r12, r5, asr #21
 800038c: d029         	beq	0x80003e2 <__aeabi_dadd+0x24e> @ imm = #0x52
 800038e: ea94 0f05    	teq.w	r4, r5
 8000392: bf08         	it	eq
 8000394: ea90 0f02    	teqeq.w	r0, r2
 8000398: d005         	beq	0x80003a6 <__aeabi_dadd+0x212> @ imm = #0xa
 800039a: ea54 0c00    	orrs.w	r12, r4, r0
 800039e: bf04         	itt	eq
 80003a0: 4619         	moveq	r1, r3
 80003a2: 4610         	moveq	r0, r2
 80003a4: bd30         	pop	{r4, r5, pc}
 80003a6: ea91 0f03    	teq.w	r1, r3
 80003aa: bf1e         	ittt	ne
 80003ac: 2100         	movne	r1, #0x0
 80003ae: 2000         	movne	r0, #0x0
 80003b0: bd30         	popne	{r4, r5, pc}
 80003b2: ea5f 5c54    	lsrs.w	r12, r4, #0x15
 80003b6: d105         	bne	0x80003c4 <__aeabi_dadd+0x230> @ imm = #0xa
 80003b8: 0040         	lsls	r0, r0, #0x1
 80003ba: 4149         	adcs	r1, r1
 80003bc: bf28         	it	hs
 80003be: f041 4100    	orrhs	r1, r1, #0x80000000
 80003c2: bd30         	pop	{r4, r5, pc}
 80003c4: f514 0480    	adds.w	r4, r4, #0x400000
 80003c8: bf3c         	itt	lo
 80003ca: f501 1180    	addlo.w	r1, r1, #0x100000
 80003ce: bd30         	poplo	{r4, r5, pc}
 80003d0: f001 4500    	and	r5, r1, #0x80000000
 80003d4: f045 41fe    	orr	r1, r5, #0x7f000000
 80003d8: f441 0170    	orr	r1, r1, #0xf00000
 80003dc: f04f 0000    	mov.w	r0, #0x0
 80003e0: bd30         	pop	{r4, r5, pc}
 80003e2: ea7f 5c64    	mvns.w	r12, r4, asr #21
 80003e6: bf1a         	itte	ne
 80003e8: 4619         	movne	r1, r3
 80003ea: 4610         	movne	r0, r2
 80003ec: ea7f 5c65    	mvnseq.w	r12, r5, asr #21
 80003f0: bf1c         	itt	ne
 80003f2: 460b         	movne	r3, r1
 80003f4: 4602         	movne	r2, r0
 80003f6: ea50 3401    	orrs.w	r4, r0, r1, lsl #12
 80003fa: bf06         	itte	eq
 80003fc: ea52 3503    	orrseq.w	r5, r2, r3, lsl #12
 8000400: ea91 0f03    	teqeq.w	r1, r3
 8000404: f441 2100    	orrne	r1, r1, #0x80000
 8000408: bd30         	pop	{r4, r5, pc}
 800040a: bf00         	nop

0800040c <__floatunsidf>:
 800040c: f090 0f00    	teq.w	r0, #0x0
 8000410: bf04         	itt	eq
 8000412: 2100         	moveq	r1, #0x0
 8000414: 4770         	bxeq	lr
 8000416: b530         	push	{r4, r5, lr}
 8000418: f44f 6480    	mov.w	r4, #0x400
 800041c: f104 0432    	add.w	r4, r4, #0x32
 8000420: f04f 0500    	mov.w	r5, #0x0
 8000424: f04f 0100    	mov.w	r1, #0x0
 8000428: e750         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x160
 800042a: bf00         	nop

0800042c <__floatsidf>:
 800042c: f090 0f00    	teq.w	r0, #0x0
 8000430: bf04         	itt	eq
 8000432: 2100         	moveq	r1, #0x0
 8000434: 4770         	bxeq	lr
 8000436: b530         	push	{r4, r5, lr}
 8000438: f44f 6480    	mov.w	r4, #0x400
 800043c: f104 0432    	add.w	r4, r4, #0x32
 8000440: f010 4500    	ands	r5, r0, #0x80000000
 8000444: bf48         	it	mi
 8000446: 4240         	rsbmi	r0, r0, #0
 8000448: f04f 0100    	mov.w	r1, #0x0
 800044c: e73e         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x184
 800044e: bf00         	nop

08000450 <__extendsfdf2>:
 8000450: 0042         	lsls	r2, r0, #0x1
 8000452: ea4f 01e2    	asr.w	r1, r2, #0x3
 8000456: ea4f 0131    	rrx	r1, r1
 800045a: ea4f 7002    	lsl.w	r0, r2, #0x1c
 800045e: bf1f         	itttt	ne
 8000460: f012 437f    	andsne	r3, r2, #0xff000000
 8000464: f093 4f7f    	teqne.w	r3, #0xff000000
 8000468: f081 5160    	eorne	r1, r1, #0x38000000
 800046c: 4770         	bxne	lr
 800046e: f032 427f    	bics	r2, r2, #0xff000000
 8000472: bf08         	it	eq
 8000474: 4770         	bxeq	lr
 8000476: f093 4f7f    	teq.w	r3, #0xff000000
 800047a: bf04         	itt	eq
 800047c: f441 2100    	orreq	r1, r1, #0x80000
 8000480: 4770         	bxeq	lr
 8000482: b530         	push	{r4, r5, lr}
 8000484: f44f 7460    	mov.w	r4, #0x380
 8000488: f001 4500    	and	r5, r1, #0x80000000
 800048c: f021 4100    	bic	r1, r1, #0x80000000
 8000490: e71c         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x1c8
 8000492: bf00         	nop

08000494 <__floatundidf>:
 8000494: ea50 0201    	orrs.w	r2, r0, r1
 8000498: bf08         	it	eq
 800049a: 4770         	bxeq	lr
 800049c: b530         	push	{r4, r5, lr}
 800049e: f04f 0500    	mov.w	r5, #0x0
 80004a2: e00a         	b	0x80004ba <__floatdidf+0x16> @ imm = #0x14

080004a4 <__floatdidf>:
 80004a4: ea50 0201    	orrs.w	r2, r0, r1
 80004a8: bf08         	it	eq
 80004aa: 4770         	bxeq	lr
 80004ac: b530         	push	{r4, r5, lr}
 80004ae: f011 4500    	ands	r5, r1, #0x80000000
 80004b2: d502         	bpl	0x80004ba <__floatdidf+0x16> @ imm = #0x4
 80004b4: 4240         	rsbs	r0, r0, #0
 80004b6: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80004ba: f44f 6480    	mov.w	r4, #0x400
 80004be: f104 0432    	add.w	r4, r4, #0x32
 80004c2: ea5f 5c91    	lsrs.w	r12, r1, #0x16
 80004c6: f43f aed8    	beq.w	0x800027a <__aeabi_dadd+0xe6> @ imm = #-0x250
 80004ca: f04f 0203    	mov.w	r2, #0x3
 80004ce: ea5f 0cdc    	lsrs.w	r12, r12, #0x3
 80004d2: bf18         	it	ne
 80004d4: 3203         	addne	r2, #0x3
 80004d6: ea5f 0cdc    	lsrs.w	r12, r12, #0x3
 80004da: bf18         	it	ne
 80004dc: 3203         	addne	r2, #0x3
 80004de: eb02 02dc    	add.w	r2, r2, r12, lsr #3
 80004e2: f1c2 0320    	rsb.w	r3, r2, #0x20
 80004e6: fa00 fc03    	lsl.w	r12, r0, r3
 80004ea: fa20 f002    	lsr.w	r0, r0, r2
 80004ee: fa01 fe03    	lsl.w	lr, r1, r3
 80004f2: ea40 000e    	orr.w	r0, r0, lr
 80004f6: fa21 f102    	lsr.w	r1, r1, r2
 80004fa: 4414         	add	r4, r2
 80004fc: e6bd         	b	0x800027a <__aeabi_dadd+0xe6> @ imm = #-0x286
 80004fe: bf00         	nop

08000500 <__truncdfsf2>:
 8000500: ea4f 0241    	lsl.w	r2, r1, #0x1
 8000504: f1b2 43e0    	subs.w	r3, r2, #0x70000000
 8000508: bf24         	itt	hs
 800050a: f5b3 1c00    	subshs.w	r12, r3, #0x200000
 800050e: f1dc 5cfe    	rsbshs.w	r12, r12, #0x1fc00000
 8000512: d90d         	bls	0x8000530 <__truncdfsf2+0x30> @ imm = #0x1a
 8000514: f001 4c00    	and	r12, r1, #0x80000000
 8000518: ea4f 02c0    	lsl.w	r2, r0, #0x3
 800051c: ea4c 7050    	orr.w	r0, r12, r0, lsr #29
 8000520: f1b2 4f00    	cmp.w	r2, #0x80000000
 8000524: eb40 0083    	adc.w	r0, r0, r3, lsl #2
 8000528: bf08         	it	eq
 800052a: f020 0001    	biceq	r0, r0, #0x1
 800052e: 4770         	bx	lr
 8000530: f011 4f80    	tst.w	r1, #0x40000000
 8000534: d121         	bne	0x800057a <__truncdfsf2+0x7a> @ imm = #0x42
 8000536: f113 7238    	adds.w	r2, r3, #0x2e00000
 800053a: bfbc         	itt	lt
 800053c: f001 4000    	andlt	r0, r1, #0x80000000
 8000540: 4770         	bxlt	lr
 8000542: f441 1180    	orr	r1, r1, #0x100000
 8000546: ea4f 5252    	lsr.w	r2, r2, #0x15
 800054a: f1c2 0218    	rsb.w	r2, r2, #0x18
 800054e: f1c2 0c20    	rsb.w	r12, r2, #0x20
 8000552: fa10 f30c    	lsls.w	r3, r0, r12
 8000556: fa20 f002    	lsr.w	r0, r0, r2
 800055a: bf18         	it	ne
 800055c: f040 0001    	orrne	r0, r0, #0x1
 8000560: ea4f 23c1    	lsl.w	r3, r1, #0xb
 8000564: ea4f 23d3    	lsr.w	r3, r3, #0xb
 8000568: fa03 fc0c    	lsl.w	r12, r3, r12
 800056c: ea40 000c    	orr.w	r0, r0, r12
 8000570: fa23 f302    	lsr.w	r3, r3, r2
 8000574: ea4f 0343    	lsl.w	r3, r3, #0x1
 8000578: e7cc         	b	0x8000514 <__truncdfsf2+0x14> @ imm = #-0x68
 800057a: ea7f 5362    	mvns.w	r3, r2, asr #21
 800057e: d107         	bne	0x8000590 <__truncdfsf2+0x90> @ imm = #0xe
 8000580: ea50 3301    	orrs.w	r3, r0, r1, lsl #12
 8000584: bf1e         	ittt	ne
 8000586: f04f 40fe    	movne.w	r0, #0x7f000000
 800058a: f440 0040    	orrne	r0, r0, #0xc00000
 800058e: 4770         	bxne	lr
 8000590: f001 4000    	and	r0, r1, #0x80000000
 8000594: f040 40fe    	orr	r0, r0, #0x7f000000
 8000598: f440 0000    	orr	r0, r0, #0x800000
 800059c: 4770         	bx	lr
 800059e: bf00         	nop

080005a0 <__aeabi_ldivmod>:
 80005a0: b97b         	cbnz	r3, 0x80005c2 <__aeabi_ldivmod+0x22> @ imm = #0x1e
 80005a2: b972         	cbnz	r2, 0x80005c2 <__aeabi_ldivmod+0x22> @ imm = #0x1c
 80005a4: 2900         	cmp	r1, #0x0
 80005a6: bfbe         	ittt	lt
 80005a8: 2000         	movlt	r0, #0x0
 80005aa: f04f 4100    	movlt.w	r1, #0x80000000
 80005ae: e006         	blt	0x80005be <__aeabi_ldivmod+0x1e> @ imm = #0xc
 80005b0: bf08         	it	eq
 80005b2: 2800         	cmpeq	r0, #0x0
 80005b4: bf1c         	itt	ne
 80005b6: f06f 4100    	mvnne	r1, #0x80000000
 80005ba: f04f 30ff    	movne.w	r0, #0xffffffff
 80005be: f000 b857    	b.w	0x8000670 <__aeabi_ldiv0> @ imm = #0xae
 80005c2: f1ad 0c08    	sub.w	r12, sp, #0x8
 80005c6: e96d ce04    	strd	r12, lr, [sp, #-16]!
 80005ca: 2900         	cmp	r1, #0x0
 80005cc: db09         	blt	0x80005e2 <__aeabi_ldivmod+0x42> @ imm = #0x12
 80005ce: 2b00         	cmp	r3, #0x0
 80005d0: db1a         	blt	0x8000608 <__aeabi_ldivmod+0x68> @ imm = #0x34
 80005d2: f000 f861    	bl	0x8000698 <__udivmoddi4> @ imm = #0xc2
 80005d6: f8dd e004    	ldr.w	lr, [sp, #0x4]
 80005da: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 80005de: b004         	add	sp, #0x10
 80005e0: 4770         	bx	lr
 80005e2: 4240         	rsbs	r0, r0, #0
 80005e4: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80005e8: 2b00         	cmp	r3, #0x0
 80005ea: db1b         	blt	0x8000624 <__aeabi_ldivmod+0x84> @ imm = #0x36
 80005ec: f000 f854    	bl	0x8000698 <__udivmoddi4> @ imm = #0xa8
 80005f0: f8dd e004    	ldr.w	lr, [sp, #0x4]
 80005f4: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 80005f8: b004         	add	sp, #0x10
 80005fa: 4240         	rsbs	r0, r0, #0
 80005fc: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000600: 4252         	rsbs	r2, r2, #0
 8000602: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 8000606: 4770         	bx	lr
 8000608: 4252         	rsbs	r2, r2, #0
 800060a: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 800060e: f000 f843    	bl	0x8000698 <__udivmoddi4> @ imm = #0x86
 8000612: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000616: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 800061a: b004         	add	sp, #0x10
 800061c: 4240         	rsbs	r0, r0, #0
 800061e: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000622: 4770         	bx	lr
 8000624: 4252         	rsbs	r2, r2, #0
 8000626: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 800062a: f000 f835    	bl	0x8000698 <__udivmoddi4> @ imm = #0x6a
 800062e: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000632: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000636: b004         	add	sp, #0x10
 8000638: 4252         	rsbs	r2, r2, #0
 800063a: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 800063e: 4770         	bx	lr

08000640 <__aeabi_uldivmod>:
 8000640: b953         	cbnz	r3, 0x8000658 <__aeabi_uldivmod+0x18> @ imm = #0x14
 8000642: b94a         	cbnz	r2, 0x8000658 <__aeabi_uldivmod+0x18> @ imm = #0x12
 8000644: 2900         	cmp	r1, #0x0
 8000646: bf08         	it	eq
 8000648: 2800         	cmpeq	r0, #0x0
 800064a: bf1c         	itt	ne
 800064c: f04f 31ff    	movne.w	r1, #0xffffffff
 8000650: f04f 30ff    	movne.w	r0, #0xffffffff
 8000654: f000 b80c    	b.w	0x8000670 <__aeabi_ldiv0> @ imm = #0x18
 8000658: f1ad 0c08    	sub.w	r12, sp, #0x8
 800065c: e96d ce04    	strd	r12, lr, [sp, #-16]!
 8000660: f000 f81a    	bl	0x8000698 <__udivmoddi4> @ imm = #0x34
 8000664: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000668: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 800066c: b004         	add	sp, #0x10
 800066e: 4770         	bx	lr

08000670 <__aeabi_ldiv0>:
 8000670: 4770         	bx	lr
 8000672: bf00         	nop

08000674 <strcmp>:
 8000674: f810 2b01    	ldrb	r2, [r0], #1
 8000678: f811 3b01    	ldrb	r3, [r1], #1
 800067c: 2a01         	cmp	r2, #0x1
 800067e: bf28         	it	hs
 8000680: 429a         	cmphs	r2, r3
 8000682: d0f7         	beq	0x8000674 <strcmp>      @ imm = #-0x12
 8000684: 1ad0         	subs	r0, r2, r3
 8000686: 4770         	bx	lr

08000688 <strlen>:
 8000688: 4603         	mov	r3, r0
 800068a: f813 2b01    	ldrb	r2, [r3], #1
 800068e: 2a00         	cmp	r2, #0x0
 8000690: d1fb         	bne	0x800068a <strlen+0x2>  @ imm = #-0xa
 8000692: 1a18         	subs	r0, r3, r0
 8000694: 3801         	subs	r0, #0x1
 8000696: 4770         	bx	lr

08000698 <__udivmoddi4>:
 8000698: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 800069c: 4686         	mov	lr, r0
 800069e: 468c         	mov	r12, r1
 80006a0: 4608         	mov	r0, r1
 80006a2: 9e08         	ldr	r6, [sp, #0x20]
 80006a4: 4615         	mov	r5, r2
 80006a6: 4674         	mov	r4, lr
 80006a8: 4619         	mov	r1, r3
 80006aa: 2b00         	cmp	r3, #0x0
 80006ac: f040 80c2    	bne.w	0x8000834 <__udivmoddi4+0x19c> @ imm = #0x184
 80006b0: 4285         	cmp	r5, r0
 80006b2: fab2 f282    	clz	r2, r2
 80006b6: d945         	bls	0x8000744 <__udivmoddi4+0xac> @ imm = #0x8a
 80006b8: b14a         	cbz	r2, 0x80006ce <__udivmoddi4+0x36> @ imm = #0x12
 80006ba: f1c2 0320    	rsb.w	r3, r2, #0x20
 80006be: fa00 fc02    	lsl.w	r12, r0, r2
 80006c2: fa2e f303    	lsr.w	r3, lr, r3
 80006c6: 4095         	lsls	r5, r2
 80006c8: ea43 0c0c    	orr.w	r12, r3, r12
 80006cc: 4094         	lsls	r4, r2
 80006ce: ea4f 4e15    	lsr.w	lr, r5, #0x10
 80006d2: b2a8         	uxth	r0, r5
 80006d4: fbbc f8fe    	udiv	r8, r12, lr
 80006d8: 0c23         	lsrs	r3, r4, #0x10
 80006da: fb0e cc18    	mls	r12, lr, r8, r12
 80006de: fb08 f900    	mul	r9, r8, r0
 80006e2: ea43 430c    	orr.w	r3, r3, r12, lsl #16
 80006e6: 4599         	cmp	r9, r3
 80006e8: d928         	bls	0x800073c <__udivmoddi4+0xa4> @ imm = #0x50
 80006ea: 18eb         	adds	r3, r5, r3
 80006ec: f108 37ff    	add.w	r7, r8, #0xffffffff
 80006f0: d204         	bhs	0x80006fc <__udivmoddi4+0x64> @ imm = #0x8
 80006f2: 4599         	cmp	r9, r3
 80006f4: d902         	bls	0x80006fc <__udivmoddi4+0x64> @ imm = #0x4
 80006f6: f1a8 0702    	sub.w	r7, r8, #0x2
 80006fa: 442b         	add	r3, r5
 80006fc: eba3 0309    	sub.w	r3, r3, r9
 8000700: b2a4         	uxth	r4, r4
 8000702: fbb3 fcfe    	udiv	r12, r3, lr
 8000706: fb0e 331c    	mls	r3, lr, r12, r3
 800070a: fb0c f000    	mul	r0, r12, r0
 800070e: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 8000712: 42a0         	cmp	r0, r4
 8000714: d914         	bls	0x8000740 <__udivmoddi4+0xa8> @ imm = #0x28
 8000716: 192c         	adds	r4, r5, r4
 8000718: f10c 33ff    	add.w	r3, r12, #0xffffffff
 800071c: d204         	bhs	0x8000728 <__udivmoddi4+0x90> @ imm = #0x8
 800071e: 42a0         	cmp	r0, r4
 8000720: d902         	bls	0x8000728 <__udivmoddi4+0x90> @ imm = #0x4
 8000722: f1ac 0302    	sub.w	r3, r12, #0x2
 8000726: 442c         	add	r4, r5
 8000728: 1a24         	subs	r4, r4, r0
 800072a: ea43 4007    	orr.w	r0, r3, r7, lsl #16
 800072e: b11e         	cbz	r6, 0x8000738 <__udivmoddi4+0xa0> @ imm = #0x6
 8000730: 40d4         	lsrs	r4, r2
 8000732: 2300         	movs	r3, #0x0
 8000734: 6034         	str	r4, [r6]
 8000736: 6073         	str	r3, [r6, #0x4]
 8000738: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}
 800073c: 4647         	mov	r7, r8
 800073e: e7dd         	b	0x80006fc <__udivmoddi4+0x64> @ imm = #-0x46
 8000740: 4663         	mov	r3, r12
 8000742: e7f1         	b	0x8000728 <__udivmoddi4+0x90> @ imm = #-0x1e
 8000744: bb92         	cbnz	r2, 0x80007ac <__udivmoddi4+0x114> @ imm = #0x64
 8000746: 1b43         	subs	r3, r0, r5
 8000748: 2101         	movs	r1, #0x1
 800074a: ea4f 4e15    	lsr.w	lr, r5, #0x10
 800074e: b2af         	uxth	r7, r5
 8000750: fbb3 fcfe    	udiv	r12, r3, lr
 8000754: 0c20         	lsrs	r0, r4, #0x10
 8000756: fb0e 331c    	mls	r3, lr, r12, r3
 800075a: fb0c f807    	mul	r8, r12, r7
 800075e: ea40 4303    	orr.w	r3, r0, r3, lsl #16
 8000762: 4598         	cmp	r8, r3
 8000764: d962         	bls	0x800082c <__udivmoddi4+0x194> @ imm = #0xc4
 8000766: 18eb         	adds	r3, r5, r3
 8000768: f10c 30ff    	add.w	r0, r12, #0xffffffff
 800076c: d204         	bhs	0x8000778 <__udivmoddi4+0xe0> @ imm = #0x8
 800076e: 4598         	cmp	r8, r3
 8000770: d902         	bls	0x8000778 <__udivmoddi4+0xe0> @ imm = #0x4
 8000772: f1ac 0002    	sub.w	r0, r12, #0x2
 8000776: 442b         	add	r3, r5
 8000778: eba3 0308    	sub.w	r3, r3, r8
 800077c: b2a4         	uxth	r4, r4
 800077e: fbb3 fcfe    	udiv	r12, r3, lr
 8000782: fb0e 331c    	mls	r3, lr, r12, r3
 8000786: fb0c f707    	mul	r7, r12, r7
 800078a: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 800078e: 42a7         	cmp	r7, r4
 8000790: d94e         	bls	0x8000830 <__udivmoddi4+0x198> @ imm = #0x9c
 8000792: 192c         	adds	r4, r5, r4
 8000794: f10c 33ff    	add.w	r3, r12, #0xffffffff
 8000798: d204         	bhs	0x80007a4 <__udivmoddi4+0x10c> @ imm = #0x8
 800079a: 42a7         	cmp	r7, r4
 800079c: d902         	bls	0x80007a4 <__udivmoddi4+0x10c> @ imm = #0x4
 800079e: f1ac 0302    	sub.w	r3, r12, #0x2
 80007a2: 442c         	add	r4, r5
 80007a4: 1be4         	subs	r4, r4, r7
 80007a6: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 80007aa: e7c0         	b	0x800072e <__udivmoddi4+0x96> @ imm = #-0x80
 80007ac: f1c2 0320    	rsb.w	r3, r2, #0x20
 80007b0: fa20 f103    	lsr.w	r1, r0, r3
 80007b4: 4095         	lsls	r5, r2
 80007b6: 4090         	lsls	r0, r2
 80007b8: fa2e f303    	lsr.w	r3, lr, r3
 80007bc: 4303         	orrs	r3, r0
 80007be: ea4f 4e15    	lsr.w	lr, r5, #0x10
 80007c2: b2af         	uxth	r7, r5
 80007c4: fbb1 fcfe    	udiv	r12, r1, lr
 80007c8: fb0e 101c    	mls	r0, lr, r12, r1
 80007cc: 0c19         	lsrs	r1, r3, #0x10
 80007ce: fb0c f807    	mul	r8, r12, r7
 80007d2: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 80007d6: 4588         	cmp	r8, r1
 80007d8: fa04 f402    	lsl.w	r4, r4, r2
 80007dc: d922         	bls	0x8000824 <__udivmoddi4+0x18c> @ imm = #0x44
 80007de: 1869         	adds	r1, r5, r1
 80007e0: f10c 30ff    	add.w	r0, r12, #0xffffffff
 80007e4: d204         	bhs	0x80007f0 <__udivmoddi4+0x158> @ imm = #0x8
 80007e6: 4588         	cmp	r8, r1
 80007e8: d902         	bls	0x80007f0 <__udivmoddi4+0x158> @ imm = #0x4
 80007ea: f1ac 0002    	sub.w	r0, r12, #0x2
 80007ee: 4429         	add	r1, r5
 80007f0: eba1 0108    	sub.w	r1, r1, r8
 80007f4: b29b         	uxth	r3, r3
 80007f6: fbb1 fcfe    	udiv	r12, r1, lr
 80007fa: fb0e 111c    	mls	r1, lr, r12, r1
 80007fe: fb0c f707    	mul	r7, r12, r7
 8000802: ea43 4301    	orr.w	r3, r3, r1, lsl #16
 8000806: 429f         	cmp	r7, r3
 8000808: d90e         	bls	0x8000828 <__udivmoddi4+0x190> @ imm = #0x1c
 800080a: 18eb         	adds	r3, r5, r3
 800080c: f10c 31ff    	add.w	r1, r12, #0xffffffff
 8000810: d204         	bhs	0x800081c <__udivmoddi4+0x184> @ imm = #0x8
 8000812: 429f         	cmp	r7, r3
 8000814: d902         	bls	0x800081c <__udivmoddi4+0x184> @ imm = #0x4
 8000816: f1ac 0102    	sub.w	r1, r12, #0x2
 800081a: 442b         	add	r3, r5
 800081c: 1bdb         	subs	r3, r3, r7
 800081e: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 8000822: e792         	b	0x800074a <__udivmoddi4+0xb2> @ imm = #-0xdc
 8000824: 4660         	mov	r0, r12
 8000826: e7e3         	b	0x80007f0 <__udivmoddi4+0x158> @ imm = #-0x3a
 8000828: 4661         	mov	r1, r12
 800082a: e7f7         	b	0x800081c <__udivmoddi4+0x184> @ imm = #-0x12
 800082c: 4660         	mov	r0, r12
 800082e: e7a3         	b	0x8000778 <__udivmoddi4+0xe0> @ imm = #-0xba
 8000830: 4663         	mov	r3, r12
 8000832: e7b7         	b	0x80007a4 <__udivmoddi4+0x10c> @ imm = #-0x92
 8000834: 4283         	cmp	r3, r0
 8000836: d906         	bls	0x8000846 <__udivmoddi4+0x1ae> @ imm = #0xc
 8000838: b916         	cbnz	r6, 0x8000840 <__udivmoddi4+0x1a8> @ imm = #0x4
 800083a: 2100         	movs	r1, #0x0
 800083c: 4608         	mov	r0, r1
 800083e: e77b         	b	0x8000738 <__udivmoddi4+0xa0> @ imm = #-0x10a
 8000840: e9c6 e000    	strd	lr, r0, [r6]
 8000844: e7f9         	b	0x800083a <__udivmoddi4+0x1a2> @ imm = #-0xe
 8000846: fab3 f783    	clz	r7, r3
 800084a: b98f         	cbnz	r7, 0x8000870 <__udivmoddi4+0x1d8> @ imm = #0x22
 800084c: 4283         	cmp	r3, r0
 800084e: d301         	blo	0x8000854 <__udivmoddi4+0x1bc> @ imm = #0x2
 8000850: 4572         	cmp	r2, lr
 8000852: d808         	bhi	0x8000866 <__udivmoddi4+0x1ce> @ imm = #0x10
 8000854: ebbe 0402    	subs.w	r4, lr, r2
 8000858: eb60 0303    	sbc.w	r3, r0, r3
 800085c: 2001         	movs	r0, #0x1
 800085e: 469c         	mov	r12, r3
 8000860: b91e         	cbnz	r6, 0x800086a <__udivmoddi4+0x1d2> @ imm = #0x6
 8000862: 2100         	movs	r1, #0x0
 8000864: e768         	b	0x8000738 <__udivmoddi4+0xa0> @ imm = #-0x130
 8000866: 4638         	mov	r0, r7
 8000868: e7fa         	b	0x8000860 <__udivmoddi4+0x1c8> @ imm = #-0xc
 800086a: e9c6 4c00    	strd	r4, r12, [r6]
 800086e: e7f8         	b	0x8000862 <__udivmoddi4+0x1ca> @ imm = #-0x10
 8000870: f1c7 0c20    	rsb.w	r12, r7, #0x20
 8000874: 40bb         	lsls	r3, r7
 8000876: fa22 f40c    	lsr.w	r4, r2, r12
 800087a: 431c         	orrs	r4, r3
 800087c: fa2e f10c    	lsr.w	r1, lr, r12
 8000880: fa20 f30c    	lsr.w	r3, r0, r12
 8000884: 40b8         	lsls	r0, r7
 8000886: 4301         	orrs	r1, r0
 8000888: ea4f 4914    	lsr.w	r9, r4, #0x10
 800088c: fa0e f507    	lsl.w	r5, lr, r7
 8000890: fbb3 f8f9    	udiv	r8, r3, r9
 8000894: fa1f fe84    	uxth.w	lr, r4
 8000898: fb09 3018    	mls	r0, r9, r8, r3
 800089c: 0c0b         	lsrs	r3, r1, #0x10
 800089e: fb08 fa0e    	mul	r10, r8, lr
 80008a2: ea43 4300    	orr.w	r3, r3, r0, lsl #16
 80008a6: 459a         	cmp	r10, r3
 80008a8: fa02 f207    	lsl.w	r2, r2, r7
 80008ac: d940         	bls	0x8000930 <__udivmoddi4+0x298> @ imm = #0x80
 80008ae: 18e3         	adds	r3, r4, r3
 80008b0: f108 30ff    	add.w	r0, r8, #0xffffffff
 80008b4: d204         	bhs	0x80008c0 <__udivmoddi4+0x228> @ imm = #0x8
 80008b6: 459a         	cmp	r10, r3
 80008b8: d902         	bls	0x80008c0 <__udivmoddi4+0x228> @ imm = #0x4
 80008ba: f1a8 0002    	sub.w	r0, r8, #0x2
 80008be: 4423         	add	r3, r4
 80008c0: eba3 030a    	sub.w	r3, r3, r10
 80008c4: b289         	uxth	r1, r1
 80008c6: fbb3 f8f9    	udiv	r8, r3, r9
 80008ca: fb09 3318    	mls	r3, r9, r8, r3
 80008ce: fb08 fe0e    	mul	lr, r8, lr
 80008d2: ea41 4103    	orr.w	r1, r1, r3, lsl #16
 80008d6: 458e         	cmp	lr, r1
 80008d8: d92c         	bls	0x8000934 <__udivmoddi4+0x29c> @ imm = #0x58
 80008da: 1861         	adds	r1, r4, r1
 80008dc: f108 33ff    	add.w	r3, r8, #0xffffffff
 80008e0: d204         	bhs	0x80008ec <__udivmoddi4+0x254> @ imm = #0x8
 80008e2: 458e         	cmp	lr, r1
 80008e4: d902         	bls	0x80008ec <__udivmoddi4+0x254> @ imm = #0x4
 80008e6: f1a8 0302    	sub.w	r3, r8, #0x2
 80008ea: 4421         	add	r1, r4
 80008ec: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 80008f0: fba0 9802    	umull	r9, r8, r0, r2
 80008f4: eba1 010e    	sub.w	r1, r1, lr
 80008f8: 4541         	cmp	r1, r8
 80008fa: 46ce         	mov	lr, r9
 80008fc: 4643         	mov	r3, r8
 80008fe: d302         	blo	0x8000906 <__udivmoddi4+0x26e> @ imm = #0x4
 8000900: d106         	bne	0x8000910 <__udivmoddi4+0x278> @ imm = #0xc
 8000902: 454d         	cmp	r5, r9
 8000904: d204         	bhs	0x8000910 <__udivmoddi4+0x278> @ imm = #0x8
 8000906: ebb9 0e02    	subs.w	lr, r9, r2
 800090a: eb68 0304    	sbc.w	r3, r8, r4
 800090e: 3801         	subs	r0, #0x1
 8000910: 2e00         	cmp	r6, #0x0
 8000912: d0a6         	beq	0x8000862 <__udivmoddi4+0x1ca> @ imm = #-0xb4
 8000914: ebb5 020e    	subs.w	r2, r5, lr
 8000918: eb61 0103    	sbc.w	r1, r1, r3
 800091c: fa01 fc0c    	lsl.w	r12, r1, r12
 8000920: fa22 f307    	lsr.w	r3, r2, r7
 8000924: ea4c 0303    	orr.w	r3, r12, r3
 8000928: 40f9         	lsrs	r1, r7
 800092a: e9c6 3100    	strd	r3, r1, [r6]
 800092e: e798         	b	0x8000862 <__udivmoddi4+0x1ca> @ imm = #-0xd0
 8000930: 4640         	mov	r0, r8
 8000932: e7c5         	b	0x80008c0 <__udivmoddi4+0x228> @ imm = #-0x76
 8000934: 4643         	mov	r3, r8
 8000936: e7d9         	b	0x80008ec <__udivmoddi4+0x254> @ imm = #-0x4e

08000938 <sensor_ms2_to_g>:
; {
 8000938: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800093c: b090         	sub	sp, #0x40
 800093e: af00         	add	r7, sp, #0x0
 8000940: 6378         	str	r0, [r7, #0x34]
; 	int64_t micro_ms2 = ms2->val1 * 1000000LL + ms2->val2;
 8000942: 6b7b         	ldr	r3, [r7, #0x34]
 8000944: 681b         	ldr	r3, [r3]
 8000946: 17da         	asrs	r2, r3, #0x1f
 8000948: 469a         	mov	r10, r3
 800094a: 4693         	mov	r11, r2
 800094c: 4652         	mov	r2, r10
 800094e: 465b         	mov	r3, r11
 8000950: f04f 0000    	mov.w	r0, #0x0
 8000954: f04f 0100    	mov.w	r1, #0x0
 8000958: 0159         	lsls	r1, r3, #0x5
 800095a: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 800095e: 0150         	lsls	r0, r2, #0x5
 8000960: 4602         	mov	r2, r0
 8000962: 460b         	mov	r3, r1
 8000964: ebb2 040a    	subs.w	r4, r2, r10
 8000968: eb63 050b    	sbc.w	r5, r3, r11
 800096c: f04f 0200    	mov.w	r2, #0x0
 8000970: f04f 0300    	mov.w	r3, #0x0
 8000974: 026b         	lsls	r3, r5, #0x9
 8000976: ea43 53d4    	orr.w	r3, r3, r4, lsr #23
 800097a: 0262         	lsls	r2, r4, #0x9
 800097c: 4614         	mov	r4, r2
 800097e: 461d         	mov	r5, r3
 8000980: eb14 080a    	adds.w	r8, r4, r10
 8000984: eb45 090b    	adc.w	r9, r5, r11
 8000988: f04f 0200    	mov.w	r2, #0x0
 800098c: f04f 0300    	mov.w	r3, #0x0
 8000990: ea4f 1389    	lsl.w	r3, r9, #0x6
 8000994: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 8000998: ea4f 1288    	lsl.w	r2, r8, #0x6
 800099c: ebb2 0108    	subs.w	r1, r2, r8
 80009a0: 60b9         	str	r1, [r7, #0x8]
 80009a2: eb63 0309    	sbc.w	r3, r3, r9
 80009a6: 60fb         	str	r3, [r7, #0xc]
 80009a8: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 80009ac: 460b         	mov	r3, r1
 80009ae: eb13 030a    	adds.w	r3, r3, r10
 80009b2: 62bb         	str	r3, [r7, #0x28]
 80009b4: 4613         	mov	r3, r2
 80009b6: eb43 030b    	adc.w	r3, r3, r11
 80009ba: 62fb         	str	r3, [r7, #0x2c]
 80009bc: 6b7b         	ldr	r3, [r7, #0x34]
 80009be: 685b         	ldr	r3, [r3, #0x4]
 80009c0: 17da         	asrs	r2, r3, #0x1f
 80009c2: 623b         	str	r3, [r7, #0x20]
 80009c4: 627a         	str	r2, [r7, #0x24]
 80009c6: e9d7 450a    	ldrd	r4, r5, [r7, #40]
 80009ca: 4623         	mov	r3, r4
 80009cc: e9d7 0108    	ldrd	r0, r1, [r7, #32]
 80009d0: 4602         	mov	r2, r0
 80009d2: 189b         	adds	r3, r3, r2
 80009d4: 603b         	str	r3, [r7]
 80009d6: 460b         	mov	r3, r1
 80009d8: 462a         	mov	r2, r5
 80009da: eb42 0303    	adc.w	r3, r2, r3
 80009de: 607b         	str	r3, [r7, #0x4]
 80009e0: e9d7 3400    	ldrd	r3, r4, [r7]
 80009e4: e9c7 340e    	strd	r3, r4, [r7, #56]
; 	if (micro_ms2 > 0) {
 80009e8: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 80009ec: 2a01         	cmp	r2, #0x1
 80009ee: f173 0300    	sbcs	r3, r3, #0x0
 80009f2: db12         	blt	0x8000a1a <sensor_ms2_to_g+0xe2> @ imm = #0x24
; 		return (micro_ms2 + SENSOR_G / 2) / SENSOR_G;
 80009f4: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 80009f8: 4915         	ldr	r1, [pc, #0x54]         @ 0x8000a50 <sensor_ms2_to_g+0x118>
 80009fa: 1851         	adds	r1, r2, r1
 80009fc: 61b9         	str	r1, [r7, #0x18]
 80009fe: f143 0300    	adc	r3, r3, #0x0
 8000a02: 61fb         	str	r3, [r7, #0x1c]
 8000a04: a310         	adr	r3, #64 <sensor_ms2_to_g+0xe0>
 8000a06: e9d3 2300    	ldrd	r2, r3, [r3]
 8000a0a: e9d7 0106    	ldrd	r0, r1, [r7, #24]
 8000a0e: f7ff fdc7    	bl	0x80005a0 <__aeabi_ldivmod> @ imm = #-0x472
 8000a12: 4602         	mov	r2, r0
 8000a14: 460b         	mov	r3, r1
 8000a16: 4613         	mov	r3, r2
 8000a18: e011         	b	0x8000a3e <sensor_ms2_to_g+0x106> @ imm = #0x22
; 		return (micro_ms2 - SENSOR_G / 2) / SENSOR_G;
 8000a1a: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 8000a1e: 490d         	ldr	r1, [pc, #0x34]         @ 0x8000a54 <sensor_ms2_to_g+0x11c>
 8000a20: 1851         	adds	r1, r2, r1
 8000a22: 6139         	str	r1, [r7, #0x10]
 8000a24: f143 33ff    	adc	r3, r3, #0xffffffff
 8000a28: 617b         	str	r3, [r7, #0x14]
 8000a2a: a307         	adr	r3, #28 <sensor_ms2_to_g+0xfd>
 8000a2c: e9d3 2300    	ldrd	r2, r3, [r3]
 8000a30: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 8000a34: f7ff fdb4    	bl	0x80005a0 <__aeabi_ldivmod> @ imm = #-0x498
 8000a38: 4602         	mov	r2, r0
 8000a3a: 460b         	mov	r3, r1
 8000a3c: 4613         	mov	r3, r2
; }
 8000a3e: 4618         	mov	r0, r3
 8000a40: 3740         	adds	r7, #0x40
 8000a42: 46bd         	mov	sp, r7
 8000a44: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08000a48 <$d>:
 8000a48: 3a a3 95 00  	.word	0x0095a33a
 8000a4c: 00 00 00 00  	.word	0x00000000
 8000a50: 9d d1 4a 00  	.word	0x004ad19d
 8000a54: 63 2e b5 ff  	.word	0xffb52e63

08000a58 <sensor_rad_to_degrees>:
; {
 8000a58: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8000a5c: b09c         	sub	sp, #0x70
 8000a5e: af00         	add	r7, sp, #0x0
 8000a60: 6678         	str	r0, [r7, #0x64]
; 	int64_t micro_rad_s = rad->val1 * 1000000LL + rad->val2;
 8000a62: 6e7b         	ldr	r3, [r7, #0x64]
 8000a64: 681b         	ldr	r3, [r3]
 8000a66: 17da         	asrs	r2, r3, #0x1f
 8000a68: 65bb         	str	r3, [r7, #0x58]
 8000a6a: 65fa         	str	r2, [r7, #0x5c]
 8000a6c: e9d7 2316    	ldrd	r2, r3, [r7, #88]
 8000a70: f04f 0000    	mov.w	r0, #0x0
 8000a74: f04f 0100    	mov.w	r1, #0x0
 8000a78: 0159         	lsls	r1, r3, #0x5
 8000a7a: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 8000a7e: 0150         	lsls	r0, r2, #0x5
 8000a80: 4602         	mov	r2, r0
 8000a82: 460b         	mov	r3, r1
 8000a84: 6db9         	ldr	r1, [r7, #0x58]
 8000a86: 1a54         	subs	r4, r2, r1
 8000a88: 6df9         	ldr	r1, [r7, #0x5c]
 8000a8a: eb63 0501    	sbc.w	r5, r3, r1
 8000a8e: f04f 0200    	mov.w	r2, #0x0
 8000a92: f04f 0300    	mov.w	r3, #0x0
 8000a96: 026b         	lsls	r3, r5, #0x9
 8000a98: ea43 53d4    	orr.w	r3, r3, r4, lsr #23
 8000a9c: 0262         	lsls	r2, r4, #0x9
 8000a9e: 4614         	mov	r4, r2
 8000aa0: 461d         	mov	r5, r3
 8000aa2: e9d7 0116    	ldrd	r0, r1, [r7, #88]
 8000aa6: 4603         	mov	r3, r0
 8000aa8: eb14 0803    	adds.w	r8, r4, r3
 8000aac: e9c7 0116    	strd	r0, r1, [r7, #88]
 8000ab0: 460b         	mov	r3, r1
 8000ab2: eb45 0903    	adc.w	r9, r5, r3
 8000ab6: f04f 0200    	mov.w	r2, #0x0
 8000aba: f04f 0300    	mov.w	r3, #0x0
 8000abe: ea4f 1389    	lsl.w	r3, r9, #0x6
 8000ac2: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 8000ac6: ea4f 1288    	lsl.w	r2, r8, #0x6
 8000aca: ebb2 0108    	subs.w	r1, r2, r8
 8000ace: 6339         	str	r1, [r7, #0x30]
 8000ad0: eb63 0309    	sbc.w	r3, r3, r9
 8000ad4: 637b         	str	r3, [r7, #0x34]
 8000ad6: e9d7 450c    	ldrd	r4, r5, [r7, #48]
 8000ada: 4623         	mov	r3, r4
 8000adc: e9d7 0116    	ldrd	r0, r1, [r7, #88]
 8000ae0: 4602         	mov	r2, r0
 8000ae2: 189b         	adds	r3, r3, r2
 8000ae4: 653b         	str	r3, [r7, #0x50]
 8000ae6: 460b         	mov	r3, r1
 8000ae8: 462a         	mov	r2, r5
 8000aea: eb42 0303    	adc.w	r3, r2, r3
 8000aee: 657b         	str	r3, [r7, #0x54]
 8000af0: 6e7b         	ldr	r3, [r7, #0x64]
 8000af2: 685b         	ldr	r3, [r3, #0x4]
 8000af4: 17da         	asrs	r2, r3, #0x1f
 8000af6: 64bb         	str	r3, [r7, #0x48]
 8000af8: 64fa         	str	r2, [r7, #0x4c]
 8000afa: e9d7 4514    	ldrd	r4, r5, [r7, #80]
 8000afe: 4623         	mov	r3, r4
 8000b00: e9d7 0112    	ldrd	r0, r1, [r7, #72]
 8000b04: 4602         	mov	r2, r0
 8000b06: 189b         	adds	r3, r3, r2
 8000b08: 62bb         	str	r3, [r7, #0x28]
 8000b0a: 460b         	mov	r3, r1
 8000b0c: 462a         	mov	r2, r5
 8000b0e: eb42 0303    	adc.w	r3, r2, r3
 8000b12: 62fb         	str	r3, [r7, #0x2c]
 8000b14: e9d7 340a    	ldrd	r3, r4, [r7, #40]
 8000b18: e9c7 341a    	strd	r3, r4, [r7, #104]
; 	if (micro_rad_s > 0) {
 8000b1c: e9d7 231a    	ldrd	r2, r3, [r7, #104]
 8000b20: 2a01         	cmp	r2, #0x1
 8000b22: f173 0300    	sbcs	r3, r3, #0x0
 8000b26: db3f         	blt	0x8000ba8 <sensor_rad_to_degrees+0x150> @ imm = #0x7e
; 		return (micro_rad_s * 180LL + SENSOR_PI / 2) / SENSOR_PI;
 8000b28: e9d7 011a    	ldrd	r0, r1, [r7, #104]
 8000b2c: 4602         	mov	r2, r0
 8000b2e: 460b         	mov	r3, r1
 8000b30: 1894         	adds	r4, r2, r2
 8000b32: 623c         	str	r4, [r7, #0x20]
 8000b34: 415b         	adcs	r3, r3
 8000b36: 627b         	str	r3, [r7, #0x24]
 8000b38: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8000b3c: 1814         	adds	r4, r2, r0
 8000b3e: 61bc         	str	r4, [r7, #0x18]
 8000b40: 414b         	adcs	r3, r1
 8000b42: 61fb         	str	r3, [r7, #0x1c]
 8000b44: f04f 0200    	mov.w	r2, #0x0
 8000b48: f04f 0300    	mov.w	r3, #0x0
 8000b4c: e9d7 4506    	ldrd	r4, r5, [r7, #24]
 8000b50: 4629         	mov	r1, r5
 8000b52: 010b         	lsls	r3, r1, #0x4
 8000b54: 4621         	mov	r1, r4
 8000b56: ea43 7311    	orr.w	r3, r3, r1, lsr #28
 8000b5a: 4621         	mov	r1, r4
 8000b5c: 010a         	lsls	r2, r1, #0x4
 8000b5e: 4621         	mov	r1, r4
 8000b60: 1a51         	subs	r1, r2, r1
 8000b62: 6139         	str	r1, [r7, #0x10]
 8000b64: 4629         	mov	r1, r5
 8000b66: eb63 0301    	sbc.w	r3, r3, r1
 8000b6a: 617b         	str	r3, [r7, #0x14]
 8000b6c: f04f 0200    	mov.w	r2, #0x0
 8000b70: f04f 0300    	mov.w	r3, #0x0
 8000b74: e9d7 4504    	ldrd	r4, r5, [r7, #16]
 8000b78: 4629         	mov	r1, r5
 8000b7a: 008b         	lsls	r3, r1, #0x2
 8000b7c: 4621         	mov	r1, r4
 8000b7e: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 8000b82: 4621         	mov	r1, r4
 8000b84: 008a         	lsls	r2, r1, #0x2
 8000b86: 492a         	ldr	r1, [pc, #0xa8]         @ 0x8000c30 <sensor_rad_to_degrees+0x1d8>
 8000b88: 1851         	adds	r1, r2, r1
 8000b8a: 6439         	str	r1, [r7, #0x40]
 8000b8c: f143 0300    	adc	r3, r3, #0x0
 8000b90: 647b         	str	r3, [r7, #0x44]
 8000b92: a325         	adr	r3, #148 <sensor_rad_to_degrees+0x163>
 8000b94: e9d3 2300    	ldrd	r2, r3, [r3]
 8000b98: e9d7 0110    	ldrd	r0, r1, [r7, #64]
 8000b9c: f7ff fd00    	bl	0x80005a0 <__aeabi_ldivmod> @ imm = #-0x600
 8000ba0: 4602         	mov	r2, r0
 8000ba2: 460b         	mov	r3, r1
 8000ba4: 4613         	mov	r3, r2
 8000ba6: e03a         	b	0x8000c1e <sensor_rad_to_degrees+0x1c6> @ imm = #0x74
; 		return (micro_rad_s * 180LL - SENSOR_PI / 2) / SENSOR_PI;
 8000ba8: e9d7 011a    	ldrd	r0, r1, [r7, #104]
 8000bac: 4602         	mov	r2, r0
 8000bae: 460b         	mov	r3, r1
 8000bb0: 1894         	adds	r4, r2, r2
 8000bb2: 60bc         	str	r4, [r7, #0x8]
 8000bb4: 415b         	adcs	r3, r3
 8000bb6: 60fb         	str	r3, [r7, #0xc]
 8000bb8: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 8000bbc: eb12 0a00    	adds.w	r10, r2, r0
 8000bc0: eb43 0b01    	adc.w	r11, r3, r1
 8000bc4: f04f 0200    	mov.w	r2, #0x0
 8000bc8: f04f 0300    	mov.w	r3, #0x0
 8000bcc: ea4f 130b    	lsl.w	r3, r11, #0x4
 8000bd0: ea43 731a    	orr.w	r3, r3, r10, lsr #28
 8000bd4: ea4f 120a    	lsl.w	r2, r10, #0x4
 8000bd8: ebb2 010a    	subs.w	r1, r2, r10
 8000bdc: 6039         	str	r1, [r7]
 8000bde: eb63 030b    	sbc.w	r3, r3, r11
 8000be2: 607b         	str	r3, [r7, #0x4]
 8000be4: f04f 0200    	mov.w	r2, #0x0
 8000be8: f04f 0300    	mov.w	r3, #0x0
 8000bec: e9d7 4500    	ldrd	r4, r5, [r7]
 8000bf0: 4629         	mov	r1, r5
 8000bf2: 008b         	lsls	r3, r1, #0x2
 8000bf4: 4621         	mov	r1, r4
 8000bf6: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 8000bfa: 4621         	mov	r1, r4
 8000bfc: 008a         	lsls	r2, r1, #0x2
 8000bfe: 490d         	ldr	r1, [pc, #0x34]         @ 0x8000c34 <sensor_rad_to_degrees+0x1dc>
 8000c00: 1851         	adds	r1, r2, r1
 8000c02: 63b9         	str	r1, [r7, #0x38]
 8000c04: f143 33ff    	adc	r3, r3, #0xffffffff
 8000c08: 63fb         	str	r3, [r7, #0x3c]
 8000c0a: a307         	adr	r3, #28 <sensor_rad_to_degrees+0x1bd>
 8000c0c: e9d3 2300    	ldrd	r2, r3, [r3]
 8000c10: e9d7 010e    	ldrd	r0, r1, [r7, #56]
 8000c14: f7ff fcc4    	bl	0x80005a0 <__aeabi_ldivmod> @ imm = #-0x678
 8000c18: 4602         	mov	r2, r0
 8000c1a: 460b         	mov	r3, r1
 8000c1c: 4613         	mov	r3, r2
; }
 8000c1e: 4618         	mov	r0, r3
 8000c20: 3770         	adds	r7, #0x70
 8000c22: 46bd         	mov	sp, r7
 8000c24: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08000c28 <$d>:
 8000c28: d8 ef 2f 00  	.word	0x002fefd8
 8000c2c: 00 00 00 00  	.word	0x00000000
 8000c30: ec f7 17 00  	.word	0x0017f7ec
 8000c34: 14 08 e8 ff  	.word	0xffe80814

08000c38 <board_init>:
; {
 8000c38: b580         	push	{r7, lr}
 8000c3a: af00         	add	r7, sp, #0x0
; 	printk("Board init done.\n");
 8000c3c: 4802         	ldr	r0, [pc, #0x8]          @ 0x8000c48 <board_init+0x10>
 8000c3e: f01a fba8    	bl	0x801b392 <printk>      @ imm = #0x1a750
; }
 8000c42: bf00         	nop
 8000c44: bd80         	pop	{r7, pc}
 8000c46: bf00         	nop

08000c48 <$d>:
 8000c48: 40 82 02 08  	.word	0x08028240

08000c4c <sensor_value_to_float>:
; {
 8000c4c: b480         	push	{r7}
 8000c4e: b083         	sub	sp, #0xc
 8000c50: af00         	add	r7, sp, #0x0
 8000c52: 6078         	str	r0, [r7, #0x4]
; 	return (float)val->val1 + (float)val->val2 / 1000000;
 8000c54: 687b         	ldr	r3, [r7, #0x4]
 8000c56: 681b         	ldr	r3, [r3]
 8000c58: ee07 3a90    	vmov	s15, r3
 8000c5c: eeb8 7ae7    	vcvt.f32.s32	s14, s15
 8000c60: 687b         	ldr	r3, [r7, #0x4]
 8000c62: 685b         	ldr	r3, [r3, #0x4]
 8000c64: ee07 3a90    	vmov	s15, r3
 8000c68: eef8 6ae7    	vcvt.f32.s32	s13, s15
 8000c6c: ed9f 6a06    	vldr	s12, [pc, #24]          @ 0x8000c88 <sensor_value_to_float+0x3c>
 8000c70: eec6 7a86    	vdiv.f32	s15, s13, s12
 8000c74: ee77 7a27    	vadd.f32	s15, s14, s15
; }
 8000c78: eeb0 0a67    	vmov.f32	s0, s15
 8000c7c: 370c         	adds	r7, #0xc
 8000c7e: 46bd         	mov	sp, r7
 8000c80: f85d 7b04    	ldr	r7, [sp], #4
 8000c84: 4770         	bx	lr
 8000c86: bf00         	nop

08000c88 <$d>:
 8000c88: 00 24 74 49  	.word	0x49742400

08000c8c <Kalman_Filter_Init>:
; {
 8000c8c: b580         	push	{r7, lr}
 8000c8e: b082         	sub	sp, #0x8
 8000c90: af00         	add	r7, sp, #0x0
 8000c92: 6078         	str	r0, [r7, #0x4]
 8000c94: 4608         	mov	r0, r1
 8000c96: 4611         	mov	r1, r2
 8000c98: 461a         	mov	r2, r3
 8000c9a: 4603         	mov	r3, r0
 8000c9c: 70fb         	strb	r3, [r7, #0x3]
 8000c9e: 460b         	mov	r3, r1
 8000ca0: 70bb         	strb	r3, [r7, #0x2]
 8000ca2: 4613         	mov	r3, r2
 8000ca4: 707b         	strb	r3, [r7, #0x1]
; 	sizeof_float = sizeof(float);
 8000ca6: 4bba         	ldr	r3, [pc, #0x2e8]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000ca8: 2204         	movs	r2, #0x4
 8000caa: 801a         	strh	r2, [r3]
; 	sizeof_double = sizeof(double);
 8000cac: 4bb9         	ldr	r3, [pc, #0x2e4]        @ 0x8000f94 <Kalman_Filter_Init+0x308>
 8000cae: 2208         	movs	r2, #0x8
 8000cb0: 801a         	strh	r2, [r3]
; 	kf->xhatSize = xhatSize;
 8000cb2: 687b         	ldr	r3, [r7, #0x4]
 8000cb4: 78fa         	ldrb	r2, [r7, #0x3]
 8000cb6: 731a         	strb	r2, [r3, #0xc]
; 	kf->uSize = uSize;
 8000cb8: 687b         	ldr	r3, [r7, #0x4]
 8000cba: 78ba         	ldrb	r2, [r7, #0x2]
 8000cbc: 735a         	strb	r2, [r3, #0xd]
; 	kf->zSize = zSize;
 8000cbe: 687b         	ldr	r3, [r7, #0x4]
 8000cc0: 787a         	ldrb	r2, [r7, #0x1]
 8000cc2: 739a         	strb	r2, [r3, #0xe]
; 	kf->MeasurementValidNum = 0;
 8000cc4: 687b         	ldr	r3, [r7, #0x4]
 8000cc6: 2200         	movs	r2, #0x0
 8000cc8: 741a         	strb	r2, [r3, #0x10]
; 	kf->MeasurementMap = (uint8_t *)user_malloc(sizeof(uint8_t) * zSize);
 8000cca: 787b         	ldrb	r3, [r7, #0x1]
 8000ccc: 4618         	mov	r0, r3
 8000cce: f005 fe3d    	bl	0x800694c <malloc>      @ imm = #0x5c7a
 8000cd2: 4603         	mov	r3, r0
 8000cd4: 461a         	mov	r2, r3
 8000cd6: 687b         	ldr	r3, [r7, #0x4]
 8000cd8: 615a         	str	r2, [r3, #0x14]
; 	memset(kf->MeasurementMap, 0, sizeof(uint8_t) * zSize);
 8000cda: 687b         	ldr	r3, [r7, #0x4]
 8000cdc: 695b         	ldr	r3, [r3, #0x14]
 8000cde: 787a         	ldrb	r2, [r7, #0x1]
 8000ce0: 2100         	movs	r1, #0x0
 8000ce2: 4618         	mov	r0, r3
 8000ce4: f026 fc10    	bl	0x8027508 <memset>      @ imm = #0x26820
; 	kf->MeasurementDegree = (float *)user_malloc(sizeof_float * zSize);
 8000ce8: 4ba9         	ldr	r3, [pc, #0x2a4]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000cea: 881b         	ldrh	r3, [r3]
 8000cec: 461a         	mov	r2, r3
 8000cee: 787b         	ldrb	r3, [r7, #0x1]
 8000cf0: fb02 f303    	mul	r3, r2, r3
 8000cf4: 4618         	mov	r0, r3
 8000cf6: f005 fe29    	bl	0x800694c <malloc>      @ imm = #0x5c52
 8000cfa: 4603         	mov	r3, r0
 8000cfc: 461a         	mov	r2, r3
 8000cfe: 687b         	ldr	r3, [r7, #0x4]
 8000d00: 619a         	str	r2, [r3, #0x18]
; 	memset(kf->MeasurementDegree, 0, sizeof_float * zSize);
 8000d02: 687b         	ldr	r3, [r7, #0x4]
 8000d04: 6998         	ldr	r0, [r3, #0x18]
 8000d06: 4ba2         	ldr	r3, [pc, #0x288]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000d08: 881b         	ldrh	r3, [r3]
 8000d0a: 461a         	mov	r2, r3
 8000d0c: 787b         	ldrb	r3, [r7, #0x1]
 8000d0e: fb02 f303    	mul	r3, r2, r3
 8000d12: 461a         	mov	r2, r3
 8000d14: 2100         	movs	r1, #0x0
 8000d16: f026 fbf7    	bl	0x8027508 <memset>      @ imm = #0x267ee
; 	kf->MatR_DiagonalElements = (float *)user_malloc(sizeof_float * zSize);
 8000d1a: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000d1c: 881b         	ldrh	r3, [r3]
 8000d1e: 461a         	mov	r2, r3
 8000d20: 787b         	ldrb	r3, [r7, #0x1]
 8000d22: fb02 f303    	mul	r3, r2, r3
 8000d26: 4618         	mov	r0, r3
 8000d28: f005 fe10    	bl	0x800694c <malloc>      @ imm = #0x5c20
 8000d2c: 4603         	mov	r3, r0
 8000d2e: 461a         	mov	r2, r3
 8000d30: 687b         	ldr	r3, [r7, #0x4]
 8000d32: 61da         	str	r2, [r3, #0x1c]
; 	memset(kf->MatR_DiagonalElements, 0, sizeof_float * zSize);
 8000d34: 687b         	ldr	r3, [r7, #0x4]
 8000d36: 69d8         	ldr	r0, [r3, #0x1c]
 8000d38: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000d3a: 881b         	ldrh	r3, [r3]
 8000d3c: 461a         	mov	r2, r3
 8000d3e: 787b         	ldrb	r3, [r7, #0x1]
 8000d40: fb02 f303    	mul	r3, r2, r3
 8000d44: 461a         	mov	r2, r3
 8000d46: 2100         	movs	r1, #0x0
 8000d48: f026 fbde    	bl	0x8027508 <memset>      @ imm = #0x267bc
; 	kf->StateMinVariance = (float *)user_malloc(sizeof_float * xhatSize);
 8000d4c: 4b90         	ldr	r3, [pc, #0x240]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000d4e: 881b         	ldrh	r3, [r3]
 8000d50: 461a         	mov	r2, r3
 8000d52: 78fb         	ldrb	r3, [r7, #0x3]
 8000d54: fb02 f303    	mul	r3, r2, r3
 8000d58: 4618         	mov	r0, r3
 8000d5a: f005 fdf7    	bl	0x800694c <malloc>      @ imm = #0x5bee
 8000d5e: 4603         	mov	r3, r0
 8000d60: 461a         	mov	r2, r3
 8000d62: 687b         	ldr	r3, [r7, #0x4]
 8000d64: 621a         	str	r2, [r3, #0x20]
; 	memset(kf->StateMinVariance, 0, sizeof_float * xhatSize);
 8000d66: 687b         	ldr	r3, [r7, #0x4]
 8000d68: 6a18         	ldr	r0, [r3, #0x20]
 8000d6a: 4b89         	ldr	r3, [pc, #0x224]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000d6c: 881b         	ldrh	r3, [r3]
 8000d6e: 461a         	mov	r2, r3
 8000d70: 78fb         	ldrb	r3, [r7, #0x3]
 8000d72: fb02 f303    	mul	r3, r2, r3
 8000d76: 461a         	mov	r2, r3
 8000d78: 2100         	movs	r1, #0x0
 8000d7a: f026 fbc5    	bl	0x8027508 <memset>      @ imm = #0x2678a
; 	kf->temp = (uint8_t *)user_malloc(sizeof(uint8_t) * zSize);
 8000d7e: 787b         	ldrb	r3, [r7, #0x1]
 8000d80: 4618         	mov	r0, r3
 8000d82: f005 fde3    	bl	0x800694c <malloc>      @ imm = #0x5bc6
 8000d86: 4603         	mov	r3, r0
 8000d88: 461a         	mov	r2, r3
 8000d8a: 687b         	ldr	r3, [r7, #0x4]
 8000d8c: 625a         	str	r2, [r3, #0x24]
; 	memset(kf->temp, 0, sizeof(uint8_t) * zSize);
 8000d8e: 687b         	ldr	r3, [r7, #0x4]
 8000d90: 6a5b         	ldr	r3, [r3, #0x24]
 8000d92: 787a         	ldrb	r2, [r7, #0x1]
 8000d94: 2100         	movs	r1, #0x0
 8000d96: 4618         	mov	r0, r3
 8000d98: f026 fbb6    	bl	0x8027508 <memset>      @ imm = #0x2676c
; 	kf->FilteredValue = (float *)user_malloc(sizeof_float * xhatSize);
 8000d9c: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000d9e: 881b         	ldrh	r3, [r3]
 8000da0: 461a         	mov	r2, r3
 8000da2: 78fb         	ldrb	r3, [r7, #0x3]
 8000da4: fb02 f303    	mul	r3, r2, r3
 8000da8: 4618         	mov	r0, r3
 8000daa: f005 fdcf    	bl	0x800694c <malloc>      @ imm = #0x5b9e
 8000dae: 4603         	mov	r3, r0
 8000db0: 461a         	mov	r2, r3
 8000db2: 687b         	ldr	r3, [r7, #0x4]
 8000db4: 601a         	str	r2, [r3]
; 	memset(kf->FilteredValue, 0, sizeof_float * xhatSize);
 8000db6: 687b         	ldr	r3, [r7, #0x4]
 8000db8: 6818         	ldr	r0, [r3]
 8000dba: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000dbc: 881b         	ldrh	r3, [r3]
 8000dbe: 461a         	mov	r2, r3
 8000dc0: 78fb         	ldrb	r3, [r7, #0x3]
 8000dc2: fb02 f303    	mul	r3, r2, r3
 8000dc6: 461a         	mov	r2, r3
 8000dc8: 2100         	movs	r1, #0x0
 8000dca: f026 fb9d    	bl	0x8027508 <memset>      @ imm = #0x2673a
; 	kf->MeasuredVector = (float *)user_malloc(sizeof_float * zSize);
 8000dce: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000dd0: 881b         	ldrh	r3, [r3]
 8000dd2: 461a         	mov	r2, r3
 8000dd4: 787b         	ldrb	r3, [r7, #0x1]
 8000dd6: fb02 f303    	mul	r3, r2, r3
 8000dda: 4618         	mov	r0, r3
 8000ddc: f005 fdb6    	bl	0x800694c <malloc>      @ imm = #0x5b6c
 8000de0: 4603         	mov	r3, r0
 8000de2: 461a         	mov	r2, r3
 8000de4: 687b         	ldr	r3, [r7, #0x4]
 8000de6: 605a         	str	r2, [r3, #0x4]
; 	memset(kf->MeasuredVector, 0, sizeof_float * zSize);
 8000de8: 687b         	ldr	r3, [r7, #0x4]
 8000dea: 6858         	ldr	r0, [r3, #0x4]
 8000dec: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000dee: 881b         	ldrh	r3, [r3]
 8000df0: 461a         	mov	r2, r3
 8000df2: 787b         	ldrb	r3, [r7, #0x1]
 8000df4: fb02 f303    	mul	r3, r2, r3
 8000df8: 461a         	mov	r2, r3
 8000dfa: 2100         	movs	r1, #0x0
 8000dfc: f026 fb84    	bl	0x8027508 <memset>      @ imm = #0x26708
; 	kf->ControlVector = (float *)user_malloc(sizeof_float * uSize);
 8000e00: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000e02: 881b         	ldrh	r3, [r3]
 8000e04: 461a         	mov	r2, r3
 8000e06: 78bb         	ldrb	r3, [r7, #0x2]
 8000e08: fb02 f303    	mul	r3, r2, r3
 8000e0c: 4618         	mov	r0, r3
 8000e0e: f005 fd9d    	bl	0x800694c <malloc>      @ imm = #0x5b3a
 8000e12: 4603         	mov	r3, r0
 8000e14: 461a         	mov	r2, r3
 8000e16: 687b         	ldr	r3, [r7, #0x4]
 8000e18: 609a         	str	r2, [r3, #0x8]
; 	memset(kf->ControlVector, 0, sizeof_float * uSize);
 8000e1a: 687b         	ldr	r3, [r7, #0x4]
 8000e1c: 6898         	ldr	r0, [r3, #0x8]
 8000e1e: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000e20: 881b         	ldrh	r3, [r3]
 8000e22: 461a         	mov	r2, r3
 8000e24: 78bb         	ldrb	r3, [r7, #0x2]
 8000e26: fb02 f303    	mul	r3, r2, r3
 8000e2a: 461a         	mov	r2, r3
 8000e2c: 2100         	movs	r1, #0x0
 8000e2e: f026 fb6b    	bl	0x8027508 <memset>      @ imm = #0x266d6
; 	kf->xhat_data = (float *)user_malloc(sizeof_float * xhatSize);
 8000e32: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000e34: 881b         	ldrh	r3, [r3]
 8000e36: 461a         	mov	r2, r3
 8000e38: 78fb         	ldrb	r3, [r7, #0x3]
 8000e3a: fb02 f303    	mul	r3, r2, r3
 8000e3e: 4618         	mov	r0, r3
 8000e40: f005 fd84    	bl	0x800694c <malloc>      @ imm = #0x5b08
 8000e44: 4603         	mov	r3, r0
 8000e46: 461a         	mov	r2, r3
 8000e48: 687b         	ldr	r3, [r7, #0x4]
 8000e4a: f8c3 20e8    	str.w	r2, [r3, #0xe8]
; 	memset(kf->xhat_data, 0, sizeof_float * xhatSize);
 8000e4e: 687b         	ldr	r3, [r7, #0x4]
 8000e50: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 8000e54: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000e56: 881b         	ldrh	r3, [r3]
 8000e58: 461a         	mov	r2, r3
 8000e5a: 78fb         	ldrb	r3, [r7, #0x3]
 8000e5c: fb02 f303    	mul	r3, r2, r3
 8000e60: 461a         	mov	r2, r3
 8000e62: 2100         	movs	r1, #0x0
 8000e64: f026 fb50    	bl	0x8027508 <memset>      @ imm = #0x266a0
; 	Matrix_Init(&kf->xhat, kf->xhatSize, 1, (float *)kf->xhat_data);
 8000e68: 687b         	ldr	r3, [r7, #0x4]
 8000e6a: f103 0030    	add.w	r0, r3, #0x30
 8000e6e: 687b         	ldr	r3, [r7, #0x4]
 8000e70: 7b1b         	ldrb	r3, [r3, #0xc]
 8000e72: 4619         	mov	r1, r3
 8000e74: 687b         	ldr	r3, [r7, #0x4]
 8000e76: f8d3 30e8    	ldr.w	r3, [r3, #0xe8]
 8000e7a: 2201         	movs	r2, #0x1
 8000e7c: f011 fabe    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x1157c
; 	kf->xhatminus_data = (float *)user_malloc(sizeof_float * xhatSize);
 8000e80: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000e82: 881b         	ldrh	r3, [r3]
 8000e84: 461a         	mov	r2, r3
 8000e86: 78fb         	ldrb	r3, [r7, #0x3]
 8000e88: fb02 f303    	mul	r3, r2, r3
 8000e8c: 4618         	mov	r0, r3
 8000e8e: f005 fd5d    	bl	0x800694c <malloc>      @ imm = #0x5aba
 8000e92: 4603         	mov	r3, r0
 8000e94: 461a         	mov	r2, r3
 8000e96: 687b         	ldr	r3, [r7, #0x4]
 8000e98: f8c3 20ec    	str.w	r2, [r3, #0xec]
; 	memset(kf->xhatminus_data, 0, sizeof_float * xhatSize);
 8000e9c: 687b         	ldr	r3, [r7, #0x4]
 8000e9e: f8d3 00ec    	ldr.w	r0, [r3, #0xec]
 8000ea2: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000ea4: 881b         	ldrh	r3, [r3]
 8000ea6: 461a         	mov	r2, r3
 8000ea8: 78fb         	ldrb	r3, [r7, #0x3]
 8000eaa: fb02 f303    	mul	r3, r2, r3
 8000eae: 461a         	mov	r2, r3
 8000eb0: 2100         	movs	r1, #0x0
 8000eb2: f026 fb29    	bl	0x8027508 <memset>      @ imm = #0x26652
; 	Matrix_Init(&kf->xhatminus, kf->xhatSize, 1, (float *)kf->xhatminus_data);
 8000eb6: 687b         	ldr	r3, [r7, #0x4]
 8000eb8: f103 0038    	add.w	r0, r3, #0x38
 8000ebc: 687b         	ldr	r3, [r7, #0x4]
 8000ebe: 7b1b         	ldrb	r3, [r3, #0xc]
 8000ec0: 4619         	mov	r1, r3
 8000ec2: 687b         	ldr	r3, [r7, #0x4]
 8000ec4: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8000ec8: 2201         	movs	r2, #0x1
 8000eca: f011 fa97    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x1152e
; 	if (uSize != 0) {
 8000ece: 78bb         	ldrb	r3, [r7, #0x2]
 8000ed0: 2b00         	cmp	r3, #0x0
 8000ed2: d026         	beq	0x8000f22 <Kalman_Filter_Init+0x296> @ imm = #0x4c
; 		kf->u_data = (float *)user_malloc(sizeof_float * uSize);
 8000ed4: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000ed6: 881b         	ldrh	r3, [r3]
 8000ed8: 461a         	mov	r2, r3
 8000eda: 78bb         	ldrb	r3, [r7, #0x2]
 8000edc: fb02 f303    	mul	r3, r2, r3
 8000ee0: 4618         	mov	r0, r3
 8000ee2: f005 fd33    	bl	0x800694c <malloc>      @ imm = #0x5a66
 8000ee6: 4603         	mov	r3, r0
 8000ee8: 461a         	mov	r2, r3
 8000eea: 687b         	ldr	r3, [r7, #0x4]
 8000eec: f8c3 20f0    	str.w	r2, [r3, #0xf0]
; 		memset(kf->u_data, 0, sizeof_float * uSize);
 8000ef0: 687b         	ldr	r3, [r7, #0x4]
 8000ef2: f8d3 00f0    	ldr.w	r0, [r3, #0xf0]
 8000ef6: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000ef8: 881b         	ldrh	r3, [r3]
 8000efa: 461a         	mov	r2, r3
 8000efc: 78bb         	ldrb	r3, [r7, #0x2]
 8000efe: fb02 f303    	mul	r3, r2, r3
 8000f02: 461a         	mov	r2, r3
 8000f04: 2100         	movs	r1, #0x0
 8000f06: f026 faff    	bl	0x8027508 <memset>      @ imm = #0x265fe
; 		Matrix_Init(&kf->u, kf->uSize, 1, (float *)kf->u_data);
 8000f0a: 687b         	ldr	r3, [r7, #0x4]
 8000f0c: f103 0040    	add.w	r0, r3, #0x40
 8000f10: 687b         	ldr	r3, [r7, #0x4]
 8000f12: 7b5b         	ldrb	r3, [r3, #0xd]
 8000f14: 4619         	mov	r1, r3
 8000f16: 687b         	ldr	r3, [r7, #0x4]
 8000f18: f8d3 30f0    	ldr.w	r3, [r3, #0xf0]
 8000f1c: 2201         	movs	r2, #0x1
 8000f1e: f011 fa6d    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x114da
; 	kf->z_data = (float *)user_malloc(sizeof_float * zSize);
 8000f22: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000f24: 881b         	ldrh	r3, [r3]
 8000f26: 461a         	mov	r2, r3
 8000f28: 787b         	ldrb	r3, [r7, #0x1]
 8000f2a: fb02 f303    	mul	r3, r2, r3
 8000f2e: 4618         	mov	r0, r3
 8000f30: f005 fd0c    	bl	0x800694c <malloc>      @ imm = #0x5a18
 8000f34: 4603         	mov	r3, r0
 8000f36: 461a         	mov	r2, r3
 8000f38: 687b         	ldr	r3, [r7, #0x4]
 8000f3a: f8c3 20f4    	str.w	r2, [r3, #0xf4]
; 	memset(kf->z_data, 0, sizeof_float * zSize);
 8000f3e: 687b         	ldr	r3, [r7, #0x4]
 8000f40: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 8000f44: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000f46: 881b         	ldrh	r3, [r3]
 8000f48: 461a         	mov	r2, r3
 8000f4a: 787b         	ldrb	r3, [r7, #0x1]
 8000f4c: fb02 f303    	mul	r3, r2, r3
 8000f50: 461a         	mov	r2, r3
 8000f52: 2100         	movs	r1, #0x0
 8000f54: f026 fad8    	bl	0x8027508 <memset>      @ imm = #0x265b0
; 	Matrix_Init(&kf->z, kf->zSize, 1, (float *)kf->z_data);
 8000f58: 687b         	ldr	r3, [r7, #0x4]
 8000f5a: f103 0048    	add.w	r0, r3, #0x48
 8000f5e: 687b         	ldr	r3, [r7, #0x4]
 8000f60: 7b9b         	ldrb	r3, [r3, #0xe]
 8000f62: 4619         	mov	r1, r3
 8000f64: 687b         	ldr	r3, [r7, #0x4]
 8000f66: f8d3 30f4    	ldr.w	r3, [r3, #0xf4]
 8000f6a: 2201         	movs	r2, #0x1
 8000f6c: f011 fa46    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x1148c
; 	kf->P_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8000f70: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8000f90 <Kalman_Filter_Init+0x304>
 8000f72: 881b         	ldrh	r3, [r3]
 8000f74: 461a         	mov	r2, r3
 8000f76: 78fb         	ldrb	r3, [r7, #0x3]
 8000f78: fb02 f303    	mul	r3, r2, r3
 8000f7c: 78fa         	ldrb	r2, [r7, #0x3]
 8000f7e: fb02 f303    	mul	r3, r2, r3
 8000f82: 4618         	mov	r0, r3
 8000f84: f005 fce2    	bl	0x800694c <malloc>      @ imm = #0x59c4
 8000f88: 4603         	mov	r3, r0
 8000f8a: 461a         	mov	r2, r3
 8000f8c: 687b         	ldr	r3, [r7, #0x4]
 8000f8e: e003         	b	0x8000f98 <Kalman_Filter_Init+0x30c> @ imm = #0x6

08000f90 <$d>:
 8000f90: 00 33 00 20  	.word	0x20003300
 8000f94: 02 33 00 20  	.word	0x20003302

08000f98 <$t>:
 8000f98: f8c3 20f8    	str.w	r2, [r3, #0xf8]
; 	memset(kf->P_data, 0, sizeof_float * xhatSize * xhatSize);
 8000f9c: 687b         	ldr	r3, [r7, #0x4]
 8000f9e: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 8000fa2: 4bbd         	ldr	r3, [pc, #0x2f4]        @ 0x8001298 <Kalman_Filter_Init+0x60c>
 8000fa4: 881b         	ldrh	r3, [r3]
 8000fa6: 461a         	mov	r2, r3
 8000fa8: 78fb         	ldrb	r3, [r7, #0x3]
 8000faa: fb02 f303    	mul	r3, r2, r3
 8000fae: 78fa         	ldrb	r2, [r7, #0x3]
 8000fb0: fb02 f303    	mul	r3, r2, r3
 8000fb4: 461a         	mov	r2, r3
 8000fb6: 2100         	movs	r1, #0x0
 8000fb8: f026 faa6    	bl	0x8027508 <memset>      @ imm = #0x2654c
; 	Matrix_Init(&kf->P, kf->xhatSize, kf->xhatSize, (float *)kf->P_data);
 8000fbc: 687b         	ldr	r3, [r7, #0x4]
 8000fbe: f103 0050    	add.w	r0, r3, #0x50
 8000fc2: 687b         	ldr	r3, [r7, #0x4]
 8000fc4: 7b1b         	ldrb	r3, [r3, #0xc]
 8000fc6: 4619         	mov	r1, r3
 8000fc8: 687b         	ldr	r3, [r7, #0x4]
 8000fca: 7b1b         	ldrb	r3, [r3, #0xc]
 8000fcc: 461a         	mov	r2, r3
 8000fce: 687b         	ldr	r3, [r7, #0x4]
 8000fd0: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8000fd4: f011 fa12    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x11424
; 	kf->Pminus_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8000fd8: 4baf         	ldr	r3, [pc, #0x2bc]        @ 0x8001298 <Kalman_Filter_Init+0x60c>
 8000fda: 881b         	ldrh	r3, [r3]
 8000fdc: 461a         	mov	r2, r3
 8000fde: 78fb         	ldrb	r3, [r7, #0x3]
 8000fe0: fb02 f303    	mul	r3, r2, r3
 8000fe4: 78fa         	ldrb	r2, [r7, #0x3]
 8000fe6: fb02 f303    	mul	r3, r2, r3
 8000fea: 4618         	mov	r0, r3
 8000fec: f005 fcae    	bl	0x800694c <malloc>      @ imm = #0x595c
 8000ff0: 4603         	mov	r3, r0
 8000ff2: 461a         	mov	r2, r3
 8000ff4: 687b         	ldr	r3, [r7, #0x4]
 8000ff6: f8c3 20fc    	str.w	r2, [r3, #0xfc]
; 	memset(kf->Pminus_data, 0, sizeof_float * xhatSize * xhatSize);
 8000ffa: 687b         	ldr	r3, [r7, #0x4]
 8000ffc: f8d3 00fc    	ldr.w	r0, [r3, #0xfc]
 8001000: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8001298 <Kalman_Filter_Init+0x60c>
 8001002: 881b         	ldrh	r3, [r3]
 8001004: 461a         	mov	r2, r3
 8001006: 78fb         	ldrb	r3, [r7, #0x3]
 8001008: fb02 f303    	mul	r3, r2, r3
 800100c: 78fa         	ldrb	r2, [r7, #0x3]
 800100e: fb02 f303    	mul	r3, r2, r3
 8001012: 461a         	mov	r2, r3
 8001014: 2100         	movs	r1, #0x0
 8001016: f026 fa77    	bl	0x8027508 <memset>      @ imm = #0x264ee
; 	Matrix_Init(&kf->Pminus, kf->xhatSize, kf->xhatSize, (float *)kf->Pminus_data);
 800101a: 687b         	ldr	r3, [r7, #0x4]
 800101c: f103 0058    	add.w	r0, r3, #0x58
 8001020: 687b         	ldr	r3, [r7, #0x4]
 8001022: 7b1b         	ldrb	r3, [r3, #0xc]
 8001024: 4619         	mov	r1, r3
 8001026: 687b         	ldr	r3, [r7, #0x4]
 8001028: 7b1b         	ldrb	r3, [r3, #0xc]
 800102a: 461a         	mov	r2, r3
 800102c: 687b         	ldr	r3, [r7, #0x4]
 800102e: f8d3 30fc    	ldr.w	r3, [r3, #0xfc]
 8001032: f011 f9e3    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x113c6
; 	kf->F_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001036: 4b98         	ldr	r3, [pc, #0x260]        @ 0x8001298 <Kalman_Filter_Init+0x60c>
 8001038: 881b         	ldrh	r3, [r3]
 800103a: 461a         	mov	r2, r3
 800103c: 78fb         	ldrb	r3, [r7, #0x3]
 800103e: fb02 f303    	mul	r3, r2, r3
 8001042: 78fa         	ldrb	r2, [r7, #0x3]
 8001044: fb02 f303    	mul	r3, r2, r3
 8001048: 4618         	mov	r0, r3
 800104a: f005 fc7f    	bl	0x800694c <malloc>      @ imm = #0x58fe
 800104e: 4603         	mov	r3, r0
 8001050: 461a         	mov	r2, r3
 8001052: 687b         	ldr	r3, [r7, #0x4]
 8001054: f8c3 2100    	str.w	r2, [r3, #0x100]
; 	kf->FT_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001058: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8001298 <Kalman_Filter_Init+0x60c>
 800105a: 881b         	ldrh	r3, [r3]
 800105c: 461a         	mov	r2, r3
 800105e: 78fb         	ldrb	r3, [r7, #0x3]
 8001060: fb02 f303    	mul	r3, r2, r3
 8001064: 78fa         	ldrb	r2, [r7, #0x3]
 8001066: fb02 f303    	mul	r3, r2, r3
 800106a: 4618         	mov	r0, r3
 800106c: f005 fc6e    	bl	0x800694c <malloc>      @ imm = #0x58dc
 8001070: 4603         	mov	r3, r0
 8001072: 461a         	mov	r2, r3
 8001074: 687b         	ldr	r3, [r7, #0x4]
 8001076: f8c3 2104    	str.w	r2, [r3, #0x104]
; 	memset(kf->F_data, 0, sizeof_float * xhatSize * xhatSize);
 800107a: 687b         	ldr	r3, [r7, #0x4]
 800107c: f8d3 0100    	ldr.w	r0, [r3, #0x100]
 8001080: 4b85         	ldr	r3, [pc, #0x214]        @ 0x8001298 <Kalman_Filter_Init+0x60c>
 8001082: 881b         	ldrh	r3, [r3]
 8001084: 461a         	mov	r2, r3
 8001086: 78fb         	ldrb	r3, [r7, #0x3]
 8001088: fb02 f303    	mul	r3, r2, r3
 800108c: 78fa         	ldrb	r2, [r7, #0x3]
 800108e: fb02 f303    	mul	r3, r2, r3
 8001092: 461a         	mov	r2, r3
 8001094: 2100         	movs	r1, #0x0
 8001096: f026 fa37    	bl	0x8027508 <memset>      @ imm = #0x2646e
; 	memset(kf->FT_data, 0, sizeof_float * xhatSize * xhatSize);
 800109a: 687b         	ldr	r3, [r7, #0x4]
 800109c: f8d3 0104    	ldr.w	r0, [r3, #0x104]
 80010a0: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x8001298 <Kalman_Filter_Init+0x60c>
 80010a2: 881b         	ldrh	r3, [r3]
 80010a4: 461a         	mov	r2, r3
 80010a6: 78fb         	ldrb	r3, [r7, #0x3]
 80010a8: fb02 f303    	mul	r3, r2, r3
 80010ac: 78fa         	ldrb	r2, [r7, #0x3]
 80010ae: fb02 f303    	mul	r3, r2, r3
 80010b2: 461a         	mov	r2, r3
 80010b4: 2100         	movs	r1, #0x0
 80010b6: f026 fa27    	bl	0x8027508 <memset>      @ imm = #0x2644e
; 	Matrix_Init(&kf->F, kf->xhatSize, kf->xhatSize, (float *)kf->F_data);
 80010ba: 687b         	ldr	r3, [r7, #0x4]
 80010bc: f103 0060    	add.w	r0, r3, #0x60
 80010c0: 687b         	ldr	r3, [r7, #0x4]
 80010c2: 7b1b         	ldrb	r3, [r3, #0xc]
 80010c4: 4619         	mov	r1, r3
 80010c6: 687b         	ldr	r3, [r7, #0x4]
 80010c8: 7b1b         	ldrb	r3, [r3, #0xc]
 80010ca: 461a         	mov	r2, r3
 80010cc: 687b         	ldr	r3, [r7, #0x4]
 80010ce: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80010d2: f011 f993    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x11326
; 	Matrix_Init(&kf->FT, kf->xhatSize, kf->xhatSize, (float *)kf->FT_data);
 80010d6: 687b         	ldr	r3, [r7, #0x4]
 80010d8: f103 0068    	add.w	r0, r3, #0x68
 80010dc: 687b         	ldr	r3, [r7, #0x4]
 80010de: 7b1b         	ldrb	r3, [r3, #0xc]
 80010e0: 4619         	mov	r1, r3
 80010e2: 687b         	ldr	r3, [r7, #0x4]
 80010e4: 7b1b         	ldrb	r3, [r3, #0xc]
 80010e6: 461a         	mov	r2, r3
 80010e8: 687b         	ldr	r3, [r7, #0x4]
 80010ea: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 80010ee: f011 f985    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x1130a
; 	if (uSize != 0) {
 80010f2: 78bb         	ldrb	r3, [r7, #0x2]
 80010f4: 2b00         	cmp	r3, #0x0
 80010f6: d02e         	beq	0x8001156 <Kalman_Filter_Init+0x4ca> @ imm = #0x5c
; 		kf->B_data = (float *)user_malloc(sizeof_float * xhatSize * uSize);
 80010f8: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x8001298 <Kalman_Filter_Init+0x60c>
 80010fa: 881b         	ldrh	r3, [r3]
 80010fc: 461a         	mov	r2, r3
 80010fe: 78fb         	ldrb	r3, [r7, #0x3]
 8001100: fb02 f303    	mul	r3, r2, r3
 8001104: 78ba         	ldrb	r2, [r7, #0x2]
 8001106: fb02 f303    	mul	r3, r2, r3
 800110a: 4618         	mov	r0, r3
 800110c: f005 fc1e    	bl	0x800694c <malloc>      @ imm = #0x583c
 8001110: 4603         	mov	r3, r0
 8001112: 461a         	mov	r2, r3
 8001114: 687b         	ldr	r3, [r7, #0x4]
 8001116: f8c3 2108    	str.w	r2, [r3, #0x108]
; 		memset(kf->B_data, 0, sizeof_float * xhatSize * uSize);
 800111a: 687b         	ldr	r3, [r7, #0x4]
 800111c: f8d3 0108    	ldr.w	r0, [r3, #0x108]
 8001120: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8001298 <Kalman_Filter_Init+0x60c>
 8001122: 881b         	ldrh	r3, [r3]
 8001124: 461a         	mov	r2, r3
 8001126: 78fb         	ldrb	r3, [r7, #0x3]
 8001128: fb02 f303    	mul	r3, r2, r3
 800112c: 78ba         	ldrb	r2, [r7, #0x2]
 800112e: fb02 f303    	mul	r3, r2, r3
 8001132: 461a         	mov	r2, r3
 8001134: 2100         	movs	r1, #0x0
 8001136: f026 f9e7    	bl	0x8027508 <memset>      @ imm = #0x263ce
; 		Matrix_Init(&kf->B, kf->xhatSize, kf->uSize, (float *)kf->B_data);
 800113a: 687b         	ldr	r3, [r7, #0x4]
 800113c: f103 0070    	add.w	r0, r3, #0x70
 8001140: 687b         	ldr	r3, [r7, #0x4]
 8001142: 7b1b         	ldrb	r3, [r3, #0xc]
 8001144: 4619         	mov	r1, r3
 8001146: 687b         	ldr	r3, [r7, #0x4]
 8001148: 7b5b         	ldrb	r3, [r3, #0xd]
 800114a: 461a         	mov	r2, r3
 800114c: 687b         	ldr	r3, [r7, #0x4]
 800114e: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 8001152: f011 f953    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x112a6
; 	kf->H_data = (float *)user_malloc(sizeof_float * zSize * xhatSize);
 8001156: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8001298 <Kalman_Filter_Init+0x60c>
 8001158: 881b         	ldrh	r3, [r3]
 800115a: 461a         	mov	r2, r3
 800115c: 787b         	ldrb	r3, [r7, #0x1]
 800115e: fb02 f303    	mul	r3, r2, r3
 8001162: 78fa         	ldrb	r2, [r7, #0x3]
 8001164: fb02 f303    	mul	r3, r2, r3
 8001168: 4618         	mov	r0, r3
 800116a: f005 fbef    	bl	0x800694c <malloc>      @ imm = #0x57de
 800116e: 4603         	mov	r3, r0
 8001170: 461a         	mov	r2, r3
 8001172: 687b         	ldr	r3, [r7, #0x4]
 8001174: f8c3 210c    	str.w	r2, [r3, #0x10c]
; 	kf->HT_data = (float *)user_malloc(sizeof_float * xhatSize * zSize);
 8001178: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x8001298 <Kalman_Filter_Init+0x60c>
 800117a: 881b         	ldrh	r3, [r3]
 800117c: 461a         	mov	r2, r3
 800117e: 78fb         	ldrb	r3, [r7, #0x3]
 8001180: fb02 f303    	mul	r3, r2, r3
 8001184: 787a         	ldrb	r2, [r7, #0x1]
 8001186: fb02 f303    	mul	r3, r2, r3
 800118a: 4618         	mov	r0, r3
 800118c: f005 fbde    	bl	0x800694c <malloc>      @ imm = #0x57bc
 8001190: 4603         	mov	r3, r0
 8001192: 461a         	mov	r2, r3
 8001194: 687b         	ldr	r3, [r7, #0x4]
 8001196: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	memset(kf->H_data, 0, sizeof_float * zSize * xhatSize);
 800119a: 687b         	ldr	r3, [r7, #0x4]
 800119c: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 80011a0: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8001298 <Kalman_Filter_Init+0x60c>
 80011a2: 881b         	ldrh	r3, [r3]
 80011a4: 461a         	mov	r2, r3
 80011a6: 787b         	ldrb	r3, [r7, #0x1]
 80011a8: fb02 f303    	mul	r3, r2, r3
 80011ac: 78fa         	ldrb	r2, [r7, #0x3]
 80011ae: fb02 f303    	mul	r3, r2, r3
 80011b2: 461a         	mov	r2, r3
 80011b4: 2100         	movs	r1, #0x0
 80011b6: f026 f9a7    	bl	0x8027508 <memset>      @ imm = #0x2634e
; 	memset(kf->HT_data, 0, sizeof_float * xhatSize * zSize);
 80011ba: 687b         	ldr	r3, [r7, #0x4]
 80011bc: f8d3 0110    	ldr.w	r0, [r3, #0x110]
 80011c0: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8001298 <Kalman_Filter_Init+0x60c>
 80011c2: 881b         	ldrh	r3, [r3]
 80011c4: 461a         	mov	r2, r3
 80011c6: 78fb         	ldrb	r3, [r7, #0x3]
 80011c8: fb02 f303    	mul	r3, r2, r3
 80011cc: 787a         	ldrb	r2, [r7, #0x1]
 80011ce: fb02 f303    	mul	r3, r2, r3
 80011d2: 461a         	mov	r2, r3
 80011d4: 2100         	movs	r1, #0x0
 80011d6: f026 f997    	bl	0x8027508 <memset>      @ imm = #0x2632e
; 	Matrix_Init(&kf->H, kf->zSize, kf->xhatSize, (float *)kf->H_data);
 80011da: 687b         	ldr	r3, [r7, #0x4]
 80011dc: f103 0078    	add.w	r0, r3, #0x78
 80011e0: 687b         	ldr	r3, [r7, #0x4]
 80011e2: 7b9b         	ldrb	r3, [r3, #0xe]
 80011e4: 4619         	mov	r1, r3
 80011e6: 687b         	ldr	r3, [r7, #0x4]
 80011e8: 7b1b         	ldrb	r3, [r3, #0xc]
 80011ea: 461a         	mov	r2, r3
 80011ec: 687b         	ldr	r3, [r7, #0x4]
 80011ee: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80011f2: f011 f903    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x11206
; 	Matrix_Init(&kf->HT, kf->xhatSize, kf->zSize, (float *)kf->HT_data);
 80011f6: 687b         	ldr	r3, [r7, #0x4]
 80011f8: f103 0080    	add.w	r0, r3, #0x80
 80011fc: 687b         	ldr	r3, [r7, #0x4]
 80011fe: 7b1b         	ldrb	r3, [r3, #0xc]
 8001200: 4619         	mov	r1, r3
 8001202: 687b         	ldr	r3, [r7, #0x4]
 8001204: 7b9b         	ldrb	r3, [r3, #0xe]
 8001206: 461a         	mov	r2, r3
 8001208: 687b         	ldr	r3, [r7, #0x4]
 800120a: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 800120e: f011 f8f5    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x111ea
; 	kf->Q_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001212: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8001298 <Kalman_Filter_Init+0x60c>
 8001214: 881b         	ldrh	r3, [r3]
 8001216: 461a         	mov	r2, r3
 8001218: 78fb         	ldrb	r3, [r7, #0x3]
 800121a: fb02 f303    	mul	r3, r2, r3
 800121e: 78fa         	ldrb	r2, [r7, #0x3]
 8001220: fb02 f303    	mul	r3, r2, r3
 8001224: 4618         	mov	r0, r3
 8001226: f005 fb91    	bl	0x800694c <malloc>      @ imm = #0x5722
 800122a: 4603         	mov	r3, r0
 800122c: 461a         	mov	r2, r3
 800122e: 687b         	ldr	r3, [r7, #0x4]
 8001230: f8c3 2114    	str.w	r2, [r3, #0x114]
; 	memset(kf->Q_data, 0, sizeof_float * xhatSize * xhatSize);
 8001234: 687b         	ldr	r3, [r7, #0x4]
 8001236: f8d3 0114    	ldr.w	r0, [r3, #0x114]
 800123a: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8001298 <Kalman_Filter_Init+0x60c>
 800123c: 881b         	ldrh	r3, [r3]
 800123e: 461a         	mov	r2, r3
 8001240: 78fb         	ldrb	r3, [r7, #0x3]
 8001242: fb02 f303    	mul	r3, r2, r3
 8001246: 78fa         	ldrb	r2, [r7, #0x3]
 8001248: fb02 f303    	mul	r3, r2, r3
 800124c: 461a         	mov	r2, r3
 800124e: 2100         	movs	r1, #0x0
 8001250: f026 f95a    	bl	0x8027508 <memset>      @ imm = #0x262b4
; 	Matrix_Init(&kf->Q, kf->xhatSize, kf->xhatSize, (float *)kf->Q_data);
 8001254: 687b         	ldr	r3, [r7, #0x4]
 8001256: f103 0088    	add.w	r0, r3, #0x88
 800125a: 687b         	ldr	r3, [r7, #0x4]
 800125c: 7b1b         	ldrb	r3, [r3, #0xc]
 800125e: 4619         	mov	r1, r3
 8001260: 687b         	ldr	r3, [r7, #0x4]
 8001262: 7b1b         	ldrb	r3, [r3, #0xc]
 8001264: 461a         	mov	r2, r3
 8001266: 687b         	ldr	r3, [r7, #0x4]
 8001268: f8d3 3114    	ldr.w	r3, [r3, #0x114]
 800126c: f011 f8c6    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x1118c
; 	kf->R_data = (float *)user_malloc(sizeof_float * zSize * zSize);
 8001270: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8001298 <Kalman_Filter_Init+0x60c>
 8001272: 881b         	ldrh	r3, [r3]
 8001274: 461a         	mov	r2, r3
 8001276: 787b         	ldrb	r3, [r7, #0x1]
 8001278: fb02 f303    	mul	r3, r2, r3
 800127c: 787a         	ldrb	r2, [r7, #0x1]
 800127e: fb02 f303    	mul	r3, r2, r3
 8001282: 4618         	mov	r0, r3
 8001284: f005 fb62    	bl	0x800694c <malloc>      @ imm = #0x56c4
 8001288: 4603         	mov	r3, r0
 800128a: 461a         	mov	r2, r3
 800128c: 687b         	ldr	r3, [r7, #0x4]
 800128e: f8c3 2118    	str.w	r2, [r3, #0x118]
; 	memset(kf->R_data, 0, sizeof_float * zSize * zSize);
 8001292: 687b         	ldr	r3, [r7, #0x4]
 8001294: e002         	b	0x800129c <Kalman_Filter_Init+0x610> @ imm = #0x4
 8001296: bf00         	nop

08001298 <$d>:
 8001298: 00 33 00 20  	.word	0x20003300

0800129c <$t>:
 800129c: f8d3 0118    	ldr.w	r0, [r3, #0x118]
 80012a0: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x8001498 <Kalman_Filter_Init+0x80c>
 80012a2: 881b         	ldrh	r3, [r3]
 80012a4: 461a         	mov	r2, r3
 80012a6: 787b         	ldrb	r3, [r7, #0x1]
 80012a8: fb02 f303    	mul	r3, r2, r3
 80012ac: 787a         	ldrb	r2, [r7, #0x1]
 80012ae: fb02 f303    	mul	r3, r2, r3
 80012b2: 461a         	mov	r2, r3
 80012b4: 2100         	movs	r1, #0x0
 80012b6: f026 f927    	bl	0x8027508 <memset>      @ imm = #0x2624e
; 	Matrix_Init(&kf->R, kf->zSize, kf->zSize, (float *)kf->R_data);
 80012ba: 687b         	ldr	r3, [r7, #0x4]
 80012bc: f103 0090    	add.w	r0, r3, #0x90
 80012c0: 687b         	ldr	r3, [r7, #0x4]
 80012c2: 7b9b         	ldrb	r3, [r3, #0xe]
 80012c4: 4619         	mov	r1, r3
 80012c6: 687b         	ldr	r3, [r7, #0x4]
 80012c8: 7b9b         	ldrb	r3, [r3, #0xe]
 80012ca: 461a         	mov	r2, r3
 80012cc: 687b         	ldr	r3, [r7, #0x4]
 80012ce: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 80012d2: f011 f893    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x11126
; 	kf->K_data = (float *)user_malloc(sizeof_float * xhatSize * zSize);
 80012d6: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x8001498 <Kalman_Filter_Init+0x80c>
 80012d8: 881b         	ldrh	r3, [r3]
 80012da: 461a         	mov	r2, r3
 80012dc: 78fb         	ldrb	r3, [r7, #0x3]
 80012de: fb02 f303    	mul	r3, r2, r3
 80012e2: 787a         	ldrb	r2, [r7, #0x1]
 80012e4: fb02 f303    	mul	r3, r2, r3
 80012e8: 4618         	mov	r0, r3
 80012ea: f005 fb2f    	bl	0x800694c <malloc>      @ imm = #0x565e
 80012ee: 4603         	mov	r3, r0
 80012f0: 461a         	mov	r2, r3
 80012f2: 687b         	ldr	r3, [r7, #0x4]
 80012f4: f8c3 211c    	str.w	r2, [r3, #0x11c]
; 	memset(kf->K_data, 0, sizeof_float * xhatSize * zSize);
 80012f8: 687b         	ldr	r3, [r7, #0x4]
 80012fa: f8d3 011c    	ldr.w	r0, [r3, #0x11c]
 80012fe: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8001498 <Kalman_Filter_Init+0x80c>
 8001300: 881b         	ldrh	r3, [r3]
 8001302: 461a         	mov	r2, r3
 8001304: 78fb         	ldrb	r3, [r7, #0x3]
 8001306: fb02 f303    	mul	r3, r2, r3
 800130a: 787a         	ldrb	r2, [r7, #0x1]
 800130c: fb02 f303    	mul	r3, r2, r3
 8001310: 461a         	mov	r2, r3
 8001312: 2100         	movs	r1, #0x0
 8001314: f026 f8f8    	bl	0x8027508 <memset>      @ imm = #0x261f0
; 	Matrix_Init(&kf->K, kf->xhatSize, kf->zSize, (float *)kf->K_data);
 8001318: 687b         	ldr	r3, [r7, #0x4]
 800131a: f103 0098    	add.w	r0, r3, #0x98
 800131e: 687b         	ldr	r3, [r7, #0x4]
 8001320: 7b1b         	ldrb	r3, [r3, #0xc]
 8001322: 4619         	mov	r1, r3
 8001324: 687b         	ldr	r3, [r7, #0x4]
 8001326: 7b9b         	ldrb	r3, [r3, #0xe]
 8001328: 461a         	mov	r2, r3
 800132a: 687b         	ldr	r3, [r7, #0x4]
 800132c: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8001330: f011 f864    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x110c8
; 	kf->S_data = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 8001334: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8001498 <Kalman_Filter_Init+0x80c>
 8001336: 881b         	ldrh	r3, [r3]
 8001338: 461a         	mov	r2, r3
 800133a: 687b         	ldr	r3, [r7, #0x4]
 800133c: 7b1b         	ldrb	r3, [r3, #0xc]
 800133e: fb02 f303    	mul	r3, r2, r3
 8001342: 687a         	ldr	r2, [r7, #0x4]
 8001344: 7b12         	ldrb	r2, [r2, #0xc]
 8001346: fb02 f303    	mul	r3, r2, r3
 800134a: 4618         	mov	r0, r3
 800134c: f005 fafe    	bl	0x800694c <malloc>      @ imm = #0x55fc
 8001350: 4603         	mov	r3, r0
 8001352: 461a         	mov	r2, r3
 8001354: 687b         	ldr	r3, [r7, #0x4]
 8001356: f8c3 2120    	str.w	r2, [r3, #0x120]
; 	kf->temp_matrix_data = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 800135a: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8001498 <Kalman_Filter_Init+0x80c>
 800135c: 881b         	ldrh	r3, [r3]
 800135e: 461a         	mov	r2, r3
 8001360: 687b         	ldr	r3, [r7, #0x4]
 8001362: 7b1b         	ldrb	r3, [r3, #0xc]
 8001364: fb02 f303    	mul	r3, r2, r3
 8001368: 687a         	ldr	r2, [r7, #0x4]
 800136a: 7b12         	ldrb	r2, [r2, #0xc]
 800136c: fb02 f303    	mul	r3, r2, r3
 8001370: 4618         	mov	r0, r3
 8001372: f005 faeb    	bl	0x800694c <malloc>      @ imm = #0x55d6
 8001376: 4603         	mov	r3, r0
 8001378: 461a         	mov	r2, r3
 800137a: 687b         	ldr	r3, [r7, #0x4]
 800137c: f8c3 2124    	str.w	r2, [r3, #0x124]
; 	kf->temp_matrix_data1 = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 8001380: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8001498 <Kalman_Filter_Init+0x80c>
 8001382: 881b         	ldrh	r3, [r3]
 8001384: 461a         	mov	r2, r3
 8001386: 687b         	ldr	r3, [r7, #0x4]
 8001388: 7b1b         	ldrb	r3, [r3, #0xc]
 800138a: fb02 f303    	mul	r3, r2, r3
 800138e: 687a         	ldr	r2, [r7, #0x4]
 8001390: 7b12         	ldrb	r2, [r2, #0xc]
 8001392: fb02 f303    	mul	r3, r2, r3
 8001396: 4618         	mov	r0, r3
 8001398: f005 fad8    	bl	0x800694c <malloc>      @ imm = #0x55b0
 800139c: 4603         	mov	r3, r0
 800139e: 461a         	mov	r2, r3
 80013a0: 687b         	ldr	r3, [r7, #0x4]
 80013a2: f8c3 2128    	str.w	r2, [r3, #0x128]
; 	kf->temp_vector_data = (float *)user_malloc(sizeof_float * kf->xhatSize);
 80013a6: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8001498 <Kalman_Filter_Init+0x80c>
 80013a8: 881b         	ldrh	r3, [r3]
 80013aa: 461a         	mov	r2, r3
 80013ac: 687b         	ldr	r3, [r7, #0x4]
 80013ae: 7b1b         	ldrb	r3, [r3, #0xc]
 80013b0: fb02 f303    	mul	r3, r2, r3
 80013b4: 4618         	mov	r0, r3
 80013b6: f005 fac9    	bl	0x800694c <malloc>      @ imm = #0x5592
 80013ba: 4603         	mov	r3, r0
 80013bc: 461a         	mov	r2, r3
 80013be: 687b         	ldr	r3, [r7, #0x4]
 80013c0: f8c3 212c    	str.w	r2, [r3, #0x12c]
; 	kf->temp_vector_data1 = (float *)user_malloc(sizeof_float * kf->xhatSize);
 80013c4: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8001498 <Kalman_Filter_Init+0x80c>
 80013c6: 881b         	ldrh	r3, [r3]
 80013c8: 461a         	mov	r2, r3
 80013ca: 687b         	ldr	r3, [r7, #0x4]
 80013cc: 7b1b         	ldrb	r3, [r3, #0xc]
 80013ce: fb02 f303    	mul	r3, r2, r3
 80013d2: 4618         	mov	r0, r3
 80013d4: f005 faba    	bl	0x800694c <malloc>      @ imm = #0x5574
 80013d8: 4603         	mov	r3, r0
 80013da: 461a         	mov	r2, r3
 80013dc: 687b         	ldr	r3, [r7, #0x4]
 80013de: f8c3 2130    	str.w	r2, [r3, #0x130]
; 	Matrix_Init(&kf->S, kf->xhatSize, kf->xhatSize, (float *)kf->S_data);
 80013e2: 687b         	ldr	r3, [r7, #0x4]
 80013e4: f103 00a0    	add.w	r0, r3, #0xa0
 80013e8: 687b         	ldr	r3, [r7, #0x4]
 80013ea: 7b1b         	ldrb	r3, [r3, #0xc]
 80013ec: 4619         	mov	r1, r3
 80013ee: 687b         	ldr	r3, [r7, #0x4]
 80013f0: 7b1b         	ldrb	r3, [r3, #0xc]
 80013f2: 461a         	mov	r2, r3
 80013f4: 687b         	ldr	r3, [r7, #0x4]
 80013f6: f8d3 3120    	ldr.w	r3, [r3, #0x120]
 80013fa: f010 ffff    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x10ffe
; 	Matrix_Init(&kf->temp_matrix, kf->xhatSize, kf->xhatSize, (float *)kf->temp_matrix_data);
 80013fe: 687b         	ldr	r3, [r7, #0x4]
 8001400: f103 00a8    	add.w	r0, r3, #0xa8
 8001404: 687b         	ldr	r3, [r7, #0x4]
 8001406: 7b1b         	ldrb	r3, [r3, #0xc]
 8001408: 4619         	mov	r1, r3
 800140a: 687b         	ldr	r3, [r7, #0x4]
 800140c: 7b1b         	ldrb	r3, [r3, #0xc]
 800140e: 461a         	mov	r2, r3
 8001410: 687b         	ldr	r3, [r7, #0x4]
 8001412: f8d3 3124    	ldr.w	r3, [r3, #0x124]
 8001416: f010 fff1    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x10fe2
; 	Matrix_Init(&kf->temp_matrix1, kf->xhatSize, kf->xhatSize, (float *)kf->temp_matrix_data1);
 800141a: 687b         	ldr	r3, [r7, #0x4]
 800141c: f103 00b0    	add.w	r0, r3, #0xb0
 8001420: 687b         	ldr	r3, [r7, #0x4]
 8001422: 7b1b         	ldrb	r3, [r3, #0xc]
 8001424: 4619         	mov	r1, r3
 8001426: 687b         	ldr	r3, [r7, #0x4]
 8001428: 7b1b         	ldrb	r3, [r3, #0xc]
 800142a: 461a         	mov	r2, r3
 800142c: 687b         	ldr	r3, [r7, #0x4]
 800142e: f8d3 3128    	ldr.w	r3, [r3, #0x128]
 8001432: f010 ffe3    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x10fc6
; 	Matrix_Init(&kf->temp_vector, kf->xhatSize, 1, (float *)kf->temp_vector_data);
 8001436: 687b         	ldr	r3, [r7, #0x4]
 8001438: f103 00b8    	add.w	r0, r3, #0xb8
 800143c: 687b         	ldr	r3, [r7, #0x4]
 800143e: 7b1b         	ldrb	r3, [r3, #0xc]
 8001440: 4619         	mov	r1, r3
 8001442: 687b         	ldr	r3, [r7, #0x4]
 8001444: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 8001448: 2201         	movs	r2, #0x1
 800144a: f010 ffd7    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x10fae
; 	Matrix_Init(&kf->temp_vector1, kf->xhatSize, 1, (float *)kf->temp_vector_data1);
 800144e: 687b         	ldr	r3, [r7, #0x4]
 8001450: f103 00c0    	add.w	r0, r3, #0xc0
 8001454: 687b         	ldr	r3, [r7, #0x4]
 8001456: 7b1b         	ldrb	r3, [r3, #0xc]
 8001458: 4619         	mov	r1, r3
 800145a: 687b         	ldr	r3, [r7, #0x4]
 800145c: f8d3 3130    	ldr.w	r3, [r3, #0x130]
 8001460: 2201         	movs	r2, #0x1
 8001462: f010 ffcb    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x10f96
; 	kf->SkipEq1 = 0;
 8001466: 687b         	ldr	r3, [r7, #0x4]
 8001468: 2200         	movs	r2, #0x0
 800146a: f883 2028    	strb.w	r2, [r3, #0x28]
; 	kf->SkipEq2 = 0;
 800146e: 687b         	ldr	r3, [r7, #0x4]
 8001470: 2200         	movs	r2, #0x0
 8001472: f883 2029    	strb.w	r2, [r3, #0x29]
; 	kf->SkipEq3 = 0;
 8001476: 687b         	ldr	r3, [r7, #0x4]
 8001478: 2200         	movs	r2, #0x0
 800147a: f883 202a    	strb.w	r2, [r3, #0x2a]
; 	kf->SkipEq4 = 0;
 800147e: 687b         	ldr	r3, [r7, #0x4]
 8001480: 2200         	movs	r2, #0x0
 8001482: f883 202b    	strb.w	r2, [r3, #0x2b]
; 	kf->SkipEq5 = 0;
 8001486: 687b         	ldr	r3, [r7, #0x4]
 8001488: 2200         	movs	r2, #0x0
 800148a: f883 202c    	strb.w	r2, [r3, #0x2c]
; }
 800148e: bf00         	nop
 8001490: 3708         	adds	r7, #0x8
 8001492: 46bd         	mov	sp, r7
 8001494: bd80         	pop	{r7, pc}
 8001496: bf00         	nop

08001498 <$d>:
 8001498: 00 33 00 20  	.word	0x20003300

0800149c <Kalman_Filter_Measure>:
; {
 800149c: b580         	push	{r7, lr}
 800149e: b082         	sub	sp, #0x8
 80014a0: af00         	add	r7, sp, #0x0
 80014a2: 6078         	str	r0, [r7, #0x4]
; 	if (kf->UseAutoAdjustment != 0) {
 80014a4: 687b         	ldr	r3, [r7, #0x4]
 80014a6: 7bdb         	ldrb	r3, [r3, #0xf]
 80014a8: 2b00         	cmp	r3, #0x0
 80014aa: d003         	beq	0x80014b4 <Kalman_Filter_Measure+0x18> @ imm = #0x6
; 		H_K_R_Adjustment(kf);
 80014ac: 6878         	ldr	r0, [r7, #0x4]
 80014ae: f000 f975    	bl	0x800179c <H_K_R_Adjustment> @ imm = #0x2ea
 80014b2: e01b         	b	0x80014ec <Kalman_Filter_Measure+0x50> @ imm = #0x36
; 		memcpy(kf->z_data, kf->MeasuredVector, sizeof_float * kf->zSize);
 80014b4: 687b         	ldr	r3, [r7, #0x4]
 80014b6: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 80014ba: 687b         	ldr	r3, [r7, #0x4]
 80014bc: 6859         	ldr	r1, [r3, #0x4]
 80014be: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8001514 <Kalman_Filter_Measure+0x78>
 80014c0: 881b         	ldrh	r3, [r3]
 80014c2: 461a         	mov	r2, r3
 80014c4: 687b         	ldr	r3, [r7, #0x4]
 80014c6: 7b9b         	ldrb	r3, [r3, #0xe]
 80014c8: fb02 f303    	mul	r3, r2, r3
 80014cc: 461a         	mov	r2, r3
 80014ce: f026 f80d    	bl	0x80274ec <memcpy>      @ imm = #0x2601a
; 		memset(kf->MeasuredVector, 0, sizeof_float * kf->zSize);
 80014d2: 687b         	ldr	r3, [r7, #0x4]
 80014d4: 6858         	ldr	r0, [r3, #0x4]
 80014d6: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8001514 <Kalman_Filter_Measure+0x78>
 80014d8: 881b         	ldrh	r3, [r3]
 80014da: 461a         	mov	r2, r3
 80014dc: 687b         	ldr	r3, [r7, #0x4]
 80014de: 7b9b         	ldrb	r3, [r3, #0xe]
 80014e0: fb02 f303    	mul	r3, r2, r3
 80014e4: 461a         	mov	r2, r3
 80014e6: 2100         	movs	r1, #0x0
 80014e8: f026 f80e    	bl	0x8027508 <memset>      @ imm = #0x2601c
; 	memcpy(kf->u_data, kf->ControlVector, sizeof_float * kf->uSize);
 80014ec: 687b         	ldr	r3, [r7, #0x4]
 80014ee: f8d3 00f0    	ldr.w	r0, [r3, #0xf0]
 80014f2: 687b         	ldr	r3, [r7, #0x4]
 80014f4: 6899         	ldr	r1, [r3, #0x8]
 80014f6: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8001514 <Kalman_Filter_Measure+0x78>
 80014f8: 881b         	ldrh	r3, [r3]
 80014fa: 461a         	mov	r2, r3
 80014fc: 687b         	ldr	r3, [r7, #0x4]
 80014fe: 7b5b         	ldrb	r3, [r3, #0xd]
 8001500: fb02 f303    	mul	r3, r2, r3
 8001504: 461a         	mov	r2, r3
 8001506: f025 fff1    	bl	0x80274ec <memcpy>      @ imm = #0x25fe2
; }
 800150a: bf00         	nop
 800150c: 3708         	adds	r7, #0x8
 800150e: 46bd         	mov	sp, r7
 8001510: bd80         	pop	{r7, pc}
 8001512: bf00         	nop

08001514 <$d>:
 8001514: 00 33 00 20  	.word	0x20003300

08001518 <Kalman_Filter_Update>:
; {
 8001518: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800151c: b08a         	sub	sp, #0x28
 800151e: af00         	add	r7, sp, #0x0
 8001520: 6178         	str	r0, [r7, #0x14]
; 	QEKF_INS_t *QEKF_INS = CONTAINER_OF(kf, QEKF_INS_t, IMU_QuaternionEKF);
 8001522: 697b         	ldr	r3, [r7, #0x14]
 8001524: 3b04         	subs	r3, #0x4
 8001526: 623b         	str	r3, [r7, #0x20]
; 	Kalman_Filter_Measure(kf);
 8001528: 6978         	ldr	r0, [r7, #0x14]
 800152a: f7ff ffb7    	bl	0x800149c <Kalman_Filter_Measure> @ imm = #-0x92
; 	if (kf->User_Func0_f != NULL) {
 800152e: 697b         	ldr	r3, [r7, #0x14]
 8001530: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
 8001534: 2b00         	cmp	r3, #0x0
 8001536: d004         	beq	0x8001542 <Kalman_Filter_Update+0x2a> @ imm = #0x8
; 		kf->User_Func0_f(kf);
 8001538: 697b         	ldr	r3, [r7, #0x14]
 800153a: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
 800153e: 6978         	ldr	r0, [r7, #0x14]
 8001540: 4798         	blx	r3
; 	Kalman_Filter_xhatMinusUpdate(kf);
 8001542: 6978         	ldr	r0, [r7, #0x14]
 8001544: f018 fd56    	bl	0x8019ff4 <Kalman_Filter_xhatMinusUpdate> @ imm = #0x18aac
; 	if (kf->User_Func1_f != NULL) {
 8001548: 697b         	ldr	r3, [r7, #0x14]
 800154a: f8d3 30d0    	ldr.w	r3, [r3, #0xd0]
 800154e: 2b00         	cmp	r3, #0x0
 8001550: d004         	beq	0x800155c <Kalman_Filter_Update+0x44> @ imm = #0x8
; 		kf->User_Func1_f(kf);
 8001552: 697b         	ldr	r3, [r7, #0x14]
 8001554: f8d3 30d0    	ldr.w	r3, [r3, #0xd0]
 8001558: 6978         	ldr	r0, [r7, #0x14]
 800155a: 4798         	blx	r3
; 	Kalman_Filter_PminusUpdate(kf);
 800155c: 6978         	ldr	r0, [r7, #0x14]
 800155e: f018 fdaf    	bl	0x801a0c0 <Kalman_Filter_PminusUpdate> @ imm = #0x18b5e
; 	if (kf->User_Func2_f != NULL) {
 8001562: 697b         	ldr	r3, [r7, #0x14]
 8001564: f8d3 30d4    	ldr.w	r3, [r3, #0xd4]
 8001568: 2b00         	cmp	r3, #0x0
 800156a: d004         	beq	0x8001576 <Kalman_Filter_Update+0x5e> @ imm = #0x8
; 		kf->User_Func2_f(kf);
 800156c: 697b         	ldr	r3, [r7, #0x14]
 800156e: f8d3 30d4    	ldr.w	r3, [r3, #0xd4]
 8001572: 6978         	ldr	r0, [r7, #0x14]
 8001574: 4798         	blx	r3
; 	if (kf->MeasurementValidNum != 0 || kf->UseAutoAdjustment == 0) {
 8001576: 697b         	ldr	r3, [r7, #0x14]
 8001578: 7c1b         	ldrb	r3, [r3, #0x10]
 800157a: 2b00         	cmp	r3, #0x0
 800157c: d103         	bne	0x8001586 <Kalman_Filter_Update+0x6e> @ imm = #0x6
 800157e: 697b         	ldr	r3, [r7, #0x14]
 8001580: 7bdb         	ldrb	r3, [r3, #0xf]
 8001582: 2b00         	cmp	r3, #0x0
 8001584: d176         	bne	0x8001674 <Kalman_Filter_Update+0x15c> @ imm = #0xec
; 		Kalman_Filter_SetK(kf);
 8001586: 6978         	ldr	r0, [r7, #0x14]
 8001588: f018 fdf1    	bl	0x801a16e <Kalman_Filter_SetK> @ imm = #0x18be2
; 		int start_us = k_cyc_to_us_near32(k_cycle_get_32());
 800158c: f018 fc6c    	bl	0x8019e68 <k_cycle_get_32> @ imm = #0x188d8
 8001590: 4603         	mov	r3, r0
 8001592: f113 0f55    	cmn.w	r3, #0x55
 8001596: d809         	bhi	0x80015ac <Kalman_Filter_Update+0x94> @ imm = #0x12
 8001598: f018 fc66    	bl	0x8019e68 <k_cycle_get_32> @ imm = #0x188cc
 800159c: 4603         	mov	r3, r0
 800159e: 3354         	adds	r3, #0x54
 80015a0: 08db         	lsrs	r3, r3, #0x3
 80015a2: 4a7c         	ldr	r2, [pc, #0x1f0]        @ 0x8001794 <Kalman_Filter_Update+0x27c>
 80015a4: fba2 2303    	umull	r2, r3, r2, r3
 80015a8: 085b         	lsrs	r3, r3, #0x1
 80015aa: e016         	b	0x80015da <Kalman_Filter_Update+0xc2> @ imm = #0x2c
 80015ac: f018 fc5c    	bl	0x8019e68 <k_cycle_get_32> @ imm = #0x188b8
 80015b0: 4603         	mov	r3, r0
 80015b2: 2200         	movs	r2, #0x0
 80015b4: 4698         	mov	r8, r3
 80015b6: 4691         	mov	r9, r2
 80015b8: f118 0354    	adds.w	r3, r8, #0x54
 80015bc: 60bb         	str	r3, [r7, #0x8]
 80015be: f149 0300    	adc	r3, r9, #0x0
 80015c2: 60fb         	str	r3, [r7, #0xc]
 80015c4: f04f 02a8    	mov.w	r2, #0xa8
 80015c8: f04f 0300    	mov.w	r3, #0x0
 80015cc: e9d7 0102    	ldrd	r0, r1, [r7, #8]
 80015d0: f7ff f836    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xf94
 80015d4: 4602         	mov	r2, r0
 80015d6: 460b         	mov	r3, r1
 80015d8: 4613         	mov	r3, r2
 80015da: 61fb         	str	r3, [r7, #0x1c]
; 		if (kf->User_Func3_f != NULL) {
 80015dc: 697b         	ldr	r3, [r7, #0x14]
 80015de: f8d3 30d8    	ldr.w	r3, [r3, #0xd8]
 80015e2: 2b00         	cmp	r3, #0x0
 80015e4: d004         	beq	0x80015f0 <Kalman_Filter_Update+0xd8> @ imm = #0x8
; 			kf->User_Func3_f(kf);
 80015e6: 697b         	ldr	r3, [r7, #0x14]
 80015e8: f8d3 30d8    	ldr.w	r3, [r3, #0xd8]
 80015ec: 6978         	ldr	r0, [r7, #0x14]
 80015ee: 4798         	blx	r3
; 		int end_us = k_cyc_to_us_near32(k_cycle_get_32());
 80015f0: f018 fc3a    	bl	0x8019e68 <k_cycle_get_32> @ imm = #0x18874
 80015f4: 4603         	mov	r3, r0
 80015f6: f113 0f55    	cmn.w	r3, #0x55
 80015fa: d809         	bhi	0x8001610 <Kalman_Filter_Update+0xf8> @ imm = #0x12
 80015fc: f018 fc34    	bl	0x8019e68 <k_cycle_get_32> @ imm = #0x18868
 8001600: 4603         	mov	r3, r0
 8001602: 3354         	adds	r3, #0x54
 8001604: 08db         	lsrs	r3, r3, #0x3
 8001606: 4a63         	ldr	r2, [pc, #0x18c]        @ 0x8001794 <Kalman_Filter_Update+0x27c>
 8001608: fba2 2303    	umull	r2, r3, r2, r3
 800160c: 085b         	lsrs	r3, r3, #0x1
 800160e: e014         	b	0x800163a <Kalman_Filter_Update+0x122> @ imm = #0x28
 8001610: f018 fc2a    	bl	0x8019e68 <k_cycle_get_32> @ imm = #0x18854
 8001614: 4603         	mov	r3, r0
 8001616: 2200         	movs	r2, #0x0
 8001618: 461c         	mov	r4, r3
 800161a: 4615         	mov	r5, r2
 800161c: f114 0a54    	adds.w	r10, r4, #0x54
 8001620: f145 0b00    	adc	r11, r5, #0x0
 8001624: f04f 02a8    	mov.w	r2, #0xa8
 8001628: f04f 0300    	mov.w	r3, #0x0
 800162c: 4650         	mov	r0, r10
 800162e: 4659         	mov	r1, r11
 8001630: f7ff f806    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xff4
 8001634: 4602         	mov	r2, r0
 8001636: 460b         	mov	r3, r1
 8001638: 4613         	mov	r3, r2
 800163a: 61bb         	str	r3, [r7, #0x18]
; 		QEKF_INS->UpdateTime = end_us - start_us;
 800163c: 69ba         	ldr	r2, [r7, #0x18]
 800163e: 69fb         	ldr	r3, [r7, #0x1c]
 8001640: 1ad3         	subs	r3, r2, r3
 8001642: 17da         	asrs	r2, r3, #0x1f
 8001644: 603b         	str	r3, [r7]
 8001646: 607a         	str	r2, [r7, #0x4]
 8001648: 6a3b         	ldr	r3, [r7, #0x20]
 800164a: e9d7 1200    	ldrd	r1, r2, [r7]
 800164e: e9c3 1278    	strd	r1, r2, [r3, #480]
; 		Kalman_Filter_xhatUpdate(kf);
 8001652: 6978         	ldr	r0, [r7, #0x14]
 8001654: f018 fe35    	bl	0x801a2c2 <Kalman_Filter_xhatUpdate> @ imm = #0x18c6a
; 		if (kf->User_Func4_f != NULL) {
 8001658: 697b         	ldr	r3, [r7, #0x14]
 800165a: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 800165e: 2b00         	cmp	r3, #0x0
 8001660: d004         	beq	0x800166c <Kalman_Filter_Update+0x154> @ imm = #0x8
; 			kf->User_Func4_f(kf);
 8001662: 697b         	ldr	r3, [r7, #0x14]
 8001664: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8001668: 6978         	ldr	r0, [r7, #0x14]
 800166a: 4798         	blx	r3
; 		Kalman_Filter_P_Update(kf);
 800166c: 6978         	ldr	r0, [r7, #0x14]
 800166e: f018 fe93    	bl	0x801a398 <Kalman_Filter_P_Update> @ imm = #0x18d26
; 	if (kf->MeasurementValidNum != 0 || kf->UseAutoAdjustment == 0) {
 8001672: e023         	b	0x80016bc <Kalman_Filter_Update+0x1a4> @ imm = #0x46
; 		memcpy(kf->xhat_data, kf->xhatminus_data, sizeof_float * kf->xhatSize);
 8001674: 697b         	ldr	r3, [r7, #0x14]
 8001676: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 800167a: 697b         	ldr	r3, [r7, #0x14]
 800167c: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 8001680: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8001798 <Kalman_Filter_Update+0x280>
 8001682: 881b         	ldrh	r3, [r3]
 8001684: 461a         	mov	r2, r3
 8001686: 697b         	ldr	r3, [r7, #0x14]
 8001688: 7b1b         	ldrb	r3, [r3, #0xc]
 800168a: fb02 f303    	mul	r3, r2, r3
 800168e: 461a         	mov	r2, r3
 8001690: f025 ff2c    	bl	0x80274ec <memcpy>      @ imm = #0x25e58
; 		memcpy(kf->P_data, kf->Pminus_data, sizeof_float * kf->xhatSize * kf->xhatSize);
 8001694: 697b         	ldr	r3, [r7, #0x14]
 8001696: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 800169a: 697b         	ldr	r3, [r7, #0x14]
 800169c: f8d3 10fc    	ldr.w	r1, [r3, #0xfc]
 80016a0: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8001798 <Kalman_Filter_Update+0x280>
 80016a2: 881b         	ldrh	r3, [r3]
 80016a4: 461a         	mov	r2, r3
 80016a6: 697b         	ldr	r3, [r7, #0x14]
 80016a8: 7b1b         	ldrb	r3, [r3, #0xc]
 80016aa: fb02 f303    	mul	r3, r2, r3
 80016ae: 697a         	ldr	r2, [r7, #0x14]
 80016b0: 7b12         	ldrb	r2, [r2, #0xc]
 80016b2: fb02 f303    	mul	r3, r2, r3
 80016b6: 461a         	mov	r2, r3
 80016b8: f025 ff18    	bl	0x80274ec <memcpy>      @ imm = #0x25e30
; 	if (kf->User_Func5_f != NULL) {
 80016bc: 697b         	ldr	r3, [r7, #0x14]
 80016be: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 80016c2: 2b00         	cmp	r3, #0x0
 80016c4: d004         	beq	0x80016d0 <Kalman_Filter_Update+0x1b8> @ imm = #0x8
; 		kf->User_Func5_f(kf);
 80016c6: 697b         	ldr	r3, [r7, #0x14]
 80016c8: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 80016cc: 6978         	ldr	r0, [r7, #0x14]
 80016ce: 4798         	blx	r3
; 	for (uint8_t i = 0; i < kf->xhatSize; ++i) {
 80016d0: 2300         	movs	r3, #0x0
 80016d2: f887 3027    	strb.w	r3, [r7, #0x27]
 80016d6: e037         	b	0x8001748 <Kalman_Filter_Update+0x230> @ imm = #0x6e
; 		if (kf->P_data[i * kf->xhatSize + i] < kf->StateMinVariance[i]) {
 80016d8: 697b         	ldr	r3, [r7, #0x14]
 80016da: f8d3 20f8    	ldr.w	r2, [r3, #0xf8]
 80016de: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80016e2: 6979         	ldr	r1, [r7, #0x14]
 80016e4: 7b09         	ldrb	r1, [r1, #0xc]
 80016e6: fb03 f101    	mul	r1, r3, r1
 80016ea: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80016ee: 440b         	add	r3, r1
 80016f0: 009b         	lsls	r3, r3, #0x2
 80016f2: 4413         	add	r3, r2
 80016f4: ed93 7a00    	vldr	s14, [r3]
 80016f8: 697b         	ldr	r3, [r7, #0x14]
 80016fa: 6a1a         	ldr	r2, [r3, #0x20]
 80016fc: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001700: 009b         	lsls	r3, r3, #0x2
 8001702: 4413         	add	r3, r2
 8001704: edd3 7a00    	vldr	s15, [r3]
 8001708: eeb4 7ae7    	vcmpe.f32	s14, s15
 800170c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8001710: d515         	bpl	0x800173e <Kalman_Filter_Update+0x226> @ imm = #0x2a
; 			kf->P_data[i * kf->xhatSize + i] = kf->StateMinVariance[i];
 8001712: 697b         	ldr	r3, [r7, #0x14]
 8001714: 6a1a         	ldr	r2, [r3, #0x20]
 8001716: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800171a: 009b         	lsls	r3, r3, #0x2
 800171c: 441a         	add	r2, r3
 800171e: 697b         	ldr	r3, [r7, #0x14]
 8001720: f8d3 10f8    	ldr.w	r1, [r3, #0xf8]
 8001724: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001728: 6978         	ldr	r0, [r7, #0x14]
 800172a: 7b00         	ldrb	r0, [r0, #0xc]
 800172c: fb03 f000    	mul	r0, r3, r0
 8001730: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001734: 4403         	add	r3, r0
 8001736: 009b         	lsls	r3, r3, #0x2
 8001738: 440b         	add	r3, r1
 800173a: 6812         	ldr	r2, [r2]
 800173c: 601a         	str	r2, [r3]
; 	for (uint8_t i = 0; i < kf->xhatSize; ++i) {
 800173e: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001742: 3301         	adds	r3, #0x1
 8001744: f887 3027    	strb.w	r3, [r7, #0x27]
 8001748: 697b         	ldr	r3, [r7, #0x14]
 800174a: 7b1b         	ldrb	r3, [r3, #0xc]
 800174c: f897 2027    	ldrb.w	r2, [r7, #0x27]
 8001750: 429a         	cmp	r2, r3
 8001752: d3c1         	blo	0x80016d8 <Kalman_Filter_Update+0x1c0> @ imm = #-0x7e
; 	memcpy(kf->FilteredValue, kf->xhat_data, sizeof_float * kf->xhatSize);
 8001754: 697b         	ldr	r3, [r7, #0x14]
 8001756: 6818         	ldr	r0, [r3]
 8001758: 697b         	ldr	r3, [r7, #0x14]
 800175a: f8d3 10e8    	ldr.w	r1, [r3, #0xe8]
 800175e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8001798 <Kalman_Filter_Update+0x280>
 8001760: 881b         	ldrh	r3, [r3]
 8001762: 461a         	mov	r2, r3
 8001764: 697b         	ldr	r3, [r7, #0x14]
 8001766: 7b1b         	ldrb	r3, [r3, #0xc]
 8001768: fb02 f303    	mul	r3, r2, r3
 800176c: 461a         	mov	r2, r3
 800176e: f025 febd    	bl	0x80274ec <memcpy>      @ imm = #0x25d7a
; 	if (kf->User_Func6_f != NULL) {
 8001772: 697b         	ldr	r3, [r7, #0x14]
 8001774: f8d3 30e4    	ldr.w	r3, [r3, #0xe4]
 8001778: 2b00         	cmp	r3, #0x0
 800177a: d004         	beq	0x8001786 <Kalman_Filter_Update+0x26e> @ imm = #0x8
; 		kf->User_Func6_f(kf);
 800177c: 697b         	ldr	r3, [r7, #0x14]
 800177e: f8d3 30e4    	ldr.w	r3, [r3, #0xe4]
 8001782: 6978         	ldr	r0, [r7, #0x14]
 8001784: 4798         	blx	r3
; 	return kf->FilteredValue;
 8001786: 697b         	ldr	r3, [r7, #0x14]
 8001788: 681b         	ldr	r3, [r3]
; }
 800178a: 4618         	mov	r0, r3
 800178c: 3728         	adds	r7, #0x28
 800178e: 46bd         	mov	sp, r7
 8001790: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08001794 <$d>:
 8001794: 19 86 61 18  	.word	0x18618619
 8001798: 00 33 00 20  	.word	0x20003300

0800179c <H_K_R_Adjustment>:
; {
 800179c: b590         	push	{r4, r7, lr}
 800179e: b085         	sub	sp, #0x14
 80017a0: af00         	add	r7, sp, #0x0
 80017a2: 6078         	str	r0, [r7, #0x4]
; 	kf->MeasurementValidNum = 0;
 80017a4: 687b         	ldr	r3, [r7, #0x4]
 80017a6: 2200         	movs	r2, #0x0
 80017a8: 741a         	strb	r2, [r3, #0x10]
; 	memcpy(kf->z_data, kf->MeasuredVector, sizeof_float * kf->zSize);
 80017aa: 687b         	ldr	r3, [r7, #0x4]
 80017ac: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 80017b0: 687b         	ldr	r3, [r7, #0x4]
 80017b2: 6859         	ldr	r1, [r3, #0x4]
 80017b4: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8001984 <H_K_R_Adjustment+0x1e8>
 80017b6: 881b         	ldrh	r3, [r3]
 80017b8: 461a         	mov	r2, r3
 80017ba: 687b         	ldr	r3, [r7, #0x4]
 80017bc: 7b9b         	ldrb	r3, [r3, #0xe]
 80017be: fb02 f303    	mul	r3, r2, r3
 80017c2: 461a         	mov	r2, r3
 80017c4: f025 fe92    	bl	0x80274ec <memcpy>      @ imm = #0x25d24
; 	memset(kf->MeasuredVector, 0, sizeof_float * kf->zSize);
 80017c8: 687b         	ldr	r3, [r7, #0x4]
 80017ca: 6858         	ldr	r0, [r3, #0x4]
 80017cc: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x8001984 <H_K_R_Adjustment+0x1e8>
 80017ce: 881b         	ldrh	r3, [r3]
 80017d0: 461a         	mov	r2, r3
 80017d2: 687b         	ldr	r3, [r7, #0x4]
 80017d4: 7b9b         	ldrb	r3, [r3, #0xe]
 80017d6: fb02 f303    	mul	r3, r2, r3
 80017da: 461a         	mov	r2, r3
 80017dc: 2100         	movs	r1, #0x0
 80017de: f025 fe93    	bl	0x8027508 <memset>      @ imm = #0x25d26
; 	memset(kf->R_data, 0, sizeof_float * kf->zSize * kf->zSize);
 80017e2: 687b         	ldr	r3, [r7, #0x4]
 80017e4: f8d3 0118    	ldr.w	r0, [r3, #0x118]
 80017e8: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8001984 <H_K_R_Adjustment+0x1e8>
 80017ea: 881b         	ldrh	r3, [r3]
 80017ec: 461a         	mov	r2, r3
 80017ee: 687b         	ldr	r3, [r7, #0x4]
 80017f0: 7b9b         	ldrb	r3, [r3, #0xe]
 80017f2: fb02 f303    	mul	r3, r2, r3
 80017f6: 687a         	ldr	r2, [r7, #0x4]
 80017f8: 7b92         	ldrb	r2, [r2, #0xe]
 80017fa: fb02 f303    	mul	r3, r2, r3
 80017fe: 461a         	mov	r2, r3
 8001800: 2100         	movs	r1, #0x0
 8001802: f025 fe81    	bl	0x8027508 <memset>      @ imm = #0x25d02
; 	memset(kf->H_data, 0, sizeof_float * kf->xhatSize * kf->zSize);
 8001806: 687b         	ldr	r3, [r7, #0x4]
 8001808: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 800180c: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8001984 <H_K_R_Adjustment+0x1e8>
 800180e: 881b         	ldrh	r3, [r3]
 8001810: 461a         	mov	r2, r3
 8001812: 687b         	ldr	r3, [r7, #0x4]
 8001814: 7b1b         	ldrb	r3, [r3, #0xc]
 8001816: fb02 f303    	mul	r3, r2, r3
 800181a: 687a         	ldr	r2, [r7, #0x4]
 800181c: 7b92         	ldrb	r2, [r2, #0xe]
 800181e: fb02 f303    	mul	r3, r2, r3
 8001822: 461a         	mov	r2, r3
 8001824: 2100         	movs	r1, #0x0
 8001826: f025 fe6f    	bl	0x8027508 <memset>      @ imm = #0x25cde
; 	for (uint8_t i = 0; i < kf->zSize; ++i) {
 800182a: 2300         	movs	r3, #0x0
 800182c: 73fb         	strb	r3, [r7, #0xf]
 800182e: e047         	b	0x80018c0 <H_K_R_Adjustment+0x124> @ imm = #0x8e
; 		if (kf->z_data[i] != 0) {
 8001830: 687b         	ldr	r3, [r7, #0x4]
 8001832: f8d3 20f4    	ldr.w	r2, [r3, #0xf4]
 8001836: 7bfb         	ldrb	r3, [r7, #0xf]
 8001838: 009b         	lsls	r3, r3, #0x2
 800183a: 4413         	add	r3, r2
 800183c: edd3 7a00    	vldr	s15, [r3]
 8001840: eef5 7a40    	vcmp.f32	s15, #0
 8001844: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8001848: d037         	beq	0x80018ba <H_K_R_Adjustment+0x11e> @ imm = #0x6e
; 			kf->z_data[kf->MeasurementValidNum] = kf->z_data[i];
 800184a: 687b         	ldr	r3, [r7, #0x4]
 800184c: f8d3 20f4    	ldr.w	r2, [r3, #0xf4]
 8001850: 7bfb         	ldrb	r3, [r7, #0xf]
 8001852: 009b         	lsls	r3, r3, #0x2
 8001854: 441a         	add	r2, r3
 8001856: 687b         	ldr	r3, [r7, #0x4]
 8001858: f8d3 10f4    	ldr.w	r1, [r3, #0xf4]
 800185c: 687b         	ldr	r3, [r7, #0x4]
 800185e: 7c1b         	ldrb	r3, [r3, #0x10]
 8001860: 009b         	lsls	r3, r3, #0x2
 8001862: 440b         	add	r3, r1
 8001864: 6812         	ldr	r2, [r2]
 8001866: 601a         	str	r2, [r3]
; 			kf->temp[kf->MeasurementValidNum] = i;
 8001868: 687b         	ldr	r3, [r7, #0x4]
 800186a: 6a5b         	ldr	r3, [r3, #0x24]
 800186c: 687a         	ldr	r2, [r7, #0x4]
 800186e: 7c12         	ldrb	r2, [r2, #0x10]
 8001870: 4413         	add	r3, r2
 8001872: 7bfa         	ldrb	r2, [r7, #0xf]
 8001874: 701a         	strb	r2, [r3]
; 				   1] = kf->MeasurementDegree[i];
 8001876: 687b         	ldr	r3, [r7, #0x4]
 8001878: 699a         	ldr	r2, [r3, #0x18]
 800187a: 7bfb         	ldrb	r3, [r7, #0xf]
 800187c: 009b         	lsls	r3, r3, #0x2
 800187e: 441a         	add	r2, r3
; 			kf->H_data[kf->xhatSize * kf->MeasurementValidNum + kf->MeasurementMap[i] -
 8001880: 687b         	ldr	r3, [r7, #0x4]
 8001882: f8d3 110c    	ldr.w	r1, [r3, #0x10c]
 8001886: 687b         	ldr	r3, [r7, #0x4]
 8001888: 7b1b         	ldrb	r3, [r3, #0xc]
 800188a: 4618         	mov	r0, r3
 800188c: 687b         	ldr	r3, [r7, #0x4]
 800188e: 7c1b         	ldrb	r3, [r3, #0x10]
 8001890: fb00 f303    	mul	r3, r0, r3
 8001894: 6878         	ldr	r0, [r7, #0x4]
 8001896: 6944         	ldr	r4, [r0, #0x14]
 8001898: 7bf8         	ldrb	r0, [r7, #0xf]
 800189a: 4420         	add	r0, r4
 800189c: 7800         	ldrb	r0, [r0]
 800189e: 4403         	add	r3, r0
 80018a0: f103 4380    	add.w	r3, r3, #0x40000000
 80018a4: 3b01         	subs	r3, #0x1
 80018a6: 009b         	lsls	r3, r3, #0x2
 80018a8: 440b         	add	r3, r1
; 				   1] = kf->MeasurementDegree[i];
 80018aa: 6812         	ldr	r2, [r2]
 80018ac: 601a         	str	r2, [r3]
; 			kf->MeasurementValidNum++;
 80018ae: 687b         	ldr	r3, [r7, #0x4]
 80018b0: 7c1b         	ldrb	r3, [r3, #0x10]
 80018b2: 3301         	adds	r3, #0x1
 80018b4: b2da         	uxtb	r2, r3
 80018b6: 687b         	ldr	r3, [r7, #0x4]
 80018b8: 741a         	strb	r2, [r3, #0x10]
; 	for (uint8_t i = 0; i < kf->zSize; ++i) {
 80018ba: 7bfb         	ldrb	r3, [r7, #0xf]
 80018bc: 3301         	adds	r3, #0x1
 80018be: 73fb         	strb	r3, [r7, #0xf]
 80018c0: 687b         	ldr	r3, [r7, #0x4]
 80018c2: 7b9b         	ldrb	r3, [r3, #0xe]
 80018c4: 7bfa         	ldrb	r2, [r7, #0xf]
 80018c6: 429a         	cmp	r2, r3
 80018c8: d3b2         	blo	0x8001830 <H_K_R_Adjustment+0x94> @ imm = #-0x9c
; 	for (uint8_t i = 0; i < kf->MeasurementValidNum; ++i) {
 80018ca: 2300         	movs	r3, #0x0
 80018cc: 73bb         	strb	r3, [r7, #0xe]
 80018ce: e019         	b	0x8001904 <H_K_R_Adjustment+0x168> @ imm = #0x32
; 			kf->MatR_DiagonalElements[kf->temp[i]];
 80018d0: 687b         	ldr	r3, [r7, #0x4]
 80018d2: 69da         	ldr	r2, [r3, #0x1c]
 80018d4: 687b         	ldr	r3, [r7, #0x4]
 80018d6: 6a59         	ldr	r1, [r3, #0x24]
 80018d8: 7bbb         	ldrb	r3, [r7, #0xe]
 80018da: 440b         	add	r3, r1
 80018dc: 781b         	ldrb	r3, [r3]
 80018de: 009b         	lsls	r3, r3, #0x2
 80018e0: 441a         	add	r2, r3
; 		kf->R_data[i * kf->MeasurementValidNum + i] =
 80018e2: 687b         	ldr	r3, [r7, #0x4]
 80018e4: f8d3 1118    	ldr.w	r1, [r3, #0x118]
 80018e8: 7bbb         	ldrb	r3, [r7, #0xe]
 80018ea: 6878         	ldr	r0, [r7, #0x4]
 80018ec: 7c00         	ldrb	r0, [r0, #0x10]
 80018ee: fb03 f000    	mul	r0, r3, r0
 80018f2: 7bbb         	ldrb	r3, [r7, #0xe]
 80018f4: 4403         	add	r3, r0
 80018f6: 009b         	lsls	r3, r3, #0x2
 80018f8: 440b         	add	r3, r1
; 			kf->MatR_DiagonalElements[kf->temp[i]];
 80018fa: 6812         	ldr	r2, [r2]
; 		kf->R_data[i * kf->MeasurementValidNum + i] =
 80018fc: 601a         	str	r2, [r3]
; 	for (uint8_t i = 0; i < kf->MeasurementValidNum; ++i) {
 80018fe: 7bbb         	ldrb	r3, [r7, #0xe]
 8001900: 3301         	adds	r3, #0x1
 8001902: 73bb         	strb	r3, [r7, #0xe]
 8001904: 687b         	ldr	r3, [r7, #0x4]
 8001906: 7c1b         	ldrb	r3, [r3, #0x10]
 8001908: 7bba         	ldrb	r2, [r7, #0xe]
 800190a: 429a         	cmp	r2, r3
 800190c: d3e0         	blo	0x80018d0 <H_K_R_Adjustment+0x134> @ imm = #-0x40
; 	kf->H.numRows = kf->MeasurementValidNum;
 800190e: 687b         	ldr	r3, [r7, #0x4]
 8001910: 7c1b         	ldrb	r3, [r3, #0x10]
 8001912: 461a         	mov	r2, r3
 8001914: 687b         	ldr	r3, [r7, #0x4]
 8001916: f8a3 2078    	strh.w	r2, [r3, #0x78]
; 	kf->H.numCols = kf->xhatSize;
 800191a: 687b         	ldr	r3, [r7, #0x4]
 800191c: 7b1b         	ldrb	r3, [r3, #0xc]
 800191e: 461a         	mov	r2, r3
 8001920: 687b         	ldr	r3, [r7, #0x4]
 8001922: f8a3 207a    	strh.w	r2, [r3, #0x7a]
; 	kf->HT.numRows = kf->xhatSize;
 8001926: 687b         	ldr	r3, [r7, #0x4]
 8001928: 7b1b         	ldrb	r3, [r3, #0xc]
 800192a: 461a         	mov	r2, r3
 800192c: 687b         	ldr	r3, [r7, #0x4]
 800192e: f8a3 2080    	strh.w	r2, [r3, #0x80]
; 	kf->HT.numCols = kf->MeasurementValidNum;
 8001932: 687b         	ldr	r3, [r7, #0x4]
 8001934: 7c1b         	ldrb	r3, [r3, #0x10]
 8001936: 461a         	mov	r2, r3
 8001938: 687b         	ldr	r3, [r7, #0x4]
 800193a: f8a3 2082    	strh.w	r2, [r3, #0x82]
; 	kf->R.numRows = kf->MeasurementValidNum;
 800193e: 687b         	ldr	r3, [r7, #0x4]
 8001940: 7c1b         	ldrb	r3, [r3, #0x10]
 8001942: 461a         	mov	r2, r3
 8001944: 687b         	ldr	r3, [r7, #0x4]
 8001946: f8a3 2090    	strh.w	r2, [r3, #0x90]
; 	kf->R.numCols = kf->MeasurementValidNum;
 800194a: 687b         	ldr	r3, [r7, #0x4]
 800194c: 7c1b         	ldrb	r3, [r3, #0x10]
 800194e: 461a         	mov	r2, r3
 8001950: 687b         	ldr	r3, [r7, #0x4]
 8001952: f8a3 2092    	strh.w	r2, [r3, #0x92]
; 	kf->K.numRows = kf->xhatSize;
 8001956: 687b         	ldr	r3, [r7, #0x4]
 8001958: 7b1b         	ldrb	r3, [r3, #0xc]
 800195a: 461a         	mov	r2, r3
 800195c: 687b         	ldr	r3, [r7, #0x4]
 800195e: f8a3 2098    	strh.w	r2, [r3, #0x98]
; 	kf->K.numCols = kf->MeasurementValidNum;
 8001962: 687b         	ldr	r3, [r7, #0x4]
 8001964: 7c1b         	ldrb	r3, [r3, #0x10]
 8001966: 461a         	mov	r2, r3
 8001968: 687b         	ldr	r3, [r7, #0x4]
 800196a: f8a3 209a    	strh.w	r2, [r3, #0x9a]
; 	kf->z.numRows = kf->MeasurementValidNum;
 800196e: 687b         	ldr	r3, [r7, #0x4]
 8001970: 7c1b         	ldrb	r3, [r3, #0x10]
 8001972: 461a         	mov	r2, r3
 8001974: 687b         	ldr	r3, [r7, #0x4]
 8001976: f8a3 2048    	strh.w	r2, [r3, #0x48]
; }
 800197a: bf00         	nop
 800197c: 3714         	adds	r7, #0x14
 800197e: 46bd         	mov	sp, r7
 8001980: bd90         	pop	{r4, r7, pc}
 8001982: bf00         	nop

08001984 <$d>:
 8001984: 00 33 00 20  	.word	0x20003300

08001988 <IMU_QuaternionEKF_Init>:
; {
 8001988: b580         	push	{r7, lr}
 800198a: b088         	sub	sp, #0x20
 800198c: af00         	add	r7, sp, #0x0
 800198e: 6178         	str	r0, [r7, #0x14]
 8001990: ed87 0a04    	vstr	s0, [r7, #16]
 8001994: edc7 0a03    	vstr	s1, [r7, #12]
 8001998: ed87 1a02    	vstr	s2, [r7, #8]
 800199c: edc7 1a01    	vstr	s3, [r7, #4]
 80019a0: ed87 2a00    	vstr	s4, [r7]
; 	QEKF_INS.Initialized = 1;
 80019a4: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 80019a6: 2201         	movs	r2, #0x1
 80019a8: 701a         	strb	r2, [r3]
; 	QEKF_INS.Q1 = process_noise1;
 80019aa: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 80019ac: 693b         	ldr	r3, [r7, #0x10]
 80019ae: f8c2 31b0    	str.w	r3, [r2, #0x1b0]
; 	QEKF_INS.Q2 = process_noise2;
 80019b2: 4a3f         	ldr	r2, [pc, #0xfc]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 80019b4: 68fb         	ldr	r3, [r7, #0xc]
 80019b6: f8c2 31b4    	str.w	r3, [r2, #0x1b4]
; 	QEKF_INS.R = measure_noise;
 80019ba: 4a3d         	ldr	r2, [pc, #0xf4]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 80019bc: 68bb         	ldr	r3, [r7, #0x8]
 80019be: f8c2 31b8    	str.w	r3, [r2, #0x1b8]
; 	QEKF_INS.ChiSquareTestThreshold = 1e-8;
 80019c2: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 80019c4: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x8001ab4 <IMU_QuaternionEKF_Init+0x12c>
 80019c6: f8c3 21cc    	str.w	r2, [r3, #0x1cc]
; 	QEKF_INS.ConvergeFlag = 0;
 80019ca: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 80019cc: 2200         	movs	r2, #0x0
 80019ce: f883 2138    	strb.w	r2, [r3, #0x138]
; 	QEKF_INS.ErrorCount = 0;
 80019d2: 4937         	ldr	r1, [pc, #0xdc]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 80019d4: f04f 0200    	mov.w	r2, #0x0
 80019d8: f04f 0300    	mov.w	r3, #0x0
 80019dc: e9c1 2350    	strd	r2, r3, [r1, #320]
; 	QEKF_INS.UpdateCount = 0;
 80019e0: 4933         	ldr	r1, [pc, #0xcc]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 80019e2: f04f 0200    	mov.w	r2, #0x0
 80019e6: f04f 0300    	mov.w	r3, #0x0
 80019ea: e9c1 2352    	strd	r2, r3, [r1, #328]
; 	if (lambda > 1) {
 80019ee: edd7 7a01    	vldr	s15, [r7, #4]
 80019f2: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 80019f6: eef4 7ac7    	vcmpe.f32	s15, s14
 80019fa: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80019fe: dd02         	ble	0x8001a06 <IMU_QuaternionEKF_Init+0x7e> @ imm = #0x4
; 		lambda = 1;
 8001a00: f04f 537e    	mov.w	r3, #0x3f800000
 8001a04: 607b         	str	r3, [r7, #0x4]
; 	QEKF_INS.lambda = lambda;
 8001a06: 4a2a         	ldr	r2, [pc, #0xa8]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 8001a08: 687b         	ldr	r3, [r7, #0x4]
 8001a0a: f8c2 31d0    	str.w	r3, [r2, #0x1d0]
; 	QEKF_INS.accLPFcoef = lpf;
 8001a0e: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 8001a10: 683b         	ldr	r3, [r7]
 8001a12: f8c2 3190    	str.w	r3, [r2, #0x190]
; 	Kalman_Filter_Init(&QEKF_INS.IMU_QuaternionEKF, 6, 0, 3);
 8001a16: 2303         	movs	r3, #0x3
 8001a18: 2200         	movs	r2, #0x0
 8001a1a: 2106         	movs	r1, #0x6
 8001a1c: 4826         	ldr	r0, [pc, #0x98]         @ 0x8001ab8 <IMU_QuaternionEKF_Init+0x130>
 8001a1e: f7ff f935    	bl	0x8000c8c <Kalman_Filter_Init> @ imm = #-0xd96
; 	Matrix_Init(&QEKF_INS.ChiSquare, 1, 1, (float *)QEKF_INS.ChiSquare_Data);
 8001a22: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8001abc <IMU_QuaternionEKF_Init+0x134>
 8001a24: 2201         	movs	r2, #0x1
 8001a26: 2101         	movs	r1, #0x1
 8001a28: 4825         	ldr	r0, [pc, #0x94]         @ 0x8001ac0 <IMU_QuaternionEKF_Init+0x138>
 8001a2a: f010 fce7    	bl	0x80123fc <arm_mat_init_f32> @ imm = #0x109ce
; 	for (int i = 0; i < 4; i++) {
 8001a2e: 2300         	movs	r3, #0x0
 8001a30: 61fb         	str	r3, [r7, #0x1c]
 8001a32: e00e         	b	0x8001a52 <IMU_QuaternionEKF_Init+0xca> @ imm = #0x1c
; 		QEKF_INS.IMU_QuaternionEKF.xhat_data[i] = init_quaternion[i];
 8001a34: 69fb         	ldr	r3, [r7, #0x1c]
 8001a36: 009b         	lsls	r3, r3, #0x2
 8001a38: 697a         	ldr	r2, [r7, #0x14]
 8001a3a: 441a         	add	r2, r3
 8001a3c: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 8001a3e: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 8001a42: 69fb         	ldr	r3, [r7, #0x1c]
 8001a44: 009b         	lsls	r3, r3, #0x2
 8001a46: 440b         	add	r3, r1
 8001a48: 6812         	ldr	r2, [r2]
 8001a4a: 601a         	str	r2, [r3]
; 	for (int i = 0; i < 4; i++) {
 8001a4c: 69fb         	ldr	r3, [r7, #0x1c]
 8001a4e: 3301         	adds	r3, #0x1
 8001a50: 61fb         	str	r3, [r7, #0x1c]
 8001a52: 69fb         	ldr	r3, [r7, #0x1c]
 8001a54: 2b03         	cmp	r3, #0x3
 8001a56: dded         	ble	0x8001a34 <IMU_QuaternionEKF_Init+0xac> @ imm = #-0x26
; 	QEKF_INS.IMU_QuaternionEKF.User_Func0_f = IMU_QuaternionEKF_Observe;
 8001a58: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 8001a5a: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x8001ac4 <IMU_QuaternionEKF_Init+0x13c>
 8001a5c: f8c3 20d0    	str.w	r2, [r3, #0xd0]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func1_f = IMU_QuaternionEKF_F_Linearization_P_Fading;
 8001a60: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 8001a62: 4a19         	ldr	r2, [pc, #0x64]         @ 0x8001ac8 <IMU_QuaternionEKF_Init+0x140>
 8001a64: f8c3 20d4    	str.w	r2, [r3, #0xd4]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func2_f = IMU_QuaternionEKF_SetH;
 8001a68: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 8001a6a: 4a18         	ldr	r2, [pc, #0x60]         @ 0x8001acc <IMU_QuaternionEKF_Init+0x144>
 8001a6c: f8c3 20d8    	str.w	r2, [r3, #0xd8]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func3_f = IMU_QuaternionEKF_xhatUpdate;
 8001a70: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 8001a72: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8001ad0 <IMU_QuaternionEKF_Init+0x148>
 8001a74: f8c3 20dc    	str.w	r2, [r3, #0xdc]
; 	QEKF_INS.IMU_QuaternionEKF.SkipEq3 = TRUE;
 8001a78: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 8001a7a: 2201         	movs	r2, #0x1
 8001a7c: f883 202e    	strb.w	r2, [r3, #0x2e]
; 	QEKF_INS.IMU_QuaternionEKF.SkipEq4 = TRUE;
 8001a80: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 8001a82: 2201         	movs	r2, #0x1
 8001a84: f883 202f    	strb.w	r2, [r3, #0x2f]
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.F_data, IMU_QuaternionEKF_F, sizeof(IMU_QuaternionEKF_F));
 8001a88: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 8001a8a: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001a8e: 2290         	movs	r2, #0x90
 8001a90: 4910         	ldr	r1, [pc, #0x40]         @ 0x8001ad4 <IMU_QuaternionEKF_Init+0x14c>
 8001a92: 4618         	mov	r0, r3
 8001a94: f025 fd2a    	bl	0x80274ec <memcpy>      @ imm = #0x25a54
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.P_data, IMU_QuaternionEKF_P, sizeof(IMU_QuaternionEKF_P));
 8001a98: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8001ab0 <IMU_QuaternionEKF_Init+0x128>
 8001a9a: f8d3 30fc    	ldr.w	r3, [r3, #0xfc]
 8001a9e: 2290         	movs	r2, #0x90
 8001aa0: 490d         	ldr	r1, [pc, #0x34]         @ 0x8001ad8 <IMU_QuaternionEKF_Init+0x150>
 8001aa2: 4618         	mov	r0, r3
 8001aa4: f025 fd22    	bl	0x80274ec <memcpy>      @ imm = #0x25a44
; }
 8001aa8: bf00         	nop
 8001aaa: 3720         	adds	r7, #0x20
 8001aac: 46bd         	mov	sp, r7
 8001aae: bd80         	pop	{r7, pc}

08001ab0 <$d>:
 8001ab0: 98 0c 00 20  	.word	0x20000c98
 8001ab4: 77 cc 2b 32  	.word	0x322bcc77
 8001ab8: 9c 0c 00 20  	.word	0x20000c9c
 8001abc: 60 0e 00 20  	.word	0x20000e60
 8001ac0: 58 0e 00 20  	.word	0x20000e58
 8001ac4: e5 2c 00 08  	.word	0x08002ce5
 8001ac8: 1d 22 00 08  	.word	0x0800221d
 8001acc: d9 24 00 08  	.word	0x080024d9
 8001ad0: 3d 26 00 08  	.word	0x0800263d
 8001ad4: e8 a6 02 08  	.word	0x0802a6e8
 8001ad8: 08 04 00 20  	.word	0x20000408

08001adc <IMU_QuaternionEKF_Update>:
; {
 8001adc: b5b0         	push	{r4, r5, r7, lr}
 8001ade: b08a         	sub	sp, #0x28
 8001ae0: af00         	add	r7, sp, #0x0
 8001ae2: ed87 0a07    	vstr	s0, [r7, #28]
 8001ae6: edc7 0a06    	vstr	s1, [r7, #24]
 8001aea: ed87 1a05    	vstr	s2, [r7, #20]
 8001aee: edc7 1a04    	vstr	s3, [r7, #16]
 8001af2: ed87 2a03    	vstr	s4, [r7, #12]
 8001af6: edc7 2a02    	vstr	s5, [r7, #8]
 8001afa: ed87 3a01    	vstr	s6, [r7, #4]
 8001afe: edc7 3a00    	vstr	s7, [r7]
; 	QEKF_INS.dt = gyro_dt;
 8001b02: 4ab5         	ldr	r2, [pc, #0x2d4]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001b04: 683b         	ldr	r3, [r7]
 8001b06: f8c2 31bc    	str.w	r3, [r2, #0x1bc]
; 	QEKF_INS.Gyro[0] = gx - QEKF_INS.GyroBias[0];
 8001b0a: 4bb3         	ldr	r3, [pc, #0x2cc]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001b0c: edd3 7a58    	vldr	s15, [r3, #352]
 8001b10: ed97 7a07    	vldr	s14, [r7, #28]
 8001b14: ee77 7a67    	vsub.f32	s15, s14, s15
 8001b18: 4baf         	ldr	r3, [pc, #0x2bc]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001b1a: edc3 7a5b    	vstr	s15, [r3, #364]
; 	QEKF_INS.Gyro[1] = gy - QEKF_INS.GyroBias[1];
 8001b1e: 4bae         	ldr	r3, [pc, #0x2b8]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001b20: edd3 7a59    	vldr	s15, [r3, #356]
 8001b24: ed97 7a06    	vldr	s14, [r7, #24]
 8001b28: ee77 7a67    	vsub.f32	s15, s14, s15
 8001b2c: 4baa         	ldr	r3, [pc, #0x2a8]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001b2e: edc3 7a5c    	vstr	s15, [r3, #368]
; 	QEKF_INS.Gyro[2] = gz - QEKF_INS.GyroBias[2];
 8001b32: 4ba9         	ldr	r3, [pc, #0x2a4]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001b34: edd3 7a5a    	vldr	s15, [r3, #360]
 8001b38: ed97 7a05    	vldr	s14, [r7, #20]
 8001b3c: ee77 7a67    	vsub.f32	s15, s14, s15
 8001b40: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001b42: edc3 7a5d    	vstr	s15, [r3, #372]
; 	halfgxdt = 0.5f * QEKF_INS.Gyro[0] * gyro_dt;
 8001b46: 4ba4         	ldr	r3, [pc, #0x290]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001b48: edd3 7a5b    	vldr	s15, [r3, #364]
 8001b4c: eeb6 7a00    	vmov.f32	s14, #5.000000e-01
 8001b50: ee27 7a87    	vmul.f32	s14, s15, s14
 8001b54: edd7 7a00    	vldr	s15, [r7]
 8001b58: ee67 7a27    	vmul.f32	s15, s14, s15
 8001b5c: 4b9f         	ldr	r3, [pc, #0x27c]        @ 0x8001ddc <IMU_QuaternionEKF_Update+0x300>
 8001b5e: edc3 7a00    	vstr	s15, [r3]
; 	halfgydt = 0.5f * QEKF_INS.Gyro[1] * gyro_dt;
 8001b62: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001b64: edd3 7a5c    	vldr	s15, [r3, #368]
 8001b68: eeb6 7a00    	vmov.f32	s14, #5.000000e-01
 8001b6c: ee27 7a87    	vmul.f32	s14, s15, s14
 8001b70: edd7 7a00    	vldr	s15, [r7]
 8001b74: ee67 7a27    	vmul.f32	s15, s14, s15
 8001b78: 4b99         	ldr	r3, [pc, #0x264]        @ 0x8001de0 <IMU_QuaternionEKF_Update+0x304>
 8001b7a: edc3 7a00    	vstr	s15, [r3]
; 	halfgzdt = 0.5f * QEKF_INS.Gyro[2] * gyro_dt;
 8001b7e: 4b96         	ldr	r3, [pc, #0x258]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001b80: edd3 7a5d    	vldr	s15, [r3, #372]
 8001b84: eeb6 7a00    	vmov.f32	s14, #5.000000e-01
 8001b88: ee27 7a87    	vmul.f32	s14, s15, s14
 8001b8c: edd7 7a00    	vldr	s15, [r7]
 8001b90: ee67 7a27    	vmul.f32	s15, s14, s15
 8001b94: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8001de4 <IMU_QuaternionEKF_Update+0x308>
 8001b96: edc3 7a00    	vstr	s15, [r3]
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.F_data, IMU_QuaternionEKF_F, sizeof(IMU_QuaternionEKF_F));
 8001b9a: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001b9c: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001ba0: 2290         	movs	r2, #0x90
 8001ba2: 4991         	ldr	r1, [pc, #0x244]        @ 0x8001de8 <IMU_QuaternionEKF_Update+0x30c>
 8001ba4: 4618         	mov	r0, r3
 8001ba6: f025 fca1    	bl	0x80274ec <memcpy>      @ imm = #0x25942
; 	QEKF_INS.IMU_QuaternionEKF.F_data[1] = -halfgxdt;
 8001baa: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x8001ddc <IMU_QuaternionEKF_Update+0x300>
 8001bac: edd3 7a00    	vldr	s15, [r3]
 8001bb0: 4b89         	ldr	r3, [pc, #0x224]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001bb2: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001bb6: 3304         	adds	r3, #0x4
 8001bb8: eef1 7a67    	vneg.f32	s15, s15
 8001bbc: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[2] = -halfgydt;
 8001bc0: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8001de0 <IMU_QuaternionEKF_Update+0x304>
 8001bc2: edd3 7a00    	vldr	s15, [r3]
 8001bc6: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001bc8: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001bcc: 3308         	adds	r3, #0x8
 8001bce: eef1 7a67    	vneg.f32	s15, s15
 8001bd2: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[3] = -halfgzdt;
 8001bd6: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x8001de4 <IMU_QuaternionEKF_Update+0x308>
 8001bd8: edd3 7a00    	vldr	s15, [r3]
 8001bdc: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001bde: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001be2: 330c         	adds	r3, #0xc
 8001be4: eef1 7a67    	vneg.f32	s15, s15
 8001be8: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[6] = halfgxdt;
 8001bec: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001bee: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001bf2: 3318         	adds	r3, #0x18
 8001bf4: 4a79         	ldr	r2, [pc, #0x1e4]        @ 0x8001ddc <IMU_QuaternionEKF_Update+0x300>
 8001bf6: 6812         	ldr	r2, [r2]
 8001bf8: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[8] = halfgzdt;
 8001bfa: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001bfc: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c00: 3320         	adds	r3, #0x20
 8001c02: 4a78         	ldr	r2, [pc, #0x1e0]        @ 0x8001de4 <IMU_QuaternionEKF_Update+0x308>
 8001c04: 6812         	ldr	r2, [r2]
 8001c06: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[9] = -halfgydt;
 8001c08: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8001de0 <IMU_QuaternionEKF_Update+0x304>
 8001c0a: edd3 7a00    	vldr	s15, [r3]
 8001c0e: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001c10: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c14: 3324         	adds	r3, #0x24
 8001c16: eef1 7a67    	vneg.f32	s15, s15
 8001c1a: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[12] = halfgydt;
 8001c1e: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001c20: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c24: 3330         	adds	r3, #0x30
 8001c26: 4a6e         	ldr	r2, [pc, #0x1b8]        @ 0x8001de0 <IMU_QuaternionEKF_Update+0x304>
 8001c28: 6812         	ldr	r2, [r2]
 8001c2a: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[13] = -halfgzdt;
 8001c2c: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x8001de4 <IMU_QuaternionEKF_Update+0x308>
 8001c2e: edd3 7a00    	vldr	s15, [r3]
 8001c32: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001c34: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c38: 3334         	adds	r3, #0x34
 8001c3a: eef1 7a67    	vneg.f32	s15, s15
 8001c3e: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[15] = halfgxdt;
 8001c42: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001c44: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c48: 333c         	adds	r3, #0x3c
 8001c4a: 4a64         	ldr	r2, [pc, #0x190]        @ 0x8001ddc <IMU_QuaternionEKF_Update+0x300>
 8001c4c: 6812         	ldr	r2, [r2]
 8001c4e: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[18] = halfgzdt;
 8001c50: 4b61         	ldr	r3, [pc, #0x184]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001c52: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c56: 3348         	adds	r3, #0x48
 8001c58: 4a62         	ldr	r2, [pc, #0x188]        @ 0x8001de4 <IMU_QuaternionEKF_Update+0x308>
 8001c5a: 6812         	ldr	r2, [r2]
 8001c5c: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[19] = halfgydt;
 8001c5e: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001c60: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c64: 334c         	adds	r3, #0x4c
 8001c66: 4a5e         	ldr	r2, [pc, #0x178]        @ 0x8001de0 <IMU_QuaternionEKF_Update+0x304>
 8001c68: 6812         	ldr	r2, [r2]
 8001c6a: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[20] = -halfgxdt;
 8001c6c: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8001ddc <IMU_QuaternionEKF_Update+0x300>
 8001c6e: edd3 7a00    	vldr	s15, [r3]
 8001c72: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001c74: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001c78: 3350         	adds	r3, #0x50
 8001c7a: eef1 7a67    	vneg.f32	s15, s15
 8001c7e: edc3 7a00    	vstr	s15, [r3]
; 	if (QEKF_INS.UpdateCount == 0) // 如果是第一次进入,需要初始化低通滤波
 8001c82: 4b55         	ldr	r3, [pc, #0x154]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001c84: e9d3 2352    	ldrd	r2, r3, [r3, #328]
 8001c88: 4313         	orrs	r3, r2
 8001c8a: d10b         	bne	0x8001ca4 <IMU_QuaternionEKF_Update+0x1c8> @ imm = #0x16
; 		QEKF_INS.Accel[0] = ax;
 8001c8c: 4a52         	ldr	r2, [pc, #0x148]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001c8e: 693b         	ldr	r3, [r7, #0x10]
 8001c90: f8c2 3178    	str.w	r3, [r2, #0x178]
; 		QEKF_INS.Accel[1] = ay;
 8001c94: 4a50         	ldr	r2, [pc, #0x140]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001c96: 68fb         	ldr	r3, [r7, #0xc]
 8001c98: f8c2 317c    	str.w	r3, [r2, #0x17c]
; 		QEKF_INS.Accel[2] = az;
 8001c9c: 4a4e         	ldr	r2, [pc, #0x138]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001c9e: 68bb         	ldr	r3, [r7, #0x8]
 8001ca0: f8c2 3180    	str.w	r3, [r2, #0x180]
; 		QEKF_INS.Accel[0] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001ca4: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001ca6: ed93 7a5e    	vldr	s14, [r3, #376]
 8001caa: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001cac: edd3 7a64    	vldr	s15, [r3, #400]
 8001cb0: ee67 6a27    	vmul.f32	s13, s14, s15
 8001cb4: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001cb6: ed93 7a64    	vldr	s14, [r3, #400]
 8001cba: edd7 7a01    	vldr	s15, [r7, #4]
 8001cbe: ee77 7a27    	vadd.f32	s15, s14, s15
 8001cc2: ee86 7aa7    	vdiv.f32	s14, s13, s15
; 		ax * accel_dt / (accel_dt + QEKF_INS.accLPFcoef);
 8001cc6: edd7 6a04    	vldr	s13, [r7, #16]
 8001cca: edd7 7a01    	vldr	s15, [r7, #4]
 8001cce: ee26 6aa7    	vmul.f32	s12, s13, s15
 8001cd2: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001cd4: edd3 6a64    	vldr	s13, [r3, #400]
 8001cd8: edd7 7a01    	vldr	s15, [r7, #4]
 8001cdc: ee76 6aa7    	vadd.f32	s13, s13, s15
 8001ce0: eec6 7a26    	vdiv.f32	s15, s12, s13
; 		QEKF_INS.Accel[0] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001ce4: ee77 7a27    	vadd.f32	s15, s14, s15
; 	QEKF_INS.Accel[0] =
 8001ce8: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001cea: edc3 7a5e    	vstr	s15, [r3, #376]
; 		QEKF_INS.Accel[1] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001cee: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001cf0: ed93 7a5f    	vldr	s14, [r3, #380]
 8001cf4: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001cf6: edd3 7a64    	vldr	s15, [r3, #400]
 8001cfa: ee67 6a27    	vmul.f32	s13, s14, s15
 8001cfe: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d00: ed93 7a64    	vldr	s14, [r3, #400]
 8001d04: edd7 7a01    	vldr	s15, [r7, #4]
 8001d08: ee77 7a27    	vadd.f32	s15, s14, s15
 8001d0c: ee86 7aa7    	vdiv.f32	s14, s13, s15
; 		ay * accel_dt / (QEKF_INS.dt + QEKF_INS.accLPFcoef);
 8001d10: edd7 6a03    	vldr	s13, [r7, #12]
 8001d14: edd7 7a01    	vldr	s15, [r7, #4]
 8001d18: ee26 6aa7    	vmul.f32	s12, s13, s15
 8001d1c: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d1e: edd3 6a6f    	vldr	s13, [r3, #444]
 8001d22: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d24: edd3 7a64    	vldr	s15, [r3, #400]
 8001d28: ee76 6aa7    	vadd.f32	s13, s13, s15
 8001d2c: eec6 7a26    	vdiv.f32	s15, s12, s13
; 		QEKF_INS.Accel[1] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001d30: ee77 7a27    	vadd.f32	s15, s14, s15
; 	QEKF_INS.Accel[1] =
 8001d34: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d36: edc3 7a5f    	vstr	s15, [r3, #380]
; 		QEKF_INS.Accel[2] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001d3a: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d3c: ed93 7a60    	vldr	s14, [r3, #384]
 8001d40: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d42: edd3 7a64    	vldr	s15, [r3, #400]
 8001d46: ee67 6a27    	vmul.f32	s13, s14, s15
 8001d4a: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d4c: ed93 7a64    	vldr	s14, [r3, #400]
 8001d50: edd7 7a01    	vldr	s15, [r7, #4]
 8001d54: ee77 7a27    	vadd.f32	s15, s14, s15
 8001d58: ee86 7aa7    	vdiv.f32	s14, s13, s15
; 		az * accel_dt / (accel_dt + QEKF_INS.accLPFcoef);
 8001d5c: edd7 6a02    	vldr	s13, [r7, #8]
 8001d60: edd7 7a01    	vldr	s15, [r7, #4]
 8001d64: ee26 6aa7    	vmul.f32	s12, s13, s15
 8001d68: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d6a: edd3 6a64    	vldr	s13, [r3, #400]
 8001d6e: edd7 7a01    	vldr	s15, [r7, #4]
 8001d72: ee76 6aa7    	vadd.f32	s13, s13, s15
 8001d76: eec6 7a26    	vdiv.f32	s15, s12, s13
; 		QEKF_INS.Accel[2] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8001d7a: ee77 7a27    	vadd.f32	s15, s14, s15
; 	QEKF_INS.Accel[2] =
 8001d7e: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d80: edc3 7a60    	vstr	s15, [r3, #384]
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 8001d84: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d86: ed93 7a5e    	vldr	s14, [r3, #376]
 8001d8a: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d8c: edd3 7a5e    	vldr	s15, [r3, #376]
 8001d90: ee27 7a27    	vmul.f32	s14, s14, s15
; 			       QEKF_INS.Accel[1] * QEKF_INS.Accel[1] +
 8001d94: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d96: edd3 6a5f    	vldr	s13, [r3, #380]
 8001d9a: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001d9c: edd3 7a5f    	vldr	s15, [r3, #380]
 8001da0: ee66 7aa7    	vmul.f32	s15, s13, s15
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 8001da4: ee37 7a27    	vadd.f32	s14, s14, s15
; 			       QEKF_INS.Accel[2] * QEKF_INS.Accel[2]);
 8001da8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001daa: edd3 6a60    	vldr	s13, [r3, #384]
 8001dae: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8001dd8 <IMU_QuaternionEKF_Update+0x2fc>
 8001db0: edd3 7a60    	vldr	s15, [r3, #384]
 8001db4: ee66 7aa7    	vmul.f32	s15, s13, s15
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 8001db8: ee77 7a27    	vadd.f32	s15, s14, s15
 8001dbc: eeb0 0a67    	vmov.f32	s0, s15
 8001dc0: f000 ffb6    	bl	0x8002d30 <invSqrt>     @ imm = #0xf6c
 8001dc4: eef0 7a40    	vmov.f32	s15, s0
 8001dc8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8001dec <IMU_QuaternionEKF_Update+0x310>
 8001dca: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 3; ++i) {
 8001dce: 2300         	movs	r3, #0x0
 8001dd0: f887 3027    	strb.w	r3, [r7, #0x27]
 8001dd4: e026         	b	0x8001e24 <IMU_QuaternionEKF_Update+0x348> @ imm = #0x4c
 8001dd6: bf00         	nop

08001dd8 <$d>:
 8001dd8: 98 0c 00 20  	.word	0x20000c98
 8001ddc: 80 2c 00 20  	.word	0x20002c80
 8001de0: 84 2c 00 20  	.word	0x20002c84
 8001de4: 88 2c 00 20  	.word	0x20002c88
 8001de8: e8 a6 02 08  	.word	0x0802a6e8
 8001dec: 8c 2c 00 20  	.word	0x20002c8c

08001df0 <$t>:
; 			QEKF_INS.Accel[i] * accelInvNorm; // 用加速度向量更新量测值
 8001df0: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001df4: 4a38         	ldr	r2, [pc, #0xe0]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001df6: 335e         	adds	r3, #0x5e
 8001df8: 009b         	lsls	r3, r3, #0x2
 8001dfa: 4413         	add	r3, r2
 8001dfc: ed93 7a00    	vldr	s14, [r3]
 8001e00: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8001edc <IMU_QuaternionEKF_Update+0x400>
 8001e02: edd3 7a00    	vldr	s15, [r3]
; 		QEKF_INS.IMU_QuaternionEKF.MeasuredVector[i] =
 8001e06: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001e08: 689a         	ldr	r2, [r3, #0x8]
 8001e0a: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001e0e: 009b         	lsls	r3, r3, #0x2
 8001e10: 4413         	add	r3, r2
; 			QEKF_INS.Accel[i] * accelInvNorm; // 用加速度向量更新量测值
 8001e12: ee67 7a27    	vmul.f32	s15, s14, s15
; 		QEKF_INS.IMU_QuaternionEKF.MeasuredVector[i] =
 8001e16: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 3; ++i) {
 8001e1a: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001e1e: 3301         	adds	r3, #0x1
 8001e20: f887 3027    	strb.w	r3, [r7, #0x27]
 8001e24: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8001e28: 2b02         	cmp	r3, #0x2
 8001e2a: d9e1         	bls	0x8001df0 <IMU_QuaternionEKF_Update+0x314> @ imm = #-0x3e
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 8001e2c: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001e2e: ed93 7a5b    	vldr	s14, [r3, #364]
 8001e32: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001e34: edd3 7a5b    	vldr	s15, [r3, #364]
 8001e38: ee27 7a27    	vmul.f32	s14, s14, s15
; 					    QEKF_INS.Gyro[1] * QEKF_INS.Gyro[1] +
 8001e3c: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001e3e: edd3 6a5c    	vldr	s13, [r3, #368]
 8001e42: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001e44: edd3 7a5c    	vldr	s15, [r3, #368]
 8001e48: ee66 7aa7    	vmul.f32	s15, s13, s15
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 8001e4c: ee37 7a27    	vadd.f32	s14, s14, s15
; 					    QEKF_INS.Gyro[2] * QEKF_INS.Gyro[2]);
 8001e50: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001e52: edd3 6a5d    	vldr	s13, [r3, #372]
 8001e56: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001e58: edd3 7a5d    	vldr	s15, [r3, #372]
 8001e5c: ee66 7aa7    	vmul.f32	s15, s13, s15
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 8001e60: ee77 7a27    	vadd.f32	s15, s14, s15
 8001e64: eeb0 0a67    	vmov.f32	s0, s15
 8001e68: f000 ff62    	bl	0x8002d30 <invSqrt>     @ imm = #0xec4
 8001e6c: eeb0 7a40    	vmov.f32	s14, s0
 8001e70: eef7 6a00    	vmov.f32	s13, #1.000000e+00
 8001e74: eec6 7a87    	vdiv.f32	s15, s13, s14
 8001e78: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001e7a: edc3 7a65    	vstr	s15, [r3, #404]
; 	QEKF_INS.accl_norm = 1.0f / accelInvNorm;
 8001e7e: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8001edc <IMU_QuaternionEKF_Update+0x400>
 8001e80: ed93 7a00    	vldr	s14, [r3]
 8001e84: eef7 6a00    	vmov.f32	s13, #1.000000e+00
 8001e88: eec6 7a87    	vdiv.f32	s15, s13, s14
 8001e8c: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001e8e: edc3 7a66    	vstr	s15, [r3, #408]
; 	if (QEKF_INS.gyro_norm < 0.3f && QEKF_INS.accl_norm > 9.8f - 0.5f &&
 8001e92: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001e94: edd3 7a65    	vldr	s15, [r3, #404]
 8001e98: ed9f 7a11    	vldr	s14, [pc, #68]          @ 0x8001ee0 <IMU_QuaternionEKF_Update+0x404>
 8001e9c: eef4 7ac7    	vcmpe.f32	s15, s14
 8001ea0: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8001ea4: d522         	bpl	0x8001eec <IMU_QuaternionEKF_Update+0x410> @ imm = #0x44
 8001ea6: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001ea8: edd3 7a66    	vldr	s15, [r3, #408]
 8001eac: ed9f 7a0d    	vldr	s14, [pc, #52]          @ 0x8001ee4 <IMU_QuaternionEKF_Update+0x408>
 8001eb0: eef4 7ac7    	vcmpe.f32	s15, s14
 8001eb4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8001eb8: dd18         	ble	0x8001eec <IMU_QuaternionEKF_Update+0x410> @ imm = #0x30
; 	    QEKF_INS.accl_norm < 9.8f + 0.5f) {
 8001eba: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001ebc: edd3 7a66    	vldr	s15, [r3, #408]
; 	if (QEKF_INS.gyro_norm < 0.3f && QEKF_INS.accl_norm > 9.8f - 0.5f &&
 8001ec0: ed9f 7a09    	vldr	s14, [pc, #36]          @ 0x8001ee8 <IMU_QuaternionEKF_Update+0x40c>
 8001ec4: eef4 7ac7    	vcmpe.f32	s15, s14
 8001ec8: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8001ecc: d50e         	bpl	0x8001eec <IMU_QuaternionEKF_Update+0x410> @ imm = #0x1c
; 		QEKF_INS.StableFlag = 1;
 8001ece: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8001ed8 <IMU_QuaternionEKF_Update+0x3fc>
 8001ed0: 2201         	movs	r2, #0x1
 8001ed2: f883 2139    	strb.w	r2, [r3, #0x139]
 8001ed6: e00d         	b	0x8001ef4 <IMU_QuaternionEKF_Update+0x418> @ imm = #0x1a

08001ed8 <$d>:
 8001ed8: 98 0c 00 20  	.word	0x20000c98
 8001edc: 8c 2c 00 20  	.word	0x20002c8c
 8001ee0: 9a 99 99 3e  	.word	0x3e99999a
 8001ee4: cd cc 14 41  	.word	0x4114cccd
 8001ee8: cd cc 24 41  	.word	0x4124cccd

08001eec <$t>:
; 		QEKF_INS.StableFlag = 0;
 8001eec: 4bc5         	ldr	r3, [pc, #0x314]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001eee: 2200         	movs	r2, #0x0
 8001ef0: f883 2139    	strb.w	r2, [r3, #0x139]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[0] = QEKF_INS.Q1 * QEKF_INS.dt;
 8001ef4: 4bc3         	ldr	r3, [pc, #0x30c]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001ef6: ed93 7a6c    	vldr	s14, [r3, #432]
 8001efa: 4bc2         	ldr	r3, [pc, #0x308]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001efc: edd3 7a6f    	vldr	s15, [r3, #444]
 8001f00: 4bc0         	ldr	r3, [pc, #0x300]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f02: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001f06: ee67 7a27    	vmul.f32	s15, s14, s15
 8001f0a: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[7] = QEKF_INS.Q1 * QEKF_INS.dt;
 8001f0e: 4bbd         	ldr	r3, [pc, #0x2f4]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f10: ed93 7a6c    	vldr	s14, [r3, #432]
 8001f14: 4bbb         	ldr	r3, [pc, #0x2ec]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f16: edd3 7a6f    	vldr	s15, [r3, #444]
 8001f1a: 4bba         	ldr	r3, [pc, #0x2e8]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f1c: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001f20: 331c         	adds	r3, #0x1c
 8001f22: ee67 7a27    	vmul.f32	s15, s14, s15
 8001f26: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[14] = QEKF_INS.Q1 * QEKF_INS.dt;
 8001f2a: 4bb6         	ldr	r3, [pc, #0x2d8]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f2c: ed93 7a6c    	vldr	s14, [r3, #432]
 8001f30: 4bb4         	ldr	r3, [pc, #0x2d0]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f32: edd3 7a6f    	vldr	s15, [r3, #444]
 8001f36: 4bb3         	ldr	r3, [pc, #0x2cc]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f38: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001f3c: 3338         	adds	r3, #0x38
 8001f3e: ee67 7a27    	vmul.f32	s15, s14, s15
 8001f42: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[21] = QEKF_INS.Q1 * QEKF_INS.dt;
 8001f46: 4baf         	ldr	r3, [pc, #0x2bc]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f48: ed93 7a6c    	vldr	s14, [r3, #432]
 8001f4c: 4bad         	ldr	r3, [pc, #0x2b4]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f4e: edd3 7a6f    	vldr	s15, [r3, #444]
 8001f52: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f54: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001f58: 3354         	adds	r3, #0x54
 8001f5a: ee67 7a27    	vmul.f32	s15, s14, s15
 8001f5e: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[28] = QEKF_INS.Q2 * QEKF_INS.dt;
 8001f62: 4ba8         	ldr	r3, [pc, #0x2a0]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f64: ed93 7a6d    	vldr	s14, [r3, #436]
 8001f68: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f6a: edd3 7a6f    	vldr	s15, [r3, #444]
 8001f6e: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f70: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001f74: 3370         	adds	r3, #0x70
 8001f76: ee67 7a27    	vmul.f32	s15, s14, s15
 8001f7a: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[35] = QEKF_INS.Q2 * QEKF_INS.dt;
 8001f7e: 4ba1         	ldr	r3, [pc, #0x284]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f80: ed93 7a6d    	vldr	s14, [r3, #436]
 8001f84: 4b9f         	ldr	r3, [pc, #0x27c]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f86: edd3 7a6f    	vldr	s15, [r3, #444]
 8001f8a: 4b9e         	ldr	r3, [pc, #0x278]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f8c: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001f90: 338c         	adds	r3, #0x8c
 8001f92: ee67 7a27    	vmul.f32	s15, s14, s15
 8001f96: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.R_data[0] = QEKF_INS.R;
 8001f9a: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001f9c: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8001fa0: 4a98         	ldr	r2, [pc, #0x260]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001fa2: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 8001fa6: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.R_data[4] = QEKF_INS.R;
 8001fa8: 4b96         	ldr	r3, [pc, #0x258]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001faa: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8001fae: 3310         	adds	r3, #0x10
 8001fb0: 4a94         	ldr	r2, [pc, #0x250]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001fb2: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 8001fb6: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.R_data[8] = QEKF_INS.R;
 8001fb8: 4b92         	ldr	r3, [pc, #0x248]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001fba: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8001fbe: 3320         	adds	r3, #0x20
 8001fc0: 4a90         	ldr	r2, [pc, #0x240]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001fc2: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 8001fc6: 601a         	str	r2, [r3]
; 	Kalman_Filter_Update(&QEKF_INS.IMU_QuaternionEKF);
 8001fc8: 488f         	ldr	r0, [pc, #0x23c]        @ 0x8002208 <IMU_QuaternionEKF_Update+0x72c>
 8001fca: f7ff faa5    	bl	0x8001518 <Kalman_Filter_Update> @ imm = #-0xab6
; 	QEKF_INS.q[0] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[0];
 8001fce: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001fd0: 685b         	ldr	r3, [r3, #0x4]
 8001fd2: 681b         	ldr	r3, [r3]
 8001fd4: 4a8b         	ldr	r2, [pc, #0x22c]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001fd6: f8c2 3150    	str.w	r3, [r2, #0x150]
; 	QEKF_INS.q[1] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[1];
 8001fda: 4b8a         	ldr	r3, [pc, #0x228]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001fdc: 685b         	ldr	r3, [r3, #0x4]
 8001fde: 685b         	ldr	r3, [r3, #0x4]
 8001fe0: 4a88         	ldr	r2, [pc, #0x220]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001fe2: f8c2 3154    	str.w	r3, [r2, #0x154]
; 	QEKF_INS.q[2] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[2];
 8001fe6: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001fe8: 685b         	ldr	r3, [r3, #0x4]
 8001fea: 689b         	ldr	r3, [r3, #0x8]
 8001fec: 4a85         	ldr	r2, [pc, #0x214]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001fee: f8c2 3158    	str.w	r3, [r2, #0x158]
; 	QEKF_INS.q[3] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[3];
 8001ff2: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001ff4: 685b         	ldr	r3, [r3, #0x4]
 8001ff6: 68db         	ldr	r3, [r3, #0xc]
 8001ff8: 4a82         	ldr	r2, [pc, #0x208]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8001ffa: f8c2 315c    	str.w	r3, [r2, #0x15c]
; 	QEKF_INS.GyroBias[0] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[4];
 8001ffe: 4b81         	ldr	r3, [pc, #0x204]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002000: 685b         	ldr	r3, [r3, #0x4]
 8002002: 691b         	ldr	r3, [r3, #0x10]
 8002004: 4a7f         	ldr	r2, [pc, #0x1fc]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002006: f8c2 3160    	str.w	r3, [r2, #0x160]
; 	QEKF_INS.GyroBias[1] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[5];
 800200a: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 800200c: 685b         	ldr	r3, [r3, #0x4]
 800200e: 695b         	ldr	r3, [r3, #0x14]
 8002010: 4a7c         	ldr	r2, [pc, #0x1f0]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002012: f8c2 3164    	str.w	r3, [r2, #0x164]
; 	QEKF_INS.GyroBias[2] = 0; // 大部分时候z轴通天,无法观测yaw的漂移
 8002016: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002018: f04f 0200    	mov.w	r2, #0x0
 800201c: f8c3 2168    	str.w	r2, [r3, #0x168]
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[3] + QEKF_INS.q[1] * QEKF_INS.q[2]),
 8002020: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002022: ed93 7a54    	vldr	s14, [r3, #336]
 8002026: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002028: edd3 7a57    	vldr	s15, [r3, #348]
 800202c: ee27 7a27    	vmul.f32	s14, s14, s15
 8002030: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002032: edd3 6a55    	vldr	s13, [r3, #340]
 8002036: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002038: edd3 7a56    	vldr	s15, [r3, #344]
 800203c: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002040: ee77 7a27    	vadd.f32	s15, s14, s15
 8002044: ee37 6aa7    	vadd.f32	s12, s15, s15
; 		       2.0f * (QEKF_INS.q[0] * QEKF_INS.q[0] + QEKF_INS.q[1] * QEKF_INS.q[1]) -
 8002048: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 800204a: ed93 7a54    	vldr	s14, [r3, #336]
 800204e: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002050: edd3 7a54    	vldr	s15, [r3, #336]
 8002054: ee27 7a27    	vmul.f32	s14, s14, s15
 8002058: 4b6a         	ldr	r3, [pc, #0x1a8]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 800205a: edd3 6a55    	vldr	s13, [r3, #340]
 800205e: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002060: edd3 7a55    	vldr	s15, [r3, #340]
 8002064: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002068: ee77 7a27    	vadd.f32	s15, s14, s15
 800206c: ee77 7aa7    	vadd.f32	s15, s15, s15
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[3] + QEKF_INS.q[1] * QEKF_INS.q[2]),
 8002070: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 8002074: ee77 7ac7    	vsub.f32	s15, s15, s14
 8002078: eef0 0a67    	vmov.f32	s1, s15
 800207c: eeb0 0a46    	vmov.f32	s0, s12
 8002080: f016 fec6    	bl	0x8018e10 <atan2f>      @ imm = #0x16d8c
 8002084: eef0 7a40    	vmov.f32	s15, s0
; 			       1.0f) *
 8002088: ed9f 7a60    	vldr	s14, [pc, #384]         @ 0x800220c <IMU_QuaternionEKF_Update+0x730>
 800208c: ee67 7a87    	vmul.f32	s15, s15, s14
; 	QEKF_INS.Yaw =
 8002090: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002092: edc3 7a6a    	vstr	s15, [r3, #424]
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[1] + QEKF_INS.q[2] * QEKF_INS.q[3]),
 8002096: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002098: ed93 7a54    	vldr	s14, [r3, #336]
 800209c: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 800209e: edd3 7a55    	vldr	s15, [r3, #340]
 80020a2: ee27 7a27    	vmul.f32	s14, s14, s15
 80020a6: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80020a8: edd3 6a56    	vldr	s13, [r3, #344]
 80020ac: 4b55         	ldr	r3, [pc, #0x154]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80020ae: edd3 7a57    	vldr	s15, [r3, #348]
 80020b2: ee66 7aa7    	vmul.f32	s15, s13, s15
 80020b6: ee77 7a27    	vadd.f32	s15, s14, s15
 80020ba: ee37 6aa7    	vadd.f32	s12, s15, s15
; 		       2.0f * (QEKF_INS.q[0] * QEKF_INS.q[0] + QEKF_INS.q[3] * QEKF_INS.q[3]) -
 80020be: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80020c0: ed93 7a54    	vldr	s14, [r3, #336]
 80020c4: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80020c6: edd3 7a54    	vldr	s15, [r3, #336]
 80020ca: ee27 7a27    	vmul.f32	s14, s14, s15
 80020ce: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80020d0: edd3 6a57    	vldr	s13, [r3, #348]
 80020d4: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80020d6: edd3 7a57    	vldr	s15, [r3, #348]
 80020da: ee66 7aa7    	vmul.f32	s15, s13, s15
 80020de: ee77 7a27    	vadd.f32	s15, s14, s15
 80020e2: ee77 7aa7    	vadd.f32	s15, s15, s15
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[1] + QEKF_INS.q[2] * QEKF_INS.q[3]),
 80020e6: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 80020ea: ee77 7ac7    	vsub.f32	s15, s15, s14
 80020ee: eef0 0a67    	vmov.f32	s1, s15
 80020f2: eeb0 0a46    	vmov.f32	s0, s12
 80020f6: f016 fe8b    	bl	0x8018e10 <atan2f>      @ imm = #0x16d16
 80020fa: eef0 7a40    	vmov.f32	s15, s0
; 			       1.0f) *
 80020fe: ed9f 7a43    	vldr	s14, [pc, #268]         @ 0x800220c <IMU_QuaternionEKF_Update+0x730>
 8002102: ee67 7a87    	vmul.f32	s15, s15, s14
; 	QEKF_INS.Pitch =
 8002106: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002108: edc3 7a69    	vstr	s15, [r3, #420]
; 		asinf(-2.0f * (QEKF_INS.q[1] * QEKF_INS.q[3] - QEKF_INS.q[0] * QEKF_INS.q[2])) *
 800210c: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 800210e: ed93 7a55    	vldr	s14, [r3, #340]
 8002112: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002114: edd3 7a57    	vldr	s15, [r3, #348]
 8002118: ee27 7a27    	vmul.f32	s14, s14, s15
 800211c: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 800211e: edd3 6a54    	vldr	s13, [r3, #336]
 8002122: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002124: edd3 7a56    	vldr	s15, [r3, #344]
 8002128: ee66 7aa7    	vmul.f32	s15, s13, s15
 800212c: ee77 7a67    	vsub.f32	s15, s14, s15
 8002130: eeb8 7a00    	vmov.f32	s14, #-2.000000e+00
 8002134: ee67 7a87    	vmul.f32	s15, s15, s14
 8002138: eeb0 0a67    	vmov.f32	s0, s15
 800213c: f016 fd86    	bl	0x8018c4c <asinf>       @ imm = #0x16b0c
 8002140: eef0 7a40    	vmov.f32	s15, s0
 8002144: ed9f 7a31    	vldr	s14, [pc, #196]         @ 0x800220c <IMU_QuaternionEKF_Update+0x730>
 8002148: ee67 7a87    	vmul.f32	s15, s15, s14
; 	QEKF_INS.Roll =
 800214c: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 800214e: edc3 7a68    	vstr	s15, [r3, #416]
; 	if (QEKF_INS.Yaw - QEKF_INS.YawAngleLast > 180.0f) {
 8002152: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002154: ed93 7a6a    	vldr	s14, [r3, #424]
 8002158: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 800215a: edd3 7a76    	vldr	s15, [r3, #472]
 800215e: ee77 7a67    	vsub.f32	s15, s14, s15
 8002162: ed9f 7a2b    	vldr	s14, [pc, #172]         @ 0x8002210 <IMU_QuaternionEKF_Update+0x734>
 8002166: eef4 7ac7    	vcmpe.f32	s15, s14
 800216a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800216e: dd0a         	ble	0x8002186 <IMU_QuaternionEKF_Update+0x6aa> @ imm = #0x14
; 		QEKF_INS.YawRoundCount--;
 8002170: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002172: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 8002176: b29b         	uxth	r3, r3
 8002178: 3b01         	subs	r3, #0x1
 800217a: b29b         	uxth	r3, r3
 800217c: b21a         	sxth	r2, r3
 800217e: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002180: f8a3 21d4    	strh.w	r2, [r3, #0x1d4]
 8002184: e018         	b	0x80021b8 <IMU_QuaternionEKF_Update+0x6dc> @ imm = #0x30
; 	} else if (QEKF_INS.Yaw - QEKF_INS.YawAngleLast < -180.0f) {
 8002186: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 8002188: ed93 7a6a    	vldr	s14, [r3, #424]
 800218c: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 800218e: edd3 7a76    	vldr	s15, [r3, #472]
 8002192: ee77 7a67    	vsub.f32	s15, s14, s15
 8002196: ed9f 7a1f    	vldr	s14, [pc, #124]         @ 0x8002214 <IMU_QuaternionEKF_Update+0x738>
 800219a: eef4 7ac7    	vcmpe.f32	s15, s14
 800219e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80021a2: d509         	bpl	0x80021b8 <IMU_QuaternionEKF_Update+0x6dc> @ imm = #0x12
; 		QEKF_INS.YawRoundCount++;
 80021a4: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80021a6: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 80021aa: b29b         	uxth	r3, r3
 80021ac: 3301         	adds	r3, #0x1
 80021ae: b29b         	uxth	r3, r3
 80021b0: b21a         	sxth	r2, r3
 80021b2: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80021b4: f8a3 21d4    	strh.w	r2, [r3, #0x1d4]
; 	QEKF_INS.YawTotalAngle = 360.0f * QEKF_INS.YawRoundCount + QEKF_INS.Yaw;
 80021b8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80021ba: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 80021be: ee07 3a90    	vmov	s15, r3
 80021c2: eef8 7ae7    	vcvt.f32.s32	s15, s15
 80021c6: ed9f 7a14    	vldr	s14, [pc, #80]          @ 0x8002218 <IMU_QuaternionEKF_Update+0x73c>
 80021ca: ee27 7a87    	vmul.f32	s14, s15, s14
 80021ce: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80021d0: edd3 7a6a    	vldr	s15, [r3, #424]
 80021d4: ee77 7a27    	vadd.f32	s15, s14, s15
 80021d8: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80021da: edc3 7a6b    	vstr	s15, [r3, #428]
; 	QEKF_INS.YawAngleLast = QEKF_INS.Yaw;
 80021de: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80021e0: f8d3 31a8    	ldr.w	r3, [r3, #0x1a8]
 80021e4: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80021e6: f8c2 31d8    	str.w	r3, [r2, #0x1d8]
; 	QEKF_INS.UpdateCount++; // 初始化低通滤波用,计数测试用
 80021ea: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80021ec: e9d3 2352    	ldrd	r2, r3, [r3, #328]
 80021f0: 1c54         	adds	r4, r2, #0x1
 80021f2: f143 0500    	adc	r5, r3, #0x0
 80021f6: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8002204 <IMU_QuaternionEKF_Update+0x728>
 80021f8: e9c3 4552    	strd	r4, r5, [r3, #328]
; }
 80021fc: bf00         	nop
 80021fe: 3728         	adds	r7, #0x28
 8002200: 46bd         	mov	sp, r7
 8002202: bdb0         	pop	{r4, r5, r7, pc}

08002204 <$d>:
 8002204: 98 0c 00 20  	.word	0x20000c98
 8002208: 9c 0c 00 20  	.word	0x20000c9c
 800220c: e1 2e 65 42  	.word	0x42652ee1
 8002210: 00 00 34 43  	.word	0x43340000
 8002214: 00 00 34 c3  	.word	0xc3340000
 8002218: 00 00 b4 43  	.word	0x43b40000

0800221c <IMU_QuaternionEKF_F_Linearization_P_Fading>:
; {
 800221c: b580         	push	{r7, lr}
 800221e: b084         	sub	sp, #0x10
 8002220: af00         	add	r7, sp, #0x0
 8002222: 6078         	str	r0, [r7, #0x4]
; 	q0 = kf->xhatminus_data[0];
 8002224: 687b         	ldr	r3, [r7, #0x4]
 8002226: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800222a: 681b         	ldr	r3, [r3]
 800222c: 4aa2         	ldr	r2, [pc, #0x288]        @ 0x80024b8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 800222e: 6013         	str	r3, [r2]
; 	q1 = kf->xhatminus_data[1];
 8002230: 687b         	ldr	r3, [r7, #0x4]
 8002232: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002236: 685b         	ldr	r3, [r3, #0x4]
 8002238: 4aa0         	ldr	r2, [pc, #0x280]        @ 0x80024bc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 800223a: 6013         	str	r3, [r2]
; 	q2 = kf->xhatminus_data[2];
 800223c: 687b         	ldr	r3, [r7, #0x4]
 800223e: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002242: 689b         	ldr	r3, [r3, #0x8]
 8002244: 4a9e         	ldr	r2, [pc, #0x278]        @ 0x80024c0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 8002246: 6013         	str	r3, [r2]
; 	q3 = kf->xhatminus_data[3];
 8002248: 687b         	ldr	r3, [r7, #0x4]
 800224a: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800224e: 68db         	ldr	r3, [r3, #0xc]
 8002250: 4a9c         	ldr	r2, [pc, #0x270]        @ 0x80024c4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 8002252: 6013         	str	r3, [r2]
; 	qInvNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
 8002254: 4b98         	ldr	r3, [pc, #0x260]        @ 0x80024b8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 8002256: ed93 7a00    	vldr	s14, [r3]
 800225a: 4b97         	ldr	r3, [pc, #0x25c]        @ 0x80024b8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 800225c: edd3 7a00    	vldr	s15, [r3]
 8002260: ee27 7a27    	vmul.f32	s14, s14, s15
 8002264: 4b95         	ldr	r3, [pc, #0x254]        @ 0x80024bc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 8002266: edd3 6a00    	vldr	s13, [r3]
 800226a: 4b94         	ldr	r3, [pc, #0x250]        @ 0x80024bc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 800226c: edd3 7a00    	vldr	s15, [r3]
 8002270: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002274: ee37 7a27    	vadd.f32	s14, s14, s15
 8002278: 4b91         	ldr	r3, [pc, #0x244]        @ 0x80024c0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 800227a: edd3 6a00    	vldr	s13, [r3]
 800227e: 4b90         	ldr	r3, [pc, #0x240]        @ 0x80024c0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 8002280: edd3 7a00    	vldr	s15, [r3]
 8002284: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002288: ee37 7a27    	vadd.f32	s14, s14, s15
 800228c: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x80024c4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 800228e: edd3 6a00    	vldr	s13, [r3]
 8002292: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x80024c4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 8002294: edd3 7a00    	vldr	s15, [r3]
 8002298: ee66 7aa7    	vmul.f32	s15, s13, s15
 800229c: ee77 7a27    	vadd.f32	s15, s14, s15
 80022a0: eeb0 0a67    	vmov.f32	s0, s15
 80022a4: f000 fd44    	bl	0x8002d30 <invSqrt>     @ imm = #0xa88
 80022a8: eef0 7a40    	vmov.f32	s15, s0
 80022ac: 4b86         	ldr	r3, [pc, #0x218]        @ 0x80024c8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2ac>
 80022ae: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 4; ++i) {
 80022b2: 2300         	movs	r3, #0x0
 80022b4: 73fb         	strb	r3, [r7, #0xf]
 80022b6: e017         	b	0x80022e8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0xcc> @ imm = #0x2e
; 		kf->xhatminus_data[i] *= qInvNorm;
 80022b8: 687b         	ldr	r3, [r7, #0x4]
 80022ba: f8d3 20ec    	ldr.w	r2, [r3, #0xec]
 80022be: 7bfb         	ldrb	r3, [r7, #0xf]
 80022c0: 009b         	lsls	r3, r3, #0x2
 80022c2: 4413         	add	r3, r2
 80022c4: ed93 7a00    	vldr	s14, [r3]
 80022c8: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x80024c8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2ac>
 80022ca: edd3 7a00    	vldr	s15, [r3]
 80022ce: 687b         	ldr	r3, [r7, #0x4]
 80022d0: f8d3 20ec    	ldr.w	r2, [r3, #0xec]
 80022d4: 7bfb         	ldrb	r3, [r7, #0xf]
 80022d6: 009b         	lsls	r3, r3, #0x2
 80022d8: 4413         	add	r3, r2
 80022da: ee67 7a27    	vmul.f32	s15, s14, s15
 80022de: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 4; ++i) {
 80022e2: 7bfb         	ldrb	r3, [r7, #0xf]
 80022e4: 3301         	adds	r3, #0x1
 80022e6: 73fb         	strb	r3, [r7, #0xf]
 80022e8: 7bfb         	ldrb	r3, [r7, #0xf]
 80022ea: 2b03         	cmp	r3, #0x3
 80022ec: d9e4         	bls	0x80022b8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x9c> @ imm = #-0x38
; 	kf->F_data[4] = q1 * QEKF_INS.dt / 2;
 80022ee: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x80024cc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 80022f0: ed93 7a6f    	vldr	s14, [r3, #444]
 80022f4: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x80024bc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 80022f6: edd3 7a00    	vldr	s15, [r3]
 80022fa: ee27 7a27    	vmul.f32	s14, s14, s15
 80022fe: 687b         	ldr	r3, [r7, #0x4]
 8002300: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002304: 3310         	adds	r3, #0x10
 8002306: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 800230a: eec7 7a26    	vdiv.f32	s15, s14, s13
 800230e: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[5] = q2 * QEKF_INS.dt / 2;
 8002312: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x80024cc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002314: ed93 7a6f    	vldr	s14, [r3, #444]
 8002318: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x80024c0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 800231a: edd3 7a00    	vldr	s15, [r3]
 800231e: ee27 7a27    	vmul.f32	s14, s14, s15
 8002322: 687b         	ldr	r3, [r7, #0x4]
 8002324: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002328: 3314         	adds	r3, #0x14
 800232a: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 800232e: eec7 7a26    	vdiv.f32	s15, s14, s13
 8002332: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[10] = -q0 * QEKF_INS.dt / 2;
 8002336: 4b60         	ldr	r3, [pc, #0x180]        @ 0x80024b8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 8002338: edd3 7a00    	vldr	s15, [r3]
 800233c: eeb1 7a67    	vneg.f32	s14, s15
 8002340: 4b62         	ldr	r3, [pc, #0x188]        @ 0x80024cc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002342: edd3 7a6f    	vldr	s15, [r3, #444]
 8002346: ee27 7a27    	vmul.f32	s14, s14, s15
 800234a: 687b         	ldr	r3, [r7, #0x4]
 800234c: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002350: 3328         	adds	r3, #0x28
 8002352: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8002356: eec7 7a26    	vdiv.f32	s15, s14, s13
 800235a: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[11] = q3 * QEKF_INS.dt / 2;
 800235e: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x80024cc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002360: ed93 7a6f    	vldr	s14, [r3, #444]
 8002364: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x80024c4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 8002366: edd3 7a00    	vldr	s15, [r3]
 800236a: ee27 7a27    	vmul.f32	s14, s14, s15
 800236e: 687b         	ldr	r3, [r7, #0x4]
 8002370: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002374: 332c         	adds	r3, #0x2c
 8002376: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 800237a: eec7 7a26    	vdiv.f32	s15, s14, s13
 800237e: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[16] = -q3 * QEKF_INS.dt / 2;
 8002382: 4b50         	ldr	r3, [pc, #0x140]        @ 0x80024c4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 8002384: edd3 7a00    	vldr	s15, [r3]
 8002388: eeb1 7a67    	vneg.f32	s14, s15
 800238c: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x80024cc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 800238e: edd3 7a6f    	vldr	s15, [r3, #444]
 8002392: ee27 7a27    	vmul.f32	s14, s14, s15
 8002396: 687b         	ldr	r3, [r7, #0x4]
 8002398: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 800239c: 3340         	adds	r3, #0x40
 800239e: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 80023a2: eec7 7a26    	vdiv.f32	s15, s14, s13
 80023a6: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[17] = -q0 * QEKF_INS.dt / 2;
 80023aa: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x80024b8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 80023ac: edd3 7a00    	vldr	s15, [r3]
 80023b0: eeb1 7a67    	vneg.f32	s14, s15
 80023b4: 4b45         	ldr	r3, [pc, #0x114]        @ 0x80024cc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 80023b6: edd3 7a6f    	vldr	s15, [r3, #444]
 80023ba: ee27 7a27    	vmul.f32	s14, s14, s15
 80023be: 687b         	ldr	r3, [r7, #0x4]
 80023c0: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80023c4: 3344         	adds	r3, #0x44
 80023c6: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 80023ca: eec7 7a26    	vdiv.f32	s15, s14, s13
 80023ce: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[22] = q2 * QEKF_INS.dt / 2;
 80023d2: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x80024cc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 80023d4: ed93 7a6f    	vldr	s14, [r3, #444]
 80023d8: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x80024c0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 80023da: edd3 7a00    	vldr	s15, [r3]
 80023de: ee27 7a27    	vmul.f32	s14, s14, s15
 80023e2: 687b         	ldr	r3, [r7, #0x4]
 80023e4: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 80023e8: 3358         	adds	r3, #0x58
 80023ea: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 80023ee: eec7 7a26    	vdiv.f32	s15, s14, s13
 80023f2: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[23] = -q1 * QEKF_INS.dt / 2;
 80023f6: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80024bc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 80023f8: edd3 7a00    	vldr	s15, [r3]
 80023fc: eeb1 7a67    	vneg.f32	s14, s15
 8002400: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x80024cc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002402: edd3 7a6f    	vldr	s15, [r3, #444]
 8002406: ee27 7a27    	vmul.f32	s14, s14, s15
 800240a: 687b         	ldr	r3, [r7, #0x4]
 800240c: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002410: 335c         	adds	r3, #0x5c
 8002412: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8002416: eec7 7a26    	vdiv.f32	s15, s14, s13
 800241a: edc3 7a00    	vstr	s15, [r3]
; 	kf->P_data[28] /= QEKF_INS.lambda;
 800241e: 687b         	ldr	r3, [r7, #0x4]
 8002420: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002424: 3370         	adds	r3, #0x70
 8002426: edd3 6a00    	vldr	s13, [r3]
 800242a: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x80024cc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 800242c: ed93 7a74    	vldr	s14, [r3, #464]
 8002430: 687b         	ldr	r3, [r7, #0x4]
 8002432: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002436: 3370         	adds	r3, #0x70
 8002438: eec6 7a87    	vdiv.f32	s15, s13, s14
 800243c: edc3 7a00    	vstr	s15, [r3]
; 	kf->P_data[35] /= QEKF_INS.lambda;
 8002440: 687b         	ldr	r3, [r7, #0x4]
 8002442: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002446: 338c         	adds	r3, #0x8c
 8002448: edd3 6a00    	vldr	s13, [r3]
 800244c: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80024cc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 800244e: ed93 7a74    	vldr	s14, [r3, #464]
 8002452: 687b         	ldr	r3, [r7, #0x4]
 8002454: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002458: 338c         	adds	r3, #0x8c
 800245a: eec6 7a87    	vdiv.f32	s15, s13, s14
 800245e: edc3 7a00    	vstr	s15, [r3]
; 	if (kf->P_data[28] > 10000) {
 8002462: 687b         	ldr	r3, [r7, #0x4]
 8002464: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002468: 3370         	adds	r3, #0x70
 800246a: edd3 7a00    	vldr	s15, [r3]
 800246e: ed9f 7a18    	vldr	s14, [pc, #96]          @ 0x80024d0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b4>
 8002472: eef4 7ac7    	vcmpe.f32	s15, s14
 8002476: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800247a: dd05         	ble	0x8002488 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x26c> @ imm = #0xa
; 		kf->P_data[28] = 10000;
 800247c: 687b         	ldr	r3, [r7, #0x4]
 800247e: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002482: 3370         	adds	r3, #0x70
 8002484: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x80024d4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b8>
 8002486: 601a         	str	r2, [r3]
; 	if (kf->P_data[35] > 10000) {
 8002488: 687b         	ldr	r3, [r7, #0x4]
 800248a: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 800248e: 338c         	adds	r3, #0x8c
 8002490: edd3 7a00    	vldr	s15, [r3]
 8002494: ed9f 7a0e    	vldr	s14, [pc, #56]          @ 0x80024d0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b4>
 8002498: eef4 7ac7    	vcmpe.f32	s15, s14
 800249c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80024a0: dc00         	bgt	0x80024a4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x288> @ imm = #0x0
; }
 80024a2: e005         	b	0x80024b0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x294> @ imm = #0xa
; 		kf->P_data[35] = 10000;
 80024a4: 687b         	ldr	r3, [r7, #0x4]
 80024a6: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 80024aa: 338c         	adds	r3, #0x8c
 80024ac: 4a09         	ldr	r2, [pc, #0x24]         @ 0x80024d4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b8>
 80024ae: 601a         	str	r2, [r3]
; }
 80024b0: bf00         	nop
 80024b2: 3710         	adds	r7, #0x10
 80024b4: 46bd         	mov	sp, r7
 80024b6: bd80         	pop	{r7, pc}

080024b8 <$d>:
 80024b8: 90 2c 00 20  	.word	0x20002c90
 80024bc: 94 2c 00 20  	.word	0x20002c94
 80024c0: 98 2c 00 20  	.word	0x20002c98
 80024c4: 9c 2c 00 20  	.word	0x20002c9c
 80024c8: a0 2c 00 20  	.word	0x20002ca0
 80024cc: 98 0c 00 20  	.word	0x20000c98
 80024d0: 00 40 1c 46  	.word	0x461c4000
 80024d4: 00 40 1c 46  	.word	0x461c4000

080024d8 <IMU_QuaternionEKF_SetH>:
; {
 80024d8: b580         	push	{r7, lr}
 80024da: b082         	sub	sp, #0x8
 80024dc: af00         	add	r7, sp, #0x0
 80024de: 6078         	str	r0, [r7, #0x4]
; 	doubleq0 = 2 * kf->xhatminus_data[0];
 80024e0: 687b         	ldr	r3, [r7, #0x4]
 80024e2: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 80024e6: edd3 7a00    	vldr	s15, [r3]
 80024ea: ee77 7aa7    	vadd.f32	s15, s15, s15
 80024ee: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8002628 <IMU_QuaternionEKF_SetH+0x150>
 80024f0: edc3 7a00    	vstr	s15, [r3]
; 	doubleq1 = 2 * kf->xhatminus_data[1];
 80024f4: 687b         	ldr	r3, [r7, #0x4]
 80024f6: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 80024fa: 3304         	adds	r3, #0x4
 80024fc: edd3 7a00    	vldr	s15, [r3]
 8002500: ee77 7aa7    	vadd.f32	s15, s15, s15
 8002504: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800262c <IMU_QuaternionEKF_SetH+0x154>
 8002506: edc3 7a00    	vstr	s15, [r3]
; 	doubleq2 = 2 * kf->xhatminus_data[2];
 800250a: 687b         	ldr	r3, [r7, #0x4]
 800250c: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002510: 3308         	adds	r3, #0x8
 8002512: edd3 7a00    	vldr	s15, [r3]
 8002516: ee77 7aa7    	vadd.f32	s15, s15, s15
 800251a: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8002630 <IMU_QuaternionEKF_SetH+0x158>
 800251c: edc3 7a00    	vstr	s15, [r3]
; 	doubleq3 = 2 * kf->xhatminus_data[3];
 8002520: 687b         	ldr	r3, [r7, #0x4]
 8002522: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002526: 330c         	adds	r3, #0xc
 8002528: edd3 7a00    	vldr	s15, [r3]
 800252c: ee77 7aa7    	vadd.f32	s15, s15, s15
 8002530: 4b40         	ldr	r3, [pc, #0x100]        @ 0x8002634 <IMU_QuaternionEKF_SetH+0x15c>
 8002532: edc3 7a00    	vstr	s15, [r3]
; 	memset(kf->H_data, 0, sizeof_float * kf->zSize * kf->xhatSize);
 8002536: 687b         	ldr	r3, [r7, #0x4]
 8002538: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 800253c: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8002638 <IMU_QuaternionEKF_SetH+0x160>
 800253e: 881b         	ldrh	r3, [r3]
 8002540: 461a         	mov	r2, r3
 8002542: 687b         	ldr	r3, [r7, #0x4]
 8002544: 7b9b         	ldrb	r3, [r3, #0xe]
 8002546: fb02 f303    	mul	r3, r2, r3
 800254a: 687a         	ldr	r2, [r7, #0x4]
 800254c: 7b12         	ldrb	r2, [r2, #0xc]
 800254e: fb02 f303    	mul	r3, r2, r3
 8002552: 461a         	mov	r2, r3
 8002554: 2100         	movs	r1, #0x0
 8002556: f024 ffd7    	bl	0x8027508 <memset>      @ imm = #0x24fae
; 	kf->H_data[0] = -doubleq2;
 800255a: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8002630 <IMU_QuaternionEKF_SetH+0x158>
 800255c: edd3 7a00    	vldr	s15, [r3]
 8002560: 687b         	ldr	r3, [r7, #0x4]
 8002562: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002566: eef1 7a67    	vneg.f32	s15, s15
 800256a: edc3 7a00    	vstr	s15, [r3]
; 	kf->H_data[1] = doubleq3;
 800256e: 687b         	ldr	r3, [r7, #0x4]
 8002570: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002574: 3304         	adds	r3, #0x4
 8002576: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x8002634 <IMU_QuaternionEKF_SetH+0x15c>
 8002578: 6812         	ldr	r2, [r2]
 800257a: 601a         	str	r2, [r3]
; 	kf->H_data[2] = -doubleq0;
 800257c: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8002628 <IMU_QuaternionEKF_SetH+0x150>
 800257e: edd3 7a00    	vldr	s15, [r3]
 8002582: 687b         	ldr	r3, [r7, #0x4]
 8002584: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002588: 3308         	adds	r3, #0x8
 800258a: eef1 7a67    	vneg.f32	s15, s15
 800258e: edc3 7a00    	vstr	s15, [r3]
; 	kf->H_data[3] = doubleq1;
 8002592: 687b         	ldr	r3, [r7, #0x4]
 8002594: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002598: 330c         	adds	r3, #0xc
 800259a: 4a24         	ldr	r2, [pc, #0x90]         @ 0x800262c <IMU_QuaternionEKF_SetH+0x154>
 800259c: 6812         	ldr	r2, [r2]
 800259e: 601a         	str	r2, [r3]
; 	kf->H_data[6] = doubleq1;
 80025a0: 687b         	ldr	r3, [r7, #0x4]
 80025a2: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025a6: 3318         	adds	r3, #0x18
 80025a8: 4a20         	ldr	r2, [pc, #0x80]         @ 0x800262c <IMU_QuaternionEKF_SetH+0x154>
 80025aa: 6812         	ldr	r2, [r2]
 80025ac: 601a         	str	r2, [r3]
; 	kf->H_data[7] = doubleq0;
 80025ae: 687b         	ldr	r3, [r7, #0x4]
 80025b0: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025b4: 331c         	adds	r3, #0x1c
 80025b6: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x8002628 <IMU_QuaternionEKF_SetH+0x150>
 80025b8: 6812         	ldr	r2, [r2]
 80025ba: 601a         	str	r2, [r3]
; 	kf->H_data[8] = doubleq3;
 80025bc: 687b         	ldr	r3, [r7, #0x4]
 80025be: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025c2: 3320         	adds	r3, #0x20
 80025c4: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8002634 <IMU_QuaternionEKF_SetH+0x15c>
 80025c6: 6812         	ldr	r2, [r2]
 80025c8: 601a         	str	r2, [r3]
; 	kf->H_data[9] = doubleq2;
 80025ca: 687b         	ldr	r3, [r7, #0x4]
 80025cc: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025d0: 3324         	adds	r3, #0x24
 80025d2: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8002630 <IMU_QuaternionEKF_SetH+0x158>
 80025d4: 6812         	ldr	r2, [r2]
 80025d6: 601a         	str	r2, [r3]
; 	kf->H_data[12] = doubleq0;
 80025d8: 687b         	ldr	r3, [r7, #0x4]
 80025da: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025de: 3330         	adds	r3, #0x30
 80025e0: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8002628 <IMU_QuaternionEKF_SetH+0x150>
 80025e2: 6812         	ldr	r2, [r2]
 80025e4: 601a         	str	r2, [r3]
; 	kf->H_data[13] = -doubleq1;
 80025e6: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800262c <IMU_QuaternionEKF_SetH+0x154>
 80025e8: edd3 7a00    	vldr	s15, [r3]
 80025ec: 687b         	ldr	r3, [r7, #0x4]
 80025ee: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80025f2: 3334         	adds	r3, #0x34
 80025f4: eef1 7a67    	vneg.f32	s15, s15
 80025f8: edc3 7a00    	vstr	s15, [r3]
; 	kf->H_data[14] = -doubleq2;
 80025fc: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8002630 <IMU_QuaternionEKF_SetH+0x158>
 80025fe: edd3 7a00    	vldr	s15, [r3]
 8002602: 687b         	ldr	r3, [r7, #0x4]
 8002604: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002608: 3338         	adds	r3, #0x38
 800260a: eef1 7a67    	vneg.f32	s15, s15
 800260e: edc3 7a00    	vstr	s15, [r3]
; 	kf->H_data[15] = doubleq3;
 8002612: 687b         	ldr	r3, [r7, #0x4]
 8002614: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002618: 333c         	adds	r3, #0x3c
 800261a: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8002634 <IMU_QuaternionEKF_SetH+0x15c>
 800261c: 6812         	ldr	r2, [r2]
 800261e: 601a         	str	r2, [r3]
; }
 8002620: bf00         	nop
 8002622: 3708         	adds	r7, #0x8
 8002624: 46bd         	mov	sp, r7
 8002626: bd80         	pop	{r7, pc}

08002628 <$d>:
 8002628: a4 2c 00 20  	.word	0x20002ca4
 800262c: a8 2c 00 20  	.word	0x20002ca8
 8002630: ac 2c 00 20  	.word	0x20002cac
 8002634: b0 2c 00 20  	.word	0x20002cb0
 8002638: 00 33 00 20  	.word	0x20003300

0800263c <IMU_QuaternionEKF_xhatUpdate>:
; {
 800263c: b5f0         	push	{r4, r5, r6, r7, lr}
 800263e: b087         	sub	sp, #0x1c
 8002640: af00         	add	r7, sp, #0x0
 8002642: 6078         	str	r0, [r7, #0x4]
; 	kf->MatStatus = Matrix_Transpose(&kf->H, &kf->HT); // z|x => x|z
 8002644: 687b         	ldr	r3, [r7, #0x4]
 8002646: f103 0278    	add.w	r2, r3, #0x78
 800264a: 687b         	ldr	r3, [r7, #0x4]
 800264c: 3380         	adds	r3, #0x80
 800264e: 4619         	mov	r1, r3
 8002650: 4610         	mov	r0, r2
 8002652: f010 f8c9    	bl	0x80127e8 <arm_mat_trans_f32> @ imm = #0x10192
 8002656: 4603         	mov	r3, r0
 8002658: 461a         	mov	r2, r3
 800265a: 687b         	ldr	r3, [r7, #0x4]
 800265c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix.numRows = kf->H.numRows;
 8002660: 687b         	ldr	r3, [r7, #0x4]
 8002662: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 8002666: 687b         	ldr	r3, [r7, #0x4]
 8002668: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = kf->Pminus.numCols;
 800266c: 687b         	ldr	r3, [r7, #0x4]
 800266e: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 8002672: 687b         	ldr	r3, [r7, #0x4]
 8002674: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		Matrix_Multiply(&kf->H, &kf->Pminus, &kf->temp_matrix); // temp_matrix = H·P'(k)
 8002678: 687b         	ldr	r3, [r7, #0x4]
 800267a: f103 0078    	add.w	r0, r3, #0x78
 800267e: 687b         	ldr	r3, [r7, #0x4]
 8002680: f103 0158    	add.w	r1, r3, #0x58
 8002684: 687b         	ldr	r3, [r7, #0x4]
 8002686: 33a8         	adds	r3, #0xa8
 8002688: 461a         	mov	r2, r3
 800268a: f010 f83d    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #0x1007a
 800268e: 4603         	mov	r3, r0
 8002690: 461a         	mov	r2, r3
; 	kf->MatStatus =
 8002692: 687b         	ldr	r3, [r7, #0x4]
 8002694: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 8002698: 687b         	ldr	r3, [r7, #0x4]
 800269a: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 800269e: 687b         	ldr	r3, [r7, #0x4]
 80026a0: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 	kf->temp_matrix1.numCols = kf->HT.numCols;
 80026a4: 687b         	ldr	r3, [r7, #0x4]
 80026a6: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 80026aa: 687b         	ldr	r3, [r7, #0x4]
 80026ac: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->HT,
 80026b0: 687b         	ldr	r3, [r7, #0x4]
 80026b2: f103 00a8    	add.w	r0, r3, #0xa8
 80026b6: 687b         	ldr	r3, [r7, #0x4]
 80026b8: f103 0180    	add.w	r1, r3, #0x80
 80026bc: 687b         	ldr	r3, [r7, #0x4]
 80026be: 33b0         	adds	r3, #0xb0
 80026c0: 461a         	mov	r2, r3
 80026c2: f010 f821    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #0x10042
 80026c6: 4603         	mov	r3, r0
 80026c8: 461a         	mov	r2, r3
 80026ca: 687b         	ldr	r3, [r7, #0x4]
 80026cc: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->S.numRows = kf->R.numRows;
 80026d0: 687b         	ldr	r3, [r7, #0x4]
 80026d2: f8b3 2090    	ldrh.w	r2, [r3, #0x90]
 80026d6: 687b         	ldr	r3, [r7, #0x4]
 80026d8: f8a3 20a0    	strh.w	r2, [r3, #0xa0]
; 	kf->S.numCols = kf->R.numCols;
 80026dc: 687b         	ldr	r3, [r7, #0x4]
 80026de: f8b3 2092    	ldrh.w	r2, [r3, #0x92]
 80026e2: 687b         	ldr	r3, [r7, #0x4]
 80026e4: f8a3 20a2    	strh.w	r2, [r3, #0xa2]
; 	kf->MatStatus = Matrix_Add(&kf->temp_matrix1, &kf->R, &kf->S); // S = H P'(k) HT + R
 80026e8: 687b         	ldr	r3, [r7, #0x4]
 80026ea: f103 00b0    	add.w	r0, r3, #0xb0
 80026ee: 687b         	ldr	r3, [r7, #0x4]
 80026f0: f103 0190    	add.w	r1, r3, #0x90
 80026f4: 687b         	ldr	r3, [r7, #0x4]
 80026f6: 33a0         	adds	r3, #0xa0
 80026f8: 461a         	mov	r2, r3
 80026fa: f00f fe69    	bl	0x80123d0 <arm_mat_add_f32> @ imm = #0xfcd2
 80026fe: 4603         	mov	r3, r0
 8002700: 461a         	mov	r2, r3
 8002702: 687b         	ldr	r3, [r7, #0x4]
 8002704: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		Matrix_Inverse(&kf->S, &kf->temp_matrix1); // temp_matrix1 = inv(H·P'(k)·HT + R)
 8002708: 687b         	ldr	r3, [r7, #0x4]
 800270a: f103 02a0    	add.w	r2, r3, #0xa0
 800270e: 687b         	ldr	r3, [r7, #0x4]
 8002710: 33b0         	adds	r3, #0xb0
 8002712: 4619         	mov	r1, r3
 8002714: 4610         	mov	r0, r2
 8002716: f00f fe75    	bl	0x8012404 <arm_mat_inverse_f32> @ imm = #0xfcea
 800271a: 4603         	mov	r3, r0
 800271c: 461a         	mov	r2, r3
; 	kf->MatStatus =
 800271e: 687b         	ldr	r3, [r7, #0x4]
 8002720: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	q0 = kf->xhatminus_data[0];
 8002724: 687b         	ldr	r3, [r7, #0x4]
 8002726: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800272a: 681b         	ldr	r3, [r3]
 800272c: 4ab8         	ldr	r2, [pc, #0x2e0]        @ 0x8002a10 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 800272e: 6013         	str	r3, [r2]
; 	q1 = kf->xhatminus_data[1];
 8002730: 687b         	ldr	r3, [r7, #0x4]
 8002732: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002736: 685b         	ldr	r3, [r3, #0x4]
 8002738: 4ab6         	ldr	r2, [pc, #0x2d8]        @ 0x8002a14 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 800273a: 6013         	str	r3, [r2]
; 	q2 = kf->xhatminus_data[2];
 800273c: 687b         	ldr	r3, [r7, #0x4]
 800273e: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002742: 689b         	ldr	r3, [r3, #0x8]
 8002744: 4ab4         	ldr	r2, [pc, #0x2d0]        @ 0x8002a18 <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 8002746: 6013         	str	r3, [r2]
; 	q3 = kf->xhatminus_data[3];
 8002748: 687b         	ldr	r3, [r7, #0x4]
 800274a: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800274e: 68db         	ldr	r3, [r3, #0xc]
 8002750: 4ab2         	ldr	r2, [pc, #0x2c8]        @ 0x8002a1c <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 8002752: 6013         	str	r3, [r2]
; 	kf->temp_vector.numRows = kf->H.numRows;
 8002754: 687b         	ldr	r3, [r7, #0x4]
 8002756: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 800275a: 687b         	ldr	r3, [r7, #0x4]
 800275c: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = 1;
 8002760: 687b         	ldr	r3, [r7, #0x4]
 8002762: 2201         	movs	r2, #0x1
 8002764: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->temp_vector_data[0] = 2 * (q1 * q3 - q0 * q2);
 8002768: 4baa         	ldr	r3, [pc, #0x2a8]        @ 0x8002a14 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 800276a: ed93 7a00    	vldr	s14, [r3]
 800276e: 4bab         	ldr	r3, [pc, #0x2ac]        @ 0x8002a1c <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 8002770: edd3 7a00    	vldr	s15, [r3]
 8002774: ee27 7a27    	vmul.f32	s14, s14, s15
 8002778: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8002a10 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 800277a: edd3 6a00    	vldr	s13, [r3]
 800277e: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8002a18 <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 8002780: edd3 7a00    	vldr	s15, [r3]
 8002784: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002788: ee77 7a67    	vsub.f32	s15, s14, s15
 800278c: 687b         	ldr	r3, [r7, #0x4]
 800278e: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 8002792: ee77 7aa7    	vadd.f32	s15, s15, s15
 8002796: edc3 7a00    	vstr	s15, [r3]
; 	kf->temp_vector_data[1] = 2 * (q0 * q1 + q2 * q3);
 800279a: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x8002a10 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 800279c: ed93 7a00    	vldr	s14, [r3]
 80027a0: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8002a14 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 80027a2: edd3 7a00    	vldr	s15, [r3]
 80027a6: ee27 7a27    	vmul.f32	s14, s14, s15
 80027aa: 4b9b         	ldr	r3, [pc, #0x26c]        @ 0x8002a18 <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 80027ac: edd3 6a00    	vldr	s13, [r3]
 80027b0: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x8002a1c <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 80027b2: edd3 7a00    	vldr	s15, [r3]
 80027b6: ee66 7aa7    	vmul.f32	s15, s13, s15
 80027ba: ee77 7a27    	vadd.f32	s15, s14, s15
 80027be: 687b         	ldr	r3, [r7, #0x4]
 80027c0: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 80027c4: 3304         	adds	r3, #0x4
 80027c6: ee77 7aa7    	vadd.f32	s15, s15, s15
 80027ca: edc3 7a00    	vstr	s15, [r3]
; 		q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3; // temp_vector = h(xhat'(k))
 80027ce: 4b90         	ldr	r3, [pc, #0x240]        @ 0x8002a10 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 80027d0: ed93 7a00    	vldr	s14, [r3]
 80027d4: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8002a10 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 80027d6: edd3 7a00    	vldr	s15, [r3]
 80027da: ee27 7a27    	vmul.f32	s14, s14, s15
 80027de: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8002a14 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 80027e0: edd3 6a00    	vldr	s13, [r3]
 80027e4: 4b8b         	ldr	r3, [pc, #0x22c]        @ 0x8002a14 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 80027e6: edd3 7a00    	vldr	s15, [r3]
 80027ea: ee66 7aa7    	vmul.f32	s15, s13, s15
 80027ee: ee37 7a67    	vsub.f32	s14, s14, s15
 80027f2: 4b89         	ldr	r3, [pc, #0x224]        @ 0x8002a18 <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 80027f4: edd3 6a00    	vldr	s13, [r3]
 80027f8: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8002a18 <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 80027fa: edd3 7a00    	vldr	s15, [r3]
 80027fe: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002802: ee37 7a67    	vsub.f32	s14, s14, s15
 8002806: 4b85         	ldr	r3, [pc, #0x214]        @ 0x8002a1c <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 8002808: edd3 6a00    	vldr	s13, [r3]
 800280c: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x8002a1c <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 800280e: edd3 7a00    	vldr	s15, [r3]
 8002812: ee66 7aa7    	vmul.f32	s15, s13, s15
; 	kf->temp_vector_data[2] =
 8002816: 687b         	ldr	r3, [r7, #0x4]
 8002818: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 800281c: 3308         	adds	r3, #0x8
; 		q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3; // temp_vector = h(xhat'(k))
 800281e: ee77 7a27    	vadd.f32	s15, s14, s15
; 	kf->temp_vector_data[2] =
 8002822: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 3; ++i) {
 8002826: 2300         	movs	r3, #0x0
 8002828: 75fb         	strb	r3, [r7, #0x17]
 800282a: e021         	b	0x8002870 <IMU_QuaternionEKF_xhatUpdate+0x234> @ imm = #0x42
; 		QEKF_INS.OrientationCosine[i] = acosf(fabsf(kf->temp_vector_data[i]));
 800282c: 687b         	ldr	r3, [r7, #0x4]
 800282e: f8d3 212c    	ldr.w	r2, [r3, #0x12c]
 8002832: 7dfb         	ldrb	r3, [r7, #0x17]
 8002834: 009b         	lsls	r3, r3, #0x2
 8002836: 4413         	add	r3, r2
 8002838: 681b         	ldr	r3, [r3]
 800283a: 60fb         	str	r3, [r7, #0xc]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 800283c: edd7 7a03    	vldr	s15, [r7, #12]
 8002840: eef0 7ae7    	vabs.f32	s15, s15
 8002844: edc7 7a02    	vstr	s15, [r7, #8]
;     return result;
 8002848: edd7 7a02    	vldr	s15, [r7, #8]
; 		QEKF_INS.OrientationCosine[i] = acosf(fabsf(kf->temp_vector_data[i]));
 800284c: 7dfe         	ldrb	r6, [r7, #0x17]
 800284e: eeb0 0a67    	vmov.f32	s0, s15
 8002852: f016 f90d    	bl	0x8018a70 <acosf>       @ imm = #0x1621a
 8002856: eef0 7a40    	vmov.f32	s15, s0
 800285a: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800285c: f106 0360    	add.w	r3, r6, #0x60
 8002860: 009b         	lsls	r3, r3, #0x2
 8002862: 4413         	add	r3, r2
 8002864: 3304         	adds	r3, #0x4
 8002866: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 3; ++i) {
 800286a: 7dfb         	ldrb	r3, [r7, #0x17]
 800286c: 3301         	adds	r3, #0x1
 800286e: 75fb         	strb	r3, [r7, #0x17]
 8002870: 7dfb         	ldrb	r3, [r7, #0x17]
 8002872: 2b02         	cmp	r3, #0x2
 8002874: d9da         	bls	0x800282c <IMU_QuaternionEKF_xhatUpdate+0x1f0> @ imm = #-0x4c
; 	kf->temp_vector1.numRows = kf->z.numRows;
 8002876: 687b         	ldr	r3, [r7, #0x4]
 8002878: f8b3 2048    	ldrh.w	r2, [r3, #0x48]
 800287c: 687b         	ldr	r3, [r7, #0x4]
 800287e: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 	kf->temp_vector1.numCols = 1;
 8002882: 687b         	ldr	r3, [r7, #0x4]
 8002884: 2201         	movs	r2, #0x1
 8002886: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 	kf->MatStatus = Matrix_Subtract(&kf->z, &kf->temp_vector,
 800288a: 687b         	ldr	r3, [r7, #0x4]
 800288c: f103 0048    	add.w	r0, r3, #0x48
 8002890: 687b         	ldr	r3, [r7, #0x4]
 8002892: f103 01b8    	add.w	r1, r3, #0xb8
 8002896: 687b         	ldr	r3, [r7, #0x4]
 8002898: 33c0         	adds	r3, #0xc0
 800289a: 461a         	mov	r2, r3
 800289c: f00f ff8e    	bl	0x80127bc <arm_mat_sub_f32> @ imm = #0xff1c
 80028a0: 4603         	mov	r3, r0
 80028a2: 461a         	mov	r2, r3
 80028a4: 687b         	ldr	r3, [r7, #0x4]
 80028a6: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix.numRows = kf->temp_vector1.numRows;
 80028aa: 687b         	ldr	r3, [r7, #0x4]
 80028ac: f8b3 20c0    	ldrh.w	r2, [r3, #0xc0]
 80028b0: 687b         	ldr	r3, [r7, #0x4]
 80028b2: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = 1;
 80028b6: 687b         	ldr	r3, [r7, #0x4]
 80028b8: 2201         	movs	r2, #0x1
 80028ba: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		&kf->temp_matrix1, &kf->temp_vector1,
 80028be: 687b         	ldr	r3, [r7, #0x4]
 80028c0: f103 00b0    	add.w	r0, r3, #0xb0
 80028c4: 687b         	ldr	r3, [r7, #0x4]
 80028c6: f103 01c0    	add.w	r1, r3, #0xc0
; 	kf->MatStatus = Matrix_Multiply(
 80028ca: 687b         	ldr	r3, [r7, #0x4]
 80028cc: 33a8         	adds	r3, #0xa8
 80028ce: 461a         	mov	r2, r3
 80028d0: f00f ff1a    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #0xfe34
 80028d4: 4603         	mov	r3, r0
 80028d6: 461a         	mov	r2, r3
 80028d8: 687b         	ldr	r3, [r7, #0x4]
 80028da: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_vector.numRows = 1;
 80028de: 687b         	ldr	r3, [r7, #0x4]
 80028e0: 2201         	movs	r2, #0x1
 80028e2: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = kf->temp_vector1.numRows;
 80028e6: 687b         	ldr	r3, [r7, #0x4]
 80028e8: f8b3 20c0    	ldrh.w	r2, [r3, #0xc0]
 80028ec: 687b         	ldr	r3, [r7, #0x4]
 80028ee: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->MatStatus = Matrix_Transpose(&kf->temp_vector1,
 80028f2: 687b         	ldr	r3, [r7, #0x4]
 80028f4: f103 02c0    	add.w	r2, r3, #0xc0
 80028f8: 687b         	ldr	r3, [r7, #0x4]
 80028fa: 33b8         	adds	r3, #0xb8
 80028fc: 4619         	mov	r1, r3
 80028fe: 4610         	mov	r0, r2
 8002900: f00f ff72    	bl	0x80127e8 <arm_mat_trans_f32> @ imm = #0xfee4
 8002904: 4603         	mov	r3, r0
 8002906: 461a         	mov	r2, r3
 8002908: 687b         	ldr	r3, [r7, #0x4]
 800290a: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_vector, &kf->temp_matrix, &QEKF_INS.ChiSquare);
 800290e: 687b         	ldr	r3, [r7, #0x4]
 8002910: f103 00b8    	add.w	r0, r3, #0xb8
 8002914: 687b         	ldr	r3, [r7, #0x4]
 8002916: 33a8         	adds	r3, #0xa8
 8002918: 4a42         	ldr	r2, [pc, #0x108]        @ 0x8002a24 <IMU_QuaternionEKF_xhatUpdate+0x3e8>
 800291a: 4619         	mov	r1, r3
 800291c: f00f fef4    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #0xfde8
 8002920: 4603         	mov	r3, r0
 8002922: 461a         	mov	r2, r3
 8002924: 687b         	ldr	r3, [r7, #0x4]
 8002926: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	if (QEKF_INS.ChiSquare_Data[0] < 0.5f * QEKF_INS.ChiSquareTestThreshold) {
 800292a: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800292c: ed93 7a72    	vldr	s14, [r3, #456]
 8002930: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8002932: edd3 7a73    	vldr	s15, [r3, #460]
 8002936: eef6 6a00    	vmov.f32	s13, #5.000000e-01
 800293a: ee67 7aa6    	vmul.f32	s15, s15, s13
 800293e: eeb4 7ae7    	vcmpe.f32	s14, s15
 8002942: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002946: d503         	bpl	0x8002950 <IMU_QuaternionEKF_xhatUpdate+0x314> @ imm = #0x6
; 		QEKF_INS.ConvergeFlag = 1;
 8002948: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800294a: 2201         	movs	r2, #0x1
 800294c: f883 2138    	strb.w	r2, [r3, #0x138]
; 	if (QEKF_INS.ChiSquare_Data[0] > QEKF_INS.ChiSquareTestThreshold && QEKF_INS.ConvergeFlag) {
 8002950: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8002952: ed93 7a72    	vldr	s14, [r3, #456]
 8002956: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8002958: edd3 7a73    	vldr	s15, [r3, #460]
 800295c: eeb4 7ae7    	vcmpe.f32	s14, s15
 8002960: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002964: dd62         	ble	0x8002a2c <IMU_QuaternionEKF_xhatUpdate+0x3f0> @ imm = #0xc4
 8002966: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8002968: f893 3138    	ldrb.w	r3, [r3, #0x138]
 800296c: 2b00         	cmp	r3, #0x0
 800296e: d05d         	beq	0x8002a2c <IMU_QuaternionEKF_xhatUpdate+0x3f0> @ imm = #0xba
; 		if (QEKF_INS.StableFlag) {
 8002970: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8002972: f893 3139    	ldrb.w	r3, [r3, #0x139]
 8002976: 2b00         	cmp	r3, #0x0
 8002978: d009         	beq	0x800298e <IMU_QuaternionEKF_xhatUpdate+0x352> @ imm = #0x12
; 			QEKF_INS.ErrorCount++; // 载体静止时仍无法通过卡方检验
 800297a: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800297c: e9d3 2350    	ldrd	r2, r3, [r3, #320]
 8002980: 1c54         	adds	r4, r2, #0x1
 8002982: f143 0500    	adc	r5, r3, #0x0
 8002986: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8002988: e9c3 4550    	strd	r4, r5, [r3, #320]
 800298c: e006         	b	0x800299c <IMU_QuaternionEKF_xhatUpdate+0x360> @ imm = #0xc
; 			QEKF_INS.ErrorCount = 0;
 800298e: 4924         	ldr	r1, [pc, #0x90]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8002990: f04f 0200    	mov.w	r2, #0x0
 8002994: f04f 0300    	mov.w	r3, #0x0
 8002998: e9c1 2350    	strd	r2, r3, [r1, #320]
; 		if (QEKF_INS.ErrorCount > 50) {
 800299c: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800299e: e9d3 2350    	ldrd	r2, r3, [r3, #320]
 80029a2: 2a33         	cmp	r2, #0x33
 80029a4: f173 0300    	sbcs	r3, r3, #0x0
 80029a8: d308         	blo	0x80029bc <IMU_QuaternionEKF_xhatUpdate+0x380> @ imm = #0x10
; 			QEKF_INS.ConvergeFlag = 0;
 80029aa: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8002a20 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 80029ac: 2200         	movs	r2, #0x0
 80029ae: f883 2138    	strb.w	r2, [r3, #0x138]
; 			kf->SkipEq5 = FALSE; // step-5 is cov mat P updating
 80029b2: 687b         	ldr	r3, [r7, #0x4]
 80029b4: 2200         	movs	r2, #0x0
 80029b6: f883 202c    	strb.w	r2, [r3, #0x2c]
; 		if (QEKF_INS.ErrorCount > 50) {
 80029ba: e070         	b	0x8002a9e <IMU_QuaternionEKF_xhatUpdate+0x462> @ imm = #0xe0
; 			memcpy(kf->xhat_data, kf->xhatminus_data, sizeof_float * kf->xhatSize);
 80029bc: 687b         	ldr	r3, [r7, #0x4]
 80029be: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 80029c2: 687b         	ldr	r3, [r7, #0x4]
 80029c4: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 80029c8: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8002a28 <IMU_QuaternionEKF_xhatUpdate+0x3ec>
 80029ca: 881b         	ldrh	r3, [r3]
 80029cc: 461a         	mov	r2, r3
 80029ce: 687b         	ldr	r3, [r7, #0x4]
 80029d0: 7b1b         	ldrb	r3, [r3, #0xc]
 80029d2: fb02 f303    	mul	r3, r2, r3
 80029d6: 461a         	mov	r2, r3
 80029d8: f024 fd88    	bl	0x80274ec <memcpy>      @ imm = #0x24b10
; 			memcpy(kf->P_data, kf->Pminus_data,
 80029dc: 687b         	ldr	r3, [r7, #0x4]
 80029de: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 80029e2: 687b         	ldr	r3, [r7, #0x4]
 80029e4: f8d3 10fc    	ldr.w	r1, [r3, #0xfc]
; 			       sizeof_float * kf->xhatSize * kf->xhatSize);
 80029e8: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8002a28 <IMU_QuaternionEKF_xhatUpdate+0x3ec>
 80029ea: 881b         	ldrh	r3, [r3]
 80029ec: 461a         	mov	r2, r3
 80029ee: 687b         	ldr	r3, [r7, #0x4]
 80029f0: 7b1b         	ldrb	r3, [r3, #0xc]
 80029f2: fb02 f303    	mul	r3, r2, r3
 80029f6: 687a         	ldr	r2, [r7, #0x4]
 80029f8: 7b12         	ldrb	r2, [r2, #0xc]
 80029fa: fb02 f303    	mul	r3, r2, r3
; 			memcpy(kf->P_data, kf->Pminus_data,
 80029fe: 461a         	mov	r2, r3
 8002a00: f024 fd74    	bl	0x80274ec <memcpy>      @ imm = #0x24ae8
; 			kf->SkipEq5 = TRUE; // part5 is P updating
 8002a04: 687b         	ldr	r3, [r7, #0x4]
 8002a06: 2201         	movs	r2, #0x1
 8002a08: f883 202c    	strb.w	r2, [r3, #0x2c]
; 			return;
 8002a0c: e15a         	b	0x8002cc4 <IMU_QuaternionEKF_xhatUpdate+0x688> @ imm = #0x2b4
 8002a0e: bf00         	nop

08002a10 <$d>:
 8002a10: b4 2c 00 20  	.word	0x20002cb4
 8002a14: b8 2c 00 20  	.word	0x20002cb8
 8002a18: bc 2c 00 20  	.word	0x20002cbc
 8002a1c: c0 2c 00 20  	.word	0x20002cc0
 8002a20: 98 0c 00 20  	.word	0x20000c98
 8002a24: 58 0e 00 20  	.word	0x20000e58
 8002a28: 00 33 00 20  	.word	0x20003300

08002a2c <$t>:
; 		if (QEKF_INS.ChiSquare_Data[0] > 0.1f * QEKF_INS.ChiSquareTestThreshold &&
 8002a2c: 4ba7         	ldr	r3, [pc, #0x29c]        @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a2e: ed93 7a72    	vldr	s14, [r3, #456]
 8002a32: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a34: edd3 7a73    	vldr	s15, [r3, #460]
 8002a38: eddf 6aa5    	vldr	s13, [pc, #660]         @ 0x8002cd0 <IMU_QuaternionEKF_xhatUpdate+0x694>
 8002a3c: ee67 7aa6    	vmul.f32	s15, s15, s13
 8002a40: eeb4 7ae7    	vcmpe.f32	s14, s15
 8002a44: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002a48: dd19         	ble	0x8002a7e <IMU_QuaternionEKF_xhatUpdate+0x442> @ imm = #0x32
; 		    QEKF_INS.ConvergeFlag) {
 8002a4a: 4ba0         	ldr	r3, [pc, #0x280]        @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a4c: f893 3138    	ldrb.w	r3, [r3, #0x138]
; 		if (QEKF_INS.ChiSquare_Data[0] > 0.1f * QEKF_INS.ChiSquareTestThreshold &&
 8002a50: 2b00         	cmp	r3, #0x0
 8002a52: d014         	beq	0x8002a7e <IMU_QuaternionEKF_xhatUpdate+0x442> @ imm = #0x28
; 				(QEKF_INS.ChiSquareTestThreshold - QEKF_INS.ChiSquare_Data[0]) /
 8002a54: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a56: ed93 7a73    	vldr	s14, [r3, #460]
 8002a5a: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a5c: edd3 7a72    	vldr	s15, [r3, #456]
 8002a60: ee77 6a67    	vsub.f32	s13, s14, s15
; 				(0.9f * QEKF_INS.ChiSquareTestThreshold);
 8002a64: 4b99         	ldr	r3, [pc, #0x264]        @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a66: edd3 7a73    	vldr	s15, [r3, #460]
 8002a6a: ed9f 7a9a    	vldr	s14, [pc, #616]         @ 0x8002cd4 <IMU_QuaternionEKF_xhatUpdate+0x698>
 8002a6e: ee27 7a87    	vmul.f32	s14, s15, s14
; 				(QEKF_INS.ChiSquareTestThreshold - QEKF_INS.ChiSquare_Data[0]) /
 8002a72: eec6 7a87    	vdiv.f32	s15, s13, s14
; 			QEKF_INS.AdaptiveGainScale =
 8002a76: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a78: edc3 7a67    	vstr	s15, [r3, #412]
 8002a7c: e004         	b	0x8002a88 <IMU_QuaternionEKF_xhatUpdate+0x44c> @ imm = #0x8
; 			QEKF_INS.AdaptiveGainScale = 1;
 8002a7e: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a80: f04f 527e    	mov.w	r2, #0x3f800000
 8002a84: f8c3 219c    	str.w	r2, [r3, #0x19c]
; 		QEKF_INS.ErrorCount = 0;
 8002a88: 4990         	ldr	r1, [pc, #0x240]        @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002a8a: f04f 0200    	mov.w	r2, #0x0
 8002a8e: f04f 0300    	mov.w	r3, #0x0
 8002a92: e9c1 2350    	strd	r2, r3, [r1, #320]
; 		kf->SkipEq5 = FALSE;
 8002a96: 687b         	ldr	r3, [r7, #0x4]
 8002a98: 2200         	movs	r2, #0x0
 8002a9a: f883 202c    	strb.w	r2, [r3, #0x2c]
; 	kf->temp_matrix.numRows = kf->Pminus.numRows;
 8002a9e: 687b         	ldr	r3, [r7, #0x4]
 8002aa0: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 8002aa4: 687b         	ldr	r3, [r7, #0x4]
 8002aa6: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = kf->HT.numCols;
 8002aaa: 687b         	ldr	r3, [r7, #0x4]
 8002aac: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 8002ab0: 687b         	ldr	r3, [r7, #0x4]
 8002ab2: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		Matrix_Multiply(&kf->Pminus, &kf->HT, &kf->temp_matrix); // temp_matrix = P'(k)·HT
 8002ab6: 687b         	ldr	r3, [r7, #0x4]
 8002ab8: f103 0058    	add.w	r0, r3, #0x58
 8002abc: 687b         	ldr	r3, [r7, #0x4]
 8002abe: f103 0180    	add.w	r1, r3, #0x80
 8002ac2: 687b         	ldr	r3, [r7, #0x4]
 8002ac4: 33a8         	adds	r3, #0xa8
 8002ac6: 461a         	mov	r2, r3
 8002ac8: f00f fe1e    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #0xfc3c
 8002acc: 4603         	mov	r3, r0
 8002ace: 461a         	mov	r2, r3
; 	kf->MatStatus =
 8002ad0: 687b         	ldr	r3, [r7, #0x4]
 8002ad2: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->temp_matrix1, &kf->K);
 8002ad6: 687b         	ldr	r3, [r7, #0x4]
 8002ad8: f103 00a8    	add.w	r0, r3, #0xa8
 8002adc: 687b         	ldr	r3, [r7, #0x4]
 8002ade: f103 01b0    	add.w	r1, r3, #0xb0
 8002ae2: 687b         	ldr	r3, [r7, #0x4]
 8002ae4: 3398         	adds	r3, #0x98
 8002ae6: 461a         	mov	r2, r3
 8002ae8: f00f fe0e    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #0xfc1c
 8002aec: 4603         	mov	r3, r0
 8002aee: 461a         	mov	r2, r3
 8002af0: 687b         	ldr	r3, [r7, #0x4]
 8002af2: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	for (uint8_t i = 0; i < kf->K.numRows * kf->K.numCols; ++i) {
 8002af6: 2300         	movs	r3, #0x0
 8002af8: 75bb         	strb	r3, [r7, #0x16]
 8002afa: e017         	b	0x8002b2c <IMU_QuaternionEKF_xhatUpdate+0x4f0> @ imm = #0x2e
; 		kf->K_data[i] *= QEKF_INS.AdaptiveGainScale;
 8002afc: 687b         	ldr	r3, [r7, #0x4]
 8002afe: f8d3 211c    	ldr.w	r2, [r3, #0x11c]
 8002b02: 7dbb         	ldrb	r3, [r7, #0x16]
 8002b04: 009b         	lsls	r3, r3, #0x2
 8002b06: 4413         	add	r3, r2
 8002b08: ed93 7a00    	vldr	s14, [r3]
 8002b0c: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002b0e: edd3 7a67    	vldr	s15, [r3, #412]
 8002b12: 687b         	ldr	r3, [r7, #0x4]
 8002b14: f8d3 211c    	ldr.w	r2, [r3, #0x11c]
 8002b18: 7dbb         	ldrb	r3, [r7, #0x16]
 8002b1a: 009b         	lsls	r3, r3, #0x2
 8002b1c: 4413         	add	r3, r2
 8002b1e: ee67 7a27    	vmul.f32	s15, s14, s15
 8002b22: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < kf->K.numRows * kf->K.numCols; ++i) {
 8002b26: 7dbb         	ldrb	r3, [r7, #0x16]
 8002b28: 3301         	adds	r3, #0x1
 8002b2a: 75bb         	strb	r3, [r7, #0x16]
 8002b2c: 7dba         	ldrb	r2, [r7, #0x16]
 8002b2e: 687b         	ldr	r3, [r7, #0x4]
 8002b30: f8b3 3098    	ldrh.w	r3, [r3, #0x98]
 8002b34: 4619         	mov	r1, r3
 8002b36: 687b         	ldr	r3, [r7, #0x4]
 8002b38: f8b3 309a    	ldrh.w	r3, [r3, #0x9a]
 8002b3c: fb01 f303    	mul	r3, r1, r3
 8002b40: 429a         	cmp	r2, r3
 8002b42: dbdb         	blt	0x8002afc <IMU_QuaternionEKF_xhatUpdate+0x4c0> @ imm = #-0x4a
; 	for (uint8_t i = 4; i < 6; ++i) {
 8002b44: 2304         	movs	r3, #0x4
 8002b46: 757b         	strb	r3, [r7, #0x15]
 8002b48: e034         	b	0x8002bb4 <IMU_QuaternionEKF_xhatUpdate+0x578> @ imm = #0x68
; 		for (uint8_t j = 0; j < 3; ++j) {
 8002b4a: 2300         	movs	r3, #0x0
 8002b4c: 753b         	strb	r3, [r7, #0x14]
 8002b4e: e02b         	b	0x8002ba8 <IMU_QuaternionEKF_xhatUpdate+0x56c> @ imm = #0x56
; 			kf->K_data[i * 3 + j] *=
 8002b50: 687b         	ldr	r3, [r7, #0x4]
 8002b52: f8d3 111c    	ldr.w	r1, [r3, #0x11c]
 8002b56: 7d7a         	ldrb	r2, [r7, #0x15]
 8002b58: 4613         	mov	r3, r2
 8002b5a: 005b         	lsls	r3, r3, #0x1
 8002b5c: 441a         	add	r2, r3
 8002b5e: 7d3b         	ldrb	r3, [r7, #0x14]
 8002b60: 4413         	add	r3, r2
 8002b62: 009b         	lsls	r3, r3, #0x2
 8002b64: 440b         	add	r3, r1
 8002b66: ed93 7a00    	vldr	s14, [r3]
; 				QEKF_INS.OrientationCosine[i - 4] / 1.5707963f; // 1 rad
 8002b6a: 7d7b         	ldrb	r3, [r7, #0x15]
 8002b6c: 3b04         	subs	r3, #0x4
 8002b6e: 4a57         	ldr	r2, [pc, #0x15c]        @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002b70: 3360         	adds	r3, #0x60
 8002b72: 009b         	lsls	r3, r3, #0x2
 8002b74: 4413         	add	r3, r2
 8002b76: 3304         	adds	r3, #0x4
 8002b78: edd3 6a00    	vldr	s13, [r3]
 8002b7c: ed9f 6a56    	vldr	s12, [pc, #344]         @ 0x8002cd8 <IMU_QuaternionEKF_xhatUpdate+0x69c>
 8002b80: eec6 7a86    	vdiv.f32	s15, s13, s12
; 			kf->K_data[i * 3 + j] *=
 8002b84: 687b         	ldr	r3, [r7, #0x4]
 8002b86: f8d3 111c    	ldr.w	r1, [r3, #0x11c]
 8002b8a: 7d7a         	ldrb	r2, [r7, #0x15]
 8002b8c: 4613         	mov	r3, r2
 8002b8e: 005b         	lsls	r3, r3, #0x1
 8002b90: 441a         	add	r2, r3
 8002b92: 7d3b         	ldrb	r3, [r7, #0x14]
 8002b94: 4413         	add	r3, r2
 8002b96: 009b         	lsls	r3, r3, #0x2
 8002b98: 440b         	add	r3, r1
 8002b9a: ee67 7a27    	vmul.f32	s15, s14, s15
 8002b9e: edc3 7a00    	vstr	s15, [r3]
; 		for (uint8_t j = 0; j < 3; ++j) {
 8002ba2: 7d3b         	ldrb	r3, [r7, #0x14]
 8002ba4: 3301         	adds	r3, #0x1
 8002ba6: 753b         	strb	r3, [r7, #0x14]
 8002ba8: 7d3b         	ldrb	r3, [r7, #0x14]
 8002baa: 2b02         	cmp	r3, #0x2
 8002bac: d9d0         	bls	0x8002b50 <IMU_QuaternionEKF_xhatUpdate+0x514> @ imm = #-0x60
; 	for (uint8_t i = 4; i < 6; ++i) {
 8002bae: 7d7b         	ldrb	r3, [r7, #0x15]
 8002bb0: 3301         	adds	r3, #0x1
 8002bb2: 757b         	strb	r3, [r7, #0x15]
 8002bb4: 7d7b         	ldrb	r3, [r7, #0x15]
 8002bb6: 2b05         	cmp	r3, #0x5
 8002bb8: d9c7         	bls	0x8002b4a <IMU_QuaternionEKF_xhatUpdate+0x50e> @ imm = #-0x72
; 	kf->temp_vector.numRows = kf->K.numRows;
 8002bba: 687b         	ldr	r3, [r7, #0x4]
 8002bbc: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 8002bc0: 687b         	ldr	r3, [r7, #0x4]
 8002bc2: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = 1;
 8002bc6: 687b         	ldr	r3, [r7, #0x4]
 8002bc8: 2201         	movs	r2, #0x1
 8002bca: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->MatStatus = Matrix_Multiply(&kf->K, &kf->temp_vector1,
 8002bce: 687b         	ldr	r3, [r7, #0x4]
 8002bd0: f103 0098    	add.w	r0, r3, #0x98
 8002bd4: 687b         	ldr	r3, [r7, #0x4]
 8002bd6: f103 01c0    	add.w	r1, r3, #0xc0
 8002bda: 687b         	ldr	r3, [r7, #0x4]
 8002bdc: 33b8         	adds	r3, #0xb8
 8002bde: 461a         	mov	r2, r3
 8002be0: f00f fd92    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #0xfb24
 8002be4: 4603         	mov	r3, r0
 8002be6: 461a         	mov	r2, r3
 8002be8: 687b         	ldr	r3, [r7, #0x4]
 8002bea: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	if (QEKF_INS.ConvergeFlag) {
 8002bee: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002bf0: f893 3138    	ldrb.w	r3, [r3, #0x138]
 8002bf4: 2b00         	cmp	r3, #0x0
 8002bf6: d04e         	beq	0x8002c96 <IMU_QuaternionEKF_xhatUpdate+0x65a> @ imm = #0x9c
; 		for (uint8_t i = 4; i < 6; ++i) {
 8002bf8: 2304         	movs	r3, #0x4
 8002bfa: 74fb         	strb	r3, [r7, #0x13]
 8002bfc: e048         	b	0x8002c90 <IMU_QuaternionEKF_xhatUpdate+0x654> @ imm = #0x90
; 			if (kf->temp_vector.pData[i] > 1e-2f * QEKF_INS.dt) {
 8002bfe: 687b         	ldr	r3, [r7, #0x4]
 8002c00: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8002c04: 7cfb         	ldrb	r3, [r7, #0x13]
 8002c06: 009b         	lsls	r3, r3, #0x2
 8002c08: 4413         	add	r3, r2
 8002c0a: ed93 7a00    	vldr	s14, [r3]
 8002c0e: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002c10: edd3 7a6f    	vldr	s15, [r3, #444]
 8002c14: eddf 6a31    	vldr	s13, [pc, #196]         @ 0x8002cdc <IMU_QuaternionEKF_xhatUpdate+0x6a0>
 8002c18: ee67 7aa6    	vmul.f32	s15, s15, s13
 8002c1c: eeb4 7ae7    	vcmpe.f32	s14, s15
 8002c20: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002c24: dd0e         	ble	0x8002c44 <IMU_QuaternionEKF_xhatUpdate+0x608> @ imm = #0x1c
; 				kf->temp_vector.pData[i] = 1e-2f * QEKF_INS.dt;
 8002c26: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002c28: edd3 7a6f    	vldr	s15, [r3, #444]
 8002c2c: 687b         	ldr	r3, [r7, #0x4]
 8002c2e: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8002c32: 7cfb         	ldrb	r3, [r7, #0x13]
 8002c34: 009b         	lsls	r3, r3, #0x2
 8002c36: 4413         	add	r3, r2
 8002c38: ed9f 7a28    	vldr	s14, [pc, #160]         @ 0x8002cdc <IMU_QuaternionEKF_xhatUpdate+0x6a0>
 8002c3c: ee67 7a87    	vmul.f32	s15, s15, s14
 8002c40: edc3 7a00    	vstr	s15, [r3]
; 			if (kf->temp_vector.pData[i] < -1e-2f * QEKF_INS.dt) {
 8002c44: 687b         	ldr	r3, [r7, #0x4]
 8002c46: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8002c4a: 7cfb         	ldrb	r3, [r7, #0x13]
 8002c4c: 009b         	lsls	r3, r3, #0x2
 8002c4e: 4413         	add	r3, r2
 8002c50: ed93 7a00    	vldr	s14, [r3]
 8002c54: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002c56: edd3 7a6f    	vldr	s15, [r3, #444]
 8002c5a: eddf 6a21    	vldr	s13, [pc, #132]         @ 0x8002ce0 <IMU_QuaternionEKF_xhatUpdate+0x6a4>
 8002c5e: ee67 7aa6    	vmul.f32	s15, s15, s13
 8002c62: eeb4 7ae7    	vcmpe.f32	s14, s15
 8002c66: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002c6a: d50e         	bpl	0x8002c8a <IMU_QuaternionEKF_xhatUpdate+0x64e> @ imm = #0x1c
; 				kf->temp_vector.pData[i] = -1e-2f * QEKF_INS.dt;
 8002c6c: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8002ccc <IMU_QuaternionEKF_xhatUpdate+0x690>
 8002c6e: edd3 7a6f    	vldr	s15, [r3, #444]
 8002c72: 687b         	ldr	r3, [r7, #0x4]
 8002c74: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8002c78: 7cfb         	ldrb	r3, [r7, #0x13]
 8002c7a: 009b         	lsls	r3, r3, #0x2
 8002c7c: 4413         	add	r3, r2
 8002c7e: ed9f 7a18    	vldr	s14, [pc, #96]          @ 0x8002ce0 <IMU_QuaternionEKF_xhatUpdate+0x6a4>
 8002c82: ee67 7a87    	vmul.f32	s15, s15, s14
 8002c86: edc3 7a00    	vstr	s15, [r3]
; 		for (uint8_t i = 4; i < 6; ++i) {
 8002c8a: 7cfb         	ldrb	r3, [r7, #0x13]
 8002c8c: 3301         	adds	r3, #0x1
 8002c8e: 74fb         	strb	r3, [r7, #0x13]
 8002c90: 7cfb         	ldrb	r3, [r7, #0x13]
 8002c92: 2b05         	cmp	r3, #0x5
 8002c94: d9b3         	bls	0x8002bfe <IMU_QuaternionEKF_xhatUpdate+0x5c2> @ imm = #-0x9a
; 	kf->temp_vector.pData[3] = 0;
 8002c96: 687b         	ldr	r3, [r7, #0x4]
 8002c98: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 8002c9c: 330c         	adds	r3, #0xc
 8002c9e: f04f 0200    	mov.w	r2, #0x0
 8002ca2: 601a         	str	r2, [r3]
; 	kf->MatStatus = Matrix_Add(&kf->xhatminus, &kf->temp_vector, &kf->xhat);
 8002ca4: 687b         	ldr	r3, [r7, #0x4]
 8002ca6: f103 0038    	add.w	r0, r3, #0x38
 8002caa: 687b         	ldr	r3, [r7, #0x4]
 8002cac: f103 01b8    	add.w	r1, r3, #0xb8
 8002cb0: 687b         	ldr	r3, [r7, #0x4]
 8002cb2: 3330         	adds	r3, #0x30
 8002cb4: 461a         	mov	r2, r3
 8002cb6: f00f fb8b    	bl	0x80123d0 <arm_mat_add_f32> @ imm = #0xf716
 8002cba: 4603         	mov	r3, r0
 8002cbc: 461a         	mov	r2, r3
 8002cbe: 687b         	ldr	r3, [r7, #0x4]
 8002cc0: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 8002cc4: 371c         	adds	r7, #0x1c
 8002cc6: 46bd         	mov	sp, r7
 8002cc8: bdf0         	pop	{r4, r5, r6, r7, pc}
 8002cca: bf00         	nop

08002ccc <$d>:
 8002ccc: 98 0c 00 20  	.word	0x20000c98
 8002cd0: cd cc cc 3d  	.word	0x3dcccccd
 8002cd4: 66 66 66 3f  	.word	0x3f666666
 8002cd8: da 0f c9 3f  	.word	0x3fc90fda
 8002cdc: 0a d7 23 3c  	.word	0x3c23d70a
 8002ce0: 0a d7 23 bc  	.word	0xbc23d70a

08002ce4 <IMU_QuaternionEKF_Observe>:
; {
 8002ce4: b580         	push	{r7, lr}
 8002ce6: b082         	sub	sp, #0x8
 8002ce8: af00         	add	r7, sp, #0x0
 8002cea: 6078         	str	r0, [r7, #0x4]
; 	memcpy(IMU_QuaternionEKF_P, kf->P_data, sizeof(IMU_QuaternionEKF_P));
 8002cec: 687b         	ldr	r3, [r7, #0x4]
 8002cee: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002cf2: 2290         	movs	r2, #0x90
 8002cf4: 4619         	mov	r1, r3
 8002cf6: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8002d24 <IMU_QuaternionEKF_Observe+0x40>
 8002cf8: f024 fbf8    	bl	0x80274ec <memcpy>      @ imm = #0x247f0
; 	memcpy(IMU_QuaternionEKF_K, kf->K_data, sizeof(IMU_QuaternionEKF_K));
 8002cfc: 687b         	ldr	r3, [r7, #0x4]
 8002cfe: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8002d02: 2248         	movs	r2, #0x48
 8002d04: 4619         	mov	r1, r3
 8002d06: 4808         	ldr	r0, [pc, #0x20]         @ 0x8002d28 <IMU_QuaternionEKF_Observe+0x44>
 8002d08: f024 fbf0    	bl	0x80274ec <memcpy>      @ imm = #0x247e0
; 	memcpy(IMU_QuaternionEKF_H, kf->H_data, sizeof(IMU_QuaternionEKF_H));
 8002d0c: 687b         	ldr	r3, [r7, #0x4]
 8002d0e: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8002d12: 2248         	movs	r2, #0x48
 8002d14: 4619         	mov	r1, r3
 8002d16: 4805         	ldr	r0, [pc, #0x14]         @ 0x8002d2c <IMU_QuaternionEKF_Observe+0x48>
 8002d18: f024 fbe8    	bl	0x80274ec <memcpy>      @ imm = #0x247d0
; }
 8002d1c: bf00         	nop
 8002d1e: 3708         	adds	r7, #0x8
 8002d20: 46bd         	mov	sp, r7
 8002d22: bd80         	pop	{r7, pc}

08002d24 <$d>:
 8002d24: 08 04 00 20  	.word	0x20000408
 8002d28: 90 2a 00 20  	.word	0x20002a90
 8002d2c: d8 2a 00 20  	.word	0x20002ad8

08002d30 <invSqrt>:
; {
 8002d30: b480         	push	{r7}
 8002d32: b087         	sub	sp, #0x1c
 8002d34: af00         	add	r7, sp, #0x0
 8002d36: ed87 0a01    	vstr	s0, [r7, #4]
; 	float halfx = 0.5f * x;
 8002d3a: edd7 7a01    	vldr	s15, [r7, #4]
 8002d3e: eeb6 7a00    	vmov.f32	s14, #5.000000e-01
 8002d42: ee67 7a87    	vmul.f32	s15, s15, s14
 8002d46: edc7 7a05    	vstr	s15, [r7, #20]
; 	float y = x;
 8002d4a: 687b         	ldr	r3, [r7, #0x4]
 8002d4c: 613b         	str	r3, [r7, #0x10]
; 	long i = *(long *)&y;
 8002d4e: f107 0310    	add.w	r3, r7, #0x10
 8002d52: 681b         	ldr	r3, [r3]
 8002d54: 60fb         	str	r3, [r7, #0xc]
; 	i = 0x5f375a86 - (i >> 1);
 8002d56: 68fb         	ldr	r3, [r7, #0xc]
 8002d58: 105a         	asrs	r2, r3, #0x1
 8002d5a: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8002da4 <invSqrt+0x74>
 8002d5c: 1a9b         	subs	r3, r3, r2
 8002d5e: 60fb         	str	r3, [r7, #0xc]
; 	y = *(float *)&i;
 8002d60: f107 030c    	add.w	r3, r7, #0xc
 8002d64: 681b         	ldr	r3, [r3]
 8002d66: 613b         	str	r3, [r7, #0x10]
; 	y = y * (1.5f - (halfx * y * y));
 8002d68: ed97 7a04    	vldr	s14, [r7, #16]
 8002d6c: edd7 7a05    	vldr	s15, [r7, #20]
 8002d70: ee27 7a27    	vmul.f32	s14, s14, s15
 8002d74: edd7 7a04    	vldr	s15, [r7, #16]
 8002d78: ee67 7a27    	vmul.f32	s15, s14, s15
 8002d7c: eeb7 7a08    	vmov.f32	s14, #1.500000e+00
 8002d80: ee37 7a67    	vsub.f32	s14, s14, s15
 8002d84: edd7 7a04    	vldr	s15, [r7, #16]
 8002d88: ee67 7a27    	vmul.f32	s15, s14, s15
 8002d8c: edc7 7a04    	vstr	s15, [r7, #16]
; 	return y;
 8002d90: 693b         	ldr	r3, [r7, #0x10]
 8002d92: ee07 3a90    	vmov	s15, r3
; }
 8002d96: eeb0 0a67    	vmov.f32	s0, s15
 8002d9a: 371c         	adds	r7, #0x1c
 8002d9c: 46bd         	mov	sp, r7
 8002d9e: f85d 7b04    	ldr	r7, [sp], #4
 8002da2: 4770         	bx	lr

08002da4 <$d>:
 8002da4: 86 5a 37 5f  	.word	0x5f375a86

08002da8 <Sqrt>:
; {
 8002da8: b480         	push	{r7}
 8002daa: b087         	sub	sp, #0x1c
 8002dac: af00         	add	r7, sp, #0x0
 8002dae: ed87 0a01    	vstr	s0, [r7, #4]
; 	if (x <= 0) {
 8002db2: edd7 7a01    	vldr	s15, [r7, #4]
 8002db6: eef5 7ac0    	vcmpe.f32	s15, #0
 8002dba: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002dbe: d802         	bhi	0x8002dc6 <Sqrt+0x1e>   @ imm = #0x4
; 		return 0;
 8002dc0: f04f 0300    	mov.w	r3, #0x0
 8002dc4: e03c         	b	0x8002e40 <Sqrt+0x98>   @ imm = #0x78
; 	y = x / 2;
 8002dc6: ed97 7a01    	vldr	s14, [r7, #4]
 8002dca: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8002dce: eec7 7a26    	vdiv.f32	s15, s14, s13
 8002dd2: edc7 7a05    	vstr	s15, [r7, #20]
; 	maxError = x * 0.001f;
 8002dd6: edd7 7a01    	vldr	s15, [r7, #4]
 8002dda: ed9f 7a1e    	vldr	s14, [pc, #120]         @ 0x8002e54 <Sqrt+0xac>
 8002dde: ee67 7a87    	vmul.f32	s15, s15, s14
 8002de2: edc7 7a04    	vstr	s15, [r7, #16]
; 		delta = (y * y) - x;
 8002de6: edd7 7a05    	vldr	s15, [r7, #20]
 8002dea: ee27 7aa7    	vmul.f32	s14, s15, s15
 8002dee: edd7 7a01    	vldr	s15, [r7, #4]
 8002df2: ee77 7a67    	vsub.f32	s15, s14, s15
 8002df6: edc7 7a03    	vstr	s15, [r7, #12]
; 		y -= delta / (2 * y);
 8002dfa: edd7 7a05    	vldr	s15, [r7, #20]
 8002dfe: ee37 7aa7    	vadd.f32	s14, s15, s15
 8002e02: edd7 6a03    	vldr	s13, [r7, #12]
 8002e06: eec6 7a87    	vdiv.f32	s15, s13, s14
 8002e0a: ed97 7a05    	vldr	s14, [r7, #20]
 8002e0e: ee77 7a67    	vsub.f32	s15, s14, s15
 8002e12: edc7 7a05    	vstr	s15, [r7, #20]
; 	} while (delta > maxError || delta < -maxError);
 8002e16: ed97 7a03    	vldr	s14, [r7, #12]
 8002e1a: edd7 7a04    	vldr	s15, [r7, #16]
 8002e1e: eeb4 7ae7    	vcmpe.f32	s14, s15
 8002e22: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002e26: dcde         	bgt	0x8002de6 <Sqrt+0x3e>   @ imm = #-0x44
 8002e28: edd7 7a04    	vldr	s15, [r7, #16]
 8002e2c: eef1 7a67    	vneg.f32	s15, s15
 8002e30: ed97 7a03    	vldr	s14, [r7, #12]
 8002e34: eeb4 7ae7    	vcmpe.f32	s14, s15
 8002e38: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002e3c: d4d3         	bmi	0x8002de6 <Sqrt+0x3e>   @ imm = #-0x5a
; 	return y;
 8002e3e: 697b         	ldr	r3, [r7, #0x14]
; }
 8002e40: ee07 3a90    	vmov	s15, r3
 8002e44: eeb0 0a67    	vmov.f32	s0, s15
 8002e48: 371c         	adds	r7, #0x1c
 8002e4a: 46bd         	mov	sp, r7
 8002e4c: f85d 7b04    	ldr	r7, [sp], #4
 8002e50: 4770         	bx	lr
 8002e52: bf00         	nop

08002e54 <$d>:
 8002e54: 6f 12 83 3a  	.word	0x3a83126f

08002e58 <IMU_Sensor_handle_update>:
; {
 8002e58: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8002e5c: b084         	sub	sp, #0x10
 8002e5e: af00         	add	r7, sp, #0x0
 8002e60: 6078         	str	r0, [r7, #0x4]
; 	if (data->flag < 3) {
 8002e62: 6879         	ldr	r1, [r7, #0x4]
 8002e64: f891 1024    	ldrb.w	r1, [r1, #0x24]
 8002e68: 2902         	cmp	r1, #0x2
 8002e6a: f240 80c4    	bls.w	0x8002ff6 <IMU_Sensor_handle_update+0x19e> @ imm = #0x188
; 	data->flag = 0;
 8002e6e: 6879         	ldr	r1, [r7, #0x4]
 8002e70: 2000         	movs	r0, #0x0
 8002e72: f881 0024    	strb.w	r0, [r1, #0x24]
; 	count++;
 8002e76: 4962         	ldr	r1, [pc, #0x188]        @ 0x8003000 <IMU_Sensor_handle_update+0x1a8>
 8002e78: 6809         	ldr	r1, [r1]
 8002e7a: 3101         	adds	r1, #0x1
 8002e7c: 4860         	ldr	r0, [pc, #0x180]        @ 0x8003000 <IMU_Sensor_handle_update+0x1a8>
 8002e7e: 6001         	str	r1, [r0]
; 		k_cyc_to_us_near32(data->accel_curr_cyc - data->accel_prev_cyc) * 0.000001f;
 8002e80: 6879         	ldr	r1, [r7, #0x4]
 8002e82: 6b88         	ldr	r0, [r1, #0x38]
 8002e84: 6879         	ldr	r1, [r7, #0x4]
 8002e86: 6ac9         	ldr	r1, [r1, #0x2c]
 8002e88: 1a41         	subs	r1, r0, r1
 8002e8a: 2900         	cmp	r1, #0x0
 8002e8c: db0f         	blt	0x8002eae <IMU_Sensor_handle_update+0x56> @ imm = #0x1e
 8002e8e: 687b         	ldr	r3, [r7, #0x4]
 8002e90: 6b9a         	ldr	r2, [r3, #0x38]
 8002e92: 687b         	ldr	r3, [r7, #0x4]
 8002e94: 6adb         	ldr	r3, [r3, #0x2c]
 8002e96: 1ad3         	subs	r3, r2, r3
 8002e98: 3354         	adds	r3, #0x54
 8002e9a: 08db         	lsrs	r3, r3, #0x3
 8002e9c: 4a59         	ldr	r2, [pc, #0x164]        @ 0x8003004 <IMU_Sensor_handle_update+0x1ac>
 8002e9e: fba2 2303    	umull	r2, r3, r2, r3
 8002ea2: 085b         	lsrs	r3, r3, #0x1
 8002ea4: ee07 3a90    	vmov	s15, r3
 8002ea8: eef8 7a67    	vcvt.f32.u32	s15, s15
 8002eac: e019         	b	0x8002ee2 <IMU_Sensor_handle_update+0x8a> @ imm = #0x32
 8002eae: 6879         	ldr	r1, [r7, #0x4]
 8002eb0: 6b88         	ldr	r0, [r1, #0x38]
 8002eb2: 6879         	ldr	r1, [r7, #0x4]
 8002eb4: 6ac9         	ldr	r1, [r1, #0x2c]
 8002eb6: 1a41         	subs	r1, r0, r1
 8002eb8: 17c8         	asrs	r0, r1, #0x1f
 8002eba: 460a         	mov	r2, r1
 8002ebc: 4603         	mov	r3, r0
 8002ebe: f112 0a54    	adds.w	r10, r2, #0x54
 8002ec2: f143 0b00    	adc	r11, r3, #0x0
 8002ec6: f04f 02a8    	mov.w	r2, #0xa8
 8002eca: f04f 0300    	mov.w	r3, #0x0
 8002ece: 4650         	mov	r0, r10
 8002ed0: 4659         	mov	r1, r11
 8002ed2: f7fd fbb5    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x2896
 8002ed6: 4602         	mov	r2, r0
 8002ed8: 460b         	mov	r3, r1
 8002eda: ee07 2a90    	vmov	s15, r2
 8002ede: eef8 7a67    	vcvt.f32.u32	s15, s15
; 	float accel_dt =
 8002ee2: ed9f 7a49    	vldr	s14, [pc, #292]         @ 0x8003008 <IMU_Sensor_handle_update+0x1b0>
 8002ee6: ee67 7a87    	vmul.f32	s15, s15, s14
 8002eea: edc7 7a03    	vstr	s15, [r7, #12]
; 	float gyro_dt = k_cyc_to_us_near32(data->gyro_curr_cyc - data->gyro_prev_cyc) * 0.000001f;
 8002eee: 687b         	ldr	r3, [r7, #0x4]
 8002ef0: 6b5a         	ldr	r2, [r3, #0x34]
 8002ef2: 687b         	ldr	r3, [r7, #0x4]
 8002ef4: 6a9b         	ldr	r3, [r3, #0x28]
 8002ef6: 1ad3         	subs	r3, r2, r3
 8002ef8: 2b00         	cmp	r3, #0x0
 8002efa: db0f         	blt	0x8002f1c <IMU_Sensor_handle_update+0xc4> @ imm = #0x1e
 8002efc: 687b         	ldr	r3, [r7, #0x4]
 8002efe: 6b5a         	ldr	r2, [r3, #0x34]
 8002f00: 687b         	ldr	r3, [r7, #0x4]
 8002f02: 6a9b         	ldr	r3, [r3, #0x28]
 8002f04: 1ad3         	subs	r3, r2, r3
 8002f06: 3354         	adds	r3, #0x54
 8002f08: 08db         	lsrs	r3, r3, #0x3
 8002f0a: 4a3e         	ldr	r2, [pc, #0xf8]         @ 0x8003004 <IMU_Sensor_handle_update+0x1ac>
 8002f0c: fba2 2303    	umull	r2, r3, r2, r3
 8002f10: 085b         	lsrs	r3, r3, #0x1
 8002f12: ee07 3a90    	vmov	s15, r3
 8002f16: eef8 7a67    	vcvt.f32.u32	s15, s15
 8002f1a: e019         	b	0x8002f50 <IMU_Sensor_handle_update+0xf8> @ imm = #0x32
 8002f1c: 687b         	ldr	r3, [r7, #0x4]
 8002f1e: 6b5a         	ldr	r2, [r3, #0x34]
 8002f20: 687b         	ldr	r3, [r7, #0x4]
 8002f22: 6a9b         	ldr	r3, [r3, #0x28]
 8002f24: 1ad3         	subs	r3, r2, r3
 8002f26: 17da         	asrs	r2, r3, #0x1f
 8002f28: 461c         	mov	r4, r3
 8002f2a: 4615         	mov	r5, r2
 8002f2c: f114 0854    	adds.w	r8, r4, #0x54
 8002f30: f145 0900    	adc	r9, r5, #0x0
 8002f34: f04f 02a8    	mov.w	r2, #0xa8
 8002f38: f04f 0300    	mov.w	r3, #0x0
 8002f3c: 4640         	mov	r0, r8
 8002f3e: 4649         	mov	r1, r9
 8002f40: f7fd fb7e    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x2904
 8002f44: 4602         	mov	r2, r0
 8002f46: 460b         	mov	r3, r1
 8002f48: ee07 2a90    	vmov	s15, r2
 8002f4c: eef8 7a67    	vcvt.f32.u32	s15, s15
 8002f50: ed9f 7a2d    	vldr	s14, [pc, #180]         @ 0x8003008 <IMU_Sensor_handle_update+0x1b0>
 8002f54: ee67 7a87    	vmul.f32	s15, s15, s14
 8002f58: edc7 7a02    	vstr	s15, [r7, #8]
; 	IMU_QuaternionEKF_Update(INS.Gyro[X], INS.Gyro[Y], INS.Gyro[Z], INS.Accel[X], INS.Accel[Y],
 8002f5c: 2300         	movs	r3, #0x0
 8002f5e: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x800300c <IMU_Sensor_handle_update+0x1b4>
 8002f60: 009b         	lsls	r3, r3, #0x2
 8002f62: 4413         	add	r3, r2
 8002f64: edd3 7a00    	vldr	s15, [r3]
 8002f68: 2301         	movs	r3, #0x1
 8002f6a: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x800300c <IMU_Sensor_handle_update+0x1b4>
 8002f6c: 009b         	lsls	r3, r3, #0x2
 8002f6e: 4413         	add	r3, r2
 8002f70: ed93 7a00    	vldr	s14, [r3]
 8002f74: 2302         	movs	r3, #0x2
 8002f76: 4a25         	ldr	r2, [pc, #0x94]         @ 0x800300c <IMU_Sensor_handle_update+0x1b4>
 8002f78: 009b         	lsls	r3, r3, #0x2
 8002f7a: 4413         	add	r3, r2
 8002f7c: edd3 6a00    	vldr	s13, [r3]
 8002f80: 2300         	movs	r3, #0x0
 8002f82: 4a22         	ldr	r2, [pc, #0x88]         @ 0x800300c <IMU_Sensor_handle_update+0x1b4>
 8002f84: 3302         	adds	r3, #0x2
 8002f86: 009b         	lsls	r3, r3, #0x2
 8002f88: 4413         	add	r3, r2
 8002f8a: 3304         	adds	r3, #0x4
 8002f8c: ed93 6a00    	vldr	s12, [r3]
 8002f90: 2301         	movs	r3, #0x1
 8002f92: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x800300c <IMU_Sensor_handle_update+0x1b4>
 8002f94: 3302         	adds	r3, #0x2
 8002f96: 009b         	lsls	r3, r3, #0x2
 8002f98: 4413         	add	r3, r2
 8002f9a: 3304         	adds	r3, #0x4
 8002f9c: edd3 5a00    	vldr	s11, [r3]
 8002fa0: 2302         	movs	r3, #0x2
 8002fa2: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x800300c <IMU_Sensor_handle_update+0x1b4>
 8002fa4: 3302         	adds	r3, #0x2
 8002fa6: 009b         	lsls	r3, r3, #0x2
 8002fa8: 4413         	add	r3, r2
 8002faa: 3304         	adds	r3, #0x4
 8002fac: ed93 5a00    	vldr	s10, [r3]
 8002fb0: edd7 3a02    	vldr	s7, [r7, #8]
 8002fb4: ed97 3a03    	vldr	s6, [r7, #12]
 8002fb8: eef0 2a45    	vmov.f32	s5, s10
 8002fbc: eeb0 2a65    	vmov.f32	s4, s11
 8002fc0: eef0 1a46    	vmov.f32	s3, s12
 8002fc4: eeb0 1a66    	vmov.f32	s2, s13
 8002fc8: eef0 0a47    	vmov.f32	s1, s14
 8002fcc: eeb0 0a67    	vmov.f32	s0, s15
 8002fd0: f7fe fd84    	bl	0x8001adc <IMU_QuaternionEKF_Update> @ imm = #-0x14f8
; 	data->gyro_prev_cyc = data->gyro_curr_cyc;
 8002fd4: 687b         	ldr	r3, [r7, #0x4]
 8002fd6: 6b5a         	ldr	r2, [r3, #0x34]
 8002fd8: 687b         	ldr	r3, [r7, #0x4]
 8002fda: 629a         	str	r2, [r3, #0x28]
; 	data->accel_prev_cyc = data->accel_curr_cyc;
 8002fdc: 687b         	ldr	r3, [r7, #0x4]
 8002fde: 6b9a         	ldr	r2, [r3, #0x38]
 8002fe0: 687b         	ldr	r3, [r7, #0x4]
 8002fe2: 62da         	str	r2, [r3, #0x2c]
; 	if (data->update_cb != NULL) {
 8002fe4: 687b         	ldr	r3, [r7, #0x4]
 8002fe6: 6bdb         	ldr	r3, [r3, #0x3c]
 8002fe8: 2b00         	cmp	r3, #0x0
 8002fea: d005         	beq	0x8002ff8 <IMU_Sensor_handle_update+0x1a0> @ imm = #0xa
; 		data->update_cb(&QEKF_INS);
 8002fec: 687b         	ldr	r3, [r7, #0x4]
 8002fee: 6bdb         	ldr	r3, [r3, #0x3c]
 8002ff0: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8003010 <IMU_Sensor_handle_update+0x1b8>
 8002ff2: 4798         	blx	r3
 8002ff4: e000         	b	0x8002ff8 <IMU_Sensor_handle_update+0x1a0> @ imm = #0x0
; 		return;
 8002ff6: bf00         	nop
; }
 8002ff8: 3710         	adds	r7, #0x10
 8002ffa: 46bd         	mov	sp, r7
 8002ffc: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08003000 <$d>:
 8003000: 7c 2b 00 20  	.word	0x20002b7c
 8003004: 19 86 61 18  	.word	0x18618619
 8003008: bd 37 86 35  	.word	0x358637bd
 800300c: 3c 2b 00 20  	.word	0x20002b3c
 8003010: 98 0c 00 20  	.word	0x20000c98

08003014 <IMU_Sensor_set_update_cb>:
; {
 8003014: b480         	push	{r7}
 8003016: b083         	sub	sp, #0xc
 8003018: af00         	add	r7, sp, #0x0
 800301a: 6078         	str	r0, [r7, #0x4]
; 	INS.update_cb = cb;
 800301c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8003030 <IMU_Sensor_set_update_cb+0x1c>
 800301e: 687b         	ldr	r3, [r7, #0x4]
 8003020: 63d3         	str	r3, [r2, #0x3c]
; }
 8003022: bf00         	nop
 8003024: 370c         	adds	r7, #0xc
 8003026: 46bd         	mov	sp, r7
 8003028: f85d 7b04    	ldr	r7, [sp], #4
 800302c: 4770         	bx	lr
 800302e: bf00         	nop

08003030 <$d>:
 8003030: 3c 2b 00 20  	.word	0x20002b3c

08003034 <InitQuaternion>:
; {
 8003034: b580         	push	{r7, lr}
 8003036: ed2d 8b02    	vpush	{d8}
 800303a: b096         	sub	sp, #0x58
 800303c: af00         	add	r7, sp, #0x0
 800303e: 60f8         	str	r0, [r7, #0xc]
 8003040: 60b9         	str	r1, [r7, #0x8]
 8003042: 607a         	str	r2, [r7, #0x4]
; 	float acc_init[3] = {0};
 8003044: f107 0344    	add.w	r3, r7, #0x44
 8003048: 2200         	movs	r2, #0x0
 800304a: 601a         	str	r2, [r3]
 800304c: 605a         	str	r2, [r3, #0x4]
 800304e: 609a         	str	r2, [r3, #0x8]
; 	float gravity_norm[3] = {0, 0, 1}; // 导航系重力加速度矢量,归一化后为(0,0,1)
 8003050: f04f 0300    	mov.w	r3, #0x0
 8003054: 63bb         	str	r3, [r7, #0x38]
 8003056: f04f 0300    	mov.w	r3, #0x0
 800305a: 63fb         	str	r3, [r7, #0x3c]
 800305c: f04f 537e    	mov.w	r3, #0x3f800000
 8003060: 643b         	str	r3, [r7, #0x40]
; 	float axis_rot[3] = {0};           // 旋转轴
 8003062: f107 032c    	add.w	r3, r7, #0x2c
 8003066: 2200         	movs	r2, #0x0
 8003068: 601a         	str	r2, [r3]
 800306a: 605a         	str	r2, [r3, #0x4]
 800306c: 609a         	str	r2, [r3, #0x8]
; 	for (uint8_t i = 0; i < 100; ++i) {
 800306e: 2300         	movs	r3, #0x0
 8003070: f887 3057    	strb.w	r3, [r7, #0x57]
 8003074: e05f         	b	0x8003136 <InitQuaternion+0x102> @ imm = #0xbe
; 		sensor_sample_fetch(dev);
 8003076: 68f8         	ldr	r0, [r7, #0xc]
 8003078: f016 ff9e    	bl	0x8019fb8 <sensor_sample_fetch> @ imm = #0x16f3c
; 		sensor_channel_get(dev, SENSOR_CHAN_ACCEL_XYZ, accel_data);
 800307c: f107 0314    	add.w	r3, r7, #0x14
 8003080: 461a         	mov	r2, r3
 8003082: 2103         	movs	r1, #0x3
 8003084: 68f8         	ldr	r0, [r7, #0xc]
 8003086: f016 ffa3    	bl	0x8019fd0 <sensor_channel_get> @ imm = #0x16f46
; 		acc_init[X] += sensor_value_to_float(&accel_data[X]);
 800308a: 2300         	movs	r3, #0x0
 800308c: f107 0214    	add.w	r2, r7, #0x14
 8003090: 00db         	lsls	r3, r3, #0x3
 8003092: 4413         	add	r3, r2
 8003094: 4618         	mov	r0, r3
 8003096: f7fd fdd9    	bl	0x8000c4c <sensor_value_to_float> @ imm = #-0x244e
 800309a: eeb0 7a40    	vmov.f32	s14, s0
 800309e: 2300         	movs	r3, #0x0
 80030a0: 009b         	lsls	r3, r3, #0x2
 80030a2: 3358         	adds	r3, #0x58
 80030a4: 443b         	add	r3, r7
 80030a6: 3b14         	subs	r3, #0x14
 80030a8: edd3 7a00    	vldr	s15, [r3]
 80030ac: 2300         	movs	r3, #0x0
 80030ae: ee77 7a27    	vadd.f32	s15, s14, s15
 80030b2: 009b         	lsls	r3, r3, #0x2
 80030b4: 3358         	adds	r3, #0x58
 80030b6: 443b         	add	r3, r7
 80030b8: 3b14         	subs	r3, #0x14
 80030ba: edc3 7a00    	vstr	s15, [r3]
; 		acc_init[Y] += sensor_value_to_float(&accel_data[Y]);
 80030be: 2301         	movs	r3, #0x1
 80030c0: f107 0214    	add.w	r2, r7, #0x14
 80030c4: 00db         	lsls	r3, r3, #0x3
 80030c6: 4413         	add	r3, r2
 80030c8: 4618         	mov	r0, r3
 80030ca: f7fd fdbf    	bl	0x8000c4c <sensor_value_to_float> @ imm = #-0x2482
 80030ce: eeb0 7a40    	vmov.f32	s14, s0
 80030d2: 2301         	movs	r3, #0x1
 80030d4: 009b         	lsls	r3, r3, #0x2
 80030d6: 3358         	adds	r3, #0x58
 80030d8: 443b         	add	r3, r7
 80030da: 3b14         	subs	r3, #0x14
 80030dc: edd3 7a00    	vldr	s15, [r3]
 80030e0: 2301         	movs	r3, #0x1
 80030e2: ee77 7a27    	vadd.f32	s15, s14, s15
 80030e6: 009b         	lsls	r3, r3, #0x2
 80030e8: 3358         	adds	r3, #0x58
 80030ea: 443b         	add	r3, r7
 80030ec: 3b14         	subs	r3, #0x14
 80030ee: edc3 7a00    	vstr	s15, [r3]
; 		acc_init[Z] += sensor_value_to_float(&accel_data[Z]);
 80030f2: 2302         	movs	r3, #0x2
 80030f4: f107 0214    	add.w	r2, r7, #0x14
 80030f8: 00db         	lsls	r3, r3, #0x3
 80030fa: 4413         	add	r3, r2
 80030fc: 4618         	mov	r0, r3
 80030fe: f7fd fda5    	bl	0x8000c4c <sensor_value_to_float> @ imm = #-0x24b6
 8003102: eeb0 7a40    	vmov.f32	s14, s0
 8003106: 2302         	movs	r3, #0x2
 8003108: 009b         	lsls	r3, r3, #0x2
 800310a: 3358         	adds	r3, #0x58
 800310c: 443b         	add	r3, r7
 800310e: 3b14         	subs	r3, #0x14
 8003110: edd3 7a00    	vldr	s15, [r3]
 8003114: 2302         	movs	r3, #0x2
 8003116: ee77 7a27    	vadd.f32	s15, s14, s15
 800311a: 009b         	lsls	r3, r3, #0x2
 800311c: 3358         	adds	r3, #0x58
 800311e: 443b         	add	r3, r7
 8003120: 3b14         	subs	r3, #0x14
 8003122: edc3 7a00    	vstr	s15, [r3]
; 		k_msleep(1);
 8003126: 2001         	movs	r0, #0x1
 8003128: f016 fe72    	bl	0x8019e10 <k_msleep>    @ imm = #0x16ce4
; 	for (uint8_t i = 0; i < 100; ++i) {
 800312c: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8003130: 3301         	adds	r3, #0x1
 8003132: f887 3057    	strb.w	r3, [r7, #0x57]
 8003136: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800313a: 2b63         	cmp	r3, #0x63
 800313c: d99b         	bls	0x8003076 <InitQuaternion+0x42> @ imm = #-0xca
; 	for (uint8_t i = 0; i < 3; ++i) {
 800313e: 2300         	movs	r3, #0x0
 8003140: f887 3056    	strb.w	r3, [r7, #0x56]
 8003144: e018         	b	0x8003178 <InitQuaternion+0x144> @ imm = #0x30
; 		acc_init[i] /= 100;
 8003146: f897 3056    	ldrb.w	r3, [r7, #0x56]
 800314a: 009b         	lsls	r3, r3, #0x2
 800314c: 3358         	adds	r3, #0x58
 800314e: 443b         	add	r3, r7
 8003150: 3b14         	subs	r3, #0x14
 8003152: ed93 7a00    	vldr	s14, [r3]
 8003156: f897 3056    	ldrb.w	r3, [r7, #0x56]
 800315a: eddf 6a4c    	vldr	s13, [pc, #304]         @ 0x800328c <InitQuaternion+0x258>
 800315e: eec7 7a26    	vdiv.f32	s15, s14, s13
 8003162: 009b         	lsls	r3, r3, #0x2
 8003164: 3358         	adds	r3, #0x58
 8003166: 443b         	add	r3, r7
 8003168: 3b14         	subs	r3, #0x14
 800316a: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 3; ++i) {
 800316e: f897 3056    	ldrb.w	r3, [r7, #0x56]
 8003172: 3301         	adds	r3, #0x1
 8003174: f887 3056    	strb.w	r3, [r7, #0x56]
 8003178: f897 3056    	ldrb.w	r3, [r7, #0x56]
 800317c: 2b02         	cmp	r3, #0x2
 800317e: d9e2         	bls	0x8003146 <InitQuaternion+0x112> @ imm = #-0x3c
; 	accel[X] = acc_init[X];
 8003180: 2100         	movs	r1, #0x0
 8003182: 2300         	movs	r3, #0x0
 8003184: 009b         	lsls	r3, r3, #0x2
 8003186: 687a         	ldr	r2, [r7, #0x4]
 8003188: 4413         	add	r3, r2
 800318a: 008a         	lsls	r2, r1, #0x2
 800318c: 3258         	adds	r2, #0x58
 800318e: 443a         	add	r2, r7
 8003190: 3a14         	subs	r2, #0x14
 8003192: 6812         	ldr	r2, [r2]
 8003194: 601a         	str	r2, [r3]
; 	accel[Y] = acc_init[Y];
 8003196: 2101         	movs	r1, #0x1
 8003198: 2301         	movs	r3, #0x1
 800319a: 009b         	lsls	r3, r3, #0x2
 800319c: 687a         	ldr	r2, [r7, #0x4]
 800319e: 4413         	add	r3, r2
 80031a0: 008a         	lsls	r2, r1, #0x2
 80031a2: 3258         	adds	r2, #0x58
 80031a4: 443a         	add	r2, r7
 80031a6: 3a14         	subs	r2, #0x14
 80031a8: 6812         	ldr	r2, [r2]
 80031aa: 601a         	str	r2, [r3]
; 	accel[Z] = acc_init[Z];
 80031ac: 2102         	movs	r1, #0x2
 80031ae: 2302         	movs	r3, #0x2
 80031b0: 009b         	lsls	r3, r3, #0x2
 80031b2: 687a         	ldr	r2, [r7, #0x4]
 80031b4: 4413         	add	r3, r2
 80031b6: 008a         	lsls	r2, r1, #0x2
 80031b8: 3258         	adds	r2, #0x58
 80031ba: 443a         	add	r2, r7
 80031bc: 3a14         	subs	r2, #0x14
 80031be: 6812         	ldr	r2, [r2]
 80031c0: 601a         	str	r2, [r3]
; 	Norm3d(acc_init);
 80031c2: f107 0344    	add.w	r3, r7, #0x44
 80031c6: 4618         	mov	r0, r3
 80031c8: f017 f93b    	bl	0x801a442 <Norm3d>      @ imm = #0x17276
; 	float angle = acosf(Dot3d(acc_init, gravity_norm));
 80031cc: f107 0238    	add.w	r2, r7, #0x38
 80031d0: f107 0344    	add.w	r3, r7, #0x44
 80031d4: 4611         	mov	r1, r2
 80031d6: 4618         	mov	r0, r3
 80031d8: f017 f9d9    	bl	0x801a58e <Dot3d>       @ imm = #0x173b2
 80031dc: eef0 7a40    	vmov.f32	s15, s0
 80031e0: eeb0 0a67    	vmov.f32	s0, s15
 80031e4: f015 fc44    	bl	0x8018a70 <acosf>       @ imm = #0x15888
 80031e8: ed87 0a14    	vstr	s0, [r7, #80]
; 	Cross3d(acc_init, gravity_norm, axis_rot);
 80031ec: f107 022c    	add.w	r2, r7, #0x2c
 80031f0: f107 0138    	add.w	r1, r7, #0x38
 80031f4: f107 0344    	add.w	r3, r7, #0x44
 80031f8: 4618         	mov	r0, r3
 80031fa: f017 f973    	bl	0x801a4e4 <Cross3d>     @ imm = #0x172e6
; 	Norm3d(axis_rot);
 80031fe: f107 032c    	add.w	r3, r7, #0x2c
 8003202: 4618         	mov	r0, r3
 8003204: f017 f91d    	bl	0x801a442 <Norm3d>      @ imm = #0x1723a
; 	init_q4[0] = cosf(angle / 2.0f);
 8003208: edd7 7a14    	vldr	s15, [r7, #80]
 800320c: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8003210: ee87 7aa6    	vdiv.f32	s14, s15, s13
 8003214: eeb0 0a47    	vmov.f32	s0, s14
 8003218: f015 feba    	bl	0x8018f90 <cosf>        @ imm = #0x15d74
 800321c: eef0 7a40    	vmov.f32	s15, s0
 8003220: 68bb         	ldr	r3, [r7, #0x8]
 8003222: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 2; ++i) {
 8003226: 2300         	movs	r3, #0x0
 8003228: f887 3055    	strb.w	r3, [r7, #0x55]
 800322c: e022         	b	0x8003274 <InitQuaternion+0x240> @ imm = #0x44
; 			axis_rot[i] * sinf(angle / 2.0f); // 轴角公式,第三轴为0(没有z轴分量)
 800322e: f897 3055    	ldrb.w	r3, [r7, #0x55]
 8003232: 009b         	lsls	r3, r3, #0x2
 8003234: 3358         	adds	r3, #0x58
 8003236: 443b         	add	r3, r7
 8003238: 3b2c         	subs	r3, #0x2c
 800323a: ed93 8a00    	vldr	s16, [r3]
 800323e: edd7 7a14    	vldr	s15, [r7, #80]
 8003242: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8003246: ee87 7aa6    	vdiv.f32	s14, s15, s13
 800324a: eeb0 0a47    	vmov.f32	s0, s14
 800324e: f016 f8b5    	bl	0x80193bc <sinf>        @ imm = #0x1616a
 8003252: eef0 7a40    	vmov.f32	s15, s0
; 		init_q4[i + 1] =
 8003256: f897 3055    	ldrb.w	r3, [r7, #0x55]
 800325a: 3301         	adds	r3, #0x1
 800325c: 009b         	lsls	r3, r3, #0x2
 800325e: 68ba         	ldr	r2, [r7, #0x8]
 8003260: 4413         	add	r3, r2
; 			axis_rot[i] * sinf(angle / 2.0f); // 轴角公式,第三轴为0(没有z轴分量)
 8003262: ee68 7a27    	vmul.f32	s15, s16, s15
; 		init_q4[i + 1] =
 8003266: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 2; ++i) {
 800326a: f897 3055    	ldrb.w	r3, [r7, #0x55]
 800326e: 3301         	adds	r3, #0x1
 8003270: f887 3055    	strb.w	r3, [r7, #0x55]
 8003274: f897 3055    	ldrb.w	r3, [r7, #0x55]
 8003278: 2b01         	cmp	r3, #0x1
 800327a: d9d8         	bls	0x800322e <InitQuaternion+0x1fa> @ imm = #-0x50
; }
 800327c: bf00         	nop
 800327e: bf00         	nop
 8003280: 3758         	adds	r7, #0x58
 8003282: 46bd         	mov	sp, r7
 8003284: ecbd 8b02    	vpop	{d8}
 8003288: bd80         	pop	{r7, pc}
 800328a: bf00         	nop

0800328c <$d>:
 800328c: 00 00 c8 42  	.word	0x42c80000

08003290 <IMU_Sensor_trig_handler>:
; {
 8003290: b590         	push	{r4, r7, lr}
 8003292: b097         	sub	sp, #0x5c
 8003294: af00         	add	r7, sp, #0x0
 8003296: 6078         	str	r0, [r7, #0x4]
 8003298: 6039         	str	r1, [r7]
; 	if (trigger->type != SENSOR_TRIG_DATA_READY) {
 800329a: 683b         	ldr	r3, [r7]
 800329c: 881b         	ldrh	r3, [r3]
 800329e: 2b01         	cmp	r3, #0x1
 80032a0: f040 80ab    	bne.w	0x80033fa <IMU_Sensor_trig_handler+0x16a> @ imm = #0x156
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80032a4: f3ef 8311    	mrs	r3, basepri
 80032a8: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 80032aa: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 80032ac: 64bb         	str	r3, [r7, #0x48]
 80032ae: 2310         	movs	r3, #0x10
 80032b0: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80032b2: 6c7b         	ldr	r3, [r7, #0x44]
 80032b4: f383 8812    	msr	basepri_max, r3
; }
 80032b8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80032ba: f3bf 8f6f    	isb	sy
; }
 80032be: bf00         	nop
; 	return key;
 80032c0: 6cbb         	ldr	r3, [r7, #0x48]
; 	unsigned int key = arch_irq_lock();
 80032c2: 657b         	str	r3, [r7, #0x54]
; 	int current_cyc = k_cycle_get_32();
 80032c4: f016 fdd0    	bl	0x8019e68 <k_cycle_get_32> @ imm = #0x16ba0
 80032c8: 4603         	mov	r3, r0
 80032ca: 653b         	str	r3, [r7, #0x50]
; 	sensor_sample_fetch(dev);
 80032cc: 6878         	ldr	r0, [r7, #0x4]
 80032ce: f016 fe73    	bl	0x8019fb8 <sensor_sample_fetch> @ imm = #0x16ce6
; 	if (trigger->chan == SENSOR_CHAN_ACCEL_XYZ) {
 80032d2: 683b         	ldr	r3, [r7]
 80032d4: 885b         	ldrh	r3, [r3, #0x2]
 80032d6: 2b03         	cmp	r3, #0x3
 80032d8: d149         	bne	0x800336e <IMU_Sensor_trig_handler+0xde> @ imm = #0x92
; 		sensor_channel_get(dev, SENSOR_CHAN_ACCEL_XYZ, accel_data);
 80032da: f107 0324    	add.w	r3, r7, #0x24
 80032de: 461a         	mov	r2, r3
 80032e0: 2103         	movs	r1, #0x3
 80032e2: 6878         	ldr	r0, [r7, #0x4]
 80032e4: f016 fe74    	bl	0x8019fd0 <sensor_channel_get> @ imm = #0x16ce8
; 		INS.flag |= 1;
 80032e8: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 80032ea: f893 3024    	ldrb.w	r3, [r3, #0x24]
 80032ee: f043 0301    	orr	r3, r3, #0x1
 80032f2: b2da         	uxtb	r2, r3
 80032f4: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 80032f6: f883 2024    	strb.w	r2, [r3, #0x24]
; 		INS.accel_curr_cyc = current_cyc;
 80032fa: 4a42         	ldr	r2, [pc, #0x108]        @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 80032fc: 6d3b         	ldr	r3, [r7, #0x50]
 80032fe: 6393         	str	r3, [r2, #0x38]
; 		INS.Accel[X] = sensor_value_to_float(&accel_data[X]);
 8003300: 2300         	movs	r3, #0x0
 8003302: f107 0224    	add.w	r2, r7, #0x24
 8003306: 00db         	lsls	r3, r3, #0x3
 8003308: 4413         	add	r3, r2
 800330a: 2400         	movs	r4, #0x0
 800330c: 4618         	mov	r0, r3
 800330e: f7fd fc9d    	bl	0x8000c4c <sensor_value_to_float> @ imm = #-0x26c6
 8003312: eef0 7a40    	vmov.f32	s15, s0
 8003316: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 8003318: 1ca3         	adds	r3, r4, #0x2
 800331a: 009b         	lsls	r3, r3, #0x2
 800331c: 4413         	add	r3, r2
 800331e: 3304         	adds	r3, #0x4
 8003320: edc3 7a00    	vstr	s15, [r3]
; 		INS.Accel[Y] = sensor_value_to_float(&accel_data[Y]);
 8003324: 2301         	movs	r3, #0x1
 8003326: f107 0224    	add.w	r2, r7, #0x24
 800332a: 00db         	lsls	r3, r3, #0x3
 800332c: 4413         	add	r3, r2
 800332e: 2401         	movs	r4, #0x1
 8003330: 4618         	mov	r0, r3
 8003332: f7fd fc8b    	bl	0x8000c4c <sensor_value_to_float> @ imm = #-0x26ea
 8003336: eef0 7a40    	vmov.f32	s15, s0
 800333a: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 800333c: 1ca3         	adds	r3, r4, #0x2
 800333e: 009b         	lsls	r3, r3, #0x2
 8003340: 4413         	add	r3, r2
 8003342: 3304         	adds	r3, #0x4
 8003344: edc3 7a00    	vstr	s15, [r3]
; 		INS.Accel[Z] = sensor_value_to_float(&accel_data[Z]);
 8003348: 2302         	movs	r3, #0x2
 800334a: f107 0224    	add.w	r2, r7, #0x24
 800334e: 00db         	lsls	r3, r3, #0x3
 8003350: 4413         	add	r3, r2
 8003352: 2402         	movs	r4, #0x2
 8003354: 4618         	mov	r0, r3
 8003356: f7fd fc79    	bl	0x8000c4c <sensor_value_to_float> @ imm = #-0x270e
 800335a: eef0 7a40    	vmov.f32	s15, s0
 800335e: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 8003360: 1ca3         	adds	r3, r4, #0x2
 8003362: 009b         	lsls	r3, r3, #0x2
 8003364: 4413         	add	r3, r2
 8003366: 3304         	adds	r3, #0x4
 8003368: edc3 7a00    	vstr	s15, [r3]
 800336c: e036         	b	0x80033dc <IMU_Sensor_trig_handler+0x14c> @ imm = #0x6c
; 	} else if (trigger->chan == SENSOR_CHAN_GYRO_XYZ) {
 800336e: 683b         	ldr	r3, [r7]
 8003370: 885b         	ldrh	r3, [r3, #0x2]
 8003372: 2b07         	cmp	r3, #0x7
 8003374: d132         	bne	0x80033dc <IMU_Sensor_trig_handler+0x14c> @ imm = #0x64
; 		sensor_channel_get(dev, SENSOR_CHAN_GYRO_XYZ, gyro_data);
 8003376: f107 030c    	add.w	r3, r7, #0xc
 800337a: 461a         	mov	r2, r3
 800337c: 2107         	movs	r1, #0x7
 800337e: 6878         	ldr	r0, [r7, #0x4]
 8003380: f016 fe26    	bl	0x8019fd0 <sensor_channel_get> @ imm = #0x16c4c
; 		INS.flag |= 2;
 8003384: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 8003386: f893 3024    	ldrb.w	r3, [r3, #0x24]
 800338a: f043 0302    	orr	r3, r3, #0x2
 800338e: b2da         	uxtb	r2, r3
 8003390: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 8003392: f883 2024    	strb.w	r2, [r3, #0x24]
; 		INS.gyro_curr_cyc = current_cyc;
 8003396: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 8003398: 6d3b         	ldr	r3, [r7, #0x50]
 800339a: 6353         	str	r3, [r2, #0x34]
; 		INS.Gyro[0] = sensor_value_to_float(&gyro_data[0]);
 800339c: f107 030c    	add.w	r3, r7, #0xc
 80033a0: 4618         	mov	r0, r3
 80033a2: f7fd fc53    	bl	0x8000c4c <sensor_value_to_float> @ imm = #-0x275a
 80033a6: eef0 7a40    	vmov.f32	s15, s0
 80033aa: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 80033ac: edc3 7a00    	vstr	s15, [r3]
; 		INS.Gyro[1] = sensor_value_to_float(&gyro_data[1]);
 80033b0: f107 030c    	add.w	r3, r7, #0xc
 80033b4: 3308         	adds	r3, #0x8
 80033b6: 4618         	mov	r0, r3
 80033b8: f7fd fc48    	bl	0x8000c4c <sensor_value_to_float> @ imm = #-0x2770
 80033bc: eef0 7a40    	vmov.f32	s15, s0
 80033c0: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 80033c2: edc3 7a01    	vstr	s15, [r3, #4]
; 		INS.Gyro[2] = sensor_value_to_float(&gyro_data[2]);
 80033c6: f107 030c    	add.w	r3, r7, #0xc
 80033ca: 3310         	adds	r3, #0x10
 80033cc: 4618         	mov	r0, r3
 80033ce: f7fd fc3d    	bl	0x8000c4c <sensor_value_to_float> @ imm = #-0x2786
 80033d2: eef0 7a40    	vmov.f32	s15, s0
 80033d6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 80033d8: edc3 7a02    	vstr	s15, [r3, #8]
; 	IMU_Sensor_handle_update(&INS);
 80033dc: 4809         	ldr	r0, [pc, #0x24]         @ 0x8003404 <IMU_Sensor_trig_handler+0x174>
 80033de: f7ff fd3b    	bl	0x8002e58 <IMU_Sensor_handle_update> @ imm = #-0x58a
 80033e2: 6d7b         	ldr	r3, [r7, #0x54]
 80033e4: 643b         	str	r3, [r7, #0x40]
 80033e6: 6c3b         	ldr	r3, [r7, #0x40]
 80033e8: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80033ea: 6bfb         	ldr	r3, [r7, #0x3c]
 80033ec: f383 8811    	msr	basepri, r3
; }
 80033f0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80033f2: f3bf 8f6f    	isb	sy
; }
 80033f6: bf00         	nop
; }
 80033f8: e000         	b	0x80033fc <IMU_Sensor_trig_handler+0x16c> @ imm = #0x0
; 		return;
 80033fa: bf00         	nop
; }
 80033fc: 375c         	adds	r7, #0x5c
 80033fe: 46bd         	mov	sp, r7
 8003400: bd90         	pop	{r4, r7, pc}
 8003402: bf00         	nop

08003404 <$d>:
 8003404: 3c 2b 00 20  	.word	0x20002b3c

08003408 <IMU_Sensor_trig_init>:
; {
 8003408: b580         	push	{r7, lr}
 800340a: b088         	sub	sp, #0x20
 800340c: af00         	add	r7, sp, #0x0
 800340e: 6078         	str	r0, [r7, #0x4]
 8003410: 6039         	str	r1, [r7]
; 	IMU_Param.scale[X] = 1;
 8003412: 2300         	movs	r3, #0x0
 8003414: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x80034d4 <IMU_Sensor_trig_init+0xcc>
 8003416: 009b         	lsls	r3, r3, #0x2
 8003418: 4413         	add	r3, r2
 800341a: 3304         	adds	r3, #0x4
 800341c: f04f 527e    	mov.w	r2, #0x3f800000
 8003420: 601a         	str	r2, [r3]
; 	IMU_Param.scale[Y] = 1;
 8003422: 2301         	movs	r3, #0x1
 8003424: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x80034d4 <IMU_Sensor_trig_init+0xcc>
 8003426: 009b         	lsls	r3, r3, #0x2
 8003428: 4413         	add	r3, r2
 800342a: 3304         	adds	r3, #0x4
 800342c: f04f 527e    	mov.w	r2, #0x3f800000
 8003430: 601a         	str	r2, [r3]
; 	IMU_Param.scale[Z] = 1;
 8003432: 2302         	movs	r3, #0x2
 8003434: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x80034d4 <IMU_Sensor_trig_init+0xcc>
 8003436: 009b         	lsls	r3, r3, #0x2
 8003438: 4413         	add	r3, r2
 800343a: 3304         	adds	r3, #0x4
 800343c: f04f 527e    	mov.w	r2, #0x3f800000
 8003440: 601a         	str	r2, [r3]
; 	IMU_Param.Yaw = 0;
 8003442: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80034d4 <IMU_Sensor_trig_init+0xcc>
 8003444: f04f 0200    	mov.w	r2, #0x0
 8003448: 611a         	str	r2, [r3, #0x10]
; 	IMU_Param.Pitch = 0;
 800344a: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80034d4 <IMU_Sensor_trig_init+0xcc>
 800344c: f04f 0200    	mov.w	r2, #0x0
 8003450: 615a         	str	r2, [r3, #0x14]
; 	IMU_Param.Roll = 0;
 8003452: 4b20         	ldr	r3, [pc, #0x80]         @ 0x80034d4 <IMU_Sensor_trig_init+0xcc>
 8003454: f04f 0200    	mov.w	r2, #0x0
 8003458: 619a         	str	r2, [r3, #0x18]
; 	IMU_Param.flag = 1;
 800345a: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80034d4 <IMU_Sensor_trig_init+0xcc>
 800345c: 2201         	movs	r2, #0x1
 800345e: 701a         	strb	r2, [r3]
; 	float init_quaternion[4] = {0};
 8003460: f107 030c    	add.w	r3, r7, #0xc
 8003464: 2200         	movs	r2, #0x0
 8003466: 601a         	str	r2, [r3]
 8003468: 605a         	str	r2, [r3, #0x4]
 800346a: 609a         	str	r2, [r3, #0x8]
 800346c: 60da         	str	r2, [r3, #0xc]
; 	InitQuaternion(accel_dev, init_quaternion, INS.lpf_Accel);
 800346e: f107 030c    	add.w	r3, r7, #0xc
 8003472: 4a19         	ldr	r2, [pc, #0x64]         @ 0x80034d8 <IMU_Sensor_trig_init+0xd0>
 8003474: 4619         	mov	r1, r3
 8003476: 6878         	ldr	r0, [r7, #0x4]
 8003478: f7ff fddc    	bl	0x8003034 <InitQuaternion> @ imm = #-0x448
; 	IMU_QuaternionEKF_Init(init_quaternion, 10, 0.001, 100000, 1, 0.95);
 800347c: f107 030c    	add.w	r3, r7, #0xc
 8003480: ed9f 2a16    	vldr	s4, [pc, #88]           @ 0x80034dc <IMU_Sensor_trig_init+0xd4>
 8003484: eef7 1a00    	vmov.f32	s3, #1.000000e+00
 8003488: ed9f 1a15    	vldr	s2, [pc, #84]           @ 0x80034e0 <IMU_Sensor_trig_init+0xd8>
 800348c: eddf 0a15    	vldr	s1, [pc, #84]           @ 0x80034e4 <IMU_Sensor_trig_init+0xdc>
 8003490: eeb2 0a04    	vmov.f32	s0, #1.000000e+01
 8003494: 4618         	mov	r0, r3
 8003496: f7fe fa77    	bl	0x8001988 <IMU_QuaternionEKF_Init> @ imm = #-0x1b12
; 	int current_cyc = k_cycle_get_32();
 800349a: f016 fce5    	bl	0x8019e68 <k_cycle_get_32> @ imm = #0x169ca
 800349e: 4603         	mov	r3, r0
 80034a0: 61fb         	str	r3, [r7, #0x1c]
; 	INS.gyro_prev_cyc = current_cyc;
 80034a2: 4a11         	ldr	r2, [pc, #0x44]         @ 0x80034e8 <IMU_Sensor_trig_init+0xe0>
 80034a4: 69fb         	ldr	r3, [r7, #0x1c]
 80034a6: 6293         	str	r3, [r2, #0x28]
; 	INS.accel_prev_cyc = current_cyc;
 80034a8: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x80034e8 <IMU_Sensor_trig_init+0xe0>
 80034aa: 69fb         	ldr	r3, [r7, #0x1c]
 80034ac: 62d3         	str	r3, [r2, #0x2c]
; 	INS.flag = 0;
 80034ae: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80034e8 <IMU_Sensor_trig_init+0xe0>
 80034b0: 2200         	movs	r2, #0x0
 80034b2: f883 2024    	strb.w	r2, [r3, #0x24]
; 	sensor_trigger_set(accel_dev, &accel_trig, IMU_Sensor_trig_handler);
 80034b6: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x80034ec <IMU_Sensor_trig_init+0xe4>
 80034b8: 490d         	ldr	r1, [pc, #0x34]         @ 0x80034f0 <IMU_Sensor_trig_init+0xe8>
 80034ba: 6878         	ldr	r0, [r7, #0x4]
 80034bc: f016 fd3b    	bl	0x8019f36 <sensor_trigger_set> @ imm = #0x16a76
; 	sensor_trigger_set(gyro_dev, &gyro_trig, IMU_Sensor_trig_handler);
 80034c0: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80034ec <IMU_Sensor_trig_init+0xe4>
 80034c2: 490c         	ldr	r1, [pc, #0x30]         @ 0x80034f4 <IMU_Sensor_trig_init+0xec>
 80034c4: 6838         	ldr	r0, [r7]
 80034c6: f016 fd36    	bl	0x8019f36 <sensor_trigger_set> @ imm = #0x16a6c
; }
 80034ca: bf00         	nop
 80034cc: 3720         	adds	r7, #0x20
 80034ce: 46bd         	mov	sp, r7
 80034d0: bd80         	pop	{r7, pc}
 80034d2: bf00         	nop

080034d4 <$d>:
 80034d4: 20 2b 00 20  	.word	0x20002b20
 80034d8: 54 2b 00 20  	.word	0x20002b54
 80034dc: 33 33 73 3f  	.word	0x3f733333
 80034e0: 00 50 c3 47  	.word	0x47c35000
 80034e4: 6f 12 83 3a  	.word	0x3a83126f
 80034e8: 3c 2b 00 20  	.word	0x20002b3c
 80034ec: 91 32 00 08  	.word	0x08003291
 80034f0: 98 04 00 20  	.word	0x20000498
 80034f4: 9c 04 00 20  	.word	0x2000049c

080034f8 <jf_send_float>:
; {
 80034f8: b580         	push	{r7, lr}
 80034fa: b084         	sub	sp, #0x10
 80034fc: af00         	add	r7, sp, #0x0
 80034fe: 6078         	str	r0, [r7, #0x4]
; 	const struct device *uart_dev = data->uart_dev;
 8003500: 687b         	ldr	r3, [r7, #0x4]
 8003502: 681b         	ldr	r3, [r3]
 8003504: 60bb         	str	r3, [r7, #0x8]
; 	for (int i = 0; i < data->channel; i++) {
 8003506: 2300         	movs	r3, #0x0
 8003508: 60fb         	str	r3, [r7, #0xc]
 800350a: e01a         	b	0x8003542 <jf_send_float+0x4a> @ imm = #0x34
; 		if (data->fdata[i] == *(float *)tail) {
 800350c: 687a         	ldr	r2, [r7, #0x4]
 800350e: 68fb         	ldr	r3, [r7, #0xc]
 8003510: 3318         	adds	r3, #0x18
 8003512: 009b         	lsls	r3, r3, #0x2
 8003514: 4413         	add	r3, r2
 8003516: 3304         	adds	r3, #0x4
 8003518: ed93 7a00    	vldr	s14, [r3]
 800351c: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80035ac <jf_send_float+0xb4>
 800351e: edd3 7a00    	vldr	s15, [r3]
 8003522: eeb4 7a67    	vcmp.f32	s14, s15
 8003526: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800352a: d107         	bne	0x800353c <jf_send_float+0x44> @ imm = #0xe
; 			data->fdata[i] = 1e+6;
 800352c: 687a         	ldr	r2, [r7, #0x4]
 800352e: 68fb         	ldr	r3, [r7, #0xc]
 8003530: 3318         	adds	r3, #0x18
 8003532: 009b         	lsls	r3, r3, #0x2
 8003534: 4413         	add	r3, r2
 8003536: 3304         	adds	r3, #0x4
 8003538: 4a1d         	ldr	r2, [pc, #0x74]         @ 0x80035b0 <jf_send_float+0xb8>
 800353a: 601a         	str	r2, [r3]
; 	for (int i = 0; i < data->channel; i++) {
 800353c: 68fb         	ldr	r3, [r7, #0xc]
 800353e: 3301         	adds	r3, #0x1
 8003540: 60fb         	str	r3, [r7, #0xc]
 8003542: 687b         	ldr	r3, [r7, #0x4]
 8003544: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003548: 68fa         	ldr	r2, [r7, #0xc]
 800354a: 429a         	cmp	r2, r3
 800354c: dbde         	blt	0x800350c <jf_send_float+0x14> @ imm = #-0x44
; 	if (data->fdata[data->channel] != *(float *)tail) {
 800354e: 687b         	ldr	r3, [r7, #0x4]
 8003550: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003554: 687a         	ldr	r2, [r7, #0x4]
 8003556: 3318         	adds	r3, #0x18
 8003558: 009b         	lsls	r3, r3, #0x2
 800355a: 4413         	add	r3, r2
 800355c: 3304         	adds	r3, #0x4
 800355e: ed93 7a00    	vldr	s14, [r3]
 8003562: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80035ac <jf_send_float+0xb4>
 8003564: edd3 7a00    	vldr	s15, [r3]
 8003568: eeb4 7a67    	vcmp.f32	s14, s15
 800356c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003570: d00a         	beq	0x8003588 <jf_send_float+0x90> @ imm = #0x14
; 		memcpy(&(data->fdata[data->channel]), tail, 4 * sizeof(uint8_t));
 8003572: 687b         	ldr	r3, [r7, #0x4]
 8003574: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003578: 3318         	adds	r3, #0x18
 800357a: 009b         	lsls	r3, r3, #0x2
 800357c: 687a         	ldr	r2, [r7, #0x4]
 800357e: 4413         	add	r3, r2
 8003580: 3304         	adds	r3, #0x4
 8003582: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80035ac <jf_send_float+0xb4>
 8003584: 6810         	ldr	r0, [r2]
 8003586: 6018         	str	r0, [r3]
; 	uart_tx(uart_dev, (const uint8_t *)data->fdata, data->channel * 4 + 4, SYS_FOREVER_US);
 8003588: 687b         	ldr	r3, [r7, #0x4]
 800358a: f103 0164    	add.w	r1, r3, #0x64
 800358e: 687b         	ldr	r3, [r7, #0x4]
 8003590: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003594: 3301         	adds	r3, #0x1
 8003596: 009b         	lsls	r3, r3, #0x2
 8003598: 461a         	mov	r2, r3
 800359a: f04f 33ff    	mov.w	r3, #0xffffffff
 800359e: 68b8         	ldr	r0, [r7, #0x8]
 80035a0: f017 f837    	bl	0x801a612 <uart_tx>     @ imm = #0x1706e
; }
 80035a4: bf00         	nop
 80035a6: 3710         	adds	r7, #0x10
 80035a8: 46bd         	mov	sp, r7
 80035aa: bd80         	pop	{r7, pc}

080035ac <$d>:
 80035ac: 78 a7 02 08  	.word	0x0802a778
 80035b0: 00 24 74 49  	.word	0x49742400

080035b4 <jf_feedback>:
; {
 80035b4: b580         	push	{r7, lr}
 80035b6: b088         	sub	sp, #0x20
 80035b8: af00         	add	r7, sp, #0x0
 80035ba: 60f8         	str	r0, [r7, #0xc]
 80035bc: 60b9         	str	r1, [r7, #0x8]
 80035be: 607a         	str	r2, [r7, #0x4]
; 	int delay = (int)arg1;
 80035c0: 68fb         	ldr	r3, [r7, #0xc]
 80035c2: 61bb         	str	r3, [r7, #0x18]
; 	struct JFData *data = (struct JFData *)arg2;
 80035c4: 68bb         	ldr	r3, [r7, #0x8]
 80035c6: 617b         	str	r3, [r7, #0x14]
; 		k_msleep(delay);
 80035c8: 69b8         	ldr	r0, [r7, #0x18]
 80035ca: f016 fc21    	bl	0x8019e10 <k_msleep>    @ imm = #0x16842
; 		if (data->channel == 0) {
 80035ce: 697b         	ldr	r3, [r7, #0x14]
 80035d0: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80035d4: 2b00         	cmp	r3, #0x0
 80035d6: f000 8082    	beq.w	0x80036de <jf_feedback+0x12a> @ imm = #0x104
; 		for (int i = 0; i < data->channel; i++) {
 80035da: 2300         	movs	r3, #0x0
 80035dc: 61fb         	str	r3, [r7, #0x1c]
 80035de: e074         	b	0x80036ca <jf_feedback+0x116> @ imm = #0xe8
; 			switch (data->types[i]) {
 80035e0: 697a         	ldr	r2, [r7, #0x14]
 80035e2: 69fb         	ldr	r3, [r7, #0x1c]
 80035e4: 4413         	add	r3, r2
 80035e6: 33c4         	adds	r3, #0xc4
 80035e8: 781b         	ldrb	r3, [r3]
 80035ea: 2b04         	cmp	r3, #0x4
 80035ec: d869         	bhi	0x80036c2 <jf_feedback+0x10e> @ imm = #0xd2
 80035ee: a201         	adr	r2, #4 <jf_feedback+0x3f>
 80035f0: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

080035f4 <$d>:
 80035f4: 09 36 00 08  	.word	0x08003609
 80035f8: 2f 36 00 08  	.word	0x0800362f
 80035fc: 4b 36 00 08  	.word	0x0800364b
 8003600: 73 36 00 08  	.word	0x08003673
 8003604: 9b 36 00 08  	.word	0x0800369b

08003608 <$t>:
; 				data->fdata[i] = *(int *)data->data_ptr[i];
 8003608: 697a         	ldr	r2, [r7, #0x14]
 800360a: 69fb         	ldr	r3, [r7, #0x1c]
 800360c: 009b         	lsls	r3, r3, #0x2
 800360e: 4413         	add	r3, r2
 8003610: 685b         	ldr	r3, [r3, #0x4]
 8003612: 681b         	ldr	r3, [r3]
 8003614: ee07 3a90    	vmov	s15, r3
 8003618: eef8 7ae7    	vcvt.f32.s32	s15, s15
 800361c: 697a         	ldr	r2, [r7, #0x14]
 800361e: 69fb         	ldr	r3, [r7, #0x1c]
 8003620: 3318         	adds	r3, #0x18
 8003622: 009b         	lsls	r3, r3, #0x2
 8003624: 4413         	add	r3, r2
 8003626: 3304         	adds	r3, #0x4
 8003628: edc3 7a00    	vstr	s15, [r3]
; 				break;
 800362c: e04a         	b	0x80036c4 <jf_feedback+0x110> @ imm = #0x94
; 				data->fdata[i] = *(float *)data->data_ptr[i];
 800362e: 697a         	ldr	r2, [r7, #0x14]
 8003630: 69fb         	ldr	r3, [r7, #0x1c]
 8003632: 009b         	lsls	r3, r3, #0x2
 8003634: 4413         	add	r3, r2
 8003636: 685b         	ldr	r3, [r3, #0x4]
 8003638: 681a         	ldr	r2, [r3]
 800363a: 6979         	ldr	r1, [r7, #0x14]
 800363c: 69fb         	ldr	r3, [r7, #0x1c]
 800363e: 3318         	adds	r3, #0x18
 8003640: 009b         	lsls	r3, r3, #0x2
 8003642: 440b         	add	r3, r1
 8003644: 3304         	adds	r3, #0x4
 8003646: 601a         	str	r2, [r3]
; 				break;
 8003648: e03c         	b	0x80036c4 <jf_feedback+0x110> @ imm = #0x78
; 				data->fdata[i] = *(double *)data->data_ptr[i];
 800364a: 697a         	ldr	r2, [r7, #0x14]
 800364c: 69fb         	ldr	r3, [r7, #0x1c]
 800364e: 009b         	lsls	r3, r3, #0x2
 8003650: 4413         	add	r3, r2
 8003652: 685b         	ldr	r3, [r3, #0x4]
 8003654: e9d3 2300    	ldrd	r2, r3, [r3]
 8003658: 4610         	mov	r0, r2
 800365a: 4619         	mov	r1, r3
 800365c: f7fc ff50    	bl	0x8000500 <__truncdfsf2> @ imm = #-0x3160
 8003660: 4601         	mov	r1, r0
 8003662: 697a         	ldr	r2, [r7, #0x14]
 8003664: 69fb         	ldr	r3, [r7, #0x1c]
 8003666: 3318         	adds	r3, #0x18
 8003668: 009b         	lsls	r3, r3, #0x2
 800366a: 4413         	add	r3, r2
 800366c: 3304         	adds	r3, #0x4
 800366e: 6019         	str	r1, [r3]
; 				break;
 8003670: e028         	b	0x80036c4 <jf_feedback+0x110> @ imm = #0x50
; 				data->fdata[i] = *(int8_t *)data->data_ptr[i];
 8003672: 697a         	ldr	r2, [r7, #0x14]
 8003674: 69fb         	ldr	r3, [r7, #0x1c]
 8003676: 009b         	lsls	r3, r3, #0x2
 8003678: 4413         	add	r3, r2
 800367a: 685b         	ldr	r3, [r3, #0x4]
 800367c: f993 3000    	ldrsb.w	r3, [r3]
 8003680: ee07 3a90    	vmov	s15, r3
 8003684: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8003688: 697a         	ldr	r2, [r7, #0x14]
 800368a: 69fb         	ldr	r3, [r7, #0x1c]
 800368c: 3318         	adds	r3, #0x18
 800368e: 009b         	lsls	r3, r3, #0x2
 8003690: 4413         	add	r3, r2
 8003692: 3304         	adds	r3, #0x4
 8003694: edc3 7a00    	vstr	s15, [r3]
; 				break;
 8003698: e014         	b	0x80036c4 <jf_feedback+0x110> @ imm = #0x28
; 				data->fdata[i] = *(int16_t *)data->data_ptr[i];
 800369a: 697a         	ldr	r2, [r7, #0x14]
 800369c: 69fb         	ldr	r3, [r7, #0x1c]
 800369e: 009b         	lsls	r3, r3, #0x2
 80036a0: 4413         	add	r3, r2
 80036a2: 685b         	ldr	r3, [r3, #0x4]
 80036a4: f9b3 3000    	ldrsh.w	r3, [r3]
 80036a8: ee07 3a90    	vmov	s15, r3
 80036ac: eef8 7ae7    	vcvt.f32.s32	s15, s15
 80036b0: 697a         	ldr	r2, [r7, #0x14]
 80036b2: 69fb         	ldr	r3, [r7, #0x1c]
 80036b4: 3318         	adds	r3, #0x18
 80036b6: 009b         	lsls	r3, r3, #0x2
 80036b8: 4413         	add	r3, r2
 80036ba: 3304         	adds	r3, #0x4
 80036bc: edc3 7a00    	vstr	s15, [r3]
; 				break;
 80036c0: e000         	b	0x80036c4 <jf_feedback+0x110> @ imm = #0x0
; 				break;
 80036c2: bf00         	nop
; 		for (int i = 0; i < data->channel; i++) {
 80036c4: 69fb         	ldr	r3, [r7, #0x1c]
 80036c6: 3301         	adds	r3, #0x1
 80036c8: 61fb         	str	r3, [r7, #0x1c]
 80036ca: 697b         	ldr	r3, [r7, #0x14]
 80036cc: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80036d0: 69fa         	ldr	r2, [r7, #0x1c]
 80036d2: 429a         	cmp	r2, r3
 80036d4: db84         	blt	0x80035e0 <jf_feedback+0x2c> @ imm = #-0xf8
; 		jf_send_float(data);
 80036d6: 6978         	ldr	r0, [r7, #0x14]
 80036d8: f7ff ff0e    	bl	0x80034f8 <jf_send_float> @ imm = #-0x1e4
 80036dc: e774         	b	0x80035c8 <jf_feedback+0x14> @ imm = #-0x118
; 			continue;
 80036de: bf00         	nop
; 		k_msleep(delay);
 80036e0: e772         	b	0x80035c8 <jf_feedback+0x14> @ imm = #-0x11c
 80036e2: bf00         	nop

080036e4 <jf_channel_add>:
; {
 80036e4: b480         	push	{r7}
 80036e6: b085         	sub	sp, #0x14
 80036e8: af00         	add	r7, sp, #0x0
 80036ea: 60f8         	str	r0, [r7, #0xc]
 80036ec: 60b9         	str	r1, [r7, #0x8]
 80036ee: 4613         	mov	r3, r2
 80036f0: 71fb         	strb	r3, [r7, #0x7]
; 	if (data->channel < 24) {
 80036f2: 68fb         	ldr	r3, [r7, #0xc]
 80036f4: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80036f8: 2b17         	cmp	r3, #0x17
 80036fa: dc21         	bgt	0x8003740 <jf_channel_add+0x5c> @ imm = #0x42
; 		if (type == RAW) {
 80036fc: 79fb         	ldrb	r3, [r7, #0x7]
 80036fe: 2b08         	cmp	r3, #0x8
 8003700: d10b         	bne	0x800371a <jf_channel_add+0x36> @ imm = #0x16
; 			data->fdata[data->channel] = *(float *)value;
 8003702: 68fb         	ldr	r3, [r7, #0xc]
 8003704: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003708: 68ba         	ldr	r2, [r7, #0x8]
 800370a: 6812         	ldr	r2, [r2]
 800370c: 68f9         	ldr	r1, [r7, #0xc]
 800370e: 3318         	adds	r3, #0x18
 8003710: 009b         	lsls	r3, r3, #0x2
 8003712: 440b         	add	r3, r1
 8003714: 3304         	adds	r3, #0x4
 8003716: 601a         	str	r2, [r3]
 8003718: e012         	b	0x8003740 <jf_channel_add+0x5c> @ imm = #0x24
; 			data->fdata[data->channel] = *(float *)value;
 800371a: 68fb         	ldr	r3, [r7, #0xc]
 800371c: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003720: 68ba         	ldr	r2, [r7, #0x8]
 8003722: 6812         	ldr	r2, [r2]
 8003724: 68f9         	ldr	r1, [r7, #0xc]
 8003726: 3318         	adds	r3, #0x18
 8003728: 009b         	lsls	r3, r3, #0x2
 800372a: 440b         	add	r3, r1
 800372c: 3304         	adds	r3, #0x4
 800372e: 601a         	str	r2, [r3]
; 			data->data_ptr[data->channel] = value;
 8003730: 68fb         	ldr	r3, [r7, #0xc]
 8003732: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003736: 68fa         	ldr	r2, [r7, #0xc]
 8003738: 009b         	lsls	r3, r3, #0x2
 800373a: 4413         	add	r3, r2
 800373c: 68ba         	ldr	r2, [r7, #0x8]
 800373e: 605a         	str	r2, [r3, #0x4]
; 	data->types[data->channel] = type;
 8003740: 68fb         	ldr	r3, [r7, #0xc]
 8003742: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003746: 68fa         	ldr	r2, [r7, #0xc]
 8003748: 4413         	add	r3, r2
 800374a: 79fa         	ldrb	r2, [r7, #0x7]
 800374c: f883 20c4    	strb.w	r2, [r3, #0xc4]
; 	data->channel++;
 8003750: 68fb         	ldr	r3, [r7, #0xc]
 8003752: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003756: 1c5a         	adds	r2, r3, #0x1
 8003758: 68fb         	ldr	r3, [r7, #0xc]
 800375a: f8c3 20dc    	str.w	r2, [r3, #0xdc]
; 	data->types[data->channel] = RAW;
 800375e: 68fb         	ldr	r3, [r7, #0xc]
 8003760: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003764: 68fa         	ldr	r2, [r7, #0xc]
 8003766: 4413         	add	r3, r2
 8003768: 2208         	movs	r2, #0x8
 800376a: f883 20c4    	strb.w	r2, [r3, #0xc4]
; 	memcpy(&(data->fdata[data->channel]), tail, 4 * sizeof(uint8_t));
 800376e: 68fb         	ldr	r3, [r7, #0xc]
 8003770: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8003774: 3318         	adds	r3, #0x18
 8003776: 009b         	lsls	r3, r3, #0x2
 8003778: 68fa         	ldr	r2, [r7, #0xc]
 800377a: 4413         	add	r3, r2
 800377c: 3304         	adds	r3, #0x4
 800377e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8003790 <jf_channel_add+0xac>
 8003780: 6810         	ldr	r0, [r2]
 8003782: 6018         	str	r0, [r3]
; }
 8003784: bf00         	nop
 8003786: 3714         	adds	r7, #0x14
 8003788: 46bd         	mov	sp, r7
 800378a: f85d 7b04    	ldr	r7, [sp], #4
 800378e: 4770         	bx	lr

08003790 <$d>:
 8003790: 78 a7 02 08  	.word	0x0802a778

08003794 <jf_send_init>:
; {
 8003794: b580         	push	{r7, lr}
 8003796: b08a         	sub	sp, #0x28
 8003798: af08         	add	r7, sp, #0x20
 800379a: 6078         	str	r0, [r7, #0x4]
 800379c: 6039         	str	r1, [r7]
; 	aresPlotData.channel = 0;
 800379e: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8003824 <jf_send_init+0x90>
 80037a0: 2200         	movs	r2, #0x0
 80037a2: f8c3 20dc    	str.w	r2, [r3, #0xdc]
; 	if (!device_is_ready(uart_dev)) {
 80037a6: 6878         	ldr	r0, [r7, #0x4]
 80037a8: f016 fb1f    	bl	0x8019dea <device_is_ready> @ imm = #0x1663e
 80037ac: 4603         	mov	r3, r0
 80037ae: f083 0301    	eor	r3, r3, #0x1
 80037b2: b2db         	uxtb	r3, r3
 80037b4: 2b00         	cmp	r3, #0x0
 80037b6: d001         	beq	0x80037bc <jf_send_init+0x28> @ imm = #0x2
; 		return NULL;
 80037b8: 2100         	movs	r1, #0x0
 80037ba: e02e         	b	0x800381a <jf_send_init+0x86> @ imm = #0x5c
; 	aresPlotData.uart_dev = (struct device *)uart_dev;
 80037bc: 4a19         	ldr	r2, [pc, #0x64]         @ 0x8003824 <jf_send_init+0x90>
 80037be: 687b         	ldr	r3, [r7, #0x4]
 80037c0: 6013         	str	r3, [r2]
; 	memcpy(&(aresPlotData.fdata[aresPlotData.channel]), tail, 4 * sizeof(uint8_t));
 80037c2: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8003824 <jf_send_init+0x90>
 80037c4: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80037c8: 3318         	adds	r3, #0x18
 80037ca: 009b         	lsls	r3, r3, #0x2
 80037cc: 4a15         	ldr	r2, [pc, #0x54]         @ 0x8003824 <jf_send_init+0x90>
 80037ce: 4413         	add	r3, r2
 80037d0: 3304         	adds	r3, #0x4
 80037d2: 4a15         	ldr	r2, [pc, #0x54]         @ 0x8003828 <jf_send_init+0x94>
 80037d4: 6810         	ldr	r0, [r2]
 80037d6: 6018         	str	r0, [r3]
; 	aresPlotData.types[aresPlotData.channel] = RAW;
 80037d8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8003824 <jf_send_init+0x90>
 80037da: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80037de: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8003824 <jf_send_init+0x90>
 80037e0: 4413         	add	r3, r2
 80037e2: 2208         	movs	r2, #0x8
 80037e4: f883 20c4    	strb.w	r2, [r3, #0xc4]
; 	k_thread_create(&jf_thread_data, jf_stack_area, K_THREAD_STACK_SIZEOF(jf_stack_area),
 80037e8: 6839         	ldr	r1, [r7]
; 			jf_feedback, (void *)delay, &aresPlotData, NULL, -1, 0, K_NO_WAIT);
 80037ea: f04f 0200    	mov.w	r2, #0x0
 80037ee: f04f 0300    	mov.w	r3, #0x0
; 	k_thread_create(&jf_thread_data, jf_stack_area, K_THREAD_STACK_SIZEOF(jf_stack_area),
 80037f2: e9cd 2306    	strd	r2, r3, [sp, #24]
 80037f6: 2300         	movs	r3, #0x0
 80037f8: 9304         	str	r3, [sp, #0x10]
 80037fa: f04f 33ff    	mov.w	r3, #0xffffffff
 80037fe: 9303         	str	r3, [sp, #0xc]
 8003800: 2300         	movs	r3, #0x0
 8003802: 9302         	str	r3, [sp, #0x8]
 8003804: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8003824 <jf_send_init+0x90>
 8003806: 9301         	str	r3, [sp, #0x4]
 8003808: 9100         	str	r1, [sp]
 800380a: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800382c <jf_send_init+0x98>
 800380c: f44f 7240    	mov.w	r2, #0x300
 8003810: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8003830 <jf_send_init+0x9c>
 8003812: 4808         	ldr	r0, [pc, #0x20]         @ 0x8003834 <jf_send_init+0xa0>
 8003814: f016 fb2f    	bl	0x8019e76 <k_thread_create> @ imm = #0x1665e
; 	return &aresPlotData;
 8003818: 4902         	ldr	r1, [pc, #0x8]          @ 0x8003824 <jf_send_init+0x90>
; }
 800381a: 460b         	mov	r3, r1
 800381c: 4618         	mov	r0, r3
 800381e: 3708         	adds	r7, #0x8
 8003820: 46bd         	mov	sp, r7
 8003822: bd80         	pop	{r7, pc}

08003824 <$d>:
 8003824: 80 2b 00 20  	.word	0x20002b80
 8003828: 78 a7 02 08  	.word	0x0802a778
 800382c: b5 35 00 08  	.word	0x080035b5
 8003830: 08 33 00 20  	.word	0x20003308
 8003834: 80 0e 00 20  	.word	0x20000e80

08003838 <console_feedback>:
; {
 8003838: b590         	push	{r4, r7, lr}
 800383a: ed2d 8b02    	vpush	{d8}
 800383e: b087         	sub	sp, #0x1c
 8003840: af00         	add	r7, sp, #0x0
 8003842: 60f8         	str	r0, [r7, #0xc]
 8003844: 60b9         	str	r1, [r7, #0x8]
 8003846: 607a         	str	r2, [r7, #0x4]
; 	float angle = 0;
 8003848: f04f 0300    	mov.w	r3, #0x0
 800384c: 613b         	str	r3, [r7, #0x10]
; 	int cnt = 0;
 800384e: 2300         	movs	r3, #0x0
 8003850: 617b         	str	r3, [r7, #0x14]
; 		chassis_set_speed(chassis, sbus_get_percent(sbus, 3) * 3,
 8003852: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80038e8 <console_feedback+0xb0>
 8003854: 681c         	ldr	r4, [r3]
 8003856: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80038ec <console_feedback+0xb4>
 8003858: 681b         	ldr	r3, [r3]
 800385a: 2103         	movs	r1, #0x3
 800385c: 4618         	mov	r0, r3
 800385e: f016 fb58    	bl	0x8019f12 <sbus_get_percent> @ imm = #0x166b0
 8003862: eef0 7a40    	vmov.f32	s15, s0
 8003866: eeb0 7a08    	vmov.f32	s14, #3.000000e+00
 800386a: ee27 8a87    	vmul.f32	s16, s15, s14
; 				  sbus_get_percent(sbus, 1) * 3);
 800386e: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80038ec <console_feedback+0xb4>
 8003870: 681b         	ldr	r3, [r3]
 8003872: 2101         	movs	r1, #0x1
 8003874: 4618         	mov	r0, r3
 8003876: f016 fb4c    	bl	0x8019f12 <sbus_get_percent> @ imm = #0x16698
 800387a: eef0 7a40    	vmov.f32	s15, s0
; 		chassis_set_speed(chassis, sbus_get_percent(sbus, 3) * 3,
 800387e: eeb0 7a08    	vmov.f32	s14, #3.000000e+00
 8003882: ee67 7a87    	vmul.f32	s15, s15, s14
 8003886: eef0 0a67    	vmov.f32	s1, s15
 800388a: eeb0 0a48    	vmov.f32	s0, s16
 800388e: 4620         	mov	r0, r4
 8003890: f016 ff2b    	bl	0x801a6ea <chassis_set_speed> @ imm = #0x16e56
; 		chassis_set_gyro(chassis, sbus_get_percent(sbus, 0) * 5);
 8003894: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80038e8 <console_feedback+0xb0>
 8003896: 681c         	ldr	r4, [r3]
 8003898: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80038ec <console_feedback+0xb4>
 800389a: 681b         	ldr	r3, [r3]
 800389c: 2100         	movs	r1, #0x0
 800389e: 4618         	mov	r0, r3
 80038a0: f016 fb37    	bl	0x8019f12 <sbus_get_percent> @ imm = #0x1666e
 80038a4: eef0 7a40    	vmov.f32	s15, s0
 80038a8: eeb1 7a04    	vmov.f32	s14, #5.000000e+00
 80038ac: ee67 7a87    	vmul.f32	s15, s15, s14
 80038b0: eeb0 0a67    	vmov.f32	s0, s15
 80038b4: 4620         	mov	r0, r4
 80038b6: f016 ff3a    	bl	0x801a72e <chassis_set_gyro> @ imm = #0x16e74
; 		k_msleep(150);
 80038ba: 2096         	movs	r0, #0x96
 80038bc: f016 faa8    	bl	0x8019e10 <k_msleep>    @ imm = #0x16550
; 		cnt++;
 80038c0: 697b         	ldr	r3, [r7, #0x14]
 80038c2: 3301         	adds	r3, #0x1
 80038c4: 617b         	str	r3, [r7, #0x14]
; 		if (cnt % 50 == 0) {
 80038c6: 697a         	ldr	r2, [r7, #0x14]
 80038c8: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80038f0 <console_feedback+0xb8>
 80038ca: fb83 1302    	smull	r1, r3, r3, r2
 80038ce: 1119         	asrs	r1, r3, #0x4
 80038d0: 17d3         	asrs	r3, r2, #0x1f
 80038d2: 1acb         	subs	r3, r1, r3
 80038d4: 2132         	movs	r1, #0x32
 80038d6: fb01 f303    	mul	r3, r1, r3
 80038da: 1ad3         	subs	r3, r2, r3
 80038dc: 2b00         	cmp	r3, #0x0
 80038de: d1b8         	bne	0x8003852 <console_feedback+0x1a> @ imm = #-0x90
; 			thread_analyzer_print(NULL);
 80038e0: 2000         	movs	r0, #0x0
 80038e2: f000 fecf    	bl	0x8004684 <thread_analyzer_print> @ imm = #0xd9e
; 		chassis_set_speed(chassis, sbus_get_percent(sbus, 3) * 3,
 80038e6: e7b4         	b	0x8003852 <console_feedback+0x1a> @ imm = #-0x98

080038e8 <$d>:
 80038e8: ac 04 00 20  	.word	0x200004ac
 80038ec: b0 04 00 20  	.word	0x200004b0
 80038f0: 1f 85 eb 51  	.word	0x51eb851f

080038f4 <Sensor_update_cb>:
; {
 80038f4: b580         	push	{r7, lr}
 80038f6: b08a         	sub	sp, #0x28
 80038f8: af00         	add	r7, sp, #0x0
 80038fa: 6078         	str	r0, [r7, #0x4]
; 	struct pos_data pos = {0};
 80038fc: f107 030c    	add.w	r3, r7, #0xc
 8003900: 2200         	movs	r2, #0x0
 8003902: 601a         	str	r2, [r3]
 8003904: 605a         	str	r2, [r3, #0x4]
 8003906: 609a         	str	r2, [r3, #0x8]
 8003908: 60da         	str	r2, [r3, #0xc]
 800390a: 611a         	str	r2, [r3, #0x10]
 800390c: 615a         	str	r2, [r3, #0x14]
 800390e: 619a         	str	r2, [r3, #0x18]
; 	pos.Yaw = QEKF->Yaw;
 8003910: 687b         	ldr	r3, [r7, #0x4]
 8003912: f8d3 31a8    	ldr.w	r3, [r3, #0x1a8]
 8003916: 60fb         	str	r3, [r7, #0xc]
; 	pos.accel[0] = QEKF->Accel[X];
 8003918: 2300         	movs	r3, #0x0
 800391a: 687a         	ldr	r2, [r7, #0x4]
 800391c: 335e         	adds	r3, #0x5e
 800391e: 009b         	lsls	r3, r3, #0x2
 8003920: 4413         	add	r3, r2
 8003922: 681b         	ldr	r3, [r3]
 8003924: 613b         	str	r3, [r7, #0x10]
; 	pos.accel[1] = QEKF->Accel[Y];
 8003926: 2301         	movs	r3, #0x1
 8003928: 687a         	ldr	r2, [r7, #0x4]
 800392a: 335e         	adds	r3, #0x5e
 800392c: 009b         	lsls	r3, r3, #0x2
 800392e: 4413         	add	r3, r2
 8003930: 681b         	ldr	r3, [r3]
 8003932: 617b         	str	r3, [r7, #0x14]
; 	pos.accel[2] = QEKF->Accel[Z];
 8003934: 2302         	movs	r3, #0x2
 8003936: 687a         	ldr	r2, [r7, #0x4]
 8003938: 335e         	adds	r3, #0x5e
 800393a: 009b         	lsls	r3, r3, #0x2
 800393c: 4413         	add	r3, r2
 800393e: 681b         	ldr	r3, [r3]
 8003940: 61bb         	str	r3, [r7, #0x18]
; 	if (pub_cnt++ % 20 == 0) {
 8003942: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8003980 <Sensor_update_cb+0x8c>
 8003944: 681a         	ldr	r2, [r3]
 8003946: 1c53         	adds	r3, r2, #0x1
 8003948: 490d         	ldr	r1, [pc, #0x34]         @ 0x8003980 <Sensor_update_cb+0x8c>
 800394a: 600b         	str	r3, [r1]
 800394c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8003984 <Sensor_update_cb+0x90>
 800394e: fb83 1302    	smull	r1, r3, r3, r2
 8003952: 10d9         	asrs	r1, r3, #0x3
 8003954: 17d3         	asrs	r3, r2, #0x1f
 8003956: 1ac9         	subs	r1, r1, r3
 8003958: 460b         	mov	r3, r1
 800395a: 009b         	lsls	r3, r3, #0x2
 800395c: 440b         	add	r3, r1
 800395e: 009b         	lsls	r3, r3, #0x2
 8003960: 1ad1         	subs	r1, r2, r3
 8003962: 2900         	cmp	r1, #0x0
 8003964: d108         	bne	0x8003978 <Sensor_update_cb+0x84> @ imm = #0x10
; 		zbus_chan_pub(&chassis_sensor_zbus, &pos, K_MSEC(5));
 8003966: f04f 0232    	mov.w	r2, #0x32
 800396a: f04f 0300    	mov.w	r3, #0x0
 800396e: f107 010c    	add.w	r1, r7, #0xc
 8003972: 4805         	ldr	r0, [pc, #0x14]         @ 0x8003988 <Sensor_update_cb+0x94>
 8003974: f019 fa00    	bl	0x801cd78 <zbus_chan_pub> @ imm = #0x19400
; }
 8003978: bf00         	nop
 800397a: 3728         	adds	r7, #0x28
 800397c: 46bd         	mov	sp, r7
 800397e: bd80         	pop	{r7, pc}

08003980 <$d>:
 8003980: 60 2c 00 20  	.word	0x20002c60
 8003984: 67 66 66 66  	.word	0x66666667
 8003988: f8 81 02 08  	.word	0x080281f8

0800398c <main>:
; {
 800398c: b580         	push	{r7, lr}
 800398e: b082         	sub	sp, #0x8
 8003990: af00         	add	r7, sp, #0x0
; 	board_init();
 8003992: f7fd f951    	bl	0x8000c38 <board_init>  @ imm = #-0x2d5e
; 	struct JFData *data = jf_send_init(uart_dev, 50);
 8003996: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8003a20 <main+0x94>
 8003998: 681b         	ldr	r3, [r3]
 800399a: 2132         	movs	r1, #0x32
 800399c: 4618         	mov	r0, r3
 800399e: f7ff fef9    	bl	0x8003794 <jf_send_init> @ imm = #-0x20e
 80039a2: 6078         	str	r0, [r7, #0x4]
; 	jf_channel_add(data, &QEKF_INS.q[0], PTR_FLOAT);
 80039a4: 2201         	movs	r2, #0x1
 80039a6: 491f         	ldr	r1, [pc, #0x7c]         @ 0x8003a24 <main+0x98>
 80039a8: 6878         	ldr	r0, [r7, #0x4]
 80039aa: f7ff fe9b    	bl	0x80036e4 <jf_channel_add> @ imm = #-0x2ca
; 	jf_channel_add(data, &QEKF_INS.q[1], PTR_FLOAT);
 80039ae: 2201         	movs	r2, #0x1
 80039b0: 491d         	ldr	r1, [pc, #0x74]         @ 0x8003a28 <main+0x9c>
 80039b2: 6878         	ldr	r0, [r7, #0x4]
 80039b4: f7ff fe96    	bl	0x80036e4 <jf_channel_add> @ imm = #-0x2d4
; 	jf_channel_add(data, &QEKF_INS.q[2], PTR_FLOAT);
 80039b8: 2201         	movs	r2, #0x1
 80039ba: 491c         	ldr	r1, [pc, #0x70]         @ 0x8003a2c <main+0xa0>
 80039bc: 6878         	ldr	r0, [r7, #0x4]
 80039be: f7ff fe91    	bl	0x80036e4 <jf_channel_add> @ imm = #-0x2de
; 	jf_channel_add(data, &QEKF_INS.q[3], PTR_FLOAT);
 80039c2: 2201         	movs	r2, #0x1
 80039c4: 491a         	ldr	r1, [pc, #0x68]         @ 0x8003a30 <main+0xa4>
 80039c6: 6878         	ldr	r0, [r7, #0x4]
 80039c8: f7ff fe8c    	bl	0x80036e4 <jf_channel_add> @ imm = #-0x2e8
; 	k_sleep(K_MSEC(50));
 80039cc: f44f 72fa    	mov.w	r2, #0x1f4
 80039d0: f04f 0300    	mov.w	r3, #0x0
 80039d4: 4610         	mov	r0, r2
 80039d6: 4619         	mov	r1, r3
 80039d8: f016 fa6d    	bl	0x8019eb6 <k_sleep>     @ imm = #0x164da
; 	IMU_Sensor_trig_init(accel_dev, gyro_dev);
 80039dc: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8003a34 <main+0xa8>
 80039de: 681b         	ldr	r3, [r3]
 80039e0: 4a15         	ldr	r2, [pc, #0x54]         @ 0x8003a38 <main+0xac>
 80039e2: 6812         	ldr	r2, [r2]
 80039e4: 4611         	mov	r1, r2
 80039e6: 4618         	mov	r0, r3
 80039e8: f7ff fd0e    	bl	0x8003408 <IMU_Sensor_trig_init> @ imm = #-0x5e4
; 	IMU_Sensor_set_update_cb(Sensor_update_cb);
 80039ec: 4813         	ldr	r0, [pc, #0x4c]         @ 0x8003a3c <main+0xb0>
 80039ee: f7ff fb11    	bl	0x8003014 <IMU_Sensor_set_update_cb> @ imm = #-0x9de
; 	chassis_set_sensor_zbus(chassis, &chassis_sensor_zbus);
 80039f2: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8003a40 <main+0xb4>
 80039f4: 681b         	ldr	r3, [r3]
 80039f6: 4913         	ldr	r1, [pc, #0x4c]         @ 0x8003a44 <main+0xb8>
 80039f8: 4618         	mov	r0, r3
 80039fa: f016 fe65    	bl	0x801a6c8 <chassis_set_sensor_zbus> @ imm = #0x16cca
; 	chassis_set_angle(chassis, 0);
 80039fe: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8003a40 <main+0xb4>
 8003a00: 681b         	ldr	r3, [r3]
 8003a02: ed9f 0a11    	vldr	s0, [pc, #68]           @ 0x8003a48 <main+0xbc>
 8003a06: 4618         	mov	r0, r3
 8003a08: f016 fe82    	bl	0x801a710 <chassis_set_angle> @ imm = #0x16d04
; 		k_sleep(K_MSEC(500));
 8003a0c: f241 3288    	movw	r2, #0x1388
 8003a10: f04f 0300    	mov.w	r3, #0x0
 8003a14: 4610         	mov	r0, r2
 8003a16: 4619         	mov	r1, r3
 8003a18: f016 fa4d    	bl	0x8019eb6 <k_sleep>     @ imm = #0x1649a
; 	while (1) {
 8003a1c: bf00         	nop
 8003a1e: e7f5         	b	0x8003a0c <main+0x80>   @ imm = #-0x16

08003a20 <$d>:
 8003a20: a0 04 00 20  	.word	0x200004a0
 8003a24: e8 0d 00 20  	.word	0x20000de8
 8003a28: ec 0d 00 20  	.word	0x20000dec
 8003a2c: f0 0d 00 20  	.word	0x20000df0
 8003a30: f4 0d 00 20  	.word	0x20000df4
 8003a34: a4 04 00 20  	.word	0x200004a4
 8003a38: a8 04 00 20  	.word	0x200004a8
 8003a3c: f5 38 00 08  	.word	0x080038f5
 8003a40: ac 04 00 20  	.word	0x200004ac
 8003a44: f8 81 02 08  	.word	0x080281f8
 8003a48: 00 00 00 00  	.word	0x00000000

08003a4c <linker_is_in_rodata>:
; {
 8003a4c: b480         	push	{r7}
 8003a4e: b083         	sub	sp, #0xc
 8003a50: af00         	add	r7, sp, #0x0
 8003a52: 6078         	str	r0, [r7, #0x4]
; 	return (((const char *)addr >= (const char *)RO_START) &&
 8003a54: 687b         	ldr	r3, [r7, #0x4]
 8003a56: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8003a7c <linker_is_in_rodata+0x30>
 8003a58: 4293         	cmp	r3, r2
 8003a5a: d305         	blo	0x8003a68 <linker_is_in_rodata+0x1c> @ imm = #0xa
 8003a5c: 687b         	ldr	r3, [r7, #0x4]
 8003a5e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8003a80 <linker_is_in_rodata+0x34>
 8003a60: 4293         	cmp	r3, r2
 8003a62: d201         	bhs	0x8003a68 <linker_is_in_rodata+0x1c> @ imm = #0x2
 8003a64: 2301         	movs	r3, #0x1
 8003a66: e000         	b	0x8003a6a <linker_is_in_rodata+0x1e> @ imm = #0x0
 8003a68: 2300         	movs	r3, #0x0
 8003a6a: f003 0301    	and	r3, r3, #0x1
 8003a6e: b2db         	uxtb	r3, r3
; }
 8003a70: 4618         	mov	r0, r3
 8003a72: 370c         	adds	r7, #0xc
 8003a74: 46bd         	mov	sp, r7
 8003a76: f85d 7b04    	ldr	r7, [sp], #4
 8003a7a: 4770         	bx	lr

08003a7c <$d>:
 8003a7c: e0 78 02 08  	.word	0x080278e0
 8003a80: 5c c2 02 08  	.word	0x0802c25c

08003a84 <cbvprintf_package>:
; {
 8003a84: b580         	push	{r7, lr}
 8003a86: b0a4         	sub	sp, #0x90
 8003a88: af00         	add	r7, sp, #0x0
 8003a8a: 60f8         	str	r0, [r7, #0xc]
 8003a8c: 60b9         	str	r1, [r7, #0x8]
 8003a8e: 607a         	str	r2, [r7, #0x4]
 8003a90: 603b         	str	r3, [r7]
; 	uint8_t *buf0 = packaged;  /* buffer start (may be NULL) */
 8003a92: 68fb         	ldr	r3, [r7, #0xc]
 8003a94: 65fb         	str	r3, [r7, #0x5c]
; 	uintptr_t buf = (uintptr_t)buf0; /* current buffer position */
 8003a96: 6dfb         	ldr	r3, [r7, #0x5c]
 8003a98: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
 8003a9c: 2300         	movs	r3, #0x0
 8003a9e: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	unsigned int s_rw_cnt = 0; /* number of rw strings */
 8003aa2: 2300         	movs	r3, #0x0
 8003aa4: 67fb         	str	r3, [r7, #0x7c]
; 	unsigned int s_ro_cnt = 0; /* number of ro strings */
 8003aa6: 2300         	movs	r3, #0x0
 8003aa8: 67bb         	str	r3, [r7, #0x78]
; 	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
 8003aaa: f04f 33ff    	mov.w	r3, #0xffffffff
 8003aae: 677b         	str	r3, [r7, #0x74]
; 	bool parsing = false;
 8003ab0: 2300         	movs	r3, #0x0
 8003ab2: f887 306b    	strb.w	r3, [r7, #0x6b]
; 	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
 8003ab6: 687b         	ldr	r3, [r7, #0x4]
 8003ab8: f003 0304    	and	r3, r3, #0x4
 8003abc: 2b00         	cmp	r3, #0x0
 8003abe: bf14         	ite	ne
 8003ac0: 2301         	movne	r3, #0x1
 8003ac2: 2300         	moveq	r3, #0x0
 8003ac4: f887 305b    	strb.w	r3, [r7, #0x5b]
; 	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 8003ac8: 687b         	ldr	r3, [r7, #0x4]
 8003aca: 08db         	lsrs	r3, r3, #0x3
 8003acc: f003 0307    	and	r3, r3, #0x7
 8003ad0: 3301         	adds	r3, #0x1
 8003ad2: 667b         	str	r3, [r7, #0x64]
; 	bool is_str_arg = false;
 8003ad4: 2300         	movs	r3, #0x0
 8003ad6: f887 3063    	strb.w	r3, [r7, #0x63]
; 	union cbprintf_package_hdr *pkg_hdr = packaged;
 8003ada: 68fb         	ldr	r3, [r7, #0xc]
 8003adc: 657b         	str	r3, [r7, #0x54]
; 	if ((uintptr_t)packaged % sizeof(void *)) {
 8003ade: 68fb         	ldr	r3, [r7, #0xc]
 8003ae0: f003 0303    	and	r3, r3, #0x3
 8003ae4: 2b00         	cmp	r3, #0x0
 8003ae6: d002         	beq	0x8003aee <cbvprintf_package+0x6a> @ imm = #0x4
; 		return -EFAULT;
 8003ae8: f06f 030d    	mvn	r3, #0xd
 8003aec: e3a2         	b	0x8004234 <cbvprintf_package+0x7b0> @ imm = #0x744
; 	buf += sizeof(*pkg_hdr);
 8003aee: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003af2: 3304         	adds	r3, #0x4
 8003af4: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	if (buf0 == NULL) {
 8003af8: 6dfb         	ldr	r3, [r7, #0x5c]
 8003afa: 2b00         	cmp	r3, #0x0
 8003afc: d10d         	bne	0x8003b1a <cbvprintf_package+0x96> @ imm = #0x1a
; 		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
 8003afe: 68bb         	ldr	r3, [r7, #0x8]
 8003b00: f003 0307    	and	r3, r3, #0x7
 8003b04: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003b08: 4413         	add	r3, r2
 8003b0a: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
 8003b0e: 68bb         	ldr	r3, [r7, #0x8]
 8003b10: f003 0307    	and	r3, r3, #0x7
 8003b14: f1c3 0308    	rsb.w	r3, r3, #0x8
 8003b18: 60bb         	str	r3, [r7, #0x8]
; 	if ((buf0 != NULL) && (BUF_OFFSET + sizeof(char *)) > len) {
 8003b1a: 6dfb         	ldr	r3, [r7, #0x5c]
 8003b1c: 2b00         	cmp	r3, #0x0
 8003b1e: d00a         	beq	0x8003b36 <cbvprintf_package+0xb2> @ imm = #0x14
 8003b20: 6dfb         	ldr	r3, [r7, #0x5c]
 8003b22: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003b26: 1ad3         	subs	r3, r2, r3
 8003b28: 3304         	adds	r3, #0x4
 8003b2a: 68ba         	ldr	r2, [r7, #0x8]
 8003b2c: 429a         	cmp	r2, r3
 8003b2e: d202         	bhs	0x8003b36 <cbvprintf_package+0xb2> @ imm = #0x4
; 		return -ENOSPC;
 8003b30: f06f 031b    	mvn	r3, #0x1b
 8003b34: e37e         	b	0x8004234 <cbvprintf_package+0x7b0> @ imm = #0x6fc
; 	s = fmt;
 8003b36: 683b         	ldr	r3, [r7]
 8003b38: 66fb         	str	r3, [r7, #0x6c]
; 	--fmt;
 8003b3a: 683b         	ldr	r3, [r7]
 8003b3c: 3b01         	subs	r3, #0x1
 8003b3e: 603b         	str	r3, [r7]
; 	align = VA_STACK_ALIGN(char *);
 8003b40: 2304         	movs	r3, #0x4
 8003b42: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	size = sizeof(char *);
 8003b46: 2304         	movs	r3, #0x4
 8003b48: f8c7 3088    	str.w	r3, [r7, #0x88]
; 	goto process_string;
 8003b4c: e197         	b	0x8003e7e <cbvprintf_package+0x3fa> @ imm = #0x32e
; 			if (!parsing) {
 8003b4e: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 8003b52: f083 0301    	eor	r3, r3, #0x1
 8003b56: b2db         	uxtb	r3, r3
 8003b58: 2b00         	cmp	r3, #0x0
 8003b5a: d011         	beq	0x8003b80 <cbvprintf_package+0xfc> @ imm = #0x22
; 				if (*fmt == '%') {
 8003b5c: 683b         	ldr	r3, [r7]
 8003b5e: 781b         	ldrb	r3, [r3]
 8003b60: 2b25         	cmp	r3, #0x25
 8003b62: f040 8278    	bne.w	0x8004056 <cbvprintf_package+0x5d2> @ imm = #0x4f0
; 					parsing = true;
 8003b66: 2301         	movs	r3, #0x1
 8003b68: f887 306b    	strb.w	r3, [r7, #0x6b]
; 					arg_idx++;
 8003b6c: 6f7b         	ldr	r3, [r7, #0x74]
 8003b6e: 3301         	adds	r3, #0x1
 8003b70: 677b         	str	r3, [r7, #0x74]
; 					align = VA_STACK_ALIGN(int);
 8003b72: 2304         	movs	r3, #0x4
 8003b74: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(int);
 8003b78: 2304         	movs	r3, #0x4
 8003b7a: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8003b7e: e26a         	b	0x8004056 <cbvprintf_package+0x5d2> @ imm = #0x4d4
; 			switch (*fmt) {
 8003b80: 683b         	ldr	r3, [r7]
 8003b82: 781b         	ldrb	r3, [r3]
 8003b84: 2b7a         	cmp	r3, #0x7a
 8003b86: f300 8149    	bgt.w	0x8003e1c <cbvprintf_package+0x398> @ imm = #0x292
 8003b8a: 2b4c         	cmp	r3, #0x4c
 8003b8c: da11         	bge	0x8003bb2 <cbvprintf_package+0x12e> @ imm = #0x22
 8003b8e: 2b47         	cmp	r3, #0x47
 8003b90: f300 8144    	bgt.w	0x8003e1c <cbvprintf_package+0x398> @ imm = #0x288
 8003b94: 2b2a         	cmp	r3, #0x2a
 8003b96: da71         	bge	0x8003c7c <cbvprintf_package+0x1f8> @ imm = #0xe2
 8003b98: 2b25         	cmp	r3, #0x25
 8003b9a: f000 8092    	beq.w	0x8003cc2 <cbvprintf_package+0x23e> @ imm = #0x124
 8003b9e: 2b25         	cmp	r3, #0x25
 8003ba0: f300 813c    	bgt.w	0x8003e1c <cbvprintf_package+0x398> @ imm = #0x278
 8003ba4: 2b20         	cmp	r3, #0x20
 8003ba6: f000 8258    	beq.w	0x800405a <cbvprintf_package+0x5d6> @ imm = #0x4b0
 8003baa: 2b23         	cmp	r3, #0x23
 8003bac: f000 8255    	beq.w	0x800405a <cbvprintf_package+0x5d6> @ imm = #0x4aa
 8003bb0: e134         	b	0x8003e1c <cbvprintf_package+0x398> @ imm = #0x268
 8003bb2: 3b4c         	subs	r3, #0x4c
 8003bb4: 2b2e         	cmp	r3, #0x2e
 8003bb6: f200 8131    	bhi.w	0x8003e1c <cbvprintf_package+0x398> @ imm = #0x262
 8003bba: a201         	adr	r2, #4 <cbvprintf_package+0x13b>
 8003bbc: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08003bc0 <$d>:
 8003bc0: 5b 40 00 08  	.word	0x0800405b
 8003bc4: 1d 3e 00 08  	.word	0x08003e1d
 8003bc8: 1d 3e 00 08  	.word	0x08003e1d
 8003bcc: 1d 3e 00 08  	.word	0x08003e1d
 8003bd0: 1d 3e 00 08  	.word	0x08003e1d
 8003bd4: 1d 3e 00 08  	.word	0x08003e1d
 8003bd8: 1d 3e 00 08  	.word	0x08003e1d
 8003bdc: 1d 3e 00 08  	.word	0x08003e1d
 8003be0: 1d 3e 00 08  	.word	0x08003e1d
 8003be4: 1d 3e 00 08  	.word	0x08003e1d
 8003be8: 1d 3e 00 08  	.word	0x08003e1d
 8003bec: 1d 3e 00 08  	.word	0x08003e1d
 8003bf0: fb 3c 00 08  	.word	0x08003cfb
 8003bf4: 1d 3e 00 08  	.word	0x08003e1d
 8003bf8: 1d 3e 00 08  	.word	0x08003e1d
 8003bfc: 1d 3e 00 08  	.word	0x08003e1d
 8003c00: 1d 3e 00 08  	.word	0x08003e1d
 8003c04: 1d 3e 00 08  	.word	0x08003e1d
 8003c08: 1d 3e 00 08  	.word	0x08003e1d
 8003c0c: 1d 3e 00 08  	.word	0x08003e1d
 8003c10: 1d 3e 00 08  	.word	0x08003e1d
 8003c14: 4b 3d 00 08  	.word	0x08003d4b
 8003c18: 1d 3e 00 08  	.word	0x08003e1d
 8003c1c: fb 3c 00 08  	.word	0x08003cfb
 8003c20: fb 3c 00 08  	.word	0x08003cfb
 8003c24: 4b 3d 00 08  	.word	0x08003d4b
 8003c28: 4b 3d 00 08  	.word	0x08003d4b
 8003c2c: 4b 3d 00 08  	.word	0x08003d4b
 8003c30: 5b 40 00 08  	.word	0x0800405b
 8003c34: fb 3c 00 08  	.word	0x08003cfb
 8003c38: d1 3c 00 08  	.word	0x08003cd1
 8003c3c: 1d 3e 00 08  	.word	0x08003e1d
 8003c40: 5b 40 00 08  	.word	0x0800405b
 8003c44: 1d 3e 00 08  	.word	0x08003e1d
 8003c48: 37 3d 00 08  	.word	0x08003d37
 8003c4c: fb 3c 00 08  	.word	0x08003cfb
 8003c50: 37 3d 00 08  	.word	0x08003d37
 8003c54: 1d 3e 00 08  	.word	0x08003e1d
 8003c58: 1d 3e 00 08  	.word	0x08003e1d
 8003c5c: 31 3d 00 08  	.word	0x08003d31
 8003c60: ed 3c 00 08  	.word	0x08003ced
 8003c64: fb 3c 00 08  	.word	0x08003cfb
 8003c68: 1d 3e 00 08  	.word	0x08003e1d
 8003c6c: 1d 3e 00 08  	.word	0x08003e1d
 8003c70: fb 3c 00 08  	.word	0x08003cfb
 8003c74: 1d 3e 00 08  	.word	0x08003e1d
 8003c78: df 3c 00 08  	.word	0x08003cdf

08003c7c <$t>:
 8003c7c: 3b2a         	subs	r3, #0x2a
 8003c7e: 2201         	movs	r2, #0x1
 8003c80: fa02 f303    	lsl.w	r3, r2, r3
 8003c84: f64f 72da    	movw	r2, #0xffda
 8003c88: 401a         	ands	r2, r3
 8003c8a: 2a00         	cmp	r2, #0x0
 8003c8c: bf14         	ite	ne
 8003c8e: 2201         	movne	r2, #0x1
 8003c90: 2200         	moveq	r2, #0x0
 8003c92: b2d2         	uxtb	r2, r2
 8003c94: 2a00         	cmp	r2, #0x0
 8003c96: f040 81e0    	bne.w	0x800405a <cbvprintf_package+0x5d6> @ imm = #0x3c0
 8003c9a: f003 5262    	and	r2, r3, #0x38800000
 8003c9e: 2a00         	cmp	r2, #0x0
 8003ca0: bf14         	ite	ne
 8003ca2: 2201         	movne	r2, #0x1
 8003ca4: 2200         	moveq	r2, #0x0
 8003ca6: b2d2         	uxtb	r2, r2
 8003ca8: 2a00         	cmp	r2, #0x0
 8003caa: d14e         	bne	0x8003d4a <cbvprintf_package+0x2c6> @ imm = #0x9c
 8003cac: f003 0301    	and	r3, r3, #0x1
 8003cb0: 2b00         	cmp	r3, #0x0
 8003cb2: bf14         	ite	ne
 8003cb4: 2301         	movne	r3, #0x1
 8003cb6: 2300         	moveq	r3, #0x0
 8003cb8: b2db         	uxtb	r3, r3
 8003cba: 2b00         	cmp	r3, #0x0
 8003cbc: f040 80b2    	bne.w	0x8003e24 <cbvprintf_package+0x3a0> @ imm = #0x164
 8003cc0: e0ac         	b	0x8003e1c <cbvprintf_package+0x398> @ imm = #0x158
; 				parsing = false;
 8003cc2: 2300         	movs	r3, #0x0
 8003cc4: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				arg_idx--;
 8003cc8: 6f7b         	ldr	r3, [r7, #0x74]
 8003cca: 3b01         	subs	r3, #0x1
 8003ccc: 677b         	str	r3, [r7, #0x74]
; 				continue;
 8003cce: e1c5         	b	0x800405c <cbvprintf_package+0x5d8> @ imm = #0x38a
; 				align = VA_STACK_ALIGN(intmax_t);
 8003cd0: 2308         	movs	r3, #0x8
 8003cd2: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(intmax_t);
 8003cd6: 2308         	movs	r3, #0x8
 8003cd8: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8003cdc: e1be         	b	0x800405c <cbvprintf_package+0x5d8> @ imm = #0x37c
; 				align = VA_STACK_ALIGN(size_t);
 8003cde: 2304         	movs	r3, #0x4
 8003ce0: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(size_t);
 8003ce4: 2304         	movs	r3, #0x4
 8003ce6: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8003cea: e1b7         	b	0x800405c <cbvprintf_package+0x5d8> @ imm = #0x36e
; 				align = VA_STACK_ALIGN(ptrdiff_t);
 8003cec: 2304         	movs	r3, #0x4
 8003cee: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(ptrdiff_t);
 8003cf2: 2304         	movs	r3, #0x4
 8003cf4: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8003cf8: e1b0         	b	0x800405c <cbvprintf_package+0x5d8> @ imm = #0x360
; 				if (fmt[-1] == 'l') {
 8003cfa: 683b         	ldr	r3, [r7]
 8003cfc: 3b01         	subs	r3, #0x1
 8003cfe: 781b         	ldrb	r3, [r3]
 8003d00: 2b6c         	cmp	r3, #0x6c
 8003d02: d111         	bne	0x8003d28 <cbvprintf_package+0x2a4> @ imm = #0x22
; 					if (fmt[-2] == 'l') {
 8003d04: 683b         	ldr	r3, [r7]
 8003d06: 3b02         	subs	r3, #0x2
 8003d08: 781b         	ldrb	r3, [r3]
 8003d0a: 2b6c         	cmp	r3, #0x6c
 8003d0c: d106         	bne	0x8003d1c <cbvprintf_package+0x298> @ imm = #0xc
; 						align = VA_STACK_ALIGN(long long);
 8003d0e: 2308         	movs	r3, #0x8
 8003d10: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long long);
 8003d14: 2308         	movs	r3, #0x8
 8003d16: f8c7 3088    	str.w	r3, [r7, #0x88]
 8003d1a: e005         	b	0x8003d28 <cbvprintf_package+0x2a4> @ imm = #0xa
; 						align = VA_STACK_ALIGN(long);
 8003d1c: 2304         	movs	r3, #0x4
 8003d1e: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long);
 8003d22: 2304         	movs	r3, #0x4
 8003d24: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 8003d28: 2300         	movs	r3, #0x0
 8003d2a: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 8003d2e: e07a         	b	0x8003e26 <cbvprintf_package+0x3a2> @ imm = #0xf4
; 				is_str_arg = true;
 8003d30: 2301         	movs	r3, #0x1
 8003d32: f887 3063    	strb.w	r3, [r7, #0x63]
; 				align = VA_STACK_ALIGN(void *);
 8003d36: 2304         	movs	r3, #0x4
 8003d38: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(void *);
 8003d3c: 2304         	movs	r3, #0x4
 8003d3e: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 8003d42: 2300         	movs	r3, #0x0
 8003d44: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 8003d48: e06d         	b	0x8003e26 <cbvprintf_package+0x3a2> @ imm = #0xda
; 				if (fmt[-1] == 'L') {
 8003d4a: 683b         	ldr	r3, [r7]
 8003d4c: 3b01         	subs	r3, #0x1
 8003d4e: 781b         	ldrb	r3, [r3]
 8003d50: 2b4c         	cmp	r3, #0x4c
 8003d52: d113         	bne	0x8003d7c <cbvprintf_package+0x2f8> @ imm = #0x26
; 					v.ld = va_arg(ap, long double);
 8003d54: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003d58: 3307         	adds	r3, #0x7
 8003d5a: f023 0307    	bic	r3, r3, #0x7
 8003d5e: f103 0208    	add.w	r2, r3, #0x8
 8003d62: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003d66: e9d3 2300    	ldrd	r2, r3, [r3]
 8003d6a: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(long double);
 8003d6e: 2308         	movs	r3, #0x8
 8003d70: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(long double);
 8003d74: 2308         	movs	r3, #0x8
 8003d76: f8c7 3088    	str.w	r3, [r7, #0x88]
 8003d7a: e012         	b	0x8003da2 <cbvprintf_package+0x31e> @ imm = #0x24
; 					v.d = va_arg(ap, double);
 8003d7c: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003d80: 3307         	adds	r3, #0x7
 8003d82: f023 0307    	bic	r3, r3, #0x7
 8003d86: f103 0208    	add.w	r2, r3, #0x8
 8003d8a: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003d8e: e9d3 2300    	ldrd	r2, r3, [r3]
 8003d92: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(double);
 8003d96: 2308         	movs	r3, #0x8
 8003d98: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(double);
 8003d9c: 2308         	movs	r3, #0x8
 8003d9e: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				buf = ROUND_UP(buf, align);
 8003da2: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8003da6: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003daa: 4413         	add	r3, r2
 8003dac: 1e5a         	subs	r2, r3, #0x1
 8003dae: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003db2: fbb2 f2f3    	udiv	r2, r2, r3
 8003db6: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003dba: fb02 f303    	mul	r3, r2, r3
 8003dbe: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				if (buf0 != NULL) {
 8003dc2: 6dfb         	ldr	r3, [r7, #0x5c]
 8003dc4: 2b00         	cmp	r3, #0x0
 8003dc6: d01e         	beq	0x8003e06 <cbvprintf_package+0x382> @ imm = #0x3c
; 					if (BUF_OFFSET + size > len) {
 8003dc8: 6dfb         	ldr	r3, [r7, #0x5c]
 8003dca: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003dce: 1ad2         	subs	r2, r2, r3
 8003dd0: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003dd4: 4413         	add	r3, r2
 8003dd6: 68ba         	ldr	r2, [r7, #0x8]
 8003dd8: 429a         	cmp	r2, r3
 8003dda: d202         	bhs	0x8003de2 <cbvprintf_package+0x35e> @ imm = #0x4
; 						return -ENOSPC;
 8003ddc: f06f 031b    	mvn	r3, #0x1b
 8003de0: e228         	b	0x8004234 <cbvprintf_package+0x7b0> @ imm = #0x450
; 					} else if (fmt[-1] == 'L') {
 8003de2: 683b         	ldr	r3, [r7]
 8003de4: 3b01         	subs	r3, #0x1
 8003de6: 781b         	ldrb	r3, [r3]
 8003de8: 2b4c         	cmp	r3, #0x4c
 8003dea: d106         	bne	0x8003dfa <cbvprintf_package+0x376> @ imm = #0xc
; 						*(long double *)buf = v.ld;
 8003dec: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8003df0: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8003df4: e9c1 2300    	strd	r2, r3, [r1]
 8003df8: e005         	b	0x8003e06 <cbvprintf_package+0x382> @ imm = #0xa
; 						*(double *)buf = v.d;
 8003dfa: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8003dfe: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8003e02: e9c1 2300    	strd	r2, r3, [r1]
; 				buf += size;
 8003e06: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003e0a: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003e0e: 4413         	add	r3, r2
 8003e10: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				parsing = false;
 8003e14: 2300         	movs	r3, #0x0
 8003e16: f887 306b    	strb.w	r3, [r7, #0x6b]
 8003e1a: e11f         	b	0x800405c <cbvprintf_package+0x5d8> @ imm = #0x23e
; 				parsing = false;
 8003e1c: 2300         	movs	r3, #0x0
 8003e1e: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				continue;
 8003e22: e11b         	b	0x800405c <cbvprintf_package+0x5d8> @ imm = #0x236
; 				break;
 8003e24: bf00         	nop
; 		buf = ROUND_UP(buf, align);
 8003e26: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8003e2a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003e2e: 4413         	add	r3, r2
 8003e30: 1e5a         	subs	r2, r3, #0x1
 8003e32: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003e36: fbb2 f2f3    	udiv	r2, r2, r3
 8003e3a: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8003e3e: fb02 f303    	mul	r3, r2, r3
 8003e42: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		if ((buf0 != NULL) && (BUF_OFFSET + size) > len) {
 8003e46: 6dfb         	ldr	r3, [r7, #0x5c]
 8003e48: 2b00         	cmp	r3, #0x0
 8003e4a: d00c         	beq	0x8003e66 <cbvprintf_package+0x3e2> @ imm = #0x18
 8003e4c: 6dfb         	ldr	r3, [r7, #0x5c]
 8003e4e: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003e52: 1ad2         	subs	r2, r2, r3
 8003e54: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003e58: 4413         	add	r3, r2
 8003e5a: 68ba         	ldr	r2, [r7, #0x8]
 8003e5c: 429a         	cmp	r2, r3
 8003e5e: d202         	bhs	0x8003e66 <cbvprintf_package+0x3e2> @ imm = #0x4
; 			return -ENOSPC;
 8003e60: f06f 031b    	mvn	r3, #0x1b
 8003e64: e1e6         	b	0x8004234 <cbvprintf_package+0x7b0> @ imm = #0x3cc
; 		if (is_str_arg) {
 8003e66: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8003e6a: 2b00         	cmp	r3, #0x0
 8003e6c: f000 80a0    	beq.w	0x8003fb0 <cbvprintf_package+0x52c> @ imm = #0x140
; 			s = va_arg(ap, char *);
 8003e70: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003e74: 1d1a         	adds	r2, r3, #0x4
 8003e76: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003e7a: 681b         	ldr	r3, [r3]
 8003e7c: 66fb         	str	r3, [r7, #0x6c]
; 			if (buf0 != NULL) {
 8003e7e: 6dfb         	ldr	r3, [r7, #0x5c]
 8003e80: 2b00         	cmp	r3, #0x0
 8003e82: d003         	beq	0x8003e8c <cbvprintf_package+0x408> @ imm = #0x6
; 				*(const char **)buf = s;
 8003e84: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003e88: 6efa         	ldr	r2, [r7, #0x6c]
 8003e8a: 601a         	str	r2, [r3]
; 			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 8003e8c: 6e7b         	ldr	r3, [r7, #0x64]
 8003e8e: 1e5a         	subs	r2, r3, #0x1
 8003e90: 667a         	str	r2, [r7, #0x64]
 8003e92: 2b00         	cmp	r3, #0x0
 8003e94: dc05         	bgt	0x8003ea2 <cbvprintf_package+0x41e> @ imm = #0xa
 8003e96: 6ef8         	ldr	r0, [r7, #0x6c]
 8003e98: f017 f9ea    	bl	0x801b270 <ptr_in_rodata> @ imm = #0x173d4
 8003e9c: 4603         	mov	r3, r0
 8003e9e: 2b00         	cmp	r3, #0x0
 8003ea0: d001         	beq	0x8003ea6 <cbvprintf_package+0x422> @ imm = #0x2
 8003ea2: 2301         	movs	r3, #0x1
 8003ea4: e000         	b	0x8003ea8 <cbvprintf_package+0x424> @ imm = #0x0
 8003ea6: 2300         	movs	r3, #0x0
 8003ea8: f887 3053    	strb.w	r3, [r7, #0x53]
; 			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);
 8003eac: 687b         	ldr	r3, [r7, #0x4]
 8003eae: f003 0302    	and	r3, r3, #0x2
 8003eb2: 2b00         	cmp	r3, #0x0
 8003eb4: bf14         	ite	ne
 8003eb6: 2301         	movne	r3, #0x1
 8003eb8: 2300         	moveq	r3, #0x0
 8003eba: f887 3052    	strb.w	r3, [r7, #0x52]
; 			if (is_ro && !do_ro) {
 8003ebe: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8003ec2: 2b00         	cmp	r3, #0x0
 8003ec4: d006         	beq	0x8003ed4 <cbvprintf_package+0x450> @ imm = #0xc
 8003ec6: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8003eca: f083 0301    	eor	r3, r3, #0x1
 8003ece: b2db         	uxtb	r3, r3
 8003ed0: 2b00         	cmp	r3, #0x0
 8003ed2: d164         	bne	0x8003f9e <cbvprintf_package+0x51a> @ imm = #0xc8
; 				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 8003ed4: 6dfb         	ldr	r3, [r7, #0x5c]
 8003ed6: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8003eda: 1ad3         	subs	r3, r2, r3
 8003edc: 089b         	lsrs	r3, r3, #0x2
 8003ede: 64fb         	str	r3, [r7, #0x4c]
; 				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 8003ee0: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8003ee4: 2b00         	cmp	r3, #0x0
 8003ee6: d005         	beq	0x8003ef4 <cbvprintf_package+0x470> @ imm = #0xa
 8003ee8: 6cfb         	ldr	r3, [r7, #0x4c]
 8003eea: 2b7f         	cmp	r3, #0x7f
 8003eec: d902         	bls	0x8003ef4 <cbvprintf_package+0x470> @ imm = #0x4
; 					return -EINVAL;
 8003eee: f06f 0315    	mvn	r3, #0x15
 8003ef2: e19f         	b	0x8004234 <cbvprintf_package+0x7b0> @ imm = #0x33e
; 				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
 8003ef4: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003ef8: 2b0f         	cmp	r3, #0xf
 8003efa: d902         	bls	0x8003f02 <cbvprintf_package+0x47e> @ imm = #0x4
; 					return -EINVAL;
 8003efc: f06f 0315    	mvn	r3, #0x15
 8003f00: e198         	b	0x8004234 <cbvprintf_package+0x7b0> @ imm = #0x330
; 				if (buf0 != NULL) {
 8003f02: 6dfb         	ldr	r3, [r7, #0x5c]
 8003f04: 2b00         	cmp	r3, #0x0
 8003f06: d02d         	beq	0x8003f64 <cbvprintf_package+0x4e0> @ imm = #0x5a
; 					str_ptr_pos[s_idx] = s_ptr_idx;
 8003f08: 6cfb         	ldr	r3, [r7, #0x4c]
 8003f0a: b2d9         	uxtb	r1, r3
 8003f0c: f107 0230    	add.w	r2, r7, #0x30
 8003f10: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003f14: 4413         	add	r3, r2
 8003f16: 460a         	mov	r2, r1
 8003f18: 701a         	strb	r2, [r3]
; 					str_ptr_arg[s_idx] = arg_idx;
 8003f1a: 6f7b         	ldr	r3, [r7, #0x74]
 8003f1c: b2d9         	uxtb	r1, r3
 8003f1e: f107 0220    	add.w	r2, r7, #0x20
 8003f22: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003f26: 4413         	add	r3, r2
 8003f28: 460a         	mov	r2, r1
 8003f2a: 701a         	strb	r2, [r3]
; 					if (is_ro) {
 8003f2c: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8003f30: 2b00         	cmp	r3, #0x0
 8003f32: d013         	beq	0x8003f5c <cbvprintf_package+0x4d8> @ imm = #0x26
; 						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
 8003f34: f107 0230    	add.w	r2, r7, #0x30
 8003f38: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003f3c: 4413         	add	r3, r2
 8003f3e: 781b         	ldrb	r3, [r3]
 8003f40: f063 037f    	orn	r3, r3, #0x7f
 8003f44: b2d9         	uxtb	r1, r3
 8003f46: f107 0230    	add.w	r2, r7, #0x30
 8003f4a: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003f4e: 4413         	add	r3, r2
 8003f50: 460a         	mov	r2, r1
 8003f52: 701a         	strb	r2, [r3]
; 						s_ro_cnt++;
 8003f54: 6fbb         	ldr	r3, [r7, #0x78]
 8003f56: 3301         	adds	r3, #0x1
 8003f58: 67bb         	str	r3, [r7, #0x78]
 8003f5a: e01b         	b	0x8003f94 <cbvprintf_package+0x510> @ imm = #0x36
; 						s_rw_cnt++;
 8003f5c: 6ffb         	ldr	r3, [r7, #0x7c]
 8003f5e: 3301         	adds	r3, #0x1
 8003f60: 67fb         	str	r3, [r7, #0x7c]
 8003f62: e017         	b	0x8003f94 <cbvprintf_package+0x510> @ imm = #0x2e
; 				} else if (is_ro) {
 8003f64: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8003f68: 2b00         	cmp	r3, #0x0
 8003f6a: d003         	beq	0x8003f74 <cbvprintf_package+0x4f0> @ imm = #0x6
; 					len += 1;
 8003f6c: 68bb         	ldr	r3, [r7, #0x8]
 8003f6e: 3301         	adds	r3, #0x1
 8003f70: 60bb         	str	r3, [r7, #0x8]
 8003f72: e00f         	b	0x8003f94 <cbvprintf_package+0x510> @ imm = #0x1e
; 				} else if (rws_pos_en) {
 8003f74: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8003f78: 2b00         	cmp	r3, #0x0
 8003f7a: d003         	beq	0x8003f84 <cbvprintf_package+0x500> @ imm = #0x6
; 					len += 2;
 8003f7c: 68bb         	ldr	r3, [r7, #0x8]
 8003f7e: 3302         	adds	r3, #0x2
 8003f80: 60bb         	str	r3, [r7, #0x8]
 8003f82: e007         	b	0x8003f94 <cbvprintf_package+0x510> @ imm = #0xe
; 					len += strlen(s) + 1 + 1;
 8003f84: 6ef8         	ldr	r0, [r7, #0x6c]
 8003f86: f7fc fb7f    	bl	0x8000688 <strlen>      @ imm = #-0x3902
 8003f8a: 4602         	mov	r2, r0
 8003f8c: 68bb         	ldr	r3, [r7, #0x8]
 8003f8e: 4413         	add	r3, r2
 8003f90: 3302         	adds	r3, #0x2
 8003f92: 60bb         	str	r3, [r7, #0x8]
; 				s_idx++;
 8003f94: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8003f98: 3301         	adds	r3, #0x1
 8003f9a: f8c7 3080    	str.w	r3, [r7, #0x80]
; 			buf += sizeof(char *);
 8003f9e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003fa2: 3304         	adds	r3, #0x4
 8003fa4: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			is_str_arg = false;
 8003fa8: 2300         	movs	r3, #0x0
 8003faa: f887 3063    	strb.w	r3, [r7, #0x63]
 8003fae: e055         	b	0x800405c <cbvprintf_package+0x5d8> @ imm = #0xaa
; 		} else if (size == sizeof(int)) {
 8003fb0: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003fb4: 2b04         	cmp	r3, #0x4
 8003fb6: d113         	bne	0x8003fe0 <cbvprintf_package+0x55c> @ imm = #0x26
; 			int v = va_arg(ap, int);
 8003fb8: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003fbc: 1d1a         	adds	r2, r3, #0x4
 8003fbe: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003fc2: 681b         	ldr	r3, [r3]
 8003fc4: 647b         	str	r3, [r7, #0x44]
; 			if (buf0 != NULL) {
 8003fc6: 6dfb         	ldr	r3, [r7, #0x5c]
 8003fc8: 2b00         	cmp	r3, #0x0
 8003fca: d003         	beq	0x8003fd4 <cbvprintf_package+0x550> @ imm = #0x6
; 				*(int *)buf = v;
 8003fcc: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003fd0: 6c7a         	ldr	r2, [r7, #0x44]
 8003fd2: 601a         	str	r2, [r3]
; 			buf += sizeof(int);
 8003fd4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8003fd8: 3304         	adds	r3, #0x4
 8003fda: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8003fde: e03d         	b	0x800405c <cbvprintf_package+0x5d8> @ imm = #0x7a
; 		} else if (size == sizeof(long)) {
 8003fe0: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8003fe4: 2b04         	cmp	r3, #0x4
 8003fe6: d113         	bne	0x8004010 <cbvprintf_package+0x58c> @ imm = #0x26
; 			long v = va_arg(ap, long);
 8003fe8: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8003fec: 1d1a         	adds	r2, r3, #0x4
 8003fee: f8c7 2098    	str.w	r2, [r7, #0x98]
 8003ff2: 681b         	ldr	r3, [r3]
 8003ff4: 64bb         	str	r3, [r7, #0x48]
; 			if (buf0 != NULL) {
 8003ff6: 6dfb         	ldr	r3, [r7, #0x5c]
 8003ff8: 2b00         	cmp	r3, #0x0
 8003ffa: d003         	beq	0x8004004 <cbvprintf_package+0x580> @ imm = #0x6
; 				*(long *)buf = v;
 8003ffc: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004000: 6cba         	ldr	r2, [r7, #0x48]
 8004002: 601a         	str	r2, [r3]
; 			buf += sizeof(long);
 8004004: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004008: 3304         	adds	r3, #0x4
 800400a: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800400e: e025         	b	0x800405c <cbvprintf_package+0x5d8> @ imm = #0x4a
; 		} else if (size == sizeof(long long)) {
 8004010: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8004014: 2b08         	cmp	r3, #0x8
 8004016: d11b         	bne	0x8004050 <cbvprintf_package+0x5cc> @ imm = #0x36
; 			long long v = va_arg(ap, long long);
 8004018: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 800401c: 3307         	adds	r3, #0x7
 800401e: f023 0307    	bic	r3, r3, #0x7
 8004022: f103 0208    	add.w	r2, r3, #0x8
 8004026: f8c7 2098    	str.w	r2, [r7, #0x98]
 800402a: e9d3 2300    	ldrd	r2, r3, [r3]
 800402e: e9c7 2304    	strd	r2, r3, [r7, #16]
; 			if (buf0 != NULL) {
 8004032: 6dfb         	ldr	r3, [r7, #0x5c]
 8004034: 2b00         	cmp	r3, #0x0
 8004036: d005         	beq	0x8004044 <cbvprintf_package+0x5c0> @ imm = #0xa
; 					*(long long *)buf = v;
 8004038: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 800403c: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8004040: e9c1 2300    	strd	r2, r3, [r1]
; 			buf += sizeof(long long);
 8004044: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004048: 3308         	adds	r3, #0x8
 800404a: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800404e: e005         	b	0x800405c <cbvprintf_package+0x5d8> @ imm = #0xa
; 			return -EINVAL;
 8004050: f06f 0315    	mvn	r3, #0x15
 8004054: e0ee         	b	0x8004234 <cbvprintf_package+0x7b0> @ imm = #0x1dc
; 				continue;
 8004056: bf00         	nop
 8004058: e000         	b	0x800405c <cbvprintf_package+0x5d8> @ imm = #0x0
; 				continue;
 800405a: bf00         	nop
; 			if (*++fmt == '\0') {
 800405c: 683b         	ldr	r3, [r7]
 800405e: 3301         	adds	r3, #0x1
 8004060: 603b         	str	r3, [r7]
 8004062: 683b         	ldr	r3, [r7]
 8004064: 781b         	ldrb	r3, [r3]
 8004066: 2b00         	cmp	r3, #0x0
 8004068: f47f ad71    	bne.w	0x8003b4e <cbvprintf_package+0xca> @ imm = #-0x51e
; 				break;
 800406c: bf00         	nop
; 	if ((BUF_OFFSET / sizeof(int)) > 255) {
 800406e: 6dfb         	ldr	r3, [r7, #0x5c]
 8004070: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004074: 1ad3         	subs	r3, r2, r3
 8004076: f5b3 6f80    	cmp.w	r3, #0x400
 800407a: d302         	blo	0x8004082 <cbvprintf_package+0x5fe> @ imm = #0x4
; 		return -EINVAL;
 800407c: f06f 0315    	mvn	r3, #0x15
 8004080: e0d8         	b	0x8004234 <cbvprintf_package+0x7b0> @ imm = #0x1b0
; 	if (buf0 == NULL) {
 8004082: 6dfb         	ldr	r3, [r7, #0x5c]
 8004084: 2b00         	cmp	r3, #0x0
 8004086: d107         	bne	0x8004098 <cbvprintf_package+0x614> @ imm = #0xe
; 		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
 8004088: 6dfb         	ldr	r3, [r7, #0x5c]
 800408a: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 800408e: 1ad2         	subs	r2, r2, r3
 8004090: 68bb         	ldr	r3, [r7, #0x8]
 8004092: 4413         	add	r3, r2
 8004094: 3b08         	subs	r3, #0x8
 8004096: e0cd         	b	0x8004234 <cbvprintf_package+0x7b0> @ imm = #0x19a
; 	*(char **)buf0 = NULL;
 8004098: 6dfb         	ldr	r3, [r7, #0x5c]
 800409a: 2200         	movs	r2, #0x0
 800409c: 601a         	str	r2, [r3]
; 	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
 800409e: 6dfb         	ldr	r3, [r7, #0x5c]
 80040a0: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80040a4: 1ad3         	subs	r3, r2, r3
 80040a6: 089b         	lsrs	r3, r3, #0x2
 80040a8: b2da         	uxtb	r2, r3
 80040aa: 6d7b         	ldr	r3, [r7, #0x54]
 80040ac: 701a         	strb	r2, [r3]
; 	if (rws_pos_en) {
 80040ae: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 80040b2: 2b00         	cmp	r3, #0x0
 80040b4: d007         	beq	0x80040c6 <cbvprintf_package+0x642> @ imm = #0xe
; 		pkg_hdr->desc.str_cnt = 0;
 80040b6: 6d7b         	ldr	r3, [r7, #0x54]
 80040b8: 2200         	movs	r2, #0x0
 80040ba: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
 80040bc: 6ffb         	ldr	r3, [r7, #0x7c]
 80040be: b2da         	uxtb	r2, r3
 80040c0: 6d7b         	ldr	r3, [r7, #0x54]
 80040c2: 70da         	strb	r2, [r3, #0x3]
 80040c4: e006         	b	0x80040d4 <cbvprintf_package+0x650> @ imm = #0xc
; 		pkg_hdr->desc.str_cnt = s_rw_cnt;
 80040c6: 6ffb         	ldr	r3, [r7, #0x7c]
 80040c8: b2da         	uxtb	r2, r3
 80040ca: 6d7b         	ldr	r3, [r7, #0x54]
 80040cc: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = 0;
 80040ce: 6d7b         	ldr	r3, [r7, #0x54]
 80040d0: 2200         	movs	r2, #0x0
 80040d2: 70da         	strb	r2, [r3, #0x3]
; 	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
 80040d4: 6fbb         	ldr	r3, [r7, #0x78]
 80040d6: b2da         	uxtb	r2, r3
 80040d8: 6d7b         	ldr	r3, [r7, #0x54]
 80040da: 709a         	strb	r2, [r3, #0x2]
; 	if (s_ro_cnt != 0U) {
 80040dc: 6fbb         	ldr	r3, [r7, #0x78]
 80040de: 2b00         	cmp	r3, #0x0
 80040e0: d032         	beq	0x8004148 <cbvprintf_package+0x6c4> @ imm = #0x64
; 		for (i = 0; i < s_idx; i++) {
 80040e2: 2300         	movs	r3, #0x0
 80040e4: 673b         	str	r3, [r7, #0x70]
 80040e6: e02a         	b	0x800413e <cbvprintf_package+0x6ba> @ imm = #0x54
; 			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
 80040e8: f107 0230    	add.w	r2, r7, #0x30
 80040ec: 6f3b         	ldr	r3, [r7, #0x70]
 80040ee: 4413         	add	r3, r2
 80040f0: 781b         	ldrb	r3, [r3]
 80040f2: b25b         	sxtb	r3, r3
 80040f4: 2b00         	cmp	r3, #0x0
 80040f6: da1e         	bge	0x8004136 <cbvprintf_package+0x6b2> @ imm = #0x3c
; 			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
 80040f8: f107 0230    	add.w	r2, r7, #0x30
 80040fc: 6f3b         	ldr	r3, [r7, #0x70]
 80040fe: 4413         	add	r3, r2
 8004100: 781b         	ldrb	r3, [r3]
 8004102: f003 037f    	and	r3, r3, #0x7f
 8004106: f887 3043    	strb.w	r3, [r7, #0x43]
; 			if ((BUF_OFFSET + 1) > len) {
 800410a: 6dfb         	ldr	r3, [r7, #0x5c]
 800410c: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004110: 1ad3         	subs	r3, r2, r3
 8004112: 3301         	adds	r3, #0x1
 8004114: 68ba         	ldr	r2, [r7, #0x8]
 8004116: 429a         	cmp	r2, r3
 8004118: d202         	bhs	0x8004120 <cbvprintf_package+0x69c> @ imm = #0x4
; 				return -ENOSPC;
 800411a: f06f 031b    	mvn	r3, #0x1b
 800411e: e089         	b	0x8004234 <cbvprintf_package+0x7b0> @ imm = #0x112
; 			*(uint8_t *)buf = pos;
 8004120: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004124: f897 2043    	ldrb.w	r2, [r7, #0x43]
 8004128: 701a         	strb	r2, [r3]
; 			++buf;
 800412a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800412e: 3301         	adds	r3, #0x1
 8004130: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8004134: e000         	b	0x8004138 <cbvprintf_package+0x6b4> @ imm = #0x0
; 				continue;
 8004136: bf00         	nop
; 		for (i = 0; i < s_idx; i++) {
 8004138: 6f3b         	ldr	r3, [r7, #0x70]
 800413a: 3301         	adds	r3, #0x1
 800413c: 673b         	str	r3, [r7, #0x70]
 800413e: 6f3a         	ldr	r2, [r7, #0x70]
 8004140: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004144: 429a         	cmp	r2, r3
 8004146: d3cf         	blo	0x80040e8 <cbvprintf_package+0x664> @ imm = #-0x62
; 	for (i = 0; i < s_idx; i++) {
 8004148: 2300         	movs	r3, #0x0
 800414a: 673b         	str	r3, [r7, #0x70]
 800414c: e069         	b	0x8004222 <cbvprintf_package+0x79e> @ imm = #0xd2
; 		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
 800414e: 6fbb         	ldr	r3, [r7, #0x78]
 8004150: 2b00         	cmp	r3, #0x0
 8004152: d007         	beq	0x8004164 <cbvprintf_package+0x6e0> @ imm = #0xe
 8004154: f107 0230    	add.w	r2, r7, #0x30
 8004158: 6f3b         	ldr	r3, [r7, #0x70]
 800415a: 4413         	add	r3, r2
 800415c: 781b         	ldrb	r3, [r3]
 800415e: b25b         	sxtb	r3, r3
 8004160: 2b00         	cmp	r3, #0x0
 8004162: db5a         	blt	0x800421a <cbvprintf_package+0x796> @ imm = #0xb4
; 		if (rws_pos_en) {
 8004164: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8004168: 2b00         	cmp	r3, #0x0
 800416a: d010         	beq	0x800418e <cbvprintf_package+0x70a> @ imm = #0x20
; 			size = 0;
 800416c: 2300         	movs	r3, #0x0
 800416e: f8c7 3088    	str.w	r3, [r7, #0x88]
; 			*(uint8_t *)buf = str_ptr_arg[i];
 8004172: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004176: f107 0120    	add.w	r1, r7, #0x20
 800417a: 6f3a         	ldr	r2, [r7, #0x70]
 800417c: 440a         	add	r2, r1
 800417e: 7812         	ldrb	r2, [r2]
 8004180: 701a         	strb	r2, [r3]
; 			++buf;
 8004182: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004186: 3301         	adds	r3, #0x1
 8004188: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800418c: e01a         	b	0x80041c4 <cbvprintf_package+0x740> @ imm = #0x34
; 			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
 800418e: f107 0230    	add.w	r2, r7, #0x30
 8004192: 6f3b         	ldr	r3, [r7, #0x70]
 8004194: 4413         	add	r3, r2
 8004196: 781b         	ldrb	r3, [r3]
 8004198: 009b         	lsls	r3, r3, #0x2
 800419a: 6dfa         	ldr	r2, [r7, #0x5c]
 800419c: 4413         	add	r3, r2
 800419e: 681b         	ldr	r3, [r3]
 80041a0: 66fb         	str	r3, [r7, #0x6c]
; 			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
 80041a2: f107 0230    	add.w	r2, r7, #0x30
 80041a6: 6f3b         	ldr	r3, [r7, #0x70]
 80041a8: 4413         	add	r3, r2
 80041aa: 781b         	ldrb	r3, [r3]
 80041ac: 009b         	lsls	r3, r3, #0x2
 80041ae: 6dfa         	ldr	r2, [r7, #0x5c]
 80041b0: 4413         	add	r3, r2
 80041b2: 2200         	movs	r2, #0x0
 80041b4: 601a         	str	r2, [r3]
; 			size = strlen(s) + 1;
 80041b6: 6ef8         	ldr	r0, [r7, #0x6c]
 80041b8: f7fc fa66    	bl	0x8000688 <strlen>      @ imm = #-0x3b34
 80041bc: 4603         	mov	r3, r0
 80041be: 3301         	adds	r3, #0x1
 80041c0: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		if ((BUF_OFFSET + 1 + size) > len) {
 80041c4: 6dfb         	ldr	r3, [r7, #0x5c]
 80041c6: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80041ca: 1ad2         	subs	r2, r2, r3
 80041cc: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80041d0: 4413         	add	r3, r2
 80041d2: 3301         	adds	r3, #0x1
 80041d4: 68ba         	ldr	r2, [r7, #0x8]
 80041d6: 429a         	cmp	r2, r3
 80041d8: d202         	bhs	0x80041e0 <cbvprintf_package+0x75c> @ imm = #0x4
; 			return -ENOSPC;
 80041da: f06f 031b    	mvn	r3, #0x1b
 80041de: e029         	b	0x8004234 <cbvprintf_package+0x7b0> @ imm = #0x52
; 		*(uint8_t *)buf = str_ptr_pos[i];
 80041e0: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80041e4: f107 0130    	add.w	r1, r7, #0x30
 80041e8: 6f3a         	ldr	r2, [r7, #0x70]
 80041ea: 440a         	add	r2, r1
 80041ec: 7812         	ldrb	r2, [r2]
 80041ee: 701a         	strb	r2, [r3]
; 		++buf;
 80041f0: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80041f4: 3301         	adds	r3, #0x1
 80041f6: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		memcpy((void *)buf, (uint8_t *)s, size);
 80041fa: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80041fe: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 8004202: 6ef9         	ldr	r1, [r7, #0x6c]
 8004204: 4618         	mov	r0, r3
 8004206: f023 f971    	bl	0x80274ec <memcpy>      @ imm = #0x232e2
; 		buf += size;
 800420a: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 800420e: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8004212: 4413         	add	r3, r2
 8004214: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8004218: e000         	b	0x800421c <cbvprintf_package+0x798> @ imm = #0x0
; 			continue;
 800421a: bf00         	nop
; 	for (i = 0; i < s_idx; i++) {
 800421c: 6f3b         	ldr	r3, [r7, #0x70]
 800421e: 3301         	adds	r3, #0x1
 8004220: 673b         	str	r3, [r7, #0x70]
 8004222: 6f3a         	ldr	r2, [r7, #0x70]
 8004224: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004228: 429a         	cmp	r2, r3
 800422a: d390         	blo	0x800414e <cbvprintf_package+0x6ca> @ imm = #-0xe0
; 	return BUF_OFFSET;
 800422c: 6dfb         	ldr	r3, [r7, #0x5c]
 800422e: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004232: 1ad3         	subs	r3, r2, r3
; }
 8004234: 4618         	mov	r0, r3
 8004236: 3790         	adds	r7, #0x90
 8004238: 46bd         	mov	sp, r7
 800423a: bd80         	pop	{r7, pc}

0800423c <__printk_hook_install>:
; {
 800423c: b480         	push	{r7}
 800423e: b083         	sub	sp, #0xc
 8004240: af00         	add	r7, sp, #0x0
 8004242: 6078         	str	r0, [r7, #0x4]
; 	_char_out = fn;
 8004244: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004258 <__printk_hook_install+0x1c>
 8004246: 687b         	ldr	r3, [r7, #0x4]
 8004248: 6013         	str	r3, [r2]
; }
 800424a: bf00         	nop
 800424c: 370c         	adds	r7, #0xc
 800424e: 46bd         	mov	sp, r7
 8004250: f85d 7b04    	ldr	r7, [sp], #4
 8004254: 4770         	bx	lr
 8004256: bf00         	nop

08004258 <$d>:
 8004258: d4 04 00 20  	.word	0x200004d4

0800425c <k_current_get>:
; {
 800425c: b580         	push	{r7, lr}
 800425e: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 8004260: f023 fb34    	bl	0x80278cc <__aeabi_read_tp> @ imm = #0x23668
 8004264: 4603         	mov	r3, r0
 8004266: 4a02         	ldr	r2, [pc, #0x8]          @ 0x8004270 <k_current_get+0x14>
 8004268: 589b         	ldr	r3, [r3, r2]
; }
 800426a: 4618         	mov	r0, r3
 800426c: bd80         	pop	{r7, pc}
 800426e: bf00         	nop

08004270 <$d>:
 8004270: 08 00 00 00  	.word	0x00000008

08004274 <z_thread_entry>:
; {
 8004274: b580         	push	{r7, lr}
 8004276: b084         	sub	sp, #0x10
 8004278: af00         	add	r7, sp, #0x0
 800427a: 60f8         	str	r0, [r7, #0xc]
 800427c: 60b9         	str	r1, [r7, #0x8]
 800427e: 607a         	str	r2, [r7, #0x4]
 8004280: 603b         	str	r3, [r7]
; 	z_tls_current = k_sched_current_thread_query();
 8004282: f017 f898    	bl	0x801b3b6 <k_sched_current_thread_query> @ imm = #0x17130
 8004286: 4602         	mov	r2, r0
 8004288: f023 fb20    	bl	0x80278cc <__aeabi_read_tp> @ imm = #0x23640
 800428c: 4603         	mov	r3, r0
 800428e: 4906         	ldr	r1, [pc, #0x18]         @ 0x80042a8 <z_thread_entry+0x34>
 8004290: 505a         	str	r2, [r3, r1]
; 	entry(p1, p2, p3);
 8004292: 68fb         	ldr	r3, [r7, #0xc]
 8004294: 683a         	ldr	r2, [r7]
 8004296: 6879         	ldr	r1, [r7, #0x4]
 8004298: 68b8         	ldr	r0, [r7, #0x8]
 800429a: 4798         	blx	r3
; 	k_thread_abort(k_current_get());
 800429c: f7ff ffde    	bl	0x800425c <k_current_get> @ imm = #-0x44
 80042a0: 4603         	mov	r3, r0
 80042a2: 4618         	mov	r0, r3
 80042a4: f017 f88e    	bl	0x801b3c4 <k_thread_abort> @ imm = #0x1711c

080042a8 <$d>:
 80042a8: 08 00 00 00  	.word	0x00000008

080042ac <LL_DBGMCU_DisableDBGStopMode>:
; {
 80042ac: b480         	push	{r7}
 80042ae: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 80042b0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80042c8 <LL_DBGMCU_DisableDBGStopMode+0x1c>
 80042b2: 685b         	ldr	r3, [r3, #0x4]
 80042b4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80042c8 <LL_DBGMCU_DisableDBGStopMode+0x1c>
 80042b6: f023 0302    	bic	r3, r3, #0x2
 80042ba: 6053         	str	r3, [r2, #0x4]
; }
 80042bc: bf00         	nop
 80042be: 46bd         	mov	sp, r7
 80042c0: f85d 7b04    	ldr	r7, [sp], #4
 80042c4: 4770         	bx	lr
 80042c6: bf00         	nop

080042c8 <$d>:
 80042c8: 00 20 04 e0  	.word	0xe0042000

080042cc <LL_FLASH_EnablePrefetch>:
; {
 80042cc: b480         	push	{r7}
 80042ce: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_PRFTEN);
 80042d0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80042e8 <LL_FLASH_EnablePrefetch+0x1c>
 80042d2: 681b         	ldr	r3, [r3]
 80042d4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80042e8 <LL_FLASH_EnablePrefetch+0x1c>
 80042d6: f443 7380    	orr	r3, r3, #0x100
 80042da: 6013         	str	r3, [r2]
; }
 80042dc: bf00         	nop
 80042de: 46bd         	mov	sp, r7
 80042e0: f85d 7b04    	ldr	r7, [sp], #4
 80042e4: 4770         	bx	lr
 80042e6: bf00         	nop

080042e8 <$d>:
 80042e8: 00 3c 02 40  	.word	0x40023c00

080042ec <LL_FLASH_EnableInstCache>:
; {
 80042ec: b480         	push	{r7}
 80042ee: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_ICEN);
 80042f0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8004308 <LL_FLASH_EnableInstCache+0x1c>
 80042f2: 681b         	ldr	r3, [r3]
 80042f4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004308 <LL_FLASH_EnableInstCache+0x1c>
 80042f6: f443 7300    	orr	r3, r3, #0x200
 80042fa: 6013         	str	r3, [r2]
; }
 80042fc: bf00         	nop
 80042fe: 46bd         	mov	sp, r7
 8004300: f85d 7b04    	ldr	r7, [sp], #4
 8004304: 4770         	bx	lr
 8004306: bf00         	nop

08004308 <$d>:
 8004308: 00 3c 02 40  	.word	0x40023c00

0800430c <LL_FLASH_EnableDataCache>:
; {
 800430c: b480         	push	{r7}
 800430e: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_DCEN);
 8004310: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8004328 <LL_FLASH_EnableDataCache+0x1c>
 8004312: 681b         	ldr	r3, [r3]
 8004314: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004328 <LL_FLASH_EnableDataCache+0x1c>
 8004316: f443 6380    	orr	r3, r3, #0x400
 800431a: 6013         	str	r3, [r2]
; }
 800431c: bf00         	nop
 800431e: 46bd         	mov	sp, r7
 8004320: f85d 7b04    	ldr	r7, [sp], #4
 8004324: 4770         	bx	lr
 8004326: bf00         	nop

08004328 <$d>:
 8004328: 00 3c 02 40  	.word	0x40023c00

0800432c <soc_early_init_hook>:
; {
 800432c: b580         	push	{r7, lr}
 800432e: af00         	add	r7, sp, #0x0
; 	LL_FLASH_EnablePrefetch();
 8004330: f7ff ffcc    	bl	0x80042cc <LL_FLASH_EnablePrefetch> @ imm = #-0x68
; 	LL_FLASH_EnableInstCache();
 8004334: f7ff ffda    	bl	0x80042ec <LL_FLASH_EnableInstCache> @ imm = #-0x4c
; 	LL_FLASH_EnableDataCache();
 8004338: f7ff ffe8    	bl	0x800430c <LL_FLASH_EnableDataCache> @ imm = #-0x30
; 	SystemCoreClock = 16000000;
 800433c: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8004348 <soc_early_init_hook+0x1c>
 800433e: 4a03         	ldr	r2, [pc, #0xc]          @ 0x800434c <soc_early_init_hook+0x20>
 8004340: 601a         	str	r2, [r3]
; }
 8004342: bf00         	nop
 8004344: bd80         	pop	{r7, pc}
 8004346: bf00         	nop

08004348 <$d>:
 8004348: 40 0b 00 20  	.word	0x20000b40
 800434c: 00 24 f4 00  	.word	0x00f42400

08004350 <thread_print_cb>:
; {
 8004350: b5b0         	push	{r4, r5, r7, lr}
 8004352: b092         	sub	sp, #0x48
 8004354: af0a         	add	r7, sp, #0x28
 8004356: 6078         	str	r0, [r7, #0x4]
; 	size_t pcnt = (info->stack_used * 100U) / info->stack_size;
 8004358: 687b         	ldr	r3, [r7, #0x4]
 800435a: 689b         	ldr	r3, [r3, #0x8]
 800435c: 2264         	movs	r2, #0x64
 800435e: fb03 f202    	mul	r2, r3, r2
 8004362: 687b         	ldr	r3, [r7, #0x4]
 8004364: 685b         	ldr	r3, [r3, #0x4]
 8004366: fbb2 f3f3    	udiv	r3, r2, r3
 800436a: 61fb         	str	r3, [r7, #0x1c]
; 	THREAD_ANALYZER_PRINT(
 800436c: 2303         	movs	r3, #0x3
 800436e: 2b02         	cmp	r3, #0x2
 8004370: d92b         	bls	0x80043ca <thread_print_cb+0x7a> @ imm = #0x56
 8004372: 2301         	movs	r3, #0x1
 8004374: 76fb         	strb	r3, [r7, #0x1b]
 8004376: 7efb         	ldrb	r3, [r7, #0x1b]
 8004378: f083 0301    	eor	r3, r3, #0x1
 800437c: b2db         	uxtb	r3, r3
 800437e: 2b00         	cmp	r3, #0x0
 8004380: d123         	bne	0x80043ca <thread_print_cb+0x7a> @ imm = #0x46
 8004382: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8004418 <thread_print_cb+0xc8>
 8004384: 681d         	ldr	r5, [r3]
 8004386: 687b         	ldr	r3, [r7, #0x4]
 8004388: 681b         	ldr	r3, [r3]
 800438a: 687a         	ldr	r2, [r7, #0x4]
 800438c: 6851         	ldr	r1, [r2, #0x4]
 800438e: 687a         	ldr	r2, [r7, #0x4]
 8004390: 6892         	ldr	r2, [r2, #0x8]
 8004392: 1a8a         	subs	r2, r1, r2
 8004394: 6879         	ldr	r1, [r7, #0x4]
 8004396: 6889         	ldr	r1, [r1, #0x8]
 8004398: 6878         	ldr	r0, [r7, #0x4]
 800439a: 6840         	ldr	r0, [r0, #0x4]
 800439c: 687c         	ldr	r4, [r7, #0x4]
 800439e: 68e4         	ldr	r4, [r4, #0xc]
 80043a0: 9408         	str	r4, [sp, #0x20]
 80043a2: 69fc         	ldr	r4, [r7, #0x1c]
 80043a4: 9407         	str	r4, [sp, #0x1c]
 80043a6: 9006         	str	r0, [sp, #0x18]
 80043a8: 9105         	str	r1, [sp, #0x14]
 80043aa: 9204         	str	r2, [sp, #0x10]
 80043ac: 9303         	str	r3, [sp, #0xc]
 80043ae: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800441c <thread_print_cb+0xcc>
 80043b0: 9302         	str	r3, [sp, #0x8]
 80043b2: 2300         	movs	r3, #0x0
 80043b4: 9301         	str	r3, [sp, #0x4]
 80043b6: 2300         	movs	r3, #0x0
 80043b8: 9300         	str	r3, [sp]
 80043ba: 2300         	movs	r3, #0x0
 80043bc: 2203         	movs	r2, #0x3
 80043be: 4629         	mov	r1, r5
 80043c0: 2000         	movs	r0, #0x0
 80043c2: f017 f831    	bl	0x801b428 <z_log_msg_runtime_create> @ imm = #0x17062
 80043c6: 2300         	movs	r3, #0x0
 80043c8: 617b         	str	r3, [r7, #0x14]
; 	THREAD_ANALYZER_PRINT(
 80043ca: 2303         	movs	r3, #0x3
 80043cc: 2b02         	cmp	r3, #0x2
 80043ce: d91e         	bls	0x800440e <thread_print_cb+0xbe> @ imm = #0x3c
 80043d0: 2301         	movs	r3, #0x1
 80043d2: 74fb         	strb	r3, [r7, #0x13]
 80043d4: 7cfb         	ldrb	r3, [r7, #0x13]
 80043d6: f083 0301    	eor	r3, r3, #0x1
 80043da: b2db         	uxtb	r3, r3
 80043dc: 2b00         	cmp	r3, #0x0
 80043de: d116         	bne	0x800440e <thread_print_cb+0xbe> @ imm = #0x2c
 80043e0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8004418 <thread_print_cb+0xc8>
 80043e2: 6819         	ldr	r1, [r3]
 80043e4: 687b         	ldr	r3, [r7, #0x4]
 80043e6: e9d3 2306    	ldrd	r2, r3, [r3, #24]
 80043ea: e9cd 2304    	strd	r2, r3, [sp, #16]
 80043ee: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004420 <thread_print_cb+0xd0>
 80043f0: 9303         	str	r3, [sp, #0xc]
 80043f2: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004424 <thread_print_cb+0xd4>
 80043f4: 9302         	str	r3, [sp, #0x8]
 80043f6: 2300         	movs	r3, #0x0
 80043f8: 9301         	str	r3, [sp, #0x4]
 80043fa: 2300         	movs	r3, #0x0
 80043fc: 9300         	str	r3, [sp]
 80043fe: 2300         	movs	r3, #0x0
 8004400: 2203         	movs	r2, #0x3
 8004402: 2000         	movs	r0, #0x0
 8004404: f017 f810    	bl	0x801b428 <z_log_msg_runtime_create> @ imm = #0x17020
 8004408: 2300         	movs	r3, #0x0
 800440a: 60fb         	str	r3, [r7, #0xc]
; }
 800440c: bf00         	nop
 800440e: bf00         	nop
 8004410: 3720         	adds	r7, #0x20
 8004412: 46bd         	mov	sp, r7
 8004414: bdb0         	pop	{r4, r5, r7, pc}
 8004416: bf00         	nop

08004418 <$d>:
 8004418: d8 04 00 20  	.word	0x200004d8
 800441c: 34 83 02 08  	.word	0x08028334
 8004420: 74 83 02 08  	.word	0x08028374
 8004424: 78 83 02 08  	.word	0x08028378

08004428 <thread_analyze_cb>:
; {
 8004428: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800442c: b0a9         	sub	sp, #0xa4
 800442e: af06         	add	r7, sp, #0x18
 8004430: 60f8         	str	r0, [r7, #0xc]
 8004432: 60b9         	str	r1, [r7, #0x8]
; 	struct k_thread *thread = (struct k_thread *)cthread;
 8004434: 68fb         	ldr	r3, [r7, #0xc]
 8004436: 67fb         	str	r3, [r7, #0x7c]
; 	size_t size = thread->stack_info.size;
 8004438: 6ffb         	ldr	r3, [r7, #0x7c]
 800443a: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800443e: 67bb         	str	r3, [r7, #0x78]
; 	struct ta_cb_user_data *ud = user_data;
 8004440: 68bb         	ldr	r3, [r7, #0x8]
 8004442: 677b         	str	r3, [r7, #0x74]
; 	thread_analyzer_cb cb = ud->cb;
 8004444: 6f7b         	ldr	r3, [r7, #0x74]
 8004446: 681b         	ldr	r3, [r3]
 8004448: 673b         	str	r3, [r7, #0x70]
; 	unsigned int cpu = ud->cpu;
 800444a: 6f7b         	ldr	r3, [r7, #0x74]
 800444c: 685b         	ldr	r3, [r3, #0x4]
 800444e: 66fb         	str	r3, [r7, #0x6c]
; 	name = k_thread_name_get((k_tid_t)thread);
 8004450: 6ff8         	ldr	r0, [r7, #0x7c]
 8004452: f021 fee2    	bl	0x802621a <k_thread_name_get> @ imm = #0x21dc4
 8004456: f8c7 0080    	str.w	r0, [r7, #0x80]
; 	if (!name || name[0] == '\0') {
 800445a: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800445e: 2b00         	cmp	r3, #0x0
 8004460: d004         	beq	0x800446c <thread_analyze_cb+0x44> @ imm = #0x8
 8004462: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004466: 781b         	ldrb	r3, [r3]
 8004468: 2b00         	cmp	r3, #0x0
 800446a: d10a         	bne	0x8004482 <thread_analyze_cb+0x5a> @ imm = #0x14
; 		name = hexname;
 800446c: f107 0314    	add.w	r3, r7, #0x14
 8004470: f8c7 3080    	str.w	r3, [r7, #0x80]
; 		snprintk(hexname, sizeof(hexname), "%p", (void *)thread);
 8004474: f107 0014    	add.w	r0, r7, #0x14
 8004478: 6ffb         	ldr	r3, [r7, #0x7c]
 800447a: 4a47         	ldr	r2, [pc, #0x11c]        @ 0x8004598 <thread_analyze_cb+0x170>
 800447c: 210b         	movs	r1, #0xb
 800447e: f013 f9c9    	bl	0x8017814 <snprintf>    @ imm = #0x13392
; 	err = k_thread_stack_space_get(thread, &unused);
 8004482: f107 0310    	add.w	r3, r7, #0x10
 8004486: 4619         	mov	r1, r3
 8004488: 6ff8         	ldr	r0, [r7, #0x7c]
 800448a: f016 ffbf    	bl	0x801b40c <k_thread_stack_space_get> @ imm = #0x16f7e
 800448e: 66b8         	str	r0, [r7, #0x68]
; 	if (err) {
 8004490: 6ebb         	ldr	r3, [r7, #0x68]
 8004492: 2b00         	cmp	r3, #0x0
 8004494: d022         	beq	0x80044dc <thread_analyze_cb+0xb4> @ imm = #0x44
; 		THREAD_ANALYZER_PRINT(
 8004496: 2303         	movs	r3, #0x3
 8004498: 2b02         	cmp	r3, #0x2
 800449a: d91d         	bls	0x80044d8 <thread_analyze_cb+0xb0> @ imm = #0x3a
 800449c: 2301         	movs	r3, #0x1
 800449e: f887 3067    	strb.w	r3, [r7, #0x67]
 80044a2: f897 3067    	ldrb.w	r3, [r7, #0x67]
 80044a6: f083 0301    	eor	r3, r3, #0x1
 80044aa: b2db         	uxtb	r3, r3
 80044ac: 2b00         	cmp	r3, #0x0
 80044ae: d113         	bne	0x80044d8 <thread_analyze_cb+0xb0> @ imm = #0x26
 80044b0: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x800459c <thread_analyze_cb+0x174>
 80044b2: 6819         	ldr	r1, [r3]
 80044b4: 6ebb         	ldr	r3, [r7, #0x68]
 80044b6: 9304         	str	r3, [sp, #0x10]
 80044b8: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80044bc: 9303         	str	r3, [sp, #0xc]
 80044be: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x80045a0 <thread_analyze_cb+0x178>
 80044c0: 9302         	str	r3, [sp, #0x8]
 80044c2: 2300         	movs	r3, #0x0
 80044c4: 9301         	str	r3, [sp, #0x4]
 80044c6: 2300         	movs	r3, #0x0
 80044c8: 9300         	str	r3, [sp]
 80044ca: 2300         	movs	r3, #0x0
 80044cc: 2203         	movs	r2, #0x3
 80044ce: 2000         	movs	r0, #0x0
 80044d0: f016 ffaa    	bl	0x801b428 <z_log_msg_runtime_create> @ imm = #0x16f54
 80044d4: 2300         	movs	r3, #0x0
 80044d6: 663b         	str	r3, [r7, #0x60]
; 		unused = 0;
 80044d8: 2300         	movs	r3, #0x0
 80044da: 613b         	str	r3, [r7, #0x10]
; 	info.name = name;
 80044dc: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80044e0: 623b         	str	r3, [r7, #0x20]
; 	info.stack_size = size;
 80044e2: 6fbb         	ldr	r3, [r7, #0x78]
 80044e4: 627b         	str	r3, [r7, #0x24]
; 	info.stack_used = size - unused;
 80044e6: 693b         	ldr	r3, [r7, #0x10]
 80044e8: 6fba         	ldr	r2, [r7, #0x78]
 80044ea: 1ad3         	subs	r3, r2, r3
 80044ec: 62bb         	str	r3, [r7, #0x28]
; 	ret = 0;
 80044ee: 2300         	movs	r3, #0x0
 80044f0: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	if (k_thread_runtime_stats_get(thread, &info.usage) != 0) {
 80044f4: f107 0320    	add.w	r3, r7, #0x20
 80044f8: 3310         	adds	r3, #0x10
 80044fa: 4619         	mov	r1, r3
 80044fc: 6ff8         	ldr	r0, [r7, #0x7c]
 80044fe: f021 ff2c    	bl	0x802635a <k_thread_runtime_stats_get> @ imm = #0x21e58
 8004502: 4603         	mov	r3, r0
 8004504: 2b00         	cmp	r3, #0x0
 8004506: d004         	beq	0x8004512 <thread_analyze_cb+0xea> @ imm = #0x8
; 		ret++;
 8004508: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800450c: 3301         	adds	r3, #0x1
 800450e: f8c7 3084    	str.w	r3, [r7, #0x84]
; 		if (k_thread_runtime_stats_all_get(&rt_stats_all) != 0) {
 8004512: f107 0348    	add.w	r3, r7, #0x48
 8004516: 4618         	mov	r0, r3
 8004518: f021 ff36    	bl	0x8026388 <k_thread_runtime_stats_all_get> @ imm = #0x21e6c
 800451c: 4603         	mov	r3, r0
 800451e: 2b00         	cmp	r3, #0x0
 8004520: d004         	beq	0x800452c <thread_analyze_cb+0x104> @ imm = #0x8
; 			ret++;
 8004522: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8004526: 3301         	adds	r3, #0x1
 8004528: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	if (ret == 0) {
 800452c: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8004530: 2b00         	cmp	r3, #0x0
 8004532: d126         	bne	0x8004582 <thread_analyze_cb+0x15a> @ imm = #0x4c
; 		info.utilization = (info.usage.execution_cycles * 100U) /
 8004534: e9d7 010c    	ldrd	r0, r1, [r7, #48]
 8004538: 4602         	mov	r2, r0
 800453a: 460b         	mov	r3, r1
 800453c: 1896         	adds	r6, r2, r2
 800453e: 603e         	str	r6, [r7]
 8004540: 415b         	adcs	r3, r3
 8004542: 607b         	str	r3, [r7, #0x4]
 8004544: e9d7 2300    	ldrd	r2, r3, [r7]
 8004548: 1814         	adds	r4, r2, r0
 800454a: eb43 0501    	adc.w	r5, r3, r1
 800454e: f04f 0200    	mov.w	r2, #0x0
 8004552: f04f 0300    	mov.w	r3, #0x0
 8004556: 016b         	lsls	r3, r5, #0x5
 8004558: ea43 63d4    	orr.w	r3, r3, r4, lsr #27
 800455c: 0162         	lsls	r2, r4, #0x5
 800455e: eb14 0802    	adds.w	r8, r4, r2
 8004562: eb45 0903    	adc.w	r9, r5, r3
 8004566: eb18 0a00    	adds.w	r10, r8, r0
 800456a: eb49 0b01    	adc.w	r11, r9, r1
; 			rt_stats_all.execution_cycles;
 800456e: e9d7 2312    	ldrd	r2, r3, [r7, #72]
; 		info.utilization = (info.usage.execution_cycles * 100U) /
 8004572: 4650         	mov	r0, r10
 8004574: 4659         	mov	r1, r11
 8004576: f7fc f863    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x3f3a
 800457a: 4602         	mov	r2, r0
 800457c: 460b         	mov	r3, r1
 800457e: 4613         	mov	r3, r2
 8004580: 62fb         	str	r3, [r7, #0x2c]
; 	cb(&info);
 8004582: f107 0220    	add.w	r2, r7, #0x20
 8004586: 6f3b         	ldr	r3, [r7, #0x70]
 8004588: 4610         	mov	r0, r2
 800458a: 4798         	blx	r3
; }
 800458c: bf00         	nop
 800458e: 378c         	adds	r7, #0x8c
 8004590: 46bd         	mov	sp, r7
 8004592: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8004596: bf00         	nop

08004598 <$d>:
 8004598: 9c 83 02 08  	.word	0x0802839c
 800459c: d8 04 00 20  	.word	0x200004d8
 80045a0: a0 83 02 08  	.word	0x080283a0

080045a4 <isr_stack>:
; {
 80045a4: b590         	push	{r4, r7, lr}
 80045a6: b093         	sub	sp, #0x4c
 80045a8: af0a         	add	r7, sp, #0x28
 80045aa: 6078         	str	r0, [r7, #0x4]
; 	const uint8_t *buf = K_KERNEL_STACK_BUFFER(z_interrupt_stacks[core]);
 80045ac: 687b         	ldr	r3, [r7, #0x4]
 80045ae: 02db         	lsls	r3, r3, #0xb
 80045b0: 4a24         	ldr	r2, [pc, #0x90]         @ 0x8004644 <isr_stack+0xa0>
 80045b2: 4413         	add	r3, r2
 80045b4: 4618         	mov	r0, r3
 80045b6: f016 ff1e    	bl	0x801b3f6 <K_KERNEL_STACK_BUFFER> @ imm = #0x16e3c
 80045ba: 6138         	str	r0, [r7, #0x10]
; 	size_t size = K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[core]);
 80045bc: f44f 6300    	mov.w	r3, #0x800
 80045c0: 60fb         	str	r3, [r7, #0xc]
; 	err = z_stack_space_get(buf, size, &unused);
 80045c2: f107 0308    	add.w	r3, r7, #0x8
 80045c6: 461a         	mov	r2, r3
 80045c8: 68f9         	ldr	r1, [r7, #0xc]
 80045ca: 6938         	ldr	r0, [r7, #0x10]
 80045cc: f021 fe7e    	bl	0x80262cc <z_stack_space_get> @ imm = #0x21cfc
 80045d0: 61f8         	str	r0, [r7, #0x1c]
; 	if (err == 0) {
 80045d2: 69fb         	ldr	r3, [r7, #0x1c]
 80045d4: 2b00         	cmp	r3, #0x0
 80045d6: d131         	bne	0x800463c <isr_stack+0x98> @ imm = #0x62
; 		THREAD_ANALYZER_PRINT(
 80045d8: 2303         	movs	r3, #0x3
 80045da: 2b02         	cmp	r3, #0x2
 80045dc: d92e         	bls	0x800463c <isr_stack+0x98> @ imm = #0x5c
 80045de: 2301         	movs	r3, #0x1
 80045e0: 76fb         	strb	r3, [r7, #0x1b]
 80045e2: 7efb         	ldrb	r3, [r7, #0x1b]
 80045e4: f083 0301    	eor	r3, r3, #0x1
 80045e8: b2db         	uxtb	r3, r3
 80045ea: 2b00         	cmp	r3, #0x0
 80045ec: d126         	bne	0x800463c <isr_stack+0x98> @ imm = #0x4c
 80045ee: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8004648 <isr_stack+0xa4>
 80045f0: 681c         	ldr	r4, [r3]
 80045f2: 68bb         	ldr	r3, [r7, #0x8]
 80045f4: 68ba         	ldr	r2, [r7, #0x8]
 80045f6: 68f9         	ldr	r1, [r7, #0xc]
 80045f8: 1a8a         	subs	r2, r1, r2
 80045fa: 68b9         	ldr	r1, [r7, #0x8]
 80045fc: 68f8         	ldr	r0, [r7, #0xc]
 80045fe: 1a41         	subs	r1, r0, r1
 8004600: 2064         	movs	r0, #0x64
 8004602: fb01 f000    	mul	r0, r1, r0
 8004606: 68f9         	ldr	r1, [r7, #0xc]
 8004608: fbb0 f1f1    	udiv	r1, r0, r1
 800460c: 9108         	str	r1, [sp, #0x20]
 800460e: 68f9         	ldr	r1, [r7, #0xc]
 8004610: 9107         	str	r1, [sp, #0x1c]
 8004612: 9206         	str	r2, [sp, #0x18]
 8004614: 9305         	str	r3, [sp, #0x14]
 8004616: 687b         	ldr	r3, [r7, #0x4]
 8004618: 9304         	str	r3, [sp, #0x10]
 800461a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800464c <isr_stack+0xa8>
 800461c: 9303         	str	r3, [sp, #0xc]
 800461e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004650 <isr_stack+0xac>
 8004620: 9302         	str	r3, [sp, #0x8]
 8004622: 2300         	movs	r3, #0x0
 8004624: 9301         	str	r3, [sp, #0x4]
 8004626: 2300         	movs	r3, #0x0
 8004628: 9300         	str	r3, [sp]
 800462a: 2300         	movs	r3, #0x0
 800462c: 2203         	movs	r2, #0x3
 800462e: 4621         	mov	r1, r4
 8004630: 2000         	movs	r0, #0x0
 8004632: f016 fef9    	bl	0x801b428 <z_log_msg_runtime_create> @ imm = #0x16df2
 8004636: 2300         	movs	r3, #0x0
 8004638: 617b         	str	r3, [r7, #0x14]
; }
 800463a: e7ff         	b	0x800463c <isr_stack+0x98> @ imm = #-0x2
 800463c: bf00         	nop
 800463e: 3724         	adds	r7, #0x24
 8004640: 46bd         	mov	sp, r7
 8004642: bd90         	pop	{r4, r7, pc}

08004644 <$d>:
 8004644: 48 53 00 20  	.word	0x20005348
 8004648: d8 04 00 20  	.word	0x200004d8
 800464c: c8 83 02 08  	.word	0x080283c8
 8004650: cc 83 02 08  	.word	0x080283cc

08004654 <thread_analyzer_run>:
; {
 8004654: b580         	push	{r7, lr}
 8004656: b084         	sub	sp, #0x10
 8004658: af00         	add	r7, sp, #0x0
 800465a: 6078         	str	r0, [r7, #0x4]
 800465c: 6039         	str	r1, [r7]
; 	struct ta_cb_user_data ud = { .cb = cb, .cpu = cpu };
 800465e: 687b         	ldr	r3, [r7, #0x4]
 8004660: 60bb         	str	r3, [r7, #0x8]
 8004662: 683b         	ldr	r3, [r7]
 8004664: 60fb         	str	r3, [r7, #0xc]
; 			k_thread_foreach_unlocked(thread_analyze_cb, &ud);
 8004666: f107 0308    	add.w	r3, r7, #0x8
 800466a: 4619         	mov	r1, r3
 800466c: 4804         	ldr	r0, [pc, #0x10]         @ 0x8004680 <thread_analyzer_run+0x2c>
 800466e: f012 fa13    	bl	0x8016a98 <k_thread_foreach_unlocked> @ imm = #0x12426
; 			isr_stacks();
 8004672: f016 fef7    	bl	0x801b464 <isr_stacks>  @ imm = #0x16dee
; }
 8004676: bf00         	nop
 8004678: 3710         	adds	r7, #0x10
 800467a: 46bd         	mov	sp, r7
 800467c: bd80         	pop	{r7, pc}
 800467e: bf00         	nop

08004680 <$d>:
 8004680: 29 44 00 08  	.word	0x08004429

08004684 <thread_analyzer_print>:
; {
 8004684: b580         	push	{r7, lr}
 8004686: b088         	sub	sp, #0x20
 8004688: af04         	add	r7, sp, #0x10
 800468a: 6078         	str	r0, [r7, #0x4]
; 	THREAD_ANALYZER_PRINT(THREAD_ANALYZER_FMT("Thread analyze:"));
 800468c: 2303         	movs	r3, #0x3
 800468e: 2b02         	cmp	r3, #0x2
 8004690: d916         	bls	0x80046c0 <thread_analyzer_print+0x3c> @ imm = #0x2c
 8004692: 2301         	movs	r3, #0x1
 8004694: 73fb         	strb	r3, [r7, #0xf]
 8004696: 7bfb         	ldrb	r3, [r7, #0xf]
 8004698: f083 0301    	eor	r3, r3, #0x1
 800469c: b2db         	uxtb	r3, r3
 800469e: 2b00         	cmp	r3, #0x0
 80046a0: d10e         	bne	0x80046c0 <thread_analyzer_print+0x3c> @ imm = #0x1c
 80046a2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80046d0 <thread_analyzer_print+0x4c>
 80046a4: 6819         	ldr	r1, [r3]
 80046a6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80046d4 <thread_analyzer_print+0x50>
 80046a8: 9302         	str	r3, [sp, #0x8]
 80046aa: 2300         	movs	r3, #0x0
 80046ac: 9301         	str	r3, [sp, #0x4]
 80046ae: 2300         	movs	r3, #0x0
 80046b0: 9300         	str	r3, [sp]
 80046b2: 2300         	movs	r3, #0x0
 80046b4: 2203         	movs	r2, #0x3
 80046b6: 2000         	movs	r0, #0x0
 80046b8: f016 feb6    	bl	0x801b428 <z_log_msg_runtime_create> @ imm = #0x16d6c
 80046bc: 2300         	movs	r3, #0x0
 80046be: 60bb         	str	r3, [r7, #0x8]
; 	thread_analyzer_run(thread_print_cb, cpu);
 80046c0: 6879         	ldr	r1, [r7, #0x4]
 80046c2: 4805         	ldr	r0, [pc, #0x14]         @ 0x80046d8 <thread_analyzer_print+0x54>
 80046c4: f7ff ffc6    	bl	0x8004654 <thread_analyzer_run> @ imm = #-0x74
; }
 80046c8: bf00         	nop
 80046ca: 3710         	adds	r7, #0x10
 80046cc: 46bd         	mov	sp, r7
 80046ce: bd80         	pop	{r7, pc}

080046d0 <$d>:
 80046d0: d8 04 00 20  	.word	0x200004d8
 80046d4: 04 84 02 08  	.word	0x08028404
 80046d8: 51 43 00 08  	.word	0x08004351

080046dc <log_backend_get>:
; {
 80046dc: b480         	push	{r7}
 80046de: b085         	sub	sp, #0x14
 80046e0: af00         	add	r7, sp, #0x0
 80046e2: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 80046e4: 687b         	ldr	r3, [r7, #0x4]
 80046e6: 011b         	lsls	r3, r3, #0x4
 80046e8: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80046fc <log_backend_get+0x20>
 80046ea: 4413         	add	r3, r2
 80046ec: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 80046ee: 68fb         	ldr	r3, [r7, #0xc]
; }
 80046f0: 4618         	mov	r0, r3
 80046f2: 3714         	adds	r7, #0x14
 80046f4: 46bd         	mov	sp, r7
 80046f6: f85d 7b04    	ldr	r7, [sp], #4
 80046fa: 4770         	bx	lr

080046fc <$d>:
 80046fc: e8 81 02 08  	.word	0x080281e8

08004700 <log_format_func_t_get>:
; {
 8004700: b480         	push	{r7}
 8004702: b083         	sub	sp, #0xc
 8004704: af00         	add	r7, sp, #0x0
 8004706: 6078         	str	r0, [r7, #0x4]
; 	return format_table[log_type];
 8004708: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800471c <log_format_func_t_get+0x1c>
 800470a: 687b         	ldr	r3, [r7, #0x4]
 800470c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8004710: 4618         	mov	r0, r3
 8004712: 370c         	adds	r7, #0xc
 8004714: 46bd         	mov	sp, r7
 8004716: f85d 7b04    	ldr	r7, [sp], #4
 800471a: 4770         	bx	lr

0800471c <$d>:
 800471c: 7c a7 02 08  	.word	0x0802a77c

08004720 <log_core_init>:
; {
 8004720: b580         	push	{r7, lr}
 8004722: af00         	add	r7, sp, #0x0
; 	panic_mode = false;
 8004724: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8004744 <log_core_init+0x24>
 8004726: 2200         	movs	r2, #0x0
 8004728: 701a         	strb	r2, [r3]
; 	dropped_cnt = 0;
 800472a: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8004748 <log_core_init+0x28>
 800472c: 2200         	movs	r2, #0x0
 800472e: 601a         	str	r2, [r3]
; 	buffered_cnt = 0;
 8004730: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800474c <log_core_init+0x2c>
 8004732: 2200         	movs	r2, #0x0
 8004734: 601a         	str	r2, [r3]
; 		log_set_timestamp_func(default_lf_get_timestamp, 1000U);
 8004736: f44f 717a    	mov.w	r1, #0x3e8
 800473a: 4805         	ldr	r0, [pc, #0x14]         @ 0x8004750 <log_core_init+0x30>
 800473c: f000 f86a    	bl	0x8004814 <log_set_timestamp_func> @ imm = #0xd4
; }
 8004740: bd80         	pop	{r7, pc}
 8004742: bf00         	nop

08004744 <$d>:
 8004744: 04 33 00 20  	.word	0x20003304
 8004748: cc 2c 00 20  	.word	0x20002ccc
 800474c: c8 2c 00 20  	.word	0x20002cc8
 8004750: ed b6 01 08  	.word	0x0801b6ed

08004754 <z_log_init>:
; {
 8004754: b580         	push	{r7, lr}
 8004756: b086         	sub	sp, #0x18
 8004758: af00         	add	r7, sp, #0x0
 800475a: 4603         	mov	r3, r0
 800475c: 460a         	mov	r2, r1
 800475e: 71fb         	strb	r3, [r7, #0x7]
 8004760: 4613         	mov	r3, r2
 8004762: 71bb         	strb	r3, [r7, #0x6]
; 	uint32_t mask = 0;
 8004764: 2300         	movs	r3, #0x0
 8004766: 617b         	str	r3, [r7, #0x14]
; 	if (atomic_inc(&initialized) != 0) {
 8004768: 4827         	ldr	r0, [pc, #0x9c]         @ 0x8004808 <z_log_init+0xb4>
 800476a: f016 fec4    	bl	0x801b4f6 <atomic_inc>  @ imm = #0x16d88
 800476e: 4603         	mov	r3, r0
 8004770: 2b00         	cmp	r3, #0x0
 8004772: d001         	beq	0x8004778 <z_log_init+0x24> @ imm = #0x2
; 		return 0;
 8004774: 2300         	movs	r3, #0x0
 8004776: e042         	b	0x80047fe <z_log_init+0xaa> @ imm = #0x84
; 	int backend_index = 0;
 8004778: 2300         	movs	r3, #0x0
 800477a: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 800477c: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800480c <z_log_init+0xb8>
 800477e: 60fb         	str	r3, [r7, #0xc]
 8004780: e022         	b	0x80047c8 <z_log_init+0x74> @ imm = #0x44
; 		if (backend->autostart) {
 8004782: 68fb         	ldr	r3, [r7, #0xc]
 8004784: 7b1b         	ldrb	r3, [r3, #0xc]
 8004786: 2b00         	cmp	r3, #0x0
 8004788: d018         	beq	0x80047bc <z_log_init+0x68> @ imm = #0x30
; 			log_backend_init(backend);
 800478a: 68f8         	ldr	r0, [r7, #0xc]
 800478c: f016 ff40    	bl	0x801b610 <log_backend_init> @ imm = #0x16e80
; 			if (log_backend_is_ready(backend) == 0) {
 8004790: 68f8         	ldr	r0, [r7, #0xc]
 8004792: f016 ff4f    	bl	0x801b634 <log_backend_is_ready> @ imm = #0x16e9e
 8004796: 4603         	mov	r3, r0
 8004798: 2b00         	cmp	r3, #0x0
 800479a: d108         	bne	0x80047ae <z_log_init+0x5a> @ imm = #0x10
; 						   backend->cb->ctx,
 800479c: 68fb         	ldr	r3, [r7, #0xc]
 800479e: 685b         	ldr	r3, [r3, #0x4]
; 				log_backend_enable(backend,
 80047a0: 681b         	ldr	r3, [r3]
 80047a2: 2204         	movs	r2, #0x4
 80047a4: 4619         	mov	r1, r3
 80047a6: 68f8         	ldr	r0, [r7, #0xc]
 80047a8: f017 f8a8    	bl	0x801b8fc <log_backend_enable> @ imm = #0x17150
 80047ac: e006         	b	0x80047bc <z_log_init+0x68> @ imm = #0xc
; 				mask |= BIT(backend_index);
 80047ae: 2201         	movs	r2, #0x1
 80047b0: 693b         	ldr	r3, [r7, #0x10]
 80047b2: fa02 f303    	lsl.w	r3, r2, r3
 80047b6: 697a         	ldr	r2, [r7, #0x14]
 80047b8: 4313         	orrs	r3, r2
 80047ba: 617b         	str	r3, [r7, #0x14]
; 		++backend_index;
 80047bc: 693b         	ldr	r3, [r7, #0x10]
 80047be: 3301         	adds	r3, #0x1
 80047c0: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80047c2: 68fb         	ldr	r3, [r7, #0xc]
 80047c4: 3310         	adds	r3, #0x10
 80047c6: 60fb         	str	r3, [r7, #0xc]
 80047c8: 68fb         	ldr	r3, [r7, #0xc]
 80047ca: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8004810 <z_log_init+0xbc>
 80047cc: 4293         	cmp	r3, r2
 80047ce: bf34         	ite	lo
 80047d0: 2301         	movlo	r3, #0x1
 80047d2: 2300         	movhs	r3, #0x0
 80047d4: b2db         	uxtb	r3, r3
 80047d6: 2b00         	cmp	r3, #0x0
 80047d8: d1d3         	bne	0x8004782 <z_log_init+0x2e> @ imm = #-0x5a
; 	if (blocking) {
 80047da: 79fb         	ldrb	r3, [r7, #0x7]
 80047dc: 2b00         	cmp	r3, #0x0
 80047de: d00d         	beq	0x80047fc <z_log_init+0xa8> @ imm = #0x1a
; 		while (mask) {
 80047e0: e009         	b	0x80047f6 <z_log_init+0xa2> @ imm = #0x12
; 			mask = activate_foreach_backend(mask);
 80047e2: 6978         	ldr	r0, [r7, #0x14]
 80047e4: f016 ff89    	bl	0x801b6fa <activate_foreach_backend> @ imm = #0x16f12
 80047e8: 6178         	str	r0, [r7, #0x14]
; 			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
 80047ea: 79bb         	ldrb	r3, [r7, #0x6]
 80047ec: 2b00         	cmp	r3, #0x0
 80047ee: d002         	beq	0x80047f6 <z_log_init+0xa2> @ imm = #0x4
; 				k_msleep(10);
 80047f0: 200a         	movs	r0, #0xa
 80047f2: f016 feae    	bl	0x801b552 <k_msleep>    @ imm = #0x16d5c
; 		while (mask) {
 80047f6: 697b         	ldr	r3, [r7, #0x14]
 80047f8: 2b00         	cmp	r3, #0x0
 80047fa: d1f2         	bne	0x80047e2 <z_log_init+0x8e> @ imm = #-0x1c
; 	return mask;
 80047fc: 697b         	ldr	r3, [r7, #0x14]
; }
 80047fe: 4618         	mov	r0, r3
 8004800: 3718         	adds	r7, #0x18
 8004802: 46bd         	mov	sp, r7
 8004804: bd80         	pop	{r7, pc}
 8004806: bf00         	nop

08004808 <$d>:
 8004808: c4 2c 00 20  	.word	0x20002cc4
 800480c: e8 81 02 08  	.word	0x080281e8
 8004810: f8 81 02 08  	.word	0x080281f8

08004814 <log_set_timestamp_func>:
; {
 8004814: b580         	push	{r7, lr}
 8004816: b082         	sub	sp, #0x8
 8004818: af00         	add	r7, sp, #0x0
 800481a: 6078         	str	r0, [r7, #0x4]
 800481c: 6039         	str	r1, [r7]
; 	if (timestamp_getter == NULL) {
 800481e: 687b         	ldr	r3, [r7, #0x4]
 8004820: 2b00         	cmp	r3, #0x0
 8004822: d102         	bne	0x800482a <log_set_timestamp_func+0x16> @ imm = #0x4
; 		return -EINVAL;
 8004824: f06f 0315    	mvn	r3, #0x15
 8004828: e009         	b	0x800483e <log_set_timestamp_func+0x2a> @ imm = #0x12
; 	timestamp_func = timestamp_getter;
 800482a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8004848 <log_set_timestamp_func+0x34>
 800482c: 687b         	ldr	r3, [r7, #0x4]
 800482e: 6013         	str	r3, [r2]
; 	timestamp_freq = freq;
 8004830: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800484c <log_set_timestamp_func+0x38>
 8004832: 683b         	ldr	r3, [r7]
 8004834: 6013         	str	r3, [r2]
; 		log_output_timestamp_freq_set(freq);
 8004836: 6838         	ldr	r0, [r7]
 8004838: f000 fcec    	bl	0x8005214 <log_output_timestamp_freq_set> @ imm = #0x9d8
; 	return 0;
 800483c: 2300         	movs	r3, #0x0
; }
 800483e: 4618         	mov	r0, r3
 8004840: 3708         	adds	r7, #0x8
 8004842: 46bd         	mov	sp, r7
 8004844: bd80         	pop	{r7, pc}
 8004846: bf00         	nop

08004848 <$d>:
 8004848: dc 04 00 20  	.word	0x200004dc
 800484c: d0 2c 00 20  	.word	0x20002cd0

08004850 <z_impl_log_panic>:
; {
 8004850: b580         	push	{r7, lr}
 8004852: b082         	sub	sp, #0x8
 8004854: af00         	add	r7, sp, #0x0
; 	if (panic_mode) {
 8004856: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80048a8 <z_impl_log_panic+0x58>
 8004858: 781b         	ldrb	r3, [r3]
 800485a: 2b00         	cmp	r3, #0x0
 800485c: d120         	bne	0x80048a0 <z_impl_log_panic+0x50> @ imm = #0x40
; 	(void)z_log_init(true, false);
 800485e: 2100         	movs	r1, #0x0
 8004860: 2001         	movs	r0, #0x1
 8004862: f7ff ff77    	bl	0x8004754 <z_log_init>  @ imm = #-0x112
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8004866: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80048ac <z_impl_log_panic+0x5c>
 8004868: 607b         	str	r3, [r7, #0x4]
 800486a: e00b         	b	0x8004884 <z_impl_log_panic+0x34> @ imm = #0x16
; 		if (log_backend_is_active(backend)) {
 800486c: 6878         	ldr	r0, [r7, #0x4]
 800486e: f016 ff12    	bl	0x801b696 <log_backend_is_active> @ imm = #0x16e24
 8004872: 4603         	mov	r3, r0
 8004874: 2b00         	cmp	r3, #0x0
 8004876: d002         	beq	0x800487e <z_impl_log_panic+0x2e> @ imm = #0x4
; 			log_backend_panic(backend);
 8004878: 6878         	ldr	r0, [r7, #0x4]
 800487a: f016 feff    	bl	0x801b67c <log_backend_panic> @ imm = #0x16dfe
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 800487e: 687b         	ldr	r3, [r7, #0x4]
 8004880: 3310         	adds	r3, #0x10
 8004882: 607b         	str	r3, [r7, #0x4]
 8004884: 687b         	ldr	r3, [r7, #0x4]
 8004886: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80048b0 <z_impl_log_panic+0x60>
 8004888: 4293         	cmp	r3, r2
 800488a: bf34         	ite	lo
 800488c: 2301         	movlo	r3, #0x1
 800488e: 2300         	movhs	r3, #0x0
 8004890: b2db         	uxtb	r3, r3
 8004892: 2b00         	cmp	r3, #0x0
 8004894: d1ea         	bne	0x800486c <z_impl_log_panic+0x1c> @ imm = #-0x2c
; out:
 8004896: bf00         	nop
; 	panic_mode = true;
 8004898: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80048a8 <z_impl_log_panic+0x58>
 800489a: 2201         	movs	r2, #0x1
 800489c: 701a         	strb	r2, [r3]
 800489e: e000         	b	0x80048a2 <z_impl_log_panic+0x52> @ imm = #0x0
; 		return;
 80048a0: bf00         	nop
; }
 80048a2: 3708         	adds	r7, #0x8
 80048a4: 46bd         	mov	sp, r7
 80048a6: bd80         	pop	{r7, pc}

080048a8 <$d>:
 80048a8: 04 33 00 20  	.word	0x20003304
 80048ac: e8 81 02 08  	.word	0x080281e8
 80048b0: f8 81 02 08  	.word	0x080281f8

080048b4 <msg_process>:
; {
 80048b4: b580         	push	{r7, lr}
 80048b6: b084         	sub	sp, #0x10
 80048b8: af00         	add	r7, sp, #0x0
 80048ba: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80048bc: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8004908 <msg_process+0x54>
 80048be: 60fb         	str	r3, [r7, #0xc]
 80048c0: e013         	b	0x80048ea <msg_process+0x36> @ imm = #0x26
; 		if (log_backend_is_active(backend) &&
 80048c2: 68f8         	ldr	r0, [r7, #0xc]
 80048c4: f016 fee7    	bl	0x801b696 <log_backend_is_active> @ imm = #0x16dce
 80048c8: 4603         	mov	r3, r0
 80048ca: 2b00         	cmp	r3, #0x0
 80048cc: d00a         	beq	0x80048e4 <msg_process+0x30> @ imm = #0x14
; 		    msg_filter_check(backend, msg)) {
 80048ce: 6879         	ldr	r1, [r7, #0x4]
 80048d0: 68f8         	ldr	r0, [r7, #0xc]
 80048d2: f016 ff4d    	bl	0x801b770 <msg_filter_check> @ imm = #0x16e9a
 80048d6: 4603         	mov	r3, r0
; 		if (log_backend_is_active(backend) &&
 80048d8: 2b00         	cmp	r3, #0x0
 80048da: d003         	beq	0x80048e4 <msg_process+0x30> @ imm = #0x6
; 			log_backend_msg_process(backend, msg);
 80048dc: 6879         	ldr	r1, [r7, #0x4]
 80048de: 68f8         	ldr	r0, [r7, #0xc]
 80048e0: f016 febd    	bl	0x801b65e <log_backend_msg_process> @ imm = #0x16d7a
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80048e4: 68fb         	ldr	r3, [r7, #0xc]
 80048e6: 3310         	adds	r3, #0x10
 80048e8: 60fb         	str	r3, [r7, #0xc]
 80048ea: 68fb         	ldr	r3, [r7, #0xc]
 80048ec: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800490c <msg_process+0x58>
 80048ee: 4293         	cmp	r3, r2
 80048f0: bf34         	ite	lo
 80048f2: 2301         	movlo	r3, #0x1
 80048f4: 2300         	movhs	r3, #0x0
 80048f6: b2db         	uxtb	r3, r3
 80048f8: 2b00         	cmp	r3, #0x0
 80048fa: d1e2         	bne	0x80048c2 <msg_process+0xe> @ imm = #-0x3c
; }
 80048fc: bf00         	nop
 80048fe: bf00         	nop
 8004900: 3710         	adds	r7, #0x10
 8004902: 46bd         	mov	sp, r7
 8004904: bd80         	pop	{r7, pc}
 8004906: bf00         	nop

08004908 <$d>:
 8004908: e8 81 02 08  	.word	0x080281e8
 800490c: f8 81 02 08  	.word	0x080281f8

08004910 <z_log_notify_backend_enabled>:
; {
 8004910: b480         	push	{r7}
 8004912: af00         	add	r7, sp, #0x0
; 	backend_attached = true;
 8004914: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8004924 <z_log_notify_backend_enabled+0x14>
 8004916: 2201         	movs	r2, #0x1
 8004918: 701a         	strb	r2, [r3]
; }
 800491a: bf00         	nop
 800491c: 46bd         	mov	sp, r7
 800491e: f85d 7b04    	ldr	r7, [sp], #4
 8004922: 4770         	bx	lr

08004924 <$d>:
 8004924: 05 33 00 20  	.word	0x20003305

08004928 <z_log_dropped>:
; {
 8004928: b580         	push	{r7, lr}
 800492a: b082         	sub	sp, #0x8
 800492c: af00         	add	r7, sp, #0x0
 800492e: 4603         	mov	r3, r0
 8004930: 71fb         	strb	r3, [r7, #0x7]
; 	atomic_inc(&dropped_cnt);
 8004932: 4806         	ldr	r0, [pc, #0x18]         @ 0x800494c <z_log_dropped+0x24>
 8004934: f016 fddf    	bl	0x801b4f6 <atomic_inc>  @ imm = #0x16bbe
; 	if (buffered) {
 8004938: 79fb         	ldrb	r3, [r7, #0x7]
 800493a: 2b00         	cmp	r3, #0x0
 800493c: d002         	beq	0x8004944 <z_log_dropped+0x1c> @ imm = #0x4
; 		atomic_dec(&buffered_cnt);
 800493e: 4804         	ldr	r0, [pc, #0x10]         @ 0x8004950 <z_log_dropped+0x28>
 8004940: f016 fde6    	bl	0x801b510 <atomic_dec>  @ imm = #0x16bcc
; }
 8004944: bf00         	nop
 8004946: 3708         	adds	r7, #0x8
 8004948: 46bd         	mov	sp, r7
 800494a: bd80         	pop	{r7, pc}

0800494c <$d>:
 800494c: cc 2c 00 20  	.word	0x20002ccc
 8004950: c8 2c 00 20  	.word	0x20002cc8

08004954 <z_log_msg_commit>:
; {
 8004954: b580         	push	{r7, lr}
 8004956: b082         	sub	sp, #0x8
 8004958: af00         	add	r7, sp, #0x0
 800495a: 6078         	str	r0, [r7, #0x4]
; 	msg->hdr.timestamp = timestamp_func();
 800495c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8004978 <z_log_msg_commit+0x24>
 800495e: 681b         	ldr	r3, [r3]
 8004960: 4798         	blx	r3
 8004962: 4602         	mov	r2, r0
 8004964: 687b         	ldr	r3, [r7, #0x4]
 8004966: 609a         	str	r2, [r3, #0x8]
; 	msg_commit(&log_buffer, msg);
 8004968: 6879         	ldr	r1, [r7, #0x4]
 800496a: 4804         	ldr	r0, [pc, #0x10]         @ 0x800497c <z_log_msg_commit+0x28>
 800496c: f016 ff15    	bl	0x801b79a <msg_commit>  @ imm = #0x16e2a
; }
 8004970: bf00         	nop
 8004972: 3708         	adds	r7, #0x8
 8004974: 46bd         	mov	sp, r7
 8004976: bd80         	pop	{r7, pc}

08004978 <$d>:
 8004978: dc 04 00 20  	.word	0x200004dc
 800497c: bc 0b 00 20  	.word	0x20000bbc

08004980 <log_const_source_id>:
; {
 8004980: b480         	push	{r7}
 8004982: b083         	sub	sp, #0xc
 8004984: af00         	add	r7, sp, #0x0
 8004986: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 8004988: 687b         	ldr	r3, [r7, #0x4]
 800498a: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800499c <log_const_source_id+0x1c>
 800498c: 1a9b         	subs	r3, r3, r2
 800498e: 08db         	lsrs	r3, r3, #0x3
; }
 8004990: 4618         	mov	r0, r3
 8004992: 370c         	adds	r7, #0xc
 8004994: 46bd         	mov	sp, r7
 8004996: f85d 7b04    	ldr	r7, [sp], #4
 800499a: 4770         	bx	lr

0800499c <$d>:
 800499c: 40 81 02 08  	.word	0x08028140

080049a0 <z_log_sources_count>:
; {
 80049a0: b580         	push	{r7, lr}
 80049a2: af00         	add	r7, sp, #0x0
; 	return log_const_source_id(TYPE_SECTION_END(log_const));
 80049a4: 4802         	ldr	r0, [pc, #0x8]          @ 0x80049b0 <z_log_sources_count+0x10>
 80049a6: f7ff ffeb    	bl	0x8004980 <log_const_source_id> @ imm = #-0x2a
 80049aa: 4603         	mov	r3, r0
; }
 80049ac: 4618         	mov	r0, r3
 80049ae: bd80         	pop	{r7, pc}

080049b0 <$d>:
 80049b0: e8 81 02 08  	.word	0x080281e8

080049b4 <log_backend_get>:
; {
 80049b4: b480         	push	{r7}
 80049b6: b085         	sub	sp, #0x14
 80049b8: af00         	add	r7, sp, #0x0
 80049ba: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 80049bc: 687b         	ldr	r3, [r7, #0x4]
 80049be: 011b         	lsls	r3, r3, #0x4
 80049c0: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80049d4 <log_backend_get+0x20>
 80049c2: 4413         	add	r3, r2
 80049c4: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 80049c6: 68fb         	ldr	r3, [r7, #0xc]
; }
 80049c8: 4618         	mov	r0, r3
 80049ca: 3714         	adds	r7, #0x14
 80049cc: 46bd         	mov	sp, r7
 80049ce: f85d 7b04    	ldr	r7, [sp], #4
 80049d2: 4770         	bx	lr

080049d4 <$d>:
 80049d4: e8 81 02 08  	.word	0x080281e8

080049d8 <get_link_domain>:
; {
 80049d8: b480         	push	{r7}
 80049da: b085         	sub	sp, #0x14
 80049dc: af00         	add	r7, sp, #0x0
 80049de: 4603         	mov	r3, r0
 80049e0: 6039         	str	r1, [r7]
 80049e2: 71fb         	strb	r3, [r7, #0x7]
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 80049e4: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8004a48 <get_link_domain+0x70>
 80049e6: 60fb         	str	r3, [r7, #0xc]
 80049e8: e01b         	b	0x8004a22 <get_link_domain+0x4a> @ imm = #0x36
; 		domain_max = link->ctrl_blk->domain_offset +
 80049ea: 68fb         	ldr	r3, [r7, #0xc]
 80049ec: 689b         	ldr	r3, [r3, #0x8]
 80049ee: 689b         	ldr	r3, [r3, #0x8]
 80049f0: b2da         	uxtb	r2, r3
; 				link->ctrl_blk->domain_cnt;
 80049f2: 68fb         	ldr	r3, [r7, #0xc]
 80049f4: 689b         	ldr	r3, [r3, #0x8]
 80049f6: 681b         	ldr	r3, [r3]
; 		domain_max = link->ctrl_blk->domain_offset +
 80049f8: b2db         	uxtb	r3, r3
 80049fa: 4413         	add	r3, r2
 80049fc: 72fb         	strb	r3, [r7, #0xb]
; 		if (domain_id < domain_max) {
 80049fe: 79fa         	ldrb	r2, [r7, #0x7]
 8004a00: 7afb         	ldrb	r3, [r7, #0xb]
 8004a02: 429a         	cmp	r2, r3
 8004a04: d20a         	bhs	0x8004a1c <get_link_domain+0x44> @ imm = #0x14
; 			*rel_domain_id = domain_id - link->ctrl_blk->domain_offset;
 8004a06: 68fb         	ldr	r3, [r7, #0xc]
 8004a08: 689b         	ldr	r3, [r3, #0x8]
 8004a0a: 689b         	ldr	r3, [r3, #0x8]
 8004a0c: b2db         	uxtb	r3, r3
 8004a0e: 79fa         	ldrb	r2, [r7, #0x7]
 8004a10: 1ad3         	subs	r3, r2, r3
 8004a12: b2da         	uxtb	r2, r3
 8004a14: 683b         	ldr	r3, [r7]
 8004a16: 701a         	strb	r2, [r3]
; 			return link;
 8004a18: 68fb         	ldr	r3, [r7, #0xc]
 8004a1a: e00f         	b	0x8004a3c <get_link_domain+0x64> @ imm = #0x1e
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 8004a1c: 68fb         	ldr	r3, [r7, #0xc]
 8004a1e: 3318         	adds	r3, #0x18
 8004a20: 60fb         	str	r3, [r7, #0xc]
 8004a22: 68fb         	ldr	r3, [r7, #0xc]
 8004a24: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8004a4c <get_link_domain+0x74>
 8004a26: 4293         	cmp	r3, r2
 8004a28: bf34         	ite	lo
 8004a2a: 2301         	movlo	r3, #0x1
 8004a2c: 2300         	movhs	r3, #0x0
 8004a2e: b2db         	uxtb	r3, r3
 8004a30: 2b00         	cmp	r3, #0x0
 8004a32: d1da         	bne	0x80049ea <get_link_domain+0x12> @ imm = #-0x4c
; 	*rel_domain_id = 0;
 8004a34: 683b         	ldr	r3, [r7]
 8004a36: 2200         	movs	r2, #0x0
 8004a38: 701a         	strb	r2, [r3]
; 	return NULL;
 8004a3a: 2300         	movs	r3, #0x0
; }
 8004a3c: 4618         	mov	r0, r3
 8004a3e: 3714         	adds	r7, #0x14
 8004a40: 46bd         	mov	sp, r7
 8004a42: f85d 7b04    	ldr	r7, [sp], #4
 8004a46: 4770         	bx	lr

08004a48 <$d>:
 8004a48: f8 81 02 08  	.word	0x080281f8
 8004a4c: f8 81 02 08  	.word	0x080281f8

08004a50 <link_source_name_get>:
; {
 8004a50: b580         	push	{r7, lr}
 8004a52: b08a         	sub	sp, #0x28
 8004a54: af02         	add	r7, sp, #0x8
 8004a56: 4603         	mov	r3, r0
 8004a58: 6039         	str	r1, [r7]
 8004a5a: 71fb         	strb	r3, [r7, #0x7]
; 	size_t cache_size = sname_cache.item_size;
 8004a5c: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8004ad0 <link_source_name_get+0x80>
 8004a5e: 69db         	ldr	r3, [r3, #0x1c]
 8004a60: 613b         	str	r3, [r7, #0x10]
; 	union log_source_ids id = {
 8004a62: 79fb         	ldrb	r3, [r7, #0x7]
 8004a64: 733b         	strb	r3, [r7, #0xc]
 8004a66: 683b         	ldr	r3, [r7]
 8004a68: b29b         	uxth	r3, r3
 8004a6a: 81fb         	strh	r3, [r7, #0xe]
; 	if (!log_cache_get(&sname_cache, id.raw, &cached)) {
 8004a6c: 68fb         	ldr	r3, [r7, #0xc]
 8004a6e: f107 0214    	add.w	r2, r7, #0x14
 8004a72: 4619         	mov	r1, r3
 8004a74: 4816         	ldr	r0, [pc, #0x58]         @ 0x8004ad0 <link_source_name_get+0x80>
 8004a76: f017 f87e    	bl	0x801bb76 <log_cache_get> @ imm = #0x170fc
 8004a7a: 4603         	mov	r3, r0
 8004a7c: f083 0301    	eor	r3, r3, #0x1
 8004a80: b2db         	uxtb	r3, r3
 8004a82: 2b00         	cmp	r3, #0x0
 8004a84: d01f         	beq	0x8004ac6 <link_source_name_get+0x76> @ imm = #0x3e
; 		const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 8004a86: f107 020b    	add.w	r2, r7, #0xb
 8004a8a: 79fb         	ldrb	r3, [r7, #0x7]
 8004a8c: 4611         	mov	r1, r2
 8004a8e: 4618         	mov	r0, r3
 8004a90: f7ff ffa2    	bl	0x80049d8 <get_link_domain> @ imm = #-0xbc
 8004a94: 61f8         	str	r0, [r7, #0x1c]
; 		err = log_link_get_source_name(link, rel_domain_id, source_id,
 8004a96: 7afb         	ldrb	r3, [r7, #0xb]
 8004a98: 4618         	mov	r0, r3
 8004a9a: 683b         	ldr	r3, [r7]
 8004a9c: b29a         	uxth	r2, r3
 8004a9e: 6979         	ldr	r1, [r7, #0x14]
 8004aa0: f107 0310    	add.w	r3, r7, #0x10
 8004aa4: 9300         	str	r3, [sp]
 8004aa6: 460b         	mov	r3, r1
 8004aa8: 4601         	mov	r1, r0
 8004aaa: 69f8         	ldr	r0, [r7, #0x1c]
 8004aac: f016 fed3    	bl	0x801b856 <log_link_get_source_name> @ imm = #0x16da6
 8004ab0: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 8004ab2: 69bb         	ldr	r3, [r7, #0x18]
 8004ab4: 2b00         	cmp	r3, #0x0
 8004ab6: da01         	bge	0x8004abc <link_source_name_get+0x6c> @ imm = #0x2
; 			return NULL;
 8004ab8: 2300         	movs	r3, #0x0
 8004aba: e005         	b	0x8004ac8 <link_source_name_get+0x78> @ imm = #0xa
; 		log_cache_put(&sname_cache, cached);
 8004abc: 697b         	ldr	r3, [r7, #0x14]
 8004abe: 4619         	mov	r1, r3
 8004ac0: 4803         	ldr	r0, [pc, #0xc]          @ 0x8004ad0 <link_source_name_get+0x80>
 8004ac2: f017 f8db    	bl	0x801bc7c <log_cache_put> @ imm = #0x171b6
; 	return (const char *)cached;
 8004ac6: 697b         	ldr	r3, [r7, #0x14]
; }
 8004ac8: 4618         	mov	r0, r3
 8004aca: 3720         	adds	r7, #0x20
 8004acc: 46bd         	mov	sp, r7
 8004ace: bd80         	pop	{r7, pc}

08004ad0 <$d>:
 8004ad0: d4 2c 00 20  	.word	0x20002cd4

08004ad4 <log_source_name_get>:
; {
 8004ad4: b580         	push	{r7, lr}
 8004ad6: b082         	sub	sp, #0x8
 8004ad8: af00         	add	r7, sp, #0x0
 8004ada: 6078         	str	r0, [r7, #0x4]
 8004adc: 6039         	str	r1, [r7]
; 	if (z_log_is_local_domain(domain_id)) {
 8004ade: 687b         	ldr	r3, [r7, #0x4]
 8004ae0: b2db         	uxtb	r3, r3
 8004ae2: 4618         	mov	r0, r3
 8004ae4: f016 fe77    	bl	0x801b7d6 <z_log_is_local_domain> @ imm = #0x16cee
 8004ae8: 4603         	mov	r3, r0
 8004aea: 2b00         	cmp	r3, #0x0
 8004aec: d00d         	beq	0x8004b0a <log_source_name_get+0x36> @ imm = #0x1a
; 		if (source_id < log_src_cnt_get(domain_id)) {
 8004aee: 6878         	ldr	r0, [r7, #0x4]
 8004af0: f016 fedf    	bl	0x801b8b2 <log_src_cnt_get> @ imm = #0x16dbe
 8004af4: 4602         	mov	r2, r0
 8004af6: 683b         	ldr	r3, [r7]
 8004af8: 4293         	cmp	r3, r2
 8004afa: d204         	bhs	0x8004b06 <log_source_name_get+0x32> @ imm = #0x8
; 			return TYPE_SECTION_START(log_const)[source_id].name;
 8004afc: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8004b20 <log_source_name_get+0x4c>
 8004afe: 683b         	ldr	r3, [r7]
 8004b00: f852 3033    	ldr.w	r3, [r2, r3, lsl #3]
 8004b04: e008         	b	0x8004b18 <log_source_name_get+0x44> @ imm = #0x10
; 			return NULL;
 8004b06: 2300         	movs	r3, #0x0
 8004b08: e006         	b	0x8004b18 <log_source_name_get+0x44> @ imm = #0xc
; 	return link_source_name_get(domain_id, source_id);
 8004b0a: 687b         	ldr	r3, [r7, #0x4]
 8004b0c: b2db         	uxtb	r3, r3
 8004b0e: 6839         	ldr	r1, [r7]
 8004b10: 4618         	mov	r0, r3
 8004b12: f7ff ff9d    	bl	0x8004a50 <link_source_name_get> @ imm = #-0xc6
 8004b16: 4603         	mov	r3, r0
; }
 8004b18: 4618         	mov	r0, r3
 8004b1a: 3708         	adds	r7, #0x8
 8004b1c: 46bd         	mov	sp, r7
 8004b1e: bd80         	pop	{r7, pc}

08004b20 <$d>:
 8004b20: 40 81 02 08  	.word	0x08028140

08004b24 <log_const_source_id>:
; {
 8004b24: b480         	push	{r7}
 8004b26: b083         	sub	sp, #0xc
 8004b28: af00         	add	r7, sp, #0x0
 8004b2a: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 8004b2c: 687b         	ldr	r3, [r7, #0x4]
 8004b2e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004b40 <log_const_source_id+0x1c>
 8004b30: 1a9b         	subs	r3, r3, r2
 8004b32: 08db         	lsrs	r3, r3, #0x3
; }
 8004b34: 4618         	mov	r0, r3
 8004b36: 370c         	adds	r7, #0xc
 8004b38: 46bd         	mov	sp, r7
 8004b3a: f85d 7b04    	ldr	r7, [sp], #4
 8004b3e: 4770         	bx	lr

08004b40 <$d>:
 8004b40: 40 81 02 08  	.word	0x08028140

08004b44 <z_log_msg_runtime_vcreate>:
; {
 8004b44: b580         	push	{r7, lr}
 8004b46: b090         	sub	sp, #0x40
 8004b48: af04         	add	r7, sp, #0x10
 8004b4a: 60b9         	str	r1, [r7, #0x8]
 8004b4c: 607b         	str	r3, [r7, #0x4]
 8004b4e: 4603         	mov	r3, r0
 8004b50: 73fb         	strb	r3, [r7, #0xf]
 8004b52: 4613         	mov	r3, r2
 8004b54: 73bb         	strb	r3, [r7, #0xe]
; 	if (fmt) {
 8004b56: 6c3b         	ldr	r3, [r7, #0x40]
 8004b58: 2b00         	cmp	r3, #0x0
 8004b5a: d00b         	beq	0x8004b74 <z_log_msg_runtime_vcreate+0x30> @ imm = #0x16
; 		va_copy(ap2, ap);
 8004b5c: 6c7b         	ldr	r3, [r7, #0x44]
 8004b5e: 613b         	str	r3, [r7, #0x10]
; 		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
 8004b60: 693b         	ldr	r3, [r7, #0x10]
 8004b62: 9300         	str	r3, [sp]
 8004b64: 6c3b         	ldr	r3, [r7, #0x40]
 8004b66: 6bfa         	ldr	r2, [r7, #0x3c]
 8004b68: 2110         	movs	r1, #0x10
 8004b6a: 2000         	movs	r0, #0x0
 8004b6c: f7fe ff8a    	bl	0x8003a84 <cbvprintf_package> @ imm = #-0x10ec
 8004b70: 62f8         	str	r0, [r7, #0x2c]
 8004b72: e001         	b	0x8004b78 <z_log_msg_runtime_vcreate+0x34> @ imm = #0x2
; 		plen = 0;
 8004b74: 2300         	movs	r3, #0x0
 8004b76: 62fb         	str	r3, [r7, #0x2c]
; 	if (plen > Z_LOG_MSG_MAX_PACKAGE) {
 8004b78: 6afb         	ldr	r3, [r7, #0x2c]
 8004b7a: f5b3 6f00    	cmp.w	r3, #0x800
 8004b7e: d31d         	blo	0x8004bbc <z_log_msg_runtime_vcreate+0x78> @ imm = #0x3a
; 		LOG_WRN("Message dropped because it exceeds size limitation (%u)",
 8004b80: 2303         	movs	r3, #0x3
 8004b82: 2b01         	cmp	r3, #0x1
 8004b84: d973         	bls	0x8004c6e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xe6
 8004b86: 2301         	movs	r3, #0x1
 8004b88: 77fb         	strb	r3, [r7, #0x1f]
 8004b8a: 7ffb         	ldrb	r3, [r7, #0x1f]
 8004b8c: f083 0301    	eor	r3, r3, #0x1
 8004b90: b2db         	uxtb	r3, r3
 8004b92: 2b00         	cmp	r3, #0x0
 8004b94: d16b         	bne	0x8004c6e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xd6
 8004b96: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8004c74 <z_log_msg_runtime_vcreate+0x130>
 8004b98: 6819         	ldr	r1, [r3]
 8004b9a: f240 73ff    	movw	r3, #0x7ff
 8004b9e: 9303         	str	r3, [sp, #0xc]
 8004ba0: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8004c78 <z_log_msg_runtime_vcreate+0x134>
 8004ba2: 9302         	str	r3, [sp, #0x8]
 8004ba4: 2300         	movs	r3, #0x0
 8004ba6: 9301         	str	r3, [sp, #0x4]
 8004ba8: 2300         	movs	r3, #0x0
 8004baa: 9300         	str	r3, [sp]
 8004bac: 2300         	movs	r3, #0x0
 8004bae: 2202         	movs	r2, #0x2
 8004bb0: 2000         	movs	r0, #0x0
 8004bb2: f017 f875    	bl	0x801bca0 <z_log_msg_runtime_create> @ imm = #0x170ea
 8004bb6: 2300         	movs	r3, #0x0
 8004bb8: 61bb         	str	r3, [r7, #0x18]
; 		return;
 8004bba: e058         	b	0x8004c6e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xb0
; 	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
 8004bbc: 6afa         	ldr	r2, [r7, #0x2c]
 8004bbe: 6bbb         	ldr	r3, [r7, #0x38]
 8004bc0: 4413         	add	r3, r2
 8004bc2: 3317         	adds	r3, #0x17
 8004bc4: f023 0307    	bic	r3, r3, #0x7
 8004bc8: 3303         	adds	r3, #0x3
 8004bca: 089b         	lsrs	r3, r3, #0x2
 8004bcc: 62bb         	str	r3, [r7, #0x28]
; 	struct log_msg_desc desc =
 8004bce: 7d3b         	ldrb	r3, [r7, #0x14]
 8004bd0: f36f 0300    	bfc	r3, #0, #1
 8004bd4: 753b         	strb	r3, [r7, #0x14]
 8004bd6: 7d3b         	ldrb	r3, [r7, #0x14]
 8004bd8: f36f 0341    	bfc	r3, #1, #1
 8004bdc: 753b         	strb	r3, [r7, #0x14]
 8004bde: 7d3b         	ldrb	r3, [r7, #0x14]
 8004be0: f36f 0382    	bfc	r3, #2, #1
 8004be4: 753b         	strb	r3, [r7, #0x14]
 8004be6: 7bfb         	ldrb	r3, [r7, #0xf]
 8004be8: f003 0307    	and	r3, r3, #0x7
 8004bec: b2da         	uxtb	r2, r3
 8004bee: 7d3b         	ldrb	r3, [r7, #0x14]
 8004bf0: f362 03c5    	bfi	r3, r2, #3, #3
 8004bf4: 753b         	strb	r3, [r7, #0x14]
 8004bf6: 7bbb         	ldrb	r3, [r7, #0xe]
 8004bf8: f003 0307    	and	r3, r3, #0x7
 8004bfc: b2da         	uxtb	r2, r3
 8004bfe: 8abb         	ldrh	r3, [r7, #0x14]
 8004c00: f362 1388    	bfi	r3, r2, #6, #3
 8004c04: 82bb         	strh	r3, [r7, #0x14]
 8004c06: 6afb         	ldr	r3, [r7, #0x2c]
 8004c08: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8004c0c: b29a         	uxth	r2, r3
 8004c0e: 697b         	ldr	r3, [r7, #0x14]
 8004c10: f362 2353    	bfi	r3, r2, #9, #11
 8004c14: 617b         	str	r3, [r7, #0x14]
 8004c16: 6bbb         	ldr	r3, [r7, #0x38]
 8004c18: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8004c1c: b29a         	uxth	r2, r3
 8004c1e: 8afb         	ldrh	r3, [r7, #0x16]
 8004c20: f362 130f    	bfi	r3, r2, #4, #12
 8004c24: 82fb         	strh	r3, [r7, #0x16]
; 		msg = alloca(msg_wlen * sizeof(int));
 8004c26: 6abb         	ldr	r3, [r7, #0x28]
 8004c28: 009b         	lsls	r3, r3, #0x2
 8004c2a: 3307         	adds	r3, #0x7
 8004c2c: 08db         	lsrs	r3, r3, #0x3
 8004c2e: 00db         	lsls	r3, r3, #0x3
 8004c30: ebad 0d03    	sub.w	sp, sp, r3
 8004c34: ab04         	add	r3, sp, #0x10
 8004c36: 3307         	adds	r3, #0x7
 8004c38: 08db         	lsrs	r3, r3, #0x3
 8004c3a: 00db         	lsls	r3, r3, #0x3
 8004c3c: 627b         	str	r3, [r7, #0x24]
; 		pkg = msg->data;
 8004c3e: 6a7b         	ldr	r3, [r7, #0x24]
 8004c40: 3310         	adds	r3, #0x10
 8004c42: 623b         	str	r3, [r7, #0x20]
; 	if (pkg && fmt) {
 8004c44: 6a3b         	ldr	r3, [r7, #0x20]
 8004c46: 2b00         	cmp	r3, #0x0
 8004c48: d00b         	beq	0x8004c62 <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x16
 8004c4a: 6c3b         	ldr	r3, [r7, #0x40]
 8004c4c: 2b00         	cmp	r3, #0x0
 8004c4e: d008         	beq	0x8004c62 <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x10
; 		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
 8004c50: 6af9         	ldr	r1, [r7, #0x2c]
 8004c52: 6c7b         	ldr	r3, [r7, #0x44]
 8004c54: 9300         	str	r3, [sp]
 8004c56: 6c3b         	ldr	r3, [r7, #0x40]
 8004c58: 6bfa         	ldr	r2, [r7, #0x3c]
 8004c5a: 6a38         	ldr	r0, [r7, #0x20]
 8004c5c: f7fe ff12    	bl	0x8003a84 <cbvprintf_package> @ imm = #-0x11dc
 8004c60: 62f8         	str	r0, [r7, #0x2c]
; 		z_log_msg_finalize(msg, source, desc, data);
 8004c62: 687b         	ldr	r3, [r7, #0x4]
 8004c64: 697a         	ldr	r2, [r7, #0x14]
 8004c66: 68b9         	ldr	r1, [r7, #0x8]
 8004c68: 6a78         	ldr	r0, [r7, #0x24]
 8004c6a: f017 f86a    	bl	0x801bd42 <z_log_msg_finalize> @ imm = #0x170d4
; }
 8004c6e: 3730         	adds	r7, #0x30
 8004c70: 46bd         	mov	sp, r7
 8004c72: bd80         	pop	{r7, pc}

08004c74 <$d>:
 8004c74: e0 04 00 20  	.word	0x200004e0
 8004c78: 98 84 02 08  	.word	0x08028498

08004c7c <cbpprintf>:
; {
 8004c7c: b580         	push	{r7, lr}
 8004c7e: b084         	sub	sp, #0x10
 8004c80: af00         	add	r7, sp, #0x0
 8004c82: 60f8         	str	r0, [r7, #0xc]
 8004c84: 60b9         	str	r1, [r7, #0x8]
 8004c86: 607a         	str	r2, [r7, #0x4]
; 	return cbpprintf_external(out, cbvprintf, ctx, packaged);
 8004c88: 687b         	ldr	r3, [r7, #0x4]
 8004c8a: 68ba         	ldr	r2, [r7, #0x8]
 8004c8c: 4904         	ldr	r1, [pc, #0x10]         @ 0x8004ca0 <cbpprintf+0x24>
 8004c8e: 68f8         	ldr	r0, [r7, #0xc]
 8004c90: f016 fb0e    	bl	0x801b2b0 <cbpprintf_external> @ imm = #0x1661c
 8004c94: 4603         	mov	r3, r0
; }
 8004c96: 4618         	mov	r0, r3
 8004c98: 3710         	adds	r7, #0x10
 8004c9a: 46bd         	mov	sp, r7
 8004c9c: bd80         	pop	{r7, pc}
 8004c9e: bf00         	nop

08004ca0 <$d>:
 8004ca0: 79 68 00 08  	.word	0x08006879

08004ca4 <__ctype_lookup>:
; static __inline char __ctype_lookup(int c) { return (__CTYPE_PTR + 1)[c]; }
 8004ca4: b480         	push	{r7}
 8004ca6: b083         	sub	sp, #0xc
 8004ca8: af00         	add	r7, sp, #0x0
 8004caa: 6078         	str	r0, [r7, #0x4]
 8004cac: 687b         	ldr	r3, [r7, #0x4]
 8004cae: 3301         	adds	r3, #0x1
 8004cb0: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8004cc4 <__ctype_lookup+0x20>
 8004cb2: 4413         	add	r3, r2
 8004cb4: 781b         	ldrb	r3, [r3]
 8004cb6: 4618         	mov	r0, r3
 8004cb8: 370c         	adds	r7, #0xc
 8004cba: 46bd         	mov	sp, r7
 8004cbc: f85d 7b04    	ldr	r7, [sp], #4
 8004cc0: 4770         	bx	lr
 8004cc2: bf00         	nop

08004cc4 <$d>:
 8004cc4: 4c c1 02 08  	.word	0x0802c14c

08004cc8 <print_formatted>:
; {
 8004cc8: b40e         	push	{r1, r2, r3}
 8004cca: b580         	push	{r7, lr}
 8004ccc: b085         	sub	sp, #0x14
 8004cce: af00         	add	r7, sp, #0x0
 8004cd0: 6078         	str	r0, [r7, #0x4]
; 	int length = 0;
 8004cd2: 2300         	movs	r3, #0x0
 8004cd4: 60fb         	str	r3, [r7, #0xc]
; 	va_start(args, fmt);
 8004cd6: f107 0320    	add.w	r3, r7, #0x20
 8004cda: 60bb         	str	r3, [r7, #0x8]
; 	length = cbvprintf(out_func, (void *)output, fmt, args);
 8004cdc: 68bb         	ldr	r3, [r7, #0x8]
 8004cde: 69fa         	ldr	r2, [r7, #0x1c]
 8004ce0: 6879         	ldr	r1, [r7, #0x4]
 8004ce2: 4806         	ldr	r0, [pc, #0x18]         @ 0x8004cfc <print_formatted+0x34>
 8004ce4: f001 fdc8    	bl	0x8006878 <cbvprintf>   @ imm = #0x1b90
 8004ce8: 60f8         	str	r0, [r7, #0xc]
; 	return length;
 8004cea: 68fb         	ldr	r3, [r7, #0xc]
; }
 8004cec: 4618         	mov	r0, r3
 8004cee: 3714         	adds	r7, #0x14
 8004cf0: 46bd         	mov	sp, r7
 8004cf2: e8bd 4080    	pop.w	{r7, lr}
 8004cf6: b003         	add	sp, #0xc
 8004cf8: 4770         	bx	lr
 8004cfa: bf00         	nop

08004cfc <$d>:
 8004cfc: 2b bf 01 08  	.word	0x0801bf2b

08004d00 <timestamp_print>:
; {
 8004d00: b580         	push	{r7, lr}
 8004d02: b09a         	sub	sp, #0x68
 8004d04: af04         	add	r7, sp, #0x10
 8004d06: 60f8         	str	r0, [r7, #0xc]
 8004d08: 60b9         	str	r1, [r7, #0x8]
 8004d0a: 607a         	str	r2, [r7, #0x4]
; 		IS_ENABLED(CONFIG_LOG_OUTPUT_FORMAT_LINUX_TIMESTAMP) |
 8004d0c: 68bb         	ldr	r3, [r7, #0x8]
 8004d0e: f003 0344    	and	r3, r3, #0x44
; 	bool format =
 8004d12: 2b00         	cmp	r3, #0x0
 8004d14: bf14         	ite	ne
 8004d16: 2301         	movne	r3, #0x1
 8004d18: 2300         	moveq	r3, #0x0
 8004d1a: f887 3037    	strb.w	r3, [r7, #0x37]
; 	if (!format) {
 8004d1e: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8004d22: f083 0301    	eor	r3, r3, #0x1
 8004d26: b2db         	uxtb	r3, r3
 8004d28: 2b00         	cmp	r3, #0x0
 8004d2a: d006         	beq	0x8004d3a <timestamp_print+0x3a> @ imm = #0xc
; 		length = print_formatted(output, "[%08lu] ", timestamp);
 8004d2c: 687a         	ldr	r2, [r7, #0x4]
 8004d2e: 4938         	ldr	r1, [pc, #0xe0]         @ 0x8004e10 <timestamp_print+0x110>
 8004d30: 68f8         	ldr	r0, [r7, #0xc]
 8004d32: f7ff ffc9    	bl	0x8004cc8 <print_formatted> @ imm = #-0x6e
 8004d36: 63b8         	str	r0, [r7, #0x38]
 8004d38: e065         	b	0x8004e06 <timestamp_print+0x106> @ imm = #0xca
; 	} else if (freq != 0U) {
 8004d3a: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8004e14 <timestamp_print+0x114>
 8004d3c: 681b         	ldr	r3, [r3]
 8004d3e: 2b00         	cmp	r3, #0x0
 8004d40: d05f         	beq	0x8004e02 <timestamp_print+0x102> @ imm = #0xbe
; 		timestamp /= timestamp_div;
 8004d42: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8004e18 <timestamp_print+0x118>
 8004d44: 681b         	ldr	r3, [r3]
 8004d46: 687a         	ldr	r2, [r7, #0x4]
 8004d48: fbb2 f3f3    	udiv	r3, r2, r3
 8004d4c: 607b         	str	r3, [r7, #0x4]
; 		total_seconds = timestamp / freq;
 8004d4e: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8004e14 <timestamp_print+0x114>
 8004d50: 681b         	ldr	r3, [r3]
 8004d52: 687a         	ldr	r2, [r7, #0x4]
 8004d54: fbb2 f3f3    	udiv	r3, r2, r3
 8004d58: 63fb         	str	r3, [r7, #0x3c]
; 		seconds = total_seconds;
 8004d5a: 6bfb         	ldr	r3, [r7, #0x3c]
 8004d5c: 653b         	str	r3, [r7, #0x50]
; 		hours = seconds / 3600U;
 8004d5e: 6d3b         	ldr	r3, [r7, #0x50]
 8004d60: 4a2e         	ldr	r2, [pc, #0xb8]         @ 0x8004e1c <timestamp_print+0x11c>
 8004d62: fba2 2303    	umull	r2, r3, r2, r3
 8004d66: 0adb         	lsrs	r3, r3, #0xb
 8004d68: 643b         	str	r3, [r7, #0x40]
; 		seconds -= hours * 3600U;
 8004d6a: 6c3b         	ldr	r3, [r7, #0x40]
 8004d6c: f44f 6261    	mov.w	r2, #0xe10
 8004d70: fb02 f303    	mul	r3, r2, r3
 8004d74: 6d3a         	ldr	r2, [r7, #0x50]
 8004d76: 1ad3         	subs	r3, r2, r3
 8004d78: 653b         	str	r3, [r7, #0x50]
; 		mins = seconds / 60U;
 8004d7a: 6d3b         	ldr	r3, [r7, #0x50]
 8004d7c: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8004e20 <timestamp_print+0x120>
 8004d7e: fba2 2303    	umull	r2, r3, r2, r3
 8004d82: 095b         	lsrs	r3, r3, #0x5
 8004d84: 657b         	str	r3, [r7, #0x54]
; 		seconds -= mins * 60U;
 8004d86: 6d7a         	ldr	r2, [r7, #0x54]
 8004d88: 4613         	mov	r3, r2
 8004d8a: 011b         	lsls	r3, r3, #0x4
 8004d8c: 1a9b         	subs	r3, r3, r2
 8004d8e: 009b         	lsls	r3, r3, #0x2
 8004d90: 461a         	mov	r2, r3
 8004d92: 6d3b         	ldr	r3, [r7, #0x50]
 8004d94: 1a9b         	subs	r3, r3, r2
 8004d96: 653b         	str	r3, [r7, #0x50]
; 		remainder = timestamp % freq;
 8004d98: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8004e14 <timestamp_print+0x114>
 8004d9a: 681a         	ldr	r2, [r3]
 8004d9c: 687b         	ldr	r3, [r7, #0x4]
 8004d9e: fbb3 f1f2    	udiv	r1, r3, r2
 8004da2: fb01 f202    	mul	r2, r1, r2
 8004da6: 1a9b         	subs	r3, r3, r2
 8004da8: 64fb         	str	r3, [r7, #0x4c]
; 		ms = (remainder * 1000U) / freq;
 8004daa: 6cfb         	ldr	r3, [r7, #0x4c]
 8004dac: f44f 727a    	mov.w	r2, #0x3e8
 8004db0: fb03 f202    	mul	r2, r3, r2
 8004db4: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8004e14 <timestamp_print+0x114>
 8004db6: 681b         	ldr	r3, [r3]
 8004db8: fbb2 f3f3    	udiv	r3, r2, r3
 8004dbc: 64bb         	str	r3, [r7, #0x48]
; 		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 8004dbe: 6cfb         	ldr	r3, [r7, #0x4c]
 8004dc0: f44f 727a    	mov.w	r2, #0x3e8
 8004dc4: fb03 f202    	mul	r2, r3, r2
 8004dc8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8004e14 <timestamp_print+0x114>
 8004dca: 681b         	ldr	r3, [r3]
 8004dcc: 6cb9         	ldr	r1, [r7, #0x48]
 8004dce: fb01 f303    	mul	r3, r1, r3
 8004dd2: 1ad3         	subs	r3, r2, r3
 8004dd4: f44f 727a    	mov.w	r2, #0x3e8
 8004dd8: fb03 f202    	mul	r2, r3, r2
 8004ddc: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8004e14 <timestamp_print+0x114>
 8004dde: 681b         	ldr	r3, [r3]
 8004de0: fbb2 f3f3    	udiv	r3, r2, r3
 8004de4: 647b         	str	r3, [r7, #0x44]
; 				length = print_formatted(output,
 8004de6: 6c7b         	ldr	r3, [r7, #0x44]
 8004de8: 9302         	str	r3, [sp, #0x8]
 8004dea: 6cbb         	ldr	r3, [r7, #0x48]
 8004dec: 9301         	str	r3, [sp, #0x4]
 8004dee: 6d3b         	ldr	r3, [r7, #0x50]
 8004df0: 9300         	str	r3, [sp]
 8004df2: 6d7b         	ldr	r3, [r7, #0x54]
 8004df4: 6c3a         	ldr	r2, [r7, #0x40]
 8004df6: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8004e24 <timestamp_print+0x124>
 8004df8: 68f8         	ldr	r0, [r7, #0xc]
 8004dfa: f7ff ff65    	bl	0x8004cc8 <print_formatted> @ imm = #-0x136
 8004dfe: 63b8         	str	r0, [r7, #0x38]
 8004e00: e001         	b	0x8004e06 <timestamp_print+0x106> @ imm = #0x2
; 		length = 0;
 8004e02: 2300         	movs	r3, #0x0
 8004e04: 63bb         	str	r3, [r7, #0x38]
; 	return length;
 8004e06: 6bbb         	ldr	r3, [r7, #0x38]
; }
 8004e08: 4618         	mov	r0, r3
 8004e0a: 3758         	adds	r7, #0x58
 8004e0c: 46bd         	mov	sp, r7
 8004e0e: bd80         	pop	{r7, pc}

08004e10 <$d>:
 8004e10: f0 84 02 08  	.word	0x080284f0
 8004e14: f4 2c 00 20  	.word	0x20002cf4
 8004e18: f8 2c 00 20  	.word	0x20002cf8
 8004e1c: c5 b3 a2 91  	.word	0x91a2b3c5
 8004e20: 89 88 88 88  	.word	0x88888889
 8004e24: fc 84 02 08  	.word	0x080284fc

08004e28 <color_print>:
; {
 8004e28: b580         	push	{r7, lr}
 8004e2a: b086         	sub	sp, #0x18
 8004e2c: af00         	add	r7, sp, #0x0
 8004e2e: 60f8         	str	r0, [r7, #0xc]
 8004e30: 607b         	str	r3, [r7, #0x4]
 8004e32: 460b         	mov	r3, r1
 8004e34: 72fb         	strb	r3, [r7, #0xb]
 8004e36: 4613         	mov	r3, r2
 8004e38: 72bb         	strb	r3, [r7, #0xa]
; 	if (color) {
 8004e3a: 7afb         	ldrb	r3, [r7, #0xb]
 8004e3c: 2b00         	cmp	r3, #0x0
 8004e3e: d014         	beq	0x8004e6a <color_print+0x42> @ imm = #0x28
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8004e40: 7abb         	ldrb	r3, [r7, #0xa]
 8004e42: 2b00         	cmp	r3, #0x0
 8004e44: d00a         	beq	0x8004e5c <color_print+0x34> @ imm = #0x14
; 		const char *log_color = start && (colors[level] != NULL) ?
 8004e46: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8004e74 <color_print+0x4c>
 8004e48: 687b         	ldr	r3, [r7, #0x4]
 8004e4a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8004e4e: 2b00         	cmp	r3, #0x0
 8004e50: d004         	beq	0x8004e5c <color_print+0x34> @ imm = #0x8
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8004e52: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8004e74 <color_print+0x4c>
 8004e54: 687b         	ldr	r3, [r7, #0x4]
 8004e56: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8004e5a: e000         	b	0x8004e5e <color_print+0x36> @ imm = #0x0
 8004e5c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8004e78 <color_print+0x50>
; 		const char *log_color = start && (colors[level] != NULL) ?
 8004e5e: 617b         	str	r3, [r7, #0x14]
; 		print_formatted(output, "%s", log_color);
 8004e60: 697a         	ldr	r2, [r7, #0x14]
 8004e62: 4906         	ldr	r1, [pc, #0x18]         @ 0x8004e7c <color_print+0x54>
 8004e64: 68f8         	ldr	r0, [r7, #0xc]
 8004e66: f7ff ff2f    	bl	0x8004cc8 <print_formatted> @ imm = #-0x1a2
; }
 8004e6a: bf00         	nop
 8004e6c: 3718         	adds	r7, #0x18
 8004e6e: 46bd         	mov	sp, r7
 8004e70: bd80         	pop	{r7, pc}
 8004e72: bf00         	nop

08004e74 <$d>:
 8004e74: a0 a7 02 08  	.word	0x0802a7a0
 8004e78: 18 85 02 08  	.word	0x08028518
 8004e7c: 20 85 02 08  	.word	0x08028520

08004e80 <ids_print>:
; {
 8004e80: b580         	push	{r7, lr}
 8004e82: b084         	sub	sp, #0x10
 8004e84: af00         	add	r7, sp, #0x0
 8004e86: 6078         	str	r0, [r7, #0x4]
 8004e88: 4608         	mov	r0, r1
 8004e8a: 4611         	mov	r1, r2
 8004e8c: 461a         	mov	r2, r3
 8004e8e: 4603         	mov	r3, r0
 8004e90: 70fb         	strb	r3, [r7, #0x3]
 8004e92: 460b         	mov	r3, r1
 8004e94: 70bb         	strb	r3, [r7, #0x2]
 8004e96: 4613         	mov	r3, r2
 8004e98: 707b         	strb	r3, [r7, #0x1]
; 	int total = 0;
 8004e9a: 2300         	movs	r3, #0x0
 8004e9c: 60fb         	str	r3, [r7, #0xc]
; 	if (level_on) {
 8004e9e: 78fb         	ldrb	r3, [r7, #0x3]
 8004ea0: 2b00         	cmp	r3, #0x0
 8004ea2: d00c         	beq	0x8004ebe <ids_print+0x3e> @ imm = #0x18
; 		total += print_formatted(output, "<%s> ", severity[level]);
 8004ea4: 4a19         	ldr	r2, [pc, #0x64]         @ 0x8004f0c <ids_print+0x8c>
 8004ea6: 6a7b         	ldr	r3, [r7, #0x24]
 8004ea8: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8004eac: 461a         	mov	r2, r3
 8004eae: 4918         	ldr	r1, [pc, #0x60]         @ 0x8004f10 <ids_print+0x90>
 8004eb0: 6878         	ldr	r0, [r7, #0x4]
 8004eb2: f7ff ff09    	bl	0x8004cc8 <print_formatted> @ imm = #-0x1ee
 8004eb6: 4602         	mov	r2, r0
 8004eb8: 68fb         	ldr	r3, [r7, #0xc]
 8004eba: 4413         	add	r3, r2
 8004ebc: 60fb         	str	r3, [r7, #0xc]
; 	if (domain) {
 8004ebe: 69bb         	ldr	r3, [r7, #0x18]
 8004ec0: 2b00         	cmp	r3, #0x0
 8004ec2: d008         	beq	0x8004ed6 <ids_print+0x56> @ imm = #0x10
; 		total += print_formatted(output, "%s/", domain);
 8004ec4: 69ba         	ldr	r2, [r7, #0x18]
 8004ec6: 4913         	ldr	r1, [pc, #0x4c]         @ 0x8004f14 <ids_print+0x94>
 8004ec8: 6878         	ldr	r0, [r7, #0x4]
 8004eca: f7ff fefd    	bl	0x8004cc8 <print_formatted> @ imm = #-0x206
 8004ece: 4602         	mov	r2, r0
 8004ed0: 68fb         	ldr	r3, [r7, #0xc]
 8004ed2: 4413         	add	r3, r2
 8004ed4: 60fb         	str	r3, [r7, #0xc]
; 	if (source) {
 8004ed6: 69fb         	ldr	r3, [r7, #0x1c]
 8004ed8: 2b00         	cmp	r3, #0x0
 8004eda: d011         	beq	0x8004f00 <ids_print+0x80> @ imm = #0x22
; 		total += print_formatted(output,
 8004edc: 78bb         	ldrb	r3, [r7, #0x2]
 8004ede: 2b00         	cmp	r3, #0x0
 8004ee0: d004         	beq	0x8004eec <ids_print+0x6c> @ imm = #0x8
; 				(func_on &&
 8004ee2: 6a7b         	ldr	r3, [r7, #0x24]
 8004ee4: 2b04         	cmp	r3, #0x4
 8004ee6: d101         	bne	0x8004eec <ids_print+0x6c> @ imm = #0x2
; 		total += print_formatted(output,
 8004ee8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8004f18 <ids_print+0x98>
 8004eea: e000         	b	0x8004eee <ids_print+0x6e> @ imm = #0x0
 8004eec: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8004f1c <ids_print+0x9c>
 8004eee: 69fa         	ldr	r2, [r7, #0x1c]
 8004ef0: 4619         	mov	r1, r3
 8004ef2: 6878         	ldr	r0, [r7, #0x4]
 8004ef4: f7ff fee8    	bl	0x8004cc8 <print_formatted> @ imm = #-0x230
 8004ef8: 4602         	mov	r2, r0
 8004efa: 68fb         	ldr	r3, [r7, #0xc]
 8004efc: 4413         	add	r3, r2
 8004efe: 60fb         	str	r3, [r7, #0xc]
; 	return total;
 8004f00: 68fb         	ldr	r3, [r7, #0xc]
; }
 8004f02: 4618         	mov	r0, r3
 8004f04: 3710         	adds	r7, #0x10
 8004f06: 46bd         	mov	sp, r7
 8004f08: bd80         	pop	{r7, pc}
 8004f0a: bf00         	nop

08004f0c <$d>:
 8004f0c: 8c a7 02 08  	.word	0x0802a78c
 8004f10: 24 85 02 08  	.word	0x08028524
 8004f14: 2c 85 02 08  	.word	0x0802852c
 8004f18: 30 85 02 08  	.word	0x08028530
 8004f1c: 34 85 02 08  	.word	0x08028534

08004f20 <newline_print>:
; {
 8004f20: b580         	push	{r7, lr}
 8004f22: b082         	sub	sp, #0x8
 8004f24: af00         	add	r7, sp, #0x0
 8004f26: 6078         	str	r0, [r7, #0x4]
 8004f28: 6039         	str	r1, [r7]
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 8004f2a: 683b         	ldr	r3, [r7]
 8004f2c: f003 0310    	and	r3, r3, #0x10
 8004f30: 2b00         	cmp	r3, #0x0
 8004f32: d10e         	bne	0x8004f52 <newline_print+0x32> @ imm = #0x1c
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 8004f34: 683b         	ldr	r3, [r7]
 8004f36: f003 0320    	and	r3, r3, #0x20
 8004f3a: 2b00         	cmp	r3, #0x0
 8004f3c: d004         	beq	0x8004f48 <newline_print+0x28> @ imm = #0x8
; 		print_formatted(ctx, "\n");
 8004f3e: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8004f5c <newline_print+0x3c>
 8004f40: 6878         	ldr	r0, [r7, #0x4]
 8004f42: f7ff fec1    	bl	0x8004cc8 <print_formatted> @ imm = #-0x27e
 8004f46: e005         	b	0x8004f54 <newline_print+0x34> @ imm = #0xa
; 		print_formatted(ctx, "\r\n");
 8004f48: 4905         	ldr	r1, [pc, #0x14]         @ 0x8004f60 <newline_print+0x40>
 8004f4a: 6878         	ldr	r0, [r7, #0x4]
 8004f4c: f7ff febc    	bl	0x8004cc8 <print_formatted> @ imm = #-0x288
 8004f50: e000         	b	0x8004f54 <newline_print+0x34> @ imm = #0x0
; 		return;
 8004f52: bf00         	nop
; }
 8004f54: 3708         	adds	r7, #0x8
 8004f56: 46bd         	mov	sp, r7
 8004f58: bd80         	pop	{r7, pc}
 8004f5a: bf00         	nop

08004f5c <$d>:
 8004f5c: 3c 85 02 08  	.word	0x0802853c
 8004f60: 40 85 02 08  	.word	0x08028540

08004f64 <hexdump_line_print>:
; {
 8004f64: b580         	push	{r7, lr}
 8004f66: b088         	sub	sp, #0x20
 8004f68: af00         	add	r7, sp, #0x0
 8004f6a: 60f8         	str	r0, [r7, #0xc]
 8004f6c: 60b9         	str	r1, [r7, #0x8]
 8004f6e: 607a         	str	r2, [r7, #0x4]
 8004f70: 603b         	str	r3, [r7]
; 	newline_print(output, flags);
 8004f72: 6ab9         	ldr	r1, [r7, #0x28]
 8004f74: 68f8         	ldr	r0, [r7, #0xc]
 8004f76: f7ff ffd3    	bl	0x8004f20 <newline_print> @ imm = #-0x5a
; 	for (int i = 0; i < prefix_offset; i++) {
 8004f7a: 2300         	movs	r3, #0x0
 8004f7c: 61fb         	str	r3, [r7, #0x1c]
 8004f7e: e006         	b	0x8004f8e <hexdump_line_print+0x2a> @ imm = #0xc
; 		print_formatted(output, " ");
 8004f80: 4937         	ldr	r1, [pc, #0xdc]         @ 0x8005060 <hexdump_line_print+0xfc>
 8004f82: 68f8         	ldr	r0, [r7, #0xc]
 8004f84: f7ff fea0    	bl	0x8004cc8 <print_formatted> @ imm = #-0x2c0
; 	for (int i = 0; i < prefix_offset; i++) {
 8004f88: 69fb         	ldr	r3, [r7, #0x1c]
 8004f8a: 3301         	adds	r3, #0x1
 8004f8c: 61fb         	str	r3, [r7, #0x1c]
 8004f8e: 69fa         	ldr	r2, [r7, #0x1c]
 8004f90: 683b         	ldr	r3, [r7]
 8004f92: 429a         	cmp	r2, r3
 8004f94: dbf4         	blt	0x8004f80 <hexdump_line_print+0x1c> @ imm = #-0x18
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8004f96: 2300         	movs	r3, #0x0
 8004f98: 61bb         	str	r3, [r7, #0x18]
 8004f9a: e020         	b	0x8004fde <hexdump_line_print+0x7a> @ imm = #0x40
; 		if (i > 0 && !(i % 8)) {
 8004f9c: 69bb         	ldr	r3, [r7, #0x18]
 8004f9e: 2b00         	cmp	r3, #0x0
 8004fa0: dd08         	ble	0x8004fb4 <hexdump_line_print+0x50> @ imm = #0x10
 8004fa2: 69bb         	ldr	r3, [r7, #0x18]
 8004fa4: f003 0307    	and	r3, r3, #0x7
 8004fa8: 2b00         	cmp	r3, #0x0
 8004faa: d103         	bne	0x8004fb4 <hexdump_line_print+0x50> @ imm = #0x6
; 			print_formatted(output, " ");
 8004fac: 492c         	ldr	r1, [pc, #0xb0]         @ 0x8005060 <hexdump_line_print+0xfc>
 8004fae: 68f8         	ldr	r0, [r7, #0xc]
 8004fb0: f7ff fe8a    	bl	0x8004cc8 <print_formatted> @ imm = #-0x2ec
; 		if (i < length) {
 8004fb4: 69bb         	ldr	r3, [r7, #0x18]
 8004fb6: 687a         	ldr	r2, [r7, #0x4]
 8004fb8: 429a         	cmp	r2, r3
 8004fba: d909         	bls	0x8004fd0 <hexdump_line_print+0x6c> @ imm = #0x12
; 			print_formatted(output, "%02x ", data[i]);
 8004fbc: 69bb         	ldr	r3, [r7, #0x18]
 8004fbe: 68ba         	ldr	r2, [r7, #0x8]
 8004fc0: 4413         	add	r3, r2
 8004fc2: 781b         	ldrb	r3, [r3]
 8004fc4: 461a         	mov	r2, r3
 8004fc6: 4927         	ldr	r1, [pc, #0x9c]         @ 0x8005064 <hexdump_line_print+0x100>
 8004fc8: 68f8         	ldr	r0, [r7, #0xc]
 8004fca: f7ff fe7d    	bl	0x8004cc8 <print_formatted> @ imm = #-0x306
 8004fce: e003         	b	0x8004fd8 <hexdump_line_print+0x74> @ imm = #0x6
; 			print_formatted(output, "   ");
 8004fd0: 4925         	ldr	r1, [pc, #0x94]         @ 0x8005068 <hexdump_line_print+0x104>
 8004fd2: 68f8         	ldr	r0, [r7, #0xc]
 8004fd4: f7ff fe78    	bl	0x8004cc8 <print_formatted> @ imm = #-0x310
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8004fd8: 69bb         	ldr	r3, [r7, #0x18]
 8004fda: 3301         	adds	r3, #0x1
 8004fdc: 61bb         	str	r3, [r7, #0x18]
 8004fde: 69bb         	ldr	r3, [r7, #0x18]
 8004fe0: 2b0f         	cmp	r3, #0xf
 8004fe2: dddb         	ble	0x8004f9c <hexdump_line_print+0x38> @ imm = #-0x4a
; 	print_formatted(output, "|");
 8004fe4: 4921         	ldr	r1, [pc, #0x84]         @ 0x800506c <hexdump_line_print+0x108>
 8004fe6: 68f8         	ldr	r0, [r7, #0xc]
 8004fe8: f7ff fe6e    	bl	0x8004cc8 <print_formatted> @ imm = #-0x324
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8004fec: 2300         	movs	r3, #0x0
 8004fee: 617b         	str	r3, [r7, #0x14]
 8004ff0: e02d         	b	0x800504e <hexdump_line_print+0xea> @ imm = #0x5a
; 		if (i > 0 && !(i % 8)) {
 8004ff2: 697b         	ldr	r3, [r7, #0x14]
 8004ff4: 2b00         	cmp	r3, #0x0
 8004ff6: dd08         	ble	0x800500a <hexdump_line_print+0xa6> @ imm = #0x10
 8004ff8: 697b         	ldr	r3, [r7, #0x14]
 8004ffa: f003 0307    	and	r3, r3, #0x7
 8004ffe: 2b00         	cmp	r3, #0x0
 8005000: d103         	bne	0x800500a <hexdump_line_print+0xa6> @ imm = #0x6
; 			print_formatted(output, " ");
 8005002: 4917         	ldr	r1, [pc, #0x5c]         @ 0x8005060 <hexdump_line_print+0xfc>
 8005004: 68f8         	ldr	r0, [r7, #0xc]
 8005006: f7ff fe5f    	bl	0x8004cc8 <print_formatted> @ imm = #-0x342
; 		if (i < length) {
 800500a: 697b         	ldr	r3, [r7, #0x14]
 800500c: 687a         	ldr	r2, [r7, #0x4]
 800500e: 429a         	cmp	r2, r3
 8005010: d916         	bls	0x8005040 <hexdump_line_print+0xdc> @ imm = #0x2c
; 			unsigned char c = (unsigned char)data[i];
 8005012: 697b         	ldr	r3, [r7, #0x14]
 8005014: 68ba         	ldr	r2, [r7, #0x8]
 8005016: 4413         	add	r3, r2
 8005018: 781b         	ldrb	r3, [r3]
 800501a: 74fb         	strb	r3, [r7, #0x13]
; 			      isprint((int)c) != 0 ? c : '.');
 800501c: 7cfb         	ldrb	r3, [r7, #0x13]
 800501e: 4618         	mov	r0, r3
 8005020: f7ff fe40    	bl	0x8004ca4 <__ctype_lookup> @ imm = #-0x380
 8005024: 4603         	mov	r3, r0
 8005026: f003 0397    	and	r3, r3, #0x97
; 			print_formatted(output, "%c",
 800502a: 2b00         	cmp	r3, #0x0
 800502c: d001         	beq	0x8005032 <hexdump_line_print+0xce> @ imm = #0x2
 800502e: 7cfb         	ldrb	r3, [r7, #0x13]
 8005030: e000         	b	0x8005034 <hexdump_line_print+0xd0> @ imm = #0x0
 8005032: 232e         	movs	r3, #0x2e
 8005034: 461a         	mov	r2, r3
 8005036: 490e         	ldr	r1, [pc, #0x38]         @ 0x8005070 <hexdump_line_print+0x10c>
 8005038: 68f8         	ldr	r0, [r7, #0xc]
 800503a: f7ff fe45    	bl	0x8004cc8 <print_formatted> @ imm = #-0x376
 800503e: e003         	b	0x8005048 <hexdump_line_print+0xe4> @ imm = #0x6
; 			print_formatted(output, " ");
 8005040: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8005060 <hexdump_line_print+0xfc>
 8005042: 68f8         	ldr	r0, [r7, #0xc]
 8005044: f7ff fe40    	bl	0x8004cc8 <print_formatted> @ imm = #-0x380
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8005048: 697b         	ldr	r3, [r7, #0x14]
 800504a: 3301         	adds	r3, #0x1
 800504c: 617b         	str	r3, [r7, #0x14]
 800504e: 697b         	ldr	r3, [r7, #0x14]
 8005050: 2b0f         	cmp	r3, #0xf
 8005052: ddce         	ble	0x8004ff2 <hexdump_line_print+0x8e> @ imm = #-0x64
; }
 8005054: bf00         	nop
 8005056: bf00         	nop
 8005058: 3720         	adds	r7, #0x20
 800505a: 46bd         	mov	sp, r7
 800505c: bd80         	pop	{r7, pc}
 800505e: bf00         	nop

08005060 <$d>:
 8005060: 44 85 02 08  	.word	0x08028544
 8005064: 48 85 02 08  	.word	0x08028548
 8005068: 50 85 02 08  	.word	0x08028550
 800506c: 54 85 02 08  	.word	0x08028554
 8005070: 58 85 02 08  	.word	0x08028558

08005074 <prefix_print>:
; {
 8005074: b590         	push	{r4, r7, lr}
 8005076: b08d         	sub	sp, #0x34
 8005078: af04         	add	r7, sp, #0x10
 800507a: 60f8         	str	r0, [r7, #0xc]
 800507c: 60b9         	str	r1, [r7, #0x8]
 800507e: 603b         	str	r3, [r7]
 8005080: 4613         	mov	r3, r2
 8005082: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t length = 0U;
 8005084: 2300         	movs	r3, #0x0
 8005086: 61fb         	str	r3, [r7, #0x1c]
; 	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
 8005088: 68bb         	ldr	r3, [r7, #0x8]
 800508a: f003 0302    	and	r3, r3, #0x2
 800508e: 2b00         	cmp	r3, #0x0
 8005090: bf14         	ite	ne
 8005092: 2301         	movne	r3, #0x1
 8005094: 2300         	moveq	r3, #0x0
 8005096: 76fb         	strb	r3, [r7, #0x1b]
; 	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
 8005098: 68bb         	ldr	r3, [r7, #0x8]
 800509a: f003 0301    	and	r3, r3, #0x1
 800509e: 2b00         	cmp	r3, #0x0
 80050a0: bf14         	ite	ne
 80050a2: 2301         	movne	r3, #0x1
 80050a4: 2300         	moveq	r3, #0x0
 80050a6: 76bb         	strb	r3, [r7, #0x1a]
; 	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
 80050a8: 68bb         	ldr	r3, [r7, #0x8]
 80050aa: f003 0308    	and	r3, r3, #0x8
 80050ae: 2b00         	cmp	r3, #0x0
 80050b0: bf14         	ite	ne
 80050b2: 2301         	movne	r3, #0x1
 80050b4: 2300         	moveq	r3, #0x0
 80050b6: 767b         	strb	r3, [r7, #0x19]
; 	bool thread_on = IS_ENABLED(CONFIG_LOG_THREAD_ID_PREFIX) &&
 80050b8: 2300         	movs	r3, #0x0
 80050ba: 74fb         	strb	r3, [r7, #0x13]
; 	bool source_off = flags & LOG_OUTPUT_FLAG_SKIP_SOURCE;
 80050bc: 68bb         	ldr	r3, [r7, #0x8]
 80050be: f403 7380    	and	r3, r3, #0x100
 80050c2: 2b00         	cmp	r3, #0x0
 80050c4: bf14         	ite	ne
 80050c6: 2301         	movne	r3, #0x1
 80050c8: 2300         	moveq	r3, #0x0
 80050ca: 763b         	strb	r3, [r7, #0x18]
; 	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
 80050cc: f016 fb72    	bl	0x801b7b4 <z_log_get_tag> @ imm = #0x166e4
 80050d0: 6178         	str	r0, [r7, #0x14]
; 	if (tag) {
 80050d2: 697b         	ldr	r3, [r7, #0x14]
 80050d4: 2b00         	cmp	r3, #0x0
 80050d6: d009         	beq	0x80050ec <prefix_print+0x78> @ imm = #0x12
; 		length += print_formatted(output, "%s ", tag);
 80050d8: 697a         	ldr	r2, [r7, #0x14]
 80050da: 491e         	ldr	r1, [pc, #0x78]         @ 0x8005154 <prefix_print+0xe0>
 80050dc: 68f8         	ldr	r0, [r7, #0xc]
 80050de: f7ff fdf3    	bl	0x8004cc8 <print_formatted> @ imm = #-0x41a
 80050e2: 4603         	mov	r3, r0
 80050e4: 461a         	mov	r2, r3
 80050e6: 69fb         	ldr	r3, [r7, #0x1c]
 80050e8: 4413         	add	r3, r2
 80050ea: 61fb         	str	r3, [r7, #0x1c]
; 	if (stamp) {
 80050ec: 7efb         	ldrb	r3, [r7, #0x1b]
 80050ee: 2b00         	cmp	r3, #0x0
 80050f0: d009         	beq	0x8005106 <prefix_print+0x92> @ imm = #0x12
; 		length += timestamp_print(output, flags, timestamp);
 80050f2: 683a         	ldr	r2, [r7]
 80050f4: 68b9         	ldr	r1, [r7, #0x8]
 80050f6: 68f8         	ldr	r0, [r7, #0xc]
 80050f8: f7ff fe02    	bl	0x8004d00 <timestamp_print> @ imm = #-0x3fc
 80050fc: 4603         	mov	r3, r0
 80050fe: 461a         	mov	r2, r3
 8005100: 69fb         	ldr	r3, [r7, #0x1c]
 8005102: 4413         	add	r3, r2
 8005104: 61fb         	str	r3, [r7, #0x1c]
; 		color_prefix(output, colors_on, level);
 8005106: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 800510a: 7ebb         	ldrb	r3, [r7, #0x1a]
 800510c: 4619         	mov	r1, r3
 800510e: 68f8         	ldr	r0, [r7, #0xc]
 8005110: f016 ff38    	bl	0x801bf84 <color_prefix> @ imm = #0x16e70
; 	length += ids_print(output, level_on, func_on, thread_on, domain,
 8005114: 7cfc         	ldrb	r4, [r7, #0x13]
 8005116: 7e3b         	ldrb	r3, [r7, #0x18]
 8005118: 2b00         	cmp	r3, #0x0
 800511a: d001         	beq	0x8005120 <prefix_print+0xac> @ imm = #0x2
 800511c: 2300         	movs	r3, #0x0
 800511e: e000         	b	0x8005122 <prefix_print+0xae> @ imm = #0x0
 8005120: 6b7b         	ldr	r3, [r7, #0x34]
 8005122: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 8005126: 79f8         	ldrb	r0, [r7, #0x7]
 8005128: 7e79         	ldrb	r1, [r7, #0x19]
 800512a: 9203         	str	r2, [sp, #0xc]
 800512c: 6bba         	ldr	r2, [r7, #0x38]
 800512e: 9202         	str	r2, [sp, #0x8]
 8005130: 9301         	str	r3, [sp, #0x4]
 8005132: 6b3b         	ldr	r3, [r7, #0x30]
 8005134: 9300         	str	r3, [sp]
 8005136: 4623         	mov	r3, r4
 8005138: 4602         	mov	r2, r0
 800513a: 68f8         	ldr	r0, [r7, #0xc]
 800513c: f7ff fea0    	bl	0x8004e80 <ids_print>   @ imm = #-0x2c0
 8005140: 4603         	mov	r3, r0
 8005142: 461a         	mov	r2, r3
 8005144: 69fb         	ldr	r3, [r7, #0x1c]
 8005146: 4413         	add	r3, r2
 8005148: 61fb         	str	r3, [r7, #0x1c]
; 	return length;
 800514a: 69fb         	ldr	r3, [r7, #0x1c]
; }
 800514c: 4618         	mov	r0, r3
 800514e: 3724         	adds	r7, #0x24
 8005150: 46bd         	mov	sp, r7
 8005152: bd90         	pop	{r4, r7, pc}

08005154 <$d>:
 8005154: 64 85 02 08  	.word	0x08028564

08005158 <log_output_process>:
; {
 8005158: b580         	push	{r7, lr}
 800515a: b08c         	sub	sp, #0x30
 800515c: af04         	add	r7, sp, #0x10
 800515e: 60f8         	str	r0, [r7, #0xc]
 8005160: 60b9         	str	r1, [r7, #0x8]
 8005162: 607a         	str	r2, [r7, #0x4]
 8005164: 603b         	str	r3, [r7]
; 	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
 8005166: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 800516a: 2b00         	cmp	r3, #0x0
 800516c: bf0c         	ite	eq
 800516e: 2301         	moveq	r3, #0x1
 8005170: 2300         	movne	r3, #0x0
 8005172: 75fb         	strb	r3, [r7, #0x17]
; 	if (!raw_string) {
 8005174: 7dfb         	ldrb	r3, [r7, #0x17]
 8005176: f083 0301    	eor	r3, r3, #0x1
 800517a: b2db         	uxtb	r3, r3
 800517c: 2b00         	cmp	r3, #0x0
 800517e: d012         	beq	0x80051a6 <log_output_process+0x4e> @ imm = #0x24
; 		prefix_offset = prefix_print(output, flags, 0, timestamp,
 8005180: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8005184: 9303         	str	r3, [sp, #0xc]
 8005186: 6abb         	ldr	r3, [r7, #0x28]
 8005188: 9302         	str	r3, [sp, #0x8]
 800518a: 683b         	ldr	r3, [r7]
 800518c: 9301         	str	r3, [sp, #0x4]
 800518e: 687b         	ldr	r3, [r7, #0x4]
 8005190: 9300         	str	r3, [sp]
 8005192: 68bb         	ldr	r3, [r7, #0x8]
 8005194: 2200         	movs	r2, #0x0
 8005196: 6bf9         	ldr	r1, [r7, #0x3c]
 8005198: 68f8         	ldr	r0, [r7, #0xc]
 800519a: f7ff ff6b    	bl	0x8005074 <prefix_print> @ imm = #-0x12a
 800519e: 61f8         	str	r0, [r7, #0x1c]
; 		cb = out_func;
 80051a0: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800520c <log_output_process+0xb4>
 80051a2: 61bb         	str	r3, [r7, #0x18]
 80051a4: e008         	b	0x80051b8 <log_output_process+0x60> @ imm = #0x10
; 		prefix_offset = 0;
 80051a6: 2300         	movs	r3, #0x0
 80051a8: 61fb         	str	r3, [r7, #0x1c]
; 		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
 80051aa: 683b         	ldr	r3, [r7]
 80051ac: 2b01         	cmp	r3, #0x1
 80051ae: d101         	bne	0x80051b4 <log_output_process+0x5c> @ imm = #0x2
 80051b0: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800520c <log_output_process+0xb4>
 80051b2: e000         	b	0x80051b6 <log_output_process+0x5e> @ imm = #0x0
 80051b4: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8005210 <log_output_process+0xb8>
 80051b6: 61bb         	str	r3, [r7, #0x18]
; 	if (package) {
 80051b8: 6b3b         	ldr	r3, [r7, #0x30]
 80051ba: 2b00         	cmp	r3, #0x0
 80051bc: d005         	beq	0x80051ca <log_output_process+0x72> @ imm = #0xa
; 		int err = cbpprintf(cb, (void *)output, (void *)package);
 80051be: 6b3a         	ldr	r2, [r7, #0x30]
 80051c0: 68f9         	ldr	r1, [r7, #0xc]
 80051c2: 69b8         	ldr	r0, [r7, #0x18]
 80051c4: f7ff fd5a    	bl	0x8004c7c <cbpprintf>   @ imm = #-0x54c
 80051c8: 6138         	str	r0, [r7, #0x10]
; 	if (data_len) {
 80051ca: 6bbb         	ldr	r3, [r7, #0x38]
 80051cc: 2b00         	cmp	r3, #0x0
 80051ce: d008         	beq	0x80051e2 <log_output_process+0x8a> @ imm = #0x10
; 		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
 80051d0: 69fa         	ldr	r2, [r7, #0x1c]
 80051d2: 6bfb         	ldr	r3, [r7, #0x3c]
 80051d4: 9300         	str	r3, [sp]
 80051d6: 4613         	mov	r3, r2
 80051d8: 6bba         	ldr	r2, [r7, #0x38]
 80051da: 6b79         	ldr	r1, [r7, #0x34]
 80051dc: 68f8         	ldr	r0, [r7, #0xc]
 80051de: f016 fef3    	bl	0x801bfc8 <log_msg_hexdump> @ imm = #0x16de6
; 	if (!raw_string) {
 80051e2: 7dfb         	ldrb	r3, [r7, #0x17]
 80051e4: f083 0301    	eor	r3, r3, #0x1
 80051e8: b2db         	uxtb	r3, r3
 80051ea: 2b00         	cmp	r3, #0x0
 80051ec: d006         	beq	0x80051fc <log_output_process+0xa4> @ imm = #0xc
; 		postfix_print(output, flags, level);
 80051ee: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 80051f2: 461a         	mov	r2, r3
 80051f4: 6bf9         	ldr	r1, [r7, #0x3c]
 80051f6: 68f8         	ldr	r0, [r7, #0xc]
 80051f8: f016 ff0a    	bl	0x801c010 <postfix_print> @ imm = #0x16e14
; 	log_output_flush(output);
 80051fc: 68f8         	ldr	r0, [r7, #0xc]
 80051fe: f016 fe7b    	bl	0x801bef8 <log_output_flush> @ imm = #0x16cf6
; }
 8005202: bf00         	nop
 8005204: 3720         	adds	r7, #0x20
 8005206: 46bd         	mov	sp, r7
 8005208: bd80         	pop	{r7, pc}
 800520a: bf00         	nop

0800520c <$d>:
 800520c: 2b bf 01 08  	.word	0x0801bf2b
 8005210: 5b bf 01 08  	.word	0x0801bf5b

08005214 <log_output_timestamp_freq_set>:
; {
 8005214: b480         	push	{r7}
 8005216: b083         	sub	sp, #0xc
 8005218: af00         	add	r7, sp, #0x0
 800521a: 6078         	str	r0, [r7, #0x4]
; 	timestamp_div = 1U;
 800521c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8005250 <log_output_timestamp_freq_set+0x3c>
 800521e: 2201         	movs	r2, #0x1
 8005220: 601a         	str	r2, [r3]
; 	while (frequency > 1000000) {
 8005222: e007         	b	0x8005234 <log_output_timestamp_freq_set+0x20> @ imm = #0xe
; 		frequency /= 2U;
 8005224: 687b         	ldr	r3, [r7, #0x4]
 8005226: 085b         	lsrs	r3, r3, #0x1
 8005228: 607b         	str	r3, [r7, #0x4]
; 		timestamp_div *= 2U;
 800522a: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8005250 <log_output_timestamp_freq_set+0x3c>
 800522c: 681b         	ldr	r3, [r3]
 800522e: 005b         	lsls	r3, r3, #0x1
 8005230: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8005250 <log_output_timestamp_freq_set+0x3c>
 8005232: 6013         	str	r3, [r2]
; 	while (frequency > 1000000) {
 8005234: 687b         	ldr	r3, [r7, #0x4]
 8005236: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8005254 <log_output_timestamp_freq_set+0x40>
 8005238: 4293         	cmp	r3, r2
 800523a: d8f3         	bhi	0x8005224 <log_output_timestamp_freq_set+0x10> @ imm = #-0x1a
; 	freq = frequency;
 800523c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8005258 <log_output_timestamp_freq_set+0x44>
 800523e: 687b         	ldr	r3, [r7, #0x4]
 8005240: 6013         	str	r3, [r2]
; }
 8005242: bf00         	nop
 8005244: 370c         	adds	r7, #0xc
 8005246: 46bd         	mov	sp, r7
 8005248: f85d 7b04    	ldr	r7, [sp], #4
 800524c: 4770         	bx	lr
 800524e: bf00         	nop

08005250 <$d>:
 8005250: f8 2c 00 20  	.word	0x20002cf8
 8005254: 40 42 0f 00  	.word	0x000f4240
 8005258: f4 2c 00 20  	.word	0x20002cf4

0800525c <char_out>:
; {
 800525c: b580         	push	{r7, lr}
 800525e: b088         	sub	sp, #0x20
 8005260: af00         	add	r7, sp, #0x0
 8005262: 60f8         	str	r0, [r7, #0xc]
 8005264: 60b9         	str	r1, [r7, #0x8]
 8005266: 607a         	str	r2, [r7, #0x4]
; 	const struct lbu_cb_ctx *cb_ctx = ctx;
 8005268: 687b         	ldr	r3, [r7, #0x4]
 800526a: 61bb         	str	r3, [r7, #0x18]
; 	struct lbu_data *lb_data = cb_ctx->data;
 800526c: 69bb         	ldr	r3, [r7, #0x18]
 800526e: 685b         	ldr	r3, [r3, #0x4]
 8005270: 617b         	str	r3, [r7, #0x14]
; 	const struct device *uart_dev = LBU_UART_DEV(cb_ctx);
 8005272: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80052c8 <char_out+0x6c>
 8005274: 613b         	str	r3, [r7, #0x10]
; 	if (pm_device_runtime_get(uart_dev) < 0) {
 8005276: 6938         	ldr	r0, [r7, #0x10]
 8005278: f016 ffc4    	bl	0x801c204 <pm_device_runtime_get> @ imm = #0x16f88
 800527c: 4603         	mov	r3, r0
 800527e: 2b00         	cmp	r3, #0x0
 8005280: da01         	bge	0x8005286 <char_out+0x2a> @ imm = #0x2
; 		return length;
 8005282: 68b9         	ldr	r1, [r7, #0x8]
 8005284: e01a         	b	0x80052bc <char_out+0x60> @ imm = #0x34
; 		for (size_t i = 0; i < length; i++) {
 8005286: 2300         	movs	r3, #0x0
 8005288: 61fb         	str	r3, [r7, #0x1c]
 800528a: e00a         	b	0x80052a2 <char_out+0x46> @ imm = #0x14
; 			uart_poll_out(uart_dev, data[i]);
 800528c: 68fa         	ldr	r2, [r7, #0xc]
 800528e: 69fb         	ldr	r3, [r7, #0x1c]
 8005290: 4413         	add	r3, r2
 8005292: 781b         	ldrb	r3, [r3]
 8005294: 4619         	mov	r1, r3
 8005296: 6938         	ldr	r0, [r7, #0x10]
 8005298: f016 ffa5    	bl	0x801c1e6 <uart_poll_out> @ imm = #0x16f4a
; 		for (size_t i = 0; i < length; i++) {
 800529c: 69fb         	ldr	r3, [r7, #0x1c]
 800529e: 3301         	adds	r3, #0x1
 80052a0: 61fb         	str	r3, [r7, #0x1c]
 80052a2: 69fa         	ldr	r2, [r7, #0x1c]
 80052a4: 68bb         	ldr	r3, [r7, #0x8]
 80052a6: 429a         	cmp	r2, r3
 80052a8: d3f0         	blo	0x800528c <char_out+0x30> @ imm = #-0x20
; 		goto cleanup;
 80052aa: bf00         	nop
; 	(void)pm_device_runtime_put_async(uart_dev, K_MSEC(1));
 80052ac: f04f 020a    	mov.w	r2, #0xa
 80052b0: f04f 0300    	mov.w	r3, #0x0
 80052b4: 6938         	ldr	r0, [r7, #0x10]
 80052b6: f016 ffb0    	bl	0x801c21a <pm_device_runtime_put_async> @ imm = #0x16f60
; 	return length;
 80052ba: 68b9         	ldr	r1, [r7, #0x8]
; }
 80052bc: 460b         	mov	r3, r1
 80052be: 4618         	mov	r0, r3
 80052c0: 3720         	adds	r7, #0x20
 80052c2: 46bd         	mov	sp, r7
 80052c4: bd80         	pop	{r7, pc}
 80052c6: bf00         	nop

080052c8 <$d>:
 80052c8: 60 7b 02 08  	.word	0x08027b60

080052cc <log_backend_uart_init>:
; {
 80052cc: b580         	push	{r7, lr}
 80052ce: b086         	sub	sp, #0x18
 80052d0: af00         	add	r7, sp, #0x0
 80052d2: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 80052d4: 687b         	ldr	r3, [r7, #0x4]
 80052d6: 685b         	ldr	r3, [r3, #0x4]
 80052d8: 681b         	ldr	r3, [r3]
 80052da: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 80052dc: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80052f8 <log_backend_uart_init+0x2c>
 80052de: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 80052e0: 693b         	ldr	r3, [r7, #0x10]
 80052e2: 685b         	ldr	r3, [r3, #0x4]
 80052e4: 617b         	str	r3, [r7, #0x14]
; 	log_output_ctx_set(ctx->output, (void *)ctx);
 80052e6: 693b         	ldr	r3, [r7, #0x10]
 80052e8: 681b         	ldr	r3, [r3]
 80052ea: 6939         	ldr	r1, [r7, #0x10]
 80052ec: 4618         	mov	r0, r3
 80052ee: f016 ff39    	bl	0x801c164 <log_output_ctx_set> @ imm = #0x16e72
; }
 80052f2: 3718         	adds	r7, #0x18
 80052f4: 46bd         	mov	sp, r7
 80052f6: bd80         	pop	{r7, pc}

080052f8 <$d>:
 80052f8: 60 7b 02 08  	.word	0x08027b60

080052fc <panic>:
; {
 80052fc: b580         	push	{r7, lr}
 80052fe: b086         	sub	sp, #0x18
 8005300: af00         	add	r7, sp, #0x0
 8005302: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8005304: 687b         	ldr	r3, [r7, #0x4]
 8005306: 685b         	ldr	r3, [r3, #0x4]
 8005308: 681b         	ldr	r3, [r3]
 800530a: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 800530c: 697b         	ldr	r3, [r7, #0x14]
 800530e: 685b         	ldr	r3, [r3, #0x4]
 8005310: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 8005312: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8005330 <panic+0x34>
 8005314: 60fb         	str	r3, [r7, #0xc]
; 	data->in_panic = true;
 8005316: 693b         	ldr	r3, [r7, #0x10]
 8005318: 2201         	movs	r2, #0x1
 800531a: 751a         	strb	r2, [r3, #0x14]
; 	log_backend_std_panic(ctx->output);
 800531c: 697b         	ldr	r3, [r7, #0x14]
 800531e: 681b         	ldr	r3, [r3]
 8005320: 4618         	mov	r0, r3
 8005322: f016 ff42    	bl	0x801c1aa <log_backend_std_panic> @ imm = #0x16e84
; }
 8005326: bf00         	nop
 8005328: 3718         	adds	r7, #0x18
 800532a: 46bd         	mov	sp, r7
 800532c: bd80         	pop	{r7, pc}
 800532e: bf00         	nop

08005330 <$d>:
 8005330: 60 7b 02 08  	.word	0x08027b60

08005334 <esf_dump>:
; {
 8005334: b5f0         	push	{r4, r5, r6, r7, lr}
 8005336: b09d         	sub	sp, #0x74
 8005338: af0c         	add	r7, sp, #0x30
 800533a: 6078         	str	r0, [r7, #0x4]
; 	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
 800533c: 2303         	movs	r3, #0x3
 800533e: 2b00         	cmp	r3, #0x0
 8005340: d020         	beq	0x8005384 <esf_dump+0x50> @ imm = #0x40
 8005342: 2301         	movs	r3, #0x1
 8005344: 77fb         	strb	r3, [r7, #0x1f]
 8005346: 7ffb         	ldrb	r3, [r7, #0x1f]
 8005348: f083 0301    	eor	r3, r3, #0x1
 800534c: b2db         	uxtb	r3, r3
 800534e: 2b00         	cmp	r3, #0x0
 8005350: d118         	bne	0x8005384 <esf_dump+0x50> @ imm = #0x30
 8005352: 4b76         	ldr	r3, [pc, #0x1d8]        @ 0x800552c <esf_dump+0x1f8>
 8005354: 6818         	ldr	r0, [r3]
 8005356: 687b         	ldr	r3, [r7, #0x4]
 8005358: 681b         	ldr	r3, [r3]
 800535a: 687a         	ldr	r2, [r7, #0x4]
 800535c: 6852         	ldr	r2, [r2, #0x4]
 800535e: 6879         	ldr	r1, [r7, #0x4]
 8005360: 6889         	ldr	r1, [r1, #0x8]
 8005362: 9105         	str	r1, [sp, #0x14]
 8005364: 9204         	str	r2, [sp, #0x10]
 8005366: 9303         	str	r3, [sp, #0xc]
 8005368: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8005530 <esf_dump+0x1fc>
 800536a: 9302         	str	r3, [sp, #0x8]
 800536c: 2300         	movs	r3, #0x0
 800536e: 9301         	str	r3, [sp, #0x4]
 8005370: 2300         	movs	r3, #0x0
 8005372: 9300         	str	r3, [sp]
 8005374: 2300         	movs	r3, #0x0
 8005376: 2201         	movs	r2, #0x1
 8005378: 4601         	mov	r1, r0
 800537a: 2000         	movs	r0, #0x0
 800537c: f016 ff8f    	bl	0x801c29e <z_log_msg_runtime_create> @ imm = #0x16f1e
 8005380: 2300         	movs	r3, #0x0
 8005382: 61bb         	str	r3, [r7, #0x18]
; 	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
 8005384: 2303         	movs	r3, #0x3
 8005386: 2b00         	cmp	r3, #0x0
 8005388: d020         	beq	0x80053cc <esf_dump+0x98> @ imm = #0x40
 800538a: 2301         	movs	r3, #0x1
 800538c: 75fb         	strb	r3, [r7, #0x17]
 800538e: 7dfb         	ldrb	r3, [r7, #0x17]
 8005390: f083 0301    	eor	r3, r3, #0x1
 8005394: b2db         	uxtb	r3, r3
 8005396: 2b00         	cmp	r3, #0x0
 8005398: d118         	bne	0x80053cc <esf_dump+0x98> @ imm = #0x30
 800539a: 4b64         	ldr	r3, [pc, #0x190]        @ 0x800552c <esf_dump+0x1f8>
 800539c: 6818         	ldr	r0, [r3]
 800539e: 687b         	ldr	r3, [r7, #0x4]
 80053a0: 68db         	ldr	r3, [r3, #0xc]
 80053a2: 687a         	ldr	r2, [r7, #0x4]
 80053a4: 6912         	ldr	r2, [r2, #0x10]
 80053a6: 6879         	ldr	r1, [r7, #0x4]
 80053a8: 6949         	ldr	r1, [r1, #0x14]
 80053aa: 9105         	str	r1, [sp, #0x14]
 80053ac: 9204         	str	r2, [sp, #0x10]
 80053ae: 9303         	str	r3, [sp, #0xc]
 80053b0: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8005534 <esf_dump+0x200>
 80053b2: 9302         	str	r3, [sp, #0x8]
 80053b4: 2300         	movs	r3, #0x0
 80053b6: 9301         	str	r3, [sp, #0x4]
 80053b8: 2300         	movs	r3, #0x0
 80053ba: 9300         	str	r3, [sp]
 80053bc: 2300         	movs	r3, #0x0
 80053be: 2201         	movs	r2, #0x1
 80053c0: 4601         	mov	r1, r0
 80053c2: 2000         	movs	r0, #0x0
 80053c4: f016 ff6b    	bl	0x801c29e <z_log_msg_runtime_create> @ imm = #0x16ed6
 80053c8: 2300         	movs	r3, #0x0
 80053ca: 613b         	str	r3, [r7, #0x10]
; 	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
 80053cc: 2303         	movs	r3, #0x3
 80053ce: 2b00         	cmp	r3, #0x0
 80053d0: d019         	beq	0x8005406 <esf_dump+0xd2> @ imm = #0x32
 80053d2: 2301         	movs	r3, #0x1
 80053d4: 73fb         	strb	r3, [r7, #0xf]
 80053d6: 7bfb         	ldrb	r3, [r7, #0xf]
 80053d8: f083 0301    	eor	r3, r3, #0x1
 80053dc: b2db         	uxtb	r3, r3
 80053de: 2b00         	cmp	r3, #0x0
 80053e0: d111         	bne	0x8005406 <esf_dump+0xd2> @ imm = #0x22
 80053e2: 4b52         	ldr	r3, [pc, #0x148]        @ 0x800552c <esf_dump+0x1f8>
 80053e4: 6819         	ldr	r1, [r3]
 80053e6: 687b         	ldr	r3, [r7, #0x4]
 80053e8: 69db         	ldr	r3, [r3, #0x1c]
 80053ea: 9303         	str	r3, [sp, #0xc]
 80053ec: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8005538 <esf_dump+0x204>
 80053ee: 9302         	str	r3, [sp, #0x8]
 80053f0: 2300         	movs	r3, #0x0
 80053f2: 9301         	str	r3, [sp, #0x4]
 80053f4: 2300         	movs	r3, #0x0
 80053f6: 9300         	str	r3, [sp]
 80053f8: 2300         	movs	r3, #0x0
 80053fa: 2201         	movs	r2, #0x1
 80053fc: 2000         	movs	r0, #0x0
 80053fe: f016 ff4e    	bl	0x801c29e <z_log_msg_runtime_create> @ imm = #0x16e9c
 8005402: 2300         	movs	r3, #0x0
 8005404: 63fb         	str	r3, [r7, #0x3c]
; 	for (int i = 0; i < ARRAY_SIZE(esf->fpu.s); i += 4) {
 8005406: 2300         	movs	r3, #0x0
 8005408: 63bb         	str	r3, [r7, #0x38]
 800540a: e048         	b	0x800549e <esf_dump+0x16a> @ imm = #0x90
; 		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
 800540c: 2303         	movs	r3, #0x3
 800540e: 2b00         	cmp	r3, #0x0
 8005410: d042         	beq	0x8005498 <esf_dump+0x164> @ imm = #0x84
 8005412: 2301         	movs	r3, #0x1
 8005414: f887 3027    	strb.w	r3, [r7, #0x27]
 8005418: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800541c: f083 0301    	eor	r3, r3, #0x1
 8005420: b2db         	uxtb	r3, r3
 8005422: 2b00         	cmp	r3, #0x0
 8005424: d138         	bne	0x8005498 <esf_dump+0x164> @ imm = #0x70
 8005426: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800552c <esf_dump+0x1f8>
 8005428: 681b         	ldr	r3, [r3]
 800542a: 603b         	str	r3, [r7]
 800542c: 687b         	ldr	r3, [r7, #0x4]
 800542e: 6bba         	ldr	r2, [r7, #0x38]
 8005430: 3208         	adds	r2, #0x8
 8005432: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8005436: 6bba         	ldr	r2, [r7, #0x38]
 8005438: 3201         	adds	r2, #0x1
 800543a: 6bb9         	ldr	r1, [r7, #0x38]
 800543c: 1c48         	adds	r0, r1, #0x1
 800543e: 6879         	ldr	r1, [r7, #0x4]
 8005440: 3008         	adds	r0, #0x8
 8005442: f851 1020    	ldr.w	r1, [r1, r0, lsl #2]
 8005446: 6bb8         	ldr	r0, [r7, #0x38]
 8005448: 3002         	adds	r0, #0x2
 800544a: 6bbc         	ldr	r4, [r7, #0x38]
 800544c: 1ca5         	adds	r5, r4, #0x2
 800544e: 687c         	ldr	r4, [r7, #0x4]
 8005450: 3508         	adds	r5, #0x8
 8005452: f854 4025    	ldr.w	r4, [r4, r5, lsl #2]
 8005456: 6bbd         	ldr	r5, [r7, #0x38]
 8005458: 3503         	adds	r5, #0x3
 800545a: 6bbe         	ldr	r6, [r7, #0x38]
 800545c: f106 0c03    	add.w	r12, r6, #0x3
 8005460: 687e         	ldr	r6, [r7, #0x4]
 8005462: f10c 0c08    	add.w	r12, r12, #0x8
 8005466: f856 602c    	ldr.w	r6, [r6, r12, lsl #2]
 800546a: 960a         	str	r6, [sp, #0x28]
 800546c: 9509         	str	r5, [sp, #0x24]
 800546e: 9408         	str	r4, [sp, #0x20]
 8005470: 9007         	str	r0, [sp, #0x1c]
 8005472: 9106         	str	r1, [sp, #0x18]
 8005474: 9205         	str	r2, [sp, #0x14]
 8005476: 9304         	str	r3, [sp, #0x10]
 8005478: 6bbb         	ldr	r3, [r7, #0x38]
 800547a: 9303         	str	r3, [sp, #0xc]
 800547c: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800553c <esf_dump+0x208>
 800547e: 9302         	str	r3, [sp, #0x8]
 8005480: 2300         	movs	r3, #0x0
 8005482: 9301         	str	r3, [sp, #0x4]
 8005484: 2300         	movs	r3, #0x0
 8005486: 9300         	str	r3, [sp]
 8005488: 2300         	movs	r3, #0x0
 800548a: 2201         	movs	r2, #0x1
 800548c: 6839         	ldr	r1, [r7]
 800548e: 2000         	movs	r0, #0x0
 8005490: f016 ff05    	bl	0x801c29e <z_log_msg_runtime_create> @ imm = #0x16e0a
 8005494: 2300         	movs	r3, #0x0
 8005496: 623b         	str	r3, [r7, #0x20]
; 	for (int i = 0; i < ARRAY_SIZE(esf->fpu.s); i += 4) {
 8005498: 6bbb         	ldr	r3, [r7, #0x38]
 800549a: 3304         	adds	r3, #0x4
 800549c: 63bb         	str	r3, [r7, #0x38]
 800549e: 6bbb         	ldr	r3, [r7, #0x38]
 80054a0: 2b0f         	cmp	r3, #0xf
 80054a2: d9b3         	bls	0x800540c <esf_dump+0xd8> @ imm = #-0x9a
; 	LOG_ERR("fpscr:  0x%08x", esf->fpu.fpscr);
 80054a4: 2303         	movs	r3, #0x3
 80054a6: 2b00         	cmp	r3, #0x0
 80054a8: d01b         	beq	0x80054e2 <esf_dump+0x1ae> @ imm = #0x36
 80054aa: 2301         	movs	r3, #0x1
 80054ac: f887 3037    	strb.w	r3, [r7, #0x37]
 80054b0: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80054b4: f083 0301    	eor	r3, r3, #0x1
 80054b8: b2db         	uxtb	r3, r3
 80054ba: 2b00         	cmp	r3, #0x0
 80054bc: d111         	bne	0x80054e2 <esf_dump+0x1ae> @ imm = #0x22
 80054be: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800552c <esf_dump+0x1f8>
 80054c0: 6819         	ldr	r1, [r3]
 80054c2: 687b         	ldr	r3, [r7, #0x4]
 80054c4: 6e1b         	ldr	r3, [r3, #0x60]
 80054c6: 9303         	str	r3, [sp, #0xc]
 80054c8: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8005540 <esf_dump+0x20c>
 80054ca: 9302         	str	r3, [sp, #0x8]
 80054cc: 2300         	movs	r3, #0x0
 80054ce: 9301         	str	r3, [sp, #0x4]
 80054d0: 2300         	movs	r3, #0x0
 80054d2: 9300         	str	r3, [sp]
 80054d4: 2300         	movs	r3, #0x0
 80054d6: 2201         	movs	r2, #0x1
 80054d8: 2000         	movs	r0, #0x0
 80054da: f016 fee0    	bl	0x801c29e <z_log_msg_runtime_create> @ imm = #0x16dc0
 80054de: 2300         	movs	r3, #0x0
 80054e0: 633b         	str	r3, [r7, #0x30]
; 	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
 80054e2: 2303         	movs	r3, #0x3
 80054e4: 2b00         	cmp	r3, #0x0
 80054e6: d01c         	beq	0x8005522 <esf_dump+0x1ee> @ imm = #0x38
 80054e8: 2301         	movs	r3, #0x1
 80054ea: f887 302f    	strb.w	r3, [r7, #0x2f]
 80054ee: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 80054f2: f083 0301    	eor	r3, r3, #0x1
 80054f6: b2db         	uxtb	r3, r3
 80054f8: 2b00         	cmp	r3, #0x0
 80054fa: d112         	bne	0x8005522 <esf_dump+0x1ee> @ imm = #0x24
 80054fc: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800552c <esf_dump+0x1f8>
 80054fe: 6819         	ldr	r1, [r3]
 8005500: 687b         	ldr	r3, [r7, #0x4]
 8005502: 699b         	ldr	r3, [r3, #0x18]
 8005504: 9303         	str	r3, [sp, #0xc]
 8005506: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8005544 <esf_dump+0x210>
 8005508: 9302         	str	r3, [sp, #0x8]
 800550a: 2300         	movs	r3, #0x0
 800550c: 9301         	str	r3, [sp, #0x4]
 800550e: 2300         	movs	r3, #0x0
 8005510: 9300         	str	r3, [sp]
 8005512: 2300         	movs	r3, #0x0
 8005514: 2201         	movs	r2, #0x1
 8005516: 2000         	movs	r0, #0x0
 8005518: f016 fec1    	bl	0x801c29e <z_log_msg_runtime_create> @ imm = #0x16d82
 800551c: 2300         	movs	r3, #0x0
 800551e: 62bb         	str	r3, [r7, #0x28]
; }
 8005520: bf00         	nop
 8005522: bf00         	nop
 8005524: 3744         	adds	r7, #0x44
 8005526: 46bd         	mov	sp, r7
 8005528: bdf0         	pop	{r4, r5, r6, r7, pc}
 800552a: bf00         	nop

0800552c <$d>:
 800552c: ec 04 00 20  	.word	0x200004ec
 8005530: a0 85 02 08  	.word	0x080285a0
 8005534: d0 85 02 08  	.word	0x080285d0
 8005538: 00 86 02 08  	.word	0x08028600
 800553c: 10 86 02 08  	.word	0x08028610
 8005540: 54 86 02 08  	.word	0x08028654
 8005544: 64 86 02 08  	.word	0x08028664

08005548 <z_arm_fatal_error>:
; {
 8005548: b580         	push	{r7, lr}
 800554a: b08a         	sub	sp, #0x28
 800554c: af04         	add	r7, sp, #0x10
 800554e: 6078         	str	r0, [r7, #0x4]
 8005550: 6039         	str	r1, [r7]
; 	if (esf != NULL) {
 8005552: 683b         	ldr	r3, [r7]
 8005554: 2b00         	cmp	r3, #0x0
 8005556: d002         	beq	0x800555e <z_arm_fatal_error+0x16> @ imm = #0x4
; 		esf_dump(esf);
 8005558: 6838         	ldr	r0, [r7]
 800555a: f7ff feeb    	bl	0x8005334 <esf_dump>    @ imm = #-0x22a
; 	if (reason == K_ERR_SPURIOUS_IRQ) {
 800555e: 687b         	ldr	r3, [r7, #0x4]
 8005560: 2b01         	cmp	r3, #0x1
 8005562: d121         	bne	0x80055a8 <z_arm_fatal_error+0x60> @ imm = #0x42
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8005564: f3ef 8305    	mrs	r3, ipsr
 8005568: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 800556a: 68bb         	ldr	r3, [r7, #0x8]
; 		uint32_t irqn = __get_IPSR() - 16;
 800556c: 3b10         	subs	r3, #0x10
 800556e: 617b         	str	r3, [r7, #0x14]
; 		LOG_ERR("Unhandled IRQn: %d", irqn);
 8005570: 2303         	movs	r3, #0x3
 8005572: 2b00         	cmp	r3, #0x0
 8005574: d018         	beq	0x80055a8 <z_arm_fatal_error+0x60> @ imm = #0x30
 8005576: 2301         	movs	r3, #0x1
 8005578: 74fb         	strb	r3, [r7, #0x13]
 800557a: 7cfb         	ldrb	r3, [r7, #0x13]
 800557c: f083 0301    	eor	r3, r3, #0x1
 8005580: b2db         	uxtb	r3, r3
 8005582: 2b00         	cmp	r3, #0x0
 8005584: d110         	bne	0x80055a8 <z_arm_fatal_error+0x60> @ imm = #0x20
 8005586: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80055b8 <z_arm_fatal_error+0x70>
 8005588: 6819         	ldr	r1, [r3]
 800558a: 697b         	ldr	r3, [r7, #0x14]
 800558c: 9303         	str	r3, [sp, #0xc]
 800558e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80055bc <z_arm_fatal_error+0x74>
 8005590: 9302         	str	r3, [sp, #0x8]
 8005592: 2300         	movs	r3, #0x0
 8005594: 9301         	str	r3, [sp, #0x4]
 8005596: 2300         	movs	r3, #0x0
 8005598: 9300         	str	r3, [sp]
 800559a: 2300         	movs	r3, #0x0
 800559c: 2201         	movs	r2, #0x1
 800559e: 2000         	movs	r0, #0x0
 80055a0: f016 fe7d    	bl	0x801c29e <z_log_msg_runtime_create> @ imm = #0x16cfa
 80055a4: 2300         	movs	r3, #0x0
 80055a6: 60fb         	str	r3, [r7, #0xc]
; 	z_fatal_error(reason, esf);
 80055a8: 6839         	ldr	r1, [r7]
 80055aa: 6878         	ldr	r0, [r7, #0x4]
 80055ac: f00d fc78    	bl	0x8012ea0 <z_fatal_error> @ imm = #0xd8f0
; }
 80055b0: bf00         	nop
 80055b2: 3718         	adds	r7, #0x18
 80055b4: 46bd         	mov	sp, r7
 80055b6: bd80         	pop	{r7, pc}

080055b8 <$d>:
 80055b8: ec 04 00 20  	.word	0x200004ec
 80055bc: 94 86 02 08  	.word	0x08028694

080055c0 <z_arm_nmi>:
; {
 80055c0: b580         	push	{r7, lr}
 80055c2: af00         	add	r7, sp, #0x0
; 	handler();
 80055c4: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80055d4 <z_arm_nmi+0x14>
 80055c6: 681b         	ldr	r3, [r3]
 80055c8: 4798         	blx	r3
; 	z_arm_int_exit();
 80055ca: f000 f835    	bl	0x8005638 <z_arm_int_exit> @ imm = #0x6a
; }
 80055ce: bf00         	nop
 80055d0: bd80         	pop	{r7, pc}
 80055d2: bf00         	nop

080055d4 <$d>:
 80055d4: f0 04 00 20  	.word	0x200004f0

080055d8 <z_SysNmiOnReset>:
;     wfi
 80055d8: bf30         	wfi
;     b z_SysNmiOnReset
 80055da: f7ff bffd    	b.w	0x80055d8 <z_SysNmiOnReset> @ imm = #-0x6
 80055de: bf00         	nop

080055e0 <z_tls_data_size>:
; {
 80055e0: b480         	push	{r7}
 80055e2: af00         	add	r7, sp, #0x0
; 	return (size_t)(uintptr_t)__tdata_size +
 80055e4: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80055f4 <z_tls_data_size+0x14>
; 	       (size_t)(uintptr_t)__tbss_size;
 80055e6: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80055f8 <z_tls_data_size+0x18>
; 	return (size_t)(uintptr_t)__tdata_size +
 80055e8: 4413         	add	r3, r2
; }
 80055ea: 4618         	mov	r0, r3
 80055ec: 46bd         	mov	sp, r7
 80055ee: f85d 7b04    	ldr	r7, [sp], #4
 80055f2: 4770         	bx	lr

080055f4 <$d>:
 80055f4: 00 00 00 00  	.word	0x00000000
 80055f8: 08 00 00 00  	.word	0x00000008

080055fc <z_tls_copy>:
; {
 80055fc: b580         	push	{r7, lr}
 80055fe: b082         	sub	sp, #0x8
 8005600: af00         	add	r7, sp, #0x0
 8005602: 6078         	str	r0, [r7, #0x4]
; 	memcpy(dest, __tdata_start, (size_t)(uintptr_t)__tdata_size);
 8005604: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800562c <z_tls_copy+0x30>
 8005606: 461a         	mov	r2, r3
 8005608: 4909         	ldr	r1, [pc, #0x24]         @ 0x8005630 <z_tls_copy+0x34>
 800560a: 6878         	ldr	r0, [r7, #0x4]
 800560c: f021 ff6e    	bl	0x80274ec <memcpy>      @ imm = #0x21edc
; 	dest += (size_t)(uintptr_t)__tdata_size;
 8005610: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800562c <z_tls_copy+0x30>
 8005612: 687b         	ldr	r3, [r7, #0x4]
 8005614: 4413         	add	r3, r2
 8005616: 607b         	str	r3, [r7, #0x4]
; 	memset(dest, 0, (size_t)(uintptr_t)__tbss_size);
 8005618: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005634 <z_tls_copy+0x38>
 800561a: 461a         	mov	r2, r3
 800561c: 2100         	movs	r1, #0x0
 800561e: 6878         	ldr	r0, [r7, #0x4]
 8005620: f021 ff72    	bl	0x8027508 <memset>      @ imm = #0x21ee4
; }
 8005624: bf00         	nop
 8005626: 3708         	adds	r7, #0x8
 8005628: 46bd         	mov	sp, r7
 800562a: bd80         	pop	{r7, pc}

0800562c <$d>:
 800562c: 00 00 00 00  	.word	0x00000000
 8005630: 20 82 02 08  	.word	0x08028220
 8005634: 08 00 00 00  	.word	0x00000008

08005638 <z_arm_int_exit>:
; {
 8005638: b480         	push	{r7}
 800563a: af00         	add	r7, sp, #0x0
; 	if (_kernel.cpus->current->base.prio >= 0) {
 800563c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800566c <z_arm_int_exit+0x34>
 800563e: 689b         	ldr	r3, [r3, #0x8]
 8005640: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8005644: 2b00         	cmp	r3, #0x0
 8005646: db0b         	blt	0x8005660 <z_arm_int_exit+0x28> @ imm = #0x16
; 		if (_kernel.ready_q.cache != _kernel.cpus->current) {
 8005648: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800566c <z_arm_int_exit+0x34>
 800564a: 6a1a         	ldr	r2, [r3, #0x20]
 800564c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800566c <z_arm_int_exit+0x34>
 800564e: 689b         	ldr	r3, [r3, #0x8]
 8005650: 429a         	cmp	r2, r3
 8005652: d005         	beq	0x8005660 <z_arm_int_exit+0x28> @ imm = #0xa
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8005654: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005670 <z_arm_int_exit+0x38>
 8005656: 685b         	ldr	r3, [r3, #0x4]
 8005658: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8005670 <z_arm_int_exit+0x38>
 800565a: f043 5380    	orr	r3, r3, #0x10000000
 800565e: 6053         	str	r3, [r2, #0x4]
; }
 8005660: bf00         	nop
 8005662: 46bd         	mov	sp, r7
 8005664: f85d 7b04    	ldr	r7, [sp], #4
 8005668: 4770         	bx	lr
 800566a: bf00         	nop

0800566c <$d>:
 800566c: a8 25 00 20  	.word	0x200025a8
 8005670: 00 ed 00 e0  	.word	0xe000ed00

08005674 <mem_manage_fault>:
; {
 8005674: b580         	push	{r7, lr}
 8005676: b09a         	sub	sp, #0x68
 8005678: af04         	add	r7, sp, #0x10
 800567a: 60f8         	str	r0, [r7, #0xc]
 800567c: 60b9         	str	r1, [r7, #0x8]
 800567e: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
 8005680: 2310         	movs	r3, #0x10
 8005682: 657b         	str	r3, [r7, #0x54]
; 	uint32_t mmfar = -EINVAL;
 8005684: f06f 0315    	mvn	r3, #0x15
 8005688: 653b         	str	r3, [r7, #0x50]
; 	PR_FAULT_INFO("***** MPU FAULT *****");
 800568a: 2303         	movs	r3, #0x3
 800568c: 2b00         	cmp	r3, #0x0
 800568e: d018         	beq	0x80056c2 <mem_manage_fault+0x4e> @ imm = #0x30
 8005690: 2301         	movs	r3, #0x1
 8005692: f887 304f    	strb.w	r3, [r7, #0x4f]
 8005696: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 800569a: f083 0301    	eor	r3, r3, #0x1
 800569e: b2db         	uxtb	r3, r3
 80056a0: 2b00         	cmp	r3, #0x0
 80056a2: d10e         	bne	0x80056c2 <mem_manage_fault+0x4e> @ imm = #0x1c
 80056a4: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x80058d8 <mem_manage_fault+0x264>
 80056a6: 6819         	ldr	r1, [r3]
 80056a8: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x80058dc <mem_manage_fault+0x268>
 80056aa: 9302         	str	r3, [sp, #0x8]
 80056ac: 2300         	movs	r3, #0x0
 80056ae: 9301         	str	r3, [sp, #0x4]
 80056b0: 2300         	movs	r3, #0x0
 80056b2: 9300         	str	r3, [sp]
 80056b4: 2300         	movs	r3, #0x0
 80056b6: 2201         	movs	r2, #0x1
 80056b8: 2000         	movs	r0, #0x0
 80056ba: f016 fe42    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16c84
 80056be: 2300         	movs	r3, #0x0
 80056c0: 64bb         	str	r3, [r7, #0x48]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 80056c2: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x80058e0 <mem_manage_fault+0x26c>
 80056c4: 6a9b         	ldr	r3, [r3, #0x28]
 80056c6: f003 0310    	and	r3, r3, #0x10
 80056ca: 2b00         	cmp	r3, #0x0
 80056cc: d01d         	beq	0x800570a <mem_manage_fault+0x96> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_STACKING;
 80056ce: 2311         	movs	r3, #0x11
 80056d0: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error (context area might be"
 80056d2: 2303         	movs	r3, #0x3
 80056d4: 2b00         	cmp	r3, #0x0
 80056d6: d018         	beq	0x800570a <mem_manage_fault+0x96> @ imm = #0x30
 80056d8: 2301         	movs	r3, #0x1
 80056da: f887 3047    	strb.w	r3, [r7, #0x47]
 80056de: f897 3047    	ldrb.w	r3, [r7, #0x47]
 80056e2: f083 0301    	eor	r3, r3, #0x1
 80056e6: b2db         	uxtb	r3, r3
 80056e8: 2b00         	cmp	r3, #0x0
 80056ea: d10e         	bne	0x800570a <mem_manage_fault+0x96> @ imm = #0x1c
 80056ec: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x80058d8 <mem_manage_fault+0x264>
 80056ee: 6819         	ldr	r1, [r3]
 80056f0: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x80058e4 <mem_manage_fault+0x270>
 80056f2: 9302         	str	r3, [sp, #0x8]
 80056f4: 2300         	movs	r3, #0x0
 80056f6: 9301         	str	r3, [sp, #0x4]
 80056f8: 2300         	movs	r3, #0x0
 80056fa: 9300         	str	r3, [sp]
 80056fc: 2300         	movs	r3, #0x0
 80056fe: 2201         	movs	r2, #0x1
 8005700: 2000         	movs	r0, #0x0
 8005702: f016 fe1e    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16c3c
 8005706: 2300         	movs	r3, #0x0
 8005708: 643b         	str	r3, [r7, #0x40]
; 	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 800570a: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x80058e0 <mem_manage_fault+0x26c>
 800570c: 6a9b         	ldr	r3, [r3, #0x28]
 800570e: f003 0308    	and	r3, r3, #0x8
 8005712: 2b00         	cmp	r3, #0x0
 8005714: d01d         	beq	0x8005752 <mem_manage_fault+0xde> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_UNSTACKING;
 8005716: 2312         	movs	r3, #0x12
 8005718: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 800571a: 2303         	movs	r3, #0x3
 800571c: 2b00         	cmp	r3, #0x0
 800571e: d018         	beq	0x8005752 <mem_manage_fault+0xde> @ imm = #0x30
 8005720: 2301         	movs	r3, #0x1
 8005722: f887 303f    	strb.w	r3, [r7, #0x3f]
 8005726: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800572a: f083 0301    	eor	r3, r3, #0x1
 800572e: b2db         	uxtb	r3, r3
 8005730: 2b00         	cmp	r3, #0x0
 8005732: d10e         	bne	0x8005752 <mem_manage_fault+0xde> @ imm = #0x1c
 8005734: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x80058d8 <mem_manage_fault+0x264>
 8005736: 6819         	ldr	r1, [r3]
 8005738: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x80058e8 <mem_manage_fault+0x274>
 800573a: 9302         	str	r3, [sp, #0x8]
 800573c: 2300         	movs	r3, #0x0
 800573e: 9301         	str	r3, [sp, #0x4]
 8005740: 2300         	movs	r3, #0x0
 8005742: 9300         	str	r3, [sp]
 8005744: 2300         	movs	r3, #0x0
 8005746: 2201         	movs	r2, #0x1
 8005748: 2000         	movs	r0, #0x0
 800574a: f016 fdfa    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16bf4
 800574e: 2300         	movs	r3, #0x0
 8005750: 63bb         	str	r3, [r7, #0x38]
; 	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 8005752: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x80058e0 <mem_manage_fault+0x26c>
 8005754: 6a9b         	ldr	r3, [r3, #0x28]
 8005756: f003 0302    	and	r3, r3, #0x2
 800575a: 2b00         	cmp	r3, #0x0
 800575c: d04f         	beq	0x80057fe <mem_manage_fault+0x18a> @ imm = #0x9e
; 		reason = K_ERR_ARM_MEM_DATA_ACCESS;
 800575e: 2313         	movs	r3, #0x13
 8005760: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Data Access Violation");
 8005762: 2303         	movs	r3, #0x3
 8005764: 2b00         	cmp	r3, #0x0
 8005766: d018         	beq	0x800579a <mem_manage_fault+0x126> @ imm = #0x30
 8005768: 2301         	movs	r3, #0x1
 800576a: f887 3037    	strb.w	r3, [r7, #0x37]
 800576e: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8005772: f083 0301    	eor	r3, r3, #0x1
 8005776: b2db         	uxtb	r3, r3
 8005778: 2b00         	cmp	r3, #0x0
 800577a: d10e         	bne	0x800579a <mem_manage_fault+0x126> @ imm = #0x1c
 800577c: 4b56         	ldr	r3, [pc, #0x158]        @ 0x80058d8 <mem_manage_fault+0x264>
 800577e: 6819         	ldr	r1, [r3]
 8005780: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x80058ec <mem_manage_fault+0x278>
 8005782: 9302         	str	r3, [sp, #0x8]
 8005784: 2300         	movs	r3, #0x0
 8005786: 9301         	str	r3, [sp, #0x4]
 8005788: 2300         	movs	r3, #0x0
 800578a: 9300         	str	r3, [sp]
 800578c: 2300         	movs	r3, #0x0
 800578e: 2201         	movs	r2, #0x1
 8005790: 2000         	movs	r0, #0x0
 8005792: f016 fdd6    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16bac
 8005796: 2300         	movs	r3, #0x0
 8005798: 633b         	str	r3, [r7, #0x30]
; 		uint32_t temp = SCB->MMFAR;
 800579a: 4b51         	ldr	r3, [pc, #0x144]        @ 0x80058e0 <mem_manage_fault+0x26c>
 800579c: 6b5b         	ldr	r3, [r3, #0x34]
 800579e: 62fb         	str	r3, [r7, #0x2c]
; 		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 80057a0: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x80058e0 <mem_manage_fault+0x26c>
 80057a2: 6a9b         	ldr	r3, [r3, #0x28]
 80057a4: f003 0380    	and	r3, r3, #0x80
 80057a8: 2b00         	cmp	r3, #0x0
 80057aa: d028         	beq	0x80057fe <mem_manage_fault+0x18a> @ imm = #0x50
; 			mmfar = temp;
 80057ac: 6afb         	ldr	r3, [r7, #0x2c]
 80057ae: 653b         	str	r3, [r7, #0x50]
; 			PR_EXC("  MMFAR Address: 0x%x", mmfar);
 80057b0: 2303         	movs	r3, #0x3
 80057b2: 2b00         	cmp	r3, #0x0
 80057b4: d01a         	beq	0x80057ec <mem_manage_fault+0x178> @ imm = #0x34
 80057b6: 2301         	movs	r3, #0x1
 80057b8: f887 302b    	strb.w	r3, [r7, #0x2b]
 80057bc: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80057c0: f083 0301    	eor	r3, r3, #0x1
 80057c4: b2db         	uxtb	r3, r3
 80057c6: 2b00         	cmp	r3, #0x0
 80057c8: d110         	bne	0x80057ec <mem_manage_fault+0x178> @ imm = #0x20
 80057ca: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x80058d8 <mem_manage_fault+0x264>
 80057cc: 6819         	ldr	r1, [r3]
 80057ce: 6d3b         	ldr	r3, [r7, #0x50]
 80057d0: 9303         	str	r3, [sp, #0xc]
 80057d2: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x80058f0 <mem_manage_fault+0x27c>
 80057d4: 9302         	str	r3, [sp, #0x8]
 80057d6: 2300         	movs	r3, #0x0
 80057d8: 9301         	str	r3, [sp, #0x4]
 80057da: 2300         	movs	r3, #0x0
 80057dc: 9300         	str	r3, [sp]
 80057de: 2300         	movs	r3, #0x0
 80057e0: 2201         	movs	r2, #0x1
 80057e2: 2000         	movs	r0, #0x0
 80057e4: f016 fdad    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16b5a
 80057e8: 2300         	movs	r3, #0x0
 80057ea: 627b         	str	r3, [r7, #0x24]
; 			if (from_hard_fault != 0) {
 80057ec: 68bb         	ldr	r3, [r7, #0x8]
 80057ee: 2b00         	cmp	r3, #0x0
 80057f0: d005         	beq	0x80057fe <mem_manage_fault+0x18a> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 80057f2: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x80058e0 <mem_manage_fault+0x26c>
 80057f4: 6a9b         	ldr	r3, [r3, #0x28]
 80057f6: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x80058e0 <mem_manage_fault+0x26c>
 80057f8: f023 0380    	bic	r3, r3, #0x80
 80057fc: 6293         	str	r3, [r2, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 80057fe: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x80058e0 <mem_manage_fault+0x26c>
 8005800: 6a9b         	ldr	r3, [r3, #0x28]
 8005802: f003 0301    	and	r3, r3, #0x1
 8005806: 2b00         	cmp	r3, #0x0
 8005808: d01d         	beq	0x8005846 <mem_manage_fault+0x1d2> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
 800580a: 2314         	movs	r3, #0x14
 800580c: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction Access Violation");
 800580e: 2303         	movs	r3, #0x3
 8005810: 2b00         	cmp	r3, #0x0
 8005812: d018         	beq	0x8005846 <mem_manage_fault+0x1d2> @ imm = #0x30
 8005814: 2301         	movs	r3, #0x1
 8005816: f887 3023    	strb.w	r3, [r7, #0x23]
 800581a: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800581e: f083 0301    	eor	r3, r3, #0x1
 8005822: b2db         	uxtb	r3, r3
 8005824: 2b00         	cmp	r3, #0x0
 8005826: d10e         	bne	0x8005846 <mem_manage_fault+0x1d2> @ imm = #0x1c
 8005828: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x80058d8 <mem_manage_fault+0x264>
 800582a: 6819         	ldr	r1, [r3]
 800582c: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80058f4 <mem_manage_fault+0x280>
 800582e: 9302         	str	r3, [sp, #0x8]
 8005830: 2300         	movs	r3, #0x0
 8005832: 9301         	str	r3, [sp, #0x4]
 8005834: 2300         	movs	r3, #0x0
 8005836: 9300         	str	r3, [sp]
 8005838: 2300         	movs	r3, #0x0
 800583a: 2201         	movs	r2, #0x1
 800583c: 2000         	movs	r0, #0x0
 800583e: f016 fd80    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16b00
 8005842: 2300         	movs	r3, #0x0
 8005844: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 8005846: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80058e0 <mem_manage_fault+0x26c>
 8005848: 6a9b         	ldr	r3, [r3, #0x28]
 800584a: f003 0320    	and	r3, r3, #0x20
 800584e: 2b00         	cmp	r3, #0x0
 8005850: d01b         	beq	0x800588a <mem_manage_fault+0x216> @ imm = #0x36
; 		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
 8005852: 2315         	movs	r3, #0x15
 8005854: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO(
 8005856: 2303         	movs	r3, #0x3
 8005858: 2b00         	cmp	r3, #0x0
 800585a: d016         	beq	0x800588a <mem_manage_fault+0x216> @ imm = #0x2c
 800585c: 2301         	movs	r3, #0x1
 800585e: 76fb         	strb	r3, [r7, #0x1b]
 8005860: 7efb         	ldrb	r3, [r7, #0x1b]
 8005862: f083 0301    	eor	r3, r3, #0x1
 8005866: b2db         	uxtb	r3, r3
 8005868: 2b00         	cmp	r3, #0x0
 800586a: d10e         	bne	0x800588a <mem_manage_fault+0x216> @ imm = #0x1c
 800586c: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x80058d8 <mem_manage_fault+0x264>
 800586e: 6819         	ldr	r1, [r3]
 8005870: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80058f8 <mem_manage_fault+0x284>
 8005872: 9302         	str	r3, [sp, #0x8]
 8005874: 2300         	movs	r3, #0x0
 8005876: 9301         	str	r3, [sp, #0x4]
 8005878: 2300         	movs	r3, #0x0
 800587a: 9300         	str	r3, [sp]
 800587c: 2300         	movs	r3, #0x0
 800587e: 2201         	movs	r2, #0x1
 8005880: 2000         	movs	r0, #0x0
 8005882: f016 fd5e    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16abc
 8005886: 2300         	movs	r3, #0x0
 8005888: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 800588a: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80058e0 <mem_manage_fault+0x26c>
 800588c: 6a9b         	ldr	r3, [r3, #0x28]
 800588e: f003 0310    	and	r3, r3, #0x10
 8005892: 2b00         	cmp	r3, #0x0
 8005894: d101         	bne	0x800589a <mem_manage_fault+0x226> @ imm = #0x2
; 		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
 8005896: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80058e0 <mem_manage_fault+0x26c>
 8005898: 6a9b         	ldr	r3, [r3, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 800589a: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80058e0 <mem_manage_fault+0x26c>
 800589c: 6a9b         	ldr	r3, [r3, #0x28]
 800589e: f003 0320    	and	r3, r3, #0x20
 80058a2: 2b00         	cmp	r3, #0x0
 80058a4: d005         	beq	0x80058b2 <mem_manage_fault+0x23e> @ imm = #0xa
; 		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
 80058a6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80058e0 <mem_manage_fault+0x26c>
 80058a8: 6a5b         	ldr	r3, [r3, #0x24]
 80058aa: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x80058e0 <mem_manage_fault+0x26c>
 80058ac: f423 5300    	bic	r3, r3, #0x2000
 80058b0: 6253         	str	r3, [r2, #0x24]
; 	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 80058b2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80058e0 <mem_manage_fault+0x26c>
 80058b4: 6a9b         	ldr	r3, [r3, #0x28]
 80058b6: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80058e0 <mem_manage_fault+0x26c>
 80058b8: f043 03ff    	orr	r3, r3, #0xff
 80058bc: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 80058be: 2101         	movs	r1, #0x1
 80058c0: 68f8         	ldr	r0, [r7, #0xc]
 80058c2: f016 fd67    	bl	0x801c394 <memory_fault_recoverable> @ imm = #0x16ace
 80058c6: 4603         	mov	r3, r0
 80058c8: 461a         	mov	r2, r3
 80058ca: 687b         	ldr	r3, [r7, #0x4]
 80058cc: 701a         	strb	r2, [r3]
; 	return reason;
 80058ce: 6d7b         	ldr	r3, [r7, #0x54]
; }
 80058d0: 4618         	mov	r0, r3
 80058d2: 3758         	adds	r7, #0x58
 80058d4: 46bd         	mov	sp, r7
 80058d6: bd80         	pop	{r7, pc}

080058d8 <$d>:
 80058d8: f4 04 00 20  	.word	0x200004f4
 80058dc: a8 86 02 08  	.word	0x080286a8
 80058e0: 00 ed 00 e0  	.word	0xe000ed00
 80058e4: c0 86 02 08  	.word	0x080286c0
 80058e8: f4 86 02 08  	.word	0x080286f4
 80058ec: 08 87 02 08  	.word	0x08028708
 80058f0: 20 87 02 08  	.word	0x08028720
 80058f4: 38 87 02 08  	.word	0x08028738
 80058f8: 58 87 02 08  	.word	0x08028758

080058fc <bus_fault>:
; {
 80058fc: b580         	push	{r7, lr}
 80058fe: b09a         	sub	sp, #0x68
 8005900: af04         	add	r7, sp, #0x10
 8005902: 60f8         	str	r0, [r7, #0xc]
 8005904: 60b9         	str	r1, [r7, #0x8]
 8005906: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
 8005908: 2316         	movs	r3, #0x16
 800590a: 657b         	str	r3, [r7, #0x54]
; 	PR_FAULT_INFO("***** BUS FAULT *****");
 800590c: 2303         	movs	r3, #0x3
 800590e: 2b00         	cmp	r3, #0x0
 8005910: d018         	beq	0x8005944 <bus_fault+0x48> @ imm = #0x30
 8005912: 2301         	movs	r3, #0x1
 8005914: f887 3053    	strb.w	r3, [r7, #0x53]
 8005918: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800591c: f083 0301    	eor	r3, r3, #0x1
 8005920: b2db         	uxtb	r3, r3
 8005922: 2b00         	cmp	r3, #0x0
 8005924: d10e         	bne	0x8005944 <bus_fault+0x48> @ imm = #0x1c
 8005926: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8005b74 <bus_fault+0x278>
 8005928: 6819         	ldr	r1, [r3]
 800592a: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8005b78 <bus_fault+0x27c>
 800592c: 9302         	str	r3, [sp, #0x8]
 800592e: 2300         	movs	r3, #0x0
 8005930: 9301         	str	r3, [sp, #0x4]
 8005932: 2300         	movs	r3, #0x0
 8005934: 9300         	str	r3, [sp]
 8005936: 2300         	movs	r3, #0x0
 8005938: 2201         	movs	r2, #0x1
 800593a: 2000         	movs	r0, #0x0
 800593c: f016 fd01    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16a02
 8005940: 2300         	movs	r3, #0x0
 8005942: 64fb         	str	r3, [r7, #0x4c]
; 	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 8005944: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8005b7c <bus_fault+0x280>
 8005946: 6a9b         	ldr	r3, [r3, #0x28]
 8005948: f403 5380    	and	r3, r3, #0x1000
 800594c: 2b00         	cmp	r3, #0x0
 800594e: d01d         	beq	0x800598c <bus_fault+0x90> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_STACKING;
 8005950: 2317         	movs	r3, #0x17
 8005952: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error");
 8005954: 2303         	movs	r3, #0x3
 8005956: 2b00         	cmp	r3, #0x0
 8005958: d018         	beq	0x800598c <bus_fault+0x90> @ imm = #0x30
 800595a: 2301         	movs	r3, #0x1
 800595c: f887 304b    	strb.w	r3, [r7, #0x4b]
 8005960: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8005964: f083 0301    	eor	r3, r3, #0x1
 8005968: b2db         	uxtb	r3, r3
 800596a: 2b00         	cmp	r3, #0x0
 800596c: d10e         	bne	0x800598c <bus_fault+0x90> @ imm = #0x1c
 800596e: 4b81         	ldr	r3, [pc, #0x204]        @ 0x8005b74 <bus_fault+0x278>
 8005970: 6819         	ldr	r1, [r3]
 8005972: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x8005b80 <bus_fault+0x284>
 8005974: 9302         	str	r3, [sp, #0x8]
 8005976: 2300         	movs	r3, #0x0
 8005978: 9301         	str	r3, [sp, #0x4]
 800597a: 2300         	movs	r3, #0x0
 800597c: 9300         	str	r3, [sp]
 800597e: 2300         	movs	r3, #0x0
 8005980: 2201         	movs	r2, #0x1
 8005982: 2000         	movs	r0, #0x0
 8005984: f016 fcdd    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x169ba
 8005988: 2300         	movs	r3, #0x0
 800598a: 647b         	str	r3, [r7, #0x44]
; 	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 800598c: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x8005b7c <bus_fault+0x280>
 800598e: 6a9b         	ldr	r3, [r3, #0x28]
 8005990: f403 6300    	and	r3, r3, #0x800
 8005994: 2b00         	cmp	r3, #0x0
 8005996: d01d         	beq	0x80059d4 <bus_fault+0xd8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_UNSTACKING;
 8005998: 2318         	movs	r3, #0x18
 800599a: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 800599c: 2303         	movs	r3, #0x3
 800599e: 2b00         	cmp	r3, #0x0
 80059a0: d018         	beq	0x80059d4 <bus_fault+0xd8> @ imm = #0x30
 80059a2: 2301         	movs	r3, #0x1
 80059a4: f887 3043    	strb.w	r3, [r7, #0x43]
 80059a8: f897 3043    	ldrb.w	r3, [r7, #0x43]
 80059ac: f083 0301    	eor	r3, r3, #0x1
 80059b0: b2db         	uxtb	r3, r3
 80059b2: 2b00         	cmp	r3, #0x0
 80059b4: d10e         	bne	0x80059d4 <bus_fault+0xd8> @ imm = #0x1c
 80059b6: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8005b74 <bus_fault+0x278>
 80059b8: 6819         	ldr	r1, [r3]
 80059ba: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8005b84 <bus_fault+0x288>
 80059bc: 9302         	str	r3, [sp, #0x8]
 80059be: 2300         	movs	r3, #0x0
 80059c0: 9301         	str	r3, [sp, #0x4]
 80059c2: 2300         	movs	r3, #0x0
 80059c4: 9300         	str	r3, [sp]
 80059c6: 2300         	movs	r3, #0x0
 80059c8: 2201         	movs	r2, #0x1
 80059ca: 2000         	movs	r0, #0x0
 80059cc: f016 fcb9    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16972
 80059d0: 2300         	movs	r3, #0x0
 80059d2: 63fb         	str	r3, [r7, #0x3c]
; 	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 80059d4: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8005b7c <bus_fault+0x280>
 80059d6: 6a9b         	ldr	r3, [r3, #0x28]
 80059d8: f403 7300    	and	r3, r3, #0x200
 80059dc: 2b00         	cmp	r3, #0x0
 80059de: d04d         	beq	0x8005a7c <bus_fault+0x180> @ imm = #0x9a
; 		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
 80059e0: 2319         	movs	r3, #0x19
 80059e2: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Precise data bus error");
 80059e4: 2303         	movs	r3, #0x3
 80059e6: 2b00         	cmp	r3, #0x0
 80059e8: d018         	beq	0x8005a1c <bus_fault+0x120> @ imm = #0x30
 80059ea: 2301         	movs	r3, #0x1
 80059ec: f887 303b    	strb.w	r3, [r7, #0x3b]
 80059f0: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 80059f4: f083 0301    	eor	r3, r3, #0x1
 80059f8: b2db         	uxtb	r3, r3
 80059fa: 2b00         	cmp	r3, #0x0
 80059fc: d10e         	bne	0x8005a1c <bus_fault+0x120> @ imm = #0x1c
 80059fe: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8005b74 <bus_fault+0x278>
 8005a00: 6819         	ldr	r1, [r3]
 8005a02: 4b61         	ldr	r3, [pc, #0x184]        @ 0x8005b88 <bus_fault+0x28c>
 8005a04: 9302         	str	r3, [sp, #0x8]
 8005a06: 2300         	movs	r3, #0x0
 8005a08: 9301         	str	r3, [sp, #0x4]
 8005a0a: 2300         	movs	r3, #0x0
 8005a0c: 9300         	str	r3, [sp]
 8005a0e: 2300         	movs	r3, #0x0
 8005a10: 2201         	movs	r2, #0x1
 8005a12: 2000         	movs	r0, #0x0
 8005a14: f016 fc95    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x1692a
 8005a18: 2300         	movs	r3, #0x0
 8005a1a: 637b         	str	r3, [r7, #0x34]
; 		STORE_xFAR(bfar, SCB->BFAR);
 8005a1c: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8005b7c <bus_fault+0x280>
 8005a1e: 6b9b         	ldr	r3, [r3, #0x38]
 8005a20: 633b         	str	r3, [r7, #0x30]
; 		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 8005a22: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8005b7c <bus_fault+0x280>
 8005a24: 6a9b         	ldr	r3, [r3, #0x28]
 8005a26: f403 4300    	and	r3, r3, #0x8000
 8005a2a: 2b00         	cmp	r3, #0x0
 8005a2c: d026         	beq	0x8005a7c <bus_fault+0x180> @ imm = #0x4c
; 			PR_EXC("  BFAR Address: 0x%x", bfar);
 8005a2e: 2303         	movs	r3, #0x3
 8005a30: 2b00         	cmp	r3, #0x0
 8005a32: d01a         	beq	0x8005a6a <bus_fault+0x16e> @ imm = #0x34
 8005a34: 2301         	movs	r3, #0x1
 8005a36: f887 302f    	strb.w	r3, [r7, #0x2f]
 8005a3a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8005a3e: f083 0301    	eor	r3, r3, #0x1
 8005a42: b2db         	uxtb	r3, r3
 8005a44: 2b00         	cmp	r3, #0x0
 8005a46: d110         	bne	0x8005a6a <bus_fault+0x16e> @ imm = #0x20
 8005a48: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x8005b74 <bus_fault+0x278>
 8005a4a: 6819         	ldr	r1, [r3]
 8005a4c: 6b3b         	ldr	r3, [r7, #0x30]
 8005a4e: 9303         	str	r3, [sp, #0xc]
 8005a50: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8005b8c <bus_fault+0x290>
 8005a52: 9302         	str	r3, [sp, #0x8]
 8005a54: 2300         	movs	r3, #0x0
 8005a56: 9301         	str	r3, [sp, #0x4]
 8005a58: 2300         	movs	r3, #0x0
 8005a5a: 9300         	str	r3, [sp]
 8005a5c: 2300         	movs	r3, #0x0
 8005a5e: 2201         	movs	r2, #0x1
 8005a60: 2000         	movs	r0, #0x0
 8005a62: f016 fc6e    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x168dc
 8005a66: 2300         	movs	r3, #0x0
 8005a68: 62bb         	str	r3, [r7, #0x28]
; 			if (from_hard_fault != 0) {
 8005a6a: 68bb         	ldr	r3, [r7, #0x8]
 8005a6c: 2b00         	cmp	r3, #0x0
 8005a6e: d005         	beq	0x8005a7c <bus_fault+0x180> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 8005a70: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8005b7c <bus_fault+0x280>
 8005a72: 6a9b         	ldr	r3, [r3, #0x28]
 8005a74: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8005b7c <bus_fault+0x280>
 8005a76: f423 4300    	bic	r3, r3, #0x8000
 8005a7a: 6293         	str	r3, [r2, #0x28]
; 	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 8005a7c: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x8005b7c <bus_fault+0x280>
 8005a7e: 6a9b         	ldr	r3, [r3, #0x28]
 8005a80: f403 6380    	and	r3, r3, #0x400
 8005a84: 2b00         	cmp	r3, #0x0
 8005a86: d01d         	beq	0x8005ac4 <bus_fault+0x1c8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
 8005a88: 231a         	movs	r3, #0x1a
 8005a8a: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Imprecise data bus error");
 8005a8c: 2303         	movs	r3, #0x3
 8005a8e: 2b00         	cmp	r3, #0x0
 8005a90: d018         	beq	0x8005ac4 <bus_fault+0x1c8> @ imm = #0x30
 8005a92: 2301         	movs	r3, #0x1
 8005a94: f887 3027    	strb.w	r3, [r7, #0x27]
 8005a98: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8005a9c: f083 0301    	eor	r3, r3, #0x1
 8005aa0: b2db         	uxtb	r3, r3
 8005aa2: 2b00         	cmp	r3, #0x0
 8005aa4: d10e         	bne	0x8005ac4 <bus_fault+0x1c8> @ imm = #0x1c
 8005aa6: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8005b74 <bus_fault+0x278>
 8005aa8: 6819         	ldr	r1, [r3]
 8005aaa: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8005b90 <bus_fault+0x294>
 8005aac: 9302         	str	r3, [sp, #0x8]
 8005aae: 2300         	movs	r3, #0x0
 8005ab0: 9301         	str	r3, [sp, #0x4]
 8005ab2: 2300         	movs	r3, #0x0
 8005ab4: 9300         	str	r3, [sp]
 8005ab6: 2300         	movs	r3, #0x0
 8005ab8: 2201         	movs	r2, #0x1
 8005aba: 2000         	movs	r0, #0x0
 8005abc: f016 fc41    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16882
 8005ac0: 2300         	movs	r3, #0x0
 8005ac2: 623b         	str	r3, [r7, #0x20]
; 	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 8005ac4: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8005b7c <bus_fault+0x280>
 8005ac6: 6a9b         	ldr	r3, [r3, #0x28]
 8005ac8: f403 7380    	and	r3, r3, #0x100
 8005acc: 2b00         	cmp	r3, #0x0
 8005ace: d01c         	beq	0x8005b0a <bus_fault+0x20e> @ imm = #0x38
; 		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
 8005ad0: 231b         	movs	r3, #0x1b
 8005ad2: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction bus error");
 8005ad4: 2303         	movs	r3, #0x3
 8005ad6: 2b00         	cmp	r3, #0x0
 8005ad8: d039         	beq	0x8005b4e <bus_fault+0x252> @ imm = #0x72
 8005ada: 2301         	movs	r3, #0x1
 8005adc: 75fb         	strb	r3, [r7, #0x17]
 8005ade: 7dfb         	ldrb	r3, [r7, #0x17]
 8005ae0: f083 0301    	eor	r3, r3, #0x1
 8005ae4: b2db         	uxtb	r3, r3
 8005ae6: 2b00         	cmp	r3, #0x0
 8005ae8: d131         	bne	0x8005b4e <bus_fault+0x252> @ imm = #0x62
 8005aea: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8005b74 <bus_fault+0x278>
 8005aec: 6819         	ldr	r1, [r3]
 8005aee: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8005b94 <bus_fault+0x298>
 8005af0: 9302         	str	r3, [sp, #0x8]
 8005af2: 2300         	movs	r3, #0x0
 8005af4: 9301         	str	r3, [sp, #0x4]
 8005af6: 2300         	movs	r3, #0x0
 8005af8: 9300         	str	r3, [sp]
 8005afa: 2300         	movs	r3, #0x0
 8005afc: 2201         	movs	r2, #0x1
 8005afe: 2000         	movs	r0, #0x0
 8005b00: f016 fc1f    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x1683e
 8005b04: 2300         	movs	r3, #0x0
 8005b06: 613b         	str	r3, [r7, #0x10]
 8005b08: e021         	b	0x8005b4e <bus_fault+0x252> @ imm = #0x42
; 	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
 8005b0a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8005b7c <bus_fault+0x280>
 8005b0c: 6a9b         	ldr	r3, [r3, #0x28]
 8005b0e: f403 5300    	and	r3, r3, #0x2000
 8005b12: 2b00         	cmp	r3, #0x0
 8005b14: d01b         	beq	0x8005b4e <bus_fault+0x252> @ imm = #0x36
; 		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
 8005b16: 231c         	movs	r3, #0x1c
 8005b18: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Floating-point lazy state preservation error");
 8005b1a: 2303         	movs	r3, #0x3
 8005b1c: 2b00         	cmp	r3, #0x0
 8005b1e: d016         	beq	0x8005b4e <bus_fault+0x252> @ imm = #0x2c
 8005b20: 2301         	movs	r3, #0x1
 8005b22: 77fb         	strb	r3, [r7, #0x1f]
 8005b24: 7ffb         	ldrb	r3, [r7, #0x1f]
 8005b26: f083 0301    	eor	r3, r3, #0x1
 8005b2a: b2db         	uxtb	r3, r3
 8005b2c: 2b00         	cmp	r3, #0x0
 8005b2e: d10e         	bne	0x8005b4e <bus_fault+0x252> @ imm = #0x1c
 8005b30: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8005b74 <bus_fault+0x278>
 8005b32: 6819         	ldr	r1, [r3]
 8005b34: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8005b98 <bus_fault+0x29c>
 8005b36: 9302         	str	r3, [sp, #0x8]
 8005b38: 2300         	movs	r3, #0x0
 8005b3a: 9301         	str	r3, [sp, #0x4]
 8005b3c: 2300         	movs	r3, #0x0
 8005b3e: 9300         	str	r3, [sp]
 8005b40: 2300         	movs	r3, #0x0
 8005b42: 2201         	movs	r2, #0x1
 8005b44: 2000         	movs	r0, #0x0
 8005b46: f016 fbfc    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x167f8
 8005b4a: 2300         	movs	r3, #0x0
 8005b4c: 61bb         	str	r3, [r7, #0x18]
; 	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 8005b4e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8005b7c <bus_fault+0x280>
 8005b50: 6a9b         	ldr	r3, [r3, #0x28]
 8005b52: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8005b7c <bus_fault+0x280>
 8005b54: f443 437f    	orr	r3, r3, #0xff00
 8005b58: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 8005b5a: 2101         	movs	r1, #0x1
 8005b5c: 68f8         	ldr	r0, [r7, #0xc]
 8005b5e: f016 fc19    	bl	0x801c394 <memory_fault_recoverable> @ imm = #0x16832
 8005b62: 4603         	mov	r3, r0
 8005b64: 461a         	mov	r2, r3
 8005b66: 687b         	ldr	r3, [r7, #0x4]
 8005b68: 701a         	strb	r2, [r3]
; 	return reason;
 8005b6a: 6d7b         	ldr	r3, [r7, #0x54]
; }
 8005b6c: 4618         	mov	r0, r3
 8005b6e: 3758         	adds	r7, #0x58
 8005b70: 46bd         	mov	sp, r7
 8005b72: bd80         	pop	{r7, pc}

08005b74 <$d>:
 8005b74: f4 04 00 20  	.word	0x200004f4
 8005b78: 88 87 02 08  	.word	0x08028788
 8005b7c: 00 ed 00 e0  	.word	0xe000ed00
 8005b80: a0 87 02 08  	.word	0x080287a0
 8005b84: f4 86 02 08  	.word	0x080286f4
 8005b88: b4 87 02 08  	.word	0x080287b4
 8005b8c: d0 87 02 08  	.word	0x080287d0
 8005b90: e8 87 02 08  	.word	0x080287e8
 8005b94: 04 88 02 08  	.word	0x08028804
 8005b98: 58 87 02 08  	.word	0x08028758

08005b9c <usage_fault>:
; {
 8005b9c: b580         	push	{r7, lr}
 8005b9e: b096         	sub	sp, #0x58
 8005ba0: af04         	add	r7, sp, #0x10
 8005ba2: 6078         	str	r0, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
 8005ba4: 231d         	movs	r3, #0x1d
 8005ba6: 647b         	str	r3, [r7, #0x44]
; 	PR_FAULT_INFO("***** USAGE FAULT *****");
 8005ba8: 2303         	movs	r3, #0x3
 8005baa: 2b00         	cmp	r3, #0x0
 8005bac: d018         	beq	0x8005be0 <usage_fault+0x44> @ imm = #0x30
 8005bae: 2301         	movs	r3, #0x1
 8005bb0: f887 3043    	strb.w	r3, [r7, #0x43]
 8005bb4: f897 3043    	ldrb.w	r3, [r7, #0x43]
 8005bb8: f083 0301    	eor	r3, r3, #0x1
 8005bbc: b2db         	uxtb	r3, r3
 8005bbe: 2b00         	cmp	r3, #0x0
 8005bc0: d10e         	bne	0x8005be0 <usage_fault+0x44> @ imm = #0x1c
 8005bc2: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8005da4 <usage_fault+0x208>
 8005bc4: 6819         	ldr	r1, [r3]
 8005bc6: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8005da8 <usage_fault+0x20c>
 8005bc8: 9302         	str	r3, [sp, #0x8]
 8005bca: 2300         	movs	r3, #0x0
 8005bcc: 9301         	str	r3, [sp, #0x4]
 8005bce: 2300         	movs	r3, #0x0
 8005bd0: 9300         	str	r3, [sp]
 8005bd2: 2300         	movs	r3, #0x0
 8005bd4: 2201         	movs	r2, #0x1
 8005bd6: 2000         	movs	r0, #0x0
 8005bd8: f016 fbb3    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16766
 8005bdc: 2300         	movs	r3, #0x0
 8005bde: 63fb         	str	r3, [r7, #0x3c]
; 	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 8005be0: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8005dac <usage_fault+0x210>
 8005be2: 6a9b         	ldr	r3, [r3, #0x28]
 8005be4: f003 7300    	and	r3, r3, #0x2000000
 8005be8: 2b00         	cmp	r3, #0x0
 8005bea: d01d         	beq	0x8005c28 <usage_fault+0x8c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_DIV_0;
 8005bec: 231e         	movs	r3, #0x1e
 8005bee: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Division by zero");
 8005bf0: 2303         	movs	r3, #0x3
 8005bf2: 2b00         	cmp	r3, #0x0
 8005bf4: d018         	beq	0x8005c28 <usage_fault+0x8c> @ imm = #0x30
 8005bf6: 2301         	movs	r3, #0x1
 8005bf8: f887 303b    	strb.w	r3, [r7, #0x3b]
 8005bfc: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8005c00: f083 0301    	eor	r3, r3, #0x1
 8005c04: b2db         	uxtb	r3, r3
 8005c06: 2b00         	cmp	r3, #0x0
 8005c08: d10e         	bne	0x8005c28 <usage_fault+0x8c> @ imm = #0x1c
 8005c0a: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8005da4 <usage_fault+0x208>
 8005c0c: 6819         	ldr	r1, [r3]
 8005c0e: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8005db0 <usage_fault+0x214>
 8005c10: 9302         	str	r3, [sp, #0x8]
 8005c12: 2300         	movs	r3, #0x0
 8005c14: 9301         	str	r3, [sp, #0x4]
 8005c16: 2300         	movs	r3, #0x0
 8005c18: 9300         	str	r3, [sp]
 8005c1a: 2300         	movs	r3, #0x0
 8005c1c: 2201         	movs	r2, #0x1
 8005c1e: 2000         	movs	r0, #0x0
 8005c20: f016 fb8f    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x1671e
 8005c24: 2300         	movs	r3, #0x0
 8005c26: 637b         	str	r3, [r7, #0x34]
; 	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 8005c28: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8005dac <usage_fault+0x210>
 8005c2a: 6a9b         	ldr	r3, [r3, #0x28]
 8005c2c: f003 7380    	and	r3, r3, #0x1000000
 8005c30: 2b00         	cmp	r3, #0x0
 8005c32: d01d         	beq	0x8005c70 <usage_fault+0xd4> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
 8005c34: 231f         	movs	r3, #0x1f
 8005c36: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Unaligned memory access");
 8005c38: 2303         	movs	r3, #0x3
 8005c3a: 2b00         	cmp	r3, #0x0
 8005c3c: d018         	beq	0x8005c70 <usage_fault+0xd4> @ imm = #0x30
 8005c3e: 2301         	movs	r3, #0x1
 8005c40: f887 3033    	strb.w	r3, [r7, #0x33]
 8005c44: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8005c48: f083 0301    	eor	r3, r3, #0x1
 8005c4c: b2db         	uxtb	r3, r3
 8005c4e: 2b00         	cmp	r3, #0x0
 8005c50: d10e         	bne	0x8005c70 <usage_fault+0xd4> @ imm = #0x1c
 8005c52: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8005da4 <usage_fault+0x208>
 8005c54: 6819         	ldr	r1, [r3]
 8005c56: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8005db4 <usage_fault+0x218>
 8005c58: 9302         	str	r3, [sp, #0x8]
 8005c5a: 2300         	movs	r3, #0x0
 8005c5c: 9301         	str	r3, [sp, #0x4]
 8005c5e: 2300         	movs	r3, #0x0
 8005c60: 9300         	str	r3, [sp]
 8005c62: 2300         	movs	r3, #0x0
 8005c64: 2201         	movs	r2, #0x1
 8005c66: 2000         	movs	r0, #0x0
 8005c68: f016 fb6b    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x166d6
 8005c6c: 2300         	movs	r3, #0x0
 8005c6e: 62fb         	str	r3, [r7, #0x2c]
; 	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 8005c70: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8005dac <usage_fault+0x210>
 8005c72: 6a9b         	ldr	r3, [r3, #0x28]
 8005c74: f403 2300    	and	r3, r3, #0x80000
 8005c78: 2b00         	cmp	r3, #0x0
 8005c7a: d01d         	beq	0x8005cb8 <usage_fault+0x11c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
 8005c7c: 2321         	movs	r3, #0x21
 8005c7e: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  No coprocessor instructions");
 8005c80: 2303         	movs	r3, #0x3
 8005c82: 2b00         	cmp	r3, #0x0
 8005c84: d018         	beq	0x8005cb8 <usage_fault+0x11c> @ imm = #0x30
 8005c86: 2301         	movs	r3, #0x1
 8005c88: f887 302b    	strb.w	r3, [r7, #0x2b]
 8005c8c: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8005c90: f083 0301    	eor	r3, r3, #0x1
 8005c94: b2db         	uxtb	r3, r3
 8005c96: 2b00         	cmp	r3, #0x0
 8005c98: d10e         	bne	0x8005cb8 <usage_fault+0x11c> @ imm = #0x1c
 8005c9a: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8005da4 <usage_fault+0x208>
 8005c9c: 6819         	ldr	r1, [r3]
 8005c9e: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8005db8 <usage_fault+0x21c>
 8005ca0: 9302         	str	r3, [sp, #0x8]
 8005ca2: 2300         	movs	r3, #0x0
 8005ca4: 9301         	str	r3, [sp, #0x4]
 8005ca6: 2300         	movs	r3, #0x0
 8005ca8: 9300         	str	r3, [sp]
 8005caa: 2300         	movs	r3, #0x0
 8005cac: 2201         	movs	r2, #0x1
 8005cae: 2000         	movs	r0, #0x0
 8005cb0: f016 fb47    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x1668e
 8005cb4: 2300         	movs	r3, #0x0
 8005cb6: 627b         	str	r3, [r7, #0x24]
; 	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 8005cb8: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8005dac <usage_fault+0x210>
 8005cba: 6a9b         	ldr	r3, [r3, #0x28]
 8005cbc: f403 2380    	and	r3, r3, #0x40000
 8005cc0: 2b00         	cmp	r3, #0x0
 8005cc2: d01d         	beq	0x8005d00 <usage_fault+0x164> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
 8005cc4: 2322         	movs	r3, #0x22
 8005cc6: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
 8005cc8: 2303         	movs	r3, #0x3
 8005cca: 2b00         	cmp	r3, #0x0
 8005ccc: d018         	beq	0x8005d00 <usage_fault+0x164> @ imm = #0x30
 8005cce: 2301         	movs	r3, #0x1
 8005cd0: f887 3023    	strb.w	r3, [r7, #0x23]
 8005cd4: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8005cd8: f083 0301    	eor	r3, r3, #0x1
 8005cdc: b2db         	uxtb	r3, r3
 8005cde: 2b00         	cmp	r3, #0x0
 8005ce0: d10e         	bne	0x8005d00 <usage_fault+0x164> @ imm = #0x1c
 8005ce2: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8005da4 <usage_fault+0x208>
 8005ce4: 6819         	ldr	r1, [r3]
 8005ce6: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8005dbc <usage_fault+0x220>
 8005ce8: 9302         	str	r3, [sp, #0x8]
 8005cea: 2300         	movs	r3, #0x0
 8005cec: 9301         	str	r3, [sp, #0x4]
 8005cee: 2300         	movs	r3, #0x0
 8005cf0: 9300         	str	r3, [sp]
 8005cf2: 2300         	movs	r3, #0x0
 8005cf4: 2201         	movs	r2, #0x1
 8005cf6: 2000         	movs	r0, #0x0
 8005cf8: f016 fb23    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16646
 8005cfc: 2300         	movs	r3, #0x0
 8005cfe: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 8005d00: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8005dac <usage_fault+0x210>
 8005d02: 6a9b         	ldr	r3, [r3, #0x28]
 8005d04: f403 3300    	and	r3, r3, #0x20000
 8005d08: 2b00         	cmp	r3, #0x0
 8005d0a: d01b         	beq	0x8005d44 <usage_fault+0x1a8> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
 8005d0c: 2323         	movs	r3, #0x23
 8005d0e: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal use of the EPSR");
 8005d10: 2303         	movs	r3, #0x3
 8005d12: 2b00         	cmp	r3, #0x0
 8005d14: d016         	beq	0x8005d44 <usage_fault+0x1a8> @ imm = #0x2c
 8005d16: 2301         	movs	r3, #0x1
 8005d18: 76fb         	strb	r3, [r7, #0x1b]
 8005d1a: 7efb         	ldrb	r3, [r7, #0x1b]
 8005d1c: f083 0301    	eor	r3, r3, #0x1
 8005d20: b2db         	uxtb	r3, r3
 8005d22: 2b00         	cmp	r3, #0x0
 8005d24: d10e         	bne	0x8005d44 <usage_fault+0x1a8> @ imm = #0x1c
 8005d26: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8005da4 <usage_fault+0x208>
 8005d28: 6819         	ldr	r1, [r3]
 8005d2a: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8005dc0 <usage_fault+0x224>
 8005d2c: 9302         	str	r3, [sp, #0x8]
 8005d2e: 2300         	movs	r3, #0x0
 8005d30: 9301         	str	r3, [sp, #0x4]
 8005d32: 2300         	movs	r3, #0x0
 8005d34: 9300         	str	r3, [sp]
 8005d36: 2300         	movs	r3, #0x0
 8005d38: 2201         	movs	r2, #0x1
 8005d3a: 2000         	movs	r0, #0x0
 8005d3c: f016 fb01    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16602
 8005d40: 2300         	movs	r3, #0x0
 8005d42: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 8005d44: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8005dac <usage_fault+0x210>
 8005d46: 6a9b         	ldr	r3, [r3, #0x28]
 8005d48: f403 3380    	and	r3, r3, #0x10000
 8005d4c: 2b00         	cmp	r3, #0x0
 8005d4e: d01b         	beq	0x8005d88 <usage_fault+0x1ec> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
 8005d50: 2324         	movs	r3, #0x24
 8005d52: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Attempt to execute undefined instruction");
 8005d54: 2303         	movs	r3, #0x3
 8005d56: 2b00         	cmp	r3, #0x0
 8005d58: d016         	beq	0x8005d88 <usage_fault+0x1ec> @ imm = #0x2c
 8005d5a: 2301         	movs	r3, #0x1
 8005d5c: 74fb         	strb	r3, [r7, #0x13]
 8005d5e: 7cfb         	ldrb	r3, [r7, #0x13]
 8005d60: f083 0301    	eor	r3, r3, #0x1
 8005d64: b2db         	uxtb	r3, r3
 8005d66: 2b00         	cmp	r3, #0x0
 8005d68: d10e         	bne	0x8005d88 <usage_fault+0x1ec> @ imm = #0x1c
 8005d6a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8005da4 <usage_fault+0x208>
 8005d6c: 6819         	ldr	r1, [r3]
 8005d6e: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8005dc4 <usage_fault+0x228>
 8005d70: 9302         	str	r3, [sp, #0x8]
 8005d72: 2300         	movs	r3, #0x0
 8005d74: 9301         	str	r3, [sp, #0x4]
 8005d76: 2300         	movs	r3, #0x0
 8005d78: 9300         	str	r3, [sp]
 8005d7a: 2300         	movs	r3, #0x0
 8005d7c: 2201         	movs	r2, #0x1
 8005d7e: 2000         	movs	r0, #0x0
 8005d80: f016 fadf    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x165be
 8005d84: 2300         	movs	r3, #0x0
 8005d86: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 8005d88: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8005dac <usage_fault+0x210>
 8005d8a: 6a9b         	ldr	r3, [r3, #0x28]
 8005d8c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8005dac <usage_fault+0x210>
 8005d8e: ea6f 4303    	mvn.w	r3, r3, lsl #16
 8005d92: ea6f 4313    	mvn.w	r3, r3, lsr #16
 8005d96: 6293         	str	r3, [r2, #0x28]
; 	return reason;
 8005d98: 6c7b         	ldr	r3, [r7, #0x44]
; }
 8005d9a: 4618         	mov	r0, r3
 8005d9c: 3748         	adds	r7, #0x48
 8005d9e: 46bd         	mov	sp, r7
 8005da0: bd80         	pop	{r7, pc}
 8005da2: bf00         	nop

08005da4 <$d>:
 8005da4: f4 04 00 20  	.word	0x200004f4
 8005da8: 1c 88 02 08  	.word	0x0802881c
 8005dac: 00 ed 00 e0  	.word	0xe000ed00
 8005db0: 34 88 02 08  	.word	0x08028834
 8005db4: 48 88 02 08  	.word	0x08028848
 8005db8: 64 88 02 08  	.word	0x08028864
 8005dbc: 84 88 02 08  	.word	0x08028884
 8005dc0: ac 88 02 08  	.word	0x080288ac
 8005dc4: c8 88 02 08  	.word	0x080288c8

08005dc8 <debug_monitor>:
; {
 8005dc8: b580         	push	{r7, lr}
 8005dca: b088         	sub	sp, #0x20
 8005dcc: af04         	add	r7, sp, #0x10
 8005dce: 6078         	str	r0, [r7, #0x4]
 8005dd0: 6039         	str	r1, [r7]
; 	*recoverable = false;
 8005dd2: 683b         	ldr	r3, [r7]
 8005dd4: 2200         	movs	r2, #0x0
 8005dd6: 701a         	strb	r2, [r3]
; 	PR_FAULT_INFO(
 8005dd8: 2303         	movs	r3, #0x3
 8005dda: 2b00         	cmp	r3, #0x0
 8005ddc: d017         	beq	0x8005e0e <debug_monitor+0x46> @ imm = #0x2e
 8005dde: 2301         	movs	r3, #0x1
 8005de0: 73fb         	strb	r3, [r7, #0xf]
 8005de2: 7bfb         	ldrb	r3, [r7, #0xf]
 8005de4: f083 0301    	eor	r3, r3, #0x1
 8005de8: b2db         	uxtb	r3, r3
 8005dea: 2b00         	cmp	r3, #0x0
 8005dec: d10f         	bne	0x8005e0e <debug_monitor+0x46> @ imm = #0x1e
 8005dee: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8005e18 <debug_monitor+0x50>
 8005df0: 6819         	ldr	r1, [r3]
 8005df2: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8005e1c <debug_monitor+0x54>
 8005df4: 9302         	str	r3, [sp, #0x8]
 8005df6: 2300         	movs	r3, #0x0
 8005df8: 9301         	str	r3, [sp, #0x4]
 8005dfa: 2300         	movs	r3, #0x0
 8005dfc: 9300         	str	r3, [sp]
 8005dfe: 2300         	movs	r3, #0x0
 8005e00: 2201         	movs	r2, #0x1
 8005e02: 2000         	movs	r0, #0x0
 8005e04: f016 fa9d    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x1653a
 8005e08: 2300         	movs	r3, #0x0
 8005e0a: 60bb         	str	r3, [r7, #0x8]
; }
 8005e0c: bf00         	nop
 8005e0e: bf00         	nop
 8005e10: 3710         	adds	r7, #0x10
 8005e12: 46bd         	mov	sp, r7
 8005e14: bd80         	pop	{r7, pc}
 8005e16: bf00         	nop

08005e18 <$d>:
 8005e18: f4 04 00 20  	.word	0x200004f4
 8005e1c: f4 88 02 08  	.word	0x080288f4

08005e20 <z_arm_is_synchronous_svc>:
; {
 8005e20: b480         	push	{r7}
 8005e22: b085         	sub	sp, #0x14
 8005e24: af00         	add	r7, sp, #0x0
 8005e26: 6078         	str	r0, [r7, #0x4]
; 	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
 8005e28: 687b         	ldr	r3, [r7, #0x4]
 8005e2a: 699b         	ldr	r3, [r3, #0x18]
 8005e2c: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
 8005e2e: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8005e9c <z_arm_is_synchronous_svc+0x7c>
 8005e30: 695b         	ldr	r3, [r3, #0x14]
 8005e32: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x8005e9c <z_arm_is_synchronous_svc+0x7c>
 8005e34: f443 7380    	orr	r3, r3, #0x100
 8005e38: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 8005e3a: f3bf 8f4f    	dsb	sy
; }
 8005e3e: bf00         	nop
; }
 8005e40: bf00         	nop
; }
 8005e42: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8005e44: f3bf 8f6f    	isb	sy
; }
 8005e48: bf00         	nop
; }
 8005e4a: bf00         	nop
; }
 8005e4c: bf00         	nop
; 	uint16_t fault_insn = *(ret_addr - 1);
 8005e4e: 68fb         	ldr	r3, [r7, #0xc]
 8005e50: f833 3c02    	ldrh	r3, [r3, #-2]
 8005e54: 817b         	strh	r3, [r7, #0xa]
; 	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
 8005e56: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8005e9c <z_arm_is_synchronous_svc+0x7c>
 8005e58: 695b         	ldr	r3, [r3, #0x14]
 8005e5a: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8005e9c <z_arm_is_synchronous_svc+0x7c>
 8005e5c: f423 7380    	bic	r3, r3, #0x100
 8005e60: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 8005e62: f3bf 8f4f    	dsb	sy
; }
 8005e66: bf00         	nop
; }
 8005e68: bf00         	nop
; }
 8005e6a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8005e6c: f3bf 8f6f    	isb	sy
; }
 8005e70: bf00         	nop
; }
 8005e72: bf00         	nop
; }
 8005e74: bf00         	nop
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 8005e76: 897b         	ldrh	r3, [r7, #0xa]
 8005e78: f403 437f    	and	r3, r3, #0xff00
 8005e7c: f5b3 4f5f    	cmp.w	r3, #0xdf00
 8005e80: d105         	bne	0x8005e8e <z_arm_is_synchronous_svc+0x6e> @ imm = #0xa
; 		((fault_insn & 0x00ff) == _SVC_CALL_RUNTIME_EXCEPT)) {
 8005e82: 897b         	ldrh	r3, [r7, #0xa]
 8005e84: b2db         	uxtb	r3, r3
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 8005e86: 2b02         	cmp	r3, #0x2
 8005e88: d101         	bne	0x8005e8e <z_arm_is_synchronous_svc+0x6e> @ imm = #0x2
; 		return true;
 8005e8a: 2301         	movs	r3, #0x1
 8005e8c: e000         	b	0x8005e90 <z_arm_is_synchronous_svc+0x70> @ imm = #0x0
; 	return false;
 8005e8e: 2300         	movs	r3, #0x0
; }
 8005e90: 4618         	mov	r0, r3
 8005e92: 3714         	adds	r7, #0x14
 8005e94: 46bd         	mov	sp, r7
 8005e96: f85d 7b04    	ldr	r7, [sp], #4
 8005e9a: 4770         	bx	lr

08005e9c <$d>:
 8005e9c: 00 ed 00 e0  	.word	0xe000ed00

08005ea0 <hard_fault>:
; {
 8005ea0: b580         	push	{r7, lr}
 8005ea2: b092         	sub	sp, #0x48
 8005ea4: af04         	add	r7, sp, #0x10
 8005ea6: 6078         	str	r0, [r7, #0x4]
 8005ea8: 6039         	str	r1, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8005eaa: 2300         	movs	r3, #0x0
 8005eac: 62fb         	str	r3, [r7, #0x2c]
; 	PR_FAULT_INFO("***** HARD FAULT *****");
 8005eae: 2303         	movs	r3, #0x3
 8005eb0: 2b00         	cmp	r3, #0x0
 8005eb2: d018         	beq	0x8005ee6 <hard_fault+0x46> @ imm = #0x30
 8005eb4: 2301         	movs	r3, #0x1
 8005eb6: f887 3033    	strb.w	r3, [r7, #0x33]
 8005eba: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8005ebe: f083 0301    	eor	r3, r3, #0x1
 8005ec2: b2db         	uxtb	r3, r3
 8005ec4: 2b00         	cmp	r3, #0x0
 8005ec6: d10e         	bne	0x8005ee6 <hard_fault+0x46> @ imm = #0x1c
 8005ec8: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8006058 <hard_fault+0x1b8>
 8005eca: 6819         	ldr	r1, [r3]
 8005ecc: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x800605c <hard_fault+0x1bc>
 8005ece: 9302         	str	r3, [sp, #0x8]
 8005ed0: 2300         	movs	r3, #0x0
 8005ed2: 9301         	str	r3, [sp, #0x4]
 8005ed4: 2300         	movs	r3, #0x0
 8005ed6: 9300         	str	r3, [sp]
 8005ed8: 2300         	movs	r3, #0x0
 8005eda: 2201         	movs	r2, #0x1
 8005edc: 2000         	movs	r0, #0x0
 8005ede: f016 fa30    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16460
 8005ee2: 2300         	movs	r3, #0x0
 8005ee4: 637b         	str	r3, [r7, #0x34]
; 	*recoverable = false;
 8005ee6: 683b         	ldr	r3, [r7]
 8005ee8: 2200         	movs	r2, #0x0
 8005eea: 701a         	strb	r2, [r3]
; 	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 8005eec: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8006060 <hard_fault+0x1c0>
 8005eee: 6adb         	ldr	r3, [r3, #0x2c]
 8005ef0: f003 0302    	and	r3, r3, #0x2
 8005ef4: 2b00         	cmp	r3, #0x0
 8005ef6: d01c         	beq	0x8005f32 <hard_fault+0x92> @ imm = #0x38
; 		PR_EXC("  Bus fault on vector table read");
 8005ef8: 2303         	movs	r3, #0x3
 8005efa: 2b00         	cmp	r3, #0x0
 8005efc: f000 80a7    	beq.w	0x800604e <hard_fault+0x1ae> @ imm = #0x14e
 8005f00: 2301         	movs	r3, #0x1
 8005f02: 74fb         	strb	r3, [r7, #0x13]
 8005f04: 7cfb         	ldrb	r3, [r7, #0x13]
 8005f06: f083 0301    	eor	r3, r3, #0x1
 8005f0a: b2db         	uxtb	r3, r3
 8005f0c: 2b00         	cmp	r3, #0x0
 8005f0e: f040 809e    	bne.w	0x800604e <hard_fault+0x1ae> @ imm = #0x13c
 8005f12: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8006058 <hard_fault+0x1b8>
 8005f14: 6819         	ldr	r1, [r3]
 8005f16: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8006064 <hard_fault+0x1c4>
 8005f18: 9302         	str	r3, [sp, #0x8]
 8005f1a: 2300         	movs	r3, #0x0
 8005f1c: 9301         	str	r3, [sp, #0x4]
 8005f1e: 2300         	movs	r3, #0x0
 8005f20: 9300         	str	r3, [sp]
 8005f22: 2300         	movs	r3, #0x0
 8005f24: 2201         	movs	r2, #0x1
 8005f26: 2000         	movs	r0, #0x0
 8005f28: f016 fa0b    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16416
 8005f2c: 2300         	movs	r3, #0x0
 8005f2e: 60fb         	str	r3, [r7, #0xc]
 8005f30: e08d         	b	0x800604e <hard_fault+0x1ae> @ imm = #0x11a
; 	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
 8005f32: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8006060 <hard_fault+0x1c0>
 8005f34: 6adb         	ldr	r3, [r3, #0x2c]
 8005f36: 2b00         	cmp	r3, #0x0
 8005f38: da1b         	bge	0x8005f72 <hard_fault+0xd2> @ imm = #0x36
; 		PR_EXC("  Debug event");
 8005f3a: 2303         	movs	r3, #0x3
 8005f3c: 2b00         	cmp	r3, #0x0
 8005f3e: f000 8086    	beq.w	0x800604e <hard_fault+0x1ae> @ imm = #0x10c
 8005f42: 2301         	movs	r3, #0x1
 8005f44: 76fb         	strb	r3, [r7, #0x1b]
 8005f46: 7efb         	ldrb	r3, [r7, #0x1b]
 8005f48: f083 0301    	eor	r3, r3, #0x1
 8005f4c: b2db         	uxtb	r3, r3
 8005f4e: 2b00         	cmp	r3, #0x0
 8005f50: d17d         	bne	0x800604e <hard_fault+0x1ae> @ imm = #0xfa
 8005f52: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8006058 <hard_fault+0x1b8>
 8005f54: 6819         	ldr	r1, [r3]
 8005f56: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8006068 <hard_fault+0x1c8>
 8005f58: 9302         	str	r3, [sp, #0x8]
 8005f5a: 2300         	movs	r3, #0x0
 8005f5c: 9301         	str	r3, [sp, #0x4]
 8005f5e: 2300         	movs	r3, #0x0
 8005f60: 9300         	str	r3, [sp]
 8005f62: 2300         	movs	r3, #0x0
 8005f64: 2201         	movs	r2, #0x1
 8005f66: 2000         	movs	r0, #0x0
 8005f68: f016 f9eb    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x163d6
 8005f6c: 2300         	movs	r3, #0x0
 8005f6e: 617b         	str	r3, [r7, #0x14]
 8005f70: e06d         	b	0x800604e <hard_fault+0x1ae> @ imm = #0xda
; 	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 8005f72: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8006060 <hard_fault+0x1c0>
 8005f74: 6adb         	ldr	r3, [r3, #0x2c]
 8005f76: f003 4380    	and	r3, r3, #0x40000000
 8005f7a: 2b00         	cmp	r3, #0x0
 8005f7c: d067         	beq	0x800604e <hard_fault+0x1ae> @ imm = #0xce
; 		PR_EXC("  Fault escalation (see below)");
 8005f7e: 2303         	movs	r3, #0x3
 8005f80: 2b00         	cmp	r3, #0x0
 8005f82: d018         	beq	0x8005fb6 <hard_fault+0x116> @ imm = #0x30
 8005f84: 2301         	movs	r3, #0x1
 8005f86: f887 302b    	strb.w	r3, [r7, #0x2b]
 8005f8a: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8005f8e: f083 0301    	eor	r3, r3, #0x1
 8005f92: b2db         	uxtb	r3, r3
 8005f94: 2b00         	cmp	r3, #0x0
 8005f96: d10e         	bne	0x8005fb6 <hard_fault+0x116> @ imm = #0x1c
 8005f98: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8006058 <hard_fault+0x1b8>
 8005f9a: 6819         	ldr	r1, [r3]
 8005f9c: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800606c <hard_fault+0x1cc>
 8005f9e: 9302         	str	r3, [sp, #0x8]
 8005fa0: 2300         	movs	r3, #0x0
 8005fa2: 9301         	str	r3, [sp, #0x4]
 8005fa4: 2300         	movs	r3, #0x0
 8005fa6: 9300         	str	r3, [sp]
 8005fa8: 2300         	movs	r3, #0x0
 8005faa: 2201         	movs	r2, #0x1
 8005fac: 2000         	movs	r0, #0x0
 8005fae: f016 f9c8    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16390
 8005fb2: 2300         	movs	r3, #0x0
 8005fb4: 627b         	str	r3, [r7, #0x24]
; 		if (z_arm_is_synchronous_svc(esf)) {
 8005fb6: 6878         	ldr	r0, [r7, #0x4]
 8005fb8: f7ff ff32    	bl	0x8005e20 <z_arm_is_synchronous_svc> @ imm = #-0x19c
 8005fbc: 4603         	mov	r3, r0
 8005fbe: 2b00         	cmp	r3, #0x0
 8005fc0: d022         	beq	0x8006008 <hard_fault+0x168> @ imm = #0x44
; 			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
 8005fc2: 2303         	movs	r3, #0x3
 8005fc4: 2b00         	cmp	r3, #0x0
 8005fc6: d01b         	beq	0x8006000 <hard_fault+0x160> @ imm = #0x36
 8005fc8: 2301         	movs	r3, #0x1
 8005fca: f887 3023    	strb.w	r3, [r7, #0x23]
 8005fce: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8005fd2: f083 0301    	eor	r3, r3, #0x1
 8005fd6: b2db         	uxtb	r3, r3
 8005fd8: 2b00         	cmp	r3, #0x0
 8005fda: d111         	bne	0x8006000 <hard_fault+0x160> @ imm = #0x22
 8005fdc: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8006058 <hard_fault+0x1b8>
 8005fde: 6819         	ldr	r1, [r3]
 8005fe0: 687b         	ldr	r3, [r7, #0x4]
 8005fe2: 681b         	ldr	r3, [r3]
 8005fe4: 9303         	str	r3, [sp, #0xc]
 8005fe6: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8006070 <hard_fault+0x1d0>
 8005fe8: 9302         	str	r3, [sp, #0x8]
 8005fea: 2300         	movs	r3, #0x0
 8005fec: 9301         	str	r3, [sp, #0x4]
 8005fee: 2300         	movs	r3, #0x0
 8005ff0: 9300         	str	r3, [sp]
 8005ff2: 2300         	movs	r3, #0x0
 8005ff4: 2201         	movs	r2, #0x1
 8005ff6: 2000         	movs	r0, #0x0
 8005ff8: f016 f9a3    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16346
 8005ffc: 2300         	movs	r3, #0x0
 8005ffe: 61fb         	str	r3, [r7, #0x1c]
; 			reason = esf->basic.r0;
 8006000: 687b         	ldr	r3, [r7, #0x4]
 8006002: 681b         	ldr	r3, [r3]
 8006004: 62fb         	str	r3, [r7, #0x2c]
 8006006: e022         	b	0x800604e <hard_fault+0x1ae> @ imm = #0x44
; 		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
 8006008: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8006060 <hard_fault+0x1c0>
 800600a: 6a9b         	ldr	r3, [r3, #0x28]
 800600c: b2db         	uxtb	r3, r3
 800600e: 2b00         	cmp	r3, #0x0
 8006010: d006         	beq	0x8006020 <hard_fault+0x180> @ imm = #0xc
; 			reason = mem_manage_fault(esf, 1, recoverable);
 8006012: 683a         	ldr	r2, [r7]
 8006014: 2101         	movs	r1, #0x1
 8006016: 6878         	ldr	r0, [r7, #0x4]
 8006018: f7ff fb2c    	bl	0x8005674 <mem_manage_fault> @ imm = #-0x9a8
 800601c: 62f8         	str	r0, [r7, #0x2c]
 800601e: e016         	b	0x800604e <hard_fault+0x1ae> @ imm = #0x2c
; 		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
 8006020: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8006060 <hard_fault+0x1c0>
 8006022: 6a9b         	ldr	r3, [r3, #0x28]
 8006024: f403 437f    	and	r3, r3, #0xff00
 8006028: 2b00         	cmp	r3, #0x0
 800602a: d007         	beq	0x800603c <hard_fault+0x19c> @ imm = #0xe
; 			reason = bus_fault(esf, 1, recoverable);
 800602c: 683a         	ldr	r2, [r7]
 800602e: 2101         	movs	r1, #0x1
 8006030: 6878         	ldr	r0, [r7, #0x4]
 8006032: f7ff fc63    	bl	0x80058fc <bus_fault>   @ imm = #-0x73a
 8006036: 4603         	mov	r3, r0
 8006038: 62fb         	str	r3, [r7, #0x2c]
 800603a: e008         	b	0x800604e <hard_fault+0x1ae> @ imm = #0x10
; 		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
 800603c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8006060 <hard_fault+0x1c0>
 800603e: 6a9b         	ldr	r3, [r3, #0x28]
 8006040: f5b3 3f80    	cmp.w	r3, #0x10000
 8006044: d303         	blo	0x800604e <hard_fault+0x1ae> @ imm = #0x6
; 			reason = usage_fault(esf);
 8006046: 6878         	ldr	r0, [r7, #0x4]
 8006048: f7ff fda8    	bl	0x8005b9c <usage_fault> @ imm = #-0x4b0
 800604c: 62f8         	str	r0, [r7, #0x2c]
; 	return reason;
 800604e: 6afb         	ldr	r3, [r7, #0x2c]
; }
 8006050: 4618         	mov	r0, r3
 8006052: 3738         	adds	r7, #0x38
 8006054: 46bd         	mov	sp, r7
 8006056: bd80         	pop	{r7, pc}

08006058 <$d>:
 8006058: f4 04 00 20  	.word	0x200004f4
 800605c: 18 89 02 08  	.word	0x08028918
 8006060: 00 ed 00 e0  	.word	0xe000ed00
 8006064: 30 89 02 08  	.word	0x08028930
 8006068: 54 89 02 08  	.word	0x08028954
 800606c: 64 89 02 08  	.word	0x08028964
 8006070: 84 89 02 08  	.word	0x08028984

08006074 <reserved_exception>:
; {
 8006074: b580         	push	{r7, lr}
 8006076: b08a         	sub	sp, #0x28
 8006078: af06         	add	r7, sp, #0x18
 800607a: 6078         	str	r0, [r7, #0x4]
 800607c: 6039         	str	r1, [r7]
; 	PR_FAULT_INFO("***** %s %d) *****",
 800607e: 2303         	movs	r3, #0x3
 8006080: 2b00         	cmp	r3, #0x0
 8006082: d021         	beq	0x80060c8 <reserved_exception+0x54> @ imm = #0x42
 8006084: 2301         	movs	r3, #0x1
 8006086: 73fb         	strb	r3, [r7, #0xf]
 8006088: 7bfb         	ldrb	r3, [r7, #0xf]
 800608a: f083 0301    	eor	r3, r3, #0x1
 800608e: b2db         	uxtb	r3, r3
 8006090: 2b00         	cmp	r3, #0x0
 8006092: d119         	bne	0x80060c8 <reserved_exception+0x54> @ imm = #0x32
 8006094: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80060d0 <reserved_exception+0x5c>
 8006096: 6819         	ldr	r1, [r3]
 8006098: 683b         	ldr	r3, [r7]
 800609a: 2b0f         	cmp	r3, #0xf
 800609c: dc01         	bgt	0x80060a2 <reserved_exception+0x2e> @ imm = #0x2
 800609e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80060d4 <reserved_exception+0x60>
 80060a0: e000         	b	0x80060a4 <reserved_exception+0x30> @ imm = #0x0
 80060a2: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80060d8 <reserved_exception+0x64>
 80060a4: 683a         	ldr	r2, [r7]
 80060a6: 3a10         	subs	r2, #0x10
 80060a8: 9204         	str	r2, [sp, #0x10]
 80060aa: 9303         	str	r3, [sp, #0xc]
 80060ac: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80060dc <reserved_exception+0x68>
 80060ae: 9302         	str	r3, [sp, #0x8]
 80060b0: 2300         	movs	r3, #0x0
 80060b2: 9301         	str	r3, [sp, #0x4]
 80060b4: 2300         	movs	r3, #0x0
 80060b6: 9300         	str	r3, [sp]
 80060b8: 2300         	movs	r3, #0x0
 80060ba: 2201         	movs	r2, #0x1
 80060bc: 2000         	movs	r0, #0x0
 80060be: f016 f940    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x16280
 80060c2: 2300         	movs	r3, #0x0
 80060c4: 60bb         	str	r3, [r7, #0x8]
; }
 80060c6: bf00         	nop
 80060c8: bf00         	nop
 80060ca: 3710         	adds	r7, #0x10
 80060cc: 46bd         	mov	sp, r7
 80060ce: bd80         	pop	{r7, pc}

080060d0 <$d>:
 80060d0: f4 04 00 20  	.word	0x200004f4
 80060d4: a0 89 02 08  	.word	0x080289a0
 80060d8: b8 89 02 08  	.word	0x080289b8
 80060dc: d4 89 02 08  	.word	0x080289d4

080060e0 <fault_handle>:
; {
 80060e0: b580         	push	{r7, lr}
 80060e2: b086         	sub	sp, #0x18
 80060e4: af00         	add	r7, sp, #0x0
 80060e6: 60f8         	str	r0, [r7, #0xc]
 80060e8: 60b9         	str	r1, [r7, #0x8]
 80060ea: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 80060ec: 2300         	movs	r3, #0x0
 80060ee: 617b         	str	r3, [r7, #0x14]
; 	*recoverable = false;
 80060f0: 687b         	ldr	r3, [r7, #0x4]
 80060f2: 2200         	movs	r2, #0x0
 80060f4: 701a         	strb	r2, [r3]
; 	switch (fault) {
 80060f6: 68bb         	ldr	r3, [r7, #0x8]
 80060f8: 3b03         	subs	r3, #0x3
 80060fa: 2b09         	cmp	r3, #0x9
 80060fc: d835         	bhi	0x800616a <fault_handle+0x8a> @ imm = #0x6a
 80060fe: a201         	adr	r2, #4 <fault_handle+0x23>
 8006100: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08006104 <$d>:
 8006104: 2d 61 00 08  	.word	0x0800612d
 8006108: 39 61 00 08  	.word	0x08006139
 800610c: 47 61 00 08  	.word	0x08006147
 8006110: 57 61 00 08  	.word	0x08006157
 8006114: 6b 61 00 08  	.word	0x0800616b
 8006118: 6b 61 00 08  	.word	0x0800616b
 800611c: 6b 61 00 08  	.word	0x0800616b
 8006120: 6b 61 00 08  	.word	0x0800616b
 8006124: 6b 61 00 08  	.word	0x0800616b
 8006128: 61 61 00 08  	.word	0x08006161

0800612c <$t>:
; 		reason = hard_fault(esf, recoverable);
 800612c: 6879         	ldr	r1, [r7, #0x4]
 800612e: 68f8         	ldr	r0, [r7, #0xc]
 8006130: f7ff feb6    	bl	0x8005ea0 <hard_fault>  @ imm = #-0x294
 8006134: 6178         	str	r0, [r7, #0x14]
; 		break;
 8006136: e01d         	b	0x8006174 <fault_handle+0x94> @ imm = #0x3a
; 		reason = mem_manage_fault(esf, 0, recoverable);
 8006138: 687a         	ldr	r2, [r7, #0x4]
 800613a: 2100         	movs	r1, #0x0
 800613c: 68f8         	ldr	r0, [r7, #0xc]
 800613e: f7ff fa99    	bl	0x8005674 <mem_manage_fault> @ imm = #-0xace
 8006142: 6178         	str	r0, [r7, #0x14]
; 		break;
 8006144: e016         	b	0x8006174 <fault_handle+0x94> @ imm = #0x2c
; 		reason = bus_fault(esf, 0, recoverable);
 8006146: 687a         	ldr	r2, [r7, #0x4]
 8006148: 2100         	movs	r1, #0x0
 800614a: 68f8         	ldr	r0, [r7, #0xc]
 800614c: f7ff fbd6    	bl	0x80058fc <bus_fault>   @ imm = #-0x854
 8006150: 4603         	mov	r3, r0
 8006152: 617b         	str	r3, [r7, #0x14]
; 		break;
 8006154: e00e         	b	0x8006174 <fault_handle+0x94> @ imm = #0x1c
; 		reason = usage_fault(esf);
 8006156: 68f8         	ldr	r0, [r7, #0xc]
 8006158: f7ff fd20    	bl	0x8005b9c <usage_fault> @ imm = #-0x5c0
 800615c: 6178         	str	r0, [r7, #0x14]
; 		break;
 800615e: e009         	b	0x8006174 <fault_handle+0x94> @ imm = #0x12
; 		debug_monitor(esf, recoverable);
 8006160: 6879         	ldr	r1, [r7, #0x4]
 8006162: 68f8         	ldr	r0, [r7, #0xc]
 8006164: f7ff fe30    	bl	0x8005dc8 <debug_monitor> @ imm = #-0x3a0
; 		break;
 8006168: e004         	b	0x8006174 <fault_handle+0x94> @ imm = #0x8
; 		reserved_exception(esf, fault);
 800616a: 68b9         	ldr	r1, [r7, #0x8]
 800616c: 68f8         	ldr	r0, [r7, #0xc]
 800616e: f7ff ff81    	bl	0x8006074 <reserved_exception> @ imm = #-0xfe
; 		break;
 8006172: bf00         	nop
; 	if ((*recoverable) == false) {
 8006174: 687b         	ldr	r3, [r7, #0x4]
 8006176: 781b         	ldrb	r3, [r3]
 8006178: f083 0301    	eor	r3, r3, #0x1
 800617c: b2db         	uxtb	r3, r3
 800617e: 2b00         	cmp	r3, #0x0
 8006180: d003         	beq	0x800618a <fault_handle+0xaa> @ imm = #0x6
; 		fault_show(esf, fault);
 8006182: 68b9         	ldr	r1, [r7, #0x8]
 8006184: 68f8         	ldr	r0, [r7, #0xc]
 8006186: f016 f8fa    	bl	0x801c37e <fault_show>  @ imm = #0x161f4
; 	return reason;
 800618a: 697b         	ldr	r3, [r7, #0x14]
; }
 800618c: 4618         	mov	r0, r3
 800618e: 3718         	adds	r7, #0x18
 8006190: 46bd         	mov	sp, r7
 8006192: bd80         	pop	{r7, pc}

08006194 <get_esf>:
; {
 8006194: b580         	push	{r7, lr}
 8006196: b08c         	sub	sp, #0x30
 8006198: af04         	add	r7, sp, #0x10
 800619a: 60f8         	str	r0, [r7, #0xc]
 800619c: 60b9         	str	r1, [r7, #0x8]
 800619e: 607a         	str	r2, [r7, #0x4]
 80061a0: 603b         	str	r3, [r7]
; 	bool alternative_state_exc = false;
 80061a2: 2300         	movs	r3, #0x0
 80061a4: 76fb         	strb	r3, [r7, #0x1b]
; 	struct arch_esf *ptr_esf = NULL;
 80061a6: 2300         	movs	r3, #0x0
 80061a8: 61fb         	str	r3, [r7, #0x1c]
; 	*nested_exc = false;
 80061aa: 683b         	ldr	r3, [r7]
 80061ac: 2200         	movs	r2, #0x0
 80061ae: 701a         	strb	r2, [r3]
; 	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 80061b0: 687b         	ldr	r3, [r7, #0x4]
 80061b2: f003 437f    	and	r3, r3, #0xff000000
 80061b6: f1b3 4f7f    	cmp.w	r3, #0xff000000
 80061ba: d001         	beq	0x80061c0 <get_esf+0x2c> @ imm = #0x2
; 		return NULL;
 80061bc: 2300         	movs	r3, #0x0
 80061be: e039         	b	0x8006234 <get_esf+0xa0> @ imm = #0x72
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 80061c0: 687b         	ldr	r3, [r7, #0x4]
 80061c2: f003 0308    	and	r3, r3, #0x8
 80061c6: 2b00         	cmp	r3, #0x0
 80061c8: d020         	beq	0x800620c <get_esf+0x78> @ imm = #0x40
; 		(!(exc_return & EXC_RETURN_SPSEL_PROCESS))) {
 80061ca: 687b         	ldr	r3, [r7, #0x4]
 80061cc: f003 0304    	and	r3, r3, #0x4
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 80061d0: 2b00         	cmp	r3, #0x0
 80061d2: d11b         	bne	0x800620c <get_esf+0x78> @ imm = #0x36
; 		PR_EXC("SPSEL in thread mode does not indicate PSP");
 80061d4: 2303         	movs	r3, #0x3
 80061d6: 2b00         	cmp	r3, #0x0
 80061d8: d016         	beq	0x8006208 <get_esf+0x74> @ imm = #0x2c
 80061da: 2301         	movs	r3, #0x1
 80061dc: 76bb         	strb	r3, [r7, #0x1a]
 80061de: 7ebb         	ldrb	r3, [r7, #0x1a]
 80061e0: f083 0301    	eor	r3, r3, #0x1
 80061e4: b2db         	uxtb	r3, r3
 80061e6: 2b00         	cmp	r3, #0x0
 80061e8: d10e         	bne	0x8006208 <get_esf+0x74> @ imm = #0x1c
 80061ea: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800623c <get_esf+0xa8>
 80061ec: 6819         	ldr	r1, [r3]
 80061ee: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8006240 <get_esf+0xac>
 80061f0: 9302         	str	r3, [sp, #0x8]
 80061f2: 2300         	movs	r3, #0x0
 80061f4: 9301         	str	r3, [sp, #0x4]
 80061f6: 2300         	movs	r3, #0x0
 80061f8: 9300         	str	r3, [sp]
 80061fa: 2300         	movs	r3, #0x0
 80061fc: 2201         	movs	r2, #0x1
 80061fe: 2000         	movs	r0, #0x0
 8006200: f016 f89f    	bl	0x801c342 <z_log_msg_runtime_create> @ imm = #0x1613e
 8006204: 2300         	movs	r3, #0x0
 8006206: 617b         	str	r3, [r7, #0x14]
; 		return NULL;
 8006208: 2300         	movs	r3, #0x0
 800620a: e013         	b	0x8006234 <get_esf+0xa0> @ imm = #0x26
; 	if (!alternative_state_exc) {
 800620c: 7efb         	ldrb	r3, [r7, #0x1b]
 800620e: f083 0301    	eor	r3, r3, #0x1
 8006212: b2db         	uxtb	r3, r3
 8006214: 2b00         	cmp	r3, #0x0
 8006216: d00c         	beq	0x8006232 <get_esf+0x9e> @ imm = #0x18
; 		if (exc_return & EXC_RETURN_MODE_THREAD) {
 8006218: 687b         	ldr	r3, [r7, #0x4]
 800621a: f003 0308    	and	r3, r3, #0x8
 800621e: 2b00         	cmp	r3, #0x0
 8006220: d002         	beq	0x8006228 <get_esf+0x94> @ imm = #0x4
; 			ptr_esf =  (struct arch_esf *)psp;
 8006222: 68bb         	ldr	r3, [r7, #0x8]
 8006224: 61fb         	str	r3, [r7, #0x1c]
 8006226: e004         	b	0x8006232 <get_esf+0x9e> @ imm = #0x8
; 			ptr_esf = (struct arch_esf *)msp;
 8006228: 68fb         	ldr	r3, [r7, #0xc]
 800622a: 61fb         	str	r3, [r7, #0x1c]
; 			*nested_exc = true;
 800622c: 683b         	ldr	r3, [r7]
 800622e: 2201         	movs	r2, #0x1
 8006230: 701a         	strb	r2, [r3]
; 	return ptr_esf;
 8006232: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8006234: 4618         	mov	r0, r3
 8006236: 3720         	adds	r7, #0x20
 8006238: 46bd         	mov	sp, r7
 800623a: bd80         	pop	{r7, pc}

0800623c <$d>:
 800623c: f4 04 00 20  	.word	0x200004f4
 8006240: e8 89 02 08  	.word	0x080289e8

08006244 <z_arm_fault>:
; {
 8006244: b580         	push	{r7, lr}
 8006246: b0a6         	sub	sp, #0x98
 8006248: af00         	add	r7, sp, #0x0
 800624a: 60f8         	str	r0, [r7, #0xc]
 800624c: 60b9         	str	r1, [r7, #0x8]
 800624e: 607a         	str	r2, [r7, #0x4]
 8006250: 603b         	str	r3, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8006252: 2300         	movs	r3, #0x0
 8006254: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 8006258: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8006314 <z_arm_fault+0xd0>
 800625a: 685b         	ldr	r3, [r3, #0x4]
 800625c: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8006260: f8c7 3090    	str.w	r3, [r7, #0x90]
 8006264: 2300         	movs	r3, #0x0
 8006266: f8c7 3080    	str.w	r3, [r7, #0x80]
 800626a: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800626e: 67fb         	str	r3, [r7, #0x7c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006270: 6ffb         	ldr	r3, [r7, #0x7c]
 8006272: f383 8811    	msr	basepri, r3
; }
 8006276: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006278: f3bf 8f6f    	isb	sy
; }
 800627c: bf00         	nop
; }
 800627e: bf00         	nop
; 	 esf = get_esf(msp, psp, exc_return, &nested_exc);
 8006280: f107 037a    	add.w	r3, r7, #0x7a
 8006284: 687a         	ldr	r2, [r7, #0x4]
 8006286: 68b9         	ldr	r1, [r7, #0x8]
 8006288: 68f8         	ldr	r0, [r7, #0xc]
 800628a: f7ff ff83    	bl	0x8006194 <get_esf>     @ imm = #-0xfa
 800628e: f8c7 008c    	str.w	r0, [r7, #0x8c]
 8006292: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8006296: f8c7 3088    	str.w	r3, [r7, #0x88]
 800629a: 687b         	ldr	r3, [r7, #0x4]
 800629c: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 80062a0: bf00         	nop
; 	reason = fault_handle(esf, fault, &recoverable);
 80062a2: f107 037b    	add.w	r3, r7, #0x7b
 80062a6: 461a         	mov	r2, r3
 80062a8: f8d7 1090    	ldr.w	r1, [r7, #0x90]
 80062ac: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 80062b0: f7ff ff16    	bl	0x80060e0 <fault_handle> @ imm = #-0x1d4
 80062b4: f8c7 0094    	str.w	r0, [r7, #0x94]
; 	if (recoverable) {
 80062b8: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 80062bc: 2b00         	cmp	r3, #0x0
 80062be: d125         	bne	0x800630c <z_arm_fault+0xc8> @ imm = #0x4a
; 	memcpy(&esf_copy, esf, sizeof(struct arch_esf));
 80062c0: f107 0310    	add.w	r3, r7, #0x10
 80062c4: 2268         	movs	r2, #0x68
 80062c6: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 80062ca: 4618         	mov	r0, r3
 80062cc: f021 f90e    	bl	0x80274ec <memcpy>      @ imm = #0x2121c
; 	if (nested_exc) {
 80062d0: f897 307a    	ldrb.w	r3, [r7, #0x7a]
 80062d4: 2b00         	cmp	r3, #0x0
 80062d6: d00b         	beq	0x80062f0 <z_arm_fault+0xac> @ imm = #0x16
; 		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 80062d8: 6afb         	ldr	r3, [r7, #0x2c]
 80062da: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 80062de: 2b00         	cmp	r3, #0x0
 80062e0: d10c         	bne	0x80062fc <z_arm_fault+0xb8> @ imm = #0x18
; 			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 80062e2: 6afb         	ldr	r3, [r7, #0x2c]
 80062e4: ea6f 2353    	mvn.w	r3, r3, lsr #9
 80062e8: ea6f 2343    	mvn.w	r3, r3, lsl #9
 80062ec: 62fb         	str	r3, [r7, #0x2c]
 80062ee: e005         	b	0x80062fc <z_arm_fault+0xb8> @ imm = #0xa
; 		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 80062f0: 6afb         	ldr	r3, [r7, #0x2c]
 80062f2: f423 73ff    	bic	r3, r3, #0x1fe
 80062f6: f023 0301    	bic	r3, r3, #0x1
 80062fa: 62fb         	str	r3, [r7, #0x2c]
; 	z_arm_fatal_error(reason, &esf_copy);
 80062fc: f107 0310    	add.w	r3, r7, #0x10
 8006300: 4619         	mov	r1, r3
 8006302: f8d7 0094    	ldr.w	r0, [r7, #0x94]
 8006306: f7ff f91f    	bl	0x8005548 <z_arm_fatal_error> @ imm = #-0xdc2
 800630a: e000         	b	0x800630e <z_arm_fault+0xca> @ imm = #0x0
; 		return;
 800630c: bf00         	nop
; }
 800630e: 3798         	adds	r7, #0x98
 8006310: 46bd         	mov	sp, r7
 8006312: bd80         	pop	{r7, pc}

08006314 <$d>:
 8006314: 00 ed 00 e0  	.word	0xe000ed00

08006318 <z_arm_fault_init>:
; {
 8006318: b480         	push	{r7}
 800631a: af00         	add	r7, sp, #0x0
; 	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 800631c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8006340 <z_arm_fault_init+0x28>
 800631e: 695b         	ldr	r3, [r3, #0x14]
 8006320: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8006340 <z_arm_fault_init+0x28>
 8006322: f043 0310    	orr	r3, r3, #0x10
 8006326: 6153         	str	r3, [r2, #0x14]
; 	SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk;
 8006328: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8006340 <z_arm_fault_init+0x28>
 800632a: 695b         	ldr	r3, [r3, #0x14]
 800632c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8006340 <z_arm_fault_init+0x28>
 800632e: f023 0308    	bic	r3, r3, #0x8
 8006332: 6153         	str	r3, [r2, #0x14]
; }
 8006334: bf00         	nop
 8006336: 46bd         	mov	sp, r7
 8006338: f85d 7b04    	ldr	r7, [sp], #4
 800633c: 4770         	bx	lr
 800633e: bf00         	nop

08006340 <$d>:
 8006340: 00 ed 00 e0  	.word	0xe000ed00

08006344 <z_arm_usage_fault>:
; 	mrs r0, MSP
 8006344: f3ef 8008    	mrs	r0, msp
; 	mrs r1, PSP
 8006348: f3ef 8109    	mrs	r1, psp
; 	push {r0, lr}
 800634c: b501         	push	{r0, lr}
; 	mov r2, lr /* EXC_RETURN */
 800634e: 4672         	mov	r2, lr
; 	bl z_arm_fault
 8006350: f7ff ff78    	bl	0x8006244 <z_arm_fault> @ imm = #-0x110
; 	pop {r0, pc}
 8006354: bd01         	pop	{r0, pc}
 8006356: bf00         	nop

08006358 <z_arm_reset>:
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8006358: 2010         	movs	r0, #0x10
;     msr BASEPRI, r0
 800635a: f380 8811    	msr	basepri, r0
;     ldr r0, =z_interrupt_stacks
 800635e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x800638c <z_arm_reset+0x34>
;     ldr r1, =0xaa
 8006360: f04f 01aa    	mov.w	r1, #0xaa
;     ldr r2, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 8006364: f44f 6200    	mov.w	r2, #0x800
;     bl z_early_memset
 8006368: f01e f9be    	bl	0x80246e8 <z_early_memset> @ imm = #0x1e37c
;     ldr r0, =z_interrupt_stacks
 800636c: 4807         	ldr	r0, [pc, #0x1c]         @ 0x800638c <z_arm_reset+0x34>
;     ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 800636e: f44f 6100    	mov.w	r1, #0x800
;     adds r0, r0, r1
 8006372: 1840         	adds	r0, r0, r1
;     msr PSP, r0
 8006374: f380 8809    	msr	psp, r0
;     mrs r0, CONTROL
 8006378: f3ef 8014    	mrs	r0, control
;     movs r1, #2
 800637c: 2102         	movs	r1, #0x2
;     orrs r0, r1 /* CONTROL_SPSEL_Msk */
 800637e: 4308         	orrs	r0, r1
;     msr CONTROL, r0
 8006380: f380 8814    	msr	control, r0
;     isb
 8006384: f3bf 8f6f    	isb	sy
;     bl z_prep_c
 8006388: f016 f83d    	bl	0x801c406 <z_prep_c>    @ imm = #0x1607a

0800638c <$d>:
 800638c: 48 53 00 20  	.word	0x20005348

08006390 <z_impl_k_thread_abort>:
; {
 8006390: b580         	push	{r7, lr}
 8006392: b084         	sub	sp, #0x10
 8006394: af00         	add	r7, sp, #0x0
 8006396: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8006398: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80063e4 <z_impl_k_thread_abort+0x54>
 800639a: 689b         	ldr	r3, [r3, #0x8]
 800639c: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800639e: 68fb         	ldr	r3, [r7, #0xc]
; 	if (arch_current_thread() == thread) {
 80063a0: 687a         	ldr	r2, [r7, #0x4]
 80063a2: 429a         	cmp	r2, r3
 80063a4: d116         	bne	0x80063d4 <z_impl_k_thread_abort+0x44> @ imm = #0x2c
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80063a6: f3ef 8305    	mrs	r3, ipsr
 80063aa: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 80063ac: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 80063ae: 2b00         	cmp	r3, #0x0
 80063b0: bf14         	ite	ne
 80063b2: 2301         	movne	r3, #0x1
 80063b4: 2300         	moveq	r3, #0x0
 80063b6: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 80063b8: 2b00         	cmp	r3, #0x0
 80063ba: d00b         	beq	0x80063d4 <z_impl_k_thread_abort+0x44> @ imm = #0x16
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 80063bc: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80063e8 <z_impl_k_thread_abort+0x58>
 80063be: 685b         	ldr	r3, [r3, #0x4]
 80063c0: 4a09         	ldr	r2, [pc, #0x24]         @ 0x80063e8 <z_impl_k_thread_abort+0x58>
 80063c2: f043 5380    	orr	r3, r3, #0x10000000
 80063c6: 6053         	str	r3, [r2, #0x4]
; 			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
 80063c8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80063e8 <z_impl_k_thread_abort+0x58>
 80063ca: 6a5b         	ldr	r3, [r3, #0x24]
 80063cc: 4a06         	ldr	r2, [pc, #0x18]         @ 0x80063e8 <z_impl_k_thread_abort+0x58>
 80063ce: f423 4300    	bic	r3, r3, #0x8000
 80063d2: 6253         	str	r3, [r2, #0x24]
; 	z_thread_abort(thread);
 80063d4: 6878         	ldr	r0, [r7, #0x4]
 80063d6: f010 f8c5    	bl	0x8016564 <z_thread_abort> @ imm = #0x1018a
; }
 80063da: bf00         	nop
 80063dc: 3710         	adds	r7, #0x10
 80063de: 46bd         	mov	sp, r7
 80063e0: bd80         	pop	{r7, pc}
 80063e2: bf00         	nop

080063e4 <$d>:
 80063e4: a8 25 00 20  	.word	0x200025a8
 80063e8: 00 ed 00 e0  	.word	0xe000ed00

080063ec <arch_swap>:
; {
 80063ec: b480         	push	{r7}
 80063ee: b089         	sub	sp, #0x24
 80063f0: af00         	add	r7, sp, #0x0
 80063f2: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80063f4: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8006450 <arch_swap+0x64>
 80063f6: 689b         	ldr	r3, [r3, #0x8]
 80063f8: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 80063fa: 68fb         	ldr	r3, [r7, #0xc]
; 	arch_current_thread()->arch.basepri = key;
 80063fc: 687a         	ldr	r2, [r7, #0x4]
 80063fe: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8006402: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8006450 <arch_swap+0x64>
 8006404: 689b         	ldr	r3, [r3, #0x8]
 8006406: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8006408: 693b         	ldr	r3, [r7, #0x10]
; 	arch_current_thread()->arch.swap_return_value = -EAGAIN;
 800640a: f06f 020a    	mvn	r2, #0xa
 800640e: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; 	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8006412: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8006454 <arch_swap+0x68>
 8006414: 685b         	ldr	r3, [r3, #0x4]
 8006416: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8006454 <arch_swap+0x68>
 8006418: f043 5380    	orr	r3, r3, #0x10000000
 800641c: 6053         	str	r3, [r2, #0x4]
 800641e: 2300         	movs	r3, #0x0
 8006420: 61bb         	str	r3, [r7, #0x18]
 8006422: 69bb         	ldr	r3, [r7, #0x18]
 8006424: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006426: 697b         	ldr	r3, [r7, #0x14]
 8006428: f383 8811    	msr	basepri, r3
; }
 800642c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800642e: f3bf 8f6f    	isb	sy
; }
 8006432: bf00         	nop
; }
 8006434: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8006436: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8006450 <arch_swap+0x64>
 8006438: 689b         	ldr	r3, [r3, #0x8]
 800643a: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 800643c: 69fb         	ldr	r3, [r7, #0x1c]
; 	return arch_current_thread()->arch.swap_return_value;
 800643e: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
; }
 8006442: 4618         	mov	r0, r3
 8006444: 3724         	adds	r7, #0x24
 8006446: 46bd         	mov	sp, r7
 8006448: f85d 7b04    	ldr	r7, [sp], #4
 800644c: 4770         	bx	lr
 800644e: bf00         	nop

08006450 <$d>:
 8006450: a8 25 00 20  	.word	0x200025a8
 8006454: 00 ed 00 e0  	.word	0xe000ed00

08006458 <z_arm_pendsv>:
;     push {r0, lr}
 8006458: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_out
 800645a: f01f ff78    	bl	0x802634e <z_thread_mark_switched_out> @ imm = #0x1fef0
;     pop {r0, lr}
 800645e: e8bd 4001    	pop.w	{r0, lr}
;     ldr r1, =_kernel
 8006462: 4925         	ldr	r1, [pc, #0x94]         @ 0x80064f8 <in_fp_endif+0x28>
;     ldr r2, [r1, #_kernel_offset_to_current]
 8006464: 688a         	ldr	r2, [r1, #0x8]
;     strb lr, [r2, #_thread_offset_to_mode_exc_return]
 8006466: f882 e111    	strb.w	lr, [r2, #0x111]
;     ldr r0, =_thread_offset_to_callee_saved
 800646a: f04f 0040    	mov.w	r0, #0x40
;     add r0, r2
 800646e: 4410         	add	r0, r2
;     mrs ip, PSP
 8006470: f3ef 8c09    	mrs	r12, psp
;     stmia r0, {r4-r11, ip}
 8006474: e880 1ff0    	stm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     tst lr, #_EXC_RETURN_FTYPE_Msk
 8006478: f01e 0f10    	tst.w	lr, #0x10
;     bne out_fp_endif
 800647c: d103         	bne	0x8006486 <out_fp_endif> @ imm = #0x6
;     add r0, r2, #_thread_offset_to_preempt_float
 800647e: f102 00d0    	add.w	r0, r2, #0xd0
;     vstmia r0, {s16-s31}
 8006482: ec80 8a10    	vstmia	r0, {s16, s17, s18, s19, s20, s21, s22, s23, s24, s25, s26, s27, s28, s29, s30, s31}

08006486 <out_fp_endif>:
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8006486: 2010         	movs	r0, #0x10
;     msr BASEPRI_MAX, r0
 8006488: f380 8812    	msr	basepri_max, r0
;     isb /* Make the effect of disabling interrupts be realized immediately */
 800648c: f3bf 8f6f    	isb	sy
;     ldr r7, =_SCS_ICSR
 8006490: 4f1a         	ldr	r7, [pc, #0x68]         @ 0x80064fc <in_fp_endif+0x2c>
;     ldr r6, =_SCS_ICSR_UNPENDSV
 8006492: f04f 6600    	mov.w	r6, #0x8000000
;     ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 8006496: 6a0a         	ldr	r2, [r1, #0x20]
;     str r2, [r1, #_kernel_offset_to_current]
 8006498: 608a         	str	r2, [r1, #0x8]
;     str r6, [r7, #0]
 800649a: 603e         	str	r6, [r7]
;     ldr r4, =_thread_offset_to_tls
 800649c: f04f 04c4    	mov.w	r4, #0xc4
;     adds r4, r2, r4
 80064a0: 1914         	adds	r4, r2, r4
;     ldr r0, [r4]
 80064a2: 6820         	ldr	r0, [r4]
;     ldr r4, =z_arm_tls_ptr
 80064a4: 4c16         	ldr	r4, [pc, #0x58]         @ 0x8006500 <in_fp_endif+0x30>
;     str r0, [r4]
 80064a6: 6020         	str	r0, [r4]
;     ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
 80064a8: f992 e111    	ldrsb.w	lr, [r2, #0x111]
;     ldr r0, [r2, #_thread_offset_to_basepri]
 80064ac: f8d2 00c8    	ldr.w	r0, [r2, #0xc8]
;     movs r3, #0
 80064b0: 2300         	movs	r3, #0x0
;     str r3, [r2, #_thread_offset_to_basepri]
 80064b2: f8c2 30c8    	str.w	r3, [r2, #0xc8]
;     msr BASEPRI, r0
 80064b6: f380 8811    	msr	basepri, r0
;     tst lr, #_EXC_RETURN_FTYPE_Msk
 80064ba: f01e 0f10    	tst.w	lr, #0x10
;     beq in_fp_active
 80064be: d003         	beq	0x80064c8 <in_fp_active> @ imm = #0x6
;     movs.n r3, #0
 80064c0: 2300         	movs	r3, #0x0
;     vmsr fpscr, r3
 80064c2: eee1 3a10    	vmsr	fpscr, r3
;     b in_fp_endif
 80064c6: e003         	b	0x80064d0 <in_fp_endif> @ imm = #0x6

080064c8 <in_fp_active>:
;     add r0, r2, #_thread_offset_to_preempt_float
 80064c8: f102 00d0    	add.w	r0, r2, #0xd0
;     vldmia r0, {s16-s31}
 80064cc: ec90 8a10    	vldmia	r0, {s16, s17, s18, s19, s20, s21, s22, s23, s24, s25, s26, s27, s28, s29, s30, s31}

080064d0 <in_fp_endif>:
;     mrs r3, CONTROL
 80064d0: f3ef 8314    	mrs	r3, control
;     bic r3, #_CONTROL_FPCA_Msk
 80064d4: f023 0304    	bic	r3, r3, #0x4
;     msr CONTROL, r3
 80064d8: f383 8814    	msr	control, r3
;     isb
 80064dc: f3bf 8f6f    	isb	sy
;     add r0, r2, #_thread_offset_to_callee_saved
 80064e0: f102 0040    	add.w	r0, r2, #0x40
;     ldmia r0, {r4-r11, ip}
 80064e4: e890 1ff0    	ldm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     msr PSP, ip
 80064e8: f38c 8809    	msr	psp, r12
;     push {r0, lr}
 80064ec: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_in
 80064ee: f00e fbd7    	bl	0x8014ca0 <z_thread_mark_switched_in> @ imm = #0xe7ae
;     pop {r0, lr}
 80064f2: e8bd 4001    	pop.w	{r0, lr}
;     bx lr
 80064f6: 4770         	bx	lr

080064f8 <$d>:
 80064f8: a8 25 00 20  	.word	0x200025a8
 80064fc: 04 ed 00 e0  	.word	0xe000ed04
 8006500: 24 2d 00 20  	.word	0x20002d24

08006504 <z_arm_svc>:
;     tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
 8006504: f01e 0f04    	tst.w	lr, #0x4
;     ite eq  /* if zero (equal), came from handler mode */
 8006508: bf0c         	ite	eq
;         mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 800650a: f3ef 8008    	mrseq	r0, msp
;         mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 800650e: f3ef 8009    	mrsne	r0, psp
;     ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 8006512: 6981         	ldr	r1, [r0, #0x18]
;     ldrb r1, [r1, #-2]
 8006514: f811 1c02    	ldrb	r1, [r1, #-2]
;     cmp r1, #2
 8006518: 2902         	cmp	r1, #0x2
;     beq _oops
 800651a: d0ff         	beq	0x800651c <_oops>       @ imm = #-0x2

0800651c <_oops>:
;     push {r0, lr}
 800651c: b501         	push	{r0, lr}
;     mov r2, lr /* EXC_RETURN */
 800651e: 4672         	mov	r2, lr
;     bl z_do_kernel_oops
 8006520: f015 fedb    	bl	0x801c2da <z_do_kernel_oops> @ imm = #0x15db6
;     pop {r0, pc}
 8006524: bd01         	pop	{r0, pc}
 8006526: bf00         	nop

08006528 <__NVIC_EnableIRQ>:
; {
 8006528: b480         	push	{r7}
 800652a: b083         	sub	sp, #0xc
 800652c: af00         	add	r7, sp, #0x0
 800652e: 4603         	mov	r3, r0
 8006530: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8006532: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8006536: 2b00         	cmp	r3, #0x0
 8006538: db0b         	blt	0x8006552 <__NVIC_EnableIRQ+0x2a> @ imm = #0x16
;     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800653a: 79fb         	ldrb	r3, [r7, #0x7]
 800653c: f003 021f    	and	r2, r3, #0x1f
 8006540: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006560 <__NVIC_EnableIRQ+0x38>
 8006542: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8006546: 095b         	lsrs	r3, r3, #0x5
 8006548: 2001         	movs	r0, #0x1
 800654a: fa00 f202    	lsl.w	r2, r0, r2
 800654e: f841 2023    	str.w	r2, [r1, r3, lsl #2]
; }
 8006552: bf00         	nop
 8006554: 370c         	adds	r7, #0xc
 8006556: 46bd         	mov	sp, r7
 8006558: f85d 7b04    	ldr	r7, [sp], #4
 800655c: 4770         	bx	lr
 800655e: bf00         	nop

08006560 <$d>:
 8006560: 00 e1 00 e0  	.word	0xe000e100

08006564 <__NVIC_SetPriority>:
; {
 8006564: b480         	push	{r7}
 8006566: b083         	sub	sp, #0xc
 8006568: af00         	add	r7, sp, #0x0
 800656a: 4603         	mov	r3, r0
 800656c: 6039         	str	r1, [r7]
 800656e: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8006570: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8006574: 2b00         	cmp	r3, #0x0
 8006576: db0a         	blt	0x800658e <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8006578: 683b         	ldr	r3, [r7]
 800657a: b2da         	uxtb	r2, r3
 800657c: 490c         	ldr	r1, [pc, #0x30]         @ 0x80065b0 <__NVIC_SetPriority+0x4c>
 800657e: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8006582: 0112         	lsls	r2, r2, #0x4
 8006584: b2d2         	uxtb	r2, r2
 8006586: 440b         	add	r3, r1
 8006588: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 800658c: e00a         	b	0x80065a4 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800658e: 683b         	ldr	r3, [r7]
 8006590: b2da         	uxtb	r2, r3
 8006592: 4908         	ldr	r1, [pc, #0x20]         @ 0x80065b4 <__NVIC_SetPriority+0x50>
 8006594: 79fb         	ldrb	r3, [r7, #0x7]
 8006596: f003 030f    	and	r3, r3, #0xf
 800659a: 3b04         	subs	r3, #0x4
 800659c: 0112         	lsls	r2, r2, #0x4
 800659e: b2d2         	uxtb	r2, r2
 80065a0: 440b         	add	r3, r1
 80065a2: 761a         	strb	r2, [r3, #0x18]
; }
 80065a4: bf00         	nop
 80065a6: 370c         	adds	r7, #0xc
 80065a8: 46bd         	mov	sp, r7
 80065aa: f85d 7b04    	ldr	r7, [sp], #4
 80065ae: 4770         	bx	lr

080065b0 <$d>:
 80065b0: 00 e1 00 e0  	.word	0xe000e100
 80065b4: 00 ed 00 e0  	.word	0xe000ed00

080065b8 <relocate_vector_table>:
; {
 80065b8: b480         	push	{r7}
 80065ba: af00         	add	r7, sp, #0x0
; 	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 80065bc: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80065e4 <relocate_vector_table+0x2c>
 80065be: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80065e8 <relocate_vector_table+0x30>
 80065c0: f023 037f    	bic	r3, r3, #0x7f
 80065c4: 6093         	str	r3, [r2, #0x8]
;   __ASM volatile ("dsb 0xF":::"memory");
 80065c6: f3bf 8f4f    	dsb	sy
; }
 80065ca: bf00         	nop
; }
 80065cc: bf00         	nop
; }
 80065ce: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80065d0: f3bf 8f6f    	isb	sy
; }
 80065d4: bf00         	nop
; }
 80065d6: bf00         	nop
; }
 80065d8: bf00         	nop
; }
 80065da: bf00         	nop
 80065dc: 46bd         	mov	sp, r7
 80065de: f85d 7b04    	ldr	r7, [sp], #4
 80065e2: 4770         	bx	lr

080065e4 <$d>:
 80065e4: 00 00 00 08  	.word	0x08000000
 80065e8: 00 ed 00 e0  	.word	0xe000ed00

080065ec <z_arm_floating_point_init>:
; {
 80065ec: b480         	push	{r7}
 80065ee: b083         	sub	sp, #0xc
 80065f0: af00         	add	r7, sp, #0x0
; 	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
 80065f2: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8006648 <z_arm_floating_point_init+0x5c>
 80065f4: f8d3 3088    	ldr.w	r3, [r3, #0x88]
 80065f8: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8006648 <z_arm_floating_point_init+0x5c>
 80065fa: f423 0370    	bic	r3, r3, #0xf00000
 80065fe: f8c2 3088    	str.w	r3, [r2, #0x88]
; 	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
 8006602: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8006648 <z_arm_floating_point_init+0x5c>
 8006604: f8d3 3088    	ldr.w	r3, [r3, #0x88]
 8006608: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8006648 <z_arm_floating_point_init+0x5c>
 800660a: f443 03a0    	orr	r3, r3, #0x500000
 800660e: f8c2 3088    	str.w	r3, [r2, #0x88]
; 	FPU->FPCCR = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
 8006612: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800664c <z_arm_floating_point_init+0x60>
 8006614: f04f 4240    	mov.w	r2, #0xc0000000
 8006618: 605a         	str	r2, [r3, #0x4]
;   __ASM volatile ("dsb 0xF":::"memory");
 800661a: f3bf 8f4f    	dsb	sy
; }
 800661e: bf00         	nop
; }
 8006620: bf00         	nop
; }
 8006622: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006624: f3bf 8f6f    	isb	sy
; }
 8006628: bf00         	nop
; }
 800662a: bf00         	nop
; }
 800662c: bf00         	nop
 800662e: 2300         	movs	r3, #0x0
 8006630: 607b         	str	r3, [r7, #0x4]
;   __builtin_arm_set_fpscr(fpscr);
 8006632: 687b         	ldr	r3, [r7, #0x4]
 8006634: eee1 3a10    	vmsr	fpscr, r3
; }
 8006638: bf00         	nop
; }
 800663a: bf00         	nop
 800663c: 370c         	adds	r7, #0xc
 800663e: 46bd         	mov	sp, r7
 8006640: f85d 7b04    	ldr	r7, [sp], #4
 8006644: 4770         	bx	lr
 8006646: bf00         	nop

08006648 <$d>:
 8006648: 00 ed 00 e0  	.word	0xe000ed00
 800664c: 30 ef 00 e0  	.word	0xe000ef30

08006650 <arch_new_thread>:
; {
 8006650: b480         	push	{r7}
 8006652: b087         	sub	sp, #0x1c
 8006654: af00         	add	r7, sp, #0x0
 8006656: 60f8         	str	r0, [r7, #0xc]
 8006658: 60b9         	str	r1, [r7, #0x8]
 800665a: 607a         	str	r2, [r7, #0x4]
 800665c: 603b         	str	r3, [r7]
; 	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
 800665e: 687b         	ldr	r3, [r7, #0x4]
 8006660: 3b20         	subs	r3, #0x20
 8006662: 617b         	str	r3, [r7, #0x14]
; 	iframe->pc = (uint32_t)z_thread_entry;
 8006664: 4a16         	ldr	r2, [pc, #0x58]         @ 0x80066c0 <arch_new_thread+0x70>
 8006666: 697b         	ldr	r3, [r7, #0x14]
 8006668: 619a         	str	r2, [r3, #0x18]
; 	iframe->pc &= 0xfffffffe;
 800666a: 697b         	ldr	r3, [r7, #0x14]
 800666c: 699b         	ldr	r3, [r3, #0x18]
 800666e: f023 0201    	bic	r2, r3, #0x1
 8006672: 697b         	ldr	r3, [r7, #0x14]
 8006674: 619a         	str	r2, [r3, #0x18]
; 	iframe->a1 = (uint32_t)entry;
 8006676: 683a         	ldr	r2, [r7]
 8006678: 697b         	ldr	r3, [r7, #0x14]
 800667a: 601a         	str	r2, [r3]
; 	iframe->a2 = (uint32_t)p1;
 800667c: 6a3a         	ldr	r2, [r7, #0x20]
 800667e: 697b         	ldr	r3, [r7, #0x14]
 8006680: 605a         	str	r2, [r3, #0x4]
; 	iframe->a3 = (uint32_t)p2;
 8006682: 6a7a         	ldr	r2, [r7, #0x24]
 8006684: 697b         	ldr	r3, [r7, #0x14]
 8006686: 609a         	str	r2, [r3, #0x8]
; 	iframe->a4 = (uint32_t)p3;
 8006688: 6aba         	ldr	r2, [r7, #0x28]
 800668a: 697b         	ldr	r3, [r7, #0x14]
 800668c: 60da         	str	r2, [r3, #0xc]
; 	iframe->xpsr =
 800668e: 697b         	ldr	r3, [r7, #0x14]
 8006690: f04f 7280    	mov.w	r2, #0x1000000
 8006694: 61da         	str	r2, [r3, #0x1c]
; 	thread->callee_saved.psp = (uint32_t)iframe;
 8006696: 697a         	ldr	r2, [r7, #0x14]
 8006698: 68fb         	ldr	r3, [r7, #0xc]
 800669a: 661a         	str	r2, [r3, #0x60]
; 	thread->arch.basepri = 0;
 800669c: 68fb         	ldr	r3, [r7, #0xc]
 800669e: 2200         	movs	r2, #0x0
 80066a0: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; 	thread->arch.mode = 0;
 80066a4: 68fb         	ldr	r3, [r7, #0xc]
 80066a6: 2200         	movs	r2, #0x0
 80066a8: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	thread->arch.mode_exc_return = DEFAULT_EXC_RETURN;
 80066ac: 68fb         	ldr	r3, [r7, #0xc]
 80066ae: 22fd         	movs	r2, #0xfd
 80066b0: f883 2111    	strb.w	r2, [r3, #0x111]
; }
 80066b4: bf00         	nop
 80066b6: 371c         	adds	r7, #0x1c
 80066b8: 46bd         	mov	sp, r7
 80066ba: f85d 7b04    	ldr	r7, [sp], #4
 80066be: 4770         	bx	lr

080066c0 <$d>:
 80066c0: 75 42 00 08  	.word	0x08004275

080066c4 <arch_float_disable>:
; {
 80066c4: b480         	push	{r7}
 80066c6: b08d         	sub	sp, #0x34
 80066c8: af00         	add	r7, sp, #0x0
 80066ca: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80066cc: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800676c <arch_float_disable+0xa8>
 80066ce: 689b         	ldr	r3, [r3, #0x8]
 80066d0: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 80066d2: 6abb         	ldr	r3, [r7, #0x28]
; 	if (thread != arch_current_thread()) {
 80066d4: 687a         	ldr	r2, [r7, #0x4]
 80066d6: 429a         	cmp	r2, r3
 80066d8: d002         	beq	0x80066e0 <arch_float_disable+0x1c> @ imm = #0x4
; 		return -EINVAL;
 80066da: f06f 0315    	mvn	r3, #0x15
 80066de: e03f         	b	0x8006760 <arch_float_disable+0x9c> @ imm = #0x7e
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80066e0: f3ef 8305    	mrs	r3, ipsr
 80066e4: 627b         	str	r3, [r7, #0x24]
;   return(result);
 80066e6: 6a7b         	ldr	r3, [r7, #0x24]
; 	return (__get_IPSR()) ? (true) : (false);
 80066e8: 2b00         	cmp	r3, #0x0
 80066ea: bf14         	ite	ne
 80066ec: 2301         	movne	r3, #0x1
 80066ee: 2300         	moveq	r3, #0x0
 80066f0: b2db         	uxtb	r3, r3
; 	if (arch_is_in_isr()) {
 80066f2: 2b00         	cmp	r3, #0x0
 80066f4: d002         	beq	0x80066fc <arch_float_disable+0x38> @ imm = #0x4
; 		return -EINVAL;
 80066f6: f06f 0315    	mvn	r3, #0x15
 80066fa: e031         	b	0x8006760 <arch_float_disable+0x9c> @ imm = #0x62
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80066fc: f3ef 8311    	mrs	r3, basepri
 8006700: 613b         	str	r3, [r7, #0x10]
;   return(result);
 8006702: 693b         	ldr	r3, [r7, #0x10]
; 	key = __get_BASEPRI();
 8006704: 60fb         	str	r3, [r7, #0xc]
 8006706: 2310         	movs	r3, #0x10
 8006708: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800670a: 68bb         	ldr	r3, [r7, #0x8]
 800670c: f383 8812    	msr	basepri_max, r3
; }
 8006710: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006712: f3bf 8f6f    	isb	sy
; }
 8006716: bf00         	nop
; 	return key;
 8006718: 68fb         	ldr	r3, [r7, #0xc]
; 	int key = arch_irq_lock();
 800671a: 62fb         	str	r3, [r7, #0x2c]
; 	thread->base.user_options &= ~K_FP_REGS;
 800671c: 687b         	ldr	r3, [r7, #0x4]
 800671e: 7b1b         	ldrb	r3, [r3, #0xc]
 8006720: f023 0302    	bic	r3, r3, #0x2
 8006724: b2da         	uxtb	r2, r3
 8006726: 687b         	ldr	r3, [r7, #0x4]
 8006728: 731a         	strb	r2, [r3, #0xc]
;   __ASM volatile ("MRS %0, control" : "=r" (result) );
 800672a: f3ef 8314    	mrs	r3, control
 800672e: 617b         	str	r3, [r7, #0x14]
;   return(result);
 8006730: 697b         	ldr	r3, [r7, #0x14]
; 	__set_CONTROL(__get_CONTROL() & (~CONTROL_FPCA_Msk));
 8006732: f023 0304    	bic	r3, r3, #0x4
 8006736: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 8006738: 69bb         	ldr	r3, [r7, #0x18]
 800673a: f383 8814    	msr	control, r3
;   __ASM volatile ("isb 0xF":::"memory");
 800673e: f3bf 8f6f    	isb	sy
; }
 8006742: bf00         	nop
; }
 8006744: bf00         	nop
; 	arch_irq_unlock(key);
 8006746: 6afb         	ldr	r3, [r7, #0x2c]
 8006748: 623b         	str	r3, [r7, #0x20]
 800674a: 6a3b         	ldr	r3, [r7, #0x20]
 800674c: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800674e: 69fb         	ldr	r3, [r7, #0x1c]
 8006750: f383 8811    	msr	basepri, r3
; }
 8006754: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006756: f3bf 8f6f    	isb	sy
; }
 800675a: bf00         	nop
; }
 800675c: bf00         	nop
; 	return 0;
 800675e: 2300         	movs	r3, #0x0
; }
 8006760: 4618         	mov	r0, r3
 8006762: 3734         	adds	r7, #0x34
 8006764: 46bd         	mov	sp, r7
 8006766: f85d 7b04    	ldr	r7, [sp], #4
 800676a: 4770         	bx	lr

0800676c <$d>:
 800676c: a8 25 00 20  	.word	0x200025a8

08006770 <arch_switch_to_main_thread>:
; {
 8006770: b5f0         	push	{r4, r5, r6, r7, lr}
 8006772: b087         	sub	sp, #0x1c
 8006774: af00         	add	r7, sp, #0x0
 8006776: 60f8         	str	r0, [r7, #0xc]
 8006778: 60b9         	str	r1, [r7, #0x8]
 800677a: 607a         	str	r2, [r7, #0x4]
; 	z_arm_prepare_switch_to_main();
 800677c: f015 fe51    	bl	0x801c422 <z_arm_prepare_switch_to_main> @ imm = #0x15ca2
 8006780: 68fb         	ldr	r3, [r7, #0xc]
 8006782: 617b         	str	r3, [r7, #0x14]
; 	_current_cpu->current = thread;
 8006784: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x80067c0 <arch_switch_to_main_thread+0x50>
 8006786: 697b         	ldr	r3, [r7, #0x14]
 8006788: 6093         	str	r3, [r2, #0x8]
; }
 800678a: bf00         	nop
; 	z_arm_tls_ptr = main_thread->tls;
 800678c: 68fb         	ldr	r3, [r7, #0xc]
 800678e: f8d3 30c4    	ldr.w	r3, [r3, #0xc4]
 8006792: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80067c4 <arch_switch_to_main_thread+0x54>
 8006794: 6013         	str	r3, [r2]
; 	z_thread_mark_switched_in();
 8006796: f00e fa83    	bl	0x8014ca0 <z_thread_mark_switched_in> @ imm = #0xe506
; 	__asm__ volatile (
 800679a: 687d         	ldr	r5, [r7, #0x4]
 800679c: 68be         	ldr	r6, [r7, #0x8]
 800679e: 462c         	mov	r4, r5
 80067a0: f386 8809    	msr	psp, r6
 80067a4: f04f 0000    	mov.w	r0, #0x0
 80067a8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80067c8 <arch_switch_to_main_thread+0x58>
 80067aa: 4798         	blx	r3
 80067ac: 4620         	mov	r0, r4
 80067ae: f04f 0100    	mov.w	r1, #0x0
 80067b2: f04f 0200    	mov.w	r2, #0x0
 80067b6: f04f 0300    	mov.w	r3, #0x0
 80067ba: 4c04         	ldr	r4, [pc, #0x10]         @ 0x80067cc <arch_switch_to_main_thread+0x5c>
 80067bc: 4720         	bx	r4
 80067be: bf00         	nop

080067c0 <$d>:
 80067c0: a8 25 00 20  	.word	0x200025a8
 80067c4: 24 2d 00 20  	.word	0x20002d24

080067c8 <$d>:
 80067c8: 67 c4 01 08  	.word	0x0801c467
 80067cc: 75 42 00 08  	.word	0x08004275

080067d0 <z_arm_cpu_idle_init>:
; {
 80067d0: b480         	push	{r7}
 80067d2: af00         	add	r7, sp, #0x0
; 	SCB->SCR = SCB_SCR_SEVONPEND_Msk;
 80067d4: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80067e4 <z_arm_cpu_idle_init+0x14>
 80067d6: 2210         	movs	r2, #0x10
 80067d8: 611a         	str	r2, [r3, #0x10]
; }
 80067da: bf00         	nop
 80067dc: 46bd         	mov	sp, r7
 80067de: f85d 7b04    	ldr	r7, [sp], #4
 80067e2: 4770         	bx	lr

080067e4 <$d>:
 80067e4: 00 ed 00 e0  	.word	0xe000ed00

080067e8 <__NVIC_SetPriority>:
; {
 80067e8: b480         	push	{r7}
 80067ea: b083         	sub	sp, #0xc
 80067ec: af00         	add	r7, sp, #0x0
 80067ee: 4603         	mov	r3, r0
 80067f0: 6039         	str	r1, [r7]
 80067f2: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 80067f4: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80067f8: 2b00         	cmp	r3, #0x0
 80067fa: db0a         	blt	0x8006812 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80067fc: 683b         	ldr	r3, [r7]
 80067fe: b2da         	uxtb	r2, r3
 8006800: 490c         	ldr	r1, [pc, #0x30]         @ 0x8006834 <__NVIC_SetPriority+0x4c>
 8006802: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8006806: 0112         	lsls	r2, r2, #0x4
 8006808: b2d2         	uxtb	r2, r2
 800680a: 440b         	add	r3, r1
 800680c: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8006810: e00a         	b	0x8006828 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8006812: 683b         	ldr	r3, [r7]
 8006814: b2da         	uxtb	r2, r3
 8006816: 4908         	ldr	r1, [pc, #0x20]         @ 0x8006838 <__NVIC_SetPriority+0x50>
 8006818: 79fb         	ldrb	r3, [r7, #0x7]
 800681a: f003 030f    	and	r3, r3, #0xf
 800681e: 3b04         	subs	r3, #0x4
 8006820: 0112         	lsls	r2, r2, #0x4
 8006822: b2d2         	uxtb	r2, r2
 8006824: 440b         	add	r3, r1
 8006826: 761a         	strb	r2, [r3, #0x18]
; }
 8006828: bf00         	nop
 800682a: 370c         	adds	r7, #0xc
 800682c: 46bd         	mov	sp, r7
 800682e: f85d 7b04    	ldr	r7, [sp], #4
 8006832: 4770         	bx	lr

08006834 <$d>:
 8006834: 00 e1 00 e0  	.word	0xe000e100
 8006838: 00 ed 00 e0  	.word	0xe000ed00

0800683c <_isr_wrapper>:
; {
 800683c: b580         	push	{r7, lr}
 800683e: b084         	sub	sp, #0x10
 8006840: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8006842: f3ef 8305    	mrs	r3, ipsr
 8006846: 607b         	str	r3, [r7, #0x4]
;   return(result);
 8006848: 687b         	ldr	r3, [r7, #0x4]
; 	int32_t irq_number = __get_IPSR();
 800684a: 60fb         	str	r3, [r7, #0xc]
; 	irq_number -= 16;
 800684c: 68fb         	ldr	r3, [r7, #0xc]
 800684e: 3b10         	subs	r3, #0x10
 8006850: 60fb         	str	r3, [r7, #0xc]
; 	struct _isr_table_entry *entry = &_sw_isr_table[irq_number];
 8006852: 68fb         	ldr	r3, [r7, #0xc]
 8006854: 00db         	lsls	r3, r3, #0x3
 8006856: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8006874 <_isr_wrapper+0x38>
 8006858: 4413         	add	r3, r2
 800685a: 60bb         	str	r3, [r7, #0x8]
; 	(entry->isr)(entry->arg);
 800685c: 68bb         	ldr	r3, [r7, #0x8]
 800685e: 685b         	ldr	r3, [r3, #0x4]
 8006860: 68ba         	ldr	r2, [r7, #0x8]
 8006862: 6812         	ldr	r2, [r2]
 8006864: 4610         	mov	r0, r2
 8006866: 4798         	blx	r3
; 	z_arm_exc_exit();
 8006868: f7fe fee6    	bl	0x8005638 <z_arm_int_exit> @ imm = #-0x1234
; }
 800686c: bf00         	nop
 800686e: 3710         	adds	r7, #0x10
 8006870: 46bd         	mov	sp, r7
 8006872: bd80         	pop	{r7, pc}

08006874 <$d>:
 8006874: 18 7d 02 08  	.word	0x08027d18

08006878 <cbvprintf>:
; {
 8006878: b580         	push	{r7, lr}
 800687a: b08a         	sub	sp, #0x28
 800687c: af00         	add	r7, sp, #0x0
 800687e: 60f8         	str	r0, [r7, #0xc]
 8006880: 60b9         	str	r1, [r7, #0x8]
 8006882: 607a         	str	r2, [r7, #0x4]
 8006884: 603b         	str	r3, [r7]
; 	struct cb_bits	s = {
 8006886: f107 0310    	add.w	r3, r7, #0x10
 800688a: 2200         	movs	r2, #0x0
 800688c: 601a         	str	r2, [r3]
 800688e: 605a         	str	r2, [r3, #0x4]
 8006890: 609a         	str	r2, [r3, #0x8]
 8006892: 60da         	str	r2, [r3, #0xc]
 8006894: 611a         	str	r2, [r3, #0x10]
 8006896: 615a         	str	r2, [r3, #0x14]
 8006898: 2302         	movs	r3, #0x2
 800689a: 74bb         	strb	r3, [r7, #0x12]
 800689c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80068c0 <cbvprintf+0x48>
 800689e: 617b         	str	r3, [r7, #0x14]
 80068a0: 68fb         	ldr	r3, [r7, #0xc]
 80068a2: 623b         	str	r3, [r7, #0x20]
 80068a4: 68bb         	ldr	r3, [r7, #0x8]
 80068a6: 627b         	str	r3, [r7, #0x24]
; 	return vfprintf(&s.f, fp, ap);
 80068a8: f107 0310    	add.w	r3, r7, #0x10
 80068ac: 683a         	ldr	r2, [r7]
 80068ae: 6879         	ldr	r1, [r7, #0x4]
 80068b0: 4618         	mov	r0, r3
 80068b2: f011 f877    	bl	0x80179a4 <vfprintf>    @ imm = #0x110ee
 80068b6: 4603         	mov	r3, r0
; }
 80068b8: 4618         	mov	r0, r3
 80068ba: 3728         	adds	r7, #0x28
 80068bc: 46bd         	mov	sp, r7
 80068be: bd80         	pop	{r7, pc}

080068c0 <$d>:
 80068c0: 03 c5 01 08  	.word	0x0801c503

080068c4 <z_impl_zephyr_fputc>:
; {
 80068c4: b580         	push	{r7, lr}
 80068c6: b082         	sub	sp, #0x8
 80068c8: af00         	add	r7, sp, #0x0
 80068ca: 6078         	str	r0, [r7, #0x4]
 80068cc: 6039         	str	r1, [r7]
; 	(*_stdout_hook)(a);
 80068ce: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80068e0 <z_impl_zephyr_fputc+0x1c>
 80068d0: 681b         	ldr	r3, [r3]
 80068d2: 6878         	ldr	r0, [r7, #0x4]
 80068d4: 4798         	blx	r3
; 	return 0;
 80068d6: 2300         	movs	r3, #0x0
; }
 80068d8: 4618         	mov	r0, r3
 80068da: 3708         	adds	r7, #0x8
 80068dc: 46bd         	mov	sp, r7
 80068de: bd80         	pop	{r7, pc}

080068e0 <$d>:
 80068e0: 28 2d 00 20  	.word	0x20002d28

080068e4 <__stdout_hook_install>:
; {
 80068e4: b480         	push	{r7}
 80068e6: b083         	sub	sp, #0xc
 80068e8: af00         	add	r7, sp, #0x0
 80068ea: 6078         	str	r0, [r7, #0x4]
; 	_stdout_hook = hook;
 80068ec: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800690c <__stdout_hook_install+0x28>
 80068ee: 687b         	ldr	r3, [r7, #0x4]
 80068f0: 6013         	str	r3, [r2]
; 	__stdout.flags |= _FDEV_SETUP_WRITE;
 80068f2: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8006910 <__stdout_hook_install+0x2c>
 80068f4: 789b         	ldrb	r3, [r3, #0x2]
 80068f6: f043 0302    	orr	r3, r3, #0x2
 80068fa: b2da         	uxtb	r2, r3
 80068fc: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8006910 <__stdout_hook_install+0x2c>
 80068fe: 709a         	strb	r2, [r3, #0x2]
; }
 8006900: bf00         	nop
 8006902: 370c         	adds	r7, #0xc
 8006904: 46bd         	mov	sp, r7
 8006906: f85d 7b04    	ldr	r7, [sp], #4
 800690a: 4770         	bx	lr

0800690c <$d>:
 800690c: 28 2d 00 20  	.word	0x20002d28
 8006910: f8 04 00 20  	.word	0x200004f8

08006914 <malloc_lock>:
; malloc_lock(void) {
 8006914: b580         	push	{r7, lr}
 8006916: b082         	sub	sp, #0x8
 8006918: af00         	add	r7, sp, #0x0
; 	lock_ret = sys_mutex_lock(&z_malloc_heap_mutex, K_FOREVER);
 800691a: f04f 32ff    	mov.w	r2, #0xffffffff
 800691e: f04f 33ff    	mov.w	r3, #0xffffffff
 8006922: 4804         	ldr	r0, [pc, #0x10]         @ 0x8006934 <malloc_lock+0x20>
 8006924: f015 fe3b    	bl	0x801c59e <sys_mutex_lock> @ imm = #0x15c76
 8006928: 6078         	str	r0, [r7, #0x4]
; }
 800692a: bf00         	nop
 800692c: 3708         	adds	r7, #0x8
 800692e: 46bd         	mov	sp, r7
 8006930: bd80         	pop	{r7, pc}
 8006932: bf00         	nop

08006934 <$d>:
 8006934: 08 05 00 20  	.word	0x20000508

08006938 <malloc_unlock>:
; {
 8006938: b580         	push	{r7, lr}
 800693a: af00         	add	r7, sp, #0x0
; 	(void) sys_mutex_unlock(&z_malloc_heap_mutex);
 800693c: 4802         	ldr	r0, [pc, #0x8]          @ 0x8006948 <malloc_unlock+0x10>
 800693e: f015 fe3f    	bl	0x801c5c0 <sys_mutex_unlock> @ imm = #0x15c7e
; }
 8006942: bf00         	nop
 8006944: bd80         	pop	{r7, pc}
 8006946: bf00         	nop

08006948 <$d>:
 8006948: 08 05 00 20  	.word	0x20000508

0800694c <malloc>:
; {
 800694c: b580         	push	{r7, lr}
 800694e: b084         	sub	sp, #0x10
 8006950: af00         	add	r7, sp, #0x0
 8006952: 6078         	str	r0, [r7, #0x4]
; 	malloc_lock();
 8006954: f7ff ffde    	bl	0x8006914 <malloc_lock> @ imm = #-0x44
; 	void *ret = sys_heap_aligned_alloc(&z_malloc_heap,
 8006958: 687a         	ldr	r2, [r7, #0x4]
 800695a: 2108         	movs	r1, #0x8
 800695c: 480b         	ldr	r0, [pc, #0x2c]         @ 0x800698c <malloc+0x40>
 800695e: f014 fb62    	bl	0x801b026 <sys_heap_aligned_alloc> @ imm = #0x146c4
 8006962: 60f8         	str	r0, [r7, #0xc]
; 	if (ret == NULL && size != 0) {
 8006964: 68fb         	ldr	r3, [r7, #0xc]
 8006966: 2b00         	cmp	r3, #0x0
 8006968: d108         	bne	0x800697c <malloc+0x30> @ imm = #0x10
 800696a: 687b         	ldr	r3, [r7, #0x4]
 800696c: 2b00         	cmp	r3, #0x0
 800696e: d005         	beq	0x800697c <malloc+0x30> @ imm = #0xa
; 		errno = ENOMEM;
 8006970: f020 ffac    	bl	0x80278cc <__aeabi_read_tp> @ imm = #0x20f58
 8006974: 4603         	mov	r3, r0
 8006976: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8006990 <malloc+0x44>
 8006978: 210c         	movs	r1, #0xc
 800697a: 5099         	str	r1, [r3, r2]
; 	malloc_unlock();
 800697c: f7ff ffdc    	bl	0x8006938 <malloc_unlock> @ imm = #-0x48
; 	return ret;
 8006980: 68fb         	ldr	r3, [r7, #0xc]
; }
 8006982: 4618         	mov	r0, r3
 8006984: 3710         	adds	r7, #0x10
 8006986: 46bd         	mov	sp, r7
 8006988: bd80         	pop	{r7, pc}
 800698a: bf00         	nop

0800698c <$d>:
 800698c: 2c 2d 00 20  	.word	0x20002d2c
 8006990: 0c 00 00 00  	.word	0x0000000c

08006994 <malloc_prepare>:
; {
 8006994: b580         	push	{r7, lr}
 8006996: b082         	sub	sp, #0x8
 8006998: af00         	add	r7, sp, #0x0
; 	void *heap_base = NULL;
 800699a: 2300         	movs	r3, #0x0
 800699c: 607b         	str	r3, [r7, #0x4]
; 	heap_base = UINT_TO_POINTER(HEAP_BASE);
 800699e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80069d0 <malloc_prepare+0x3c>
 80069a0: 3307         	adds	r3, #0x7
 80069a2: f023 0307    	bic	r3, r3, #0x7
 80069a6: 607b         	str	r3, [r7, #0x4]
; 	heap_size = HEAP_SIZE;
 80069a8: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80069d0 <malloc_prepare+0x3c>
 80069aa: 3307         	adds	r3, #0x7
 80069ac: f023 0307    	bic	r3, r3, #0x7
 80069b0: f1c3 5300    	rsb.w	r3, r3, #0x20000000
 80069b4: f503 3300    	add.w	r3, r3, #0x20000
 80069b8: 603b         	str	r3, [r7]
; 	sys_heap_init(&z_malloc_heap, heap_base, heap_size);
 80069ba: 683a         	ldr	r2, [r7]
 80069bc: 6879         	ldr	r1, [r7, #0x4]
 80069be: 4805         	ldr	r0, [pc, #0x14]         @ 0x80069d4 <malloc_prepare+0x40>
 80069c0: f014 fbda    	bl	0x801b178 <sys_heap_init> @ imm = #0x147b4
; 	return 0;
 80069c4: 2300         	movs	r3, #0x0
; }
 80069c6: 4618         	mov	r0, r3
 80069c8: 3708         	adds	r7, #0x8
 80069ca: 46bd         	mov	sp, r7
 80069cc: bd80         	pop	{r7, pc}
 80069ce: bf00         	nop

080069d0 <$d>:
 80069d0: 08 6e 00 20  	.word	0x20006e08
 80069d4: 2c 2d 00 20  	.word	0x20002d2c

080069d8 <k_current_get>:
; {
 80069d8: b580         	push	{r7, lr}
 80069da: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 80069dc: f020 ff76    	bl	0x80278cc <__aeabi_read_tp> @ imm = #0x20eec
 80069e0: 4603         	mov	r3, r0
 80069e2: 4a02         	ldr	r2, [pc, #0x8]          @ 0x80069ec <k_current_get+0x14>
 80069e4: 589b         	ldr	r3, [r3, r2]
; }
 80069e6: 4618         	mov	r0, r3
 80069e8: bd80         	pop	{r7, pc}
 80069ea: bf00         	nop

080069ec <$d>:
 80069ec: 08 00 00 00  	.word	0x00000008

080069f0 <net_buf_pool_get>:
; {
 80069f0: b480         	push	{r7}
 80069f2: b085         	sub	sp, #0x14
 80069f4: af00         	add	r7, sp, #0x0
 80069f6: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(net_buf_pool, id, &pool);
 80069f8: 687a         	ldr	r2, [r7, #0x4]
 80069fa: 4613         	mov	r3, r2
 80069fc: 00db         	lsls	r3, r3, #0x3
 80069fe: 4413         	add	r3, r2
 8006a00: 009b         	lsls	r3, r3, #0x2
 8006a02: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8006a18 <net_buf_pool_get+0x28>
 8006a04: 4413         	add	r3, r2
 8006a06: 60fb         	str	r3, [r7, #0xc]
; 	return pool;
 8006a08: 68fb         	ldr	r3, [r7, #0xc]
; }
 8006a0a: 4618         	mov	r0, r3
 8006a0c: 3714         	adds	r7, #0x14
 8006a0e: 46bd         	mov	sp, r7
 8006a10: f85d 7b04    	ldr	r7, [sp], #4
 8006a14: 4770         	bx	lr
 8006a16: bf00         	nop

08006a18 <$d>:
 8006a18: 70 0c 00 20  	.word	0x20000c70

08006a1c <pool_id>:
; {
 8006a1c: b480         	push	{r7}
 8006a1e: b083         	sub	sp, #0xc
 8006a20: af00         	add	r7, sp, #0x0
 8006a22: 6078         	str	r0, [r7, #0x4]
; 	return pool - TYPE_SECTION_START(net_buf_pool);
 8006a24: 687b         	ldr	r3, [r7, #0x4]
 8006a26: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8006a40 <pool_id+0x24>
 8006a28: 1a9b         	subs	r3, r3, r2
 8006a2a: 109b         	asrs	r3, r3, #0x2
 8006a2c: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8006a44 <pool_id+0x28>
 8006a2e: fb02 f303    	mul	r3, r2, r3
; }
 8006a32: 4618         	mov	r0, r3
 8006a34: 370c         	adds	r7, #0xc
 8006a36: 46bd         	mov	sp, r7
 8006a38: f85d 7b04    	ldr	r7, [sp], #4
 8006a3c: 4770         	bx	lr
 8006a3e: bf00         	nop

08006a40 <$d>:
 8006a40: 70 0c 00 20  	.word	0x20000c70
 8006a44: 39 8e e3 38  	.word	0x38e38e39

08006a48 <net_buf_alloc_len>:
; {
 8006a48: b590         	push	{r4, r7, lr}
 8006a4a: b0a7         	sub	sp, #0x9c
 8006a4c: af04         	add	r7, sp, #0x10
 8006a4e: 60f8         	str	r0, [r7, #0xc]
 8006a50: 60b9         	str	r1, [r7, #0x8]
 8006a52: e9c7 2300    	strd	r2, r3, [r7]
; 	k_timepoint_t end = sys_timepoint_calc(timeout);
 8006a56: f107 0128    	add.w	r1, r7, #0x28
 8006a5a: e9d7 2300    	ldrd	r2, r3, [r7]
 8006a5e: 4608         	mov	r0, r1
 8006a60: f020 facc    	bl	0x8026ffc <sys_timepoint_calc> @ imm = #0x20598
; 	key = k_spin_lock(&pool->lock);
 8006a64: 68fb         	ldr	r3, [r7, #0xc]
 8006a66: 3310         	adds	r3, #0x10
 8006a68: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8006a6a: f3ef 8311    	mrs	r3, basepri
 8006a6e: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 8006a70: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 8006a72: 667b         	str	r3, [r7, #0x64]
 8006a74: 2310         	movs	r3, #0x10
 8006a76: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8006a78: 6e3b         	ldr	r3, [r7, #0x60]
 8006a7a: f383 8812    	msr	basepri_max, r3
; }
 8006a7e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006a80: f3bf 8f6f    	isb	sy
; }
 8006a84: bf00         	nop
; 	return key;
 8006a86: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 8006a88: 61fb         	str	r3, [r7, #0x1c]
 8006a8a: 6efb         	ldr	r3, [r7, #0x6c]
 8006a8c: 65fb         	str	r3, [r7, #0x5c]
; }
 8006a8e: bf00         	nop
 8006a90: 6efb         	ldr	r3, [r7, #0x6c]
 8006a92: 65bb         	str	r3, [r7, #0x58]
; }
 8006a94: bf00         	nop
; 	return k;
 8006a96: 69fb         	ldr	r3, [r7, #0x1c]
 8006a98: 627b         	str	r3, [r7, #0x24]
; 	if (pool->uninit_count) {
 8006a9a: 68fb         	ldr	r3, [r7, #0xc]
 8006a9c: 8a5b         	ldrh	r3, [r3, #0x12]
 8006a9e: 2b00         	cmp	r3, #0x0
 8006aa0: d04b         	beq	0x8006b3a <net_buf_alloc_len+0xf2> @ imm = #0x96
; 		if (pool->uninit_count < pool->buf_count) {
 8006aa2: 68fb         	ldr	r3, [r7, #0xc]
 8006aa4: 8a5a         	ldrh	r2, [r3, #0x12]
 8006aa6: 68fb         	ldr	r3, [r7, #0xc]
 8006aa8: 8a1b         	ldrh	r3, [r3, #0x10]
 8006aaa: 429a         	cmp	r2, r3
 8006aac: d222         	bhs	0x8006af4 <net_buf_alloc_len+0xac> @ imm = #0x44
; 			buf = k_lifo_get(&pool->free, K_NO_WAIT);
 8006aae: 68f9         	ldr	r1, [r7, #0xc]
 8006ab0: f04f 0200    	mov.w	r2, #0x0
 8006ab4: f04f 0300    	mov.w	r3, #0x0
 8006ab8: 4608         	mov	r0, r1
 8006aba: f015 fdb7    	bl	0x801c62c <k_queue_get> @ imm = #0x15b6e
 8006abe: 6778         	str	r0, [r7, #0x74]
 8006ac0: 6f79         	ldr	r1, [r7, #0x74]
 8006ac2: f8c7 1084    	str.w	r1, [r7, #0x84]
; 			if (buf) {
 8006ac6: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006aca: 2b00         	cmp	r3, #0x0
 8006acc: d012         	beq	0x8006af4 <net_buf_alloc_len+0xac> @ imm = #0x24
; 				k_spin_unlock(&pool->lock, key);
 8006ace: 68fb         	ldr	r3, [r7, #0xc]
 8006ad0: 3310         	adds	r3, #0x10
 8006ad2: 657b         	str	r3, [r7, #0x54]
 8006ad4: 6a7b         	ldr	r3, [r7, #0x24]
 8006ad6: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8006ad8: 697b         	ldr	r3, [r7, #0x14]
 8006ada: 653b         	str	r3, [r7, #0x50]
 8006adc: 6d3b         	ldr	r3, [r7, #0x50]
 8006ade: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006ae0: 6cfb         	ldr	r3, [r7, #0x4c]
 8006ae2: f383 8811    	msr	basepri, r3
; }
 8006ae6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006ae8: f3bf 8f6f    	isb	sy
; }
 8006aec: bf00         	nop
; }
 8006aee: bf00         	nop
; }
 8006af0: bf00         	nop
; 				goto success;
 8006af2: e07a         	b	0x8006bea <net_buf_alloc_len+0x1a2> @ imm = #0xf4
; 		uninit_count = pool->uninit_count--;
 8006af4: 68fb         	ldr	r3, [r7, #0xc]
 8006af6: 8a5b         	ldrh	r3, [r3, #0x12]
 8006af8: 1e5a         	subs	r2, r3, #0x1
 8006afa: b291         	uxth	r1, r2
 8006afc: 68fa         	ldr	r2, [r7, #0xc]
 8006afe: 8251         	strh	r1, [r2, #0x12]
 8006b00: f8a7 3072    	strh.w	r3, [r7, #0x72]
; 		k_spin_unlock(&pool->lock, key);
 8006b04: 68fb         	ldr	r3, [r7, #0xc]
 8006b06: 3310         	adds	r3, #0x10
 8006b08: 64bb         	str	r3, [r7, #0x48]
 8006b0a: 6a7b         	ldr	r3, [r7, #0x24]
 8006b0c: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8006b0e: 69bb         	ldr	r3, [r7, #0x18]
 8006b10: 647b         	str	r3, [r7, #0x44]
 8006b12: 6c7b         	ldr	r3, [r7, #0x44]
 8006b14: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006b16: 6c3b         	ldr	r3, [r7, #0x40]
 8006b18: f383 8811    	msr	basepri, r3
; }
 8006b1c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006b1e: f3bf 8f6f    	isb	sy
; }
 8006b22: bf00         	nop
; }
 8006b24: bf00         	nop
; }
 8006b26: bf00         	nop
; 		buf = pool_get_uninit(pool, uninit_count);
 8006b28: f8b7 3072    	ldrh.w	r3, [r7, #0x72]
 8006b2c: 4619         	mov	r1, r3
 8006b2e: 68f8         	ldr	r0, [r7, #0xc]
 8006b30: f015 fde6    	bl	0x801c700 <pool_get_uninit> @ imm = #0x15bcc
 8006b34: f8c7 0084    	str.w	r0, [r7, #0x84]
; 		goto success;
 8006b38: e057         	b	0x8006bea <net_buf_alloc_len+0x1a2> @ imm = #0xae
; 	k_spin_unlock(&pool->lock, key);
 8006b3a: 68fb         	ldr	r3, [r7, #0xc]
 8006b3c: 3310         	adds	r3, #0x10
 8006b3e: 63fb         	str	r3, [r7, #0x3c]
 8006b40: 6a7b         	ldr	r3, [r7, #0x24]
 8006b42: 623b         	str	r3, [r7, #0x20]
; 	arch_irq_unlock(key.key);
 8006b44: 6a3b         	ldr	r3, [r7, #0x20]
 8006b46: 63bb         	str	r3, [r7, #0x38]
 8006b48: 6bbb         	ldr	r3, [r7, #0x38]
 8006b4a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006b4c: 6b7b         	ldr	r3, [r7, #0x34]
 8006b4e: f383 8811    	msr	basepri, r3
; }
 8006b52: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006b54: f3bf 8f6f    	isb	sy
; }
 8006b58: bf00         	nop
; }
 8006b5a: bf00         	nop
; }
 8006b5c: bf00         	nop
; 	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 8006b5e: e9d7 2300    	ldrd	r2, r3, [r7]
 8006b62: f04f 0000    	mov.w	r0, #0x0
 8006b66: f04f 0100    	mov.w	r1, #0x0
 8006b6a: 428b         	cmp	r3, r1
 8006b6c: bf08         	it	eq
 8006b6e: 4282         	cmpeq	r2, r0
 8006b70: d02a         	beq	0x8006bc8 <net_buf_alloc_len+0x180> @ imm = #0x54
; 	    k_current_get() == k_work_queue_thread_get(&k_sys_work_q)) {
 8006b72: f7ff ff31    	bl	0x80069d8 <k_current_get> @ imm = #-0x19e
 8006b76: 4604         	mov	r4, r0
 8006b78: 4841         	ldr	r0, [pc, #0x104]        @ 0x8006c80 <net_buf_alloc_len+0x238>
 8006b7a: f015 fd4c    	bl	0x801c616 <k_work_queue_thread_get> @ imm = #0x15a98
 8006b7e: 4603         	mov	r3, r0
; 	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 8006b80: 429c         	cmp	r4, r3
 8006b82: d121         	bne	0x8006bc8 <net_buf_alloc_len+0x180> @ imm = #0x42
; 		LOG_WRN("Timeout discarded. No blocking in syswq");
 8006b84: 2303         	movs	r3, #0x3
 8006b86: 2b01         	cmp	r3, #0x1
 8006b88: d918         	bls	0x8006bbc <net_buf_alloc_len+0x174> @ imm = #0x30
 8006b8a: 2301         	movs	r3, #0x1
 8006b8c: f887 3083    	strb.w	r3, [r7, #0x83]
 8006b90: f897 3083    	ldrb.w	r3, [r7, #0x83]
 8006b94: f083 0301    	eor	r3, r3, #0x1
 8006b98: b2db         	uxtb	r3, r3
 8006b9a: 2b00         	cmp	r3, #0x0
 8006b9c: d10e         	bne	0x8006bbc <net_buf_alloc_len+0x174> @ imm = #0x1c
 8006b9e: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8006c84 <net_buf_alloc_len+0x23c>
 8006ba0: 6819         	ldr	r1, [r3]
 8006ba2: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8006c88 <net_buf_alloc_len+0x240>
 8006ba4: 9302         	str	r3, [sp, #0x8]
 8006ba6: 2300         	movs	r3, #0x0
 8006ba8: 9301         	str	r3, [sp, #0x4]
 8006baa: 2300         	movs	r3, #0x0
 8006bac: 9300         	str	r3, [sp]
 8006bae: 2300         	movs	r3, #0x0
 8006bb0: 2202         	movs	r2, #0x2
 8006bb2: 2000         	movs	r0, #0x0
 8006bb4: f015 fd11    	bl	0x801c5da <z_log_msg_runtime_create> @ imm = #0x15a22
 8006bb8: 2300         	movs	r3, #0x0
 8006bba: 67fb         	str	r3, [r7, #0x7c]
; 		timeout = K_NO_WAIT;
 8006bbc: f04f 0200    	mov.w	r2, #0x0
 8006bc0: f04f 0300    	mov.w	r3, #0x0
 8006bc4: e9c7 2300    	strd	r2, r3, [r7]
; 	buf = k_lifo_get(&pool->free, timeout);
 8006bc8: 68f9         	ldr	r1, [r7, #0xc]
 8006bca: e9d7 2300    	ldrd	r2, r3, [r7]
 8006bce: 4608         	mov	r0, r1
 8006bd0: f015 fd2c    	bl	0x801c62c <k_queue_get> @ imm = #0x15a58
 8006bd4: 67b8         	str	r0, [r7, #0x78]
 8006bd6: 6fbb         	ldr	r3, [r7, #0x78]
 8006bd8: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	if (!buf) {
 8006bdc: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006be0: 2b00         	cmp	r3, #0x0
 8006be2: d101         	bne	0x8006be8 <net_buf_alloc_len+0x1a0> @ imm = #0x2
; 		return NULL;
 8006be4: 2300         	movs	r3, #0x0
 8006be6: e046         	b	0x8006c76 <net_buf_alloc_len+0x22e> @ imm = #0x8c
; success:
 8006be8: bf00         	nop
; 	if (size) {
 8006bea: 68bb         	ldr	r3, [r7, #0x8]
 8006bec: 2b00         	cmp	r3, #0x0
 8006bee: d01c         	beq	0x8006c2a <net_buf_alloc_len+0x1e2> @ imm = #0x38
; 		timeout = sys_timepoint_timeout(end);
 8006bf0: 4639         	mov	r1, r7
 8006bf2: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8006bf6: 4608         	mov	r0, r1
 8006bf8: f020 fa65    	bl	0x80270c6 <sys_timepoint_timeout> @ imm = #0x204ca
; 		buf->__buf = data_alloc(buf, &size, timeout);
 8006bfc: f107 0108    	add.w	r1, r7, #0x8
 8006c00: e9d7 2300    	ldrd	r2, r3, [r7]
 8006c04: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 8006c08: f015 fdfd    	bl	0x801c806 <data_alloc>  @ imm = #0x15bfa
 8006c0c: 4602         	mov	r2, r0
 8006c0e: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c12: 615a         	str	r2, [r3, #0x14]
; 		if (!buf->__buf) {
 8006c14: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c18: 695b         	ldr	r3, [r3, #0x14]
 8006c1a: 2b00         	cmp	r3, #0x0
 8006c1c: d109         	bne	0x8006c32 <net_buf_alloc_len+0x1ea> @ imm = #0x12
; 			net_buf_destroy(buf);
 8006c1e: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 8006c22: f015 fd24    	bl	0x801c66e <net_buf_destroy> @ imm = #0x15a48
; 			return NULL;
 8006c26: 2300         	movs	r3, #0x0
 8006c28: e025         	b	0x8006c76 <net_buf_alloc_len+0x22e> @ imm = #0x4a
; 		buf->__buf = NULL;
 8006c2a: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c2e: 2200         	movs	r2, #0x0
 8006c30: 615a         	str	r2, [r3, #0x14]
; 	buf->ref   = 1U;
 8006c32: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c36: 2201         	movs	r2, #0x1
 8006c38: 721a         	strb	r2, [r3, #0x8]
; 	buf->flags = 0U;
 8006c3a: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c3e: 2200         	movs	r2, #0x0
 8006c40: 725a         	strb	r2, [r3, #0x9]
; 	buf->frags = NULL;
 8006c42: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c46: 2200         	movs	r2, #0x0
 8006c48: 605a         	str	r2, [r3, #0x4]
; 	buf->size  = size;
 8006c4a: 68bb         	ldr	r3, [r7, #0x8]
 8006c4c: b29a         	uxth	r2, r3
 8006c4e: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c52: 825a         	strh	r2, [r3, #0x12]
; 	memset(buf->user_data, 0, buf->user_data_size);
 8006c54: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c58: f103 0018    	add.w	r0, r3, #0x18
 8006c5c: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8006c60: 7adb         	ldrb	r3, [r3, #0xb]
 8006c62: 461a         	mov	r2, r3
 8006c64: 2100         	movs	r1, #0x0
 8006c66: f020 fc4f    	bl	0x8027508 <memset>      @ imm = #0x2089e
; 	net_buf_reset(buf);
 8006c6a: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 8006c6e: f015 fd72    	bl	0x801c756 <net_buf_reset> @ imm = #0x15ae4
; 	return buf;
 8006c72: f8d7 3084    	ldr.w	r3, [r7, #0x84]
; }
 8006c76: 4618         	mov	r0, r3
 8006c78: 378c         	adds	r7, #0x8c
 8006c7a: 46bd         	mov	sp, r7
 8006c7c: bd90         	pop	{r4, r7, pc}
 8006c7e: bf00         	nop

08006c80 <$d>:
 8006c80: 20 28 00 20  	.word	0x20002820
 8006c84: 1c 05 00 20  	.word	0x2000051c
 8006c88: 1c 8a 02 08  	.word	0x08028a1c

08006c8c <k_current_get>:
; {
 8006c8c: b580         	push	{r7, lr}
 8006c8e: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 8006c90: f020 fe1c    	bl	0x80278cc <__aeabi_read_tp> @ imm = #0x20c38
 8006c94: 4603         	mov	r3, r0
 8006c96: 4a02         	ldr	r2, [pc, #0x8]          @ 0x8006ca0 <k_current_get+0x14>
 8006c98: 589b         	ldr	r3, [r3, r2]
; }
 8006c9a: 4618         	mov	r0, r3
 8006c9c: bd80         	pop	{r7, pc}
 8006c9e: bf00         	nop

08006ca0 <$d>:
 8006ca0: 08 00 00 00  	.word	0x00000008

08006ca4 <_zbus_init>:
; {
 8006ca4: b480         	push	{r7}
 8006ca6: b085         	sub	sp, #0x14
 8006ca8: af00         	add	r7, sp, #0x0
; 	const struct zbus_channel *curr = NULL;
 8006caa: 2300         	movs	r3, #0x0
 8006cac: 607b         	str	r3, [r7, #0x4]
; 	const struct zbus_channel *prev = NULL;
 8006cae: 2300         	movs	r3, #0x0
 8006cb0: 60fb         	str	r3, [r7, #0xc]
; 	STRUCT_SECTION_FOREACH(zbus_channel_observation, observation) {
 8006cb2: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8006d38 <_zbus_init+0x94>
 8006cb4: 60bb         	str	r3, [r7, #0x8]
 8006cb6: e02e         	b	0x8006d16 <_zbus_init+0x72> @ imm = #0x5c
; 		curr = observation->chan;
 8006cb8: 68bb         	ldr	r3, [r7, #0x8]
 8006cba: 681b         	ldr	r3, [r3]
 8006cbc: 607b         	str	r3, [r7, #0x4]
; 		if (prev != curr) {
 8006cbe: 68fa         	ldr	r2, [r7, #0xc]
 8006cc0: 687b         	ldr	r3, [r7, #0x4]
 8006cc2: 429a         	cmp	r2, r3
 8006cc4: d01b         	beq	0x8006cfe <_zbus_init+0x5a> @ imm = #0x36
; 			if (prev == NULL) {
 8006cc6: 68fb         	ldr	r3, [r7, #0xc]
 8006cc8: 2b00         	cmp	r3, #0x0
 8006cca: d108         	bne	0x8006cde <_zbus_init+0x3a> @ imm = #0x10
; 				curr->data->observers_start_idx = 0;
 8006ccc: 687b         	ldr	r3, [r7, #0x4]
 8006cce: 691b         	ldr	r3, [r3, #0x10]
 8006cd0: 2200         	movs	r2, #0x0
 8006cd2: 801a         	strh	r2, [r3]
; 				curr->data->observers_end_idx = 0;
 8006cd4: 687b         	ldr	r3, [r7, #0x4]
 8006cd6: 691b         	ldr	r3, [r3, #0x10]
 8006cd8: 2200         	movs	r2, #0x0
 8006cda: 805a         	strh	r2, [r3, #0x2]
 8006cdc: e00d         	b	0x8006cfa <_zbus_init+0x56> @ imm = #0x1a
; 				curr->data->observers_start_idx = prev->data->observers_end_idx;
 8006cde: 68fb         	ldr	r3, [r7, #0xc]
 8006ce0: 691a         	ldr	r2, [r3, #0x10]
 8006ce2: 687b         	ldr	r3, [r7, #0x4]
 8006ce4: 691b         	ldr	r3, [r3, #0x10]
 8006ce6: f9b2 2002    	ldrsh.w	r2, [r2, #0x2]
 8006cea: 801a         	strh	r2, [r3]
; 				curr->data->observers_end_idx = prev->data->observers_end_idx;
 8006cec: 68fb         	ldr	r3, [r7, #0xc]
 8006cee: 691a         	ldr	r2, [r3, #0x10]
 8006cf0: 687b         	ldr	r3, [r7, #0x4]
 8006cf2: 691b         	ldr	r3, [r3, #0x10]
 8006cf4: f9b2 2002    	ldrsh.w	r2, [r2, #0x2]
 8006cf8: 805a         	strh	r2, [r3, #0x2]
; 			prev = curr;
 8006cfa: 687b         	ldr	r3, [r7, #0x4]
 8006cfc: 60fb         	str	r3, [r7, #0xc]
; 		++(curr->data->observers_end_idx);
 8006cfe: 687b         	ldr	r3, [r7, #0x4]
 8006d00: 691b         	ldr	r3, [r3, #0x10]
 8006d02: f9b3 2002    	ldrsh.w	r2, [r3, #0x2]
 8006d06: b292         	uxth	r2, r2
 8006d08: 3201         	adds	r2, #0x1
 8006d0a: b292         	uxth	r2, r2
 8006d0c: b212         	sxth	r2, r2
 8006d0e: 805a         	strh	r2, [r3, #0x2]
; 	STRUCT_SECTION_FOREACH(zbus_channel_observation, observation) {
 8006d10: 68bb         	ldr	r3, [r7, #0x8]
 8006d12: 3308         	adds	r3, #0x8
 8006d14: 60bb         	str	r3, [r7, #0x8]
 8006d16: 68bb         	ldr	r3, [r7, #0x8]
 8006d18: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8006d3c <_zbus_init+0x98>
 8006d1a: 4293         	cmp	r3, r2
 8006d1c: bf34         	ite	lo
 8006d1e: 2301         	movlo	r3, #0x1
 8006d20: 2300         	movhs	r3, #0x0
 8006d22: b2db         	uxtb	r3, r3
 8006d24: 2b00         	cmp	r3, #0x0
 8006d26: d1c7         	bne	0x8006cb8 <_zbus_init+0x14> @ imm = #-0x72
; 	return 0;
 8006d28: 2300         	movs	r3, #0x0
; }
 8006d2a: 4618         	mov	r0, r3
 8006d2c: 3714         	adds	r7, #0x14
 8006d2e: 46bd         	mov	sp, r7
 8006d30: f85d 7b04    	ldr	r7, [sp], #4
 8006d34: 4770         	bx	lr
 8006d36: bf00         	nop

08006d38 <$d>:
 8006d38: 18 82 02 08  	.word	0x08028218
 8006d3c: 20 82 02 08  	.word	0x08028220

08006d40 <_zbus_vded_exec>:
; {
 8006d40: b590         	push	{r4, r7, lr}
 8006d42: b0a1         	sub	sp, #0x84
 8006d44: af06         	add	r7, sp, #0x18
 8006d46: 60f8         	str	r0, [r7, #0xc]
 8006d48: e9c7 2300    	strd	r2, r3, [r7]
; 	int err = 0;
 8006d4c: 2300         	movs	r3, #0x0
 8006d4e: 653b         	str	r3, [r7, #0x50]
; 	int last_error = 0;
 8006d50: 2300         	movs	r3, #0x0
 8006d52: 65fb         	str	r3, [r7, #0x5c]
; 	struct net_buf *buf = NULL;
 8006d54: 2300         	movs	r3, #0x0
 8006d56: 64fb         	str	r3, [r7, #0x4c]
; 	struct net_buf_pool *pool =
 8006d58: 4b9f         	ldr	r3, [pc, #0x27c]        @ 0x8006fd8 <_zbus_vded_exec+0x298>
 8006d5a: 64bb         	str	r3, [r7, #0x48]
; 	buf = _zbus_create_net_buf(pool, zbus_chan_msg_size(chan), sys_timepoint_timeout(end_time));
 8006d5c: 68fb         	ldr	r3, [r7, #0xc]
 8006d5e: 4618         	mov	r0, r3
 8006d60: f015 ff89    	bl	0x801cc76 <zbus_chan_msg_size> @ imm = #0x15f12
 8006d64: 4603         	mov	r3, r0
 8006d66: 461c         	mov	r4, r3
 8006d68: f107 0118    	add.w	r1, r7, #0x18
 8006d6c: e9d7 2300    	ldrd	r2, r3, [r7]
 8006d70: 4608         	mov	r0, r1
 8006d72: f020 f9a8    	bl	0x80270c6 <sys_timepoint_timeout> @ imm = #0x20350
 8006d76: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8006d7a: 4621         	mov	r1, r4
 8006d7c: 6cb8         	ldr	r0, [r7, #0x48]
 8006d7e: f015 ff87    	bl	0x801cc90 <_zbus_create_net_buf> @ imm = #0x15f0e
 8006d82: 64f8         	str	r0, [r7, #0x4c]
; 	memcpy(net_buf_user_data(buf), &chan, sizeof(struct zbus_channel *));
 8006d84: 6cf8         	ldr	r0, [r7, #0x4c]
 8006d86: f015 ff3c    	bl	0x801cc02 <net_buf_user_data> @ imm = #0x15e78
 8006d8a: 4602         	mov	r2, r0
 8006d8c: 68fb         	ldr	r3, [r7, #0xc]
 8006d8e: 6013         	str	r3, [r2]
; 	net_buf_add_mem(buf, zbus_chan_msg(chan), zbus_chan_msg_size(chan));
 8006d90: 68fb         	ldr	r3, [r7, #0xc]
 8006d92: 4618         	mov	r0, r3
 8006d94: f015 ff63    	bl	0x801cc5e <zbus_chan_msg> @ imm = #0x15ec6
 8006d98: 4604         	mov	r4, r0
 8006d9a: 68fb         	ldr	r3, [r7, #0xc]
 8006d9c: 4618         	mov	r0, r3
 8006d9e: f015 ff6a    	bl	0x801cc76 <zbus_chan_msg_size> @ imm = #0x15ed4
 8006da2: 4603         	mov	r3, r0
 8006da4: 461a         	mov	r2, r3
 8006da6: 4621         	mov	r1, r4
 8006da8: 6cf8         	ldr	r0, [r7, #0x4c]
 8006daa: f015 ff36    	bl	0x801cc1a <net_buf_add_mem> @ imm = #0x15e6c
; 	LOG_DBG("Notifing %s's observers. Starting VDED:", _ZBUS_CHAN_NAME(chan));
 8006dae: 2300         	movs	r3, #0x0
 8006db0: 2b03         	cmp	r3, #0x3
 8006db2: d91c         	bls	0x8006dee <_zbus_vded_exec+0xae> @ imm = #0x38
 8006db4: 2301         	movs	r3, #0x1
 8006db6: f887 3047    	strb.w	r3, [r7, #0x47]
 8006dba: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8006dbe: f083 0301    	eor	r3, r3, #0x1
 8006dc2: b2db         	uxtb	r3, r3
 8006dc4: 2b00         	cmp	r3, #0x0
 8006dc6: d112         	bne	0x8006dee <_zbus_vded_exec+0xae> @ imm = #0x24
 8006dc8: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8006fdc <_zbus_vded_exec+0x29c>
 8006dca: 6819         	ldr	r1, [r3]
 8006dcc: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8006fe0 <_zbus_vded_exec+0x2a0>
 8006dce: 9304         	str	r3, [sp, #0x10]
 8006dd0: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8006fe4 <_zbus_vded_exec+0x2a4>
 8006dd2: 9303         	str	r3, [sp, #0xc]
 8006dd4: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8006fe8 <_zbus_vded_exec+0x2a8>
 8006dd6: 9302         	str	r3, [sp, #0x8]
 8006dd8: 2308         	movs	r3, #0x8
 8006dda: 9301         	str	r3, [sp, #0x4]
 8006ddc: 2300         	movs	r3, #0x0
 8006dde: 9300         	str	r3, [sp]
 8006de0: 2300         	movs	r3, #0x0
 8006de2: 2204         	movs	r2, #0x4
 8006de4: 2000         	movs	r0, #0x0
 8006de6: f015 feee    	bl	0x801cbc6 <z_log_msg_runtime_create> @ imm = #0x15ddc
 8006dea: 2300         	movs	r3, #0x0
 8006dec: 643b         	str	r3, [r7, #0x40]
; 	int __maybe_unused index = 0;
 8006dee: 2300         	movs	r3, #0x0
 8006df0: 667b         	str	r3, [r7, #0x64]
; 	for (int16_t i = chan->data->observers_start_idx, limit = chan->data->observers_end_idx;
 8006df2: 68fb         	ldr	r3, [r7, #0xc]
 8006df4: 691b         	ldr	r3, [r3, #0x10]
 8006df6: 881b         	ldrh	r3, [r3]
 8006df8: f8a7 3062    	strh.w	r3, [r7, #0x62]
 8006dfc: 68fb         	ldr	r3, [r7, #0xc]
 8006dfe: 691b         	ldr	r3, [r3, #0x10]
 8006e00: 885b         	ldrh	r3, [r3, #0x2]
 8006e02: 87fb         	strh	r3, [r7, #0x3e]
 8006e04: e07c         	b	0x8006f00 <_zbus_vded_exec+0x1c0> @ imm = #0xf8
; 		STRUCT_SECTION_GET(zbus_channel_observation, i, &observation);
 8006e06: f9b7 3062    	ldrsh.w	r3, [r7, #0x62]
 8006e0a: 00db         	lsls	r3, r3, #0x3
 8006e0c: 4a77         	ldr	r2, [pc, #0x1dc]        @ 0x8006fec <_zbus_vded_exec+0x2ac>
 8006e0e: 4413         	add	r3, r2
 8006e10: 617b         	str	r3, [r7, #0x14]
; 		STRUCT_SECTION_GET(zbus_channel_observation_mask, i, &observation_mask);
 8006e12: f9b7 3062    	ldrsh.w	r3, [r7, #0x62]
 8006e16: 4a76         	ldr	r2, [pc, #0x1d8]        @ 0x8006ff0 <_zbus_vded_exec+0x2b0>
 8006e18: 4413         	add	r3, r2
 8006e1a: 613b         	str	r3, [r7, #0x10]
; 		const struct zbus_observer *obs = observation->obs;
 8006e1c: 697b         	ldr	r3, [r7, #0x14]
 8006e1e: 685b         	ldr	r3, [r3, #0x4]
 8006e20: 637b         	str	r3, [r7, #0x34]
; 		if (!obs->data->enabled || observation_mask->enabled) {
 8006e22: 6b7b         	ldr	r3, [r7, #0x34]
 8006e24: 685b         	ldr	r3, [r3, #0x4]
 8006e26: 781b         	ldrb	r3, [r3]
 8006e28: f083 0301    	eor	r3, r3, #0x1
 8006e2c: b2db         	uxtb	r3, r3
 8006e2e: 2b00         	cmp	r3, #0x0
 8006e30: d15f         	bne	0x8006ef2 <_zbus_vded_exec+0x1b2> @ imm = #0xbe
 8006e32: 693b         	ldr	r3, [r7, #0x10]
 8006e34: 781b         	ldrb	r3, [r3]
 8006e36: 2b00         	cmp	r3, #0x0
 8006e38: d15b         	bne	0x8006ef2 <_zbus_vded_exec+0x1b2> @ imm = #0xb6
; 		err = _zbus_notify_observer(chan, obs, end_time, buf);
 8006e3a: 68f8         	ldr	r0, [r7, #0xc]
 8006e3c: 6cfb         	ldr	r3, [r7, #0x4c]
 8006e3e: 9300         	str	r3, [sp]
 8006e40: e9d7 2300    	ldrd	r2, r3, [r7]
 8006e44: 6b79         	ldr	r1, [r7, #0x34]
 8006e46: f015 ff35    	bl	0x801ccb4 <_zbus_notify_observer> @ imm = #0x15e6a
 8006e4a: 6538         	str	r0, [r7, #0x50]
; 		if (err) {
 8006e4c: 6d3b         	ldr	r3, [r7, #0x50]
 8006e4e: 2b00         	cmp	r3, #0x0
 8006e50: d02a         	beq	0x8006ea8 <_zbus_vded_exec+0x168> @ imm = #0x54
; 			last_error = err;
 8006e52: 6d3b         	ldr	r3, [r7, #0x50]
 8006e54: 65fb         	str	r3, [r7, #0x5c]
; 			LOG_ERR("could not deliver notification to observer %s. Error code %d",
 8006e56: 2300         	movs	r3, #0x0
 8006e58: 2b00         	cmp	r3, #0x0
 8006e5a: d01c         	beq	0x8006e96 <_zbus_vded_exec+0x156> @ imm = #0x38
 8006e5c: 2301         	movs	r3, #0x1
 8006e5e: f887 3033    	strb.w	r3, [r7, #0x33]
 8006e62: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8006e66: f083 0301    	eor	r3, r3, #0x1
 8006e6a: b2db         	uxtb	r3, r3
 8006e6c: 2b00         	cmp	r3, #0x0
 8006e6e: d112         	bne	0x8006e96 <_zbus_vded_exec+0x156> @ imm = #0x24
 8006e70: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x8006fdc <_zbus_vded_exec+0x29c>
 8006e72: 6819         	ldr	r1, [r3]
 8006e74: 6d3b         	ldr	r3, [r7, #0x50]
 8006e76: 9304         	str	r3, [sp, #0x10]
 8006e78: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8006fe0 <_zbus_vded_exec+0x2a0>
 8006e7a: 9303         	str	r3, [sp, #0xc]
 8006e7c: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8006ff4 <_zbus_vded_exec+0x2b4>
 8006e7e: 9302         	str	r3, [sp, #0x8]
 8006e80: 2300         	movs	r3, #0x0
 8006e82: 9301         	str	r3, [sp, #0x4]
 8006e84: 2300         	movs	r3, #0x0
 8006e86: 9300         	str	r3, [sp]
 8006e88: 2300         	movs	r3, #0x0
 8006e8a: 2201         	movs	r2, #0x1
 8006e8c: 2000         	movs	r0, #0x0
 8006e8e: f015 fe9a    	bl	0x801cbc6 <z_log_msg_runtime_create> @ imm = #0x15d34
 8006e92: 2300         	movs	r3, #0x0
 8006e94: 62fb         	str	r3, [r7, #0x2c]
; 			if (err == -ENOMEM) {
 8006e96: 6d3b         	ldr	r3, [r7, #0x50]
 8006e98: f113 0f0c    	cmn.w	r3, #0xc
 8006e9c: d104         	bne	0x8006ea8 <_zbus_vded_exec+0x168> @ imm = #0x8
; 					net_buf_unref(buf);
 8006e9e: 6cf8         	ldr	r0, [r7, #0x4c]
 8006ea0: f015 fce3    	bl	0x801c86a <net_buf_unref> @ imm = #0x159c6
; 				return err;
 8006ea4: 6d3b         	ldr	r3, [r7, #0x50]
 8006ea6: e092         	b	0x8006fce <_zbus_vded_exec+0x28e> @ imm = #0x124
; 		LOG_DBG(" %d -> %s", index++, _ZBUS_OBS_NAME(obs));
 8006ea8: 2300         	movs	r3, #0x0
 8006eaa: 2b03         	cmp	r3, #0x3
 8006eac: d922         	bls	0x8006ef4 <_zbus_vded_exec+0x1b4> @ imm = #0x44
 8006eae: 2301         	movs	r3, #0x1
 8006eb0: f887 302b    	strb.w	r3, [r7, #0x2b]
 8006eb4: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8006eb8: f083 0301    	eor	r3, r3, #0x1
 8006ebc: b2db         	uxtb	r3, r3
 8006ebe: 2b00         	cmp	r3, #0x0
 8006ec0: d118         	bne	0x8006ef4 <_zbus_vded_exec+0x1b4> @ imm = #0x30
 8006ec2: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8006fdc <_zbus_vded_exec+0x29c>
 8006ec4: 6819         	ldr	r1, [r3]
 8006ec6: 6e7b         	ldr	r3, [r7, #0x64]
 8006ec8: 1c5a         	adds	r2, r3, #0x1
 8006eca: 667a         	str	r2, [r7, #0x64]
 8006ecc: 4a44         	ldr	r2, [pc, #0x110]        @ 0x8006fe0 <_zbus_vded_exec+0x2a0>
 8006ece: 9205         	str	r2, [sp, #0x14]
 8006ed0: 9304         	str	r3, [sp, #0x10]
 8006ed2: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8006fe4 <_zbus_vded_exec+0x2a4>
 8006ed4: 9303         	str	r3, [sp, #0xc]
 8006ed6: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8006ff8 <_zbus_vded_exec+0x2b8>
 8006ed8: 9302         	str	r3, [sp, #0x8]
 8006eda: 2308         	movs	r3, #0x8
 8006edc: 9301         	str	r3, [sp, #0x4]
 8006ede: 2300         	movs	r3, #0x0
 8006ee0: 9300         	str	r3, [sp]
 8006ee2: 2300         	movs	r3, #0x0
 8006ee4: 2204         	movs	r2, #0x4
 8006ee6: 2000         	movs	r0, #0x0
 8006ee8: f015 fe6d    	bl	0x801cbc6 <z_log_msg_runtime_create> @ imm = #0x15cda
 8006eec: 2300         	movs	r3, #0x0
 8006eee: 627b         	str	r3, [r7, #0x24]
 8006ef0: e000         	b	0x8006ef4 <_zbus_vded_exec+0x1b4> @ imm = #0x0
; 			continue;
 8006ef2: bf00         	nop
; 	     i < limit; ++i) {
 8006ef4: f8b7 3062    	ldrh.w	r3, [r7, #0x62]
 8006ef8: 3301         	adds	r3, #0x1
 8006efa: b29b         	uxth	r3, r3
 8006efc: f8a7 3062    	strh.w	r3, [r7, #0x62]
 8006f00: f9b7 2062    	ldrsh.w	r2, [r7, #0x62]
 8006f04: f9b7 303e    	ldrsh.w	r3, [r7, #0x3e]
 8006f08: 429a         	cmp	r2, r3
 8006f0a: f6ff af7c    	blt.w	0x8006e06 <_zbus_vded_exec+0xc6> @ imm = #-0x108
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&chan->data->observers, obs_nd, tmp, node) {
 8006f0e: 68fb         	ldr	r3, [r7, #0xc]
 8006f10: 691b         	ldr	r3, [r3, #0x10]
 8006f12: 3318         	adds	r3, #0x18
 8006f14: 4618         	mov	r0, r3
 8006f16: f015 fdd7    	bl	0x801cac8 <sys_slist_peek_head> @ imm = #0x15bae
 8006f1a: 4603         	mov	r3, r0
 8006f1c: 2b00         	cmp	r3, #0x0
 8006f1e: d007         	beq	0x8006f30 <_zbus_vded_exec+0x1f0> @ imm = #0xe
 8006f20: 68fb         	ldr	r3, [r7, #0xc]
 8006f22: 691b         	ldr	r3, [r3, #0x10]
 8006f24: 3318         	adds	r3, #0x18
 8006f26: 4618         	mov	r0, r3
 8006f28: f015 fdce    	bl	0x801cac8 <sys_slist_peek_head> @ imm = #0x15b9c
 8006f2c: 4603         	mov	r3, r0
 8006f2e: e000         	b	0x8006f32 <_zbus_vded_exec+0x1f2> @ imm = #0x0
 8006f30: 2300         	movs	r3, #0x0
 8006f32: 65bb         	str	r3, [r7, #0x58]
 8006f34: 6dbb         	ldr	r3, [r7, #0x58]
 8006f36: 2b00         	cmp	r3, #0x0
 8006f38: d00e         	beq	0x8006f58 <_zbus_vded_exec+0x218> @ imm = #0x1c
 8006f3a: 6dbb         	ldr	r3, [r7, #0x58]
 8006f3c: 4618         	mov	r0, r3
 8006f3e: f015 fddb    	bl	0x801caf8 <sys_slist_peek_next> @ imm = #0x15bb6
 8006f42: 4603         	mov	r3, r0
 8006f44: 2b00         	cmp	r3, #0x0
 8006f46: d005         	beq	0x8006f54 <_zbus_vded_exec+0x214> @ imm = #0xa
 8006f48: 6dbb         	ldr	r3, [r7, #0x58]
 8006f4a: 4618         	mov	r0, r3
 8006f4c: f015 fdd4    	bl	0x801caf8 <sys_slist_peek_next> @ imm = #0x15ba8
 8006f50: 4603         	mov	r3, r0
 8006f52: e002         	b	0x8006f5a <_zbus_vded_exec+0x21a> @ imm = #0x4
 8006f54: 2300         	movs	r3, #0x0
 8006f56: e000         	b	0x8006f5a <_zbus_vded_exec+0x21a> @ imm = #0x0
 8006f58: 2300         	movs	r3, #0x0
 8006f5a: 657b         	str	r3, [r7, #0x54]
 8006f5c: e030         	b	0x8006fc0 <_zbus_vded_exec+0x280> @ imm = #0x60
; 		const struct zbus_observer *obs = obs_nd->obs;
 8006f5e: 6dbb         	ldr	r3, [r7, #0x58]
 8006f60: 685b         	ldr	r3, [r3, #0x4]
 8006f62: 63bb         	str	r3, [r7, #0x38]
; 		if (!obs->data->enabled) {
 8006f64: 6bbb         	ldr	r3, [r7, #0x38]
 8006f66: 685b         	ldr	r3, [r3, #0x4]
 8006f68: 781b         	ldrb	r3, [r3]
 8006f6a: f083 0301    	eor	r3, r3, #0x1
 8006f6e: b2db         	uxtb	r3, r3
 8006f70: 2b00         	cmp	r3, #0x0
 8006f72: d10e         	bne	0x8006f92 <_zbus_vded_exec+0x252> @ imm = #0x1c
; 		err = _zbus_notify_observer(chan, obs, end_time, buf);
 8006f74: 68f8         	ldr	r0, [r7, #0xc]
 8006f76: 6cfb         	ldr	r3, [r7, #0x4c]
 8006f78: 9300         	str	r3, [sp]
 8006f7a: e9d7 2300    	ldrd	r2, r3, [r7]
 8006f7e: 6bb9         	ldr	r1, [r7, #0x38]
 8006f80: f015 fe98    	bl	0x801ccb4 <_zbus_notify_observer> @ imm = #0x15d30
 8006f84: 6538         	str	r0, [r7, #0x50]
; 		if (err) {
 8006f86: 6d3b         	ldr	r3, [r7, #0x50]
 8006f88: 2b00         	cmp	r3, #0x0
 8006f8a: d003         	beq	0x8006f94 <_zbus_vded_exec+0x254> @ imm = #0x6
; 			last_error = err;
 8006f8c: 6d3b         	ldr	r3, [r7, #0x50]
 8006f8e: 65fb         	str	r3, [r7, #0x5c]
 8006f90: e000         	b	0x8006f94 <_zbus_vded_exec+0x254> @ imm = #0x0
; 			continue;
 8006f92: bf00         	nop
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&chan->data->observers, obs_nd, tmp, node) {
 8006f94: 6d7b         	ldr	r3, [r7, #0x54]
 8006f96: 65bb         	str	r3, [r7, #0x58]
 8006f98: 6dbb         	ldr	r3, [r7, #0x58]
 8006f9a: 2b00         	cmp	r3, #0x0
 8006f9c: d00e         	beq	0x8006fbc <_zbus_vded_exec+0x27c> @ imm = #0x1c
 8006f9e: 6dbb         	ldr	r3, [r7, #0x58]
 8006fa0: 4618         	mov	r0, r3
 8006fa2: f015 fda9    	bl	0x801caf8 <sys_slist_peek_next> @ imm = #0x15b52
 8006fa6: 4603         	mov	r3, r0
 8006fa8: 2b00         	cmp	r3, #0x0
 8006faa: d005         	beq	0x8006fb8 <_zbus_vded_exec+0x278> @ imm = #0xa
 8006fac: 6dbb         	ldr	r3, [r7, #0x58]
 8006fae: 4618         	mov	r0, r3
 8006fb0: f015 fda2    	bl	0x801caf8 <sys_slist_peek_next> @ imm = #0x15b44
 8006fb4: 4603         	mov	r3, r0
 8006fb6: e002         	b	0x8006fbe <_zbus_vded_exec+0x27e> @ imm = #0x4
 8006fb8: 2300         	movs	r3, #0x0
 8006fba: e000         	b	0x8006fbe <_zbus_vded_exec+0x27e> @ imm = #0x0
 8006fbc: 2300         	movs	r3, #0x0
 8006fbe: 657b         	str	r3, [r7, #0x54]
 8006fc0: 6dbb         	ldr	r3, [r7, #0x58]
 8006fc2: 2b00         	cmp	r3, #0x0
 8006fc4: d1cb         	bne	0x8006f5e <_zbus_vded_exec+0x21e> @ imm = #-0x6a
; 	IF_ENABLED(CONFIG_ZBUS_MSG_SUBSCRIBER, (net_buf_unref(buf);))
 8006fc6: 6cf8         	ldr	r0, [r7, #0x4c]
 8006fc8: f015 fc4f    	bl	0x801c86a <net_buf_unref> @ imm = #0x1589e
; 	return last_error;
 8006fcc: 6dfb         	ldr	r3, [r7, #0x5c]
; }
 8006fce: 4618         	mov	r0, r3
 8006fd0: 376c         	adds	r7, #0x6c
 8006fd2: 46bd         	mov	sp, r7
 8006fd4: bd90         	pop	{r4, r7, pc}
 8006fd6: bf00         	nop

08006fd8 <$d>:
 8006fd8: 70 0c 00 20  	.word	0x20000c70
 8006fdc: 38 2d 00 20  	.word	0x20002d38
 8006fe0: 54 8a 02 08  	.word	0x08028a54
 8006fe4: 00 a8 02 08  	.word	0x0802a800
 8006fe8: 58 8a 02 08  	.word	0x08028a58
 8006fec: 18 82 02 08  	.word	0x08028218
 8006ff0: 94 0c 00 20  	.word	0x20000c94
 8006ff4: 84 8a 02 08  	.word	0x08028a84
 8006ff8: c4 8a 02 08  	.word	0x08028ac4

08006ffc <chan_lock>:
; {
 8006ffc: b580         	push	{r7, lr}
 8006ffe: b094         	sub	sp, #0x50
 8007000: af00         	add	r7, sp, #0x0
 8007002: 60f8         	str	r0, [r7, #0xc]
 8007004: e9c7 2300    	strd	r2, r3, [r7]
; 	bool boosting = false;
 8007008: 2300         	movs	r3, #0x0
 800700a: f887 304f    	strb.w	r3, [r7, #0x4f]
; 	if (!k_is_in_isr()) {
 800700e: f01f f8e5    	bl	0x80261dc <k_is_in_isr> @ imm = #0x1f1ca
 8007012: 4603         	mov	r3, r0
 8007014: f083 0301    	eor	r3, r3, #0x1
 8007018: b2db         	uxtb	r3, r3
 800701a: 2b00         	cmp	r3, #0x0
 800701c: d055         	beq	0x80070ca <chan_lock+0xce> @ imm = #0xaa
; 		*prio = k_thread_priority_get(k_current_get());
 800701e: f7ff fe35    	bl	0x8006c8c <k_current_get> @ imm = #-0x396
 8007022: 4603         	mov	r3, r0
 8007024: 4618         	mov	r0, r3
 8007026: f015 fd78    	bl	0x801cb1a <k_thread_priority_get> @ imm = #0x15af0
 800702a: 4602         	mov	r2, r0
 800702c: 6dbb         	ldr	r3, [r7, #0x58]
 800702e: 601a         	str	r2, [r3]
; 		K_SPINLOCK(&_zbus_chan_slock) {
 8007030: 2300         	movs	r3, #0x0
 8007032: 61fb         	str	r3, [r7, #0x1c]
 8007034: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800710c <chan_lock+0x110>
 8007036: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8007038: f3ef 8311    	mrs	r3, basepri
 800703c: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800703e: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 8007040: 63bb         	str	r3, [r7, #0x38]
 8007042: 2310         	movs	r3, #0x10
 8007044: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8007046: 6b7b         	ldr	r3, [r7, #0x34]
 8007048: f383 8812    	msr	basepri_max, r3
; }
 800704c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800704e: f3bf 8f6f    	isb	sy
; }
 8007052: bf00         	nop
; 	return key;
 8007054: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 8007056: 613b         	str	r3, [r7, #0x10]
 8007058: 6c3b         	ldr	r3, [r7, #0x40]
 800705a: 633b         	str	r3, [r7, #0x30]
; }
 800705c: bf00         	nop
 800705e: 6c3b         	ldr	r3, [r7, #0x40]
 8007060: 62fb         	str	r3, [r7, #0x2c]
; }
 8007062: bf00         	nop
; 	return k;
 8007064: 693b         	ldr	r3, [r7, #0x10]
 8007066: 61bb         	str	r3, [r7, #0x18]
; 		K_SPINLOCK(&_zbus_chan_slock) {
 8007068: e02c         	b	0x80070c4 <chan_lock+0xc8> @ imm = #0x58
; 			if (*prio > chan->data->highest_observer_priority) {
 800706a: 6dbb         	ldr	r3, [r7, #0x58]
 800706c: 681a         	ldr	r2, [r3]
 800706e: 68fb         	ldr	r3, [r7, #0xc]
 8007070: 691b         	ldr	r3, [r3, #0x10]
 8007072: 695b         	ldr	r3, [r3, #0x14]
 8007074: 429a         	cmp	r2, r3
 8007076: dd12         	ble	0x800709e <chan_lock+0xa2> @ imm = #0x24
; 				int new_prio = chan->data->highest_observer_priority - 1;
 8007078: 68fb         	ldr	r3, [r7, #0xc]
 800707a: 691b         	ldr	r3, [r3, #0x10]
 800707c: 695b         	ldr	r3, [r3, #0x14]
 800707e: 3b01         	subs	r3, #0x1
 8007080: 64bb         	str	r3, [r7, #0x48]
; 				new_prio = MAX(new_prio, 0);
 8007082: 6cbb         	ldr	r3, [r7, #0x48]
 8007084: ea23 73e3    	bic.w	r3, r3, r3, asr #31
 8007088: 64bb         	str	r3, [r7, #0x48]
; 				k_thread_priority_set(k_current_get(), new_prio);
 800708a: f7ff fdff    	bl	0x8006c8c <k_current_get> @ imm = #-0x402
 800708e: 4603         	mov	r3, r0
 8007090: 6cb9         	ldr	r1, [r7, #0x48]
 8007092: 4618         	mov	r0, r3
 8007094: f015 fd4d    	bl	0x801cb32 <k_thread_priority_set> @ imm = #0x15a9a
; 				boosting = true;
 8007098: 2301         	movs	r3, #0x1
 800709a: f887 304f    	strb.w	r3, [r7, #0x4f]
 800709e: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800710c <chan_lock+0x110>
 80070a0: 62bb         	str	r3, [r7, #0x28]
 80070a2: 69bb         	ldr	r3, [r7, #0x18]
 80070a4: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 80070a6: 697b         	ldr	r3, [r7, #0x14]
 80070a8: 627b         	str	r3, [r7, #0x24]
 80070aa: 6a7b         	ldr	r3, [r7, #0x24]
 80070ac: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80070ae: 6a3b         	ldr	r3, [r7, #0x20]
 80070b0: f383 8811    	msr	basepri, r3
; }
 80070b4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80070b6: f3bf 8f6f    	isb	sy
; }
 80070ba: bf00         	nop
; }
 80070bc: bf00         	nop
; }
 80070be: bf00         	nop
; 		K_SPINLOCK(&_zbus_chan_slock) {
 80070c0: 2301         	movs	r3, #0x1
 80070c2: 61fb         	str	r3, [r7, #0x1c]
 80070c4: 69fb         	ldr	r3, [r7, #0x1c]
 80070c6: 2b00         	cmp	r3, #0x0
 80070c8: d0cf         	beq	0x800706a <chan_lock+0x6e> @ imm = #-0x62
; 	int err = k_sem_take(&chan->data->sem, timeout);
 80070ca: 68fb         	ldr	r3, [r7, #0xc]
 80070cc: 691b         	ldr	r3, [r3, #0x10]
 80070ce: 1d19         	adds	r1, r3, #0x4
 80070d0: e9d7 2300    	ldrd	r2, r3, [r7]
 80070d4: 4608         	mov	r0, r1
 80070d6: f015 fd49    	bl	0x801cb6c <k_sem_take>  @ imm = #0x15a92
 80070da: 6478         	str	r0, [r7, #0x44]
; 	if (err) {
 80070dc: 6c7b         	ldr	r3, [r7, #0x44]
 80070de: 2b00         	cmp	r3, #0x0
 80070e0: d00e         	beq	0x8007100 <chan_lock+0x104> @ imm = #0x1c
; 		if (boosting) {
 80070e2: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 80070e6: 2b00         	cmp	r3, #0x0
 80070e8: d008         	beq	0x80070fc <chan_lock+0x100> @ imm = #0x10
; 			k_thread_priority_set(k_current_get(), *prio);
 80070ea: f7ff fdcf    	bl	0x8006c8c <k_current_get> @ imm = #-0x462
 80070ee: 4602         	mov	r2, r0
 80070f0: 6dbb         	ldr	r3, [r7, #0x58]
 80070f2: 681b         	ldr	r3, [r3]
 80070f4: 4619         	mov	r1, r3
 80070f6: 4610         	mov	r0, r2
 80070f8: f015 fd1b    	bl	0x801cb32 <k_thread_priority_set> @ imm = #0x15a36
; 		return err;
 80070fc: 6c7b         	ldr	r3, [r7, #0x44]
 80070fe: e000         	b	0x8007102 <chan_lock+0x106> @ imm = #0x0
; 	return 0;
 8007100: 2300         	movs	r3, #0x0
; }
 8007102: 4618         	mov	r0, r3
 8007104: 3750         	adds	r7, #0x50
 8007106: 46bd         	mov	sp, r7
 8007108: bd80         	pop	{r7, pc}
 800710a: bf00         	nop

0800710c <$d>:
 800710c: 3c 2d 00 20  	.word	0x20002d3c

08007110 <LL_EXTI_EnableIT_0_31>:
; {
 8007110: b480         	push	{r7}
 8007112: b083         	sub	sp, #0xc
 8007114: af00         	add	r7, sp, #0x0
 8007116: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->IMR, ExtiLine);
 8007118: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8007130 <LL_EXTI_EnableIT_0_31+0x20>
 800711a: 681a         	ldr	r2, [r3]
 800711c: 4904         	ldr	r1, [pc, #0x10]         @ 0x8007130 <LL_EXTI_EnableIT_0_31+0x20>
 800711e: 687b         	ldr	r3, [r7, #0x4]
 8007120: 4313         	orrs	r3, r2
 8007122: 600b         	str	r3, [r1]
; }
 8007124: bf00         	nop
 8007126: 370c         	adds	r7, #0xc
 8007128: 46bd         	mov	sp, r7
 800712a: f85d 7b04    	ldr	r7, [sp], #4
 800712e: 4770         	bx	lr

08007130 <$d>:
 8007130: 00 3c 01 40  	.word	0x40013c00

08007134 <LL_EXTI_DisableIT_0_31>:
; {
 8007134: b480         	push	{r7}
 8007136: b083         	sub	sp, #0xc
 8007138: af00         	add	r7, sp, #0x0
 800713a: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->IMR, ExtiLine);
 800713c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007158 <LL_EXTI_DisableIT_0_31+0x24>
 800713e: 681a         	ldr	r2, [r3]
 8007140: 687b         	ldr	r3, [r7, #0x4]
 8007142: 43db         	mvns	r3, r3
 8007144: 4904         	ldr	r1, [pc, #0x10]         @ 0x8007158 <LL_EXTI_DisableIT_0_31+0x24>
 8007146: 4013         	ands	r3, r2
 8007148: 600b         	str	r3, [r1]
; }
 800714a: bf00         	nop
 800714c: 370c         	adds	r7, #0xc
 800714e: 46bd         	mov	sp, r7
 8007150: f85d 7b04    	ldr	r7, [sp], #4
 8007154: 4770         	bx	lr
 8007156: bf00         	nop

08007158 <$d>:
 8007158: 00 3c 01 40  	.word	0x40013c00

0800715c <LL_EXTI_EnableRisingTrig_0_31>:
; {
 800715c: b480         	push	{r7}
 800715e: b083         	sub	sp, #0xc
 8007160: af00         	add	r7, sp, #0x0
 8007162: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->RTSR, ExtiLine);
 8007164: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800717c <LL_EXTI_EnableRisingTrig_0_31+0x20>
 8007166: 689a         	ldr	r2, [r3, #0x8]
 8007168: 4904         	ldr	r1, [pc, #0x10]         @ 0x800717c <LL_EXTI_EnableRisingTrig_0_31+0x20>
 800716a: 687b         	ldr	r3, [r7, #0x4]
 800716c: 4313         	orrs	r3, r2
 800716e: 608b         	str	r3, [r1, #0x8]
; }
 8007170: bf00         	nop
 8007172: 370c         	adds	r7, #0xc
 8007174: 46bd         	mov	sp, r7
 8007176: f85d 7b04    	ldr	r7, [sp], #4
 800717a: 4770         	bx	lr

0800717c <$d>:
 800717c: 00 3c 01 40  	.word	0x40013c00

08007180 <LL_EXTI_DisableRisingTrig_0_31>:
; {
 8007180: b480         	push	{r7}
 8007182: b083         	sub	sp, #0xc
 8007184: af00         	add	r7, sp, #0x0
 8007186: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->RTSR, ExtiLine);
 8007188: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80071a4 <LL_EXTI_DisableRisingTrig_0_31+0x24>
 800718a: 689a         	ldr	r2, [r3, #0x8]
 800718c: 687b         	ldr	r3, [r7, #0x4]
 800718e: 43db         	mvns	r3, r3
 8007190: 4904         	ldr	r1, [pc, #0x10]         @ 0x80071a4 <LL_EXTI_DisableRisingTrig_0_31+0x24>
 8007192: 4013         	ands	r3, r2
 8007194: 608b         	str	r3, [r1, #0x8]
; }
 8007196: bf00         	nop
 8007198: 370c         	adds	r7, #0xc
 800719a: 46bd         	mov	sp, r7
 800719c: f85d 7b04    	ldr	r7, [sp], #4
 80071a0: 4770         	bx	lr
 80071a2: bf00         	nop

080071a4 <$d>:
 80071a4: 00 3c 01 40  	.word	0x40013c00

080071a8 <LL_EXTI_EnableFallingTrig_0_31>:
; {
 80071a8: b480         	push	{r7}
 80071aa: b083         	sub	sp, #0xc
 80071ac: af00         	add	r7, sp, #0x0
 80071ae: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->FTSR, ExtiLine);
 80071b0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80071c8 <LL_EXTI_EnableFallingTrig_0_31+0x20>
 80071b2: 68da         	ldr	r2, [r3, #0xc]
 80071b4: 4904         	ldr	r1, [pc, #0x10]         @ 0x80071c8 <LL_EXTI_EnableFallingTrig_0_31+0x20>
 80071b6: 687b         	ldr	r3, [r7, #0x4]
 80071b8: 4313         	orrs	r3, r2
 80071ba: 60cb         	str	r3, [r1, #0xc]
; }
 80071bc: bf00         	nop
 80071be: 370c         	adds	r7, #0xc
 80071c0: 46bd         	mov	sp, r7
 80071c2: f85d 7b04    	ldr	r7, [sp], #4
 80071c6: 4770         	bx	lr

080071c8 <$d>:
 80071c8: 00 3c 01 40  	.word	0x40013c00

080071cc <LL_EXTI_DisableFallingTrig_0_31>:
; {
 80071cc: b480         	push	{r7}
 80071ce: b083         	sub	sp, #0xc
 80071d0: af00         	add	r7, sp, #0x0
 80071d2: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->FTSR, ExtiLine);
 80071d4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80071f0 <LL_EXTI_DisableFallingTrig_0_31+0x24>
 80071d6: 68da         	ldr	r2, [r3, #0xc]
 80071d8: 687b         	ldr	r3, [r7, #0x4]
 80071da: 43db         	mvns	r3, r3
 80071dc: 4904         	ldr	r1, [pc, #0x10]         @ 0x80071f0 <LL_EXTI_DisableFallingTrig_0_31+0x24>
 80071de: 4013         	ands	r3, r2
 80071e0: 60cb         	str	r3, [r1, #0xc]
; }
 80071e2: bf00         	nop
 80071e4: 370c         	adds	r7, #0xc
 80071e6: 46bd         	mov	sp, r7
 80071e8: f85d 7b04    	ldr	r7, [sp], #4
 80071ec: 4770         	bx	lr
 80071ee: bf00         	nop

080071f0 <$d>:
 80071f0: 00 3c 01 40  	.word	0x40013c00

080071f4 <LL_EXTI_IsActiveFlag_0_31>:
; {
 80071f4: b480         	push	{r7}
 80071f6: b083         	sub	sp, #0xc
 80071f8: af00         	add	r7, sp, #0x0
 80071fa: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(EXTI->PR, ExtiLine) == (ExtiLine));
 80071fc: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800721c <LL_EXTI_IsActiveFlag_0_31+0x28>
 80071fe: 695a         	ldr	r2, [r3, #0x14]
 8007200: 687b         	ldr	r3, [r7, #0x4]
 8007202: 4013         	ands	r3, r2
 8007204: 687a         	ldr	r2, [r7, #0x4]
 8007206: 429a         	cmp	r2, r3
 8007208: bf0c         	ite	eq
 800720a: 2301         	moveq	r3, #0x1
 800720c: 2300         	movne	r3, #0x0
 800720e: b2db         	uxtb	r3, r3
; }
 8007210: 4618         	mov	r0, r3
 8007212: 370c         	adds	r7, #0xc
 8007214: 46bd         	mov	sp, r7
 8007216: f85d 7b04    	ldr	r7, [sp], #4
 800721a: 4770         	bx	lr

0800721c <$d>:
 800721c: 00 3c 01 40  	.word	0x40013c00

08007220 <LL_EXTI_ClearFlag_0_31>:
; {
 8007220: b480         	push	{r7}
 8007222: b083         	sub	sp, #0xc
 8007224: af00         	add	r7, sp, #0x0
 8007226: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(EXTI->PR, ExtiLine);
 8007228: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800723c <LL_EXTI_ClearFlag_0_31+0x1c>
 800722a: 687b         	ldr	r3, [r7, #0x4]
 800722c: 6153         	str	r3, [r2, #0x14]
; }
 800722e: bf00         	nop
 8007230: 370c         	adds	r7, #0xc
 8007232: 46bd         	mov	sp, r7
 8007234: f85d 7b04    	ldr	r7, [sp], #4
 8007238: 4770         	bx	lr
 800723a: bf00         	nop

0800723c <$d>:
 800723c: 00 3c 01 40  	.word	0x40013c00

08007240 <LL_SYSCFG_SetEXTISource>:
; {
 8007240: b480         	push	{r7}
 8007242: b087         	sub	sp, #0x1c
 8007244: af00         	add	r7, sp, #0x0
 8007246: 6078         	str	r0, [r7, #0x4]
 8007248: 6039         	str	r1, [r7]
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 800724a: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x80072a8 <LL_SYSCFG_SetEXTISource+0x68>
 800724c: 683b         	ldr	r3, [r7]
 800724e: b2db         	uxtb	r3, r3
 8007250: 3302         	adds	r3, #0x2
 8007252: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 8007256: 683b         	ldr	r3, [r7]
 8007258: 0c1b         	lsrs	r3, r3, #0x10
 800725a: 43db         	mvns	r3, r3
 800725c: ea02 0103    	and.w	r1, r2, r3
 8007260: 683b         	ldr	r3, [r7]
 8007262: 0c1b         	lsrs	r3, r3, #0x10
 8007264: 613b         	str	r3, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007266: 693b         	ldr	r3, [r7, #0x10]
 8007268: fa93 f3a3    	rbit	r3, r3
 800726c: 60fb         	str	r3, [r7, #0xc]
;   return result;
 800726e: 68fb         	ldr	r3, [r7, #0xc]
 8007270: 617b         	str	r3, [r7, #0x14]
;   if (value == 0U)
 8007272: 697b         	ldr	r3, [r7, #0x14]
 8007274: 2b00         	cmp	r3, #0x0
 8007276: d101         	bne	0x800727c <LL_SYSCFG_SetEXTISource+0x3c> @ imm = #0x2
;     return 32U;
 8007278: 2320         	movs	r3, #0x20
 800727a: e003         	b	0x8007284 <LL_SYSCFG_SetEXTISource+0x44> @ imm = #0x6
;   return __builtin_clz(value);
 800727c: 697b         	ldr	r3, [r7, #0x14]
 800727e: fab3 f383    	clz	r3, r3
 8007282: b2db         	uxtb	r3, r3
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 8007284: 461a         	mov	r2, r3
 8007286: 687b         	ldr	r3, [r7, #0x4]
 8007288: fa03 f202    	lsl.w	r2, r3, r2
 800728c: 4806         	ldr	r0, [pc, #0x18]         @ 0x80072a8 <LL_SYSCFG_SetEXTISource+0x68>
 800728e: 683b         	ldr	r3, [r7]
 8007290: b2db         	uxtb	r3, r3
 8007292: 430a         	orrs	r2, r1
 8007294: 3302         	adds	r3, #0x2
 8007296: f840 2023    	str.w	r2, [r0, r3, lsl #2]
; }
 800729a: bf00         	nop
 800729c: 371c         	adds	r7, #0x1c
 800729e: 46bd         	mov	sp, r7
 80072a0: f85d 7b04    	ldr	r7, [sp], #4
 80072a4: 4770         	bx	lr
 80072a6: bf00         	nop

080072a8 <$d>:
 80072a8: 00 38 01 40  	.word	0x40013800

080072ac <LL_SYSCFG_GetEXTISource>:
; {
 80072ac: b480         	push	{r7}
 80072ae: b087         	sub	sp, #0x1c
 80072b0: af00         	add	r7, sp, #0x0
 80072b2: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 80072b4: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80072f8 <LL_SYSCFG_GetEXTISource+0x4c>
 80072b6: 687b         	ldr	r3, [r7, #0x4]
 80072b8: b2db         	uxtb	r3, r3
 80072ba: 3302         	adds	r3, #0x2
 80072bc: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 80072c0: 687b         	ldr	r3, [r7, #0x4]
 80072c2: 0c1b         	lsrs	r3, r3, #0x10
 80072c4: 4013         	ands	r3, r2
 80072c6: 687a         	ldr	r2, [r7, #0x4]
 80072c8: 0c12         	lsrs	r2, r2, #0x10
 80072ca: 613a         	str	r2, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80072cc: 693a         	ldr	r2, [r7, #0x10]
 80072ce: fa92 f2a2    	rbit	r2, r2
 80072d2: 60fa         	str	r2, [r7, #0xc]
;   return result;
 80072d4: 68fa         	ldr	r2, [r7, #0xc]
 80072d6: 617a         	str	r2, [r7, #0x14]
;   if (value == 0U)
 80072d8: 697a         	ldr	r2, [r7, #0x14]
 80072da: 2a00         	cmp	r2, #0x0
 80072dc: d101         	bne	0x80072e2 <LL_SYSCFG_GetEXTISource+0x36> @ imm = #0x2
;     return 32U;
 80072de: 2220         	movs	r2, #0x20
 80072e0: e003         	b	0x80072ea <LL_SYSCFG_GetEXTISource+0x3e> @ imm = #0x6
;   return __builtin_clz(value);
 80072e2: 697a         	ldr	r2, [r7, #0x14]
 80072e4: fab2 f282    	clz	r2, r2
 80072e8: b2d2         	uxtb	r2, r2
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 80072ea: 40d3         	lsrs	r3, r2
; }
 80072ec: 4618         	mov	r0, r3
 80072ee: 371c         	adds	r7, #0x1c
 80072f0: 46bd         	mov	sp, r7
 80072f2: f85d 7b04    	ldr	r7, [sp], #4
 80072f6: 4770         	bx	lr

080072f8 <$d>:
 80072f8: 00 38 01 40  	.word	0x40013800

080072fc <stm32_exti_isr>:
; {
 80072fc: b580         	push	{r7, lr}
 80072fe: b088         	sub	sp, #0x20
 8007300: af00         	add	r7, sp, #0x0
 8007302: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = DEVICE_DT_GET(EXTI_NODE);
 8007304: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8007384 <stm32_exti_isr+0x88>
 8007306: 61bb         	str	r3, [r7, #0x18]
; 	struct stm32_exti_data *data = dev->data;
 8007308: 69bb         	ldr	r3, [r7, #0x18]
 800730a: 691b         	ldr	r3, [r3, #0x10]
 800730c: 617b         	str	r3, [r7, #0x14]
; 	const struct stm32_exti_range *range = exti_range;
 800730e: 687b         	ldr	r3, [r7, #0x4]
 8007310: 613b         	str	r3, [r7, #0x10]
; 	for (uint8_t i = 0; i <= range->len; i++) {
 8007312: 2300         	movs	r3, #0x0
 8007314: 77fb         	strb	r3, [r7, #0x1f]
 8007316: e02b         	b	0x8007370 <stm32_exti_isr+0x74> @ imm = #0x56
; 		line_num = range->start + i;
 8007318: 693b         	ldr	r3, [r7, #0x10]
 800731a: 781b         	ldrb	r3, [r3]
 800731c: 461a         	mov	r2, r3
 800731e: 7ffb         	ldrb	r3, [r7, #0x1f]
 8007320: 4413         	add	r3, r2
 8007322: 60fb         	str	r3, [r7, #0xc]
; 		line = linenum_to_ll_exti_line(line_num);
 8007324: 68fb         	ldr	r3, [r7, #0xc]
 8007326: b2db         	uxtb	r3, r3
 8007328: 4618         	mov	r0, r3
 800732a: f015 fe0b    	bl	0x801cf44 <linenum_to_ll_exti_line> @ imm = #0x15c16
 800732e: 60b8         	str	r0, [r7, #0x8]
; 		if (stm32_exti_is_pending(line) != 0) {
 8007330: 68b8         	ldr	r0, [r7, #0x8]
 8007332: f015 fdf0    	bl	0x801cf16 <stm32_exti_is_pending> @ imm = #0x15be0
 8007336: 4603         	mov	r3, r0
 8007338: 2b00         	cmp	r3, #0x0
 800733a: d016         	beq	0x800736a <stm32_exti_isr+0x6e> @ imm = #0x2c
; 			stm32_exti_clear_pending(line);
 800733c: 68b8         	ldr	r0, [r7, #0x8]
 800733e: f015 fdf6    	bl	0x801cf2e <stm32_exti_clear_pending> @ imm = #0x15bec
; 			if (!data->cb[line_num].cb) {
 8007342: 697b         	ldr	r3, [r7, #0x14]
 8007344: 68fa         	ldr	r2, [r7, #0xc]
 8007346: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 800734a: 2b00         	cmp	r3, #0x0
 800734c: d00c         	beq	0x8007368 <stm32_exti_isr+0x6c> @ imm = #0x18
; 			data->cb[line_num].cb(line, data->cb[line_num].data);
 800734e: 697b         	ldr	r3, [r7, #0x14]
 8007350: 68fa         	ldr	r2, [r7, #0xc]
 8007352: f853 2032    	ldr.w	r2, [r3, r2, lsl #3]
 8007356: 6979         	ldr	r1, [r7, #0x14]
 8007358: 68fb         	ldr	r3, [r7, #0xc]
 800735a: 00db         	lsls	r3, r3, #0x3
 800735c: 440b         	add	r3, r1
 800735e: 685b         	ldr	r3, [r3, #0x4]
 8007360: 4619         	mov	r1, r3
 8007362: 68b8         	ldr	r0, [r7, #0x8]
 8007364: 4790         	blx	r2
 8007366: e000         	b	0x800736a <stm32_exti_isr+0x6e> @ imm = #0x0
; 				continue;
 8007368: bf00         	nop
; 	for (uint8_t i = 0; i <= range->len; i++) {
 800736a: 7ffb         	ldrb	r3, [r7, #0x1f]
 800736c: 3301         	adds	r3, #0x1
 800736e: 77fb         	strb	r3, [r7, #0x1f]
 8007370: 693b         	ldr	r3, [r7, #0x10]
 8007372: 785b         	ldrb	r3, [r3, #0x1]
 8007374: 7ffa         	ldrb	r2, [r7, #0x1f]
 8007376: 429a         	cmp	r2, r3
 8007378: d9ce         	bls	0x8007318 <stm32_exti_isr+0x1c> @ imm = #-0x64
; }
 800737a: bf00         	nop
 800737c: bf00         	nop
 800737e: 3720         	adds	r7, #0x20
 8007380: 46bd         	mov	sp, r7
 8007382: bd80         	pop	{r7, pc}

08007384 <$d>:
 8007384: 70 7a 02 08  	.word	0x08027a70

08007388 <stm32_exti_enable_registers>:
; {
 8007388: b580         	push	{r7, lr}
 800738a: b084         	sub	sp, #0x10
 800738c: af00         	add	r7, sp, #0x0
; 	int ret = 0;
 800738e: 2300         	movs	r3, #0x0
 8007390: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8007392: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80073b8 <stm32_exti_enable_registers+0x30>
 8007394: 60bb         	str	r3, [r7, #0x8]
; 	struct stm32_pclken pclken = {
 8007396: 4a09         	ldr	r2, [pc, #0x24]         @ 0x80073bc <stm32_exti_enable_registers+0x34>
 8007398: 463b         	mov	r3, r7
 800739a: e892 0003    	ldm.w	r2, {r0, r1}
 800739e: e883 0003    	stm.w	r3, {r0, r1}
; 	ret = clock_control_on(clk, (clock_control_subsys_t) &pclken);
 80073a2: 463b         	mov	r3, r7
 80073a4: 4619         	mov	r1, r3
 80073a6: 68b8         	ldr	r0, [r7, #0x8]
 80073a8: f015 fd77    	bl	0x801ce9a <clock_control_on> @ imm = #0x15aee
 80073ac: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 80073ae: 68fb         	ldr	r3, [r7, #0xc]
; }
 80073b0: 4618         	mov	r0, r3
 80073b2: 3710         	adds	r7, #0x10
 80073b4: 46bd         	mov	sp, r7
 80073b6: bd80         	pop	{r7, pc}

080073b8 <$d>:
 80073b8: 48 7a 02 08  	.word	0x08027a48
 80073bc: d4 8a 02 08  	.word	0x08028ad4

080073c0 <stm32_fill_irq_table>:
; {
 80073c0: b480         	push	{r7}
 80073c2: b085         	sub	sp, #0x14
 80073c4: af00         	add	r7, sp, #0x0
 80073c6: 4603         	mov	r3, r0
 80073c8: 603a         	str	r2, [r7]
 80073ca: 71fb         	strb	r3, [r7, #0x7]
 80073cc: 460b         	mov	r3, r1
 80073ce: 71bb         	strb	r3, [r7, #0x6]
; 	for (int i = 0; i < len; i++) {
 80073d0: 2300         	movs	r3, #0x0
 80073d2: 60fb         	str	r3, [r7, #0xc]
 80073d4: e00a         	b	0x80073ec <stm32_fill_irq_table+0x2c> @ imm = #0x14
; 		exti_irq_table[start + i] = irqn;
 80073d6: f997 2007    	ldrsb.w	r2, [r7, #0x7]
 80073da: 68fb         	ldr	r3, [r7, #0xc]
 80073dc: 4413         	add	r3, r2
 80073de: 683a         	ldr	r2, [r7]
 80073e0: b251         	sxtb	r1, r2
 80073e2: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007404 <stm32_fill_irq_table+0x44>
 80073e4: 54d1         	strb	r1, [r2, r3]
; 	for (int i = 0; i < len; i++) {
 80073e6: 68fb         	ldr	r3, [r7, #0xc]
 80073e8: 3301         	adds	r3, #0x1
 80073ea: 60fb         	str	r3, [r7, #0xc]
 80073ec: f997 3006    	ldrsb.w	r3, [r7, #0x6]
 80073f0: 68fa         	ldr	r2, [r7, #0xc]
 80073f2: 429a         	cmp	r2, r3
 80073f4: dbef         	blt	0x80073d6 <stm32_fill_irq_table+0x16> @ imm = #-0x22
; }
 80073f6: bf00         	nop
 80073f8: bf00         	nop
 80073fa: 3714         	adds	r7, #0x14
 80073fc: 46bd         	mov	sp, r7
 80073fe: f85d 7b04    	ldr	r7, [sp], #4
 8007402: 4770         	bx	lr

08007404 <$d>:
 8007404: 20 05 00 20  	.word	0x20000520

08007408 <stm32_exti_init>:
; {
 8007408: b580         	push	{r7, lr}
 800740a: b082         	sub	sp, #0x8
 800740c: af00         	add	r7, sp, #0x0
 800740e: 6078         	str	r0, [r7, #0x4]
; 	DT_FOREACH_PROP_ELEM(DT_NODELABEL(exti),
 8007410: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x80074f0 <stm32_exti_init+0xe8>
 8007412: 781b         	ldrb	r3, [r3]
 8007414: b25b         	sxtb	r3, r3
 8007416: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x80074f0 <stm32_exti_init+0xe8>
 8007418: 7852         	ldrb	r2, [r2, #0x1]
 800741a: b251         	sxtb	r1, r2
 800741c: 2206         	movs	r2, #0x6
 800741e: 4618         	mov	r0, r3
 8007420: f7ff ffce    	bl	0x80073c0 <stm32_fill_irq_table> @ imm = #-0x64
 8007424: 2200         	movs	r2, #0x0
 8007426: 2100         	movs	r1, #0x0
 8007428: 2006         	movs	r0, #0x6
 800742a: f014 ffcd    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #0x14f9a
 800742e: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80074f4 <stm32_exti_init+0xec>
 8007430: 781b         	ldrb	r3, [r3]
 8007432: b25b         	sxtb	r3, r3
 8007434: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x80074f4 <stm32_exti_init+0xec>
 8007436: 7852         	ldrb	r2, [r2, #0x1]
 8007438: b251         	sxtb	r1, r2
 800743a: 2207         	movs	r2, #0x7
 800743c: 4618         	mov	r0, r3
 800743e: f7ff ffbf    	bl	0x80073c0 <stm32_fill_irq_table> @ imm = #-0x82
 8007442: 2200         	movs	r2, #0x0
 8007444: 2100         	movs	r1, #0x0
 8007446: 2007         	movs	r0, #0x7
 8007448: f014 ffbe    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #0x14f7c
 800744c: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80074f8 <stm32_exti_init+0xf0>
 800744e: 781b         	ldrb	r3, [r3]
 8007450: b25b         	sxtb	r3, r3
 8007452: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x80074f8 <stm32_exti_init+0xf0>
 8007454: 7852         	ldrb	r2, [r2, #0x1]
 8007456: b251         	sxtb	r1, r2
 8007458: 2208         	movs	r2, #0x8
 800745a: 4618         	mov	r0, r3
 800745c: f7ff ffb0    	bl	0x80073c0 <stm32_fill_irq_table> @ imm = #-0xa0
 8007460: 2200         	movs	r2, #0x0
 8007462: 2100         	movs	r1, #0x0
 8007464: 2008         	movs	r0, #0x8
 8007466: f014 ffaf    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #0x14f5e
 800746a: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80074fc <stm32_exti_init+0xf4>
 800746c: 781b         	ldrb	r3, [r3]
 800746e: b25b         	sxtb	r3, r3
 8007470: 4a22         	ldr	r2, [pc, #0x88]         @ 0x80074fc <stm32_exti_init+0xf4>
 8007472: 7852         	ldrb	r2, [r2, #0x1]
 8007474: b251         	sxtb	r1, r2
 8007476: 2209         	movs	r2, #0x9
 8007478: 4618         	mov	r0, r3
 800747a: f7ff ffa1    	bl	0x80073c0 <stm32_fill_irq_table> @ imm = #-0xbe
 800747e: 2200         	movs	r2, #0x0
 8007480: 2100         	movs	r1, #0x0
 8007482: 2009         	movs	r0, #0x9
 8007484: f014 ffa0    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #0x14f40
 8007488: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8007500 <stm32_exti_init+0xf8>
 800748a: 781b         	ldrb	r3, [r3]
 800748c: b25b         	sxtb	r3, r3
 800748e: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x8007500 <stm32_exti_init+0xf8>
 8007490: 7852         	ldrb	r2, [r2, #0x1]
 8007492: b251         	sxtb	r1, r2
 8007494: 220a         	movs	r2, #0xa
 8007496: 4618         	mov	r0, r3
 8007498: f7ff ff92    	bl	0x80073c0 <stm32_fill_irq_table> @ imm = #-0xdc
 800749c: 2200         	movs	r2, #0x0
 800749e: 2100         	movs	r1, #0x0
 80074a0: 200a         	movs	r0, #0xa
 80074a2: f014 ff91    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #0x14f22
 80074a6: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8007504 <stm32_exti_init+0xfc>
 80074a8: 781b         	ldrb	r3, [r3]
 80074aa: b25b         	sxtb	r3, r3
 80074ac: 4a15         	ldr	r2, [pc, #0x54]         @ 0x8007504 <stm32_exti_init+0xfc>
 80074ae: 7852         	ldrb	r2, [r2, #0x1]
 80074b0: b251         	sxtb	r1, r2
 80074b2: 2217         	movs	r2, #0x17
 80074b4: 4618         	mov	r0, r3
 80074b6: f7ff ff83    	bl	0x80073c0 <stm32_fill_irq_table> @ imm = #-0xfa
 80074ba: 2200         	movs	r2, #0x0
 80074bc: 2100         	movs	r1, #0x0
 80074be: 2017         	movs	r0, #0x17
 80074c0: f014 ff82    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #0x14f04
 80074c4: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8007508 <stm32_exti_init+0x100>
 80074c6: 781b         	ldrb	r3, [r3]
 80074c8: b25b         	sxtb	r3, r3
 80074ca: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8007508 <stm32_exti_init+0x100>
 80074cc: 7852         	ldrb	r2, [r2, #0x1]
 80074ce: b251         	sxtb	r1, r2
 80074d0: 2228         	movs	r2, #0x28
 80074d2: 4618         	mov	r0, r3
 80074d4: f7ff ff74    	bl	0x80073c0 <stm32_fill_irq_table> @ imm = #-0x118
 80074d8: 2200         	movs	r2, #0x0
 80074da: 2100         	movs	r1, #0x0
 80074dc: 2028         	movs	r0, #0x28
 80074de: f014 ff73    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #0x14ee6
; 	return stm32_exti_enable_registers();
 80074e2: f7ff ff51    	bl	0x8007388 <stm32_exti_enable_registers> @ imm = #-0x15e
 80074e6: 4603         	mov	r3, r0
; }
 80074e8: 4618         	mov	r0, r3
 80074ea: 3708         	adds	r7, #0x8
 80074ec: 46bd         	mov	sp, r7
 80074ee: bd80         	pop	{r7, pc}

080074f0 <$d>:
 80074f0: 10 a8 02 08  	.word	0x0802a810
 80074f4: 14 a8 02 08  	.word	0x0802a814
 80074f8: 18 a8 02 08  	.word	0x0802a818
 80074fc: 1c a8 02 08  	.word	0x0802a81c
 8007500: 20 a8 02 08  	.word	0x0802a820
 8007504: 24 a8 02 08  	.word	0x0802a824
 8007508: 28 a8 02 08  	.word	0x0802a828

0800750c <stm32_gpio_intc_enable_line>:
; {
 800750c: b580         	push	{r7, lr}
 800750e: b084         	sub	sp, #0x10
 8007510: af00         	add	r7, sp, #0x0
 8007512: 6078         	str	r0, [r7, #0x4]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 8007514: 6878         	ldr	r0, [r7, #0x4]
 8007516: f015 fd24    	bl	0x801cf62 <ll_exti_line_to_linenum> @ imm = #0x15a48
 800751a: 4603         	mov	r3, r0
 800751c: 60fb         	str	r3, [r7, #0xc]
; 	irqnum = exti_irq_table[line_num];
 800751e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007540 <stm32_gpio_intc_enable_line+0x34>
 8007520: 68fb         	ldr	r3, [r7, #0xc]
 8007522: 4413         	add	r3, r2
 8007524: f993 3000    	ldrsb.w	r3, [r3]
 8007528: 60bb         	str	r3, [r7, #0x8]
; 	LL_EXTI_EnableIT_0_31(line);
 800752a: 6878         	ldr	r0, [r7, #0x4]
 800752c: f7ff fdf0    	bl	0x8007110 <LL_EXTI_EnableIT_0_31> @ imm = #-0x420
; 	irq_enable(irqnum);
 8007530: 68b8         	ldr	r0, [r7, #0x8]
 8007532: f014 ff3c    	bl	0x801c3ae <arch_irq_enable> @ imm = #0x14e78
; }
 8007536: bf00         	nop
 8007538: 3710         	adds	r7, #0x10
 800753a: 46bd         	mov	sp, r7
 800753c: bd80         	pop	{r7, pc}
 800753e: bf00         	nop

08007540 <$d>:
 8007540: 20 05 00 20  	.word	0x20000520

08007544 <stm32_gpio_intc_select_line_trigger>:
; {
 8007544: b580         	push	{r7, lr}
 8007546: b082         	sub	sp, #0x8
 8007548: af00         	add	r7, sp, #0x0
 800754a: 6078         	str	r0, [r7, #0x4]
 800754c: 6039         	str	r1, [r7]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 800754e: f44f 1180    	mov.w	r1, #0x100000
 8007552: 2000         	movs	r0, #0x0
 8007554: f015 fcb3    	bl	0x801cebe <z_stm32_hsem_lock> @ imm = #0x15966
; 	switch (trg) {
 8007558: 683b         	ldr	r3, [r7]
 800755a: 2b03         	cmp	r3, #0x3
 800755c: d826         	bhi	0x80075ac <stm32_gpio_intc_select_line_trigger+0x68> @ imm = #0x4c
 800755e: a201         	adr	r2, #4 <stm32_gpio_intc_select_line_trigger+0x1f>
 8007560: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08007564 <$d>:
 8007564: 75 75 00 08  	.word	0x08007575
 8007568: 83 75 00 08  	.word	0x08007583
 800756c: 91 75 00 08  	.word	0x08007591
 8007570: 9f 75 00 08  	.word	0x0800759f

08007574 <$t>:
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 8007574: 6878         	ldr	r0, [r7, #0x4]
 8007576: f7ff fe03    	bl	0x8007180 <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x3fa
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 800757a: 6878         	ldr	r0, [r7, #0x4]
 800757c: f7ff fe26    	bl	0x80071cc <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3b4
; 		break;
 8007580: e015         	b	0x80075ae <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x2a
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 8007582: 6878         	ldr	r0, [r7, #0x4]
 8007584: f7ff fdea    	bl	0x800715c <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x42c
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 8007588: 6878         	ldr	r0, [r7, #0x4]
 800758a: f7ff fe1f    	bl	0x80071cc <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3c2
; 		break;
 800758e: e00e         	b	0x80075ae <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x1c
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 8007590: 6878         	ldr	r0, [r7, #0x4]
 8007592: f7ff fe09    	bl	0x80071a8 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x3ee
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 8007596: 6878         	ldr	r0, [r7, #0x4]
 8007598: f7ff fdf2    	bl	0x8007180 <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x41c
; 		break;
 800759c: e007         	b	0x80075ae <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0xe
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 800759e: 6878         	ldr	r0, [r7, #0x4]
 80075a0: f7ff fddc    	bl	0x800715c <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x448
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 80075a4: 6878         	ldr	r0, [r7, #0x4]
 80075a6: f7ff fdff    	bl	0x80071a8 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x402
; 		break;
 80075aa: e000         	b	0x80075ae <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x0
; 		break;
 80075ac: bf00         	nop
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 80075ae: 2000         	movs	r0, #0x0
 80075b0: f015 fc90    	bl	0x801ced4 <z_stm32_hsem_unlock> @ imm = #0x15920
; }
 80075b4: bf00         	nop
 80075b6: 3708         	adds	r7, #0x8
 80075b8: 46bd         	mov	sp, r7
 80075ba: bd80         	pop	{r7, pc}

080075bc <stm32_gpio_intc_set_irq_callback>:
; {
 80075bc: b580         	push	{r7, lr}
 80075be: b088         	sub	sp, #0x20
 80075c0: af00         	add	r7, sp, #0x0
 80075c2: 60f8         	str	r0, [r7, #0xc]
 80075c4: 60b9         	str	r1, [r7, #0x8]
 80075c6: 607a         	str	r2, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 80075c8: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8007630 <stm32_gpio_intc_set_irq_callback+0x74>
 80075ca: 61fb         	str	r3, [r7, #0x1c]
; 	struct stm32_exti_data *data = dev->data;
 80075cc: 69fb         	ldr	r3, [r7, #0x1c]
 80075ce: 691b         	ldr	r3, [r3, #0x10]
 80075d0: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 80075d2: 68f8         	ldr	r0, [r7, #0xc]
 80075d4: f015 fcc5    	bl	0x801cf62 <ll_exti_line_to_linenum> @ imm = #0x1598a
 80075d8: 4603         	mov	r3, r0
 80075da: 617b         	str	r3, [r7, #0x14]
; 	if ((data->cb[line_num].cb == cb) && (data->cb[line_num].data == user)) {
 80075dc: 69bb         	ldr	r3, [r7, #0x18]
 80075de: 697a         	ldr	r2, [r7, #0x14]
 80075e0: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 80075e4: 68ba         	ldr	r2, [r7, #0x8]
 80075e6: 429a         	cmp	r2, r3
 80075e8: d109         	bne	0x80075fe <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x12
 80075ea: 69ba         	ldr	r2, [r7, #0x18]
 80075ec: 697b         	ldr	r3, [r7, #0x14]
 80075ee: 00db         	lsls	r3, r3, #0x3
 80075f0: 4413         	add	r3, r2
 80075f2: 685b         	ldr	r3, [r3, #0x4]
 80075f4: 687a         	ldr	r2, [r7, #0x4]
 80075f6: 429a         	cmp	r2, r3
 80075f8: d101         	bne	0x80075fe <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x2
; 		return 0;
 80075fa: 2300         	movs	r3, #0x0
 80075fc: e014         	b	0x8007628 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x28
; 	if (data->cb[line_num].cb != NULL) {
 80075fe: 69bb         	ldr	r3, [r7, #0x18]
 8007600: 697a         	ldr	r2, [r7, #0x14]
 8007602: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 8007606: 2b00         	cmp	r3, #0x0
 8007608: d002         	beq	0x8007610 <stm32_gpio_intc_set_irq_callback+0x54> @ imm = #0x4
; 		return -EBUSY;
 800760a: f06f 030f    	mvn	r3, #0xf
 800760e: e00b         	b	0x8007628 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x16
; 	data->cb[line_num].cb = cb;
 8007610: 69bb         	ldr	r3, [r7, #0x18]
 8007612: 697a         	ldr	r2, [r7, #0x14]
 8007614: 68b9         	ldr	r1, [r7, #0x8]
 8007616: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = user;
 800761a: 69ba         	ldr	r2, [r7, #0x18]
 800761c: 697b         	ldr	r3, [r7, #0x14]
 800761e: 00db         	lsls	r3, r3, #0x3
 8007620: 4413         	add	r3, r2
 8007622: 687a         	ldr	r2, [r7, #0x4]
 8007624: 605a         	str	r2, [r3, #0x4]
; 	return 0;
 8007626: 2300         	movs	r3, #0x0
; }
 8007628: 4618         	mov	r0, r3
 800762a: 3720         	adds	r7, #0x20
 800762c: 46bd         	mov	sp, r7
 800762e: bd80         	pop	{r7, pc}

08007630 <$d>:
 8007630: 70 7a 02 08  	.word	0x08027a70

08007634 <stm32_gpio_intc_remove_irq_callback>:
; {
 8007634: b580         	push	{r7, lr}
 8007636: b086         	sub	sp, #0x18
 8007638: af00         	add	r7, sp, #0x0
 800763a: 6078         	str	r0, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 800763c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007670 <stm32_gpio_intc_remove_irq_callback+0x3c>
 800763e: 617b         	str	r3, [r7, #0x14]
; 	struct stm32_exti_data *data = dev->data;
 8007640: 697b         	ldr	r3, [r7, #0x14]
 8007642: 691b         	ldr	r3, [r3, #0x10]
 8007644: 613b         	str	r3, [r7, #0x10]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 8007646: 6878         	ldr	r0, [r7, #0x4]
 8007648: f015 fc8b    	bl	0x801cf62 <ll_exti_line_to_linenum> @ imm = #0x15916
 800764c: 4603         	mov	r3, r0
 800764e: 60fb         	str	r3, [r7, #0xc]
; 	data->cb[line_num].cb = NULL;
 8007650: 693b         	ldr	r3, [r7, #0x10]
 8007652: 68fa         	ldr	r2, [r7, #0xc]
 8007654: 2100         	movs	r1, #0x0
 8007656: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = NULL;
 800765a: 693a         	ldr	r2, [r7, #0x10]
 800765c: 68fb         	ldr	r3, [r7, #0xc]
 800765e: 00db         	lsls	r3, r3, #0x3
 8007660: 4413         	add	r3, r2
 8007662: 2200         	movs	r2, #0x0
 8007664: 605a         	str	r2, [r3, #0x4]
; }
 8007666: bf00         	nop
 8007668: 3718         	adds	r7, #0x18
 800766a: 46bd         	mov	sp, r7
 800766c: bd80         	pop	{r7, pc}
 800766e: bf00         	nop

08007670 <$d>:
 8007670: 70 7a 02 08  	.word	0x08027a70

08007674 <z_impl_can_send>:
; {
 8007674: b590         	push	{r4, r7, lr}
 8007676: b097         	sub	sp, #0x5c
 8007678: af08         	add	r7, sp, #0x20
 800767a: 60f8         	str	r0, [r7, #0xc]
 800767c: 60b9         	str	r1, [r7, #0x8]
 800767e: e9c7 2300    	strd	r2, r3, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8007682: 68fb         	ldr	r3, [r7, #0xc]
 8007684: 689b         	ldr	r3, [r3, #0x8]
 8007686: 62fb         	str	r3, [r7, #0x2c]
; 	CHECKIF(frame == NULL) {
 8007688: 68bb         	ldr	r3, [r7, #0x8]
 800768a: 2b00         	cmp	r3, #0x0
 800768c: d102         	bne	0x8007694 <z_impl_can_send+0x20> @ imm = #0x4
; 		return -EINVAL;
 800768e: f06f 0315    	mvn	r3, #0x15
 8007692: e089         	b	0x80077a8 <z_impl_can_send+0x134> @ imm = #0x112
; 	if ((frame->flags & CAN_FRAME_IDE) != 0U) {
 8007694: 68bb         	ldr	r3, [r7, #0x8]
 8007696: 795b         	ldrb	r3, [r3, #0x5]
 8007698: f003 0301    	and	r3, r3, #0x1
 800769c: 2b00         	cmp	r3, #0x0
 800769e: d003         	beq	0x80076a8 <z_impl_can_send+0x34> @ imm = #0x6
; 		id_mask = CAN_EXT_ID_MASK;
 80076a0: f06f 4360    	mvn	r3, #0xe0000000
 80076a4: 633b         	str	r3, [r7, #0x30]
 80076a6: e002         	b	0x80076ae <z_impl_can_send+0x3a> @ imm = #0x4
; 		id_mask = CAN_STD_ID_MASK;
 80076a8: f240 73ff    	movw	r3, #0x7ff
 80076ac: 633b         	str	r3, [r7, #0x30]
; 	CHECKIF((frame->id & ~(id_mask)) != 0U) {
 80076ae: 68bb         	ldr	r3, [r7, #0x8]
 80076b0: 681a         	ldr	r2, [r3]
 80076b2: 6b3b         	ldr	r3, [r7, #0x30]
 80076b4: 43db         	mvns	r3, r3
 80076b6: 4013         	ands	r3, r2
 80076b8: 2b00         	cmp	r3, #0x0
 80076ba: d040         	beq	0x800773e <z_impl_can_send+0xca> @ imm = #0x80
; 		LOG_ERR("invalid frame with %s (%d-bit) CAN ID 0x%0*x",
 80076bc: 2303         	movs	r3, #0x3
 80076be: 2b00         	cmp	r3, #0x0
 80076c0: d03a         	beq	0x8007738 <z_impl_can_send+0xc4> @ imm = #0x74
 80076c2: 2301         	movs	r3, #0x1
 80076c4: f887 302b    	strb.w	r3, [r7, #0x2b]
 80076c8: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80076cc: f083 0301    	eor	r3, r3, #0x1
 80076d0: b2db         	uxtb	r3, r3
 80076d2: 2b00         	cmp	r3, #0x0
 80076d4: d130         	bne	0x8007738 <z_impl_can_send+0xc4> @ imm = #0x60
 80076d6: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80077b0 <z_impl_can_send+0x13c>
 80076d8: 681c         	ldr	r4, [r3]
 80076da: 68bb         	ldr	r3, [r7, #0x8]
 80076dc: 795b         	ldrb	r3, [r3, #0x5]
 80076de: f003 0301    	and	r3, r3, #0x1
 80076e2: 2b00         	cmp	r3, #0x0
 80076e4: d001         	beq	0x80076ea <z_impl_can_send+0x76> @ imm = #0x2
 80076e6: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80077b4 <z_impl_can_send+0x140>
 80076e8: e000         	b	0x80076ec <z_impl_can_send+0x78> @ imm = #0x0
 80076ea: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80077b8 <z_impl_can_send+0x144>
 80076ec: 68ba         	ldr	r2, [r7, #0x8]
 80076ee: 7952         	ldrb	r2, [r2, #0x5]
 80076f0: f002 0201    	and	r2, r2, #0x1
 80076f4: 2a00         	cmp	r2, #0x0
 80076f6: d001         	beq	0x80076fc <z_impl_can_send+0x88> @ imm = #0x2
 80076f8: 221d         	movs	r2, #0x1d
 80076fa: e000         	b	0x80076fe <z_impl_can_send+0x8a> @ imm = #0x0
 80076fc: 220b         	movs	r2, #0xb
 80076fe: 68b9         	ldr	r1, [r7, #0x8]
 8007700: 7949         	ldrb	r1, [r1, #0x5]
 8007702: f001 0101    	and	r1, r1, #0x1
 8007706: 2900         	cmp	r1, #0x0
 8007708: d001         	beq	0x800770e <z_impl_can_send+0x9a> @ imm = #0x2
 800770a: 2108         	movs	r1, #0x8
 800770c: e000         	b	0x8007710 <z_impl_can_send+0x9c> @ imm = #0x0
 800770e: 2103         	movs	r1, #0x3
 8007710: 68b8         	ldr	r0, [r7, #0x8]
 8007712: 6800         	ldr	r0, [r0]
 8007714: 9006         	str	r0, [sp, #0x18]
 8007716: 9105         	str	r1, [sp, #0x14]
 8007718: 9204         	str	r2, [sp, #0x10]
 800771a: 9303         	str	r3, [sp, #0xc]
 800771c: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x80077bc <z_impl_can_send+0x148>
 800771e: 9302         	str	r3, [sp, #0x8]
 8007720: 2300         	movs	r3, #0x0
 8007722: 9301         	str	r3, [sp, #0x4]
 8007724: 2300         	movs	r3, #0x0
 8007726: 9300         	str	r3, [sp]
 8007728: 2300         	movs	r3, #0x0
 800772a: 2201         	movs	r2, #0x1
 800772c: 4621         	mov	r1, r4
 800772e: 2000         	movs	r0, #0x0
 8007730: f015 fcf6    	bl	0x801d120 <z_log_msg_runtime_create> @ imm = #0x159ec
 8007734: 2300         	movs	r3, #0x0
 8007736: 627b         	str	r3, [r7, #0x24]
; 		return -EINVAL;
 8007738: f06f 0315    	mvn	r3, #0x15
 800773c: e034         	b	0x80077a8 <z_impl_can_send+0x134> @ imm = #0x68
; 	if (callback == NULL) {
 800773e: 6cbb         	ldr	r3, [r7, #0x48]
 8007740: 2b00         	cmp	r3, #0x0
 8007742: d125         	bne	0x8007790 <z_impl_can_send+0x11c> @ imm = #0x4a
; 		k_sem_init(&ctx.done, 0, 1);
 8007744: f107 0310    	add.w	r3, r7, #0x10
 8007748: 2201         	movs	r2, #0x1
 800774a: 2100         	movs	r1, #0x0
 800774c: 4618         	mov	r0, r3
 800774e: f015 fc66    	bl	0x801d01e <k_sem_init>  @ imm = #0x158cc
; 		err = api->send(dev, frame, timeout, can_tx_default_cb, &ctx);
 8007752: 6afb         	ldr	r3, [r7, #0x2c]
 8007754: 695c         	ldr	r4, [r3, #0x14]
 8007756: f107 0310    	add.w	r3, r7, #0x10
 800775a: 9301         	str	r3, [sp, #0x4]
 800775c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80077c0 <z_impl_can_send+0x14c>
 800775e: 9300         	str	r3, [sp]
 8007760: e9d7 2300    	ldrd	r2, r3, [r7]
 8007764: 68b9         	ldr	r1, [r7, #0x8]
 8007766: 68f8         	ldr	r0, [r7, #0xc]
 8007768: 47a0         	blx	r4
 800776a: 6378         	str	r0, [r7, #0x34]
; 		if (err != 0) {
 800776c: 6b7b         	ldr	r3, [r7, #0x34]
 800776e: 2b00         	cmp	r3, #0x0
 8007770: d001         	beq	0x8007776 <z_impl_can_send+0x102> @ imm = #0x2
; 			return err;
 8007772: 6b7b         	ldr	r3, [r7, #0x34]
 8007774: e018         	b	0x80077a8 <z_impl_can_send+0x134> @ imm = #0x30
; 		k_sem_take(&ctx.done, K_FOREVER);
 8007776: f04f 30ff    	mov.w	r0, #0xffffffff
 800777a: f04f 31ff    	mov.w	r1, #0xffffffff
 800777e: f107 0410    	add.w	r4, r7, #0x10
 8007782: 4602         	mov	r2, r0
 8007784: 460b         	mov	r3, r1
 8007786: 4620         	mov	r0, r4
 8007788: f015 fc59    	bl	0x801d03e <k_sem_take>  @ imm = #0x158b2
; 		return ctx.status;
 800778c: 6a3b         	ldr	r3, [r7, #0x20]
 800778e: e00b         	b	0x80077a8 <z_impl_can_send+0x134> @ imm = #0x16
; 	return api->send(dev, frame, timeout, callback, user_data);
 8007790: 6afb         	ldr	r3, [r7, #0x2c]
 8007792: 695c         	ldr	r4, [r3, #0x14]
 8007794: 6cfb         	ldr	r3, [r7, #0x4c]
 8007796: 9301         	str	r3, [sp, #0x4]
 8007798: 6cbb         	ldr	r3, [r7, #0x48]
 800779a: 9300         	str	r3, [sp]
 800779c: e9d7 2300    	ldrd	r2, r3, [r7]
 80077a0: 68b9         	ldr	r1, [r7, #0x8]
 80077a2: 68f8         	ldr	r0, [r7, #0xc]
 80077a4: 47a0         	blx	r4
 80077a6: 4603         	mov	r3, r0
; }
 80077a8: 4618         	mov	r0, r3
 80077aa: 373c         	adds	r7, #0x3c
 80077ac: 46bd         	mov	sp, r7
 80077ae: bd90         	pop	{r4, r7, pc}

080077b0 <$d>:
 80077b0: 30 05 00 20  	.word	0x20000530
 80077b4: 08 8b 02 08  	.word	0x08028b08
 80077b8: 14 8b 02 08  	.word	0x08028b14
 80077bc: 20 8b 02 08  	.word	0x08028b20
 80077c0: 5d d1 01 08  	.word	0x0801d15d

080077c4 <can_add_rx_filter>:
; {
 80077c4: b5f0         	push	{r4, r5, r6, r7, lr}
 80077c6: b093         	sub	sp, #0x4c
 80077c8: af0a         	add	r7, sp, #0x28
 80077ca: 60f8         	str	r0, [r7, #0xc]
 80077cc: 60b9         	str	r1, [r7, #0x8]
 80077ce: 607a         	str	r2, [r7, #0x4]
 80077d0: 603b         	str	r3, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 80077d2: 68fb         	ldr	r3, [r7, #0xc]
 80077d4: 689b         	ldr	r3, [r3, #0x8]
 80077d6: 613b         	str	r3, [r7, #0x10]
; 	CHECKIF(callback == NULL || filter == NULL) {
 80077d8: 68bb         	ldr	r3, [r7, #0x8]
 80077da: 2b00         	cmp	r3, #0x0
 80077dc: d002         	beq	0x80077e4 <can_add_rx_filter+0x20> @ imm = #0x4
 80077de: 683b         	ldr	r3, [r7]
 80077e0: 2b00         	cmp	r3, #0x0
 80077e2: d102         	bne	0x80077ea <can_add_rx_filter+0x26> @ imm = #0x4
; 		return -EINVAL;
 80077e4: f06f 0315    	mvn	r3, #0x15
 80077e8: e06e         	b	0x80078c8 <can_add_rx_filter+0x104> @ imm = #0xdc
; 	if ((filter->flags & CAN_FILTER_IDE) != 0U) {
 80077ea: 683b         	ldr	r3, [r7]
 80077ec: 7a1b         	ldrb	r3, [r3, #0x8]
 80077ee: f003 0301    	and	r3, r3, #0x1
 80077f2: 2b00         	cmp	r3, #0x0
 80077f4: d003         	beq	0x80077fe <can_add_rx_filter+0x3a> @ imm = #0x6
; 		id_mask = CAN_EXT_ID_MASK;
 80077f6: f06f 4360    	mvn	r3, #0xe0000000
 80077fa: 617b         	str	r3, [r7, #0x14]
 80077fc: e002         	b	0x8007804 <can_add_rx_filter+0x40> @ imm = #0x4
; 		id_mask = CAN_STD_ID_MASK;
 80077fe: f240 73ff    	movw	r3, #0x7ff
 8007802: 617b         	str	r3, [r7, #0x14]
; 	CHECKIF(((filter->id & ~(id_mask)) != 0U) || ((filter->mask & ~(id_mask)) != 0U)) {
 8007804: 683b         	ldr	r3, [r7]
 8007806: 681a         	ldr	r2, [r3]
 8007808: 697b         	ldr	r3, [r7, #0x14]
 800780a: 43db         	mvns	r3, r3
 800780c: 4013         	ands	r3, r2
 800780e: 2b00         	cmp	r3, #0x0
 8007810: d106         	bne	0x8007820 <can_add_rx_filter+0x5c> @ imm = #0xc
 8007812: 683b         	ldr	r3, [r7]
 8007814: 685a         	ldr	r2, [r3, #0x4]
 8007816: 697b         	ldr	r3, [r7, #0x14]
 8007818: 43db         	mvns	r3, r3
 800781a: 4013         	ands	r3, r2
 800781c: 2b00         	cmp	r3, #0x0
 800781e: d04b         	beq	0x80078b8 <can_add_rx_filter+0xf4> @ imm = #0x96
; 		LOG_ERR("invalid filter with %s (%d-bit) CAN ID 0x%0*x, CAN ID mask 0x%0*x",
 8007820: 2303         	movs	r3, #0x3
 8007822: 2b00         	cmp	r3, #0x0
 8007824: d045         	beq	0x80078b2 <can_add_rx_filter+0xee> @ imm = #0x8a
 8007826: 2301         	movs	r3, #0x1
 8007828: 76fb         	strb	r3, [r7, #0x1b]
 800782a: 7efb         	ldrb	r3, [r7, #0x1b]
 800782c: f083 0301    	eor	r3, r3, #0x1
 8007830: b2db         	uxtb	r3, r3
 8007832: 2b00         	cmp	r3, #0x0
 8007834: d13d         	bne	0x80078b2 <can_add_rx_filter+0xee> @ imm = #0x7a
 8007836: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80078d0 <can_add_rx_filter+0x10c>
 8007838: 681e         	ldr	r6, [r3]
 800783a: 683b         	ldr	r3, [r7]
 800783c: 7a1b         	ldrb	r3, [r3, #0x8]
 800783e: f003 0301    	and	r3, r3, #0x1
 8007842: 2b00         	cmp	r3, #0x0
 8007844: d001         	beq	0x800784a <can_add_rx_filter+0x86> @ imm = #0x2
 8007846: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80078d4 <can_add_rx_filter+0x110>
 8007848: e000         	b	0x800784c <can_add_rx_filter+0x88> @ imm = #0x0
 800784a: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80078d8 <can_add_rx_filter+0x114>
 800784c: 683a         	ldr	r2, [r7]
 800784e: 7a12         	ldrb	r2, [r2, #0x8]
 8007850: f002 0201    	and	r2, r2, #0x1
 8007854: 2a00         	cmp	r2, #0x0
 8007856: d001         	beq	0x800785c <can_add_rx_filter+0x98> @ imm = #0x2
 8007858: 221d         	movs	r2, #0x1d
 800785a: e000         	b	0x800785e <can_add_rx_filter+0x9a> @ imm = #0x0
 800785c: 220b         	movs	r2, #0xb
 800785e: 6839         	ldr	r1, [r7]
 8007860: 7a09         	ldrb	r1, [r1, #0x8]
 8007862: f001 0101    	and	r1, r1, #0x1
 8007866: 2900         	cmp	r1, #0x0
 8007868: d001         	beq	0x800786e <can_add_rx_filter+0xaa> @ imm = #0x2
 800786a: 2108         	movs	r1, #0x8
 800786c: e000         	b	0x8007870 <can_add_rx_filter+0xac> @ imm = #0x0
 800786e: 2103         	movs	r1, #0x3
 8007870: 6838         	ldr	r0, [r7]
 8007872: 6800         	ldr	r0, [r0]
 8007874: 683c         	ldr	r4, [r7]
 8007876: 7a24         	ldrb	r4, [r4, #0x8]
 8007878: f004 0401    	and	r4, r4, #0x1
 800787c: 2c00         	cmp	r4, #0x0
 800787e: d001         	beq	0x8007884 <can_add_rx_filter+0xc0> @ imm = #0x2
 8007880: 2408         	movs	r4, #0x8
 8007882: e000         	b	0x8007886 <can_add_rx_filter+0xc2> @ imm = #0x0
 8007884: 2403         	movs	r4, #0x3
 8007886: 683d         	ldr	r5, [r7]
 8007888: 686d         	ldr	r5, [r5, #0x4]
 800788a: 9508         	str	r5, [sp, #0x20]
 800788c: 9407         	str	r4, [sp, #0x1c]
 800788e: 9006         	str	r0, [sp, #0x18]
 8007890: 9105         	str	r1, [sp, #0x14]
 8007892: 9204         	str	r2, [sp, #0x10]
 8007894: 9303         	str	r3, [sp, #0xc]
 8007896: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80078dc <can_add_rx_filter+0x118>
 8007898: 9302         	str	r3, [sp, #0x8]
 800789a: 2300         	movs	r3, #0x0
 800789c: 9301         	str	r3, [sp, #0x4]
 800789e: 2300         	movs	r3, #0x0
 80078a0: 9300         	str	r3, [sp]
 80078a2: 2300         	movs	r3, #0x0
 80078a4: 2201         	movs	r2, #0x1
 80078a6: 4631         	mov	r1, r6
 80078a8: 2000         	movs	r0, #0x0
 80078aa: f015 fc39    	bl	0x801d120 <z_log_msg_runtime_create> @ imm = #0x15872
 80078ae: 2300         	movs	r3, #0x0
 80078b0: 61fb         	str	r3, [r7, #0x1c]
; 		return -EINVAL;
 80078b2: f06f 0315    	mvn	r3, #0x15
 80078b6: e007         	b	0x80078c8 <can_add_rx_filter+0x104> @ imm = #0xe
; 	return api->add_rx_filter(dev, callback, user_data, filter);
 80078b8: 693b         	ldr	r3, [r7, #0x10]
 80078ba: 699c         	ldr	r4, [r3, #0x18]
 80078bc: 683b         	ldr	r3, [r7]
 80078be: 687a         	ldr	r2, [r7, #0x4]
 80078c0: 68b9         	ldr	r1, [r7, #0x8]
 80078c2: 68f8         	ldr	r0, [r7, #0xc]
 80078c4: 47a0         	blx	r4
 80078c6: 4603         	mov	r3, r0
; }
 80078c8: 4618         	mov	r0, r3
 80078ca: 3724         	adds	r7, #0x24
 80078cc: 46bd         	mov	sp, r7
 80078ce: bdf0         	pop	{r4, r5, r6, r7, pc}

080078d0 <$d>:
 80078d0: 30 05 00 20  	.word	0x20000530
 80078d4: 08 8b 02 08  	.word	0x08028b08
 80078d8: 14 8b 02 08  	.word	0x08028b14
 80078dc: 50 8b 02 08  	.word	0x08028b50

080078e0 <update_sample_pnt>:
; {
 80078e0: b480         	push	{r7}
 80078e2: b089         	sub	sp, #0x24
 80078e4: af00         	add	r7, sp, #0x0
 80078e6: 60f8         	str	r0, [r7, #0xc]
 80078e8: 60b9         	str	r1, [r7, #0x8]
 80078ea: 607a         	str	r2, [r7, #0x4]
 80078ec: 603b         	str	r3, [r7]
; 	uint16_t tseg1_max = max->phase_seg1 + max->prop_seg;
 80078ee: 6abb         	ldr	r3, [r7, #0x28]
 80078f0: 889a         	ldrh	r2, [r3, #0x4]
 80078f2: 6abb         	ldr	r3, [r7, #0x28]
 80078f4: 885b         	ldrh	r3, [r3, #0x2]
 80078f6: 4413         	add	r3, r2
 80078f8: 837b         	strh	r3, [r7, #0x1a]
; 	uint16_t tseg1_min = min->phase_seg1 + min->prop_seg;
 80078fa: 683b         	ldr	r3, [r7]
 80078fc: 889a         	ldrh	r2, [r3, #0x4]
 80078fe: 683b         	ldr	r3, [r7]
 8007900: 885b         	ldrh	r3, [r3, #0x2]
 8007902: 4413         	add	r3, r2
 8007904: 833b         	strh	r3, [r7, #0x18]
; 	tseg2 = total_tq - (total_tq * sample_pnt) / 1000;
 8007906: 68fb         	ldr	r3, [r7, #0xc]
 8007908: b29a         	uxth	r2, r3
 800790a: 68fb         	ldr	r3, [r7, #0xc]
 800790c: 68b9         	ldr	r1, [r7, #0x8]
 800790e: fb01 f303    	mul	r3, r1, r3
 8007912: 4953         	ldr	r1, [pc, #0x14c]        @ 0x8007a60 <update_sample_pnt+0x180>
 8007914: fba1 1303    	umull	r1, r3, r1, r3
 8007918: 099b         	lsrs	r3, r3, #0x6
 800791a: b29b         	uxth	r3, r3
 800791c: 1ad3         	subs	r3, r2, r3
 800791e: 83bb         	strh	r3, [r7, #0x1c]
; 	tseg2 = CLAMP(tseg2, min->phase_seg2, max->phase_seg2);
 8007920: 683b         	ldr	r3, [r7]
 8007922: 88db         	ldrh	r3, [r3, #0x6]
 8007924: 8bba         	ldrh	r2, [r7, #0x1c]
 8007926: 429a         	cmp	r2, r3
 8007928: d802         	bhi	0x8007930 <update_sample_pnt+0x50> @ imm = #0x4
 800792a: 683b         	ldr	r3, [r7]
 800792c: 88db         	ldrh	r3, [r3, #0x6]
 800792e: e006         	b	0x800793e <update_sample_pnt+0x5e> @ imm = #0xc
 8007930: 6abb         	ldr	r3, [r7, #0x28]
 8007932: 88db         	ldrh	r3, [r3, #0x6]
 8007934: 8bba         	ldrh	r2, [r7, #0x1c]
 8007936: 4293         	cmp	r3, r2
 8007938: bf28         	it	hs
 800793a: 4613         	movhs	r3, r2
 800793c: b29b         	uxth	r3, r3
 800793e: 83bb         	strh	r3, [r7, #0x1c]
; 	tseg1 = total_tq - CAN_SYNC_SEG - tseg2;
 8007940: 68fb         	ldr	r3, [r7, #0xc]
 8007942: b29a         	uxth	r2, r3
 8007944: 8bbb         	ldrh	r3, [r7, #0x1c]
 8007946: 1ad3         	subs	r3, r2, r3
 8007948: b29b         	uxth	r3, r3
 800794a: 3b01         	subs	r3, #0x1
 800794c: 83fb         	strh	r3, [r7, #0x1e]
; 	if (tseg1 > tseg1_max) {
 800794e: 8bfa         	ldrh	r2, [r7, #0x1e]
 8007950: 8b7b         	ldrh	r3, [r7, #0x1a]
 8007952: 429a         	cmp	r2, r3
 8007954: d910         	bls	0x8007978 <update_sample_pnt+0x98> @ imm = #0x20
; 		tseg1 = tseg1_max;
 8007956: 8b7b         	ldrh	r3, [r7, #0x1a]
 8007958: 83fb         	strh	r3, [r7, #0x1e]
; 		tseg2 = total_tq - CAN_SYNC_SEG - tseg1;
 800795a: 68fb         	ldr	r3, [r7, #0xc]
 800795c: b29a         	uxth	r2, r3
 800795e: 8bfb         	ldrh	r3, [r7, #0x1e]
 8007960: 1ad3         	subs	r3, r2, r3
 8007962: b29b         	uxth	r3, r3
 8007964: 3b01         	subs	r3, #0x1
 8007966: 83bb         	strh	r3, [r7, #0x1c]
; 		if (tseg2 > max->phase_seg2) {
 8007968: 6abb         	ldr	r3, [r7, #0x28]
 800796a: 88db         	ldrh	r3, [r3, #0x6]
 800796c: 8bba         	ldrh	r2, [r7, #0x1c]
 800796e: 429a         	cmp	r2, r3
 8007970: d917         	bls	0x80079a2 <update_sample_pnt+0xc2> @ imm = #0x2e
; 			return -ENOTSUP;
 8007972: f06f 0385    	mvn	r3, #0x85
 8007976: e06c         	b	0x8007a52 <update_sample_pnt+0x172> @ imm = #0xd8
; 	} else if (tseg1 < tseg1_min) {
 8007978: 8bfa         	ldrh	r2, [r7, #0x1e]
 800797a: 8b3b         	ldrh	r3, [r7, #0x18]
 800797c: 429a         	cmp	r2, r3
 800797e: d210         	bhs	0x80079a2 <update_sample_pnt+0xc2> @ imm = #0x20
; 		tseg1 = tseg1_min;
 8007980: 8b3b         	ldrh	r3, [r7, #0x18]
 8007982: 83fb         	strh	r3, [r7, #0x1e]
; 		tseg2 = total_tq - CAN_SYNC_SEG - tseg1;
 8007984: 68fb         	ldr	r3, [r7, #0xc]
 8007986: b29a         	uxth	r2, r3
 8007988: 8bfb         	ldrh	r3, [r7, #0x1e]
 800798a: 1ad3         	subs	r3, r2, r3
 800798c: b29b         	uxth	r3, r3
 800798e: 3b01         	subs	r3, #0x1
 8007990: 83bb         	strh	r3, [r7, #0x1c]
; 		if (tseg2 < min->phase_seg2) {
 8007992: 683b         	ldr	r3, [r7]
 8007994: 88db         	ldrh	r3, [r3, #0x6]
 8007996: 8bba         	ldrh	r2, [r7, #0x1c]
 8007998: 429a         	cmp	r2, r3
 800799a: d202         	bhs	0x80079a2 <update_sample_pnt+0xc2> @ imm = #0x4
; 			return -ENOTSUP;
 800799c: f06f 0385    	mvn	r3, #0x85
 80079a0: e057         	b	0x8007a52 <update_sample_pnt+0x172> @ imm = #0xae
; 	res->phase_seg2 = tseg2;
 80079a2: 687b         	ldr	r3, [r7, #0x4]
 80079a4: 8bba         	ldrh	r2, [r7, #0x1c]
 80079a6: 80da         	strh	r2, [r3, #0x6]
; 	res->prop_seg = CLAMP(tseg1 / 2, min->prop_seg, max->prop_seg);
 80079a8: 8bfb         	ldrh	r3, [r7, #0x1e]
 80079aa: 085b         	lsrs	r3, r3, #0x1
 80079ac: b29a         	uxth	r2, r3
 80079ae: 683b         	ldr	r3, [r7]
 80079b0: 885b         	ldrh	r3, [r3, #0x2]
 80079b2: 429a         	cmp	r2, r3
 80079b4: d802         	bhi	0x80079bc <update_sample_pnt+0xdc> @ imm = #0x4
 80079b6: 683b         	ldr	r3, [r7]
 80079b8: 885b         	ldrh	r3, [r3, #0x2]
 80079ba: e008         	b	0x80079ce <update_sample_pnt+0xee> @ imm = #0x10
 80079bc: 6abb         	ldr	r3, [r7, #0x28]
 80079be: 885a         	ldrh	r2, [r3, #0x2]
 80079c0: 8bfb         	ldrh	r3, [r7, #0x1e]
 80079c2: 085b         	lsrs	r3, r3, #0x1
 80079c4: b29b         	uxth	r3, r3
 80079c6: 4293         	cmp	r3, r2
 80079c8: bf28         	it	hs
 80079ca: 4613         	movhs	r3, r2
 80079cc: b29b         	uxth	r3, r3
 80079ce: 687a         	ldr	r2, [r7, #0x4]
 80079d0: 8053         	strh	r3, [r2, #0x2]
; 	res->phase_seg1 = tseg1 - res->prop_seg;
 80079d2: 687b         	ldr	r3, [r7, #0x4]
 80079d4: 885b         	ldrh	r3, [r3, #0x2]
 80079d6: 8bfa         	ldrh	r2, [r7, #0x1e]
 80079d8: 1ad3         	subs	r3, r2, r3
 80079da: b29a         	uxth	r2, r3
 80079dc: 687b         	ldr	r3, [r7, #0x4]
 80079de: 809a         	strh	r2, [r3, #0x4]
; 	if (res->phase_seg1 > max->phase_seg1) {
 80079e0: 687b         	ldr	r3, [r7, #0x4]
 80079e2: 889a         	ldrh	r2, [r3, #0x4]
 80079e4: 6abb         	ldr	r3, [r7, #0x28]
 80079e6: 889b         	ldrh	r3, [r3, #0x4]
 80079e8: 429a         	cmp	r2, r3
 80079ea: d90b         	bls	0x8007a04 <update_sample_pnt+0x124> @ imm = #0x16
; 		res->phase_seg1 = max->phase_seg1;
 80079ec: 6abb         	ldr	r3, [r7, #0x28]
 80079ee: 889a         	ldrh	r2, [r3, #0x4]
 80079f0: 687b         	ldr	r3, [r7, #0x4]
 80079f2: 809a         	strh	r2, [r3, #0x4]
; 		res->prop_seg = tseg1 - res->phase_seg1;
 80079f4: 687b         	ldr	r3, [r7, #0x4]
 80079f6: 889b         	ldrh	r3, [r3, #0x4]
 80079f8: 8bfa         	ldrh	r2, [r7, #0x1e]
 80079fa: 1ad3         	subs	r3, r2, r3
 80079fc: b29a         	uxth	r2, r3
 80079fe: 687b         	ldr	r3, [r7, #0x4]
 8007a00: 805a         	strh	r2, [r3, #0x2]
 8007a02: e010         	b	0x8007a26 <update_sample_pnt+0x146> @ imm = #0x20
; 	} else if (res->phase_seg1 < min->phase_seg1) {
 8007a04: 687b         	ldr	r3, [r7, #0x4]
 8007a06: 889a         	ldrh	r2, [r3, #0x4]
 8007a08: 683b         	ldr	r3, [r7]
 8007a0a: 889b         	ldrh	r3, [r3, #0x4]
 8007a0c: 429a         	cmp	r2, r3
 8007a0e: d20a         	bhs	0x8007a26 <update_sample_pnt+0x146> @ imm = #0x14
; 		res->phase_seg1 = min->phase_seg1;
 8007a10: 683b         	ldr	r3, [r7]
 8007a12: 889a         	ldrh	r2, [r3, #0x4]
 8007a14: 687b         	ldr	r3, [r7, #0x4]
 8007a16: 809a         	strh	r2, [r3, #0x4]
; 		res->prop_seg = tseg1 - res->phase_seg1;
 8007a18: 687b         	ldr	r3, [r7, #0x4]
 8007a1a: 889b         	ldrh	r3, [r3, #0x4]
 8007a1c: 8bfa         	ldrh	r2, [r7, #0x1e]
 8007a1e: 1ad3         	subs	r3, r2, r3
 8007a20: b29a         	uxth	r2, r3
 8007a22: 687b         	ldr	r3, [r7, #0x4]
 8007a24: 805a         	strh	r2, [r3, #0x2]
; 	sample_pnt_res = (CAN_SYNC_SEG + tseg1) * 1000 / total_tq;
 8007a26: 8bfb         	ldrh	r3, [r7, #0x1e]
 8007a28: 3301         	adds	r3, #0x1
 8007a2a: f44f 727a    	mov.w	r2, #0x3e8
 8007a2e: fb02 f303    	mul	r3, r2, r3
 8007a32: 461a         	mov	r2, r3
 8007a34: 68fb         	ldr	r3, [r7, #0xc]
 8007a36: fbb2 f3f3    	udiv	r3, r2, r3
 8007a3a: 617b         	str	r3, [r7, #0x14]
; 		sample_pnt_res - sample_pnt :
 8007a3c: 697a         	ldr	r2, [r7, #0x14]
 8007a3e: 68bb         	ldr	r3, [r7, #0x8]
 8007a40: 429a         	cmp	r2, r3
 8007a42: d903         	bls	0x8007a4c <update_sample_pnt+0x16c> @ imm = #0x6
 8007a44: 697a         	ldr	r2, [r7, #0x14]
 8007a46: 68bb         	ldr	r3, [r7, #0x8]
 8007a48: 1ad3         	subs	r3, r2, r3
 8007a4a: e002         	b	0x8007a52 <update_sample_pnt+0x172> @ imm = #0x4
; 		sample_pnt - sample_pnt_res;
 8007a4c: 68ba         	ldr	r2, [r7, #0x8]
 8007a4e: 697b         	ldr	r3, [r7, #0x14]
 8007a50: 1ad3         	subs	r3, r2, r3
; }
 8007a52: 4618         	mov	r0, r3
 8007a54: 3724         	adds	r7, #0x24
 8007a56: 46bd         	mov	sp, r7
 8007a58: f85d 7b04    	ldr	r7, [sp], #4
 8007a5c: 4770         	bx	lr
 8007a5e: bf00         	nop

08007a60 <$d>:
 8007a60: d3 4d 62 10  	.word	0x10624dd3

08007a64 <sample_point_for_bitrate>:
; {
 8007a64: b480         	push	{r7}
 8007a66: b085         	sub	sp, #0x14
 8007a68: af00         	add	r7, sp, #0x0
 8007a6a: 6078         	str	r0, [r7, #0x4]
; 	if (bitrate > 800000) {
 8007a6c: 687b         	ldr	r3, [r7, #0x4]
 8007a6e: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8007aa0 <sample_point_for_bitrate+0x3c>
 8007a70: 4293         	cmp	r3, r2
 8007a72: d903         	bls	0x8007a7c <sample_point_for_bitrate+0x18> @ imm = #0x6
; 		sample_pnt = 750;
 8007a74: f240 23ee    	movw	r3, #0x2ee
 8007a78: 81fb         	strh	r3, [r7, #0xe]
 8007a7a: e00a         	b	0x8007a92 <sample_point_for_bitrate+0x2e> @ imm = #0x14
; 	} else if (bitrate > 500000) {
 8007a7c: 687b         	ldr	r3, [r7, #0x4]
 8007a7e: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8007aa4 <sample_point_for_bitrate+0x40>
 8007a80: 4293         	cmp	r3, r2
 8007a82: d903         	bls	0x8007a8c <sample_point_for_bitrate+0x28> @ imm = #0x6
; 		sample_pnt = 800;
 8007a84: f44f 7348    	mov.w	r3, #0x320
 8007a88: 81fb         	strh	r3, [r7, #0xe]
 8007a8a: e002         	b	0x8007a92 <sample_point_for_bitrate+0x2e> @ imm = #0x4
; 		sample_pnt = 875;
 8007a8c: f240 336b    	movw	r3, #0x36b
 8007a90: 81fb         	strh	r3, [r7, #0xe]
; 	return sample_pnt;
 8007a92: 89fb         	ldrh	r3, [r7, #0xe]
; }
 8007a94: 4618         	mov	r0, r3
 8007a96: 3714         	adds	r7, #0x14
 8007a98: 46bd         	mov	sp, r7
 8007a9a: f85d 7b04    	ldr	r7, [sp], #4
 8007a9e: 4770         	bx	lr

08007aa0 <$d>:
 8007aa0: 00 35 0c 00  	.word	0x000c3500
 8007aa4: 20 a1 07 00  	.word	0x0007a120

08007aa8 <can_calc_timing_internal>:
; {
 8007aa8: b580         	push	{r7, lr}
 8007aaa: b094         	sub	sp, #0x50
 8007aac: af06         	add	r7, sp, #0x18
 8007aae: 60f8         	str	r0, [r7, #0xc]
 8007ab0: 60b9         	str	r1, [r7, #0x8]
 8007ab2: 607a         	str	r2, [r7, #0x4]
 8007ab4: 603b         	str	r3, [r7]
; 	uint32_t total_tq = CAN_SYNC_SEG + max->prop_seg + max->phase_seg1 + max->phase_seg2;
 8007ab6: 683b         	ldr	r3, [r7]
 8007ab8: 885b         	ldrh	r3, [r3, #0x2]
 8007aba: 3301         	adds	r3, #0x1
 8007abc: 683a         	ldr	r2, [r7]
 8007abe: 8892         	ldrh	r2, [r2, #0x4]
 8007ac0: 4413         	add	r3, r2
 8007ac2: 683a         	ldr	r2, [r7]
 8007ac4: 88d2         	ldrh	r2, [r2, #0x6]
 8007ac6: 4413         	add	r3, r2
 8007ac8: 62fb         	str	r3, [r7, #0x2c]
; 	struct can_timing tmp_res = { 0 };
 8007aca: f107 0314    	add.w	r3, r7, #0x14
 8007ace: 2200         	movs	r2, #0x0
 8007ad0: 601a         	str	r2, [r3]
 8007ad2: 605a         	str	r2, [r3, #0x4]
 8007ad4: 811a         	strh	r2, [r3, #0x8]
; 	int err_min = INT_MAX;
 8007ad6: f06f 4300    	mvn	r3, #0x80000000
 8007ada: 637b         	str	r3, [r7, #0x34]
; 	if (bitrate == 0 || sample_pnt >= 1000) {
 8007adc: 6c3b         	ldr	r3, [r7, #0x40]
 8007ade: 2b00         	cmp	r3, #0x0
 8007ae0: d004         	beq	0x8007aec <can_calc_timing_internal+0x44> @ imm = #0x8
 8007ae2: f8b7 3044    	ldrh.w	r3, [r7, #0x44]
 8007ae6: f5b3 7f7a    	cmp.w	r3, #0x3e8
 8007aea: d302         	blo	0x8007af2 <can_calc_timing_internal+0x4a> @ imm = #0x4
; 		return -EINVAL;
 8007aec: f06f 0315    	mvn	r3, #0x15
 8007af0: e0b7         	b	0x8007c62 <can_calc_timing_internal+0x1ba> @ imm = #0x16e
; 	err = can_get_core_clock(dev, &core_clock);
 8007af2: f107 0310    	add.w	r3, r7, #0x10
 8007af6: 4619         	mov	r1, r3
 8007af8: 68f8         	ldr	r0, [r7, #0xc]
 8007afa: f015 faeb    	bl	0x801d0d4 <can_get_core_clock> @ imm = #0x155d6
 8007afe: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 8007b00: 6abb         	ldr	r3, [r7, #0x28]
 8007b02: 2b00         	cmp	r3, #0x0
 8007b04: d002         	beq	0x8007b0c <can_calc_timing_internal+0x64> @ imm = #0x4
; 		return -EIO;
 8007b06: f06f 0304    	mvn	r3, #0x4
 8007b0a: e0aa         	b	0x8007c62 <can_calc_timing_internal+0x1ba> @ imm = #0x154
; 	if (sample_pnt == 0U) {
 8007b0c: f8b7 3044    	ldrh.w	r3, [r7, #0x44]
 8007b10: 2b00         	cmp	r3, #0x0
 8007b12: d105         	bne	0x8007b20 <can_calc_timing_internal+0x78> @ imm = #0xa
; 		sample_pnt = sample_point_for_bitrate(bitrate);
 8007b14: 6c38         	ldr	r0, [r7, #0x40]
 8007b16: f7ff ffa5    	bl	0x8007a64 <sample_point_for_bitrate> @ imm = #-0xb6
 8007b1a: 4603         	mov	r3, r0
 8007b1c: f8a7 3044    	strh.w	r3, [r7, #0x44]
; 	for (prescaler = MAX(core_clock / (total_tq * bitrate), min->prescaler);
 8007b20: 687b         	ldr	r3, [r7, #0x4]
 8007b22: 891b         	ldrh	r3, [r3, #0x8]
 8007b24: 4618         	mov	r0, r3
 8007b26: 693a         	ldr	r2, [r7, #0x10]
 8007b28: 6afb         	ldr	r3, [r7, #0x2c]
 8007b2a: 6c39         	ldr	r1, [r7, #0x40]
 8007b2c: fb01 f303    	mul	r3, r1, r3
 8007b30: fbb2 f3f3    	udiv	r3, r2, r3
 8007b34: 4283         	cmp	r3, r0
 8007b36: bf38         	it	lo
 8007b38: 4603         	movlo	r3, r0
 8007b3a: 633b         	str	r3, [r7, #0x30]
 8007b3c: e03e         	b	0x8007bbc <can_calc_timing_internal+0x114> @ imm = #0x7c
; 		if (core_clock % (prescaler * bitrate)) {
 8007b3e: 693b         	ldr	r3, [r7, #0x10]
 8007b40: 6b3a         	ldr	r2, [r7, #0x30]
 8007b42: 6c39         	ldr	r1, [r7, #0x40]
 8007b44: fb01 f202    	mul	r2, r1, r2
 8007b48: fbb3 f1f2    	udiv	r1, r3, r2
 8007b4c: fb01 f202    	mul	r2, r1, r2
 8007b50: 1a9b         	subs	r3, r3, r2
 8007b52: 2b00         	cmp	r3, #0x0
 8007b54: d12c         	bne	0x8007bb0 <can_calc_timing_internal+0x108> @ imm = #0x58
; 		total_tq = core_clock / (prescaler * bitrate);
 8007b56: 693a         	ldr	r2, [r7, #0x10]
 8007b58: 6b3b         	ldr	r3, [r7, #0x30]
 8007b5a: 6c39         	ldr	r1, [r7, #0x40]
 8007b5c: fb01 f303    	mul	r3, r1, r3
 8007b60: fbb2 f3f3    	udiv	r3, r2, r3
 8007b64: 62fb         	str	r3, [r7, #0x2c]
; 		err = update_sample_pnt(total_tq, sample_pnt, &tmp_res, min, max);
 8007b66: f8b7 1044    	ldrh.w	r1, [r7, #0x44]
 8007b6a: f107 0214    	add.w	r2, r7, #0x14
 8007b6e: 683b         	ldr	r3, [r7]
 8007b70: 9300         	str	r3, [sp]
 8007b72: 687b         	ldr	r3, [r7, #0x4]
 8007b74: 6af8         	ldr	r0, [r7, #0x2c]
 8007b76: f7ff feb3    	bl	0x80078e0 <update_sample_pnt> @ imm = #-0x29a
 8007b7a: 62b8         	str	r0, [r7, #0x28]
; 		if (err < 0) {
 8007b7c: 6abb         	ldr	r3, [r7, #0x28]
 8007b7e: 2b00         	cmp	r3, #0x0
 8007b80: db18         	blt	0x8007bb4 <can_calc_timing_internal+0x10c> @ imm = #0x30
; 		if (err < err_min) {
 8007b82: 6aba         	ldr	r2, [r7, #0x28]
 8007b84: 6b7b         	ldr	r3, [r7, #0x34]
 8007b86: 429a         	cmp	r2, r3
 8007b88: da15         	bge	0x8007bb6 <can_calc_timing_internal+0x10e> @ imm = #0x2a
; 			err_min = err;
 8007b8a: 6abb         	ldr	r3, [r7, #0x28]
 8007b8c: 637b         	str	r3, [r7, #0x34]
; 			res->prop_seg = tmp_res.prop_seg;
 8007b8e: 8afa         	ldrh	r2, [r7, #0x16]
 8007b90: 68bb         	ldr	r3, [r7, #0x8]
 8007b92: 805a         	strh	r2, [r3, #0x2]
; 			res->phase_seg1 = tmp_res.phase_seg1;
 8007b94: 8b3a         	ldrh	r2, [r7, #0x18]
 8007b96: 68bb         	ldr	r3, [r7, #0x8]
 8007b98: 809a         	strh	r2, [r3, #0x4]
; 			res->phase_seg2 = tmp_res.phase_seg2;
 8007b9a: 8b7a         	ldrh	r2, [r7, #0x1a]
 8007b9c: 68bb         	ldr	r3, [r7, #0x8]
 8007b9e: 80da         	strh	r2, [r3, #0x6]
; 			res->prescaler = (uint16_t)prescaler;
 8007ba0: 6b3b         	ldr	r3, [r7, #0x30]
 8007ba2: b29a         	uxth	r2, r3
 8007ba4: 68bb         	ldr	r3, [r7, #0x8]
 8007ba6: 811a         	strh	r2, [r3, #0x8]
; 			if (err == 0) {
 8007ba8: 6abb         	ldr	r3, [r7, #0x28]
 8007baa: 2b00         	cmp	r3, #0x0
 8007bac: d00d         	beq	0x8007bca <can_calc_timing_internal+0x122> @ imm = #0x1a
 8007bae: e002         	b	0x8007bb6 <can_calc_timing_internal+0x10e> @ imm = #0x4
; 			continue;
 8007bb0: bf00         	nop
 8007bb2: e000         	b	0x8007bb6 <can_calc_timing_internal+0x10e> @ imm = #0x0
; 			continue;
 8007bb4: bf00         	nop
; 	     prescaler++) {
 8007bb6: 6b3b         	ldr	r3, [r7, #0x30]
 8007bb8: 3301         	adds	r3, #0x1
 8007bba: 633b         	str	r3, [r7, #0x30]
; 	     prescaler <= max->prescaler;
 8007bbc: 683b         	ldr	r3, [r7]
 8007bbe: 891b         	ldrh	r3, [r3, #0x8]
 8007bc0: 461a         	mov	r2, r3
 8007bc2: 6b3b         	ldr	r3, [r7, #0x30]
 8007bc4: 4293         	cmp	r3, r2
 8007bc6: ddba         	ble	0x8007b3e <can_calc_timing_internal+0x96> @ imm = #-0x8c
 8007bc8: e000         	b	0x8007bcc <can_calc_timing_internal+0x124> @ imm = #0x0
; 				break;
 8007bca: bf00         	nop
; 	if (err_min != 0U) {
 8007bcc: 6b7b         	ldr	r3, [r7, #0x34]
 8007bce: 2b00         	cmp	r3, #0x0
 8007bd0: d01f         	beq	0x8007c12 <can_calc_timing_internal+0x16a> @ imm = #0x3e
; 		LOG_DBG("Sample point error: %d 1/1000", err_min);
 8007bd2: 2303         	movs	r3, #0x3
 8007bd4: 2b03         	cmp	r3, #0x3
 8007bd6: d91c         	bls	0x8007c12 <can_calc_timing_internal+0x16a> @ imm = #0x38
 8007bd8: 2301         	movs	r3, #0x1
 8007bda: f887 3027    	strb.w	r3, [r7, #0x27]
 8007bde: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8007be2: f083 0301    	eor	r3, r3, #0x1
 8007be6: b2db         	uxtb	r3, r3
 8007be8: 2b00         	cmp	r3, #0x0
 8007bea: d112         	bne	0x8007c12 <can_calc_timing_internal+0x16a> @ imm = #0x24
 8007bec: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8007c6c <can_calc_timing_internal+0x1c4>
 8007bee: 6819         	ldr	r1, [r3]
 8007bf0: 6b7b         	ldr	r3, [r7, #0x34]
 8007bf2: 9304         	str	r3, [sp, #0x10]
 8007bf4: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8007c70 <can_calc_timing_internal+0x1c8>
 8007bf6: 9303         	str	r3, [sp, #0xc]
 8007bf8: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8007c74 <can_calc_timing_internal+0x1cc>
 8007bfa: 9302         	str	r3, [sp, #0x8]
 8007bfc: 2308         	movs	r3, #0x8
 8007bfe: 9301         	str	r3, [sp, #0x4]
 8007c00: 2300         	movs	r3, #0x0
 8007c02: 9300         	str	r3, [sp]
 8007c04: 2300         	movs	r3, #0x0
 8007c06: 2204         	movs	r2, #0x4
 8007c08: 2000         	movs	r0, #0x0
 8007c0a: f015 fa89    	bl	0x801d120 <z_log_msg_runtime_create> @ imm = #0x15512
 8007c0e: 2300         	movs	r3, #0x0
 8007c10: 623b         	str	r3, [r7, #0x20]
; 	res->sjw = MIN(res->phase_seg1, res->phase_seg2 / 2);
 8007c12: 68bb         	ldr	r3, [r7, #0x8]
 8007c14: 88db         	ldrh	r3, [r3, #0x6]
 8007c16: 085b         	lsrs	r3, r3, #0x1
 8007c18: b29a         	uxth	r2, r3
 8007c1a: 68bb         	ldr	r3, [r7, #0x8]
 8007c1c: 889b         	ldrh	r3, [r3, #0x4]
 8007c1e: 4293         	cmp	r3, r2
 8007c20: bf28         	it	hs
 8007c22: 4613         	movhs	r3, r2
 8007c24: b29a         	uxth	r2, r3
 8007c26: 68bb         	ldr	r3, [r7, #0x8]
 8007c28: 801a         	strh	r2, [r3]
; 	res->sjw = CLAMP(res->sjw, min->sjw, max->sjw);
 8007c2a: 68bb         	ldr	r3, [r7, #0x8]
 8007c2c: 881a         	ldrh	r2, [r3]
 8007c2e: 687b         	ldr	r3, [r7, #0x4]
 8007c30: 881b         	ldrh	r3, [r3]
 8007c32: 429a         	cmp	r2, r3
 8007c34: d802         	bhi	0x8007c3c <can_calc_timing_internal+0x194> @ imm = #0x4
 8007c36: 687b         	ldr	r3, [r7, #0x4]
 8007c38: 881b         	ldrh	r3, [r3]
 8007c3a: e007         	b	0x8007c4c <can_calc_timing_internal+0x1a4> @ imm = #0xe
 8007c3c: 683b         	ldr	r3, [r7]
 8007c3e: 881a         	ldrh	r2, [r3]
 8007c40: 68bb         	ldr	r3, [r7, #0x8]
 8007c42: 881b         	ldrh	r3, [r3]
 8007c44: 4293         	cmp	r3, r2
 8007c46: bf28         	it	hs
 8007c48: 4613         	movhs	r3, r2
 8007c4a: b29b         	uxth	r3, r3
 8007c4c: 68ba         	ldr	r2, [r7, #0x8]
 8007c4e: 8013         	strh	r3, [r2]
; 	return err_min == INT_MAX ? -ENOTSUP : err_min;
 8007c50: 6b7b         	ldr	r3, [r7, #0x34]
 8007c52: f06f 4200    	mvn	r2, #0x80000000
 8007c56: 4293         	cmp	r3, r2
 8007c58: d001         	beq	0x8007c5e <can_calc_timing_internal+0x1b6> @ imm = #0x2
 8007c5a: 6b7b         	ldr	r3, [r7, #0x34]
 8007c5c: e001         	b	0x8007c62 <can_calc_timing_internal+0x1ba> @ imm = #0x2
 8007c5e: f06f 0385    	mvn	r3, #0x85
; }
 8007c62: 4618         	mov	r0, r3
 8007c64: 3738         	adds	r7, #0x38
 8007c66: 46bd         	mov	sp, r7
 8007c68: bd80         	pop	{r7, pc}
 8007c6a: bf00         	nop

08007c6c <$d>:
 8007c6c: 30 05 00 20  	.word	0x20000530
 8007c70: 2c a8 02 08  	.word	0x0802a82c
 8007c74: b8 8b 02 08  	.word	0x08028bb8

08007c78 <z_impl_can_calc_timing>:
; {
 8007c78: b580         	push	{r7, lr}
 8007c7a: b088         	sub	sp, #0x20
 8007c7c: af02         	add	r7, sp, #0x8
 8007c7e: 60f8         	str	r0, [r7, #0xc]
 8007c80: 60b9         	str	r1, [r7, #0x8]
 8007c82: 607a         	str	r2, [r7, #0x4]
 8007c84: 807b         	strh	r3, [r7, #0x2]
; 	const struct can_timing *min = can_get_timing_min(dev);
 8007c86: 68f8         	ldr	r0, [r7, #0xc]
 8007c88: f015 fa32    	bl	0x801d0f0 <can_get_timing_min> @ imm = #0x15464
 8007c8c: 6178         	str	r0, [r7, #0x14]
; 	const struct can_timing *max = can_get_timing_max(dev);
 8007c8e: 68f8         	ldr	r0, [r7, #0xc]
 8007c90: f015 fa3a    	bl	0x801d108 <can_get_timing_max> @ imm = #0x15474
 8007c94: 6138         	str	r0, [r7, #0x10]
; 	if (bitrate > 1000000) {
 8007c96: 687b         	ldr	r3, [r7, #0x4]
 8007c98: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007cc4 <z_impl_can_calc_timing+0x4c>
 8007c9a: 4293         	cmp	r3, r2
 8007c9c: d902         	bls	0x8007ca4 <z_impl_can_calc_timing+0x2c> @ imm = #0x4
; 		return -EINVAL;
 8007c9e: f06f 0315    	mvn	r3, #0x15
 8007ca2: e00a         	b	0x8007cba <z_impl_can_calc_timing+0x42> @ imm = #0x14
; 	return can_calc_timing_internal(dev, res, min, max, bitrate, sample_pnt);
 8007ca4: 887b         	ldrh	r3, [r7, #0x2]
 8007ca6: 9301         	str	r3, [sp, #0x4]
 8007ca8: 687b         	ldr	r3, [r7, #0x4]
 8007caa: 9300         	str	r3, [sp]
 8007cac: 693b         	ldr	r3, [r7, #0x10]
 8007cae: 697a         	ldr	r2, [r7, #0x14]
 8007cb0: 68b9         	ldr	r1, [r7, #0x8]
 8007cb2: 68f8         	ldr	r0, [r7, #0xc]
 8007cb4: f7ff fef8    	bl	0x8007aa8 <can_calc_timing_internal> @ imm = #-0x210
 8007cb8: 4603         	mov	r3, r0
; }
 8007cba: 4618         	mov	r0, r3
 8007cbc: 3718         	adds	r7, #0x18
 8007cbe: 46bd         	mov	sp, r7
 8007cc0: bd80         	pop	{r7, pc}
 8007cc2: bf00         	nop

08007cc4 <$d>:
 8007cc4: 40 42 0f 00  	.word	0x000f4240

08007cc8 <can_stm32_rx_isr_handler>:
; {
 8007cc8: b580         	push	{r7, lr}
 8007cca: b098         	sub	sp, #0x60
 8007ccc: af06         	add	r7, sp, #0x18
 8007cce: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 8007cd0: 687b         	ldr	r3, [r7, #0x4]
 8007cd2: 691b         	ldr	r3, [r3, #0x10]
 8007cd4: 63bb         	str	r3, [r7, #0x38]
; 	const struct can_stm32_config *cfg = dev->config;
 8007cd6: 687b         	ldr	r3, [r7, #0x4]
 8007cd8: 685b         	ldr	r3, [r3, #0x4]
 8007cda: 637b         	str	r3, [r7, #0x34]
; 	CAN_TypeDef *can = cfg->can;
 8007cdc: 6b7b         	ldr	r3, [r7, #0x34]
 8007cde: 695b         	ldr	r3, [r3, #0x14]
 8007ce0: 633b         	str	r3, [r7, #0x30]
; 	can_rx_callback_t callback = NULL;
 8007ce2: 2300         	movs	r3, #0x0
 8007ce4: 647b         	str	r3, [r7, #0x44]
; 	while (can->RF0R & CAN_RF0R_FMP0) {
 8007ce6: e06a         	b	0x8007dbe <can_stm32_rx_isr_handler+0xf6> @ imm = #0xd4
; 		mbox = &can->sFIFOMailBox[0];
 8007ce8: 6b3b         	ldr	r3, [r7, #0x30]
 8007cea: f503 73d8    	add.w	r3, r3, #0x1b0
 8007cee: 627b         	str	r3, [r7, #0x24]
; 		filter_id = ((mbox->RDTR & CAN_RDT0R_FMI) >> CAN_RDT0R_FMI_Pos);
 8007cf0: 6a7b         	ldr	r3, [r7, #0x24]
 8007cf2: 685b         	ldr	r3, [r3, #0x4]
 8007cf4: 0a1b         	lsrs	r3, r3, #0x8
 8007cf6: b2db         	uxtb	r3, r3
 8007cf8: 63fb         	str	r3, [r7, #0x3c]
; 		if (cfg->master_can != cfg->can) {
 8007cfa: 6b7b         	ldr	r3, [r7, #0x34]
 8007cfc: 699a         	ldr	r2, [r3, #0x18]
 8007cfe: 6b7b         	ldr	r3, [r7, #0x34]
 8007d00: 695b         	ldr	r3, [r3, #0x14]
 8007d02: 429a         	cmp	r2, r3
 8007d04: d002         	beq	0x8007d0c <can_stm32_rx_isr_handler+0x44> @ imm = #0x4
; 			filter_id -= 7;
 8007d06: 6bfb         	ldr	r3, [r7, #0x3c]
 8007d08: 3b07         	subs	r3, #0x7
 8007d0a: 63fb         	str	r3, [r7, #0x3c]
; 		LOG_DBG("Message on filter_id %d", filter_id);
 8007d0c: 2303         	movs	r3, #0x3
 8007d0e: 2b03         	cmp	r3, #0x3
 8007d10: d91c         	bls	0x8007d4c <can_stm32_rx_isr_handler+0x84> @ imm = #0x38
 8007d12: 2301         	movs	r3, #0x1
 8007d14: f887 3023    	strb.w	r3, [r7, #0x23]
 8007d18: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8007d1c: f083 0301    	eor	r3, r3, #0x1
 8007d20: b2db         	uxtb	r3, r3
 8007d22: 2b00         	cmp	r3, #0x0
 8007d24: d112         	bne	0x8007d4c <can_stm32_rx_isr_handler+0x84> @ imm = #0x24
 8007d26: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8007e18 <can_stm32_rx_isr_handler+0x150>
 8007d28: 6819         	ldr	r1, [r3]
 8007d2a: 6bfb         	ldr	r3, [r7, #0x3c]
 8007d2c: 9304         	str	r3, [sp, #0x10]
 8007d2e: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8007e1c <can_stm32_rx_isr_handler+0x154>
 8007d30: 9303         	str	r3, [sp, #0xc]
 8007d32: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8007e20 <can_stm32_rx_isr_handler+0x158>
 8007d34: 9302         	str	r3, [sp, #0x8]
 8007d36: 2308         	movs	r3, #0x8
 8007d38: 9301         	str	r3, [sp, #0x4]
 8007d3a: 2300         	movs	r3, #0x0
 8007d3c: 9300         	str	r3, [sp]
 8007d3e: 2300         	movs	r3, #0x0
 8007d40: 2204         	movs	r2, #0x4
 8007d42: 2000         	movs	r0, #0x0
 8007d44: f015 fba6    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x1574c
 8007d48: 2300         	movs	r3, #0x0
 8007d4a: 61fb         	str	r3, [r7, #0x1c]
; 		can_stm32_rx_fifo_pop(mbox, &frame);
 8007d4c: f107 0308    	add.w	r3, r7, #0x8
 8007d50: 4619         	mov	r1, r3
 8007d52: 6a78         	ldr	r0, [r7, #0x24]
 8007d54: f015 fbd5    	bl	0x801d502 <can_stm32_rx_fifo_pop> @ imm = #0x157aa
; 		if (filter_id < CONFIG_CAN_MAX_EXT_ID_FILTER) {
 8007d58: 6bfb         	ldr	r3, [r7, #0x3c]
 8007d5a: 2b06         	cmp	r3, #0x6
 8007d5c: dc0d         	bgt	0x8007d7a <can_stm32_rx_isr_handler+0xb2> @ imm = #0x1a
; 			callback = data->rx_cb_ext[filter_id];
 8007d5e: 6bba         	ldr	r2, [r7, #0x38]
 8007d60: 6bfb         	ldr	r3, [r7, #0x3c]
 8007d62: 3320         	adds	r3, #0x20
 8007d64: 009b         	lsls	r3, r3, #0x2
 8007d66: 4413         	add	r3, r2
 8007d68: 685b         	ldr	r3, [r3, #0x4]
 8007d6a: 647b         	str	r3, [r7, #0x44]
; 			cb_arg = data->cb_arg_ext[filter_id];
 8007d6c: 6bbb         	ldr	r3, [r7, #0x38]
 8007d6e: 6bfa         	ldr	r2, [r7, #0x3c]
 8007d70: 3236         	adds	r2, #0x36
 8007d72: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8007d76: 643b         	str	r3, [r7, #0x40]
 8007d78: e012         	b	0x8007da0 <can_stm32_rx_isr_handler+0xd8> @ imm = #0x24
; 		} else if (filter_id < CAN_STM32_MAX_FILTER_ID) {
 8007d7a: 6bfb         	ldr	r3, [r7, #0x3c]
 8007d7c: 2b22         	cmp	r3, #0x22
 8007d7e: dc0f         	bgt	0x8007da0 <can_stm32_rx_isr_handler+0xd8> @ imm = #0x1e
; 			index = filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER;
 8007d80: 6bfb         	ldr	r3, [r7, #0x3c]
 8007d82: 3b07         	subs	r3, #0x7
 8007d84: 61bb         	str	r3, [r7, #0x18]
; 			callback = data->rx_cb_std[index];
 8007d86: 6bba         	ldr	r2, [r7, #0x38]
 8007d88: 69bb         	ldr	r3, [r7, #0x18]
 8007d8a: 3312         	adds	r3, #0x12
 8007d8c: 009b         	lsls	r3, r3, #0x2
 8007d8e: 4413         	add	r3, r2
 8007d90: 685b         	ldr	r3, [r3, #0x4]
 8007d92: 647b         	str	r3, [r7, #0x44]
; 			cb_arg = data->cb_arg_std[index];
 8007d94: 6bbb         	ldr	r3, [r7, #0x38]
 8007d96: 69ba         	ldr	r2, [r7, #0x18]
 8007d98: 3228         	adds	r2, #0x28
 8007d9a: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8007d9e: 643b         	str	r3, [r7, #0x40]
; 		if (callback) {
 8007da0: 6c7b         	ldr	r3, [r7, #0x44]
 8007da2: 2b00         	cmp	r3, #0x0
 8007da4: d005         	beq	0x8007db2 <can_stm32_rx_isr_handler+0xea> @ imm = #0xa
; 			callback(dev, &frame, cb_arg);
 8007da6: f107 0108    	add.w	r1, r7, #0x8
 8007daa: 6c7b         	ldr	r3, [r7, #0x44]
 8007dac: 6c3a         	ldr	r2, [r7, #0x40]
 8007dae: 6878         	ldr	r0, [r7, #0x4]
 8007db0: 4798         	blx	r3
; 		can->RF0R |= CAN_RF0R_RFOM0;
 8007db2: 6b3b         	ldr	r3, [r7, #0x30]
 8007db4: 68db         	ldr	r3, [r3, #0xc]
 8007db6: f043 0220    	orr	r2, r3, #0x20
 8007dba: 6b3b         	ldr	r3, [r7, #0x30]
 8007dbc: 60da         	str	r2, [r3, #0xc]
; 	while (can->RF0R & CAN_RF0R_FMP0) {
 8007dbe: 6b3b         	ldr	r3, [r7, #0x30]
 8007dc0: 68db         	ldr	r3, [r3, #0xc]
 8007dc2: f003 0303    	and	r3, r3, #0x3
 8007dc6: 2b00         	cmp	r3, #0x0
 8007dc8: d18e         	bne	0x8007ce8 <can_stm32_rx_isr_handler+0x20> @ imm = #-0xe4
; 	if (can->RF0R & CAN_RF0R_FOVR0) {
 8007dca: 6b3b         	ldr	r3, [r7, #0x30]
 8007dcc: 68db         	ldr	r3, [r3, #0xc]
 8007dce: f003 0310    	and	r3, r3, #0x10
 8007dd2: 2b00         	cmp	r3, #0x0
 8007dd4: d01c         	beq	0x8007e10 <can_stm32_rx_isr_handler+0x148> @ imm = #0x38
; 		LOG_ERR("RX FIFO Overflow");
 8007dd6: 2303         	movs	r3, #0x3
 8007dd8: 2b00         	cmp	r3, #0x0
 8007dda: d019         	beq	0x8007e10 <can_stm32_rx_isr_handler+0x148> @ imm = #0x32
 8007ddc: 2301         	movs	r3, #0x1
 8007dde: f887 302f    	strb.w	r3, [r7, #0x2f]
 8007de2: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8007de6: f083 0301    	eor	r3, r3, #0x1
 8007dea: b2db         	uxtb	r3, r3
 8007dec: 2b00         	cmp	r3, #0x0
 8007dee: d10f         	bne	0x8007e10 <can_stm32_rx_isr_handler+0x148> @ imm = #0x1e
 8007df0: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8007e18 <can_stm32_rx_isr_handler+0x150>
 8007df2: 6819         	ldr	r1, [r3]
 8007df4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8007e24 <can_stm32_rx_isr_handler+0x15c>
 8007df6: 9302         	str	r3, [sp, #0x8]
 8007df8: 2300         	movs	r3, #0x0
 8007dfa: 9301         	str	r3, [sp, #0x4]
 8007dfc: 2300         	movs	r3, #0x0
 8007dfe: 9300         	str	r3, [sp]
 8007e00: 2300         	movs	r3, #0x0
 8007e02: 2201         	movs	r2, #0x1
 8007e04: 2000         	movs	r0, #0x0
 8007e06: f015 fb45    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x1568a
 8007e0a: 2300         	movs	r3, #0x0
 8007e0c: 62bb         	str	r3, [r7, #0x28]
; }
 8007e0e: e7ff         	b	0x8007e10 <can_stm32_rx_isr_handler+0x148> @ imm = #-0x2
 8007e10: bf00         	nop
 8007e12: 3748         	adds	r7, #0x48
 8007e14: 46bd         	mov	sp, r7
 8007e16: bd80         	pop	{r7, pc}

08007e18 <$d>:
 8007e18: 34 05 00 20  	.word	0x20000534
 8007e1c: e0 a8 02 08  	.word	0x0802a8e0
 8007e20: e8 8b 02 08  	.word	0x08028be8
 8007e24: 04 8c 02 08  	.word	0x08028c04

08007e28 <can_stm32_enter_init_mode>:
; {
 8007e28: b580         	push	{r7, lr}
 8007e2a: b084         	sub	sp, #0x10
 8007e2c: af00         	add	r7, sp, #0x0
 8007e2e: 6078         	str	r0, [r7, #0x4]
; 	can->MCR |= CAN_MCR_INRQ;
 8007e30: 687b         	ldr	r3, [r7, #0x4]
 8007e32: 681b         	ldr	r3, [r3]
 8007e34: f043 0201    	orr	r2, r3, #0x1
 8007e38: 687b         	ldr	r3, [r7, #0x4]
 8007e3a: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 8007e3c: f015 fa34    	bl	0x801d2a8 <k_cycle_get_32> @ imm = #0x15468
 8007e40: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_INAK) == 0U) {
 8007e42: e010         	b	0x8007e66 <can_stm32_enter_init_mode+0x3e> @ imm = #0x20
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 8007e44: f015 fa30    	bl	0x801d2a8 <k_cycle_get_32> @ imm = #0x15460
 8007e48: 4602         	mov	r2, r0
 8007e4a: 68fb         	ldr	r3, [r7, #0xc]
 8007e4c: 1ad3         	subs	r3, r2, r3
 8007e4e: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8007e7c <can_stm32_enter_init_mode+0x54>
 8007e50: 4293         	cmp	r3, r2
 8007e52: d908         	bls	0x8007e66 <can_stm32_enter_init_mode+0x3e> @ imm = #0x10
; 			can->MCR &= ~CAN_MCR_INRQ;
 8007e54: 687b         	ldr	r3, [r7, #0x4]
 8007e56: 681b         	ldr	r3, [r3]
 8007e58: f023 0201    	bic	r2, r3, #0x1
 8007e5c: 687b         	ldr	r3, [r7, #0x4]
 8007e5e: 601a         	str	r2, [r3]
; 			return -EAGAIN;
 8007e60: f06f 030a    	mvn	r3, #0xa
 8007e64: e006         	b	0x8007e74 <can_stm32_enter_init_mode+0x4c> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_INAK) == 0U) {
 8007e66: 687b         	ldr	r3, [r7, #0x4]
 8007e68: 685b         	ldr	r3, [r3, #0x4]
 8007e6a: f003 0301    	and	r3, r3, #0x1
 8007e6e: 2b00         	cmp	r3, #0x0
 8007e70: d0e8         	beq	0x8007e44 <can_stm32_enter_init_mode+0x1c> @ imm = #-0x30
; 	return 0;
 8007e72: 2300         	movs	r3, #0x0
; }
 8007e74: 4618         	mov	r0, r3
 8007e76: 3710         	adds	r7, #0x10
 8007e78: 46bd         	mov	sp, r7
 8007e7a: bd80         	pop	{r7, pc}

08007e7c <$d>:
 8007e7c: 80 a2 19 00  	.word	0x0019a280

08007e80 <can_stm32_leave_init_mode>:
; {
 8007e80: b580         	push	{r7, lr}
 8007e82: b084         	sub	sp, #0x10
 8007e84: af00         	add	r7, sp, #0x0
 8007e86: 6078         	str	r0, [r7, #0x4]
; 	can->MCR &= ~CAN_MCR_INRQ;
 8007e88: 687b         	ldr	r3, [r7, #0x4]
 8007e8a: 681b         	ldr	r3, [r3]
 8007e8c: f023 0201    	bic	r2, r3, #0x1
 8007e90: 687b         	ldr	r3, [r7, #0x4]
 8007e92: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 8007e94: f015 fa08    	bl	0x801d2a8 <k_cycle_get_32> @ imm = #0x15410
 8007e98: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_INAK) != 0U) {
 8007e9a: e00a         	b	0x8007eb2 <can_stm32_leave_init_mode+0x32> @ imm = #0x14
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 8007e9c: f015 fa04    	bl	0x801d2a8 <k_cycle_get_32> @ imm = #0x15408
 8007ea0: 4602         	mov	r2, r0
 8007ea2: 68fb         	ldr	r3, [r7, #0xc]
 8007ea4: 1ad3         	subs	r3, r2, r3
 8007ea6: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007ec8 <can_stm32_leave_init_mode+0x48>
 8007ea8: 4293         	cmp	r3, r2
 8007eaa: d902         	bls	0x8007eb2 <can_stm32_leave_init_mode+0x32> @ imm = #0x4
; 			return -EAGAIN;
 8007eac: f06f 030a    	mvn	r3, #0xa
 8007eb0: e006         	b	0x8007ec0 <can_stm32_leave_init_mode+0x40> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_INAK) != 0U) {
 8007eb2: 687b         	ldr	r3, [r7, #0x4]
 8007eb4: 685b         	ldr	r3, [r3, #0x4]
 8007eb6: f003 0301    	and	r3, r3, #0x1
 8007eba: 2b00         	cmp	r3, #0x0
 8007ebc: d1ee         	bne	0x8007e9c <can_stm32_leave_init_mode+0x1c> @ imm = #-0x24
; 	return 0;
 8007ebe: 2300         	movs	r3, #0x0
; }
 8007ec0: 4618         	mov	r0, r3
 8007ec2: 3710         	adds	r7, #0x10
 8007ec4: 46bd         	mov	sp, r7
 8007ec6: bd80         	pop	{r7, pc}

08007ec8 <$d>:
 8007ec8: 80 a2 19 00  	.word	0x0019a280

08007ecc <can_stm32_leave_sleep_mode>:
; {
 8007ecc: b580         	push	{r7, lr}
 8007ece: b084         	sub	sp, #0x10
 8007ed0: af00         	add	r7, sp, #0x0
 8007ed2: 6078         	str	r0, [r7, #0x4]
; 	can->MCR &= ~CAN_MCR_SLEEP;
 8007ed4: 687b         	ldr	r3, [r7, #0x4]
 8007ed6: 681b         	ldr	r3, [r3]
 8007ed8: f023 0202    	bic	r2, r3, #0x2
 8007edc: 687b         	ldr	r3, [r7, #0x4]
 8007ede: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 8007ee0: f015 f9e2    	bl	0x801d2a8 <k_cycle_get_32> @ imm = #0x153c4
 8007ee4: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_SLAK) != 0) {
 8007ee6: e00a         	b	0x8007efe <can_stm32_leave_sleep_mode+0x32> @ imm = #0x14
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 8007ee8: f015 f9de    	bl	0x801d2a8 <k_cycle_get_32> @ imm = #0x153bc
 8007eec: 4602         	mov	r2, r0
 8007eee: 68fb         	ldr	r3, [r7, #0xc]
 8007ef0: 1ad3         	subs	r3, r2, r3
 8007ef2: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007f14 <can_stm32_leave_sleep_mode+0x48>
 8007ef4: 4293         	cmp	r3, r2
 8007ef6: d902         	bls	0x8007efe <can_stm32_leave_sleep_mode+0x32> @ imm = #0x4
; 			return -EAGAIN;
 8007ef8: f06f 030a    	mvn	r3, #0xa
 8007efc: e006         	b	0x8007f0c <can_stm32_leave_sleep_mode+0x40> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_SLAK) != 0) {
 8007efe: 687b         	ldr	r3, [r7, #0x4]
 8007f00: 685b         	ldr	r3, [r3, #0x4]
 8007f02: f003 0302    	and	r3, r3, #0x2
 8007f06: 2b00         	cmp	r3, #0x0
 8007f08: d1ee         	bne	0x8007ee8 <can_stm32_leave_sleep_mode+0x1c> @ imm = #-0x24
; 	return 0;
 8007f0a: 2300         	movs	r3, #0x0
; }
 8007f0c: 4618         	mov	r0, r3
 8007f0e: 3710         	adds	r7, #0x10
 8007f10: 46bd         	mov	sp, r7
 8007f12: bd80         	pop	{r7, pc}

08007f14 <$d>:
 8007f14: 80 a2 19 00  	.word	0x0019a280

08007f18 <can_stm32_start>:
; {
 8007f18: b580         	push	{r7, lr}
 8007f1a: b08e         	sub	sp, #0x38
 8007f1c: af04         	add	r7, sp, #0x10
 8007f1e: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8007f20: 687b         	ldr	r3, [r7, #0x4]
 8007f22: 685b         	ldr	r3, [r3, #0x4]
 8007f24: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 8007f26: 687b         	ldr	r3, [r7, #0x4]
 8007f28: 691b         	ldr	r3, [r3, #0x10]
 8007f2a: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->can;
 8007f2c: 6a3b         	ldr	r3, [r7, #0x20]
 8007f2e: 695b         	ldr	r3, [r3, #0x14]
 8007f30: 61bb         	str	r3, [r7, #0x18]
; 	int ret = 0;
 8007f32: 2300         	movs	r3, #0x0
 8007f34: 627b         	str	r3, [r7, #0x24]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8007f36: 69fb         	ldr	r3, [r7, #0x1c]
 8007f38: f103 0110    	add.w	r1, r3, #0x10
 8007f3c: f04f 32ff    	mov.w	r2, #0xffffffff
 8007f40: f04f 33ff    	mov.w	r3, #0xffffffff
 8007f44: 4608         	mov	r0, r1
 8007f46: f015 f9c2    	bl	0x801d2ce <k_mutex_lock> @ imm = #0x15384
; 	if (data->common.started) {
 8007f4a: 69fb         	ldr	r3, [r7, #0x1c]
 8007f4c: 791b         	ldrb	r3, [r3, #0x4]
 8007f4e: 2b00         	cmp	r3, #0x0
 8007f50: d003         	beq	0x8007f5a <can_stm32_start+0x42> @ imm = #0x6
; 		ret = -EALREADY;
 8007f52: f06f 0377    	mvn	r3, #0x77
 8007f56: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 8007f58: e05e         	b	0x8008018 <can_stm32_start+0x100> @ imm = #0xbc
; 	if (cfg->common.phy != NULL) {
 8007f5a: 6a3b         	ldr	r3, [r7, #0x20]
 8007f5c: 681b         	ldr	r3, [r3]
 8007f5e: 2b00         	cmp	r3, #0x0
 8007f60: d029         	beq	0x8007fb6 <can_stm32_start+0x9e> @ imm = #0x52
; 		ret = can_transceiver_enable(cfg->common.phy, data->common.mode);
 8007f62: 6a3b         	ldr	r3, [r7, #0x20]
 8007f64: 681a         	ldr	r2, [r3]
 8007f66: 69fb         	ldr	r3, [r7, #0x1c]
 8007f68: 681b         	ldr	r3, [r3]
 8007f6a: 4619         	mov	r1, r3
 8007f6c: 4610         	mov	r0, r2
 8007f6e: f015 fa15    	bl	0x801d39c <can_transceiver_enable> @ imm = #0x1542a
 8007f72: 6278         	str	r0, [r7, #0x24]
; 		if (ret != 0) {
 8007f74: 6a7b         	ldr	r3, [r7, #0x24]
 8007f76: 2b00         	cmp	r3, #0x0
 8007f78: d01d         	beq	0x8007fb6 <can_stm32_start+0x9e> @ imm = #0x3a
; 			LOG_ERR("failed to enable CAN transceiver (err %d)", ret);
 8007f7a: 2303         	movs	r3, #0x3
 8007f7c: 2b00         	cmp	r3, #0x0
 8007f7e: d019         	beq	0x8007fb4 <can_stm32_start+0x9c> @ imm = #0x32
 8007f80: 2301         	movs	r3, #0x1
 8007f82: 75fb         	strb	r3, [r7, #0x17]
 8007f84: 7dfb         	ldrb	r3, [r7, #0x17]
 8007f86: f083 0301    	eor	r3, r3, #0x1
 8007f8a: b2db         	uxtb	r3, r3
 8007f8c: 2b00         	cmp	r3, #0x0
 8007f8e: d111         	bne	0x8007fb4 <can_stm32_start+0x9c> @ imm = #0x22
 8007f90: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8008030 <can_stm32_start+0x118>
 8007f92: 6819         	ldr	r1, [r3]
 8007f94: 6a7b         	ldr	r3, [r7, #0x24]
 8007f96: 9303         	str	r3, [sp, #0xc]
 8007f98: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8008034 <can_stm32_start+0x11c>
 8007f9a: 9302         	str	r3, [sp, #0x8]
 8007f9c: 2300         	movs	r3, #0x0
 8007f9e: 9301         	str	r3, [sp, #0x4]
 8007fa0: 2300         	movs	r3, #0x0
 8007fa2: 9300         	str	r3, [sp]
 8007fa4: 2300         	movs	r3, #0x0
 8007fa6: 2201         	movs	r2, #0x1
 8007fa8: 2000         	movs	r0, #0x0
 8007faa: f015 fa73    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x154e6
 8007fae: 2300         	movs	r3, #0x0
 8007fb0: 613b         	str	r3, [r7, #0x10]
; 			goto unlock;
 8007fb2: e031         	b	0x8008018 <can_stm32_start+0x100> @ imm = #0x62
 8007fb4: e030         	b	0x8008018 <can_stm32_start+0x100> @ imm = #0x60
; 	ret = can_stm32_leave_init_mode(can);
 8007fb6: 69b8         	ldr	r0, [r7, #0x18]
 8007fb8: f7ff ff62    	bl	0x8007e80 <can_stm32_leave_init_mode> @ imm = #-0x13c
 8007fbc: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 8007fbe: 6a7b         	ldr	r3, [r7, #0x24]
 8007fc0: 2b00         	cmp	r3, #0x0
 8007fc2: da26         	bge	0x8008012 <can_stm32_start+0xfa> @ imm = #0x4c
; 		LOG_ERR("Failed to leave init mode");
 8007fc4: 2303         	movs	r3, #0x3
 8007fc6: 2b00         	cmp	r3, #0x0
 8007fc8: d016         	beq	0x8007ff8 <can_stm32_start+0xe0> @ imm = #0x2c
 8007fca: 2301         	movs	r3, #0x1
 8007fcc: 73fb         	strb	r3, [r7, #0xf]
 8007fce: 7bfb         	ldrb	r3, [r7, #0xf]
 8007fd0: f083 0301    	eor	r3, r3, #0x1
 8007fd4: b2db         	uxtb	r3, r3
 8007fd6: 2b00         	cmp	r3, #0x0
 8007fd8: d10e         	bne	0x8007ff8 <can_stm32_start+0xe0> @ imm = #0x1c
 8007fda: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8008030 <can_stm32_start+0x118>
 8007fdc: 6819         	ldr	r1, [r3]
 8007fde: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8008038 <can_stm32_start+0x120>
 8007fe0: 9302         	str	r3, [sp, #0x8]
 8007fe2: 2300         	movs	r3, #0x0
 8007fe4: 9301         	str	r3, [sp, #0x4]
 8007fe6: 2300         	movs	r3, #0x0
 8007fe8: 9300         	str	r3, [sp]
 8007fea: 2300         	movs	r3, #0x0
 8007fec: 2201         	movs	r2, #0x1
 8007fee: 2000         	movs	r0, #0x0
 8007ff0: f015 fa50    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x154a0
 8007ff4: 2300         	movs	r3, #0x0
 8007ff6: 60bb         	str	r3, [r7, #0x8]
; 		if (cfg->common.phy != NULL) {
 8007ff8: 6a3b         	ldr	r3, [r7, #0x20]
 8007ffa: 681b         	ldr	r3, [r3]
 8007ffc: 2b00         	cmp	r3, #0x0
 8007ffe: d004         	beq	0x800800a <can_stm32_start+0xf2> @ imm = #0x8
; 			(void)can_transceiver_disable(cfg->common.phy);
 8008000: 6a3b         	ldr	r3, [r7, #0x20]
 8008002: 681b         	ldr	r3, [r3]
 8008004: 4618         	mov	r0, r3
 8008006: f015 f9d9    	bl	0x801d3bc <can_transceiver_disable> @ imm = #0x153b2
; 		ret = -EIO;
 800800a: f06f 0304    	mvn	r3, #0x4
 800800e: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 8008010: e002         	b	0x8008018 <can_stm32_start+0x100> @ imm = #0x4
; 	data->common.started = true;
 8008012: 69fb         	ldr	r3, [r7, #0x1c]
 8008014: 2201         	movs	r2, #0x1
 8008016: 711a         	strb	r2, [r3, #0x4]
; 	k_mutex_unlock(&data->inst_mutex);
 8008018: 69fb         	ldr	r3, [r7, #0x1c]
 800801a: 3310         	adds	r3, #0x10
 800801c: 4618         	mov	r0, r3
 800801e: f015 f966    	bl	0x801d2ee <k_mutex_unlock> @ imm = #0x152cc
; 	return ret;
 8008022: 6a79         	ldr	r1, [r7, #0x24]
 8008024: 460b         	mov	r3, r1
; }
 8008026: 4618         	mov	r0, r3
 8008028: 3728         	adds	r7, #0x28
 800802a: 46bd         	mov	sp, r7
 800802c: bd80         	pop	{r7, pc}
 800802e: bf00         	nop

08008030 <$d>:
 8008030: 34 05 00 20  	.word	0x20000534
 8008034: 18 8c 02 08  	.word	0x08028c18
 8008038: 44 8c 02 08  	.word	0x08028c44

0800803c <can_stm32_stop>:
; {
 800803c: b580         	push	{r7, lr}
 800803e: b08e         	sub	sp, #0x38
 8008040: af04         	add	r7, sp, #0x10
 8008042: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8008044: 687b         	ldr	r3, [r7, #0x4]
 8008046: 685b         	ldr	r3, [r3, #0x4]
 8008048: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 800804a: 687b         	ldr	r3, [r7, #0x4]
 800804c: 691b         	ldr	r3, [r3, #0x10]
 800804e: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->can;
 8008050: 6a3b         	ldr	r3, [r7, #0x20]
 8008052: 695b         	ldr	r3, [r3, #0x14]
 8008054: 61bb         	str	r3, [r7, #0x18]
; 	int ret = 0;
 8008056: 2300         	movs	r3, #0x0
 8008058: 627b         	str	r3, [r7, #0x24]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 800805a: 69fb         	ldr	r3, [r7, #0x1c]
 800805c: f103 0110    	add.w	r1, r3, #0x10
 8008060: f04f 32ff    	mov.w	r2, #0xffffffff
 8008064: f04f 33ff    	mov.w	r3, #0xffffffff
 8008068: 4608         	mov	r0, r1
 800806a: f015 f930    	bl	0x801d2ce <k_mutex_lock> @ imm = #0x15260
; 	if (!data->common.started) {
 800806e: 69fb         	ldr	r3, [r7, #0x1c]
 8008070: 791b         	ldrb	r3, [r3, #0x4]
 8008072: f083 0301    	eor	r3, r3, #0x1
 8008076: b2db         	uxtb	r3, r3
 8008078: 2b00         	cmp	r3, #0x0
 800807a: d003         	beq	0x8008084 <can_stm32_stop+0x48> @ imm = #0x6
; 		ret = -EALREADY;
 800807c: f06f 0377    	mvn	r3, #0x77
 8008080: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 8008082: e072         	b	0x800816a <can_stm32_stop+0x12e> @ imm = #0xe4
; 	ret = can_stm32_enter_init_mode(can);
 8008084: 69b8         	ldr	r0, [r7, #0x18]
 8008086: f7ff fecf    	bl	0x8007e28 <can_stm32_enter_init_mode> @ imm = #-0x262
 800808a: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 800808c: 6a7b         	ldr	r3, [r7, #0x24]
 800808e: 2b00         	cmp	r3, #0x0
 8008090: da1d         	bge	0x80080ce <can_stm32_stop+0x92> @ imm = #0x3a
; 		LOG_ERR("Failed to enter init mode");
 8008092: 2303         	movs	r3, #0x3
 8008094: 2b00         	cmp	r3, #0x0
 8008096: d016         	beq	0x80080c6 <can_stm32_stop+0x8a> @ imm = #0x2c
 8008098: 2301         	movs	r3, #0x1
 800809a: 73fb         	strb	r3, [r7, #0xf]
 800809c: 7bfb         	ldrb	r3, [r7, #0xf]
 800809e: f083 0301    	eor	r3, r3, #0x1
 80080a2: b2db         	uxtb	r3, r3
 80080a4: 2b00         	cmp	r3, #0x0
 80080a6: d10e         	bne	0x80080c6 <can_stm32_stop+0x8a> @ imm = #0x1c
 80080a8: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8008180 <can_stm32_stop+0x144>
 80080aa: 6819         	ldr	r1, [r3]
 80080ac: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8008184 <can_stm32_stop+0x148>
 80080ae: 9302         	str	r3, [sp, #0x8]
 80080b0: 2300         	movs	r3, #0x0
 80080b2: 9301         	str	r3, [sp, #0x4]
 80080b4: 2300         	movs	r3, #0x0
 80080b6: 9300         	str	r3, [sp]
 80080b8: 2300         	movs	r3, #0x0
 80080ba: 2201         	movs	r2, #0x1
 80080bc: 2000         	movs	r0, #0x0
 80080be: f015 f9e9    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x153d2
 80080c2: 2300         	movs	r3, #0x0
 80080c4: 60bb         	str	r3, [r7, #0x8]
; 		ret = -EIO;
 80080c6: f06f 0304    	mvn	r3, #0x4
 80080ca: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 80080cc: e04d         	b	0x800816a <can_stm32_stop+0x12e> @ imm = #0x9a
; 	can_stm32_signal_tx_complete(dev, &data->mb0, -ENETDOWN);
 80080ce: 69fb         	ldr	r3, [r7, #0x1c]
 80080d0: 3334         	adds	r3, #0x34
 80080d2: f06f 0272    	mvn	r2, #0x72
 80080d6: 4619         	mov	r1, r3
 80080d8: 6878         	ldr	r0, [r7, #0x4]
 80080da: f015 f9f9    	bl	0x801d4d0 <can_stm32_signal_tx_complete> @ imm = #0x153f2
; 	can_stm32_signal_tx_complete(dev, &data->mb1, -ENETDOWN);
 80080de: 69fb         	ldr	r3, [r7, #0x1c]
 80080e0: 333c         	adds	r3, #0x3c
 80080e2: f06f 0272    	mvn	r2, #0x72
 80080e6: 4619         	mov	r1, r3
 80080e8: 6878         	ldr	r0, [r7, #0x4]
 80080ea: f015 f9f1    	bl	0x801d4d0 <can_stm32_signal_tx_complete> @ imm = #0x153e2
; 	can_stm32_signal_tx_complete(dev, &data->mb2, -ENETDOWN);
 80080ee: 69fb         	ldr	r3, [r7, #0x1c]
 80080f0: 3344         	adds	r3, #0x44
 80080f2: f06f 0272    	mvn	r2, #0x72
 80080f6: 4619         	mov	r1, r3
 80080f8: 6878         	ldr	r0, [r7, #0x4]
 80080fa: f015 f9e9    	bl	0x801d4d0 <can_stm32_signal_tx_complete> @ imm = #0x153d2
; 	can->TSR |= CAN_TSR_ABRQ2 | CAN_TSR_ABRQ1 | CAN_TSR_ABRQ0;
 80080fe: 69bb         	ldr	r3, [r7, #0x18]
 8008100: 689b         	ldr	r3, [r3, #0x8]
 8008102: f043 1380    	orr	r3, r3, #0x800080
 8008106: f443 4300    	orr	r3, r3, #0x8000
 800810a: 69ba         	ldr	r2, [r7, #0x18]
 800810c: 6093         	str	r3, [r2, #0x8]
; 	if (cfg->common.phy != NULL) {
 800810e: 6a3b         	ldr	r3, [r7, #0x20]
 8008110: 681b         	ldr	r3, [r3]
 8008112: 2b00         	cmp	r3, #0x0
 8008114: d026         	beq	0x8008164 <can_stm32_stop+0x128> @ imm = #0x4c
; 		ret = can_transceiver_disable(cfg->common.phy);
 8008116: 6a3b         	ldr	r3, [r7, #0x20]
 8008118: 681b         	ldr	r3, [r3]
 800811a: 4618         	mov	r0, r3
 800811c: f015 f94e    	bl	0x801d3bc <can_transceiver_disable> @ imm = #0x1529c
 8008120: 6278         	str	r0, [r7, #0x24]
; 		if (ret != 0) {
 8008122: 6a7b         	ldr	r3, [r7, #0x24]
 8008124: 2b00         	cmp	r3, #0x0
 8008126: d01d         	beq	0x8008164 <can_stm32_stop+0x128> @ imm = #0x3a
; 			LOG_ERR("failed to enable CAN transceiver (err %d)", ret);
 8008128: 2303         	movs	r3, #0x3
 800812a: 2b00         	cmp	r3, #0x0
 800812c: d019         	beq	0x8008162 <can_stm32_stop+0x126> @ imm = #0x32
 800812e: 2301         	movs	r3, #0x1
 8008130: 75fb         	strb	r3, [r7, #0x17]
 8008132: 7dfb         	ldrb	r3, [r7, #0x17]
 8008134: f083 0301    	eor	r3, r3, #0x1
 8008138: b2db         	uxtb	r3, r3
 800813a: 2b00         	cmp	r3, #0x0
 800813c: d111         	bne	0x8008162 <can_stm32_stop+0x126> @ imm = #0x22
 800813e: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8008180 <can_stm32_stop+0x144>
 8008140: 6819         	ldr	r1, [r3]
 8008142: 6a7b         	ldr	r3, [r7, #0x24]
 8008144: 9303         	str	r3, [sp, #0xc]
 8008146: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8008188 <can_stm32_stop+0x14c>
 8008148: 9302         	str	r3, [sp, #0x8]
 800814a: 2300         	movs	r3, #0x0
 800814c: 9301         	str	r3, [sp, #0x4]
 800814e: 2300         	movs	r3, #0x0
 8008150: 9300         	str	r3, [sp]
 8008152: 2300         	movs	r3, #0x0
 8008154: 2201         	movs	r2, #0x1
 8008156: 2000         	movs	r0, #0x0
 8008158: f015 f99c    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x15338
 800815c: 2300         	movs	r3, #0x0
 800815e: 613b         	str	r3, [r7, #0x10]
; 			goto unlock;
 8008160: e003         	b	0x800816a <can_stm32_stop+0x12e> @ imm = #0x6
 8008162: e002         	b	0x800816a <can_stm32_stop+0x12e> @ imm = #0x4
; 	data->common.started = false;
 8008164: 69fb         	ldr	r3, [r7, #0x1c]
 8008166: 2200         	movs	r2, #0x0
 8008168: 711a         	strb	r2, [r3, #0x4]
; 	k_mutex_unlock(&data->inst_mutex);
 800816a: 69fb         	ldr	r3, [r7, #0x1c]
 800816c: 3310         	adds	r3, #0x10
 800816e: 4618         	mov	r0, r3
 8008170: f015 f8bd    	bl	0x801d2ee <k_mutex_unlock> @ imm = #0x1517a
; 	return ret;
 8008174: 6a79         	ldr	r1, [r7, #0x24]
 8008176: 460b         	mov	r3, r1
; }
 8008178: 4618         	mov	r0, r3
 800817a: 3728         	adds	r7, #0x28
 800817c: 46bd         	mov	sp, r7
 800817e: bd80         	pop	{r7, pc}

08008180 <$d>:
 8008180: 34 05 00 20  	.word	0x20000534
 8008184: 60 8c 02 08  	.word	0x08028c60
 8008188: 18 8c 02 08  	.word	0x08028c18

0800818c <can_stm32_set_mode>:
; {
 800818c: b580         	push	{r7, lr}
 800818e: b090         	sub	sp, #0x40
 8008190: af06         	add	r7, sp, #0x18
 8008192: 6078         	str	r0, [r7, #0x4]
 8008194: 6039         	str	r1, [r7]
; 	can_mode_t supported = CAN_MODE_LOOPBACK | CAN_MODE_LISTENONLY | CAN_MODE_ONE_SHOT;
 8008196: 230b         	movs	r3, #0xb
 8008198: 627b         	str	r3, [r7, #0x24]
; 	const struct can_stm32_config *cfg = dev->config;
 800819a: 687b         	ldr	r3, [r7, #0x4]
 800819c: 685b         	ldr	r3, [r3, #0x4]
 800819e: 623b         	str	r3, [r7, #0x20]
; 	CAN_TypeDef *can = cfg->can;
 80081a0: 6a3b         	ldr	r3, [r7, #0x20]
 80081a2: 695b         	ldr	r3, [r3, #0x14]
 80081a4: 61fb         	str	r3, [r7, #0x1c]
; 	struct can_stm32_data *data = dev->data;
 80081a6: 687b         	ldr	r3, [r7, #0x4]
 80081a8: 691b         	ldr	r3, [r3, #0x10]
 80081aa: 61bb         	str	r3, [r7, #0x18]
; 	LOG_DBG("Set mode %d", mode);
 80081ac: 2303         	movs	r3, #0x3
 80081ae: 2b03         	cmp	r3, #0x3
 80081b0: d91a         	bls	0x80081e8 <can_stm32_set_mode+0x5c> @ imm = #0x34
 80081b2: 2301         	movs	r3, #0x1
 80081b4: 75fb         	strb	r3, [r7, #0x17]
 80081b6: 7dfb         	ldrb	r3, [r7, #0x17]
 80081b8: f083 0301    	eor	r3, r3, #0x1
 80081bc: b2db         	uxtb	r3, r3
 80081be: 2b00         	cmp	r3, #0x0
 80081c0: d112         	bne	0x80081e8 <can_stm32_set_mode+0x5c> @ imm = #0x24
 80081c2: 4b46         	ldr	r3, [pc, #0x118]        @ 0x80082dc <can_stm32_set_mode+0x150>
 80081c4: 6819         	ldr	r1, [r3]
 80081c6: 683b         	ldr	r3, [r7]
 80081c8: 9304         	str	r3, [sp, #0x10]
 80081ca: 4b45         	ldr	r3, [pc, #0x114]        @ 0x80082e0 <can_stm32_set_mode+0x154>
 80081cc: 9303         	str	r3, [sp, #0xc]
 80081ce: 4b45         	ldr	r3, [pc, #0x114]        @ 0x80082e4 <can_stm32_set_mode+0x158>
 80081d0: 9302         	str	r3, [sp, #0x8]
 80081d2: 2308         	movs	r3, #0x8
 80081d4: 9301         	str	r3, [sp, #0x4]
 80081d6: 2300         	movs	r3, #0x0
 80081d8: 9300         	str	r3, [sp]
 80081da: 2300         	movs	r3, #0x0
 80081dc: 2204         	movs	r2, #0x4
 80081de: 2000         	movs	r0, #0x0
 80081e0: f015 f958    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x152b0
 80081e4: 2300         	movs	r3, #0x0
 80081e6: 613b         	str	r3, [r7, #0x10]
; 	if ((mode & ~(supported)) != 0) {
 80081e8: 6a7b         	ldr	r3, [r7, #0x24]
 80081ea: 43da         	mvns	r2, r3
 80081ec: 683b         	ldr	r3, [r7]
 80081ee: 4013         	ands	r3, r2
 80081f0: 2b00         	cmp	r3, #0x0
 80081f2: d01e         	beq	0x8008232 <can_stm32_set_mode+0xa6> @ imm = #0x3c
; 		LOG_ERR("unsupported mode: 0x%08x", mode);
 80081f4: 2303         	movs	r3, #0x3
 80081f6: 2b00         	cmp	r3, #0x0
 80081f8: d018         	beq	0x800822c <can_stm32_set_mode+0xa0> @ imm = #0x30
 80081fa: 2301         	movs	r3, #0x1
 80081fc: 73fb         	strb	r3, [r7, #0xf]
 80081fe: 7bfb         	ldrb	r3, [r7, #0xf]
 8008200: f083 0301    	eor	r3, r3, #0x1
 8008204: b2db         	uxtb	r3, r3
 8008206: 2b00         	cmp	r3, #0x0
 8008208: d110         	bne	0x800822c <can_stm32_set_mode+0xa0> @ imm = #0x20
 800820a: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x80082dc <can_stm32_set_mode+0x150>
 800820c: 6819         	ldr	r1, [r3]
 800820e: 683b         	ldr	r3, [r7]
 8008210: 9303         	str	r3, [sp, #0xc]
 8008212: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80082e8 <can_stm32_set_mode+0x15c>
 8008214: 9302         	str	r3, [sp, #0x8]
 8008216: 2300         	movs	r3, #0x0
 8008218: 9301         	str	r3, [sp, #0x4]
 800821a: 2300         	movs	r3, #0x0
 800821c: 9300         	str	r3, [sp]
 800821e: 2300         	movs	r3, #0x0
 8008220: 2201         	movs	r2, #0x1
 8008222: 2000         	movs	r0, #0x0
 8008224: f015 f936    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x1526c
 8008228: 2300         	movs	r3, #0x0
 800822a: 60bb         	str	r3, [r7, #0x8]
; 		return -ENOTSUP;
 800822c: f06f 0185    	mvn	r1, #0x85
 8008230: e04f         	b	0x80082d2 <can_stm32_set_mode+0x146> @ imm = #0x9e
; 	if (data->common.started) {
 8008232: 69bb         	ldr	r3, [r7, #0x18]
 8008234: 791b         	ldrb	r3, [r3, #0x4]
 8008236: 2b00         	cmp	r3, #0x0
 8008238: d002         	beq	0x8008240 <can_stm32_set_mode+0xb4> @ imm = #0x4
; 		return -EBUSY;
 800823a: f06f 010f    	mvn	r1, #0xf
 800823e: e048         	b	0x80082d2 <can_stm32_set_mode+0x146> @ imm = #0x90
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8008240: 69bb         	ldr	r3, [r7, #0x18]
 8008242: f103 0110    	add.w	r1, r3, #0x10
 8008246: f04f 32ff    	mov.w	r2, #0xffffffff
 800824a: f04f 33ff    	mov.w	r3, #0xffffffff
 800824e: 4608         	mov	r0, r1
 8008250: f015 f83d    	bl	0x801d2ce <k_mutex_lock> @ imm = #0x1507a
; 	if ((mode & CAN_MODE_LOOPBACK) != 0) {
 8008254: 683b         	ldr	r3, [r7]
 8008256: f003 0301    	and	r3, r3, #0x1
 800825a: 2b00         	cmp	r3, #0x0
 800825c: d006         	beq	0x800826c <can_stm32_set_mode+0xe0> @ imm = #0xc
; 		can->BTR |= CAN_BTR_LBKM;
 800825e: 69fb         	ldr	r3, [r7, #0x1c]
 8008260: 69db         	ldr	r3, [r3, #0x1c]
 8008262: f043 4280    	orr	r2, r3, #0x40000000
 8008266: 69fb         	ldr	r3, [r7, #0x1c]
 8008268: 61da         	str	r2, [r3, #0x1c]
 800826a: e005         	b	0x8008278 <can_stm32_set_mode+0xec> @ imm = #0xa
; 		can->BTR &= ~CAN_BTR_LBKM;
 800826c: 69fb         	ldr	r3, [r7, #0x1c]
 800826e: 69db         	ldr	r3, [r3, #0x1c]
 8008270: f023 4280    	bic	r2, r3, #0x40000000
 8008274: 69fb         	ldr	r3, [r7, #0x1c]
 8008276: 61da         	str	r2, [r3, #0x1c]
; 	if ((mode & CAN_MODE_LISTENONLY) != 0) {
 8008278: 683b         	ldr	r3, [r7]
 800827a: f003 0302    	and	r3, r3, #0x2
 800827e: 2b00         	cmp	r3, #0x0
 8008280: d006         	beq	0x8008290 <can_stm32_set_mode+0x104> @ imm = #0xc
; 		can->BTR |= CAN_BTR_SILM;
 8008282: 69fb         	ldr	r3, [r7, #0x1c]
 8008284: 69db         	ldr	r3, [r3, #0x1c]
 8008286: f043 4200    	orr	r2, r3, #0x80000000
 800828a: 69fb         	ldr	r3, [r7, #0x1c]
 800828c: 61da         	str	r2, [r3, #0x1c]
 800828e: e005         	b	0x800829c <can_stm32_set_mode+0x110> @ imm = #0xa
; 		can->BTR &= ~CAN_BTR_SILM;
 8008290: 69fb         	ldr	r3, [r7, #0x1c]
 8008292: 69db         	ldr	r3, [r3, #0x1c]
 8008294: f023 4200    	bic	r2, r3, #0x80000000
 8008298: 69fb         	ldr	r3, [r7, #0x1c]
 800829a: 61da         	str	r2, [r3, #0x1c]
; 	if ((mode & CAN_MODE_ONE_SHOT) != 0) {
 800829c: 683b         	ldr	r3, [r7]
 800829e: f003 0308    	and	r3, r3, #0x8
 80082a2: 2b00         	cmp	r3, #0x0
 80082a4: d006         	beq	0x80082b4 <can_stm32_set_mode+0x128> @ imm = #0xc
; 		can->MCR |= CAN_MCR_NART;
 80082a6: 69fb         	ldr	r3, [r7, #0x1c]
 80082a8: 681b         	ldr	r3, [r3]
 80082aa: f043 0210    	orr	r2, r3, #0x10
 80082ae: 69fb         	ldr	r3, [r7, #0x1c]
 80082b0: 601a         	str	r2, [r3]
 80082b2: e005         	b	0x80082c0 <can_stm32_set_mode+0x134> @ imm = #0xa
; 		can->MCR &= ~CAN_MCR_NART;
 80082b4: 69fb         	ldr	r3, [r7, #0x1c]
 80082b6: 681b         	ldr	r3, [r3]
 80082b8: f023 0210    	bic	r2, r3, #0x10
 80082bc: 69fb         	ldr	r3, [r7, #0x1c]
 80082be: 601a         	str	r2, [r3]
; 	data->common.mode = mode;
 80082c0: 69bb         	ldr	r3, [r7, #0x18]
 80082c2: 683a         	ldr	r2, [r7]
 80082c4: 601a         	str	r2, [r3]
; 	k_mutex_unlock(&data->inst_mutex);
 80082c6: 69bb         	ldr	r3, [r7, #0x18]
 80082c8: 3310         	adds	r3, #0x10
 80082ca: 4618         	mov	r0, r3
 80082cc: f015 f80f    	bl	0x801d2ee <k_mutex_unlock> @ imm = #0x1501e
; 	return 0;
 80082d0: 2100         	movs	r1, #0x0
; }
 80082d2: 460b         	mov	r3, r1
 80082d4: 4618         	mov	r0, r3
 80082d6: 3728         	adds	r7, #0x28
 80082d8: 46bd         	mov	sp, r7
 80082da: bd80         	pop	{r7, pc}

080082dc <$d>:
 80082dc: 34 05 00 20  	.word	0x20000534
 80082e0: fc a8 02 08  	.word	0x0802a8fc
 80082e4: 7c 8c 02 08  	.word	0x08028c7c
 80082e8: 8c 8c 02 08  	.word	0x08028c8c

080082ec <can_stm32_set_timing>:
; {
 80082ec: b580         	push	{r7, lr}
 80082ee: b086         	sub	sp, #0x18
 80082f0: af00         	add	r7, sp, #0x0
 80082f2: 6078         	str	r0, [r7, #0x4]
 80082f4: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 80082f6: 687b         	ldr	r3, [r7, #0x4]
 80082f8: 685b         	ldr	r3, [r3, #0x4]
 80082fa: 617b         	str	r3, [r7, #0x14]
; 	CAN_TypeDef *can = cfg->can;
 80082fc: 697b         	ldr	r3, [r7, #0x14]
 80082fe: 695b         	ldr	r3, [r3, #0x14]
 8008300: 613b         	str	r3, [r7, #0x10]
; 	struct can_stm32_data *data = dev->data;
 8008302: 687b         	ldr	r3, [r7, #0x4]
 8008304: 691b         	ldr	r3, [r3, #0x10]
 8008306: 60fb         	str	r3, [r7, #0xc]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8008308: 68fb         	ldr	r3, [r7, #0xc]
 800830a: f103 0110    	add.w	r1, r3, #0x10
 800830e: f04f 32ff    	mov.w	r2, #0xffffffff
 8008312: f04f 33ff    	mov.w	r3, #0xffffffff
 8008316: 4608         	mov	r0, r1
 8008318: f014 ffd9    	bl	0x801d2ce <k_mutex_lock> @ imm = #0x14fb2
; 	if (data->common.started) {
 800831c: 68fb         	ldr	r3, [r7, #0xc]
 800831e: 791b         	ldrb	r3, [r3, #0x4]
 8008320: 2b00         	cmp	r3, #0x0
 8008322: d007         	beq	0x8008334 <can_stm32_set_timing+0x48> @ imm = #0xe
; 		k_mutex_unlock(&data->inst_mutex);
 8008324: 68fb         	ldr	r3, [r7, #0xc]
 8008326: 3310         	adds	r3, #0x10
 8008328: 4618         	mov	r0, r3
 800832a: f014 ffe0    	bl	0x801d2ee <k_mutex_unlock> @ imm = #0x14fc0
; 		return -EBUSY;
 800832e: f06f 010f    	mvn	r1, #0xf
 8008332: e026         	b	0x8008382 <can_stm32_set_timing+0x96> @ imm = #0x4c
; 	can->BTR = (can->BTR &
 8008334: 693b         	ldr	r3, [r7, #0x10]
 8008336: 69da         	ldr	r2, [r3, #0x1c]
 8008338: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800838c <can_stm32_set_timing+0xa0>
 800833a: 4013         	ands	r3, r2
; 		   (((timing->sjw - 1) << CAN_BTR_SJW_Pos) & CAN_BTR_SJW_Msk) |
 800833c: 683a         	ldr	r2, [r7]
 800833e: 8812         	ldrh	r2, [r2]
 8008340: 3a01         	subs	r2, #0x1
 8008342: 0612         	lsls	r2, r2, #0x18
 8008344: f002 7240    	and	r2, r2, #0x3000000
; 		    ~(CAN_BTR_SJW_Msk | CAN_BTR_BRP_Msk | CAN_BTR_TS1_Msk | CAN_BTR_TS2_Msk)) |
 8008348: 431a         	orrs	r2, r3
; 		   (((timing->phase_seg1 - 1) << CAN_BTR_TS1_Pos) & CAN_BTR_TS1_Msk) |
 800834a: 683b         	ldr	r3, [r7]
 800834c: 889b         	ldrh	r3, [r3, #0x4]
 800834e: 3b01         	subs	r3, #0x1
 8008350: 041b         	lsls	r3, r3, #0x10
 8008352: f403 2370    	and	r3, r3, #0xf0000
; 		   (((timing->sjw - 1) << CAN_BTR_SJW_Pos) & CAN_BTR_SJW_Msk) |
 8008356: 431a         	orrs	r2, r3
; 		   (((timing->phase_seg2 - 1) << CAN_BTR_TS2_Pos) & CAN_BTR_TS2_Msk) |
 8008358: 683b         	ldr	r3, [r7]
 800835a: 88db         	ldrh	r3, [r3, #0x6]
 800835c: 3b01         	subs	r3, #0x1
 800835e: 051b         	lsls	r3, r3, #0x14
 8008360: f403 03e0    	and	r3, r3, #0x700000
; 		   (((timing->phase_seg1 - 1) << CAN_BTR_TS1_Pos) & CAN_BTR_TS1_Msk) |
 8008364: 431a         	orrs	r2, r3
; 		   (((timing->prescaler - 1) << CAN_BTR_BRP_Pos) & CAN_BTR_BRP_Msk);
 8008366: 683b         	ldr	r3, [r7]
 8008368: 891b         	ldrh	r3, [r3, #0x8]
 800836a: 3b01         	subs	r3, #0x1
 800836c: f3c3 0309    	ubfx	r3, r3, #0x0, #0xa
; 		   (((timing->phase_seg2 - 1) << CAN_BTR_TS2_Pos) & CAN_BTR_TS2_Msk) |
 8008370: 431a         	orrs	r2, r3
; 	can->BTR = (can->BTR &
 8008372: 693b         	ldr	r3, [r7, #0x10]
 8008374: 61da         	str	r2, [r3, #0x1c]
; 	k_mutex_unlock(&data->inst_mutex);
 8008376: 68fb         	ldr	r3, [r7, #0xc]
 8008378: 3310         	adds	r3, #0x10
 800837a: 4618         	mov	r0, r3
 800837c: f014 ffb7    	bl	0x801d2ee <k_mutex_unlock> @ imm = #0x14f6e
; 	return 0;
 8008380: 2100         	movs	r1, #0x0
; }
 8008382: 460b         	mov	r3, r1
 8008384: 4618         	mov	r0, r3
 8008386: 3718         	adds	r7, #0x18
 8008388: 46bd         	mov	sp, r7
 800838a: bd80         	pop	{r7, pc}

0800838c <$d>:
 800838c: 00 fc 80 fc  	.word	0xfc80fc00

08008390 <can_stm32_get_core_clock>:
; {
 8008390: b580         	push	{r7, lr}
 8008392: b08c         	sub	sp, #0x30
 8008394: af04         	add	r7, sp, #0x10
 8008396: 6078         	str	r0, [r7, #0x4]
 8008398: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 800839a: 687b         	ldr	r3, [r7, #0x4]
 800839c: 685b         	ldr	r3, [r3, #0x4]
 800839e: 61fb         	str	r3, [r7, #0x1c]
; 	clock = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 80083a0: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8008404 <can_stm32_get_core_clock+0x74>
 80083a2: 61bb         	str	r3, [r7, #0x18]
; 	ret = clock_control_get_rate(clock, (clock_control_subsys_t)&cfg->pclken, rate);
 80083a4: 69fb         	ldr	r3, [r7, #0x1c]
 80083a6: 331c         	adds	r3, #0x1c
 80083a8: 683a         	ldr	r2, [r7]
 80083aa: 4619         	mov	r1, r3
 80083ac: 69b8         	ldr	r0, [r7, #0x18]
 80083ae: f015 f825    	bl	0x801d3fc <clock_control_get_rate> @ imm = #0x1504a
 80083b2: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 80083b4: 697b         	ldr	r3, [r7, #0x14]
 80083b6: 2b00         	cmp	r3, #0x0
 80083b8: d01e         	beq	0x80083f8 <can_stm32_get_core_clock+0x68> @ imm = #0x3c
; 		LOG_ERR("Failed call clock_control_get_rate: return [%d]", ret);
 80083ba: 2303         	movs	r3, #0x3
 80083bc: 2b00         	cmp	r3, #0x0
 80083be: d018         	beq	0x80083f2 <can_stm32_get_core_clock+0x62> @ imm = #0x30
 80083c0: 2301         	movs	r3, #0x1
 80083c2: 74fb         	strb	r3, [r7, #0x13]
 80083c4: 7cfb         	ldrb	r3, [r7, #0x13]
 80083c6: f083 0301    	eor	r3, r3, #0x1
 80083ca: b2db         	uxtb	r3, r3
 80083cc: 2b00         	cmp	r3, #0x0
 80083ce: d110         	bne	0x80083f2 <can_stm32_get_core_clock+0x62> @ imm = #0x20
 80083d0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8008408 <can_stm32_get_core_clock+0x78>
 80083d2: 6819         	ldr	r1, [r3]
 80083d4: 697b         	ldr	r3, [r7, #0x14]
 80083d6: 9303         	str	r3, [sp, #0xc]
 80083d8: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800840c <can_stm32_get_core_clock+0x7c>
 80083da: 9302         	str	r3, [sp, #0x8]
 80083dc: 2300         	movs	r3, #0x0
 80083de: 9301         	str	r3, [sp, #0x4]
 80083e0: 2300         	movs	r3, #0x0
 80083e2: 9300         	str	r3, [sp]
 80083e4: 2300         	movs	r3, #0x0
 80083e6: 2201         	movs	r2, #0x1
 80083e8: 2000         	movs	r0, #0x0
 80083ea: f015 f853    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x150a6
 80083ee: 2300         	movs	r3, #0x0
 80083f0: 60fb         	str	r3, [r7, #0xc]
; 		return -EIO;
 80083f2: f06f 0304    	mvn	r3, #0x4
 80083f6: e000         	b	0x80083fa <can_stm32_get_core_clock+0x6a> @ imm = #0x0
; 	return 0;
 80083f8: 2300         	movs	r3, #0x0
; }
 80083fa: 4618         	mov	r0, r3
 80083fc: 3720         	adds	r7, #0x20
 80083fe: 46bd         	mov	sp, r7
 8008400: bd80         	pop	{r7, pc}
 8008402: bf00         	nop

08008404 <$d>:
 8008404: 48 7a 02 08  	.word	0x08027a48
 8008408: 34 05 00 20  	.word	0x20000534
 800840c: a8 8c 02 08  	.word	0x08028ca8

08008410 <can_stm32_init>:
; {
 8008410: b580         	push	{r7, lr}
 8008412: b0a6         	sub	sp, #0x98
 8008414: af08         	add	r7, sp, #0x20
 8008416: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8008418: 687b         	ldr	r3, [r7, #0x4]
 800841a: 685b         	ldr	r3, [r3, #0x4]
 800841c: 663b         	str	r3, [r7, #0x60]
; 	struct can_stm32_data *data = dev->data;
 800841e: 687b         	ldr	r3, [r7, #0x4]
 8008420: 691b         	ldr	r3, [r3, #0x10]
 8008422: 66bb         	str	r3, [r7, #0x68]
; 	CAN_TypeDef *can = cfg->can;
 8008424: 6e3b         	ldr	r3, [r7, #0x60]
 8008426: 695b         	ldr	r3, [r3, #0x14]
 8008428: 667b         	str	r3, [r7, #0x64]
; 	struct can_timing timing = {0};
 800842a: f107 030c    	add.w	r3, r7, #0xc
 800842e: 2200         	movs	r2, #0x0
 8008430: 601a         	str	r2, [r3]
 8008432: 605a         	str	r2, [r3, #0x4]
 8008434: 811a         	strh	r2, [r3, #0x8]
; 	k_mutex_init(&filter_mutex);
 8008436: 4886         	ldr	r0, [pc, #0x218]        @ 0x8008650 <can_stm32_init+0x240>
 8008438: f014 ff3d    	bl	0x801d2b6 <k_mutex_init> @ imm = #0x14e7a
; 	k_mutex_init(&data->inst_mutex);
 800843c: 6ebb         	ldr	r3, [r7, #0x68]
 800843e: 3310         	adds	r3, #0x10
 8008440: 4618         	mov	r0, r3
 8008442: f014 ff38    	bl	0x801d2b6 <k_mutex_init> @ imm = #0x14e70
; 	k_sem_init(&data->tx_int_sem, 0, 1);
 8008446: 6ebb         	ldr	r3, [r7, #0x68]
 8008448: 3324         	adds	r3, #0x24
 800844a: 2201         	movs	r2, #0x1
 800844c: 2100         	movs	r1, #0x0
 800844e: 4618         	mov	r0, r3
 8008450: f014 ff59    	bl	0x801d306 <k_sem_init>  @ imm = #0x14eb2
; 	if (cfg->common.phy != NULL) {
 8008454: 6e3b         	ldr	r3, [r7, #0x60]
 8008456: 681b         	ldr	r3, [r3]
 8008458: 2b00         	cmp	r3, #0x0
 800845a: d029         	beq	0x80084b0 <can_stm32_init+0xa0> @ imm = #0x52
; 		if (!device_is_ready(cfg->common.phy)) {
 800845c: 6e3b         	ldr	r3, [r7, #0x60]
 800845e: 681b         	ldr	r3, [r3]
 8008460: 4618         	mov	r0, r3
 8008462: f014 ff0e    	bl	0x801d282 <device_is_ready> @ imm = #0x14e1c
 8008466: 4603         	mov	r3, r0
 8008468: f083 0301    	eor	r3, r3, #0x1
 800846c: b2db         	uxtb	r3, r3
 800846e: 2b00         	cmp	r3, #0x0
 8008470: d01e         	beq	0x80084b0 <can_stm32_init+0xa0> @ imm = #0x3c
; 			LOG_ERR("CAN transceiver not ready");
 8008472: 2303         	movs	r3, #0x3
 8008474: 2b00         	cmp	r3, #0x0
 8008476: d018         	beq	0x80084aa <can_stm32_init+0x9a> @ imm = #0x30
 8008478: 2301         	movs	r3, #0x1
 800847a: f887 306f    	strb.w	r3, [r7, #0x6f]
 800847e: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 8008482: f083 0301    	eor	r3, r3, #0x1
 8008486: b2db         	uxtb	r3, r3
 8008488: 2b00         	cmp	r3, #0x0
 800848a: d10e         	bne	0x80084aa <can_stm32_init+0x9a> @ imm = #0x1c
 800848c: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8008654 <can_stm32_init+0x244>
 800848e: 6819         	ldr	r1, [r3]
 8008490: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8008658 <can_stm32_init+0x248>
 8008492: 9302         	str	r3, [sp, #0x8]
 8008494: 2300         	movs	r3, #0x0
 8008496: 9301         	str	r3, [sp, #0x4]
 8008498: 2300         	movs	r3, #0x0
 800849a: 9300         	str	r3, [sp]
 800849c: 2300         	movs	r3, #0x0
 800849e: 2201         	movs	r2, #0x1
 80084a0: 2000         	movs	r0, #0x0
 80084a2: f014 fff7    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14fee
 80084a6: 2300         	movs	r3, #0x0
 80084a8: 673b         	str	r3, [r7, #0x70]
; 			return -ENODEV;
 80084aa: f06f 0312    	mvn	r3, #0x12
 80084ae: e1a8         	b	0x8008802 <can_stm32_init+0x3f2> @ imm = #0x350
; 	clock = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 80084b0: 4b6a         	ldr	r3, [pc, #0x1a8]        @ 0x800865c <can_stm32_init+0x24c>
 80084b2: 677b         	str	r3, [r7, #0x74]
; 	if (!device_is_ready(clock)) {
 80084b4: 6f78         	ldr	r0, [r7, #0x74]
 80084b6: f014 fee4    	bl	0x801d282 <device_is_ready> @ imm = #0x14dc8
 80084ba: 4603         	mov	r3, r0
 80084bc: f083 0301    	eor	r3, r3, #0x1
 80084c0: b2db         	uxtb	r3, r3
 80084c2: 2b00         	cmp	r3, #0x0
 80084c4: d01c         	beq	0x8008500 <can_stm32_init+0xf0> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 80084c6: 2303         	movs	r3, #0x3
 80084c8: 2b00         	cmp	r3, #0x0
 80084ca: d016         	beq	0x80084fa <can_stm32_init+0xea> @ imm = #0x2c
 80084cc: 2301         	movs	r3, #0x1
 80084ce: 77fb         	strb	r3, [r7, #0x1f]
 80084d0: 7ffb         	ldrb	r3, [r7, #0x1f]
 80084d2: f083 0301    	eor	r3, r3, #0x1
 80084d6: b2db         	uxtb	r3, r3
 80084d8: 2b00         	cmp	r3, #0x0
 80084da: d10e         	bne	0x80084fa <can_stm32_init+0xea> @ imm = #0x1c
 80084dc: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8008654 <can_stm32_init+0x244>
 80084de: 6819         	ldr	r1, [r3]
 80084e0: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x8008660 <can_stm32_init+0x250>
 80084e2: 9302         	str	r3, [sp, #0x8]
 80084e4: 2300         	movs	r3, #0x0
 80084e6: 9301         	str	r3, [sp, #0x4]
 80084e8: 2300         	movs	r3, #0x0
 80084ea: 9300         	str	r3, [sp]
 80084ec: 2300         	movs	r3, #0x0
 80084ee: 2201         	movs	r2, #0x1
 80084f0: 2000         	movs	r0, #0x0
 80084f2: f014 ffcf    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14f9e
 80084f6: 2300         	movs	r3, #0x0
 80084f8: 61bb         	str	r3, [r7, #0x18]
; 		return -ENODEV;
 80084fa: f06f 0312    	mvn	r3, #0x12
 80084fe: e180         	b	0x8008802 <can_stm32_init+0x3f2> @ imm = #0x300
; 	ret = clock_control_on(clock, (clock_control_subsys_t)&cfg->pclken);
 8008500: 6e3b         	ldr	r3, [r7, #0x60]
 8008502: 331c         	adds	r3, #0x1c
 8008504: 4619         	mov	r1, r3
 8008506: 6f78         	ldr	r0, [r7, #0x74]
 8008508: f014 ff66    	bl	0x801d3d8 <clock_control_on> @ imm = #0x14ecc
 800850c: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret != 0) {
 800850e: 6dfb         	ldr	r3, [r7, #0x5c]
 8008510: 2b00         	cmp	r3, #0x0
 8008512: d020         	beq	0x8008556 <can_stm32_init+0x146> @ imm = #0x40
; 		LOG_ERR("HAL_CAN_Init clock control on failed: %d", ret);
 8008514: 2303         	movs	r3, #0x3
 8008516: 2b00         	cmp	r3, #0x0
 8008518: d01a         	beq	0x8008550 <can_stm32_init+0x140> @ imm = #0x34
 800851a: 2301         	movs	r3, #0x1
 800851c: f887 3027    	strb.w	r3, [r7, #0x27]
 8008520: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8008524: f083 0301    	eor	r3, r3, #0x1
 8008528: b2db         	uxtb	r3, r3
 800852a: 2b00         	cmp	r3, #0x0
 800852c: d110         	bne	0x8008550 <can_stm32_init+0x140> @ imm = #0x20
 800852e: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8008654 <can_stm32_init+0x244>
 8008530: 6819         	ldr	r1, [r3]
 8008532: 6dfb         	ldr	r3, [r7, #0x5c]
 8008534: 9303         	str	r3, [sp, #0xc]
 8008536: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8008664 <can_stm32_init+0x254>
 8008538: 9302         	str	r3, [sp, #0x8]
 800853a: 2300         	movs	r3, #0x0
 800853c: 9301         	str	r3, [sp, #0x4]
 800853e: 2300         	movs	r3, #0x0
 8008540: 9300         	str	r3, [sp]
 8008542: 2300         	movs	r3, #0x0
 8008544: 2201         	movs	r2, #0x1
 8008546: 2000         	movs	r0, #0x0
 8008548: f014 ffa4    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14f48
 800854c: 2300         	movs	r3, #0x0
 800854e: 623b         	str	r3, [r7, #0x20]
; 		return -EIO;
 8008550: f06f 0304    	mvn	r3, #0x4
 8008554: e155         	b	0x8008802 <can_stm32_init+0x3f2> @ imm = #0x2aa
; 	ret = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
 8008556: 6e3b         	ldr	r3, [r7, #0x60]
 8008558: 6a9b         	ldr	r3, [r3, #0x28]
 800855a: 2100         	movs	r1, #0x0
 800855c: 4618         	mov	r0, r3
 800855e: f014 ff7c    	bl	0x801d45a <pinctrl_apply_state> @ imm = #0x14ef8
 8008562: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret < 0) {
 8008564: 6dfb         	ldr	r3, [r7, #0x5c]
 8008566: 2b00         	cmp	r3, #0x0
 8008568: da1f         	bge	0x80085aa <can_stm32_init+0x19a> @ imm = #0x3e
; 		LOG_ERR("CAN pinctrl setup failed (%d)", ret);
 800856a: 2303         	movs	r3, #0x3
 800856c: 2b00         	cmp	r3, #0x0
 800856e: d01a         	beq	0x80085a6 <can_stm32_init+0x196> @ imm = #0x34
 8008570: 2301         	movs	r3, #0x1
 8008572: f887 302f    	strb.w	r3, [r7, #0x2f]
 8008576: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800857a: f083 0301    	eor	r3, r3, #0x1
 800857e: b2db         	uxtb	r3, r3
 8008580: 2b00         	cmp	r3, #0x0
 8008582: d110         	bne	0x80085a6 <can_stm32_init+0x196> @ imm = #0x20
 8008584: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8008654 <can_stm32_init+0x244>
 8008586: 6819         	ldr	r1, [r3]
 8008588: 6dfb         	ldr	r3, [r7, #0x5c]
 800858a: 9303         	str	r3, [sp, #0xc]
 800858c: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8008668 <can_stm32_init+0x258>
 800858e: 9302         	str	r3, [sp, #0x8]
 8008590: 2300         	movs	r3, #0x0
 8008592: 9301         	str	r3, [sp, #0x4]
 8008594: 2300         	movs	r3, #0x0
 8008596: 9300         	str	r3, [sp]
 8008598: 2300         	movs	r3, #0x0
 800859a: 2201         	movs	r2, #0x1
 800859c: 2000         	movs	r0, #0x0
 800859e: f014 ff79    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14ef2
 80085a2: 2300         	movs	r3, #0x0
 80085a4: 62bb         	str	r3, [r7, #0x28]
; 		return ret;
 80085a6: 6dfb         	ldr	r3, [r7, #0x5c]
 80085a8: e12b         	b	0x8008802 <can_stm32_init+0x3f2> @ imm = #0x256
; 	ret = can_stm32_enter_init_mode(can);
 80085aa: 6e78         	ldr	r0, [r7, #0x64]
 80085ac: f7ff fc3c    	bl	0x8007e28 <can_stm32_enter_init_mode> @ imm = #-0x788
 80085b0: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 80085b2: 6dfb         	ldr	r3, [r7, #0x5c]
 80085b4: 2b00         	cmp	r3, #0x0
 80085b6: d01d         	beq	0x80085f4 <can_stm32_init+0x1e4> @ imm = #0x3a
; 		LOG_ERR("Failed to enter init mode");
 80085b8: 2303         	movs	r3, #0x3
 80085ba: 2b00         	cmp	r3, #0x0
 80085bc: d018         	beq	0x80085f0 <can_stm32_init+0x1e0> @ imm = #0x30
 80085be: 2301         	movs	r3, #0x1
 80085c0: f887 3037    	strb.w	r3, [r7, #0x37]
 80085c4: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80085c8: f083 0301    	eor	r3, r3, #0x1
 80085cc: b2db         	uxtb	r3, r3
 80085ce: 2b00         	cmp	r3, #0x0
 80085d0: d10e         	bne	0x80085f0 <can_stm32_init+0x1e0> @ imm = #0x1c
 80085d2: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8008654 <can_stm32_init+0x244>
 80085d4: 6819         	ldr	r1, [r3]
 80085d6: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800866c <can_stm32_init+0x25c>
 80085d8: 9302         	str	r3, [sp, #0x8]
 80085da: 2300         	movs	r3, #0x0
 80085dc: 9301         	str	r3, [sp, #0x4]
 80085de: 2300         	movs	r3, #0x0
 80085e0: 9300         	str	r3, [sp]
 80085e2: 2300         	movs	r3, #0x0
 80085e4: 2201         	movs	r2, #0x1
 80085e6: 2000         	movs	r0, #0x0
 80085e8: f014 ff54    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14ea8
 80085ec: 2300         	movs	r3, #0x0
 80085ee: 633b         	str	r3, [r7, #0x30]
; 		return ret;
 80085f0: 6dfb         	ldr	r3, [r7, #0x5c]
 80085f2: e106         	b	0x8008802 <can_stm32_init+0x3f2> @ imm = #0x20c
; 	ret = can_stm32_leave_sleep_mode(can);
 80085f4: 6e78         	ldr	r0, [r7, #0x64]
 80085f6: f7ff fc69    	bl	0x8007ecc <can_stm32_leave_sleep_mode> @ imm = #-0x72e
 80085fa: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 80085fc: 6dfb         	ldr	r3, [r7, #0x5c]
 80085fe: 2b00         	cmp	r3, #0x0
 8008600: d01d         	beq	0x800863e <can_stm32_init+0x22e> @ imm = #0x3a
; 		LOG_ERR("Failed to exit sleep mode");
 8008602: 2303         	movs	r3, #0x3
 8008604: 2b00         	cmp	r3, #0x0
 8008606: d018         	beq	0x800863a <can_stm32_init+0x22a> @ imm = #0x30
 8008608: 2301         	movs	r3, #0x1
 800860a: f887 303f    	strb.w	r3, [r7, #0x3f]
 800860e: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8008612: f083 0301    	eor	r3, r3, #0x1
 8008616: b2db         	uxtb	r3, r3
 8008618: 2b00         	cmp	r3, #0x0
 800861a: d10e         	bne	0x800863a <can_stm32_init+0x22a> @ imm = #0x1c
 800861c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8008654 <can_stm32_init+0x244>
 800861e: 6819         	ldr	r1, [r3]
 8008620: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8008670 <can_stm32_init+0x260>
 8008622: 9302         	str	r3, [sp, #0x8]
 8008624: 2300         	movs	r3, #0x0
 8008626: 9301         	str	r3, [sp, #0x4]
 8008628: 2300         	movs	r3, #0x0
 800862a: 9300         	str	r3, [sp]
 800862c: 2300         	movs	r3, #0x0
 800862e: 2201         	movs	r2, #0x1
 8008630: 2000         	movs	r0, #0x0
 8008632: f014 ff2f    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14e5e
 8008636: 2300         	movs	r3, #0x0
 8008638: 63bb         	str	r3, [r7, #0x38]
; 		return ret;
 800863a: 6dfb         	ldr	r3, [r7, #0x5c]
 800863c: e0e1         	b	0x8008802 <can_stm32_init+0x3f2> @ imm = #0x1c2
; 	bank_offset = (cfg->can == cfg->master_can) ? 0 : CAN_STM32_NUM_FILTER_BANKS;
 800863e: 6e3b         	ldr	r3, [r7, #0x60]
 8008640: 695a         	ldr	r2, [r3, #0x14]
 8008642: 6e3b         	ldr	r3, [r7, #0x60]
 8008644: 699b         	ldr	r3, [r3, #0x18]
 8008646: 429a         	cmp	r2, r3
 8008648: d114         	bne	0x8008674 <can_stm32_init+0x264> @ imm = #0x28
 800864a: 2300         	movs	r3, #0x0
 800864c: e013         	b	0x8008676 <can_stm32_init+0x266> @ imm = #0x26
 800864e: bf00         	nop

08008650 <$d>:
 8008650: bc 2d 00 20  	.word	0x20002dbc
 8008654: 34 05 00 20  	.word	0x20000534
 8008658: d8 8c 02 08  	.word	0x08028cd8
 800865c: 48 7a 02 08  	.word	0x08027a48
 8008660: f4 8c 02 08  	.word	0x08028cf4
 8008664: 14 8d 02 08  	.word	0x08028d14
 8008668: 40 8d 02 08  	.word	0x08028d40
 800866c: 60 8c 02 08  	.word	0x08028c60
 8008670: 60 8d 02 08  	.word	0x08028d60

08008674 <$t>:
 8008674: 230e         	movs	r3, #0xe
 8008676: 65bb         	str	r3, [r7, #0x58]
; 	cfg->master_can->FMR |= CAN_FMR_FINIT;
 8008678: 6e3b         	ldr	r3, [r7, #0x60]
 800867a: 699b         	ldr	r3, [r3, #0x18]
 800867c: f8d3 2200    	ldr.w	r2, [r3, #0x200]
 8008680: 6e3b         	ldr	r3, [r7, #0x60]
 8008682: 699b         	ldr	r3, [r3, #0x18]
 8008684: f042 0201    	orr	r2, r2, #0x1
 8008688: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	cfg->master_can->FS1R |= ((1U << CONFIG_CAN_MAX_EXT_ID_FILTER) - 1) << bank_offset;
 800868c: 6e3b         	ldr	r3, [r7, #0x60]
 800868e: 699b         	ldr	r3, [r3, #0x18]
 8008690: f8d3 120c    	ldr.w	r1, [r3, #0x20c]
 8008694: 227f         	movs	r2, #0x7f
 8008696: 6dbb         	ldr	r3, [r7, #0x58]
 8008698: 409a         	lsls	r2, r3
 800869a: 6e3b         	ldr	r3, [r7, #0x60]
 800869c: 699b         	ldr	r3, [r3, #0x18]
 800869e: 430a         	orrs	r2, r1
 80086a0: f8c3 220c    	str.w	r2, [r3, #0x20c]
; 	cfg->master_can->FMR &= ~CAN_FMR_FINIT;
 80086a4: 6e3b         	ldr	r3, [r7, #0x60]
 80086a6: 699b         	ldr	r3, [r3, #0x18]
 80086a8: f8d3 2200    	ldr.w	r2, [r3, #0x200]
 80086ac: 6e3b         	ldr	r3, [r7, #0x60]
 80086ae: 699b         	ldr	r3, [r3, #0x18]
 80086b0: f022 0201    	bic	r2, r2, #0x1
 80086b4: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	can->MCR &= ~CAN_MCR_TTCM & ~CAN_MCR_ABOM & ~CAN_MCR_AWUM & ~CAN_MCR_NART & ~CAN_MCR_RFLM &
 80086b8: 6e7b         	ldr	r3, [r7, #0x64]
 80086ba: 681b         	ldr	r3, [r3]
 80086bc: f023 02fc    	bic	r2, r3, #0xfc
 80086c0: 6e7b         	ldr	r3, [r7, #0x64]
 80086c2: 601a         	str	r2, [r3]
; 	can->MCR |= CAN_MCR_ABOM;
 80086c4: 6e7b         	ldr	r3, [r7, #0x64]
 80086c6: 681b         	ldr	r3, [r3]
 80086c8: f043 0240    	orr	r2, r3, #0x40
 80086cc: 6e7b         	ldr	r3, [r7, #0x64]
 80086ce: 601a         	str	r2, [r3]
; 	ret = can_calc_timing(dev, &timing, cfg->common.bitrate, cfg->common.sample_point);
 80086d0: 6e3b         	ldr	r3, [r7, #0x60]
 80086d2: 68da         	ldr	r2, [r3, #0xc]
 80086d4: 6e3b         	ldr	r3, [r7, #0x60]
 80086d6: 8a1b         	ldrh	r3, [r3, #0x10]
 80086d8: f107 010c    	add.w	r1, r7, #0xc
 80086dc: 6878         	ldr	r0, [r7, #0x4]
 80086de: f014 fe3d    	bl	0x801d35c <can_calc_timing> @ imm = #0x14c7a
 80086e2: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret == -EINVAL) {
 80086e4: 6dfb         	ldr	r3, [r7, #0x5c]
 80086e6: f113 0f16    	cmn.w	r3, #0x16
 80086ea: d11e         	bne	0x800872a <can_stm32_init+0x31a> @ imm = #0x3c
; 		LOG_ERR("Can't find timing for given param");
 80086ec: 2303         	movs	r3, #0x3
 80086ee: 2b00         	cmp	r3, #0x0
 80086f0: d018         	beq	0x8008724 <can_stm32_init+0x314> @ imm = #0x30
 80086f2: 2301         	movs	r3, #0x1
 80086f4: f887 3047    	strb.w	r3, [r7, #0x47]
 80086f8: f897 3047    	ldrb.w	r3, [r7, #0x47]
 80086fc: f083 0301    	eor	r3, r3, #0x1
 8008700: b2db         	uxtb	r3, r3
 8008702: 2b00         	cmp	r3, #0x0
 8008704: d10e         	bne	0x8008724 <can_stm32_init+0x314> @ imm = #0x1c
 8008706: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800880c <can_stm32_init+0x3fc>
 8008708: 6819         	ldr	r1, [r3]
 800870a: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8008810 <can_stm32_init+0x400>
 800870c: 9302         	str	r3, [sp, #0x8]
 800870e: 2300         	movs	r3, #0x0
 8008710: 9301         	str	r3, [sp, #0x4]
 8008712: 2300         	movs	r3, #0x0
 8008714: 9300         	str	r3, [sp]
 8008716: 2300         	movs	r3, #0x0
 8008718: 2201         	movs	r2, #0x1
 800871a: 2000         	movs	r0, #0x0
 800871c: f014 feba    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14d74
 8008720: 2300         	movs	r3, #0x0
 8008722: 643b         	str	r3, [r7, #0x40]
; 		return -EIO;
 8008724: f06f 0304    	mvn	r3, #0x4
 8008728: e06b         	b	0x8008802 <can_stm32_init+0x3f2> @ imm = #0xd6
; 	LOG_DBG("Presc: %d, TS1: %d, TS2: %d", timing.prescaler, timing.phase_seg1,
 800872a: 2303         	movs	r3, #0x3
 800872c: 2b03         	cmp	r3, #0x3
 800872e: d920         	bls	0x8008772 <can_stm32_init+0x362> @ imm = #0x40
 8008730: 2301         	movs	r3, #0x1
 8008732: f887 3057    	strb.w	r3, [r7, #0x57]
 8008736: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800873a: f083 0301    	eor	r3, r3, #0x1
 800873e: b2db         	uxtb	r3, r3
 8008740: 2b00         	cmp	r3, #0x0
 8008742: d116         	bne	0x8008772 <can_stm32_init+0x362> @ imm = #0x2c
 8008744: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800880c <can_stm32_init+0x3fc>
 8008746: 6819         	ldr	r1, [r3]
 8008748: 8abb         	ldrh	r3, [r7, #0x14]
 800874a: 8a3a         	ldrh	r2, [r7, #0x10]
 800874c: 8a78         	ldrh	r0, [r7, #0x12]
 800874e: 9006         	str	r0, [sp, #0x18]
 8008750: 9205         	str	r2, [sp, #0x14]
 8008752: 9304         	str	r3, [sp, #0x10]
 8008754: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8008814 <can_stm32_init+0x404>
 8008756: 9303         	str	r3, [sp, #0xc]
 8008758: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8008818 <can_stm32_init+0x408>
 800875a: 9302         	str	r3, [sp, #0x8]
 800875c: 2308         	movs	r3, #0x8
 800875e: 9301         	str	r3, [sp, #0x4]
 8008760: 2300         	movs	r3, #0x0
 8008762: 9300         	str	r3, [sp]
 8008764: 2300         	movs	r3, #0x0
 8008766: 2204         	movs	r2, #0x4
 8008768: 2000         	movs	r0, #0x0
 800876a: f014 fe93    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14d26
 800876e: 2300         	movs	r3, #0x0
 8008770: 653b         	str	r3, [r7, #0x50]
; 	LOG_DBG("Sample-point err : %d", ret);
 8008772: 2303         	movs	r3, #0x3
 8008774: 2b03         	cmp	r3, #0x3
 8008776: d91c         	bls	0x80087b2 <can_stm32_init+0x3a2> @ imm = #0x38
 8008778: 2301         	movs	r3, #0x1
 800877a: f887 304f    	strb.w	r3, [r7, #0x4f]
 800877e: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 8008782: f083 0301    	eor	r3, r3, #0x1
 8008786: b2db         	uxtb	r3, r3
 8008788: 2b00         	cmp	r3, #0x0
 800878a: d112         	bne	0x80087b2 <can_stm32_init+0x3a2> @ imm = #0x24
 800878c: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800880c <can_stm32_init+0x3fc>
 800878e: 6819         	ldr	r1, [r3]
 8008790: 6dfb         	ldr	r3, [r7, #0x5c]
 8008792: 9304         	str	r3, [sp, #0x10]
 8008794: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8008814 <can_stm32_init+0x404>
 8008796: 9303         	str	r3, [sp, #0xc]
 8008798: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800881c <can_stm32_init+0x40c>
 800879a: 9302         	str	r3, [sp, #0x8]
 800879c: 2308         	movs	r3, #0x8
 800879e: 9301         	str	r3, [sp, #0x4]
 80087a0: 2300         	movs	r3, #0x0
 80087a2: 9300         	str	r3, [sp]
 80087a4: 2300         	movs	r3, #0x0
 80087a6: 2204         	movs	r2, #0x4
 80087a8: 2000         	movs	r0, #0x0
 80087aa: f014 fe73    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14ce6
 80087ae: 2300         	movs	r3, #0x0
 80087b0: 64bb         	str	r3, [r7, #0x48]
; 	ret = can_set_timing(dev, &timing);
 80087b2: f107 030c    	add.w	r3, r7, #0xc
 80087b6: 4619         	mov	r1, r3
 80087b8: 6878         	ldr	r0, [r7, #0x4]
 80087ba: f014 fde1    	bl	0x801d380 <can_set_timing> @ imm = #0x14bc2
 80087be: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 80087c0: 6dfb         	ldr	r3, [r7, #0x5c]
 80087c2: 2b00         	cmp	r3, #0x0
 80087c4: d001         	beq	0x80087ca <can_stm32_init+0x3ba> @ imm = #0x2
; 		return ret;
 80087c6: 6dfb         	ldr	r3, [r7, #0x5c]
 80087c8: e01b         	b	0x8008802 <can_stm32_init+0x3f2> @ imm = #0x36
; 	ret = can_stm32_set_mode(dev, CAN_MODE_NORMAL);
 80087ca: 2100         	movs	r1, #0x0
 80087cc: 6878         	ldr	r0, [r7, #0x4]
 80087ce: f7ff fcdd    	bl	0x800818c <can_stm32_set_mode> @ imm = #-0x646
 80087d2: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 80087d4: 6dfb         	ldr	r3, [r7, #0x5c]
 80087d6: 2b00         	cmp	r3, #0x0
 80087d8: d001         	beq	0x80087de <can_stm32_init+0x3ce> @ imm = #0x2
; 		return ret;
 80087da: 6dfb         	ldr	r3, [r7, #0x5c]
 80087dc: e011         	b	0x8008802 <can_stm32_init+0x3f2> @ imm = #0x22
; 	(void)can_stm32_get_state(dev, &data->state, NULL);
 80087de: 6ebb         	ldr	r3, [r7, #0x68]
 80087e0: 33f4         	adds	r3, #0xf4
 80087e2: 2200         	movs	r2, #0x0
 80087e4: 4619         	mov	r1, r3
 80087e6: 6878         	ldr	r0, [r7, #0x4]
 80087e8: f014 fecf    	bl	0x801d58a <can_stm32_get_state> @ imm = #0x14d9e
; 	cfg->config_irq(can);
 80087ec: 6e3b         	ldr	r3, [r7, #0x60]
 80087ee: 6a5b         	ldr	r3, [r3, #0x24]
 80087f0: 6e78         	ldr	r0, [r7, #0x64]
 80087f2: 4798         	blx	r3
; 	can->IER |= CAN_IER_TMEIE;
 80087f4: 6e7b         	ldr	r3, [r7, #0x64]
 80087f6: 695b         	ldr	r3, [r3, #0x14]
 80087f8: f043 0201    	orr	r2, r3, #0x1
 80087fc: 6e7b         	ldr	r3, [r7, #0x64]
 80087fe: 615a         	str	r2, [r3, #0x14]
; 	return 0;
 8008800: 2300         	movs	r3, #0x0
; }
 8008802: 4618         	mov	r0, r3
 8008804: 3778         	adds	r7, #0x78
 8008806: 46bd         	mov	sp, r7
 8008808: bd80         	pop	{r7, pc}
 800880a: bf00         	nop

0800880c <$d>:
 800880c: 34 05 00 20  	.word	0x20000534
 8008810: 7c 8d 02 08  	.word	0x08028d7c
 8008814: 10 a9 02 08  	.word	0x0802a910
 8008818: a0 8d 02 08  	.word	0x08028da0
 800881c: c0 8d 02 08  	.word	0x08028dc0

08008820 <can_stm32_send>:
; {
 8008820: b5b0         	push	{r4, r5, r7, lr}
 8008822: b0a2         	sub	sp, #0x88
 8008824: af0a         	add	r7, sp, #0x28
 8008826: 60f8         	str	r0, [r7, #0xc]
 8008828: 60b9         	str	r1, [r7, #0x8]
 800882a: e9c7 2300    	strd	r2, r3, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 800882e: 68fb         	ldr	r3, [r7, #0xc]
 8008830: 685b         	ldr	r3, [r3, #0x4]
 8008832: 643b         	str	r3, [r7, #0x40]
; 	struct can_stm32_data *data = dev->data;
 8008834: 68fb         	ldr	r3, [r7, #0xc]
 8008836: 691b         	ldr	r3, [r3, #0x10]
 8008838: 63fb         	str	r3, [r7, #0x3c]
; 	CAN_TypeDef *can = cfg->can;
 800883a: 6c3b         	ldr	r3, [r7, #0x40]
 800883c: 695b         	ldr	r3, [r3, #0x14]
 800883e: 63bb         	str	r3, [r7, #0x38]
; 	uint32_t transmit_status_register = 0;
 8008840: 2300         	movs	r3, #0x0
 8008842: 65bb         	str	r3, [r7, #0x58]
; 	CAN_TxMailBox_TypeDef *mailbox = NULL;
 8008844: 2300         	movs	r3, #0x0
 8008846: 64fb         	str	r3, [r7, #0x4c]
; 	struct can_stm32_mailbox *mb = NULL;
 8008848: 2300         	movs	r3, #0x0
 800884a: 64bb         	str	r3, [r7, #0x48]
; 	LOG_DBG("Sending %d bytes on %s. "
 800884c: 2303         	movs	r3, #0x3
 800884e: 2b03         	cmp	r3, #0x3
 8008850: d939         	bls	0x80088c6 <can_stm32_send+0xa6> @ imm = #0x72
 8008852: 2301         	movs	r3, #0x1
 8008854: f887 3047    	strb.w	r3, [r7, #0x47]
 8008858: f897 3047    	ldrb.w	r3, [r7, #0x47]
 800885c: f083 0301    	eor	r3, r3, #0x1
 8008860: b2db         	uxtb	r3, r3
 8008862: 2b00         	cmp	r3, #0x0
 8008864: d12f         	bne	0x80088c6 <can_stm32_send+0xa6> @ imm = #0x5e
 8008866: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8008ad8 <can_stm32_send+0x2b8>
 8008868: 681c         	ldr	r4, [r3]
 800886a: 68bb         	ldr	r3, [r7, #0x8]
 800886c: 791b         	ldrb	r3, [r3, #0x4]
 800886e: 461d         	mov	r5, r3
 8008870: 68fb         	ldr	r3, [r7, #0xc]
 8008872: 681b         	ldr	r3, [r3]
 8008874: 68ba         	ldr	r2, [r7, #0x8]
 8008876: 6812         	ldr	r2, [r2]
 8008878: 68b9         	ldr	r1, [r7, #0x8]
 800887a: 7949         	ldrb	r1, [r1, #0x5]
 800887c: f001 0101    	and	r1, r1, #0x1
 8008880: 2900         	cmp	r1, #0x0
 8008882: d001         	beq	0x8008888 <can_stm32_send+0x68> @ imm = #0x2
 8008884: 4995         	ldr	r1, [pc, #0x254]        @ 0x8008adc <can_stm32_send+0x2bc>
 8008886: e000         	b	0x800888a <can_stm32_send+0x6a> @ imm = #0x0
 8008888: 4995         	ldr	r1, [pc, #0x254]        @ 0x8008ae0 <can_stm32_send+0x2c0>
 800888a: 68b8         	ldr	r0, [r7, #0x8]
 800888c: 7940         	ldrb	r0, [r0, #0x5]
 800888e: f000 0002    	and	r0, r0, #0x2
 8008892: 2800         	cmp	r0, #0x0
 8008894: d001         	beq	0x800889a <can_stm32_send+0x7a> @ imm = #0x2
 8008896: 4893         	ldr	r0, [pc, #0x24c]        @ 0x8008ae4 <can_stm32_send+0x2c4>
 8008898: e000         	b	0x800889c <can_stm32_send+0x7c> @ imm = #0x0
 800889a: 4893         	ldr	r0, [pc, #0x24c]        @ 0x8008ae8 <can_stm32_send+0x2c8>
 800889c: 9008         	str	r0, [sp, #0x20]
 800889e: 9107         	str	r1, [sp, #0x1c]
 80088a0: 9206         	str	r2, [sp, #0x18]
 80088a2: 9305         	str	r3, [sp, #0x14]
 80088a4: 9504         	str	r5, [sp, #0x10]
 80088a6: 4b91         	ldr	r3, [pc, #0x244]        @ 0x8008aec <can_stm32_send+0x2cc>
 80088a8: 9303         	str	r3, [sp, #0xc]
 80088aa: 4b91         	ldr	r3, [pc, #0x244]        @ 0x8008af0 <can_stm32_send+0x2d0>
 80088ac: 9302         	str	r3, [sp, #0x8]
 80088ae: 2308         	movs	r3, #0x8
 80088b0: 9301         	str	r3, [sp, #0x4]
 80088b2: 2300         	movs	r3, #0x0
 80088b4: 9300         	str	r3, [sp]
 80088b6: 2300         	movs	r3, #0x0
 80088b8: 2204         	movs	r2, #0x4
 80088ba: 4621         	mov	r1, r4
 80088bc: 2000         	movs	r0, #0x0
 80088be: f014 fde9    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14bd2
 80088c2: 2300         	movs	r3, #0x0
 80088c4: 65fb         	str	r3, [r7, #0x5c]
; 	if (frame->dlc > CAN_MAX_DLC) {
 80088c6: 68bb         	ldr	r3, [r7, #0x8]
 80088c8: 791b         	ldrb	r3, [r3, #0x4]
 80088ca: 2b08         	cmp	r3, #0x8
 80088cc: d922         	bls	0x8008914 <can_stm32_send+0xf4> @ imm = #0x44
; 		LOG_ERR("DLC of %d exceeds maximum (%d)", frame->dlc, CAN_MAX_DLC);
 80088ce: 2303         	movs	r3, #0x3
 80088d0: 2b00         	cmp	r3, #0x0
 80088d2: d01c         	beq	0x800890e <can_stm32_send+0xee> @ imm = #0x38
 80088d4: 2301         	movs	r3, #0x1
 80088d6: 75fb         	strb	r3, [r7, #0x17]
 80088d8: 7dfb         	ldrb	r3, [r7, #0x17]
 80088da: f083 0301    	eor	r3, r3, #0x1
 80088de: b2db         	uxtb	r3, r3
 80088e0: 2b00         	cmp	r3, #0x0
 80088e2: d114         	bne	0x800890e <can_stm32_send+0xee> @ imm = #0x28
 80088e4: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x8008ad8 <can_stm32_send+0x2b8>
 80088e6: 6819         	ldr	r1, [r3]
 80088e8: 68bb         	ldr	r3, [r7, #0x8]
 80088ea: 791b         	ldrb	r3, [r3, #0x4]
 80088ec: 461a         	mov	r2, r3
 80088ee: 2308         	movs	r3, #0x8
 80088f0: 9304         	str	r3, [sp, #0x10]
 80088f2: 9203         	str	r2, [sp, #0xc]
 80088f4: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x8008af4 <can_stm32_send+0x2d4>
 80088f6: 9302         	str	r3, [sp, #0x8]
 80088f8: 2300         	movs	r3, #0x0
 80088fa: 9301         	str	r3, [sp, #0x4]
 80088fc: 2300         	movs	r3, #0x0
 80088fe: 9300         	str	r3, [sp]
 8008900: 2300         	movs	r3, #0x0
 8008902: 2201         	movs	r2, #0x1
 8008904: 2000         	movs	r0, #0x0
 8008906: f014 fdc5    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14b8a
 800890a: 2300         	movs	r3, #0x0
 800890c: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 800890e: f06f 0315    	mvn	r3, #0x15
 8008912: e174         	b	0x8008bfe <can_stm32_send+0x3de> @ imm = #0x2e8
; 	if ((frame->flags & ~(CAN_FRAME_IDE | CAN_FRAME_RTR)) != 0) {
 8008914: 68bb         	ldr	r3, [r7, #0x8]
 8008916: 795b         	ldrb	r3, [r3, #0x5]
 8008918: 2b03         	cmp	r3, #0x3
 800891a: d91f         	bls	0x800895c <can_stm32_send+0x13c> @ imm = #0x3e
; 		LOG_ERR("unsupported CAN frame flags 0x%02x", frame->flags);
 800891c: 2303         	movs	r3, #0x3
 800891e: 2b00         	cmp	r3, #0x0
 8008920: d019         	beq	0x8008956 <can_stm32_send+0x136> @ imm = #0x32
 8008922: 2301         	movs	r3, #0x1
 8008924: 77fb         	strb	r3, [r7, #0x1f]
 8008926: 7ffb         	ldrb	r3, [r7, #0x1f]
 8008928: f083 0301    	eor	r3, r3, #0x1
 800892c: b2db         	uxtb	r3, r3
 800892e: 2b00         	cmp	r3, #0x0
 8008930: d111         	bne	0x8008956 <can_stm32_send+0x136> @ imm = #0x22
 8008932: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8008ad8 <can_stm32_send+0x2b8>
 8008934: 6819         	ldr	r1, [r3]
 8008936: 68bb         	ldr	r3, [r7, #0x8]
 8008938: 795b         	ldrb	r3, [r3, #0x5]
 800893a: 9303         	str	r3, [sp, #0xc]
 800893c: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8008af8 <can_stm32_send+0x2d8>
 800893e: 9302         	str	r3, [sp, #0x8]
 8008940: 2300         	movs	r3, #0x0
 8008942: 9301         	str	r3, [sp, #0x4]
 8008944: 2300         	movs	r3, #0x0
 8008946: 9300         	str	r3, [sp]
 8008948: 2300         	movs	r3, #0x0
 800894a: 2201         	movs	r2, #0x1
 800894c: 2000         	movs	r0, #0x0
 800894e: f014 fda1    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14b42
 8008952: 2300         	movs	r3, #0x0
 8008954: 61bb         	str	r3, [r7, #0x18]
; 		return -ENOTSUP;
 8008956: f06f 0385    	mvn	r3, #0x85
 800895a: e150         	b	0x8008bfe <can_stm32_send+0x3de> @ imm = #0x2a0
; 	if (!data->common.started) {
 800895c: 6bfb         	ldr	r3, [r7, #0x3c]
 800895e: 791b         	ldrb	r3, [r3, #0x4]
 8008960: f083 0301    	eor	r3, r3, #0x1
 8008964: b2db         	uxtb	r3, r3
 8008966: 2b00         	cmp	r3, #0x0
 8008968: d002         	beq	0x8008970 <can_stm32_send+0x150> @ imm = #0x4
; 		return -ENETDOWN;
 800896a: f06f 0372    	mvn	r3, #0x72
 800896e: e146         	b	0x8008bfe <can_stm32_send+0x3de> @ imm = #0x28c
; 	if (can->ESR & CAN_ESR_BOFF) {
 8008970: 6bbb         	ldr	r3, [r7, #0x38]
 8008972: 699b         	ldr	r3, [r3, #0x18]
 8008974: f003 0304    	and	r3, r3, #0x4
 8008978: 2b00         	cmp	r3, #0x0
 800897a: d002         	beq	0x8008982 <can_stm32_send+0x162> @ imm = #0x4
; 		return -ENETUNREACH;
 800897c: f06f 0371    	mvn	r3, #0x71
 8008980: e13d         	b	0x8008bfe <can_stm32_send+0x3de> @ imm = #0x27a
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8008982: 6bfb         	ldr	r3, [r7, #0x3c]
 8008984: f103 0410    	add.w	r4, r3, #0x10
 8008988: f04f 30ff    	mov.w	r0, #0xffffffff
 800898c: f04f 31ff    	mov.w	r1, #0xffffffff
 8008990: 4602         	mov	r2, r0
 8008992: 460b         	mov	r3, r1
 8008994: 4620         	mov	r0, r4
 8008996: f014 fc9a    	bl	0x801d2ce <k_mutex_lock> @ imm = #0x14934
; 	transmit_status_register = can->TSR;
 800899a: 6bbb         	ldr	r3, [r7, #0x38]
 800899c: 689b         	ldr	r3, [r3, #0x8]
 800899e: 65bb         	str	r3, [r7, #0x58]
; 	while (!(transmit_status_register & CAN_TSR_TME)) {
 80089a0: e03f         	b	0x8008a22 <can_stm32_send+0x202> @ imm = #0x7e
; 		k_mutex_unlock(&data->inst_mutex);
 80089a2: 6bfb         	ldr	r3, [r7, #0x3c]
 80089a4: 3310         	adds	r3, #0x10
 80089a6: 4618         	mov	r0, r3
 80089a8: f014 fca1    	bl	0x801d2ee <k_mutex_unlock> @ imm = #0x14942
; 		LOG_DBG("Transmit buffer full");
 80089ac: 2303         	movs	r3, #0x3
 80089ae: 2b03         	cmp	r3, #0x3
 80089b0: d91a         	bls	0x80089e8 <can_stm32_send+0x1c8> @ imm = #0x34
 80089b2: 2301         	movs	r3, #0x1
 80089b4: f887 3027    	strb.w	r3, [r7, #0x27]
 80089b8: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80089bc: f083 0301    	eor	r3, r3, #0x1
 80089c0: b2db         	uxtb	r3, r3
 80089c2: 2b00         	cmp	r3, #0x0
 80089c4: d110         	bne	0x80089e8 <can_stm32_send+0x1c8> @ imm = #0x20
 80089c6: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8008ad8 <can_stm32_send+0x2b8>
 80089c8: 6819         	ldr	r1, [r3]
 80089ca: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8008aec <can_stm32_send+0x2cc>
 80089cc: 9303         	str	r3, [sp, #0xc]
 80089ce: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8008afc <can_stm32_send+0x2dc>
 80089d0: 9302         	str	r3, [sp, #0x8]
 80089d2: 2308         	movs	r3, #0x8
 80089d4: 9301         	str	r3, [sp, #0x4]
 80089d6: 2300         	movs	r3, #0x0
 80089d8: 9300         	str	r3, [sp]
 80089da: 2300         	movs	r3, #0x0
 80089dc: 2204         	movs	r2, #0x4
 80089de: 2000         	movs	r0, #0x0
 80089e0: f014 fd58    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14ab0
 80089e4: 2300         	movs	r3, #0x0
 80089e6: 623b         	str	r3, [r7, #0x20]
; 		if (k_sem_take(&data->tx_int_sem, timeout)) {
 80089e8: 6bfb         	ldr	r3, [r7, #0x3c]
 80089ea: f103 0124    	add.w	r1, r3, #0x24
 80089ee: e9d7 2300    	ldrd	r2, r3, [r7]
 80089f2: 4608         	mov	r0, r1
 80089f4: f014 fc97    	bl	0x801d326 <k_sem_take>  @ imm = #0x1492e
 80089f8: 4603         	mov	r3, r0
 80089fa: 2b00         	cmp	r3, #0x0
 80089fc: d002         	beq	0x8008a04 <can_stm32_send+0x1e4> @ imm = #0x4
; 			return -EAGAIN;
 80089fe: f06f 030a    	mvn	r3, #0xa
 8008a02: e0fc         	b	0x8008bfe <can_stm32_send+0x3de> @ imm = #0x1f8
; 		k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8008a04: 6bfb         	ldr	r3, [r7, #0x3c]
 8008a06: f103 0410    	add.w	r4, r3, #0x10
 8008a0a: f04f 30ff    	mov.w	r0, #0xffffffff
 8008a0e: f04f 31ff    	mov.w	r1, #0xffffffff
 8008a12: 4602         	mov	r2, r0
 8008a14: 460b         	mov	r3, r1
 8008a16: 4620         	mov	r0, r4
 8008a18: f014 fc59    	bl	0x801d2ce <k_mutex_lock> @ imm = #0x148b2
; 		transmit_status_register = can->TSR;
 8008a1c: 6bbb         	ldr	r3, [r7, #0x38]
 8008a1e: 689b         	ldr	r3, [r3, #0x8]
 8008a20: 65bb         	str	r3, [r7, #0x58]
; 	while (!(transmit_status_register & CAN_TSR_TME)) {
 8008a22: 6dbb         	ldr	r3, [r7, #0x58]
 8008a24: f003 53e0    	and	r3, r3, #0x1c000000
 8008a28: 2b00         	cmp	r3, #0x0
 8008a2a: d0ba         	beq	0x80089a2 <can_stm32_send+0x182> @ imm = #-0x8c
; 	if (transmit_status_register & CAN_TSR_TME0) {
 8008a2c: 6dbb         	ldr	r3, [r7, #0x58]
 8008a2e: f003 6380    	and	r3, r3, #0x4000000
 8008a32: 2b00         	cmp	r3, #0x0
 8008a34: d025         	beq	0x8008a82 <can_stm32_send+0x262> @ imm = #0x4a
; 		LOG_DBG("Using TX mailbox 0");
 8008a36: 2303         	movs	r3, #0x3
 8008a38: 2b03         	cmp	r3, #0x3
 8008a3a: d91a         	bls	0x8008a72 <can_stm32_send+0x252> @ imm = #0x34
 8008a3c: 2301         	movs	r3, #0x1
 8008a3e: f887 302f    	strb.w	r3, [r7, #0x2f]
 8008a42: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8008a46: f083 0301    	eor	r3, r3, #0x1
 8008a4a: b2db         	uxtb	r3, r3
 8008a4c: 2b00         	cmp	r3, #0x0
 8008a4e: d110         	bne	0x8008a72 <can_stm32_send+0x252> @ imm = #0x20
 8008a50: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8008ad8 <can_stm32_send+0x2b8>
 8008a52: 6819         	ldr	r1, [r3]
 8008a54: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8008aec <can_stm32_send+0x2cc>
 8008a56: 9303         	str	r3, [sp, #0xc]
 8008a58: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8008b00 <can_stm32_send+0x2e0>
 8008a5a: 9302         	str	r3, [sp, #0x8]
 8008a5c: 2308         	movs	r3, #0x8
 8008a5e: 9301         	str	r3, [sp, #0x4]
 8008a60: 2300         	movs	r3, #0x0
 8008a62: 9300         	str	r3, [sp]
 8008a64: 2300         	movs	r3, #0x0
 8008a66: 2204         	movs	r2, #0x4
 8008a68: 2000         	movs	r0, #0x0
 8008a6a: f014 fd13    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14a26
 8008a6e: 2300         	movs	r3, #0x0
 8008a70: 62bb         	str	r3, [r7, #0x28]
; 		mailbox = &can->sTxMailBox[0];
 8008a72: 6bbb         	ldr	r3, [r7, #0x38]
 8008a74: f503 73c0    	add.w	r3, r3, #0x180
 8008a78: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &(data->mb0);
 8008a7a: 6bfb         	ldr	r3, [r7, #0x3c]
 8008a7c: 3334         	adds	r3, #0x34
 8008a7e: 64bb         	str	r3, [r7, #0x48]
 8008a80: e06c         	b	0x8008b5c <can_stm32_send+0x33c> @ imm = #0xd8
; 	} else if (transmit_status_register & CAN_TSR_TME1) {
 8008a82: 6dbb         	ldr	r3, [r7, #0x58]
 8008a84: f003 6300    	and	r3, r3, #0x8000000
 8008a88: 2b00         	cmp	r3, #0x0
 8008a8a: d03d         	beq	0x8008b08 <can_stm32_send+0x2e8> @ imm = #0x7a
; 		LOG_DBG("Using TX mailbox 1");
 8008a8c: 2303         	movs	r3, #0x3
 8008a8e: 2b03         	cmp	r3, #0x3
 8008a90: d91a         	bls	0x8008ac8 <can_stm32_send+0x2a8> @ imm = #0x34
 8008a92: 2301         	movs	r3, #0x1
 8008a94: f887 3037    	strb.w	r3, [r7, #0x37]
 8008a98: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8008a9c: f083 0301    	eor	r3, r3, #0x1
 8008aa0: b2db         	uxtb	r3, r3
 8008aa2: 2b00         	cmp	r3, #0x0
 8008aa4: d110         	bne	0x8008ac8 <can_stm32_send+0x2a8> @ imm = #0x20
 8008aa6: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8008ad8 <can_stm32_send+0x2b8>
 8008aa8: 6819         	ldr	r1, [r3]
 8008aaa: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8008aec <can_stm32_send+0x2cc>
 8008aac: 9303         	str	r3, [sp, #0xc]
 8008aae: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8008b04 <can_stm32_send+0x2e4>
 8008ab0: 9302         	str	r3, [sp, #0x8]
 8008ab2: 2308         	movs	r3, #0x8
 8008ab4: 9301         	str	r3, [sp, #0x4]
 8008ab6: 2300         	movs	r3, #0x0
 8008ab8: 9300         	str	r3, [sp]
 8008aba: 2300         	movs	r3, #0x0
 8008abc: 2204         	movs	r2, #0x4
 8008abe: 2000         	movs	r0, #0x0
 8008ac0: f014 fce8    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x149d0
 8008ac4: 2300         	movs	r3, #0x0
 8008ac6: 633b         	str	r3, [r7, #0x30]
; 		mailbox = &can->sTxMailBox[1];
 8008ac8: 6bbb         	ldr	r3, [r7, #0x38]
 8008aca: f503 73c8    	add.w	r3, r3, #0x190
 8008ace: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &data->mb1;
 8008ad0: 6bfb         	ldr	r3, [r7, #0x3c]
 8008ad2: 333c         	adds	r3, #0x3c
 8008ad4: 64bb         	str	r3, [r7, #0x48]
 8008ad6: e041         	b	0x8008b5c <can_stm32_send+0x33c> @ imm = #0x82

08008ad8 <$d>:
 8008ad8: 34 05 00 20  	.word	0x20000534
 8008adc: dc 8d 02 08  	.word	0x08028ddc
 8008ae0: e8 8d 02 08  	.word	0x08028de8
 8008ae4: f4 8d 02 08  	.word	0x08028df4
 8008ae8: f8 8d 02 08  	.word	0x08028df8
 8008aec: 20 a9 02 08  	.word	0x0802a920
 8008af0: fc 8d 02 08  	.word	0x08028dfc
 8008af4: 40 8e 02 08  	.word	0x08028e40
 8008af8: 60 8e 02 08  	.word	0x08028e60
 8008afc: 84 8e 02 08  	.word	0x08028e84
 8008b00: a0 8e 02 08  	.word	0x08028ea0
 8008b04: b8 8e 02 08  	.word	0x08028eb8

08008b08 <$t>:
; 	} else if (transmit_status_register & CAN_TSR_TME2) {
 8008b08: 6dbb         	ldr	r3, [r7, #0x58]
 8008b0a: f003 5380    	and	r3, r3, #0x10000000
 8008b0e: 2b00         	cmp	r3, #0x0
 8008b10: d024         	beq	0x8008b5c <can_stm32_send+0x33c> @ imm = #0x48
; 		LOG_DBG("Using TX mailbox 2");
 8008b12: 2303         	movs	r3, #0x3
 8008b14: 2b03         	cmp	r3, #0x3
 8008b16: d91a         	bls	0x8008b4e <can_stm32_send+0x32e> @ imm = #0x34
 8008b18: 2301         	movs	r3, #0x1
 8008b1a: f887 3057    	strb.w	r3, [r7, #0x57]
 8008b1e: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8008b22: f083 0301    	eor	r3, r3, #0x1
 8008b26: b2db         	uxtb	r3, r3
 8008b28: 2b00         	cmp	r3, #0x0
 8008b2a: d110         	bne	0x8008b4e <can_stm32_send+0x32e> @ imm = #0x20
 8008b2c: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8008c08 <can_stm32_send+0x3e8>
 8008b2e: 6819         	ldr	r1, [r3]
 8008b30: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8008c0c <can_stm32_send+0x3ec>
 8008b32: 9303         	str	r3, [sp, #0xc]
 8008b34: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8008c10 <can_stm32_send+0x3f0>
 8008b36: 9302         	str	r3, [sp, #0x8]
 8008b38: 2308         	movs	r3, #0x8
 8008b3a: 9301         	str	r3, [sp, #0x4]
 8008b3c: 2300         	movs	r3, #0x0
 8008b3e: 9300         	str	r3, [sp]
 8008b40: 2300         	movs	r3, #0x0
 8008b42: 2204         	movs	r2, #0x4
 8008b44: 2000         	movs	r0, #0x0
 8008b46: f014 fca5    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x1494a
 8008b4a: 2300         	movs	r3, #0x0
 8008b4c: 653b         	str	r3, [r7, #0x50]
; 		mailbox = &can->sTxMailBox[2];
 8008b4e: 6bbb         	ldr	r3, [r7, #0x38]
 8008b50: f503 73d0    	add.w	r3, r3, #0x1a0
 8008b54: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &data->mb2;
 8008b56: 6bfb         	ldr	r3, [r7, #0x3c]
 8008b58: 3344         	adds	r3, #0x44
 8008b5a: 64bb         	str	r3, [r7, #0x48]
; 	mb->tx_callback = callback;
 8008b5c: 6cbb         	ldr	r3, [r7, #0x48]
 8008b5e: 6f3a         	ldr	r2, [r7, #0x70]
 8008b60: 601a         	str	r2, [r3]
; 	mb->callback_arg = user_data;
 8008b62: 6cbb         	ldr	r3, [r7, #0x48]
 8008b64: 6f7a         	ldr	r2, [r7, #0x74]
 8008b66: 605a         	str	r2, [r3, #0x4]
; 	mailbox->TIR &= CAN_TI0R_TXRQ;
 8008b68: 6cfb         	ldr	r3, [r7, #0x4c]
 8008b6a: 681b         	ldr	r3, [r3]
 8008b6c: f003 0201    	and	r2, r3, #0x1
 8008b70: 6cfb         	ldr	r3, [r7, #0x4c]
 8008b72: 601a         	str	r2, [r3]
; 	if ((frame->flags & CAN_FRAME_IDE) != 0) {
 8008b74: 68bb         	ldr	r3, [r7, #0x8]
 8008b76: 795b         	ldrb	r3, [r3, #0x5]
 8008b78: f003 0301    	and	r3, r3, #0x1
 8008b7c: 2b00         	cmp	r3, #0x0
 8008b7e: d00a         	beq	0x8008b96 <can_stm32_send+0x376> @ imm = #0x14
; 		mailbox->TIR |= (frame->id << CAN_TI0R_EXID_Pos) | CAN_TI0R_IDE;
 8008b80: 6cfb         	ldr	r3, [r7, #0x4c]
 8008b82: 681a         	ldr	r2, [r3]
 8008b84: 68bb         	ldr	r3, [r7, #0x8]
 8008b86: 681b         	ldr	r3, [r3]
 8008b88: 00db         	lsls	r3, r3, #0x3
 8008b8a: 4313         	orrs	r3, r2
 8008b8c: f043 0204    	orr	r2, r3, #0x4
 8008b90: 6cfb         	ldr	r3, [r7, #0x4c]
 8008b92: 601a         	str	r2, [r3]
 8008b94: e007         	b	0x8008ba6 <can_stm32_send+0x386> @ imm = #0xe
; 		mailbox->TIR |= (frame->id << CAN_TI0R_STID_Pos);
 8008b96: 6cfb         	ldr	r3, [r7, #0x4c]
 8008b98: 681a         	ldr	r2, [r3]
 8008b9a: 68bb         	ldr	r3, [r7, #0x8]
 8008b9c: 681b         	ldr	r3, [r3]
 8008b9e: 055b         	lsls	r3, r3, #0x15
 8008ba0: 431a         	orrs	r2, r3
 8008ba2: 6cfb         	ldr	r3, [r7, #0x4c]
 8008ba4: 601a         	str	r2, [r3]
; 	if ((frame->flags & CAN_FRAME_RTR) != 0) {
 8008ba6: 68bb         	ldr	r3, [r7, #0x8]
 8008ba8: 795b         	ldrb	r3, [r3, #0x5]
 8008baa: f003 0302    	and	r3, r3, #0x2
 8008bae: 2b00         	cmp	r3, #0x0
 8008bb0: d006         	beq	0x8008bc0 <can_stm32_send+0x3a0> @ imm = #0xc
; 		mailbox->TIR |= CAN_TI1R_RTR;
 8008bb2: 6cfb         	ldr	r3, [r7, #0x4c]
 8008bb4: 681b         	ldr	r3, [r3]
 8008bb6: f043 0202    	orr	r2, r3, #0x2
 8008bba: 6cfb         	ldr	r3, [r7, #0x4c]
 8008bbc: 601a         	str	r2, [r3]
 8008bbe: e007         	b	0x8008bd0 <can_stm32_send+0x3b0> @ imm = #0xe
; 		mailbox->TDLR = frame->data_32[0];
 8008bc0: 68bb         	ldr	r3, [r7, #0x8]
 8008bc2: 689a         	ldr	r2, [r3, #0x8]
 8008bc4: 6cfb         	ldr	r3, [r7, #0x4c]
 8008bc6: 609a         	str	r2, [r3, #0x8]
; 		mailbox->TDHR = frame->data_32[1];
 8008bc8: 68bb         	ldr	r3, [r7, #0x8]
 8008bca: 68da         	ldr	r2, [r3, #0xc]
 8008bcc: 6cfb         	ldr	r3, [r7, #0x4c]
 8008bce: 60da         	str	r2, [r3, #0xc]
; 		(mailbox->TDTR & ~CAN_TDT1R_DLC) | ((frame->dlc & 0xF) << CAN_TDT1R_DLC_Pos);
 8008bd0: 6cfb         	ldr	r3, [r7, #0x4c]
 8008bd2: 685b         	ldr	r3, [r3, #0x4]
 8008bd4: f023 020f    	bic	r2, r3, #0xf
 8008bd8: 68bb         	ldr	r3, [r7, #0x8]
 8008bda: 791b         	ldrb	r3, [r3, #0x4]
 8008bdc: f003 030f    	and	r3, r3, #0xf
 8008be0: 431a         	orrs	r2, r3
; 	mailbox->TDTR =
 8008be2: 6cfb         	ldr	r3, [r7, #0x4c]
 8008be4: 605a         	str	r2, [r3, #0x4]
; 	mailbox->TIR |= CAN_TI0R_TXRQ;
 8008be6: 6cfb         	ldr	r3, [r7, #0x4c]
 8008be8: 681b         	ldr	r3, [r3]
 8008bea: f043 0201    	orr	r2, r3, #0x1
 8008bee: 6cfb         	ldr	r3, [r7, #0x4c]
 8008bf0: 601a         	str	r2, [r3]
; 	k_mutex_unlock(&data->inst_mutex);
 8008bf2: 6bfb         	ldr	r3, [r7, #0x3c]
 8008bf4: 3310         	adds	r3, #0x10
 8008bf6: 4618         	mov	r0, r3
 8008bf8: f014 fb79    	bl	0x801d2ee <k_mutex_unlock> @ imm = #0x146f2
; 	return 0;
 8008bfc: 2300         	movs	r3, #0x0
; }
 8008bfe: 4618         	mov	r0, r3
 8008c00: 3760         	adds	r7, #0x60
 8008c02: 46bd         	mov	sp, r7
 8008c04: bdb0         	pop	{r4, r5, r7, pc}
 8008c06: bf00         	nop

08008c08 <$d>:
 8008c08: 34 05 00 20  	.word	0x20000534
 8008c0c: 20 a9 02 08  	.word	0x0802a920
 8008c10: d0 8e 02 08  	.word	0x08028ed0

08008c14 <can_stm32_set_filter>:
; {
 8008c14: b580         	push	{r7, lr}
 8008c16: b098         	sub	sp, #0x60
 8008c18: af08         	add	r7, sp, #0x20
 8008c1a: 6078         	str	r0, [r7, #0x4]
 8008c1c: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8008c1e: 687b         	ldr	r3, [r7, #0x4]
 8008c20: 685b         	ldr	r3, [r3, #0x4]
 8008c22: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 8008c24: 687b         	ldr	r3, [r7, #0x4]
 8008c26: 691b         	ldr	r3, [r3, #0x10]
 8008c28: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->master_can;
 8008c2a: 6a3b         	ldr	r3, [r7, #0x20]
 8008c2c: 699b         	ldr	r3, [r3, #0x18]
 8008c2e: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t mask = 0U;
 8008c30: 2300         	movs	r3, #0x0
 8008c32: 62fb         	str	r3, [r7, #0x2c]
; 	uint32_t id = 0U;
 8008c34: 2300         	movs	r3, #0x0
 8008c36: 633b         	str	r3, [r7, #0x30]
; 	int filter_id = -ENOSPC;
 8008c38: f06f 031b    	mvn	r3, #0x1b
 8008c3c: 63fb         	str	r3, [r7, #0x3c]
; 	int bank_offset = 0;
 8008c3e: 2300         	movs	r3, #0x0
 8008c40: 63bb         	str	r3, [r7, #0x38]
; 	if (cfg->can != cfg->master_can) {
 8008c42: 6a3b         	ldr	r3, [r7, #0x20]
 8008c44: 695a         	ldr	r2, [r3, #0x14]
 8008c46: 6a3b         	ldr	r3, [r7, #0x20]
 8008c48: 699b         	ldr	r3, [r3, #0x18]
 8008c4a: 429a         	cmp	r2, r3
 8008c4c: d001         	beq	0x8008c52 <can_stm32_set_filter+0x3e> @ imm = #0x2
; 		bank_offset = CAN_STM32_NUM_FILTER_BANKS;
 8008c4e: 230e         	movs	r3, #0xe
 8008c50: 63bb         	str	r3, [r7, #0x38]
; 	if ((filter->flags & CAN_FILTER_IDE) != 0) {
 8008c52: 683b         	ldr	r3, [r7]
 8008c54: 7a1b         	ldrb	r3, [r3, #0x8]
 8008c56: f003 0301    	and	r3, r3, #0x1
 8008c5a: 2b00         	cmp	r3, #0x0
 8008c5c: d020         	beq	0x8008ca0 <can_stm32_set_filter+0x8c> @ imm = #0x40
; 		for (int i = 0; i < CONFIG_CAN_MAX_EXT_ID_FILTER; i++) {
 8008c5e: 2300         	movs	r3, #0x0
 8008c60: 62bb         	str	r3, [r7, #0x28]
 8008c62: e019         	b	0x8008c98 <can_stm32_set_filter+0x84> @ imm = #0x32
; 			if (data->rx_cb_ext[i] == NULL) {
 8008c64: 69fa         	ldr	r2, [r7, #0x1c]
 8008c66: 6abb         	ldr	r3, [r7, #0x28]
 8008c68: 3320         	adds	r3, #0x20
 8008c6a: 009b         	lsls	r3, r3, #0x2
 8008c6c: 4413         	add	r3, r2
 8008c6e: 685b         	ldr	r3, [r3, #0x4]
 8008c70: 2b00         	cmp	r3, #0x0
 8008c72: d10e         	bne	0x8008c92 <can_stm32_set_filter+0x7e> @ imm = #0x1c
; 				id = can_stm32_filter_to_ext_id(filter);
 8008c74: 6838         	ldr	r0, [r7]
 8008c76: f014 feb3    	bl	0x801d9e0 <can_stm32_filter_to_ext_id> @ imm = #0x14d66
 8008c7a: 6338         	str	r0, [r7, #0x30]
; 				mask = can_stm32_filter_to_ext_mask(filter);
 8008c7c: 6838         	ldr	r0, [r7]
 8008c7e: f014 fe8e    	bl	0x801d99e <can_stm32_filter_to_ext_mask> @ imm = #0x14d1c
 8008c82: 62f8         	str	r0, [r7, #0x2c]
; 				filter_id = i;
 8008c84: 6abb         	ldr	r3, [r7, #0x28]
 8008c86: 63fb         	str	r3, [r7, #0x3c]
; 				bank_num = bank_offset + i;
 8008c88: 6bba         	ldr	r2, [r7, #0x38]
 8008c8a: 6abb         	ldr	r3, [r7, #0x28]
 8008c8c: 4413         	add	r3, r2
 8008c8e: 637b         	str	r3, [r7, #0x34]
; 				break;
 8008c90: e02b         	b	0x8008cea <can_stm32_set_filter+0xd6> @ imm = #0x56
; 		for (int i = 0; i < CONFIG_CAN_MAX_EXT_ID_FILTER; i++) {
 8008c92: 6abb         	ldr	r3, [r7, #0x28]
 8008c94: 3301         	adds	r3, #0x1
 8008c96: 62bb         	str	r3, [r7, #0x28]
 8008c98: 6abb         	ldr	r3, [r7, #0x28]
 8008c9a: 2b06         	cmp	r3, #0x6
 8008c9c: dde2         	ble	0x8008c64 <can_stm32_set_filter+0x50> @ imm = #-0x3c
 8008c9e: e024         	b	0x8008cea <can_stm32_set_filter+0xd6> @ imm = #0x48
; 		for (int i = 0; i < CONFIG_CAN_MAX_STD_ID_FILTER; i++) {
 8008ca0: 2300         	movs	r3, #0x0
 8008ca2: 627b         	str	r3, [r7, #0x24]
 8008ca4: e01e         	b	0x8008ce4 <can_stm32_set_filter+0xd0> @ imm = #0x3c
; 			if (data->rx_cb_std[i] == NULL) {
 8008ca6: 69fa         	ldr	r2, [r7, #0x1c]
 8008ca8: 6a7b         	ldr	r3, [r7, #0x24]
 8008caa: 3312         	adds	r3, #0x12
 8008cac: 009b         	lsls	r3, r3, #0x2
 8008cae: 4413         	add	r3, r2
 8008cb0: 685b         	ldr	r3, [r3, #0x4]
 8008cb2: 2b00         	cmp	r3, #0x0
 8008cb4: d113         	bne	0x8008cde <can_stm32_set_filter+0xca> @ imm = #0x26
; 				id = can_stm32_filter_to_std_id(filter);
 8008cb6: 6838         	ldr	r0, [r7]
 8008cb8: f014 fe85    	bl	0x801d9c6 <can_stm32_filter_to_std_id> @ imm = #0x14d0a
 8008cbc: 6338         	str	r0, [r7, #0x30]
; 				mask = can_stm32_filter_to_std_mask(filter);
 8008cbe: 6838         	ldr	r0, [r7]
 8008cc0: f014 fe59    	bl	0x801d976 <can_stm32_filter_to_std_mask> @ imm = #0x14cb2
 8008cc4: 62f8         	str	r0, [r7, #0x2c]
; 				filter_id = CONFIG_CAN_MAX_EXT_ID_FILTER + i;
 8008cc6: 6a7b         	ldr	r3, [r7, #0x24]
 8008cc8: 3307         	adds	r3, #0x7
 8008cca: 63fb         	str	r3, [r7, #0x3c]
; 				bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER + i / 2;
 8008ccc: 6bbb         	ldr	r3, [r7, #0x38]
 8008cce: 1dda         	adds	r2, r3, #0x7
 8008cd0: 6a7b         	ldr	r3, [r7, #0x24]
 8008cd2: 0fd9         	lsrs	r1, r3, #0x1f
 8008cd4: 440b         	add	r3, r1
 8008cd6: 105b         	asrs	r3, r3, #0x1
 8008cd8: 4413         	add	r3, r2
 8008cda: 637b         	str	r3, [r7, #0x34]
; 				break;
 8008cdc: e005         	b	0x8008cea <can_stm32_set_filter+0xd6> @ imm = #0xa
; 		for (int i = 0; i < CONFIG_CAN_MAX_STD_ID_FILTER; i++) {
 8008cde: 6a7b         	ldr	r3, [r7, #0x24]
 8008ce0: 3301         	adds	r3, #0x1
 8008ce2: 627b         	str	r3, [r7, #0x24]
 8008ce4: 6a7b         	ldr	r3, [r7, #0x24]
 8008ce6: 2b0d         	cmp	r3, #0xd
 8008ce8: dddd         	ble	0x8008ca6 <can_stm32_set_filter+0x92> @ imm = #-0x46
; 	if (filter_id != -ENOSPC) {
 8008cea: 6bfb         	ldr	r3, [r7, #0x3c]
 8008cec: f113 0f1c    	cmn.w	r3, #0x1c
 8008cf0: d053         	beq	0x8008d9a <can_stm32_set_filter+0x186> @ imm = #0xa6
; 		LOG_DBG("Adding filter_id %d, CAN ID: 0x%x, mask: 0x%x", filter_id, filter->id,
 8008cf2: 2303         	movs	r3, #0x3
 8008cf4: 2b03         	cmp	r3, #0x3
 8008cf6: d920         	bls	0x8008d3a <can_stm32_set_filter+0x126> @ imm = #0x40
 8008cf8: 2301         	movs	r3, #0x1
 8008cfa: 73fb         	strb	r3, [r7, #0xf]
 8008cfc: 7bfb         	ldrb	r3, [r7, #0xf]
 8008cfe: f083 0301    	eor	r3, r3, #0x1
 8008d02: b2db         	uxtb	r3, r3
 8008d04: 2b00         	cmp	r3, #0x0
 8008d06: d118         	bne	0x8008d3a <can_stm32_set_filter+0x126> @ imm = #0x30
 8008d08: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8008dd8 <can_stm32_set_filter+0x1c4>
 8008d0a: 6819         	ldr	r1, [r3]
 8008d0c: 683b         	ldr	r3, [r7]
 8008d0e: 681b         	ldr	r3, [r3]
 8008d10: 683a         	ldr	r2, [r7]
 8008d12: 6852         	ldr	r2, [r2, #0x4]
 8008d14: 9206         	str	r2, [sp, #0x18]
 8008d16: 9305         	str	r3, [sp, #0x14]
 8008d18: 6bfb         	ldr	r3, [r7, #0x3c]
 8008d1a: 9304         	str	r3, [sp, #0x10]
 8008d1c: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8008ddc <can_stm32_set_filter+0x1c8>
 8008d1e: 9303         	str	r3, [sp, #0xc]
 8008d20: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8008de0 <can_stm32_set_filter+0x1cc>
 8008d22: 9302         	str	r3, [sp, #0x8]
 8008d24: 2308         	movs	r3, #0x8
 8008d26: 9301         	str	r3, [sp, #0x4]
 8008d28: 2300         	movs	r3, #0x0
 8008d2a: 9300         	str	r3, [sp]
 8008d2c: 2300         	movs	r3, #0x0
 8008d2e: 2204         	movs	r2, #0x4
 8008d30: 2000         	movs	r0, #0x0
 8008d32: f014 fbaf    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x1475e
 8008d36: 2300         	movs	r3, #0x0
 8008d38: 60bb         	str	r3, [r7, #0x8]
; 		can->FMR |= CAN_FMR_FINIT;
 8008d3a: 69bb         	ldr	r3, [r7, #0x18]
 8008d3c: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 8008d40: f043 0201    	orr	r2, r3, #0x1
 8008d44: 69bb         	ldr	r3, [r7, #0x18]
 8008d46: f8c3 2200    	str.w	r2, [r3, #0x200]
; 		can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num],
 8008d4a: 6b7b         	ldr	r3, [r7, #0x34]
 8008d4c: 3348         	adds	r3, #0x48
 8008d4e: 00db         	lsls	r3, r3, #0x3
 8008d50: 69ba         	ldr	r2, [r7, #0x18]
 8008d52: 18d1         	adds	r1, r2, r3
; 					  (filter->flags & CAN_FILTER_IDE) != 0, id, mask);
 8008d54: 683b         	ldr	r3, [r7]
 8008d56: 7a1b         	ldrb	r3, [r3, #0x8]
 8008d58: f003 0301    	and	r3, r3, #0x1
; 		can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num],
 8008d5c: 2b00         	cmp	r3, #0x0
 8008d5e: bf14         	ite	ne
 8008d60: 2301         	movne	r3, #0x1
 8008d62: 2300         	moveq	r3, #0x0
 8008d64: b2da         	uxtb	r2, r3
 8008d66: 6afb         	ldr	r3, [r7, #0x2c]
 8008d68: 9300         	str	r3, [sp]
 8008d6a: 6b3b         	ldr	r3, [r7, #0x30]
 8008d6c: 6bf8         	ldr	r0, [r7, #0x3c]
 8008d6e: f014 fdd7    	bl	0x801d920 <can_stm32_set_filter_bank> @ imm = #0x14bae
; 		can->FA1R |= 1U << bank_num;
 8008d72: 69bb         	ldr	r3, [r7, #0x18]
 8008d74: f8d3 221c    	ldr.w	r2, [r3, #0x21c]
 8008d78: 2101         	movs	r1, #0x1
 8008d7a: 6b7b         	ldr	r3, [r7, #0x34]
 8008d7c: fa01 f303    	lsl.w	r3, r1, r3
 8008d80: 431a         	orrs	r2, r3
 8008d82: 69bb         	ldr	r3, [r7, #0x18]
 8008d84: f8c3 221c    	str.w	r2, [r3, #0x21c]
; 		can->FMR &= ~(CAN_FMR_FINIT);
 8008d88: 69bb         	ldr	r3, [r7, #0x18]
 8008d8a: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 8008d8e: f023 0201    	bic	r2, r3, #0x1
 8008d92: 69bb         	ldr	r3, [r7, #0x18]
 8008d94: f8c3 2200    	str.w	r2, [r3, #0x200]
 8008d98: e019         	b	0x8008dce <can_stm32_set_filter+0x1ba> @ imm = #0x32
; 		LOG_WRN("No free filter left");
 8008d9a: 2303         	movs	r3, #0x3
 8008d9c: 2b01         	cmp	r3, #0x1
 8008d9e: d916         	bls	0x8008dce <can_stm32_set_filter+0x1ba> @ imm = #0x2c
 8008da0: 2301         	movs	r3, #0x1
 8008da2: 75fb         	strb	r3, [r7, #0x17]
 8008da4: 7dfb         	ldrb	r3, [r7, #0x17]
 8008da6: f083 0301    	eor	r3, r3, #0x1
 8008daa: b2db         	uxtb	r3, r3
 8008dac: 2b00         	cmp	r3, #0x0
 8008dae: d10e         	bne	0x8008dce <can_stm32_set_filter+0x1ba> @ imm = #0x1c
 8008db0: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8008dd8 <can_stm32_set_filter+0x1c4>
 8008db2: 6819         	ldr	r1, [r3]
 8008db4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008de4 <can_stm32_set_filter+0x1d0>
 8008db6: 9302         	str	r3, [sp, #0x8]
 8008db8: 2300         	movs	r3, #0x0
 8008dba: 9301         	str	r3, [sp, #0x4]
 8008dbc: 2300         	movs	r3, #0x0
 8008dbe: 9300         	str	r3, [sp]
 8008dc0: 2300         	movs	r3, #0x0
 8008dc2: 2202         	movs	r2, #0x2
 8008dc4: 2000         	movs	r0, #0x0
 8008dc6: f014 fb65    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x146ca
 8008dca: 2300         	movs	r3, #0x0
 8008dcc: 613b         	str	r3, [r7, #0x10]
; 	return filter_id;
 8008dce: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 8008dd0: 4618         	mov	r0, r3
 8008dd2: 3740         	adds	r7, #0x40
 8008dd4: 46bd         	mov	sp, r7
 8008dd6: bd80         	pop	{r7, pc}

08008dd8 <$d>:
 8008dd8: 34 05 00 20  	.word	0x20000534
 8008ddc: 30 a9 02 08  	.word	0x0802a930
 8008de0: e8 8e 02 08  	.word	0x08028ee8
 8008de4: 1c 8f 02 08  	.word	0x08028f1c

08008de8 <can_stm32_add_rx_filter>:
; {
 8008de8: b580         	push	{r7, lr}
 8008dea: b08c         	sub	sp, #0x30
 8008dec: af04         	add	r7, sp, #0x10
 8008dee: 60f8         	str	r0, [r7, #0xc]
 8008df0: 60b9         	str	r1, [r7, #0x8]
 8008df2: 607a         	str	r2, [r7, #0x4]
 8008df4: 603b         	str	r3, [r7]
; 	struct can_stm32_data *data = dev->data;
 8008df6: 68fb         	ldr	r3, [r7, #0xc]
 8008df8: 691b         	ldr	r3, [r3, #0x10]
 8008dfa: 61fb         	str	r3, [r7, #0x1c]
; 	if ((filter->flags & ~(CAN_FILTER_IDE)) != 0) {
 8008dfc: 683b         	ldr	r3, [r7]
 8008dfe: 7a1b         	ldrb	r3, [r3, #0x8]
 8008e00: 2b01         	cmp	r3, #0x1
 8008e02: d91f         	bls	0x8008e44 <can_stm32_add_rx_filter+0x5c> @ imm = #0x3e
; 		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
 8008e04: 2303         	movs	r3, #0x3
 8008e06: 2b00         	cmp	r3, #0x0
 8008e08: d019         	beq	0x8008e3e <can_stm32_add_rx_filter+0x56> @ imm = #0x32
 8008e0a: 2301         	movs	r3, #0x1
 8008e0c: 75fb         	strb	r3, [r7, #0x17]
 8008e0e: 7dfb         	ldrb	r3, [r7, #0x17]
 8008e10: f083 0301    	eor	r3, r3, #0x1
 8008e14: b2db         	uxtb	r3, r3
 8008e16: 2b00         	cmp	r3, #0x0
 8008e18: d111         	bne	0x8008e3e <can_stm32_add_rx_filter+0x56> @ imm = #0x22
 8008e1a: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8008ed8 <can_stm32_add_rx_filter+0xf0>
 8008e1c: 6819         	ldr	r1, [r3]
 8008e1e: 683b         	ldr	r3, [r7]
 8008e20: 7a1b         	ldrb	r3, [r3, #0x8]
 8008e22: 9303         	str	r3, [sp, #0xc]
 8008e24: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8008edc <can_stm32_add_rx_filter+0xf4>
 8008e26: 9302         	str	r3, [sp, #0x8]
 8008e28: 2300         	movs	r3, #0x0
 8008e2a: 9301         	str	r3, [sp, #0x4]
 8008e2c: 2300         	movs	r3, #0x0
 8008e2e: 9300         	str	r3, [sp]
 8008e30: 2300         	movs	r3, #0x0
 8008e32: 2201         	movs	r2, #0x1
 8008e34: 2000         	movs	r0, #0x0
 8008e36: f014 fb2d    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x1465a
 8008e3a: 2300         	movs	r3, #0x0
 8008e3c: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 8008e3e: f06f 0185    	mvn	r1, #0x85
 8008e42: e044         	b	0x8008ece <can_stm32_add_rx_filter+0xe6> @ imm = #0x88
; 	k_mutex_lock(&filter_mutex, K_FOREVER);
 8008e44: f04f 32ff    	mov.w	r2, #0xffffffff
 8008e48: f04f 33ff    	mov.w	r3, #0xffffffff
 8008e4c: 4824         	ldr	r0, [pc, #0x90]         @ 0x8008ee0 <can_stm32_add_rx_filter+0xf8>
 8008e4e: f014 fa3e    	bl	0x801d2ce <k_mutex_lock> @ imm = #0x1447c
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8008e52: 69fb         	ldr	r3, [r7, #0x1c]
 8008e54: f103 0110    	add.w	r1, r3, #0x10
 8008e58: f04f 32ff    	mov.w	r2, #0xffffffff
 8008e5c: f04f 33ff    	mov.w	r3, #0xffffffff
 8008e60: 4608         	mov	r0, r1
 8008e62: f014 fa34    	bl	0x801d2ce <k_mutex_lock> @ imm = #0x14468
; 	filter_id = can_stm32_set_filter(dev, filter);
 8008e66: 6839         	ldr	r1, [r7]
 8008e68: 68f8         	ldr	r0, [r7, #0xc]
 8008e6a: f7ff fed3    	bl	0x8008c14 <can_stm32_set_filter> @ imm = #-0x25a
 8008e6e: 61b8         	str	r0, [r7, #0x18]
; 	if (filter_id >= 0) {
 8008e70: 69bb         	ldr	r3, [r7, #0x18]
 8008e72: 2b00         	cmp	r3, #0x0
 8008e74: db22         	blt	0x8008ebc <can_stm32_add_rx_filter+0xd4> @ imm = #0x44
; 		if ((filter->flags & CAN_FILTER_IDE) != 0) {
 8008e76: 683b         	ldr	r3, [r7]
 8008e78: 7a1b         	ldrb	r3, [r3, #0x8]
 8008e7a: f003 0301    	and	r3, r3, #0x1
 8008e7e: 2b00         	cmp	r3, #0x0
 8008e80: d00d         	beq	0x8008e9e <can_stm32_add_rx_filter+0xb6> @ imm = #0x1a
; 			data->rx_cb_ext[filter_id] = cb;
 8008e82: 69fa         	ldr	r2, [r7, #0x1c]
 8008e84: 69bb         	ldr	r3, [r7, #0x18]
 8008e86: 3320         	adds	r3, #0x20
 8008e88: 009b         	lsls	r3, r3, #0x2
 8008e8a: 4413         	add	r3, r2
 8008e8c: 68ba         	ldr	r2, [r7, #0x8]
 8008e8e: 605a         	str	r2, [r3, #0x4]
; 			data->cb_arg_ext[filter_id] = cb_arg;
 8008e90: 69fb         	ldr	r3, [r7, #0x1c]
 8008e92: 69ba         	ldr	r2, [r7, #0x18]
 8008e94: 3236         	adds	r2, #0x36
 8008e96: 6879         	ldr	r1, [r7, #0x4]
 8008e98: f843 1022    	str.w	r1, [r3, r2, lsl #2]
 8008e9c: e00e         	b	0x8008ebc <can_stm32_add_rx_filter+0xd4> @ imm = #0x1c
; 			data->rx_cb_std[filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER] = cb;
 8008e9e: 69bb         	ldr	r3, [r7, #0x18]
 8008ea0: 3b07         	subs	r3, #0x7
 8008ea2: 69fa         	ldr	r2, [r7, #0x1c]
 8008ea4: 3312         	adds	r3, #0x12
 8008ea6: 009b         	lsls	r3, r3, #0x2
 8008ea8: 4413         	add	r3, r2
 8008eaa: 68ba         	ldr	r2, [r7, #0x8]
 8008eac: 605a         	str	r2, [r3, #0x4]
; 			data->cb_arg_std[filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER] = cb_arg;
 8008eae: 69bb         	ldr	r3, [r7, #0x18]
 8008eb0: 1fda         	subs	r2, r3, #0x7
 8008eb2: 69fb         	ldr	r3, [r7, #0x1c]
 8008eb4: 3228         	adds	r2, #0x28
 8008eb6: 6879         	ldr	r1, [r7, #0x4]
 8008eb8: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 	k_mutex_unlock(&data->inst_mutex);
 8008ebc: 69fb         	ldr	r3, [r7, #0x1c]
 8008ebe: 3310         	adds	r3, #0x10
 8008ec0: 4618         	mov	r0, r3
 8008ec2: f014 fa14    	bl	0x801d2ee <k_mutex_unlock> @ imm = #0x14428
; 	k_mutex_unlock(&filter_mutex);
 8008ec6: 4806         	ldr	r0, [pc, #0x18]         @ 0x8008ee0 <can_stm32_add_rx_filter+0xf8>
 8008ec8: f014 fa11    	bl	0x801d2ee <k_mutex_unlock> @ imm = #0x14422
; 	return filter_id;
 8008ecc: 69b9         	ldr	r1, [r7, #0x18]
; }
 8008ece: 460b         	mov	r3, r1
 8008ed0: 4618         	mov	r0, r3
 8008ed2: 3720         	adds	r7, #0x20
 8008ed4: 46bd         	mov	sp, r7
 8008ed6: bd80         	pop	{r7, pc}

08008ed8 <$d>:
 8008ed8: 34 05 00 20  	.word	0x20000534
 8008edc: 30 8f 02 08  	.word	0x08028f30
 8008ee0: bc 2d 00 20  	.word	0x20002dbc

08008ee4 <can_stm32_remove_rx_filter>:
; {
 8008ee4: b580         	push	{r7, lr}
 8008ee6: b096         	sub	sp, #0x58
 8008ee8: af06         	add	r7, sp, #0x18
 8008eea: 6078         	str	r0, [r7, #0x4]
 8008eec: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8008eee: 687b         	ldr	r3, [r7, #0x4]
 8008ef0: 685b         	ldr	r3, [r3, #0x4]
 8008ef2: 62fb         	str	r3, [r7, #0x2c]
; 	struct can_stm32_data *data = dev->data;
 8008ef4: 687b         	ldr	r3, [r7, #0x4]
 8008ef6: 691b         	ldr	r3, [r3, #0x10]
 8008ef8: 62bb         	str	r3, [r7, #0x28]
; 	CAN_TypeDef *can = cfg->master_can;
 8008efa: 6afb         	ldr	r3, [r7, #0x2c]
 8008efc: 699b         	ldr	r3, [r3, #0x18]
 8008efe: 627b         	str	r3, [r7, #0x24]
; 	int bank_offset = 0;
 8008f00: 2300         	movs	r3, #0x0
 8008f02: 633b         	str	r3, [r7, #0x30]
; 	if (filter_id < 0 || filter_id >= CAN_STM32_MAX_FILTER_ID) {
 8008f04: 683b         	ldr	r3, [r7]
 8008f06: 2b00         	cmp	r3, #0x0
 8008f08: db02         	blt	0x8008f10 <can_stm32_remove_rx_filter+0x2c> @ imm = #0x4
 8008f0a: 683b         	ldr	r3, [r7]
 8008f0c: 2b22         	cmp	r3, #0x22
 8008f0e: dd1e         	ble	0x8008f4e <can_stm32_remove_rx_filter+0x6a> @ imm = #0x3c
; 		LOG_ERR("filter ID %d out of bounds", filter_id);
 8008f10: 2303         	movs	r3, #0x3
 8008f12: 2b00         	cmp	r3, #0x0
 8008f14: f000 810a    	beq.w	0x800912c <can_stm32_remove_rx_filter+0x248> @ imm = #0x214
 8008f18: 2301         	movs	r3, #0x1
 8008f1a: 73fb         	strb	r3, [r7, #0xf]
 8008f1c: 7bfb         	ldrb	r3, [r7, #0xf]
 8008f1e: f083 0301    	eor	r3, r3, #0x1
 8008f22: b2db         	uxtb	r3, r3
 8008f24: 2b00         	cmp	r3, #0x0
 8008f26: f040 8101    	bne.w	0x800912c <can_stm32_remove_rx_filter+0x248> @ imm = #0x202
 8008f2a: 4b82         	ldr	r3, [pc, #0x208]        @ 0x8009134 <can_stm32_remove_rx_filter+0x250>
 8008f2c: 6819         	ldr	r1, [r3]
 8008f2e: 683b         	ldr	r3, [r7]
 8008f30: 9303         	str	r3, [sp, #0xc]
 8008f32: 4b81         	ldr	r3, [pc, #0x204]        @ 0x8009138 <can_stm32_remove_rx_filter+0x254>
 8008f34: 9302         	str	r3, [sp, #0x8]
 8008f36: 2300         	movs	r3, #0x0
 8008f38: 9301         	str	r3, [sp, #0x4]
 8008f3a: 2300         	movs	r3, #0x0
 8008f3c: 9300         	str	r3, [sp]
 8008f3e: 2300         	movs	r3, #0x0
 8008f40: 2201         	movs	r2, #0x1
 8008f42: 2000         	movs	r0, #0x0
 8008f44: f014 faa6    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x1454c
 8008f48: 2300         	movs	r3, #0x0
 8008f4a: 60bb         	str	r3, [r7, #0x8]
 8008f4c: e0ee         	b	0x800912c <can_stm32_remove_rx_filter+0x248> @ imm = #0x1dc
; 	k_mutex_lock(&filter_mutex, K_FOREVER);
 8008f4e: f04f 32ff    	mov.w	r2, #0xffffffff
 8008f52: f04f 33ff    	mov.w	r3, #0xffffffff
 8008f56: 4879         	ldr	r0, [pc, #0x1e4]        @ 0x800913c <can_stm32_remove_rx_filter+0x258>
 8008f58: f014 f9b9    	bl	0x801d2ce <k_mutex_lock> @ imm = #0x14372
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8008f5c: 6abb         	ldr	r3, [r7, #0x28]
 8008f5e: f103 0110    	add.w	r1, r3, #0x10
 8008f62: f04f 32ff    	mov.w	r2, #0xffffffff
 8008f66: f04f 33ff    	mov.w	r3, #0xffffffff
 8008f6a: 4608         	mov	r0, r1
 8008f6c: f014 f9af    	bl	0x801d2ce <k_mutex_lock> @ imm = #0x1435e
; 	if (cfg->can != cfg->master_can) {
 8008f70: 6afb         	ldr	r3, [r7, #0x2c]
 8008f72: 695a         	ldr	r2, [r3, #0x14]
 8008f74: 6afb         	ldr	r3, [r7, #0x2c]
 8008f76: 699b         	ldr	r3, [r3, #0x18]
 8008f78: 429a         	cmp	r2, r3
 8008f7a: d001         	beq	0x8008f80 <can_stm32_remove_rx_filter+0x9c> @ imm = #0x2
; 		bank_offset = CAN_STM32_NUM_FILTER_BANKS;
 8008f7c: 230e         	movs	r3, #0xe
 8008f7e: 633b         	str	r3, [r7, #0x30]
; 	if (filter_id < CONFIG_CAN_MAX_EXT_ID_FILTER) {
 8008f80: 683b         	ldr	r3, [r7]
 8008f82: 2b06         	cmp	r3, #0x6
 8008f84: dc17         	bgt	0x8008fb6 <can_stm32_remove_rx_filter+0xd2> @ imm = #0x2e
; 		ide = true;
 8008f86: 2301         	movs	r3, #0x1
 8008f88: f887 3037    	strb.w	r3, [r7, #0x37]
; 		bank_num = bank_offset + filter_id;
 8008f8c: 6b3a         	ldr	r2, [r7, #0x30]
 8008f8e: 683b         	ldr	r3, [r7]
 8008f90: 4413         	add	r3, r2
 8008f92: 63bb         	str	r3, [r7, #0x38]
; 		data->rx_cb_ext[filter_id] = NULL;
 8008f94: 6aba         	ldr	r2, [r7, #0x28]
 8008f96: 683b         	ldr	r3, [r7]
 8008f98: 3320         	adds	r3, #0x20
 8008f9a: 009b         	lsls	r3, r3, #0x2
 8008f9c: 4413         	add	r3, r2
 8008f9e: 2200         	movs	r2, #0x0
 8008fa0: 605a         	str	r2, [r3, #0x4]
; 		data->cb_arg_ext[filter_id] = NULL;
 8008fa2: 6abb         	ldr	r3, [r7, #0x28]
 8008fa4: 683a         	ldr	r2, [r7]
 8008fa6: 3236         	adds	r2, #0x36
 8008fa8: 2100         	movs	r1, #0x0
 8008faa: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 		bank_unused = true;
 8008fae: 2301         	movs	r3, #0x1
 8008fb0: f887 303f    	strb.w	r3, [r7, #0x3f]
 8008fb4: e045         	b	0x8009042 <can_stm32_remove_rx_filter+0x15e> @ imm = #0x8a
; 		int filter_index = filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER;
 8008fb6: 683b         	ldr	r3, [r7]
 8008fb8: 3b07         	subs	r3, #0x7
 8008fba: 623b         	str	r3, [r7, #0x20]
; 		ide = false;
 8008fbc: 2300         	movs	r3, #0x0
 8008fbe: f887 3037    	strb.w	r3, [r7, #0x37]
; 		bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER +
 8008fc2: 6b3b         	ldr	r3, [r7, #0x30]
 8008fc4: 1dda         	adds	r2, r3, #0x7
; 			   (filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER) / 2;
 8008fc6: 683b         	ldr	r3, [r7]
 8008fc8: 3b07         	subs	r3, #0x7
 8008fca: 0fd9         	lsrs	r1, r3, #0x1f
 8008fcc: 440b         	add	r3, r1
 8008fce: 105b         	asrs	r3, r3, #0x1
; 		bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER +
 8008fd0: 4413         	add	r3, r2
 8008fd2: 63bb         	str	r3, [r7, #0x38]
; 		data->rx_cb_std[filter_index] = NULL;
 8008fd4: 6aba         	ldr	r2, [r7, #0x28]
 8008fd6: 6a3b         	ldr	r3, [r7, #0x20]
 8008fd8: 3312         	adds	r3, #0x12
 8008fda: 009b         	lsls	r3, r3, #0x2
 8008fdc: 4413         	add	r3, r2
 8008fde: 2200         	movs	r2, #0x0
 8008fe0: 605a         	str	r2, [r3, #0x4]
; 		data->cb_arg_std[filter_index] = NULL;
 8008fe2: 6abb         	ldr	r3, [r7, #0x28]
 8008fe4: 6a3a         	ldr	r2, [r7, #0x20]
 8008fe6: 3228         	adds	r2, #0x28
 8008fe8: 2100         	movs	r1, #0x0
 8008fea: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 		if (filter_index % 2 == 1) {
 8008fee: 6a3b         	ldr	r3, [r7, #0x20]
 8008ff0: 2b00         	cmp	r3, #0x0
 8008ff2: f003 0301    	and	r3, r3, #0x1
 8008ff6: bfb8         	it	lt
 8008ff8: 425b         	rsblt	r3, r3, #0
 8008ffa: 2b01         	cmp	r3, #0x1
 8008ffc: d10d         	bne	0x800901a <can_stm32_remove_rx_filter+0x136> @ imm = #0x1a
; 			bank_unused = data->rx_cb_std[filter_index - 1] == NULL;
 8008ffe: 6a3b         	ldr	r3, [r7, #0x20]
 8009000: 3b01         	subs	r3, #0x1
 8009002: 6aba         	ldr	r2, [r7, #0x28]
 8009004: 3312         	adds	r3, #0x12
 8009006: 009b         	lsls	r3, r3, #0x2
 8009008: 4413         	add	r3, r2
 800900a: 685b         	ldr	r3, [r3, #0x4]
 800900c: 2b00         	cmp	r3, #0x0
 800900e: bf0c         	ite	eq
 8009010: 2301         	moveq	r3, #0x1
 8009012: 2300         	movne	r3, #0x0
 8009014: f887 303f    	strb.w	r3, [r7, #0x3f]
 8009018: e013         	b	0x8009042 <can_stm32_remove_rx_filter+0x15e> @ imm = #0x26
; 		} else if (filter_index + 1 < CONFIG_CAN_MAX_STD_ID_FILTER) {
 800901a: 6a3b         	ldr	r3, [r7, #0x20]
 800901c: 2b0c         	cmp	r3, #0xc
 800901e: dc0d         	bgt	0x800903c <can_stm32_remove_rx_filter+0x158> @ imm = #0x1a
; 			bank_unused = data->rx_cb_std[filter_index + 1] == NULL;
 8009020: 6a3b         	ldr	r3, [r7, #0x20]
 8009022: 3301         	adds	r3, #0x1
 8009024: 6aba         	ldr	r2, [r7, #0x28]
 8009026: 3312         	adds	r3, #0x12
 8009028: 009b         	lsls	r3, r3, #0x2
 800902a: 4413         	add	r3, r2
 800902c: 685b         	ldr	r3, [r3, #0x4]
 800902e: 2b00         	cmp	r3, #0x0
 8009030: bf0c         	ite	eq
 8009032: 2301         	moveq	r3, #0x1
 8009034: 2300         	movne	r3, #0x0
 8009036: f887 303f    	strb.w	r3, [r7, #0x3f]
 800903a: e002         	b	0x8009042 <can_stm32_remove_rx_filter+0x15e> @ imm = #0x4
; 			bank_unused = true;
 800903c: 2301         	movs	r3, #0x1
 800903e: f887 303f    	strb.w	r3, [r7, #0x3f]
; 	LOG_DBG("Removing filter_id %d, ide %d", filter_id, ide);
 8009042: 2303         	movs	r3, #0x3
 8009044: 2b03         	cmp	r3, #0x3
 8009046: d91d         	bls	0x8009084 <can_stm32_remove_rx_filter+0x1a0> @ imm = #0x3a
 8009048: 2301         	movs	r3, #0x1
 800904a: 77fb         	strb	r3, [r7, #0x1f]
 800904c: 7ffb         	ldrb	r3, [r7, #0x1f]
 800904e: f083 0301    	eor	r3, r3, #0x1
 8009052: b2db         	uxtb	r3, r3
 8009054: 2b00         	cmp	r3, #0x0
 8009056: d115         	bne	0x8009084 <can_stm32_remove_rx_filter+0x1a0> @ imm = #0x2a
 8009058: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8009134 <can_stm32_remove_rx_filter+0x250>
 800905a: 6819         	ldr	r1, [r3]
 800905c: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8009060: 9305         	str	r3, [sp, #0x14]
 8009062: 683b         	ldr	r3, [r7]
 8009064: 9304         	str	r3, [sp, #0x10]
 8009066: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8009140 <can_stm32_remove_rx_filter+0x25c>
 8009068: 9303         	str	r3, [sp, #0xc]
 800906a: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8009144 <can_stm32_remove_rx_filter+0x260>
 800906c: 9302         	str	r3, [sp, #0x8]
 800906e: 2308         	movs	r3, #0x8
 8009070: 9301         	str	r3, [sp, #0x4]
 8009072: 2300         	movs	r3, #0x0
 8009074: 9300         	str	r3, [sp]
 8009076: 2300         	movs	r3, #0x0
 8009078: 2204         	movs	r2, #0x4
 800907a: 2000         	movs	r0, #0x0
 800907c: f014 fa0a    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x14414
 8009080: 2300         	movs	r3, #0x0
 8009082: 61bb         	str	r3, [r7, #0x18]
; 	can->FMR |= CAN_FMR_FINIT;
 8009084: 6a7b         	ldr	r3, [r7, #0x24]
 8009086: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 800908a: f043 0201    	orr	r2, r3, #0x1
 800908e: 6a7b         	ldr	r3, [r7, #0x24]
 8009090: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num], ide, 0, 0xFFFFFFFF);
 8009094: 6bbb         	ldr	r3, [r7, #0x38]
 8009096: 3348         	adds	r3, #0x48
 8009098: 00db         	lsls	r3, r3, #0x3
 800909a: 6a7a         	ldr	r2, [r7, #0x24]
 800909c: 18d1         	adds	r1, r2, r3
 800909e: f897 2037    	ldrb.w	r2, [r7, #0x37]
 80090a2: f04f 33ff    	mov.w	r3, #0xffffffff
 80090a6: 9300         	str	r3, [sp]
 80090a8: 2300         	movs	r3, #0x0
 80090aa: 6838         	ldr	r0, [r7]
 80090ac: f014 fc38    	bl	0x801d920 <can_stm32_set_filter_bank> @ imm = #0x14870
; 	if (bank_unused) {
 80090b0: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 80090b4: 2b00         	cmp	r3, #0x0
 80090b6: d029         	beq	0x800910c <can_stm32_remove_rx_filter+0x228> @ imm = #0x52
; 		can->FA1R &= ~(1U << bank_num);
 80090b8: 6a7b         	ldr	r3, [r7, #0x24]
 80090ba: f8d3 221c    	ldr.w	r2, [r3, #0x21c]
 80090be: 2101         	movs	r1, #0x1
 80090c0: 6bbb         	ldr	r3, [r7, #0x38]
 80090c2: fa01 f303    	lsl.w	r3, r1, r3
 80090c6: 43db         	mvns	r3, r3
 80090c8: 401a         	ands	r2, r3
 80090ca: 6a7b         	ldr	r3, [r7, #0x24]
 80090cc: f8c3 221c    	str.w	r2, [r3, #0x21c]
; 		LOG_DBG("Filter bank %d is unused -> deactivate", bank_num);
 80090d0: 2303         	movs	r3, #0x3
 80090d2: 2b03         	cmp	r3, #0x3
 80090d4: d91a         	bls	0x800910c <can_stm32_remove_rx_filter+0x228> @ imm = #0x34
 80090d6: 2301         	movs	r3, #0x1
 80090d8: 75fb         	strb	r3, [r7, #0x17]
 80090da: 7dfb         	ldrb	r3, [r7, #0x17]
 80090dc: f083 0301    	eor	r3, r3, #0x1
 80090e0: b2db         	uxtb	r3, r3
 80090e2: 2b00         	cmp	r3, #0x0
 80090e4: d112         	bne	0x800910c <can_stm32_remove_rx_filter+0x228> @ imm = #0x24
 80090e6: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8009134 <can_stm32_remove_rx_filter+0x250>
 80090e8: 6819         	ldr	r1, [r3]
 80090ea: 6bbb         	ldr	r3, [r7, #0x38]
 80090ec: 9304         	str	r3, [sp, #0x10]
 80090ee: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8009140 <can_stm32_remove_rx_filter+0x25c>
 80090f0: 9303         	str	r3, [sp, #0xc]
 80090f2: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8009148 <can_stm32_remove_rx_filter+0x264>
 80090f4: 9302         	str	r3, [sp, #0x8]
 80090f6: 2308         	movs	r3, #0x8
 80090f8: 9301         	str	r3, [sp, #0x4]
 80090fa: 2300         	movs	r3, #0x0
 80090fc: 9300         	str	r3, [sp]
 80090fe: 2300         	movs	r3, #0x0
 8009100: 2204         	movs	r2, #0x4
 8009102: 2000         	movs	r0, #0x0
 8009104: f014 f9c6    	bl	0x801d494 <z_log_msg_runtime_create> @ imm = #0x1438c
 8009108: 2300         	movs	r3, #0x0
 800910a: 613b         	str	r3, [r7, #0x10]
; 	can->FMR &= ~(CAN_FMR_FINIT);
 800910c: 6a7b         	ldr	r3, [r7, #0x24]
 800910e: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 8009112: f023 0201    	bic	r2, r3, #0x1
 8009116: 6a7b         	ldr	r3, [r7, #0x24]
 8009118: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	k_mutex_unlock(&data->inst_mutex);
 800911c: 6abb         	ldr	r3, [r7, #0x28]
 800911e: 3310         	adds	r3, #0x10
 8009120: 4618         	mov	r0, r3
 8009122: f014 f8e4    	bl	0x801d2ee <k_mutex_unlock> @ imm = #0x141c8
; 	k_mutex_unlock(&filter_mutex);
 8009126: 4805         	ldr	r0, [pc, #0x14]         @ 0x800913c <can_stm32_remove_rx_filter+0x258>
 8009128: f014 f8e1    	bl	0x801d2ee <k_mutex_unlock> @ imm = #0x141c2
; }
 800912c: 3740         	adds	r7, #0x40
 800912e: 46bd         	mov	sp, r7
 8009130: bd80         	pop	{r7, pc}
 8009132: bf00         	nop

08009134 <$d>:
 8009134: 34 05 00 20  	.word	0x20000534
 8009138: 54 8f 02 08  	.word	0x08028f54
 800913c: bc 2d 00 20  	.word	0x20002dbc
 8009140: 48 a9 02 08  	.word	0x0802a948
 8009144: 70 8f 02 08  	.word	0x08028f70
 8009148: 94 8f 02 08  	.word	0x08028f94

0800914c <LL_RCC_HSE_DisableBypass>:
; {
 800914c: b480         	push	{r7}
 800914e: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 8009150: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8009168 <LL_RCC_HSE_DisableBypass+0x1c>
 8009152: 681b         	ldr	r3, [r3]
 8009154: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8009168 <LL_RCC_HSE_DisableBypass+0x1c>
 8009156: f423 2380    	bic	r3, r3, #0x40000
 800915a: 6013         	str	r3, [r2]
; }
 800915c: bf00         	nop
 800915e: 46bd         	mov	sp, r7
 8009160: f85d 7b04    	ldr	r7, [sp], #4
 8009164: 4770         	bx	lr
 8009166: bf00         	nop

08009168 <$d>:
 8009168: 00 38 02 40  	.word	0x40023800

0800916c <LL_RCC_HSE_Enable>:
; {
 800916c: b480         	push	{r7}
 800916e: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSEON);
 8009170: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8009188 <LL_RCC_HSE_Enable+0x1c>
 8009172: 681b         	ldr	r3, [r3]
 8009174: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8009188 <LL_RCC_HSE_Enable+0x1c>
 8009176: f443 3380    	orr	r3, r3, #0x10000
 800917a: 6013         	str	r3, [r2]
; }
 800917c: bf00         	nop
 800917e: 46bd         	mov	sp, r7
 8009180: f85d 7b04    	ldr	r7, [sp], #4
 8009184: 4770         	bx	lr
 8009186: bf00         	nop

08009188 <$d>:
 8009188: 00 38 02 40  	.word	0x40023800

0800918c <LL_RCC_HSE_IsReady>:
; {
 800918c: b480         	push	{r7}
 800918e: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
 8009190: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80091b0 <LL_RCC_HSE_IsReady+0x24>
 8009192: 681b         	ldr	r3, [r3]
 8009194: f403 3300    	and	r3, r3, #0x20000
 8009198: f5b3 3f00    	cmp.w	r3, #0x20000
 800919c: bf0c         	ite	eq
 800919e: 2301         	moveq	r3, #0x1
 80091a0: 2300         	movne	r3, #0x0
 80091a2: b2db         	uxtb	r3, r3
; }
 80091a4: 4618         	mov	r0, r3
 80091a6: 46bd         	mov	sp, r7
 80091a8: f85d 7b04    	ldr	r7, [sp], #4
 80091ac: 4770         	bx	lr
 80091ae: bf00         	nop

080091b0 <$d>:
 80091b0: 00 38 02 40  	.word	0x40023800

080091b4 <LL_RCC_HSI_Enable>:
; {
 80091b4: b480         	push	{r7}
 80091b6: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSION);
 80091b8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80091d0 <LL_RCC_HSI_Enable+0x1c>
 80091ba: 681b         	ldr	r3, [r3]
 80091bc: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80091d0 <LL_RCC_HSI_Enable+0x1c>
 80091be: f043 0301    	orr	r3, r3, #0x1
 80091c2: 6013         	str	r3, [r2]
; }
 80091c4: bf00         	nop
 80091c6: 46bd         	mov	sp, r7
 80091c8: f85d 7b04    	ldr	r7, [sp], #4
 80091cc: 4770         	bx	lr
 80091ce: bf00         	nop

080091d0 <$d>:
 80091d0: 00 38 02 40  	.word	0x40023800

080091d4 <LL_RCC_HSI_IsReady>:
; {
 80091d4: b480         	push	{r7}
 80091d6: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
 80091d8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80091f4 <LL_RCC_HSI_IsReady+0x20>
 80091da: 681b         	ldr	r3, [r3]
 80091dc: f003 0302    	and	r3, r3, #0x2
 80091e0: 2b02         	cmp	r3, #0x2
 80091e2: bf0c         	ite	eq
 80091e4: 2301         	moveq	r3, #0x1
 80091e6: 2300         	movne	r3, #0x0
 80091e8: b2db         	uxtb	r3, r3
; }
 80091ea: 4618         	mov	r0, r3
 80091ec: 46bd         	mov	sp, r7
 80091ee: f85d 7b04    	ldr	r7, [sp], #4
 80091f2: 4770         	bx	lr

080091f4 <$d>:
 80091f4: 00 38 02 40  	.word	0x40023800

080091f8 <LL_RCC_LSI_Enable>:
; {
 80091f8: b480         	push	{r7}
 80091fa: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CSR, RCC_CSR_LSION);
 80091fc: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8009214 <LL_RCC_LSI_Enable+0x1c>
 80091fe: 6f5b         	ldr	r3, [r3, #0x74]
 8009200: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8009214 <LL_RCC_LSI_Enable+0x1c>
 8009202: f043 0301    	orr	r3, r3, #0x1
 8009206: 6753         	str	r3, [r2, #0x74]
; }
 8009208: bf00         	nop
 800920a: 46bd         	mov	sp, r7
 800920c: f85d 7b04    	ldr	r7, [sp], #4
 8009210: 4770         	bx	lr
 8009212: bf00         	nop

08009214 <$d>:
 8009214: 00 38 02 40  	.word	0x40023800

08009218 <LL_RCC_LSI_IsReady>:
; {
 8009218: b480         	push	{r7}
 800921a: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY));
 800921c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8009238 <LL_RCC_LSI_IsReady+0x20>
 800921e: 6f5b         	ldr	r3, [r3, #0x74]
 8009220: f003 0302    	and	r3, r3, #0x2
 8009224: 2b02         	cmp	r3, #0x2
 8009226: bf0c         	ite	eq
 8009228: 2301         	moveq	r3, #0x1
 800922a: 2300         	movne	r3, #0x0
 800922c: b2db         	uxtb	r3, r3
; }
 800922e: 4618         	mov	r0, r3
 8009230: 46bd         	mov	sp, r7
 8009232: f85d 7b04    	ldr	r7, [sp], #4
 8009236: 4770         	bx	lr

08009238 <$d>:
 8009238: 00 38 02 40  	.word	0x40023800

0800923c <LL_RCC_SetSysClkSource>:
; {
 800923c: b480         	push	{r7}
 800923e: b083         	sub	sp, #0xc
 8009240: af00         	add	r7, sp, #0x0
 8009242: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8009244: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8009260 <LL_RCC_SetSysClkSource+0x24>
 8009246: 689b         	ldr	r3, [r3, #0x8]
 8009248: f023 0203    	bic	r2, r3, #0x3
 800924c: 4904         	ldr	r1, [pc, #0x10]         @ 0x8009260 <LL_RCC_SetSysClkSource+0x24>
 800924e: 687b         	ldr	r3, [r7, #0x4]
 8009250: 4313         	orrs	r3, r2
 8009252: 608b         	str	r3, [r1, #0x8]
; }
 8009254: bf00         	nop
 8009256: 370c         	adds	r7, #0xc
 8009258: 46bd         	mov	sp, r7
 800925a: f85d 7b04    	ldr	r7, [sp], #4
 800925e: 4770         	bx	lr

08009260 <$d>:
 8009260: 00 38 02 40  	.word	0x40023800

08009264 <LL_RCC_GetSysClkSource>:
; {
 8009264: b480         	push	{r7}
 8009266: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8009268: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800927c <LL_RCC_GetSysClkSource+0x18>
 800926a: 689b         	ldr	r3, [r3, #0x8]
 800926c: f003 030c    	and	r3, r3, #0xc
; }
 8009270: 4618         	mov	r0, r3
 8009272: 46bd         	mov	sp, r7
 8009274: f85d 7b04    	ldr	r7, [sp], #4
 8009278: 4770         	bx	lr
 800927a: bf00         	nop

0800927c <$d>:
 800927c: 00 38 02 40  	.word	0x40023800

08009280 <LL_RCC_SetAHBPrescaler>:
; {
 8009280: b480         	push	{r7}
 8009282: b083         	sub	sp, #0xc
 8009284: af00         	add	r7, sp, #0x0
 8009286: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8009288: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80092a4 <LL_RCC_SetAHBPrescaler+0x24>
 800928a: 689b         	ldr	r3, [r3, #0x8]
 800928c: f023 02f0    	bic	r2, r3, #0xf0
 8009290: 4904         	ldr	r1, [pc, #0x10]         @ 0x80092a4 <LL_RCC_SetAHBPrescaler+0x24>
 8009292: 687b         	ldr	r3, [r7, #0x4]
 8009294: 4313         	orrs	r3, r2
 8009296: 608b         	str	r3, [r1, #0x8]
; }
 8009298: bf00         	nop
 800929a: 370c         	adds	r7, #0xc
 800929c: 46bd         	mov	sp, r7
 800929e: f85d 7b04    	ldr	r7, [sp], #4
 80092a2: 4770         	bx	lr

080092a4 <$d>:
 80092a4: 00 38 02 40  	.word	0x40023800

080092a8 <LL_RCC_SetAPB1Prescaler>:
; {
 80092a8: b480         	push	{r7}
 80092aa: b083         	sub	sp, #0xc
 80092ac: af00         	add	r7, sp, #0x0
 80092ae: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 80092b0: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80092cc <LL_RCC_SetAPB1Prescaler+0x24>
 80092b2: 689b         	ldr	r3, [r3, #0x8]
 80092b4: f423 52e0    	bic	r2, r3, #0x1c00
 80092b8: 4904         	ldr	r1, [pc, #0x10]         @ 0x80092cc <LL_RCC_SetAPB1Prescaler+0x24>
 80092ba: 687b         	ldr	r3, [r7, #0x4]
 80092bc: 4313         	orrs	r3, r2
 80092be: 608b         	str	r3, [r1, #0x8]
; }
 80092c0: bf00         	nop
 80092c2: 370c         	adds	r7, #0xc
 80092c4: 46bd         	mov	sp, r7
 80092c6: f85d 7b04    	ldr	r7, [sp], #4
 80092ca: 4770         	bx	lr

080092cc <$d>:
 80092cc: 00 38 02 40  	.word	0x40023800

080092d0 <LL_RCC_SetAPB2Prescaler>:
; {
 80092d0: b480         	push	{r7}
 80092d2: b083         	sub	sp, #0xc
 80092d4: af00         	add	r7, sp, #0x0
 80092d6: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 80092d8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80092f4 <LL_RCC_SetAPB2Prescaler+0x24>
 80092da: 689b         	ldr	r3, [r3, #0x8]
 80092dc: f423 4260    	bic	r2, r3, #0xe000
 80092e0: 4904         	ldr	r1, [pc, #0x10]         @ 0x80092f4 <LL_RCC_SetAPB2Prescaler+0x24>
 80092e2: 687b         	ldr	r3, [r7, #0x4]
 80092e4: 4313         	orrs	r3, r2
 80092e6: 608b         	str	r3, [r1, #0x8]
; }
 80092e8: bf00         	nop
 80092ea: 370c         	adds	r7, #0xc
 80092ec: 46bd         	mov	sp, r7
 80092ee: f85d 7b04    	ldr	r7, [sp], #4
 80092f2: 4770         	bx	lr

080092f4 <$d>:
 80092f4: 00 38 02 40  	.word	0x40023800

080092f8 <LL_RCC_GetAHBPrescaler>:
; {
 80092f8: b480         	push	{r7}
 80092fa: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 80092fc: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8009310 <LL_RCC_GetAHBPrescaler+0x18>
 80092fe: 689b         	ldr	r3, [r3, #0x8]
 8009300: f003 03f0    	and	r3, r3, #0xf0
; }
 8009304: 4618         	mov	r0, r3
 8009306: 46bd         	mov	sp, r7
 8009308: f85d 7b04    	ldr	r7, [sp], #4
 800930c: 4770         	bx	lr
 800930e: bf00         	nop

08009310 <$d>:
 8009310: 00 38 02 40  	.word	0x40023800

08009314 <LL_RCC_PLL_Enable>:
; {
 8009314: b480         	push	{r7}
 8009316: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_PLLON);
 8009318: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8009330 <LL_RCC_PLL_Enable+0x1c>
 800931a: 681b         	ldr	r3, [r3]
 800931c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8009330 <LL_RCC_PLL_Enable+0x1c>
 800931e: f043 7380    	orr	r3, r3, #0x1000000
 8009322: 6013         	str	r3, [r2]
; }
 8009324: bf00         	nop
 8009326: 46bd         	mov	sp, r7
 8009328: f85d 7b04    	ldr	r7, [sp], #4
 800932c: 4770         	bx	lr
 800932e: bf00         	nop

08009330 <$d>:
 8009330: 00 38 02 40  	.word	0x40023800

08009334 <LL_RCC_PLL_Disable>:
; {
 8009334: b480         	push	{r7}
 8009336: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8009338: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8009350 <LL_RCC_PLL_Disable+0x1c>
 800933a: 681b         	ldr	r3, [r3]
 800933c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8009350 <LL_RCC_PLL_Disable+0x1c>
 800933e: f023 7380    	bic	r3, r3, #0x1000000
 8009342: 6013         	str	r3, [r2]
; }
 8009344: bf00         	nop
 8009346: 46bd         	mov	sp, r7
 8009348: f85d 7b04    	ldr	r7, [sp], #4
 800934c: 4770         	bx	lr
 800934e: bf00         	nop

08009350 <$d>:
 8009350: 00 38 02 40  	.word	0x40023800

08009354 <LL_RCC_PLL_IsReady>:
; {
 8009354: b480         	push	{r7}
 8009356: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8009358: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8009378 <LL_RCC_PLL_IsReady+0x24>
 800935a: 681b         	ldr	r3, [r3]
 800935c: f003 7300    	and	r3, r3, #0x2000000
 8009360: f1b3 7f00    	cmp.w	r3, #0x2000000
 8009364: bf0c         	ite	eq
 8009366: 2301         	moveq	r3, #0x1
 8009368: 2300         	movne	r3, #0x0
 800936a: b2db         	uxtb	r3, r3
; }
 800936c: 4618         	mov	r0, r3
 800936e: 46bd         	mov	sp, r7
 8009370: f85d 7b04    	ldr	r7, [sp], #4
 8009374: 4770         	bx	lr
 8009376: bf00         	nop

08009378 <$d>:
 8009378: 00 38 02 40  	.word	0x40023800

0800937c <enabled_clock>:
; {
 800937c: b480         	push	{r7}
 800937e: b085         	sub	sp, #0x14
 8009380: af00         	add	r7, sp, #0x0
 8009382: 6078         	str	r0, [r7, #0x4]
; 	int r = 0;
 8009384: 2300         	movs	r3, #0x0
 8009386: 60fb         	str	r3, [r7, #0xc]
; 	switch (src_clk) {
 8009388: 687b         	ldr	r3, [r7, #0x4]
 800938a: 3b01         	subs	r3, #0x1
 800938c: 2b08         	cmp	r3, #0x8
 800938e: d825         	bhi	0x80093dc <enabled_clock+0x60> @ imm = #0x4a
 8009390: a201         	adr	r2, #4 <enabled_clock+0x19>
 8009392: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8009396: bf00         	nop

08009398 <$d>:
 8009398: e3 93 00 08  	.word	0x080093e3
 800939c: c5 93 00 08  	.word	0x080093c5
 80093a0: e3 93 00 08  	.word	0x080093e3
 80093a4: bd 93 00 08  	.word	0x080093bd
 80093a8: e3 93 00 08  	.word	0x080093e3
 80093ac: e3 93 00 08  	.word	0x080093e3
 80093b0: e3 93 00 08  	.word	0x080093e3
 80093b4: cd 93 00 08  	.word	0x080093cd
 80093b8: d5 93 00 08  	.word	0x080093d5

080093bc <$t>:
; 			r = -ENOTSUP;
 80093bc: f06f 0385    	mvn	r3, #0x85
 80093c0: 60fb         	str	r3, [r7, #0xc]
; 		break;
 80093c2: e00f         	b	0x80093e4 <enabled_clock+0x68> @ imm = #0x1e
; 			r = -ENOTSUP;
 80093c4: f06f 0385    	mvn	r3, #0x85
 80093c8: 60fb         	str	r3, [r7, #0xc]
; 		break;
 80093ca: e00b         	b	0x80093e4 <enabled_clock+0x68> @ imm = #0x16
; 			r = -ENOTSUP;
 80093cc: f06f 0385    	mvn	r3, #0x85
 80093d0: 60fb         	str	r3, [r7, #0xc]
; 		break;
 80093d2: e007         	b	0x80093e4 <enabled_clock+0x68> @ imm = #0xe
; 			r = -ENOTSUP;
 80093d4: f06f 0385    	mvn	r3, #0x85
 80093d8: 60fb         	str	r3, [r7, #0xc]
; 		break;
 80093da: e003         	b	0x80093e4 <enabled_clock+0x68> @ imm = #0x6
; 		return -ENOTSUP;
 80093dc: f06f 0385    	mvn	r3, #0x85
 80093e0: e001         	b	0x80093e6 <enabled_clock+0x6a> @ imm = #0x2
; 		break;
 80093e2: bf00         	nop
; 	return r;
 80093e4: 68fb         	ldr	r3, [r7, #0xc]
; }
 80093e6: 4618         	mov	r0, r3
 80093e8: 3714         	adds	r7, #0x14
 80093ea: 46bd         	mov	sp, r7
 80093ec: f85d 7b04    	ldr	r7, [sp], #4
 80093f0: 4770         	bx	lr
 80093f2: bf00         	nop

080093f4 <stm32_clock_control_get_subsys_rate>:
; {
 80093f4: b580         	push	{r7, lr}
 80093f6: b08a         	sub	sp, #0x28
 80093f8: af00         	add	r7, sp, #0x0
 80093fa: 60f8         	str	r0, [r7, #0xc]
 80093fc: 60b9         	str	r1, [r7, #0x8]
 80093fe: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8009400: 68bb         	ldr	r3, [r7, #0x8]
 8009402: 627b         	str	r3, [r7, #0x24]
; 	uint32_t ahb_clock = SystemCoreClock;
 8009404: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x80095e8 <stm32_clock_control_get_subsys_rate+0x1f4>
 8009406: 681b         	ldr	r3, [r3]
 8009408: 623b         	str	r3, [r7, #0x20]
; 	uint32_t apb1_clock = get_bus_clock(ahb_clock, STM32_APB1_PRESCALER);
 800940a: 2104         	movs	r1, #0x4
 800940c: 6a38         	ldr	r0, [r7, #0x20]
 800940e: f014 fb62    	bl	0x801dad6 <get_bus_clock> @ imm = #0x146c4
 8009412: 61f8         	str	r0, [r7, #0x1c]
; 	uint32_t apb2_clock = get_bus_clock(ahb_clock, STM32_APB2_PRESCALER);
 8009414: 2102         	movs	r1, #0x2
 8009416: 6a38         	ldr	r0, [r7, #0x20]
 8009418: f014 fb5d    	bl	0x801dad6 <get_bus_clock> @ imm = #0x146ba
 800941c: 61b8         	str	r0, [r7, #0x18]
; 	uint32_t ahb3_clock = ahb_clock;
 800941e: 6a3b         	ldr	r3, [r7, #0x20]
 8009420: 617b         	str	r3, [r7, #0x14]
; 	switch (pclken->bus) {
 8009422: 6a7b         	ldr	r3, [r7, #0x24]
 8009424: 681b         	ldr	r3, [r3]
 8009426: 2b44         	cmp	r3, #0x44
 8009428: f200 8092    	bhi.w	0x8009550 <stm32_clock_control_get_subsys_rate+0x15c> @ imm = #0x124
 800942c: 2b00         	cmp	r3, #0x0
 800942e: f000 80d2    	beq.w	0x80095d6 <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x1a4
 8009432: 3b01         	subs	r3, #0x1
 8009434: 2b43         	cmp	r3, #0x43
 8009436: f200 80ce    	bhi.w	0x80095d6 <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x19c
 800943a: a201         	adr	r2, #4 <stm32_clock_control_get_subsys_rate+0x4b>
 800943c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08009440 <$d>:
 8009440: 7f 95 00 08  	.word	0x0800957f
 8009444: b5 95 00 08  	.word	0x080095b5
 8009448: bd 95 00 08  	.word	0x080095bd
 800944c: c7 95 00 08  	.word	0x080095c7
 8009450: cf 95 00 08  	.word	0x080095cf
 8009454: 89 95 00 08  	.word	0x08009589
 8009458: 9f 95 00 08  	.word	0x0800959f
 800945c: d7 95 00 08  	.word	0x080095d7
 8009460: d7 95 00 08  	.word	0x080095d7
 8009464: d7 95 00 08  	.word	0x080095d7
 8009468: d7 95 00 08  	.word	0x080095d7
 800946c: d7 95 00 08  	.word	0x080095d7
 8009470: d7 95 00 08  	.word	0x080095d7
 8009474: d7 95 00 08  	.word	0x080095d7
 8009478: d7 95 00 08  	.word	0x080095d7
 800947c: d7 95 00 08  	.word	0x080095d7
 8009480: d7 95 00 08  	.word	0x080095d7
 8009484: d7 95 00 08  	.word	0x080095d7
 8009488: d7 95 00 08  	.word	0x080095d7
 800948c: d7 95 00 08  	.word	0x080095d7
 8009490: d7 95 00 08  	.word	0x080095d7
 8009494: d7 95 00 08  	.word	0x080095d7
 8009498: d7 95 00 08  	.word	0x080095d7
 800949c: d7 95 00 08  	.word	0x080095d7
 80094a0: d7 95 00 08  	.word	0x080095d7
 80094a4: d7 95 00 08  	.word	0x080095d7
 80094a8: d7 95 00 08  	.word	0x080095d7
 80094ac: d7 95 00 08  	.word	0x080095d7
 80094b0: d7 95 00 08  	.word	0x080095d7
 80094b4: d7 95 00 08  	.word	0x080095d7
 80094b8: d7 95 00 08  	.word	0x080095d7
 80094bc: d7 95 00 08  	.word	0x080095d7
 80094c0: d7 95 00 08  	.word	0x080095d7
 80094c4: d7 95 00 08  	.word	0x080095d7
 80094c8: d7 95 00 08  	.word	0x080095d7
 80094cc: d7 95 00 08  	.word	0x080095d7
 80094d0: d7 95 00 08  	.word	0x080095d7
 80094d4: d7 95 00 08  	.word	0x080095d7
 80094d8: d7 95 00 08  	.word	0x080095d7
 80094dc: d7 95 00 08  	.word	0x080095d7
 80094e0: d7 95 00 08  	.word	0x080095d7
 80094e4: d7 95 00 08  	.word	0x080095d7
 80094e8: d7 95 00 08  	.word	0x080095d7
 80094ec: d7 95 00 08  	.word	0x080095d7
 80094f0: d7 95 00 08  	.word	0x080095d7
 80094f4: d7 95 00 08  	.word	0x080095d7
 80094f8: d7 95 00 08  	.word	0x080095d7
 80094fc: 57 95 00 08  	.word	0x08009557
 8009500: d7 95 00 08  	.word	0x080095d7
 8009504: d7 95 00 08  	.word	0x080095d7
 8009508: d7 95 00 08  	.word	0x080095d7
 800950c: 57 95 00 08  	.word	0x08009557
 8009510: d7 95 00 08  	.word	0x080095d7
 8009514: d7 95 00 08  	.word	0x080095d7
 8009518: d7 95 00 08  	.word	0x080095d7
 800951c: 5f 95 00 08  	.word	0x0800955f
 8009520: d7 95 00 08  	.word	0x080095d7
 8009524: d7 95 00 08  	.word	0x080095d7
 8009528: d7 95 00 08  	.word	0x080095d7
 800952c: d7 95 00 08  	.word	0x080095d7
 8009530: d7 95 00 08  	.word	0x080095d7
 8009534: d7 95 00 08  	.word	0x080095d7
 8009538: d7 95 00 08  	.word	0x080095d7
 800953c: 67 95 00 08  	.word	0x08009567
 8009540: d7 95 00 08  	.word	0x080095d7
 8009544: d7 95 00 08  	.word	0x080095d7
 8009548: d7 95 00 08  	.word	0x080095d7
 800954c: 6f 95 00 08  	.word	0x0800956f

08009550 <$t>:
 8009550: 2ba8         	cmp	r3, #0xa8
 8009552: d010         	beq	0x8009576 <stm32_clock_control_get_subsys_rate+0x182> @ imm = #0x20
 8009554: e03f         	b	0x80095d6 <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x7e
; 		*rate = ahb_clock;
 8009556: 687b         	ldr	r3, [r7, #0x4]
 8009558: 6a3a         	ldr	r2, [r7, #0x20]
 800955a: 601a         	str	r2, [r3]
; 		break;
 800955c: e03e         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x7c
; 		*rate = ahb3_clock;
 800955e: 687b         	ldr	r3, [r7, #0x4]
 8009560: 697a         	ldr	r2, [r7, #0x14]
 8009562: 601a         	str	r2, [r3]
; 		break;
 8009564: e03a         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x74
; 		*rate = apb1_clock;
 8009566: 687b         	ldr	r3, [r7, #0x4]
 8009568: 69fa         	ldr	r2, [r7, #0x1c]
 800956a: 601a         	str	r2, [r3]
; 		break;
 800956c: e036         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x6c
; 		*rate = apb2_clock;
 800956e: 687b         	ldr	r3, [r7, #0x4]
 8009570: 69ba         	ldr	r2, [r7, #0x18]
 8009572: 601a         	str	r2, [r3]
; 		break;
 8009574: e032         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x64
; 		*rate = ahb3_clock;
 8009576: 687b         	ldr	r3, [r7, #0x4]
 8009578: 697a         	ldr	r2, [r7, #0x14]
 800957a: 601a         	str	r2, [r3]
; 		break;
 800957c: e02e         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x5c
; 		*rate = SystemCoreClock * STM32_CORE_PRESCALER;
 800957e: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x80095e8 <stm32_clock_control_get_subsys_rate+0x1f4>
 8009580: 681a         	ldr	r2, [r3]
 8009582: 687b         	ldr	r3, [r7, #0x4]
 8009584: 601a         	str	r2, [r3]
; 		break;
 8009586: e029         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x52
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 8009588: f000 f8f0    	bl	0x800976c <get_pllsrc_frequency> @ imm = #0x1e0
 800958c: 2302         	movs	r3, #0x2
 800958e: 22a8         	movs	r2, #0xa8
 8009590: 2106         	movs	r1, #0x6
 8009592: f014 fa89    	bl	0x801daa8 <get_pll_div_frequency> @ imm = #0x14512
 8009596: 4602         	mov	r2, r0
 8009598: 687b         	ldr	r3, [r7, #0x4]
 800959a: 601a         	str	r2, [r3]
; 		break;
 800959c: e01e         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x3c
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 800959e: f000 f8e5    	bl	0x800976c <get_pllsrc_frequency> @ imm = #0x1ca
 80095a2: 2304         	movs	r3, #0x4
 80095a4: 22a8         	movs	r2, #0xa8
 80095a6: 2106         	movs	r1, #0x6
 80095a8: f014 fa7e    	bl	0x801daa8 <get_pll_div_frequency> @ imm = #0x144fc
 80095ac: 4602         	mov	r2, r0
 80095ae: 687b         	ldr	r3, [r7, #0x4]
 80095b0: 601a         	str	r2, [r3]
; 		break;
 80095b2: e013         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x26
; 		*rate = STM32_LSE_FREQ;
 80095b4: 687b         	ldr	r3, [r7, #0x4]
 80095b6: 2200         	movs	r2, #0x0
 80095b8: 601a         	str	r2, [r3]
; 		break;
 80095ba: e00f         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x1e
; 		*rate = STM32_LSI_FREQ;
 80095bc: 687b         	ldr	r3, [r7, #0x4]
 80095be: f44f 42fa    	mov.w	r2, #0x7d00
 80095c2: 601a         	str	r2, [r3]
; 		break;
 80095c4: e00a         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x14
; 		*rate = STM32_HSI_FREQ;
 80095c6: 687b         	ldr	r3, [r7, #0x4]
 80095c8: 2200         	movs	r2, #0x0
 80095ca: 601a         	str	r2, [r3]
; 		break;
 80095cc: e006         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0xc
; 		*rate = STM32_HSE_FREQ;
 80095ce: 687b         	ldr	r3, [r7, #0x4]
 80095d0: 4a06         	ldr	r2, [pc, #0x18]         @ 0x80095ec <stm32_clock_control_get_subsys_rate+0x1f8>
 80095d2: 601a         	str	r2, [r3]
; 		break;
 80095d4: e002         	b	0x80095dc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x4
; 		return -ENOTSUP;
 80095d6: f06f 0385    	mvn	r3, #0x85
 80095da: e000         	b	0x80095de <stm32_clock_control_get_subsys_rate+0x1ea> @ imm = #0x0
; 	return 0;
 80095dc: 2300         	movs	r3, #0x0
; }
 80095de: 4618         	mov	r0, r3
 80095e0: 3728         	adds	r7, #0x28
 80095e2: 46bd         	mov	sp, r7
 80095e4: bd80         	pop	{r7, pc}
 80095e6: bf00         	nop

080095e8 <$d>:
 80095e8: 40 0b 00 20  	.word	0x20000b40
 80095ec: 00 1b b7 00  	.word	0x00b71b00

080095f0 <set_up_plls>:
; {
 80095f0: b580         	push	{r7, lr}
 80095f2: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_GetSysClkSource() == LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 80095f4: f7ff fe36    	bl	0x8009264 <LL_RCC_GetSysClkSource> @ imm = #-0x394
 80095f8: 4603         	mov	r3, r0
 80095fa: 2b08         	cmp	r3, #0x8
 80095fc: d104         	bne	0x8009608 <set_up_plls+0x18> @ imm = #0x8
; 		stm32_clock_switch_to_hsi();
 80095fe: f014 fb79    	bl	0x801dcf4 <stm32_clock_switch_to_hsi> @ imm = #0x146f2
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(1));
 8009602: 2000         	movs	r0, #0x0
 8009604: f7ff fe3c    	bl	0x8009280 <LL_RCC_SetAHBPrescaler> @ imm = #-0x388
; 	LL_RCC_PLL_Disable();
 8009608: f7ff fe94    	bl	0x8009334 <LL_RCC_PLL_Disable> @ imm = #-0x2d8
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, pllp(STM32_PLL_P_DIVISOR));
 800960c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8009644 <set_up_plls+0x54>
 800960e: 685b         	ldr	r3, [r3, #0x4]
 8009610: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8009644 <set_up_plls+0x54>
 8009612: f423 3340    	bic	r3, r3, #0x30000
 8009616: 6053         	str	r3, [r2, #0x4]
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ, pllq(STM32_PLL_Q_DIVISOR));
 8009618: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8009644 <set_up_plls+0x54>
 800961a: 685b         	ldr	r3, [r3, #0x4]
 800961c: f023 6370    	bic	r3, r3, #0xf000000
 8009620: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8009644 <set_up_plls+0x54>
 8009622: f043 6380    	orr	r3, r3, #0x4000000
 8009626: 6053         	str	r3, [r2, #0x4]
; 	config_pll_sysclock();
 8009628: f014 fba9    	bl	0x801dd7e <config_pll_sysclock> @ imm = #0x14752
; 	LL_RCC_PLL_Enable();
 800962c: f7ff fe72    	bl	0x8009314 <LL_RCC_PLL_Enable> @ imm = #-0x31c
; 	while (LL_RCC_PLL_IsReady() != 1U) {
 8009630: bf00         	nop
 8009632: f7ff fe8f    	bl	0x8009354 <LL_RCC_PLL_IsReady> @ imm = #-0x2e2
 8009636: 4603         	mov	r3, r0
 8009638: 2b01         	cmp	r3, #0x1
 800963a: d1fa         	bne	0x8009632 <set_up_plls+0x42> @ imm = #-0xc
; }
 800963c: bf00         	nop
 800963e: bf00         	nop
 8009640: bd80         	pop	{r7, pc}
 8009642: bf00         	nop

08009644 <$d>:
 8009644: 00 38 02 40  	.word	0x40023800

08009648 <stm32_clock_control_init>:
; {
 8009648: b590         	push	{r4, r7, lr}
 800964a: b085         	sub	sp, #0x14
 800964c: af00         	add	r7, sp, #0x0
 800964e: 6078         	str	r0, [r7, #0x4]
; 	config_enable_default_clocks();
 8009650: f014 fba0    	bl	0x801dd94 <config_enable_default_clocks> @ imm = #0x14740
; 	config_regulator_voltage(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC);
 8009654: 4823         	ldr	r0, [pc, #0x8c]         @ 0x80096e4 <stm32_clock_control_init+0x9c>
 8009656: f014 fb7f    	bl	0x801dd58 <config_regulator_voltage> @ imm = #0x146fe
; 	old_flash_freq = RCC_CALC_FLASH_FREQ(HAL_RCC_GetSysClockFreq(),
 800965a: f009 f8f3    	bl	0x8012844 <HAL_RCC_GetSysClockFreq> @ imm = #0x91e6
 800965e: 4604         	mov	r4, r0
 8009660: f7ff fe4a    	bl	0x80092f8 <LL_RCC_GetAHBPrescaler> @ imm = #-0x36c
 8009664: 4603         	mov	r3, r0
 8009666: 091b         	lsrs	r3, r3, #0x4
 8009668: f003 030f    	and	r3, r3, #0xf
 800966c: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x80096e8 <stm32_clock_control_init+0xa0>
 800966e: 5cd3         	ldrb	r3, [r2, r3]
 8009670: fa24 f303    	lsr.w	r3, r4, r3
 8009674: 60fb         	str	r3, [r7, #0xc]
; 	new_flash_freq = RCC_CALC_FLASH_FREQ(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC,
 8009676: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80096e8 <stm32_clock_control_init+0xa0>
 8009678: 781b         	ldrb	r3, [r3]
 800967a: 461a         	mov	r2, r3
 800967c: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80096e4 <stm32_clock_control_init+0x9c>
 800967e: 4113         	asrs	r3, r2
 8009680: 60bb         	str	r3, [r7, #0x8]
; 	if (old_flash_freq < new_flash_freq) {
 8009682: 68fa         	ldr	r2, [r7, #0xc]
 8009684: 68bb         	ldr	r3, [r7, #0x8]
 8009686: 429a         	cmp	r2, r3
 8009688: d202         	bhs	0x8009690 <stm32_clock_control_init+0x48> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 800968a: 68b8         	ldr	r0, [r7, #0x8]
 800968c: f009 fadc    	bl	0x8012c48 <LL_SetFlashLatency> @ imm = #0x95b8
; 	set_up_fixed_clock_sources();
 8009690: f014 fb4b    	bl	0x801dd2a <set_up_fixed_clock_sources> @ imm = #0x14696
; 	set_up_plls();
 8009694: f7ff ffac    	bl	0x80095f0 <set_up_plls> @ imm = #-0xa8
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(STM32_CORE_PRESCALER));
 8009698: 2000         	movs	r0, #0x0
 800969a: f7ff fdf1    	bl	0x8009280 <LL_RCC_SetAHBPrescaler> @ imm = #-0x41e
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
 800969e: 2002         	movs	r0, #0x2
 80096a0: f7ff fdcc    	bl	0x800923c <LL_RCC_SetSysClkSource> @ imm = #-0x468
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 80096a4: bf00         	nop
 80096a6: f7ff fddd    	bl	0x8009264 <LL_RCC_GetSysClkSource> @ imm = #-0x446
 80096aa: 4603         	mov	r3, r0
 80096ac: 2b08         	cmp	r3, #0x8
 80096ae: d1fa         	bne	0x80096a6 <stm32_clock_control_init+0x5e> @ imm = #-0xc
; 	if (old_flash_freq >= new_flash_freq) {
 80096b0: 68fa         	ldr	r2, [r7, #0xc]
 80096b2: 68bb         	ldr	r3, [r7, #0x8]
 80096b4: 429a         	cmp	r2, r3
 80096b6: d302         	blo	0x80096be <stm32_clock_control_init+0x76> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 80096b8: 68b8         	ldr	r0, [r7, #0x8]
 80096ba: f009 fac5    	bl	0x8012c48 <LL_SetFlashLatency> @ imm = #0x958a
; 	SystemCoreClock = CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC;
 80096be: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80096ec <stm32_clock_control_init+0xa4>
 80096c0: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80096e4 <stm32_clock_control_init+0x9c>
 80096c2: 601a         	str	r2, [r3]
; 	LL_RCC_SetAPB1Prescaler(apb1_prescaler(STM32_APB1_PRESCALER));
 80096c4: f44f 50a0    	mov.w	r0, #0x1400
 80096c8: f7ff fdee    	bl	0x80092a8 <LL_RCC_SetAPB1Prescaler> @ imm = #-0x424
; 	LL_RCC_SetAPB2Prescaler(apb2_prescaler(STM32_APB2_PRESCALER));
 80096cc: f44f 4000    	mov.w	r0, #0x8000
 80096d0: f7ff fdfe    	bl	0x80092d0 <LL_RCC_SetAPB2Prescaler> @ imm = #-0x404
; 	stm32_clock_control_mco_init();
 80096d4: f014 f9e1    	bl	0x801da9a <stm32_clock_control_mco_init> @ imm = #0x143c2
; 	return 0;
 80096d8: 2300         	movs	r3, #0x0
; }
 80096da: 4618         	mov	r0, r3
 80096dc: 3714         	adds	r7, #0x14
 80096de: 46bd         	mov	sp, r7
 80096e0: bd90         	pop	{r4, r7, pc}
 80096e2: bf00         	nop

080096e4 <$d>:
 80096e4: 00 7a 03 0a  	.word	0x0a037a00
 80096e8: 20 bc 02 08  	.word	0x0802bc20
 80096ec: 40 0b 00 20  	.word	0x20000b40

080096f0 <LL_APB1_GRP1_EnableClock>:
; {
 80096f0: b480         	push	{r7}
 80096f2: b085         	sub	sp, #0x14
 80096f4: af00         	add	r7, sp, #0x0
 80096f6: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(RCC->APB1ENR, Periphs);
 80096f8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800971c <LL_APB1_GRP1_EnableClock+0x2c>
 80096fa: 6c1a         	ldr	r2, [r3, #0x40]
 80096fc: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800971c <LL_APB1_GRP1_EnableClock+0x2c>
 80096fe: 687b         	ldr	r3, [r7, #0x4]
 8009700: 4313         	orrs	r3, r2
 8009702: 640b         	str	r3, [r1, #0x40]
;   tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8009704: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800971c <LL_APB1_GRP1_EnableClock+0x2c>
 8009706: 6c1a         	ldr	r2, [r3, #0x40]
 8009708: 687b         	ldr	r3, [r7, #0x4]
 800970a: 4013         	ands	r3, r2
 800970c: 60fb         	str	r3, [r7, #0xc]
;   (void)tmpreg;
 800970e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8009710: bf00         	nop
 8009712: 3714         	adds	r7, #0x14
 8009714: 46bd         	mov	sp, r7
 8009716: f85d 7b04    	ldr	r7, [sp], #4
 800971a: 4770         	bx	lr

0800971c <$d>:
 800971c: 00 38 02 40  	.word	0x40023800

08009720 <LL_RCC_PLL_ConfigDomain_SYS>:
; {
 8009720: b480         	push	{r7}
 8009722: b085         	sub	sp, #0x14
 8009724: af00         	add	r7, sp, #0x0
 8009726: 60f8         	str	r0, [r7, #0xc]
 8009728: 60b9         	str	r1, [r7, #0x8]
 800972a: 607a         	str	r2, [r7, #0x4]
 800972c: 603b         	str	r3, [r7]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN,
 800972e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8009764 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8009730: 685a         	ldr	r2, [r3, #0x4]
 8009732: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8009768 <LL_RCC_PLL_ConfigDomain_SYS+0x48>
 8009734: 4013         	ands	r3, r2
 8009736: 68f9         	ldr	r1, [r7, #0xc]
 8009738: 68ba         	ldr	r2, [r7, #0x8]
 800973a: 4311         	orrs	r1, r2
 800973c: 687a         	ldr	r2, [r7, #0x4]
 800973e: 0192         	lsls	r2, r2, #0x6
 8009740: 430a         	orrs	r2, r1
 8009742: 4908         	ldr	r1, [pc, #0x20]         @ 0x8009764 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8009744: 4313         	orrs	r3, r2
 8009746: 604b         	str	r3, [r1, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, PLLP_R);
 8009748: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8009764 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 800974a: 685b         	ldr	r3, [r3, #0x4]
 800974c: f423 3240    	bic	r2, r3, #0x30000
 8009750: 4904         	ldr	r1, [pc, #0x10]         @ 0x8009764 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8009752: 683b         	ldr	r3, [r7]
 8009754: 4313         	orrs	r3, r2
 8009756: 604b         	str	r3, [r1, #0x4]
; }
 8009758: bf00         	nop
 800975a: 3714         	adds	r7, #0x14
 800975c: 46bd         	mov	sp, r7
 800975e: f85d 7b04    	ldr	r7, [sp], #4
 8009762: 4770         	bx	lr

08009764 <$d>:
 8009764: 00 38 02 40  	.word	0x40023800
 8009768: 00 80 bf ff  	.word	0xffbf8000

0800976c <get_pllsrc_frequency>:
; {
 800976c: b480         	push	{r7}
 800976e: af00         	add	r7, sp, #0x0
; 		return STM32_HSE_FREQ;
 8009770: 4b02         	ldr	r3, [pc, #0x8]          @ 0x800977c <get_pllsrc_frequency+0x10>
; }
 8009772: 4618         	mov	r0, r3
 8009774: 46bd         	mov	sp, r7
 8009776: f85d 7b04    	ldr	r7, [sp], #4
 800977a: 4770         	bx	lr

0800977c <$d>:
 800977c: 00 1b b7 00  	.word	0x00b71b00

08009780 <console_out>:
; {
 8009780: b580         	push	{r7, lr}
 8009782: b082         	sub	sp, #0x8
 8009784: af00         	add	r7, sp, #0x0
 8009786: 6078         	str	r0, [r7, #0x4]
; 	if (pm_device_runtime_get(uart_console_dev) < 0) {
 8009788: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80097d4 <console_out+0x54>
 800978a: 4618         	mov	r0, r3
 800978c: f014 fb38    	bl	0x801de00 <pm_device_runtime_get> @ imm = #0x14670
 8009790: 4603         	mov	r3, r0
 8009792: 2b00         	cmp	r3, #0x0
 8009794: da01         	bge	0x800979a <console_out+0x1a> @ imm = #0x2
; 		return c;
 8009796: 6879         	ldr	r1, [r7, #0x4]
 8009798: e017         	b	0x80097ca <console_out+0x4a> @ imm = #0x2e
; 	if ('\n' == c) {
 800979a: 687b         	ldr	r3, [r7, #0x4]
 800979c: 2b0a         	cmp	r3, #0xa
 800979e: d104         	bne	0x80097aa <console_out+0x2a> @ imm = #0x8
; 		uart_poll_out(uart_console_dev, '\r');
 80097a0: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80097d4 <console_out+0x54>
 80097a2: 210d         	movs	r1, #0xd
 80097a4: 4618         	mov	r0, r3
 80097a6: f014 fb1c    	bl	0x801dde2 <uart_poll_out> @ imm = #0x14638
; 	uart_poll_out(uart_console_dev, c);
 80097aa: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80097d4 <console_out+0x54>
 80097ac: 687b         	ldr	r3, [r7, #0x4]
 80097ae: b2db         	uxtb	r3, r3
 80097b0: 4619         	mov	r1, r3
 80097b2: 4610         	mov	r0, r2
 80097b4: f014 fb15    	bl	0x801dde2 <uart_poll_out> @ imm = #0x1462a
; 	(void)pm_device_runtime_put_async(uart_console_dev, K_MSEC(1));
 80097b8: 4906         	ldr	r1, [pc, #0x18]         @ 0x80097d4 <console_out+0x54>
 80097ba: f04f 020a    	mov.w	r2, #0xa
 80097be: f04f 0300    	mov.w	r3, #0x0
 80097c2: 4608         	mov	r0, r1
 80097c4: f014 fb27    	bl	0x801de16 <pm_device_runtime_put_async> @ imm = #0x1464e
; 	return c;
 80097c8: 6879         	ldr	r1, [r7, #0x4]
; }
 80097ca: 460b         	mov	r3, r1
 80097cc: 4618         	mov	r0, r3
 80097ce: 3708         	adds	r7, #0x8
 80097d0: 46bd         	mov	sp, r7
 80097d2: bd80         	pop	{r7, pc}

080097d4 <$d>:
 80097d4: 60 7b 02 08  	.word	0x08027b60

080097d8 <uart_console_hook_install>:
; {
 80097d8: b580         	push	{r7, lr}
 80097da: af00         	add	r7, sp, #0x0
; 	__stdout_hook_install(console_out);
 80097dc: 4803         	ldr	r0, [pc, #0xc]          @ 0x80097ec <uart_console_hook_install+0x14>
 80097de: f7fd f881    	bl	0x80068e4 <__stdout_hook_install> @ imm = #-0x2efe
; 	__printk_hook_install(console_out);
 80097e2: 4802         	ldr	r0, [pc, #0x8]          @ 0x80097ec <uart_console_hook_install+0x14>
 80097e4: f7fa fd2a    	bl	0x800423c <__printk_hook_install> @ imm = #-0x55ac
; }
 80097e8: bf00         	nop
 80097ea: bd80         	pop	{r7, pc}

080097ec <$d>:
 80097ec: 81 97 00 08  	.word	0x08009781

080097f0 <uart_console_init>:
; {
 80097f0: b580         	push	{r7, lr}
 80097f2: af00         	add	r7, sp, #0x0
; 	if (!device_is_ready(uart_console_dev)) {
 80097f4: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8009818 <uart_console_init+0x28>
 80097f6: 4618         	mov	r0, r3
 80097f8: f014 fad4    	bl	0x801dda4 <device_is_ready> @ imm = #0x145a8
 80097fc: 4603         	mov	r3, r0
 80097fe: f083 0301    	eor	r3, r3, #0x1
 8009802: b2db         	uxtb	r3, r3
 8009804: 2b00         	cmp	r3, #0x0
 8009806: d002         	beq	0x800980e <uart_console_init+0x1e> @ imm = #0x4
; 		return -ENODEV;
 8009808: f06f 0312    	mvn	r3, #0x12
 800980c: e002         	b	0x8009814 <uart_console_init+0x24> @ imm = #0x4
; 	uart_console_hook_install();
 800980e: f7ff ffe3    	bl	0x80097d8 <uart_console_hook_install> @ imm = #-0x3a
; 	return 0;
 8009812: 2300         	movs	r3, #0x0
; }
 8009814: 4618         	mov	r0, r3
 8009816: bd80         	pop	{r7, pc}

08009818 <$d>:
 8009818: 60 7b 02 08  	.word	0x08027b60

0800981c <LL_DMA_SetDataLength>:
; {
 800981c: b480         	push	{r7}
 800981e: b085         	sub	sp, #0x14
 8009820: af00         	add	r7, sp, #0x0
 8009822: 60f8         	str	r0, [r7, #0xc]
 8009824: 60b9         	str	r1, [r7, #0x8]
 8009826: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT, NbData);
 8009828: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8009860 <LL_DMA_SetDataLength+0x44>
 800982a: 68bb         	ldr	r3, [r7, #0x8]
 800982c: 4413         	add	r3, r2
 800982e: 781b         	ldrb	r3, [r3]
 8009830: 461a         	mov	r2, r3
 8009832: 68fb         	ldr	r3, [r7, #0xc]
 8009834: 4413         	add	r3, r2
 8009836: 685b         	ldr	r3, [r3, #0x4]
 8009838: 0c1b         	lsrs	r3, r3, #0x10
 800983a: 041b         	lsls	r3, r3, #0x10
 800983c: 4908         	ldr	r1, [pc, #0x20]         @ 0x8009860 <LL_DMA_SetDataLength+0x44>
 800983e: 68ba         	ldr	r2, [r7, #0x8]
 8009840: 440a         	add	r2, r1
 8009842: 7812         	ldrb	r2, [r2]
 8009844: 4611         	mov	r1, r2
 8009846: 68fa         	ldr	r2, [r7, #0xc]
 8009848: 440a         	add	r2, r1
 800984a: 4611         	mov	r1, r2
 800984c: 687a         	ldr	r2, [r7, #0x4]
 800984e: 4313         	orrs	r3, r2
 8009850: 604b         	str	r3, [r1, #0x4]
; }
 8009852: bf00         	nop
 8009854: 3714         	adds	r7, #0x14
 8009856: 46bd         	mov	sp, r7
 8009858: f85d 7b04    	ldr	r7, [sp], #4
 800985c: 4770         	bx	lr
 800985e: bf00         	nop

08009860 <$d>:
 8009860: 64 a9 02 08  	.word	0x0802a964

08009864 <LL_DMA_GetDataLength>:
; {
 8009864: b480         	push	{r7}
 8009866: b083         	sub	sp, #0xc
 8009868: af00         	add	r7, sp, #0x0
 800986a: 6078         	str	r0, [r7, #0x4]
 800986c: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT));
 800986e: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800988c <LL_DMA_GetDataLength+0x28>
 8009870: 683b         	ldr	r3, [r7]
 8009872: 4413         	add	r3, r2
 8009874: 781b         	ldrb	r3, [r3]
 8009876: 461a         	mov	r2, r3
 8009878: 687b         	ldr	r3, [r7, #0x4]
 800987a: 4413         	add	r3, r2
 800987c: 685b         	ldr	r3, [r3, #0x4]
 800987e: b29b         	uxth	r3, r3
; }
 8009880: 4618         	mov	r0, r3
 8009882: 370c         	adds	r7, #0xc
 8009884: 46bd         	mov	sp, r7
 8009886: f85d 7b04    	ldr	r7, [sp], #4
 800988a: 4770         	bx	lr

0800988c <$d>:
 800988c: 64 a9 02 08  	.word	0x0802a964

08009890 <LL_DMA_DisableFifoMode>:
; {
 8009890: b480         	push	{r7}
 8009892: b083         	sub	sp, #0xc
 8009894: af00         	add	r7, sp, #0x0
 8009896: 6078         	str	r0, [r7, #0x4]
 8009898: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_DMDIS);
 800989a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80098cc <LL_DMA_DisableFifoMode+0x3c>
 800989c: 683b         	ldr	r3, [r7]
 800989e: 4413         	add	r3, r2
 80098a0: 781b         	ldrb	r3, [r3]
 80098a2: 461a         	mov	r2, r3
 80098a4: 687b         	ldr	r3, [r7, #0x4]
 80098a6: 4413         	add	r3, r2
 80098a8: 695b         	ldr	r3, [r3, #0x14]
 80098aa: 4908         	ldr	r1, [pc, #0x20]         @ 0x80098cc <LL_DMA_DisableFifoMode+0x3c>
 80098ac: 683a         	ldr	r2, [r7]
 80098ae: 440a         	add	r2, r1
 80098b0: 7812         	ldrb	r2, [r2]
 80098b2: 4611         	mov	r1, r2
 80098b4: 687a         	ldr	r2, [r7, #0x4]
 80098b6: 440a         	add	r2, r1
 80098b8: f023 0304    	bic	r3, r3, #0x4
 80098bc: 6153         	str	r3, [r2, #0x14]
; }
 80098be: bf00         	nop
 80098c0: 370c         	adds	r7, #0xc
 80098c2: 46bd         	mov	sp, r7
 80098c4: f85d 7b04    	ldr	r7, [sp], #4
 80098c8: 4770         	bx	lr
 80098ca: bf00         	nop

080098cc <$d>:
 80098cc: 64 a9 02 08  	.word	0x0802a964

080098d0 <LL_DMA_EnableFifoMode>:
; {
 80098d0: b480         	push	{r7}
 80098d2: b083         	sub	sp, #0xc
 80098d4: af00         	add	r7, sp, #0x0
 80098d6: 6078         	str	r0, [r7, #0x4]
 80098d8: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_DMDIS);
 80098da: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800990c <LL_DMA_EnableFifoMode+0x3c>
 80098dc: 683b         	ldr	r3, [r7]
 80098de: 4413         	add	r3, r2
 80098e0: 781b         	ldrb	r3, [r3]
 80098e2: 461a         	mov	r2, r3
 80098e4: 687b         	ldr	r3, [r7, #0x4]
 80098e6: 4413         	add	r3, r2
 80098e8: 695b         	ldr	r3, [r3, #0x14]
 80098ea: 4908         	ldr	r1, [pc, #0x20]         @ 0x800990c <LL_DMA_EnableFifoMode+0x3c>
 80098ec: 683a         	ldr	r2, [r7]
 80098ee: 440a         	add	r2, r1
 80098f0: 7812         	ldrb	r2, [r2]
 80098f2: 4611         	mov	r1, r2
 80098f4: 687a         	ldr	r2, [r7, #0x4]
 80098f6: 440a         	add	r2, r1
 80098f8: f043 0304    	orr	r3, r3, #0x4
 80098fc: 6153         	str	r3, [r2, #0x14]
; }
 80098fe: bf00         	nop
 8009900: 370c         	adds	r7, #0xc
 8009902: 46bd         	mov	sp, r7
 8009904: f85d 7b04    	ldr	r7, [sp], #4
 8009908: 4770         	bx	lr
 800990a: bf00         	nop

0800990c <$d>:
 800990c: 64 a9 02 08  	.word	0x0802a964

08009910 <LL_DMA_SetMemoryAddress>:
; {
 8009910: b480         	push	{r7}
 8009912: b085         	sub	sp, #0x14
 8009914: af00         	add	r7, sp, #0x0
 8009916: 60f8         	str	r0, [r7, #0xc]
 8009918: 60b9         	str	r1, [r7, #0x8]
 800991a: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->M0AR, MemoryAddress);
 800991c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800993c <LL_DMA_SetMemoryAddress+0x2c>
 800991e: 68bb         	ldr	r3, [r7, #0x8]
 8009920: 4413         	add	r3, r2
 8009922: 781b         	ldrb	r3, [r3]
 8009924: 461a         	mov	r2, r3
 8009926: 68fb         	ldr	r3, [r7, #0xc]
 8009928: 4413         	add	r3, r2
 800992a: 461a         	mov	r2, r3
 800992c: 687b         	ldr	r3, [r7, #0x4]
 800992e: 60d3         	str	r3, [r2, #0xc]
; }
 8009930: bf00         	nop
 8009932: 3714         	adds	r7, #0x14
 8009934: 46bd         	mov	sp, r7
 8009936: f85d 7b04    	ldr	r7, [sp], #4
 800993a: 4770         	bx	lr

0800993c <$d>:
 800993c: 64 a9 02 08  	.word	0x0802a964

08009940 <LL_DMA_SetPeriphAddress>:
; {
 8009940: b480         	push	{r7}
 8009942: b085         	sub	sp, #0x14
 8009944: af00         	add	r7, sp, #0x0
 8009946: 60f8         	str	r0, [r7, #0xc]
 8009948: 60b9         	str	r1, [r7, #0x8]
 800994a: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->PAR, PeriphAddress);
 800994c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800996c <LL_DMA_SetPeriphAddress+0x2c>
 800994e: 68bb         	ldr	r3, [r7, #0x8]
 8009950: 4413         	add	r3, r2
 8009952: 781b         	ldrb	r3, [r3]
 8009954: 461a         	mov	r2, r3
 8009956: 68fb         	ldr	r3, [r7, #0xc]
 8009958: 4413         	add	r3, r2
 800995a: 461a         	mov	r2, r3
 800995c: 687b         	ldr	r3, [r7, #0x4]
 800995e: 6093         	str	r3, [r2, #0x8]
; }
 8009960: bf00         	nop
 8009962: 3714         	adds	r7, #0x14
 8009964: 46bd         	mov	sp, r7
 8009966: f85d 7b04    	ldr	r7, [sp], #4
 800996a: 4770         	bx	lr

0800996c <$d>:
 800996c: 64 a9 02 08  	.word	0x0802a964

08009970 <LL_DMA_EnableIT_HT>:
; {
 8009970: b480         	push	{r7}
 8009972: b083         	sub	sp, #0xc
 8009974: af00         	add	r7, sp, #0x0
 8009976: 6078         	str	r0, [r7, #0x4]
 8009978: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_HTIE);
 800997a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80099ac <LL_DMA_EnableIT_HT+0x3c>
 800997c: 683b         	ldr	r3, [r7]
 800997e: 4413         	add	r3, r2
 8009980: 781b         	ldrb	r3, [r3]
 8009982: 461a         	mov	r2, r3
 8009984: 687b         	ldr	r3, [r7, #0x4]
 8009986: 4413         	add	r3, r2
 8009988: 681b         	ldr	r3, [r3]
 800998a: 4908         	ldr	r1, [pc, #0x20]         @ 0x80099ac <LL_DMA_EnableIT_HT+0x3c>
 800998c: 683a         	ldr	r2, [r7]
 800998e: 440a         	add	r2, r1
 8009990: 7812         	ldrb	r2, [r2]
 8009992: 4611         	mov	r1, r2
 8009994: 687a         	ldr	r2, [r7, #0x4]
 8009996: 440a         	add	r2, r1
 8009998: f043 0308    	orr	r3, r3, #0x8
 800999c: 6013         	str	r3, [r2]
; }
 800999e: bf00         	nop
 80099a0: 370c         	adds	r7, #0xc
 80099a2: 46bd         	mov	sp, r7
 80099a4: f85d 7b04    	ldr	r7, [sp], #4
 80099a8: 4770         	bx	lr
 80099aa: bf00         	nop

080099ac <$d>:
 80099ac: 64 a9 02 08  	.word	0x0802a964

080099b0 <LL_DMA_EnableIT_TC>:
; {
 80099b0: b480         	push	{r7}
 80099b2: b083         	sub	sp, #0xc
 80099b4: af00         	add	r7, sp, #0x0
 80099b6: 6078         	str	r0, [r7, #0x4]
 80099b8: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE);
 80099ba: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80099ec <LL_DMA_EnableIT_TC+0x3c>
 80099bc: 683b         	ldr	r3, [r7]
 80099be: 4413         	add	r3, r2
 80099c0: 781b         	ldrb	r3, [r3]
 80099c2: 461a         	mov	r2, r3
 80099c4: 687b         	ldr	r3, [r7, #0x4]
 80099c6: 4413         	add	r3, r2
 80099c8: 681b         	ldr	r3, [r3]
 80099ca: 4908         	ldr	r1, [pc, #0x20]         @ 0x80099ec <LL_DMA_EnableIT_TC+0x3c>
 80099cc: 683a         	ldr	r2, [r7]
 80099ce: 440a         	add	r2, r1
 80099d0: 7812         	ldrb	r2, [r2]
 80099d2: 4611         	mov	r1, r2
 80099d4: 687a         	ldr	r2, [r7, #0x4]
 80099d6: 440a         	add	r2, r1
 80099d8: f043 0310    	orr	r3, r3, #0x10
 80099dc: 6013         	str	r3, [r2]
; }
 80099de: bf00         	nop
 80099e0: 370c         	adds	r7, #0xc
 80099e2: 46bd         	mov	sp, r7
 80099e4: f85d 7b04    	ldr	r7, [sp], #4
 80099e8: 4770         	bx	lr
 80099ea: bf00         	nop

080099ec <$d>:
 80099ec: 64 a9 02 08  	.word	0x0802a964

080099f0 <LL_DMA_EnableIT_FE>:
; {
 80099f0: b480         	push	{r7}
 80099f2: b083         	sub	sp, #0xc
 80099f4: af00         	add	r7, sp, #0x0
 80099f6: 6078         	str	r0, [r7, #0x4]
 80099f8: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 80099fa: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8009a2c <LL_DMA_EnableIT_FE+0x3c>
 80099fc: 683b         	ldr	r3, [r7]
 80099fe: 4413         	add	r3, r2
 8009a00: 781b         	ldrb	r3, [r3]
 8009a02: 461a         	mov	r2, r3
 8009a04: 687b         	ldr	r3, [r7, #0x4]
 8009a06: 4413         	add	r3, r2
 8009a08: 695b         	ldr	r3, [r3, #0x14]
 8009a0a: 4908         	ldr	r1, [pc, #0x20]         @ 0x8009a2c <LL_DMA_EnableIT_FE+0x3c>
 8009a0c: 683a         	ldr	r2, [r7]
 8009a0e: 440a         	add	r2, r1
 8009a10: 7812         	ldrb	r2, [r2]
 8009a12: 4611         	mov	r1, r2
 8009a14: 687a         	ldr	r2, [r7, #0x4]
 8009a16: 440a         	add	r2, r1
 8009a18: f043 0380    	orr	r3, r3, #0x80
 8009a1c: 6153         	str	r3, [r2, #0x14]
; }
 8009a1e: bf00         	nop
 8009a20: 370c         	adds	r7, #0xc
 8009a22: 46bd         	mov	sp, r7
 8009a24: f85d 7b04    	ldr	r7, [sp], #4
 8009a28: 4770         	bx	lr
 8009a2a: bf00         	nop

08009a2c <$d>:
 8009a2c: 64 a9 02 08  	.word	0x0802a964

08009a30 <LL_DMA_DisableIT_TC>:
; {
 8009a30: b480         	push	{r7}
 8009a32: b083         	sub	sp, #0xc
 8009a34: af00         	add	r7, sp, #0x0
 8009a36: 6078         	str	r0, [r7, #0x4]
 8009a38: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE);
 8009a3a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8009a6c <LL_DMA_DisableIT_TC+0x3c>
 8009a3c: 683b         	ldr	r3, [r7]
 8009a3e: 4413         	add	r3, r2
 8009a40: 781b         	ldrb	r3, [r3]
 8009a42: 461a         	mov	r2, r3
 8009a44: 687b         	ldr	r3, [r7, #0x4]
 8009a46: 4413         	add	r3, r2
 8009a48: 681b         	ldr	r3, [r3]
 8009a4a: 4908         	ldr	r1, [pc, #0x20]         @ 0x8009a6c <LL_DMA_DisableIT_TC+0x3c>
 8009a4c: 683a         	ldr	r2, [r7]
 8009a4e: 440a         	add	r2, r1
 8009a50: 7812         	ldrb	r2, [r2]
 8009a52: 4611         	mov	r1, r2
 8009a54: 687a         	ldr	r2, [r7, #0x4]
 8009a56: 440a         	add	r2, r1
 8009a58: f023 0310    	bic	r3, r3, #0x10
 8009a5c: 6013         	str	r3, [r2]
; }
 8009a5e: bf00         	nop
 8009a60: 370c         	adds	r7, #0xc
 8009a62: 46bd         	mov	sp, r7
 8009a64: f85d 7b04    	ldr	r7, [sp], #4
 8009a68: 4770         	bx	lr
 8009a6a: bf00         	nop

08009a6c <$d>:
 8009a6c: 64 a9 02 08  	.word	0x0802a964

08009a70 <LL_DMA_DisableIT_FE>:
; {
 8009a70: b480         	push	{r7}
 8009a72: b083         	sub	sp, #0xc
 8009a74: af00         	add	r7, sp, #0x0
 8009a76: 6078         	str	r0, [r7, #0x4]
 8009a78: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 8009a7a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8009aac <LL_DMA_DisableIT_FE+0x3c>
 8009a7c: 683b         	ldr	r3, [r7]
 8009a7e: 4413         	add	r3, r2
 8009a80: 781b         	ldrb	r3, [r3]
 8009a82: 461a         	mov	r2, r3
 8009a84: 687b         	ldr	r3, [r7, #0x4]
 8009a86: 4413         	add	r3, r2
 8009a88: 695b         	ldr	r3, [r3, #0x14]
 8009a8a: 4908         	ldr	r1, [pc, #0x20]         @ 0x8009aac <LL_DMA_DisableIT_FE+0x3c>
 8009a8c: 683a         	ldr	r2, [r7]
 8009a8e: 440a         	add	r2, r1
 8009a90: 7812         	ldrb	r2, [r2]
 8009a92: 4611         	mov	r1, r2
 8009a94: 687a         	ldr	r2, [r7, #0x4]
 8009a96: 440a         	add	r2, r1
 8009a98: f023 0380    	bic	r3, r3, #0x80
 8009a9c: 6153         	str	r3, [r2, #0x14]
; }
 8009a9e: bf00         	nop
 8009aa0: 370c         	adds	r7, #0xc
 8009aa2: 46bd         	mov	sp, r7
 8009aa4: f85d 7b04    	ldr	r7, [sp], #4
 8009aa8: 4770         	bx	lr
 8009aaa: bf00         	nop

08009aac <$d>:
 8009aac: 64 a9 02 08  	.word	0x0802a964

08009ab0 <dma_stm32_irq_handler>:
; {
 8009ab0: b590         	push	{r4, r7, lr}
 8009ab2: b08f         	sub	sp, #0x3c
 8009ab4: af04         	add	r7, sp, #0x10
 8009ab6: 6078         	str	r0, [r7, #0x4]
 8009ab8: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8009aba: 687b         	ldr	r3, [r7, #0x4]
 8009abc: 685b         	ldr	r3, [r3, #0x4]
 8009abe: 627b         	str	r3, [r7, #0x24]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8009ac0: 6a7b         	ldr	r3, [r7, #0x24]
 8009ac2: 691b         	ldr	r3, [r3, #0x10]
 8009ac4: 623b         	str	r3, [r7, #0x20]
; 	stream = &config->streams[id];
 8009ac6: 6a7b         	ldr	r3, [r7, #0x24]
 8009ac8: 6999         	ldr	r1, [r3, #0x18]
 8009aca: 683a         	ldr	r2, [r7]
 8009acc: 4613         	mov	r3, r2
 8009ace: 00db         	lsls	r3, r3, #0x3
 8009ad0: 1a9b         	subs	r3, r3, r2
 8009ad2: 009b         	lsls	r3, r3, #0x2
 8009ad4: 440b         	add	r3, r1
 8009ad6: 61fb         	str	r3, [r7, #0x1c]
; 	if ((stream->hal_override != true) && (stream->busy == false)) {
 8009ad8: 69fb         	ldr	r3, [r7, #0x1c]
 8009ada: 795b         	ldrb	r3, [r3, #0x5]
 8009adc: f083 0301    	eor	r3, r3, #0x1
 8009ae0: b2db         	uxtb	r3, r3
 8009ae2: 2b00         	cmp	r3, #0x0
 8009ae4: d00c         	beq	0x8009b00 <dma_stm32_irq_handler+0x50> @ imm = #0x18
 8009ae6: 69fb         	ldr	r3, [r7, #0x1c]
 8009ae8: 799b         	ldrb	r3, [r3, #0x6]
 8009aea: b2db         	uxtb	r3, r3
 8009aec: f083 0301    	eor	r3, r3, #0x1
 8009af0: b2db         	uxtb	r3, r3
 8009af2: 2b00         	cmp	r3, #0x0
 8009af4: d004         	beq	0x8009b00 <dma_stm32_irq_handler+0x50> @ imm = #0x8
; 		dma_stm32_clear_stream_irq(dev, id);
 8009af6: 6839         	ldr	r1, [r7]
 8009af8: 6878         	ldr	r0, [r7, #0x4]
 8009afa: f014 f9f6    	bl	0x801deea <dma_stm32_clear_stream_irq> @ imm = #0x143ec
; 		return;
 8009afe: e09a         	b	0x8009c36 <dma_stm32_irq_handler+0x186> @ imm = #0x134
; 	callback_arg = id + STM32_DMA_STREAM_OFFSET;
 8009b00: 683b         	ldr	r3, [r7]
 8009b02: 61bb         	str	r3, [r7, #0x18]
; 	if (stm32_dma_is_ht_irq_active(dma, id)) {
 8009b04: 6839         	ldr	r1, [r7]
 8009b06: 6a38         	ldr	r0, [r7, #0x20]
 8009b08: f015 fa28    	bl	0x801ef5c <stm32_dma_is_ht_irq_active> @ imm = #0x15450
 8009b0c: 4603         	mov	r3, r0
 8009b0e: 2b00         	cmp	r3, #0x0
 8009b10: d013         	beq	0x8009b3a <dma_stm32_irq_handler+0x8a> @ imm = #0x26
; 		if (!stream->hal_override) {
 8009b12: 69fb         	ldr	r3, [r7, #0x1c]
 8009b14: 795b         	ldrb	r3, [r3, #0x5]
 8009b16: f083 0301    	eor	r3, r3, #0x1
 8009b1a: b2db         	uxtb	r3, r3
 8009b1c: 2b00         	cmp	r3, #0x0
 8009b1e: d003         	beq	0x8009b28 <dma_stm32_irq_handler+0x78> @ imm = #0x6
; 			dma_stm32_clear_ht(dma, id);
 8009b20: 6839         	ldr	r1, [r7]
 8009b22: 6a38         	ldr	r0, [r7, #0x20]
 8009b24: f000 ff8c    	bl	0x800aa40 <dma_stm32_clear_ht> @ imm = #0xf18
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_BLOCK);
 8009b28: 69fb         	ldr	r3, [r7, #0x1c]
 8009b2a: 695c         	ldr	r4, [r3, #0x14]
 8009b2c: 69fb         	ldr	r3, [r7, #0x1c]
 8009b2e: 6919         	ldr	r1, [r3, #0x10]
 8009b30: 2301         	movs	r3, #0x1
 8009b32: 69ba         	ldr	r2, [r7, #0x18]
 8009b34: 6878         	ldr	r0, [r7, #0x4]
 8009b36: 47a0         	blx	r4
 8009b38: e07d         	b	0x8009c36 <dma_stm32_irq_handler+0x186> @ imm = #0xfa
; 	} else if (stm32_dma_is_tc_irq_active(dma, id)) {
 8009b3a: 6839         	ldr	r1, [r7]
 8009b3c: 6a38         	ldr	r0, [r7, #0x20]
 8009b3e: f015 f9ec    	bl	0x801ef1a <stm32_dma_is_tc_irq_active> @ imm = #0x153d8
 8009b42: 4603         	mov	r3, r0
 8009b44: 2b00         	cmp	r3, #0x0
 8009b46: d01d         	beq	0x8009b84 <dma_stm32_irq_handler+0xd4> @ imm = #0x3a
; 		if (!stream->cyclic) {
 8009b48: 69fb         	ldr	r3, [r7, #0x1c]
 8009b4a: 7e1b         	ldrb	r3, [r3, #0x18]
 8009b4c: f083 0301    	eor	r3, r3, #0x1
 8009b50: b2db         	uxtb	r3, r3
 8009b52: 2b00         	cmp	r3, #0x0
 8009b54: d002         	beq	0x8009b5c <dma_stm32_irq_handler+0xac> @ imm = #0x4
; 			stream->busy = false;
 8009b56: 69fb         	ldr	r3, [r7, #0x1c]
 8009b58: 2200         	movs	r2, #0x0
 8009b5a: 719a         	strb	r2, [r3, #0x6]
; 		if (!stream->hal_override) {
 8009b5c: 69fb         	ldr	r3, [r7, #0x1c]
 8009b5e: 795b         	ldrb	r3, [r3, #0x5]
 8009b60: f083 0301    	eor	r3, r3, #0x1
 8009b64: b2db         	uxtb	r3, r3
 8009b66: 2b00         	cmp	r3, #0x0
 8009b68: d003         	beq	0x8009b72 <dma_stm32_irq_handler+0xc2> @ imm = #0x6
; 			dma_stm32_clear_tc(dma, id);
 8009b6a: 6839         	ldr	r1, [r7]
 8009b6c: 6a38         	ldr	r0, [r7, #0x20]
 8009b6e: f000 ff79    	bl	0x800aa64 <dma_stm32_clear_tc> @ imm = #0xef2
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_COMPLETE);
 8009b72: 69fb         	ldr	r3, [r7, #0x1c]
 8009b74: 695c         	ldr	r4, [r3, #0x14]
 8009b76: 69fb         	ldr	r3, [r7, #0x1c]
 8009b78: 6919         	ldr	r1, [r3, #0x10]
 8009b7a: 2300         	movs	r3, #0x0
 8009b7c: 69ba         	ldr	r2, [r7, #0x18]
 8009b7e: 6878         	ldr	r0, [r7, #0x4]
 8009b80: 47a0         	blx	r4
 8009b82: e058         	b	0x8009c36 <dma_stm32_irq_handler+0x186> @ imm = #0xb0
; 	} else if (stm32_dma_is_unexpected_irq_happened(dma, id)) {
 8009b84: 6839         	ldr	r1, [r7]
 8009b86: 6a38         	ldr	r0, [r7, #0x20]
 8009b88: f001 f87a    	bl	0x800ac80 <stm32_dma_is_unexpected_irq_happened> @ imm = #0x10f4
 8009b8c: 4603         	mov	r3, r0
 8009b8e: 2b00         	cmp	r3, #0x0
 8009b90: d023         	beq	0x8009bda <dma_stm32_irq_handler+0x12a> @ imm = #0x46
; 		LOG_ERR("Unexpected irq happened.");
 8009b92: 2303         	movs	r3, #0x3
 8009b94: 2b00         	cmp	r3, #0x0
 8009b96: d016         	beq	0x8009bc6 <dma_stm32_irq_handler+0x116> @ imm = #0x2c
 8009b98: 2301         	movs	r3, #0x1
 8009b9a: 73fb         	strb	r3, [r7, #0xf]
 8009b9c: 7bfb         	ldrb	r3, [r7, #0xf]
 8009b9e: f083 0301    	eor	r3, r3, #0x1
 8009ba2: b2db         	uxtb	r3, r3
 8009ba4: 2b00         	cmp	r3, #0x0
 8009ba6: d10e         	bne	0x8009bc6 <dma_stm32_irq_handler+0x116> @ imm = #0x1c
 8009ba8: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8009c3c <dma_stm32_irq_handler+0x18c>
 8009baa: 6819         	ldr	r1, [r3]
 8009bac: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8009c40 <dma_stm32_irq_handler+0x190>
 8009bae: 9302         	str	r3, [sp, #0x8]
 8009bb0: 2300         	movs	r3, #0x0
 8009bb2: 9301         	str	r3, [sp, #0x4]
 8009bb4: 2300         	movs	r3, #0x0
 8009bb6: 9300         	str	r3, [sp]
 8009bb8: 2300         	movs	r3, #0x0
 8009bba: 2201         	movs	r2, #0x1
 8009bbc: 2000         	movs	r0, #0x0
 8009bbe: f014 f963    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x142c6
 8009bc2: 2300         	movs	r3, #0x0
 8009bc4: 60bb         	str	r3, [r7, #0x8]
; 		stream->dma_callback(dev, stream->user_data,
 8009bc6: 69fb         	ldr	r3, [r7, #0x1c]
 8009bc8: 695c         	ldr	r4, [r3, #0x14]
 8009bca: 69fb         	ldr	r3, [r7, #0x1c]
 8009bcc: 6919         	ldr	r1, [r3, #0x10]
 8009bce: f06f 0304    	mvn	r3, #0x4
 8009bd2: 69ba         	ldr	r2, [r7, #0x18]
 8009bd4: 6878         	ldr	r0, [r7, #0x4]
 8009bd6: 47a0         	blx	r4
 8009bd8: e02d         	b	0x8009c36 <dma_stm32_irq_handler+0x186> @ imm = #0x5a
; 		LOG_ERR("Transfer Error.");
 8009bda: 2303         	movs	r3, #0x3
 8009bdc: 2b00         	cmp	r3, #0x0
 8009bde: d016         	beq	0x8009c0e <dma_stm32_irq_handler+0x15e> @ imm = #0x2c
 8009be0: 2301         	movs	r3, #0x1
 8009be2: 75fb         	strb	r3, [r7, #0x17]
 8009be4: 7dfb         	ldrb	r3, [r7, #0x17]
 8009be6: f083 0301    	eor	r3, r3, #0x1
 8009bea: b2db         	uxtb	r3, r3
 8009bec: 2b00         	cmp	r3, #0x0
 8009bee: d10e         	bne	0x8009c0e <dma_stm32_irq_handler+0x15e> @ imm = #0x1c
 8009bf0: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8009c3c <dma_stm32_irq_handler+0x18c>
 8009bf2: 6819         	ldr	r1, [r3]
 8009bf4: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8009c44 <dma_stm32_irq_handler+0x194>
 8009bf6: 9302         	str	r3, [sp, #0x8]
 8009bf8: 2300         	movs	r3, #0x0
 8009bfa: 9301         	str	r3, [sp, #0x4]
 8009bfc: 2300         	movs	r3, #0x0
 8009bfe: 9300         	str	r3, [sp]
 8009c00: 2300         	movs	r3, #0x0
 8009c02: 2201         	movs	r2, #0x1
 8009c04: 2000         	movs	r0, #0x0
 8009c06: f014 f93f    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x1427e
 8009c0a: 2300         	movs	r3, #0x0
 8009c0c: 613b         	str	r3, [r7, #0x10]
; 		stream->busy = false;
 8009c0e: 69fb         	ldr	r3, [r7, #0x1c]
 8009c10: 2200         	movs	r2, #0x0
 8009c12: 719a         	strb	r2, [r3, #0x6]
; 		dma_stm32_dump_stream_irq(dev, id);
 8009c14: 6839         	ldr	r1, [r7]
 8009c16: 6878         	ldr	r0, [r7, #0x4]
 8009c18: f014 f954    	bl	0x801dec4 <dma_stm32_dump_stream_irq> @ imm = #0x142a8
; 		dma_stm32_clear_stream_irq(dev, id);
 8009c1c: 6839         	ldr	r1, [r7]
 8009c1e: 6878         	ldr	r0, [r7, #0x4]
 8009c20: f014 f963    	bl	0x801deea <dma_stm32_clear_stream_irq> @ imm = #0x142c6
; 		stream->dma_callback(dev, stream->user_data,
 8009c24: 69fb         	ldr	r3, [r7, #0x1c]
 8009c26: 695c         	ldr	r4, [r3, #0x14]
 8009c28: 69fb         	ldr	r3, [r7, #0x1c]
 8009c2a: 6919         	ldr	r1, [r3, #0x10]
 8009c2c: f06f 0304    	mvn	r3, #0x4
 8009c30: 69ba         	ldr	r2, [r7, #0x18]
 8009c32: 6878         	ldr	r0, [r7, #0x4]
 8009c34: 47a0         	blx	r4
; }
 8009c36: 372c         	adds	r7, #0x2c
 8009c38: 46bd         	mov	sp, r7
 8009c3a: bd90         	pop	{r4, r7, pc}

08009c3c <$d>:
 8009c3c: 38 05 00 20  	.word	0x20000538
 8009c40: fc 8f 02 08  	.word	0x08028ffc
 8009c44: 18 90 02 08  	.word	0x08029018

08009c48 <dma_stm32_get_priority>:
; {
 8009c48: b580         	push	{r7, lr}
 8009c4a: b088         	sub	sp, #0x20
 8009c4c: af04         	add	r7, sp, #0x10
 8009c4e: 4603         	mov	r3, r0
 8009c50: 6039         	str	r1, [r7]
 8009c52: 71fb         	strb	r3, [r7, #0x7]
; 	switch (priority) {
 8009c54: 79fb         	ldrb	r3, [r7, #0x7]
 8009c56: 2b03         	cmp	r3, #0x3
 8009c58: d81d         	bhi	0x8009c96 <dma_stm32_get_priority+0x4e> @ imm = #0x3a
 8009c5a: a201         	adr	r2, #4 <dma_stm32_get_priority+0x17>
 8009c5c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08009c60 <$d>:
 8009c60: 71 9c 00 08  	.word	0x08009c71
 8009c64: 79 9c 00 08  	.word	0x08009c79
 8009c68: 83 9c 00 08  	.word	0x08009c83
 8009c6c: 8d 9c 00 08  	.word	0x08009c8d

08009c70 <$t>:
; 		*ll_priority = LL_DMA_PRIORITY_LOW;
 8009c70: 683b         	ldr	r3, [r7]
 8009c72: 2200         	movs	r2, #0x0
 8009c74: 601a         	str	r2, [r3]
; 		break;
 8009c76: e02d         	b	0x8009cd4 <dma_stm32_get_priority+0x8c> @ imm = #0x5a
; 		*ll_priority = LL_DMA_PRIORITY_MEDIUM;
 8009c78: 683b         	ldr	r3, [r7]
 8009c7a: f44f 3280    	mov.w	r2, #0x10000
 8009c7e: 601a         	str	r2, [r3]
; 		break;
 8009c80: e028         	b	0x8009cd4 <dma_stm32_get_priority+0x8c> @ imm = #0x50
; 		*ll_priority = LL_DMA_PRIORITY_HIGH;
 8009c82: 683b         	ldr	r3, [r7]
 8009c84: f44f 3200    	mov.w	r2, #0x20000
 8009c88: 601a         	str	r2, [r3]
; 		break;
 8009c8a: e023         	b	0x8009cd4 <dma_stm32_get_priority+0x8c> @ imm = #0x46
; 		*ll_priority = LL_DMA_PRIORITY_VERYHIGH;
 8009c8c: 683b         	ldr	r3, [r7]
 8009c8e: f44f 3240    	mov.w	r2, #0x30000
 8009c92: 601a         	str	r2, [r3]
; 		break;
 8009c94: e01e         	b	0x8009cd4 <dma_stm32_get_priority+0x8c> @ imm = #0x3c
; 		LOG_ERR("Priority error. %d", priority);
 8009c96: 2303         	movs	r3, #0x3
 8009c98: 2b00         	cmp	r3, #0x0
 8009c9a: d018         	beq	0x8009cce <dma_stm32_get_priority+0x86> @ imm = #0x30
 8009c9c: 2301         	movs	r3, #0x1
 8009c9e: 73fb         	strb	r3, [r7, #0xf]
 8009ca0: 7bfb         	ldrb	r3, [r7, #0xf]
 8009ca2: f083 0301    	eor	r3, r3, #0x1
 8009ca6: b2db         	uxtb	r3, r3
 8009ca8: 2b00         	cmp	r3, #0x0
 8009caa: d110         	bne	0x8009cce <dma_stm32_get_priority+0x86> @ imm = #0x20
 8009cac: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8009ce0 <dma_stm32_get_priority+0x98>
 8009cae: 6819         	ldr	r1, [r3]
 8009cb0: 79fb         	ldrb	r3, [r7, #0x7]
 8009cb2: 9303         	str	r3, [sp, #0xc]
 8009cb4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8009ce4 <dma_stm32_get_priority+0x9c>
 8009cb6: 9302         	str	r3, [sp, #0x8]
 8009cb8: 2300         	movs	r3, #0x0
 8009cba: 9301         	str	r3, [sp, #0x4]
 8009cbc: 2300         	movs	r3, #0x0
 8009cbe: 9300         	str	r3, [sp]
 8009cc0: 2300         	movs	r3, #0x0
 8009cc2: 2201         	movs	r2, #0x1
 8009cc4: 2000         	movs	r0, #0x0
 8009cc6: f014 f8df    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x141be
 8009cca: 2300         	movs	r3, #0x0
 8009ccc: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8009cce: f06f 0315    	mvn	r3, #0x15
 8009cd2: e000         	b	0x8009cd6 <dma_stm32_get_priority+0x8e> @ imm = #0x0
; 	return 0;
 8009cd4: 2300         	movs	r3, #0x0
; }
 8009cd6: 4618         	mov	r0, r3
 8009cd8: 3710         	adds	r7, #0x10
 8009cda: 46bd         	mov	sp, r7
 8009cdc: bd80         	pop	{r7, pc}
 8009cde: bf00         	nop

08009ce0 <$d>:
 8009ce0: 38 05 00 20  	.word	0x20000538
 8009ce4: 28 90 02 08  	.word	0x08029028

08009ce8 <dma_stm32_get_direction>:
; {
 8009ce8: b580         	push	{r7, lr}
 8009cea: b088         	sub	sp, #0x20
 8009cec: af04         	add	r7, sp, #0x10
 8009cee: 4603         	mov	r3, r0
 8009cf0: 6039         	str	r1, [r7]
 8009cf2: 71fb         	strb	r3, [r7, #0x7]
; 	switch (direction) {
 8009cf4: 79fb         	ldrb	r3, [r7, #0x7]
 8009cf6: 2b02         	cmp	r3, #0x2
 8009cf8: d00e         	beq	0x8009d18 <dma_stm32_get_direction+0x30> @ imm = #0x1c
 8009cfa: 2b02         	cmp	r3, #0x2
 8009cfc: dc10         	bgt	0x8009d20 <dma_stm32_get_direction+0x38> @ imm = #0x20
 8009cfe: 2b00         	cmp	r3, #0x0
 8009d00: d002         	beq	0x8009d08 <dma_stm32_get_direction+0x20> @ imm = #0x4
 8009d02: 2b01         	cmp	r3, #0x1
 8009d04: d004         	beq	0x8009d10 <dma_stm32_get_direction+0x28> @ imm = #0x8
 8009d06: e00b         	b	0x8009d20 <dma_stm32_get_direction+0x38> @ imm = #0x16
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_MEMORY;
 8009d08: 683b         	ldr	r3, [r7]
 8009d0a: 2280         	movs	r2, #0x80
 8009d0c: 601a         	str	r2, [r3]
; 		break;
 8009d0e: e026         	b	0x8009d5e <dma_stm32_get_direction+0x76> @ imm = #0x4c
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_PERIPH;
 8009d10: 683b         	ldr	r3, [r7]
 8009d12: 2240         	movs	r2, #0x40
 8009d14: 601a         	str	r2, [r3]
; 		break;
 8009d16: e022         	b	0x8009d5e <dma_stm32_get_direction+0x76> @ imm = #0x44
; 		*ll_direction = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 8009d18: 683b         	ldr	r3, [r7]
 8009d1a: 2200         	movs	r2, #0x0
 8009d1c: 601a         	str	r2, [r3]
; 		break;
 8009d1e: e01e         	b	0x8009d5e <dma_stm32_get_direction+0x76> @ imm = #0x3c
; 		LOG_ERR("Direction error. %d", direction);
 8009d20: 2303         	movs	r3, #0x3
 8009d22: 2b00         	cmp	r3, #0x0
 8009d24: d018         	beq	0x8009d58 <dma_stm32_get_direction+0x70> @ imm = #0x30
 8009d26: 2301         	movs	r3, #0x1
 8009d28: 73fb         	strb	r3, [r7, #0xf]
 8009d2a: 7bfb         	ldrb	r3, [r7, #0xf]
 8009d2c: f083 0301    	eor	r3, r3, #0x1
 8009d30: b2db         	uxtb	r3, r3
 8009d32: 2b00         	cmp	r3, #0x0
 8009d34: d110         	bne	0x8009d58 <dma_stm32_get_direction+0x70> @ imm = #0x20
 8009d36: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8009d68 <dma_stm32_get_direction+0x80>
 8009d38: 6819         	ldr	r1, [r3]
 8009d3a: 79fb         	ldrb	r3, [r7, #0x7]
 8009d3c: 9303         	str	r3, [sp, #0xc]
 8009d3e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8009d6c <dma_stm32_get_direction+0x84>
 8009d40: 9302         	str	r3, [sp, #0x8]
 8009d42: 2300         	movs	r3, #0x0
 8009d44: 9301         	str	r3, [sp, #0x4]
 8009d46: 2300         	movs	r3, #0x0
 8009d48: 9300         	str	r3, [sp]
 8009d4a: 2300         	movs	r3, #0x0
 8009d4c: 2201         	movs	r2, #0x1
 8009d4e: 2000         	movs	r0, #0x0
 8009d50: f014 f89a    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x14134
 8009d54: 2300         	movs	r3, #0x0
 8009d56: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8009d58: f06f 0315    	mvn	r3, #0x15
 8009d5c: e000         	b	0x8009d60 <dma_stm32_get_direction+0x78> @ imm = #0x0
; 	return 0;
 8009d5e: 2300         	movs	r3, #0x0
; }
 8009d60: 4618         	mov	r0, r3
 8009d62: 3710         	adds	r7, #0x10
 8009d64: 46bd         	mov	sp, r7
 8009d66: bd80         	pop	{r7, pc}

08009d68 <$d>:
 8009d68: 38 05 00 20  	.word	0x20000538
 8009d6c: 3c 90 02 08  	.word	0x0802903c

08009d70 <dma_stm32_get_memory_increment>:
; {
 8009d70: b580         	push	{r7, lr}
 8009d72: b088         	sub	sp, #0x20
 8009d74: af04         	add	r7, sp, #0x10
 8009d76: 4603         	mov	r3, r0
 8009d78: 6039         	str	r1, [r7]
 8009d7a: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 8009d7c: 79fb         	ldrb	r3, [r7, #0x7]
 8009d7e: 2b02         	cmp	r3, #0x2
 8009d80: d00b         	beq	0x8009d9a <dma_stm32_get_memory_increment+0x2a> @ imm = #0x16
 8009d82: 2b02         	cmp	r3, #0x2
 8009d84: dc10         	bgt	0x8009da8 <dma_stm32_get_memory_increment+0x38> @ imm = #0x20
 8009d86: 2b00         	cmp	r3, #0x0
 8009d88: d002         	beq	0x8009d90 <dma_stm32_get_memory_increment+0x20> @ imm = #0x4
 8009d8a: 2b01         	cmp	r3, #0x1
 8009d8c: d009         	beq	0x8009da2 <dma_stm32_get_memory_increment+0x32> @ imm = #0x12
 8009d8e: e00b         	b	0x8009da8 <dma_stm32_get_memory_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_MEMORY_INCREMENT;
 8009d90: 683b         	ldr	r3, [r7]
 8009d92: f44f 6280    	mov.w	r2, #0x400
 8009d96: 601a         	str	r2, [r3]
; 		break;
 8009d98: e025         	b	0x8009de6 <dma_stm32_get_memory_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_MEMORY_NOINCREMENT;
 8009d9a: 683b         	ldr	r3, [r7]
 8009d9c: 2200         	movs	r2, #0x0
 8009d9e: 601a         	str	r2, [r3]
; 		break;
 8009da0: e021         	b	0x8009de6 <dma_stm32_get_memory_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 8009da2: f06f 0385    	mvn	r3, #0x85
 8009da6: e01f         	b	0x8009de8 <dma_stm32_get_memory_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Memory increment error. %d", increment);
 8009da8: 2303         	movs	r3, #0x3
 8009daa: 2b00         	cmp	r3, #0x0
 8009dac: d018         	beq	0x8009de0 <dma_stm32_get_memory_increment+0x70> @ imm = #0x30
 8009dae: 2301         	movs	r3, #0x1
 8009db0: 73fb         	strb	r3, [r7, #0xf]
 8009db2: 7bfb         	ldrb	r3, [r7, #0xf]
 8009db4: f083 0301    	eor	r3, r3, #0x1
 8009db8: b2db         	uxtb	r3, r3
 8009dba: 2b00         	cmp	r3, #0x0
 8009dbc: d110         	bne	0x8009de0 <dma_stm32_get_memory_increment+0x70> @ imm = #0x20
 8009dbe: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8009df0 <dma_stm32_get_memory_increment+0x80>
 8009dc0: 6819         	ldr	r1, [r3]
 8009dc2: 79fb         	ldrb	r3, [r7, #0x7]
 8009dc4: 9303         	str	r3, [sp, #0xc]
 8009dc6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8009df4 <dma_stm32_get_memory_increment+0x84>
 8009dc8: 9302         	str	r3, [sp, #0x8]
 8009dca: 2300         	movs	r3, #0x0
 8009dcc: 9301         	str	r3, [sp, #0x4]
 8009dce: 2300         	movs	r3, #0x0
 8009dd0: 9300         	str	r3, [sp]
 8009dd2: 2300         	movs	r3, #0x0
 8009dd4: 2201         	movs	r2, #0x1
 8009dd6: 2000         	movs	r0, #0x0
 8009dd8: f014 f856    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x140ac
 8009ddc: 2300         	movs	r3, #0x0
 8009dde: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8009de0: f06f 0315    	mvn	r3, #0x15
 8009de4: e000         	b	0x8009de8 <dma_stm32_get_memory_increment+0x78> @ imm = #0x0
; 	return 0;
 8009de6: 2300         	movs	r3, #0x0
; }
 8009de8: 4618         	mov	r0, r3
 8009dea: 3710         	adds	r7, #0x10
 8009dec: 46bd         	mov	sp, r7
 8009dee: bd80         	pop	{r7, pc}

08009df0 <$d>:
 8009df0: 38 05 00 20  	.word	0x20000538
 8009df4: 50 90 02 08  	.word	0x08029050

08009df8 <dma_stm32_get_periph_increment>:
; {
 8009df8: b580         	push	{r7, lr}
 8009dfa: b088         	sub	sp, #0x20
 8009dfc: af04         	add	r7, sp, #0x10
 8009dfe: 4603         	mov	r3, r0
 8009e00: 6039         	str	r1, [r7]
 8009e02: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 8009e04: 79fb         	ldrb	r3, [r7, #0x7]
 8009e06: 2b02         	cmp	r3, #0x2
 8009e08: d00b         	beq	0x8009e22 <dma_stm32_get_periph_increment+0x2a> @ imm = #0x16
 8009e0a: 2b02         	cmp	r3, #0x2
 8009e0c: dc10         	bgt	0x8009e30 <dma_stm32_get_periph_increment+0x38> @ imm = #0x20
 8009e0e: 2b00         	cmp	r3, #0x0
 8009e10: d002         	beq	0x8009e18 <dma_stm32_get_periph_increment+0x20> @ imm = #0x4
 8009e12: 2b01         	cmp	r3, #0x1
 8009e14: d009         	beq	0x8009e2a <dma_stm32_get_periph_increment+0x32> @ imm = #0x12
 8009e16: e00b         	b	0x8009e30 <dma_stm32_get_periph_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_PERIPH_INCREMENT;
 8009e18: 683b         	ldr	r3, [r7]
 8009e1a: f44f 7200    	mov.w	r2, #0x200
 8009e1e: 601a         	str	r2, [r3]
; 		break;
 8009e20: e025         	b	0x8009e6e <dma_stm32_get_periph_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_PERIPH_NOINCREMENT;
 8009e22: 683b         	ldr	r3, [r7]
 8009e24: 2200         	movs	r2, #0x0
 8009e26: 601a         	str	r2, [r3]
; 		break;
 8009e28: e021         	b	0x8009e6e <dma_stm32_get_periph_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 8009e2a: f06f 0385    	mvn	r3, #0x85
 8009e2e: e01f         	b	0x8009e70 <dma_stm32_get_periph_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Periph increment error. %d", increment);
 8009e30: 2303         	movs	r3, #0x3
 8009e32: 2b00         	cmp	r3, #0x0
 8009e34: d018         	beq	0x8009e68 <dma_stm32_get_periph_increment+0x70> @ imm = #0x30
 8009e36: 2301         	movs	r3, #0x1
 8009e38: 73fb         	strb	r3, [r7, #0xf]
 8009e3a: 7bfb         	ldrb	r3, [r7, #0xf]
 8009e3c: f083 0301    	eor	r3, r3, #0x1
 8009e40: b2db         	uxtb	r3, r3
 8009e42: 2b00         	cmp	r3, #0x0
 8009e44: d110         	bne	0x8009e68 <dma_stm32_get_periph_increment+0x70> @ imm = #0x20
 8009e46: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8009e78 <dma_stm32_get_periph_increment+0x80>
 8009e48: 6819         	ldr	r1, [r3]
 8009e4a: 79fb         	ldrb	r3, [r7, #0x7]
 8009e4c: 9303         	str	r3, [sp, #0xc]
 8009e4e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8009e7c <dma_stm32_get_periph_increment+0x84>
 8009e50: 9302         	str	r3, [sp, #0x8]
 8009e52: 2300         	movs	r3, #0x0
 8009e54: 9301         	str	r3, [sp, #0x4]
 8009e56: 2300         	movs	r3, #0x0
 8009e58: 9300         	str	r3, [sp]
 8009e5a: 2300         	movs	r3, #0x0
 8009e5c: 2201         	movs	r2, #0x1
 8009e5e: 2000         	movs	r0, #0x0
 8009e60: f014 f812    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x14024
 8009e64: 2300         	movs	r3, #0x0
 8009e66: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8009e68: f06f 0315    	mvn	r3, #0x15
 8009e6c: e000         	b	0x8009e70 <dma_stm32_get_periph_increment+0x78> @ imm = #0x0
; 	return 0;
 8009e6e: 2300         	movs	r3, #0x0
; }
 8009e70: 4618         	mov	r0, r3
 8009e72: 3710         	adds	r7, #0x10
 8009e74: 46bd         	mov	sp, r7
 8009e76: bd80         	pop	{r7, pc}

08009e78 <$d>:
 8009e78: 38 05 00 20  	.word	0x20000538
 8009e7c: 6c 90 02 08  	.word	0x0802906c

08009e80 <dma_stm32_configure>:
; {
 8009e80: b580         	push	{r7, lr}
 8009e82: b0be         	sub	sp, #0xf8
 8009e84: af06         	add	r7, sp, #0x18
 8009e86: 60f8         	str	r0, [r7, #0xc]
 8009e88: 60b9         	str	r1, [r7, #0x8]
 8009e8a: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *dev_config = dev->config;
 8009e8c: 68fb         	ldr	r3, [r7, #0xc]
 8009e8e: 685b         	ldr	r3, [r3, #0x4]
 8009e90: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 				&dev_config->streams[id - STM32_DMA_STREAM_OFFSET];
 8009e94: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8009e98: 6999         	ldr	r1, [r3, #0x18]
 8009e9a: 68ba         	ldr	r2, [r7, #0x8]
 8009e9c: 4613         	mov	r3, r2
 8009e9e: 00db         	lsls	r3, r3, #0x3
 8009ea0: 1a9b         	subs	r3, r3, r2
 8009ea2: 009b         	lsls	r3, r3, #0x2
; 	struct dma_stm32_stream *stream =
 8009ea4: 440b         	add	r3, r1
 8009ea6: f8c7 30d0    	str.w	r3, [r7, #0xd0]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)dev_config->base;
 8009eaa: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8009eae: 691b         	ldr	r3, [r3, #0x10]
 8009eb0: f8c7 30cc    	str.w	r3, [r7, #0xcc]
; 	LL_DMA_StructInit(&DMA_InitStruct);
 8009eb4: f107 0310    	add.w	r3, r7, #0x10
 8009eb8: 4618         	mov	r0, r3
 8009eba: f01a fac4    	bl	0x8024446 <LL_DMA_StructInit> @ imm = #0x1a588
; 	if (id >= dev_config->max_streams) {
 8009ebe: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8009ec2: 695b         	ldr	r3, [r3, #0x14]
 8009ec4: 68ba         	ldr	r2, [r7, #0x8]
 8009ec6: 429a         	cmp	r2, r3
 8009ec8: d321         	blo	0x8009f0e <dma_stm32_configure+0x8e> @ imm = #0x42
; 		LOG_ERR("cannot configure the dma stream %d.", id);
 8009eca: 2303         	movs	r3, #0x3
 8009ecc: 2b00         	cmp	r3, #0x0
 8009ece: d01a         	beq	0x8009f06 <dma_stm32_configure+0x86> @ imm = #0x34
 8009ed0: 2301         	movs	r3, #0x1
 8009ed2: f887 305b    	strb.w	r3, [r7, #0x5b]
 8009ed6: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8009eda: f083 0301    	eor	r3, r3, #0x1
 8009ede: b2db         	uxtb	r3, r3
 8009ee0: 2b00         	cmp	r3, #0x0
 8009ee2: d110         	bne	0x8009f06 <dma_stm32_configure+0x86> @ imm = #0x20
 8009ee4: 4b9b         	ldr	r3, [pc, #0x26c]        @ 0x800a154 <dma_stm32_configure+0x2d4>
 8009ee6: 6819         	ldr	r1, [r3]
 8009ee8: 68bb         	ldr	r3, [r7, #0x8]
 8009eea: 9303         	str	r3, [sp, #0xc]
 8009eec: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x800a158 <dma_stm32_configure+0x2d8>
 8009eee: 9302         	str	r3, [sp, #0x8]
 8009ef0: 2300         	movs	r3, #0x0
 8009ef2: 9301         	str	r3, [sp, #0x4]
 8009ef4: 2300         	movs	r3, #0x0
 8009ef6: 9300         	str	r3, [sp]
 8009ef8: 2300         	movs	r3, #0x0
 8009efa: 2201         	movs	r2, #0x1
 8009efc: 2000         	movs	r0, #0x0
 8009efe: f013 ffc3    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13f86
 8009f02: 2300         	movs	r3, #0x0
 8009f04: 657b         	str	r3, [r7, #0x54]
; 		return -EINVAL;
 8009f06: f06f 0315    	mvn	r3, #0x15
 8009f0a: f000 bc1f    	b.w	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x83e
; 	if (stream->busy) {
 8009f0e: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8009f12: 799b         	ldrb	r3, [r3, #0x6]
 8009f14: b2db         	uxtb	r3, r3
 8009f16: 2b00         	cmp	r3, #0x0
 8009f18: d020         	beq	0x8009f5c <dma_stm32_configure+0xdc> @ imm = #0x40
; 		LOG_ERR("dma stream %d is busy.", id);
 8009f1a: 2303         	movs	r3, #0x3
 8009f1c: 2b00         	cmp	r3, #0x0
 8009f1e: d01a         	beq	0x8009f56 <dma_stm32_configure+0xd6> @ imm = #0x34
 8009f20: 2301         	movs	r3, #0x1
 8009f22: f887 3063    	strb.w	r3, [r7, #0x63]
 8009f26: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8009f2a: f083 0301    	eor	r3, r3, #0x1
 8009f2e: b2db         	uxtb	r3, r3
 8009f30: 2b00         	cmp	r3, #0x0
 8009f32: d110         	bne	0x8009f56 <dma_stm32_configure+0xd6> @ imm = #0x20
 8009f34: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x800a154 <dma_stm32_configure+0x2d4>
 8009f36: 6819         	ldr	r1, [r3]
 8009f38: 68bb         	ldr	r3, [r7, #0x8]
 8009f3a: 9303         	str	r3, [sp, #0xc]
 8009f3c: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x800a15c <dma_stm32_configure+0x2dc>
 8009f3e: 9302         	str	r3, [sp, #0x8]
 8009f40: 2300         	movs	r3, #0x0
 8009f42: 9301         	str	r3, [sp, #0x4]
 8009f44: 2300         	movs	r3, #0x0
 8009f46: 9300         	str	r3, [sp]
 8009f48: 2300         	movs	r3, #0x0
 8009f4a: 2201         	movs	r2, #0x1
 8009f4c: 2000         	movs	r0, #0x0
 8009f4e: f013 ff9b    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13f36
 8009f52: 2300         	movs	r3, #0x0
 8009f54: 65fb         	str	r3, [r7, #0x5c]
; 		return -EBUSY;
 8009f56: f06f 030f    	mvn	r3, #0xf
 8009f5a: e3f7         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x7ee
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 8009f5c: 68b9         	ldr	r1, [r7, #0x8]
 8009f5e: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8009f62: f013 ffdd    	bl	0x801df20 <dma_stm32_disable_stream> @ imm = #0x13fba
 8009f66: 4603         	mov	r3, r0
 8009f68: 2b00         	cmp	r3, #0x0
 8009f6a: d020         	beq	0x8009fae <dma_stm32_configure+0x12e> @ imm = #0x40
; 		LOG_ERR("could not disable dma stream %d.", id);
 8009f6c: 2303         	movs	r3, #0x3
 8009f6e: 2b00         	cmp	r3, #0x0
 8009f70: d01a         	beq	0x8009fa8 <dma_stm32_configure+0x128> @ imm = #0x34
 8009f72: 2301         	movs	r3, #0x1
 8009f74: f887 306b    	strb.w	r3, [r7, #0x6b]
 8009f78: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 8009f7c: f083 0301    	eor	r3, r3, #0x1
 8009f80: b2db         	uxtb	r3, r3
 8009f82: 2b00         	cmp	r3, #0x0
 8009f84: d110         	bne	0x8009fa8 <dma_stm32_configure+0x128> @ imm = #0x20
 8009f86: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x800a154 <dma_stm32_configure+0x2d4>
 8009f88: 6819         	ldr	r1, [r3]
 8009f8a: 68bb         	ldr	r3, [r7, #0x8]
 8009f8c: 9303         	str	r3, [sp, #0xc]
 8009f8e: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800a160 <dma_stm32_configure+0x2e0>
 8009f90: 9302         	str	r3, [sp, #0x8]
 8009f92: 2300         	movs	r3, #0x0
 8009f94: 9301         	str	r3, [sp, #0x4]
 8009f96: 2300         	movs	r3, #0x0
 8009f98: 9300         	str	r3, [sp]
 8009f9a: 2300         	movs	r3, #0x0
 8009f9c: 2201         	movs	r2, #0x1
 8009f9e: 2000         	movs	r0, #0x0
 8009fa0: f013 ff72    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13ee4
 8009fa4: 2300         	movs	r3, #0x0
 8009fa6: 667b         	str	r3, [r7, #0x64]
; 		return -EBUSY;
 8009fa8: f06f 030f    	mvn	r3, #0xf
 8009fac: e3ce         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x79c
; 	dma_stm32_clear_stream_irq(dev, id);
 8009fae: 68b9         	ldr	r1, [r7, #0x8]
 8009fb0: 68f8         	ldr	r0, [r7, #0xc]
 8009fb2: f013 ff9a    	bl	0x801deea <dma_stm32_clear_stream_irq> @ imm = #0x13f34
; 	if (config->linked_channel == STM32_DMA_HAL_OVERRIDE) {
 8009fb6: 687b         	ldr	r3, [r7, #0x4]
 8009fb8: 885b         	ldrh	r3, [r3, #0x2]
 8009fba: f403 637e    	and	r3, r3, #0xfe0
 8009fbe: b29b         	uxth	r3, r3
 8009fc0: f5b3 6f7e    	cmp.w	r3, #0xfe0
 8009fc4: d117         	bne	0x8009ff6 <dma_stm32_configure+0x176> @ imm = #0x2e
; 		stream->busy = true;
 8009fc6: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8009fca: 2201         	movs	r2, #0x1
 8009fcc: 719a         	strb	r2, [r3, #0x6]
; 		stream->hal_override = true;
 8009fce: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8009fd2: 2201         	movs	r2, #0x1
 8009fd4: 715a         	strb	r2, [r3, #0x5]
; 		stream->dma_callback = config->dma_callback;
 8009fd6: 687b         	ldr	r3, [r7, #0x4]
 8009fd8: 699a         	ldr	r2, [r3, #0x18]
 8009fda: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8009fde: 615a         	str	r2, [r3, #0x14]
; 		stream->user_data = config->user_data;
 8009fe0: 687b         	ldr	r3, [r7, #0x4]
 8009fe2: 695a         	ldr	r2, [r3, #0x14]
 8009fe4: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8009fe8: 611a         	str	r2, [r3, #0x10]
; 		stream->cyclic = false;
 8009fea: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8009fee: 2200         	movs	r2, #0x0
 8009ff0: 761a         	strb	r2, [r3, #0x18]
; 		return 0;
 8009ff2: 2300         	movs	r3, #0x0
 8009ff4: e3aa         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x754
; 	if (config->head_block->block_size > DMA_STM32_MAX_DATA_ITEMS) {
 8009ff6: 687b         	ldr	r3, [r7, #0x4]
 8009ff8: 691b         	ldr	r3, [r3, #0x10]
 8009ffa: 695b         	ldr	r3, [r3, #0x14]
 8009ffc: f5b3 3f80    	cmp.w	r3, #0x10000
 800a000: d322         	blo	0x800a048 <dma_stm32_configure+0x1c8> @ imm = #0x44
; 		LOG_ERR("Data size too big: %d\n",
 800a002: 2303         	movs	r3, #0x3
 800a004: 2b00         	cmp	r3, #0x0
 800a006: d01c         	beq	0x800a042 <dma_stm32_configure+0x1c2> @ imm = #0x38
 800a008: 2301         	movs	r3, #0x1
 800a00a: f887 3073    	strb.w	r3, [r7, #0x73]
 800a00e: f897 3073    	ldrb.w	r3, [r7, #0x73]
 800a012: f083 0301    	eor	r3, r3, #0x1
 800a016: b2db         	uxtb	r3, r3
 800a018: 2b00         	cmp	r3, #0x0
 800a01a: d112         	bne	0x800a042 <dma_stm32_configure+0x1c2> @ imm = #0x24
 800a01c: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800a154 <dma_stm32_configure+0x2d4>
 800a01e: 6819         	ldr	r1, [r3]
 800a020: 687b         	ldr	r3, [r7, #0x4]
 800a022: 691b         	ldr	r3, [r3, #0x10]
 800a024: 695b         	ldr	r3, [r3, #0x14]
 800a026: 9303         	str	r3, [sp, #0xc]
 800a028: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x800a164 <dma_stm32_configure+0x2e4>
 800a02a: 9302         	str	r3, [sp, #0x8]
 800a02c: 2300         	movs	r3, #0x0
 800a02e: 9301         	str	r3, [sp, #0x4]
 800a030: 2300         	movs	r3, #0x0
 800a032: 9300         	str	r3, [sp]
 800a034: 2300         	movs	r3, #0x0
 800a036: 2201         	movs	r2, #0x1
 800a038: 2000         	movs	r0, #0x0
 800a03a: f013 ff25    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13e4a
 800a03e: 2300         	movs	r3, #0x0
 800a040: 66fb         	str	r3, [r7, #0x6c]
; 		return -EINVAL;
 800a042: f06f 0315    	mvn	r3, #0x15
 800a046: e381         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x702
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 800a048: 687b         	ldr	r3, [r7, #0x4]
 800a04a: 785b         	ldrb	r3, [r3, #0x1]
 800a04c: f003 0307    	and	r3, r3, #0x7
 800a050: b2db         	uxtb	r3, r3
 800a052: 2b00         	cmp	r3, #0x0
 800a054: d12a         	bne	0x800a0ac <dma_stm32_configure+0x22c> @ imm = #0x54
; 		(!dev_config->support_m2m)) {
 800a056: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 800a05a: 7b1b         	ldrb	r3, [r3, #0xc]
 800a05c: f083 0301    	eor	r3, r3, #0x1
 800a060: b2db         	uxtb	r3, r3
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 800a062: 2b00         	cmp	r3, #0x0
 800a064: d022         	beq	0x800a0ac <dma_stm32_configure+0x22c> @ imm = #0x44
; 		LOG_ERR("Memcopy not supported for device %s",
 800a066: 2303         	movs	r3, #0x3
 800a068: 2b00         	cmp	r3, #0x0
 800a06a: d01c         	beq	0x800a0a6 <dma_stm32_configure+0x226> @ imm = #0x38
 800a06c: 2301         	movs	r3, #0x1
 800a06e: f887 30d6    	strb.w	r3, [r7, #0xd6]
 800a072: f897 30d6    	ldrb.w	r3, [r7, #0xd6]
 800a076: f083 0301    	eor	r3, r3, #0x1
 800a07a: b2db         	uxtb	r3, r3
 800a07c: 2b00         	cmp	r3, #0x0
 800a07e: d112         	bne	0x800a0a6 <dma_stm32_configure+0x226> @ imm = #0x24
 800a080: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x800a154 <dma_stm32_configure+0x2d4>
 800a082: 6819         	ldr	r1, [r3]
 800a084: 68fb         	ldr	r3, [r7, #0xc]
 800a086: 681b         	ldr	r3, [r3]
 800a088: 9303         	str	r3, [sp, #0xc]
 800a08a: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x800a168 <dma_stm32_configure+0x2e8>
 800a08c: 9302         	str	r3, [sp, #0x8]
 800a08e: 2300         	movs	r3, #0x0
 800a090: 9301         	str	r3, [sp, #0x4]
 800a092: 2300         	movs	r3, #0x0
 800a094: 9300         	str	r3, [sp]
 800a096: 2300         	movs	r3, #0x0
 800a098: 2201         	movs	r2, #0x1
 800a09a: 2000         	movs	r0, #0x0
 800a09c: f013 fef4    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13de8
 800a0a0: 2300         	movs	r3, #0x0
 800a0a2: f8c7 30d8    	str.w	r3, [r7, #0xd8]
; 		return -ENOTSUP;
 800a0a6: f06f 0385    	mvn	r3, #0x85
 800a0aa: e34f         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x69e
; 	if ((config->dest_data_size != config->source_data_size)) {
 800a0ac: 687b         	ldr	r3, [r7, #0x4]
 800a0ae: 88da         	ldrh	r2, [r3, #0x6]
 800a0b0: 687b         	ldr	r3, [r7, #0x4]
 800a0b2: 889b         	ldrh	r3, [r3, #0x4]
 800a0b4: 429a         	cmp	r2, r3
 800a0b6: d01e         	beq	0x800a0f6 <dma_stm32_configure+0x276> @ imm = #0x3c
; 		LOG_ERR("source and dest data size differ.");
 800a0b8: 2303         	movs	r3, #0x3
 800a0ba: 2b00         	cmp	r3, #0x0
 800a0bc: d018         	beq	0x800a0f0 <dma_stm32_configure+0x270> @ imm = #0x30
 800a0be: 2301         	movs	r3, #0x1
 800a0c0: f887 307b    	strb.w	r3, [r7, #0x7b]
 800a0c4: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 800a0c8: f083 0301    	eor	r3, r3, #0x1
 800a0cc: b2db         	uxtb	r3, r3
 800a0ce: 2b00         	cmp	r3, #0x0
 800a0d0: d10e         	bne	0x800a0f0 <dma_stm32_configure+0x270> @ imm = #0x1c
 800a0d2: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800a154 <dma_stm32_configure+0x2d4>
 800a0d4: 6819         	ldr	r1, [r3]
 800a0d6: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800a16c <dma_stm32_configure+0x2ec>
 800a0d8: 9302         	str	r3, [sp, #0x8]
 800a0da: 2300         	movs	r3, #0x0
 800a0dc: 9301         	str	r3, [sp, #0x4]
 800a0de: 2300         	movs	r3, #0x0
 800a0e0: 9300         	str	r3, [sp]
 800a0e2: 2300         	movs	r3, #0x0
 800a0e4: 2201         	movs	r2, #0x1
 800a0e6: 2000         	movs	r0, #0x0
 800a0e8: f013 fece    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13d9c
 800a0ec: 2300         	movs	r3, #0x0
 800a0ee: 677b         	str	r3, [r7, #0x74]
; 		return -EINVAL;
 800a0f0: f06f 0315    	mvn	r3, #0x15
 800a0f4: e32a         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x654
; 	if (config->source_data_size != 4U &&
 800a0f6: 687b         	ldr	r3, [r7, #0x4]
 800a0f8: 889b         	ldrh	r3, [r3, #0x4]
 800a0fa: 2b04         	cmp	r3, #0x4
 800a0fc: d03a         	beq	0x800a174 <dma_stm32_configure+0x2f4> @ imm = #0x74
; 	    config->source_data_size != 2U &&
 800a0fe: 687b         	ldr	r3, [r7, #0x4]
 800a100: 889b         	ldrh	r3, [r3, #0x4]
; 	if (config->source_data_size != 4U &&
 800a102: 2b02         	cmp	r3, #0x2
 800a104: d036         	beq	0x800a174 <dma_stm32_configure+0x2f4> @ imm = #0x6c
; 	    config->source_data_size != 1U) {
 800a106: 687b         	ldr	r3, [r7, #0x4]
 800a108: 889b         	ldrh	r3, [r3, #0x4]
; 	    config->source_data_size != 2U &&
 800a10a: 2b01         	cmp	r3, #0x1
 800a10c: d032         	beq	0x800a174 <dma_stm32_configure+0x2f4> @ imm = #0x64
; 		LOG_ERR("source and dest unit size error, %d",
 800a10e: 2303         	movs	r3, #0x3
 800a110: 2b00         	cmp	r3, #0x0
 800a112: d01c         	beq	0x800a14e <dma_stm32_configure+0x2ce> @ imm = #0x38
 800a114: 2301         	movs	r3, #0x1
 800a116: f887 30d7    	strb.w	r3, [r7, #0xd7]
 800a11a: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 800a11e: f083 0301    	eor	r3, r3, #0x1
 800a122: b2db         	uxtb	r3, r3
 800a124: 2b00         	cmp	r3, #0x0
 800a126: d112         	bne	0x800a14e <dma_stm32_configure+0x2ce> @ imm = #0x24
 800a128: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800a154 <dma_stm32_configure+0x2d4>
 800a12a: 6819         	ldr	r1, [r3]
 800a12c: 687b         	ldr	r3, [r7, #0x4]
 800a12e: 889b         	ldrh	r3, [r3, #0x4]
 800a130: 9303         	str	r3, [sp, #0xc]
 800a132: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800a170 <dma_stm32_configure+0x2f0>
 800a134: 9302         	str	r3, [sp, #0x8]
 800a136: 2300         	movs	r3, #0x0
 800a138: 9301         	str	r3, [sp, #0x4]
 800a13a: 2300         	movs	r3, #0x0
 800a13c: 9300         	str	r3, [sp]
 800a13e: 2300         	movs	r3, #0x0
 800a140: 2201         	movs	r2, #0x1
 800a142: 2000         	movs	r0, #0x0
 800a144: f013 fea0    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13d40
 800a148: 2300         	movs	r3, #0x0
 800a14a: f8c7 30dc    	str.w	r3, [r7, #0xdc]
; 		return -EINVAL;
 800a14e: f06f 0315    	mvn	r3, #0x15
 800a152: e2fb         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x5f6

0800a154 <$d>:
 800a154: 38 05 00 20  	.word	0x20000538
 800a158: 88 90 02 08  	.word	0x08029088
 800a15c: ac 90 02 08  	.word	0x080290ac
 800a160: c4 90 02 08  	.word	0x080290c4
 800a164: e8 90 02 08  	.word	0x080290e8
 800a168: 00 91 02 08  	.word	0x08029100
 800a16c: 24 91 02 08  	.word	0x08029124
 800a170: 48 91 02 08  	.word	0x08029148

0800a174 <$t>:
; 	if (config->head_block->source_reload_en !=
 800a174: 687b         	ldr	r3, [r7, #0x4]
 800a176: 691b         	ldr	r3, [r3, #0x10]
 800a178: 7f1b         	ldrb	r3, [r3, #0x1c]
 800a17a: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 800a17e: b2da         	uxtb	r2, r3
; 		config->head_block->dest_reload_en) {
 800a180: 687b         	ldr	r3, [r7, #0x4]
 800a182: 691b         	ldr	r3, [r3, #0x10]
 800a184: 7f1b         	ldrb	r3, [r3, #0x1c]
 800a186: f3c3 13c0    	ubfx	r3, r3, #0x7, #0x1
 800a18a: b2db         	uxtb	r3, r3
; 	if (config->head_block->source_reload_en !=
 800a18c: 429a         	cmp	r2, r3
 800a18e: d01e         	beq	0x800a1ce <dma_stm32_configure+0x34e> @ imm = #0x3c
; 		LOG_ERR("source_reload_en and dest_reload_en must "
 800a190: 2303         	movs	r3, #0x3
 800a192: 2b00         	cmp	r3, #0x0
 800a194: d018         	beq	0x800a1c8 <dma_stm32_configure+0x348> @ imm = #0x30
 800a196: 2301         	movs	r3, #0x1
 800a198: f887 3083    	strb.w	r3, [r7, #0x83]
 800a19c: f897 3083    	ldrb.w	r3, [r7, #0x83]
 800a1a0: f083 0301    	eor	r3, r3, #0x1
 800a1a4: b2db         	uxtb	r3, r3
 800a1a6: 2b00         	cmp	r3, #0x0
 800a1a8: d10e         	bne	0x800a1c8 <dma_stm32_configure+0x348> @ imm = #0x1c
 800a1aa: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x800a41c <dma_stm32_configure+0x59c>
 800a1ac: 6819         	ldr	r1, [r3]
 800a1ae: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x800a420 <dma_stm32_configure+0x5a0>
 800a1b0: 9302         	str	r3, [sp, #0x8]
 800a1b2: 2300         	movs	r3, #0x0
 800a1b4: 9301         	str	r3, [sp, #0x4]
 800a1b6: 2300         	movs	r3, #0x0
 800a1b8: 9300         	str	r3, [sp]
 800a1ba: 2300         	movs	r3, #0x0
 800a1bc: 2201         	movs	r2, #0x1
 800a1be: 2000         	movs	r0, #0x0
 800a1c0: f013 fe62    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13cc4
 800a1c4: 2300         	movs	r3, #0x0
 800a1c6: 67fb         	str	r3, [r7, #0x7c]
; 		return -EINVAL;
 800a1c8: f06f 0315    	mvn	r3, #0x15
 800a1cc: e2be         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x57c
; 	stream->busy		= true;
 800a1ce: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a1d2: 2201         	movs	r2, #0x1
 800a1d4: 719a         	strb	r2, [r3, #0x6]
; 	stream->dma_callback	= config->dma_callback;
 800a1d6: 687b         	ldr	r3, [r7, #0x4]
 800a1d8: 699a         	ldr	r2, [r3, #0x18]
 800a1da: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a1de: 615a         	str	r2, [r3, #0x14]
; 	stream->direction	= config->channel_direction;
 800a1e0: 687b         	ldr	r3, [r7, #0x4]
 800a1e2: 785b         	ldrb	r3, [r3, #0x1]
 800a1e4: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 800a1e8: b2db         	uxtb	r3, r3
 800a1ea: 461a         	mov	r2, r3
 800a1ec: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a1f0: 601a         	str	r2, [r3]
; 	stream->user_data       = config->user_data;
 800a1f2: 687b         	ldr	r3, [r7, #0x4]
 800a1f4: 695a         	ldr	r2, [r3, #0x14]
 800a1f6: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a1fa: 611a         	str	r2, [r3, #0x10]
; 	stream->src_size	= config->source_data_size;
 800a1fc: 687b         	ldr	r3, [r7, #0x4]
 800a1fe: 889b         	ldrh	r3, [r3, #0x4]
 800a200: 461a         	mov	r2, r3
 800a202: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a206: 609a         	str	r2, [r3, #0x8]
; 	stream->dst_size	= config->dest_data_size;
 800a208: 687b         	ldr	r3, [r7, #0x4]
 800a20a: 88db         	ldrh	r3, [r3, #0x6]
 800a20c: 461a         	mov	r2, r3
 800a20e: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a212: 60da         	str	r2, [r3, #0xc]
; 	stream->cyclic		= config->head_block->source_reload_en;
 800a214: 687b         	ldr	r3, [r7, #0x4]
 800a216: 691b         	ldr	r3, [r3, #0x10]
 800a218: 7f1b         	ldrb	r3, [r3, #0x1c]
 800a21a: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 800a21e: b2db         	uxtb	r3, r3
 800a220: 2b00         	cmp	r3, #0x0
 800a222: bf14         	ite	ne
 800a224: 2301         	movne	r3, #0x1
 800a226: 2300         	moveq	r3, #0x0
 800a228: b2da         	uxtb	r2, r3
 800a22a: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a22e: 761a         	strb	r2, [r3, #0x18]
; 	if (config->head_block->source_address == 0) {
 800a230: 687b         	ldr	r3, [r7, #0x4]
 800a232: 691b         	ldr	r3, [r3, #0x10]
 800a234: 681b         	ldr	r3, [r3]
 800a236: 2b00         	cmp	r3, #0x0
 800a238: d11c         	bne	0x800a274 <dma_stm32_configure+0x3f4> @ imm = #0x38
; 		LOG_WRN("source_buffer address is null.");
 800a23a: 2303         	movs	r3, #0x3
 800a23c: 2b01         	cmp	r3, #0x1
 800a23e: d919         	bls	0x800a274 <dma_stm32_configure+0x3f4> @ imm = #0x32
 800a240: 2301         	movs	r3, #0x1
 800a242: f887 30c3    	strb.w	r3, [r7, #0xc3]
 800a246: f897 30c3    	ldrb.w	r3, [r7, #0xc3]
 800a24a: f083 0301    	eor	r3, r3, #0x1
 800a24e: b2db         	uxtb	r3, r3
 800a250: 2b00         	cmp	r3, #0x0
 800a252: d10f         	bne	0x800a274 <dma_stm32_configure+0x3f4> @ imm = #0x1e
 800a254: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x800a41c <dma_stm32_configure+0x59c>
 800a256: 6819         	ldr	r1, [r3]
 800a258: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800a424 <dma_stm32_configure+0x5a4>
 800a25a: 9302         	str	r3, [sp, #0x8]
 800a25c: 2300         	movs	r3, #0x0
 800a25e: 9301         	str	r3, [sp, #0x4]
 800a260: 2300         	movs	r3, #0x0
 800a262: 9300         	str	r3, [sp]
 800a264: 2300         	movs	r3, #0x0
 800a266: 2202         	movs	r2, #0x2
 800a268: 2000         	movs	r0, #0x0
 800a26a: f013 fe0d    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13c1a
 800a26e: 2300         	movs	r3, #0x0
 800a270: f8c7 30bc    	str.w	r3, [r7, #0xbc]
; 	if (config->head_block->dest_address == 0) {
 800a274: 687b         	ldr	r3, [r7, #0x4]
 800a276: 691b         	ldr	r3, [r3, #0x10]
 800a278: 685b         	ldr	r3, [r3, #0x4]
 800a27a: 2b00         	cmp	r3, #0x0
 800a27c: d11c         	bne	0x800a2b8 <dma_stm32_configure+0x438> @ imm = #0x38
; 		LOG_WRN("dest_buffer address is null.");
 800a27e: 2303         	movs	r3, #0x3
 800a280: 2b01         	cmp	r3, #0x1
 800a282: d919         	bls	0x800a2b8 <dma_stm32_configure+0x438> @ imm = #0x32
 800a284: 2301         	movs	r3, #0x1
 800a286: f887 30bb    	strb.w	r3, [r7, #0xbb]
 800a28a: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 800a28e: f083 0301    	eor	r3, r3, #0x1
 800a292: b2db         	uxtb	r3, r3
 800a294: 2b00         	cmp	r3, #0x0
 800a296: d10f         	bne	0x800a2b8 <dma_stm32_configure+0x438> @ imm = #0x1e
 800a298: 4b60         	ldr	r3, [pc, #0x180]        @ 0x800a41c <dma_stm32_configure+0x59c>
 800a29a: 6819         	ldr	r1, [r3]
 800a29c: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800a428 <dma_stm32_configure+0x5a8>
 800a29e: 9302         	str	r3, [sp, #0x8]
 800a2a0: 2300         	movs	r3, #0x0
 800a2a2: 9301         	str	r3, [sp, #0x4]
 800a2a4: 2300         	movs	r3, #0x0
 800a2a6: 9300         	str	r3, [sp]
 800a2a8: 2300         	movs	r3, #0x0
 800a2aa: 2202         	movs	r2, #0x2
 800a2ac: 2000         	movs	r0, #0x0
 800a2ae: f013 fdeb    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13bd6
 800a2b2: 2300         	movs	r3, #0x0
 800a2b4: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (stream->direction == MEMORY_TO_PERIPHERAL) {
 800a2b8: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a2bc: 681b         	ldr	r3, [r3]
 800a2be: 2b01         	cmp	r3, #0x1
 800a2c0: d108         	bne	0x800a2d4 <dma_stm32_configure+0x454> @ imm = #0x10
; 					config->head_block->source_address;
 800a2c2: 687b         	ldr	r3, [r7, #0x4]
 800a2c4: 691b         	ldr	r3, [r3, #0x10]
 800a2c6: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 800a2c8: 617b         	str	r3, [r7, #0x14]
; 					config->head_block->dest_address;
 800a2ca: 687b         	ldr	r3, [r7, #0x4]
 800a2cc: 691b         	ldr	r3, [r3, #0x10]
 800a2ce: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 800a2d0: 613b         	str	r3, [r7, #0x10]
 800a2d2: e007         	b	0x800a2e4 <dma_stm32_configure+0x464> @ imm = #0xe
; 					config->head_block->source_address;
 800a2d4: 687b         	ldr	r3, [r7, #0x4]
 800a2d6: 691b         	ldr	r3, [r3, #0x10]
 800a2d8: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 800a2da: 613b         	str	r3, [r7, #0x10]
; 					config->head_block->dest_address;
 800a2dc: 687b         	ldr	r3, [r7, #0x4]
 800a2de: 691b         	ldr	r3, [r3, #0x10]
 800a2e0: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 800a2e2: 617b         	str	r3, [r7, #0x14]
; 	uint16_t memory_addr_adj = 0, periph_addr_adj = 0;
 800a2e4: 2300         	movs	r3, #0x0
 800a2e6: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
 800a2ea: 2300         	movs	r3, #0x0
 800a2ec: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 	ret = dma_stm32_get_priority(config->channel_priority,
 800a2f0: 687b         	ldr	r3, [r7, #0x4]
 800a2f2: 681b         	ldr	r3, [r3]
 800a2f4: f3c3 33c3    	ubfx	r3, r3, #0xf, #0x4
 800a2f8: b2db         	uxtb	r3, r3
 800a2fa: 461a         	mov	r2, r3
 800a2fc: f107 0310    	add.w	r3, r7, #0x10
 800a300: 3328         	adds	r3, #0x28
 800a302: 4619         	mov	r1, r3
 800a304: 4610         	mov	r0, r2
 800a306: f7ff fc9f    	bl	0x8009c48 <dma_stm32_get_priority> @ imm = #-0x6c2
 800a30a: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 800a30e: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 800a312: 2b00         	cmp	r3, #0x0
 800a314: da02         	bge	0x800a31c <dma_stm32_configure+0x49c> @ imm = #0x4
; 		return ret;
 800a316: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 800a31a: e217         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x42e
; 	ret = dma_stm32_get_direction(config->channel_direction,
 800a31c: 687b         	ldr	r3, [r7, #0x4]
 800a31e: 785b         	ldrb	r3, [r3, #0x1]
 800a320: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 800a324: b2db         	uxtb	r3, r3
 800a326: 461a         	mov	r2, r3
 800a328: f107 0310    	add.w	r3, r7, #0x10
 800a32c: 3308         	adds	r3, #0x8
 800a32e: 4619         	mov	r1, r3
 800a330: 4610         	mov	r0, r2
 800a332: f7ff fcd9    	bl	0x8009ce8 <dma_stm32_get_direction> @ imm = #-0x64e
 800a336: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 800a33a: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 800a33e: 2b00         	cmp	r3, #0x0
 800a340: da02         	bge	0x800a348 <dma_stm32_configure+0x4c8> @ imm = #0x4
; 		return ret;
 800a342: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 800a346: e201         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x402
; 	switch (config->channel_direction) {
 800a348: 687b         	ldr	r3, [r7, #0x4]
 800a34a: 785b         	ldrb	r3, [r3, #0x1]
 800a34c: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 800a350: b2db         	uxtb	r3, r3
 800a352: 2b02         	cmp	r3, #0x2
 800a354: d006         	beq	0x800a364 <dma_stm32_configure+0x4e4> @ imm = #0xc
 800a356: 2b02         	cmp	r3, #0x2
 800a358: dc26         	bgt	0x800a3a8 <dma_stm32_configure+0x528> @ imm = #0x4c
 800a35a: 2b00         	cmp	r3, #0x0
 800a35c: d002         	beq	0x800a364 <dma_stm32_configure+0x4e4> @ imm = #0x4
 800a35e: 2b01         	cmp	r3, #0x1
 800a360: d011         	beq	0x800a386 <dma_stm32_configure+0x506> @ imm = #0x22
 800a362: e021         	b	0x800a3a8 <dma_stm32_configure+0x528> @ imm = #0x42
; 		memory_addr_adj = config->head_block->dest_addr_adj;
 800a364: 687b         	ldr	r3, [r7, #0x4]
 800a366: 691b         	ldr	r3, [r3, #0x10]
 800a368: 7f1b         	ldrb	r3, [r3, #0x1c]
 800a36a: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 800a36e: b2db         	uxtb	r3, r3
 800a370: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
; 		periph_addr_adj = config->head_block->source_addr_adj;
 800a374: 687b         	ldr	r3, [r7, #0x4]
 800a376: 691b         	ldr	r3, [r3, #0x10]
 800a378: 7f1b         	ldrb	r3, [r3, #0x1c]
 800a37a: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 800a37e: b2db         	uxtb	r3, r3
 800a380: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 		break;
 800a384: e036         	b	0x800a3f4 <dma_stm32_configure+0x574> @ imm = #0x6c
; 		memory_addr_adj = config->head_block->source_addr_adj;
 800a386: 687b         	ldr	r3, [r7, #0x4]
 800a388: 691b         	ldr	r3, [r3, #0x10]
 800a38a: 7f1b         	ldrb	r3, [r3, #0x1c]
 800a38c: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 800a390: b2db         	uxtb	r3, r3
 800a392: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
; 		periph_addr_adj = config->head_block->dest_addr_adj;
 800a396: 687b         	ldr	r3, [r7, #0x4]
 800a398: 691b         	ldr	r3, [r3, #0x10]
 800a39a: 7f1b         	ldrb	r3, [r3, #0x1c]
 800a39c: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 800a3a0: b2db         	uxtb	r3, r3
 800a3a2: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 		break;
 800a3a6: e025         	b	0x800a3f4 <dma_stm32_configure+0x574> @ imm = #0x4a
; 		LOG_ERR("Channel direction error (%d).",
 800a3a8: 2303         	movs	r3, #0x3
 800a3aa: 2b00         	cmp	r3, #0x0
 800a3ac: d01f         	beq	0x800a3ee <dma_stm32_configure+0x56e> @ imm = #0x3e
 800a3ae: 2301         	movs	r3, #0x1
 800a3b0: f887 308b    	strb.w	r3, [r7, #0x8b]
 800a3b4: f897 308b    	ldrb.w	r3, [r7, #0x8b]
 800a3b8: f083 0301    	eor	r3, r3, #0x1
 800a3bc: b2db         	uxtb	r3, r3
 800a3be: 2b00         	cmp	r3, #0x0
 800a3c0: d115         	bne	0x800a3ee <dma_stm32_configure+0x56e> @ imm = #0x2a
 800a3c2: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800a41c <dma_stm32_configure+0x59c>
 800a3c4: 6819         	ldr	r1, [r3]
 800a3c6: 687b         	ldr	r3, [r7, #0x4]
 800a3c8: 785b         	ldrb	r3, [r3, #0x1]
 800a3ca: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 800a3ce: b2db         	uxtb	r3, r3
 800a3d0: 9303         	str	r3, [sp, #0xc]
 800a3d2: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800a42c <dma_stm32_configure+0x5ac>
 800a3d4: 9302         	str	r3, [sp, #0x8]
 800a3d6: 2300         	movs	r3, #0x0
 800a3d8: 9301         	str	r3, [sp, #0x4]
 800a3da: 2300         	movs	r3, #0x0
 800a3dc: 9300         	str	r3, [sp]
 800a3de: 2300         	movs	r3, #0x0
 800a3e0: 2201         	movs	r2, #0x1
 800a3e2: 2000         	movs	r0, #0x0
 800a3e4: f013 fd50    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13aa0
 800a3e8: 2300         	movs	r3, #0x0
 800a3ea: f8c7 3084    	str.w	r3, [r7, #0x84]
; 		return -EINVAL;
 800a3ee: f06f 0315    	mvn	r3, #0x15
 800a3f2: e1ab         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x356
; 	ret = dma_stm32_get_memory_increment(memory_addr_adj,
 800a3f4: f8b7 30c6    	ldrh.w	r3, [r7, #0xc6]
 800a3f8: b2da         	uxtb	r2, r3
 800a3fa: f107 0310    	add.w	r3, r7, #0x10
 800a3fe: 3314         	adds	r3, #0x14
 800a400: 4619         	mov	r1, r3
 800a402: 4610         	mov	r0, r2
 800a404: f7ff fcb4    	bl	0x8009d70 <dma_stm32_get_memory_increment> @ imm = #-0x698
 800a408: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 800a40c: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 800a410: 2b00         	cmp	r3, #0x0
 800a412: da0d         	bge	0x800a430 <dma_stm32_configure+0x5b0> @ imm = #0x1a
; 		return ret;
 800a414: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 800a418: e198         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x330
 800a41a: bf00         	nop

0800a41c <$d>:
 800a41c: 38 05 00 20  	.word	0x20000538
 800a420: 6c 91 02 08  	.word	0x0802916c
 800a424: a4 91 02 08  	.word	0x080291a4
 800a428: c4 91 02 08  	.word	0x080291c4
 800a42c: e4 91 02 08  	.word	0x080291e4

0800a430 <$t>:
; 	LOG_DBG("Channel (%d) memory inc (%x).",
 800a430: 2303         	movs	r3, #0x3
 800a432: 2b03         	cmp	r3, #0x3
 800a434: d91f         	bls	0x800a476 <dma_stm32_configure+0x5f6> @ imm = #0x3e
 800a436: 2301         	movs	r3, #0x1
 800a438: f887 30af    	strb.w	r3, [r7, #0xaf]
 800a43c: f897 30af    	ldrb.w	r3, [r7, #0xaf]
 800a440: f083 0301    	eor	r3, r3, #0x1
 800a444: b2db         	uxtb	r3, r3
 800a446: 2b00         	cmp	r3, #0x0
 800a448: d115         	bne	0x800a476 <dma_stm32_configure+0x5f6> @ imm = #0x2a
 800a44a: 4bae         	ldr	r3, [pc, #0x2b8]        @ 0x800a704 <dma_stm32_configure+0x884>
 800a44c: 6819         	ldr	r1, [r3]
 800a44e: 6a7b         	ldr	r3, [r7, #0x24]
 800a450: 9305         	str	r3, [sp, #0x14]
 800a452: 68bb         	ldr	r3, [r7, #0x8]
 800a454: 9304         	str	r3, [sp, #0x10]
 800a456: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x800a708 <dma_stm32_configure+0x888>
 800a458: 9303         	str	r3, [sp, #0xc]
 800a45a: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x800a70c <dma_stm32_configure+0x88c>
 800a45c: 9302         	str	r3, [sp, #0x8]
 800a45e: 2308         	movs	r3, #0x8
 800a460: 9301         	str	r3, [sp, #0x4]
 800a462: 2300         	movs	r3, #0x0
 800a464: 9300         	str	r3, [sp]
 800a466: 2300         	movs	r3, #0x0
 800a468: 2204         	movs	r2, #0x4
 800a46a: 2000         	movs	r0, #0x0
 800a46c: f013 fd0c    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13a18
 800a470: 2300         	movs	r3, #0x0
 800a472: f8c7 30a8    	str.w	r3, [r7, #0xa8]
; 	ret = dma_stm32_get_periph_increment(periph_addr_adj,
 800a476: f8b7 30c4    	ldrh.w	r3, [r7, #0xc4]
 800a47a: b2da         	uxtb	r2, r3
 800a47c: f107 0310    	add.w	r3, r7, #0x10
 800a480: 3310         	adds	r3, #0x10
 800a482: 4619         	mov	r1, r3
 800a484: 4610         	mov	r0, r2
 800a486: f7ff fcb7    	bl	0x8009df8 <dma_stm32_get_periph_increment> @ imm = #-0x692
 800a48a: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 800a48e: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 800a492: 2b00         	cmp	r3, #0x0
 800a494: da02         	bge	0x800a49c <dma_stm32_configure+0x61c> @ imm = #0x4
; 		return ret;
 800a496: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 800a49a: e157         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x2ae
; 	LOG_DBG("Channel (%d) peripheral inc (%x).",
 800a49c: 2303         	movs	r3, #0x3
 800a49e: 2b03         	cmp	r3, #0x3
 800a4a0: d91f         	bls	0x800a4e2 <dma_stm32_configure+0x662> @ imm = #0x3e
 800a4a2: 2301         	movs	r3, #0x1
 800a4a4: f887 30a7    	strb.w	r3, [r7, #0xa7]
 800a4a8: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 800a4ac: f083 0301    	eor	r3, r3, #0x1
 800a4b0: b2db         	uxtb	r3, r3
 800a4b2: 2b00         	cmp	r3, #0x0
 800a4b4: d115         	bne	0x800a4e2 <dma_stm32_configure+0x662> @ imm = #0x2a
 800a4b6: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x800a704 <dma_stm32_configure+0x884>
 800a4b8: 6819         	ldr	r1, [r3]
 800a4ba: 6a3b         	ldr	r3, [r7, #0x20]
 800a4bc: 9305         	str	r3, [sp, #0x14]
 800a4be: 68bb         	ldr	r3, [r7, #0x8]
 800a4c0: 9304         	str	r3, [sp, #0x10]
 800a4c2: 4b91         	ldr	r3, [pc, #0x244]        @ 0x800a708 <dma_stm32_configure+0x888>
 800a4c4: 9303         	str	r3, [sp, #0xc]
 800a4c6: 4b92         	ldr	r3, [pc, #0x248]        @ 0x800a710 <dma_stm32_configure+0x890>
 800a4c8: 9302         	str	r3, [sp, #0x8]
 800a4ca: 2308         	movs	r3, #0x8
 800a4cc: 9301         	str	r3, [sp, #0x4]
 800a4ce: 2300         	movs	r3, #0x0
 800a4d0: 9300         	str	r3, [sp]
 800a4d2: 2300         	movs	r3, #0x0
 800a4d4: 2204         	movs	r2, #0x4
 800a4d6: 2000         	movs	r0, #0x0
 800a4d8: f013 fcd6    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x139ac
 800a4dc: 2300         	movs	r3, #0x0
 800a4de: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 	if (stream->cyclic) {
 800a4e2: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a4e6: 7e1b         	ldrb	r3, [r3, #0x18]
 800a4e8: 2b00         	cmp	r3, #0x0
 800a4ea: d003         	beq	0x800a4f4 <dma_stm32_configure+0x674> @ imm = #0x6
; 		DMA_InitStruct.Mode = LL_DMA_MODE_CIRCULAR;
 800a4ec: f44f 7380    	mov.w	r3, #0x100
 800a4f0: 61fb         	str	r3, [r7, #0x1c]
 800a4f2: e001         	b	0x800a4f8 <dma_stm32_configure+0x678> @ imm = #0x2
; 		DMA_InitStruct.Mode = LL_DMA_MODE_NORMAL;
 800a4f4: 2300         	movs	r3, #0x0
 800a4f6: 61fb         	str	r3, [r7, #0x1c]
; 	stream->source_periph = (stream->direction == PERIPHERAL_TO_MEMORY);
 800a4f8: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a4fc: 681b         	ldr	r3, [r3]
 800a4fe: 2b02         	cmp	r3, #0x2
 800a500: bf0c         	ite	eq
 800a502: 2301         	moveq	r3, #0x1
 800a504: 2300         	movne	r3, #0x0
 800a506: b2da         	uxtb	r2, r3
 800a508: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a50c: 711a         	strb	r2, [r3, #0x4]
; 	int index = find_lsb_set(config->source_data_size) - 1;
 800a50e: 687b         	ldr	r3, [r7, #0x4]
 800a510: 889b         	ldrh	r3, [r3, #0x4]
 800a512: 64fb         	str	r3, [r7, #0x4c]
; 	return __builtin_ffs(op);
 800a514: 6cfb         	ldr	r3, [r7, #0x4c]
 800a516: fa93 f2a3    	rbit	r2, r3
 800a51a: fab2 f282    	clz	r2, r2
 800a51e: 2b00         	cmp	r3, #0x0
 800a520: d101         	bne	0x800a526 <dma_stm32_configure+0x6a6> @ imm = #0x2
 800a522: f04f 32ff    	mov.w	r2, #0xffffffff
 800a526: 1c53         	adds	r3, r2, #0x1
; 	int index = find_lsb_set(config->source_data_size) - 1;
 800a528: 3b01         	subs	r3, #0x1
 800a52a: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	DMA_InitStruct.PeriphOrM2MSrcDataSize = table_p_size[index];
 800a52e: 4a79         	ldr	r2, [pc, #0x1e4]        @ 0x800a714 <dma_stm32_configure+0x894>
 800a530: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 800a534: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800a538: 62bb         	str	r3, [r7, #0x28]
; 	index = find_lsb_set(config->dest_data_size) - 1;
 800a53a: 687b         	ldr	r3, [r7, #0x4]
 800a53c: 88db         	ldrh	r3, [r3, #0x6]
 800a53e: 653b         	str	r3, [r7, #0x50]
; 	return __builtin_ffs(op);
 800a540: 6d3b         	ldr	r3, [r7, #0x50]
 800a542: fa93 f2a3    	rbit	r2, r3
 800a546: fab2 f282    	clz	r2, r2
 800a54a: 2b00         	cmp	r3, #0x0
 800a54c: d101         	bne	0x800a552 <dma_stm32_configure+0x6d2> @ imm = #0x2
 800a54e: f04f 32ff    	mov.w	r2, #0xffffffff
 800a552: 1c53         	adds	r3, r2, #0x1
; 	index = find_lsb_set(config->dest_data_size) - 1;
 800a554: 3b01         	subs	r3, #0x1
 800a556: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	DMA_InitStruct.MemoryOrM2MDstDataSize = table_m_size[index];
 800a55a: 4a6f         	ldr	r2, [pc, #0x1bc]        @ 0x800a718 <dma_stm32_configure+0x898>
 800a55c: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 800a560: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800a564: 62fb         	str	r3, [r7, #0x2c]
; 	DMA_InitStruct.MemBurst = stm32_dma_get_mburst(config,
 800a566: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a56a: 791b         	ldrb	r3, [r3, #0x4]
 800a56c: 4619         	mov	r1, r3
 800a56e: 6878         	ldr	r0, [r7, #0x4]
 800a570: f000 fbca    	bl	0x800ad08 <stm32_dma_get_mburst> @ imm = #0x794
 800a574: 4603         	mov	r3, r0
 800a576: 647b         	str	r3, [r7, #0x44]
; 	DMA_InitStruct.PeriphBurst = stm32_dma_get_pburst(config,
 800a578: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a57c: 791b         	ldrb	r3, [r3, #0x4]
 800a57e: 4619         	mov	r1, r3
 800a580: 6878         	ldr	r0, [r7, #0x4]
 800a582: f000 fc27    	bl	0x800add4 <stm32_dma_get_pburst> @ imm = #0x84e
 800a586: 4603         	mov	r3, r0
 800a588: 64bb         	str	r3, [r7, #0x48]
; 	if (config->channel_direction != MEMORY_TO_MEMORY) {
 800a58a: 687b         	ldr	r3, [r7, #0x4]
 800a58c: 785b         	ldrb	r3, [r3, #0x1]
 800a58e: f003 0307    	and	r3, r3, #0x7
 800a592: b2db         	uxtb	r3, r3
 800a594: 2b00         	cmp	r3, #0x0
 800a596: d023         	beq	0x800a5e0 <dma_stm32_configure+0x760> @ imm = #0x46
; 		if (config->dma_slot >= 8) {
 800a598: 687b         	ldr	r3, [r7, #0x4]
 800a59a: 781b         	ldrb	r3, [r3]
 800a59c: 2b07         	cmp	r3, #0x7
 800a59e: d943         	bls	0x800a628 <dma_stm32_configure+0x7a8> @ imm = #0x86
; 			LOG_ERR("dma slot error.");
 800a5a0: 2303         	movs	r3, #0x3
 800a5a2: 2b00         	cmp	r3, #0x0
 800a5a4: d019         	beq	0x800a5da <dma_stm32_configure+0x75a> @ imm = #0x32
 800a5a6: 2301         	movs	r3, #0x1
 800a5a8: f887 3093    	strb.w	r3, [r7, #0x93]
 800a5ac: f897 3093    	ldrb.w	r3, [r7, #0x93]
 800a5b0: f083 0301    	eor	r3, r3, #0x1
 800a5b4: b2db         	uxtb	r3, r3
 800a5b6: 2b00         	cmp	r3, #0x0
 800a5b8: d10f         	bne	0x800a5da <dma_stm32_configure+0x75a> @ imm = #0x1e
 800a5ba: 4b52         	ldr	r3, [pc, #0x148]        @ 0x800a704 <dma_stm32_configure+0x884>
 800a5bc: 6819         	ldr	r1, [r3]
 800a5be: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x800a71c <dma_stm32_configure+0x89c>
 800a5c0: 9302         	str	r3, [sp, #0x8]
 800a5c2: 2300         	movs	r3, #0x0
 800a5c4: 9301         	str	r3, [sp, #0x4]
 800a5c6: 2300         	movs	r3, #0x0
 800a5c8: 9300         	str	r3, [sp]
 800a5ca: 2300         	movs	r3, #0x0
 800a5cc: 2201         	movs	r2, #0x1
 800a5ce: 2000         	movs	r0, #0x0
 800a5d0: f013 fc5a    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x138b4
 800a5d4: 2300         	movs	r3, #0x0
 800a5d6: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			return -EINVAL;
 800a5da: f06f 0315    	mvn	r3, #0x15
 800a5de: e0b5         	b	0x800a74c <dma_stm32_configure+0x8cc> @ imm = #0x16a
; 		if (config->dma_slot >= 8) {
 800a5e0: 687b         	ldr	r3, [r7, #0x4]
 800a5e2: 781b         	ldrb	r3, [r3]
 800a5e4: 2b07         	cmp	r3, #0x7
 800a5e6: d91f         	bls	0x800a628 <dma_stm32_configure+0x7a8> @ imm = #0x3e
; 			LOG_ERR("dma slot is too big, using 0 as default.");
 800a5e8: 2303         	movs	r3, #0x3
 800a5ea: 2b00         	cmp	r3, #0x0
 800a5ec: d019         	beq	0x800a622 <dma_stm32_configure+0x7a2> @ imm = #0x32
 800a5ee: 2301         	movs	r3, #0x1
 800a5f0: f887 309b    	strb.w	r3, [r7, #0x9b]
 800a5f4: f897 309b    	ldrb.w	r3, [r7, #0x9b]
 800a5f8: f083 0301    	eor	r3, r3, #0x1
 800a5fc: b2db         	uxtb	r3, r3
 800a5fe: 2b00         	cmp	r3, #0x0
 800a600: d10f         	bne	0x800a622 <dma_stm32_configure+0x7a2> @ imm = #0x1e
 800a602: 4b40         	ldr	r3, [pc, #0x100]        @ 0x800a704 <dma_stm32_configure+0x884>
 800a604: 6819         	ldr	r1, [r3]
 800a606: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800a720 <dma_stm32_configure+0x8a0>
 800a608: 9302         	str	r3, [sp, #0x8]
 800a60a: 2300         	movs	r3, #0x0
 800a60c: 9301         	str	r3, [sp, #0x4]
 800a60e: 2300         	movs	r3, #0x0
 800a610: 9300         	str	r3, [sp]
 800a612: 2300         	movs	r3, #0x0
 800a614: 2201         	movs	r2, #0x1
 800a616: 2000         	movs	r0, #0x0
 800a618: f013 fc36    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x1386c
 800a61c: 2300         	movs	r3, #0x0
 800a61e: f8c7 3094    	str.w	r3, [r7, #0x94]
; 			config->dma_slot = 0;
 800a622: 687b         	ldr	r3, [r7, #0x4]
 800a624: 2200         	movs	r2, #0x0
 800a626: 701a         	strb	r2, [r3]
; 	DMA_InitStruct.Channel = dma_stm32_slot_to_channel(config->dma_slot);
 800a628: 687b         	ldr	r3, [r7, #0x4]
 800a62a: 781b         	ldrb	r3, [r3]
 800a62c: 4618         	mov	r0, r3
 800a62e: f000 f9f7    	bl	0x800aa20 <dma_stm32_slot_to_channel> @ imm = #0x3ee
 800a632: 4603         	mov	r3, r0
 800a634: 637b         	str	r3, [r7, #0x34]
; 					config->head_block->fifo_mode_control);
 800a636: 687b         	ldr	r3, [r7, #0x4]
 800a638: 691b         	ldr	r3, [r3, #0x10]
 800a63a: 7f5b         	ldrb	r3, [r3, #0x1d]
 800a63c: f3c3 0303    	ubfx	r3, r3, #0x0, #0x4
 800a640: b2db         	uxtb	r3, r3
; 	DMA_InitStruct.FIFOThreshold = stm32_dma_get_fifo_threshold(
 800a642: 4618         	mov	r0, r3
 800a644: f000 fc2c    	bl	0x800aea0 <stm32_dma_get_fifo_threshold> @ imm = #0x858
 800a648: 4603         	mov	r3, r0
 800a64a: 643b         	str	r3, [r7, #0x40]
; 	if (stm32_dma_check_fifo_mburst(&DMA_InitStruct)) {
 800a64c: f107 0310    	add.w	r3, r7, #0x10
 800a650: 4618         	mov	r0, r3
 800a652: f014 fd10    	bl	0x801f076 <stm32_dma_check_fifo_mburst> @ imm = #0x14a20
 800a656: 4603         	mov	r3, r0
 800a658: 2b00         	cmp	r3, #0x0
 800a65a: d002         	beq	0x800a662 <dma_stm32_configure+0x7e2> @ imm = #0x4
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_ENABLE;
 800a65c: 2304         	movs	r3, #0x4
 800a65e: 63fb         	str	r3, [r7, #0x3c]
 800a660: e001         	b	0x800a666 <dma_stm32_configure+0x7e6> @ imm = #0x2
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_DISABLE;
 800a662: 2300         	movs	r3, #0x0
 800a664: 63fb         	str	r3, [r7, #0x3c]
; 	if (stream->source_periph) {
 800a666: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a66a: 791b         	ldrb	r3, [r3, #0x4]
 800a66c: 2b00         	cmp	r3, #0x0
 800a66e: d008         	beq	0x800a682 <dma_stm32_configure+0x802> @ imm = #0x10
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 800a670: 687b         	ldr	r3, [r7, #0x4]
 800a672: 691b         	ldr	r3, [r3, #0x10]
 800a674: 695b         	ldr	r3, [r3, #0x14]
; 					config->source_data_size;
 800a676: 687a         	ldr	r2, [r7, #0x4]
 800a678: 8892         	ldrh	r2, [r2, #0x4]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 800a67a: fbb3 f3f2    	udiv	r3, r3, r2
 800a67e: 633b         	str	r3, [r7, #0x30]
 800a680: e007         	b	0x800a692 <dma_stm32_configure+0x812> @ imm = #0xe
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 800a682: 687b         	ldr	r3, [r7, #0x4]
 800a684: 691b         	ldr	r3, [r3, #0x10]
 800a686: 695b         	ldr	r3, [r3, #0x14]
; 					config->dest_data_size;
 800a688: 687a         	ldr	r2, [r7, #0x4]
 800a68a: 88d2         	ldrh	r2, [r2, #0x6]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 800a68c: fbb3 f3f2    	udiv	r3, r3, r2
 800a690: 633b         	str	r3, [r7, #0x30]
; 	LL_DMA_Init(dma, dma_stm32_id_to_stream(id), &DMA_InitStruct);
 800a692: 68b8         	ldr	r0, [r7, #0x8]
 800a694: f000 f9b4    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #0x368
 800a698: 4601         	mov	r1, r0
 800a69a: f107 0310    	add.w	r3, r7, #0x10
 800a69e: 461a         	mov	r2, r3
 800a6a0: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 800a6a4: f019 fe75    	bl	0x8024392 <LL_DMA_Init> @ imm = #0x19cea
; 	LL_DMA_EnableIT_TC(dma, dma_stm32_id_to_stream(id));
 800a6a8: 68b8         	ldr	r0, [r7, #0x8]
 800a6aa: f000 f9a9    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #0x352
 800a6ae: 4603         	mov	r3, r0
 800a6b0: 4619         	mov	r1, r3
 800a6b2: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 800a6b6: f7ff f97b    	bl	0x80099b0 <LL_DMA_EnableIT_TC> @ imm = #-0xd0a
; 	if (stream->cyclic) {
 800a6ba: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800a6be: 7e1b         	ldrb	r3, [r3, #0x18]
 800a6c0: 2b00         	cmp	r3, #0x0
 800a6c2: d008         	beq	0x800a6d6 <dma_stm32_configure+0x856> @ imm = #0x10
; 		LL_DMA_EnableIT_HT(dma, dma_stm32_id_to_stream(id));
 800a6c4: 68b8         	ldr	r0, [r7, #0x8]
 800a6c6: f000 f99b    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #0x336
 800a6ca: 4603         	mov	r3, r0
 800a6cc: 4619         	mov	r1, r3
 800a6ce: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 800a6d2: f7ff f94d    	bl	0x8009970 <LL_DMA_EnableIT_HT> @ imm = #-0xd66
; 	if (DMA_InitStruct.FIFOMode == LL_DMA_FIFOMODE_ENABLE) {
 800a6d6: 6bfb         	ldr	r3, [r7, #0x3c]
 800a6d8: 2b04         	cmp	r3, #0x4
 800a6da: d123         	bne	0x800a724 <dma_stm32_configure+0x8a4> @ imm = #0x46
; 		LL_DMA_EnableFifoMode(dma, dma_stm32_id_to_stream(id));
 800a6dc: 68b8         	ldr	r0, [r7, #0x8]
 800a6de: f000 f98f    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #0x31e
 800a6e2: 4603         	mov	r3, r0
 800a6e4: 4619         	mov	r1, r3
 800a6e6: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 800a6ea: f7ff f8f1    	bl	0x80098d0 <LL_DMA_EnableFifoMode> @ imm = #-0xe1e
; 		LL_DMA_EnableIT_FE(dma, dma_stm32_id_to_stream(id));
 800a6ee: 68b8         	ldr	r0, [r7, #0x8]
 800a6f0: f000 f986    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #0x30c
 800a6f4: 4603         	mov	r3, r0
 800a6f6: 4619         	mov	r1, r3
 800a6f8: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 800a6fc: f7ff f978    	bl	0x80099f0 <LL_DMA_EnableIT_FE> @ imm = #-0xd10
 800a700: e022         	b	0x800a748 <dma_stm32_configure+0x8c8> @ imm = #0x44
 800a702: bf00         	nop

0800a704 <$d>:
 800a704: 38 05 00 20  	.word	0x20000538
 800a708: e4 a9 02 08  	.word	0x0802a9e4
 800a70c: 04 92 02 08  	.word	0x08029204
 800a710: 28 92 02 08  	.word	0x08029228
 800a714: 78 a9 02 08  	.word	0x0802a978
 800a718: 6c a9 02 08  	.word	0x0802a96c
 800a71c: 50 92 02 08  	.word	0x08029250
 800a720: 60 92 02 08  	.word	0x08029260

0800a724 <$t>:
; 		LL_DMA_DisableFifoMode(dma, dma_stm32_id_to_stream(id));
 800a724: 68b8         	ldr	r0, [r7, #0x8]
 800a726: f000 f96b    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #0x2d6
 800a72a: 4603         	mov	r3, r0
 800a72c: 4619         	mov	r1, r3
 800a72e: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 800a732: f7ff f8ad    	bl	0x8009890 <LL_DMA_DisableFifoMode> @ imm = #-0xea6
; 		LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 800a736: 68b8         	ldr	r0, [r7, #0x8]
 800a738: f000 f962    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #0x2c4
 800a73c: 4603         	mov	r3, r0
 800a73e: 4619         	mov	r1, r3
 800a740: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 800a744: f7ff f994    	bl	0x8009a70 <LL_DMA_DisableIT_FE> @ imm = #-0xcd8
; 	return ret;
 800a748: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
; }
 800a74c: 4618         	mov	r0, r3
 800a74e: 37e0         	adds	r7, #0xe0
 800a750: 46bd         	mov	sp, r7
 800a752: bd80         	pop	{r7, pc}

0800a754 <dma_stm32_init>:
; {
 800a754: b580         	push	{r7, lr}
 800a756: b08e         	sub	sp, #0x38
 800a758: af04         	add	r7, sp, #0x10
 800a75a: 6078         	str	r0, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 800a75c: 687b         	ldr	r3, [r7, #0x4]
 800a75e: 685b         	ldr	r3, [r3, #0x4]
 800a760: 623b         	str	r3, [r7, #0x20]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800a762: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x800a850 <dma_stm32_init+0xfc>
 800a764: 61fb         	str	r3, [r7, #0x1c]
; 	if (!device_is_ready(clk)) {
 800a766: 69f8         	ldr	r0, [r7, #0x1c]
 800a768: f013 fb62    	bl	0x801de30 <device_is_ready> @ imm = #0x136c4
 800a76c: 4603         	mov	r3, r0
 800a76e: f083 0301    	eor	r3, r3, #0x1
 800a772: b2db         	uxtb	r3, r3
 800a774: 2b00         	cmp	r3, #0x0
 800a776: d01c         	beq	0x800a7b2 <dma_stm32_init+0x5e> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800a778: 2303         	movs	r3, #0x3
 800a77a: 2b00         	cmp	r3, #0x0
 800a77c: d016         	beq	0x800a7ac <dma_stm32_init+0x58> @ imm = #0x2c
 800a77e: 2301         	movs	r3, #0x1
 800a780: 74fb         	strb	r3, [r7, #0x13]
 800a782: 7cfb         	ldrb	r3, [r7, #0x13]
 800a784: f083 0301    	eor	r3, r3, #0x1
 800a788: b2db         	uxtb	r3, r3
 800a78a: 2b00         	cmp	r3, #0x0
 800a78c: d10e         	bne	0x800a7ac <dma_stm32_init+0x58> @ imm = #0x1c
 800a78e: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800a854 <dma_stm32_init+0x100>
 800a790: 6819         	ldr	r1, [r3]
 800a792: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800a858 <dma_stm32_init+0x104>
 800a794: 9302         	str	r3, [sp, #0x8]
 800a796: 2300         	movs	r3, #0x0
 800a798: 9301         	str	r3, [sp, #0x4]
 800a79a: 2300         	movs	r3, #0x0
 800a79c: 9300         	str	r3, [sp]
 800a79e: 2300         	movs	r3, #0x0
 800a7a0: 2201         	movs	r2, #0x1
 800a7a2: 2000         	movs	r0, #0x0
 800a7a4: f013 fb70    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x136e0
 800a7a8: 2300         	movs	r3, #0x0
 800a7aa: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800a7ac: f06f 0312    	mvn	r3, #0x12
 800a7b0: e04a         	b	0x800a848 <dma_stm32_init+0xf4> @ imm = #0x94
; 		(clock_control_subsys_t) &config->pclken) != 0) {
 800a7b2: 6a3b         	ldr	r3, [r7, #0x20]
; 	if (clock_control_on(clk,
 800a7b4: 4619         	mov	r1, r3
 800a7b6: 69f8         	ldr	r0, [r7, #0x1c]
 800a7b8: f013 fb54    	bl	0x801de64 <clock_control_on> @ imm = #0x136a8
 800a7bc: 4603         	mov	r3, r0
 800a7be: 2b00         	cmp	r3, #0x0
 800a7c0: d01c         	beq	0x800a7fc <dma_stm32_init+0xa8> @ imm = #0x38
; 		LOG_ERR("clock op failed\n");
 800a7c2: 2303         	movs	r3, #0x3
 800a7c4: 2b00         	cmp	r3, #0x0
 800a7c6: d016         	beq	0x800a7f6 <dma_stm32_init+0xa2> @ imm = #0x2c
 800a7c8: 2301         	movs	r3, #0x1
 800a7ca: 76fb         	strb	r3, [r7, #0x1b]
 800a7cc: 7efb         	ldrb	r3, [r7, #0x1b]
 800a7ce: f083 0301    	eor	r3, r3, #0x1
 800a7d2: b2db         	uxtb	r3, r3
 800a7d4: 2b00         	cmp	r3, #0x0
 800a7d6: d10e         	bne	0x800a7f6 <dma_stm32_init+0xa2> @ imm = #0x1c
 800a7d8: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800a854 <dma_stm32_init+0x100>
 800a7da: 6819         	ldr	r1, [r3]
 800a7dc: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800a85c <dma_stm32_init+0x108>
 800a7de: 9302         	str	r3, [sp, #0x8]
 800a7e0: 2300         	movs	r3, #0x0
 800a7e2: 9301         	str	r3, [sp, #0x4]
 800a7e4: 2300         	movs	r3, #0x0
 800a7e6: 9300         	str	r3, [sp]
 800a7e8: 2300         	movs	r3, #0x0
 800a7ea: 2201         	movs	r2, #0x1
 800a7ec: 2000         	movs	r0, #0x0
 800a7ee: f013 fb4b    	bl	0x801de88 <z_log_msg_runtime_create> @ imm = #0x13696
 800a7f2: 2300         	movs	r3, #0x0
 800a7f4: 617b         	str	r3, [r7, #0x14]
; 		return -EIO;
 800a7f6: f06f 0304    	mvn	r3, #0x4
 800a7fa: e025         	b	0x800a848 <dma_stm32_init+0xf4> @ imm = #0x4a
; 	config->config_irq(dev);
 800a7fc: 6a3b         	ldr	r3, [r7, #0x20]
 800a7fe: 689b         	ldr	r3, [r3, #0x8]
 800a800: 6878         	ldr	r0, [r7, #0x4]
 800a802: 4798         	blx	r3
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 800a804: 2300         	movs	r3, #0x0
 800a806: 627b         	str	r3, [r7, #0x24]
 800a808: e00c         	b	0x800a824 <dma_stm32_init+0xd0> @ imm = #0x18
; 		config->streams[i].busy = false;
 800a80a: 6a3b         	ldr	r3, [r7, #0x20]
 800a80c: 6999         	ldr	r1, [r3, #0x18]
 800a80e: 6a7a         	ldr	r2, [r7, #0x24]
 800a810: 4613         	mov	r3, r2
 800a812: 00db         	lsls	r3, r3, #0x3
 800a814: 1a9b         	subs	r3, r3, r2
 800a816: 009b         	lsls	r3, r3, #0x2
 800a818: 440b         	add	r3, r1
 800a81a: 2200         	movs	r2, #0x0
 800a81c: 719a         	strb	r2, [r3, #0x6]
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 800a81e: 6a7b         	ldr	r3, [r7, #0x24]
 800a820: 3301         	adds	r3, #0x1
 800a822: 627b         	str	r3, [r7, #0x24]
 800a824: 6a3b         	ldr	r3, [r7, #0x20]
 800a826: 695b         	ldr	r3, [r3, #0x14]
 800a828: 6a7a         	ldr	r2, [r7, #0x24]
 800a82a: 429a         	cmp	r2, r3
 800a82c: d3ed         	blo	0x800a80a <dma_stm32_init+0xb6> @ imm = #-0x26
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.magic = 0;
 800a82e: 687b         	ldr	r3, [r7, #0x4]
 800a830: 691b         	ldr	r3, [r3, #0x10]
 800a832: 2200         	movs	r2, #0x0
 800a834: 601a         	str	r2, [r3]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.dma_channels = 0;
 800a836: 687b         	ldr	r3, [r7, #0x4]
 800a838: 691b         	ldr	r3, [r3, #0x10]
 800a83a: 2200         	movs	r2, #0x0
 800a83c: 605a         	str	r2, [r3, #0x4]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.atomic = 0;
 800a83e: 687b         	ldr	r3, [r7, #0x4]
 800a840: 691b         	ldr	r3, [r3, #0x10]
 800a842: 2200         	movs	r2, #0x0
 800a844: 609a         	str	r2, [r3, #0x8]
; 	return 0;
 800a846: 2300         	movs	r3, #0x0
; }
 800a848: 4618         	mov	r0, r3
 800a84a: 3728         	adds	r7, #0x28
 800a84c: 46bd         	mov	sp, r7
 800a84e: bd80         	pop	{r7, pc}

0800a850 <$d>:
 800a850: 48 7a 02 08  	.word	0x08027a48
 800a854: 38 05 00 20  	.word	0x20000538
 800a858: 8c 92 02 08  	.word	0x0802928c
 800a85c: ac 92 02 08  	.word	0x080292ac

0800a860 <LL_DMA_EnableStream>:
; {
 800a860: b480         	push	{r7}
 800a862: b083         	sub	sp, #0xc
 800a864: af00         	add	r7, sp, #0x0
 800a866: 6078         	str	r0, [r7, #0x4]
 800a868: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN);
 800a86a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800a89c <LL_DMA_EnableStream+0x3c>
 800a86c: 683b         	ldr	r3, [r7]
 800a86e: 4413         	add	r3, r2
 800a870: 781b         	ldrb	r3, [r3]
 800a872: 461a         	mov	r2, r3
 800a874: 687b         	ldr	r3, [r7, #0x4]
 800a876: 4413         	add	r3, r2
 800a878: 681b         	ldr	r3, [r3]
 800a87a: 4908         	ldr	r1, [pc, #0x20]         @ 0x800a89c <LL_DMA_EnableStream+0x3c>
 800a87c: 683a         	ldr	r2, [r7]
 800a87e: 440a         	add	r2, r1
 800a880: 7812         	ldrb	r2, [r2]
 800a882: 4611         	mov	r1, r2
 800a884: 687a         	ldr	r2, [r7, #0x4]
 800a886: 440a         	add	r2, r1
 800a888: f043 0301    	orr	r3, r3, #0x1
 800a88c: 6013         	str	r3, [r2]
; }
 800a88e: bf00         	nop
 800a890: 370c         	adds	r7, #0xc
 800a892: 46bd         	mov	sp, r7
 800a894: f85d 7b04    	ldr	r7, [sp], #4
 800a898: 4770         	bx	lr
 800a89a: bf00         	nop

0800a89c <$d>:
 800a89c: f8 a9 02 08  	.word	0x0802a9f8

0800a8a0 <LL_DMA_DisableStream>:
; {
 800a8a0: b480         	push	{r7}
 800a8a2: b083         	sub	sp, #0xc
 800a8a4: af00         	add	r7, sp, #0x0
 800a8a6: 6078         	str	r0, [r7, #0x4]
 800a8a8: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN);
 800a8aa: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800a8dc <LL_DMA_DisableStream+0x3c>
 800a8ac: 683b         	ldr	r3, [r7]
 800a8ae: 4413         	add	r3, r2
 800a8b0: 781b         	ldrb	r3, [r3]
 800a8b2: 461a         	mov	r2, r3
 800a8b4: 687b         	ldr	r3, [r7, #0x4]
 800a8b6: 4413         	add	r3, r2
 800a8b8: 681b         	ldr	r3, [r3]
 800a8ba: 4908         	ldr	r1, [pc, #0x20]         @ 0x800a8dc <LL_DMA_DisableStream+0x3c>
 800a8bc: 683a         	ldr	r2, [r7]
 800a8be: 440a         	add	r2, r1
 800a8c0: 7812         	ldrb	r2, [r2]
 800a8c2: 4611         	mov	r1, r2
 800a8c4: 687a         	ldr	r2, [r7, #0x4]
 800a8c6: 440a         	add	r2, r1
 800a8c8: f023 0301    	bic	r3, r3, #0x1
 800a8cc: 6013         	str	r3, [r2]
; }
 800a8ce: bf00         	nop
 800a8d0: 370c         	adds	r7, #0xc
 800a8d2: 46bd         	mov	sp, r7
 800a8d4: f85d 7b04    	ldr	r7, [sp], #4
 800a8d8: 4770         	bx	lr
 800a8da: bf00         	nop

0800a8dc <$d>:
 800a8dc: f8 a9 02 08  	.word	0x0802a9f8

0800a8e0 <LL_DMA_IsEnabledStream>:
; {
 800a8e0: b480         	push	{r7}
 800a8e2: b083         	sub	sp, #0xc
 800a8e4: af00         	add	r7, sp, #0x0
 800a8e6: 6078         	str	r0, [r7, #0x4]
 800a8e8: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN) == (DMA_SxCR_EN));
 800a8ea: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800a914 <LL_DMA_IsEnabledStream+0x34>
 800a8ec: 683b         	ldr	r3, [r7]
 800a8ee: 4413         	add	r3, r2
 800a8f0: 781b         	ldrb	r3, [r3]
 800a8f2: 461a         	mov	r2, r3
 800a8f4: 687b         	ldr	r3, [r7, #0x4]
 800a8f6: 4413         	add	r3, r2
 800a8f8: 681b         	ldr	r3, [r3]
 800a8fa: f003 0301    	and	r3, r3, #0x1
 800a8fe: 2b01         	cmp	r3, #0x1
 800a900: bf0c         	ite	eq
 800a902: 2301         	moveq	r3, #0x1
 800a904: 2300         	movne	r3, #0x0
 800a906: b2db         	uxtb	r3, r3
; }
 800a908: 4618         	mov	r0, r3
 800a90a: 370c         	adds	r7, #0xc
 800a90c: 46bd         	mov	sp, r7
 800a90e: f85d 7b04    	ldr	r7, [sp], #4
 800a912: 4770         	bx	lr

0800a914 <$d>:
 800a914: f8 a9 02 08  	.word	0x0802a9f8

0800a918 <LL_DMA_DisableIT_FE>:
; {
 800a918: b480         	push	{r7}
 800a91a: b083         	sub	sp, #0xc
 800a91c: af00         	add	r7, sp, #0x0
 800a91e: 6078         	str	r0, [r7, #0x4]
 800a920: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 800a922: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800a954 <LL_DMA_DisableIT_FE+0x3c>
 800a924: 683b         	ldr	r3, [r7]
 800a926: 4413         	add	r3, r2
 800a928: 781b         	ldrb	r3, [r3]
 800a92a: 461a         	mov	r2, r3
 800a92c: 687b         	ldr	r3, [r7, #0x4]
 800a92e: 4413         	add	r3, r2
 800a930: 695b         	ldr	r3, [r3, #0x14]
 800a932: 4908         	ldr	r1, [pc, #0x20]         @ 0x800a954 <LL_DMA_DisableIT_FE+0x3c>
 800a934: 683a         	ldr	r2, [r7]
 800a936: 440a         	add	r2, r1
 800a938: 7812         	ldrb	r2, [r2]
 800a93a: 4611         	mov	r1, r2
 800a93c: 687a         	ldr	r2, [r7, #0x4]
 800a93e: 440a         	add	r2, r1
 800a940: f023 0380    	bic	r3, r3, #0x80
 800a944: 6153         	str	r3, [r2, #0x14]
; }
 800a946: bf00         	nop
 800a948: 370c         	adds	r7, #0xc
 800a94a: 46bd         	mov	sp, r7
 800a94c: f85d 7b04    	ldr	r7, [sp], #4
 800a950: 4770         	bx	lr
 800a952: bf00         	nop

0800a954 <$d>:
 800a954: f8 a9 02 08  	.word	0x0802a9f8

0800a958 <LL_DMA_IsEnabledIT_HT>:
; {
 800a958: b480         	push	{r7}
 800a95a: b083         	sub	sp, #0xc
 800a95c: af00         	add	r7, sp, #0x0
 800a95e: 6078         	str	r0, [r7, #0x4]
 800a960: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_HTIE) == DMA_SxCR_HTIE);
 800a962: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800a98c <LL_DMA_IsEnabledIT_HT+0x34>
 800a964: 683b         	ldr	r3, [r7]
 800a966: 4413         	add	r3, r2
 800a968: 781b         	ldrb	r3, [r3]
 800a96a: 461a         	mov	r2, r3
 800a96c: 687b         	ldr	r3, [r7, #0x4]
 800a96e: 4413         	add	r3, r2
 800a970: 681b         	ldr	r3, [r3]
 800a972: f003 0308    	and	r3, r3, #0x8
 800a976: 2b08         	cmp	r3, #0x8
 800a978: bf0c         	ite	eq
 800a97a: 2301         	moveq	r3, #0x1
 800a97c: 2300         	movne	r3, #0x0
 800a97e: b2db         	uxtb	r3, r3
; }
 800a980: 4618         	mov	r0, r3
 800a982: 370c         	adds	r7, #0xc
 800a984: 46bd         	mov	sp, r7
 800a986: f85d 7b04    	ldr	r7, [sp], #4
 800a98a: 4770         	bx	lr

0800a98c <$d>:
 800a98c: f8 a9 02 08  	.word	0x0802a9f8

0800a990 <LL_DMA_IsEnabledIT_TC>:
; {
 800a990: b480         	push	{r7}
 800a992: b083         	sub	sp, #0xc
 800a994: af00         	add	r7, sp, #0x0
 800a996: 6078         	str	r0, [r7, #0x4]
 800a998: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE) == DMA_SxCR_TCIE);
 800a99a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800a9c4 <LL_DMA_IsEnabledIT_TC+0x34>
 800a99c: 683b         	ldr	r3, [r7]
 800a99e: 4413         	add	r3, r2
 800a9a0: 781b         	ldrb	r3, [r3]
 800a9a2: 461a         	mov	r2, r3
 800a9a4: 687b         	ldr	r3, [r7, #0x4]
 800a9a6: 4413         	add	r3, r2
 800a9a8: 681b         	ldr	r3, [r3]
 800a9aa: f003 0310    	and	r3, r3, #0x10
 800a9ae: 2b10         	cmp	r3, #0x10
 800a9b0: bf0c         	ite	eq
 800a9b2: 2301         	moveq	r3, #0x1
 800a9b4: 2300         	movne	r3, #0x0
 800a9b6: b2db         	uxtb	r3, r3
; }
 800a9b8: 4618         	mov	r0, r3
 800a9ba: 370c         	adds	r7, #0xc
 800a9bc: 46bd         	mov	sp, r7
 800a9be: f85d 7b04    	ldr	r7, [sp], #4
 800a9c2: 4770         	bx	lr

0800a9c4 <$d>:
 800a9c4: f8 a9 02 08  	.word	0x0802a9f8

0800a9c8 <LL_DMA_IsEnabledIT_FE>:
; {
 800a9c8: b480         	push	{r7}
 800a9ca: b083         	sub	sp, #0xc
 800a9cc: af00         	add	r7, sp, #0x0
 800a9ce: 6078         	str	r0, [r7, #0x4]
 800a9d0: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE) == DMA_SxFCR_FEIE);
 800a9d2: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800a9fc <LL_DMA_IsEnabledIT_FE+0x34>
 800a9d4: 683b         	ldr	r3, [r7]
 800a9d6: 4413         	add	r3, r2
 800a9d8: 781b         	ldrb	r3, [r3]
 800a9da: 461a         	mov	r2, r3
 800a9dc: 687b         	ldr	r3, [r7, #0x4]
 800a9de: 4413         	add	r3, r2
 800a9e0: 695b         	ldr	r3, [r3, #0x14]
 800a9e2: f003 0380    	and	r3, r3, #0x80
 800a9e6: 2b80         	cmp	r3, #0x80
 800a9e8: bf0c         	ite	eq
 800a9ea: 2301         	moveq	r3, #0x1
 800a9ec: 2300         	movne	r3, #0x0
 800a9ee: b2db         	uxtb	r3, r3
; }
 800a9f0: 4618         	mov	r0, r3
 800a9f2: 370c         	adds	r7, #0xc
 800a9f4: 46bd         	mov	sp, r7
 800a9f6: f85d 7b04    	ldr	r7, [sp], #4
 800a9fa: 4770         	bx	lr

0800a9fc <$d>:
 800a9fc: f8 a9 02 08  	.word	0x0802a9f8

0800aa00 <dma_stm32_id_to_stream>:
; {
 800aa00: b480         	push	{r7}
 800aa02: b083         	sub	sp, #0xc
 800aa04: af00         	add	r7, sp, #0x0
 800aa06: 6078         	str	r0, [r7, #0x4]
; 	return stream_nr[id];
 800aa08: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800aa1c <dma_stm32_id_to_stream+0x1c>
 800aa0a: 687b         	ldr	r3, [r7, #0x4]
 800aa0c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 800aa10: 4618         	mov	r0, r3
 800aa12: 370c         	adds	r7, #0xc
 800aa14: 46bd         	mov	sp, r7
 800aa16: f85d 7b04    	ldr	r7, [sp], #4
 800aa1a: 4770         	bx	lr

0800aa1c <$d>:
 800aa1c: 00 aa 02 08  	.word	0x0802aa00

0800aa20 <dma_stm32_slot_to_channel>:
; {
 800aa20: b480         	push	{r7}
 800aa22: b083         	sub	sp, #0xc
 800aa24: af00         	add	r7, sp, #0x0
 800aa26: 6078         	str	r0, [r7, #0x4]
; 	return channel_nr[slot];
 800aa28: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800aa3c <dma_stm32_slot_to_channel+0x1c>
 800aa2a: 687b         	ldr	r3, [r7, #0x4]
 800aa2c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 800aa30: 4618         	mov	r0, r3
 800aa32: 370c         	adds	r7, #0xc
 800aa34: 46bd         	mov	sp, r7
 800aa36: f85d 7b04    	ldr	r7, [sp], #4
 800aa3a: 4770         	bx	lr

0800aa3c <$d>:
 800aa3c: 20 aa 02 08  	.word	0x0802aa20

0800aa40 <dma_stm32_clear_ht>:
; {
 800aa40: b580         	push	{r7, lr}
 800aa42: b082         	sub	sp, #0x8
 800aa44: af00         	add	r7, sp, #0x0
 800aa46: 6078         	str	r0, [r7, #0x4]
 800aa48: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800aa4a: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800aa60 <dma_stm32_clear_ht+0x20>
 800aa4c: 683b         	ldr	r3, [r7]
 800aa4e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800aa52: 6878         	ldr	r0, [r7, #0x4]
 800aa54: 4798         	blx	r3
; }
 800aa56: bf00         	nop
 800aa58: 3708         	adds	r7, #0x8
 800aa5a: 46bd         	mov	sp, r7
 800aa5c: bd80         	pop	{r7, pc}
 800aa5e: bf00         	nop

0800aa60 <$d>:
 800aa60: 40 aa 02 08  	.word	0x0802aa40

0800aa64 <dma_stm32_clear_tc>:
; {
 800aa64: b580         	push	{r7, lr}
 800aa66: b082         	sub	sp, #0x8
 800aa68: af00         	add	r7, sp, #0x0
 800aa6a: 6078         	str	r0, [r7, #0x4]
 800aa6c: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800aa6e: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800aa84 <dma_stm32_clear_tc+0x20>
 800aa70: 683b         	ldr	r3, [r7]
 800aa72: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800aa76: 6878         	ldr	r0, [r7, #0x4]
 800aa78: 4798         	blx	r3
; }
 800aa7a: bf00         	nop
 800aa7c: 3708         	adds	r7, #0x8
 800aa7e: 46bd         	mov	sp, r7
 800aa80: bd80         	pop	{r7, pc}
 800aa82: bf00         	nop

0800aa84 <$d>:
 800aa84: 60 aa 02 08  	.word	0x0802aa60

0800aa88 <dma_stm32_is_ht_active>:
; {
 800aa88: b580         	push	{r7, lr}
 800aa8a: b082         	sub	sp, #0x8
 800aa8c: af00         	add	r7, sp, #0x0
 800aa8e: 6078         	str	r0, [r7, #0x4]
 800aa90: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800aa92: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800aab4 <dma_stm32_is_ht_active+0x2c>
 800aa94: 683b         	ldr	r3, [r7]
 800aa96: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800aa9a: 6878         	ldr	r0, [r7, #0x4]
 800aa9c: 4798         	blx	r3
 800aa9e: 4603         	mov	r3, r0
 800aaa0: 2b00         	cmp	r3, #0x0
 800aaa2: bf14         	ite	ne
 800aaa4: 2301         	movne	r3, #0x1
 800aaa6: 2300         	moveq	r3, #0x0
 800aaa8: b2db         	uxtb	r3, r3
; }
 800aaaa: 4618         	mov	r0, r3
 800aaac: 3708         	adds	r7, #0x8
 800aaae: 46bd         	mov	sp, r7
 800aab0: bd80         	pop	{r7, pc}
 800aab2: bf00         	nop

0800aab4 <$d>:
 800aab4: 80 aa 02 08  	.word	0x0802aa80

0800aab8 <dma_stm32_is_tc_active>:
; {
 800aab8: b580         	push	{r7, lr}
 800aaba: b082         	sub	sp, #0x8
 800aabc: af00         	add	r7, sp, #0x0
 800aabe: 6078         	str	r0, [r7, #0x4]
 800aac0: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800aac2: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800aae4 <dma_stm32_is_tc_active+0x2c>
 800aac4: 683b         	ldr	r3, [r7]
 800aac6: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800aaca: 6878         	ldr	r0, [r7, #0x4]
 800aacc: 4798         	blx	r3
 800aace: 4603         	mov	r3, r0
 800aad0: 2b00         	cmp	r3, #0x0
 800aad2: bf14         	ite	ne
 800aad4: 2301         	movne	r3, #0x1
 800aad6: 2300         	moveq	r3, #0x0
 800aad8: b2db         	uxtb	r3, r3
; }
 800aada: 4618         	mov	r0, r3
 800aadc: 3708         	adds	r7, #0x8
 800aade: 46bd         	mov	sp, r7
 800aae0: bd80         	pop	{r7, pc}
 800aae2: bf00         	nop

0800aae4 <$d>:
 800aae4: a0 aa 02 08  	.word	0x0802aaa0

0800aae8 <dma_stm32_clear_te>:
; {
 800aae8: b580         	push	{r7, lr}
 800aaea: b082         	sub	sp, #0x8
 800aaec: af00         	add	r7, sp, #0x0
 800aaee: 6078         	str	r0, [r7, #0x4]
 800aaf0: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800aaf2: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800ab08 <dma_stm32_clear_te+0x20>
 800aaf4: 683b         	ldr	r3, [r7]
 800aaf6: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800aafa: 6878         	ldr	r0, [r7, #0x4]
 800aafc: 4798         	blx	r3
; }
 800aafe: bf00         	nop
 800ab00: 3708         	adds	r7, #0x8
 800ab02: 46bd         	mov	sp, r7
 800ab04: bd80         	pop	{r7, pc}
 800ab06: bf00         	nop

0800ab08 <$d>:
 800ab08: c0 aa 02 08  	.word	0x0802aac0

0800ab0c <dma_stm32_clear_dme>:
; {
 800ab0c: b580         	push	{r7, lr}
 800ab0e: b082         	sub	sp, #0x8
 800ab10: af00         	add	r7, sp, #0x0
 800ab12: 6078         	str	r0, [r7, #0x4]
 800ab14: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800ab16: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800ab2c <dma_stm32_clear_dme+0x20>
 800ab18: 683b         	ldr	r3, [r7]
 800ab1a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800ab1e: 6878         	ldr	r0, [r7, #0x4]
 800ab20: 4798         	blx	r3
; }
 800ab22: bf00         	nop
 800ab24: 3708         	adds	r7, #0x8
 800ab26: 46bd         	mov	sp, r7
 800ab28: bd80         	pop	{r7, pc}
 800ab2a: bf00         	nop

0800ab2c <$d>:
 800ab2c: e0 aa 02 08  	.word	0x0802aae0

0800ab30 <dma_stm32_clear_fe>:
; {
 800ab30: b580         	push	{r7, lr}
 800ab32: b082         	sub	sp, #0x8
 800ab34: af00         	add	r7, sp, #0x0
 800ab36: 6078         	str	r0, [r7, #0x4]
 800ab38: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800ab3a: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800ab50 <dma_stm32_clear_fe+0x20>
 800ab3c: 683b         	ldr	r3, [r7]
 800ab3e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800ab42: 6878         	ldr	r0, [r7, #0x4]
 800ab44: 4798         	blx	r3
; }
 800ab46: bf00         	nop
 800ab48: 3708         	adds	r7, #0x8
 800ab4a: 46bd         	mov	sp, r7
 800ab4c: bd80         	pop	{r7, pc}
 800ab4e: bf00         	nop

0800ab50 <$d>:
 800ab50: 00 ab 02 08  	.word	0x0802ab00

0800ab54 <dma_stm32_is_te_active>:
; {
 800ab54: b580         	push	{r7, lr}
 800ab56: b082         	sub	sp, #0x8
 800ab58: af00         	add	r7, sp, #0x0
 800ab5a: 6078         	str	r0, [r7, #0x4]
 800ab5c: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800ab5e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800ab80 <dma_stm32_is_te_active+0x2c>
 800ab60: 683b         	ldr	r3, [r7]
 800ab62: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800ab66: 6878         	ldr	r0, [r7, #0x4]
 800ab68: 4798         	blx	r3
 800ab6a: 4603         	mov	r3, r0
 800ab6c: 2b00         	cmp	r3, #0x0
 800ab6e: bf14         	ite	ne
 800ab70: 2301         	movne	r3, #0x1
 800ab72: 2300         	moveq	r3, #0x0
 800ab74: b2db         	uxtb	r3, r3
; }
 800ab76: 4618         	mov	r0, r3
 800ab78: 3708         	adds	r7, #0x8
 800ab7a: 46bd         	mov	sp, r7
 800ab7c: bd80         	pop	{r7, pc}
 800ab7e: bf00         	nop

0800ab80 <$d>:
 800ab80: 20 ab 02 08  	.word	0x0802ab20

0800ab84 <dma_stm32_is_dme_active>:
; {
 800ab84: b580         	push	{r7, lr}
 800ab86: b082         	sub	sp, #0x8
 800ab88: af00         	add	r7, sp, #0x0
 800ab8a: 6078         	str	r0, [r7, #0x4]
 800ab8c: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800ab8e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800abb0 <dma_stm32_is_dme_active+0x2c>
 800ab90: 683b         	ldr	r3, [r7]
 800ab92: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800ab96: 6878         	ldr	r0, [r7, #0x4]
 800ab98: 4798         	blx	r3
 800ab9a: 4603         	mov	r3, r0
 800ab9c: 2b00         	cmp	r3, #0x0
 800ab9e: bf14         	ite	ne
 800aba0: 2301         	movne	r3, #0x1
 800aba2: 2300         	moveq	r3, #0x0
 800aba4: b2db         	uxtb	r3, r3
; }
 800aba6: 4618         	mov	r0, r3
 800aba8: 3708         	adds	r7, #0x8
 800abaa: 46bd         	mov	sp, r7
 800abac: bd80         	pop	{r7, pc}
 800abae: bf00         	nop

0800abb0 <$d>:
 800abb0: 40 ab 02 08  	.word	0x0802ab40

0800abb4 <dma_stm32_is_fe_active>:
; {
 800abb4: b580         	push	{r7, lr}
 800abb6: b082         	sub	sp, #0x8
 800abb8: af00         	add	r7, sp, #0x0
 800abba: 6078         	str	r0, [r7, #0x4]
 800abbc: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800abbe: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800abe0 <dma_stm32_is_fe_active+0x2c>
 800abc0: 683b         	ldr	r3, [r7]
 800abc2: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800abc6: 6878         	ldr	r0, [r7, #0x4]
 800abc8: 4798         	blx	r3
 800abca: 4603         	mov	r3, r0
 800abcc: 2b00         	cmp	r3, #0x0
 800abce: bf14         	ite	ne
 800abd0: 2301         	movne	r3, #0x1
 800abd2: 2300         	moveq	r3, #0x0
 800abd4: b2db         	uxtb	r3, r3
; }
 800abd6: 4618         	mov	r0, r3
 800abd8: 3708         	adds	r7, #0x8
 800abda: 46bd         	mov	sp, r7
 800abdc: bd80         	pop	{r7, pc}
 800abde: bf00         	nop

0800abe0 <$d>:
 800abe0: 60 ab 02 08  	.word	0x0802ab60

0800abe4 <stm32_dma_dump_stream_irq>:
; {
 800abe4: b5f0         	push	{r4, r5, r6, r7, lr}
 800abe6: b08f         	sub	sp, #0x3c
 800abe8: af08         	add	r7, sp, #0x20
 800abea: 60f8         	str	r0, [r7, #0xc]
 800abec: 60b9         	str	r1, [r7, #0x8]
; 	LOG_INF("tc: %d, ht: %d, te: %d, dme: %d, fe: %d",
 800abee: 2303         	movs	r3, #0x3
 800abf0: 2b02         	cmp	r3, #0x2
 800abf2: d93c         	bls	0x800ac6e <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x78
 800abf4: 2301         	movs	r3, #0x1
 800abf6: 74fb         	strb	r3, [r7, #0x13]
 800abf8: 7cfb         	ldrb	r3, [r7, #0x13]
 800abfa: f083 0301    	eor	r3, r3, #0x1
 800abfe: b2db         	uxtb	r3, r3
 800ac00: 2b00         	cmp	r3, #0x0
 800ac02: d134         	bne	0x800ac6e <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x68
 800ac04: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800ac78 <stm32_dma_dump_stream_irq+0x94>
 800ac06: 681c         	ldr	r4, [r3]
 800ac08: 68b9         	ldr	r1, [r7, #0x8]
 800ac0a: 68f8         	ldr	r0, [r7, #0xc]
 800ac0c: f7ff ff54    	bl	0x800aab8 <dma_stm32_is_tc_active> @ imm = #-0x158
 800ac10: 4603         	mov	r3, r0
 800ac12: 461d         	mov	r5, r3
 800ac14: 68b9         	ldr	r1, [r7, #0x8]
 800ac16: 68f8         	ldr	r0, [r7, #0xc]
 800ac18: f7ff ff36    	bl	0x800aa88 <dma_stm32_is_ht_active> @ imm = #-0x194
 800ac1c: 4603         	mov	r3, r0
 800ac1e: 461e         	mov	r6, r3
 800ac20: 68b9         	ldr	r1, [r7, #0x8]
 800ac22: 68f8         	ldr	r0, [r7, #0xc]
 800ac24: f7ff ff96    	bl	0x800ab54 <dma_stm32_is_te_active> @ imm = #-0xd4
 800ac28: 4603         	mov	r3, r0
 800ac2a: 607b         	str	r3, [r7, #0x4]
 800ac2c: 68b9         	ldr	r1, [r7, #0x8]
 800ac2e: 68f8         	ldr	r0, [r7, #0xc]
 800ac30: f7ff ffa8    	bl	0x800ab84 <dma_stm32_is_dme_active> @ imm = #-0xb0
 800ac34: 4603         	mov	r3, r0
 800ac36: 603b         	str	r3, [r7]
 800ac38: 68b9         	ldr	r1, [r7, #0x8]
 800ac3a: 68f8         	ldr	r0, [r7, #0xc]
 800ac3c: f7ff ffba    	bl	0x800abb4 <dma_stm32_is_fe_active> @ imm = #-0x8c
 800ac40: 4603         	mov	r3, r0
 800ac42: 9307         	str	r3, [sp, #0x1c]
 800ac44: 683a         	ldr	r2, [r7]
 800ac46: 9206         	str	r2, [sp, #0x18]
 800ac48: 687b         	ldr	r3, [r7, #0x4]
 800ac4a: 9305         	str	r3, [sp, #0x14]
 800ac4c: 9604         	str	r6, [sp, #0x10]
 800ac4e: 9503         	str	r5, [sp, #0xc]
 800ac50: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800ac7c <stm32_dma_dump_stream_irq+0x98>
 800ac52: 9302         	str	r3, [sp, #0x8]
 800ac54: 2300         	movs	r3, #0x0
 800ac56: 9301         	str	r3, [sp, #0x4]
 800ac58: 2300         	movs	r3, #0x0
 800ac5a: 9300         	str	r3, [sp]
 800ac5c: 2300         	movs	r3, #0x0
 800ac5e: 2203         	movs	r2, #0x3
 800ac60: 4621         	mov	r1, r4
 800ac62: 2000         	movs	r0, #0x0
 800ac64: f014 f93b    	bl	0x801eede <z_log_msg_runtime_create> @ imm = #0x14276
 800ac68: 2300         	movs	r3, #0x0
 800ac6a: 617b         	str	r3, [r7, #0x14]
; }
 800ac6c: bf00         	nop
 800ac6e: bf00         	nop
 800ac70: 371c         	adds	r7, #0x1c
 800ac72: 46bd         	mov	sp, r7
 800ac74: bdf0         	pop	{r4, r5, r6, r7, pc}
 800ac76: bf00         	nop

0800ac78 <$d>:
 800ac78: 3c 05 00 20  	.word	0x2000053c
 800ac7c: f0 92 02 08  	.word	0x080292f0

0800ac80 <stm32_dma_is_unexpected_irq_happened>:
; {
 800ac80: b580         	push	{r7, lr}
 800ac82: b088         	sub	sp, #0x20
 800ac84: af04         	add	r7, sp, #0x10
 800ac86: 6078         	str	r0, [r7, #0x4]
 800ac88: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 800ac8a: 6838         	ldr	r0, [r7]
 800ac8c: f7ff feb8    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x290
 800ac90: 4603         	mov	r3, r0
 800ac92: 4619         	mov	r1, r3
 800ac94: 6878         	ldr	r0, [r7, #0x4]
 800ac96: f7ff fe97    	bl	0x800a9c8 <LL_DMA_IsEnabledIT_FE> @ imm = #-0x2d2
 800ac9a: 4603         	mov	r3, r0
 800ac9c: 2b00         	cmp	r3, #0x0
 800ac9e: d02a         	beq	0x800acf6 <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x54
; 	    dma_stm32_is_fe_active(dma, id)) {
 800aca0: 6839         	ldr	r1, [r7]
 800aca2: 6878         	ldr	r0, [r7, #0x4]
 800aca4: f7ff ff86    	bl	0x800abb4 <dma_stm32_is_fe_active> @ imm = #-0xf4
 800aca8: 4603         	mov	r3, r0
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 800acaa: 2b00         	cmp	r3, #0x0
 800acac: d023         	beq	0x800acf6 <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x46
; 		LOG_ERR("FiFo error.");
 800acae: 2303         	movs	r3, #0x3
 800acb0: 2b00         	cmp	r3, #0x0
 800acb2: d016         	beq	0x800ace2 <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x2c
 800acb4: 2301         	movs	r3, #0x1
 800acb6: 73fb         	strb	r3, [r7, #0xf]
 800acb8: 7bfb         	ldrb	r3, [r7, #0xf]
 800acba: f083 0301    	eor	r3, r3, #0x1
 800acbe: b2db         	uxtb	r3, r3
 800acc0: 2b00         	cmp	r3, #0x0
 800acc2: d10e         	bne	0x800ace2 <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x1c
 800acc4: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800ad00 <stm32_dma_is_unexpected_irq_happened+0x80>
 800acc6: 6819         	ldr	r1, [r3]
 800acc8: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800ad04 <stm32_dma_is_unexpected_irq_happened+0x84>
 800acca: 9302         	str	r3, [sp, #0x8]
 800accc: 2300         	movs	r3, #0x0
 800acce: 9301         	str	r3, [sp, #0x4]
 800acd0: 2300         	movs	r3, #0x0
 800acd2: 9300         	str	r3, [sp]
 800acd4: 2300         	movs	r3, #0x0
 800acd6: 2201         	movs	r2, #0x1
 800acd8: 2000         	movs	r0, #0x0
 800acda: f014 f900    	bl	0x801eede <z_log_msg_runtime_create> @ imm = #0x14200
 800acde: 2300         	movs	r3, #0x0
 800ace0: 60bb         	str	r3, [r7, #0x8]
; 		stm32_dma_dump_stream_irq(dma, id);
 800ace2: 6839         	ldr	r1, [r7]
 800ace4: 6878         	ldr	r0, [r7, #0x4]
 800ace6: f7ff ff7d    	bl	0x800abe4 <stm32_dma_dump_stream_irq> @ imm = #-0x106
; 		stm32_dma_clear_stream_irq(dma, id);
 800acea: 6839         	ldr	r1, [r7]
 800acec: 6878         	ldr	r0, [r7, #0x4]
 800acee: f014 f956    	bl	0x801ef9e <stm32_dma_clear_stream_irq> @ imm = #0x142ac
; 		return true;
 800acf2: 2301         	movs	r3, #0x1
 800acf4: e000         	b	0x800acf8 <stm32_dma_is_unexpected_irq_happened+0x78> @ imm = #0x0
; 	return false;
 800acf6: 2300         	movs	r3, #0x0
; }
 800acf8: 4618         	mov	r0, r3
 800acfa: 3710         	adds	r7, #0x10
 800acfc: 46bd         	mov	sp, r7
 800acfe: bd80         	pop	{r7, pc}

0800ad00 <$d>:
 800ad00: 3c 05 00 20  	.word	0x2000053c
 800ad04: 18 93 02 08  	.word	0x08029318

0800ad08 <stm32_dma_get_mburst>:
; {
 800ad08: b580         	push	{r7, lr}
 800ad0a: b08a         	sub	sp, #0x28
 800ad0c: af04         	add	r7, sp, #0x10
 800ad0e: 6078         	str	r0, [r7, #0x4]
 800ad10: 460b         	mov	r3, r1
 800ad12: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 800ad14: 78fb         	ldrb	r3, [r7, #0x3]
 800ad16: 2b00         	cmp	r3, #0x0
 800ad18: d003         	beq	0x800ad22 <stm32_dma_get_mburst+0x1a> @ imm = #0x6
; 		memory_burst = config->dest_burst_length;
 800ad1a: 687b         	ldr	r3, [r7, #0x4]
 800ad1c: 895b         	ldrh	r3, [r3, #0xa]
 800ad1e: 617b         	str	r3, [r7, #0x14]
 800ad20: e002         	b	0x800ad28 <stm32_dma_get_mburst+0x20> @ imm = #0x4
; 		memory_burst = config->source_burst_length;
 800ad22: 687b         	ldr	r3, [r7, #0x4]
 800ad24: 891b         	ldrh	r3, [r3, #0x8]
 800ad26: 617b         	str	r3, [r7, #0x14]
; 	switch (memory_burst) {
 800ad28: 697b         	ldr	r3, [r7, #0x14]
 800ad2a: 3b01         	subs	r3, #0x1
 800ad2c: 2b0f         	cmp	r3, #0xf
 800ad2e: d82e         	bhi	0x800ad8e <stm32_dma_get_mburst+0x86> @ imm = #0x5c
 800ad30: a201         	adr	r2, #4 <stm32_dma_get_mburst+0x2d>
 800ad32: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800ad36: bf00         	nop

0800ad38 <$d>:
 800ad38: 79 ad 00 08  	.word	0x0800ad79
 800ad3c: 8f ad 00 08  	.word	0x0800ad8f
 800ad40: 8f ad 00 08  	.word	0x0800ad8f
 800ad44: 7d ad 00 08  	.word	0x0800ad7d
 800ad48: 8f ad 00 08  	.word	0x0800ad8f
 800ad4c: 8f ad 00 08  	.word	0x0800ad8f
 800ad50: 8f ad 00 08  	.word	0x0800ad8f
 800ad54: 83 ad 00 08  	.word	0x0800ad83
 800ad58: 8f ad 00 08  	.word	0x0800ad8f
 800ad5c: 8f ad 00 08  	.word	0x0800ad8f
 800ad60: 8f ad 00 08  	.word	0x0800ad8f
 800ad64: 8f ad 00 08  	.word	0x0800ad8f
 800ad68: 8f ad 00 08  	.word	0x0800ad8f
 800ad6c: 8f ad 00 08  	.word	0x0800ad8f
 800ad70: 8f ad 00 08  	.word	0x0800ad8f
 800ad74: 89 ad 00 08  	.word	0x0800ad89

0800ad78 <$t>:
; 		return LL_DMA_MBURST_SINGLE;
 800ad78: 2300         	movs	r3, #0x0
 800ad7a: e023         	b	0x800adc4 <stm32_dma_get_mburst+0xbc> @ imm = #0x46
; 		return LL_DMA_MBURST_INC4;
 800ad7c: f44f 0300    	mov.w	r3, #0x800000
 800ad80: e020         	b	0x800adc4 <stm32_dma_get_mburst+0xbc> @ imm = #0x40
; 		return LL_DMA_MBURST_INC8;
 800ad82: f04f 7380    	mov.w	r3, #0x1000000
 800ad86: e01d         	b	0x800adc4 <stm32_dma_get_mburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_MBURST_INC16;
 800ad88: f04f 73c0    	mov.w	r3, #0x1800000
 800ad8c: e01a         	b	0x800adc4 <stm32_dma_get_mburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Memory burst size error,"
 800ad8e: 2303         	movs	r3, #0x3
 800ad90: 2b00         	cmp	r3, #0x0
 800ad92: d016         	beq	0x800adc2 <stm32_dma_get_mburst+0xba> @ imm = #0x2c
 800ad94: 2301         	movs	r3, #0x1
 800ad96: 74fb         	strb	r3, [r7, #0x13]
 800ad98: 7cfb         	ldrb	r3, [r7, #0x13]
 800ad9a: f083 0301    	eor	r3, r3, #0x1
 800ad9e: b2db         	uxtb	r3, r3
 800ada0: 2b00         	cmp	r3, #0x0
 800ada2: d10e         	bne	0x800adc2 <stm32_dma_get_mburst+0xba> @ imm = #0x1c
 800ada4: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800adcc <stm32_dma_get_mburst+0xc4>
 800ada6: 6819         	ldr	r1, [r3]
 800ada8: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800add0 <stm32_dma_get_mburst+0xc8>
 800adaa: 9302         	str	r3, [sp, #0x8]
 800adac: 2300         	movs	r3, #0x0
 800adae: 9301         	str	r3, [sp, #0x4]
 800adb0: 2300         	movs	r3, #0x0
 800adb2: 9300         	str	r3, [sp]
 800adb4: 2300         	movs	r3, #0x0
 800adb6: 2201         	movs	r2, #0x1
 800adb8: 2000         	movs	r0, #0x0
 800adba: f014 f890    	bl	0x801eede <z_log_msg_runtime_create> @ imm = #0x14120
 800adbe: 2300         	movs	r3, #0x0
 800adc0: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_MBURST_SINGLE;
 800adc2: 2300         	movs	r3, #0x0
; }
 800adc4: 4618         	mov	r0, r3
 800adc6: 3718         	adds	r7, #0x18
 800adc8: 46bd         	mov	sp, r7
 800adca: bd80         	pop	{r7, pc}

0800adcc <$d>:
 800adcc: 3c 05 00 20  	.word	0x2000053c
 800add0: 24 93 02 08  	.word	0x08029324

0800add4 <stm32_dma_get_pburst>:
; {
 800add4: b580         	push	{r7, lr}
 800add6: b08a         	sub	sp, #0x28
 800add8: af04         	add	r7, sp, #0x10
 800adda: 6078         	str	r0, [r7, #0x4]
 800addc: 460b         	mov	r3, r1
 800adde: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 800ade0: 78fb         	ldrb	r3, [r7, #0x3]
 800ade2: 2b00         	cmp	r3, #0x0
 800ade4: d003         	beq	0x800adee <stm32_dma_get_pburst+0x1a> @ imm = #0x6
; 		periph_burst = config->source_burst_length;
 800ade6: 687b         	ldr	r3, [r7, #0x4]
 800ade8: 891b         	ldrh	r3, [r3, #0x8]
 800adea: 617b         	str	r3, [r7, #0x14]
 800adec: e002         	b	0x800adf4 <stm32_dma_get_pburst+0x20> @ imm = #0x4
; 		periph_burst = config->dest_burst_length;
 800adee: 687b         	ldr	r3, [r7, #0x4]
 800adf0: 895b         	ldrh	r3, [r3, #0xa]
 800adf2: 617b         	str	r3, [r7, #0x14]
; 	switch (periph_burst) {
 800adf4: 697b         	ldr	r3, [r7, #0x14]
 800adf6: 3b01         	subs	r3, #0x1
 800adf8: 2b0f         	cmp	r3, #0xf
 800adfa: d82e         	bhi	0x800ae5a <stm32_dma_get_pburst+0x86> @ imm = #0x5c
 800adfc: a201         	adr	r2, #4 <stm32_dma_get_pburst+0x2d>
 800adfe: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800ae02: bf00         	nop

0800ae04 <$d>:
 800ae04: 45 ae 00 08  	.word	0x0800ae45
 800ae08: 5b ae 00 08  	.word	0x0800ae5b
 800ae0c: 5b ae 00 08  	.word	0x0800ae5b
 800ae10: 49 ae 00 08  	.word	0x0800ae49
 800ae14: 5b ae 00 08  	.word	0x0800ae5b
 800ae18: 5b ae 00 08  	.word	0x0800ae5b
 800ae1c: 5b ae 00 08  	.word	0x0800ae5b
 800ae20: 4f ae 00 08  	.word	0x0800ae4f
 800ae24: 5b ae 00 08  	.word	0x0800ae5b
 800ae28: 5b ae 00 08  	.word	0x0800ae5b
 800ae2c: 5b ae 00 08  	.word	0x0800ae5b
 800ae30: 5b ae 00 08  	.word	0x0800ae5b
 800ae34: 5b ae 00 08  	.word	0x0800ae5b
 800ae38: 5b ae 00 08  	.word	0x0800ae5b
 800ae3c: 5b ae 00 08  	.word	0x0800ae5b
 800ae40: 55 ae 00 08  	.word	0x0800ae55

0800ae44 <$t>:
; 		return LL_DMA_PBURST_SINGLE;
 800ae44: 2300         	movs	r3, #0x0
 800ae46: e023         	b	0x800ae90 <stm32_dma_get_pburst+0xbc> @ imm = #0x46
; 		return LL_DMA_PBURST_INC4;
 800ae48: f44f 1300    	mov.w	r3, #0x200000
 800ae4c: e020         	b	0x800ae90 <stm32_dma_get_pburst+0xbc> @ imm = #0x40
; 		return LL_DMA_PBURST_INC8;
 800ae4e: f44f 0380    	mov.w	r3, #0x400000
 800ae52: e01d         	b	0x800ae90 <stm32_dma_get_pburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_PBURST_INC16;
 800ae54: f44f 03c0    	mov.w	r3, #0x600000
 800ae58: e01a         	b	0x800ae90 <stm32_dma_get_pburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Peripheral burst size error,"
 800ae5a: 2303         	movs	r3, #0x3
 800ae5c: 2b00         	cmp	r3, #0x0
 800ae5e: d016         	beq	0x800ae8e <stm32_dma_get_pburst+0xba> @ imm = #0x2c
 800ae60: 2301         	movs	r3, #0x1
 800ae62: 74fb         	strb	r3, [r7, #0x13]
 800ae64: 7cfb         	ldrb	r3, [r7, #0x13]
 800ae66: f083 0301    	eor	r3, r3, #0x1
 800ae6a: b2db         	uxtb	r3, r3
 800ae6c: 2b00         	cmp	r3, #0x0
 800ae6e: d10e         	bne	0x800ae8e <stm32_dma_get_pburst+0xba> @ imm = #0x1c
 800ae70: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800ae98 <stm32_dma_get_pburst+0xc4>
 800ae72: 6819         	ldr	r1, [r3]
 800ae74: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800ae9c <stm32_dma_get_pburst+0xc8>
 800ae76: 9302         	str	r3, [sp, #0x8]
 800ae78: 2300         	movs	r3, #0x0
 800ae7a: 9301         	str	r3, [sp, #0x4]
 800ae7c: 2300         	movs	r3, #0x0
 800ae7e: 9300         	str	r3, [sp]
 800ae80: 2300         	movs	r3, #0x0
 800ae82: 2201         	movs	r2, #0x1
 800ae84: 2000         	movs	r0, #0x0
 800ae86: f014 f82a    	bl	0x801eede <z_log_msg_runtime_create> @ imm = #0x14054
 800ae8a: 2300         	movs	r3, #0x0
 800ae8c: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_PBURST_SINGLE;
 800ae8e: 2300         	movs	r3, #0x0
; }
 800ae90: 4618         	mov	r0, r3
 800ae92: 3718         	adds	r7, #0x18
 800ae94: 46bd         	mov	sp, r7
 800ae96: bd80         	pop	{r7, pc}

0800ae98 <$d>:
 800ae98: 3c 05 00 20  	.word	0x2000053c
 800ae9c: 5c 93 02 08  	.word	0x0802935c

0800aea0 <stm32_dma_get_fifo_threshold>:
; {
 800aea0: b580         	push	{r7, lr}
 800aea2: b088         	sub	sp, #0x20
 800aea4: af04         	add	r7, sp, #0x10
 800aea6: 4603         	mov	r3, r0
 800aea8: 80fb         	strh	r3, [r7, #0x6]
; 	switch (fifo_mode_control) {
 800aeaa: 88fb         	ldrh	r3, [r7, #0x6]
 800aeac: 2b03         	cmp	r3, #0x3
 800aeae: d813         	bhi	0x800aed8 <stm32_dma_get_fifo_threshold+0x38> @ imm = #0x26
 800aeb0: a201         	adr	r2, #4 <stm32_dma_get_fifo_threshold+0x15>
 800aeb2: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800aeb6: bf00         	nop

0800aeb8 <$d>:
 800aeb8: c9 ae 00 08  	.word	0x0800aec9
 800aebc: cd ae 00 08  	.word	0x0800aecd
 800aec0: d1 ae 00 08  	.word	0x0800aed1
 800aec4: d5 ae 00 08  	.word	0x0800aed5

0800aec8 <$t>:
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 800aec8: 2300         	movs	r3, #0x0
 800aeca: e020         	b	0x800af0e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x40
; 		return LL_DMA_FIFOTHRESHOLD_1_2;
 800aecc: 2301         	movs	r3, #0x1
 800aece: e01e         	b	0x800af0e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x3c
; 		return LL_DMA_FIFOTHRESHOLD_3_4;
 800aed0: 2302         	movs	r3, #0x2
 800aed2: e01c         	b	0x800af0e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x38
; 		return LL_DMA_FIFOTHRESHOLD_FULL;
 800aed4: 2303         	movs	r3, #0x3
 800aed6: e01a         	b	0x800af0e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x34
; 		LOG_WRN("FIFO threshold parameter error, reset to 1/4");
 800aed8: 2303         	movs	r3, #0x3
 800aeda: 2b01         	cmp	r3, #0x1
 800aedc: d916         	bls	0x800af0c <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x2c
 800aede: 2301         	movs	r3, #0x1
 800aee0: 73fb         	strb	r3, [r7, #0xf]
 800aee2: 7bfb         	ldrb	r3, [r7, #0xf]
 800aee4: f083 0301    	eor	r3, r3, #0x1
 800aee8: b2db         	uxtb	r3, r3
 800aeea: 2b00         	cmp	r3, #0x0
 800aeec: d10e         	bne	0x800af0c <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x1c
 800aeee: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800af18 <stm32_dma_get_fifo_threshold+0x78>
 800aef0: 6819         	ldr	r1, [r3]
 800aef2: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800af1c <stm32_dma_get_fifo_threshold+0x7c>
 800aef4: 9302         	str	r3, [sp, #0x8]
 800aef6: 2300         	movs	r3, #0x0
 800aef8: 9301         	str	r3, [sp, #0x4]
 800aefa: 2300         	movs	r3, #0x0
 800aefc: 9300         	str	r3, [sp]
 800aefe: 2300         	movs	r3, #0x0
 800af00: 2202         	movs	r2, #0x2
 800af02: 2000         	movs	r0, #0x0
 800af04: f013 ffeb    	bl	0x801eede <z_log_msg_runtime_create> @ imm = #0x13fd6
 800af08: 2300         	movs	r3, #0x0
 800af0a: 60bb         	str	r3, [r7, #0x8]
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 800af0c: 2300         	movs	r3, #0x0
; }
 800af0e: 4618         	mov	r0, r3
 800af10: 3710         	adds	r7, #0x10
 800af12: 46bd         	mov	sp, r7
 800af14: bd80         	pop	{r7, pc}
 800af16: bf00         	nop

0800af18 <$d>:
 800af18: 3c 05 00 20  	.word	0x2000053c
 800af1c: 98 93 02 08  	.word	0x08029398

0800af20 <gpio_stm32_clock_request>:
; {
 800af20: b580         	push	{r7, lr}
 800af22: b086         	sub	sp, #0x18
 800af24: af00         	add	r7, sp, #0x0
 800af26: 6078         	str	r0, [r7, #0x4]
 800af28: 460b         	mov	r3, r1
 800af2a: 70fb         	strb	r3, [r7, #0x3]
; 	const struct gpio_stm32_config *cfg = dev->config;
 800af2c: 687b         	ldr	r3, [r7, #0x4]
 800af2e: 685b         	ldr	r3, [r3, #0x4]
 800af30: 613b         	str	r3, [r7, #0x10]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800af32: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800af64 <gpio_stm32_clock_request+0x44>
 800af34: 60fb         	str	r3, [r7, #0xc]
; 	if (on) {
 800af36: 78fb         	ldrb	r3, [r7, #0x3]
 800af38: 2b00         	cmp	r3, #0x0
 800af3a: d007         	beq	0x800af4c <gpio_stm32_clock_request+0x2c> @ imm = #0xe
; 					(clock_control_subsys_t)&cfg->pclken);
 800af3c: 693b         	ldr	r3, [r7, #0x10]
 800af3e: 330c         	adds	r3, #0xc
; 		ret = clock_control_on(clk,
 800af40: 4619         	mov	r1, r3
 800af42: 68f8         	ldr	r0, [r7, #0xc]
 800af44: f014 fb8d    	bl	0x801f662 <clock_control_on> @ imm = #0x1471a
 800af48: 6178         	str	r0, [r7, #0x14]
 800af4a: e006         	b	0x800af5a <gpio_stm32_clock_request+0x3a> @ imm = #0xc
; 					(clock_control_subsys_t)&cfg->pclken);
 800af4c: 693b         	ldr	r3, [r7, #0x10]
 800af4e: 330c         	adds	r3, #0xc
; 		ret = clock_control_off(clk,
 800af50: 4619         	mov	r1, r3
 800af52: 68f8         	ldr	r0, [r7, #0xc]
 800af54: f014 fb97    	bl	0x801f686 <clock_control_off> @ imm = #0x1472e
 800af58: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 800af5a: 697b         	ldr	r3, [r7, #0x14]
; }
 800af5c: 4618         	mov	r0, r3
 800af5e: 3718         	adds	r7, #0x18
 800af60: 46bd         	mov	sp, r7
 800af62: bd80         	pop	{r7, pc}

0800af64 <$d>:
 800af64: 48 7a 02 08  	.word	0x08027a48

0800af68 <gpio_stm32_pin_interrupt_configure>:
; {
 800af68: b580         	push	{r7, lr}
 800af6a: b08a         	sub	sp, #0x28
 800af6c: af00         	add	r7, sp, #0x0
 800af6e: 60f8         	str	r0, [r7, #0xc]
 800af70: 607a         	str	r2, [r7, #0x4]
 800af72: 603b         	str	r3, [r7]
 800af74: 460b         	mov	r3, r1
 800af76: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 800af78: 68fb         	ldr	r3, [r7, #0xc]
 800af7a: 685b         	ldr	r3, [r3, #0x4]
 800af7c: 61fb         	str	r3, [r7, #0x1c]
; 	struct gpio_stm32_data *data = dev->data;
 800af7e: 68fb         	ldr	r3, [r7, #0xc]
 800af80: 691b         	ldr	r3, [r3, #0x10]
 800af82: 61bb         	str	r3, [r7, #0x18]
; 	const stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(cfg->port, pin);
 800af84: 69fb         	ldr	r3, [r7, #0x1c]
 800af86: 689b         	ldr	r3, [r3, #0x8]
 800af88: 461a         	mov	r2, r3
 800af8a: 7afb         	ldrb	r3, [r7, #0xb]
 800af8c: 4619         	mov	r1, r3
 800af8e: 4610         	mov	r0, r2
 800af90: f011 fffd    	bl	0x801cf8e <stm32_gpio_intc_get_pin_irq_line> @ imm = #0x11ffa
 800af94: 6178         	str	r0, [r7, #0x14]
; 	uint32_t irq_trigger = 0;
 800af96: 2300         	movs	r3, #0x0
 800af98: 627b         	str	r3, [r7, #0x24]
; 	int err = 0;
 800af9a: 2300         	movs	r3, #0x0
 800af9c: 623b         	str	r3, [r7, #0x20]
; 	if (mode == GPIO_INT_MODE_DISABLED) {
 800af9e: 687b         	ldr	r3, [r7, #0x4]
 800afa0: f5b3 1f00    	cmp.w	r3, #0x200000
 800afa4: d108         	bne	0x800afb8 <gpio_stm32_pin_interrupt_configure+0x50> @ imm = #0x10
; 		gpio_stm32_disable_pin_irqs(cfg->port, pin);
 800afa6: 69fb         	ldr	r3, [r7, #0x1c]
 800afa8: 689b         	ldr	r3, [r3, #0x8]
 800afaa: 461a         	mov	r2, r3
 800afac: 7afb         	ldrb	r3, [r7, #0xb]
 800afae: 4619         	mov	r1, r3
 800afb0: 4610         	mov	r0, r2
 800afb2: f014 fcdf    	bl	0x801f974 <gpio_stm32_disable_pin_irqs> @ imm = #0x149be
; 		goto exit;
 800afb6: e040         	b	0x800b03a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x80
; 	if (mode == GPIO_INT_MODE_LEVEL) {
 800afb8: 687b         	ldr	r3, [r7, #0x4]
 800afba: f5b3 0f80    	cmp.w	r3, #0x400000
 800afbe: d103         	bne	0x800afc8 <gpio_stm32_pin_interrupt_configure+0x60> @ imm = #0x6
; 			err = -ENOTSUP;
 800afc0: f06f 0385    	mvn	r3, #0x85
 800afc4: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 800afc6: e038         	b	0x800b03a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x70
; 		switch (trig) {
 800afc8: 683b         	ldr	r3, [r7]
 800afca: f1b3 6fc0    	cmp.w	r3, #0x6000000
 800afce: d012         	beq	0x800aff6 <gpio_stm32_pin_interrupt_configure+0x8e> @ imm = #0x24
 800afd0: 683b         	ldr	r3, [r7]
 800afd2: f1b3 6fc0    	cmp.w	r3, #0x6000000
 800afd6: d811         	bhi	0x800affc <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x22
 800afd8: 683b         	ldr	r3, [r7]
 800afda: f1b3 7f00    	cmp.w	r3, #0x2000000
 800afde: d004         	beq	0x800afea <gpio_stm32_pin_interrupt_configure+0x82> @ imm = #0x8
 800afe0: 683b         	ldr	r3, [r7]
 800afe2: f1b3 6f80    	cmp.w	r3, #0x4000000
 800afe6: d003         	beq	0x800aff0 <gpio_stm32_pin_interrupt_configure+0x88> @ imm = #0x6
 800afe8: e008         	b	0x800affc <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x10
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_FALLING;
 800afea: 2302         	movs	r3, #0x2
 800afec: 627b         	str	r3, [r7, #0x24]
; 			break;
 800afee: e009         	b	0x800b004 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x12
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_RISING;
 800aff0: 2301         	movs	r3, #0x1
 800aff2: 627b         	str	r3, [r7, #0x24]
; 			break;
 800aff4: e006         	b	0x800b004 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0xc
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_BOTH;
 800aff6: 2303         	movs	r3, #0x3
 800aff8: 627b         	str	r3, [r7, #0x24]
; 			break;
 800affa: e003         	b	0x800b004 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x6
; 			err = -EINVAL;
 800affc: f06f 0315    	mvn	r3, #0x15
 800b000: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 800b002: e01a         	b	0x800b03a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x34
; 	if (stm32_gpio_intc_set_irq_callback(irq_line, gpio_stm32_isr, data) != 0) {
 800b004: 69ba         	ldr	r2, [r7, #0x18]
 800b006: 490f         	ldr	r1, [pc, #0x3c]         @ 0x800b044 <gpio_stm32_pin_interrupt_configure+0xdc>
 800b008: 6978         	ldr	r0, [r7, #0x14]
 800b00a: f7fc fad7    	bl	0x80075bc <stm32_gpio_intc_set_irq_callback> @ imm = #-0x3a52
 800b00e: 4603         	mov	r3, r0
 800b010: 2b00         	cmp	r3, #0x0
 800b012: d003         	beq	0x800b01c <gpio_stm32_pin_interrupt_configure+0xb4> @ imm = #0x6
; 		err = -EBUSY;
 800b014: f06f 030f    	mvn	r3, #0xf
 800b018: 623b         	str	r3, [r7, #0x20]
; 		goto exit;
 800b01a: e00e         	b	0x800b03a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x1c
; 	stm32_exti_set_line_src_port(pin, cfg->port);
 800b01c: 69fb         	ldr	r3, [r7, #0x1c]
 800b01e: 689b         	ldr	r3, [r3, #0x8]
 800b020: 461a         	mov	r2, r3
 800b022: 7afb         	ldrb	r3, [r7, #0xb]
 800b024: 4611         	mov	r1, r2
 800b026: 4618         	mov	r0, r3
 800b028: f011 ffcb    	bl	0x801cfc2 <stm32_exti_set_line_src_port> @ imm = #0x11f96
; 	stm32_gpio_intc_select_line_trigger(irq_line, irq_trigger);
 800b02c: 6a79         	ldr	r1, [r7, #0x24]
 800b02e: 6978         	ldr	r0, [r7, #0x14]
 800b030: f7fc fa88    	bl	0x8007544 <stm32_gpio_intc_select_line_trigger> @ imm = #-0x3af0
; 	stm32_gpio_intc_enable_line(irq_line);
 800b034: 6978         	ldr	r0, [r7, #0x14]
 800b036: f7fc fa69    	bl	0x800750c <stm32_gpio_intc_enable_line> @ imm = #-0x3b2e
; 	return err;
 800b03a: 6a3b         	ldr	r3, [r7, #0x20]
; }
 800b03c: 4618         	mov	r0, r3
 800b03e: 3728         	adds	r7, #0x28
 800b040: 46bd         	mov	sp, r7
 800b042: bd80         	pop	{r7, pc}

0800b044 <$d>:
 800b044: 35 f8 01 08  	.word	0x0801f835

0800b048 <gpio_stm32_init>:
; {
 800b048: b580         	push	{r7, lr}
 800b04a: b084         	sub	sp, #0x10
 800b04c: af00         	add	r7, sp, #0x0
 800b04e: 6078         	str	r0, [r7, #0x4]
; 	struct gpio_stm32_data *data = dev->data;
 800b050: 687b         	ldr	r3, [r7, #0x4]
 800b052: 691b         	ldr	r3, [r3, #0x10]
 800b054: 60fb         	str	r3, [r7, #0xc]
; 	data->dev = dev;
 800b056: 68fb         	ldr	r3, [r7, #0xc]
 800b058: 687a         	ldr	r2, [r7, #0x4]
 800b05a: 605a         	str	r2, [r3, #0x4]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 800b05c: 480e         	ldr	r0, [pc, #0x38]         @ 0x800b098 <gpio_stm32_init+0x50>
 800b05e: f014 f974    	bl	0x801f34a <device_is_ready> @ imm = #0x142e8
 800b062: 4603         	mov	r3, r0
 800b064: f083 0301    	eor	r3, r3, #0x1
 800b068: b2db         	uxtb	r3, r3
 800b06a: 2b00         	cmp	r3, #0x0
 800b06c: d002         	beq	0x800b074 <gpio_stm32_init+0x2c> @ imm = #0x4
; 		return -ENODEV;
 800b06e: f06f 0312    	mvn	r3, #0x12
 800b072: e00d         	b	0x800b090 <gpio_stm32_init+0x48> @ imm = #0x1a
; 	ret = gpio_stm32_clock_request(dev, !IS_ENABLED(CONFIG_PM_DEVICE_RUNTIME));
 800b074: 2101         	movs	r1, #0x1
 800b076: 6878         	ldr	r0, [r7, #0x4]
 800b078: f7ff ff52    	bl	0x800af20 <gpio_stm32_clock_request> @ imm = #-0x15c
 800b07c: 60b8         	str	r0, [r7, #0x8]
; 	if (ret < 0) {
 800b07e: 68bb         	ldr	r3, [r7, #0x8]
 800b080: 2b00         	cmp	r3, #0x0
 800b082: da01         	bge	0x800b088 <gpio_stm32_init+0x40> @ imm = #0x2
; 		return ret;
 800b084: 68bb         	ldr	r3, [r7, #0x8]
 800b086: e003         	b	0x800b090 <gpio_stm32_init+0x48> @ imm = #0x6
; 	(void)pm_device_runtime_enable(dev);
 800b088: 6878         	ldr	r0, [r7, #0x4]
 800b08a: f014 fb0e    	bl	0x801f6aa <pm_device_runtime_enable> @ imm = #0x1461c
; 	return 0;
 800b08e: 2300         	movs	r3, #0x0
; }
 800b090: 4618         	mov	r0, r3
 800b092: 3710         	adds	r7, #0x10
 800b094: 46bd         	mov	sp, r7
 800b096: bd80         	pop	{r7, pc}

0800b098 <$d>:
 800b098: 48 7a 02 08  	.word	0x08027a48

0800b09c <stm32_pin_configure>:
; {
 800b09c: b580         	push	{r7, lr}
 800b09e: b086         	sub	sp, #0x18
 800b0a0: af00         	add	r7, sp, #0x0
 800b0a2: 60f8         	str	r0, [r7, #0xc]
 800b0a4: 60b9         	str	r1, [r7, #0x8]
 800b0a6: 607a         	str	r2, [r7, #0x4]
; 	if (STM32_PORT(pin) >= gpio_ports_cnt) {
 800b0a8: 68fb         	ldr	r3, [r7, #0xc]
 800b0aa: 091b         	lsrs	r3, r3, #0x4
 800b0ac: 2210         	movs	r2, #0x10
 800b0ae: 4293         	cmp	r3, r2
 800b0b0: d302         	blo	0x800b0b8 <stm32_pin_configure+0x1c> @ imm = #0x4
; 		return -EINVAL;
 800b0b2: f06f 0315    	mvn	r3, #0x15
 800b0b6: e01f         	b	0x800b0f8 <stm32_pin_configure+0x5c> @ imm = #0x3e
; 	port_device = gpio_ports[STM32_PORT(pin)];
 800b0b8: 68fb         	ldr	r3, [r7, #0xc]
 800b0ba: 091b         	lsrs	r3, r3, #0x4
 800b0bc: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800b100 <stm32_pin_configure+0x64>
 800b0be: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800b0c2: 617b         	str	r3, [r7, #0x14]
; 	if ((port_device == NULL) || (!device_is_ready(port_device))) {
 800b0c4: 697b         	ldr	r3, [r7, #0x14]
 800b0c6: 2b00         	cmp	r3, #0x0
 800b0c8: d008         	beq	0x800b0dc <stm32_pin_configure+0x40> @ imm = #0x10
 800b0ca: 6978         	ldr	r0, [r7, #0x14]
 800b0cc: f014 fe63    	bl	0x801fd96 <device_is_ready> @ imm = #0x14cc6
 800b0d0: 4603         	mov	r3, r0
 800b0d2: f083 0301    	eor	r3, r3, #0x1
 800b0d6: b2db         	uxtb	r3, r3
 800b0d8: 2b00         	cmp	r3, #0x0
 800b0da: d002         	beq	0x800b0e2 <stm32_pin_configure+0x46> @ imm = #0x4
; 		return -ENODEV;
 800b0dc: f06f 0312    	mvn	r3, #0x12
 800b0e0: e00a         	b	0x800b0f8 <stm32_pin_configure+0x5c> @ imm = #0x14
; 	return gpio_stm32_configure(port_device, STM32_PIN(pin), pin_cgf, pin_func);
 800b0e2: 68fb         	ldr	r3, [r7, #0xc]
 800b0e4: b2db         	uxtb	r3, r3
 800b0e6: f003 030f    	and	r3, r3, #0xf
 800b0ea: b2d9         	uxtb	r1, r3
 800b0ec: 687b         	ldr	r3, [r7, #0x4]
 800b0ee: 68ba         	ldr	r2, [r7, #0x8]
 800b0f0: 6978         	ldr	r0, [r7, #0x14]
 800b0f2: f014 fd44    	bl	0x801fb7e <gpio_stm32_configure> @ imm = #0x14a88
 800b0f6: 4603         	mov	r3, r0
; }
 800b0f8: 4618         	mov	r0, r3
 800b0fa: 3718         	adds	r7, #0x18
 800b0fc: 46bd         	mov	sp, r7
 800b0fe: bd80         	pop	{r7, pc}

0800b100 <$d>:
 800b100: 34 ac 02 08  	.word	0x0802ac34

0800b104 <bmi08x_bus_init_spi>:
; {
 800b104: b580         	push	{r7, lr}
 800b106: b08a         	sub	sp, #0x28
 800b108: af04         	add	r7, sp, #0x10
 800b10a: 6078         	str	r0, [r7, #0x4]
; 	ret = bmi08x_accel_byte_read(dev, 0x7F, &val);
 800b10c: f107 030b    	add.w	r3, r7, #0xb
 800b110: 461a         	mov	r2, r3
 800b112: 217f         	movs	r1, #0x7f
 800b114: 6878         	ldr	r0, [r7, #0x4]
 800b116: f015 f930    	bl	0x802037a <bmi08x_accel_byte_read> @ imm = #0x15260
 800b11a: 6178         	str	r0, [r7, #0x14]
; 	if (ret < 0) {
 800b11c: 697b         	ldr	r3, [r7, #0x14]
 800b11e: 2b00         	cmp	r3, #0x0
 800b120: da1b         	bge	0x800b15a <bmi08x_bus_init_spi+0x56> @ imm = #0x36
; 		LOG_ERR("Cannot read from 0x7F..");
 800b122: 2303         	movs	r3, #0x3
 800b124: 2b00         	cmp	r3, #0x0
 800b126: d016         	beq	0x800b156 <bmi08x_bus_init_spi+0x52> @ imm = #0x2c
 800b128: 2301         	movs	r3, #0x1
 800b12a: 74fb         	strb	r3, [r7, #0x13]
 800b12c: 7cfb         	ldrb	r3, [r7, #0x13]
 800b12e: f083 0301    	eor	r3, r3, #0x1
 800b132: b2db         	uxtb	r3, r3
 800b134: 2b00         	cmp	r3, #0x0
 800b136: d10e         	bne	0x800b156 <bmi08x_bus_init_spi+0x52> @ imm = #0x1c
 800b138: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b16c <bmi08x_bus_init_spi+0x68>
 800b13a: 6819         	ldr	r1, [r3]
 800b13c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b170 <bmi08x_bus_init_spi+0x6c>
 800b13e: 9302         	str	r3, [sp, #0x8]
 800b140: 2300         	movs	r3, #0x0
 800b142: 9301         	str	r3, [sp, #0x4]
 800b144: 2300         	movs	r3, #0x0
 800b146: 9300         	str	r3, [sp]
 800b148: 2300         	movs	r3, #0x0
 800b14a: 2201         	movs	r2, #0x1
 800b14c: 2000         	movs	r0, #0x0
 800b14e: f014 ff86    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x14f0c
 800b152: 2300         	movs	r3, #0x0
 800b154: 60fb         	str	r3, [r7, #0xc]
; 		return ret;
 800b156: 697b         	ldr	r3, [r7, #0x14]
 800b158: e003         	b	0x800b162 <bmi08x_bus_init_spi+0x5e> @ imm = #0x6
; 	k_usleep(100);
 800b15a: 2064         	movs	r0, #0x64
 800b15c: f014 ff5f    	bl	0x802001e <k_usleep>    @ imm = #0x14ebe
; 	return ret;
 800b160: 697b         	ldr	r3, [r7, #0x14]
; }
 800b162: 4618         	mov	r0, r3
 800b164: 3718         	adds	r7, #0x18
 800b166: 46bd         	mov	sp, r7
 800b168: bd80         	pop	{r7, pc}
 800b16a: bf00         	nop

0800b16c <$d>:
 800b16c: 40 05 00 20  	.word	0x20000540
 800b170: 84 94 02 08  	.word	0x08029484

0800b174 <bmi08x_acc_range_set>:
; {
 800b174: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800b178: b086         	sub	sp, #0x18
 800b17a: af00         	add	r7, sp, #0x0
 800b17c: 6078         	str	r0, [r7, #0x4]
 800b17e: 6039         	str	r1, [r7]
; 	struct bmi08x_accel_data *data = dev->data;
 800b180: 687b         	ldr	r3, [r7, #0x4]
 800b182: 691b         	ldr	r3, [r3, #0x10]
 800b184: 613b         	str	r3, [r7, #0x10]
; 	int32_t reg_val = -1;
 800b186: f04f 33ff    	mov.w	r3, #0xffffffff
 800b18a: 617b         	str	r3, [r7, #0x14]
; 	if (data->accel_chip_id == BMI085_ACCEL_CHIP_ID) {
 800b18c: 693b         	ldr	r3, [r7, #0x10]
 800b18e: f893 3948    	ldrb.w	r3, [r3, #0x948]
 800b192: 2b1f         	cmp	r3, #0x1f
 800b194: d108         	bne	0x800b1a8 <bmi08x_acc_range_set+0x34> @ imm = #0x10
; 		reg_val = bmi08x_range_to_reg_val(range, bmi085_acc_range_map,
 800b196: 683b         	ldr	r3, [r7]
 800b198: b29b         	uxth	r3, r3
 800b19a: 2204         	movs	r2, #0x4
 800b19c: 492b         	ldr	r1, [pc, #0xac]         @ 0x800b24c <bmi08x_acc_range_set+0xd8>
 800b19e: 4618         	mov	r0, r3
 800b1a0: f015 fc5f    	bl	0x8020a62 <bmi08x_range_to_reg_val> @ imm = #0x158be
 800b1a4: 6178         	str	r0, [r7, #0x14]
 800b1a6: e010         	b	0x800b1ca <bmi08x_acc_range_set+0x56> @ imm = #0x20
; 	} else if (data->accel_chip_id == BMI088_ACCEL_CHIP_ID) {
 800b1a8: 693b         	ldr	r3, [r7, #0x10]
 800b1aa: f893 3948    	ldrb.w	r3, [r3, #0x948]
 800b1ae: 2b1e         	cmp	r3, #0x1e
 800b1b0: d108         	bne	0x800b1c4 <bmi08x_acc_range_set+0x50> @ imm = #0x10
; 		reg_val = bmi08x_range_to_reg_val(range, bmi088_acc_range_map,
 800b1b2: 683b         	ldr	r3, [r7]
 800b1b4: b29b         	uxth	r3, r3
 800b1b6: 2204         	movs	r2, #0x4
 800b1b8: 4925         	ldr	r1, [pc, #0x94]         @ 0x800b250 <bmi08x_acc_range_set+0xdc>
 800b1ba: 4618         	mov	r0, r3
 800b1bc: f015 fc51    	bl	0x8020a62 <bmi08x_range_to_reg_val> @ imm = #0x158a2
 800b1c0: 6178         	str	r0, [r7, #0x14]
 800b1c2: e002         	b	0x800b1ca <bmi08x_acc_range_set+0x56> @ imm = #0x4
; 		return -ENODEV;
 800b1c4: f06f 0312    	mvn	r3, #0x12
 800b1c8: e03b         	b	0x800b242 <bmi08x_acc_range_set+0xce> @ imm = #0x76
; 	if (reg_val < 0) {
 800b1ca: 697b         	ldr	r3, [r7, #0x14]
 800b1cc: 2b00         	cmp	r3, #0x0
 800b1ce: da01         	bge	0x800b1d4 <bmi08x_acc_range_set+0x60> @ imm = #0x2
; 		return reg_val;
 800b1d0: 697b         	ldr	r3, [r7, #0x14]
 800b1d2: e036         	b	0x800b242 <bmi08x_acc_range_set+0xce> @ imm = #0x6c
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_RANGE, reg_val & 0xff);
 800b1d4: 697b         	ldr	r3, [r7, #0x14]
 800b1d6: b2db         	uxtb	r3, r3
 800b1d8: 461a         	mov	r2, r3
 800b1da: 2141         	movs	r1, #0x41
 800b1dc: 6878         	ldr	r0, [r7, #0x4]
 800b1de: f015 f904    	bl	0x80203ea <bmi08x_accel_byte_write> @ imm = #0x15208
 800b1e2: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 800b1e4: 68fb         	ldr	r3, [r7, #0xc]
 800b1e6: 2b00         	cmp	r3, #0x0
 800b1e8: da01         	bge	0x800b1ee <bmi08x_acc_range_set+0x7a> @ imm = #0x2
; 		return ret;
 800b1ea: 68fb         	ldr	r3, [r7, #0xc]
 800b1ec: e029         	b	0x800b242 <bmi08x_acc_range_set+0xce> @ imm = #0x52
; 	data->scale = BMI08X_ACC_SCALE(range);
 800b1ee: 683b         	ldr	r3, [r7]
 800b1f0: 17da         	asrs	r2, r3, #0x1f
 800b1f2: 4698         	mov	r8, r3
 800b1f4: 4691         	mov	r9, r2
 800b1f6: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800b254 <bmi08x_acc_range_set+0xe0>
 800b1f8: fb03 f209    	mul	r2, r3, r9
 800b1fc: 2300         	movs	r3, #0x0
 800b1fe: fb03 f308    	mul	r3, r3, r8
 800b202: 4413         	add	r3, r2
 800b204: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800b254 <bmi08x_acc_range_set+0xe0>
 800b206: fba8 4502    	umull	r4, r5, r8, r2
 800b20a: 442b         	add	r3, r5
 800b20c: 461d         	mov	r5, r3
 800b20e: 4622         	mov	r2, r4
 800b210: 462b         	mov	r3, r5
 800b212: 2b00         	cmp	r3, #0x0
 800b214: da07         	bge	0x800b226 <bmi08x_acc_range_set+0xb2> @ imm = #0xe
 800b216: f64f 71ff    	movw	r1, #0xffff
 800b21a: eb12 0a01    	adds.w	r10, r2, r1
 800b21e: f143 0b00    	adc	r11, r3, #0x0
 800b222: 4652         	mov	r2, r10
 800b224: 465b         	mov	r3, r11
 800b226: f04f 0000    	mov.w	r0, #0x0
 800b22a: f04f 0100    	mov.w	r1, #0x0
 800b22e: 0c10         	lsrs	r0, r2, #0x10
 800b230: ea40 4003    	orr.w	r0, r0, r3, lsl #16
 800b234: 1419         	asrs	r1, r3, #0x10
 800b236: 4602         	mov	r2, r0
 800b238: 460b         	mov	r3, r1
 800b23a: b292         	uxth	r2, r2
 800b23c: 693b         	ldr	r3, [r7, #0x10]
 800b23e: 825a         	strh	r2, [r3, #0x12]
; 	return ret;
 800b240: 68fb         	ldr	r3, [r7, #0xc]
; }
 800b242: 4618         	mov	r0, r3
 800b244: 3718         	adds	r7, #0x18
 800b246: 46bd         	mov	sp, r7
 800b248: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800b24c <$d>:
 800b24c: 84 ac 02 08  	.word	0x0802ac84
 800b250: 94 ac 02 08  	.word	0x0802ac94
 800b254: 74 46 2b 01  	.word	0x012b4674

0800b258 <bmi08x_acc_config>:
; {
 800b258: b580         	push	{r7, lr}
 800b25a: b08a         	sub	sp, #0x28
 800b25c: af04         	add	r7, sp, #0x10
 800b25e: 60f8         	str	r0, [r7, #0xc]
 800b260: 607b         	str	r3, [r7, #0x4]
 800b262: 460b         	mov	r3, r1
 800b264: 817b         	strh	r3, [r7, #0xa]
 800b266: 4613         	mov	r3, r2
 800b268: 813b         	strh	r3, [r7, #0x8]
; 	switch (attr) {
 800b26a: 893b         	ldrh	r3, [r7, #0x8]
 800b26c: 2b00         	cmp	r3, #0x0
 800b26e: d00b         	beq	0x800b288 <bmi08x_acc_config+0x30> @ imm = #0x16
 800b270: 2b07         	cmp	r3, #0x7
 800b272: d11b         	bne	0x800b2ac <bmi08x_acc_config+0x54> @ imm = #0x36
; 		return bmi08x_acc_range_set(dev, sensor_ms2_to_g(val));
 800b274: 6878         	ldr	r0, [r7, #0x4]
 800b276: f7f5 fb5f    	bl	0x8000938 <sensor_ms2_to_g> @ imm = #-0xa942
 800b27a: 4603         	mov	r3, r0
 800b27c: 4619         	mov	r1, r3
 800b27e: 68f8         	ldr	r0, [r7, #0xc]
 800b280: f7ff ff78    	bl	0x800b174 <bmi08x_acc_range_set> @ imm = #-0x110
 800b284: 4603         	mov	r3, r0
 800b286: e02f         	b	0x800b2e8 <bmi08x_acc_config+0x90> @ imm = #0x5e
; 		return bmi08x_acc_odr_set(dev, val->val1, val->val2 / 1000);
 800b288: 687b         	ldr	r3, [r7, #0x4]
 800b28a: 681b         	ldr	r3, [r3]
 800b28c: b299         	uxth	r1, r3
 800b28e: 687b         	ldr	r3, [r7, #0x4]
 800b290: 685b         	ldr	r3, [r3, #0x4]
 800b292: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800b2f0 <bmi08x_acc_config+0x98>
 800b294: fb82 0203    	smull	r0, r2, r2, r3
 800b298: 1192         	asrs	r2, r2, #0x6
 800b29a: 17db         	asrs	r3, r3, #0x1f
 800b29c: 1ad3         	subs	r3, r2, r3
 800b29e: b29b         	uxth	r3, r3
 800b2a0: 461a         	mov	r2, r3
 800b2a2: 68f8         	ldr	r0, [r7, #0xc]
 800b2a4: f015 f8f1    	bl	0x802048a <bmi08x_acc_odr_set> @ imm = #0x151e2
 800b2a8: 4603         	mov	r3, r0
 800b2aa: e01d         	b	0x800b2e8 <bmi08x_acc_config+0x90> @ imm = #0x3a
; 		LOG_DBG("Accel attribute not supported.");
 800b2ac: 2303         	movs	r3, #0x3
 800b2ae: 2b03         	cmp	r3, #0x3
 800b2b0: d918         	bls	0x800b2e4 <bmi08x_acc_config+0x8c> @ imm = #0x30
 800b2b2: 2301         	movs	r3, #0x1
 800b2b4: 75fb         	strb	r3, [r7, #0x17]
 800b2b6: 7dfb         	ldrb	r3, [r7, #0x17]
 800b2b8: f083 0301    	eor	r3, r3, #0x1
 800b2bc: b2db         	uxtb	r3, r3
 800b2be: 2b00         	cmp	r3, #0x0
 800b2c0: d110         	bne	0x800b2e4 <bmi08x_acc_config+0x8c> @ imm = #0x20
 800b2c2: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b2f4 <bmi08x_acc_config+0x9c>
 800b2c4: 6819         	ldr	r1, [r3]
 800b2c6: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b2f8 <bmi08x_acc_config+0xa0>
 800b2c8: 9303         	str	r3, [sp, #0xc]
 800b2ca: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b2fc <bmi08x_acc_config+0xa4>
 800b2cc: 9302         	str	r3, [sp, #0x8]
 800b2ce: 2308         	movs	r3, #0x8
 800b2d0: 9301         	str	r3, [sp, #0x4]
 800b2d2: 2300         	movs	r3, #0x0
 800b2d4: 9300         	str	r3, [sp]
 800b2d6: 2300         	movs	r3, #0x0
 800b2d8: 2204         	movs	r2, #0x4
 800b2da: 2000         	movs	r0, #0x0
 800b2dc: f014 febf    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x14d7e
 800b2e0: 2300         	movs	r3, #0x0
 800b2e2: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800b2e4: f06f 0385    	mvn	r3, #0x85
; }
 800b2e8: 4618         	mov	r0, r3
 800b2ea: 3718         	adds	r7, #0x18
 800b2ec: 46bd         	mov	sp, r7
 800b2ee: bd80         	pop	{r7, pc}

0800b2f0 <$d>:
 800b2f0: d3 4d 62 10  	.word	0x10624dd3
 800b2f4: 40 05 00 20  	.word	0x20000540
 800b2f8: d0 ac 02 08  	.word	0x0802acd0
 800b2fc: 9c 94 02 08  	.word	0x0802949c

0800b300 <bmi08x_attr_set>:
; {
 800b300: b580         	push	{r7, lr}
 800b302: b08a         	sub	sp, #0x28
 800b304: af04         	add	r7, sp, #0x10
 800b306: 60f8         	str	r0, [r7, #0xc]
 800b308: 607b         	str	r3, [r7, #0x4]
 800b30a: 460b         	mov	r3, r1
 800b30c: 817b         	strh	r3, [r7, #0xa]
 800b30e: 4613         	mov	r3, r2
 800b310: 813b         	strh	r3, [r7, #0x8]
; 	switch (chan) {
 800b312: 897b         	ldrh	r3, [r7, #0xa]
 800b314: 2b03         	cmp	r3, #0x3
 800b316: d807         	bhi	0x800b328 <bmi08x_attr_set+0x28> @ imm = #0xe
; 		return bmi08x_acc_config(dev, chan, attr, val);
 800b318: 893a         	ldrh	r2, [r7, #0x8]
 800b31a: 8979         	ldrh	r1, [r7, #0xa]
 800b31c: 687b         	ldr	r3, [r7, #0x4]
 800b31e: 68f8         	ldr	r0, [r7, #0xc]
 800b320: f7ff ff9a    	bl	0x800b258 <bmi08x_acc_config> @ imm = #-0xcc
 800b324: 4603         	mov	r3, r0
 800b326: e01d         	b	0x800b364 <bmi08x_attr_set+0x64> @ imm = #0x3a
; 		LOG_DBG("attr_set() not supported on this channel.");
 800b328: 2303         	movs	r3, #0x3
 800b32a: 2b03         	cmp	r3, #0x3
 800b32c: d918         	bls	0x800b360 <bmi08x_attr_set+0x60> @ imm = #0x30
 800b32e: 2301         	movs	r3, #0x1
 800b330: 75fb         	strb	r3, [r7, #0x17]
 800b332: 7dfb         	ldrb	r3, [r7, #0x17]
 800b334: f083 0301    	eor	r3, r3, #0x1
 800b338: b2db         	uxtb	r3, r3
 800b33a: 2b00         	cmp	r3, #0x0
 800b33c: d110         	bne	0x800b360 <bmi08x_attr_set+0x60> @ imm = #0x20
 800b33e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b36c <bmi08x_attr_set+0x6c>
 800b340: 6819         	ldr	r1, [r3]
 800b342: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b370 <bmi08x_attr_set+0x70>
 800b344: 9303         	str	r3, [sp, #0xc]
 800b346: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b374 <bmi08x_attr_set+0x74>
 800b348: 9302         	str	r3, [sp, #0x8]
 800b34a: 2308         	movs	r3, #0x8
 800b34c: 9301         	str	r3, [sp, #0x4]
 800b34e: 2300         	movs	r3, #0x0
 800b350: 9300         	str	r3, [sp]
 800b352: 2300         	movs	r3, #0x0
 800b354: 2204         	movs	r2, #0x4
 800b356: 2000         	movs	r0, #0x0
 800b358: f014 fe81    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x14d02
 800b35c: 2300         	movs	r3, #0x0
 800b35e: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800b360: f06f 0385    	mvn	r3, #0x85
; }
 800b364: 4618         	mov	r0, r3
 800b366: 3718         	adds	r7, #0x18
 800b368: 46bd         	mov	sp, r7
 800b36a: bd80         	pop	{r7, pc}

0800b36c <$d>:
 800b36c: 40 05 00 20  	.word	0x20000540
 800b370: e4 ac 02 08  	.word	0x0802ace4
 800b374: c0 94 02 08  	.word	0x080294c0

0800b378 <bmi08x_sample_fetch>:
; {
 800b378: b580         	push	{r7, lr}
 800b37a: b08c         	sub	sp, #0x30
 800b37c: af04         	add	r7, sp, #0x10
 800b37e: 6078         	str	r0, [r7, #0x4]
 800b380: 460b         	mov	r3, r1
 800b382: 807b         	strh	r3, [r7, #0x2]
; 	struct bmi08x_accel_data *data = dev->data;
 800b384: 687b         	ldr	r3, [r7, #0x4]
 800b386: 691b         	ldr	r3, [r3, #0x10]
 800b388: 61bb         	str	r3, [r7, #0x18]
; 	if (chan != SENSOR_CHAN_ALL && chan != SENSOR_CHAN_ACCEL_XYZ) {
 800b38a: 887b         	ldrh	r3, [r7, #0x2]
 800b38c: 2b3c         	cmp	r3, #0x3c
 800b38e: d021         	beq	0x800b3d4 <bmi08x_sample_fetch+0x5c> @ imm = #0x42
 800b390: 887b         	ldrh	r3, [r7, #0x2]
 800b392: 2b03         	cmp	r3, #0x3
 800b394: d01e         	beq	0x800b3d4 <bmi08x_sample_fetch+0x5c> @ imm = #0x3c
; 		LOG_DBG("Unsupported sensor channel");
 800b396: 2303         	movs	r3, #0x3
 800b398: 2b03         	cmp	r3, #0x3
 800b39a: d918         	bls	0x800b3ce <bmi08x_sample_fetch+0x56> @ imm = #0x30
 800b39c: 2301         	movs	r3, #0x1
 800b39e: 75fb         	strb	r3, [r7, #0x17]
 800b3a0: 7dfb         	ldrb	r3, [r7, #0x17]
 800b3a2: f083 0301    	eor	r3, r3, #0x1
 800b3a6: b2db         	uxtb	r3, r3
 800b3a8: 2b00         	cmp	r3, #0x0
 800b3aa: d110         	bne	0x800b3ce <bmi08x_sample_fetch+0x56> @ imm = #0x20
 800b3ac: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800b438 <bmi08x_sample_fetch+0xc0>
 800b3ae: 6819         	ldr	r1, [r3]
 800b3b0: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800b43c <bmi08x_sample_fetch+0xc4>
 800b3b2: 9303         	str	r3, [sp, #0xc]
 800b3b4: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800b440 <bmi08x_sample_fetch+0xc8>
 800b3b6: 9302         	str	r3, [sp, #0x8]
 800b3b8: 2308         	movs	r3, #0x8
 800b3ba: 9301         	str	r3, [sp, #0x4]
 800b3bc: 2300         	movs	r3, #0x0
 800b3be: 9300         	str	r3, [sp]
 800b3c0: 2300         	movs	r3, #0x0
 800b3c2: 2204         	movs	r2, #0x4
 800b3c4: 2000         	movs	r0, #0x0
 800b3c6: f014 fe4a    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x14c94
 800b3ca: 2300         	movs	r3, #0x0
 800b3cc: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800b3ce: f06f 0385    	mvn	r3, #0x85
 800b3d2: e02d         	b	0x800b430 <bmi08x_sample_fetch+0xb8> @ imm = #0x5a
; 	pm_device_busy_set(dev);
 800b3d4: 6878         	ldr	r0, [r7, #0x4]
 800b3d6: f014 fe2e    	bl	0x8020036 <pm_device_busy_set> @ imm = #0x14c5c
; 	ret = bmi08x_accel_read(dev, BMI08X_REG_ACCEL_X_LSB, (uint8_t *)data->acc_sample,
 800b3da: 69bb         	ldr	r3, [r7, #0x18]
 800b3dc: f103 020c    	add.w	r2, r3, #0xc
 800b3e0: 2306         	movs	r3, #0x6
 800b3e2: 2112         	movs	r1, #0x12
 800b3e4: 6878         	ldr	r0, [r7, #0x4]
 800b3e6: f014 ffae    	bl	0x8020346 <bmi08x_accel_read> @ imm = #0x14f5c
 800b3ea: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 800b3ec: 68fb         	ldr	r3, [r7, #0xc]
 800b3ee: 2b00         	cmp	r3, #0x0
 800b3f0: da04         	bge	0x800b3fc <bmi08x_sample_fetch+0x84> @ imm = #0x8
; 		pm_device_busy_clear(dev);
 800b3f2: 6878         	ldr	r0, [r7, #0x4]
 800b3f4: f014 fe29    	bl	0x802004a <pm_device_busy_clear> @ imm = #0x14c52
; 		return ret;
 800b3f8: 68fb         	ldr	r3, [r7, #0xc]
 800b3fa: e019         	b	0x800b430 <bmi08x_sample_fetch+0xb8> @ imm = #0x32
; 	for (i = 0; i < ARRAY_SIZE(data->acc_sample); i++) {
 800b3fc: 2300         	movs	r3, #0x0
 800b3fe: 61fb         	str	r3, [r7, #0x1c]
 800b400: e00f         	b	0x800b422 <bmi08x_sample_fetch+0xaa> @ imm = #0x1e
; 		data->acc_sample[i] = sys_le16_to_cpu(data->acc_sample[i]);
 800b402: 69ba         	ldr	r2, [r7, #0x18]
 800b404: 69fb         	ldr	r3, [r7, #0x1c]
 800b406: 3304         	adds	r3, #0x4
 800b408: 005b         	lsls	r3, r3, #0x1
 800b40a: 4413         	add	r3, r2
 800b40c: 8899         	ldrh	r1, [r3, #0x4]
 800b40e: 69ba         	ldr	r2, [r7, #0x18]
 800b410: 69fb         	ldr	r3, [r7, #0x1c]
 800b412: 3304         	adds	r3, #0x4
 800b414: 005b         	lsls	r3, r3, #0x1
 800b416: 4413         	add	r3, r2
 800b418: 460a         	mov	r2, r1
 800b41a: 809a         	strh	r2, [r3, #0x4]
; 	for (i = 0; i < ARRAY_SIZE(data->acc_sample); i++) {
 800b41c: 69fb         	ldr	r3, [r7, #0x1c]
 800b41e: 3301         	adds	r3, #0x1
 800b420: 61fb         	str	r3, [r7, #0x1c]
 800b422: 69fb         	ldr	r3, [r7, #0x1c]
 800b424: 2b02         	cmp	r3, #0x2
 800b426: d9ec         	bls	0x800b402 <bmi08x_sample_fetch+0x8a> @ imm = #-0x28
; 	pm_device_busy_clear(dev);
 800b428: 6878         	ldr	r0, [r7, #0x4]
 800b42a: f014 fe0e    	bl	0x802004a <pm_device_busy_clear> @ imm = #0x14c1c
; 	return ret;
 800b42e: 68fb         	ldr	r3, [r7, #0xc]
; }
 800b430: 4618         	mov	r0, r3
 800b432: 3720         	adds	r7, #0x20
 800b434: 46bd         	mov	sp, r7
 800b436: bd80         	pop	{r7, pc}

0800b438 <$d>:
 800b438: 40 05 00 20  	.word	0x20000540
 800b43c: f4 ac 02 08  	.word	0x0802acf4
 800b440: f0 94 02 08  	.word	0x080294f0

0800b444 <bmi08x_to_fixed_point>:
; {
 800b444: b480         	push	{r7}
 800b446: b085         	sub	sp, #0x14
 800b448: af00         	add	r7, sp, #0x0
 800b44a: 4603         	mov	r3, r0
 800b44c: 603a         	str	r2, [r7]
 800b44e: 80fb         	strh	r3, [r7, #0x6]
 800b450: 460b         	mov	r3, r1
 800b452: 80bb         	strh	r3, [r7, #0x4]
; 	converted_val = raw_val * scale;
 800b454: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 800b458: 88ba         	ldrh	r2, [r7, #0x4]
 800b45a: fb02 f303    	mul	r3, r2, r3
 800b45e: 60fb         	str	r3, [r7, #0xc]
; 	val->val1 = converted_val / 1000000;
 800b460: 68fb         	ldr	r3, [r7, #0xc]
 800b462: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800b498 <bmi08x_to_fixed_point+0x54>
 800b464: fb82 1203    	smull	r1, r2, r2, r3
 800b468: 1492         	asrs	r2, r2, #0x12
 800b46a: 17db         	asrs	r3, r3, #0x1f
 800b46c: 1ad2         	subs	r2, r2, r3
 800b46e: 683b         	ldr	r3, [r7]
 800b470: 601a         	str	r2, [r3]
; 	val->val2 = converted_val % 1000000;
 800b472: 68fa         	ldr	r2, [r7, #0xc]
 800b474: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800b498 <bmi08x_to_fixed_point+0x54>
 800b476: fb83 1302    	smull	r1, r3, r3, r2
 800b47a: 1499         	asrs	r1, r3, #0x12
 800b47c: 17d3         	asrs	r3, r2, #0x1f
 800b47e: 1acb         	subs	r3, r1, r3
 800b480: 4906         	ldr	r1, [pc, #0x18]         @ 0x800b49c <bmi08x_to_fixed_point+0x58>
 800b482: fb01 f303    	mul	r3, r1, r3
 800b486: 1ad3         	subs	r3, r2, r3
 800b488: 683a         	ldr	r2, [r7]
 800b48a: 6053         	str	r3, [r2, #0x4]
; }
 800b48c: bf00         	nop
 800b48e: 3714         	adds	r7, #0x14
 800b490: 46bd         	mov	sp, r7
 800b492: f85d 7b04    	ldr	r7, [sp], #4
 800b496: 4770         	bx	lr

0800b498 <$d>:
 800b498: 83 de 1b 43  	.word	0x431bde83
 800b49c: 40 42 0f 00  	.word	0x000f4240

0800b4a0 <bmi08x_temp_channel_get>:
; {
 800b4a0: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800b4a4: b090         	sub	sp, #0x40
 800b4a6: af04         	add	r7, sp, #0x10
 800b4a8: 6078         	str	r0, [r7, #0x4]
 800b4aa: 6039         	str	r1, [r7]
; 	uint16_t temp_raw = 0U;
 800b4ac: 2300         	movs	r3, #0x0
 800b4ae: 817b         	strh	r3, [r7, #0xa]
; 	int32_t temp_micro = 0;
 800b4b0: 2300         	movs	r3, #0x0
 800b4b2: 62bb         	str	r3, [r7, #0x28]
; 	int16_t temp_int11 = 0;
 800b4b4: 2300         	movs	r3, #0x0
 800b4b6: 85fb         	strh	r3, [r7, #0x2e]
; 	ret = bmi08x_accel_word_read(dev, BMI08X_REG_TEMP_MSB, &temp_raw);
 800b4b8: f107 030a    	add.w	r3, r7, #0xa
 800b4bc: 461a         	mov	r2, r3
 800b4be: 2122         	movs	r1, #0x22
 800b4c0: 6878         	ldr	r0, [r7, #0x4]
 800b4c2: f014 ff71    	bl	0x80203a8 <bmi08x_accel_word_read> @ imm = #0x14ee2
 800b4c6: 6278         	str	r0, [r7, #0x24]
; 	if (!ret) {
 800b4c8: 6a7b         	ldr	r3, [r7, #0x24]
 800b4ca: 2b00         	cmp	r3, #0x0
 800b4cc: d109         	bne	0x800b4e2 <bmi08x_temp_channel_get+0x42> @ imm = #0x12
; 		temp_int11 = (temp_raw & 0xFF) << 3;
 800b4ce: 897b         	ldrh	r3, [r7, #0xa]
 800b4d0: 00db         	lsls	r3, r3, #0x3
 800b4d2: b21b         	sxth	r3, r3
 800b4d4: f403 63ff    	and	r3, r3, #0x7f8
 800b4d8: 85fb         	strh	r3, [r7, #0x2e]
; 	if (temp_raw == 0x80) {
 800b4da: 897b         	ldrh	r3, [r7, #0xa]
 800b4dc: 2b80         	cmp	r3, #0x80
 800b4de: d13d         	bne	0x800b55c <bmi08x_temp_channel_get+0xbc> @ imm = #0x7a
 800b4e0: e01f         	b	0x800b522 <bmi08x_temp_channel_get+0x82> @ imm = #0x3e
; 		LOG_ERR("Error reading BMI08X_REG_TEMP_MSB. (err %d)", ret);
 800b4e2: 2303         	movs	r3, #0x3
 800b4e4: 2b00         	cmp	r3, #0x0
 800b4e6: d01a         	beq	0x800b51e <bmi08x_temp_channel_get+0x7e> @ imm = #0x34
 800b4e8: 2301         	movs	r3, #0x1
 800b4ea: f887 3023    	strb.w	r3, [r7, #0x23]
 800b4ee: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800b4f2: f083 0301    	eor	r3, r3, #0x1
 800b4f6: b2db         	uxtb	r3, r3
 800b4f8: 2b00         	cmp	r3, #0x0
 800b4fa: d110         	bne	0x800b51e <bmi08x_temp_channel_get+0x7e> @ imm = #0x20
 800b4fc: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x800b630 <bmi08x_temp_channel_get+0x190>
 800b4fe: 6819         	ldr	r1, [r3]
 800b500: 6a7b         	ldr	r3, [r7, #0x24]
 800b502: 9303         	str	r3, [sp, #0xc]
 800b504: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800b634 <bmi08x_temp_channel_get+0x194>
 800b506: 9302         	str	r3, [sp, #0x8]
 800b508: 2300         	movs	r3, #0x0
 800b50a: 9301         	str	r3, [sp, #0x4]
 800b50c: 2300         	movs	r3, #0x0
 800b50e: 9300         	str	r3, [sp]
 800b510: 2300         	movs	r3, #0x0
 800b512: 2201         	movs	r2, #0x1
 800b514: 2000         	movs	r0, #0x0
 800b516: f014 fda2    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x14b44
 800b51a: 2300         	movs	r3, #0x0
 800b51c: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 800b51e: 6a7b         	ldr	r3, [r7, #0x24]
 800b520: e080         	b	0x800b624 <bmi08x_temp_channel_get+0x184> @ imm = #0x100
; 		LOG_ERR("BMI08X returned invalid temperature.");
 800b522: 2303         	movs	r3, #0x3
 800b524: 2b00         	cmp	r3, #0x0
 800b526: d016         	beq	0x800b556 <bmi08x_temp_channel_get+0xb6> @ imm = #0x2c
 800b528: 2301         	movs	r3, #0x1
 800b52a: 74fb         	strb	r3, [r7, #0x13]
 800b52c: 7cfb         	ldrb	r3, [r7, #0x13]
 800b52e: f083 0301    	eor	r3, r3, #0x1
 800b532: b2db         	uxtb	r3, r3
 800b534: 2b00         	cmp	r3, #0x0
 800b536: d10e         	bne	0x800b556 <bmi08x_temp_channel_get+0xb6> @ imm = #0x1c
 800b538: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x800b630 <bmi08x_temp_channel_get+0x190>
 800b53a: 6819         	ldr	r1, [r3]
 800b53c: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800b638 <bmi08x_temp_channel_get+0x198>
 800b53e: 9302         	str	r3, [sp, #0x8]
 800b540: 2300         	movs	r3, #0x0
 800b542: 9301         	str	r3, [sp, #0x4]
 800b544: 2300         	movs	r3, #0x0
 800b546: 9300         	str	r3, [sp]
 800b548: 2300         	movs	r3, #0x0
 800b54a: 2201         	movs	r2, #0x1
 800b54c: 2000         	movs	r0, #0x0
 800b54e: f014 fd86    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x14b0c
 800b552: 2300         	movs	r3, #0x0
 800b554: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODATA;
 800b556: f06f 033c    	mvn	r3, #0x3c
 800b55a: e063         	b	0x800b624 <bmi08x_temp_channel_get+0x184> @ imm = #0xc6
; 	ret = bmi08x_accel_word_read(dev, BMI08X_REG_TEMP_LSB, &temp_raw);
 800b55c: f107 030a    	add.w	r3, r7, #0xa
 800b560: 461a         	mov	r2, r3
 800b562: 2123         	movs	r1, #0x23
 800b564: 6878         	ldr	r0, [r7, #0x4]
 800b566: f014 ff1f    	bl	0x80203a8 <bmi08x_accel_word_read> @ imm = #0x14e3e
 800b56a: 6278         	str	r0, [r7, #0x24]
; 	if (!ret) {
 800b56c: 6a7b         	ldr	r3, [r7, #0x24]
 800b56e: 2b00         	cmp	r3, #0x0
 800b570: d10e         	bne	0x800b590 <bmi08x_temp_channel_get+0xf0> @ imm = #0x1c
; 		temp_int11 |= (temp_raw & 0xE0) >> 5;
 800b572: 897b         	ldrh	r3, [r7, #0xa]
 800b574: 115b         	asrs	r3, r3, #0x5
 800b576: b21b         	sxth	r3, r3
 800b578: f003 0307    	and	r3, r3, #0x7
 800b57c: b21a         	sxth	r2, r3
 800b57e: 8dfb         	ldrh	r3, [r7, #0x2e]
 800b580: 4313         	orrs	r3, r2
 800b582: 85fb         	strh	r3, [r7, #0x2e]
; 	if (temp_int11 > 1023) {
 800b584: f9b7 302e    	ldrsh.w	r3, [r7, #0x2e]
 800b588: f5b3 6f80    	cmp.w	r3, #0x400
 800b58c: db23         	blt	0x800b5d6 <bmi08x_temp_channel_get+0x136> @ imm = #0x46
 800b58e: e01d         	b	0x800b5cc <bmi08x_temp_channel_get+0x12c> @ imm = #0x3a
; 		LOG_ERR("Error reading BMI08X_REG_TEMP_LSB. (err %d)", ret);
 800b590: 2303         	movs	r3, #0x3
 800b592: 2b00         	cmp	r3, #0x0
 800b594: d018         	beq	0x800b5c8 <bmi08x_temp_channel_get+0x128> @ imm = #0x30
 800b596: 2301         	movs	r3, #0x1
 800b598: 76fb         	strb	r3, [r7, #0x1b]
 800b59a: 7efb         	ldrb	r3, [r7, #0x1b]
 800b59c: f083 0301    	eor	r3, r3, #0x1
 800b5a0: b2db         	uxtb	r3, r3
 800b5a2: 2b00         	cmp	r3, #0x0
 800b5a4: d110         	bne	0x800b5c8 <bmi08x_temp_channel_get+0x128> @ imm = #0x20
 800b5a6: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800b630 <bmi08x_temp_channel_get+0x190>
 800b5a8: 6819         	ldr	r1, [r3]
 800b5aa: 6a7b         	ldr	r3, [r7, #0x24]
 800b5ac: 9303         	str	r3, [sp, #0xc]
 800b5ae: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800b63c <bmi08x_temp_channel_get+0x19c>
 800b5b0: 9302         	str	r3, [sp, #0x8]
 800b5b2: 2300         	movs	r3, #0x0
 800b5b4: 9301         	str	r3, [sp, #0x4]
 800b5b6: 2300         	movs	r3, #0x0
 800b5b8: 9300         	str	r3, [sp]
 800b5ba: 2300         	movs	r3, #0x0
 800b5bc: 2201         	movs	r2, #0x1
 800b5be: 2000         	movs	r0, #0x0
 800b5c0: f014 fd4d    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x14a9a
 800b5c4: 2300         	movs	r3, #0x0
 800b5c6: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 800b5c8: 6a7b         	ldr	r3, [r7, #0x24]
 800b5ca: e02b         	b	0x800b624 <bmi08x_temp_channel_get+0x184> @ imm = #0x56
; 		temp_int11 -= 2048;
 800b5cc: 8dfb         	ldrh	r3, [r7, #0x2e]
 800b5ce: f5a3 6300    	sub.w	r3, r3, #0x800
 800b5d2: b29b         	uxth	r3, r3
 800b5d4: 85fb         	strh	r3, [r7, #0x2e]
; 	temp_micro = temp_int11 * 125 + 23 * 1000000;
 800b5d6: f9b7 202e    	ldrsh.w	r2, [r7, #0x2e]
 800b5da: 4613         	mov	r3, r2
 800b5dc: 015b         	lsls	r3, r3, #0x5
 800b5de: 1a9b         	subs	r3, r3, r2
 800b5e0: 009b         	lsls	r3, r3, #0x2
 800b5e2: 441a         	add	r2, r3
 800b5e4: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800b640 <bmi08x_temp_channel_get+0x1a0>
 800b5e6: 4413         	add	r3, r2
 800b5e8: 62bb         	str	r3, [r7, #0x28]
; 	val->val1 = temp_micro / 1000000ULL;
 800b5ea: 6abb         	ldr	r3, [r7, #0x28]
 800b5ec: 17da         	asrs	r2, r3, #0x1f
 800b5ee: 4698         	mov	r8, r3
 800b5f0: 4691         	mov	r9, r2
 800b5f2: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800b644 <bmi08x_temp_channel_get+0x1a4>
 800b5f4: f04f 0300    	mov.w	r3, #0x0
 800b5f8: 4640         	mov	r0, r8
 800b5fa: 4649         	mov	r1, r9
 800b5fc: f7f5 f820    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xafc0
 800b600: 4602         	mov	r2, r0
 800b602: 460b         	mov	r3, r1
 800b604: 683b         	ldr	r3, [r7]
 800b606: 601a         	str	r2, [r3]
; 	val->val2 = temp_micro % 1000000ULL;
 800b608: 6abb         	ldr	r3, [r7, #0x28]
 800b60a: 17da         	asrs	r2, r3, #0x1f
 800b60c: 461c         	mov	r4, r3
 800b60e: 4615         	mov	r5, r2
 800b610: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800b644 <bmi08x_temp_channel_get+0x1a4>
 800b612: f04f 0300    	mov.w	r3, #0x0
 800b616: 4620         	mov	r0, r4
 800b618: 4629         	mov	r1, r5
 800b61a: f7f5 f811    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xafde
 800b61e: 683b         	ldr	r3, [r7]
 800b620: 605a         	str	r2, [r3, #0x4]
; 	return ret;
 800b622: 6a7b         	ldr	r3, [r7, #0x24]
; }
 800b624: 4618         	mov	r0, r3
 800b626: 3730         	adds	r7, #0x30
 800b628: 46bd         	mov	sp, r7
 800b62a: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 800b62e: bf00         	nop

0800b630 <$d>:
 800b630: 40 05 00 20  	.word	0x20000540
 800b634: 10 95 02 08  	.word	0x08029510
 800b638: 3c 95 02 08  	.word	0x0802953c
 800b63c: 64 95 02 08  	.word	0x08029564
 800b640: c0 f3 5e 01  	.word	0x015ef3c0
 800b644: 40 42 0f 00  	.word	0x000f4240

0800b648 <bmi08x_channel_get>:
; {
 800b648: b580         	push	{r7, lr}
 800b64a: b08a         	sub	sp, #0x28
 800b64c: af04         	add	r7, sp, #0x10
 800b64e: 60f8         	str	r0, [r7, #0xc]
 800b650: 460b         	mov	r3, r1
 800b652: 607a         	str	r2, [r7, #0x4]
 800b654: 817b         	strh	r3, [r7, #0xa]
; 	switch ((int16_t)chan) {
 800b656: f9b7 300a    	ldrsh.w	r3, [r7, #0xa]
 800b65a: 2b03         	cmp	r3, #0x3
 800b65c: dc02         	bgt	0x800b664 <bmi08x_channel_get+0x1c> @ imm = #0x4
 800b65e: 2b00         	cmp	r3, #0x0
 800b660: da03         	bge	0x800b66a <bmi08x_channel_get+0x22> @ imm = #0x6
 800b662: e010         	b	0x800b686 <bmi08x_channel_get+0x3e> @ imm = #0x20
 800b664: 2b0c         	cmp	r3, #0xc
 800b666: d008         	beq	0x800b67a <bmi08x_channel_get+0x32> @ imm = #0x10
 800b668: e00d         	b	0x800b686 <bmi08x_channel_get+0x3e> @ imm = #0x1a
; 		bmi08x_acc_channel_get(dev, chan, val);
 800b66a: 897b         	ldrh	r3, [r7, #0xa]
 800b66c: 687a         	ldr	r2, [r7, #0x4]
 800b66e: 4619         	mov	r1, r3
 800b670: 68f8         	ldr	r0, [r7, #0xc]
 800b672: f014 ff70    	bl	0x8020556 <bmi08x_acc_channel_get> @ imm = #0x14ee0
; 		return 0;
 800b676: 2300         	movs	r3, #0x0
 800b678: e023         	b	0x800b6c2 <bmi08x_channel_get+0x7a> @ imm = #0x46
; 		return bmi08x_temp_channel_get(dev, val);
 800b67a: 6879         	ldr	r1, [r7, #0x4]
 800b67c: 68f8         	ldr	r0, [r7, #0xc]
 800b67e: f7ff ff0f    	bl	0x800b4a0 <bmi08x_temp_channel_get> @ imm = #-0x1e2
 800b682: 4603         	mov	r3, r0
 800b684: e01d         	b	0x800b6c2 <bmi08x_channel_get+0x7a> @ imm = #0x3a
; 		LOG_DBG("Channel not supported.");
 800b686: 2303         	movs	r3, #0x3
 800b688: 2b03         	cmp	r3, #0x3
 800b68a: d918         	bls	0x800b6be <bmi08x_channel_get+0x76> @ imm = #0x30
 800b68c: 2301         	movs	r3, #0x1
 800b68e: 75fb         	strb	r3, [r7, #0x17]
 800b690: 7dfb         	ldrb	r3, [r7, #0x17]
 800b692: f083 0301    	eor	r3, r3, #0x1
 800b696: b2db         	uxtb	r3, r3
 800b698: 2b00         	cmp	r3, #0x0
 800b69a: d110         	bne	0x800b6be <bmi08x_channel_get+0x76> @ imm = #0x20
 800b69c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b6cc <bmi08x_channel_get+0x84>
 800b69e: 6819         	ldr	r1, [r3]
 800b6a0: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b6d0 <bmi08x_channel_get+0x88>
 800b6a2: 9303         	str	r3, [sp, #0xc]
 800b6a4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b6d4 <bmi08x_channel_get+0x8c>
 800b6a6: 9302         	str	r3, [sp, #0x8]
 800b6a8: 2308         	movs	r3, #0x8
 800b6aa: 9301         	str	r3, [sp, #0x4]
 800b6ac: 2300         	movs	r3, #0x0
 800b6ae: 9300         	str	r3, [sp]
 800b6b0: 2300         	movs	r3, #0x0
 800b6b2: 2204         	movs	r2, #0x4
 800b6b4: 2000         	movs	r0, #0x0
 800b6b6: f014 fcd2    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x149a4
 800b6ba: 2300         	movs	r3, #0x0
 800b6bc: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800b6be: f06f 0385    	mvn	r3, #0x85
; }
 800b6c2: 4618         	mov	r0, r3
 800b6c4: 3718         	adds	r7, #0x18
 800b6c6: 46bd         	mov	sp, r7
 800b6c8: bd80         	pop	{r7, pc}
 800b6ca: bf00         	nop

0800b6cc <$d>:
 800b6cc: 40 05 00 20  	.word	0x20000540
 800b6d0: 08 ad 02 08  	.word	0x0802ad08
 800b6d4: 90 95 02 08  	.word	0x08029590

0800b6d8 <bmi08x_accel_init>:
; {
 800b6d8: b580         	push	{r7, lr}
 800b6da: b09e         	sub	sp, #0x78
 800b6dc: af04         	add	r7, sp, #0x10
 800b6de: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 800b6e0: 687b         	ldr	r3, [r7, #0x4]
 800b6e2: 685b         	ldr	r3, [r3, #0x4]
 800b6e4: 65fb         	str	r3, [r7, #0x5c]
; 	struct bmi08x_accel_data *data = dev->data;
 800b6e6: 687b         	ldr	r3, [r7, #0x4]
 800b6e8: 691b         	ldr	r3, [r3, #0x10]
 800b6ea: 65bb         	str	r3, [r7, #0x58]
; 	uint8_t val = 0U;
 800b6ec: 2300         	movs	r3, #0x0
 800b6ee: 72fb         	strb	r3, [r7, #0xb]
; 	ret = bmi08x_bus_check(dev);
 800b6f0: 6878         	ldr	r0, [r7, #0x4]
 800b6f2: f014 fde3    	bl	0x80202bc <bmi08x_bus_check> @ imm = #0x14bc6
 800b6f6: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800b6f8: 6e7b         	ldr	r3, [r7, #0x64]
 800b6fa: 2b00         	cmp	r3, #0x0
 800b6fc: da1e         	bge	0x800b73c <bmi08x_accel_init+0x64> @ imm = #0x3c
; 		LOG_ERR("Bus not ready for '%s'", dev->name);
 800b6fe: 2303         	movs	r3, #0x3
 800b700: 2b00         	cmp	r3, #0x0
 800b702: d019         	beq	0x800b738 <bmi08x_accel_init+0x60> @ imm = #0x32
 800b704: 2301         	movs	r3, #0x1
 800b706: 74fb         	strb	r3, [r7, #0x13]
 800b708: 7cfb         	ldrb	r3, [r7, #0x13]
 800b70a: f083 0301    	eor	r3, r3, #0x1
 800b70e: b2db         	uxtb	r3, r3
 800b710: 2b00         	cmp	r3, #0x0
 800b712: d111         	bne	0x800b738 <bmi08x_accel_init+0x60> @ imm = #0x22
 800b714: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x800b980 <bmi08x_accel_init+0x2a8>
 800b716: 6819         	ldr	r1, [r3]
 800b718: 687b         	ldr	r3, [r7, #0x4]
 800b71a: 681b         	ldr	r3, [r3]
 800b71c: 9303         	str	r3, [sp, #0xc]
 800b71e: 4b99         	ldr	r3, [pc, #0x264]        @ 0x800b984 <bmi08x_accel_init+0x2ac>
 800b720: 9302         	str	r3, [sp, #0x8]
 800b722: 2300         	movs	r3, #0x0
 800b724: 9301         	str	r3, [sp, #0x4]
 800b726: 2300         	movs	r3, #0x0
 800b728: 9300         	str	r3, [sp]
 800b72a: 2300         	movs	r3, #0x0
 800b72c: 2201         	movs	r2, #0x1
 800b72e: 2000         	movs	r0, #0x0
 800b730: f014 fc95    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x1492a
 800b734: 2300         	movs	r3, #0x0
 800b736: 60fb         	str	r3, [r7, #0xc]
; 		return ret;
 800b738: 6e7b         	ldr	r3, [r7, #0x64]
 800b73a: e185         	b	0x800ba48 <bmi08x_accel_init+0x370> @ imm = #0x30a
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_SOFTRESET, BMI08X_SOFT_RESET_CMD);
 800b73c: 22b6         	movs	r2, #0xb6
 800b73e: 217e         	movs	r1, #0x7e
 800b740: 6878         	ldr	r0, [r7, #0x4]
 800b742: f014 fe52    	bl	0x80203ea <bmi08x_accel_byte_write> @ imm = #0x14ca4
 800b746: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800b748: 6e7b         	ldr	r3, [r7, #0x64]
 800b74a: 2b00         	cmp	r3, #0x0
 800b74c: da1b         	bge	0x800b786 <bmi08x_accel_init+0xae> @ imm = #0x36
; 		LOG_ERR("Cannot reboot chip.");
 800b74e: 2303         	movs	r3, #0x3
 800b750: 2b00         	cmp	r3, #0x0
 800b752: d016         	beq	0x800b782 <bmi08x_accel_init+0xaa> @ imm = #0x2c
 800b754: 2301         	movs	r3, #0x1
 800b756: 76fb         	strb	r3, [r7, #0x1b]
 800b758: 7efb         	ldrb	r3, [r7, #0x1b]
 800b75a: f083 0301    	eor	r3, r3, #0x1
 800b75e: b2db         	uxtb	r3, r3
 800b760: 2b00         	cmp	r3, #0x0
 800b762: d10e         	bne	0x800b782 <bmi08x_accel_init+0xaa> @ imm = #0x1c
 800b764: 4b86         	ldr	r3, [pc, #0x218]        @ 0x800b980 <bmi08x_accel_init+0x2a8>
 800b766: 6819         	ldr	r1, [r3]
 800b768: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x800b988 <bmi08x_accel_init+0x2b0>
 800b76a: 9302         	str	r3, [sp, #0x8]
 800b76c: 2300         	movs	r3, #0x0
 800b76e: 9301         	str	r3, [sp, #0x4]
 800b770: 2300         	movs	r3, #0x0
 800b772: 9300         	str	r3, [sp]
 800b774: 2300         	movs	r3, #0x0
 800b776: 2201         	movs	r2, #0x1
 800b778: 2000         	movs	r0, #0x0
 800b77a: f014 fc70    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x148e0
 800b77e: 2300         	movs	r3, #0x0
 800b780: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 800b782: 6e7b         	ldr	r3, [r7, #0x64]
 800b784: e160         	b	0x800ba48 <bmi08x_accel_init+0x370> @ imm = #0x2c0
; 	k_msleep(BMI08X_ACCEL_SOFTRESET_DELAY_MS);
 800b786: 2001         	movs	r0, #0x1
 800b788: f014 fc0f    	bl	0x801ffaa <k_msleep>    @ imm = #0x1481e
; 	ret = bmi08x_bus_init(dev);
 800b78c: 6878         	ldr	r0, [r7, #0x4]
 800b78e: f014 fda7    	bl	0x80202e0 <bmi08x_bus_init> @ imm = #0x14b4e
 800b792: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800b794: 6e7b         	ldr	r3, [r7, #0x64]
 800b796: 2b00         	cmp	r3, #0x0
 800b798: da20         	bge	0x800b7dc <bmi08x_accel_init+0x104> @ imm = #0x40
; 		LOG_ERR("Can't initialize bus for %s", dev->name);
 800b79a: 2303         	movs	r3, #0x3
 800b79c: 2b00         	cmp	r3, #0x0
 800b79e: d01b         	beq	0x800b7d8 <bmi08x_accel_init+0x100> @ imm = #0x36
 800b7a0: 2301         	movs	r3, #0x1
 800b7a2: f887 3023    	strb.w	r3, [r7, #0x23]
 800b7a6: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800b7aa: f083 0301    	eor	r3, r3, #0x1
 800b7ae: b2db         	uxtb	r3, r3
 800b7b0: 2b00         	cmp	r3, #0x0
 800b7b2: d111         	bne	0x800b7d8 <bmi08x_accel_init+0x100> @ imm = #0x22
 800b7b4: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800b980 <bmi08x_accel_init+0x2a8>
 800b7b6: 6819         	ldr	r1, [r3]
 800b7b8: 687b         	ldr	r3, [r7, #0x4]
 800b7ba: 681b         	ldr	r3, [r3]
 800b7bc: 9303         	str	r3, [sp, #0xc]
 800b7be: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x800b98c <bmi08x_accel_init+0x2b4>
 800b7c0: 9302         	str	r3, [sp, #0x8]
 800b7c2: 2300         	movs	r3, #0x0
 800b7c4: 9301         	str	r3, [sp, #0x4]
 800b7c6: 2300         	movs	r3, #0x0
 800b7c8: 9300         	str	r3, [sp]
 800b7ca: 2300         	movs	r3, #0x0
 800b7cc: 2201         	movs	r2, #0x1
 800b7ce: 2000         	movs	r0, #0x0
 800b7d0: f014 fc45    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x1488a
 800b7d4: 2300         	movs	r3, #0x0
 800b7d6: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 800b7d8: 6e7b         	ldr	r3, [r7, #0x64]
 800b7da: e135         	b	0x800ba48 <bmi08x_accel_init+0x370> @ imm = #0x26a
; 	ret = bmi08x_accel_byte_read(dev, BMI08X_REG_ACCEL_CHIP_ID, &val);
 800b7dc: f107 030b    	add.w	r3, r7, #0xb
 800b7e0: 461a         	mov	r2, r3
 800b7e2: 2100         	movs	r1, #0x0
 800b7e4: 6878         	ldr	r0, [r7, #0x4]
 800b7e6: f014 fdc8    	bl	0x802037a <bmi08x_accel_byte_read> @ imm = #0x14b90
 800b7ea: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800b7ec: 6e7b         	ldr	r3, [r7, #0x64]
 800b7ee: 2b00         	cmp	r3, #0x0
 800b7f0: da1d         	bge	0x800b82e <bmi08x_accel_init+0x156> @ imm = #0x3a
; 		LOG_ERR("Failed to read chip id.");
 800b7f2: 2303         	movs	r3, #0x3
 800b7f4: 2b00         	cmp	r3, #0x0
 800b7f6: d018         	beq	0x800b82a <bmi08x_accel_init+0x152> @ imm = #0x30
 800b7f8: 2301         	movs	r3, #0x1
 800b7fa: f887 302b    	strb.w	r3, [r7, #0x2b]
 800b7fe: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800b802: f083 0301    	eor	r3, r3, #0x1
 800b806: b2db         	uxtb	r3, r3
 800b808: 2b00         	cmp	r3, #0x0
 800b80a: d10e         	bne	0x800b82a <bmi08x_accel_init+0x152> @ imm = #0x1c
 800b80c: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800b980 <bmi08x_accel_init+0x2a8>
 800b80e: 6819         	ldr	r1, [r3]
 800b810: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800b990 <bmi08x_accel_init+0x2b8>
 800b812: 9302         	str	r3, [sp, #0x8]
 800b814: 2300         	movs	r3, #0x0
 800b816: 9301         	str	r3, [sp, #0x4]
 800b818: 2300         	movs	r3, #0x0
 800b81a: 9300         	str	r3, [sp]
 800b81c: 2300         	movs	r3, #0x0
 800b81e: 2201         	movs	r2, #0x1
 800b820: 2000         	movs	r0, #0x0
 800b822: f014 fc1c    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x14838
 800b826: 2300         	movs	r3, #0x0
 800b828: 627b         	str	r3, [r7, #0x24]
; 		return ret;
 800b82a: 6e7b         	ldr	r3, [r7, #0x64]
 800b82c: e10c         	b	0x800ba48 <bmi08x_accel_init+0x370> @ imm = #0x218
; 	if ((val != BMI085_ACCEL_CHIP_ID) && (val != BMI088_ACCEL_CHIP_ID)) {
 800b82e: 7afb         	ldrb	r3, [r7, #0xb]
 800b830: 2b1f         	cmp	r3, #0x1f
 800b832: d023         	beq	0x800b87c <bmi08x_accel_init+0x1a4> @ imm = #0x46
 800b834: 7afb         	ldrb	r3, [r7, #0xb]
 800b836: 2b1e         	cmp	r3, #0x1e
 800b838: d020         	beq	0x800b87c <bmi08x_accel_init+0x1a4> @ imm = #0x40
; 		LOG_ERR("Unsupported chip detected (0x%02x)!", val);
 800b83a: 2303         	movs	r3, #0x3
 800b83c: 2b00         	cmp	r3, #0x0
 800b83e: d01a         	beq	0x800b876 <bmi08x_accel_init+0x19e> @ imm = #0x34
 800b840: 2301         	movs	r3, #0x1
 800b842: f887 3063    	strb.w	r3, [r7, #0x63]
 800b846: f897 3063    	ldrb.w	r3, [r7, #0x63]
 800b84a: f083 0301    	eor	r3, r3, #0x1
 800b84e: b2db         	uxtb	r3, r3
 800b850: 2b00         	cmp	r3, #0x0
 800b852: d110         	bne	0x800b876 <bmi08x_accel_init+0x19e> @ imm = #0x20
 800b854: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x800b980 <bmi08x_accel_init+0x2a8>
 800b856: 6819         	ldr	r1, [r3]
 800b858: 7afb         	ldrb	r3, [r7, #0xb]
 800b85a: 9303         	str	r3, [sp, #0xc]
 800b85c: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800b994 <bmi08x_accel_init+0x2bc>
 800b85e: 9302         	str	r3, [sp, #0x8]
 800b860: 2300         	movs	r3, #0x0
 800b862: 9301         	str	r3, [sp, #0x4]
 800b864: 2300         	movs	r3, #0x0
 800b866: 9300         	str	r3, [sp]
 800b868: 2300         	movs	r3, #0x0
 800b86a: 2201         	movs	r2, #0x1
 800b86c: 2000         	movs	r0, #0x0
 800b86e: f014 fbf6    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x147ec
 800b872: 2300         	movs	r3, #0x0
 800b874: 657b         	str	r3, [r7, #0x54]
; 		return -ENODEV;
 800b876: f06f 0312    	mvn	r3, #0x12
 800b87a: e0e5         	b	0x800ba48 <bmi08x_accel_init+0x370> @ imm = #0x1ca
; 	data->accel_chip_id = val;
 800b87c: 7afa         	ldrb	r2, [r7, #0xb]
 800b87e: 6dbb         	ldr	r3, [r7, #0x58]
 800b880: f883 2948    	strb.w	r2, [r3, #0x948]
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_PWR_CONF, BMI08X_ACCEL_PM_ACTIVE);
 800b884: 2200         	movs	r2, #0x0
 800b886: 217c         	movs	r1, #0x7c
 800b888: 6878         	ldr	r0, [r7, #0x4]
 800b88a: f014 fdae    	bl	0x80203ea <bmi08x_accel_byte_write> @ imm = #0x14b5c
 800b88e: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800b890: 6e7b         	ldr	r3, [r7, #0x64]
 800b892: 2b00         	cmp	r3, #0x0
 800b894: da1d         	bge	0x800b8d2 <bmi08x_accel_init+0x1fa> @ imm = #0x3a
; 		LOG_ERR("Failed to set conf power mode");
 800b896: 2303         	movs	r3, #0x3
 800b898: 2b00         	cmp	r3, #0x0
 800b89a: d018         	beq	0x800b8ce <bmi08x_accel_init+0x1f6> @ imm = #0x30
 800b89c: 2301         	movs	r3, #0x1
 800b89e: f887 3033    	strb.w	r3, [r7, #0x33]
 800b8a2: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800b8a6: f083 0301    	eor	r3, r3, #0x1
 800b8aa: b2db         	uxtb	r3, r3
 800b8ac: 2b00         	cmp	r3, #0x0
 800b8ae: d10e         	bne	0x800b8ce <bmi08x_accel_init+0x1f6> @ imm = #0x1c
 800b8b0: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800b980 <bmi08x_accel_init+0x2a8>
 800b8b2: 6819         	ldr	r1, [r3]
 800b8b4: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800b998 <bmi08x_accel_init+0x2c0>
 800b8b6: 9302         	str	r3, [sp, #0x8]
 800b8b8: 2300         	movs	r3, #0x0
 800b8ba: 9301         	str	r3, [sp, #0x4]
 800b8bc: 2300         	movs	r3, #0x0
 800b8be: 9300         	str	r3, [sp]
 800b8c0: 2300         	movs	r3, #0x0
 800b8c2: 2201         	movs	r2, #0x1
 800b8c4: 2000         	movs	r0, #0x0
 800b8c6: f014 fbca    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x14794
 800b8ca: 2300         	movs	r3, #0x0
 800b8cc: 62fb         	str	r3, [r7, #0x2c]
; 		return ret;
 800b8ce: 6e7b         	ldr	r3, [r7, #0x64]
 800b8d0: e0ba         	b	0x800ba48 <bmi08x_accel_init+0x370> @ imm = #0x174
; 	k_msleep(BMI08X_POWER_CONFIG_DELAY);
 800b8d2: 2005         	movs	r0, #0x5
 800b8d4: f014 fb69    	bl	0x801ffaa <k_msleep>    @ imm = #0x146d2
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_PWR_CTRL, BMI08X_ACCEL_POWER_ENABLE);
 800b8d8: 2204         	movs	r2, #0x4
 800b8da: 217d         	movs	r1, #0x7d
 800b8dc: 6878         	ldr	r0, [r7, #0x4]
 800b8de: f014 fd84    	bl	0x80203ea <bmi08x_accel_byte_write> @ imm = #0x14b08
 800b8e2: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800b8e4: 6e7b         	ldr	r3, [r7, #0x64]
 800b8e6: 2b00         	cmp	r3, #0x0
 800b8e8: da1d         	bge	0x800b926 <bmi08x_accel_init+0x24e> @ imm = #0x3a
; 		LOG_ERR("Failed to set ctrl power mode");
 800b8ea: 2303         	movs	r3, #0x3
 800b8ec: 2b00         	cmp	r3, #0x0
 800b8ee: d018         	beq	0x800b922 <bmi08x_accel_init+0x24a> @ imm = #0x30
 800b8f0: 2301         	movs	r3, #0x1
 800b8f2: f887 303b    	strb.w	r3, [r7, #0x3b]
 800b8f6: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800b8fa: f083 0301    	eor	r3, r3, #0x1
 800b8fe: b2db         	uxtb	r3, r3
 800b900: 2b00         	cmp	r3, #0x0
 800b902: d10e         	bne	0x800b922 <bmi08x_accel_init+0x24a> @ imm = #0x1c
 800b904: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800b980 <bmi08x_accel_init+0x2a8>
 800b906: 6819         	ldr	r1, [r3]
 800b908: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800b99c <bmi08x_accel_init+0x2c4>
 800b90a: 9302         	str	r3, [sp, #0x8]
 800b90c: 2300         	movs	r3, #0x0
 800b90e: 9301         	str	r3, [sp, #0x4]
 800b910: 2300         	movs	r3, #0x0
 800b912: 9300         	str	r3, [sp]
 800b914: 2300         	movs	r3, #0x0
 800b916: 2201         	movs	r2, #0x1
 800b918: 2000         	movs	r0, #0x0
 800b91a: f014 fba0    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x14740
 800b91e: 2300         	movs	r3, #0x0
 800b920: 637b         	str	r3, [r7, #0x34]
; 		return ret;
 800b922: 6e7b         	ldr	r3, [r7, #0x64]
 800b924: e090         	b	0x800ba48 <bmi08x_accel_init+0x370> @ imm = #0x120
; 	k_msleep(BMI08X_POWER_CONFIG_DELAY);
 800b926: 2005         	movs	r0, #0x5
 800b928: f014 fb3f    	bl	0x801ffaa <k_msleep>    @ imm = #0x1467e
; 	ret = bmi08x_acc_range_set(dev, config->accel_fs);
 800b92c: 6dfb         	ldr	r3, [r7, #0x5c]
 800b92e: f893 3029    	ldrb.w	r3, [r3, #0x29]
 800b932: 4619         	mov	r1, r3
 800b934: 6878         	ldr	r0, [r7, #0x4]
 800b936: f7ff fc1d    	bl	0x800b174 <bmi08x_acc_range_set> @ imm = #-0x7c6
 800b93a: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800b93c: 6e7b         	ldr	r3, [r7, #0x64]
 800b93e: 2b00         	cmp	r3, #0x0
 800b940: da30         	bge	0x800b9a4 <bmi08x_accel_init+0x2cc> @ imm = #0x60
; 		LOG_ERR("Cannot set default range for accelerometer.");
 800b942: 2303         	movs	r3, #0x3
 800b944: 2b00         	cmp	r3, #0x0
 800b946: d018         	beq	0x800b97a <bmi08x_accel_init+0x2a2> @ imm = #0x30
 800b948: 2301         	movs	r3, #0x1
 800b94a: f887 3043    	strb.w	r3, [r7, #0x43]
 800b94e: f897 3043    	ldrb.w	r3, [r7, #0x43]
 800b952: f083 0301    	eor	r3, r3, #0x1
 800b956: b2db         	uxtb	r3, r3
 800b958: 2b00         	cmp	r3, #0x0
 800b95a: d10e         	bne	0x800b97a <bmi08x_accel_init+0x2a2> @ imm = #0x1c
 800b95c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800b980 <bmi08x_accel_init+0x2a8>
 800b95e: 6819         	ldr	r1, [r3]
 800b960: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800b9a0 <bmi08x_accel_init+0x2c8>
 800b962: 9302         	str	r3, [sp, #0x8]
 800b964: 2300         	movs	r3, #0x0
 800b966: 9301         	str	r3, [sp, #0x4]
 800b968: 2300         	movs	r3, #0x0
 800b96a: 9300         	str	r3, [sp]
 800b96c: 2300         	movs	r3, #0x0
 800b96e: 2201         	movs	r2, #0x1
 800b970: 2000         	movs	r0, #0x0
 800b972: f014 fb74    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x146e8
 800b976: 2300         	movs	r3, #0x0
 800b978: 63fb         	str	r3, [r7, #0x3c]
; 		return ret;
 800b97a: 6e7b         	ldr	r3, [r7, #0x64]
 800b97c: e064         	b	0x800ba48 <bmi08x_accel_init+0x370> @ imm = #0xc8
 800b97e: bf00         	nop

0800b980 <$d>:
 800b980: 40 05 00 20  	.word	0x20000540
 800b984: ac 95 02 08  	.word	0x080295ac
 800b988: c4 95 02 08  	.word	0x080295c4
 800b98c: d8 95 02 08  	.word	0x080295d8
 800b990: f4 95 02 08  	.word	0x080295f4
 800b994: 0c 96 02 08  	.word	0x0802960c
 800b998: 30 96 02 08  	.word	0x08029630
 800b99c: 50 96 02 08  	.word	0x08029650
 800b9a0: 70 96 02 08  	.word	0x08029670

0800b9a4 <$t>:
; 					    config->accel_hz);
 800b9a4: 6dfb         	ldr	r3, [r7, #0x5c]
 800b9a6: f893 3028    	ldrb.w	r3, [r3, #0x28]
; 	ret = bmi08x_accel_reg_field_update(dev, BMI08X_REG_ACCEL_CONF, 0, BMI08X_ACCEL_ODR_MASK,
 800b9aa: 9300         	str	r3, [sp]
 800b9ac: 230f         	movs	r3, #0xf
 800b9ae: 2200         	movs	r2, #0x0
 800b9b0: 2140         	movs	r1, #0x40
 800b9b2: 6878         	ldr	r0, [r7, #0x4]
 800b9b4: f014 fd31    	bl	0x802041a <bmi08x_accel_reg_field_update> @ imm = #0x14a62
 800b9b8: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800b9ba: 6e7b         	ldr	r3, [r7, #0x64]
 800b9bc: 2b00         	cmp	r3, #0x0
 800b9be: da1d         	bge	0x800b9fc <bmi08x_accel_init+0x324> @ imm = #0x3a
; 		LOG_ERR("Failed to set accel's default ODR.");
 800b9c0: 2303         	movs	r3, #0x3
 800b9c2: 2b00         	cmp	r3, #0x0
 800b9c4: d018         	beq	0x800b9f8 <bmi08x_accel_init+0x320> @ imm = #0x30
 800b9c6: 2301         	movs	r3, #0x1
 800b9c8: f887 304b    	strb.w	r3, [r7, #0x4b]
 800b9cc: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 800b9d0: f083 0301    	eor	r3, r3, #0x1
 800b9d4: b2db         	uxtb	r3, r3
 800b9d6: 2b00         	cmp	r3, #0x0
 800b9d8: d10e         	bne	0x800b9f8 <bmi08x_accel_init+0x320> @ imm = #0x1c
 800b9da: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800ba50 <bmi08x_accel_init+0x378>
 800b9dc: 6819         	ldr	r1, [r3]
 800b9de: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800ba54 <bmi08x_accel_init+0x37c>
 800b9e0: 9302         	str	r3, [sp, #0x8]
 800b9e2: 2300         	movs	r3, #0x0
 800b9e4: 9301         	str	r3, [sp, #0x4]
 800b9e6: 2300         	movs	r3, #0x0
 800b9e8: 9300         	str	r3, [sp]
 800b9ea: 2300         	movs	r3, #0x0
 800b9ec: 2201         	movs	r2, #0x1
 800b9ee: 2000         	movs	r0, #0x0
 800b9f0: f014 fb35    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x1466a
 800b9f4: 2300         	movs	r3, #0x0
 800b9f6: 647b         	str	r3, [r7, #0x44]
; 		return ret;
 800b9f8: 6e7b         	ldr	r3, [r7, #0x64]
 800b9fa: e025         	b	0x800ba48 <bmi08x_accel_init+0x370> @ imm = #0x4a
; 	ret = bmi08x_acc_trigger_mode_init(dev);
 800b9fc: 6878         	ldr	r0, [r7, #0x4]
 800b9fe: f000 fc61    	bl	0x800c2c4 <bmi08x_acc_trigger_mode_init> @ imm = #0x8c2
 800ba02: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800ba04: 6e7b         	ldr	r3, [r7, #0x64]
 800ba06: 2b00         	cmp	r3, #0x0
 800ba08: da1d         	bge	0x800ba46 <bmi08x_accel_init+0x36e> @ imm = #0x3a
; 		LOG_ERR("Cannot set up trigger mode.");
 800ba0a: 2303         	movs	r3, #0x3
 800ba0c: 2b00         	cmp	r3, #0x0
 800ba0e: d018         	beq	0x800ba42 <bmi08x_accel_init+0x36a> @ imm = #0x30
 800ba10: 2301         	movs	r3, #0x1
 800ba12: f887 3053    	strb.w	r3, [r7, #0x53]
 800ba16: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800ba1a: f083 0301    	eor	r3, r3, #0x1
 800ba1e: b2db         	uxtb	r3, r3
 800ba20: 2b00         	cmp	r3, #0x0
 800ba22: d10e         	bne	0x800ba42 <bmi08x_accel_init+0x36a> @ imm = #0x1c
 800ba24: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800ba50 <bmi08x_accel_init+0x378>
 800ba26: 6819         	ldr	r1, [r3]
 800ba28: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ba58 <bmi08x_accel_init+0x380>
 800ba2a: 9302         	str	r3, [sp, #0x8]
 800ba2c: 2300         	movs	r3, #0x0
 800ba2e: 9301         	str	r3, [sp, #0x4]
 800ba30: 2300         	movs	r3, #0x0
 800ba32: 9300         	str	r3, [sp]
 800ba34: 2300         	movs	r3, #0x0
 800ba36: 2201         	movs	r2, #0x1
 800ba38: 2000         	movs	r0, #0x0
 800ba3a: f014 fb10    	bl	0x802005e <z_log_msg_runtime_create> @ imm = #0x14620
 800ba3e: 2300         	movs	r3, #0x0
 800ba40: 64fb         	str	r3, [r7, #0x4c]
; 		return ret;
 800ba42: 6e7b         	ldr	r3, [r7, #0x64]
 800ba44: e000         	b	0x800ba48 <bmi08x_accel_init+0x370> @ imm = #0x0
; 	return ret;
 800ba46: 6e7b         	ldr	r3, [r7, #0x64]
; }
 800ba48: 4618         	mov	r0, r3
 800ba4a: 3768         	adds	r7, #0x68
 800ba4c: 46bd         	mov	sp, r7
 800ba4e: bd80         	pop	{r7, pc}

0800ba50 <$d>:
 800ba50: 40 05 00 20  	.word	0x20000540
 800ba54: 9c 96 02 08  	.word	0x0802969c
 800ba58: c0 96 02 08  	.word	0x080296c0

0800ba5c <bmi08x_gyr_range_set>:
; {
 800ba5c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800ba60: b08c         	sub	sp, #0x30
 800ba62: af00         	add	r7, sp, #0x0
 800ba64: 61f8         	str	r0, [r7, #0x1c]
 800ba66: 460b         	mov	r3, r1
 800ba68: 837b         	strh	r3, [r7, #0x1a]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 800ba6a: 69fb         	ldr	r3, [r7, #0x1c]
 800ba6c: 691b         	ldr	r3, [r3, #0x10]
 800ba6e: 62fb         	str	r3, [r7, #0x2c]
; 		bmi08x_range_to_reg_val(range, bmi08x_gyr_range_map, BMI08X_GYR_RANGE_MAP_SIZE);
 800ba70: 8b7b         	ldrh	r3, [r7, #0x1a]
 800ba72: 2205         	movs	r2, #0x5
 800ba74: 493d         	ldr	r1, [pc, #0xf4]         @ 0x800bb6c <bmi08x_gyr_range_set+0x110>
 800ba76: 4618         	mov	r0, r3
 800ba78: f014 fff3    	bl	0x8020a62 <bmi08x_range_to_reg_val> @ imm = #0x14fe6
 800ba7c: 62b8         	str	r0, [r7, #0x28]
; 	if (reg_val < 0) {
 800ba7e: 6abb         	ldr	r3, [r7, #0x28]
 800ba80: 2b00         	cmp	r3, #0x0
 800ba82: da01         	bge	0x800ba88 <bmi08x_gyr_range_set+0x2c> @ imm = #0x2
; 		return reg_val;
 800ba84: 6abb         	ldr	r3, [r7, #0x28]
 800ba86: e06c         	b	0x800bb62 <bmi08x_gyr_range_set+0x106> @ imm = #0xd8
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_RANGE, reg_val);
 800ba88: 6abb         	ldr	r3, [r7, #0x28]
 800ba8a: b2db         	uxtb	r3, r3
 800ba8c: 461a         	mov	r2, r3
 800ba8e: 210f         	movs	r1, #0xf
 800ba90: 69f8         	ldr	r0, [r7, #0x1c]
 800ba92: f014 ff4a    	bl	0x802092a <bmi08x_gyro_byte_write> @ imm = #0x14e94
 800ba96: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 800ba98: 6a7b         	ldr	r3, [r7, #0x24]
 800ba9a: 2b00         	cmp	r3, #0x0
 800ba9c: da01         	bge	0x800baa2 <bmi08x_gyr_range_set+0x46> @ imm = #0x2
; 		return ret;
 800ba9e: 6a7b         	ldr	r3, [r7, #0x24]
 800baa0: e05f         	b	0x800bb62 <bmi08x_gyr_range_set+0x106> @ imm = #0xbe
; 	bmi08x->scale = BMI08X_GYR_SCALE(range);
 800baa2: 8b7b         	ldrh	r3, [r7, #0x1a]
 800baa4: 2200         	movs	r2, #0x0
 800baa6: 461c         	mov	r4, r3
 800baa8: 4615         	mov	r5, r2
 800baaa: 4622         	mov	r2, r4
 800baac: 462b         	mov	r3, r5
 800baae: 1891         	adds	r1, r2, r2
 800bab0: 60b9         	str	r1, [r7, #0x8]
 800bab2: 415b         	adcs	r3, r3
 800bab4: 60fb         	str	r3, [r7, #0xc]
 800bab6: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800baba: 1911         	adds	r1, r2, r4
 800babc: 6139         	str	r1, [r7, #0x10]
 800babe: 416b         	adcs	r3, r5
 800bac0: 617b         	str	r3, [r7, #0x14]
 800bac2: f04f 0200    	mov.w	r2, #0x0
 800bac6: f04f 0300    	mov.w	r3, #0x0
 800baca: 6979         	ldr	r1, [r7, #0x14]
 800bacc: 020b         	lsls	r3, r1, #0x8
 800bace: 6939         	ldr	r1, [r7, #0x10]
 800bad0: ea43 6311    	orr.w	r3, r3, r1, lsr #24
 800bad4: 6939         	ldr	r1, [r7, #0x10]
 800bad6: 020a         	lsls	r2, r1, #0x8
 800bad8: 4611         	mov	r1, r2
 800bada: 461a         	mov	r2, r3
 800badc: 460b         	mov	r3, r1
 800bade: ebb3 0a04    	subs.w	r10, r3, r4
 800bae2: 4613         	mov	r3, r2
 800bae4: eb63 0b05    	sbc.w	r11, r3, r5
 800bae8: f04f 0200    	mov.w	r2, #0x0
 800baec: f04f 0300    	mov.w	r3, #0x0
 800baf0: ea4f 13cb    	lsl.w	r3, r11, #0x7
 800baf4: ea43 635a    	orr.w	r3, r3, r10, lsr #25
 800baf8: ea4f 12ca    	lsl.w	r2, r10, #0x7
 800bafc: 4692         	mov	r10, r2
 800bafe: 469b         	mov	r11, r3
 800bb00: ebba 0804    	subs.w	r8, r10, r4
 800bb04: eb6b 0905    	sbc.w	r9, r11, r5
 800bb08: f04f 0200    	mov.w	r2, #0x0
 800bb0c: f04f 0300    	mov.w	r3, #0x0
 800bb10: ea4f 0389    	lsl.w	r3, r9, #0x2
 800bb14: ea43 7398    	orr.w	r3, r3, r8, lsr #30
 800bb18: ea4f 0288    	lsl.w	r2, r8, #0x2
 800bb1c: 4690         	mov	r8, r2
 800bb1e: 4699         	mov	r9, r3
 800bb20: ebb8 0304    	subs.w	r3, r8, r4
 800bb24: 603b         	str	r3, [r7]
 800bb26: eb69 0305    	sbc.w	r3, r9, r5
 800bb2a: 607b         	str	r3, [r7, #0x4]
 800bb2c: f04f 0200    	mov.w	r2, #0x0
 800bb30: f04f 0300    	mov.w	r3, #0x0
 800bb34: e9d7 4500    	ldrd	r4, r5, [r7]
 800bb38: 4629         	mov	r1, r5
 800bb3a: 010b         	lsls	r3, r1, #0x4
 800bb3c: 4621         	mov	r1, r4
 800bb3e: ea43 7311    	orr.w	r3, r3, r1, lsr #28
 800bb42: 4621         	mov	r1, r4
 800bb44: 010a         	lsls	r2, r1, #0x4
 800bb46: 4610         	mov	r0, r2
 800bb48: 4619         	mov	r1, r3
 800bb4a: f44f 0234    	mov.w	r2, #0xb40000
 800bb4e: f04f 0300    	mov.w	r3, #0x0
 800bb52: f7f4 fd25    	bl	0x80005a0 <__aeabi_ldivmod> @ imm = #-0xb5b6
 800bb56: 4602         	mov	r2, r0
 800bb58: 460b         	mov	r3, r1
 800bb5a: b292         	uxth	r2, r2
 800bb5c: 6afb         	ldr	r3, [r7, #0x2c]
 800bb5e: 825a         	strh	r2, [r3, #0x12]
; 	return ret;
 800bb60: 6a7b         	ldr	r3, [r7, #0x24]
; }
 800bb62: 4618         	mov	r0, r3
 800bb64: 3730         	adds	r7, #0x30
 800bb66: 46bd         	mov	sp, r7
 800bb68: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800bb6c <$d>:
 800bb6c: 24 ad 02 08  	.word	0x0802ad24

0800bb70 <bmi08x_gyr_config>:
; {
 800bb70: b580         	push	{r7, lr}
 800bb72: b08a         	sub	sp, #0x28
 800bb74: af04         	add	r7, sp, #0x10
 800bb76: 60f8         	str	r0, [r7, #0xc]
 800bb78: 607b         	str	r3, [r7, #0x4]
 800bb7a: 460b         	mov	r3, r1
 800bb7c: 817b         	strh	r3, [r7, #0xa]
 800bb7e: 4613         	mov	r3, r2
 800bb80: 813b         	strh	r3, [r7, #0x8]
; 	switch (attr) {
 800bb82: 893b         	ldrh	r3, [r7, #0x8]
 800bb84: 2b00         	cmp	r3, #0x0
 800bb86: d00c         	beq	0x800bba2 <bmi08x_gyr_config+0x32> @ imm = #0x18
 800bb88: 2b07         	cmp	r3, #0x7
 800bb8a: d11c         	bne	0x800bbc6 <bmi08x_gyr_config+0x56> @ imm = #0x38
; 		return bmi08x_gyr_range_set(dev, sensor_rad_to_degrees(val));
 800bb8c: 6878         	ldr	r0, [r7, #0x4]
 800bb8e: f7f4 ff63    	bl	0x8000a58 <sensor_rad_to_degrees> @ imm = #-0xb13a
 800bb92: 4603         	mov	r3, r0
 800bb94: b29b         	uxth	r3, r3
 800bb96: 4619         	mov	r1, r3
 800bb98: 68f8         	ldr	r0, [r7, #0xc]
 800bb9a: f7ff ff5f    	bl	0x800ba5c <bmi08x_gyr_range_set> @ imm = #-0x142
 800bb9e: 4603         	mov	r3, r0
 800bba0: e02f         	b	0x800bc02 <bmi08x_gyr_config+0x92> @ imm = #0x5e
; 		return bmi08x_gyr_odr_set(dev, val->val1, val->val2 / 1000);
 800bba2: 687b         	ldr	r3, [r7, #0x4]
 800bba4: 681b         	ldr	r3, [r3]
 800bba6: b299         	uxth	r1, r3
 800bba8: 687b         	ldr	r3, [r7, #0x4]
 800bbaa: 685b         	ldr	r3, [r3, #0x4]
 800bbac: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800bc0c <bmi08x_gyr_config+0x9c>
 800bbae: fb82 0203    	smull	r0, r2, r2, r3
 800bbb2: 1192         	asrs	r2, r2, #0x6
 800bbb4: 17db         	asrs	r3, r3, #0x1f
 800bbb6: 1ad3         	subs	r3, r2, r3
 800bbb8: b29b         	uxth	r3, r3
 800bbba: 461a         	mov	r2, r3
 800bbbc: 68f8         	ldr	r0, [r7, #0xc]
 800bbbe: f014 fecc    	bl	0x802095a <bmi08x_gyr_odr_set> @ imm = #0x14d98
 800bbc2: 4603         	mov	r3, r0
 800bbc4: e01d         	b	0x800bc02 <bmi08x_gyr_config+0x92> @ imm = #0x3a
; 		LOG_DBG("Gyro attribute not supported.");
 800bbc6: 2303         	movs	r3, #0x3
 800bbc8: 2b03         	cmp	r3, #0x3
 800bbca: d918         	bls	0x800bbfe <bmi08x_gyr_config+0x8e> @ imm = #0x30
 800bbcc: 2301         	movs	r3, #0x1
 800bbce: 75fb         	strb	r3, [r7, #0x17]
 800bbd0: 7dfb         	ldrb	r3, [r7, #0x17]
 800bbd2: f083 0301    	eor	r3, r3, #0x1
 800bbd6: b2db         	uxtb	r3, r3
 800bbd8: 2b00         	cmp	r3, #0x0
 800bbda: d110         	bne	0x800bbfe <bmi08x_gyr_config+0x8e> @ imm = #0x20
 800bbdc: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800bc10 <bmi08x_gyr_config+0xa0>
 800bbde: 6819         	ldr	r1, [r3]
 800bbe0: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800bc14 <bmi08x_gyr_config+0xa4>
 800bbe2: 9303         	str	r3, [sp, #0xc]
 800bbe4: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800bc18 <bmi08x_gyr_config+0xa8>
 800bbe6: 9302         	str	r3, [sp, #0x8]
 800bbe8: 2308         	movs	r3, #0x8
 800bbea: 9301         	str	r3, [sp, #0x4]
 800bbec: 2300         	movs	r3, #0x0
 800bbee: 9300         	str	r3, [sp]
 800bbf0: 2300         	movs	r3, #0x0
 800bbf2: 2204         	movs	r2, #0x4
 800bbf4: 2000         	movs	r0, #0x0
 800bbf6: f014 fd0b    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x14a16
 800bbfa: 2300         	movs	r3, #0x0
 800bbfc: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800bbfe: f06f 0385    	mvn	r3, #0x85
; }
 800bc02: 4618         	mov	r0, r3
 800bc04: 3718         	adds	r7, #0x18
 800bc06: 46bd         	mov	sp, r7
 800bc08: bd80         	pop	{r7, pc}
 800bc0a: bf00         	nop

0800bc0c <$d>:
 800bc0c: d3 4d 62 10  	.word	0x10624dd3
 800bc10: 44 05 00 20  	.word	0x20000544
 800bc14: 64 ad 02 08  	.word	0x0802ad64
 800bc18: f8 96 02 08  	.word	0x080296f8

0800bc1c <bmi08x_attr_set>:
; {
 800bc1c: b580         	push	{r7, lr}
 800bc1e: b08a         	sub	sp, #0x28
 800bc20: af04         	add	r7, sp, #0x10
 800bc22: 60f8         	str	r0, [r7, #0xc]
 800bc24: 607b         	str	r3, [r7, #0x4]
 800bc26: 460b         	mov	r3, r1
 800bc28: 817b         	strh	r3, [r7, #0xa]
 800bc2a: 4613         	mov	r3, r2
 800bc2c: 813b         	strh	r3, [r7, #0x8]
; 	switch (chan) {
 800bc2e: 897b         	ldrh	r3, [r7, #0xa]
 800bc30: 3b04         	subs	r3, #0x4
 800bc32: 2b03         	cmp	r3, #0x3
 800bc34: d807         	bhi	0x800bc46 <bmi08x_attr_set+0x2a> @ imm = #0xe
; 		return bmi08x_gyr_config(dev, chan, attr, val);
 800bc36: 893a         	ldrh	r2, [r7, #0x8]
 800bc38: 8979         	ldrh	r1, [r7, #0xa]
 800bc3a: 687b         	ldr	r3, [r7, #0x4]
 800bc3c: 68f8         	ldr	r0, [r7, #0xc]
 800bc3e: f7ff ff97    	bl	0x800bb70 <bmi08x_gyr_config> @ imm = #-0xd2
 800bc42: 4603         	mov	r3, r0
 800bc44: e01d         	b	0x800bc82 <bmi08x_attr_set+0x66> @ imm = #0x3a
; 		LOG_DBG("attr_set() not supported on this channel.");
 800bc46: 2303         	movs	r3, #0x3
 800bc48: 2b03         	cmp	r3, #0x3
 800bc4a: d918         	bls	0x800bc7e <bmi08x_attr_set+0x62> @ imm = #0x30
 800bc4c: 2301         	movs	r3, #0x1
 800bc4e: 75fb         	strb	r3, [r7, #0x17]
 800bc50: 7dfb         	ldrb	r3, [r7, #0x17]
 800bc52: f083 0301    	eor	r3, r3, #0x1
 800bc56: b2db         	uxtb	r3, r3
 800bc58: 2b00         	cmp	r3, #0x0
 800bc5a: d110         	bne	0x800bc7e <bmi08x_attr_set+0x62> @ imm = #0x20
 800bc5c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800bc8c <bmi08x_attr_set+0x70>
 800bc5e: 6819         	ldr	r1, [r3]
 800bc60: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800bc90 <bmi08x_attr_set+0x74>
 800bc62: 9303         	str	r3, [sp, #0xc]
 800bc64: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800bc94 <bmi08x_attr_set+0x78>
 800bc66: 9302         	str	r3, [sp, #0x8]
 800bc68: 2308         	movs	r3, #0x8
 800bc6a: 9301         	str	r3, [sp, #0x4]
 800bc6c: 2300         	movs	r3, #0x0
 800bc6e: 9300         	str	r3, [sp]
 800bc70: 2300         	movs	r3, #0x0
 800bc72: 2204         	movs	r2, #0x4
 800bc74: 2000         	movs	r0, #0x0
 800bc76: f014 fccb    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x14996
 800bc7a: 2300         	movs	r3, #0x0
 800bc7c: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800bc7e: f06f 0385    	mvn	r3, #0x85
; }
 800bc82: 4618         	mov	r0, r3
 800bc84: 3718         	adds	r7, #0x18
 800bc86: 46bd         	mov	sp, r7
 800bc88: bd80         	pop	{r7, pc}
 800bc8a: bf00         	nop

0800bc8c <$d>:
 800bc8c: 44 05 00 20  	.word	0x20000544
 800bc90: 78 ad 02 08  	.word	0x0802ad78
 800bc94: 1c 97 02 08  	.word	0x0802971c

0800bc98 <bmi08x_sample_fetch>:
; {
 800bc98: b580         	push	{r7, lr}
 800bc9a: b08c         	sub	sp, #0x30
 800bc9c: af04         	add	r7, sp, #0x10
 800bc9e: 6078         	str	r0, [r7, #0x4]
 800bca0: 460b         	mov	r3, r1
 800bca2: 807b         	strh	r3, [r7, #0x2]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 800bca4: 687b         	ldr	r3, [r7, #0x4]
 800bca6: 691b         	ldr	r3, [r3, #0x10]
 800bca8: 61bb         	str	r3, [r7, #0x18]
; 	if (chan != SENSOR_CHAN_ALL && chan != SENSOR_CHAN_GYRO_XYZ) {
 800bcaa: 887b         	ldrh	r3, [r7, #0x2]
 800bcac: 2b3c         	cmp	r3, #0x3c
 800bcae: d021         	beq	0x800bcf4 <bmi08x_sample_fetch+0x5c> @ imm = #0x42
 800bcb0: 887b         	ldrh	r3, [r7, #0x2]
 800bcb2: 2b07         	cmp	r3, #0x7
 800bcb4: d01e         	beq	0x800bcf4 <bmi08x_sample_fetch+0x5c> @ imm = #0x3c
; 		LOG_DBG("Unsupported sensor channel");
 800bcb6: 2303         	movs	r3, #0x3
 800bcb8: 2b03         	cmp	r3, #0x3
 800bcba: d918         	bls	0x800bcee <bmi08x_sample_fetch+0x56> @ imm = #0x30
 800bcbc: 2301         	movs	r3, #0x1
 800bcbe: 75fb         	strb	r3, [r7, #0x17]
 800bcc0: 7dfb         	ldrb	r3, [r7, #0x17]
 800bcc2: f083 0301    	eor	r3, r3, #0x1
 800bcc6: b2db         	uxtb	r3, r3
 800bcc8: 2b00         	cmp	r3, #0x0
 800bcca: d110         	bne	0x800bcee <bmi08x_sample_fetch+0x56> @ imm = #0x20
 800bccc: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800bd48 <bmi08x_sample_fetch+0xb0>
 800bcce: 6819         	ldr	r1, [r3]
 800bcd0: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800bd4c <bmi08x_sample_fetch+0xb4>
 800bcd2: 9303         	str	r3, [sp, #0xc]
 800bcd4: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800bd50 <bmi08x_sample_fetch+0xb8>
 800bcd6: 9302         	str	r3, [sp, #0x8]
 800bcd8: 2308         	movs	r3, #0x8
 800bcda: 9301         	str	r3, [sp, #0x4]
 800bcdc: 2300         	movs	r3, #0x0
 800bcde: 9300         	str	r3, [sp]
 800bce0: 2300         	movs	r3, #0x0
 800bce2: 2204         	movs	r2, #0x4
 800bce4: 2000         	movs	r0, #0x0
 800bce6: f014 fc93    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x14926
 800bcea: 2300         	movs	r3, #0x0
 800bcec: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800bcee: f06f 0385    	mvn	r3, #0x85
 800bcf2: e024         	b	0x800bd3e <bmi08x_sample_fetch+0xa6> @ imm = #0x48
; 	ret = bmi08x_gyro_read(dev, BMI08X_REG_GYRO_X_LSB, (uint8_t *)bmi08x->gyr_sample,
 800bcf4: 69bb         	ldr	r3, [r7, #0x18]
 800bcf6: f103 020c    	add.w	r2, r3, #0xc
 800bcfa: 2306         	movs	r3, #0x6
 800bcfc: 2102         	movs	r1, #0x2
 800bcfe: 6878         	ldr	r0, [r7, #0x4]
 800bd00: f014 fde2    	bl	0x80208c8 <bmi08x_gyro_read> @ imm = #0x14bc4
 800bd04: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 800bd06: 68fb         	ldr	r3, [r7, #0xc]
 800bd08: 2b00         	cmp	r3, #0x0
 800bd0a: da01         	bge	0x800bd10 <bmi08x_sample_fetch+0x78> @ imm = #0x2
; 		return ret;
 800bd0c: 68fb         	ldr	r3, [r7, #0xc]
 800bd0e: e016         	b	0x800bd3e <bmi08x_sample_fetch+0xa6> @ imm = #0x2c
; 	for (i = 0; i < ARRAY_SIZE(bmi08x->gyr_sample); i++) {
 800bd10: 2300         	movs	r3, #0x0
 800bd12: 61fb         	str	r3, [r7, #0x1c]
 800bd14: e00f         	b	0x800bd36 <bmi08x_sample_fetch+0x9e> @ imm = #0x1e
; 		bmi08x->gyr_sample[i] = sys_le16_to_cpu(bmi08x->gyr_sample[i]);
 800bd16: 69ba         	ldr	r2, [r7, #0x18]
 800bd18: 69fb         	ldr	r3, [r7, #0x1c]
 800bd1a: 3304         	adds	r3, #0x4
 800bd1c: 005b         	lsls	r3, r3, #0x1
 800bd1e: 4413         	add	r3, r2
 800bd20: 8899         	ldrh	r1, [r3, #0x4]
 800bd22: 69ba         	ldr	r2, [r7, #0x18]
 800bd24: 69fb         	ldr	r3, [r7, #0x1c]
 800bd26: 3304         	adds	r3, #0x4
 800bd28: 005b         	lsls	r3, r3, #0x1
 800bd2a: 4413         	add	r3, r2
 800bd2c: 460a         	mov	r2, r1
 800bd2e: 809a         	strh	r2, [r3, #0x4]
; 	for (i = 0; i < ARRAY_SIZE(bmi08x->gyr_sample); i++) {
 800bd30: 69fb         	ldr	r3, [r7, #0x1c]
 800bd32: 3301         	adds	r3, #0x1
 800bd34: 61fb         	str	r3, [r7, #0x1c]
 800bd36: 69fb         	ldr	r3, [r7, #0x1c]
 800bd38: 2b02         	cmp	r3, #0x2
 800bd3a: d9ec         	bls	0x800bd16 <bmi08x_sample_fetch+0x7e> @ imm = #-0x28
; 	return ret;
 800bd3c: 68fb         	ldr	r3, [r7, #0xc]
; }
 800bd3e: 4618         	mov	r0, r3
 800bd40: 3720         	adds	r7, #0x20
 800bd42: 46bd         	mov	sp, r7
 800bd44: bd80         	pop	{r7, pc}
 800bd46: bf00         	nop

0800bd48 <$d>:
 800bd48: 44 05 00 20  	.word	0x20000544
 800bd4c: 88 ad 02 08  	.word	0x0802ad88
 800bd50: 4c 97 02 08  	.word	0x0802974c

0800bd54 <bmi08x_to_fixed_point>:
; {
 800bd54: b480         	push	{r7}
 800bd56: b085         	sub	sp, #0x14
 800bd58: af00         	add	r7, sp, #0x0
 800bd5a: 4603         	mov	r3, r0
 800bd5c: 603a         	str	r2, [r7]
 800bd5e: 80fb         	strh	r3, [r7, #0x6]
 800bd60: 460b         	mov	r3, r1
 800bd62: 80bb         	strh	r3, [r7, #0x4]
; 	converted_val = raw_val * scale;
 800bd64: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 800bd68: 88ba         	ldrh	r2, [r7, #0x4]
 800bd6a: fb02 f303    	mul	r3, r2, r3
 800bd6e: 60fb         	str	r3, [r7, #0xc]
; 	val->val1 = converted_val / 1000000;
 800bd70: 68fb         	ldr	r3, [r7, #0xc]
 800bd72: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800bda8 <bmi08x_to_fixed_point+0x54>
 800bd74: fb82 1203    	smull	r1, r2, r2, r3
 800bd78: 1492         	asrs	r2, r2, #0x12
 800bd7a: 17db         	asrs	r3, r3, #0x1f
 800bd7c: 1ad2         	subs	r2, r2, r3
 800bd7e: 683b         	ldr	r3, [r7]
 800bd80: 601a         	str	r2, [r3]
; 	val->val2 = converted_val % 1000000;
 800bd82: 68fa         	ldr	r2, [r7, #0xc]
 800bd84: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800bda8 <bmi08x_to_fixed_point+0x54>
 800bd86: fb83 1302    	smull	r1, r3, r3, r2
 800bd8a: 1499         	asrs	r1, r3, #0x12
 800bd8c: 17d3         	asrs	r3, r2, #0x1f
 800bd8e: 1acb         	subs	r3, r1, r3
 800bd90: 4906         	ldr	r1, [pc, #0x18]         @ 0x800bdac <bmi08x_to_fixed_point+0x58>
 800bd92: fb01 f303    	mul	r3, r1, r3
 800bd96: 1ad3         	subs	r3, r2, r3
 800bd98: 683a         	ldr	r2, [r7]
 800bd9a: 6053         	str	r3, [r2, #0x4]
; }
 800bd9c: bf00         	nop
 800bd9e: 3714         	adds	r7, #0x14
 800bda0: 46bd         	mov	sp, r7
 800bda2: f85d 7b04    	ldr	r7, [sp], #4
 800bda6: 4770         	bx	lr

0800bda8 <$d>:
 800bda8: 83 de 1b 43  	.word	0x431bde83
 800bdac: 40 42 0f 00  	.word	0x000f4240

0800bdb0 <bmi08x_channel_get>:
; {
 800bdb0: b580         	push	{r7, lr}
 800bdb2: b08a         	sub	sp, #0x28
 800bdb4: af04         	add	r7, sp, #0x10
 800bdb6: 60f8         	str	r0, [r7, #0xc]
 800bdb8: 460b         	mov	r3, r1
 800bdba: 607a         	str	r2, [r7, #0x4]
 800bdbc: 817b         	strh	r3, [r7, #0xa]
; 	switch ((int16_t)chan) {
 800bdbe: f9b7 300a    	ldrsh.w	r3, [r7, #0xa]
 800bdc2: 3b04         	subs	r3, #0x4
 800bdc4: 2b03         	cmp	r3, #0x3
 800bdc6: d807         	bhi	0x800bdd8 <bmi08x_channel_get+0x28> @ imm = #0xe
; 		bmi08x_gyr_channel_get(dev, chan, val);
 800bdc8: 897b         	ldrh	r3, [r7, #0xa]
 800bdca: 687a         	ldr	r2, [r7, #0x4]
 800bdcc: 4619         	mov	r1, r3
 800bdce: 68f8         	ldr	r0, [r7, #0xc]
 800bdd0: f014 fe30    	bl	0x8020a34 <bmi08x_gyr_channel_get> @ imm = #0x14c60
; 		return 0;
 800bdd4: 2300         	movs	r3, #0x0
 800bdd6: e01d         	b	0x800be14 <bmi08x_channel_get+0x64> @ imm = #0x3a
; 		LOG_DBG("Channel not supported.");
 800bdd8: 2303         	movs	r3, #0x3
 800bdda: 2b03         	cmp	r3, #0x3
 800bddc: d918         	bls	0x800be10 <bmi08x_channel_get+0x60> @ imm = #0x30
 800bdde: 2301         	movs	r3, #0x1
 800bde0: 75fb         	strb	r3, [r7, #0x17]
 800bde2: 7dfb         	ldrb	r3, [r7, #0x17]
 800bde4: f083 0301    	eor	r3, r3, #0x1
 800bde8: b2db         	uxtb	r3, r3
 800bdea: 2b00         	cmp	r3, #0x0
 800bdec: d110         	bne	0x800be10 <bmi08x_channel_get+0x60> @ imm = #0x20
 800bdee: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800be1c <bmi08x_channel_get+0x6c>
 800bdf0: 6819         	ldr	r1, [r3]
 800bdf2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800be20 <bmi08x_channel_get+0x70>
 800bdf4: 9303         	str	r3, [sp, #0xc]
 800bdf6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800be24 <bmi08x_channel_get+0x74>
 800bdf8: 9302         	str	r3, [sp, #0x8]
 800bdfa: 2308         	movs	r3, #0x8
 800bdfc: 9301         	str	r3, [sp, #0x4]
 800bdfe: 2300         	movs	r3, #0x0
 800be00: 9300         	str	r3, [sp]
 800be02: 2300         	movs	r3, #0x0
 800be04: 2204         	movs	r2, #0x4
 800be06: 2000         	movs	r0, #0x0
 800be08: f014 fc02    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x14804
 800be0c: 2300         	movs	r3, #0x0
 800be0e: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800be10: f06f 0385    	mvn	r3, #0x85
; }
 800be14: 4618         	mov	r0, r3
 800be16: 3718         	adds	r7, #0x18
 800be18: 46bd         	mov	sp, r7
 800be1a: bd80         	pop	{r7, pc}

0800be1c <$d>:
 800be1c: 44 05 00 20  	.word	0x20000544
 800be20: 9c ad 02 08  	.word	0x0802ad9c
 800be24: 6c 97 02 08  	.word	0x0802976c

0800be28 <bmi08x_gyro_init>:
; {
 800be28: b580         	push	{r7, lr}
 800be2a: b09e         	sub	sp, #0x78
 800be2c: af04         	add	r7, sp, #0x10
 800be2e: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_gyro_config *config = dev->config;
 800be30: 687b         	ldr	r3, [r7, #0x4]
 800be32: 685b         	ldr	r3, [r3, #0x4]
 800be34: 663b         	str	r3, [r7, #0x60]
; 	uint8_t val = 0U;
 800be36: 2300         	movs	r3, #0x0
 800be38: 73fb         	strb	r3, [r7, #0xf]
; 	ret = bmi08x_bus_check(dev);
 800be3a: 6878         	ldr	r0, [r7, #0x4]
 800be3c: f014 fd17    	bl	0x802086e <bmi08x_bus_check> @ imm = #0x14a2e
 800be40: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800be42: 6e7b         	ldr	r3, [r7, #0x64]
 800be44: 2b00         	cmp	r3, #0x0
 800be46: da1e         	bge	0x800be86 <bmi08x_gyro_init+0x5e> @ imm = #0x3c
; 		LOG_ERR("Bus not ready for '%s'", dev->name);
 800be48: 2303         	movs	r3, #0x3
 800be4a: 2b00         	cmp	r3, #0x0
 800be4c: d019         	beq	0x800be82 <bmi08x_gyro_init+0x5a> @ imm = #0x32
 800be4e: 2301         	movs	r3, #0x1
 800be50: 75fb         	strb	r3, [r7, #0x17]
 800be52: 7dfb         	ldrb	r3, [r7, #0x17]
 800be54: f083 0301    	eor	r3, r3, #0x1
 800be58: b2db         	uxtb	r3, r3
 800be5a: 2b00         	cmp	r3, #0x0
 800be5c: d111         	bne	0x800be82 <bmi08x_gyro_init+0x5a> @ imm = #0x22
 800be5e: 4ba8         	ldr	r3, [pc, #0x2a0]        @ 0x800c100 <bmi08x_gyro_init+0x2d8>
 800be60: 6819         	ldr	r1, [r3]
 800be62: 687b         	ldr	r3, [r7, #0x4]
 800be64: 681b         	ldr	r3, [r3]
 800be66: 9303         	str	r3, [sp, #0xc]
 800be68: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x800c104 <bmi08x_gyro_init+0x2dc>
 800be6a: 9302         	str	r3, [sp, #0x8]
 800be6c: 2300         	movs	r3, #0x0
 800be6e: 9301         	str	r3, [sp, #0x4]
 800be70: 2300         	movs	r3, #0x0
 800be72: 9300         	str	r3, [sp]
 800be74: 2300         	movs	r3, #0x0
 800be76: 2201         	movs	r2, #0x1
 800be78: 2000         	movs	r0, #0x0
 800be7a: f014 fbc9    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x14792
 800be7e: 2300         	movs	r3, #0x0
 800be80: 613b         	str	r3, [r7, #0x10]
; 		return ret;
 800be82: 6e7b         	ldr	r3, [r7, #0x64]
 800be84: e179         	b	0x800c17a <bmi08x_gyro_init+0x352> @ imm = #0x2f2
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_SOFTRESET, BMI08X_SOFT_RESET_CMD);
 800be86: 22b6         	movs	r2, #0xb6
 800be88: 2114         	movs	r1, #0x14
 800be8a: 6878         	ldr	r0, [r7, #0x4]
 800be8c: f014 fd4d    	bl	0x802092a <bmi08x_gyro_byte_write> @ imm = #0x14a9a
 800be90: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800be92: 6e7b         	ldr	r3, [r7, #0x64]
 800be94: 2b00         	cmp	r3, #0x0
 800be96: da1b         	bge	0x800bed0 <bmi08x_gyro_init+0xa8> @ imm = #0x36
; 		LOG_ERR("Cannot reboot chip.");
 800be98: 2303         	movs	r3, #0x3
 800be9a: 2b00         	cmp	r3, #0x0
 800be9c: d016         	beq	0x800becc <bmi08x_gyro_init+0xa4> @ imm = #0x2c
 800be9e: 2301         	movs	r3, #0x1
 800bea0: 77fb         	strb	r3, [r7, #0x1f]
 800bea2: 7ffb         	ldrb	r3, [r7, #0x1f]
 800bea4: f083 0301    	eor	r3, r3, #0x1
 800bea8: b2db         	uxtb	r3, r3
 800beaa: 2b00         	cmp	r3, #0x0
 800beac: d10e         	bne	0x800becc <bmi08x_gyro_init+0xa4> @ imm = #0x1c
 800beae: 4b94         	ldr	r3, [pc, #0x250]        @ 0x800c100 <bmi08x_gyro_init+0x2d8>
 800beb0: 6819         	ldr	r1, [r3]
 800beb2: 4b95         	ldr	r3, [pc, #0x254]        @ 0x800c108 <bmi08x_gyro_init+0x2e0>
 800beb4: 9302         	str	r3, [sp, #0x8]
 800beb6: 2300         	movs	r3, #0x0
 800beb8: 9301         	str	r3, [sp, #0x4]
 800beba: 2300         	movs	r3, #0x0
 800bebc: 9300         	str	r3, [sp]
 800bebe: 2300         	movs	r3, #0x0
 800bec0: 2201         	movs	r2, #0x1
 800bec2: 2000         	movs	r0, #0x0
 800bec4: f014 fba4    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x14748
 800bec8: 2300         	movs	r3, #0x0
 800beca: 61bb         	str	r3, [r7, #0x18]
; 		return ret;
 800becc: 6e7b         	ldr	r3, [r7, #0x64]
 800bece: e154         	b	0x800c17a <bmi08x_gyro_init+0x352> @ imm = #0x2a8
; 	k_msleep(BMI08X_GYRO_SOFTRESET_DELAY);
 800bed0: 201e         	movs	r0, #0x1e
 800bed2: f014 fb63    	bl	0x802059c <k_msleep>    @ imm = #0x146c6
; 	ret = bmi08x_gyro_byte_read(dev, BMI08X_REG_GYRO_CHIP_ID, &val);
 800bed6: f107 030f    	add.w	r3, r7, #0xf
 800beda: 461a         	mov	r2, r3
 800bedc: 2100         	movs	r1, #0x0
 800bede: 6878         	ldr	r0, [r7, #0x4]
 800bee0: f014 fd0c    	bl	0x80208fc <bmi08x_gyro_byte_read> @ imm = #0x14a18
 800bee4: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800bee6: 6e7b         	ldr	r3, [r7, #0x64]
 800bee8: 2b00         	cmp	r3, #0x0
 800beea: da1d         	bge	0x800bf28 <bmi08x_gyro_init+0x100> @ imm = #0x3a
; 		LOG_ERR("Failed to read chip id.");
 800beec: 2303         	movs	r3, #0x3
 800beee: 2b00         	cmp	r3, #0x0
 800bef0: d018         	beq	0x800bf24 <bmi08x_gyro_init+0xfc> @ imm = #0x30
 800bef2: 2301         	movs	r3, #0x1
 800bef4: f887 3027    	strb.w	r3, [r7, #0x27]
 800bef8: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800befc: f083 0301    	eor	r3, r3, #0x1
 800bf00: b2db         	uxtb	r3, r3
 800bf02: 2b00         	cmp	r3, #0x0
 800bf04: d10e         	bne	0x800bf24 <bmi08x_gyro_init+0xfc> @ imm = #0x1c
 800bf06: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x800c100 <bmi08x_gyro_init+0x2d8>
 800bf08: 6819         	ldr	r1, [r3]
 800bf0a: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800c10c <bmi08x_gyro_init+0x2e4>
 800bf0c: 9302         	str	r3, [sp, #0x8]
 800bf0e: 2300         	movs	r3, #0x0
 800bf10: 9301         	str	r3, [sp, #0x4]
 800bf12: 2300         	movs	r3, #0x0
 800bf14: 9300         	str	r3, [sp]
 800bf16: 2300         	movs	r3, #0x0
 800bf18: 2201         	movs	r2, #0x1
 800bf1a: 2000         	movs	r0, #0x0
 800bf1c: f014 fb78    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x146f0
 800bf20: 2300         	movs	r3, #0x0
 800bf22: 623b         	str	r3, [r7, #0x20]
; 		return ret;
 800bf24: 6e7b         	ldr	r3, [r7, #0x64]
 800bf26: e128         	b	0x800c17a <bmi08x_gyro_init+0x352> @ imm = #0x250
; 	if (val != BMI08X_GYRO_CHIP_ID) {
 800bf28: 7bfb         	ldrb	r3, [r7, #0xf]
 800bf2a: 2b0f         	cmp	r3, #0xf
 800bf2c: d020         	beq	0x800bf70 <bmi08x_gyro_init+0x148> @ imm = #0x40
; 		LOG_ERR("Unsupported chip detected (0x%02x)!", val);
 800bf2e: 2303         	movs	r3, #0x3
 800bf30: 2b00         	cmp	r3, #0x0
 800bf32: d01a         	beq	0x800bf6a <bmi08x_gyro_init+0x142> @ imm = #0x34
 800bf34: 2301         	movs	r3, #0x1
 800bf36: f887 302f    	strb.w	r3, [r7, #0x2f]
 800bf3a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800bf3e: f083 0301    	eor	r3, r3, #0x1
 800bf42: b2db         	uxtb	r3, r3
 800bf44: 2b00         	cmp	r3, #0x0
 800bf46: d110         	bne	0x800bf6a <bmi08x_gyro_init+0x142> @ imm = #0x20
 800bf48: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x800c100 <bmi08x_gyro_init+0x2d8>
 800bf4a: 6819         	ldr	r1, [r3]
 800bf4c: 7bfb         	ldrb	r3, [r7, #0xf]
 800bf4e: 9303         	str	r3, [sp, #0xc]
 800bf50: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x800c110 <bmi08x_gyro_init+0x2e8>
 800bf52: 9302         	str	r3, [sp, #0x8]
 800bf54: 2300         	movs	r3, #0x0
 800bf56: 9301         	str	r3, [sp, #0x4]
 800bf58: 2300         	movs	r3, #0x0
 800bf5a: 9300         	str	r3, [sp]
 800bf5c: 2300         	movs	r3, #0x0
 800bf5e: 2201         	movs	r2, #0x1
 800bf60: 2000         	movs	r0, #0x0
 800bf62: f014 fb55    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x146aa
 800bf66: 2300         	movs	r3, #0x0
 800bf68: 62bb         	str	r3, [r7, #0x28]
; 		return -ENODEV;
 800bf6a: f06f 0312    	mvn	r3, #0x12
 800bf6e: e104         	b	0x800c17a <bmi08x_gyro_init+0x352> @ imm = #0x208
; 	ret = bmi08x_gyr_range_set(dev, config->gyro_fs);
 800bf70: 6e3b         	ldr	r3, [r7, #0x60]
 800bf72: 8d1b         	ldrh	r3, [r3, #0x28]
 800bf74: 4619         	mov	r1, r3
 800bf76: 6878         	ldr	r0, [r7, #0x4]
 800bf78: f7ff fd70    	bl	0x800ba5c <bmi08x_gyr_range_set> @ imm = #-0x520
 800bf7c: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800bf7e: 6e7b         	ldr	r3, [r7, #0x64]
 800bf80: 2b00         	cmp	r3, #0x0
 800bf82: da1d         	bge	0x800bfc0 <bmi08x_gyro_init+0x198> @ imm = #0x3a
; 		LOG_ERR("Cannot set default range for gyroscope.");
 800bf84: 2303         	movs	r3, #0x3
 800bf86: 2b00         	cmp	r3, #0x0
 800bf88: d018         	beq	0x800bfbc <bmi08x_gyro_init+0x194> @ imm = #0x30
 800bf8a: 2301         	movs	r3, #0x1
 800bf8c: f887 3037    	strb.w	r3, [r7, #0x37]
 800bf90: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800bf94: f083 0301    	eor	r3, r3, #0x1
 800bf98: b2db         	uxtb	r3, r3
 800bf9a: 2b00         	cmp	r3, #0x0
 800bf9c: d10e         	bne	0x800bfbc <bmi08x_gyro_init+0x194> @ imm = #0x1c
 800bf9e: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800c100 <bmi08x_gyro_init+0x2d8>
 800bfa0: 6819         	ldr	r1, [r3]
 800bfa2: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800c114 <bmi08x_gyro_init+0x2ec>
 800bfa4: 9302         	str	r3, [sp, #0x8]
 800bfa6: 2300         	movs	r3, #0x0
 800bfa8: 9301         	str	r3, [sp, #0x4]
 800bfaa: 2300         	movs	r3, #0x0
 800bfac: 9300         	str	r3, [sp]
 800bfae: 2300         	movs	r3, #0x0
 800bfb0: 2201         	movs	r2, #0x1
 800bfb2: 2000         	movs	r0, #0x0
 800bfb4: f014 fb2c    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x14658
 800bfb8: 2300         	movs	r3, #0x0
 800bfba: 633b         	str	r3, [r7, #0x30]
; 		return ret;
 800bfbc: 6e7b         	ldr	r3, [r7, #0x64]
 800bfbe: e0dc         	b	0x800c17a <bmi08x_gyro_init+0x352> @ imm = #0x1b8
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_BANDWIDTH, config->gyro_hz);
 800bfc0: 6e3b         	ldr	r3, [r7, #0x60]
 800bfc2: f893 3026    	ldrb.w	r3, [r3, #0x26]
 800bfc6: 461a         	mov	r2, r3
 800bfc8: 2110         	movs	r1, #0x10
 800bfca: 6878         	ldr	r0, [r7, #0x4]
 800bfcc: f014 fcad    	bl	0x802092a <bmi08x_gyro_byte_write> @ imm = #0x1495a
 800bfd0: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800bfd2: 6e7b         	ldr	r3, [r7, #0x64]
 800bfd4: 2b00         	cmp	r3, #0x0
 800bfd6: da1d         	bge	0x800c014 <bmi08x_gyro_init+0x1ec> @ imm = #0x3a
; 		LOG_ERR("Failed to set gyro's default ODR.");
 800bfd8: 2303         	movs	r3, #0x3
 800bfda: 2b00         	cmp	r3, #0x0
 800bfdc: d018         	beq	0x800c010 <bmi08x_gyro_init+0x1e8> @ imm = #0x30
 800bfde: 2301         	movs	r3, #0x1
 800bfe0: f887 303f    	strb.w	r3, [r7, #0x3f]
 800bfe4: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800bfe8: f083 0301    	eor	r3, r3, #0x1
 800bfec: b2db         	uxtb	r3, r3
 800bfee: 2b00         	cmp	r3, #0x0
 800bff0: d10e         	bne	0x800c010 <bmi08x_gyro_init+0x1e8> @ imm = #0x1c
 800bff2: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800c100 <bmi08x_gyro_init+0x2d8>
 800bff4: 6819         	ldr	r1, [r3]
 800bff6: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800c118 <bmi08x_gyro_init+0x2f0>
 800bff8: 9302         	str	r3, [sp, #0x8]
 800bffa: 2300         	movs	r3, #0x0
 800bffc: 9301         	str	r3, [sp, #0x4]
 800bffe: 2300         	movs	r3, #0x0
 800c000: 9300         	str	r3, [sp]
 800c002: 2300         	movs	r3, #0x0
 800c004: 2201         	movs	r2, #0x1
 800c006: 2000         	movs	r0, #0x0
 800c008: f014 fb02    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x14604
 800c00c: 2300         	movs	r3, #0x0
 800c00e: 63bb         	str	r3, [r7, #0x38]
; 		return ret;
 800c010: 6e7b         	ldr	r3, [r7, #0x64]
 800c012: e0b2         	b	0x800c17a <bmi08x_gyro_init+0x352> @ imm = #0x164
; 	ret = bmi08x_gyr_trigger_mode_init(dev);
 800c014: 6878         	ldr	r0, [r7, #0x4]
 800c016: f000 faed    	bl	0x800c5f4 <bmi08x_gyr_trigger_mode_init> @ imm = #0x5da
 800c01a: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800c01c: 6e7b         	ldr	r3, [r7, #0x64]
 800c01e: 2b00         	cmp	r3, #0x0
 800c020: da1d         	bge	0x800c05e <bmi08x_gyro_init+0x236> @ imm = #0x3a
; 		LOG_ERR("Cannot set up trigger mode.");
 800c022: 2303         	movs	r3, #0x3
 800c024: 2b00         	cmp	r3, #0x0
 800c026: d018         	beq	0x800c05a <bmi08x_gyro_init+0x232> @ imm = #0x30
 800c028: 2301         	movs	r3, #0x1
 800c02a: f887 3047    	strb.w	r3, [r7, #0x47]
 800c02e: f897 3047    	ldrb.w	r3, [r7, #0x47]
 800c032: f083 0301    	eor	r3, r3, #0x1
 800c036: b2db         	uxtb	r3, r3
 800c038: 2b00         	cmp	r3, #0x0
 800c03a: d10e         	bne	0x800c05a <bmi08x_gyro_init+0x232> @ imm = #0x1c
 800c03c: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x800c100 <bmi08x_gyro_init+0x2d8>
 800c03e: 6819         	ldr	r1, [r3]
 800c040: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800c11c <bmi08x_gyro_init+0x2f4>
 800c042: 9302         	str	r3, [sp, #0x8]
 800c044: 2300         	movs	r3, #0x0
 800c046: 9301         	str	r3, [sp, #0x4]
 800c048: 2300         	movs	r3, #0x0
 800c04a: 9300         	str	r3, [sp]
 800c04c: 2300         	movs	r3, #0x0
 800c04e: 2201         	movs	r2, #0x1
 800c050: 2000         	movs	r0, #0x0
 800c052: f014 fadd    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x145ba
 800c056: 2300         	movs	r3, #0x0
 800c058: 643b         	str	r3, [r7, #0x40]
; 		return ret;
 800c05a: 6e7b         	ldr	r3, [r7, #0x64]
 800c05c: e08d         	b	0x800c17a <bmi08x_gyro_init+0x352> @ imm = #0x11a
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT_CTRL, 0x80);
 800c05e: 2280         	movs	r2, #0x80
 800c060: 2115         	movs	r1, #0x15
 800c062: 6878         	ldr	r0, [r7, #0x4]
 800c064: f014 fc61    	bl	0x802092a <bmi08x_gyro_byte_write> @ imm = #0x148c2
 800c068: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800c06a: 6e7b         	ldr	r3, [r7, #0x64]
 800c06c: 2b00         	cmp	r3, #0x0
 800c06e: da1d         	bge	0x800c0ac <bmi08x_gyro_init+0x284> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800c070: 2303         	movs	r3, #0x3
 800c072: 2b00         	cmp	r3, #0x0
 800c074: d018         	beq	0x800c0a8 <bmi08x_gyro_init+0x280> @ imm = #0x30
 800c076: 2301         	movs	r3, #0x1
 800c078: f887 304f    	strb.w	r3, [r7, #0x4f]
 800c07c: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 800c080: f083 0301    	eor	r3, r3, #0x1
 800c084: b2db         	uxtb	r3, r3
 800c086: 2b00         	cmp	r3, #0x0
 800c088: d10e         	bne	0x800c0a8 <bmi08x_gyro_init+0x280> @ imm = #0x1c
 800c08a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800c100 <bmi08x_gyro_init+0x2d8>
 800c08c: 6819         	ldr	r1, [r3]
 800c08e: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800c120 <bmi08x_gyro_init+0x2f8>
 800c090: 9302         	str	r3, [sp, #0x8]
 800c092: 2300         	movs	r3, #0x0
 800c094: 9301         	str	r3, [sp, #0x4]
 800c096: 2300         	movs	r3, #0x0
 800c098: 9300         	str	r3, [sp]
 800c09a: 2300         	movs	r3, #0x0
 800c09c: 2201         	movs	r2, #0x1
 800c09e: 2000         	movs	r0, #0x0
 800c0a0: f014 fab6    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x1456c
 800c0a4: 2300         	movs	r3, #0x0
 800c0a6: 64bb         	str	r3, [r7, #0x48]
; 		return ret;
 800c0a8: 6e7b         	ldr	r3, [r7, #0x64]
 800c0aa: e066         	b	0x800c17a <bmi08x_gyro_init+0x352> @ imm = #0xcc
; 				     config->int3_4_conf_io);
 800c0ac: 6e3b         	ldr	r3, [r7, #0x60]
 800c0ae: f893 3025    	ldrb.w	r3, [r3, #0x25]
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT3_INT4_IO_CONF,
 800c0b2: 461a         	mov	r2, r3
 800c0b4: 2116         	movs	r1, #0x16
 800c0b6: 6878         	ldr	r0, [r7, #0x4]
 800c0b8: f014 fc37    	bl	0x802092a <bmi08x_gyro_byte_write> @ imm = #0x1486e
 800c0bc: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800c0be: 6e7b         	ldr	r3, [r7, #0x64]
 800c0c0: 2b00         	cmp	r3, #0x0
 800c0c2: da2f         	bge	0x800c124 <bmi08x_gyro_init+0x2fc> @ imm = #0x5e
; 		LOG_ERR("Failed to map interrupts.");
 800c0c4: 2303         	movs	r3, #0x3
 800c0c6: 2b00         	cmp	r3, #0x0
 800c0c8: d018         	beq	0x800c0fc <bmi08x_gyro_init+0x2d4> @ imm = #0x30
 800c0ca: 2301         	movs	r3, #0x1
 800c0cc: f887 3057    	strb.w	r3, [r7, #0x57]
 800c0d0: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800c0d4: f083 0301    	eor	r3, r3, #0x1
 800c0d8: b2db         	uxtb	r3, r3
 800c0da: 2b00         	cmp	r3, #0x0
 800c0dc: d10e         	bne	0x800c0fc <bmi08x_gyro_init+0x2d4> @ imm = #0x1c
 800c0de: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800c100 <bmi08x_gyro_init+0x2d8>
 800c0e0: 6819         	ldr	r1, [r3]
 800c0e2: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800c120 <bmi08x_gyro_init+0x2f8>
 800c0e4: 9302         	str	r3, [sp, #0x8]
 800c0e6: 2300         	movs	r3, #0x0
 800c0e8: 9301         	str	r3, [sp, #0x4]
 800c0ea: 2300         	movs	r3, #0x0
 800c0ec: 9300         	str	r3, [sp]
 800c0ee: 2300         	movs	r3, #0x0
 800c0f0: 2201         	movs	r2, #0x1
 800c0f2: 2000         	movs	r0, #0x0
 800c0f4: f014 fa8c    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x14518
 800c0f8: 2300         	movs	r3, #0x0
 800c0fa: 653b         	str	r3, [r7, #0x50]
; 		return ret;
 800c0fc: 6e7b         	ldr	r3, [r7, #0x64]
 800c0fe: e03c         	b	0x800c17a <bmi08x_gyro_init+0x352> @ imm = #0x78

0800c100 <$d>:
 800c100: 44 05 00 20  	.word	0x20000544
 800c104: 88 97 02 08  	.word	0x08029788
 800c108: a0 97 02 08  	.word	0x080297a0
 800c10c: b4 97 02 08  	.word	0x080297b4
 800c110: cc 97 02 08  	.word	0x080297cc
 800c114: f0 97 02 08  	.word	0x080297f0
 800c118: 18 98 02 08  	.word	0x08029818
 800c11c: 3c 98 02 08  	.word	0x0802983c
 800c120: 58 98 02 08  	.word	0x08029858

0800c124 <$t>:
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT3_INT4_IO_MAP, config->int3_4_map);
 800c124: 6e3b         	ldr	r3, [r7, #0x60]
 800c126: f893 3024    	ldrb.w	r3, [r3, #0x24]
 800c12a: 461a         	mov	r2, r3
 800c12c: 2118         	movs	r1, #0x18
 800c12e: 6878         	ldr	r0, [r7, #0x4]
 800c130: f014 fbfb    	bl	0x802092a <bmi08x_gyro_byte_write> @ imm = #0x147f6
 800c134: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800c136: 6e7b         	ldr	r3, [r7, #0x64]
 800c138: 2b00         	cmp	r3, #0x0
 800c13a: da1d         	bge	0x800c178 <bmi08x_gyro_init+0x350> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800c13c: 2303         	movs	r3, #0x3
 800c13e: 2b00         	cmp	r3, #0x0
 800c140: d018         	beq	0x800c174 <bmi08x_gyro_init+0x34c> @ imm = #0x30
 800c142: 2301         	movs	r3, #0x1
 800c144: f887 305f    	strb.w	r3, [r7, #0x5f]
 800c148: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 800c14c: f083 0301    	eor	r3, r3, #0x1
 800c150: b2db         	uxtb	r3, r3
 800c152: 2b00         	cmp	r3, #0x0
 800c154: d10e         	bne	0x800c174 <bmi08x_gyro_init+0x34c> @ imm = #0x1c
 800c156: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800c184 <bmi08x_gyro_init+0x35c>
 800c158: 6819         	ldr	r1, [r3]
 800c15a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800c188 <bmi08x_gyro_init+0x360>
 800c15c: 9302         	str	r3, [sp, #0x8]
 800c15e: 2300         	movs	r3, #0x0
 800c160: 9301         	str	r3, [sp, #0x4]
 800c162: 2300         	movs	r3, #0x0
 800c164: 9300         	str	r3, [sp]
 800c166: 2300         	movs	r3, #0x0
 800c168: 2201         	movs	r2, #0x1
 800c16a: 2000         	movs	r0, #0x0
 800c16c: f014 fa50    	bl	0x8020610 <z_log_msg_runtime_create> @ imm = #0x144a0
 800c170: 2300         	movs	r3, #0x0
 800c172: 65bb         	str	r3, [r7, #0x58]
; 		return ret;
 800c174: 6e7b         	ldr	r3, [r7, #0x64]
 800c176: e000         	b	0x800c17a <bmi08x_gyro_init+0x352> @ imm = #0x0
; 	return ret;
 800c178: 6e7b         	ldr	r3, [r7, #0x64]
; }
 800c17a: 4618         	mov	r0, r3
 800c17c: 3768         	adds	r7, #0x68
 800c17e: 46bd         	mov	sp, r7
 800c180: bd80         	pop	{r7, pc}
 800c182: bf00         	nop

0800c184 <$d>:
 800c184: 44 05 00 20  	.word	0x20000544
 800c188: 58 98 02 08  	.word	0x08029858

0800c18c <bmi08x_freq_to_odr_val>:
; {
 800c18c: b480         	push	{r7}
 800c18e: b085         	sub	sp, #0x14
 800c190: af00         	add	r7, sp, #0x0
 800c192: 4603         	mov	r3, r0
 800c194: 460a         	mov	r2, r1
 800c196: 80fb         	strh	r3, [r7, #0x6]
 800c198: 4613         	mov	r3, r2
 800c19a: 80bb         	strh	r3, [r7, #0x4]
; 	if (freq_int == 0U && freq_milli == 0U) {
 800c19c: 88fb         	ldrh	r3, [r7, #0x6]
 800c19e: 2b00         	cmp	r3, #0x0
 800c1a0: d105         	bne	0x800c1ae <bmi08x_freq_to_odr_val+0x22> @ imm = #0xa
 800c1a2: 88bb         	ldrh	r3, [r7, #0x4]
 800c1a4: 2b00         	cmp	r3, #0x0
 800c1a6: d102         	bne	0x800c1ae <bmi08x_freq_to_odr_val+0x22> @ imm = #0x4
; 		return -EINVAL;
 800c1a8: f06f 0315    	mvn	r3, #0x15
 800c1ac: e022         	b	0x800c1f4 <bmi08x_freq_to_odr_val+0x68> @ imm = #0x44
; 	for (i = 0; i < ARRAY_SIZE(bmi08x_odr_map); i++) {
 800c1ae: 2300         	movs	r3, #0x0
 800c1b0: 60fb         	str	r3, [r7, #0xc]
 800c1b2: e01a         	b	0x800c1ea <bmi08x_freq_to_odr_val+0x5e> @ imm = #0x34
; 		if (freq_int < bmi08x_odr_map[i].freq_int ||
 800c1b4: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800c200 <bmi08x_freq_to_odr_val+0x74>
 800c1b6: 68fb         	ldr	r3, [r7, #0xc]
 800c1b8: f832 3023    	ldrh.w	r3, [r2, r3, lsl #2]
 800c1bc: 88fa         	ldrh	r2, [r7, #0x6]
 800c1be: 429a         	cmp	r2, r3
 800c1c0: d30e         	blo	0x800c1e0 <bmi08x_freq_to_odr_val+0x54> @ imm = #0x1c
; 		    (freq_int == bmi08x_odr_map[i].freq_int &&
 800c1c2: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x800c200 <bmi08x_freq_to_odr_val+0x74>
 800c1c4: 68fb         	ldr	r3, [r7, #0xc]
 800c1c6: f832 3023    	ldrh.w	r3, [r2, r3, lsl #2]
; 		if (freq_int < bmi08x_odr_map[i].freq_int ||
 800c1ca: 88fa         	ldrh	r2, [r7, #0x6]
 800c1cc: 429a         	cmp	r2, r3
 800c1ce: d109         	bne	0x800c1e4 <bmi08x_freq_to_odr_val+0x58> @ imm = #0x12
; 		     freq_milli <= bmi08x_odr_map[i].freq_milli)) {
 800c1d0: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800c200 <bmi08x_freq_to_odr_val+0x74>
 800c1d2: 68fb         	ldr	r3, [r7, #0xc]
 800c1d4: 009b         	lsls	r3, r3, #0x2
 800c1d6: 4413         	add	r3, r2
 800c1d8: 885b         	ldrh	r3, [r3, #0x2]
; 		    (freq_int == bmi08x_odr_map[i].freq_int &&
 800c1da: 88ba         	ldrh	r2, [r7, #0x4]
 800c1dc: 429a         	cmp	r2, r3
 800c1de: d801         	bhi	0x800c1e4 <bmi08x_freq_to_odr_val+0x58> @ imm = #0x2
; 			return i;
 800c1e0: 68fb         	ldr	r3, [r7, #0xc]
 800c1e2: e007         	b	0x800c1f4 <bmi08x_freq_to_odr_val+0x68> @ imm = #0xe
; 	for (i = 0; i < ARRAY_SIZE(bmi08x_odr_map); i++) {
 800c1e4: 68fb         	ldr	r3, [r7, #0xc]
 800c1e6: 3301         	adds	r3, #0x1
 800c1e8: 60fb         	str	r3, [r7, #0xc]
 800c1ea: 68fb         	ldr	r3, [r7, #0xc]
 800c1ec: 2b0d         	cmp	r3, #0xd
 800c1ee: d9e1         	bls	0x800c1b4 <bmi08x_freq_to_odr_val+0x28> @ imm = #-0x3e
; 	return -EINVAL;
 800c1f0: f06f 0315    	mvn	r3, #0x15
; }
 800c1f4: 4618         	mov	r0, r3
 800c1f6: 3714         	adds	r7, #0x14
 800c1f8: 46bd         	mov	sp, r7
 800c1fa: f85d 7b04    	ldr	r7, [sp], #4
 800c1fe: 4770         	bx	lr

0800c200 <$d>:
 800c200: b0 ad 02 08  	.word	0x0802adb0

0800c204 <z_impl_gpio_pin_interrupt_configure>:
; {
 800c204: b590         	push	{r4, r7, lr}
 800c206: b08b         	sub	sp, #0x2c
 800c208: af00         	add	r7, sp, #0x0
 800c20a: 60f8         	str	r0, [r7, #0xc]
 800c20c: 460b         	mov	r3, r1
 800c20e: 607a         	str	r2, [r7, #0x4]
 800c210: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 800c212: 68fb         	ldr	r3, [r7, #0xc]
 800c214: 689b         	ldr	r3, [r3, #0x8]
 800c216: 627b         	str	r3, [r7, #0x24]
; 	__unused const struct gpio_driver_config *const cfg =
 800c218: 68fb         	ldr	r3, [r7, #0xc]
 800c21a: 685b         	ldr	r3, [r3, #0x4]
 800c21c: 623b         	str	r3, [r7, #0x20]
; 	const struct gpio_driver_data *const data =
 800c21e: 68fb         	ldr	r3, [r7, #0xc]
 800c220: 691b         	ldr	r3, [r3, #0x10]
 800c222: 61fb         	str	r3, [r7, #0x1c]
; 	if (api->pin_interrupt_configure == NULL) {
 800c224: 6a7b         	ldr	r3, [r7, #0x24]
 800c226: 699b         	ldr	r3, [r3, #0x18]
 800c228: 2b00         	cmp	r3, #0x0
 800c22a: d102         	bne	0x800c232 <z_impl_gpio_pin_interrupt_configure+0x2e> @ imm = #0x4
; 		return -ENOSYS;
 800c22c: f06f 0357    	mvn	r3, #0x57
 800c230: e021         	b	0x800c276 <z_impl_gpio_pin_interrupt_configure+0x72> @ imm = #0x42
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800c232: 687b         	ldr	r3, [r7, #0x4]
 800c234: f403 0300    	and	r3, r3, #0x800000
 800c238: 2b00         	cmp	r3, #0x0
 800c23a: d00c         	beq	0x800c256 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x18
; 	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
 800c23c: 69fb         	ldr	r3, [r7, #0x1c]
 800c23e: 681a         	ldr	r2, [r3]
 800c240: 7afb         	ldrb	r3, [r7, #0xb]
 800c242: 2101         	movs	r1, #0x1
 800c244: fa01 f303    	lsl.w	r3, r1, r3
 800c248: 4013         	ands	r3, r2
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800c24a: 2b00         	cmp	r3, #0x0
 800c24c: d003         	beq	0x800c256 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x6
; 		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
 800c24e: 687b         	ldr	r3, [r7, #0x4]
 800c250: f083 63c0    	eor	r3, r3, #0x6000000
 800c254: 607b         	str	r3, [r7, #0x4]
; 	trig = (enum gpio_int_trig)(flags & (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1 | GPIO_INT_WAKEUP));
 800c256: 687a         	ldr	r2, [r7, #0x4]
 800c258: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800c280 <z_impl_gpio_pin_interrupt_configure+0x7c>
 800c25a: 4013         	ands	r3, r2
 800c25c: 61bb         	str	r3, [r7, #0x18]
; 	mode = (enum gpio_int_mode)(flags & (GPIO_INT_EDGE | GPIO_INT_DISABLE | GPIO_INT_ENABLE));
 800c25e: 687b         	ldr	r3, [r7, #0x4]
 800c260: f003 73b0    	and	r3, r3, #0x1600000
 800c264: 617b         	str	r3, [r7, #0x14]
; 	return api->pin_interrupt_configure(port, pin, mode, trig);
 800c266: 6a7b         	ldr	r3, [r7, #0x24]
 800c268: 699c         	ldr	r4, [r3, #0x18]
 800c26a: 7af9         	ldrb	r1, [r7, #0xb]
 800c26c: 69bb         	ldr	r3, [r7, #0x18]
 800c26e: 697a         	ldr	r2, [r7, #0x14]
 800c270: 68f8         	ldr	r0, [r7, #0xc]
 800c272: 47a0         	blx	r4
 800c274: 4603         	mov	r3, r0
; }
 800c276: 4618         	mov	r0, r3
 800c278: 372c         	adds	r7, #0x2c
 800c27a: 46bd         	mov	sp, r7
 800c27c: bd90         	pop	{r4, r7, pc}
 800c27e: bf00         	nop

0800c280 <$d>:
 800c280: 40 00 00 06  	.word	0x06000040

0800c284 <bmi08x_acc_thread_main>:
; {
 800c284: b580         	push	{r7, lr}
 800c286: b086         	sub	sp, #0x18
 800c288: af00         	add	r7, sp, #0x0
 800c28a: 60f8         	str	r0, [r7, #0xc]
 800c28c: 60b9         	str	r1, [r7, #0x8]
 800c28e: 607a         	str	r2, [r7, #0x4]
; 	k_thread_name_set(NULL, "bmi08x_acc_trig");
 800c290: 490b         	ldr	r1, [pc, #0x2c]         @ 0x800c2c0 <bmi08x_acc_thread_main+0x3c>
 800c292: 2000         	movs	r0, #0x0
 800c294: f014 fd0a    	bl	0x8020cac <k_thread_name_set> @ imm = #0x14a14
; 	const struct device *dev = (const struct device *)arg1;
 800c298: 68fb         	ldr	r3, [r7, #0xc]
 800c29a: 617b         	str	r3, [r7, #0x14]
; 	struct bmi08x_accel_data *data = dev->data;
 800c29c: 697b         	ldr	r3, [r7, #0x14]
 800c29e: 691b         	ldr	r3, [r3, #0x10]
 800c2a0: 613b         	str	r3, [r7, #0x10]
; 		k_sem_take(&data->sem, K_FOREVER);
 800c2a2: 693b         	ldr	r3, [r7, #0x10]
 800c2a4: f503 6113    	add.w	r1, r3, #0x930
 800c2a8: f04f 32ff    	mov.w	r2, #0xffffffff
 800c2ac: f04f 33ff    	mov.w	r3, #0xffffffff
 800c2b0: 4608         	mov	r0, r1
 800c2b2: f014 fd19    	bl	0x8020ce8 <k_sem_take>  @ imm = #0x14a32
; 		bmi08x_handle_interrupts_acc((void *)dev);
 800c2b6: 6978         	ldr	r0, [r7, #0x14]
 800c2b8: f014 fd68    	bl	0x8020d8c <bmi08x_handle_interrupts_acc> @ imm = #0x14ad0
; 	while (1) {
 800c2bc: bf00         	nop
 800c2be: e7f0         	b	0x800c2a2 <bmi08x_acc_thread_main+0x1e> @ imm = #-0x20

0800c2c0 <$d>:
 800c2c0: 84 98 02 08  	.word	0x08029884

0800c2c4 <bmi08x_acc_trigger_mode_init>:
; {
 800c2c4: b5b0         	push	{r4, r5, r7, lr}
 800c2c6: b098         	sub	sp, #0x60
 800c2c8: af08         	add	r7, sp, #0x20
 800c2ca: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 800c2cc: 687b         	ldr	r3, [r7, #0x4]
 800c2ce: 691b         	ldr	r3, [r3, #0x10]
 800c2d0: 63fb         	str	r3, [r7, #0x3c]
; 	const struct bmi08x_accel_config *cfg = dev->config;
 800c2d2: 687b         	ldr	r3, [r7, #0x4]
 800c2d4: 685b         	ldr	r3, [r3, #0x4]
 800c2d6: 63bb         	str	r3, [r7, #0x38]
; 	int ret = 0;
 800c2d8: 2300         	movs	r3, #0x0
 800c2da: 637b         	str	r3, [r7, #0x34]
; 	if (!gpio_is_ready_dt(&cfg->int_gpio)) {
 800c2dc: 6bbb         	ldr	r3, [r7, #0x38]
 800c2de: 331c         	adds	r3, #0x1c
 800c2e0: 4618         	mov	r0, r3
 800c2e2: f014 fbf2    	bl	0x8020aca <gpio_is_ready_dt> @ imm = #0x147e4
 800c2e6: 4603         	mov	r3, r0
 800c2e8: f083 0301    	eor	r3, r3, #0x1
 800c2ec: b2db         	uxtb	r3, r3
 800c2ee: 2b00         	cmp	r3, #0x0
 800c2f0: d01c         	beq	0x800c32c <bmi08x_acc_trigger_mode_init+0x68> @ imm = #0x38
; 		LOG_ERR("GPIO device not ready");
 800c2f2: 2303         	movs	r3, #0x3
 800c2f4: 2b00         	cmp	r3, #0x0
 800c2f6: d016         	beq	0x800c326 <bmi08x_acc_trigger_mode_init+0x62> @ imm = #0x2c
 800c2f8: 2301         	movs	r3, #0x1
 800c2fa: 74fb         	strb	r3, [r7, #0x13]
 800c2fc: 7cfb         	ldrb	r3, [r7, #0x13]
 800c2fe: f083 0301    	eor	r3, r3, #0x1
 800c302: b2db         	uxtb	r3, r3
 800c304: 2b00         	cmp	r3, #0x0
 800c306: d10e         	bne	0x800c326 <bmi08x_acc_trigger_mode_init+0x62> @ imm = #0x1c
 800c308: 4b84         	ldr	r3, [pc, #0x210]        @ 0x800c51c <bmi08x_acc_trigger_mode_init+0x258>
 800c30a: 6819         	ldr	r1, [r3]
 800c30c: 4b84         	ldr	r3, [pc, #0x210]        @ 0x800c520 <bmi08x_acc_trigger_mode_init+0x25c>
 800c30e: 9302         	str	r3, [sp, #0x8]
 800c310: 2300         	movs	r3, #0x0
 800c312: 9301         	str	r3, [sp, #0x4]
 800c314: 2300         	movs	r3, #0x0
 800c316: 9300         	str	r3, [sp]
 800c318: 2300         	movs	r3, #0x0
 800c31a: 2201         	movs	r2, #0x1
 800c31c: 2000         	movs	r0, #0x0
 800c31e: f014 fcfe    	bl	0x8020d1e <z_log_msg_runtime_create> @ imm = #0x149fc
 800c322: 2300         	movs	r3, #0x0
 800c324: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800c326: f06f 0312    	mvn	r3, #0x12
 800c32a: e0f2         	b	0x800c512 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x1e4
; 	k_sem_init(&data->sem, 0, K_SEM_MAX_LIMIT);
 800c32c: 6bfb         	ldr	r3, [r7, #0x3c]
 800c32e: f503 6313    	add.w	r3, r3, #0x930
 800c332: f04f 32ff    	mov.w	r2, #0xffffffff
 800c336: 2100         	movs	r1, #0x0
 800c338: 4618         	mov	r0, r3
 800c33a: f014 fcc5    	bl	0x8020cc8 <k_sem_init>  @ imm = #0x1498a
; 	k_thread_create(&data->thread, data->thread_stack,
 800c33e: 6bfb         	ldr	r3, [r7, #0x3c]
 800c340: f603 0418    	addw	r4, r3, #0x818
 800c344: 6bfb         	ldr	r3, [r7, #0x3c]
 800c346: f103 0518    	add.w	r5, r3, #0x18
; 			NULL, NULL, K_PRIO_COOP(CONFIG_BMI08X_ACCEL_THREAD_PRIORITY), 0, K_NO_WAIT);
 800c34a: f04f 0000    	mov.w	r0, #0x0
 800c34e: f04f 0100    	mov.w	r1, #0x0
; 	k_thread_create(&data->thread, data->thread_stack,
 800c352: e9cd 0106    	strd	r0, r1, [sp, #24]
 800c356: 2300         	movs	r3, #0x0
 800c358: 9304         	str	r3, [sp, #0x10]
 800c35a: f06f 0305    	mvn	r3, #0x5
 800c35e: 9303         	str	r3, [sp, #0xc]
 800c360: 2300         	movs	r3, #0x0
 800c362: 9302         	str	r3, [sp, #0x8]
 800c364: 2300         	movs	r3, #0x0
 800c366: 9301         	str	r3, [sp, #0x4]
 800c368: 687b         	ldr	r3, [r7, #0x4]
 800c36a: 9300         	str	r3, [sp]
 800c36c: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x800c524 <bmi08x_acc_trigger_mode_init+0x260>
 800c36e: f44f 6200    	mov.w	r2, #0x800
 800c372: 4629         	mov	r1, r5
 800c374: 4620         	mov	r0, r4
 800c376: f014 fc79    	bl	0x8020c6c <k_thread_create> @ imm = #0x148f2
; 		uint8_t map_data = ((cfg->int2_map << BMI08X_ACCEL_INT2_DRDY_POS) |
 800c37a: 6bbb         	ldr	r3, [r7, #0x38]
 800c37c: f893 3025    	ldrb.w	r3, [r3, #0x25]
 800c380: 019b         	lsls	r3, r3, #0x6
 800c382: b25a         	sxtb	r2, r3
; 				    (cfg->int1_map << BMI08X_ACCEL_INT1_DRDY_POS));
 800c384: 6bbb         	ldr	r3, [r7, #0x38]
 800c386: f893 3024    	ldrb.w	r3, [r3, #0x24]
 800c38a: 009b         	lsls	r3, r3, #0x2
; 		uint8_t map_data = ((cfg->int2_map << BMI08X_ACCEL_INT2_DRDY_POS) |
 800c38c: b25b         	sxtb	r3, r3
 800c38e: 4313         	orrs	r3, r2
 800c390: b25b         	sxtb	r3, r3
 800c392: f887 3033    	strb.w	r3, [r7, #0x33]
; 		ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT1_INT2_MAP_DATA, map_data);
 800c396: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800c39a: 461a         	mov	r2, r3
 800c39c: 2158         	movs	r1, #0x58
 800c39e: 6878         	ldr	r0, [r7, #0x4]
 800c3a0: f014 f823    	bl	0x80203ea <bmi08x_accel_byte_write> @ imm = #0x14046
 800c3a4: 6378         	str	r0, [r7, #0x34]
; 		if (ret < 0) {
 800c3a6: 6b7b         	ldr	r3, [r7, #0x34]
 800c3a8: 2b00         	cmp	r3, #0x0
 800c3aa: da1b         	bge	0x800c3e4 <bmi08x_acc_trigger_mode_init+0x120> @ imm = #0x36
; 			LOG_ERR("Failed to map interrupts.");
 800c3ac: 2303         	movs	r3, #0x3
 800c3ae: 2b00         	cmp	r3, #0x0
 800c3b0: d016         	beq	0x800c3e0 <bmi08x_acc_trigger_mode_init+0x11c> @ imm = #0x2c
 800c3b2: 2301         	movs	r3, #0x1
 800c3b4: 76fb         	strb	r3, [r7, #0x1b]
 800c3b6: 7efb         	ldrb	r3, [r7, #0x1b]
 800c3b8: f083 0301    	eor	r3, r3, #0x1
 800c3bc: b2db         	uxtb	r3, r3
 800c3be: 2b00         	cmp	r3, #0x0
 800c3c0: d10e         	bne	0x800c3e0 <bmi08x_acc_trigger_mode_init+0x11c> @ imm = #0x1c
 800c3c2: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800c51c <bmi08x_acc_trigger_mode_init+0x258>
 800c3c4: 6819         	ldr	r1, [r3]
 800c3c6: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800c528 <bmi08x_acc_trigger_mode_init+0x264>
 800c3c8: 9302         	str	r3, [sp, #0x8]
 800c3ca: 2300         	movs	r3, #0x0
 800c3cc: 9301         	str	r3, [sp, #0x4]
 800c3ce: 2300         	movs	r3, #0x0
 800c3d0: 9300         	str	r3, [sp]
 800c3d2: 2300         	movs	r3, #0x0
 800c3d4: 2201         	movs	r2, #0x1
 800c3d6: 2000         	movs	r0, #0x0
 800c3d8: f014 fca1    	bl	0x8020d1e <z_log_msg_runtime_create> @ imm = #0x14942
 800c3dc: 2300         	movs	r3, #0x0
 800c3de: 617b         	str	r3, [r7, #0x14]
; 			return ret;
 800c3e0: 6b7b         	ldr	r3, [r7, #0x34]
 800c3e2: e096         	b	0x800c512 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x12c
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT1_IO_CONF, cfg->int1_conf_io);
 800c3e4: 6bbb         	ldr	r3, [r7, #0x38]
 800c3e6: f893 3026    	ldrb.w	r3, [r3, #0x26]
 800c3ea: 461a         	mov	r2, r3
 800c3ec: 2153         	movs	r1, #0x53
 800c3ee: 6878         	ldr	r0, [r7, #0x4]
 800c3f0: f013 fffb    	bl	0x80203ea <bmi08x_accel_byte_write> @ imm = #0x13ff6
 800c3f4: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 800c3f6: 6b7b         	ldr	r3, [r7, #0x34]
 800c3f8: 2b00         	cmp	r3, #0x0
 800c3fa: da1d         	bge	0x800c438 <bmi08x_acc_trigger_mode_init+0x174> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800c3fc: 2303         	movs	r3, #0x3
 800c3fe: 2b00         	cmp	r3, #0x0
 800c400: d018         	beq	0x800c434 <bmi08x_acc_trigger_mode_init+0x170> @ imm = #0x30
 800c402: 2301         	movs	r3, #0x1
 800c404: f887 3023    	strb.w	r3, [r7, #0x23]
 800c408: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800c40c: f083 0301    	eor	r3, r3, #0x1
 800c410: b2db         	uxtb	r3, r3
 800c412: 2b00         	cmp	r3, #0x0
 800c414: d10e         	bne	0x800c434 <bmi08x_acc_trigger_mode_init+0x170> @ imm = #0x1c
 800c416: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800c51c <bmi08x_acc_trigger_mode_init+0x258>
 800c418: 6819         	ldr	r1, [r3]
 800c41a: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800c528 <bmi08x_acc_trigger_mode_init+0x264>
 800c41c: 9302         	str	r3, [sp, #0x8]
 800c41e: 2300         	movs	r3, #0x0
 800c420: 9301         	str	r3, [sp, #0x4]
 800c422: 2300         	movs	r3, #0x0
 800c424: 9300         	str	r3, [sp]
 800c426: 2300         	movs	r3, #0x0
 800c428: 2201         	movs	r2, #0x1
 800c42a: 2000         	movs	r0, #0x0
 800c42c: f014 fc77    	bl	0x8020d1e <z_log_msg_runtime_create> @ imm = #0x148ee
 800c430: 2300         	movs	r3, #0x0
 800c432: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 800c434: 6b7b         	ldr	r3, [r7, #0x34]
 800c436: e06c         	b	0x800c512 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0xd8
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT2_IO_CONF, cfg->int2_conf_io);
 800c438: 6bbb         	ldr	r3, [r7, #0x38]
 800c43a: f893 3027    	ldrb.w	r3, [r3, #0x27]
 800c43e: 461a         	mov	r2, r3
 800c440: 2154         	movs	r1, #0x54
 800c442: 6878         	ldr	r0, [r7, #0x4]
 800c444: f013 ffd1    	bl	0x80203ea <bmi08x_accel_byte_write> @ imm = #0x13fa2
 800c448: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 800c44a: 6b7b         	ldr	r3, [r7, #0x34]
 800c44c: 2b00         	cmp	r3, #0x0
 800c44e: da1d         	bge	0x800c48c <bmi08x_acc_trigger_mode_init+0x1c8> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800c450: 2303         	movs	r3, #0x3
 800c452: 2b00         	cmp	r3, #0x0
 800c454: d018         	beq	0x800c488 <bmi08x_acc_trigger_mode_init+0x1c4> @ imm = #0x30
 800c456: 2301         	movs	r3, #0x1
 800c458: f887 302b    	strb.w	r3, [r7, #0x2b]
 800c45c: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800c460: f083 0301    	eor	r3, r3, #0x1
 800c464: b2db         	uxtb	r3, r3
 800c466: 2b00         	cmp	r3, #0x0
 800c468: d10e         	bne	0x800c488 <bmi08x_acc_trigger_mode_init+0x1c4> @ imm = #0x1c
 800c46a: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800c51c <bmi08x_acc_trigger_mode_init+0x258>
 800c46c: 6819         	ldr	r1, [r3]
 800c46e: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x800c528 <bmi08x_acc_trigger_mode_init+0x264>
 800c470: 9302         	str	r3, [sp, #0x8]
 800c472: 2300         	movs	r3, #0x0
 800c474: 9301         	str	r3, [sp, #0x4]
 800c476: 2300         	movs	r3, #0x0
 800c478: 9300         	str	r3, [sp]
 800c47a: 2300         	movs	r3, #0x0
 800c47c: 2201         	movs	r2, #0x1
 800c47e: 2000         	movs	r0, #0x0
 800c480: f014 fc4d    	bl	0x8020d1e <z_log_msg_runtime_create> @ imm = #0x1489a
 800c484: 2300         	movs	r3, #0x0
 800c486: 627b         	str	r3, [r7, #0x24]
; 		return ret;
 800c488: 6b7b         	ldr	r3, [r7, #0x34]
 800c48a: e042         	b	0x800c512 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x84
; 	gpio_pin_configure_dt(&cfg->int_gpio, GPIO_INPUT);
 800c48c: 6bbb         	ldr	r3, [r7, #0x38]
 800c48e: 331c         	adds	r3, #0x1c
 800c490: f44f 3180    	mov.w	r1, #0x10000
 800c494: 4618         	mov	r0, r3
 800c496: f014 fb83    	bl	0x8020ba0 <gpio_pin_configure_dt> @ imm = #0x14706
; 	gpio_init_callback(&data->gpio_cb, bmi08x_acc_gpio_callback, BIT(cfg->int_gpio.pin));
 800c49a: 6bf8         	ldr	r0, [r7, #0x3c]
 800c49c: 6bbb         	ldr	r3, [r7, #0x38]
 800c49e: f893 3020    	ldrb.w	r3, [r3, #0x20]
 800c4a2: 461a         	mov	r2, r3
 800c4a4: 2301         	movs	r3, #0x1
 800c4a6: 4093         	lsls	r3, r2
 800c4a8: 461a         	mov	r2, r3
 800c4aa: 4920         	ldr	r1, [pc, #0x80]         @ 0x800c52c <bmi08x_acc_trigger_mode_init+0x268>
 800c4ac: f014 fb8e    	bl	0x8020bcc <gpio_init_callback> @ imm = #0x1471c
; 	ret = gpio_add_callback(cfg->int_gpio.port, &data->gpio_cb);
 800c4b0: 6bbb         	ldr	r3, [r7, #0x38]
 800c4b2: 69db         	ldr	r3, [r3, #0x1c]
 800c4b4: 6bfa         	ldr	r2, [r7, #0x3c]
 800c4b6: 4611         	mov	r1, r2
 800c4b8: 4618         	mov	r0, r3
 800c4ba: f014 fb99    	bl	0x8020bf0 <gpio_add_callback> @ imm = #0x14732
 800c4be: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 800c4c0: 6b7b         	ldr	r3, [r7, #0x34]
 800c4c2: 2b00         	cmp	r3, #0x0
 800c4c4: da1d         	bge	0x800c502 <bmi08x_acc_trigger_mode_init+0x23e> @ imm = #0x3a
; 		LOG_ERR("Failed to set gpio callback.");
 800c4c6: 2303         	movs	r3, #0x3
 800c4c8: 2b00         	cmp	r3, #0x0
 800c4ca: d018         	beq	0x800c4fe <bmi08x_acc_trigger_mode_init+0x23a> @ imm = #0x30
 800c4cc: 2301         	movs	r3, #0x1
 800c4ce: f887 3032    	strb.w	r3, [r7, #0x32]
 800c4d2: f897 3032    	ldrb.w	r3, [r7, #0x32]
 800c4d6: f083 0301    	eor	r3, r3, #0x1
 800c4da: b2db         	uxtb	r3, r3
 800c4dc: 2b00         	cmp	r3, #0x0
 800c4de: d10e         	bne	0x800c4fe <bmi08x_acc_trigger_mode_init+0x23a> @ imm = #0x1c
 800c4e0: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800c51c <bmi08x_acc_trigger_mode_init+0x258>
 800c4e2: 6819         	ldr	r1, [r3]
 800c4e4: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800c530 <bmi08x_acc_trigger_mode_init+0x26c>
 800c4e6: 9302         	str	r3, [sp, #0x8]
 800c4e8: 2300         	movs	r3, #0x0
 800c4ea: 9301         	str	r3, [sp, #0x4]
 800c4ec: 2300         	movs	r3, #0x0
 800c4ee: 9300         	str	r3, [sp]
 800c4f0: 2300         	movs	r3, #0x0
 800c4f2: 2201         	movs	r2, #0x1
 800c4f4: 2000         	movs	r0, #0x0
 800c4f6: f014 fc12    	bl	0x8020d1e <z_log_msg_runtime_create> @ imm = #0x14824
 800c4fa: 2300         	movs	r3, #0x0
 800c4fc: 62fb         	str	r3, [r7, #0x2c]
; 		return ret;
 800c4fe: 6b7b         	ldr	r3, [r7, #0x34]
 800c500: e007         	b	0x800c512 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0xe
; 	gpio_pin_interrupt_configure_dt(&cfg->int_gpio, GPIO_INT_EDGE_TO_ACTIVE);
 800c502: 6bbb         	ldr	r3, [r7, #0x38]
 800c504: 331c         	adds	r3, #0x1c
 800c506: f04f 61b8    	mov.w	r1, #0x5c00000
 800c50a: 4618         	mov	r0, r3
 800c50c: f014 faeb    	bl	0x8020ae6 <gpio_pin_interrupt_configure_dt> @ imm = #0x145d6
; 	return ret;
 800c510: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800c512: 4618         	mov	r0, r3
 800c514: 3740         	adds	r7, #0x40
 800c516: 46bd         	mov	sp, r7
 800c518: bdb0         	pop	{r4, r5, r7, pc}
 800c51a: bf00         	nop

0800c51c <$d>:
 800c51c: 48 05 00 20  	.word	0x20000548
 800c520: 94 98 02 08  	.word	0x08029894
 800c524: 85 c2 00 08  	.word	0x0800c285
 800c528: ac 98 02 08  	.word	0x080298ac
 800c52c: a7 0d 02 08  	.word	0x08020da7
 800c530: c8 98 02 08  	.word	0x080298c8

0800c534 <z_impl_gpio_pin_interrupt_configure>:
; {
 800c534: b590         	push	{r4, r7, lr}
 800c536: b08b         	sub	sp, #0x2c
 800c538: af00         	add	r7, sp, #0x0
 800c53a: 60f8         	str	r0, [r7, #0xc]
 800c53c: 460b         	mov	r3, r1
 800c53e: 607a         	str	r2, [r7, #0x4]
 800c540: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 800c542: 68fb         	ldr	r3, [r7, #0xc]
 800c544: 689b         	ldr	r3, [r3, #0x8]
 800c546: 627b         	str	r3, [r7, #0x24]
; 	__unused const struct gpio_driver_config *const cfg =
 800c548: 68fb         	ldr	r3, [r7, #0xc]
 800c54a: 685b         	ldr	r3, [r3, #0x4]
 800c54c: 623b         	str	r3, [r7, #0x20]
; 	const struct gpio_driver_data *const data =
 800c54e: 68fb         	ldr	r3, [r7, #0xc]
 800c550: 691b         	ldr	r3, [r3, #0x10]
 800c552: 61fb         	str	r3, [r7, #0x1c]
; 	if (api->pin_interrupt_configure == NULL) {
 800c554: 6a7b         	ldr	r3, [r7, #0x24]
 800c556: 699b         	ldr	r3, [r3, #0x18]
 800c558: 2b00         	cmp	r3, #0x0
 800c55a: d102         	bne	0x800c562 <z_impl_gpio_pin_interrupt_configure+0x2e> @ imm = #0x4
; 		return -ENOSYS;
 800c55c: f06f 0357    	mvn	r3, #0x57
 800c560: e021         	b	0x800c5a6 <z_impl_gpio_pin_interrupt_configure+0x72> @ imm = #0x42
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800c562: 687b         	ldr	r3, [r7, #0x4]
 800c564: f403 0300    	and	r3, r3, #0x800000
 800c568: 2b00         	cmp	r3, #0x0
 800c56a: d00c         	beq	0x800c586 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x18
; 	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
 800c56c: 69fb         	ldr	r3, [r7, #0x1c]
 800c56e: 681a         	ldr	r2, [r3]
 800c570: 7afb         	ldrb	r3, [r7, #0xb]
 800c572: 2101         	movs	r1, #0x1
 800c574: fa01 f303    	lsl.w	r3, r1, r3
 800c578: 4013         	ands	r3, r2
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800c57a: 2b00         	cmp	r3, #0x0
 800c57c: d003         	beq	0x800c586 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x6
; 		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
 800c57e: 687b         	ldr	r3, [r7, #0x4]
 800c580: f083 63c0    	eor	r3, r3, #0x6000000
 800c584: 607b         	str	r3, [r7, #0x4]
; 	trig = (enum gpio_int_trig)(flags & (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1 | GPIO_INT_WAKEUP));
 800c586: 687a         	ldr	r2, [r7, #0x4]
 800c588: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800c5b0 <z_impl_gpio_pin_interrupt_configure+0x7c>
 800c58a: 4013         	ands	r3, r2
 800c58c: 61bb         	str	r3, [r7, #0x18]
; 	mode = (enum gpio_int_mode)(flags & (GPIO_INT_EDGE | GPIO_INT_DISABLE | GPIO_INT_ENABLE));
 800c58e: 687b         	ldr	r3, [r7, #0x4]
 800c590: f003 73b0    	and	r3, r3, #0x1600000
 800c594: 617b         	str	r3, [r7, #0x14]
; 	return api->pin_interrupt_configure(port, pin, mode, trig);
 800c596: 6a7b         	ldr	r3, [r7, #0x24]
 800c598: 699c         	ldr	r4, [r3, #0x18]
 800c59a: 7af9         	ldrb	r1, [r7, #0xb]
 800c59c: 69bb         	ldr	r3, [r7, #0x18]
 800c59e: 697a         	ldr	r2, [r7, #0x14]
 800c5a0: 68f8         	ldr	r0, [r7, #0xc]
 800c5a2: 47a0         	blx	r4
 800c5a4: 4603         	mov	r3, r0
; }
 800c5a6: 4618         	mov	r0, r3
 800c5a8: 372c         	adds	r7, #0x2c
 800c5aa: 46bd         	mov	sp, r7
 800c5ac: bd90         	pop	{r4, r7, pc}
 800c5ae: bf00         	nop

0800c5b0 <$d>:
 800c5b0: 40 00 00 06  	.word	0x06000040

0800c5b4 <bmi08x_gyr_thread_main>:
; {
 800c5b4: b580         	push	{r7, lr}
 800c5b6: b086         	sub	sp, #0x18
 800c5b8: af00         	add	r7, sp, #0x0
 800c5ba: 60f8         	str	r0, [r7, #0xc]
 800c5bc: 60b9         	str	r1, [r7, #0x8]
 800c5be: 607a         	str	r2, [r7, #0x4]
; 	k_thread_name_set(NULL, "bmi08x_gyr_trig");
 800c5c0: 490b         	ldr	r1, [pc, #0x2c]         @ 0x800c5f0 <bmi08x_gyr_thread_main+0x3c>
 800c5c2: 2000         	movs	r0, #0x0
 800c5c4: f014 fd21    	bl	0x802100a <k_thread_name_set> @ imm = #0x14a42
; 	const struct device *dev = (const struct device *)arg1;
 800c5c8: 68fb         	ldr	r3, [r7, #0xc]
 800c5ca: 617b         	str	r3, [r7, #0x14]
; 	struct bmi08x_gyro_data *data = dev->data;
 800c5cc: 697b         	ldr	r3, [r7, #0x14]
 800c5ce: 691b         	ldr	r3, [r3, #0x10]
 800c5d0: 613b         	str	r3, [r7, #0x10]
; 		k_sem_take(&data->sem, K_FOREVER);
 800c5d2: 693b         	ldr	r3, [r7, #0x10]
 800c5d4: f503 6113    	add.w	r1, r3, #0x930
 800c5d8: f04f 32ff    	mov.w	r2, #0xffffffff
 800c5dc: f04f 33ff    	mov.w	r3, #0xffffffff
 800c5e0: 4608         	mov	r0, r1
 800c5e2: f014 fd30    	bl	0x8021046 <k_sem_take>  @ imm = #0x14a60
; 		bmi08x_handle_interrupts_gyr((void *)dev);
 800c5e6: 6978         	ldr	r0, [r7, #0x14]
 800c5e8: f014 fd7f    	bl	0x80210ea <bmi08x_handle_interrupts_gyr> @ imm = #0x14afe
; 	while (1) {
 800c5ec: bf00         	nop
 800c5ee: e7f0         	b	0x800c5d2 <bmi08x_gyr_thread_main+0x1e> @ imm = #-0x20

0800c5f0 <$d>:
 800c5f0: e8 98 02 08  	.word	0x080298e8

0800c5f4 <bmi08x_gyr_trigger_mode_init>:
; {
 800c5f4: b5b0         	push	{r4, r5, r7, lr}
 800c5f6: b092         	sub	sp, #0x48
 800c5f8: af08         	add	r7, sp, #0x20
 800c5fa: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 800c5fc: 687b         	ldr	r3, [r7, #0x4]
 800c5fe: 691b         	ldr	r3, [r3, #0x10]
 800c600: 627b         	str	r3, [r7, #0x24]
; 	const struct bmi08x_gyro_config *cfg = dev->config;
 800c602: 687b         	ldr	r3, [r7, #0x4]
 800c604: 685b         	ldr	r3, [r3, #0x4]
 800c606: 623b         	str	r3, [r7, #0x20]
; 	if (!gpio_is_ready_dt(&cfg->int_gpio)) {
 800c608: 6a3b         	ldr	r3, [r7, #0x20]
 800c60a: 331c         	adds	r3, #0x1c
 800c60c: 4618         	mov	r0, r3
 800c60e: f014 fc0b    	bl	0x8020e28 <gpio_is_ready_dt> @ imm = #0x14816
 800c612: 4603         	mov	r3, r0
 800c614: f083 0301    	eor	r3, r3, #0x1
 800c618: b2db         	uxtb	r3, r3
 800c61a: 2b00         	cmp	r3, #0x0
 800c61c: d01c         	beq	0x800c658 <bmi08x_gyr_trigger_mode_init+0x64> @ imm = #0x38
; 		LOG_ERR("GPIO device not ready");
 800c61e: 2303         	movs	r3, #0x3
 800c620: 2b00         	cmp	r3, #0x0
 800c622: d016         	beq	0x800c652 <bmi08x_gyr_trigger_mode_init+0x5e> @ imm = #0x2c
 800c624: 2301         	movs	r3, #0x1
 800c626: 74fb         	strb	r3, [r7, #0x13]
 800c628: 7cfb         	ldrb	r3, [r7, #0x13]
 800c62a: f083 0301    	eor	r3, r3, #0x1
 800c62e: b2db         	uxtb	r3, r3
 800c630: 2b00         	cmp	r3, #0x0
 800c632: d10e         	bne	0x800c652 <bmi08x_gyr_trigger_mode_init+0x5e> @ imm = #0x1c
 800c634: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800c730 <bmi08x_gyr_trigger_mode_init+0x13c>
 800c636: 6819         	ldr	r1, [r3]
 800c638: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800c734 <bmi08x_gyr_trigger_mode_init+0x140>
 800c63a: 9302         	str	r3, [sp, #0x8]
 800c63c: 2300         	movs	r3, #0x0
 800c63e: 9301         	str	r3, [sp, #0x4]
 800c640: 2300         	movs	r3, #0x0
 800c642: 9300         	str	r3, [sp]
 800c644: 2300         	movs	r3, #0x0
 800c646: 2201         	movs	r2, #0x1
 800c648: 2000         	movs	r0, #0x0
 800c64a: f014 fd17    	bl	0x802107c <z_log_msg_runtime_create> @ imm = #0x14a2e
 800c64e: 2300         	movs	r3, #0x0
 800c650: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800c652: f06f 0312    	mvn	r3, #0x12
 800c656: e067         	b	0x800c728 <bmi08x_gyr_trigger_mode_init+0x134> @ imm = #0xce
; 	k_sem_init(&data->sem, 0, K_SEM_MAX_LIMIT);
 800c658: 6a7b         	ldr	r3, [r7, #0x24]
 800c65a: f503 6313    	add.w	r3, r3, #0x930
 800c65e: f04f 32ff    	mov.w	r2, #0xffffffff
 800c662: 2100         	movs	r1, #0x0
 800c664: 4618         	mov	r0, r3
 800c666: f014 fcde    	bl	0x8021026 <k_sem_init>  @ imm = #0x149bc
; 	k_thread_create(&data->thread, data->thread_stack,
 800c66a: 6a7b         	ldr	r3, [r7, #0x24]
 800c66c: f603 0418    	addw	r4, r3, #0x818
 800c670: 6a7b         	ldr	r3, [r7, #0x24]
 800c672: f103 0518    	add.w	r5, r3, #0x18
; 			NULL, NULL, K_PRIO_COOP(CONFIG_BMI08X_GYRO_THREAD_PRIORITY), 0, K_NO_WAIT);
 800c676: f04f 0000    	mov.w	r0, #0x0
 800c67a: f04f 0100    	mov.w	r1, #0x0
; 	k_thread_create(&data->thread, data->thread_stack,
 800c67e: e9cd 0106    	strd	r0, r1, [sp, #24]
 800c682: 2300         	movs	r3, #0x0
 800c684: 9304         	str	r3, [sp, #0x10]
 800c686: f06f 0305    	mvn	r3, #0x5
 800c68a: 9303         	str	r3, [sp, #0xc]
 800c68c: 2300         	movs	r3, #0x0
 800c68e: 9302         	str	r3, [sp, #0x8]
 800c690: 2300         	movs	r3, #0x0
 800c692: 9301         	str	r3, [sp, #0x4]
 800c694: 687b         	ldr	r3, [r7, #0x4]
 800c696: 9300         	str	r3, [sp]
 800c698: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800c738 <bmi08x_gyr_trigger_mode_init+0x144>
 800c69a: f44f 6200    	mov.w	r2, #0x800
 800c69e: 4629         	mov	r1, r5
 800c6a0: 4620         	mov	r0, r4
 800c6a2: f014 fc92    	bl	0x8020fca <k_thread_create> @ imm = #0x14924
; 	gpio_pin_configure_dt(&cfg->int_gpio, GPIO_INPUT);
 800c6a6: 6a3b         	ldr	r3, [r7, #0x20]
 800c6a8: 331c         	adds	r3, #0x1c
 800c6aa: f44f 3180    	mov.w	r1, #0x10000
 800c6ae: 4618         	mov	r0, r3
 800c6b0: f014 fc25    	bl	0x8020efe <gpio_pin_configure_dt> @ imm = #0x1484a
; 	gpio_init_callback(&data->gpio_cb, bmi08x_gyr_gpio_callback, BIT(cfg->int_gpio.pin));
 800c6b4: 6a78         	ldr	r0, [r7, #0x24]
 800c6b6: 6a3b         	ldr	r3, [r7, #0x20]
 800c6b8: f893 3020    	ldrb.w	r3, [r3, #0x20]
 800c6bc: 461a         	mov	r2, r3
 800c6be: 2301         	movs	r3, #0x1
 800c6c0: 4093         	lsls	r3, r2
 800c6c2: 461a         	mov	r2, r3
 800c6c4: 491d         	ldr	r1, [pc, #0x74]         @ 0x800c73c <bmi08x_gyr_trigger_mode_init+0x148>
 800c6c6: f014 fc30    	bl	0x8020f2a <gpio_init_callback> @ imm = #0x14860
; 	ret = gpio_add_callback(cfg->int_gpio.port, &data->gpio_cb);
 800c6ca: 6a3b         	ldr	r3, [r7, #0x20]
 800c6cc: 69db         	ldr	r3, [r3, #0x1c]
 800c6ce: 6a7a         	ldr	r2, [r7, #0x24]
 800c6d0: 4611         	mov	r1, r2
 800c6d2: 4618         	mov	r0, r3
 800c6d4: f014 fc3b    	bl	0x8020f4e <gpio_add_callback> @ imm = #0x14876
 800c6d8: 61f8         	str	r0, [r7, #0x1c]
; 	if (ret < 0) {
 800c6da: 69fb         	ldr	r3, [r7, #0x1c]
 800c6dc: 2b00         	cmp	r3, #0x0
 800c6de: da1b         	bge	0x800c718 <bmi08x_gyr_trigger_mode_init+0x124> @ imm = #0x36
; 		LOG_ERR("Failed to set gpio callback.");
 800c6e0: 2303         	movs	r3, #0x3
 800c6e2: 2b00         	cmp	r3, #0x0
 800c6e4: d016         	beq	0x800c714 <bmi08x_gyr_trigger_mode_init+0x120> @ imm = #0x2c
 800c6e6: 2301         	movs	r3, #0x1
 800c6e8: 76fb         	strb	r3, [r7, #0x1b]
 800c6ea: 7efb         	ldrb	r3, [r7, #0x1b]
 800c6ec: f083 0301    	eor	r3, r3, #0x1
 800c6f0: b2db         	uxtb	r3, r3
 800c6f2: 2b00         	cmp	r3, #0x0
 800c6f4: d10e         	bne	0x800c714 <bmi08x_gyr_trigger_mode_init+0x120> @ imm = #0x1c
 800c6f6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800c730 <bmi08x_gyr_trigger_mode_init+0x13c>
 800c6f8: 6819         	ldr	r1, [r3]
 800c6fa: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800c740 <bmi08x_gyr_trigger_mode_init+0x14c>
 800c6fc: 9302         	str	r3, [sp, #0x8]
 800c6fe: 2300         	movs	r3, #0x0
 800c700: 9301         	str	r3, [sp, #0x4]
 800c702: 2300         	movs	r3, #0x0
 800c704: 9300         	str	r3, [sp]
 800c706: 2300         	movs	r3, #0x0
 800c708: 2201         	movs	r2, #0x1
 800c70a: 2000         	movs	r0, #0x0
 800c70c: f014 fcb6    	bl	0x802107c <z_log_msg_runtime_create> @ imm = #0x1496c
 800c710: 2300         	movs	r3, #0x0
 800c712: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 800c714: 69fb         	ldr	r3, [r7, #0x1c]
 800c716: e007         	b	0x800c728 <bmi08x_gyr_trigger_mode_init+0x134> @ imm = #0xe
; 	gpio_pin_interrupt_configure_dt(&cfg->int_gpio, GPIO_INT_EDGE_TO_ACTIVE);
 800c718: 6a3b         	ldr	r3, [r7, #0x20]
 800c71a: 331c         	adds	r3, #0x1c
 800c71c: f04f 61b8    	mov.w	r1, #0x5c00000
 800c720: 4618         	mov	r0, r3
 800c722: f014 fb8f    	bl	0x8020e44 <gpio_pin_interrupt_configure_dt> @ imm = #0x1471e
; 	return ret;
 800c726: 69fb         	ldr	r3, [r7, #0x1c]
; }
 800c728: 4618         	mov	r0, r3
 800c72a: 3728         	adds	r7, #0x28
 800c72c: 46bd         	mov	sp, r7
 800c72e: bdb0         	pop	{r4, r5, r7, pc}

0800c730 <$d>:
 800c730: 4c 05 00 20  	.word	0x2000054c
 800c734: f8 98 02 08  	.word	0x080298f8
 800c738: b5 c5 00 08  	.word	0x0800c5b5
 800c73c: 05 11 02 08  	.word	0x08021105
 800c740: 10 99 02 08  	.word	0x08029910

0800c744 <LL_USART_SetBaudRate>:
; {
 800c744: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800c748: b0c0         	sub	sp, #0x100
 800c74a: af00         	add	r7, sp, #0x0
 800c74c: f8c7 00fc    	str.w	r0, [r7, #0xfc]
 800c750: f8c7 10f8    	str.w	r1, [r7, #0xf8]
 800c754: f8c7 20f4    	str.w	r2, [r7, #0xf4]
 800c758: f8c7 30f0    	str.w	r3, [r7, #0xf0]
;   if (OverSampling == LL_USART_OVERSAMPLING_8)
 800c75c: f8d7 30f4    	ldr.w	r3, [r7, #0xf4]
 800c760: f5b3 4f00    	cmp.w	r3, #0x8000
 800c764: f040 810c    	bne.w	0x800c980 <LL_USART_SetBaudRate+0x23c> @ imm = #0x218
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 800c768: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800c76c: 2200         	movs	r2, #0x0
 800c76e: f8c7 30e8    	str.w	r3, [r7, #0xe8]
 800c772: f8c7 20ec    	str.w	r2, [r7, #0xec]
 800c776: e9d7 453a    	ldrd	r4, r5, [r7, #232]
 800c77a: 4622         	mov	r2, r4
 800c77c: 462b         	mov	r3, r5
 800c77e: 1891         	adds	r1, r2, r2
 800c780: 6639         	str	r1, [r7, #0x60]
 800c782: 415b         	adcs	r3, r3
 800c784: 667b         	str	r3, [r7, #0x64]
 800c786: e9d7 2318    	ldrd	r2, r3, [r7, #96]
 800c78a: 4621         	mov	r1, r4
 800c78c: eb12 0801    	adds.w	r8, r2, r1
 800c790: 4629         	mov	r1, r5
 800c792: eb43 0901    	adc.w	r9, r3, r1
 800c796: f04f 0200    	mov.w	r2, #0x0
 800c79a: f04f 0300    	mov.w	r3, #0x0
 800c79e: ea4f 03c9    	lsl.w	r3, r9, #0x3
 800c7a2: ea43 7358    	orr.w	r3, r3, r8, lsr #29
 800c7a6: ea4f 02c8    	lsl.w	r2, r8, #0x3
 800c7aa: 4690         	mov	r8, r2
 800c7ac: 4699         	mov	r9, r3
 800c7ae: 4623         	mov	r3, r4
 800c7b0: eb18 0303    	adds.w	r3, r8, r3
 800c7b4: f8c7 30e0    	str.w	r3, [r7, #0xe0]
 800c7b8: 462b         	mov	r3, r5
 800c7ba: eb49 0303    	adc.w	r3, r9, r3
 800c7be: f8c7 30e4    	str.w	r3, [r7, #0xe4]
 800c7c2: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800c7c6: 2200         	movs	r2, #0x0
 800c7c8: 469a         	mov	r10, r3
 800c7ca: 4693         	mov	r11, r2
 800c7cc: eb1a 030a    	adds.w	r3, r10, r10
 800c7d0: 65bb         	str	r3, [r7, #0x58]
 800c7d2: eb4b 030b    	adc.w	r3, r11, r11
 800c7d6: 65fb         	str	r3, [r7, #0x5c]
 800c7d8: e9d7 2316    	ldrd	r2, r3, [r7, #88]
 800c7dc: e9d7 0138    	ldrd	r0, r1, [r7, #224]
 800c7e0: f7f3 ff2e    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xc1a4
 800c7e4: 4602         	mov	r2, r0
 800c7e6: 460b         	mov	r3, r1
 800c7e8: 4b64         	ldr	r3, [pc, #0x190]        @ 0x800c97c <LL_USART_SetBaudRate+0x238>
 800c7ea: fba3 2302    	umull	r2, r3, r3, r2
 800c7ee: 095b         	lsrs	r3, r3, #0x5
 800c7f0: b29b         	uxth	r3, r3
 800c7f2: 011b         	lsls	r3, r3, #0x4
 800c7f4: b29c         	uxth	r4, r3
 800c7f6: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800c7fa: 2200         	movs	r2, #0x0
 800c7fc: f8c7 30d8    	str.w	r3, [r7, #0xd8]
 800c800: f8c7 20dc    	str.w	r2, [r7, #0xdc]
 800c804: e9d7 8936    	ldrd	r8, r9, [r7, #216]
 800c808: 4642         	mov	r2, r8
 800c80a: 464b         	mov	r3, r9
 800c80c: 1891         	adds	r1, r2, r2
 800c80e: 6539         	str	r1, [r7, #0x50]
 800c810: 415b         	adcs	r3, r3
 800c812: 657b         	str	r3, [r7, #0x54]
 800c814: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 800c818: 4641         	mov	r1, r8
 800c81a: 1851         	adds	r1, r2, r1
 800c81c: 64b9         	str	r1, [r7, #0x48]
 800c81e: 4649         	mov	r1, r9
 800c820: 414b         	adcs	r3, r1
 800c822: 64fb         	str	r3, [r7, #0x4c]
 800c824: f04f 0200    	mov.w	r2, #0x0
 800c828: f04f 0300    	mov.w	r3, #0x0
 800c82c: e9d7 ab12    	ldrd	r10, r11, [r7, #72]
 800c830: 4659         	mov	r1, r11
 800c832: 00cb         	lsls	r3, r1, #0x3
 800c834: 4651         	mov	r1, r10
 800c836: ea43 7351    	orr.w	r3, r3, r1, lsr #29
 800c83a: 4651         	mov	r1, r10
 800c83c: 00ca         	lsls	r2, r1, #0x3
 800c83e: 4610         	mov	r0, r2
 800c840: 4619         	mov	r1, r3
 800c842: 4603         	mov	r3, r0
 800c844: 4642         	mov	r2, r8
 800c846: 189b         	adds	r3, r3, r2
 800c848: f8c7 30d0    	str.w	r3, [r7, #0xd0]
 800c84c: 464b         	mov	r3, r9
 800c84e: 460a         	mov	r2, r1
 800c850: eb42 0303    	adc.w	r3, r2, r3
 800c854: f8c7 30d4    	str.w	r3, [r7, #0xd4]
 800c858: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800c85c: 2200         	movs	r2, #0x0
 800c85e: f8c7 30c8    	str.w	r3, [r7, #0xc8]
 800c862: f8c7 20cc    	str.w	r2, [r7, #0xcc]
 800c866: e9d7 1232    	ldrd	r1, r2, [r7, #200]
 800c86a: 460b         	mov	r3, r1
 800c86c: 18db         	adds	r3, r3, r3
 800c86e: 643b         	str	r3, [r7, #0x40]
 800c870: 4613         	mov	r3, r2
 800c872: eb42 0303    	adc.w	r3, r2, r3
 800c876: 647b         	str	r3, [r7, #0x44]
 800c878: e9d7 2310    	ldrd	r2, r3, [r7, #64]
 800c87c: e9d7 0134    	ldrd	r0, r1, [r7, #208]
 800c880: f7f3 fede    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xc244
 800c884: 4602         	mov	r2, r0
 800c886: 460b         	mov	r3, r1
 800c888: 4611         	mov	r1, r2
 800c88a: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x800c97c <LL_USART_SetBaudRate+0x238>
 800c88c: fba3 2301    	umull	r2, r3, r3, r1
 800c890: 095b         	lsrs	r3, r3, #0x5
 800c892: 2264         	movs	r2, #0x64
 800c894: fb02 f303    	mul	r3, r2, r3
 800c898: 1acb         	subs	r3, r1, r3
 800c89a: 00db         	lsls	r3, r3, #0x3
 800c89c: f103 0232    	add.w	r2, r3, #0x32
 800c8a0: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800c97c <LL_USART_SetBaudRate+0x238>
 800c8a2: fba3 2302    	umull	r2, r3, r3, r2
 800c8a6: 095b         	lsrs	r3, r3, #0x5
 800c8a8: b29b         	uxth	r3, r3
 800c8aa: 005b         	lsls	r3, r3, #0x1
 800c8ac: b29b         	uxth	r3, r3
 800c8ae: f403 73f8    	and	r3, r3, #0x1f0
 800c8b2: b29b         	uxth	r3, r3
 800c8b4: 4423         	add	r3, r4
 800c8b6: b29c         	uxth	r4, r3
 800c8b8: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800c8bc: 2200         	movs	r2, #0x0
 800c8be: f8c7 30c0    	str.w	r3, [r7, #0xc0]
 800c8c2: f8c7 20c4    	str.w	r2, [r7, #0xc4]
 800c8c6: e9d7 8930    	ldrd	r8, r9, [r7, #192]
 800c8ca: 4642         	mov	r2, r8
 800c8cc: 464b         	mov	r3, r9
 800c8ce: 1891         	adds	r1, r2, r2
 800c8d0: 63b9         	str	r1, [r7, #0x38]
 800c8d2: 415b         	adcs	r3, r3
 800c8d4: 63fb         	str	r3, [r7, #0x3c]
 800c8d6: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 800c8da: 4641         	mov	r1, r8
 800c8dc: 1851         	adds	r1, r2, r1
 800c8de: 6339         	str	r1, [r7, #0x30]
 800c8e0: 4649         	mov	r1, r9
 800c8e2: 414b         	adcs	r3, r1
 800c8e4: 637b         	str	r3, [r7, #0x34]
 800c8e6: f04f 0200    	mov.w	r2, #0x0
 800c8ea: f04f 0300    	mov.w	r3, #0x0
 800c8ee: e9d7 ab0c    	ldrd	r10, r11, [r7, #48]
 800c8f2: 4659         	mov	r1, r11
 800c8f4: 00cb         	lsls	r3, r1, #0x3
 800c8f6: 4651         	mov	r1, r10
 800c8f8: ea43 7351    	orr.w	r3, r3, r1, lsr #29
 800c8fc: 4651         	mov	r1, r10
 800c8fe: 00ca         	lsls	r2, r1, #0x3
 800c900: 4610         	mov	r0, r2
 800c902: 4619         	mov	r1, r3
 800c904: 4603         	mov	r3, r0
 800c906: 4642         	mov	r2, r8
 800c908: 189b         	adds	r3, r3, r2
 800c90a: f8c7 30b8    	str.w	r3, [r7, #0xb8]
 800c90e: 464b         	mov	r3, r9
 800c910: 460a         	mov	r2, r1
 800c912: eb42 0303    	adc.w	r3, r2, r3
 800c916: f8c7 30bc    	str.w	r3, [r7, #0xbc]
 800c91a: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800c91e: 2200         	movs	r2, #0x0
 800c920: f8c7 30b0    	str.w	r3, [r7, #0xb0]
 800c924: f8c7 20b4    	str.w	r2, [r7, #0xb4]
 800c928: e9d7 122c    	ldrd	r1, r2, [r7, #176]
 800c92c: 460b         	mov	r3, r1
 800c92e: 18db         	adds	r3, r3, r3
 800c930: 62bb         	str	r3, [r7, #0x28]
 800c932: 4613         	mov	r3, r2
 800c934: eb42 0303    	adc.w	r3, r2, r3
 800c938: 62fb         	str	r3, [r7, #0x2c]
 800c93a: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 800c93e: e9d7 012e    	ldrd	r0, r1, [r7, #184]
 800c942: f7f3 fe7d    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xc306
 800c946: 4602         	mov	r2, r0
 800c948: 460b         	mov	r3, r1
 800c94a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800c97c <LL_USART_SetBaudRate+0x238>
 800c94c: fba3 1302    	umull	r1, r3, r3, r2
 800c950: 095b         	lsrs	r3, r3, #0x5
 800c952: 2164         	movs	r1, #0x64
 800c954: fb01 f303    	mul	r3, r1, r3
 800c958: 1ad3         	subs	r3, r2, r3
 800c95a: 00db         	lsls	r3, r3, #0x3
 800c95c: 3332         	adds	r3, #0x32
 800c95e: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800c97c <LL_USART_SetBaudRate+0x238>
 800c960: fba2 2303    	umull	r2, r3, r2, r3
 800c964: 095b         	lsrs	r3, r3, #0x5
 800c966: b29b         	uxth	r3, r3
 800c968: f003 0307    	and	r3, r3, #0x7
 800c96c: b29b         	uxth	r3, r3
 800c96e: 4423         	add	r3, r4
 800c970: b29b         	uxth	r3, r3
 800c972: 461a         	mov	r2, r3
 800c974: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 800c978: 609a         	str	r2, [r3, #0x8]
; }
 800c97a: e108         	b	0x800cb8e <LL_USART_SetBaudRate+0x44a> @ imm = #0x210

0800c97c <$d>:
 800c97c: 1f 85 eb 51  	.word	0x51eb851f

0800c980 <$t>:
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 800c980: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800c984: 2200         	movs	r2, #0x0
 800c986: f8c7 30a8    	str.w	r3, [r7, #0xa8]
 800c98a: f8c7 20ac    	str.w	r2, [r7, #0xac]
 800c98e: e9d7 892a    	ldrd	r8, r9, [r7, #168]
 800c992: 4642         	mov	r2, r8
 800c994: 464b         	mov	r3, r9
 800c996: 1891         	adds	r1, r2, r2
 800c998: 6239         	str	r1, [r7, #0x20]
 800c99a: 415b         	adcs	r3, r3
 800c99c: 627b         	str	r3, [r7, #0x24]
 800c99e: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 800c9a2: 4641         	mov	r1, r8
 800c9a4: 1854         	adds	r4, r2, r1
 800c9a6: 4649         	mov	r1, r9
 800c9a8: eb43 0501    	adc.w	r5, r3, r1
 800c9ac: f04f 0200    	mov.w	r2, #0x0
 800c9b0: f04f 0300    	mov.w	r3, #0x0
 800c9b4: 00eb         	lsls	r3, r5, #0x3
 800c9b6: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 800c9ba: 00e2         	lsls	r2, r4, #0x3
 800c9bc: 4614         	mov	r4, r2
 800c9be: 461d         	mov	r5, r3
 800c9c0: 4643         	mov	r3, r8
 800c9c2: 18e3         	adds	r3, r4, r3
 800c9c4: f8c7 30a0    	str.w	r3, [r7, #0xa0]
 800c9c8: 464b         	mov	r3, r9
 800c9ca: eb45 0303    	adc.w	r3, r5, r3
 800c9ce: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 800c9d2: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800c9d6: 2200         	movs	r2, #0x0
 800c9d8: f8c7 3098    	str.w	r3, [r7, #0x98]
 800c9dc: f8c7 209c    	str.w	r2, [r7, #0x9c]
 800c9e0: f04f 0200    	mov.w	r2, #0x0
 800c9e4: f04f 0300    	mov.w	r3, #0x0
 800c9e8: e9d7 4526    	ldrd	r4, r5, [r7, #152]
 800c9ec: 4629         	mov	r1, r5
 800c9ee: 008b         	lsls	r3, r1, #0x2
 800c9f0: 4621         	mov	r1, r4
 800c9f2: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 800c9f6: 4621         	mov	r1, r4
 800c9f8: 008a         	lsls	r2, r1, #0x2
 800c9fa: e9d7 0128    	ldrd	r0, r1, [r7, #160]
 800c9fe: f7f3 fe1f    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xc3c2
 800ca02: 4602         	mov	r2, r0
 800ca04: 460b         	mov	r3, r1
 800ca06: 4b65         	ldr	r3, [pc, #0x194]        @ 0x800cb9c <LL_USART_SetBaudRate+0x458>
 800ca08: fba3 2302    	umull	r2, r3, r3, r2
 800ca0c: 095b         	lsrs	r3, r3, #0x5
 800ca0e: b29b         	uxth	r3, r3
 800ca10: 011b         	lsls	r3, r3, #0x4
 800ca12: b29c         	uxth	r4, r3
 800ca14: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800ca18: 2200         	movs	r2, #0x0
 800ca1a: f8c7 3090    	str.w	r3, [r7, #0x90]
 800ca1e: f8c7 2094    	str.w	r2, [r7, #0x94]
 800ca22: e9d7 8924    	ldrd	r8, r9, [r7, #144]
 800ca26: 4642         	mov	r2, r8
 800ca28: 464b         	mov	r3, r9
 800ca2a: 1891         	adds	r1, r2, r2
 800ca2c: 61b9         	str	r1, [r7, #0x18]
 800ca2e: 415b         	adcs	r3, r3
 800ca30: 61fb         	str	r3, [r7, #0x1c]
 800ca32: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 800ca36: 4641         	mov	r1, r8
 800ca38: 1851         	adds	r1, r2, r1
 800ca3a: 6139         	str	r1, [r7, #0x10]
 800ca3c: 4649         	mov	r1, r9
 800ca3e: 414b         	adcs	r3, r1
 800ca40: 617b         	str	r3, [r7, #0x14]
 800ca42: f04f 0200    	mov.w	r2, #0x0
 800ca46: f04f 0300    	mov.w	r3, #0x0
 800ca4a: e9d7 ab04    	ldrd	r10, r11, [r7, #16]
 800ca4e: 4659         	mov	r1, r11
 800ca50: 00cb         	lsls	r3, r1, #0x3
 800ca52: 4651         	mov	r1, r10
 800ca54: ea43 7351    	orr.w	r3, r3, r1, lsr #29
 800ca58: 4651         	mov	r1, r10
 800ca5a: 00ca         	lsls	r2, r1, #0x3
 800ca5c: 4610         	mov	r0, r2
 800ca5e: 4619         	mov	r1, r3
 800ca60: 4603         	mov	r3, r0
 800ca62: 4642         	mov	r2, r8
 800ca64: 189b         	adds	r3, r3, r2
 800ca66: f8c7 3088    	str.w	r3, [r7, #0x88]
 800ca6a: 464b         	mov	r3, r9
 800ca6c: 460a         	mov	r2, r1
 800ca6e: eb42 0303    	adc.w	r3, r2, r3
 800ca72: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800ca76: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800ca7a: 2200         	movs	r2, #0x0
 800ca7c: f8c7 3080    	str.w	r3, [r7, #0x80]
 800ca80: f8c7 2084    	str.w	r2, [r7, #0x84]
 800ca84: f04f 0200    	mov.w	r2, #0x0
 800ca88: f04f 0300    	mov.w	r3, #0x0
 800ca8c: e9d7 8920    	ldrd	r8, r9, [r7, #128]
 800ca90: 4649         	mov	r1, r9
 800ca92: 008b         	lsls	r3, r1, #0x2
 800ca94: 4641         	mov	r1, r8
 800ca96: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 800ca9a: 4641         	mov	r1, r8
 800ca9c: 008a         	lsls	r2, r1, #0x2
 800ca9e: e9d7 0122    	ldrd	r0, r1, [r7, #136]
 800caa2: f7f3 fdcd    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xc466
 800caa6: 4602         	mov	r2, r0
 800caa8: 460b         	mov	r3, r1
 800caaa: 4611         	mov	r1, r2
 800caac: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x800cb9c <LL_USART_SetBaudRate+0x458>
 800caae: fba3 2301    	umull	r2, r3, r3, r1
 800cab2: 095b         	lsrs	r3, r3, #0x5
 800cab4: 2264         	movs	r2, #0x64
 800cab6: fb02 f303    	mul	r3, r2, r3
 800caba: 1acb         	subs	r3, r1, r3
 800cabc: 011b         	lsls	r3, r3, #0x4
 800cabe: 3332         	adds	r3, #0x32
 800cac0: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x800cb9c <LL_USART_SetBaudRate+0x458>
 800cac2: fba2 2303    	umull	r2, r3, r2, r3
 800cac6: 095b         	lsrs	r3, r3, #0x5
 800cac8: b29b         	uxth	r3, r3
 800caca: f003 03f0    	and	r3, r3, #0xf0
 800cace: b29b         	uxth	r3, r3
 800cad0: 4423         	add	r3, r4
 800cad2: b29c         	uxth	r4, r3
 800cad4: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800cad8: 2200         	movs	r2, #0x0
 800cada: 67bb         	str	r3, [r7, #0x78]
 800cadc: 67fa         	str	r2, [r7, #0x7c]
 800cade: e9d7 891e    	ldrd	r8, r9, [r7, #120]
 800cae2: 4642         	mov	r2, r8
 800cae4: 464b         	mov	r3, r9
 800cae6: 1891         	adds	r1, r2, r2
 800cae8: 60b9         	str	r1, [r7, #0x8]
 800caea: 415b         	adcs	r3, r3
 800caec: 60fb         	str	r3, [r7, #0xc]
 800caee: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800caf2: 4641         	mov	r1, r8
 800caf4: 1851         	adds	r1, r2, r1
 800caf6: 6039         	str	r1, [r7]
 800caf8: 4649         	mov	r1, r9
 800cafa: 414b         	adcs	r3, r1
 800cafc: 607b         	str	r3, [r7, #0x4]
 800cafe: f04f 0200    	mov.w	r2, #0x0
 800cb02: f04f 0300    	mov.w	r3, #0x0
 800cb06: e9d7 ab00    	ldrd	r10, r11, [r7]
 800cb0a: 4659         	mov	r1, r11
 800cb0c: 00cb         	lsls	r3, r1, #0x3
 800cb0e: 4651         	mov	r1, r10
 800cb10: ea43 7351    	orr.w	r3, r3, r1, lsr #29
 800cb14: 4651         	mov	r1, r10
 800cb16: 00ca         	lsls	r2, r1, #0x3
 800cb18: 4610         	mov	r0, r2
 800cb1a: 4619         	mov	r1, r3
 800cb1c: 4603         	mov	r3, r0
 800cb1e: 4642         	mov	r2, r8
 800cb20: 189b         	adds	r3, r3, r2
 800cb22: 673b         	str	r3, [r7, #0x70]
 800cb24: 464b         	mov	r3, r9
 800cb26: 460a         	mov	r2, r1
 800cb28: eb42 0303    	adc.w	r3, r2, r3
 800cb2c: 677b         	str	r3, [r7, #0x74]
 800cb2e: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800cb32: 2200         	movs	r2, #0x0
 800cb34: 66bb         	str	r3, [r7, #0x68]
 800cb36: 66fa         	str	r2, [r7, #0x6c]
 800cb38: f04f 0200    	mov.w	r2, #0x0
 800cb3c: f04f 0300    	mov.w	r3, #0x0
 800cb40: e9d7 891a    	ldrd	r8, r9, [r7, #104]
 800cb44: 4649         	mov	r1, r9
 800cb46: 008b         	lsls	r3, r1, #0x2
 800cb48: 4641         	mov	r1, r8
 800cb4a: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 800cb4e: 4641         	mov	r1, r8
 800cb50: 008a         	lsls	r2, r1, #0x2
 800cb52: e9d7 011c    	ldrd	r0, r1, [r7, #112]
 800cb56: f7f3 fd73    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xc51a
 800cb5a: 4602         	mov	r2, r0
 800cb5c: 460b         	mov	r3, r1
 800cb5e: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800cb9c <LL_USART_SetBaudRate+0x458>
 800cb60: fba3 1302    	umull	r1, r3, r3, r2
 800cb64: 095b         	lsrs	r3, r3, #0x5
 800cb66: 2164         	movs	r1, #0x64
 800cb68: fb01 f303    	mul	r3, r1, r3
 800cb6c: 1ad3         	subs	r3, r2, r3
 800cb6e: 011b         	lsls	r3, r3, #0x4
 800cb70: 3332         	adds	r3, #0x32
 800cb72: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800cb9c <LL_USART_SetBaudRate+0x458>
 800cb74: fba2 2303    	umull	r2, r3, r2, r3
 800cb78: 095b         	lsrs	r3, r3, #0x5
 800cb7a: b29b         	uxth	r3, r3
 800cb7c: f003 030f    	and	r3, r3, #0xf
 800cb80: b29b         	uxth	r3, r3
 800cb82: 4423         	add	r3, r4
 800cb84: b29b         	uxth	r3, r3
 800cb86: 461a         	mov	r2, r3
 800cb88: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 800cb8c: 609a         	str	r2, [r3, #0x8]
; }
 800cb8e: bf00         	nop
 800cb90: f507 7780    	add.w	r7, r7, #0x100
 800cb94: 46bd         	mov	sp, r7
 800cb96: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 800cb9a: bf00         	nop

0800cb9c <$d>:
 800cb9c: 1f 85 eb 51  	.word	0x51eb851f

0800cba0 <uart_stm32_set_baudrate>:
; {
 800cba0: b580         	push	{r7, lr}
 800cba2: b08c         	sub	sp, #0x30
 800cba4: af04         	add	r7, sp, #0x10
 800cba6: 6078         	str	r0, [r7, #0x4]
 800cba8: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800cbaa: 687b         	ldr	r3, [r7, #0x4]
 800cbac: 685b         	ldr	r3, [r3, #0x4]
 800cbae: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 800cbb0: 69bb         	ldr	r3, [r7, #0x18]
 800cbb2: 681b         	ldr	r3, [r3]
 800cbb4: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = dev->data;
 800cbb6: 687b         	ldr	r3, [r7, #0x4]
 800cbb8: 691b         	ldr	r3, [r3, #0x10]
 800cbba: 61fb         	str	r3, [r7, #0x1c]
; 		if (clock_control_get_rate(data->clock,
 800cbbc: 69fb         	ldr	r3, [r7, #0x1c]
 800cbbe: 6818         	ldr	r0, [r3]
; 					   (clock_control_subsys_t)&config->pclken[0],
 800cbc0: 69bb         	ldr	r3, [r7, #0x18]
 800cbc2: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(data->clock,
 800cbc4: f107 0208    	add.w	r2, r7, #0x8
 800cbc8: 4619         	mov	r1, r3
 800cbca: f014 faf9    	bl	0x80211c0 <clock_control_get_rate> @ imm = #0x145f2
 800cbce: 4603         	mov	r3, r0
 800cbd0: 2b00         	cmp	r3, #0x0
 800cbd2: da1a         	bge	0x800cc0a <uart_stm32_set_baudrate+0x6a> @ imm = #0x34
; 			LOG_ERR("Failed call clock_control_get_rate(pclken[0])");
 800cbd4: 2303         	movs	r3, #0x3
 800cbd6: 2b00         	cmp	r3, #0x0
 800cbd8: d021         	beq	0x800cc1e <uart_stm32_set_baudrate+0x7e> @ imm = #0x42
 800cbda: 2301         	movs	r3, #0x1
 800cbdc: 74fb         	strb	r3, [r7, #0x13]
 800cbde: 7cfb         	ldrb	r3, [r7, #0x13]
 800cbe0: f083 0301    	eor	r3, r3, #0x1
 800cbe4: b2db         	uxtb	r3, r3
 800cbe6: 2b00         	cmp	r3, #0x0
 800cbe8: d119         	bne	0x800cc1e <uart_stm32_set_baudrate+0x7e> @ imm = #0x32
 800cbea: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800cc24 <uart_stm32_set_baudrate+0x84>
 800cbec: 6819         	ldr	r1, [r3]
 800cbee: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800cc28 <uart_stm32_set_baudrate+0x88>
 800cbf0: 9302         	str	r3, [sp, #0x8]
 800cbf2: 2300         	movs	r3, #0x0
 800cbf4: 9301         	str	r3, [sp, #0x4]
 800cbf6: 2300         	movs	r3, #0x0
 800cbf8: 9300         	str	r3, [sp]
 800cbfa: 2300         	movs	r3, #0x0
 800cbfc: 2201         	movs	r2, #0x1
 800cbfe: 2000         	movs	r0, #0x0
 800cc00: f015 f874    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x150e8
 800cc04: 2300         	movs	r3, #0x0
 800cc06: 60fb         	str	r3, [r7, #0xc]
; 			return;
 800cc08: e009         	b	0x800cc1e <uart_stm32_set_baudrate+0x7e> @ imm = #0x12
; 		LL_USART_SetOverSampling(usart,
 800cc0a: 2100         	movs	r1, #0x0
 800cc0c: 6978         	ldr	r0, [r7, #0x14]
 800cc0e: f014 fc71    	bl	0x80214f4 <LL_USART_SetOverSampling> @ imm = #0x148e2
; 		LL_USART_SetBaudRate(usart,
 800cc12: 68b9         	ldr	r1, [r7, #0x8]
 800cc14: 683b         	ldr	r3, [r7]
 800cc16: 2200         	movs	r2, #0x0
 800cc18: 6978         	ldr	r0, [r7, #0x14]
 800cc1a: f7ff fd93    	bl	0x800c744 <LL_USART_SetBaudRate> @ imm = #-0x4da
; }
 800cc1e: 3720         	adds	r7, #0x20
 800cc20: 46bd         	mov	sp, r7
 800cc22: bd80         	pop	{r7, pc}

0800cc24 <$d>:
 800cc24: 50 05 00 20  	.word	0x20000550
 800cc28: 3c 99 02 08  	.word	0x0802993c

0800cc2c <uart_stm32_configure>:
; {
 800cc2c: b580         	push	{r7, lr}
 800cc2e: b08a         	sub	sp, #0x28
 800cc30: af00         	add	r7, sp, #0x0
 800cc32: 6078         	str	r0, [r7, #0x4]
 800cc34: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800cc36: 687b         	ldr	r3, [r7, #0x4]
 800cc38: 685b         	ldr	r3, [r3, #0x4]
 800cc3a: 627b         	str	r3, [r7, #0x24]
; 	USART_TypeDef *usart = config->usart;
 800cc3c: 6a7b         	ldr	r3, [r7, #0x24]
 800cc3e: 681b         	ldr	r3, [r3]
 800cc40: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 800cc42: 687b         	ldr	r3, [r7, #0x4]
 800cc44: 691b         	ldr	r3, [r3, #0x10]
 800cc46: 61fb         	str	r3, [r7, #0x1c]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 800cc48: 69fb         	ldr	r3, [r7, #0x1c]
 800cc4a: 685b         	ldr	r3, [r3, #0x4]
 800cc4c: 61bb         	str	r3, [r7, #0x18]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 800cc4e: 683b         	ldr	r3, [r7]
 800cc50: 791b         	ldrb	r3, [r3, #0x4]
 800cc52: 4618         	mov	r0, r3
 800cc54: f015 f8f4    	bl	0x8021e40 <uart_stm32_cfg2ll_parity> @ imm = #0x151e8
 800cc58: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 800cc5a: 683b         	ldr	r3, [r7]
 800cc5c: 795b         	ldrb	r3, [r3, #0x5]
 800cc5e: 4619         	mov	r1, r3
 800cc60: 6a78         	ldr	r0, [r7, #0x24]
 800cc62: f015 f91c    	bl	0x8021e9e <uart_stm32_cfg2ll_stopbits> @ imm = #0x15238
 800cc66: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 800cc68: 683b         	ldr	r3, [r7]
 800cc6a: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 800cc6c: 683b         	ldr	r3, [r7]
 800cc6e: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 800cc70: 4619         	mov	r1, r3
 800cc72: 4610         	mov	r0, r2
 800cc74: f015 f953    	bl	0x8021f1e <uart_stm32_cfg2ll_databits> @ imm = #0x152a6
 800cc78: 60f8         	str	r0, [r7, #0xc]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 800cc7a: 683b         	ldr	r3, [r7]
 800cc7c: 791b         	ldrb	r3, [r3, #0x4]
 800cc7e: 2b03         	cmp	r3, #0x3
 800cc80: d003         	beq	0x800cc8a <uart_stm32_configure+0x5e> @ imm = #0x6
; 	    (cfg->parity == UART_CFG_PARITY_SPACE)) {
 800cc82: 683b         	ldr	r3, [r7]
 800cc84: 791b         	ldrb	r3, [r3, #0x4]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 800cc86: 2b04         	cmp	r3, #0x4
 800cc88: d102         	bne	0x800cc90 <uart_stm32_configure+0x64> @ imm = #0x4
; 		return -ENOTSUP;
 800cc8a: f06f 0385    	mvn	r3, #0x85
 800cc8e: e04f         	b	0x800cd30 <uart_stm32_configure+0x104> @ imm = #0x9e
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 800cc90: 683b         	ldr	r3, [r7]
 800cc92: 791b         	ldrb	r3, [r3, #0x4]
 800cc94: 2b00         	cmp	r3, #0x0
 800cc96: d006         	beq	0x800cca6 <uart_stm32_configure+0x7a> @ imm = #0xc
; 	    (cfg->data_bits == UART_CFG_DATA_BITS_9)) {
 800cc98: 683b         	ldr	r3, [r7]
 800cc9a: 799b         	ldrb	r3, [r3, #0x6]
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 800cc9c: 2b04         	cmp	r3, #0x4
 800cc9e: d102         	bne	0x800cca6 <uart_stm32_configure+0x7a> @ imm = #0x4
; 		return -ENOTSUP;
 800cca0: f06f 0385    	mvn	r3, #0x85
 800cca4: e044         	b	0x800cd30 <uart_stm32_configure+0x104> @ imm = #0x88
; 	if (uart_stm32_ll2cfg_stopbits(stopbits) != cfg->stop_bits) {
 800cca6: 6938         	ldr	r0, [r7, #0x10]
 800cca8: f015 f919    	bl	0x8021ede <uart_stm32_ll2cfg_stopbits> @ imm = #0x15232
 800ccac: 4603         	mov	r3, r0
 800ccae: 461a         	mov	r2, r3
 800ccb0: 683b         	ldr	r3, [r7]
 800ccb2: 795b         	ldrb	r3, [r3, #0x5]
 800ccb4: 429a         	cmp	r2, r3
 800ccb6: d002         	beq	0x800ccbe <uart_stm32_configure+0x92> @ imm = #0x4
; 		return -ENOTSUP;
 800ccb8: f06f 0385    	mvn	r3, #0x85
 800ccbc: e038         	b	0x800cd30 <uart_stm32_configure+0x104> @ imm = #0x70
; 	if (uart_stm32_ll2cfg_databits(databits, parity) != cfg->data_bits) {
 800ccbe: 6979         	ldr	r1, [r7, #0x14]
 800ccc0: 68f8         	ldr	r0, [r7, #0xc]
 800ccc2: f015 f947    	bl	0x8021f54 <uart_stm32_ll2cfg_databits> @ imm = #0x1528e
 800ccc6: 4603         	mov	r3, r0
 800ccc8: 461a         	mov	r2, r3
 800ccca: 683b         	ldr	r3, [r7]
 800cccc: 799b         	ldrb	r3, [r3, #0x6]
 800ccce: 429a         	cmp	r2, r3
 800ccd0: d002         	beq	0x800ccd8 <uart_stm32_configure+0xac> @ imm = #0x4
; 		return -ENOTSUP;
 800ccd2: f06f 0385    	mvn	r3, #0x85
 800ccd6: e02b         	b	0x800cd30 <uart_stm32_configure+0x104> @ imm = #0x56
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 800ccd8: 683b         	ldr	r3, [r7]
 800ccda: 79db         	ldrb	r3, [r3, #0x7]
 800ccdc: 2b00         	cmp	r3, #0x0
 800ccde: d016         	beq	0x800cd0e <uart_stm32_configure+0xe2> @ imm = #0x2c
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 800cce0: 683b         	ldr	r3, [r7]
 800cce2: 79db         	ldrb	r3, [r3, #0x7]
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 800cce4: 2b01         	cmp	r3, #0x1
 800cce6: d10f         	bne	0x800cd08 <uart_stm32_configure+0xdc> @ imm = #0x1e
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 800cce8: 6a3b         	ldr	r3, [r7, #0x20]
 800ccea: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800cd38 <uart_stm32_configure+0x10c>
 800ccec: 4293         	cmp	r3, r2
 800ccee: d00e         	beq	0x800cd0e <uart_stm32_configure+0xe2> @ imm = #0x1c
; 			IS_UART_HWFLOW_INSTANCE(usart))
 800ccf0: 6a3b         	ldr	r3, [r7, #0x20]
 800ccf2: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800cd3c <uart_stm32_configure+0x110>
 800ccf4: 4293         	cmp	r3, r2
 800ccf6: d00a         	beq	0x800cd0e <uart_stm32_configure+0xe2> @ imm = #0x14
 800ccf8: 6a3b         	ldr	r3, [r7, #0x20]
 800ccfa: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800cd40 <uart_stm32_configure+0x114>
 800ccfc: 4293         	cmp	r3, r2
 800ccfe: d006         	beq	0x800cd0e <uart_stm32_configure+0xe2> @ imm = #0xc
 800cd00: 6a3b         	ldr	r3, [r7, #0x20]
 800cd02: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800cd44 <uart_stm32_configure+0x118>
 800cd04: 4293         	cmp	r3, r2
 800cd06: d002         	beq	0x800cd0e <uart_stm32_configure+0xe2> @ imm = #0x4
; 		return -ENOTSUP;
 800cd08: f06f 0385    	mvn	r3, #0x85
 800cd0c: e010         	b	0x800cd30 <uart_stm32_configure+0x104> @ imm = #0x20
; 	LL_USART_Disable(usart);
 800cd0e: 6a38         	ldr	r0, [r7, #0x20]
 800cd10: f014 fb78    	bl	0x8021404 <LL_USART_Disable> @ imm = #0x146f0
; 	uart_stm32_parameters_set(dev, cfg);
 800cd14: 6839         	ldr	r1, [r7]
 800cd16: 6878         	ldr	r0, [r7, #0x4]
 800cd18: f015 f960    	bl	0x8021fdc <uart_stm32_parameters_set> @ imm = #0x152c0
; 	LL_USART_Enable(usart);
 800cd1c: 6a38         	ldr	r0, [r7, #0x20]
 800cd1e: f014 fb61    	bl	0x80213e4 <LL_USART_Enable> @ imm = #0x146c2
; 	*uart_cfg = *cfg;
 800cd22: 69bb         	ldr	r3, [r7, #0x18]
 800cd24: 683a         	ldr	r2, [r7]
 800cd26: e892 0003    	ldm.w	r2, {r0, r1}
 800cd2a: e883 0003    	stm.w	r3, {r0, r1}
; 	return 0;
 800cd2e: 2300         	movs	r3, #0x0
; };
 800cd30: 4618         	mov	r0, r3
 800cd32: 3728         	adds	r7, #0x28
 800cd34: 46bd         	mov	sp, r7
 800cd36: bd80         	pop	{r7, pc}

0800cd38 <$d>:
 800cd38: 00 10 01 40  	.word	0x40011000
 800cd3c: 00 44 00 40  	.word	0x40004400
 800cd40: 00 48 00 40  	.word	0x40004800
 800cd44: 00 14 01 40  	.word	0x40011400

0800cd48 <uart_stm32_poll_in>:
; {
 800cd48: b580         	push	{r7, lr}
 800cd4a: b082         	sub	sp, #0x8
 800cd4c: af00         	add	r7, sp, #0x0
 800cd4e: 6078         	str	r0, [r7, #0x4]
 800cd50: 6039         	str	r1, [r7]
; 	return uart_stm32_poll_in_visitor(dev, (void *)c, poll_in_u8);
 800cd52: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800cd68 <uart_stm32_poll_in+0x20>
 800cd54: 6839         	ldr	r1, [r7]
 800cd56: 6878         	ldr	r0, [r7, #0x4]
 800cd58: f015 fa05    	bl	0x8022166 <uart_stm32_poll_in_visitor> @ imm = #0x1540a
 800cd5c: 4603         	mov	r3, r0
; }
 800cd5e: 4618         	mov	r0, r3
 800cd60: 3708         	adds	r7, #0x8
 800cd62: 46bd         	mov	sp, r7
 800cd64: bd80         	pop	{r7, pc}
 800cd66: bf00         	nop

0800cd68 <$d>:
 800cd68: 4d 22 02 08  	.word	0x0802224d

0800cd6c <uart_stm32_poll_out>:
; {
 800cd6c: b580         	push	{r7, lr}
 800cd6e: b082         	sub	sp, #0x8
 800cd70: af00         	add	r7, sp, #0x0
 800cd72: 6078         	str	r0, [r7, #0x4]
 800cd74: 460b         	mov	r3, r1
 800cd76: 70fb         	strb	r3, [r7, #0x3]
; 	uart_stm32_poll_out_visitor(dev, c, poll_out_u8);
 800cd78: 78fb         	ldrb	r3, [r7, #0x3]
 800cd7a: b29b         	uxth	r3, r3
 800cd7c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800cd90 <uart_stm32_poll_out+0x24>
 800cd7e: 4619         	mov	r1, r3
 800cd80: 6878         	ldr	r0, [r7, #0x4]
 800cd82: f015 fa17    	bl	0x80221b4 <uart_stm32_poll_out_visitor> @ imm = #0x1542e
; }
 800cd86: bf00         	nop
 800cd88: 3708         	adds	r7, #0x8
 800cd8a: 46bd         	mov	sp, r7
 800cd8c: bd80         	pop	{r7, pc}
 800cd8e: bf00         	nop

0800cd90 <$d>:
 800cd90: 6d 22 02 08  	.word	0x0802226d

0800cd94 <__uart_stm32_get_clock>:
; {
 800cd94: b480         	push	{r7}
 800cd96: b085         	sub	sp, #0x14
 800cd98: af00         	add	r7, sp, #0x0
 800cd9a: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800cd9c: 687b         	ldr	r3, [r7, #0x4]
 800cd9e: 691b         	ldr	r3, [r3, #0x10]
 800cda0: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800cda2: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800cdb8 <__uart_stm32_get_clock+0x24>
 800cda4: 60bb         	str	r3, [r7, #0x8]
; 	data->clock = clk;
 800cda6: 68fb         	ldr	r3, [r7, #0xc]
 800cda8: 68ba         	ldr	r2, [r7, #0x8]
 800cdaa: 601a         	str	r2, [r3]
; }
 800cdac: bf00         	nop
 800cdae: 3714         	adds	r7, #0x14
 800cdb0: 46bd         	mov	sp, r7
 800cdb2: f85d 7b04    	ldr	r7, [sp], #4
 800cdb6: 4770         	bx	lr

0800cdb8 <$d>:
 800cdb8: 48 7a 02 08  	.word	0x08027a48

0800cdbc <uart_stm32_fifo_fill>:
; {
 800cdbc: b590         	push	{r4, r7, lr}
 800cdbe: b085         	sub	sp, #0x14
 800cdc0: af00         	add	r7, sp, #0x0
 800cdc2: 60f8         	str	r0, [r7, #0xc]
 800cdc4: 60b9         	str	r1, [r7, #0x8]
 800cdc6: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 800cdc8: 68f8         	ldr	r0, [r7, #0xc]
 800cdca: f015 f805    	bl	0x8021dd8 <uart_stm32_get_databits> @ imm = #0x1500a
 800cdce: 4604         	mov	r4, r0
 800cdd0: 68f8         	ldr	r0, [r7, #0xc]
 800cdd2: f014 ffbb    	bl	0x8021d4c <uart_stm32_get_parity> @ imm = #0x14f76
 800cdd6: 4603         	mov	r3, r0
 800cdd8: 4619         	mov	r1, r3
 800cdda: 4620         	mov	r0, r4
 800cddc: f015 f8ba    	bl	0x8021f54 <uart_stm32_ll2cfg_databits> @ imm = #0x15174
 800cde0: 4603         	mov	r3, r0
 800cde2: 2b04         	cmp	r3, #0x4
 800cde4: d102         	bne	0x800cdec <uart_stm32_fifo_fill+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 800cde6: f06f 0385    	mvn	r3, #0x85
 800cdea: e006         	b	0x800cdfa <uart_stm32_fifo_fill+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_fill_visitor(dev, (const void *)tx_data, size,
 800cdec: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800ce04 <uart_stm32_fifo_fill+0x48>
 800cdee: 687a         	ldr	r2, [r7, #0x4]
 800cdf0: 68b9         	ldr	r1, [r7, #0x8]
 800cdf2: 68f8         	ldr	r0, [r7, #0xc]
 800cdf4: f015 fab5    	bl	0x8022362 <uart_stm32_fifo_fill_visitor> @ imm = #0x1556a
 800cdf8: 4603         	mov	r3, r0
; }
 800cdfa: 4618         	mov	r0, r3
 800cdfc: 3714         	adds	r7, #0x14
 800cdfe: 46bd         	mov	sp, r7
 800ce00: bd90         	pop	{r4, r7, pc}
 800ce02: bf00         	nop

0800ce04 <$d>:
 800ce04: fb 23 02 08  	.word	0x080223fb

0800ce08 <uart_stm32_fifo_read>:
; {
 800ce08: b590         	push	{r4, r7, lr}
 800ce0a: b085         	sub	sp, #0x14
 800ce0c: af00         	add	r7, sp, #0x0
 800ce0e: 60f8         	str	r0, [r7, #0xc]
 800ce10: 60b9         	str	r1, [r7, #0x8]
 800ce12: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 800ce14: 68f8         	ldr	r0, [r7, #0xc]
 800ce16: f014 ffdf    	bl	0x8021dd8 <uart_stm32_get_databits> @ imm = #0x14fbe
 800ce1a: 4604         	mov	r4, r0
 800ce1c: 68f8         	ldr	r0, [r7, #0xc]
 800ce1e: f014 ff95    	bl	0x8021d4c <uart_stm32_get_parity> @ imm = #0x14f2a
 800ce22: 4603         	mov	r3, r0
 800ce24: 4619         	mov	r1, r3
 800ce26: 4620         	mov	r0, r4
 800ce28: f015 f894    	bl	0x8021f54 <uart_stm32_ll2cfg_databits> @ imm = #0x15128
 800ce2c: 4603         	mov	r3, r0
 800ce2e: 2b04         	cmp	r3, #0x4
 800ce30: d102         	bne	0x800ce38 <uart_stm32_fifo_read+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 800ce32: f06f 0385    	mvn	r3, #0x85
 800ce36: e006         	b	0x800ce46 <uart_stm32_fifo_read+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_read_visitor(dev, (void *)rx_data, size,
 800ce38: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800ce50 <uart_stm32_fifo_read+0x48>
 800ce3a: 687a         	ldr	r2, [r7, #0x4]
 800ce3c: 68b9         	ldr	r1, [r7, #0x8]
 800ce3e: 68f8         	ldr	r0, [r7, #0xc]
 800ce40: f015 faef    	bl	0x8022422 <uart_stm32_fifo_read_visitor> @ imm = #0x155de
 800ce44: 4603         	mov	r3, r0
; }
 800ce46: 4618         	mov	r0, r3
 800ce48: 3714         	adds	r7, #0x14
 800ce4a: 46bd         	mov	sp, r7
 800ce4c: bd90         	pop	{r4, r7, pc}
 800ce4e: bf00         	nop

0800ce50 <$d>:
 800ce50: 85 24 02 08  	.word	0x08022485

0800ce54 <uart_stm32_irq_err_enable>:
; {
 800ce54: b580         	push	{r7, lr}
 800ce56: b084         	sub	sp, #0x10
 800ce58: af00         	add	r7, sp, #0x0
 800ce5a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800ce5c: 687b         	ldr	r3, [r7, #0x4]
 800ce5e: 685b         	ldr	r3, [r3, #0x4]
 800ce60: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 800ce62: 68fb         	ldr	r3, [r7, #0xc]
 800ce64: 681b         	ldr	r3, [r3]
 800ce66: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableIT_ERROR(usart);
 800ce68: 68b8         	ldr	r0, [r7, #0x8]
 800ce6a: f014 fd93    	bl	0x8021994 <LL_USART_EnableIT_ERROR> @ imm = #0x14b26
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 800ce6e: 68bb         	ldr	r3, [r7, #0x8]
 800ce70: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800ceb4 <uart_stm32_irq_err_enable+0x60>
 800ce72: 4293         	cmp	r3, r2
 800ce74: d013         	beq	0x800ce9e <uart_stm32_irq_err_enable+0x4a> @ imm = #0x26
 800ce76: 68bb         	ldr	r3, [r7, #0x8]
 800ce78: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x800ceb8 <uart_stm32_irq_err_enable+0x64>
 800ce7a: 4293         	cmp	r3, r2
 800ce7c: d00f         	beq	0x800ce9e <uart_stm32_irq_err_enable+0x4a> @ imm = #0x1e
 800ce7e: 68bb         	ldr	r3, [r7, #0x8]
 800ce80: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800cebc <uart_stm32_irq_err_enable+0x68>
 800ce82: 4293         	cmp	r3, r2
 800ce84: d00b         	beq	0x800ce9e <uart_stm32_irq_err_enable+0x4a> @ imm = #0x16
 800ce86: 68bb         	ldr	r3, [r7, #0x8]
 800ce88: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800cec0 <uart_stm32_irq_err_enable+0x6c>
 800ce8a: 4293         	cmp	r3, r2
 800ce8c: d007         	beq	0x800ce9e <uart_stm32_irq_err_enable+0x4a> @ imm = #0xe
 800ce8e: 68bb         	ldr	r3, [r7, #0x8]
 800ce90: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800cec4 <uart_stm32_irq_err_enable+0x70>
 800ce92: 4293         	cmp	r3, r2
 800ce94: d003         	beq	0x800ce9e <uart_stm32_irq_err_enable+0x4a> @ imm = #0x6
 800ce96: 68bb         	ldr	r3, [r7, #0x8]
 800ce98: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800cec8 <uart_stm32_irq_err_enable+0x74>
 800ce9a: 4293         	cmp	r3, r2
 800ce9c: d102         	bne	0x800cea4 <uart_stm32_irq_err_enable+0x50> @ imm = #0x4
; 		LL_USART_EnableIT_LBD(usart);
 800ce9e: 68b8         	ldr	r0, [r7, #0x8]
 800cea0: f014 fd68    	bl	0x8021974 <LL_USART_EnableIT_LBD> @ imm = #0x14ad0
; 	LL_USART_EnableIT_PE(usart);
 800cea4: 68b8         	ldr	r0, [r7, #0x8]
 800cea6: f014 fd42    	bl	0x802192e <LL_USART_EnableIT_PE> @ imm = #0x14a84
; }
 800ceaa: bf00         	nop
 800ceac: 3710         	adds	r7, #0x10
 800ceae: 46bd         	mov	sp, r7
 800ceb0: bd80         	pop	{r7, pc}
 800ceb2: bf00         	nop

0800ceb4 <$d>:
 800ceb4: 00 10 01 40  	.word	0x40011000
 800ceb8: 00 44 00 40  	.word	0x40004400
 800cebc: 00 48 00 40  	.word	0x40004800
 800cec0: 00 4c 00 40  	.word	0x40004c00
 800cec4: 00 50 00 40  	.word	0x40005000
 800cec8: 00 14 01 40  	.word	0x40011400

0800cecc <uart_stm32_irq_err_disable>:
; {
 800cecc: b580         	push	{r7, lr}
 800cece: b084         	sub	sp, #0x10
 800ced0: af00         	add	r7, sp, #0x0
 800ced2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800ced4: 687b         	ldr	r3, [r7, #0x4]
 800ced6: 685b         	ldr	r3, [r3, #0x4]
 800ced8: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 800ceda: 68fb         	ldr	r3, [r7, #0xc]
 800cedc: 681b         	ldr	r3, [r3]
 800cede: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_DisableIT_ERROR(usart);
 800cee0: 68b8         	ldr	r0, [r7, #0x8]
 800cee2: f014 fe16    	bl	0x8021b12 <LL_USART_DisableIT_ERROR> @ imm = #0x14c2c
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 800cee6: 68bb         	ldr	r3, [r7, #0x8]
 800cee8: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800cf2c <uart_stm32_irq_err_disable+0x60>
 800ceea: 4293         	cmp	r3, r2
 800ceec: d013         	beq	0x800cf16 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x26
 800ceee: 68bb         	ldr	r3, [r7, #0x8]
 800cef0: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x800cf30 <uart_stm32_irq_err_disable+0x64>
 800cef2: 4293         	cmp	r3, r2
 800cef4: d00f         	beq	0x800cf16 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x1e
 800cef6: 68bb         	ldr	r3, [r7, #0x8]
 800cef8: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800cf34 <uart_stm32_irq_err_disable+0x68>
 800cefa: 4293         	cmp	r3, r2
 800cefc: d00b         	beq	0x800cf16 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x16
 800cefe: 68bb         	ldr	r3, [r7, #0x8]
 800cf00: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800cf38 <uart_stm32_irq_err_disable+0x6c>
 800cf02: 4293         	cmp	r3, r2
 800cf04: d007         	beq	0x800cf16 <uart_stm32_irq_err_disable+0x4a> @ imm = #0xe
 800cf06: 68bb         	ldr	r3, [r7, #0x8]
 800cf08: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800cf3c <uart_stm32_irq_err_disable+0x70>
 800cf0a: 4293         	cmp	r3, r2
 800cf0c: d003         	beq	0x800cf16 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x6
 800cf0e: 68bb         	ldr	r3, [r7, #0x8]
 800cf10: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800cf40 <uart_stm32_irq_err_disable+0x74>
 800cf12: 4293         	cmp	r3, r2
 800cf14: d102         	bne	0x800cf1c <uart_stm32_irq_err_disable+0x50> @ imm = #0x4
; 		LL_USART_DisableIT_LBD(usart);
 800cf16: 68b8         	ldr	r0, [r7, #0x8]
 800cf18: f014 fdeb    	bl	0x8021af2 <LL_USART_DisableIT_LBD> @ imm = #0x14bd6
; 	LL_USART_DisableIT_PE(usart);
 800cf1c: 68b8         	ldr	r0, [r7, #0x8]
 800cf1e: f014 fdc5    	bl	0x8021aac <LL_USART_DisableIT_PE> @ imm = #0x14b8a
; }
 800cf22: bf00         	nop
 800cf24: 3710         	adds	r7, #0x10
 800cf26: 46bd         	mov	sp, r7
 800cf28: bd80         	pop	{r7, pc}
 800cf2a: bf00         	nop

0800cf2c <$d>:
 800cf2c: 00 10 01 40  	.word	0x40011000
 800cf30: 00 44 00 40  	.word	0x40004400
 800cf34: 00 48 00 40  	.word	0x40004800
 800cf38: 00 4c 00 40  	.word	0x40004c00
 800cf3c: 00 50 00 40  	.word	0x40005000
 800cf40: 00 14 01 40  	.word	0x40011400

0800cf44 <async_evt_rx_rdy>:
; {
 800cf44: b580         	push	{r7, lr}
 800cf46: b090         	sub	sp, #0x40
 800cf48: af06         	add	r7, sp, #0x18
 800cf4a: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("rx_rdy: (%d %d)", data->dma_rx.offset, data->dma_rx.counter);
 800cf4c: 2303         	movs	r3, #0x3
 800cf4e: 2b03         	cmp	r3, #0x3
 800cf50: d920         	bls	0x800cf94 <async_evt_rx_rdy+0x50> @ imm = #0x40
 800cf52: 2301         	movs	r3, #0x1
 800cf54: f887 3027    	strb.w	r3, [r7, #0x27]
 800cf58: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800cf5c: f083 0301    	eor	r3, r3, #0x1
 800cf60: b2db         	uxtb	r3, r3
 800cf62: 2b00         	cmp	r3, #0x0
 800cf64: d116         	bne	0x800cf94 <async_evt_rx_rdy+0x50> @ imm = #0x2c
 800cf66: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800cfe4 <async_evt_rx_rdy+0xa0>
 800cf68: 6819         	ldr	r1, [r3]
 800cf6a: 687b         	ldr	r3, [r7, #0x4]
 800cf6c: 6f5b         	ldr	r3, [r3, #0x74]
 800cf6e: 687a         	ldr	r2, [r7, #0x4]
 800cf70: 6f92         	ldr	r2, [r2, #0x78]
 800cf72: 9205         	str	r2, [sp, #0x14]
 800cf74: 9304         	str	r3, [sp, #0x10]
 800cf76: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800cfe8 <async_evt_rx_rdy+0xa4>
 800cf78: 9303         	str	r3, [sp, #0xc]
 800cf7a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800cfec <async_evt_rx_rdy+0xa8>
 800cf7c: 9302         	str	r3, [sp, #0x8]
 800cf7e: 2308         	movs	r3, #0x8
 800cf80: 9301         	str	r3, [sp, #0x4]
 800cf82: 2300         	movs	r3, #0x0
 800cf84: 9300         	str	r3, [sp]
 800cf86: 2300         	movs	r3, #0x0
 800cf88: 2204         	movs	r2, #0x4
 800cf8a: 2000         	movs	r0, #0x0
 800cf8c: f014 feae    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14d5c
 800cf90: 2300         	movs	r3, #0x0
 800cf92: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800cf94: f107 030c    	add.w	r3, r7, #0xc
 800cf98: 2200         	movs	r2, #0x0
 800cf9a: 601a         	str	r2, [r3]
 800cf9c: 605a         	str	r2, [r3, #0x4]
 800cf9e: 609a         	str	r2, [r3, #0x8]
 800cfa0: 60da         	str	r2, [r3, #0xc]
 800cfa2: 611a         	str	r2, [r3, #0x10]
 800cfa4: 2302         	movs	r3, #0x2
 800cfa6: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx.buf = data->dma_rx.buffer,
 800cfa8: 687b         	ldr	r3, [r7, #0x4]
 800cfaa: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 800cfac: 613b         	str	r3, [r7, #0x10]
; 		.data.rx.offset = data->dma_rx.offset
 800cfae: 687b         	ldr	r3, [r7, #0x4]
 800cfb0: 6f5b         	ldr	r3, [r3, #0x74]
; 	struct uart_event event = {
 800cfb2: 617b         	str	r3, [r7, #0x14]
; 		.data.rx.len = data->dma_rx.counter - data->dma_rx.offset,
 800cfb4: 687b         	ldr	r3, [r7, #0x4]
 800cfb6: 6f9a         	ldr	r2, [r3, #0x78]
 800cfb8: 687b         	ldr	r3, [r7, #0x4]
 800cfba: 6f5b         	ldr	r3, [r3, #0x74]
 800cfbc: 1ad3         	subs	r3, r2, r3
; 	struct uart_event event = {
 800cfbe: 61bb         	str	r3, [r7, #0x18]
; 	data->dma_rx.offset = data->dma_rx.counter;
 800cfc0: 687b         	ldr	r3, [r7, #0x4]
 800cfc2: 6f9a         	ldr	r2, [r3, #0x78]
 800cfc4: 687b         	ldr	r3, [r7, #0x4]
 800cfc6: 675a         	str	r2, [r3, #0x74]
; 	if (event.data.rx.len > 0) {
 800cfc8: 69bb         	ldr	r3, [r7, #0x18]
 800cfca: 2b00         	cmp	r3, #0x0
 800cfcc: d005         	beq	0x800cfda <async_evt_rx_rdy+0x96> @ imm = #0xa
; 		async_user_callback(data, &event);
 800cfce: f107 030c    	add.w	r3, r7, #0xc
 800cfd2: 4619         	mov	r1, r3
 800cfd4: 6878         	ldr	r0, [r7, #0x4]
 800cfd6: f015 fb38    	bl	0x802264a <async_user_callback> @ imm = #0x15670
; }
 800cfda: bf00         	nop
 800cfdc: 3728         	adds	r7, #0x28
 800cfde: 46bd         	mov	sp, r7
 800cfe0: bd80         	pop	{r7, pc}
 800cfe2: bf00         	nop

0800cfe4 <$d>:
 800cfe4: 50 05 00 20  	.word	0x20000550
 800cfe8: d8 ae 02 08  	.word	0x0802aed8
 800cfec: 6c 99 02 08  	.word	0x0802996c

0800cff0 <async_evt_rx_err>:
; {
 800cff0: b580         	push	{r7, lr}
 800cff2: b090         	sub	sp, #0x40
 800cff4: af06         	add	r7, sp, #0x18
 800cff6: 6078         	str	r0, [r7, #0x4]
 800cff8: 6039         	str	r1, [r7]
; 	LOG_DBG("rx error: %d", err_code);
 800cffa: 2303         	movs	r3, #0x3
 800cffc: 2b03         	cmp	r3, #0x3
 800cffe: d91c         	bls	0x800d03a <async_evt_rx_err+0x4a> @ imm = #0x38
 800d000: 2301         	movs	r3, #0x1
 800d002: f887 3027    	strb.w	r3, [r7, #0x27]
 800d006: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800d00a: f083 0301    	eor	r3, r3, #0x1
 800d00e: b2db         	uxtb	r3, r3
 800d010: 2b00         	cmp	r3, #0x0
 800d012: d112         	bne	0x800d03a <async_evt_rx_err+0x4a> @ imm = #0x24
 800d014: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800d068 <async_evt_rx_err+0x78>
 800d016: 6819         	ldr	r1, [r3]
 800d018: 683b         	ldr	r3, [r7]
 800d01a: 9304         	str	r3, [sp, #0x10]
 800d01c: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800d06c <async_evt_rx_err+0x7c>
 800d01e: 9303         	str	r3, [sp, #0xc]
 800d020: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800d070 <async_evt_rx_err+0x80>
 800d022: 9302         	str	r3, [sp, #0x8]
 800d024: 2308         	movs	r3, #0x8
 800d026: 9301         	str	r3, [sp, #0x4]
 800d028: 2300         	movs	r3, #0x0
 800d02a: 9300         	str	r3, [sp]
 800d02c: 2300         	movs	r3, #0x0
 800d02e: 2204         	movs	r2, #0x4
 800d030: 2000         	movs	r0, #0x0
 800d032: f014 fe5b    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14cb6
 800d036: 2300         	movs	r3, #0x0
 800d038: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800d03a: 2306         	movs	r3, #0x6
 800d03c: 733b         	strb	r3, [r7, #0xc]
 800d03e: 683b         	ldr	r3, [r7]
 800d040: b2db         	uxtb	r3, r3
 800d042: 743b         	strb	r3, [r7, #0x10]
; 		.data.rx_stop.data.buf = data->dma_rx.buffer
 800d044: 687b         	ldr	r3, [r7, #0x4]
 800d046: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 800d048: 617b         	str	r3, [r7, #0x14]
 800d04a: 2300         	movs	r3, #0x0
 800d04c: 61bb         	str	r3, [r7, #0x18]
; 		.data.rx_stop.data.len = data->dma_rx.counter,
 800d04e: 687b         	ldr	r3, [r7, #0x4]
 800d050: 6f9b         	ldr	r3, [r3, #0x78]
; 	struct uart_event event = {
 800d052: 61fb         	str	r3, [r7, #0x1c]
; 	async_user_callback(data, &event);
 800d054: f107 030c    	add.w	r3, r7, #0xc
 800d058: 4619         	mov	r1, r3
 800d05a: 6878         	ldr	r0, [r7, #0x4]
 800d05c: f015 faf5    	bl	0x802264a <async_user_callback> @ imm = #0x155ea
; }
 800d060: bf00         	nop
 800d062: 3728         	adds	r7, #0x28
 800d064: 46bd         	mov	sp, r7
 800d066: bd80         	pop	{r7, pc}

0800d068 <$d>:
 800d068: 50 05 00 20  	.word	0x20000550
 800d06c: 60 af 02 08  	.word	0x0802af60
 800d070: 80 99 02 08  	.word	0x08029980

0800d074 <async_evt_tx_done>:
; {
 800d074: b580         	push	{r7, lr}
 800d076: b090         	sub	sp, #0x40
 800d078: af06         	add	r7, sp, #0x18
 800d07a: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx done: %d", data->dma_tx.counter);
 800d07c: 2303         	movs	r3, #0x3
 800d07e: 2b03         	cmp	r3, #0x3
 800d080: d91e         	bls	0x800d0c0 <async_evt_tx_done+0x4c> @ imm = #0x3c
 800d082: 2301         	movs	r3, #0x1
 800d084: f887 3027    	strb.w	r3, [r7, #0x27]
 800d088: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800d08c: f083 0301    	eor	r3, r3, #0x1
 800d090: b2db         	uxtb	r3, r3
 800d092: 2b00         	cmp	r3, #0x0
 800d094: d114         	bne	0x800d0c0 <async_evt_tx_done+0x4c> @ imm = #0x28
 800d096: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800d104 <async_evt_tx_done+0x90>
 800d098: 6819         	ldr	r1, [r3]
 800d09a: 687b         	ldr	r3, [r7, #0x4]
 800d09c: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 800d0a0: 9304         	str	r3, [sp, #0x10]
 800d0a2: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800d108 <async_evt_tx_done+0x94>
 800d0a4: 9303         	str	r3, [sp, #0xc]
 800d0a6: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800d10c <async_evt_tx_done+0x98>
 800d0a8: 9302         	str	r3, [sp, #0x8]
 800d0aa: 2308         	movs	r3, #0x8
 800d0ac: 9301         	str	r3, [sp, #0x4]
 800d0ae: 2300         	movs	r3, #0x0
 800d0b0: 9300         	str	r3, [sp]
 800d0b2: 2300         	movs	r3, #0x0
 800d0b4: 2204         	movs	r2, #0x4
 800d0b6: 2000         	movs	r0, #0x0
 800d0b8: f014 fe18    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14c30
 800d0bc: 2300         	movs	r3, #0x0
 800d0be: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800d0c0: f107 030c    	add.w	r3, r7, #0xc
 800d0c4: 2200         	movs	r2, #0x0
 800d0c6: 601a         	str	r2, [r3]
 800d0c8: 605a         	str	r2, [r3, #0x4]
 800d0ca: 609a         	str	r2, [r3, #0x8]
 800d0cc: 60da         	str	r2, [r3, #0xc]
 800d0ce: 611a         	str	r2, [r3, #0x10]
; 		.data.tx.buf = data->dma_tx.buffer,
 800d0d0: 687b         	ldr	r3, [r7, #0x4]
 800d0d2: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 800d0d6: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 800d0d8: 687b         	ldr	r3, [r7, #0x4]
 800d0da: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 800d0de: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 800d0e0: 687b         	ldr	r3, [r7, #0x4]
 800d0e2: 2200         	movs	r2, #0x0
 800d0e4: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 800d0e8: 687b         	ldr	r3, [r7, #0x4]
 800d0ea: 2200         	movs	r2, #0x0
 800d0ec: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 800d0f0: f107 030c    	add.w	r3, r7, #0xc
 800d0f4: 4619         	mov	r1, r3
 800d0f6: 6878         	ldr	r0, [r7, #0x4]
 800d0f8: f015 faa7    	bl	0x802264a <async_user_callback> @ imm = #0x1554e
; }
 800d0fc: bf00         	nop
 800d0fe: 3728         	adds	r7, #0x28
 800d100: 46bd         	mov	sp, r7
 800d102: bd80         	pop	{r7, pc}

0800d104 <$d>:
 800d104: 50 05 00 20  	.word	0x20000550
 800d108: 10 af 02 08  	.word	0x0802af10
 800d10c: 94 99 02 08  	.word	0x08029994

0800d110 <async_evt_tx_abort>:
; {
 800d110: b580         	push	{r7, lr}
 800d112: b090         	sub	sp, #0x40
 800d114: af06         	add	r7, sp, #0x18
 800d116: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx abort: %d", data->dma_tx.counter);
 800d118: 2303         	movs	r3, #0x3
 800d11a: 2b03         	cmp	r3, #0x3
 800d11c: d91e         	bls	0x800d15c <async_evt_tx_abort+0x4c> @ imm = #0x3c
 800d11e: 2301         	movs	r3, #0x1
 800d120: f887 3027    	strb.w	r3, [r7, #0x27]
 800d124: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800d128: f083 0301    	eor	r3, r3, #0x1
 800d12c: b2db         	uxtb	r3, r3
 800d12e: 2b00         	cmp	r3, #0x0
 800d130: d114         	bne	0x800d15c <async_evt_tx_abort+0x4c> @ imm = #0x28
 800d132: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800d1a4 <async_evt_tx_abort+0x94>
 800d134: 6819         	ldr	r1, [r3]
 800d136: 687b         	ldr	r3, [r7, #0x4]
 800d138: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 800d13c: 9304         	str	r3, [sp, #0x10]
 800d13e: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800d1a8 <async_evt_tx_abort+0x98>
 800d140: 9303         	str	r3, [sp, #0xc]
 800d142: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800d1ac <async_evt_tx_abort+0x9c>
 800d144: 9302         	str	r3, [sp, #0x8]
 800d146: 2308         	movs	r3, #0x8
 800d148: 9301         	str	r3, [sp, #0x4]
 800d14a: 2300         	movs	r3, #0x0
 800d14c: 9300         	str	r3, [sp]
 800d14e: 2300         	movs	r3, #0x0
 800d150: 2204         	movs	r2, #0x4
 800d152: 2000         	movs	r0, #0x0
 800d154: f014 fdca    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14b94
 800d158: 2300         	movs	r3, #0x0
 800d15a: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800d15c: f107 030c    	add.w	r3, r7, #0xc
 800d160: 2200         	movs	r2, #0x0
 800d162: 601a         	str	r2, [r3]
 800d164: 605a         	str	r2, [r3, #0x4]
 800d166: 609a         	str	r2, [r3, #0x8]
 800d168: 60da         	str	r2, [r3, #0xc]
 800d16a: 611a         	str	r2, [r3, #0x10]
 800d16c: 2301         	movs	r3, #0x1
 800d16e: 733b         	strb	r3, [r7, #0xc]
; 		.data.tx.buf = data->dma_tx.buffer,
 800d170: 687b         	ldr	r3, [r7, #0x4]
 800d172: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 800d176: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 800d178: 687b         	ldr	r3, [r7, #0x4]
 800d17a: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 800d17e: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 800d180: 687b         	ldr	r3, [r7, #0x4]
 800d182: 2200         	movs	r2, #0x0
 800d184: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 800d188: 687b         	ldr	r3, [r7, #0x4]
 800d18a: 2200         	movs	r2, #0x0
 800d18c: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 800d190: f107 030c    	add.w	r3, r7, #0xc
 800d194: 4619         	mov	r1, r3
 800d196: 6878         	ldr	r0, [r7, #0x4]
 800d198: f015 fa57    	bl	0x802264a <async_user_callback> @ imm = #0x154ae
; }
 800d19c: bf00         	nop
 800d19e: 3728         	adds	r7, #0x28
 800d1a0: 46bd         	mov	sp, r7
 800d1a2: bd80         	pop	{r7, pc}

0800d1a4 <$d>:
 800d1a4: 50 05 00 20  	.word	0x20000550
 800d1a8: a4 af 02 08  	.word	0x0802afa4
 800d1ac: a4 99 02 08  	.word	0x080299a4

0800d1b0 <async_timer_start>:
; {
 800d1b0: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800d1b4: b08a         	sub	sp, #0x28
 800d1b6: af06         	add	r7, sp, #0x18
 800d1b8: 6078         	str	r0, [r7, #0x4]
 800d1ba: 6039         	str	r1, [r7]
; 	if ((timeout != SYS_FOREVER_US) && (timeout != 0)) {
 800d1bc: 683b         	ldr	r3, [r7]
 800d1be: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800d1c2: d037         	beq	0x800d234 <async_timer_start+0x84> @ imm = #0x6e
 800d1c4: 683b         	ldr	r3, [r7]
 800d1c6: 2b00         	cmp	r3, #0x0
 800d1c8: d034         	beq	0x800d234 <async_timer_start+0x84> @ imm = #0x68
; 		LOG_DBG("async timer started for %d us", timeout);
 800d1ca: 2303         	movs	r3, #0x3
 800d1cc: 2b03         	cmp	r3, #0x3
 800d1ce: d91a         	bls	0x800d206 <async_timer_start+0x56> @ imm = #0x34
 800d1d0: 2301         	movs	r3, #0x1
 800d1d2: 73fb         	strb	r3, [r7, #0xf]
 800d1d4: 7bfb         	ldrb	r3, [r7, #0xf]
 800d1d6: f083 0301    	eor	r3, r3, #0x1
 800d1da: b2db         	uxtb	r3, r3
 800d1dc: 2b00         	cmp	r3, #0x0
 800d1de: d112         	bne	0x800d206 <async_timer_start+0x56> @ imm = #0x24
 800d1e0: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800d240 <async_timer_start+0x90>
 800d1e2: 6819         	ldr	r1, [r3]
 800d1e4: 683b         	ldr	r3, [r7]
 800d1e6: 9304         	str	r3, [sp, #0x10]
 800d1e8: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800d244 <async_timer_start+0x94>
 800d1ea: 9303         	str	r3, [sp, #0xc]
 800d1ec: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800d248 <async_timer_start+0x98>
 800d1ee: 9302         	str	r3, [sp, #0x8]
 800d1f0: 2308         	movs	r3, #0x8
 800d1f2: 9301         	str	r3, [sp, #0x4]
 800d1f4: 2300         	movs	r3, #0x0
 800d1f6: 9300         	str	r3, [sp]
 800d1f8: 2300         	movs	r3, #0x0
 800d1fa: 2204         	movs	r2, #0x4
 800d1fc: 2000         	movs	r0, #0x0
 800d1fe: f014 fd75    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14aea
 800d202: 2300         	movs	r3, #0x0
 800d204: 60bb         	str	r3, [r7, #0x8]
; 		k_work_reschedule(work, K_USEC(timeout));
 800d206: 683b         	ldr	r3, [r7]
 800d208: ea23 73e3    	bic.w	r3, r3, r3, asr #31
 800d20c: 17da         	asrs	r2, r3, #0x1f
 800d20e: 461c         	mov	r4, r3
 800d210: 4615         	mov	r5, r2
 800d212: f114 0863    	adds.w	r8, r4, #0x63
 800d216: f145 0900    	adc	r9, r5, #0x0
 800d21a: f04f 0264    	mov.w	r2, #0x64
 800d21e: f04f 0300    	mov.w	r3, #0x0
 800d222: 4640         	mov	r0, r8
 800d224: 4649         	mov	r1, r9
 800d226: f7f3 fa0b    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xcbea
 800d22a: 4602         	mov	r2, r0
 800d22c: 460b         	mov	r3, r1
 800d22e: 6878         	ldr	r0, [r7, #0x4]
 800d230: f007 fb9a    	bl	0x8014968 <k_work_reschedule> @ imm = #0x7734
; }
 800d234: bf00         	nop
 800d236: 3710         	adds	r7, #0x10
 800d238: 46bd         	mov	sp, r7
 800d23a: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 800d23e: bf00         	nop

0800d240 <$d>:
 800d240: 50 05 00 20  	.word	0x20000550
 800d244: fc ae 02 08  	.word	0x0802aefc
 800d248: b8 99 02 08  	.word	0x080299b8

0800d24c <uart_stm32_isr>:
; {
 800d24c: b580         	push	{r7, lr}
 800d24e: b08c         	sub	sp, #0x30
 800d250: af04         	add	r7, sp, #0x10
 800d252: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800d254: 687b         	ldr	r3, [r7, #0x4]
 800d256: 691b         	ldr	r3, [r3, #0x10]
 800d258: 61fb         	str	r3, [r7, #0x1c]
; 	const struct uart_stm32_config *config = dev->config;
 800d25a: 687b         	ldr	r3, [r7, #0x4]
 800d25c: 685b         	ldr	r3, [r3, #0x4]
 800d25e: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 800d260: 69bb         	ldr	r3, [r7, #0x18]
 800d262: 681b         	ldr	r3, [r3]
 800d264: 617b         	str	r3, [r7, #0x14]
; 	if (data->user_cb) {
 800d266: 69fb         	ldr	r3, [r7, #0x1c]
 800d268: 689b         	ldr	r3, [r3, #0x8]
 800d26a: 2b00         	cmp	r3, #0x0
 800d26c: d006         	beq	0x800d27c <uart_stm32_isr+0x30> @ imm = #0xc
; 		data->user_cb(dev, data->user_data);
 800d26e: 69fb         	ldr	r3, [r7, #0x1c]
 800d270: 689b         	ldr	r3, [r3, #0x8]
 800d272: 69fa         	ldr	r2, [r7, #0x1c]
 800d274: 68d2         	ldr	r2, [r2, #0xc]
 800d276: 4611         	mov	r1, r2
 800d278: 6878         	ldr	r0, [r7, #0x4]
 800d27a: 4798         	blx	r3
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 800d27c: 6978         	ldr	r0, [r7, #0x14]
 800d27e: f014 fc6b    	bl	0x8021b58 <LL_USART_IsEnabledIT_IDLE> @ imm = #0x148d6
 800d282: 4603         	mov	r3, r0
 800d284: 2b00         	cmp	r3, #0x0
 800d286: d036         	beq	0x800d2f6 <uart_stm32_isr+0xaa> @ imm = #0x6c
; 			LL_USART_IsActiveFlag_IDLE(usart)) {
 800d288: 6978         	ldr	r0, [r7, #0x14]
 800d28a: f014 fa03    	bl	0x8021694 <LL_USART_IsActiveFlag_IDLE> @ imm = #0x14406
 800d28e: 4603         	mov	r3, r0
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 800d290: 2b00         	cmp	r3, #0x0
 800d292: d030         	beq	0x800d2f6 <uart_stm32_isr+0xaa> @ imm = #0x60
; 		LL_USART_ClearFlag_IDLE(usart);
 800d294: 6978         	ldr	r0, [r7, #0x14]
 800d296: f014 faa5    	bl	0x80217e4 <LL_USART_ClearFlag_IDLE> @ imm = #0x1454a
; 		LOG_DBG("idle interrupt occurred");
 800d29a: 2303         	movs	r3, #0x3
 800d29c: 2b03         	cmp	r3, #0x3
 800d29e: d918         	bls	0x800d2d2 <uart_stm32_isr+0x86> @ imm = #0x30
 800d2a0: 2301         	movs	r3, #0x1
 800d2a2: 74fb         	strb	r3, [r7, #0x13]
 800d2a4: 7cfb         	ldrb	r3, [r7, #0x13]
 800d2a6: f083 0301    	eor	r3, r3, #0x1
 800d2aa: b2db         	uxtb	r3, r3
 800d2ac: 2b00         	cmp	r3, #0x0
 800d2ae: d110         	bne	0x800d2d2 <uart_stm32_isr+0x86> @ imm = #0x20
 800d2b0: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800d348 <uart_stm32_isr+0xfc>
 800d2b2: 6819         	ldr	r1, [r3]
 800d2b4: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800d34c <uart_stm32_isr+0x100>
 800d2b6: 9303         	str	r3, [sp, #0xc]
 800d2b8: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800d350 <uart_stm32_isr+0x104>
 800d2ba: 9302         	str	r3, [sp, #0x8]
 800d2bc: 2308         	movs	r3, #0x8
 800d2be: 9301         	str	r3, [sp, #0x4]
 800d2c0: 2300         	movs	r3, #0x0
 800d2c2: 9300         	str	r3, [sp]
 800d2c4: 2300         	movs	r3, #0x0
 800d2c6: 2204         	movs	r2, #0x4
 800d2c8: 2000         	movs	r0, #0x0
 800d2ca: f014 fd0f    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14a1e
 800d2ce: 2300         	movs	r3, #0x0
 800d2d0: 60fb         	str	r3, [r7, #0xc]
; 		if (data->dma_rx.timeout == 0) {
 800d2d2: 69fb         	ldr	r3, [r7, #0x1c]
 800d2d4: 6fdb         	ldr	r3, [r3, #0x7c]
 800d2d6: 2b00         	cmp	r3, #0x0
 800d2d8: d103         	bne	0x800d2e2 <uart_stm32_isr+0x96> @ imm = #0x6
; 			uart_stm32_dma_rx_flush(dev);
 800d2da: 6878         	ldr	r0, [r7, #0x4]
 800d2dc: f015 f9fd    	bl	0x80226da <uart_stm32_dma_rx_flush> @ imm = #0x153fa
; 		if (data->dma_rx.timeout == 0) {
 800d2e0: e02b         	b	0x800d33a <uart_stm32_isr+0xee> @ imm = #0x56
; 			async_timer_start(&data->dma_rx.timeout_work,
 800d2e2: 69fb         	ldr	r3, [r7, #0x1c]
 800d2e4: f103 0280    	add.w	r2, r3, #0x80
 800d2e8: 69fb         	ldr	r3, [r7, #0x1c]
 800d2ea: 6fdb         	ldr	r3, [r3, #0x7c]
 800d2ec: 4619         	mov	r1, r3
 800d2ee: 4610         	mov	r0, r2
 800d2f0: f7ff ff5e    	bl	0x800d1b0 <async_timer_start> @ imm = #-0x144
; 		if (data->dma_rx.timeout == 0) {
 800d2f4: e021         	b	0x800d33a <uart_stm32_isr+0xee> @ imm = #0x42
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 800d2f6: 6978         	ldr	r0, [r7, #0x14]
 800d2f8: f014 fc54    	bl	0x8021ba4 <LL_USART_IsEnabledIT_TC> @ imm = #0x148a8
 800d2fc: 4603         	mov	r3, r0
 800d2fe: 2b00         	cmp	r3, #0x0
 800d300: d00c         	beq	0x800d31c <uart_stm32_isr+0xd0> @ imm = #0x18
; 			LL_USART_IsActiveFlag_TC(usart)) {
 800d302: 6978         	ldr	r0, [r7, #0x14]
 800d304: f014 f9ec    	bl	0x80216e0 <LL_USART_IsActiveFlag_TC> @ imm = #0x143d8
 800d308: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 800d30a: 2b00         	cmp	r3, #0x0
 800d30c: d006         	beq	0x800d31c <uart_stm32_isr+0xd0> @ imm = #0xc
; 		LL_USART_DisableIT_TC(usart);
 800d30e: 6978         	ldr	r0, [r7, #0x14]
 800d310: f014 fba9    	bl	0x8021a66 <LL_USART_DisableIT_TC> @ imm = #0x14752
; 		async_evt_tx_done(data);
 800d314: 69f8         	ldr	r0, [r7, #0x1c]
 800d316: f7ff fead    	bl	0x800d074 <async_evt_tx_done> @ imm = #-0x2a6
 800d31a: e00e         	b	0x800d33a <uart_stm32_isr+0xee> @ imm = #0x1c
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 800d31c: 6978         	ldr	r0, [r7, #0x14]
 800d31e: f014 fc2e    	bl	0x8021b7e <LL_USART_IsEnabledIT_RXNE> @ imm = #0x1485c
 800d322: 4603         	mov	r3, r0
 800d324: 2b00         	cmp	r3, #0x0
 800d326: d008         	beq	0x800d33a <uart_stm32_isr+0xee> @ imm = #0x10
; 			LL_USART_IsActiveFlag_RXNE(usart)) {
 800d328: 6978         	ldr	r0, [r7, #0x14]
 800d32a: f014 f9c6    	bl	0x80216ba <LL_USART_IsActiveFlag_RXNE> @ imm = #0x1438c
 800d32e: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 800d330: 2b00         	cmp	r3, #0x0
 800d332: d002         	beq	0x800d33a <uart_stm32_isr+0xee> @ imm = #0x4
; 		LL_USART_ClearFlag_RXNE(usart);
 800d334: 6978         	ldr	r0, [r7, #0x14]
 800d336: f014 fa75    	bl	0x8021824 <LL_USART_ClearFlag_RXNE> @ imm = #0x144ea
; 	uart_stm32_err_check(dev);
 800d33a: 6878         	ldr	r0, [r7, #0x4]
 800d33c: f014 ffa6    	bl	0x802228c <uart_stm32_err_check> @ imm = #0x14f4c
; }
 800d340: bf00         	nop
 800d342: 3720         	adds	r7, #0x20
 800d344: 46bd         	mov	sp, r7
 800d346: bd80         	pop	{r7, pc}

0800d348 <$d>:
 800d348: 50 05 00 20  	.word	0x20000550
 800d34c: ec ae 02 08  	.word	0x0802aeec
 800d350: dc 99 02 08  	.word	0x080299dc

0800d354 <uart_stm32_async_rx_disable>:
; {
 800d354: b580         	push	{r7, lr}
 800d356: b096         	sub	sp, #0x58
 800d358: af04         	add	r7, sp, #0x10
 800d35a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800d35c: 687b         	ldr	r3, [r7, #0x4]
 800d35e: 685b         	ldr	r3, [r3, #0x4]
 800d360: 647b         	str	r3, [r7, #0x44]
; 	USART_TypeDef *usart = config->usart;
 800d362: 6c7b         	ldr	r3, [r7, #0x44]
 800d364: 681b         	ldr	r3, [r3]
 800d366: 643b         	str	r3, [r7, #0x40]
; 	struct uart_stm32_data *data = dev->data;
 800d368: 687b         	ldr	r3, [r7, #0x4]
 800d36a: 691b         	ldr	r3, [r3, #0x10]
 800d36c: 63fb         	str	r3, [r7, #0x3c]
; 	struct uart_event disabled_event = {
 800d36e: f107 0320    	add.w	r3, r7, #0x20
 800d372: 2200         	movs	r2, #0x0
 800d374: 601a         	str	r2, [r3]
 800d376: 605a         	str	r2, [r3, #0x4]
 800d378: 609a         	str	r2, [r3, #0x8]
 800d37a: 60da         	str	r2, [r3, #0xc]
 800d37c: 611a         	str	r2, [r3, #0x10]
 800d37e: 2305         	movs	r3, #0x5
 800d380: f887 3020    	strb.w	r3, [r7, #0x20]
; 	if (!data->dma_rx.enabled) {
 800d384: 6bfb         	ldr	r3, [r7, #0x3c]
 800d386: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800d38a: f083 0301    	eor	r3, r3, #0x1
 800d38e: b2db         	uxtb	r3, r3
 800d390: 2b00         	cmp	r3, #0x0
 800d392: d008         	beq	0x800d3a6 <uart_stm32_async_rx_disable+0x52> @ imm = #0x10
; 		async_user_callback(data, &disabled_event);
 800d394: f107 0320    	add.w	r3, r7, #0x20
 800d398: 4619         	mov	r1, r3
 800d39a: 6bf8         	ldr	r0, [r7, #0x3c]
 800d39c: f015 f955    	bl	0x802264a <async_user_callback> @ imm = #0x152aa
; 		return -EFAULT;
 800d3a0: f06f 030d    	mvn	r3, #0xd
 800d3a4: e061         	b	0x800d46a <uart_stm32_async_rx_disable+0x116> @ imm = #0xc2
; 	LL_USART_DisableIT_IDLE(usart);
 800d3a6: 6c38         	ldr	r0, [r7, #0x40]
 800d3a8: f014 fb17    	bl	0x80219da <LL_USART_DisableIT_IDLE> @ imm = #0x1462e
; 	uart_stm32_dma_rx_flush(dev);
 800d3ac: 6878         	ldr	r0, [r7, #0x4]
 800d3ae: f015 f994    	bl	0x80226da <uart_stm32_dma_rx_flush> @ imm = #0x15328
; 	async_evt_rx_buf_release(data);
 800d3b2: 6bf8         	ldr	r0, [r7, #0x3c]
 800d3b4: f015 f976    	bl	0x80226a4 <async_evt_rx_buf_release> @ imm = #0x152ec
; 	uart_stm32_dma_rx_disable(dev);
 800d3b8: 6878         	ldr	r0, [r7, #0x4]
 800d3ba: f015 fa08    	bl	0x80227ce <uart_stm32_dma_rx_disable> @ imm = #0x15410
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 800d3be: 6bfb         	ldr	r3, [r7, #0x3c]
 800d3c0: 3380         	adds	r3, #0x80
 800d3c2: 4618         	mov	r0, r3
 800d3c4: f007 fae4    	bl	0x8014990 <k_work_cancel_delayable> @ imm = #0x75c8
; 	dma_stop(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 800d3c8: 6bfb         	ldr	r3, [r7, #0x3c]
 800d3ca: 6a1a         	ldr	r2, [r3, #0x20]
 800d3cc: 6bfb         	ldr	r3, [r7, #0x3c]
 800d3ce: 6a5b         	ldr	r3, [r3, #0x24]
 800d3d0: 4619         	mov	r1, r3
 800d3d2: 4610         	mov	r0, r2
 800d3d4: f013 ff8f    	bl	0x80212f6 <dma_stop>    @ imm = #0x13f1e
; 	if (data->rx_next_buffer) {
 800d3d8: 6bfb         	ldr	r3, [r7, #0x3c]
 800d3da: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 800d3de: 2b00         	cmp	r3, #0x0
 800d3e0: d013         	beq	0x800d40a <uart_stm32_async_rx_disable+0xb6> @ imm = #0x26
; 		struct uart_event rx_next_buf_release_evt = {
 800d3e2: f107 030c    	add.w	r3, r7, #0xc
 800d3e6: 2200         	movs	r2, #0x0
 800d3e8: 601a         	str	r2, [r3]
 800d3ea: 605a         	str	r2, [r3, #0x4]
 800d3ec: 609a         	str	r2, [r3, #0x8]
 800d3ee: 60da         	str	r2, [r3, #0xc]
 800d3f0: 611a         	str	r2, [r3, #0x10]
 800d3f2: 2304         	movs	r3, #0x4
 800d3f4: 733b         	strb	r3, [r7, #0xc]
; 			.data.rx_buf.buf = data->rx_next_buffer,
 800d3f6: 6bfb         	ldr	r3, [r7, #0x3c]
 800d3f8: f8d3 3150    	ldr.w	r3, [r3, #0x150]
; 		struct uart_event rx_next_buf_release_evt = {
 800d3fc: 613b         	str	r3, [r7, #0x10]
; 		async_user_callback(data, &rx_next_buf_release_evt);
 800d3fe: f107 030c    	add.w	r3, r7, #0xc
 800d402: 4619         	mov	r1, r3
 800d404: 6bf8         	ldr	r0, [r7, #0x3c]
 800d406: f015 f920    	bl	0x802264a <async_user_callback> @ imm = #0x15240
; 	data->rx_next_buffer = NULL;
 800d40a: 6bfb         	ldr	r3, [r7, #0x3c]
 800d40c: 2200         	movs	r2, #0x0
 800d40e: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800d412: 6bfb         	ldr	r3, [r7, #0x3c]
 800d414: 2200         	movs	r2, #0x0
 800d416: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	LL_USART_EnableIT_RXNE(usart);
 800d41a: 6c38         	ldr	r0, [r7, #0x40]
 800d41c: f014 fa41    	bl	0x80218a2 <LL_USART_EnableIT_RXNE> @ imm = #0x14482
; 	LOG_DBG("rx: disabled");
 800d420: 2303         	movs	r3, #0x3
 800d422: 2b03         	cmp	r3, #0x3
 800d424: d91a         	bls	0x800d45c <uart_stm32_async_rx_disable+0x108> @ imm = #0x34
 800d426: 2301         	movs	r3, #0x1
 800d428: f887 303b    	strb.w	r3, [r7, #0x3b]
 800d42c: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800d430: f083 0301    	eor	r3, r3, #0x1
 800d434: b2db         	uxtb	r3, r3
 800d436: 2b00         	cmp	r3, #0x0
 800d438: d110         	bne	0x800d45c <uart_stm32_async_rx_disable+0x108> @ imm = #0x20
 800d43a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800d474 <uart_stm32_async_rx_disable+0x120>
 800d43c: 6819         	ldr	r1, [r3]
 800d43e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800d478 <uart_stm32_async_rx_disable+0x124>
 800d440: 9303         	str	r3, [sp, #0xc]
 800d442: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800d47c <uart_stm32_async_rx_disable+0x128>
 800d444: 9302         	str	r3, [sp, #0x8]
 800d446: 2308         	movs	r3, #0x8
 800d448: 9301         	str	r3, [sp, #0x4]
 800d44a: 2300         	movs	r3, #0x0
 800d44c: 9300         	str	r3, [sp]
 800d44e: 2300         	movs	r3, #0x0
 800d450: 2204         	movs	r2, #0x4
 800d452: 2000         	movs	r0, #0x0
 800d454: f014 fc4a    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14894
 800d458: 2300         	movs	r3, #0x0
 800d45a: 637b         	str	r3, [r7, #0x34]
; 	async_user_callback(data, &disabled_event);
 800d45c: f107 0320    	add.w	r3, r7, #0x20
 800d460: 4619         	mov	r1, r3
 800d462: 6bf8         	ldr	r0, [r7, #0x3c]
 800d464: f015 f8f1    	bl	0x802264a <async_user_callback> @ imm = #0x151e2
; 	return 0;
 800d468: 2300         	movs	r3, #0x0
; }
 800d46a: 4618         	mov	r0, r3
 800d46c: 3748         	adds	r7, #0x48
 800d46e: 46bd         	mov	sp, r7
 800d470: bd80         	pop	{r7, pc}
 800d472: bf00         	nop

0800d474 <$d>:
 800d474: 50 05 00 20  	.word	0x20000550
 800d478: 24 af 02 08  	.word	0x0802af24
 800d47c: f8 99 02 08  	.word	0x080299f8

0800d480 <uart_stm32_dma_replace_buffer>:
; {
 800d480: b590         	push	{r4, r7, lr}
 800d482: b08f         	sub	sp, #0x3c
 800d484: af06         	add	r7, sp, #0x18
 800d486: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800d488: 687b         	ldr	r3, [r7, #0x4]
 800d48a: 685b         	ldr	r3, [r3, #0x4]
 800d48c: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 800d48e: 69fb         	ldr	r3, [r7, #0x1c]
 800d490: 681b         	ldr	r3, [r3]
 800d492: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 800d494: 687b         	ldr	r3, [r7, #0x4]
 800d496: 691b         	ldr	r3, [r3, #0x10]
 800d498: 617b         	str	r3, [r7, #0x14]
; 	LOG_DBG("Replacing RX buffer: %d", data->rx_next_buffer_len);
 800d49a: 2303         	movs	r3, #0x3
 800d49c: 2b03         	cmp	r3, #0x3
 800d49e: d91c         	bls	0x800d4da <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x38
 800d4a0: 2301         	movs	r3, #0x1
 800d4a2: 74fb         	strb	r3, [r7, #0x13]
 800d4a4: 7cfb         	ldrb	r3, [r7, #0x13]
 800d4a6: f083 0301    	eor	r3, r3, #0x1
 800d4aa: b2db         	uxtb	r3, r3
 800d4ac: 2b00         	cmp	r3, #0x0
 800d4ae: d114         	bne	0x800d4da <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x28
 800d4b0: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800d55c <uart_stm32_dma_replace_buffer+0xdc>
 800d4b2: 6819         	ldr	r1, [r3]
 800d4b4: 697b         	ldr	r3, [r7, #0x14]
 800d4b6: f8d3 3154    	ldr.w	r3, [r3, #0x154]
 800d4ba: 9304         	str	r3, [sp, #0x10]
 800d4bc: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800d560 <uart_stm32_dma_replace_buffer+0xe0>
 800d4be: 9303         	str	r3, [sp, #0xc]
 800d4c0: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800d564 <uart_stm32_dma_replace_buffer+0xe4>
 800d4c2: 9302         	str	r3, [sp, #0x8]
 800d4c4: 2308         	movs	r3, #0x8
 800d4c6: 9301         	str	r3, [sp, #0x4]
 800d4c8: 2300         	movs	r3, #0x0
 800d4ca: 9300         	str	r3, [sp]
 800d4cc: 2300         	movs	r3, #0x0
 800d4ce: 2204         	movs	r2, #0x4
 800d4d0: 2000         	movs	r0, #0x0
 800d4d2: f014 fc0b    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14816
 800d4d6: 2300         	movs	r3, #0x0
 800d4d8: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.offset = 0;
 800d4da: 697b         	ldr	r3, [r7, #0x14]
 800d4dc: 2200         	movs	r2, #0x0
 800d4de: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.counter = 0;
 800d4e0: 697b         	ldr	r3, [r7, #0x14]
 800d4e2: 2200         	movs	r2, #0x0
 800d4e4: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.buffer = data->rx_next_buffer;
 800d4e6: 697b         	ldr	r3, [r7, #0x14]
 800d4e8: f8d3 2150    	ldr.w	r2, [r3, #0x150]
 800d4ec: 697b         	ldr	r3, [r7, #0x14]
 800d4ee: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = data->rx_next_buffer_len;
 800d4f0: 697b         	ldr	r3, [r7, #0x14]
 800d4f2: f8d3 2154    	ldr.w	r2, [r3, #0x154]
 800d4f6: 697b         	ldr	r3, [r7, #0x14]
 800d4f8: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.blk_cfg.block_size = data->dma_rx.buffer_length;
 800d4fa: 697b         	ldr	r3, [r7, #0x14]
 800d4fc: 6f1a         	ldr	r2, [r3, #0x70]
 800d4fe: 697b         	ldr	r3, [r7, #0x14]
 800d500: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 800d502: 697b         	ldr	r3, [r7, #0x14]
 800d504: 6edb         	ldr	r3, [r3, #0x6c]
 800d506: 461a         	mov	r2, r3
 800d508: 697b         	ldr	r3, [r7, #0x14]
 800d50a: 651a         	str	r2, [r3, #0x50]
; 	data->rx_next_buffer = NULL;
 800d50c: 697b         	ldr	r3, [r7, #0x14]
 800d50e: 2200         	movs	r2, #0x0
 800d510: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800d514: 697b         	ldr	r3, [r7, #0x14]
 800d516: 2200         	movs	r2, #0x0
 800d518: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	dma_reload(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 800d51c: 697b         	ldr	r3, [r7, #0x14]
 800d51e: 6a18         	ldr	r0, [r3, #0x20]
 800d520: 697b         	ldr	r3, [r7, #0x14]
 800d522: 6a59         	ldr	r1, [r3, #0x24]
 800d524: 697b         	ldr	r3, [r7, #0x14]
 800d526: 6cda         	ldr	r2, [r3, #0x4c]
 800d528: 697b         	ldr	r3, [r7, #0x14]
 800d52a: 6d1c         	ldr	r4, [r3, #0x50]
 800d52c: 697b         	ldr	r3, [r7, #0x14]
 800d52e: 6e1b         	ldr	r3, [r3, #0x60]
 800d530: 9300         	str	r3, [sp]
 800d532: 4623         	mov	r3, r4
 800d534: f013 fe73    	bl	0x802121e <dma_reload>  @ imm = #0x13ce6
; 	dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 800d538: 697b         	ldr	r3, [r7, #0x14]
 800d53a: 6a1a         	ldr	r2, [r3, #0x20]
 800d53c: 697b         	ldr	r3, [r7, #0x14]
 800d53e: 6a5b         	ldr	r3, [r3, #0x24]
 800d540: 4619         	mov	r1, r3
 800d542: 4610         	mov	r0, r2
 800d544: f013 fec9    	bl	0x80212da <dma_start>   @ imm = #0x13d92
; 	LL_USART_ClearFlag_IDLE(usart);
 800d548: 69b8         	ldr	r0, [r7, #0x18]
 800d54a: f014 f94b    	bl	0x80217e4 <LL_USART_ClearFlag_IDLE> @ imm = #0x14296
; 	async_evt_rx_buf_request(data);
 800d54e: 6978         	ldr	r0, [r7, #0x14]
 800d550: f015 f890    	bl	0x8022674 <async_evt_rx_buf_request> @ imm = #0x15120
; }
 800d554: bf00         	nop
 800d556: 3724         	adds	r7, #0x24
 800d558: 46bd         	mov	sp, r7
 800d55a: bd90         	pop	{r4, r7, pc}

0800d55c <$d>:
 800d55c: 50 05 00 20  	.word	0x20000550
 800d560: 40 af 02 08  	.word	0x0802af40
 800d564: 0c 9a 02 08  	.word	0x08029a0c

0800d568 <uart_stm32_async_tx>:
; {
 800d568: b580         	push	{r7, lr}
 800d56a: b094         	sub	sp, #0x50
 800d56c: af06         	add	r7, sp, #0x18
 800d56e: 60f8         	str	r0, [r7, #0xc]
 800d570: 60b9         	str	r1, [r7, #0x8]
 800d572: 607a         	str	r2, [r7, #0x4]
 800d574: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800d576: 68fb         	ldr	r3, [r7, #0xc]
 800d578: 685b         	ldr	r3, [r3, #0x4]
 800d57a: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 800d57c: 6b7b         	ldr	r3, [r7, #0x34]
 800d57e: 681b         	ldr	r3, [r3]
 800d580: 633b         	str	r3, [r7, #0x30]
; 	struct uart_stm32_data *data = dev->data;
 800d582: 68fb         	ldr	r3, [r7, #0xc]
 800d584: 691b         	ldr	r3, [r3, #0x10]
 800d586: 62fb         	str	r3, [r7, #0x2c]
; 	if (data->dma_tx.dma_dev == NULL) {
 800d588: 6afb         	ldr	r3, [r7, #0x2c]
 800d58a: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800d58e: 2b00         	cmp	r3, #0x0
 800d590: d102         	bne	0x800d598 <uart_stm32_async_tx+0x30> @ imm = #0x4
; 		return -ENODEV;
 800d592: f06f 0312    	mvn	r3, #0x12
 800d596: e0ac         	b	0x800d6f2 <uart_stm32_async_tx+0x18a> @ imm = #0x158
; 	if (data->dma_tx.buffer_length != 0) {
 800d598: 6afb         	ldr	r3, [r7, #0x2c]
 800d59a: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 800d59e: 2b00         	cmp	r3, #0x0
 800d5a0: d002         	beq	0x800d5a8 <uart_stm32_async_tx+0x40> @ imm = #0x4
; 		return -EBUSY;
 800d5a2: f06f 030f    	mvn	r3, #0xf
 800d5a6: e0a4         	b	0x800d6f2 <uart_stm32_async_tx+0x18a> @ imm = #0x148
; 	data->dma_tx.buffer = (uint8_t *)tx_data;
 800d5a8: 6afb         	ldr	r3, [r7, #0x2c]
 800d5aa: 68ba         	ldr	r2, [r7, #0x8]
 800d5ac: f8c3 2104    	str.w	r2, [r3, #0x104]
; 	data->dma_tx.buffer_length = buf_size;
 800d5b0: 6afb         	ldr	r3, [r7, #0x2c]
 800d5b2: 687a         	ldr	r2, [r7, #0x4]
 800d5b4: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.timeout = timeout;
 800d5b8: 6afb         	ldr	r3, [r7, #0x2c]
 800d5ba: 683a         	ldr	r2, [r7]
 800d5bc: f8c3 2114    	str.w	r2, [r3, #0x114]
; 	LOG_DBG("tx: l=%d", data->dma_tx.buffer_length);
 800d5c0: 2303         	movs	r3, #0x3
 800d5c2: 2b03         	cmp	r3, #0x3
 800d5c4: d91e         	bls	0x800d604 <uart_stm32_async_tx+0x9c> @ imm = #0x3c
 800d5c6: 2301         	movs	r3, #0x1
 800d5c8: f887 302b    	strb.w	r3, [r7, #0x2b]
 800d5cc: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800d5d0: f083 0301    	eor	r3, r3, #0x1
 800d5d4: b2db         	uxtb	r3, r3
 800d5d6: 2b00         	cmp	r3, #0x0
 800d5d8: d114         	bne	0x800d604 <uart_stm32_async_tx+0x9c> @ imm = #0x28
 800d5da: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800d6fc <uart_stm32_async_tx+0x194>
 800d5dc: 6819         	ldr	r1, [r3]
 800d5de: 6afb         	ldr	r3, [r7, #0x2c]
 800d5e0: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 800d5e4: 9304         	str	r3, [sp, #0x10]
 800d5e6: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800d700 <uart_stm32_async_tx+0x198>
 800d5e8: 9303         	str	r3, [sp, #0xc]
 800d5ea: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800d704 <uart_stm32_async_tx+0x19c>
 800d5ec: 9302         	str	r3, [sp, #0x8]
 800d5ee: 2308         	movs	r3, #0x8
 800d5f0: 9301         	str	r3, [sp, #0x4]
 800d5f2: 2300         	movs	r3, #0x0
 800d5f4: 9300         	str	r3, [sp]
 800d5f6: 2300         	movs	r3, #0x0
 800d5f8: 2204         	movs	r2, #0x4
 800d5fa: 2000         	movs	r0, #0x0
 800d5fc: f014 fb76    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x146ec
 800d600: 2300         	movs	r3, #0x0
 800d602: 627b         	str	r3, [r7, #0x24]
; 	LL_USART_ClearFlag_TC(usart);
 800d604: 6b38         	ldr	r0, [r7, #0x30]
 800d606: f014 f8ff    	bl	0x8021808 <LL_USART_ClearFlag_TC> @ imm = #0x141fe
; 	LL_USART_EnableIT_TC(usart);
 800d60a: 6b38         	ldr	r0, [r7, #0x30]
 800d60c: f014 f96c    	bl	0x80218e8 <LL_USART_EnableIT_TC> @ imm = #0x142d8
; 	data->dma_tx.blk_cfg.source_address = (uint32_t)data->dma_tx.buffer;
 800d610: 6afb         	ldr	r3, [r7, #0x2c]
 800d612: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 800d616: 461a         	mov	r2, r3
 800d618: 6afb         	ldr	r3, [r7, #0x2c]
 800d61a: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	data->dma_tx.blk_cfg.block_size = data->dma_tx.buffer_length;
 800d61e: 6afb         	ldr	r3, [r7, #0x2c]
 800d620: f8d3 2108    	ldr.w	r2, [r3, #0x108]
 800d624: 6afb         	ldr	r3, [r7, #0x2c]
 800d626: f8c3 20f8    	str.w	r2, [r3, #0xf8]
; 	ret = dma_config(data->dma_tx.dma_dev, data->dma_tx.dma_channel,
 800d62a: 6afb         	ldr	r3, [r7, #0x2c]
 800d62c: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 800d630: 6afb         	ldr	r3, [r7, #0x2c]
 800d632: f8d3 10bc    	ldr.w	r1, [r3, #0xbc]
 800d636: 6afb         	ldr	r3, [r7, #0x2c]
 800d638: 33c0         	adds	r3, #0xc0
 800d63a: 461a         	mov	r2, r3
 800d63c: f013 fddb    	bl	0x80211f6 <dma_config>  @ imm = #0x13bb6
 800d640: 6238         	str	r0, [r7, #0x20]
; 	if (ret != 0) {
 800d642: 6a3b         	ldr	r3, [r7, #0x20]
 800d644: 2b00         	cmp	r3, #0x0
 800d646: d01c         	beq	0x800d682 <uart_stm32_async_tx+0x11a> @ imm = #0x38
; 		LOG_ERR("dma tx config error!");
 800d648: 2303         	movs	r3, #0x3
 800d64a: 2b00         	cmp	r3, #0x0
 800d64c: d016         	beq	0x800d67c <uart_stm32_async_tx+0x114> @ imm = #0x2c
 800d64e: 2301         	movs	r3, #0x1
 800d650: 75fb         	strb	r3, [r7, #0x17]
 800d652: 7dfb         	ldrb	r3, [r7, #0x17]
 800d654: f083 0301    	eor	r3, r3, #0x1
 800d658: b2db         	uxtb	r3, r3
 800d65a: 2b00         	cmp	r3, #0x0
 800d65c: d10e         	bne	0x800d67c <uart_stm32_async_tx+0x114> @ imm = #0x1c
 800d65e: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800d6fc <uart_stm32_async_tx+0x194>
 800d660: 6819         	ldr	r1, [r3]
 800d662: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800d708 <uart_stm32_async_tx+0x1a0>
 800d664: 9302         	str	r3, [sp, #0x8]
 800d666: 2300         	movs	r3, #0x0
 800d668: 9301         	str	r3, [sp, #0x4]
 800d66a: 2300         	movs	r3, #0x0
 800d66c: 9300         	str	r3, [sp]
 800d66e: 2300         	movs	r3, #0x0
 800d670: 2201         	movs	r2, #0x1
 800d672: 2000         	movs	r0, #0x0
 800d674: f014 fb3a    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14674
 800d678: 2300         	movs	r3, #0x0
 800d67a: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 800d67c: f06f 0315    	mvn	r3, #0x15
 800d680: e037         	b	0x800d6f2 <uart_stm32_async_tx+0x18a> @ imm = #0x6e
; 	if (dma_start(data->dma_tx.dma_dev, data->dma_tx.dma_channel)) {
 800d682: 6afb         	ldr	r3, [r7, #0x2c]
 800d684: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 800d688: 6afb         	ldr	r3, [r7, #0x2c]
 800d68a: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 800d68e: 4619         	mov	r1, r3
 800d690: 4610         	mov	r0, r2
 800d692: f013 fe22    	bl	0x80212da <dma_start>   @ imm = #0x13c44
 800d696: 4603         	mov	r3, r0
 800d698: 2b00         	cmp	r3, #0x0
 800d69a: d01c         	beq	0x800d6d6 <uart_stm32_async_tx+0x16e> @ imm = #0x38
; 		LOG_ERR("UART err: TX DMA start failed!");
 800d69c: 2303         	movs	r3, #0x3
 800d69e: 2b00         	cmp	r3, #0x0
 800d6a0: d016         	beq	0x800d6d0 <uart_stm32_async_tx+0x168> @ imm = #0x2c
 800d6a2: 2301         	movs	r3, #0x1
 800d6a4: 77fb         	strb	r3, [r7, #0x1f]
 800d6a6: 7ffb         	ldrb	r3, [r7, #0x1f]
 800d6a8: f083 0301    	eor	r3, r3, #0x1
 800d6ac: b2db         	uxtb	r3, r3
 800d6ae: 2b00         	cmp	r3, #0x0
 800d6b0: d10e         	bne	0x800d6d0 <uart_stm32_async_tx+0x168> @ imm = #0x1c
 800d6b2: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800d6fc <uart_stm32_async_tx+0x194>
 800d6b4: 6819         	ldr	r1, [r3]
 800d6b6: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800d70c <uart_stm32_async_tx+0x1a4>
 800d6b8: 9302         	str	r3, [sp, #0x8]
 800d6ba: 2300         	movs	r3, #0x0
 800d6bc: 9301         	str	r3, [sp, #0x4]
 800d6be: 2300         	movs	r3, #0x0
 800d6c0: 9300         	str	r3, [sp]
 800d6c2: 2300         	movs	r3, #0x0
 800d6c4: 2201         	movs	r2, #0x1
 800d6c6: 2000         	movs	r0, #0x0
 800d6c8: f014 fb10    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14620
 800d6cc: 2300         	movs	r3, #0x0
 800d6ce: 61bb         	str	r3, [r7, #0x18]
; 		return -EFAULT;
 800d6d0: f06f 030d    	mvn	r3, #0xd
 800d6d4: e00d         	b	0x800d6f2 <uart_stm32_async_tx+0x18a> @ imm = #0x1a
; 	async_timer_start(&data->dma_tx.timeout_work, data->dma_tx.timeout);
 800d6d6: 6afb         	ldr	r3, [r7, #0x2c]
 800d6d8: f503 728c    	add.w	r2, r3, #0x118
 800d6dc: 6afb         	ldr	r3, [r7, #0x2c]
 800d6de: f8d3 3114    	ldr.w	r3, [r3, #0x114]
 800d6e2: 4619         	mov	r1, r3
 800d6e4: 4610         	mov	r0, r2
 800d6e6: f7ff fd63    	bl	0x800d1b0 <async_timer_start> @ imm = #-0x53a
; 	uart_stm32_dma_tx_enable(dev);
 800d6ea: 68f8         	ldr	r0, [r7, #0xc]
 800d6ec: f015 f838    	bl	0x8022760 <uart_stm32_dma_tx_enable> @ imm = #0x15070
; 	return 0;
 800d6f0: 2300         	movs	r3, #0x0
; }
 800d6f2: 4618         	mov	r0, r3
 800d6f4: 3738         	adds	r7, #0x38
 800d6f6: 46bd         	mov	sp, r7
 800d6f8: bd80         	pop	{r7, pc}
 800d6fa: bf00         	nop

0800d6fc <$d>:
 800d6fc: 50 05 00 20  	.word	0x20000550
 800d700: 74 af 02 08  	.word	0x0802af74
 800d704: 28 9a 02 08  	.word	0x08029a28
 800d708: 38 9a 02 08  	.word	0x08029a38
 800d70c: 50 9a 02 08  	.word	0x08029a50

0800d710 <uart_stm32_async_rx_enable>:
; {
 800d710: b580         	push	{r7, lr}
 800d712: b094         	sub	sp, #0x50
 800d714: af04         	add	r7, sp, #0x10
 800d716: 60f8         	str	r0, [r7, #0xc]
 800d718: 60b9         	str	r1, [r7, #0x8]
 800d71a: 607a         	str	r2, [r7, #0x4]
 800d71c: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800d71e: 68fb         	ldr	r3, [r7, #0xc]
 800d720: 685b         	ldr	r3, [r3, #0x4]
 800d722: 63fb         	str	r3, [r7, #0x3c]
; 	USART_TypeDef *usart = config->usart;
 800d724: 6bfb         	ldr	r3, [r7, #0x3c]
 800d726: 681b         	ldr	r3, [r3]
 800d728: 63bb         	str	r3, [r7, #0x38]
; 	struct uart_stm32_data *data = dev->data;
 800d72a: 68fb         	ldr	r3, [r7, #0xc]
 800d72c: 691b         	ldr	r3, [r3, #0x10]
 800d72e: 637b         	str	r3, [r7, #0x34]
; 	if (data->dma_rx.dma_dev == NULL) {
 800d730: 6b7b         	ldr	r3, [r7, #0x34]
 800d732: 6a1b         	ldr	r3, [r3, #0x20]
 800d734: 2b00         	cmp	r3, #0x0
 800d736: d102         	bne	0x800d73e <uart_stm32_async_rx_enable+0x2e> @ imm = #0x4
; 		return -ENODEV;
 800d738: f06f 0312    	mvn	r3, #0x12
 800d73c: e0c0         	b	0x800d8c0 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x180
; 	if (data->dma_rx.enabled) {
 800d73e: 6b7b         	ldr	r3, [r7, #0x34]
 800d740: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800d744: 2b00         	cmp	r3, #0x0
 800d746: d01c         	beq	0x800d782 <uart_stm32_async_rx_enable+0x72> @ imm = #0x38
; 		LOG_WRN("RX was already enabled");
 800d748: 2303         	movs	r3, #0x3
 800d74a: 2b01         	cmp	r3, #0x1
 800d74c: d916         	bls	0x800d77c <uart_stm32_async_rx_enable+0x6c> @ imm = #0x2c
 800d74e: 2301         	movs	r3, #0x1
 800d750: 75fb         	strb	r3, [r7, #0x17]
 800d752: 7dfb         	ldrb	r3, [r7, #0x17]
 800d754: f083 0301    	eor	r3, r3, #0x1
 800d758: b2db         	uxtb	r3, r3
 800d75a: 2b00         	cmp	r3, #0x0
 800d75c: d10e         	bne	0x800d77c <uart_stm32_async_rx_enable+0x6c> @ imm = #0x1c
 800d75e: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800d8c8 <uart_stm32_async_rx_enable+0x1b8>
 800d760: 6819         	ldr	r1, [r3]
 800d762: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800d8cc <uart_stm32_async_rx_enable+0x1bc>
 800d764: 9302         	str	r3, [sp, #0x8]
 800d766: 2300         	movs	r3, #0x0
 800d768: 9301         	str	r3, [sp, #0x4]
 800d76a: 2300         	movs	r3, #0x0
 800d76c: 9300         	str	r3, [sp]
 800d76e: 2300         	movs	r3, #0x0
 800d770: 2202         	movs	r2, #0x2
 800d772: 2000         	movs	r0, #0x0
 800d774: f014 faba    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14574
 800d778: 2300         	movs	r3, #0x0
 800d77a: 613b         	str	r3, [r7, #0x10]
; 		return -EBUSY;
 800d77c: f06f 030f    	mvn	r3, #0xf
 800d780: e09e         	b	0x800d8c0 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x13c
; 	data->dma_rx.offset = 0;
 800d782: 6b7b         	ldr	r3, [r7, #0x34]
 800d784: 2200         	movs	r2, #0x0
 800d786: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.buffer = rx_buf;
 800d788: 6b7b         	ldr	r3, [r7, #0x34]
 800d78a: 68ba         	ldr	r2, [r7, #0x8]
 800d78c: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = buf_size;
 800d78e: 6b7b         	ldr	r3, [r7, #0x34]
 800d790: 687a         	ldr	r2, [r7, #0x4]
 800d792: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.counter = 0;
 800d794: 6b7b         	ldr	r3, [r7, #0x34]
 800d796: 2200         	movs	r2, #0x0
 800d798: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.timeout = timeout;
 800d79a: 6b7b         	ldr	r3, [r7, #0x34]
 800d79c: 683a         	ldr	r2, [r7]
 800d79e: 67da         	str	r2, [r3, #0x7c]
; 	LL_USART_DisableIT_RXNE(usart);
 800d7a0: 6bb8         	ldr	r0, [r7, #0x38]
 800d7a2: f014 f93d    	bl	0x8021a20 <LL_USART_DisableIT_RXNE> @ imm = #0x1427a
; 	data->dma_rx.blk_cfg.block_size = buf_size;
 800d7a6: 6b7b         	ldr	r3, [r7, #0x34]
 800d7a8: 687a         	ldr	r2, [r7, #0x4]
 800d7aa: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 800d7ac: 6b7b         	ldr	r3, [r7, #0x34]
 800d7ae: 6edb         	ldr	r3, [r3, #0x6c]
 800d7b0: 461a         	mov	r2, r3
 800d7b2: 6b7b         	ldr	r3, [r7, #0x34]
 800d7b4: 651a         	str	r2, [r3, #0x50]
; 	ret = dma_config(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 800d7b6: 6b7b         	ldr	r3, [r7, #0x34]
 800d7b8: 6a18         	ldr	r0, [r3, #0x20]
 800d7ba: 6b7b         	ldr	r3, [r7, #0x34]
 800d7bc: 6a59         	ldr	r1, [r3, #0x24]
 800d7be: 6b7b         	ldr	r3, [r7, #0x34]
 800d7c0: 3328         	adds	r3, #0x28
 800d7c2: 461a         	mov	r2, r3
 800d7c4: f013 fd17    	bl	0x80211f6 <dma_config>  @ imm = #0x13a2e
 800d7c8: 6338         	str	r0, [r7, #0x30]
; 	if (ret != 0) {
 800d7ca: 6b3b         	ldr	r3, [r7, #0x30]
 800d7cc: 2b00         	cmp	r3, #0x0
 800d7ce: d01c         	beq	0x800d80a <uart_stm32_async_rx_enable+0xfa> @ imm = #0x38
; 		LOG_ERR("UART ERR: RX DMA config failed!");
 800d7d0: 2303         	movs	r3, #0x3
 800d7d2: 2b00         	cmp	r3, #0x0
 800d7d4: d016         	beq	0x800d804 <uart_stm32_async_rx_enable+0xf4> @ imm = #0x2c
 800d7d6: 2301         	movs	r3, #0x1
 800d7d8: 77fb         	strb	r3, [r7, #0x1f]
 800d7da: 7ffb         	ldrb	r3, [r7, #0x1f]
 800d7dc: f083 0301    	eor	r3, r3, #0x1
 800d7e0: b2db         	uxtb	r3, r3
 800d7e2: 2b00         	cmp	r3, #0x0
 800d7e4: d10e         	bne	0x800d804 <uart_stm32_async_rx_enable+0xf4> @ imm = #0x1c
 800d7e6: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800d8c8 <uart_stm32_async_rx_enable+0x1b8>
 800d7e8: 6819         	ldr	r1, [r3]
 800d7ea: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800d8d0 <uart_stm32_async_rx_enable+0x1c0>
 800d7ec: 9302         	str	r3, [sp, #0x8]
 800d7ee: 2300         	movs	r3, #0x0
 800d7f0: 9301         	str	r3, [sp, #0x4]
 800d7f2: 2300         	movs	r3, #0x0
 800d7f4: 9300         	str	r3, [sp]
 800d7f6: 2300         	movs	r3, #0x0
 800d7f8: 2201         	movs	r2, #0x1
 800d7fa: 2000         	movs	r0, #0x0
 800d7fc: f014 fa76    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x144ec
 800d800: 2300         	movs	r3, #0x0
 800d802: 61bb         	str	r3, [r7, #0x18]
; 		return -EINVAL;
 800d804: f06f 0315    	mvn	r3, #0x15
 800d808: e05a         	b	0x800d8c0 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0xb4
; 	if (dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel)) {
 800d80a: 6b7b         	ldr	r3, [r7, #0x34]
 800d80c: 6a1a         	ldr	r2, [r3, #0x20]
 800d80e: 6b7b         	ldr	r3, [r7, #0x34]
 800d810: 6a5b         	ldr	r3, [r3, #0x24]
 800d812: 4619         	mov	r1, r3
 800d814: 4610         	mov	r0, r2
 800d816: f013 fd60    	bl	0x80212da <dma_start>   @ imm = #0x13ac0
 800d81a: 4603         	mov	r3, r0
 800d81c: 2b00         	cmp	r3, #0x0
 800d81e: d01e         	beq	0x800d85e <uart_stm32_async_rx_enable+0x14e> @ imm = #0x3c
; 		LOG_ERR("UART ERR: RX DMA start failed!");
 800d820: 2303         	movs	r3, #0x3
 800d822: 2b00         	cmp	r3, #0x0
 800d824: d018         	beq	0x800d858 <uart_stm32_async_rx_enable+0x148> @ imm = #0x30
 800d826: 2301         	movs	r3, #0x1
 800d828: f887 3027    	strb.w	r3, [r7, #0x27]
 800d82c: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800d830: f083 0301    	eor	r3, r3, #0x1
 800d834: b2db         	uxtb	r3, r3
 800d836: 2b00         	cmp	r3, #0x0
 800d838: d10e         	bne	0x800d858 <uart_stm32_async_rx_enable+0x148> @ imm = #0x1c
 800d83a: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800d8c8 <uart_stm32_async_rx_enable+0x1b8>
 800d83c: 6819         	ldr	r1, [r3]
 800d83e: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800d8d4 <uart_stm32_async_rx_enable+0x1c4>
 800d840: 9302         	str	r3, [sp, #0x8]
 800d842: 2300         	movs	r3, #0x0
 800d844: 9301         	str	r3, [sp, #0x4]
 800d846: 2300         	movs	r3, #0x0
 800d848: 9300         	str	r3, [sp]
 800d84a: 2300         	movs	r3, #0x0
 800d84c: 2201         	movs	r2, #0x1
 800d84e: 2000         	movs	r0, #0x0
 800d850: f014 fa4c    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14498
 800d854: 2300         	movs	r3, #0x0
 800d856: 623b         	str	r3, [r7, #0x20]
; 		return -EFAULT;
 800d858: f06f 030d    	mvn	r3, #0xd
 800d85c: e030         	b	0x800d8c0 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x60
; 	LL_USART_ClearFlag_RXNE(usart);
 800d85e: 6bb8         	ldr	r0, [r7, #0x38]
 800d860: f013 ffe0    	bl	0x8021824 <LL_USART_ClearFlag_RXNE> @ imm = #0x13fc0
; 	uart_stm32_dma_rx_enable(dev);
 800d864: 68f8         	ldr	r0, [r7, #0xc]
 800d866: f014 ff9b    	bl	0x80227a0 <uart_stm32_dma_rx_enable> @ imm = #0x14f36
; 	LL_USART_ClearFlag_IDLE(usart);
 800d86a: 6bb8         	ldr	r0, [r7, #0x38]
 800d86c: f013 ffba    	bl	0x80217e4 <LL_USART_ClearFlag_IDLE> @ imm = #0x13f74
; 	LL_USART_EnableIT_IDLE(usart);
 800d870: 6bb8         	ldr	r0, [r7, #0x38]
 800d872: f013 fff3    	bl	0x802185c <LL_USART_EnableIT_IDLE> @ imm = #0x13fe6
; 	LL_USART_EnableIT_ERROR(usart);
 800d876: 6bb8         	ldr	r0, [r7, #0x38]
 800d878: f014 f88c    	bl	0x8021994 <LL_USART_EnableIT_ERROR> @ imm = #0x14118
; 	async_evt_rx_buf_request(data);
 800d87c: 6b78         	ldr	r0, [r7, #0x34]
 800d87e: f014 fef9    	bl	0x8022674 <async_evt_rx_buf_request> @ imm = #0x14df2
; 	LOG_DBG("async rx enabled");
 800d882: 2303         	movs	r3, #0x3
 800d884: 2b03         	cmp	r3, #0x3
 800d886: d91a         	bls	0x800d8be <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x34
 800d888: 2301         	movs	r3, #0x1
 800d88a: f887 302f    	strb.w	r3, [r7, #0x2f]
 800d88e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800d892: f083 0301    	eor	r3, r3, #0x1
 800d896: b2db         	uxtb	r3, r3
 800d898: 2b00         	cmp	r3, #0x0
 800d89a: d110         	bne	0x800d8be <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x20
 800d89c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800d8c8 <uart_stm32_async_rx_enable+0x1b8>
 800d89e: 6819         	ldr	r1, [r3]
 800d8a0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800d8d8 <uart_stm32_async_rx_enable+0x1c8>
 800d8a2: 9303         	str	r3, [sp, #0xc]
 800d8a4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800d8dc <uart_stm32_async_rx_enable+0x1cc>
 800d8a6: 9302         	str	r3, [sp, #0x8]
 800d8a8: 2308         	movs	r3, #0x8
 800d8aa: 9301         	str	r3, [sp, #0x4]
 800d8ac: 2300         	movs	r3, #0x0
 800d8ae: 9300         	str	r3, [sp]
 800d8b0: 2300         	movs	r3, #0x0
 800d8b2: 2204         	movs	r2, #0x4
 800d8b4: 2000         	movs	r0, #0x0
 800d8b6: f014 fa19    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14432
 800d8ba: 2300         	movs	r3, #0x0
 800d8bc: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800d8be: 6b3b         	ldr	r3, [r7, #0x30]
; }
 800d8c0: 4618         	mov	r0, r3
 800d8c2: 3740         	adds	r7, #0x40
 800d8c4: 46bd         	mov	sp, r7
 800d8c6: bd80         	pop	{r7, pc}

0800d8c8 <$d>:
 800d8c8: 50 05 00 20  	.word	0x20000550
 800d8cc: 70 9a 02 08  	.word	0x08029a70
 800d8d0: 88 9a 02 08  	.word	0x08029a88
 800d8d4: a8 9a 02 08  	.word	0x08029aa8
 800d8d8: 88 af 02 08  	.word	0x0802af88
 800d8dc: c8 9a 02 08  	.word	0x08029ac8

0800d8e0 <uart_stm32_async_rx_timeout>:
; {
 800d8e0: b580         	push	{r7, lr}
 800d8e2: b08c         	sub	sp, #0x30
 800d8e4: af04         	add	r7, sp, #0x10
 800d8e6: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 800d8e8: 6878         	ldr	r0, [r7, #0x4]
 800d8ea: f013 fc4c    	bl	0x8021186 <k_work_delayable_from_work> @ imm = #0x13898
 800d8ee: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *rx_stream = CONTAINER_OF(dwork,
 800d8f0: 69fb         	ldr	r3, [r7, #0x1c]
 800d8f2: 3b60         	subs	r3, #0x60
 800d8f4: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(rx_stream,
 800d8f6: 69bb         	ldr	r3, [r7, #0x18]
 800d8f8: 3b20         	subs	r3, #0x20
 800d8fa: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 800d8fc: 697b         	ldr	r3, [r7, #0x14]
 800d8fe: 691b         	ldr	r3, [r3, #0x10]
 800d900: 613b         	str	r3, [r7, #0x10]
; 	LOG_DBG("rx timeout");
 800d902: 2303         	movs	r3, #0x3
 800d904: 2b03         	cmp	r3, #0x3
 800d906: d918         	bls	0x800d93a <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x30
 800d908: 2301         	movs	r3, #0x1
 800d90a: 73fb         	strb	r3, [r7, #0xf]
 800d90c: 7bfb         	ldrb	r3, [r7, #0xf]
 800d90e: f083 0301    	eor	r3, r3, #0x1
 800d912: b2db         	uxtb	r3, r3
 800d914: 2b00         	cmp	r3, #0x0
 800d916: d110         	bne	0x800d93a <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x20
 800d918: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800d95c <uart_stm32_async_rx_timeout+0x7c>
 800d91a: 6819         	ldr	r1, [r3]
 800d91c: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800d960 <uart_stm32_async_rx_timeout+0x80>
 800d91e: 9303         	str	r3, [sp, #0xc]
 800d920: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800d964 <uart_stm32_async_rx_timeout+0x84>
 800d922: 9302         	str	r3, [sp, #0x8]
 800d924: 2308         	movs	r3, #0x8
 800d926: 9301         	str	r3, [sp, #0x4]
 800d928: 2300         	movs	r3, #0x0
 800d92a: 9300         	str	r3, [sp]
 800d92c: 2300         	movs	r3, #0x0
 800d92e: 2204         	movs	r2, #0x4
 800d930: 2000         	movs	r0, #0x0
 800d932: f014 f9db    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x143b6
 800d936: 2300         	movs	r3, #0x0
 800d938: 60bb         	str	r3, [r7, #0x8]
; 	if (data->dma_rx.counter == data->dma_rx.buffer_length) {
 800d93a: 697b         	ldr	r3, [r7, #0x14]
 800d93c: 6f9a         	ldr	r2, [r3, #0x78]
 800d93e: 697b         	ldr	r3, [r7, #0x14]
 800d940: 6f1b         	ldr	r3, [r3, #0x70]
 800d942: 429a         	cmp	r2, r3
 800d944: d103         	bne	0x800d94e <uart_stm32_async_rx_timeout+0x6e> @ imm = #0x6
; 		uart_stm32_async_rx_disable(dev);
 800d946: 6938         	ldr	r0, [r7, #0x10]
 800d948: f7ff fd04    	bl	0x800d354 <uart_stm32_async_rx_disable> @ imm = #-0x5f8
; }
 800d94c: e002         	b	0x800d954 <uart_stm32_async_rx_timeout+0x74> @ imm = #0x4
; 		uart_stm32_dma_rx_flush(dev);
 800d94e: 6938         	ldr	r0, [r7, #0x10]
 800d950: f014 fec3    	bl	0x80226da <uart_stm32_dma_rx_flush> @ imm = #0x14d86
; }
 800d954: bf00         	nop
 800d956: 3720         	adds	r7, #0x20
 800d958: 46bd         	mov	sp, r7
 800d95a: bd80         	pop	{r7, pc}

0800d95c <$d>:
 800d95c: 50 05 00 20  	.word	0x20000550
 800d960: b8 af 02 08  	.word	0x0802afb8
 800d964: e0 9a 02 08  	.word	0x08029ae0

0800d968 <uart_stm32_async_tx_timeout>:
; {
 800d968: b580         	push	{r7, lr}
 800d96a: b08c         	sub	sp, #0x30
 800d96c: af04         	add	r7, sp, #0x10
 800d96e: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 800d970: 6878         	ldr	r0, [r7, #0x4]
 800d972: f013 fc08    	bl	0x8021186 <k_work_delayable_from_work> @ imm = #0x13810
 800d976: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *tx_stream = CONTAINER_OF(dwork,
 800d978: 69fb         	ldr	r3, [r7, #0x1c]
 800d97a: 3b60         	subs	r3, #0x60
 800d97c: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(tx_stream,
 800d97e: 69bb         	ldr	r3, [r7, #0x18]
 800d980: 3bb8         	subs	r3, #0xb8
 800d982: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 800d984: 697b         	ldr	r3, [r7, #0x14]
 800d986: 691b         	ldr	r3, [r3, #0x10]
 800d988: 613b         	str	r3, [r7, #0x10]
; 	uart_stm32_async_tx_abort(dev);
 800d98a: 6938         	ldr	r0, [r7, #0x10]
 800d98c: f014 ffb8    	bl	0x8022900 <uart_stm32_async_tx_abort> @ imm = #0x14f70
; 	LOG_DBG("tx: async timeout");
 800d990: 2303         	movs	r3, #0x3
 800d992: 2b03         	cmp	r3, #0x3
 800d994: d919         	bls	0x800d9ca <uart_stm32_async_tx_timeout+0x62> @ imm = #0x32
 800d996: 2301         	movs	r3, #0x1
 800d998: 73fb         	strb	r3, [r7, #0xf]
 800d99a: 7bfb         	ldrb	r3, [r7, #0xf]
 800d99c: f083 0301    	eor	r3, r3, #0x1
 800d9a0: b2db         	uxtb	r3, r3
 800d9a2: 2b00         	cmp	r3, #0x0
 800d9a4: d111         	bne	0x800d9ca <uart_stm32_async_tx_timeout+0x62> @ imm = #0x22
 800d9a6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800d9d4 <uart_stm32_async_tx_timeout+0x6c>
 800d9a8: 6819         	ldr	r1, [r3]
 800d9aa: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800d9d8 <uart_stm32_async_tx_timeout+0x70>
 800d9ac: 9303         	str	r3, [sp, #0xc]
 800d9ae: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800d9dc <uart_stm32_async_tx_timeout+0x74>
 800d9b0: 9302         	str	r3, [sp, #0x8]
 800d9b2: 2308         	movs	r3, #0x8
 800d9b4: 9301         	str	r3, [sp, #0x4]
 800d9b6: 2300         	movs	r3, #0x0
 800d9b8: 9300         	str	r3, [sp]
 800d9ba: 2300         	movs	r3, #0x0
 800d9bc: 2204         	movs	r2, #0x4
 800d9be: 2000         	movs	r0, #0x0
 800d9c0: f014 f994    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x14328
 800d9c4: 2300         	movs	r3, #0x0
 800d9c6: 60bb         	str	r3, [r7, #0x8]
; }
 800d9c8: bf00         	nop
 800d9ca: bf00         	nop
 800d9cc: 3720         	adds	r7, #0x20
 800d9ce: 46bd         	mov	sp, r7
 800d9d0: bd80         	pop	{r7, pc}
 800d9d2: bf00         	nop

0800d9d4 <$d>:
 800d9d4: 50 05 00 20  	.word	0x20000550
 800d9d8: d4 af 02 08  	.word	0x0802afd4
 800d9dc: f0 9a 02 08  	.word	0x08029af0

0800d9e0 <uart_stm32_async_rx_buf_rsp>:
; {
 800d9e0: b580         	push	{r7, lr}
 800d9e2: b094         	sub	sp, #0x50
 800d9e4: af06         	add	r7, sp, #0x18
 800d9e6: 60f8         	str	r0, [r7, #0xc]
 800d9e8: 60b9         	str	r1, [r7, #0x8]
 800d9ea: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800d9ec: 68fb         	ldr	r3, [r7, #0xc]
 800d9ee: 691b         	ldr	r3, [r3, #0x10]
 800d9f0: 633b         	str	r3, [r7, #0x30]
; 	int err = 0;
 800d9f2: 2300         	movs	r3, #0x0
 800d9f4: 637b         	str	r3, [r7, #0x34]
; 	LOG_DBG("replace buffer (%d)", len);
 800d9f6: 2303         	movs	r3, #0x3
 800d9f8: 2b03         	cmp	r3, #0x3
 800d9fa: d91c         	bls	0x800da36 <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x38
 800d9fc: 2301         	movs	r3, #0x1
 800d9fe: f887 302f    	strb.w	r3, [r7, #0x2f]
 800da02: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800da06: f083 0301    	eor	r3, r3, #0x1
 800da0a: b2db         	uxtb	r3, r3
 800da0c: 2b00         	cmp	r3, #0x0
 800da0e: d112         	bne	0x800da36 <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x24
 800da10: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800dab4 <uart_stm32_async_rx_buf_rsp+0xd4>
 800da12: 6819         	ldr	r1, [r3]
 800da14: 687b         	ldr	r3, [r7, #0x4]
 800da16: 9304         	str	r3, [sp, #0x10]
 800da18: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800dab8 <uart_stm32_async_rx_buf_rsp+0xd8>
 800da1a: 9303         	str	r3, [sp, #0xc]
 800da1c: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800dabc <uart_stm32_async_rx_buf_rsp+0xdc>
 800da1e: 9302         	str	r3, [sp, #0x8]
 800da20: 2308         	movs	r3, #0x8
 800da22: 9301         	str	r3, [sp, #0x4]
 800da24: 2300         	movs	r3, #0x0
 800da26: 9300         	str	r3, [sp]
 800da28: 2300         	movs	r3, #0x0
 800da2a: 2204         	movs	r2, #0x4
 800da2c: 2000         	movs	r0, #0x0
 800da2e: f014 f95d    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x142ba
 800da32: 2300         	movs	r3, #0x0
 800da34: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800da36: f3ef 8311    	mrs	r3, basepri
 800da3a: 623b         	str	r3, [r7, #0x20]
;   return(result);
 800da3c: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 800da3e: 61fb         	str	r3, [r7, #0x1c]
 800da40: 2310         	movs	r3, #0x10
 800da42: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800da44: 69bb         	ldr	r3, [r7, #0x18]
 800da46: f383 8812    	msr	basepri_max, r3
; }
 800da4a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800da4c: f3bf 8f6f    	isb	sy
; }
 800da50: bf00         	nop
; 	return key;
 800da52: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = irq_lock();
 800da54: 627b         	str	r3, [r7, #0x24]
; 	if (data->rx_next_buffer != NULL) {
 800da56: 6b3b         	ldr	r3, [r7, #0x30]
 800da58: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 800da5c: 2b00         	cmp	r3, #0x0
 800da5e: d003         	beq	0x800da68 <uart_stm32_async_rx_buf_rsp+0x88> @ imm = #0x6
; 		err = -EBUSY;
 800da60: f06f 030f    	mvn	r3, #0xf
 800da64: 637b         	str	r3, [r7, #0x34]
 800da66: e013         	b	0x800da90 <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0x26
; 	} else if (!data->dma_rx.enabled) {
 800da68: 6b3b         	ldr	r3, [r7, #0x30]
 800da6a: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800da6e: f083 0301    	eor	r3, r3, #0x1
 800da72: b2db         	uxtb	r3, r3
 800da74: 2b00         	cmp	r3, #0x0
 800da76: d003         	beq	0x800da80 <uart_stm32_async_rx_buf_rsp+0xa0> @ imm = #0x6
; 		err = -EACCES;
 800da78: f06f 030c    	mvn	r3, #0xc
 800da7c: 637b         	str	r3, [r7, #0x34]
 800da7e: e007         	b	0x800da90 <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0xe
; 		data->rx_next_buffer = buf;
 800da80: 6b3b         	ldr	r3, [r7, #0x30]
 800da82: 68ba         	ldr	r2, [r7, #0x8]
 800da84: f8c3 2150    	str.w	r2, [r3, #0x150]
; 		data->rx_next_buffer_len = len;
 800da88: 6b3b         	ldr	r3, [r7, #0x30]
 800da8a: 687a         	ldr	r2, [r7, #0x4]
 800da8c: f8c3 2154    	str.w	r2, [r3, #0x154]
 800da90: 6a7b         	ldr	r3, [r7, #0x24]
 800da92: 617b         	str	r3, [r7, #0x14]
 800da94: 697b         	ldr	r3, [r7, #0x14]
 800da96: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800da98: 693b         	ldr	r3, [r7, #0x10]
 800da9a: f383 8811    	msr	basepri, r3
; }
 800da9e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800daa0: f3bf 8f6f    	isb	sy
; }
 800daa4: bf00         	nop
; }
 800daa6: bf00         	nop
; 	return err;
 800daa8: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800daaa: 4618         	mov	r0, r3
 800daac: 3738         	adds	r7, #0x38
 800daae: 46bd         	mov	sp, r7
 800dab0: bd80         	pop	{r7, pc}
 800dab2: bf00         	nop

0800dab4 <$d>:
 800dab4: 50 05 00 20  	.word	0x20000550
 800dab8: f0 af 02 08  	.word	0x0802aff0
 800dabc: 08 9b 02 08  	.word	0x08029b08

0800dac0 <uart_stm32_async_init>:
; {
 800dac0: b580         	push	{r7, lr}
 800dac2: b086         	sub	sp, #0x18
 800dac4: af00         	add	r7, sp, #0x0
 800dac6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800dac8: 687b         	ldr	r3, [r7, #0x4]
 800daca: 685b         	ldr	r3, [r3, #0x4]
 800dacc: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 800dace: 697b         	ldr	r3, [r7, #0x14]
 800dad0: 681b         	ldr	r3, [r3]
 800dad2: 613b         	str	r3, [r7, #0x10]
; 	struct uart_stm32_data *data = dev->data;
 800dad4: 687b         	ldr	r3, [r7, #0x4]
 800dad6: 691b         	ldr	r3, [r3, #0x10]
 800dad8: 60fb         	str	r3, [r7, #0xc]
; 	data->uart_dev = dev;
 800dada: 68fb         	ldr	r3, [r7, #0xc]
 800dadc: 687a         	ldr	r2, [r7, #0x4]
 800dade: 611a         	str	r2, [r3, #0x10]
; 	if (data->dma_rx.dma_dev != NULL) {
 800dae0: 68fb         	ldr	r3, [r7, #0xc]
 800dae2: 6a1b         	ldr	r3, [r3, #0x20]
 800dae4: 2b00         	cmp	r3, #0x0
 800dae6: d00d         	beq	0x800db04 <uart_stm32_async_init+0x44> @ imm = #0x1a
; 		if (!device_is_ready(data->dma_rx.dma_dev)) {
 800dae8: 68fb         	ldr	r3, [r7, #0xc]
 800daea: 6a1b         	ldr	r3, [r3, #0x20]
 800daec: 4618         	mov	r0, r3
 800daee: f013 fb3e    	bl	0x802116e <device_is_ready> @ imm = #0x1367c
 800daf2: 4603         	mov	r3, r0
 800daf4: f083 0301    	eor	r3, r3, #0x1
 800daf8: b2db         	uxtb	r3, r3
 800dafa: 2b00         	cmp	r3, #0x0
 800dafc: d002         	beq	0x800db04 <uart_stm32_async_init+0x44> @ imm = #0x4
; 			return -ENODEV;
 800dafe: f06f 0312    	mvn	r3, #0x12
 800db02: e0de         	b	0x800dcc2 <uart_stm32_async_init+0x202> @ imm = #0x1bc
; 	if (data->dma_tx.dma_dev != NULL) {
 800db04: 68fb         	ldr	r3, [r7, #0xc]
 800db06: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800db0a: 2b00         	cmp	r3, #0x0
 800db0c: d00e         	beq	0x800db2c <uart_stm32_async_init+0x6c> @ imm = #0x1c
; 		if (!device_is_ready(data->dma_tx.dma_dev)) {
 800db0e: 68fb         	ldr	r3, [r7, #0xc]
 800db10: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800db14: 4618         	mov	r0, r3
 800db16: f013 fb2a    	bl	0x802116e <device_is_ready> @ imm = #0x13654
 800db1a: 4603         	mov	r3, r0
 800db1c: f083 0301    	eor	r3, r3, #0x1
 800db20: b2db         	uxtb	r3, r3
 800db22: 2b00         	cmp	r3, #0x0
 800db24: d002         	beq	0x800db2c <uart_stm32_async_init+0x6c> @ imm = #0x4
; 			return -ENODEV;
 800db26: f06f 0312    	mvn	r3, #0x12
 800db2a: e0ca         	b	0x800dcc2 <uart_stm32_async_init+0x202> @ imm = #0x194
; 	uart_stm32_dma_rx_disable(dev);
 800db2c: 6878         	ldr	r0, [r7, #0x4]
 800db2e: f014 fe4e    	bl	0x80227ce <uart_stm32_dma_rx_disable> @ imm = #0x14c9c
; 	uart_stm32_dma_tx_disable(dev);
 800db32: 6878         	ldr	r0, [r7, #0x4]
 800db34: f014 fe24    	bl	0x8022780 <uart_stm32_dma_tx_disable> @ imm = #0x14c48
; 	k_work_init_delayable(&data->dma_rx.timeout_work,
 800db38: 68fb         	ldr	r3, [r7, #0xc]
 800db3a: 3380         	adds	r3, #0x80
 800db3c: 4963         	ldr	r1, [pc, #0x18c]        @ 0x800dccc <uart_stm32_async_init+0x20c>
 800db3e: 4618         	mov	r0, r3
 800db40: f018 fa5e    	bl	0x8026000 <k_work_init_delayable> @ imm = #0x184bc
; 	k_work_init_delayable(&data->dma_tx.timeout_work,
 800db44: 68fb         	ldr	r3, [r7, #0xc]
 800db46: f503 738c    	add.w	r3, r3, #0x118
 800db4a: 4961         	ldr	r1, [pc, #0x184]        @ 0x800dcd0 <uart_stm32_async_init+0x210>
 800db4c: 4618         	mov	r0, r3
 800db4e: f018 fa57    	bl	0x8026000 <k_work_init_delayable> @ imm = #0x184ae
; 	memset(&data->dma_rx.blk_cfg, 0, sizeof(data->dma_rx.blk_cfg));
 800db52: 68fb         	ldr	r3, [r7, #0xc]
 800db54: 334c         	adds	r3, #0x4c
 800db56: 2220         	movs	r2, #0x20
 800db58: 2100         	movs	r1, #0x0
 800db5a: 4618         	mov	r0, r3
 800db5c: f019 fcd4    	bl	0x8027508 <memset>      @ imm = #0x199a8
; 				LL_USART_DMA_GetRegAddr(usart);
 800db60: 6938         	ldr	r0, [r7, #0x10]
 800db62: f014 f89b    	bl	0x8021c9c <LL_USART_DMA_GetRegAddr> @ imm = #0x14136
 800db66: 4602         	mov	r2, r0
; 	data->dma_rx.blk_cfg.source_address =
 800db68: 68fb         	ldr	r3, [r7, #0xc]
 800db6a: 64da         	str	r2, [r3, #0x4c]
; 	data->dma_rx.blk_cfg.dest_address = 0; /* dest not ready */
 800db6c: 68fb         	ldr	r3, [r7, #0xc]
 800db6e: 2200         	movs	r2, #0x0
 800db70: 651a         	str	r2, [r3, #0x50]
; 	if (data->dma_rx.src_addr_increment) {
 800db72: 68fb         	ldr	r3, [r7, #0xc]
 800db74: f893 3045    	ldrb.w	r3, [r3, #0x45]
 800db78: 2b00         	cmp	r3, #0x0
 800db7a: d007         	beq	0x800db8c <uart_stm32_async_init+0xcc> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800db7c: 68fa         	ldr	r2, [r7, #0xc]
 800db7e: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800db82: f36f 0383    	bfc	r3, #2, #2
 800db86: f882 3068    	strb.w	r3, [r2, #0x68]
 800db8a: e007         	b	0x800db9c <uart_stm32_async_init+0xdc> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800db8c: 68fa         	ldr	r2, [r7, #0xc]
 800db8e: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800db92: 2102         	movs	r1, #0x2
 800db94: f361 0383    	bfi	r3, r1, #2, #2
 800db98: f882 3068    	strb.w	r3, [r2, #0x68]
; 	if (data->dma_rx.dst_addr_increment) {
 800db9c: 68fb         	ldr	r3, [r7, #0xc]
 800db9e: f893 3046    	ldrb.w	r3, [r3, #0x46]
 800dba2: 2b00         	cmp	r3, #0x0
 800dba4: d007         	beq	0x800dbb6 <uart_stm32_async_init+0xf6> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800dba6: 68fa         	ldr	r2, [r7, #0xc]
 800dba8: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800dbac: f36f 1305    	bfc	r3, #4, #2
 800dbb0: f882 3068    	strb.w	r3, [r2, #0x68]
 800dbb4: e007         	b	0x800dbc6 <uart_stm32_async_init+0x106> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800dbb6: 68fa         	ldr	r2, [r7, #0xc]
 800dbb8: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800dbbc: 2102         	movs	r1, #0x2
 800dbbe: f361 1305    	bfi	r3, r1, #4, #2
 800dbc2: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.source_reload_en  = 0;
 800dbc6: 68fa         	ldr	r2, [r7, #0xc]
 800dbc8: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800dbcc: f36f 1386    	bfc	r3, #6, #1
 800dbd0: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.dest_reload_en = 0;
 800dbd4: 68fa         	ldr	r2, [r7, #0xc]
 800dbd6: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800dbda: f36f 13c7    	bfc	r3, #7, #1
 800dbde: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.fifo_mode_control = data->dma_rx.fifo_threshold;
 800dbe2: 68fb         	ldr	r3, [r7, #0xc]
 800dbe4: 6c9b         	ldr	r3, [r3, #0x48]
 800dbe6: f003 030f    	and	r3, r3, #0xf
 800dbea: b2d9         	uxtb	r1, r3
 800dbec: 68fa         	ldr	r2, [r7, #0xc]
 800dbee: f892 3069    	ldrb.w	r3, [r2, #0x69]
 800dbf2: f361 0303    	bfi	r3, r1, #0, #4
 800dbf6: f882 3069    	strb.w	r3, [r2, #0x69]
; 	data->dma_rx.dma_cfg.head_block = &data->dma_rx.blk_cfg;
 800dbfa: 68fb         	ldr	r3, [r7, #0xc]
 800dbfc: f103 024c    	add.w	r2, r3, #0x4c
 800dc00: 68fb         	ldr	r3, [r7, #0xc]
 800dc02: 639a         	str	r2, [r3, #0x38]
; 	data->dma_rx.dma_cfg.user_data = (void *)dev;
 800dc04: 68fb         	ldr	r3, [r7, #0xc]
 800dc06: 687a         	ldr	r2, [r7, #0x4]
 800dc08: 63da         	str	r2, [r3, #0x3c]
; 	data->rx_next_buffer = NULL;
 800dc0a: 68fb         	ldr	r3, [r7, #0xc]
 800dc0c: 2200         	movs	r2, #0x0
 800dc0e: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800dc12: 68fb         	ldr	r3, [r7, #0xc]
 800dc14: 2200         	movs	r2, #0x0
 800dc16: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	memset(&data->dma_tx.blk_cfg, 0, sizeof(data->dma_tx.blk_cfg));
 800dc1a: 68fb         	ldr	r3, [r7, #0xc]
 800dc1c: 33e4         	adds	r3, #0xe4
 800dc1e: 2220         	movs	r2, #0x20
 800dc20: 2100         	movs	r1, #0x0
 800dc22: 4618         	mov	r0, r3
 800dc24: f019 fc70    	bl	0x8027508 <memset>      @ imm = #0x198e0
; 			LL_USART_DMA_GetRegAddr(usart);
 800dc28: 6938         	ldr	r0, [r7, #0x10]
 800dc2a: f014 f837    	bl	0x8021c9c <LL_USART_DMA_GetRegAddr> @ imm = #0x1406e
 800dc2e: 4602         	mov	r2, r0
; 	data->dma_tx.blk_cfg.dest_address =
 800dc30: 68fb         	ldr	r3, [r7, #0xc]
 800dc32: f8c3 20e8    	str.w	r2, [r3, #0xe8]
; 	data->dma_tx.blk_cfg.source_address = 0; /* not ready */
 800dc36: 68fb         	ldr	r3, [r7, #0xc]
 800dc38: 2200         	movs	r2, #0x0
 800dc3a: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	if (data->dma_tx.src_addr_increment) {
 800dc3e: 68fb         	ldr	r3, [r7, #0xc]
 800dc40: f893 30dd    	ldrb.w	r3, [r3, #0xdd]
 800dc44: 2b00         	cmp	r3, #0x0
 800dc46: d007         	beq	0x800dc58 <uart_stm32_async_init+0x198> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800dc48: 68fa         	ldr	r2, [r7, #0xc]
 800dc4a: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800dc4e: f36f 0383    	bfc	r3, #2, #2
 800dc52: f882 3100    	strb.w	r3, [r2, #0x100]
 800dc56: e007         	b	0x800dc68 <uart_stm32_async_init+0x1a8> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800dc58: 68fa         	ldr	r2, [r7, #0xc]
 800dc5a: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800dc5e: 2102         	movs	r1, #0x2
 800dc60: f361 0383    	bfi	r3, r1, #2, #2
 800dc64: f882 3100    	strb.w	r3, [r2, #0x100]
; 	if (data->dma_tx.dst_addr_increment) {
 800dc68: 68fb         	ldr	r3, [r7, #0xc]
 800dc6a: f893 30de    	ldrb.w	r3, [r3, #0xde]
 800dc6e: 2b00         	cmp	r3, #0x0
 800dc70: d007         	beq	0x800dc82 <uart_stm32_async_init+0x1c2> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800dc72: 68fa         	ldr	r2, [r7, #0xc]
 800dc74: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800dc78: f36f 1305    	bfc	r3, #4, #2
 800dc7c: f882 3100    	strb.w	r3, [r2, #0x100]
 800dc80: e007         	b	0x800dc92 <uart_stm32_async_init+0x1d2> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800dc82: 68fa         	ldr	r2, [r7, #0xc]
 800dc84: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800dc88: 2102         	movs	r1, #0x2
 800dc8a: f361 1305    	bfi	r3, r1, #4, #2
 800dc8e: f882 3100    	strb.w	r3, [r2, #0x100]
; 	data->dma_tx.blk_cfg.fifo_mode_control = data->dma_tx.fifo_threshold;
 800dc92: 68fb         	ldr	r3, [r7, #0xc]
 800dc94: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 800dc98: f003 030f    	and	r3, r3, #0xf
 800dc9c: b2d9         	uxtb	r1, r3
 800dc9e: 68fa         	ldr	r2, [r7, #0xc]
 800dca0: f892 3101    	ldrb.w	r3, [r2, #0x101]
 800dca4: f361 0303    	bfi	r3, r1, #0, #4
 800dca8: f882 3101    	strb.w	r3, [r2, #0x101]
; 	data->dma_tx.dma_cfg.head_block = &data->dma_tx.blk_cfg;
 800dcac: 68fb         	ldr	r3, [r7, #0xc]
 800dcae: f103 02e4    	add.w	r2, r3, #0xe4
 800dcb2: 68fb         	ldr	r3, [r7, #0xc]
 800dcb4: f8c3 20d0    	str.w	r2, [r3, #0xd0]
; 	data->dma_tx.dma_cfg.user_data = (void *)dev;
 800dcb8: 68fb         	ldr	r3, [r7, #0xc]
 800dcba: 687a         	ldr	r2, [r7, #0x4]
 800dcbc: f8c3 20d4    	str.w	r2, [r3, #0xd4]
; 	return 0;
 800dcc0: 2300         	movs	r3, #0x0
; }
 800dcc2: 4618         	mov	r0, r3
 800dcc4: 3718         	adds	r7, #0x18
 800dcc6: 46bd         	mov	sp, r7
 800dcc8: bd80         	pop	{r7, pc}
 800dcca: bf00         	nop

0800dccc <$d>:
 800dccc: e1 d8 00 08  	.word	0x0800d8e1
 800dcd0: 69 d9 00 08  	.word	0x0800d969

0800dcd4 <uart_stm32_clocks_enable>:
; {
 800dcd4: b580         	push	{r7, lr}
 800dcd6: b08e         	sub	sp, #0x38
 800dcd8: af04         	add	r7, sp, #0x10
 800dcda: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800dcdc: 687b         	ldr	r3, [r7, #0x4]
 800dcde: 685b         	ldr	r3, [r3, #0x4]
 800dce0: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 800dce2: 687b         	ldr	r3, [r7, #0x4]
 800dce4: 691b         	ldr	r3, [r3, #0x10]
 800dce6: 627b         	str	r3, [r7, #0x24]
; 	__uart_stm32_get_clock(dev);
 800dce8: 6878         	ldr	r0, [r7, #0x4]
 800dcea: f7ff f853    	bl	0x800cd94 <__uart_stm32_get_clock> @ imm = #-0xf5a
; 	if (!device_is_ready(data->clock)) {
 800dcee: 6a7b         	ldr	r3, [r7, #0x24]
 800dcf0: 681b         	ldr	r3, [r3]
 800dcf2: 4618         	mov	r0, r3
 800dcf4: f013 fa3b    	bl	0x802116e <device_is_ready> @ imm = #0x13476
 800dcf8: 4603         	mov	r3, r0
 800dcfa: f083 0301    	eor	r3, r3, #0x1
 800dcfe: b2db         	uxtb	r3, r3
 800dd00: 2b00         	cmp	r3, #0x0
 800dd02: d01c         	beq	0x800dd3e <uart_stm32_clocks_enable+0x6a> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800dd04: 2303         	movs	r3, #0x3
 800dd06: 2b00         	cmp	r3, #0x0
 800dd08: d016         	beq	0x800dd38 <uart_stm32_clocks_enable+0x64> @ imm = #0x2c
 800dd0a: 2301         	movs	r3, #0x1
 800dd0c: 74fb         	strb	r3, [r7, #0x13]
 800dd0e: 7cfb         	ldrb	r3, [r7, #0x13]
 800dd10: f083 0301    	eor	r3, r3, #0x1
 800dd14: b2db         	uxtb	r3, r3
 800dd16: 2b00         	cmp	r3, #0x0
 800dd18: d10e         	bne	0x800dd38 <uart_stm32_clocks_enable+0x64> @ imm = #0x1c
 800dd1a: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800dd98 <uart_stm32_clocks_enable+0xc4>
 800dd1c: 6819         	ldr	r1, [r3]
 800dd1e: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800dd9c <uart_stm32_clocks_enable+0xc8>
 800dd20: 9302         	str	r3, [sp, #0x8]
 800dd22: 2300         	movs	r3, #0x0
 800dd24: 9301         	str	r3, [sp, #0x4]
 800dd26: 2300         	movs	r3, #0x0
 800dd28: 9300         	str	r3, [sp]
 800dd2a: 2300         	movs	r3, #0x0
 800dd2c: 2201         	movs	r2, #0x1
 800dd2e: 2000         	movs	r0, #0x0
 800dd30: f013 ffdc    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x13fb8
 800dd34: 2300         	movs	r3, #0x0
 800dd36: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800dd38: f06f 0312    	mvn	r3, #0x12
 800dd3c: e028         	b	0x800dd90 <uart_stm32_clocks_enable+0xbc> @ imm = #0x50
; 	err = clock_control_on(data->clock, (clock_control_subsys_t)&config->pclken[0]);
 800dd3e: 6a7b         	ldr	r3, [r7, #0x24]
 800dd40: 681a         	ldr	r2, [r3]
 800dd42: 6a3b         	ldr	r3, [r7, #0x20]
 800dd44: 68db         	ldr	r3, [r3, #0xc]
 800dd46: 4619         	mov	r1, r3
 800dd48: 4610         	mov	r0, r2
 800dd4a: f013 fa27    	bl	0x802119c <clock_control_on> @ imm = #0x1344e
 800dd4e: 61f8         	str	r0, [r7, #0x1c]
; 	if (err != 0) {
 800dd50: 69fb         	ldr	r3, [r7, #0x1c]
 800dd52: 2b00         	cmp	r3, #0x0
 800dd54: d01b         	beq	0x800dd8e <uart_stm32_clocks_enable+0xba> @ imm = #0x36
; 		LOG_ERR("Could not enable (LP)UART clock");
 800dd56: 2303         	movs	r3, #0x3
 800dd58: 2b00         	cmp	r3, #0x0
 800dd5a: d016         	beq	0x800dd8a <uart_stm32_clocks_enable+0xb6> @ imm = #0x2c
 800dd5c: 2301         	movs	r3, #0x1
 800dd5e: 76fb         	strb	r3, [r7, #0x1b]
 800dd60: 7efb         	ldrb	r3, [r7, #0x1b]
 800dd62: f083 0301    	eor	r3, r3, #0x1
 800dd66: b2db         	uxtb	r3, r3
 800dd68: 2b00         	cmp	r3, #0x0
 800dd6a: d10e         	bne	0x800dd8a <uart_stm32_clocks_enable+0xb6> @ imm = #0x1c
 800dd6c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800dd98 <uart_stm32_clocks_enable+0xc4>
 800dd6e: 6819         	ldr	r1, [r3]
 800dd70: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800dda0 <uart_stm32_clocks_enable+0xcc>
 800dd72: 9302         	str	r3, [sp, #0x8]
 800dd74: 2300         	movs	r3, #0x0
 800dd76: 9301         	str	r3, [sp, #0x4]
 800dd78: 2300         	movs	r3, #0x0
 800dd7a: 9300         	str	r3, [sp]
 800dd7c: 2300         	movs	r3, #0x0
 800dd7e: 2201         	movs	r2, #0x1
 800dd80: 2000         	movs	r0, #0x0
 800dd82: f013 ffb3    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x13f66
 800dd86: 2300         	movs	r3, #0x0
 800dd88: 617b         	str	r3, [r7, #0x14]
; 		return err;
 800dd8a: 69fb         	ldr	r3, [r7, #0x1c]
 800dd8c: e000         	b	0x800dd90 <uart_stm32_clocks_enable+0xbc> @ imm = #0x0
; 	return 0;
 800dd8e: 2300         	movs	r3, #0x0
; }
 800dd90: 4618         	mov	r0, r3
 800dd92: 3728         	adds	r7, #0x28
 800dd94: 46bd         	mov	sp, r7
 800dd96: bd80         	pop	{r7, pc}

0800dd98 <$d>:
 800dd98: 50 05 00 20  	.word	0x20000550
 800dd9c: 20 9b 02 08  	.word	0x08029b20
 800dda0: 40 9b 02 08  	.word	0x08029b40

0800dda4 <uart_stm32_registers_configure>:
; {
 800dda4: b580         	push	{r7, lr}
 800dda6: b08c         	sub	sp, #0x30
 800dda8: af04         	add	r7, sp, #0x10
 800ddaa: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800ddac: 687b         	ldr	r3, [r7, #0x4]
 800ddae: 685b         	ldr	r3, [r3, #0x4]
 800ddb0: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 800ddb2: 69fb         	ldr	r3, [r7, #0x1c]
 800ddb4: 681b         	ldr	r3, [r3]
 800ddb6: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 800ddb8: 687b         	ldr	r3, [r7, #0x4]
 800ddba: 691b         	ldr	r3, [r3, #0x10]
 800ddbc: 617b         	str	r3, [r7, #0x14]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 800ddbe: 697b         	ldr	r3, [r7, #0x14]
 800ddc0: 685b         	ldr	r3, [r3, #0x4]
 800ddc2: 613b         	str	r3, [r7, #0x10]
; 	LL_USART_Disable(usart);
 800ddc4: 69b8         	ldr	r0, [r7, #0x18]
 800ddc6: f013 fb1d    	bl	0x8021404 <LL_USART_Disable> @ imm = #0x1363a
; 	if (!device_is_ready(config->reset.dev)) {
 800ddca: 69fb         	ldr	r3, [r7, #0x1c]
 800ddcc: 685b         	ldr	r3, [r3, #0x4]
 800ddce: 4618         	mov	r0, r3
 800ddd0: f013 f9cd    	bl	0x802116e <device_is_ready> @ imm = #0x1339a
 800ddd4: 4603         	mov	r3, r0
 800ddd6: f083 0301    	eor	r3, r3, #0x1
 800ddda: b2db         	uxtb	r3, r3
 800dddc: 2b00         	cmp	r3, #0x0
 800ddde: d01c         	beq	0x800de1a <uart_stm32_registers_configure+0x76> @ imm = #0x38
; 		LOG_ERR("reset controller not ready");
 800dde0: 2303         	movs	r3, #0x3
 800dde2: 2b00         	cmp	r3, #0x0
 800dde4: d016         	beq	0x800de14 <uart_stm32_registers_configure+0x70> @ imm = #0x2c
 800dde6: 2301         	movs	r3, #0x1
 800dde8: 73fb         	strb	r3, [r7, #0xf]
 800ddea: 7bfb         	ldrb	r3, [r7, #0xf]
 800ddec: f083 0301    	eor	r3, r3, #0x1
 800ddf0: b2db         	uxtb	r3, r3
 800ddf2: 2b00         	cmp	r3, #0x0
 800ddf4: d10e         	bne	0x800de14 <uart_stm32_registers_configure+0x70> @ imm = #0x1c
 800ddf6: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800de54 <uart_stm32_registers_configure+0xb0>
 800ddf8: 6819         	ldr	r1, [r3]
 800ddfa: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800de58 <uart_stm32_registers_configure+0xb4>
 800ddfc: 9302         	str	r3, [sp, #0x8]
 800ddfe: 2300         	movs	r3, #0x0
 800de00: 9301         	str	r3, [sp, #0x4]
 800de02: 2300         	movs	r3, #0x0
 800de04: 9300         	str	r3, [sp]
 800de06: 2300         	movs	r3, #0x0
 800de08: 2201         	movs	r2, #0x1
 800de0a: 2000         	movs	r0, #0x0
 800de0c: f013 ff6e    	bl	0x8021cec <z_log_msg_runtime_create> @ imm = #0x13edc
 800de10: 2300         	movs	r3, #0x0
 800de12: 60bb         	str	r3, [r7, #0x8]
; 		return -ENODEV;
 800de14: f06f 0312    	mvn	r3, #0x12
 800de18: e017         	b	0x800de4a <uart_stm32_registers_configure+0xa6> @ imm = #0x2e
; 	(void)reset_line_toggle_dt(&config->reset);
 800de1a: 69fb         	ldr	r3, [r7, #0x1c]
 800de1c: 3304         	adds	r3, #0x4
 800de1e: 4618         	mov	r0, r3
 800de20: f013 fac1    	bl	0x80213a6 <reset_line_toggle_dt> @ imm = #0x13582
; 	LL_USART_SetTransferDirection(usart, LL_USART_DIRECTION_TX_RX);
 800de24: 210c         	movs	r1, #0xc
 800de26: 69b8         	ldr	r0, [r7, #0x18]
 800de28: f013 fafc    	bl	0x8021424 <LL_USART_SetTransferDirection> @ imm = #0x135f8
; 	uart_stm32_parameters_set(dev, uart_cfg);
 800de2c: 6939         	ldr	r1, [r7, #0x10]
 800de2e: 6878         	ldr	r0, [r7, #0x4]
 800de30: f014 f8d4    	bl	0x8021fdc <uart_stm32_parameters_set> @ imm = #0x141a8
; 	if (config->single_wire) {
 800de34: 69fb         	ldr	r3, [r7, #0x1c]
 800de36: 7d1b         	ldrb	r3, [r3, #0x14]
 800de38: 2b00         	cmp	r3, #0x0
 800de3a: d002         	beq	0x800de42 <uart_stm32_registers_configure+0x9e> @ imm = #0x4
; 		LL_USART_EnableHalfDuplex(usart);
 800de3c: 69b8         	ldr	r0, [r7, #0x18]
 800de3e: f013 fbcd    	bl	0x80215dc <LL_USART_EnableHalfDuplex> @ imm = #0x1379a
; 	LL_USART_Enable(usart);
 800de42: 69b8         	ldr	r0, [r7, #0x18]
 800de44: f013 face    	bl	0x80213e4 <LL_USART_Enable> @ imm = #0x1359c
; 	return 0;
 800de48: 2300         	movs	r3, #0x0
; }
 800de4a: 4618         	mov	r0, r3
 800de4c: 3720         	adds	r7, #0x20
 800de4e: 46bd         	mov	sp, r7
 800de50: bd80         	pop	{r7, pc}
 800de52: bf00         	nop

0800de54 <$d>:
 800de54: 50 05 00 20  	.word	0x20000550
 800de58: 60 9b 02 08  	.word	0x08029b60

0800de5c <spi_context_cs_configure_all>:
; {
 800de5c: b580         	push	{r7, lr}
 800de5e: b08c         	sub	sp, #0x30
 800de60: af06         	add	r7, sp, #0x18
 800de62: 6078         	str	r0, [r7, #0x4]
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 800de64: 687b         	ldr	r3, [r7, #0x4]
 800de66: 689b         	ldr	r3, [r3, #0x8]
 800de68: 617b         	str	r3, [r7, #0x14]
 800de6a: e03c         	b	0x800dee6 <spi_context_cs_configure_all+0x8a> @ imm = #0x78
; 		if (!device_is_ready(cs_gpio->port)) {
 800de6c: 697b         	ldr	r3, [r7, #0x14]
 800de6e: 681b         	ldr	r3, [r3]
 800de70: 4618         	mov	r0, r3
 800de72: f014 fde0    	bl	0x8022a36 <device_is_ready> @ imm = #0x14bc0
 800de76: 4603         	mov	r3, r0
 800de78: f083 0301    	eor	r3, r3, #0x1
 800de7c: b2db         	uxtb	r3, r3
 800de7e: 2b00         	cmp	r3, #0x0
 800de80: d023         	beq	0x800deca <spi_context_cs_configure_all+0x6e> @ imm = #0x46
; 			LOG_ERR("CS GPIO port %s pin %d is not ready",
 800de82: 2303         	movs	r3, #0x3
 800de84: 2b00         	cmp	r3, #0x0
 800de86: d01d         	beq	0x800dec4 <spi_context_cs_configure_all+0x68> @ imm = #0x3a
 800de88: 2301         	movs	r3, #0x1
 800de8a: 73fb         	strb	r3, [r7, #0xf]
 800de8c: 7bfb         	ldrb	r3, [r7, #0xf]
 800de8e: f083 0301    	eor	r3, r3, #0x1
 800de92: b2db         	uxtb	r3, r3
 800de94: 2b00         	cmp	r3, #0x0
 800de96: d115         	bne	0x800dec4 <spi_context_cs_configure_all+0x68> @ imm = #0x2a
 800de98: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800df04 <spi_context_cs_configure_all+0xa8>
 800de9a: 6819         	ldr	r1, [r3]
 800de9c: 697b         	ldr	r3, [r7, #0x14]
 800de9e: 681b         	ldr	r3, [r3]
 800dea0: 681b         	ldr	r3, [r3]
 800dea2: 697a         	ldr	r2, [r7, #0x14]
 800dea4: 7912         	ldrb	r2, [r2, #0x4]
 800dea6: 9204         	str	r2, [sp, #0x10]
 800dea8: 9303         	str	r3, [sp, #0xc]
 800deaa: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800df08 <spi_context_cs_configure_all+0xac>
 800deac: 9302         	str	r3, [sp, #0x8]
 800deae: 2300         	movs	r3, #0x0
 800deb0: 9301         	str	r3, [sp, #0x4]
 800deb2: 2300         	movs	r3, #0x0
 800deb4: 9300         	str	r3, [sp]
 800deb6: 2300         	movs	r3, #0x0
 800deb8: 2201         	movs	r2, #0x1
 800deba: 2000         	movs	r0, #0x0
 800debc: f014 fdc7    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x14b8e
 800dec0: 2300         	movs	r3, #0x0
 800dec2: 60bb         	str	r3, [r7, #0x8]
; 			return -ENODEV;
 800dec4: f06f 0312    	mvn	r3, #0x12
 800dec8: e017         	b	0x800defa <spi_context_cs_configure_all+0x9e> @ imm = #0x2e
; 		ret = gpio_pin_configure_dt(cs_gpio, GPIO_OUTPUT_INACTIVE);
 800deca: f44f 11b0    	mov.w	r1, #0x160000
 800dece: 6978         	ldr	r0, [r7, #0x14]
 800ded0: f015 f83d    	bl	0x8022f4e <gpio_pin_configure_dt> @ imm = #0x1507a
 800ded4: 6138         	str	r0, [r7, #0x10]
; 		if (ret < 0) {
 800ded6: 693b         	ldr	r3, [r7, #0x10]
 800ded8: 2b00         	cmp	r3, #0x0
 800deda: da01         	bge	0x800dee0 <spi_context_cs_configure_all+0x84> @ imm = #0x2
; 			return ret;
 800dedc: 693b         	ldr	r3, [r7, #0x10]
 800dede: e00c         	b	0x800defa <spi_context_cs_configure_all+0x9e> @ imm = #0x18
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 800dee0: 697b         	ldr	r3, [r7, #0x14]
 800dee2: 3308         	adds	r3, #0x8
 800dee4: 617b         	str	r3, [r7, #0x14]
 800dee6: 687b         	ldr	r3, [r7, #0x4]
 800dee8: 689a         	ldr	r2, [r3, #0x8]
 800deea: 687b         	ldr	r3, [r7, #0x4]
 800deec: 68db         	ldr	r3, [r3, #0xc]
 800deee: 00db         	lsls	r3, r3, #0x3
 800def0: 4413         	add	r3, r2
 800def2: 697a         	ldr	r2, [r7, #0x14]
 800def4: 429a         	cmp	r2, r3
 800def6: d3b9         	blo	0x800de6c <spi_context_cs_configure_all+0x10> @ imm = #-0x8e
; 	return 0;
 800def8: 2300         	movs	r3, #0x0
; }
 800defa: 4618         	mov	r0, r3
 800defc: 3718         	adds	r7, #0x18
 800defe: 46bd         	mov	sp, r7
 800df00: bd80         	pop	{r7, pc}
 800df02: bf00         	nop

0800df04 <$d>:
 800df04: 6c 05 00 20  	.word	0x2000056c
 800df08: bc 9b 02 08  	.word	0x08029bbc

0800df0c <spi_context_buffers_setup>:
; {
 800df0c: b5f0         	push	{r4, r5, r6, r7, lr}
 800df0e: b097         	sub	sp, #0x5c
 800df10: af0c         	add	r7, sp, #0x30
 800df12: 6178         	str	r0, [r7, #0x14]
 800df14: 6139         	str	r1, [r7, #0x10]
 800df16: 60fa         	str	r2, [r7, #0xc]
 800df18: 72fb         	strb	r3, [r7, #0xb]
; 	LOG_DBG("tx_bufs %p - rx_bufs %p - %u", tx_bufs, rx_bufs, dfs);
 800df1a: 2303         	movs	r3, #0x3
 800df1c: 2b03         	cmp	r3, #0x3
 800df1e: d920         	bls	0x800df62 <spi_context_buffers_setup+0x56> @ imm = #0x40
 800df20: 2301         	movs	r3, #0x1
 800df22: f887 3023    	strb.w	r3, [r7, #0x23]
 800df26: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800df2a: f083 0301    	eor	r3, r3, #0x1
 800df2e: b2db         	uxtb	r3, r3
 800df30: 2b00         	cmp	r3, #0x0
 800df32: d116         	bne	0x800df62 <spi_context_buffers_setup+0x56> @ imm = #0x2c
 800df34: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x800e070 <spi_context_buffers_setup+0x164>
 800df36: 6819         	ldr	r1, [r3]
 800df38: 7afb         	ldrb	r3, [r7, #0xb]
 800df3a: 9306         	str	r3, [sp, #0x18]
 800df3c: 68fb         	ldr	r3, [r7, #0xc]
 800df3e: 9305         	str	r3, [sp, #0x14]
 800df40: 693b         	ldr	r3, [r7, #0x10]
 800df42: 9304         	str	r3, [sp, #0x10]
 800df44: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800e074 <spi_context_buffers_setup+0x168>
 800df46: 9303         	str	r3, [sp, #0xc]
 800df48: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800e078 <spi_context_buffers_setup+0x16c>
 800df4a: 9302         	str	r3, [sp, #0x8]
 800df4c: 2308         	movs	r3, #0x8
 800df4e: 9301         	str	r3, [sp, #0x4]
 800df50: 2300         	movs	r3, #0x0
 800df52: 9300         	str	r3, [sp]
 800df54: 2300         	movs	r3, #0x0
 800df56: 2204         	movs	r2, #0x4
 800df58: 2000         	movs	r0, #0x0
 800df5a: f014 fd78    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x14af0
 800df5e: 2300         	movs	r3, #0x0
 800df60: 627b         	str	r3, [r7, #0x24]
; 	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
 800df62: 693b         	ldr	r3, [r7, #0x10]
 800df64: 2b00         	cmp	r3, #0x0
 800df66: d002         	beq	0x800df6e <spi_context_buffers_setup+0x62> @ imm = #0x4
 800df68: 693b         	ldr	r3, [r7, #0x10]
 800df6a: 681b         	ldr	r3, [r3]
 800df6c: e000         	b	0x800df70 <spi_context_buffers_setup+0x64> @ imm = #0x0
 800df6e: 2300         	movs	r3, #0x0
 800df70: 697a         	ldr	r2, [r7, #0x14]
 800df72: 6353         	str	r3, [r2, #0x34]
; 	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
 800df74: 697b         	ldr	r3, [r7, #0x14]
 800df76: 6b5b         	ldr	r3, [r3, #0x34]
 800df78: 2b00         	cmp	r3, #0x0
 800df7a: d002         	beq	0x800df82 <spi_context_buffers_setup+0x76> @ imm = #0x4
 800df7c: 693b         	ldr	r3, [r7, #0x10]
 800df7e: 685b         	ldr	r3, [r3, #0x4]
 800df80: e000         	b	0x800df84 <spi_context_buffers_setup+0x78> @ imm = #0x0
 800df82: 2300         	movs	r3, #0x0
 800df84: 697a         	ldr	r2, [r7, #0x14]
 800df86: 6393         	str	r3, [r2, #0x38]
; 		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
 800df88: 697b         	ldr	r3, [r7, #0x14]
 800df8a: f103 0034    	add.w	r0, r3, #0x34
 800df8e: 697b         	ldr	r3, [r7, #0x14]
 800df90: f103 0138    	add.w	r1, r3, #0x38
 800df94: 697b         	ldr	r3, [r7, #0x14]
 800df96: f103 0248    	add.w	r2, r3, #0x48
 800df9a: 7afb         	ldrb	r3, [r7, #0xb]
 800df9c: f015 f9e0    	bl	0x8023360 <spi_context_get_next_buf> @ imm = #0x153c0
 800dfa0: 4602         	mov	r2, r0
; 	ctx->tx_buf = (const uint8_t *)
 800dfa2: 697b         	ldr	r3, [r7, #0x14]
 800dfa4: 645a         	str	r2, [r3, #0x44]
; 	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
 800dfa6: 68fb         	ldr	r3, [r7, #0xc]
 800dfa8: 2b00         	cmp	r3, #0x0
 800dfaa: d002         	beq	0x800dfb2 <spi_context_buffers_setup+0xa6> @ imm = #0x4
 800dfac: 68fb         	ldr	r3, [r7, #0xc]
 800dfae: 681b         	ldr	r3, [r3]
 800dfb0: e000         	b	0x800dfb4 <spi_context_buffers_setup+0xa8> @ imm = #0x0
 800dfb2: 2300         	movs	r3, #0x0
 800dfb4: 697a         	ldr	r2, [r7, #0x14]
 800dfb6: 63d3         	str	r3, [r2, #0x3c]
; 	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
 800dfb8: 697b         	ldr	r3, [r7, #0x14]
 800dfba: 6bdb         	ldr	r3, [r3, #0x3c]
 800dfbc: 2b00         	cmp	r3, #0x0
 800dfbe: d002         	beq	0x800dfc6 <spi_context_buffers_setup+0xba> @ imm = #0x4
 800dfc0: 68fb         	ldr	r3, [r7, #0xc]
 800dfc2: 685b         	ldr	r3, [r3, #0x4]
 800dfc4: e000         	b	0x800dfc8 <spi_context_buffers_setup+0xbc> @ imm = #0x0
 800dfc6: 2300         	movs	r3, #0x0
 800dfc8: 697a         	ldr	r2, [r7, #0x14]
 800dfca: 6413         	str	r3, [r2, #0x40]
; 		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
 800dfcc: 697b         	ldr	r3, [r7, #0x14]
 800dfce: f103 003c    	add.w	r0, r3, #0x3c
 800dfd2: 697b         	ldr	r3, [r7, #0x14]
 800dfd4: f103 0140    	add.w	r1, r3, #0x40
 800dfd8: 697b         	ldr	r3, [r7, #0x14]
 800dfda: f103 0250    	add.w	r2, r3, #0x50
 800dfde: 7afb         	ldrb	r3, [r7, #0xb]
 800dfe0: f015 f9be    	bl	0x8023360 <spi_context_get_next_buf> @ imm = #0x1537c
 800dfe4: 4602         	mov	r2, r0
; 	ctx->rx_buf = (uint8_t *)
 800dfe6: 697b         	ldr	r3, [r7, #0x14]
 800dfe8: 64da         	str	r2, [r3, #0x4c]
; 	ctx->sync_status = 0;
 800dfea: 697b         	ldr	r3, [r7, #0x14]
 800dfec: 2200         	movs	r2, #0x0
 800dfee: 631a         	str	r2, [r3, #0x30]
; 	LOG_DBG("current_tx %p (%zu), current_rx %p (%zu),"
 800dff0: 2303         	movs	r3, #0x3
 800dff2: 2b03         	cmp	r3, #0x3
 800dff4: d937         	bls	0x800e066 <spi_context_buffers_setup+0x15a> @ imm = #0x6e
 800dff6: 2301         	movs	r3, #0x1
 800dff8: f887 3022    	strb.w	r3, [r7, #0x22]
 800dffc: f897 3022    	ldrb.w	r3, [r7, #0x22]
 800e000: f083 0301    	eor	r3, r3, #0x1
 800e004: b2db         	uxtb	r3, r3
 800e006: 2b00         	cmp	r3, #0x0
 800e008: d12d         	bne	0x800e066 <spi_context_buffers_setup+0x15a> @ imm = #0x5a
 800e00a: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800e070 <spi_context_buffers_setup+0x164>
 800e00c: 681b         	ldr	r3, [r3]
 800e00e: 607b         	str	r3, [r7, #0x4]
 800e010: 697b         	ldr	r3, [r7, #0x14]
 800e012: 6b5b         	ldr	r3, [r3, #0x34]
 800e014: 697a         	ldr	r2, [r7, #0x14]
 800e016: 6b92         	ldr	r2, [r2, #0x38]
 800e018: 603a         	str	r2, [r7]
 800e01a: 6979         	ldr	r1, [r7, #0x14]
 800e01c: 6bc9         	ldr	r1, [r1, #0x3c]
 800e01e: 6978         	ldr	r0, [r7, #0x14]
 800e020: 6c00         	ldr	r0, [r0, #0x40]
 800e022: 697c         	ldr	r4, [r7, #0x14]
 800e024: 6c64         	ldr	r4, [r4, #0x44]
 800e026: 697d         	ldr	r5, [r7, #0x14]
 800e028: 6cad         	ldr	r5, [r5, #0x48]
 800e02a: 697e         	ldr	r6, [r7, #0x14]
 800e02c: 6cf6         	ldr	r6, [r6, #0x4c]
 800e02e: 697a         	ldr	r2, [r7, #0x14]
 800e030: 6d12         	ldr	r2, [r2, #0x50]
 800e032: 920b         	str	r2, [sp, #0x2c]
 800e034: 960a         	str	r6, [sp, #0x28]
 800e036: 9509         	str	r5, [sp, #0x24]
 800e038: 9408         	str	r4, [sp, #0x20]
 800e03a: 9007         	str	r0, [sp, #0x1c]
 800e03c: 9106         	str	r1, [sp, #0x18]
 800e03e: 683a         	ldr	r2, [r7]
 800e040: 9205         	str	r2, [sp, #0x14]
 800e042: 9304         	str	r3, [sp, #0x10]
 800e044: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800e074 <spi_context_buffers_setup+0x168>
 800e046: 9303         	str	r3, [sp, #0xc]
 800e048: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800e07c <spi_context_buffers_setup+0x170>
 800e04a: 9302         	str	r3, [sp, #0x8]
 800e04c: 2308         	movs	r3, #0x8
 800e04e: 9301         	str	r3, [sp, #0x4]
 800e050: 2300         	movs	r3, #0x0
 800e052: 9300         	str	r3, [sp]
 800e054: 2300         	movs	r3, #0x0
 800e056: 2204         	movs	r2, #0x4
 800e058: 6879         	ldr	r1, [r7, #0x4]
 800e05a: 2000         	movs	r0, #0x0
 800e05c: f014 fcf7    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x149ee
 800e060: 2300         	movs	r3, #0x0
 800e062: 61fb         	str	r3, [r7, #0x1c]
; }
 800e064: bf00         	nop
 800e066: bf00         	nop
 800e068: 372c         	adds	r7, #0x2c
 800e06a: 46bd         	mov	sp, r7
 800e06c: bdf0         	pop	{r4, r5, r6, r7, pc}
 800e06e: bf00         	nop

0800e070 <$d>:
 800e070: 6c 05 00 20  	.word	0x2000056c
 800e074: b8 b0 02 08  	.word	0x0802b0b8
 800e078: e0 9b 02 08  	.word	0x08029be0
 800e07c: 04 9c 02 08  	.word	0x08029c04

0800e080 <spi_stm32_send_next_frame>:
; {
 800e080: b580         	push	{r7, lr}
 800e082: b09c         	sub	sp, #0x70
 800e084: af06         	add	r7, sp, #0x18
 800e086: 6078         	str	r0, [r7, #0x4]
 800e088: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 800e08a: 683b         	ldr	r3, [r7]
 800e08c: 681b         	ldr	r3, [r3]
 800e08e: 889b         	ldrh	r3, [r3, #0x4]
 800e090: 095b         	lsrs	r3, r3, #0x5
 800e092: b2db         	uxtb	r3, r3
 800e094: f003 033f    	and	r3, r3, #0x3f
 800e098: f887 3053    	strb.w	r3, [r7, #0x53]
; 	uint32_t tx_frame = SPI_STM32_TX_NOP;
 800e09c: 2300         	movs	r3, #0x0
 800e09e: 657b         	str	r3, [r7, #0x54]
; 	if (frame_size == 8) {
 800e0a0: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800e0a4: 2b08         	cmp	r3, #0x8
 800e0a6: f040 80a8    	bne.w	0x800e1fa <spi_stm32_send_next_frame+0x17a> @ imm = #0x150
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800e0aa: 683b         	ldr	r3, [r7]
 800e0ac: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 800e0ae: 6c7b         	ldr	r3, [r7, #0x44]
 800e0b0: 6c5b         	ldr	r3, [r3, #0x44]
 800e0b2: 2b00         	cmp	r3, #0x0
 800e0b4: d005         	beq	0x800e0c2 <spi_stm32_send_next_frame+0x42> @ imm = #0xa
 800e0b6: 6c7b         	ldr	r3, [r7, #0x44]
 800e0b8: 6c9b         	ldr	r3, [r3, #0x48]
 800e0ba: 2b00         	cmp	r3, #0x0
 800e0bc: d001         	beq	0x800e0c2 <spi_stm32_send_next_frame+0x42> @ imm = #0x2
 800e0be: 2301         	movs	r3, #0x1
 800e0c0: e000         	b	0x800e0c4 <spi_stm32_send_next_frame+0x44> @ imm = #0x0
 800e0c2: 2300         	movs	r3, #0x0
 800e0c4: f003 0301    	and	r3, r3, #0x1
 800e0c8: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800e0ca: 2b00         	cmp	r3, #0x0
 800e0cc: d005         	beq	0x800e0da <spi_stm32_send_next_frame+0x5a> @ imm = #0xa
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 800e0ce: 683b         	ldr	r3, [r7]
 800e0d0: 6c5b         	ldr	r3, [r3, #0x44]
 800e0d2: 64bb         	str	r3, [r7, #0x48]
 800e0d4: 6cbb         	ldr	r3, [r7, #0x48]
 800e0d6: 781b         	ldrb	r3, [r3]
 800e0d8: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData8(spi, tx_frame);
 800e0da: 6d7b         	ldr	r3, [r7, #0x54]
 800e0dc: b2db         	uxtb	r3, r3
 800e0de: 4619         	mov	r1, r3
 800e0e0: 6878         	ldr	r0, [r7, #0x4]
 800e0e2: f014 fec5    	bl	0x8022e70 <LL_SPI_TransmitData8> @ imm = #0x14d8a
; 		spi_context_update_tx(&data->ctx, 1, 1);
 800e0e6: 683b         	ldr	r3, [r7]
 800e0e8: 643b         	str	r3, [r7, #0x40]
 800e0ea: 2301         	movs	r3, #0x1
 800e0ec: f887 303f    	strb.w	r3, [r7, #0x3f]
 800e0f0: 2301         	movs	r3, #0x1
 800e0f2: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->tx_len) {
 800e0f4: 6c3b         	ldr	r3, [r7, #0x40]
 800e0f6: 6c9b         	ldr	r3, [r3, #0x48]
 800e0f8: 2b00         	cmp	r3, #0x0
 800e0fa: f000 811d    	beq.w	0x800e338 <spi_stm32_send_next_frame+0x2b8> @ imm = #0x23a
; 	if (len > ctx->tx_len) {
 800e0fe: 6c3b         	ldr	r3, [r7, #0x40]
 800e100: 6c9b         	ldr	r3, [r3, #0x48]
 800e102: 6bba         	ldr	r2, [r7, #0x38]
 800e104: 429a         	cmp	r2, r3
 800e106: d91d         	bls	0x800e144 <spi_stm32_send_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800e108: 2303         	movs	r3, #0x3
 800e10a: 2b00         	cmp	r3, #0x0
 800e10c: d019         	beq	0x800e142 <spi_stm32_send_next_frame+0xc2> @ imm = #0x32
 800e10e: 2301         	movs	r3, #0x1
 800e110: f887 3037    	strb.w	r3, [r7, #0x37]
 800e114: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800e118: f083 0301    	eor	r3, r3, #0x1
 800e11c: b2db         	uxtb	r3, r3
 800e11e: 2b00         	cmp	r3, #0x0
 800e120: d10f         	bne	0x800e142 <spi_stm32_send_next_frame+0xc2> @ imm = #0x1e
 800e122: 4b89         	ldr	r3, [pc, #0x224]        @ 0x800e348 <spi_stm32_send_next_frame+0x2c8>
 800e124: 6819         	ldr	r1, [r3]
 800e126: 4b89         	ldr	r3, [pc, #0x224]        @ 0x800e34c <spi_stm32_send_next_frame+0x2cc>
 800e128: 9302         	str	r3, [sp, #0x8]
 800e12a: 2300         	movs	r3, #0x0
 800e12c: 9301         	str	r3, [sp, #0x4]
 800e12e: 2300         	movs	r3, #0x0
 800e130: 9300         	str	r3, [sp]
 800e132: 2300         	movs	r3, #0x0
 800e134: 2201         	movs	r2, #0x1
 800e136: 2000         	movs	r0, #0x0
 800e138: f014 fc89    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x14912
 800e13c: 2300         	movs	r3, #0x0
 800e13e: 633b         	str	r3, [r7, #0x30]
; 		return;
 800e140: e0fd         	b	0x800e33e <spi_stm32_send_next_frame+0x2be> @ imm = #0x1fa
 800e142: e0fc         	b	0x800e33e <spi_stm32_send_next_frame+0x2be> @ imm = #0x1f8
; 	ctx->tx_len -= len;
 800e144: 6c3b         	ldr	r3, [r7, #0x40]
 800e146: 6c9a         	ldr	r2, [r3, #0x48]
 800e148: 6bbb         	ldr	r3, [r7, #0x38]
 800e14a: 1ad2         	subs	r2, r2, r3
 800e14c: 6c3b         	ldr	r3, [r7, #0x40]
 800e14e: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800e150: 6c3b         	ldr	r3, [r7, #0x40]
 800e152: 6c9b         	ldr	r3, [r3, #0x48]
 800e154: 2b00         	cmp	r3, #0x0
 800e156: d11b         	bne	0x800e190 <spi_stm32_send_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_tx;
 800e158: 6c3b         	ldr	r3, [r7, #0x40]
 800e15a: 6b5b         	ldr	r3, [r3, #0x34]
 800e15c: f103 0208    	add.w	r2, r3, #0x8
 800e160: 6c3b         	ldr	r3, [r7, #0x40]
 800e162: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800e164: 6c3b         	ldr	r3, [r7, #0x40]
 800e166: 6b9b         	ldr	r3, [r3, #0x38]
 800e168: 1e5a         	subs	r2, r3, #0x1
 800e16a: 6c3b         	ldr	r3, [r7, #0x40]
 800e16c: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800e16e: 6c3b         	ldr	r3, [r7, #0x40]
 800e170: f103 0034    	add.w	r0, r3, #0x34
 800e174: 6c3b         	ldr	r3, [r7, #0x40]
 800e176: f103 0138    	add.w	r1, r3, #0x38
 800e17a: 6c3b         	ldr	r3, [r7, #0x40]
 800e17c: f103 0248    	add.w	r2, r3, #0x48
 800e180: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800e184: f015 f8ec    	bl	0x8023360 <spi_context_get_next_buf> @ imm = #0x151d8
 800e188: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800e18a: 6c3b         	ldr	r3, [r7, #0x40]
 800e18c: 645a         	str	r2, [r3, #0x44]
 800e18e: e00d         	b	0x800e1ac <spi_stm32_send_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 800e190: 6c3b         	ldr	r3, [r7, #0x40]
 800e192: 6c5b         	ldr	r3, [r3, #0x44]
 800e194: 2b00         	cmp	r3, #0x0
 800e196: d009         	beq	0x800e1ac <spi_stm32_send_next_frame+0x12c> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 800e198: 6c3b         	ldr	r3, [r7, #0x40]
 800e19a: 6c5a         	ldr	r2, [r3, #0x44]
 800e19c: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800e1a0: 6bb9         	ldr	r1, [r7, #0x38]
 800e1a2: fb01 f303    	mul	r3, r1, r3
 800e1a6: 441a         	add	r2, r3
 800e1a8: 6c3b         	ldr	r3, [r7, #0x40]
 800e1aa: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800e1ac: 2303         	movs	r3, #0x3
 800e1ae: 2b03         	cmp	r3, #0x3
 800e1b0: f240 80c5    	bls.w	0x800e33e <spi_stm32_send_next_frame+0x2be> @ imm = #0x18a
 800e1b4: 2301         	movs	r3, #0x1
 800e1b6: f887 302f    	strb.w	r3, [r7, #0x2f]
 800e1ba: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800e1be: f083 0301    	eor	r3, r3, #0x1
 800e1c2: b2db         	uxtb	r3, r3
 800e1c4: 2b00         	cmp	r3, #0x0
 800e1c6: f040 80ba    	bne.w	0x800e33e <spi_stm32_send_next_frame+0x2be> @ imm = #0x174
 800e1ca: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800e348 <spi_stm32_send_next_frame+0x2c8>
 800e1cc: 6819         	ldr	r1, [r3]
 800e1ce: 6c3b         	ldr	r3, [r7, #0x40]
 800e1d0: 6c5b         	ldr	r3, [r3, #0x44]
 800e1d2: 6c3a         	ldr	r2, [r7, #0x40]
 800e1d4: 6c92         	ldr	r2, [r2, #0x48]
 800e1d6: 9205         	str	r2, [sp, #0x14]
 800e1d8: 9304         	str	r3, [sp, #0x10]
 800e1da: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x800e350 <spi_stm32_send_next_frame+0x2d0>
 800e1dc: 9303         	str	r3, [sp, #0xc]
 800e1de: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x800e354 <spi_stm32_send_next_frame+0x2d4>
 800e1e0: 9302         	str	r3, [sp, #0x8]
 800e1e2: 2308         	movs	r3, #0x8
 800e1e4: 9301         	str	r3, [sp, #0x4]
 800e1e6: 2300         	movs	r3, #0x0
 800e1e8: 9300         	str	r3, [sp]
 800e1ea: 2300         	movs	r3, #0x0
 800e1ec: 2204         	movs	r2, #0x4
 800e1ee: 2000         	movs	r0, #0x0
 800e1f0: f014 fc2d    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x1485a
 800e1f4: 2300         	movs	r3, #0x0
 800e1f6: 62bb         	str	r3, [r7, #0x28]
; }
 800e1f8: e0a1         	b	0x800e33e <spi_stm32_send_next_frame+0x2be> @ imm = #0x142
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800e1fa: 683b         	ldr	r3, [r7]
 800e1fc: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 800e1fe: 6a7b         	ldr	r3, [r7, #0x24]
 800e200: 6c5b         	ldr	r3, [r3, #0x44]
 800e202: 2b00         	cmp	r3, #0x0
 800e204: d005         	beq	0x800e212 <spi_stm32_send_next_frame+0x192> @ imm = #0xa
 800e206: 6a7b         	ldr	r3, [r7, #0x24]
 800e208: 6c9b         	ldr	r3, [r3, #0x48]
 800e20a: 2b00         	cmp	r3, #0x0
 800e20c: d001         	beq	0x800e212 <spi_stm32_send_next_frame+0x192> @ imm = #0x2
 800e20e: 2301         	movs	r3, #0x1
 800e210: e000         	b	0x800e214 <spi_stm32_send_next_frame+0x194> @ imm = #0x0
 800e212: 2300         	movs	r3, #0x0
 800e214: f003 0301    	and	r3, r3, #0x1
 800e218: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800e21a: 2b00         	cmp	r3, #0x0
 800e21c: d006         	beq	0x800e22c <spi_stm32_send_next_frame+0x1ac> @ imm = #0xc
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 800e21e: 683b         	ldr	r3, [r7]
 800e220: 6c5b         	ldr	r3, [r3, #0x44]
 800e222: 64fb         	str	r3, [r7, #0x4c]
 800e224: 6cfb         	ldr	r3, [r7, #0x4c]
 800e226: 881b         	ldrh	r3, [r3]
 800e228: b29b         	uxth	r3, r3
 800e22a: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData16(spi, tx_frame);
 800e22c: 6d7b         	ldr	r3, [r7, #0x54]
 800e22e: b29b         	uxth	r3, r3
 800e230: 4619         	mov	r1, r3
 800e232: 6878         	ldr	r0, [r7, #0x4]
 800e234: f014 fe2e    	bl	0x8022e94 <LL_SPI_TransmitData16> @ imm = #0x14c5c
; 		spi_context_update_tx(&data->ctx, 2, 1);
 800e238: 683b         	ldr	r3, [r7]
 800e23a: 623b         	str	r3, [r7, #0x20]
 800e23c: 2302         	movs	r3, #0x2
 800e23e: 77fb         	strb	r3, [r7, #0x1f]
 800e240: 2301         	movs	r3, #0x1
 800e242: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->tx_len) {
 800e244: 6a3b         	ldr	r3, [r7, #0x20]
 800e246: 6c9b         	ldr	r3, [r3, #0x48]
 800e248: 2b00         	cmp	r3, #0x0
 800e24a: d077         	beq	0x800e33c <spi_stm32_send_next_frame+0x2bc> @ imm = #0xee
; 	if (len > ctx->tx_len) {
 800e24c: 6a3b         	ldr	r3, [r7, #0x20]
 800e24e: 6c9b         	ldr	r3, [r3, #0x48]
 800e250: 69ba         	ldr	r2, [r7, #0x18]
 800e252: 429a         	cmp	r2, r3
 800e254: d91b         	bls	0x800e28e <spi_stm32_send_next_frame+0x20e> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 800e256: 2303         	movs	r3, #0x3
 800e258: 2b00         	cmp	r3, #0x0
 800e25a: d017         	beq	0x800e28c <spi_stm32_send_next_frame+0x20c> @ imm = #0x2e
 800e25c: 2301         	movs	r3, #0x1
 800e25e: 75fb         	strb	r3, [r7, #0x17]
 800e260: 7dfb         	ldrb	r3, [r7, #0x17]
 800e262: f083 0301    	eor	r3, r3, #0x1
 800e266: b2db         	uxtb	r3, r3
 800e268: 2b00         	cmp	r3, #0x0
 800e26a: d10f         	bne	0x800e28c <spi_stm32_send_next_frame+0x20c> @ imm = #0x1e
 800e26c: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800e348 <spi_stm32_send_next_frame+0x2c8>
 800e26e: 6819         	ldr	r1, [r3]
 800e270: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800e34c <spi_stm32_send_next_frame+0x2cc>
 800e272: 9302         	str	r3, [sp, #0x8]
 800e274: 2300         	movs	r3, #0x0
 800e276: 9301         	str	r3, [sp, #0x4]
 800e278: 2300         	movs	r3, #0x0
 800e27a: 9300         	str	r3, [sp]
 800e27c: 2300         	movs	r3, #0x0
 800e27e: 2201         	movs	r2, #0x1
 800e280: 2000         	movs	r0, #0x0
 800e282: f014 fbe4    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x147c8
 800e286: 2300         	movs	r3, #0x0
 800e288: 613b         	str	r3, [r7, #0x10]
; 		return;
 800e28a: e058         	b	0x800e33e <spi_stm32_send_next_frame+0x2be> @ imm = #0xb0
 800e28c: e057         	b	0x800e33e <spi_stm32_send_next_frame+0x2be> @ imm = #0xae
; 	ctx->tx_len -= len;
 800e28e: 6a3b         	ldr	r3, [r7, #0x20]
 800e290: 6c9a         	ldr	r2, [r3, #0x48]
 800e292: 69bb         	ldr	r3, [r7, #0x18]
 800e294: 1ad2         	subs	r2, r2, r3
 800e296: 6a3b         	ldr	r3, [r7, #0x20]
 800e298: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800e29a: 6a3b         	ldr	r3, [r7, #0x20]
 800e29c: 6c9b         	ldr	r3, [r3, #0x48]
 800e29e: 2b00         	cmp	r3, #0x0
 800e2a0: d11a         	bne	0x800e2d8 <spi_stm32_send_next_frame+0x258> @ imm = #0x34
; 		++ctx->current_tx;
 800e2a2: 6a3b         	ldr	r3, [r7, #0x20]
 800e2a4: 6b5b         	ldr	r3, [r3, #0x34]
 800e2a6: f103 0208    	add.w	r2, r3, #0x8
 800e2aa: 6a3b         	ldr	r3, [r7, #0x20]
 800e2ac: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800e2ae: 6a3b         	ldr	r3, [r7, #0x20]
 800e2b0: 6b9b         	ldr	r3, [r3, #0x38]
 800e2b2: 1e5a         	subs	r2, r3, #0x1
 800e2b4: 6a3b         	ldr	r3, [r7, #0x20]
 800e2b6: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800e2b8: 6a3b         	ldr	r3, [r7, #0x20]
 800e2ba: f103 0034    	add.w	r0, r3, #0x34
 800e2be: 6a3b         	ldr	r3, [r7, #0x20]
 800e2c0: f103 0138    	add.w	r1, r3, #0x38
 800e2c4: 6a3b         	ldr	r3, [r7, #0x20]
 800e2c6: f103 0248    	add.w	r2, r3, #0x48
 800e2ca: 7ffb         	ldrb	r3, [r7, #0x1f]
 800e2cc: f015 f848    	bl	0x8023360 <spi_context_get_next_buf> @ imm = #0x15090
 800e2d0: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800e2d2: 6a3b         	ldr	r3, [r7, #0x20]
 800e2d4: 645a         	str	r2, [r3, #0x44]
 800e2d6: e00c         	b	0x800e2f2 <spi_stm32_send_next_frame+0x272> @ imm = #0x18
; 	} else if (ctx->tx_buf) {
 800e2d8: 6a3b         	ldr	r3, [r7, #0x20]
 800e2da: 6c5b         	ldr	r3, [r3, #0x44]
 800e2dc: 2b00         	cmp	r3, #0x0
 800e2de: d008         	beq	0x800e2f2 <spi_stm32_send_next_frame+0x272> @ imm = #0x10
; 		ctx->tx_buf += dfs * len;
 800e2e0: 6a3b         	ldr	r3, [r7, #0x20]
 800e2e2: 6c5a         	ldr	r2, [r3, #0x44]
 800e2e4: 7ffb         	ldrb	r3, [r7, #0x1f]
 800e2e6: 69b9         	ldr	r1, [r7, #0x18]
 800e2e8: fb01 f303    	mul	r3, r1, r3
 800e2ec: 441a         	add	r2, r3
 800e2ee: 6a3b         	ldr	r3, [r7, #0x20]
 800e2f0: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800e2f2: 2303         	movs	r3, #0x3
 800e2f4: 2b03         	cmp	r3, #0x3
 800e2f6: d922         	bls	0x800e33e <spi_stm32_send_next_frame+0x2be> @ imm = #0x44
 800e2f8: 2301         	movs	r3, #0x1
 800e2fa: 73fb         	strb	r3, [r7, #0xf]
 800e2fc: 7bfb         	ldrb	r3, [r7, #0xf]
 800e2fe: f083 0301    	eor	r3, r3, #0x1
 800e302: b2db         	uxtb	r3, r3
 800e304: 2b00         	cmp	r3, #0x0
 800e306: d11a         	bne	0x800e33e <spi_stm32_send_next_frame+0x2be> @ imm = #0x34
 800e308: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800e348 <spi_stm32_send_next_frame+0x2c8>
 800e30a: 6819         	ldr	r1, [r3]
 800e30c: 6a3b         	ldr	r3, [r7, #0x20]
 800e30e: 6c5b         	ldr	r3, [r3, #0x44]
 800e310: 6a3a         	ldr	r2, [r7, #0x20]
 800e312: 6c92         	ldr	r2, [r2, #0x48]
 800e314: 9205         	str	r2, [sp, #0x14]
 800e316: 9304         	str	r3, [sp, #0x10]
 800e318: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e350 <spi_stm32_send_next_frame+0x2d0>
 800e31a: 9303         	str	r3, [sp, #0xc]
 800e31c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e354 <spi_stm32_send_next_frame+0x2d4>
 800e31e: 9302         	str	r3, [sp, #0x8]
 800e320: 2308         	movs	r3, #0x8
 800e322: 9301         	str	r3, [sp, #0x4]
 800e324: 2300         	movs	r3, #0x0
 800e326: 9300         	str	r3, [sp]
 800e328: 2300         	movs	r3, #0x0
 800e32a: 2204         	movs	r2, #0x4
 800e32c: 2000         	movs	r0, #0x0
 800e32e: f014 fb8e    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x1471c
 800e332: 2300         	movs	r3, #0x0
 800e334: 60bb         	str	r3, [r7, #0x8]
; }
 800e336: e002         	b	0x800e33e <spi_stm32_send_next_frame+0x2be> @ imm = #0x4
; 		return;
 800e338: bf00         	nop
 800e33a: e000         	b	0x800e33e <spi_stm32_send_next_frame+0x2be> @ imm = #0x0
 800e33c: bf00         	nop
; }
 800e33e: bf00         	nop
 800e340: 3758         	adds	r7, #0x58
 800e342: 46bd         	mov	sp, r7
 800e344: bd80         	pop	{r7, pc}
 800e346: bf00         	nop

0800e348 <$d>:
 800e348: 6c 05 00 20  	.word	0x2000056c
 800e34c: 58 9c 02 08  	.word	0x08029c58
 800e350: 60 b0 02 08  	.word	0x0802b060
 800e354: 78 9c 02 08  	.word	0x08029c78

0800e358 <spi_stm32_read_next_frame>:
; {
 800e358: b580         	push	{r7, lr}
 800e35a: b09c         	sub	sp, #0x70
 800e35c: af06         	add	r7, sp, #0x18
 800e35e: 6078         	str	r0, [r7, #0x4]
 800e360: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 800e362: 683b         	ldr	r3, [r7]
 800e364: 681b         	ldr	r3, [r3]
 800e366: 889b         	ldrh	r3, [r3, #0x4]
 800e368: 095b         	lsrs	r3, r3, #0x5
 800e36a: b2db         	uxtb	r3, r3
 800e36c: f003 033f    	and	r3, r3, #0x3f
 800e370: f887 3057    	strb.w	r3, [r7, #0x57]
; 	uint32_t rx_frame = 0;
 800e374: 2300         	movs	r3, #0x0
 800e376: 653b         	str	r3, [r7, #0x50]
; 	if (frame_size == 8) {
 800e378: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800e37c: 2b08         	cmp	r3, #0x8
 800e37e: f040 80a8    	bne.w	0x800e4d2 <spi_stm32_read_next_frame+0x17a> @ imm = #0x150
; 		rx_frame = LL_SPI_ReceiveData8(spi);
 800e382: 6878         	ldr	r0, [r7, #0x4]
 800e384: f014 fd59    	bl	0x8022e3a <LL_SPI_ReceiveData8> @ imm = #0x14ab2
 800e388: 4603         	mov	r3, r0
 800e38a: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800e38c: 683b         	ldr	r3, [r7]
 800e38e: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 800e390: 6c7b         	ldr	r3, [r7, #0x44]
 800e392: 6cdb         	ldr	r3, [r3, #0x4c]
 800e394: 2b00         	cmp	r3, #0x0
 800e396: d005         	beq	0x800e3a4 <spi_stm32_read_next_frame+0x4c> @ imm = #0xa
 800e398: 6c7b         	ldr	r3, [r7, #0x44]
 800e39a: 6d1b         	ldr	r3, [r3, #0x50]
 800e39c: 2b00         	cmp	r3, #0x0
 800e39e: d001         	beq	0x800e3a4 <spi_stm32_read_next_frame+0x4c> @ imm = #0x2
 800e3a0: 2301         	movs	r3, #0x1
 800e3a2: e000         	b	0x800e3a6 <spi_stm32_read_next_frame+0x4e> @ imm = #0x0
 800e3a4: 2300         	movs	r3, #0x0
 800e3a6: f003 0301    	and	r3, r3, #0x1
 800e3aa: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800e3ac: 2b00         	cmp	r3, #0x0
 800e3ae: d006         	beq	0x800e3be <spi_stm32_read_next_frame+0x66> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 800e3b0: 683b         	ldr	r3, [r7]
 800e3b2: 6cdb         	ldr	r3, [r3, #0x4c]
 800e3b4: 64bb         	str	r3, [r7, #0x48]
 800e3b6: 6d3b         	ldr	r3, [r7, #0x50]
 800e3b8: b2da         	uxtb	r2, r3
 800e3ba: 6cbb         	ldr	r3, [r7, #0x48]
 800e3bc: 701a         	strb	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 1, 1);
 800e3be: 683b         	ldr	r3, [r7]
 800e3c0: 643b         	str	r3, [r7, #0x40]
 800e3c2: 2301         	movs	r3, #0x1
 800e3c4: f887 303f    	strb.w	r3, [r7, #0x3f]
 800e3c8: 2301         	movs	r3, #0x1
 800e3ca: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->rx_len) {
 800e3cc: 6c3b         	ldr	r3, [r7, #0x40]
 800e3ce: 6d1b         	ldr	r3, [r3, #0x50]
 800e3d0: 2b00         	cmp	r3, #0x0
 800e3d2: f000 811c    	beq.w	0x800e60e <spi_stm32_read_next_frame+0x2b6> @ imm = #0x238
; 	if (len > ctx->rx_len) {
 800e3d6: 6c3b         	ldr	r3, [r7, #0x40]
 800e3d8: 6d1b         	ldr	r3, [r3, #0x50]
 800e3da: 6bba         	ldr	r2, [r7, #0x38]
 800e3dc: 429a         	cmp	r2, r3
 800e3de: d91d         	bls	0x800e41c <spi_stm32_read_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800e3e0: 2303         	movs	r3, #0x3
 800e3e2: 2b00         	cmp	r3, #0x0
 800e3e4: d019         	beq	0x800e41a <spi_stm32_read_next_frame+0xc2> @ imm = #0x32
 800e3e6: 2301         	movs	r3, #0x1
 800e3e8: f887 3037    	strb.w	r3, [r7, #0x37]
 800e3ec: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800e3f0: f083 0301    	eor	r3, r3, #0x1
 800e3f4: b2db         	uxtb	r3, r3
 800e3f6: 2b00         	cmp	r3, #0x0
 800e3f8: d10f         	bne	0x800e41a <spi_stm32_read_next_frame+0xc2> @ imm = #0x1e
 800e3fa: 4b88         	ldr	r3, [pc, #0x220]        @ 0x800e61c <spi_stm32_read_next_frame+0x2c4>
 800e3fc: 6819         	ldr	r1, [r3]
 800e3fe: 4b88         	ldr	r3, [pc, #0x220]        @ 0x800e620 <spi_stm32_read_next_frame+0x2c8>
 800e400: 9302         	str	r3, [sp, #0x8]
 800e402: 2300         	movs	r3, #0x0
 800e404: 9301         	str	r3, [sp, #0x4]
 800e406: 2300         	movs	r3, #0x0
 800e408: 9300         	str	r3, [sp]
 800e40a: 2300         	movs	r3, #0x0
 800e40c: 2201         	movs	r2, #0x1
 800e40e: 2000         	movs	r0, #0x0
 800e410: f014 fb1d    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x1463a
 800e414: 2300         	movs	r3, #0x0
 800e416: 633b         	str	r3, [r7, #0x30]
; 		return;
 800e418: e0fc         	b	0x800e614 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f8
 800e41a: e0fb         	b	0x800e614 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f6
; 	ctx->rx_len -= len;
 800e41c: 6c3b         	ldr	r3, [r7, #0x40]
 800e41e: 6d1a         	ldr	r2, [r3, #0x50]
 800e420: 6bbb         	ldr	r3, [r7, #0x38]
 800e422: 1ad2         	subs	r2, r2, r3
 800e424: 6c3b         	ldr	r3, [r7, #0x40]
 800e426: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800e428: 6c3b         	ldr	r3, [r7, #0x40]
 800e42a: 6d1b         	ldr	r3, [r3, #0x50]
 800e42c: 2b00         	cmp	r3, #0x0
 800e42e: d11b         	bne	0x800e468 <spi_stm32_read_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_rx;
 800e430: 6c3b         	ldr	r3, [r7, #0x40]
 800e432: 6bdb         	ldr	r3, [r3, #0x3c]
 800e434: f103 0208    	add.w	r2, r3, #0x8
 800e438: 6c3b         	ldr	r3, [r7, #0x40]
 800e43a: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800e43c: 6c3b         	ldr	r3, [r7, #0x40]
 800e43e: 6c1b         	ldr	r3, [r3, #0x40]
 800e440: 1e5a         	subs	r2, r3, #0x1
 800e442: 6c3b         	ldr	r3, [r7, #0x40]
 800e444: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800e446: 6c3b         	ldr	r3, [r7, #0x40]
 800e448: f103 003c    	add.w	r0, r3, #0x3c
 800e44c: 6c3b         	ldr	r3, [r7, #0x40]
 800e44e: f103 0140    	add.w	r1, r3, #0x40
 800e452: 6c3b         	ldr	r3, [r7, #0x40]
 800e454: f103 0250    	add.w	r2, r3, #0x50
 800e458: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800e45c: f014 ff80    	bl	0x8023360 <spi_context_get_next_buf> @ imm = #0x14f00
 800e460: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800e462: 6c3b         	ldr	r3, [r7, #0x40]
 800e464: 64da         	str	r2, [r3, #0x4c]
 800e466: e00d         	b	0x800e484 <spi_stm32_read_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 800e468: 6c3b         	ldr	r3, [r7, #0x40]
 800e46a: 6cdb         	ldr	r3, [r3, #0x4c]
 800e46c: 2b00         	cmp	r3, #0x0
 800e46e: d009         	beq	0x800e484 <spi_stm32_read_next_frame+0x12c> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 800e470: 6c3b         	ldr	r3, [r7, #0x40]
 800e472: 6cda         	ldr	r2, [r3, #0x4c]
 800e474: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800e478: 6bb9         	ldr	r1, [r7, #0x38]
 800e47a: fb01 f303    	mul	r3, r1, r3
 800e47e: 441a         	add	r2, r3
 800e480: 6c3b         	ldr	r3, [r7, #0x40]
 800e482: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800e484: 2303         	movs	r3, #0x3
 800e486: 2b03         	cmp	r3, #0x3
 800e488: f240 80c4    	bls.w	0x800e614 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x188
 800e48c: 2301         	movs	r3, #0x1
 800e48e: f887 302f    	strb.w	r3, [r7, #0x2f]
 800e492: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800e496: f083 0301    	eor	r3, r3, #0x1
 800e49a: b2db         	uxtb	r3, r3
 800e49c: 2b00         	cmp	r3, #0x0
 800e49e: f040 80b9    	bne.w	0x800e614 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x172
 800e4a2: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x800e61c <spi_stm32_read_next_frame+0x2c4>
 800e4a4: 6819         	ldr	r1, [r3]
 800e4a6: 6c3b         	ldr	r3, [r7, #0x40]
 800e4a8: 6cdb         	ldr	r3, [r3, #0x4c]
 800e4aa: 6c3a         	ldr	r2, [r7, #0x40]
 800e4ac: 6d12         	ldr	r2, [r2, #0x50]
 800e4ae: 9205         	str	r2, [sp, #0x14]
 800e4b0: 9304         	str	r3, [sp, #0x10]
 800e4b2: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800e624 <spi_stm32_read_next_frame+0x2cc>
 800e4b4: 9303         	str	r3, [sp, #0xc]
 800e4b6: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800e628 <spi_stm32_read_next_frame+0x2d0>
 800e4b8: 9302         	str	r3, [sp, #0x8]
 800e4ba: 2308         	movs	r3, #0x8
 800e4bc: 9301         	str	r3, [sp, #0x4]
 800e4be: 2300         	movs	r3, #0x0
 800e4c0: 9300         	str	r3, [sp]
 800e4c2: 2300         	movs	r3, #0x0
 800e4c4: 2204         	movs	r2, #0x4
 800e4c6: 2000         	movs	r0, #0x0
 800e4c8: f014 fac1    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x14582
 800e4cc: 2300         	movs	r3, #0x0
 800e4ce: 62bb         	str	r3, [r7, #0x28]
; }
 800e4d0: e0a0         	b	0x800e614 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x140
; 		rx_frame = LL_SPI_ReceiveData16(spi);
 800e4d2: 6878         	ldr	r0, [r7, #0x4]
 800e4d4: f014 fcbf    	bl	0x8022e56 <LL_SPI_ReceiveData16> @ imm = #0x1497e
 800e4d8: 4603         	mov	r3, r0
 800e4da: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800e4dc: 683b         	ldr	r3, [r7]
 800e4de: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 800e4e0: 6a7b         	ldr	r3, [r7, #0x24]
 800e4e2: 6cdb         	ldr	r3, [r3, #0x4c]
 800e4e4: 2b00         	cmp	r3, #0x0
 800e4e6: d005         	beq	0x800e4f4 <spi_stm32_read_next_frame+0x19c> @ imm = #0xa
 800e4e8: 6a7b         	ldr	r3, [r7, #0x24]
 800e4ea: 6d1b         	ldr	r3, [r3, #0x50]
 800e4ec: 2b00         	cmp	r3, #0x0
 800e4ee: d001         	beq	0x800e4f4 <spi_stm32_read_next_frame+0x19c> @ imm = #0x2
 800e4f0: 2301         	movs	r3, #0x1
 800e4f2: e000         	b	0x800e4f6 <spi_stm32_read_next_frame+0x19e> @ imm = #0x0
 800e4f4: 2300         	movs	r3, #0x0
 800e4f6: f003 0301    	and	r3, r3, #0x1
 800e4fa: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800e4fc: 2b00         	cmp	r3, #0x0
 800e4fe: d006         	beq	0x800e50e <spi_stm32_read_next_frame+0x1b6> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 800e500: 683b         	ldr	r3, [r7]
 800e502: 6cdb         	ldr	r3, [r3, #0x4c]
 800e504: 64fb         	str	r3, [r7, #0x4c]
 800e506: 6d3b         	ldr	r3, [r7, #0x50]
 800e508: b29a         	uxth	r2, r3
 800e50a: 6cfb         	ldr	r3, [r7, #0x4c]
 800e50c: 801a         	strh	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 2, 1);
 800e50e: 683b         	ldr	r3, [r7]
 800e510: 623b         	str	r3, [r7, #0x20]
 800e512: 2302         	movs	r3, #0x2
 800e514: 77fb         	strb	r3, [r7, #0x1f]
 800e516: 2301         	movs	r3, #0x1
 800e518: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 800e51a: 6a3b         	ldr	r3, [r7, #0x20]
 800e51c: 6d1b         	ldr	r3, [r3, #0x50]
 800e51e: 2b00         	cmp	r3, #0x0
 800e520: d077         	beq	0x800e612 <spi_stm32_read_next_frame+0x2ba> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 800e522: 6a3b         	ldr	r3, [r7, #0x20]
 800e524: 6d1b         	ldr	r3, [r3, #0x50]
 800e526: 69ba         	ldr	r2, [r7, #0x18]
 800e528: 429a         	cmp	r2, r3
 800e52a: d91b         	bls	0x800e564 <spi_stm32_read_next_frame+0x20c> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 800e52c: 2303         	movs	r3, #0x3
 800e52e: 2b00         	cmp	r3, #0x0
 800e530: d017         	beq	0x800e562 <spi_stm32_read_next_frame+0x20a> @ imm = #0x2e
 800e532: 2301         	movs	r3, #0x1
 800e534: 75fb         	strb	r3, [r7, #0x17]
 800e536: 7dfb         	ldrb	r3, [r7, #0x17]
 800e538: f083 0301    	eor	r3, r3, #0x1
 800e53c: b2db         	uxtb	r3, r3
 800e53e: 2b00         	cmp	r3, #0x0
 800e540: d10f         	bne	0x800e562 <spi_stm32_read_next_frame+0x20a> @ imm = #0x1e
 800e542: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800e61c <spi_stm32_read_next_frame+0x2c4>
 800e544: 6819         	ldr	r1, [r3]
 800e546: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800e620 <spi_stm32_read_next_frame+0x2c8>
 800e548: 9302         	str	r3, [sp, #0x8]
 800e54a: 2300         	movs	r3, #0x0
 800e54c: 9301         	str	r3, [sp, #0x4]
 800e54e: 2300         	movs	r3, #0x0
 800e550: 9300         	str	r3, [sp]
 800e552: 2300         	movs	r3, #0x0
 800e554: 2201         	movs	r2, #0x1
 800e556: 2000         	movs	r0, #0x0
 800e558: f014 fa79    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x144f2
 800e55c: 2300         	movs	r3, #0x0
 800e55e: 613b         	str	r3, [r7, #0x10]
; 		return;
 800e560: e058         	b	0x800e614 <spi_stm32_read_next_frame+0x2bc> @ imm = #0xb0
 800e562: e057         	b	0x800e614 <spi_stm32_read_next_frame+0x2bc> @ imm = #0xae
; 	ctx->rx_len -= len;
 800e564: 6a3b         	ldr	r3, [r7, #0x20]
 800e566: 6d1a         	ldr	r2, [r3, #0x50]
 800e568: 69bb         	ldr	r3, [r7, #0x18]
 800e56a: 1ad2         	subs	r2, r2, r3
 800e56c: 6a3b         	ldr	r3, [r7, #0x20]
 800e56e: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800e570: 6a3b         	ldr	r3, [r7, #0x20]
 800e572: 6d1b         	ldr	r3, [r3, #0x50]
 800e574: 2b00         	cmp	r3, #0x0
 800e576: d11a         	bne	0x800e5ae <spi_stm32_read_next_frame+0x256> @ imm = #0x34
; 		++ctx->current_rx;
 800e578: 6a3b         	ldr	r3, [r7, #0x20]
 800e57a: 6bdb         	ldr	r3, [r3, #0x3c]
 800e57c: f103 0208    	add.w	r2, r3, #0x8
 800e580: 6a3b         	ldr	r3, [r7, #0x20]
 800e582: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800e584: 6a3b         	ldr	r3, [r7, #0x20]
 800e586: 6c1b         	ldr	r3, [r3, #0x40]
 800e588: 1e5a         	subs	r2, r3, #0x1
 800e58a: 6a3b         	ldr	r3, [r7, #0x20]
 800e58c: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800e58e: 6a3b         	ldr	r3, [r7, #0x20]
 800e590: f103 003c    	add.w	r0, r3, #0x3c
 800e594: 6a3b         	ldr	r3, [r7, #0x20]
 800e596: f103 0140    	add.w	r1, r3, #0x40
 800e59a: 6a3b         	ldr	r3, [r7, #0x20]
 800e59c: f103 0250    	add.w	r2, r3, #0x50
 800e5a0: 7ffb         	ldrb	r3, [r7, #0x1f]
 800e5a2: f014 fedd    	bl	0x8023360 <spi_context_get_next_buf> @ imm = #0x14dba
 800e5a6: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800e5a8: 6a3b         	ldr	r3, [r7, #0x20]
 800e5aa: 64da         	str	r2, [r3, #0x4c]
 800e5ac: e00c         	b	0x800e5c8 <spi_stm32_read_next_frame+0x270> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 800e5ae: 6a3b         	ldr	r3, [r7, #0x20]
 800e5b0: 6cdb         	ldr	r3, [r3, #0x4c]
 800e5b2: 2b00         	cmp	r3, #0x0
 800e5b4: d008         	beq	0x800e5c8 <spi_stm32_read_next_frame+0x270> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 800e5b6: 6a3b         	ldr	r3, [r7, #0x20]
 800e5b8: 6cda         	ldr	r2, [r3, #0x4c]
 800e5ba: 7ffb         	ldrb	r3, [r7, #0x1f]
 800e5bc: 69b9         	ldr	r1, [r7, #0x18]
 800e5be: fb01 f303    	mul	r3, r1, r3
 800e5c2: 441a         	add	r2, r3
 800e5c4: 6a3b         	ldr	r3, [r7, #0x20]
 800e5c6: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800e5c8: 2303         	movs	r3, #0x3
 800e5ca: 2b03         	cmp	r3, #0x3
 800e5cc: d922         	bls	0x800e614 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x44
 800e5ce: 2301         	movs	r3, #0x1
 800e5d0: 73fb         	strb	r3, [r7, #0xf]
 800e5d2: 7bfb         	ldrb	r3, [r7, #0xf]
 800e5d4: f083 0301    	eor	r3, r3, #0x1
 800e5d8: b2db         	uxtb	r3, r3
 800e5da: 2b00         	cmp	r3, #0x0
 800e5dc: d11a         	bne	0x800e614 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x34
 800e5de: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800e61c <spi_stm32_read_next_frame+0x2c4>
 800e5e0: 6819         	ldr	r1, [r3]
 800e5e2: 6a3b         	ldr	r3, [r7, #0x20]
 800e5e4: 6cdb         	ldr	r3, [r3, #0x4c]
 800e5e6: 6a3a         	ldr	r2, [r7, #0x20]
 800e5e8: 6d12         	ldr	r2, [r2, #0x50]
 800e5ea: 9205         	str	r2, [sp, #0x14]
 800e5ec: 9304         	str	r3, [sp, #0x10]
 800e5ee: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e624 <spi_stm32_read_next_frame+0x2cc>
 800e5f0: 9303         	str	r3, [sp, #0xc]
 800e5f2: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e628 <spi_stm32_read_next_frame+0x2d0>
 800e5f4: 9302         	str	r3, [sp, #0x8]
 800e5f6: 2308         	movs	r3, #0x8
 800e5f8: 9301         	str	r3, [sp, #0x4]
 800e5fa: 2300         	movs	r3, #0x0
 800e5fc: 9300         	str	r3, [sp]
 800e5fe: 2300         	movs	r3, #0x0
 800e600: 2204         	movs	r2, #0x4
 800e602: 2000         	movs	r0, #0x0
 800e604: f014 fa23    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x14446
 800e608: 2300         	movs	r3, #0x0
 800e60a: 60bb         	str	r3, [r7, #0x8]
; }
 800e60c: e002         	b	0x800e614 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x4
; 		return;
 800e60e: bf00         	nop
 800e610: e000         	b	0x800e614 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x0
 800e612: bf00         	nop
; }
 800e614: bf00         	nop
 800e616: 3758         	adds	r7, #0x58
 800e618: 46bd         	mov	sp, r7
 800e61a: bd80         	pop	{r7, pc}

0800e61c <$d>:
 800e61c: 6c 05 00 20  	.word	0x2000056c
 800e620: 58 9c 02 08  	.word	0x08029c58
 800e624: 78 b0 02 08  	.word	0x0802b078
 800e628: 90 9c 02 08  	.word	0x08029c90

0800e62c <spi_stm32_get_err>:
; {
 800e62c: b580         	push	{r7, lr}
 800e62e: b08c         	sub	sp, #0x30
 800e630: af06         	add	r7, sp, #0x18
 800e632: 6078         	str	r0, [r7, #0x4]
; 	uint32_t sr = LL_SPI_ReadReg(spi, SR);
 800e634: 687b         	ldr	r3, [r7, #0x4]
 800e636: 689b         	ldr	r3, [r3, #0x8]
 800e638: 617b         	str	r3, [r7, #0x14]
; 	if (sr & SPI_STM32_ERR_MSK) {
 800e63a: 697b         	ldr	r3, [r7, #0x14]
 800e63c: f403 73b8    	and	r3, r3, #0x170
 800e640: 2b00         	cmp	r3, #0x0
 800e642: d02b         	beq	0x800e69c <spi_stm32_get_err+0x70> @ imm = #0x56
; 		LOG_ERR("%s: err=%d", __func__, sr & (uint32_t)SPI_STM32_ERR_MSK);
 800e644: 2303         	movs	r3, #0x3
 800e646: 2b00         	cmp	r3, #0x0
 800e648: d01c         	beq	0x800e684 <spi_stm32_get_err+0x58> @ imm = #0x38
 800e64a: 2301         	movs	r3, #0x1
 800e64c: 74fb         	strb	r3, [r7, #0x13]
 800e64e: 7cfb         	ldrb	r3, [r7, #0x13]
 800e650: f083 0301    	eor	r3, r3, #0x1
 800e654: b2db         	uxtb	r3, r3
 800e656: 2b00         	cmp	r3, #0x0
 800e658: d114         	bne	0x800e684 <spi_stm32_get_err+0x58> @ imm = #0x28
 800e65a: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800e6a8 <spi_stm32_get_err+0x7c>
 800e65c: 6819         	ldr	r1, [r3]
 800e65e: 697b         	ldr	r3, [r7, #0x14]
 800e660: f403 73b8    	and	r3, r3, #0x170
 800e664: 9304         	str	r3, [sp, #0x10]
 800e666: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800e6ac <spi_stm32_get_err+0x80>
 800e668: 9303         	str	r3, [sp, #0xc]
 800e66a: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800e6b0 <spi_stm32_get_err+0x84>
 800e66c: 9302         	str	r3, [sp, #0x8]
 800e66e: 2300         	movs	r3, #0x0
 800e670: 9301         	str	r3, [sp, #0x4]
 800e672: 2300         	movs	r3, #0x0
 800e674: 9300         	str	r3, [sp]
 800e676: 2300         	movs	r3, #0x0
 800e678: 2201         	movs	r2, #0x1
 800e67a: 2000         	movs	r0, #0x0
 800e67c: f014 f9e7    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x143ce
 800e680: 2300         	movs	r3, #0x0
 800e682: 60fb         	str	r3, [r7, #0xc]
; 		if (LL_SPI_IsActiveFlag_OVR(spi)) {
 800e684: 6878         	ldr	r0, [r7, #0x4]
 800e686: f014 fb7c    	bl	0x8022d82 <LL_SPI_IsActiveFlag_OVR> @ imm = #0x146f8
 800e68a: 4603         	mov	r3, r0
 800e68c: 2b00         	cmp	r3, #0x0
 800e68e: d002         	beq	0x800e696 <spi_stm32_get_err+0x6a> @ imm = #0x4
; 			LL_SPI_ClearFlag_OVR(spi);
 800e690: 6878         	ldr	r0, [r7, #0x4]
 800e692: f014 fbb0    	bl	0x8022df6 <LL_SPI_ClearFlag_OVR> @ imm = #0x14760
; 		return -EIO;
 800e696: f06f 0304    	mvn	r3, #0x4
 800e69a: e000         	b	0x800e69e <spi_stm32_get_err+0x72> @ imm = #0x0
; 	return 0;
 800e69c: 2300         	movs	r3, #0x0
; }
 800e69e: 4618         	mov	r0, r3
 800e6a0: 3718         	adds	r7, #0x18
 800e6a2: 46bd         	mov	sp, r7
 800e6a4: bd80         	pop	{r7, pc}
 800e6a6: bf00         	nop

0800e6a8 <$d>:
 800e6a8: 6c 05 00 20  	.word	0x2000056c
 800e6ac: 90 b0 02 08  	.word	0x0802b090
 800e6b0: a8 9c 02 08  	.word	0x08029ca8

0800e6b4 <spi_stm32_shift_s>:
; {
 800e6b4: b580         	push	{r7, lr}
 800e6b6: b0ac         	sub	sp, #0xb0
 800e6b8: af06         	add	r7, sp, #0x18
 800e6ba: 6078         	str	r0, [r7, #0x4]
 800e6bc: 6039         	str	r1, [r7]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800e6be: 6878         	ldr	r0, [r7, #0x4]
 800e6c0: f014 fe81    	bl	0x80233c6 <ll_func_tx_is_not_full> @ imm = #0x14d02
 800e6c4: 4603         	mov	r3, r0
 800e6c6: 2b00         	cmp	r3, #0x0
 800e6c8: f000 814a    	beq.w	0x800e960 <spi_stm32_shift_s+0x2ac> @ imm = #0x294
 800e6cc: 683b         	ldr	r3, [r7]
 800e6ce: 67fb         	str	r3, [r7, #0x7c]
; 	return !!(ctx->tx_len);
 800e6d0: 6ffb         	ldr	r3, [r7, #0x7c]
 800e6d2: 6c9b         	ldr	r3, [r3, #0x48]
 800e6d4: 2b00         	cmp	r3, #0x0
 800e6d6: bf14         	ite	ne
 800e6d8: 2301         	movne	r3, #0x1
 800e6da: 2300         	moveq	r3, #0x0
 800e6dc: b2db         	uxtb	r3, r3
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800e6de: 2b00         	cmp	r3, #0x0
 800e6e0: f000 813e    	beq.w	0x800e960 <spi_stm32_shift_s+0x2ac> @ imm = #0x27c
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 800e6e4: 683b         	ldr	r3, [r7]
 800e6e6: 681b         	ldr	r3, [r3]
 800e6e8: 889b         	ldrh	r3, [r3, #0x4]
 800e6ea: 095b         	lsrs	r3, r3, #0x5
 800e6ec: f003 033f    	and	r3, r3, #0x3f
 800e6f0: 2b08         	cmp	r3, #0x8
 800e6f2: f040 809a    	bne.w	0x800e82a <spi_stm32_shift_s+0x176> @ imm = #0x134
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 800e6f6: 683b         	ldr	r3, [r7]
 800e6f8: 6c5b         	ldr	r3, [r3, #0x44]
 800e6fa: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800e6fe: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800e702: 781b         	ldrb	r3, [r3]
 800e704: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData8(spi, tx_frame);
 800e708: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 800e70c: b2db         	uxtb	r3, r3
 800e70e: 4619         	mov	r1, r3
 800e710: 6878         	ldr	r0, [r7, #0x4]
 800e712: f014 fbad    	bl	0x8022e70 <LL_SPI_TransmitData8> @ imm = #0x1475a
; 			spi_context_update_tx(&data->ctx, 1, 1);
 800e716: 683b         	ldr	r3, [r7]
 800e718: 67bb         	str	r3, [r7, #0x78]
 800e71a: 2301         	movs	r3, #0x1
 800e71c: f887 3077    	strb.w	r3, [r7, #0x77]
 800e720: 2301         	movs	r3, #0x1
 800e722: 673b         	str	r3, [r7, #0x70]
; 	if (!ctx->tx_len) {
 800e724: 6fbb         	ldr	r3, [r7, #0x78]
 800e726: 6c9b         	ldr	r3, [r3, #0x48]
 800e728: 2b00         	cmp	r3, #0x0
 800e72a: f000 8115    	beq.w	0x800e958 <spi_stm32_shift_s+0x2a4> @ imm = #0x22a
; 	if (len > ctx->tx_len) {
 800e72e: 6fbb         	ldr	r3, [r7, #0x78]
 800e730: 6c9b         	ldr	r3, [r3, #0x48]
 800e732: 6f3a         	ldr	r2, [r7, #0x70]
 800e734: 429a         	cmp	r2, r3
 800e736: d91d         	bls	0x800e774 <spi_stm32_shift_s+0xc0> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800e738: 2303         	movs	r3, #0x3
 800e73a: 2b00         	cmp	r3, #0x0
 800e73c: d019         	beq	0x800e772 <spi_stm32_shift_s+0xbe> @ imm = #0x32
 800e73e: 2301         	movs	r3, #0x1
 800e740: f887 306f    	strb.w	r3, [r7, #0x6f]
 800e744: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800e748: f083 0301    	eor	r3, r3, #0x1
 800e74c: b2db         	uxtb	r3, r3
 800e74e: 2b00         	cmp	r3, #0x0
 800e750: d10f         	bne	0x800e772 <spi_stm32_shift_s+0xbe> @ imm = #0x1e
 800e752: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800e98c <spi_stm32_shift_s+0x2d8>
 800e754: 6819         	ldr	r1, [r3]
 800e756: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800e990 <spi_stm32_shift_s+0x2dc>
 800e758: 9302         	str	r3, [sp, #0x8]
 800e75a: 2300         	movs	r3, #0x0
 800e75c: 9301         	str	r3, [sp, #0x4]
 800e75e: 2300         	movs	r3, #0x0
 800e760: 9300         	str	r3, [sp]
 800e762: 2300         	movs	r3, #0x0
 800e764: 2201         	movs	r2, #0x1
 800e766: 2000         	movs	r0, #0x0
 800e768: f014 f971    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x142e2
 800e76c: 2300         	movs	r3, #0x0
 800e76e: 66bb         	str	r3, [r7, #0x68]
; 		return;
 800e770: e0f5         	b	0x800e95e <spi_stm32_shift_s+0x2aa> @ imm = #0x1ea
 800e772: e0f4         	b	0x800e95e <spi_stm32_shift_s+0x2aa> @ imm = #0x1e8
; 	ctx->tx_len -= len;
 800e774: 6fbb         	ldr	r3, [r7, #0x78]
 800e776: 6c9a         	ldr	r2, [r3, #0x48]
 800e778: 6f3b         	ldr	r3, [r7, #0x70]
 800e77a: 1ad2         	subs	r2, r2, r3
 800e77c: 6fbb         	ldr	r3, [r7, #0x78]
 800e77e: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800e780: 6fbb         	ldr	r3, [r7, #0x78]
 800e782: 6c9b         	ldr	r3, [r3, #0x48]
 800e784: 2b00         	cmp	r3, #0x0
 800e786: d11b         	bne	0x800e7c0 <spi_stm32_shift_s+0x10c> @ imm = #0x36
; 		++ctx->current_tx;
 800e788: 6fbb         	ldr	r3, [r7, #0x78]
 800e78a: 6b5b         	ldr	r3, [r3, #0x34]
 800e78c: f103 0208    	add.w	r2, r3, #0x8
 800e790: 6fbb         	ldr	r3, [r7, #0x78]
 800e792: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800e794: 6fbb         	ldr	r3, [r7, #0x78]
 800e796: 6b9b         	ldr	r3, [r3, #0x38]
 800e798: 1e5a         	subs	r2, r3, #0x1
 800e79a: 6fbb         	ldr	r3, [r7, #0x78]
 800e79c: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800e79e: 6fbb         	ldr	r3, [r7, #0x78]
 800e7a0: f103 0034    	add.w	r0, r3, #0x34
 800e7a4: 6fbb         	ldr	r3, [r7, #0x78]
 800e7a6: f103 0138    	add.w	r1, r3, #0x38
 800e7aa: 6fbb         	ldr	r3, [r7, #0x78]
 800e7ac: f103 0248    	add.w	r2, r3, #0x48
 800e7b0: f897 3077    	ldrb.w	r3, [r7, #0x77]
 800e7b4: f014 fdd4    	bl	0x8023360 <spi_context_get_next_buf> @ imm = #0x14ba8
 800e7b8: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800e7ba: 6fbb         	ldr	r3, [r7, #0x78]
 800e7bc: 645a         	str	r2, [r3, #0x44]
 800e7be: e00d         	b	0x800e7dc <spi_stm32_shift_s+0x128> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 800e7c0: 6fbb         	ldr	r3, [r7, #0x78]
 800e7c2: 6c5b         	ldr	r3, [r3, #0x44]
 800e7c4: 2b00         	cmp	r3, #0x0
 800e7c6: d009         	beq	0x800e7dc <spi_stm32_shift_s+0x128> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 800e7c8: 6fbb         	ldr	r3, [r7, #0x78]
 800e7ca: 6c5a         	ldr	r2, [r3, #0x44]
 800e7cc: f897 3077    	ldrb.w	r3, [r7, #0x77]
 800e7d0: 6f39         	ldr	r1, [r7, #0x70]
 800e7d2: fb01 f303    	mul	r3, r1, r3
 800e7d6: 441a         	add	r2, r3
 800e7d8: 6fbb         	ldr	r3, [r7, #0x78]
 800e7da: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800e7dc: 2303         	movs	r3, #0x3
 800e7de: 2b03         	cmp	r3, #0x3
 800e7e0: f240 80bd    	bls.w	0x800e95e <spi_stm32_shift_s+0x2aa> @ imm = #0x17a
 800e7e4: 2301         	movs	r3, #0x1
 800e7e6: f887 3067    	strb.w	r3, [r7, #0x67]
 800e7ea: f897 3067    	ldrb.w	r3, [r7, #0x67]
 800e7ee: f083 0301    	eor	r3, r3, #0x1
 800e7f2: b2db         	uxtb	r3, r3
 800e7f4: 2b00         	cmp	r3, #0x0
 800e7f6: f040 80b2    	bne.w	0x800e95e <spi_stm32_shift_s+0x2aa> @ imm = #0x164
 800e7fa: 4b64         	ldr	r3, [pc, #0x190]        @ 0x800e98c <spi_stm32_shift_s+0x2d8>
 800e7fc: 6819         	ldr	r1, [r3]
 800e7fe: 6fbb         	ldr	r3, [r7, #0x78]
 800e800: 6c5b         	ldr	r3, [r3, #0x44]
 800e802: 6fba         	ldr	r2, [r7, #0x78]
 800e804: 6c92         	ldr	r2, [r2, #0x48]
 800e806: 9205         	str	r2, [sp, #0x14]
 800e808: 9304         	str	r3, [sp, #0x10]
 800e80a: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800e994 <spi_stm32_shift_s+0x2e0>
 800e80c: 9303         	str	r3, [sp, #0xc]
 800e80e: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800e998 <spi_stm32_shift_s+0x2e4>
 800e810: 9302         	str	r3, [sp, #0x8]
 800e812: 2308         	movs	r3, #0x8
 800e814: 9301         	str	r3, [sp, #0x4]
 800e816: 2300         	movs	r3, #0x0
 800e818: 9300         	str	r3, [sp]
 800e81a: 2300         	movs	r3, #0x0
 800e81c: 2204         	movs	r2, #0x4
 800e81e: 2000         	movs	r0, #0x0
 800e820: f014 f915    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x1422a
 800e824: 2300         	movs	r3, #0x0
 800e826: 663b         	str	r3, [r7, #0x60]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800e828: e09d         	b	0x800e966 <spi_stm32_shift_s+0x2b2> @ imm = #0x13a
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 800e82a: 683b         	ldr	r3, [r7]
 800e82c: 6c5b         	ldr	r3, [r3, #0x44]
 800e82e: f8c7 3094    	str.w	r3, [r7, #0x94]
 800e832: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800e836: 881b         	ldrh	r3, [r3]
 800e838: b29b         	uxth	r3, r3
 800e83a: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData16(spi, tx_frame);
 800e83e: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 800e842: 4619         	mov	r1, r3
 800e844: 6878         	ldr	r0, [r7, #0x4]
 800e846: f014 fb25    	bl	0x8022e94 <LL_SPI_TransmitData16> @ imm = #0x1464a
; 			spi_context_update_tx(&data->ctx, 2, 1);
 800e84a: 683b         	ldr	r3, [r7]
 800e84c: 65fb         	str	r3, [r7, #0x5c]
 800e84e: 2302         	movs	r3, #0x2
 800e850: f887 305b    	strb.w	r3, [r7, #0x5b]
 800e854: 2301         	movs	r3, #0x1
 800e856: 657b         	str	r3, [r7, #0x54]
; 	if (!ctx->tx_len) {
 800e858: 6dfb         	ldr	r3, [r7, #0x5c]
 800e85a: 6c9b         	ldr	r3, [r3, #0x48]
 800e85c: 2b00         	cmp	r3, #0x0
 800e85e: d07d         	beq	0x800e95c <spi_stm32_shift_s+0x2a8> @ imm = #0xfa
; 	if (len > ctx->tx_len) {
 800e860: 6dfb         	ldr	r3, [r7, #0x5c]
 800e862: 6c9b         	ldr	r3, [r3, #0x48]
 800e864: 6d7a         	ldr	r2, [r7, #0x54]
 800e866: 429a         	cmp	r2, r3
 800e868: d91d         	bls	0x800e8a6 <spi_stm32_shift_s+0x1f2> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800e86a: 2303         	movs	r3, #0x3
 800e86c: 2b00         	cmp	r3, #0x0
 800e86e: d019         	beq	0x800e8a4 <spi_stm32_shift_s+0x1f0> @ imm = #0x32
 800e870: 2301         	movs	r3, #0x1
 800e872: f887 3053    	strb.w	r3, [r7, #0x53]
 800e876: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800e87a: f083 0301    	eor	r3, r3, #0x1
 800e87e: b2db         	uxtb	r3, r3
 800e880: 2b00         	cmp	r3, #0x0
 800e882: d10f         	bne	0x800e8a4 <spi_stm32_shift_s+0x1f0> @ imm = #0x1e
 800e884: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800e98c <spi_stm32_shift_s+0x2d8>
 800e886: 6819         	ldr	r1, [r3]
 800e888: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800e990 <spi_stm32_shift_s+0x2dc>
 800e88a: 9302         	str	r3, [sp, #0x8]
 800e88c: 2300         	movs	r3, #0x0
 800e88e: 9301         	str	r3, [sp, #0x4]
 800e890: 2300         	movs	r3, #0x0
 800e892: 9300         	str	r3, [sp]
 800e894: 2300         	movs	r3, #0x0
 800e896: 2201         	movs	r2, #0x1
 800e898: 2000         	movs	r0, #0x0
 800e89a: f014 f8d8    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x141b0
 800e89e: 2300         	movs	r3, #0x0
 800e8a0: 64fb         	str	r3, [r7, #0x4c]
; 		return;
 800e8a2: e05c         	b	0x800e95e <spi_stm32_shift_s+0x2aa> @ imm = #0xb8
 800e8a4: e05b         	b	0x800e95e <spi_stm32_shift_s+0x2aa> @ imm = #0xb6
; 	ctx->tx_len -= len;
 800e8a6: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8a8: 6c9a         	ldr	r2, [r3, #0x48]
 800e8aa: 6d7b         	ldr	r3, [r7, #0x54]
 800e8ac: 1ad2         	subs	r2, r2, r3
 800e8ae: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8b0: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800e8b2: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8b4: 6c9b         	ldr	r3, [r3, #0x48]
 800e8b6: 2b00         	cmp	r3, #0x0
 800e8b8: d11b         	bne	0x800e8f2 <spi_stm32_shift_s+0x23e> @ imm = #0x36
; 		++ctx->current_tx;
 800e8ba: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8bc: 6b5b         	ldr	r3, [r3, #0x34]
 800e8be: f103 0208    	add.w	r2, r3, #0x8
 800e8c2: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8c4: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800e8c6: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8c8: 6b9b         	ldr	r3, [r3, #0x38]
 800e8ca: 1e5a         	subs	r2, r3, #0x1
 800e8cc: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8ce: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800e8d0: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8d2: f103 0034    	add.w	r0, r3, #0x34
 800e8d6: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8d8: f103 0138    	add.w	r1, r3, #0x38
 800e8dc: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8de: f103 0248    	add.w	r2, r3, #0x48
 800e8e2: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 800e8e6: f014 fd3b    	bl	0x8023360 <spi_context_get_next_buf> @ imm = #0x14a76
 800e8ea: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800e8ec: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8ee: 645a         	str	r2, [r3, #0x44]
 800e8f0: e00d         	b	0x800e90e <spi_stm32_shift_s+0x25a> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 800e8f2: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8f4: 6c5b         	ldr	r3, [r3, #0x44]
 800e8f6: 2b00         	cmp	r3, #0x0
 800e8f8: d009         	beq	0x800e90e <spi_stm32_shift_s+0x25a> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 800e8fa: 6dfb         	ldr	r3, [r7, #0x5c]
 800e8fc: 6c5a         	ldr	r2, [r3, #0x44]
 800e8fe: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 800e902: 6d79         	ldr	r1, [r7, #0x54]
 800e904: fb01 f303    	mul	r3, r1, r3
 800e908: 441a         	add	r2, r3
 800e90a: 6dfb         	ldr	r3, [r7, #0x5c]
 800e90c: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800e90e: 2303         	movs	r3, #0x3
 800e910: 2b03         	cmp	r3, #0x3
 800e912: d924         	bls	0x800e95e <spi_stm32_shift_s+0x2aa> @ imm = #0x48
 800e914: 2301         	movs	r3, #0x1
 800e916: f887 304b    	strb.w	r3, [r7, #0x4b]
 800e91a: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 800e91e: f083 0301    	eor	r3, r3, #0x1
 800e922: b2db         	uxtb	r3, r3
 800e924: 2b00         	cmp	r3, #0x0
 800e926: d11a         	bne	0x800e95e <spi_stm32_shift_s+0x2aa> @ imm = #0x34
 800e928: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800e98c <spi_stm32_shift_s+0x2d8>
 800e92a: 6819         	ldr	r1, [r3]
 800e92c: 6dfb         	ldr	r3, [r7, #0x5c]
 800e92e: 6c5b         	ldr	r3, [r3, #0x44]
 800e930: 6dfa         	ldr	r2, [r7, #0x5c]
 800e932: 6c92         	ldr	r2, [r2, #0x48]
 800e934: 9205         	str	r2, [sp, #0x14]
 800e936: 9304         	str	r3, [sp, #0x10]
 800e938: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800e994 <spi_stm32_shift_s+0x2e0>
 800e93a: 9303         	str	r3, [sp, #0xc]
 800e93c: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800e998 <spi_stm32_shift_s+0x2e4>
 800e93e: 9302         	str	r3, [sp, #0x8]
 800e940: 2308         	movs	r3, #0x8
 800e942: 9301         	str	r3, [sp, #0x4]
 800e944: 2300         	movs	r3, #0x0
 800e946: 9300         	str	r3, [sp]
 800e948: 2300         	movs	r3, #0x0
 800e94a: 2204         	movs	r2, #0x4
 800e94c: 2000         	movs	r0, #0x0
 800e94e: f014 f87e    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x140fc
 800e952: 2300         	movs	r3, #0x0
 800e954: 647b         	str	r3, [r7, #0x44]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800e956: e006         	b	0x800e966 <spi_stm32_shift_s+0x2b2> @ imm = #0xc
; 		return;
 800e958: bf00         	nop
 800e95a: e004         	b	0x800e966 <spi_stm32_shift_s+0x2b2> @ imm = #0x8
 800e95c: bf00         	nop
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800e95e: e002         	b	0x800e966 <spi_stm32_shift_s+0x2b2> @ imm = #0x4
; 		ll_func_disable_int_tx_empty(spi);
 800e960: 6878         	ldr	r0, [r7, #0x4]
 800e962: f014 fd48    	bl	0x80233f6 <ll_func_disable_int_tx_empty> @ imm = #0x14a90
; 	if (ll_func_rx_is_not_empty(spi) && spi_context_rx_buf_on(&data->ctx)) {
 800e966: 6878         	ldr	r0, [r7, #0x4]
 800e968: f014 fd39    	bl	0x80233de <ll_func_rx_is_not_empty> @ imm = #0x14a72
 800e96c: 4603         	mov	r3, r0
 800e96e: 2b00         	cmp	r3, #0x0
 800e970: f000 8150    	beq.w	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0x2a0
 800e974: 683b         	ldr	r3, [r7]
 800e976: 643b         	str	r3, [r7, #0x40]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 800e978: 6c3b         	ldr	r3, [r7, #0x40]
 800e97a: 6cdb         	ldr	r3, [r3, #0x4c]
 800e97c: 2b00         	cmp	r3, #0x0
 800e97e: d00d         	beq	0x800e99c <spi_stm32_shift_s+0x2e8> @ imm = #0x1a
 800e980: 6c3b         	ldr	r3, [r7, #0x40]
 800e982: 6d1b         	ldr	r3, [r3, #0x50]
 800e984: 2b00         	cmp	r3, #0x0
 800e986: d009         	beq	0x800e99c <spi_stm32_shift_s+0x2e8> @ imm = #0x12
 800e988: 2301         	movs	r3, #0x1
 800e98a: e008         	b	0x800e99e <spi_stm32_shift_s+0x2ea> @ imm = #0x10

0800e98c <$d>:
 800e98c: 6c 05 00 20  	.word	0x2000056c
 800e990: 58 9c 02 08  	.word	0x08029c58
 800e994: 60 b0 02 08  	.word	0x0802b060
 800e998: 78 9c 02 08  	.word	0x08029c78

0800e99c <$t>:
 800e99c: 2300         	movs	r3, #0x0
 800e99e: f003 0301    	and	r3, r3, #0x1
 800e9a2: b2db         	uxtb	r3, r3
; 	if (ll_func_rx_is_not_empty(spi) && spi_context_rx_buf_on(&data->ctx)) {
 800e9a4: 2b00         	cmp	r3, #0x0
 800e9a6: f000 8135    	beq.w	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0x26a
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 800e9aa: 683b         	ldr	r3, [r7]
 800e9ac: 681b         	ldr	r3, [r3]
 800e9ae: 889b         	ldrh	r3, [r3, #0x4]
 800e9b0: 095b         	lsrs	r3, r3, #0x5
 800e9b2: f003 033f    	and	r3, r3, #0x3f
 800e9b6: 2b08         	cmp	r3, #0x8
 800e9b8: f040 809a    	bne.w	0x800eaf0 <spi_stm32_shift_s+0x43c> @ imm = #0x134
; 			rx_frame = LL_SPI_ReceiveData8(spi);
 800e9bc: 6878         	ldr	r0, [r7, #0x4]
 800e9be: f014 fa3c    	bl	0x8022e3a <LL_SPI_ReceiveData8> @ imm = #0x14478
 800e9c2: 4603         	mov	r3, r0
 800e9c4: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 800e9c8: 683b         	ldr	r3, [r7]
 800e9ca: 6cdb         	ldr	r3, [r3, #0x4c]
 800e9cc: f8c7 3080    	str.w	r3, [r7, #0x80]
 800e9d0: f8b7 308a    	ldrh.w	r3, [r7, #0x8a]
 800e9d4: b2da         	uxtb	r2, r3
 800e9d6: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800e9da: 701a         	strb	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 1, 1);
 800e9dc: 683b         	ldr	r3, [r7]
 800e9de: 63fb         	str	r3, [r7, #0x3c]
 800e9e0: 2301         	movs	r3, #0x1
 800e9e2: f887 303b    	strb.w	r3, [r7, #0x3b]
 800e9e6: 2301         	movs	r3, #0x1
 800e9e8: 637b         	str	r3, [r7, #0x34]
; 	if (!ctx->rx_len) {
 800e9ea: 6bfb         	ldr	r3, [r7, #0x3c]
 800e9ec: 6d1b         	ldr	r3, [r3, #0x50]
 800e9ee: 2b00         	cmp	r3, #0x0
 800e9f0: f000 810d    	beq.w	0x800ec0e <spi_stm32_shift_s+0x55a> @ imm = #0x21a
; 	if (len > ctx->rx_len) {
 800e9f4: 6bfb         	ldr	r3, [r7, #0x3c]
 800e9f6: 6d1b         	ldr	r3, [r3, #0x50]
 800e9f8: 6b7a         	ldr	r2, [r7, #0x34]
 800e9fa: 429a         	cmp	r2, r3
 800e9fc: d91d         	bls	0x800ea3a <spi_stm32_shift_s+0x386> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800e9fe: 2303         	movs	r3, #0x3
 800ea00: 2b00         	cmp	r3, #0x0
 800ea02: d019         	beq	0x800ea38 <spi_stm32_shift_s+0x384> @ imm = #0x32
 800ea04: 2301         	movs	r3, #0x1
 800ea06: f887 3033    	strb.w	r3, [r7, #0x33]
 800ea0a: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800ea0e: f083 0301    	eor	r3, r3, #0x1
 800ea12: b2db         	uxtb	r3, r3
 800ea14: 2b00         	cmp	r3, #0x0
 800ea16: d10f         	bne	0x800ea38 <spi_stm32_shift_s+0x384> @ imm = #0x1e
 800ea18: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800ec1c <spi_stm32_shift_s+0x568>
 800ea1a: 6819         	ldr	r1, [r3]
 800ea1c: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800ec20 <spi_stm32_shift_s+0x56c>
 800ea1e: 9302         	str	r3, [sp, #0x8]
 800ea20: 2300         	movs	r3, #0x0
 800ea22: 9301         	str	r3, [sp, #0x4]
 800ea24: 2300         	movs	r3, #0x0
 800ea26: 9300         	str	r3, [sp]
 800ea28: 2300         	movs	r3, #0x0
 800ea2a: 2201         	movs	r2, #0x1
 800ea2c: 2000         	movs	r0, #0x0
 800ea2e: f014 f80e    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x1401c
 800ea32: 2300         	movs	r3, #0x0
 800ea34: 62fb         	str	r3, [r7, #0x2c]
; 		return;
 800ea36: e0ed         	b	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0x1da
 800ea38: e0ec         	b	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0x1d8
; 	ctx->rx_len -= len;
 800ea3a: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea3c: 6d1a         	ldr	r2, [r3, #0x50]
 800ea3e: 6b7b         	ldr	r3, [r7, #0x34]
 800ea40: 1ad2         	subs	r2, r2, r3
 800ea42: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea44: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800ea46: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea48: 6d1b         	ldr	r3, [r3, #0x50]
 800ea4a: 2b00         	cmp	r3, #0x0
 800ea4c: d11b         	bne	0x800ea86 <spi_stm32_shift_s+0x3d2> @ imm = #0x36
; 		++ctx->current_rx;
 800ea4e: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea50: 6bdb         	ldr	r3, [r3, #0x3c]
 800ea52: f103 0208    	add.w	r2, r3, #0x8
 800ea56: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea58: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800ea5a: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea5c: 6c1b         	ldr	r3, [r3, #0x40]
 800ea5e: 1e5a         	subs	r2, r3, #0x1
 800ea60: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea62: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800ea64: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea66: f103 003c    	add.w	r0, r3, #0x3c
 800ea6a: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea6c: f103 0140    	add.w	r1, r3, #0x40
 800ea70: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea72: f103 0250    	add.w	r2, r3, #0x50
 800ea76: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800ea7a: f014 fc71    	bl	0x8023360 <spi_context_get_next_buf> @ imm = #0x148e2
 800ea7e: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800ea80: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea82: 64da         	str	r2, [r3, #0x4c]
 800ea84: e00d         	b	0x800eaa2 <spi_stm32_shift_s+0x3ee> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 800ea86: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea88: 6cdb         	ldr	r3, [r3, #0x4c]
 800ea8a: 2b00         	cmp	r3, #0x0
 800ea8c: d009         	beq	0x800eaa2 <spi_stm32_shift_s+0x3ee> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 800ea8e: 6bfb         	ldr	r3, [r7, #0x3c]
 800ea90: 6cda         	ldr	r2, [r3, #0x4c]
 800ea92: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800ea96: 6b79         	ldr	r1, [r7, #0x34]
 800ea98: fb01 f303    	mul	r3, r1, r3
 800ea9c: 441a         	add	r2, r3
 800ea9e: 6bfb         	ldr	r3, [r7, #0x3c]
 800eaa0: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800eaa2: 2303         	movs	r3, #0x3
 800eaa4: 2b03         	cmp	r3, #0x3
 800eaa6: f240 80b5    	bls.w	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0x16a
 800eaaa: 2301         	movs	r3, #0x1
 800eaac: f887 302b    	strb.w	r3, [r7, #0x2b]
 800eab0: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800eab4: f083 0301    	eor	r3, r3, #0x1
 800eab8: b2db         	uxtb	r3, r3
 800eaba: 2b00         	cmp	r3, #0x0
 800eabc: f040 80aa    	bne.w	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0x154
 800eac0: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800ec1c <spi_stm32_shift_s+0x568>
 800eac2: 6819         	ldr	r1, [r3]
 800eac4: 6bfb         	ldr	r3, [r7, #0x3c]
 800eac6: 6cdb         	ldr	r3, [r3, #0x4c]
 800eac8: 6bfa         	ldr	r2, [r7, #0x3c]
 800eaca: 6d12         	ldr	r2, [r2, #0x50]
 800eacc: 9205         	str	r2, [sp, #0x14]
 800eace: 9304         	str	r3, [sp, #0x10]
 800ead0: 4b54         	ldr	r3, [pc, #0x150]        @ 0x800ec24 <spi_stm32_shift_s+0x570>
 800ead2: 9303         	str	r3, [sp, #0xc]
 800ead4: 4b54         	ldr	r3, [pc, #0x150]        @ 0x800ec28 <spi_stm32_shift_s+0x574>
 800ead6: 9302         	str	r3, [sp, #0x8]
 800ead8: 2308         	movs	r3, #0x8
 800eada: 9301         	str	r3, [sp, #0x4]
 800eadc: 2300         	movs	r3, #0x0
 800eade: 9300         	str	r3, [sp]
 800eae0: 2300         	movs	r3, #0x0
 800eae2: 2204         	movs	r2, #0x4
 800eae4: 2000         	movs	r0, #0x0
 800eae6: f013 ffb2    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x13f64
 800eaea: 2300         	movs	r3, #0x0
 800eaec: 627b         	str	r3, [r7, #0x24]
; }
 800eaee: e091         	b	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0x122
; 			rx_frame = LL_SPI_ReceiveData16(spi);
 800eaf0: 6878         	ldr	r0, [r7, #0x4]
 800eaf2: f014 f9b0    	bl	0x8022e56 <LL_SPI_ReceiveData16> @ imm = #0x14360
 800eaf6: 4603         	mov	r3, r0
 800eaf8: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 800eafc: 683b         	ldr	r3, [r7]
 800eafe: 6cdb         	ldr	r3, [r3, #0x4c]
 800eb00: f8c7 3084    	str.w	r3, [r7, #0x84]
 800eb04: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800eb08: f8b7 208a    	ldrh.w	r2, [r7, #0x8a]
 800eb0c: 801a         	strh	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 2, 1);
 800eb0e: 683b         	ldr	r3, [r7]
 800eb10: 623b         	str	r3, [r7, #0x20]
 800eb12: 2302         	movs	r3, #0x2
 800eb14: 77fb         	strb	r3, [r7, #0x1f]
 800eb16: 2301         	movs	r3, #0x1
 800eb18: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 800eb1a: 6a3b         	ldr	r3, [r7, #0x20]
 800eb1c: 6d1b         	ldr	r3, [r3, #0x50]
 800eb1e: 2b00         	cmp	r3, #0x0
 800eb20: d077         	beq	0x800ec12 <spi_stm32_shift_s+0x55e> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 800eb22: 6a3b         	ldr	r3, [r7, #0x20]
 800eb24: 6d1b         	ldr	r3, [r3, #0x50]
 800eb26: 69ba         	ldr	r2, [r7, #0x18]
 800eb28: 429a         	cmp	r2, r3
 800eb2a: d91b         	bls	0x800eb64 <spi_stm32_shift_s+0x4b0> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 800eb2c: 2303         	movs	r3, #0x3
 800eb2e: 2b00         	cmp	r3, #0x0
 800eb30: d017         	beq	0x800eb62 <spi_stm32_shift_s+0x4ae> @ imm = #0x2e
 800eb32: 2301         	movs	r3, #0x1
 800eb34: 75fb         	strb	r3, [r7, #0x17]
 800eb36: 7dfb         	ldrb	r3, [r7, #0x17]
 800eb38: f083 0301    	eor	r3, r3, #0x1
 800eb3c: b2db         	uxtb	r3, r3
 800eb3e: 2b00         	cmp	r3, #0x0
 800eb40: d10f         	bne	0x800eb62 <spi_stm32_shift_s+0x4ae> @ imm = #0x1e
 800eb42: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800ec1c <spi_stm32_shift_s+0x568>
 800eb44: 6819         	ldr	r1, [r3]
 800eb46: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800ec20 <spi_stm32_shift_s+0x56c>
 800eb48: 9302         	str	r3, [sp, #0x8]
 800eb4a: 2300         	movs	r3, #0x0
 800eb4c: 9301         	str	r3, [sp, #0x4]
 800eb4e: 2300         	movs	r3, #0x0
 800eb50: 9300         	str	r3, [sp]
 800eb52: 2300         	movs	r3, #0x0
 800eb54: 2201         	movs	r2, #0x1
 800eb56: 2000         	movs	r0, #0x0
 800eb58: f013 ff79    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x13ef2
 800eb5c: 2300         	movs	r3, #0x0
 800eb5e: 613b         	str	r3, [r7, #0x10]
; 		return;
 800eb60: e058         	b	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0xb0
 800eb62: e057         	b	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0xae
; 	ctx->rx_len -= len;
 800eb64: 6a3b         	ldr	r3, [r7, #0x20]
 800eb66: 6d1a         	ldr	r2, [r3, #0x50]
 800eb68: 69bb         	ldr	r3, [r7, #0x18]
 800eb6a: 1ad2         	subs	r2, r2, r3
 800eb6c: 6a3b         	ldr	r3, [r7, #0x20]
 800eb6e: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800eb70: 6a3b         	ldr	r3, [r7, #0x20]
 800eb72: 6d1b         	ldr	r3, [r3, #0x50]
 800eb74: 2b00         	cmp	r3, #0x0
 800eb76: d11a         	bne	0x800ebae <spi_stm32_shift_s+0x4fa> @ imm = #0x34
; 		++ctx->current_rx;
 800eb78: 6a3b         	ldr	r3, [r7, #0x20]
 800eb7a: 6bdb         	ldr	r3, [r3, #0x3c]
 800eb7c: f103 0208    	add.w	r2, r3, #0x8
 800eb80: 6a3b         	ldr	r3, [r7, #0x20]
 800eb82: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800eb84: 6a3b         	ldr	r3, [r7, #0x20]
 800eb86: 6c1b         	ldr	r3, [r3, #0x40]
 800eb88: 1e5a         	subs	r2, r3, #0x1
 800eb8a: 6a3b         	ldr	r3, [r7, #0x20]
 800eb8c: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800eb8e: 6a3b         	ldr	r3, [r7, #0x20]
 800eb90: f103 003c    	add.w	r0, r3, #0x3c
 800eb94: 6a3b         	ldr	r3, [r7, #0x20]
 800eb96: f103 0140    	add.w	r1, r3, #0x40
 800eb9a: 6a3b         	ldr	r3, [r7, #0x20]
 800eb9c: f103 0250    	add.w	r2, r3, #0x50
 800eba0: 7ffb         	ldrb	r3, [r7, #0x1f]
 800eba2: f014 fbdd    	bl	0x8023360 <spi_context_get_next_buf> @ imm = #0x147ba
 800eba6: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800eba8: 6a3b         	ldr	r3, [r7, #0x20]
 800ebaa: 64da         	str	r2, [r3, #0x4c]
 800ebac: e00c         	b	0x800ebc8 <spi_stm32_shift_s+0x514> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 800ebae: 6a3b         	ldr	r3, [r7, #0x20]
 800ebb0: 6cdb         	ldr	r3, [r3, #0x4c]
 800ebb2: 2b00         	cmp	r3, #0x0
 800ebb4: d008         	beq	0x800ebc8 <spi_stm32_shift_s+0x514> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 800ebb6: 6a3b         	ldr	r3, [r7, #0x20]
 800ebb8: 6cda         	ldr	r2, [r3, #0x4c]
 800ebba: 7ffb         	ldrb	r3, [r7, #0x1f]
 800ebbc: 69b9         	ldr	r1, [r7, #0x18]
 800ebbe: fb01 f303    	mul	r3, r1, r3
 800ebc2: 441a         	add	r2, r3
 800ebc4: 6a3b         	ldr	r3, [r7, #0x20]
 800ebc6: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800ebc8: 2303         	movs	r3, #0x3
 800ebca: 2b03         	cmp	r3, #0x3
 800ebcc: d922         	bls	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0x44
 800ebce: 2301         	movs	r3, #0x1
 800ebd0: 73fb         	strb	r3, [r7, #0xf]
 800ebd2: 7bfb         	ldrb	r3, [r7, #0xf]
 800ebd4: f083 0301    	eor	r3, r3, #0x1
 800ebd8: b2db         	uxtb	r3, r3
 800ebda: 2b00         	cmp	r3, #0x0
 800ebdc: d11a         	bne	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0x34
 800ebde: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800ec1c <spi_stm32_shift_s+0x568>
 800ebe0: 6819         	ldr	r1, [r3]
 800ebe2: 6a3b         	ldr	r3, [r7, #0x20]
 800ebe4: 6cdb         	ldr	r3, [r3, #0x4c]
 800ebe6: 6a3a         	ldr	r2, [r7, #0x20]
 800ebe8: 6d12         	ldr	r2, [r2, #0x50]
 800ebea: 9205         	str	r2, [sp, #0x14]
 800ebec: 9304         	str	r3, [sp, #0x10]
 800ebee: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ec24 <spi_stm32_shift_s+0x570>
 800ebf0: 9303         	str	r3, [sp, #0xc]
 800ebf2: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ec28 <spi_stm32_shift_s+0x574>
 800ebf4: 9302         	str	r3, [sp, #0x8]
 800ebf6: 2308         	movs	r3, #0x8
 800ebf8: 9301         	str	r3, [sp, #0x4]
 800ebfa: 2300         	movs	r3, #0x0
 800ebfc: 9300         	str	r3, [sp]
 800ebfe: 2300         	movs	r3, #0x0
 800ec00: 2204         	movs	r2, #0x4
 800ec02: 2000         	movs	r0, #0x0
 800ec04: f013 ff23    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x13e46
 800ec08: 2300         	movs	r3, #0x0
 800ec0a: 60bb         	str	r3, [r7, #0x8]
; }
 800ec0c: e002         	b	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0x4
; 		return;
 800ec0e: bf00         	nop
 800ec10: e000         	b	0x800ec14 <spi_stm32_shift_s+0x560> @ imm = #0x0
 800ec12: bf00         	nop
; }
 800ec14: bf00         	nop
 800ec16: 3798         	adds	r7, #0x98
 800ec18: 46bd         	mov	sp, r7
 800ec1a: bd80         	pop	{r7, pc}

0800ec1c <$d>:
 800ec1c: 6c 05 00 20  	.word	0x2000056c
 800ec20: 58 9c 02 08  	.word	0x08029c58
 800ec24: 78 b0 02 08  	.word	0x0802b078
 800ec28: 90 9c 02 08  	.word	0x08029c90

0800ec2c <spi_stm32_configure>:
; {
 800ec2c: b5f0         	push	{r4, r5, r6, r7, lr}
 800ec2e: b0a3         	sub	sp, #0x8c
 800ec30: af0c         	add	r7, sp, #0x30
 800ec32: 6078         	str	r0, [r7, #0x4]
 800ec34: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 800ec36: 687b         	ldr	r3, [r7, #0x4]
 800ec38: 685b         	ldr	r3, [r3, #0x4]
 800ec3a: 63bb         	str	r3, [r7, #0x38]
; 	struct spi_stm32_data *data = dev->data;
 800ec3c: 687b         	ldr	r3, [r7, #0x4]
 800ec3e: 691b         	ldr	r3, [r3, #0x10]
 800ec40: 637b         	str	r3, [r7, #0x34]
; 	const uint32_t scaler[] = {
 800ec42: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x800ee78 <spi_stm32_configure+0x24c>
 800ec44: f107 0410    	add.w	r4, r7, #0x10
 800ec48: 461d         	mov	r5, r3
 800ec4a: cd0f         	ldm	r5!, {r0, r1, r2, r3}
 800ec4c: c40f         	stm	r4!, {r0, r1, r2, r3}
 800ec4e: e895 000f    	ldm.w	r5, {r0, r1, r2, r3}
 800ec52: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
; 	SPI_TypeDef *spi = cfg->spi;
 800ec56: 6bbb         	ldr	r3, [r7, #0x38]
 800ec58: 681b         	ldr	r3, [r3]
 800ec5a: 633b         	str	r3, [r7, #0x30]
; 	if (spi_context_configured(&data->ctx, config)) {
 800ec5c: 6b7b         	ldr	r3, [r7, #0x34]
 800ec5e: 6839         	ldr	r1, [r7]
 800ec60: 4618         	mov	r0, r3
 800ec62: f014 fab5    	bl	0x80231d0 <spi_context_configured> @ imm = #0x1456a
 800ec66: 4603         	mov	r3, r0
 800ec68: 2b00         	cmp	r3, #0x0
 800ec6a: d001         	beq	0x800ec70 <spi_stm32_configure+0x44> @ imm = #0x2
; 		return 0;
 800ec6c: 2300         	movs	r3, #0x0
 800ec6e: e156         	b	0x800ef1e <spi_stm32_configure+0x2f2> @ imm = #0x2ac
; 	if ((SPI_WORD_SIZE_GET(config->operation) != 8) &&
 800ec70: 683b         	ldr	r3, [r7]
 800ec72: 889b         	ldrh	r3, [r3, #0x4]
 800ec74: 095b         	lsrs	r3, r3, #0x5
 800ec76: f003 033f    	and	r3, r3, #0x3f
 800ec7a: 2b08         	cmp	r3, #0x8
 800ec7c: d009         	beq	0x800ec92 <spi_stm32_configure+0x66> @ imm = #0x12
; 	    (SPI_WORD_SIZE_GET(config->operation) != 16)) {
 800ec7e: 683b         	ldr	r3, [r7]
 800ec80: 889b         	ldrh	r3, [r3, #0x4]
 800ec82: 095b         	lsrs	r3, r3, #0x5
 800ec84: f003 033f    	and	r3, r3, #0x3f
; 	if ((SPI_WORD_SIZE_GET(config->operation) != 8) &&
 800ec88: 2b10         	cmp	r3, #0x10
 800ec8a: d002         	beq	0x800ec92 <spi_stm32_configure+0x66> @ imm = #0x4
; 		return -ENOTSUP;
 800ec8c: f06f 0385    	mvn	r3, #0x85
 800ec90: e145         	b	0x800ef1e <spi_stm32_configure+0x2f2> @ imm = #0x28a
; 	if ((config->operation & SPI_FRAME_FORMAT_TI) == SPI_FRAME_FORMAT_TI) {
 800ec92: 683b         	ldr	r3, [r7]
 800ec94: 889b         	ldrh	r3, [r3, #0x4]
 800ec96: b21b         	sxth	r3, r3
 800ec98: 2b00         	cmp	r3, #0x0
 800ec9a: da04         	bge	0x800eca6 <spi_stm32_configure+0x7a> @ imm = #0x8
; 		LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_TI);
 800ec9c: 2110         	movs	r1, #0x10
 800ec9e: 6b38         	ldr	r0, [r7, #0x30]
 800eca0: f013 ff85    	bl	0x8022bae <LL_SPI_SetStandard> @ imm = #0x13f0a
 800eca4: e003         	b	0x800ecae <spi_stm32_configure+0x82> @ imm = #0x6
; 		LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_MOTOROLA);
 800eca6: 2100         	movs	r1, #0x0
 800eca8: 6b38         	ldr	r0, [r7, #0x30]
 800ecaa: f013 ff80    	bl	0x8022bae <LL_SPI_SetStandard> @ imm = #0x13f00
; 					   (clock_control_subsys_t)&cfg->pclken[0], &clock) < 0) {
 800ecae: 6bbb         	ldr	r3, [r7, #0x38]
 800ecb0: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 800ecb2: f107 020c    	add.w	r2, r7, #0xc
 800ecb6: 4619         	mov	r1, r3
 800ecb8: 4870         	ldr	r0, [pc, #0x1c0]        @ 0x800ee7c <spi_stm32_configure+0x250>
 800ecba: f014 fa6e    	bl	0x802319a <clock_control_get_rate> @ imm = #0x144dc
 800ecbe: 4603         	mov	r3, r0
 800ecc0: 2b00         	cmp	r3, #0x0
 800ecc2: da1e         	bge	0x800ed02 <spi_stm32_configure+0xd6> @ imm = #0x3c
; 			LOG_ERR("Failed call clock_control_get_rate(pclk[0])");
 800ecc4: 2303         	movs	r3, #0x3
 800ecc6: 2b00         	cmp	r3, #0x0
 800ecc8: d018         	beq	0x800ecfc <spi_stm32_configure+0xd0> @ imm = #0x30
 800ecca: 2301         	movs	r3, #0x1
 800eccc: f887 3053    	strb.w	r3, [r7, #0x53]
 800ecd0: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800ecd4: f083 0301    	eor	r3, r3, #0x1
 800ecd8: b2db         	uxtb	r3, r3
 800ecda: 2b00         	cmp	r3, #0x0
 800ecdc: d10e         	bne	0x800ecfc <spi_stm32_configure+0xd0> @ imm = #0x1c
 800ecde: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x800ee80 <spi_stm32_configure+0x254>
 800ece0: 6819         	ldr	r1, [r3]
 800ece2: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x800ee84 <spi_stm32_configure+0x258>
 800ece4: 9302         	str	r3, [sp, #0x8]
 800ece6: 2300         	movs	r3, #0x0
 800ece8: 9301         	str	r3, [sp, #0x4]
 800ecea: 2300         	movs	r3, #0x0
 800ecec: 9300         	str	r3, [sp]
 800ecee: 2300         	movs	r3, #0x0
 800ecf0: 2201         	movs	r2, #0x1
 800ecf2: 2000         	movs	r0, #0x0
 800ecf4: f013 feab    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x13d56
 800ecf8: 2300         	movs	r3, #0x0
 800ecfa: 657b         	str	r3, [r7, #0x54]
; 			return -EIO;
 800ecfc: f06f 0304    	mvn	r3, #0x4
 800ed00: e10d         	b	0x800ef1e <spi_stm32_configure+0x2f2> @ imm = #0x21a
; 	for (br = 1; br <= ARRAY_SIZE(scaler); ++br) {
 800ed02: 2301         	movs	r3, #0x1
 800ed04: 643b         	str	r3, [r7, #0x40]
 800ed06: e00c         	b	0x800ed22 <spi_stm32_configure+0xf6> @ imm = #0x18
; 		uint32_t clk = clock >> br;
 800ed08: 68fa         	ldr	r2, [r7, #0xc]
 800ed0a: 6c3b         	ldr	r3, [r7, #0x40]
 800ed0c: fa22 f303    	lsr.w	r3, r2, r3
 800ed10: 63fb         	str	r3, [r7, #0x3c]
; 		if (clk <= config->frequency) {
 800ed12: 683b         	ldr	r3, [r7]
 800ed14: 681b         	ldr	r3, [r3]
 800ed16: 6bfa         	ldr	r2, [r7, #0x3c]
 800ed18: 429a         	cmp	r2, r3
 800ed1a: d906         	bls	0x800ed2a <spi_stm32_configure+0xfe> @ imm = #0xc
; 	for (br = 1; br <= ARRAY_SIZE(scaler); ++br) {
 800ed1c: 6c3b         	ldr	r3, [r7, #0x40]
 800ed1e: 3301         	adds	r3, #0x1
 800ed20: 643b         	str	r3, [r7, #0x40]
 800ed22: 6c3b         	ldr	r3, [r7, #0x40]
 800ed24: 2b08         	cmp	r3, #0x8
 800ed26: d9ef         	bls	0x800ed08 <spi_stm32_configure+0xdc> @ imm = #-0x22
 800ed28: e000         	b	0x800ed2c <spi_stm32_configure+0x100> @ imm = #0x0
; 			break;
 800ed2a: bf00         	nop
; 	if (br > ARRAY_SIZE(scaler)) {
 800ed2c: 6c3b         	ldr	r3, [r7, #0x40]
 800ed2e: 2b08         	cmp	r3, #0x8
 800ed30: d928         	bls	0x800ed84 <spi_stm32_configure+0x158> @ imm = #0x50
; 		LOG_ERR("Unsupported frequency %uHz, max %uHz, min %uHz", config->frequency,
 800ed32: 2303         	movs	r3, #0x3
 800ed34: 2b00         	cmp	r3, #0x0
 800ed36: d022         	beq	0x800ed7e <spi_stm32_configure+0x152> @ imm = #0x44
 800ed38: 2301         	movs	r3, #0x1
 800ed3a: f887 304b    	strb.w	r3, [r7, #0x4b]
 800ed3e: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 800ed42: f083 0301    	eor	r3, r3, #0x1
 800ed46: b2db         	uxtb	r3, r3
 800ed48: 2b00         	cmp	r3, #0x0
 800ed4a: d118         	bne	0x800ed7e <spi_stm32_configure+0x152> @ imm = #0x30
 800ed4c: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x800ee80 <spi_stm32_configure+0x254>
 800ed4e: 6818         	ldr	r0, [r3]
 800ed50: 683b         	ldr	r3, [r7]
 800ed52: 681b         	ldr	r3, [r3]
 800ed54: 68fa         	ldr	r2, [r7, #0xc]
 800ed56: 0852         	lsrs	r2, r2, #0x1
 800ed58: 68f9         	ldr	r1, [r7, #0xc]
 800ed5a: 0a09         	lsrs	r1, r1, #0x8
 800ed5c: 9105         	str	r1, [sp, #0x14]
 800ed5e: 9204         	str	r2, [sp, #0x10]
 800ed60: 9303         	str	r3, [sp, #0xc]
 800ed62: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800ee88 <spi_stm32_configure+0x25c>
 800ed64: 9302         	str	r3, [sp, #0x8]
 800ed66: 2300         	movs	r3, #0x0
 800ed68: 9301         	str	r3, [sp, #0x4]
 800ed6a: 2300         	movs	r3, #0x0
 800ed6c: 9300         	str	r3, [sp]
 800ed6e: 2300         	movs	r3, #0x0
 800ed70: 2201         	movs	r2, #0x1
 800ed72: 4601         	mov	r1, r0
 800ed74: 2000         	movs	r0, #0x0
 800ed76: f013 fe6a    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x13cd4
 800ed7a: 2300         	movs	r3, #0x0
 800ed7c: 647b         	str	r3, [r7, #0x44]
; 		return -EINVAL;
 800ed7e: f06f 0315    	mvn	r3, #0x15
 800ed82: e0cc         	b	0x800ef1e <spi_stm32_configure+0x2f2> @ imm = #0x198
; 	LL_SPI_Disable(spi);
 800ed84: 6b38         	ldr	r0, [r7, #0x30]
 800ed86: f013 fece    	bl	0x8022b26 <LL_SPI_Disable> @ imm = #0x13d9c
; 	LL_SPI_SetBaudRatePrescaler(spi, scaler[br - 1]);
 800ed8a: 6c3b         	ldr	r3, [r7, #0x40]
 800ed8c: 3b01         	subs	r3, #0x1
 800ed8e: 009b         	lsls	r3, r3, #0x2
 800ed90: 3358         	adds	r3, #0x58
 800ed92: 443b         	add	r3, r7
 800ed94: f853 3c48    	ldr	r3, [r3, #-72]
 800ed98: 4619         	mov	r1, r3
 800ed9a: 6b38         	ldr	r0, [r7, #0x30]
 800ed9c: f013 ff40    	bl	0x8022c20 <LL_SPI_SetBaudRatePrescaler> @ imm = #0x13e80
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPOL) {
 800eda0: 683b         	ldr	r3, [r7]
 800eda2: 889b         	ldrh	r3, [r3, #0x4]
 800eda4: f003 0302    	and	r3, r3, #0x2
 800eda8: 2b00         	cmp	r3, #0x0
 800edaa: d004         	beq	0x800edb6 <spi_stm32_configure+0x18a> @ imm = #0x8
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_HIGH);
 800edac: 2102         	movs	r1, #0x2
 800edae: 6b38         	ldr	r0, [r7, #0x30]
 800edb0: f013 ff23    	bl	0x8022bfa <LL_SPI_SetClockPolarity> @ imm = #0x13e46
 800edb4: e003         	b	0x800edbe <spi_stm32_configure+0x192> @ imm = #0x6
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_LOW);
 800edb6: 2100         	movs	r1, #0x0
 800edb8: 6b38         	ldr	r0, [r7, #0x30]
 800edba: f013 ff1e    	bl	0x8022bfa <LL_SPI_SetClockPolarity> @ imm = #0x13e3c
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPHA) {
 800edbe: 683b         	ldr	r3, [r7]
 800edc0: 889b         	ldrh	r3, [r3, #0x4]
 800edc2: f003 0304    	and	r3, r3, #0x4
 800edc6: 2b00         	cmp	r3, #0x0
 800edc8: d004         	beq	0x800edd4 <spi_stm32_configure+0x1a8> @ imm = #0x8
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_2EDGE);
 800edca: 2101         	movs	r1, #0x1
 800edcc: 6b38         	ldr	r0, [r7, #0x30]
 800edce: f013 ff01    	bl	0x8022bd4 <LL_SPI_SetClockPhase> @ imm = #0x13e02
 800edd2: e003         	b	0x800eddc <spi_stm32_configure+0x1b0> @ imm = #0x6
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_1EDGE);
 800edd4: 2100         	movs	r1, #0x0
 800edd6: 6b38         	ldr	r0, [r7, #0x30]
 800edd8: f013 fefc    	bl	0x8022bd4 <LL_SPI_SetClockPhase> @ imm = #0x13df8
; 	LL_SPI_SetTransferDirection(spi, LL_SPI_FULL_DUPLEX);
 800eddc: 2100         	movs	r1, #0x0
 800edde: 6b38         	ldr	r0, [r7, #0x30]
 800ede0: f013 ff44    	bl	0x8022c6c <LL_SPI_SetTransferDirection> @ imm = #0x13e88
; 	if (config->operation & SPI_TRANSFER_LSB) {
 800ede4: 683b         	ldr	r3, [r7]
 800ede6: 889b         	ldrh	r3, [r3, #0x4]
 800ede8: f003 0310    	and	r3, r3, #0x10
 800edec: 2b00         	cmp	r3, #0x0
 800edee: d004         	beq	0x800edfa <spi_stm32_configure+0x1ce> @ imm = #0x8
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_LSB_FIRST);
 800edf0: 2180         	movs	r1, #0x80
 800edf2: 6b38         	ldr	r0, [r7, #0x30]
 800edf4: f013 ff27    	bl	0x8022c46 <LL_SPI_SetTransferBitOrder> @ imm = #0x13e4e
 800edf8: e003         	b	0x800ee02 <spi_stm32_configure+0x1d6> @ imm = #0x6
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_MSB_FIRST);
 800edfa: 2100         	movs	r1, #0x0
 800edfc: 6b38         	ldr	r0, [r7, #0x30]
 800edfe: f013 ff22    	bl	0x8022c46 <LL_SPI_SetTransferBitOrder> @ imm = #0x13e44
; 	LL_SPI_DisableCRC(spi);
 800ee02: 6b38         	ldr	r0, [r7, #0x30]
 800ee04: f013 ff58    	bl	0x8022cb8 <LL_SPI_DisableCRC> @ imm = #0x13eb0
; 	if (spi_cs_is_gpio(config) || !IS_ENABLED(CONFIG_SPI_STM32_USE_HW_SS)) {
 800ee08: 6838         	ldr	r0, [r7]
 800ee0a: f014 f967    	bl	0x80230dc <spi_cs_is_gpio> @ imm = #0x142ce
 800ee0e: 4603         	mov	r3, r0
 800ee10: 2b00         	cmp	r3, #0x0
 800ee12: d005         	beq	0x800ee20 <spi_stm32_configure+0x1f4> @ imm = #0xa
; 		LL_SPI_SetNSSMode(spi, LL_SPI_NSS_SOFT);
 800ee14: f44f 7100    	mov.w	r1, #0x200
 800ee18: 6b38         	ldr	r0, [r7, #0x30]
 800ee1a: f013 ff5d    	bl	0x8022cd8 <LL_SPI_SetNSSMode> @ imm = #0x13eba
 800ee1e: e00f         	b	0x800ee40 <spi_stm32_configure+0x214> @ imm = #0x1e
; 		if (config->operation & SPI_OP_MODE_SLAVE) {
 800ee20: 683b         	ldr	r3, [r7]
 800ee22: 889b         	ldrh	r3, [r3, #0x4]
 800ee24: f003 0301    	and	r3, r3, #0x1
 800ee28: 2b00         	cmp	r3, #0x0
 800ee2a: d004         	beq	0x800ee36 <spi_stm32_configure+0x20a> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_INPUT);
 800ee2c: 2100         	movs	r1, #0x0
 800ee2e: 6b38         	ldr	r0, [r7, #0x30]
 800ee30: f013 ff52    	bl	0x8022cd8 <LL_SPI_SetNSSMode> @ imm = #0x13ea4
 800ee34: e004         	b	0x800ee40 <spi_stm32_configure+0x214> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_OUTPUT);
 800ee36: f44f 2180    	mov.w	r1, #0x40000
 800ee3a: 6b38         	ldr	r0, [r7, #0x30]
 800ee3c: f013 ff4c    	bl	0x8022cd8 <LL_SPI_SetNSSMode> @ imm = #0x13e98
; 	if (config->operation & SPI_OP_MODE_SLAVE) {
 800ee40: 683b         	ldr	r3, [r7]
 800ee42: 889b         	ldrh	r3, [r3, #0x4]
 800ee44: f003 0301    	and	r3, r3, #0x1
 800ee48: 2b00         	cmp	r3, #0x0
 800ee4a: d004         	beq	0x800ee56 <spi_stm32_configure+0x22a> @ imm = #0x8
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_SLAVE);
 800ee4c: 2100         	movs	r1, #0x0
 800ee4e: 6b38         	ldr	r0, [r7, #0x30]
 800ee50: f013 fe8c    	bl	0x8022b6c <LL_SPI_SetMode> @ imm = #0x13d18
 800ee54: e004         	b	0x800ee60 <spi_stm32_configure+0x234> @ imm = #0x8
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_MASTER);
 800ee56: f44f 7182    	mov.w	r1, #0x104
 800ee5a: 6b38         	ldr	r0, [r7, #0x30]
 800ee5c: f013 fe86    	bl	0x8022b6c <LL_SPI_SetMode> @ imm = #0x13d0c
; 	if (SPI_WORD_SIZE_GET(config->operation) == 8) {
 800ee60: 683b         	ldr	r3, [r7]
 800ee62: 889b         	ldrh	r3, [r3, #0x4]
 800ee64: 095b         	lsrs	r3, r3, #0x5
 800ee66: f003 033f    	and	r3, r3, #0x3f
 800ee6a: 2b08         	cmp	r3, #0x8
 800ee6c: d10e         	bne	0x800ee8c <spi_stm32_configure+0x260> @ imm = #0x1c
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_8BIT);
 800ee6e: 2100         	movs	r1, #0x0
 800ee70: 6b38         	ldr	r0, [r7, #0x30]
 800ee72: f013 ff0e    	bl	0x8022c92 <LL_SPI_SetDataWidth> @ imm = #0x13e1c
 800ee76: e00e         	b	0x800ee96 <spi_stm32_configure+0x26a> @ imm = #0x1c

0800ee78 <$d>:
 800ee78: 58 9d 02 08  	.word	0x08029d58
 800ee7c: 48 7a 02 08  	.word	0x08027a48
 800ee80: 6c 05 00 20  	.word	0x2000056c
 800ee84: b4 9c 02 08  	.word	0x08029cb4
 800ee88: e0 9c 02 08  	.word	0x08029ce0

0800ee8c <$t>:
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_16BIT);
 800ee8c: f44f 6100    	mov.w	r1, #0x800
 800ee90: 6b38         	ldr	r0, [r7, #0x30]
 800ee92: f013 fefe    	bl	0x8022c92 <LL_SPI_SetDataWidth> @ imm = #0x13dfc
; 	data->ctx.config = config;
 800ee96: 6b7b         	ldr	r3, [r7, #0x34]
 800ee98: 683a         	ldr	r2, [r7]
 800ee9a: 601a         	str	r2, [r3]
; 	LOG_DBG("Installed config %p: freq %uHz (div = %u),"
 800ee9c: 2303         	movs	r3, #0x3
 800ee9e: 2b03         	cmp	r3, #0x3
 800eea0: d93c         	bls	0x800ef1c <spi_stm32_configure+0x2f0> @ imm = #0x78
 800eea2: 2301         	movs	r3, #0x1
 800eea4: f887 3052    	strb.w	r3, [r7, #0x52]
 800eea8: f897 3052    	ldrb.w	r3, [r7, #0x52]
 800eeac: f083 0301    	eor	r3, r3, #0x1
 800eeb0: b2db         	uxtb	r3, r3
 800eeb2: 2b00         	cmp	r3, #0x0
 800eeb4: d132         	bne	0x800ef1c <spi_stm32_configure+0x2f0> @ imm = #0x64
 800eeb6: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800ef28 <spi_stm32_configure+0x2fc>
 800eeb8: 681e         	ldr	r6, [r3]
 800eeba: 68fa         	ldr	r2, [r7, #0xc]
 800eebc: 6c3b         	ldr	r3, [r7, #0x40]
 800eebe: fa22 f303    	lsr.w	r3, r2, r3
 800eec2: 2101         	movs	r1, #0x1
 800eec4: 6c3a         	ldr	r2, [r7, #0x40]
 800eec6: fa01 f202    	lsl.w	r2, r1, r2
 800eeca: 6839         	ldr	r1, [r7]
 800eecc: 8889         	ldrh	r1, [r1, #0x4]
 800eece: 0849         	lsrs	r1, r1, #0x1
 800eed0: f001 0101    	and	r1, r1, #0x1
 800eed4: 6838         	ldr	r0, [r7]
 800eed6: 8880         	ldrh	r0, [r0, #0x4]
 800eed8: 0880         	lsrs	r0, r0, #0x2
 800eeda: f000 0001    	and	r0, r0, #0x1
 800eede: 683c         	ldr	r4, [r7]
 800eee0: 88a4         	ldrh	r4, [r4, #0x4]
 800eee2: 08e4         	lsrs	r4, r4, #0x3
 800eee4: f004 0401    	and	r4, r4, #0x1
 800eee8: 683d         	ldr	r5, [r7]
 800eeea: 88ed         	ldrh	r5, [r5, #0x6]
 800eeec: 950a         	str	r5, [sp, #0x28]
 800eeee: 9409         	str	r4, [sp, #0x24]
 800eef0: 9008         	str	r0, [sp, #0x20]
 800eef2: 9107         	str	r1, [sp, #0x1c]
 800eef4: 9206         	str	r2, [sp, #0x18]
 800eef6: 9305         	str	r3, [sp, #0x14]
 800eef8: 683b         	ldr	r3, [r7]
 800eefa: 9304         	str	r3, [sp, #0x10]
 800eefc: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ef2c <spi_stm32_configure+0x300>
 800eefe: 9303         	str	r3, [sp, #0xc]
 800ef00: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ef30 <spi_stm32_configure+0x304>
 800ef02: 9302         	str	r3, [sp, #0x8]
 800ef04: 2308         	movs	r3, #0x8
 800ef06: 9301         	str	r3, [sp, #0x4]
 800ef08: 2300         	movs	r3, #0x0
 800ef0a: 9300         	str	r3, [sp]
 800ef0c: 2300         	movs	r3, #0x0
 800ef0e: 2204         	movs	r2, #0x4
 800ef10: 4631         	mov	r1, r6
 800ef12: 2000         	movs	r0, #0x0
 800ef14: f013 fd9b    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x13b36
 800ef18: 2300         	movs	r3, #0x0
 800ef1a: 64fb         	str	r3, [r7, #0x4c]
; 	return 0;
 800ef1c: 2300         	movs	r3, #0x0
; }
 800ef1e: 4618         	mov	r0, r3
 800ef20: 375c         	adds	r7, #0x5c
 800ef22: 46bd         	mov	sp, r7
 800ef24: bdf0         	pop	{r4, r5, r6, r7, pc}
 800ef26: bf00         	nop

0800ef28 <$d>:
 800ef28: 6c 05 00 20  	.word	0x2000056c
 800ef2c: a4 b0 02 08  	.word	0x0802b0a4
 800ef30: 10 9d 02 08  	.word	0x08029d10

0800ef34 <spi_stm32_init>:
; {
 800ef34: b580         	push	{r7, lr}
 800ef36: b090         	sub	sp, #0x40
 800ef38: af04         	add	r7, sp, #0x10
 800ef3a: 6078         	str	r0, [r7, #0x4]
; 	struct spi_stm32_data *data __attribute__((unused)) = dev->data;
 800ef3c: 687b         	ldr	r3, [r7, #0x4]
 800ef3e: 691b         	ldr	r3, [r3, #0x10]
 800ef40: 627b         	str	r3, [r7, #0x24]
; 	const struct spi_stm32_config *cfg = dev->config;
 800ef42: 687b         	ldr	r3, [r7, #0x4]
 800ef44: 685b         	ldr	r3, [r3, #0x4]
 800ef46: 62bb         	str	r3, [r7, #0x28]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 800ef48: 484a         	ldr	r0, [pc, #0x128]        @ 0x800f074 <spi_stm32_init+0x140>
 800ef4a: f013 fd74    	bl	0x8022a36 <device_is_ready> @ imm = #0x13ae8
 800ef4e: 4603         	mov	r3, r0
 800ef50: f083 0301    	eor	r3, r3, #0x1
 800ef54: b2db         	uxtb	r3, r3
 800ef56: 2b00         	cmp	r3, #0x0
 800ef58: d01c         	beq	0x800ef94 <spi_stm32_init+0x60> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800ef5a: 2303         	movs	r3, #0x3
 800ef5c: 2b00         	cmp	r3, #0x0
 800ef5e: d016         	beq	0x800ef8e <spi_stm32_init+0x5a> @ imm = #0x2c
 800ef60: 2301         	movs	r3, #0x1
 800ef62: 74fb         	strb	r3, [r7, #0x13]
 800ef64: 7cfb         	ldrb	r3, [r7, #0x13]
 800ef66: f083 0301    	eor	r3, r3, #0x1
 800ef6a: b2db         	uxtb	r3, r3
 800ef6c: 2b00         	cmp	r3, #0x0
 800ef6e: d10e         	bne	0x800ef8e <spi_stm32_init+0x5a> @ imm = #0x1c
 800ef70: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800f078 <spi_stm32_init+0x144>
 800ef72: 6819         	ldr	r1, [r3]
 800ef74: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800f07c <spi_stm32_init+0x148>
 800ef76: 9302         	str	r3, [sp, #0x8]
 800ef78: 2300         	movs	r3, #0x0
 800ef7a: 9301         	str	r3, [sp, #0x4]
 800ef7c: 2300         	movs	r3, #0x0
 800ef7e: 9300         	str	r3, [sp]
 800ef80: 2300         	movs	r3, #0x0
 800ef82: 2201         	movs	r2, #0x1
 800ef84: 2000         	movs	r0, #0x0
 800ef86: f013 fd62    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x13ac4
 800ef8a: 2300         	movs	r3, #0x0
 800ef8c: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800ef8e: f06f 0312    	mvn	r3, #0x12
 800ef92: e06a         	b	0x800f06a <spi_stm32_init+0x136> @ imm = #0xd4
; 			       (clock_control_subsys_t)&cfg->pclken[0]);
 800ef94: 6abb         	ldr	r3, [r7, #0x28]
 800ef96: 68db         	ldr	r3, [r3, #0xc]
; 	err = clock_control_on(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 800ef98: 4619         	mov	r1, r3
 800ef9a: 4836         	ldr	r0, [pc, #0xd8]         @ 0x800f074 <spi_stm32_init+0x140>
 800ef9c: f014 f8eb    	bl	0x8023176 <clock_control_on> @ imm = #0x141d6
 800efa0: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 800efa2: 6afb         	ldr	r3, [r7, #0x2c]
 800efa4: 2b00         	cmp	r3, #0x0
 800efa6: da1b         	bge	0x800efe0 <spi_stm32_init+0xac> @ imm = #0x36
; 		LOG_ERR("Could not enable SPI clock");
 800efa8: 2303         	movs	r3, #0x3
 800efaa: 2b00         	cmp	r3, #0x0
 800efac: d016         	beq	0x800efdc <spi_stm32_init+0xa8> @ imm = #0x2c
 800efae: 2301         	movs	r3, #0x1
 800efb0: 76fb         	strb	r3, [r7, #0x1b]
 800efb2: 7efb         	ldrb	r3, [r7, #0x1b]
 800efb4: f083 0301    	eor	r3, r3, #0x1
 800efb8: b2db         	uxtb	r3, r3
 800efba: 2b00         	cmp	r3, #0x0
 800efbc: d10e         	bne	0x800efdc <spi_stm32_init+0xa8> @ imm = #0x1c
 800efbe: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x800f078 <spi_stm32_init+0x144>
 800efc0: 6819         	ldr	r1, [r3]
 800efc2: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800f080 <spi_stm32_init+0x14c>
 800efc4: 9302         	str	r3, [sp, #0x8]
 800efc6: 2300         	movs	r3, #0x0
 800efc8: 9301         	str	r3, [sp, #0x4]
 800efca: 2300         	movs	r3, #0x0
 800efcc: 9300         	str	r3, [sp]
 800efce: 2300         	movs	r3, #0x0
 800efd0: 2201         	movs	r2, #0x1
 800efd2: 2000         	movs	r0, #0x0
 800efd4: f013 fd3b    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x13a76
 800efd8: 2300         	movs	r3, #0x0
 800efda: 617b         	str	r3, [r7, #0x14]
; 		return err;
 800efdc: 6afb         	ldr	r3, [r7, #0x2c]
 800efde: e044         	b	0x800f06a <spi_stm32_init+0x136> @ imm = #0x88
; 	if (!spi_stm32_is_subghzspi(dev)) {
 800efe0: 6878         	ldr	r0, [r7, #0x4]
 800efe2: f014 fbc8    	bl	0x8023776 <spi_stm32_is_subghzspi> @ imm = #0x14790
 800efe6: 4603         	mov	r3, r0
 800efe8: f083 0301    	eor	r3, r3, #0x1
 800efec: b2db         	uxtb	r3, r3
 800efee: 2b00         	cmp	r3, #0x0
 800eff0: d029         	beq	0x800f046 <spi_stm32_init+0x112> @ imm = #0x52
; 		err = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
 800eff2: 6abb         	ldr	r3, [r7, #0x28]
 800eff4: 685b         	ldr	r3, [r3, #0x4]
 800eff6: 2100         	movs	r1, #0x0
 800eff8: 4618         	mov	r0, r3
 800effa: f014 f894    	bl	0x8023126 <pinctrl_apply_state> @ imm = #0x14128
 800effe: 62f8         	str	r0, [r7, #0x2c]
; 		if (err < 0) {
 800f000: 6afb         	ldr	r3, [r7, #0x2c]
 800f002: 2b00         	cmp	r3, #0x0
 800f004: da1f         	bge	0x800f046 <spi_stm32_init+0x112> @ imm = #0x3e
; 			LOG_ERR("SPI pinctrl setup failed (%d)", err);
 800f006: 2303         	movs	r3, #0x3
 800f008: 2b00         	cmp	r3, #0x0
 800f00a: d01a         	beq	0x800f042 <spi_stm32_init+0x10e> @ imm = #0x34
 800f00c: 2301         	movs	r3, #0x1
 800f00e: f887 3023    	strb.w	r3, [r7, #0x23]
 800f012: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800f016: f083 0301    	eor	r3, r3, #0x1
 800f01a: b2db         	uxtb	r3, r3
 800f01c: 2b00         	cmp	r3, #0x0
 800f01e: d110         	bne	0x800f042 <spi_stm32_init+0x10e> @ imm = #0x20
 800f020: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800f078 <spi_stm32_init+0x144>
 800f022: 6819         	ldr	r1, [r3]
 800f024: 6afb         	ldr	r3, [r7, #0x2c]
 800f026: 9303         	str	r3, [sp, #0xc]
 800f028: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800f084 <spi_stm32_init+0x150>
 800f02a: 9302         	str	r3, [sp, #0x8]
 800f02c: 2300         	movs	r3, #0x0
 800f02e: 9301         	str	r3, [sp, #0x4]
 800f030: 2300         	movs	r3, #0x0
 800f032: 9300         	str	r3, [sp]
 800f034: 2300         	movs	r3, #0x0
 800f036: 2201         	movs	r2, #0x1
 800f038: 2000         	movs	r0, #0x0
 800f03a: f013 fd08    	bl	0x8022a4e <z_log_msg_runtime_create> @ imm = #0x13a10
 800f03e: 2300         	movs	r3, #0x0
 800f040: 61fb         	str	r3, [r7, #0x1c]
; 			return err;
 800f042: 6afb         	ldr	r3, [r7, #0x2c]
 800f044: e011         	b	0x800f06a <spi_stm32_init+0x136> @ imm = #0x22
; 	err = spi_context_cs_configure_all(&data->ctx);
 800f046: 6a7b         	ldr	r3, [r7, #0x24]
 800f048: 4618         	mov	r0, r3
 800f04a: f7fe ff07    	bl	0x800de5c <spi_context_cs_configure_all> @ imm = #-0x11f2
 800f04e: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 800f050: 6afb         	ldr	r3, [r7, #0x2c]
 800f052: 2b00         	cmp	r3, #0x0
 800f054: da01         	bge	0x800f05a <spi_stm32_init+0x126> @ imm = #0x2
; 		return err;
 800f056: 6afb         	ldr	r3, [r7, #0x2c]
 800f058: e007         	b	0x800f06a <spi_stm32_init+0x136> @ imm = #0xe
; 	spi_context_unlock_unconditionally(&data->ctx);
 800f05a: 6a7b         	ldr	r3, [r7, #0x24]
 800f05c: 4618         	mov	r0, r3
 800f05e: f014 f962    	bl	0x8023326 <spi_context_unlock_unconditionally> @ imm = #0x142c4
; 	return pm_device_runtime_enable(dev);
 800f062: 6878         	ldr	r0, [r7, #0x4]
 800f064: f014 f87c    	bl	0x8023160 <pm_device_runtime_enable> @ imm = #0x140f8
 800f068: 4603         	mov	r3, r0
; }
 800f06a: 4618         	mov	r0, r3
 800f06c: 3730         	adds	r7, #0x30
 800f06e: 46bd         	mov	sp, r7
 800f070: bd80         	pop	{r7, pc}
 800f072: bf00         	nop

0800f074 <$d>:
 800f074: 48 7a 02 08  	.word	0x08027a48
 800f078: 6c 05 00 20  	.word	0x2000056c
 800f07c: 78 9d 02 08  	.word	0x08029d78
 800f080: 98 9d 02 08  	.word	0x08029d98
 800f084: b4 9d 02 08  	.word	0x08029db4

0800f088 <__NVIC_SetPriority>:
; {
 800f088: b480         	push	{r7}
 800f08a: b083         	sub	sp, #0xc
 800f08c: af00         	add	r7, sp, #0x0
 800f08e: 4603         	mov	r3, r0
 800f090: 6039         	str	r1, [r7]
 800f092: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 800f094: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800f098: 2b00         	cmp	r3, #0x0
 800f09a: db0a         	blt	0x800f0b2 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f09c: 683b         	ldr	r3, [r7]
 800f09e: b2da         	uxtb	r2, r3
 800f0a0: 490c         	ldr	r1, [pc, #0x30]         @ 0x800f0d4 <__NVIC_SetPriority+0x4c>
 800f0a2: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800f0a6: 0112         	lsls	r2, r2, #0x4
 800f0a8: b2d2         	uxtb	r2, r2
 800f0aa: 440b         	add	r3, r1
 800f0ac: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 800f0b0: e00a         	b	0x800f0c8 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f0b2: 683b         	ldr	r3, [r7]
 800f0b4: b2da         	uxtb	r2, r3
 800f0b6: 4908         	ldr	r1, [pc, #0x20]         @ 0x800f0d8 <__NVIC_SetPriority+0x50>
 800f0b8: 79fb         	ldrb	r3, [r7, #0x7]
 800f0ba: f003 030f    	and	r3, r3, #0xf
 800f0be: 3b04         	subs	r3, #0x4
 800f0c0: 0112         	lsls	r2, r2, #0x4
 800f0c2: b2d2         	uxtb	r2, r2
 800f0c4: 440b         	add	r3, r1
 800f0c6: 761a         	strb	r2, [r3, #0x18]
; }
 800f0c8: bf00         	nop
 800f0ca: 370c         	adds	r7, #0xc
 800f0cc: 46bd         	mov	sp, r7
 800f0ce: f85d 7b04    	ldr	r7, [sp], #4
 800f0d2: 4770         	bx	lr

0800f0d4 <$d>:
 800f0d4: 00 e1 00 e0  	.word	0xe000e100
 800f0d8: 00 ed 00 e0  	.word	0xe000ed00

0800f0dc <elapsed>:
; {
 800f0dc: b480         	push	{r7}
 800f0de: b085         	sub	sp, #0x14
 800f0e0: af00         	add	r7, sp, #0x0
; 	uint32_t val1 = SysTick->VAL;	/* A */
 800f0e2: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800f14c <elapsed+0x70>
 800f0e4: 689b         	ldr	r3, [r3, #0x8]
 800f0e6: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ctrl = SysTick->CTRL;	/* B */
 800f0e8: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800f14c <elapsed+0x70>
 800f0ea: 681b         	ldr	r3, [r3]
 800f0ec: 607b         	str	r3, [r7, #0x4]
; 	uint32_t val2 = SysTick->VAL;	/* C */
 800f0ee: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800f14c <elapsed+0x70>
 800f0f0: 689b         	ldr	r3, [r3, #0x8]
 800f0f2: 60bb         	str	r3, [r7, #0x8]
; 	if (val1 == 0) {
 800f0f4: 68fb         	ldr	r3, [r7, #0xc]
 800f0f6: 2b00         	cmp	r3, #0x0
 800f0f8: d102         	bne	0x800f100 <elapsed+0x24> @ imm = #0x4
; 		val1 = last_load;
 800f0fa: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800f150 <elapsed+0x74>
 800f0fc: 681b         	ldr	r3, [r3]
 800f0fe: 60fb         	str	r3, [r7, #0xc]
; 	if (val2 == 0) {
 800f100: 68bb         	ldr	r3, [r7, #0x8]
 800f102: 2b00         	cmp	r3, #0x0
 800f104: d102         	bne	0x800f10c <elapsed+0x30> @ imm = #0x4
; 		val2 = last_load;
 800f106: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800f150 <elapsed+0x74>
 800f108: 681b         	ldr	r3, [r3]
 800f10a: 60bb         	str	r3, [r7, #0x8]
; 	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
 800f10c: 687b         	ldr	r3, [r7, #0x4]
 800f10e: f403 3380    	and	r3, r3, #0x10000
 800f112: 2b00         	cmp	r3, #0x0
 800f114: d103         	bne	0x800f11e <elapsed+0x42> @ imm = #0x6
; 	    || (val1 < val2)) {
 800f116: 68fa         	ldr	r2, [r7, #0xc]
 800f118: 68bb         	ldr	r3, [r7, #0x8]
 800f11a: 429a         	cmp	r2, r3
 800f11c: d208         	bhs	0x800f130 <elapsed+0x54> @ imm = #0x10
; 		overflow_cyc += last_load;
 800f11e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800f154 <elapsed+0x78>
 800f120: 681a         	ldr	r2, [r3]
 800f122: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800f150 <elapsed+0x74>
 800f124: 681b         	ldr	r3, [r3]
 800f126: 4413         	add	r3, r2
 800f128: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800f154 <elapsed+0x78>
 800f12a: 6013         	str	r3, [r2]
; 		(void)SysTick->CTRL;
 800f12c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800f14c <elapsed+0x70>
 800f12e: 681b         	ldr	r3, [r3]
; 	return (last_load - val2) + overflow_cyc;
 800f130: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800f150 <elapsed+0x74>
 800f132: 681a         	ldr	r2, [r3]
 800f134: 68bb         	ldr	r3, [r7, #0x8]
 800f136: 1ad2         	subs	r2, r2, r3
 800f138: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800f154 <elapsed+0x78>
 800f13a: 681b         	ldr	r3, [r3]
 800f13c: 4413         	add	r3, r2
; }
 800f13e: 4618         	mov	r0, r3
 800f140: 3714         	adds	r7, #0x14
 800f142: 46bd         	mov	sp, r7
 800f144: f85d 7b04    	ldr	r7, [sp], #4
 800f148: 4770         	bx	lr
 800f14a: bf00         	nop

0800f14c <$d>:
 800f14c: 10 e0 00 e0  	.word	0xe000e010
 800f150: 4c 32 00 20  	.word	0x2000324c
 800f154: 50 32 00 20  	.word	0x20003250

0800f158 <sys_clock_isr>:
; {
 800f158: 4668         	mov	r0, sp
 800f15a: f020 0107    	bic	r1, r0, #0x7
 800f15e: 468d         	mov	sp, r1
 800f160: e92d 4fb1    	push.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 800f164: b085         	sub	sp, #0x14
 800f166: af00         	add	r7, sp, #0x0
; 	elapsed();
 800f168: f7ff ffb8    	bl	0x800f0dc <elapsed>     @ imm = #-0x90
; 	cycle_count += overflow_cyc;
 800f16c: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800f1f8 <sys_clock_isr+0xa0>
 800f16e: 681b         	ldr	r3, [r3]
 800f170: 2200         	movs	r2, #0x0
 800f172: 4698         	mov	r8, r3
 800f174: 4691         	mov	r9, r2
 800f176: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800f1fc <sys_clock_isr+0xa4>
 800f178: e9d3 2300    	ldrd	r2, r3, [r3]
 800f17c: eb18 0102    	adds.w	r1, r8, r2
 800f180: 6039         	str	r1, [r7]
 800f182: eb49 0303    	adc.w	r3, r9, r3
 800f186: 607b         	str	r3, [r7, #0x4]
 800f188: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800f1fc <sys_clock_isr+0xa4>
 800f18a: e9d7 1200    	ldrd	r1, r2, [r7]
 800f18e: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0;
 800f192: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800f1f8 <sys_clock_isr+0xa0>
 800f194: 2200         	movs	r2, #0x0
 800f196: 601a         	str	r2, [r3]
; 		dcycles = cycle_count - announced_cycles;
 800f198: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800f1fc <sys_clock_isr+0xa4>
 800f19a: e9d3 2300    	ldrd	r2, r3, [r3]
 800f19e: 4611         	mov	r1, r2
 800f1a0: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800f200 <sys_clock_isr+0xa8>
 800f1a2: e9d3 2300    	ldrd	r2, r3, [r3]
 800f1a6: 4613         	mov	r3, r2
 800f1a8: 1acb         	subs	r3, r1, r3
 800f1aa: 60fb         	str	r3, [r7, #0xc]
; 		dticks = dcycles / CYC_PER_TICK;
 800f1ac: 68fb         	ldr	r3, [r7, #0xc]
 800f1ae: 4a15         	ldr	r2, [pc, #0x54]         @ 0x800f204 <sys_clock_isr+0xac>
 800f1b0: fba2 2303    	umull	r2, r3, r2, r3
 800f1b4: 0b9b         	lsrs	r3, r3, #0xe
 800f1b6: 60bb         	str	r3, [r7, #0x8]
; 		announced_cycles += dticks * CYC_PER_TICK;
 800f1b8: 68bb         	ldr	r3, [r7, #0x8]
 800f1ba: f244 12a0    	movw	r2, #0x41a0
 800f1be: fb02 f303    	mul	r3, r2, r3
 800f1c2: 2200         	movs	r2, #0x0
 800f1c4: 461c         	mov	r4, r3
 800f1c6: 4615         	mov	r5, r2
 800f1c8: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800f200 <sys_clock_isr+0xa8>
 800f1ca: e9d3 2300    	ldrd	r2, r3, [r3]
 800f1ce: eb14 0a02    	adds.w	r10, r4, r2
 800f1d2: eb45 0b03    	adc.w	r11, r5, r3
 800f1d6: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800f200 <sys_clock_isr+0xa8>
 800f1d8: e9c3 ab00    	strd	r10, r11, [r3]
; 		sys_clock_announce(dticks);
 800f1dc: 68bb         	ldr	r3, [r7, #0x8]
 800f1de: 4618         	mov	r0, r3
 800f1e0: f007 fe5e    	bl	0x8016ea0 <sys_clock_announce> @ imm = #0x7cbc
; 	z_arm_int_exit();
 800f1e4: f7f6 fa28    	bl	0x8005638 <z_arm_int_exit> @ imm = #-0x9bb0
; }
 800f1e8: bf00         	nop
 800f1ea: 3714         	adds	r7, #0x14
 800f1ec: 46bd         	mov	sp, r7
 800f1ee: e8bd 4fb1    	pop.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 800f1f2: 4685         	mov	sp, r0
 800f1f4: 4770         	bx	lr
 800f1f6: bf00         	nop

0800f1f8 <$d>:
 800f1f8: 50 32 00 20  	.word	0x20003250
 800f1fc: 48 23 00 20  	.word	0x20002348
 800f200: 50 23 00 20  	.word	0x20002350
 800f204: 2d 34 a9 f9  	.word	0xf9a9342d

0800f208 <sys_clock_set_timeout>:
; {
 800f208: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800f20c: b09a         	sub	sp, #0x68
 800f20e: af00         	add	r7, sp, #0x0
 800f210: 61f8         	str	r0, [r7, #0x1c]
 800f212: 460b         	mov	r3, r1
 800f214: 76fb         	strb	r3, [r7, #0x1b]
; 	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
 800f216: 7efb         	ldrb	r3, [r7, #0x1b]
 800f218: 2b00         	cmp	r3, #0x0
 800f21a: d00e         	beq	0x800f23a <sys_clock_set_timeout+0x32> @ imm = #0x1c
 800f21c: 69fb         	ldr	r3, [r7, #0x1c]
 800f21e: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800f222: d10a         	bne	0x800f23a <sys_clock_set_timeout+0x32> @ imm = #0x14
; 		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 800f224: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800f3f0 <sys_clock_set_timeout+0x1e8>
 800f226: 681b         	ldr	r3, [r3]
 800f228: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x800f3f0 <sys_clock_set_timeout+0x1e8>
 800f22a: f023 0301    	bic	r3, r3, #0x1
 800f22e: 6013         	str	r3, [r2]
; 		last_load = TIMER_STOPPED;
 800f230: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x800f3f4 <sys_clock_set_timeout+0x1ec>
 800f232: f04f 427f    	mov.w	r2, #0xff000000
 800f236: 601a         	str	r2, [r3]
 800f238: e0d6         	b	0x800f3e8 <sys_clock_set_timeout+0x1e0> @ imm = #0x1ac
; 	uint32_t last_load_ = last_load;
 800f23a: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800f3f4 <sys_clock_set_timeout+0x1ec>
 800f23c: 681b         	ldr	r3, [r3]
 800f23e: 667b         	str	r3, [r7, #0x64]
; 	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 800f240: 69fb         	ldr	r3, [r7, #0x1c]
 800f242: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800f246: d001         	beq	0x800f24c <sys_clock_set_timeout+0x44> @ imm = #0x2
 800f248: 69fb         	ldr	r3, [r7, #0x1c]
 800f24a: e001         	b	0x800f250 <sys_clock_set_timeout+0x48> @ imm = #0x2
 800f24c: f240 33e5    	movw	r3, #0x3e5
 800f250: 61fb         	str	r3, [r7, #0x1c]
; 	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
 800f252: 69fb         	ldr	r3, [r7, #0x1c]
 800f254: 2b01         	cmp	r3, #0x1
 800f256: dd07         	ble	0x800f268 <sys_clock_set_timeout+0x60> @ imm = #0xe
 800f258: 69fb         	ldr	r3, [r7, #0x1c]
 800f25a: f240 32e6    	movw	r2, #0x3e6
 800f25e: 4293         	cmp	r3, r2
 800f260: bfa8         	it	ge
 800f262: 4613         	movge	r3, r2
 800f264: 3b01         	subs	r3, #0x1
 800f266: e000         	b	0x800f26a <sys_clock_set_timeout+0x62> @ imm = #0x0
 800f268: 2300         	movs	r3, #0x0
 800f26a: 61fb         	str	r3, [r7, #0x1c]
 800f26c: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800f3f8 <sys_clock_set_timeout+0x1f0>
 800f26e: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f270: f3ef 8311    	mrs	r3, basepri
 800f274: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800f276: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800f278: 647b         	str	r3, [r7, #0x44]
 800f27a: 2310         	movs	r3, #0x10
 800f27c: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f27e: 6c3b         	ldr	r3, [r7, #0x40]
 800f280: f383 8812    	msr	basepri_max, r3
; }
 800f284: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f286: f3bf 8f6f    	isb	sy
; }
 800f28a: bf00         	nop
; 	return key;
 800f28c: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800f28e: 623b         	str	r3, [r7, #0x20]
 800f290: 6cfb         	ldr	r3, [r7, #0x4c]
 800f292: 63fb         	str	r3, [r7, #0x3c]
; }
 800f294: bf00         	nop
 800f296: 6cfb         	ldr	r3, [r7, #0x4c]
 800f298: 63bb         	str	r3, [r7, #0x38]
; }
 800f29a: bf00         	nop
; 	return k;
 800f29c: 6a3b         	ldr	r3, [r7, #0x20]
 800f29e: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pending = elapsed();
 800f2a0: f7ff ff1c    	bl	0x800f0dc <elapsed>     @ imm = #-0x1c8
 800f2a4: 6638         	str	r0, [r7, #0x60]
; 	val1 = SysTick->VAL;
 800f2a6: 4b52         	ldr	r3, [pc, #0x148]        @ 0x800f3f0 <sys_clock_set_timeout+0x1e8>
 800f2a8: 689b         	ldr	r3, [r3, #0x8]
 800f2aa: 65fb         	str	r3, [r7, #0x5c]
; 	cycle_count += pending;
 800f2ac: 6e3b         	ldr	r3, [r7, #0x60]
 800f2ae: 2200         	movs	r2, #0x0
 800f2b0: 469a         	mov	r10, r3
 800f2b2: 4693         	mov	r11, r2
 800f2b4: 4b51         	ldr	r3, [pc, #0x144]        @ 0x800f3fc <sys_clock_set_timeout+0x1f4>
 800f2b6: e9d3 2300    	ldrd	r2, r3, [r3]
 800f2ba: eb1a 0102    	adds.w	r1, r10, r2
 800f2be: 6139         	str	r1, [r7, #0x10]
 800f2c0: eb4b 0303    	adc.w	r3, r11, r3
 800f2c4: 617b         	str	r3, [r7, #0x14]
 800f2c6: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800f3fc <sys_clock_set_timeout+0x1f4>
 800f2c8: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 800f2cc: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0U;
 800f2d0: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800f400 <sys_clock_set_timeout+0x1f8>
 800f2d2: 2200         	movs	r2, #0x0
 800f2d4: 601a         	str	r2, [r3]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 800f2d6: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800f3fc <sys_clock_set_timeout+0x1f4>
 800f2d8: e9d3 2300    	ldrd	r2, r3, [r3]
 800f2dc: 4611         	mov	r1, r2
 800f2de: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800f404 <sys_clock_set_timeout+0x1fc>
 800f2e0: e9d3 2300    	ldrd	r2, r3, [r3]
 800f2e4: 4613         	mov	r3, r2
 800f2e6: 1acb         	subs	r3, r1, r3
 800f2e8: 65bb         	str	r3, [r7, #0x58]
; 	if ((int32_t)unannounced < 0) {
 800f2ea: 6dbb         	ldr	r3, [r7, #0x58]
 800f2ec: 2b00         	cmp	r3, #0x0
 800f2ee: da04         	bge	0x800f2fa <sys_clock_set_timeout+0xf2> @ imm = #0x8
; 		last_load = MIN_DELAY;
 800f2f0: 4b40         	ldr	r3, [pc, #0x100]        @ 0x800f3f4 <sys_clock_set_timeout+0x1ec>
 800f2f2: f240 421a    	movw	r2, #0x41a
 800f2f6: 601a         	str	r2, [r3]
 800f2f8: e02c         	b	0x800f354 <sys_clock_set_timeout+0x14c> @ imm = #0x58
; 		delay = ticks * CYC_PER_TICK;
 800f2fa: 69fb         	ldr	r3, [r7, #0x1c]
 800f2fc: f244 12a0    	movw	r2, #0x41a0
 800f300: fb02 f303    	mul	r3, r2, r3
 800f304: 657b         	str	r3, [r7, #0x54]
; 		delay += unannounced;
 800f306: 6d7a         	ldr	r2, [r7, #0x54]
 800f308: 6dbb         	ldr	r3, [r7, #0x58]
 800f30a: 4413         	add	r3, r2
 800f30c: 657b         	str	r3, [r7, #0x54]
; 		delay = DIV_ROUND_UP(delay, CYC_PER_TICK) * CYC_PER_TICK;
 800f30e: 6d7b         	ldr	r3, [r7, #0x54]
 800f310: f503 4383    	add.w	r3, r3, #0x4180
 800f314: 331f         	adds	r3, #0x1f
 800f316: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x800f408 <sys_clock_set_timeout+0x200>
 800f318: fba2 2303    	umull	r2, r3, r2, r3
 800f31c: 0b9b         	lsrs	r3, r3, #0xe
 800f31e: f244 12a0    	movw	r2, #0x41a0
 800f322: fb02 f303    	mul	r3, r2, r3
 800f326: 657b         	str	r3, [r7, #0x54]
; 		delay -= unannounced;
 800f328: 6d7a         	ldr	r2, [r7, #0x54]
 800f32a: 6dbb         	ldr	r3, [r7, #0x58]
 800f32c: 1ad3         	subs	r3, r2, r3
 800f32e: 657b         	str	r3, [r7, #0x54]
; 		delay = MAX(delay, MIN_DELAY);
 800f330: 6d7b         	ldr	r3, [r7, #0x54]
 800f332: f240 421a    	movw	r2, #0x41a
 800f336: 4293         	cmp	r3, r2
 800f338: bf38         	it	lo
 800f33a: 4613         	movlo	r3, r2
 800f33c: 657b         	str	r3, [r7, #0x54]
; 		if (delay > MAX_CYCLES) {
 800f33e: 6d7b         	ldr	r3, [r7, #0x54]
 800f340: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x800f40c <sys_clock_set_timeout+0x204>
 800f342: 4293         	cmp	r3, r2
 800f344: d903         	bls	0x800f34e <sys_clock_set_timeout+0x146> @ imm = #0x6
; 			last_load = MAX_CYCLES;
 800f346: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800f3f4 <sys_clock_set_timeout+0x1ec>
 800f348: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x800f40c <sys_clock_set_timeout+0x204>
 800f34a: 601a         	str	r2, [r3]
 800f34c: e002         	b	0x800f354 <sys_clock_set_timeout+0x14c> @ imm = #0x4
; 			last_load = delay;
 800f34e: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x800f3f4 <sys_clock_set_timeout+0x1ec>
 800f350: 6d7b         	ldr	r3, [r7, #0x54]
 800f352: 6013         	str	r3, [r2]
; 	val2 = SysTick->VAL;
 800f354: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800f3f0 <sys_clock_set_timeout+0x1e8>
 800f356: 689b         	ldr	r3, [r3, #0x8]
 800f358: 653b         	str	r3, [r7, #0x50]
; 	SysTick->LOAD = last_load - 1;
 800f35a: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800f3f4 <sys_clock_set_timeout+0x1ec>
 800f35c: 681b         	ldr	r3, [r3]
 800f35e: 4a24         	ldr	r2, [pc, #0x90]         @ 0x800f3f0 <sys_clock_set_timeout+0x1e8>
 800f360: 3b01         	subs	r3, #0x1
 800f362: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 800f364: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800f3f0 <sys_clock_set_timeout+0x1e8>
 800f366: 2200         	movs	r2, #0x0
 800f368: 609a         	str	r2, [r3, #0x8]
; 	if (val1 < val2) {
 800f36a: 6dfa         	ldr	r2, [r7, #0x5c]
 800f36c: 6d3b         	ldr	r3, [r7, #0x50]
 800f36e: 429a         	cmp	r2, r3
 800f370: d216         	bhs	0x800f3a0 <sys_clock_set_timeout+0x198> @ imm = #0x2c
; 		cycle_count += (val1 + (last_load_ - val2));
 800f372: 6e7a         	ldr	r2, [r7, #0x64]
 800f374: 6d3b         	ldr	r3, [r7, #0x50]
 800f376: 1ad2         	subs	r2, r2, r3
 800f378: 6dfb         	ldr	r3, [r7, #0x5c]
 800f37a: 4413         	add	r3, r2
 800f37c: 2200         	movs	r2, #0x0
 800f37e: 4698         	mov	r8, r3
 800f380: 4691         	mov	r9, r2
 800f382: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800f3fc <sys_clock_set_timeout+0x1f4>
 800f384: e9d3 2300    	ldrd	r2, r3, [r3]
 800f388: eb18 0102    	adds.w	r1, r8, r2
 800f38c: 60b9         	str	r1, [r7, #0x8]
 800f38e: eb49 0303    	adc.w	r3, r9, r3
 800f392: 60fb         	str	r3, [r7, #0xc]
 800f394: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800f3fc <sys_clock_set_timeout+0x1f4>
 800f396: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 800f39a: e9c3 1200    	strd	r1, r2, [r3]
 800f39e: e012         	b	0x800f3c6 <sys_clock_set_timeout+0x1be> @ imm = #0x24
; 		cycle_count += (val1 - val2);
 800f3a0: 6dfa         	ldr	r2, [r7, #0x5c]
 800f3a2: 6d3b         	ldr	r3, [r7, #0x50]
 800f3a4: 1ad3         	subs	r3, r2, r3
 800f3a6: 2200         	movs	r2, #0x0
 800f3a8: 461c         	mov	r4, r3
 800f3aa: 4615         	mov	r5, r2
 800f3ac: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800f3fc <sys_clock_set_timeout+0x1f4>
 800f3ae: e9d3 2300    	ldrd	r2, r3, [r3]
 800f3b2: 18a1         	adds	r1, r4, r2
 800f3b4: 6039         	str	r1, [r7]
 800f3b6: eb45 0303    	adc.w	r3, r5, r3
 800f3ba: 607b         	str	r3, [r7, #0x4]
 800f3bc: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800f3fc <sys_clock_set_timeout+0x1f4>
 800f3be: e9d7 1200    	ldrd	r1, r2, [r7]
 800f3c2: e9c3 1200    	strd	r1, r2, [r3]
 800f3c6: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800f3f8 <sys_clock_set_timeout+0x1f0>
 800f3c8: 637b         	str	r3, [r7, #0x34]
 800f3ca: 6abb         	ldr	r3, [r7, #0x28]
 800f3cc: 627b         	str	r3, [r7, #0x24]
; 	arch_irq_unlock(key.key);
 800f3ce: 6a7b         	ldr	r3, [r7, #0x24]
 800f3d0: 633b         	str	r3, [r7, #0x30]
 800f3d2: 6b3b         	ldr	r3, [r7, #0x30]
 800f3d4: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f3d6: 6afb         	ldr	r3, [r7, #0x2c]
 800f3d8: f383 8811    	msr	basepri, r3
; }
 800f3dc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f3de: f3bf 8f6f    	isb	sy
; }
 800f3e2: bf00         	nop
; }
 800f3e4: bf00         	nop
; }
 800f3e6: bf00         	nop
; }
 800f3e8: 3768         	adds	r7, #0x68
 800f3ea: 46bd         	mov	sp, r7
 800f3ec: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800f3f0 <$d>:
 800f3f0: 10 e0 00 e0  	.word	0xe000e010
 800f3f4: 4c 32 00 20  	.word	0x2000324c
 800f3f8: 4c 32 00 20  	.word	0x2000324c
 800f3fc: 48 23 00 20  	.word	0x20002348
 800f400: 50 32 00 20  	.word	0x20003250
 800f404: 50 23 00 20  	.word	0x20002350
 800f408: 2d 34 a9 f9  	.word	0xf9a9342d
 800f40c: 20 94 ff 00  	.word	0x00ff9420

0800f410 <sys_clock_elapsed>:
; {
 800f410: b580         	push	{r7, lr}
 800f412: b08e         	sub	sp, #0x38
 800f414: af00         	add	r7, sp, #0x0
 800f416: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800f4a0 <sys_clock_elapsed+0x90>
 800f418: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f41a: f3ef 8311    	mrs	r3, basepri
 800f41e: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 800f420: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 800f422: 61bb         	str	r3, [r7, #0x18]
 800f424: 2310         	movs	r3, #0x10
 800f426: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f428: 697b         	ldr	r3, [r7, #0x14]
 800f42a: f383 8812    	msr	basepri_max, r3
; }
 800f42e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f430: f3bf 8f6f    	isb	sy
; }
 800f434: bf00         	nop
; 	return key;
 800f436: 69bb         	ldr	r3, [r7, #0x18]
; 	k.key = arch_irq_lock();
 800f438: 607b         	str	r3, [r7, #0x4]
 800f43a: 6a3b         	ldr	r3, [r7, #0x20]
 800f43c: 613b         	str	r3, [r7, #0x10]
; }
 800f43e: bf00         	nop
 800f440: 6a3b         	ldr	r3, [r7, #0x20]
 800f442: 60fb         	str	r3, [r7, #0xc]
; }
 800f444: bf00         	nop
; 	return k;
 800f446: 687b         	ldr	r3, [r7, #0x4]
 800f448: 60bb         	str	r3, [r7, #0x8]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 800f44a: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800f4a4 <sys_clock_elapsed+0x94>
 800f44c: e9d3 2300    	ldrd	r2, r3, [r3]
 800f450: 4611         	mov	r1, r2
 800f452: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800f4a8 <sys_clock_elapsed+0x98>
 800f454: e9d3 2300    	ldrd	r2, r3, [r3]
 800f458: 4613         	mov	r3, r2
 800f45a: 1acb         	subs	r3, r1, r3
 800f45c: 637b         	str	r3, [r7, #0x34]
; 	uint32_t cyc = elapsed() + unannounced;
 800f45e: f7ff fe3d    	bl	0x800f0dc <elapsed>     @ imm = #-0x386
 800f462: 4602         	mov	r2, r0
 800f464: 6b7b         	ldr	r3, [r7, #0x34]
 800f466: 4413         	add	r3, r2
 800f468: 633b         	str	r3, [r7, #0x30]
 800f46a: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800f4a0 <sys_clock_elapsed+0x90>
 800f46c: 62fb         	str	r3, [r7, #0x2c]
 800f46e: 68bb         	ldr	r3, [r7, #0x8]
 800f470: 603b         	str	r3, [r7]
; 	arch_irq_unlock(key.key);
 800f472: 683b         	ldr	r3, [r7]
 800f474: 62bb         	str	r3, [r7, #0x28]
 800f476: 6abb         	ldr	r3, [r7, #0x28]
 800f478: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f47a: 6a7b         	ldr	r3, [r7, #0x24]
 800f47c: f383 8811    	msr	basepri, r3
; }
 800f480: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f482: f3bf 8f6f    	isb	sy
; }
 800f486: bf00         	nop
; }
 800f488: bf00         	nop
; }
 800f48a: bf00         	nop
; 	return cyc / CYC_PER_TICK;
 800f48c: 6b3b         	ldr	r3, [r7, #0x30]
 800f48e: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800f4ac <sys_clock_elapsed+0x9c>
 800f490: fba2 2303    	umull	r2, r3, r2, r3
 800f494: 0b9b         	lsrs	r3, r3, #0xe
; }
 800f496: 4618         	mov	r0, r3
 800f498: 3738         	adds	r7, #0x38
 800f49a: 46bd         	mov	sp, r7
 800f49c: bd80         	pop	{r7, pc}
 800f49e: bf00         	nop

0800f4a0 <$d>:
 800f4a0: 4c 32 00 20  	.word	0x2000324c
 800f4a4: 48 23 00 20  	.word	0x20002348
 800f4a8: 50 23 00 20  	.word	0x20002350
 800f4ac: 2d 34 a9 f9  	.word	0xf9a9342d

0800f4b0 <sys_clock_cycle_get_32>:
; {
 800f4b0: b580         	push	{r7, lr}
 800f4b2: b08e         	sub	sp, #0x38
 800f4b4: af00         	add	r7, sp, #0x0
 800f4b6: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800f52c <sys_clock_cycle_get_32+0x7c>
 800f4b8: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f4ba: f3ef 8311    	mrs	r3, basepri
 800f4be: 623b         	str	r3, [r7, #0x20]
;   return(result);
 800f4c0: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 800f4c2: 61fb         	str	r3, [r7, #0x1c]
 800f4c4: 2310         	movs	r3, #0x10
 800f4c6: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f4c8: 69bb         	ldr	r3, [r7, #0x18]
 800f4ca: f383 8812    	msr	basepri_max, r3
; }
 800f4ce: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f4d0: f3bf 8f6f    	isb	sy
; }
 800f4d4: bf00         	nop
; 	return key;
 800f4d6: 69fb         	ldr	r3, [r7, #0x1c]
; 	k.key = arch_irq_lock();
 800f4d8: 60bb         	str	r3, [r7, #0x8]
 800f4da: 6a7b         	ldr	r3, [r7, #0x24]
 800f4dc: 617b         	str	r3, [r7, #0x14]
; }
 800f4de: bf00         	nop
 800f4e0: 6a7b         	ldr	r3, [r7, #0x24]
 800f4e2: 613b         	str	r3, [r7, #0x10]
; }
 800f4e4: bf00         	nop
; 	return k;
 800f4e6: 68bb         	ldr	r3, [r7, #0x8]
 800f4e8: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ret = cycle_count;
 800f4ea: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800f530 <sys_clock_cycle_get_32+0x80>
 800f4ec: e9d3 2300    	ldrd	r2, r3, [r3]
 800f4f0: 4613         	mov	r3, r2
 800f4f2: 637b         	str	r3, [r7, #0x34]
; 	ret += elapsed();
 800f4f4: f7ff fdf2    	bl	0x800f0dc <elapsed>     @ imm = #-0x41c
 800f4f8: 4602         	mov	r2, r0
 800f4fa: 6b7b         	ldr	r3, [r7, #0x34]
 800f4fc: 4413         	add	r3, r2
 800f4fe: 637b         	str	r3, [r7, #0x34]
 800f500: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800f52c <sys_clock_cycle_get_32+0x7c>
 800f502: 633b         	str	r3, [r7, #0x30]
 800f504: 68fb         	ldr	r3, [r7, #0xc]
 800f506: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 800f508: 687b         	ldr	r3, [r7, #0x4]
 800f50a: 62fb         	str	r3, [r7, #0x2c]
 800f50c: 6afb         	ldr	r3, [r7, #0x2c]
 800f50e: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f510: 6abb         	ldr	r3, [r7, #0x28]
 800f512: f383 8811    	msr	basepri, r3
; }
 800f516: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f518: f3bf 8f6f    	isb	sy
; }
 800f51c: bf00         	nop
; }
 800f51e: bf00         	nop
; }
 800f520: bf00         	nop
; 	return ret;
 800f522: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800f524: 4618         	mov	r0, r3
 800f526: 3738         	adds	r7, #0x38
 800f528: 46bd         	mov	sp, r7
 800f52a: bd80         	pop	{r7, pc}

0800f52c <$d>:
 800f52c: 4c 32 00 20  	.word	0x2000324c
 800f530: 48 23 00 20  	.word	0x20002348

0800f534 <sys_clock_driver_init>:
; {
 800f534: b580         	push	{r7, lr}
 800f536: af00         	add	r7, sp, #0x0
; 	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
 800f538: 2101         	movs	r1, #0x1
 800f53a: f04f 30ff    	mov.w	r0, #0xffffffff
 800f53e: f7ff fda3    	bl	0x800f088 <__NVIC_SetPriority> @ imm = #-0x4ba
; 	last_load = CYC_PER_TICK;
 800f542: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800f574 <sys_clock_driver_init+0x40>
 800f544: f244 12a0    	movw	r2, #0x41a0
 800f548: 601a         	str	r2, [r3]
; 	overflow_cyc = 0U;
 800f54a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800f578 <sys_clock_driver_init+0x44>
 800f54c: 2200         	movs	r2, #0x0
 800f54e: 601a         	str	r2, [r3]
; 	SysTick->LOAD = last_load - 1;
 800f550: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800f574 <sys_clock_driver_init+0x40>
 800f552: 681b         	ldr	r3, [r3]
 800f554: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800f57c <sys_clock_driver_init+0x48>
 800f556: 3b01         	subs	r3, #0x1
 800f558: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 800f55a: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800f57c <sys_clock_driver_init+0x48>
 800f55c: 2200         	movs	r2, #0x0
 800f55e: 609a         	str	r2, [r3, #0x8]
; 	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
 800f560: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800f57c <sys_clock_driver_init+0x48>
 800f562: 681b         	ldr	r3, [r3]
 800f564: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800f57c <sys_clock_driver_init+0x48>
 800f566: f043 0307    	orr	r3, r3, #0x7
 800f56a: 6013         	str	r3, [r2]
; 	return 0;
 800f56c: 2300         	movs	r3, #0x0
; }
 800f56e: 4618         	mov	r0, r3
 800f570: bd80         	pop	{r7, pc}
 800f572: bf00         	nop

0800f574 <$d>:
 800f574: 4c 32 00 20  	.word	0x2000324c
 800f578: 50 32 00 20  	.word	0x20003250
 800f57c: 10 e0 00 e0  	.word	0xe000e010

0800f580 <float_equal>:
; {
 800f580: b480         	push	{r7}
 800f582: b085         	sub	sp, #0x14
 800f584: af00         	add	r7, sp, #0x0
 800f586: ed87 0a01    	vstr	s0, [r7, #4]
 800f58a: edc7 0a00    	vstr	s1, [r7]
; 	return fabsf(a - b) < 0.0001f;
 800f58e: ed97 7a01    	vldr	s14, [r7, #4]
 800f592: edd7 7a00    	vldr	s15, [r7]
 800f596: ee77 7a67    	vsub.f32	s15, s14, s15
 800f59a: edc7 7a03    	vstr	s15, [r7, #12]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 800f59e: edd7 7a03    	vldr	s15, [r7, #12]
 800f5a2: eef0 7ae7    	vabs.f32	s15, s15
 800f5a6: edc7 7a02    	vstr	s15, [r7, #8]
;     return result;
 800f5aa: edd7 7a02    	vldr	s15, [r7, #8]
; 	return fabsf(a - b) < 0.0001f;
 800f5ae: ed9f 7a08    	vldr	s14, [pc, #32]          @ 0x800f5d0 <float_equal+0x50>
 800f5b2: eef4 7ac7    	vcmpe.f32	s15, s14
 800f5b6: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800f5ba: bf4c         	ite	mi
 800f5bc: 2301         	movmi	r3, #0x1
 800f5be: 2300         	movpl	r3, #0x0
 800f5c0: b2db         	uxtb	r3, r3
; }
 800f5c2: 4618         	mov	r0, r3
 800f5c4: 3714         	adds	r7, #0x14
 800f5c6: 46bd         	mov	sp, r7
 800f5c8: f85d 7b04    	ldr	r7, [sp], #4
 800f5cc: 4770         	bx	lr
 800f5ce: bf00         	nop

0800f5d0 <$d>:
 800f5d0: 17 b7 d1 38  	.word	0x38d1b717

0800f5d4 <pid_calc>:
; {
 800f5d4: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800f5d8: b08e         	sub	sp, #0x38
 800f5da: af00         	add	r7, sp, #0x0
 800f5dc: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = data->pid_dev;
 800f5de: 6879         	ldr	r1, [r7, #0x4]
 800f5e0: 69c9         	ldr	r1, [r1, #0x1c]
 800f5e2: 6379         	str	r1, [r7, #0x34]
; 	if (dev == NULL) {
 800f5e4: 6b79         	ldr	r1, [r7, #0x34]
 800f5e6: 2900         	cmp	r1, #0x0
 800f5e8: f000 8159    	beq.w	0x800f89e <pid_calc+0x2ca> @ imm = #0x2b2
; 	const struct pid_config *pid_para = dev->config;
 800f5ec: 6b79         	ldr	r1, [r7, #0x34]
 800f5ee: 6849         	ldr	r1, [r1, #0x4]
 800f5f0: 6339         	str	r1, [r7, #0x30]
; 	if (!pid_para->mit) {
 800f5f2: 6b39         	ldr	r1, [r7, #0x30]
 800f5f4: 7b09         	ldrb	r1, [r1, #0xc]
 800f5f6: f081 0101    	eor	r1, r1, #0x1
 800f5fa: b2c9         	uxtb	r1, r1
 800f5fc: 2900         	cmp	r1, #0x0
 800f5fe: f000 80a3    	beq.w	0x800f748 <pid_calc+0x174> @ imm = #0x146
; 		if (data->curr == NULL) {
 800f602: 687b         	ldr	r3, [r7, #0x4]
 800f604: 685b         	ldr	r3, [r3, #0x4]
 800f606: 2b00         	cmp	r3, #0x0
 800f608: f000 814b    	beq.w	0x800f8a2 <pid_calc+0x2ce> @ imm = #0x296
; 		float kp = pid_para->k_p;
 800f60c: 6b3b         	ldr	r3, [r7, #0x30]
 800f60e: 681b         	ldr	r3, [r3]
 800f610: 61bb         	str	r3, [r7, #0x18]
; 		float ki = pid_para->k_i;
 800f612: 6b3b         	ldr	r3, [r7, #0x30]
 800f614: 685b         	ldr	r3, [r3, #0x4]
 800f616: 617b         	str	r3, [r7, #0x14]
; 		float kd = pid_para->k_d;
 800f618: 6b3b         	ldr	r3, [r7, #0x30]
 800f61a: 689b         	ldr	r3, [r3, #0x8]
 800f61c: 613b         	str	r3, [r7, #0x10]
; 		float err = *(data->ref) - *(data->curr);
 800f61e: 687b         	ldr	r3, [r7, #0x4]
 800f620: 681b         	ldr	r3, [r3]
 800f622: ed93 7a00    	vldr	s14, [r3]
 800f626: 687b         	ldr	r3, [r7, #0x4]
 800f628: 685b         	ldr	r3, [r3, #0x4]
 800f62a: edd3 7a00    	vldr	s15, [r3]
 800f62e: ee77 7a67    	vsub.f32	s15, s14, s15
 800f632: edc7 7a03    	vstr	s15, [r7, #12]
; 		float deltaT = k_cyc_to_us_near32(*(data->curr_time) - *(data->prev_time));
 800f636: 687b         	ldr	r3, [r7, #0x4]
 800f638: 6a1b         	ldr	r3, [r3, #0x20]
 800f63a: 681a         	ldr	r2, [r3]
 800f63c: 687b         	ldr	r3, [r7, #0x4]
 800f63e: 6a5b         	ldr	r3, [r3, #0x24]
 800f640: 681b         	ldr	r3, [r3]
 800f642: 1ad3         	subs	r3, r2, r3
 800f644: 2b00         	cmp	r3, #0x0
 800f646: db11         	blt	0x800f66c <pid_calc+0x98> @ imm = #0x22
 800f648: 687b         	ldr	r3, [r7, #0x4]
 800f64a: 6a1b         	ldr	r3, [r3, #0x20]
 800f64c: 681a         	ldr	r2, [r3]
 800f64e: 687b         	ldr	r3, [r7, #0x4]
 800f650: 6a5b         	ldr	r3, [r3, #0x24]
 800f652: 681b         	ldr	r3, [r3]
 800f654: 1ad3         	subs	r3, r2, r3
 800f656: 3354         	adds	r3, #0x54
 800f658: 08db         	lsrs	r3, r3, #0x3
 800f65a: 4a95         	ldr	r2, [pc, #0x254]        @ 0x800f8b0 <pid_calc+0x2dc>
 800f65c: fba2 2303    	umull	r2, r3, r2, r3
 800f660: 085b         	lsrs	r3, r3, #0x1
 800f662: ee07 3a90    	vmov	s15, r3
 800f666: eef8 7a67    	vcvt.f32.u32	s15, s15
 800f66a: e01b         	b	0x800f6a4 <pid_calc+0xd0> @ imm = #0x36
 800f66c: 687b         	ldr	r3, [r7, #0x4]
 800f66e: 6a1b         	ldr	r3, [r3, #0x20]
 800f670: 681a         	ldr	r2, [r3]
 800f672: 687b         	ldr	r3, [r7, #0x4]
 800f674: 6a5b         	ldr	r3, [r3, #0x24]
 800f676: 681b         	ldr	r3, [r3]
 800f678: 1ad3         	subs	r3, r2, r3
 800f67a: 17da         	asrs	r2, r3, #0x1f
 800f67c: 461c         	mov	r4, r3
 800f67e: 4615         	mov	r5, r2
 800f680: f114 0a54    	adds.w	r10, r4, #0x54
 800f684: f145 0b00    	adc	r11, r5, #0x0
 800f688: f04f 02a8    	mov.w	r2, #0xa8
 800f68c: f04f 0300    	mov.w	r3, #0x0
 800f690: 4650         	mov	r0, r10
 800f692: 4659         	mov	r1, r11
 800f694: f7f0 ffd4    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xf058
 800f698: 4602         	mov	r2, r0
 800f69a: 460b         	mov	r3, r1
 800f69c: ee07 2a90    	vmov	s15, r2
 800f6a0: eef8 7a67    	vcvt.f32.u32	s15, s15
 800f6a4: edc7 7a02    	vstr	s15, [r7, #8]
; 		if (!float_equal(ki, 0)) {
 800f6a8: eddf 0a82    	vldr	s1, [pc, #520]          @ 0x800f8b4 <pid_calc+0x2e0>
 800f6ac: ed97 0a05    	vldr	s0, [r7, #20]
 800f6b0: f7ff ff66    	bl	0x800f580 <float_equal> @ imm = #-0x134
 800f6b4: 4603         	mov	r3, r0
 800f6b6: f083 0301    	eor	r3, r3, #0x1
 800f6ba: b2db         	uxtb	r3, r3
 800f6bc: 2b00         	cmp	r3, #0x0
 800f6be: d015         	beq	0x800f6ec <pid_calc+0x118> @ imm = #0x2a
; 			data->err_integral += (err * deltaT) / (1000000 * ki);
 800f6c0: 687b         	ldr	r3, [r7, #0x4]
 800f6c2: ed93 7a04    	vldr	s14, [r3, #16]
 800f6c6: edd7 6a03    	vldr	s13, [r7, #12]
 800f6ca: edd7 7a02    	vldr	s15, [r7, #8]
 800f6ce: ee26 6aa7    	vmul.f32	s12, s13, s15
 800f6d2: edd7 7a05    	vldr	s15, [r7, #20]
 800f6d6: eddf 6a78    	vldr	s13, [pc, #480]         @ 0x800f8b8 <pid_calc+0x2e4>
 800f6da: ee67 6aa6    	vmul.f32	s13, s15, s13
 800f6de: eec6 7a26    	vdiv.f32	s15, s12, s13
 800f6e2: ee77 7a27    	vadd.f32	s15, s14, s15
 800f6e6: 687b         	ldr	r3, [r7, #0x4]
 800f6e8: edc3 7a04    	vstr	s15, [r3, #16]
; 		if (!float_equal(kd, 0)) {
 800f6ec: eddf 0a71    	vldr	s1, [pc, #452]          @ 0x800f8b4 <pid_calc+0x2e0>
 800f6f0: ed97 0a04    	vldr	s0, [r7, #16]
 800f6f4: f7ff ff44    	bl	0x800f580 <float_equal> @ imm = #-0x178
 800f6f8: 4603         	mov	r3, r0
 800f6fa: f083 0301    	eor	r3, r3, #0x1
 800f6fe: b2db         	uxtb	r3, r3
 800f700: 2b00         	cmp	r3, #0x0
 800f702: d00c         	beq	0x800f71e <pid_calc+0x14a> @ imm = #0x18
; 			data->err_derivate = kd * err / deltaT;
 800f704: ed97 7a04    	vldr	s14, [r7, #16]
 800f708: edd7 7a03    	vldr	s15, [r7, #12]
 800f70c: ee67 6a27    	vmul.f32	s13, s14, s15
 800f710: ed97 7a02    	vldr	s14, [r7, #8]
 800f714: eec6 7a87    	vdiv.f32	s15, s13, s14
 800f718: 687b         	ldr	r3, [r7, #0x4]
 800f71a: edc3 7a05    	vstr	s15, [r3, #20]
; 		*(data->output) = kp * (err + data->err_integral + data->err_derivate);
 800f71e: 687b         	ldr	r3, [r7, #0x4]
 800f720: ed93 7a04    	vldr	s14, [r3, #16]
 800f724: edd7 7a03    	vldr	s15, [r7, #12]
 800f728: ee37 7a27    	vadd.f32	s14, s14, s15
 800f72c: 687b         	ldr	r3, [r7, #0x4]
 800f72e: edd3 7a05    	vldr	s15, [r3, #20]
 800f732: ee37 7a27    	vadd.f32	s14, s14, s15
 800f736: 687b         	ldr	r3, [r7, #0x4]
 800f738: 6a9b         	ldr	r3, [r3, #0x28]
 800f73a: edd7 7a06    	vldr	s15, [r7, #24]
 800f73e: ee67 7a27    	vmul.f32	s15, s14, s15
 800f742: edc3 7a00    	vstr	s15, [r3]
 800f746: e0af         	b	0x800f8a8 <pid_calc+0x2d4> @ imm = #0x15e
; 		if (data->curr == NULL) {
 800f748: 6879         	ldr	r1, [r7, #0x4]
 800f74a: 6849         	ldr	r1, [r1, #0x4]
 800f74c: 2900         	cmp	r1, #0x0
 800f74e: f000 80aa    	beq.w	0x800f8a6 <pid_calc+0x2d2> @ imm = #0x154
; 		float kp = pid_para->k_p;
 800f752: 6b39         	ldr	r1, [r7, #0x30]
 800f754: 6809         	ldr	r1, [r1]
 800f756: 62f9         	str	r1, [r7, #0x2c]
; 		float ki = pid_para->k_i;
 800f758: 6b39         	ldr	r1, [r7, #0x30]
 800f75a: 6849         	ldr	r1, [r1, #0x4]
 800f75c: 62b9         	str	r1, [r7, #0x28]
; 		float kd = pid_para->k_d;
 800f75e: 6b39         	ldr	r1, [r7, #0x30]
 800f760: 6889         	ldr	r1, [r1, #0x8]
 800f762: 6279         	str	r1, [r7, #0x24]
; 		float err = *(data->ref) - *(data->curr);
 800f764: 6879         	ldr	r1, [r7, #0x4]
 800f766: 6809         	ldr	r1, [r1]
 800f768: ed91 7a00    	vldr	s14, [r1]
 800f76c: 6879         	ldr	r1, [r7, #0x4]
 800f76e: 6849         	ldr	r1, [r1, #0x4]
 800f770: edd1 7a00    	vldr	s15, [r1]
 800f774: ee77 7a67    	vsub.f32	s15, s14, s15
 800f778: edc7 7a08    	vstr	s15, [r7, #32]
; 		float deltaT = k_cyc_to_us_near32(*(data->curr_time) - *(data->prev_time));
 800f77c: 6879         	ldr	r1, [r7, #0x4]
 800f77e: 6a09         	ldr	r1, [r1, #0x20]
 800f780: 6808         	ldr	r0, [r1]
 800f782: 6879         	ldr	r1, [r7, #0x4]
 800f784: 6a49         	ldr	r1, [r1, #0x24]
 800f786: 6809         	ldr	r1, [r1]
 800f788: 1a41         	subs	r1, r0, r1
 800f78a: 2900         	cmp	r1, #0x0
 800f78c: db11         	blt	0x800f7b2 <pid_calc+0x1de> @ imm = #0x22
 800f78e: 687b         	ldr	r3, [r7, #0x4]
 800f790: 6a1b         	ldr	r3, [r3, #0x20]
 800f792: 681a         	ldr	r2, [r3]
 800f794: 687b         	ldr	r3, [r7, #0x4]
 800f796: 6a5b         	ldr	r3, [r3, #0x24]
 800f798: 681b         	ldr	r3, [r3]
 800f79a: 1ad3         	subs	r3, r2, r3
 800f79c: 3354         	adds	r3, #0x54
 800f79e: 08db         	lsrs	r3, r3, #0x3
 800f7a0: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x800f8b0 <pid_calc+0x2dc>
 800f7a2: fba2 2303    	umull	r2, r3, r2, r3
 800f7a6: 085b         	lsrs	r3, r3, #0x1
 800f7a8: ee07 3a90    	vmov	s15, r3
 800f7ac: eef8 7a67    	vcvt.f32.u32	s15, s15
 800f7b0: e01b         	b	0x800f7ea <pid_calc+0x216> @ imm = #0x36
 800f7b2: 6879         	ldr	r1, [r7, #0x4]
 800f7b4: 6a09         	ldr	r1, [r1, #0x20]
 800f7b6: 6808         	ldr	r0, [r1]
 800f7b8: 6879         	ldr	r1, [r7, #0x4]
 800f7ba: 6a49         	ldr	r1, [r1, #0x24]
 800f7bc: 6809         	ldr	r1, [r1]
 800f7be: 1a41         	subs	r1, r0, r1
 800f7c0: 17c8         	asrs	r0, r1, #0x1f
 800f7c2: 460a         	mov	r2, r1
 800f7c4: 4603         	mov	r3, r0
 800f7c6: f112 0854    	adds.w	r8, r2, #0x54
 800f7ca: f143 0900    	adc	r9, r3, #0x0
 800f7ce: f04f 02a8    	mov.w	r2, #0xa8
 800f7d2: f04f 0300    	mov.w	r3, #0x0
 800f7d6: 4640         	mov	r0, r8
 800f7d8: 4649         	mov	r1, r9
 800f7da: f7f0 ff31    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0xf19e
 800f7de: 4602         	mov	r2, r0
 800f7e0: 460b         	mov	r3, r1
 800f7e2: ee07 2a90    	vmov	s15, r2
 800f7e6: eef8 7a67    	vcvt.f32.u32	s15, s15
 800f7ea: edc7 7a07    	vstr	s15, [r7, #28]
; 		if (!float_equal(ki, 0)) {
 800f7ee: eddf 0a31    	vldr	s1, [pc, #196]          @ 0x800f8b4 <pid_calc+0x2e0>
 800f7f2: ed97 0a0a    	vldr	s0, [r7, #40]
 800f7f6: f7ff fec3    	bl	0x800f580 <float_equal> @ imm = #-0x27a
 800f7fa: 4603         	mov	r3, r0
 800f7fc: f083 0301    	eor	r3, r3, #0x1
 800f800: b2db         	uxtb	r3, r3
 800f802: 2b00         	cmp	r3, #0x0
 800f804: d015         	beq	0x800f832 <pid_calc+0x25e> @ imm = #0x2a
; 			data->err_integral += (err * deltaT) / (1000000 * ki);
 800f806: 687b         	ldr	r3, [r7, #0x4]
 800f808: ed93 7a04    	vldr	s14, [r3, #16]
 800f80c: edd7 6a08    	vldr	s13, [r7, #32]
 800f810: edd7 7a07    	vldr	s15, [r7, #28]
 800f814: ee26 6aa7    	vmul.f32	s12, s13, s15
 800f818: edd7 7a0a    	vldr	s15, [r7, #40]
 800f81c: eddf 6a26    	vldr	s13, [pc, #152]         @ 0x800f8b8 <pid_calc+0x2e4>
 800f820: ee67 6aa6    	vmul.f32	s13, s15, s13
 800f824: eec6 7a26    	vdiv.f32	s15, s12, s13
 800f828: ee77 7a27    	vadd.f32	s15, s14, s15
 800f82c: 687b         	ldr	r3, [r7, #0x4]
 800f82e: edc3 7a04    	vstr	s15, [r3, #16]
; 		if (!float_equal(kd, 0)) {
 800f832: eddf 0a20    	vldr	s1, [pc, #128]          @ 0x800f8b4 <pid_calc+0x2e0>
 800f836: ed97 0a09    	vldr	s0, [r7, #36]
 800f83a: f7ff fea1    	bl	0x800f580 <float_equal> @ imm = #-0x2be
 800f83e: 4603         	mov	r3, r0
 800f840: f083 0301    	eor	r3, r3, #0x1
 800f844: b2db         	uxtb	r3, r3
 800f846: 2b00         	cmp	r3, #0x0
 800f848: d014         	beq	0x800f874 <pid_calc+0x2a0> @ imm = #0x28
; 				kd * (*(data->detri_ref) - *(data->detri_curr)) / deltaT;
 800f84a: 687b         	ldr	r3, [r7, #0x4]
 800f84c: 689b         	ldr	r3, [r3, #0x8]
 800f84e: ed93 7a00    	vldr	s14, [r3]
 800f852: 687b         	ldr	r3, [r7, #0x4]
 800f854: 68db         	ldr	r3, [r3, #0xc]
 800f856: edd3 7a00    	vldr	s15, [r3]
 800f85a: ee37 7a67    	vsub.f32	s14, s14, s15
 800f85e: edd7 7a09    	vldr	s15, [r7, #36]
 800f862: ee67 6a27    	vmul.f32	s13, s14, s15
 800f866: ed97 7a07    	vldr	s14, [r7, #28]
 800f86a: eec6 7a87    	vdiv.f32	s15, s13, s14
; 			data->err_derivate =
 800f86e: 687b         	ldr	r3, [r7, #0x4]
 800f870: edc3 7a05    	vstr	s15, [r3, #20]
; 		*(data->output) = kp * (err + data->err_integral + data->err_derivate);
 800f874: 687b         	ldr	r3, [r7, #0x4]
 800f876: ed93 7a04    	vldr	s14, [r3, #16]
 800f87a: edd7 7a08    	vldr	s15, [r7, #32]
 800f87e: ee37 7a27    	vadd.f32	s14, s14, s15
 800f882: 687b         	ldr	r3, [r7, #0x4]
 800f884: edd3 7a05    	vldr	s15, [r3, #20]
 800f888: ee37 7a27    	vadd.f32	s14, s14, s15
 800f88c: 687b         	ldr	r3, [r7, #0x4]
 800f88e: 6a9b         	ldr	r3, [r3, #0x28]
 800f890: edd7 7a0b    	vldr	s15, [r7, #44]
 800f894: ee67 7a27    	vmul.f32	s15, s14, s15
 800f898: edc3 7a00    	vstr	s15, [r3]
; 		return;
 800f89c: e004         	b	0x800f8a8 <pid_calc+0x2d4> @ imm = #0x8
; 		return;
 800f89e: bf00         	nop
 800f8a0: e002         	b	0x800f8a8 <pid_calc+0x2d4> @ imm = #0x4
; 			return;
 800f8a2: bf00         	nop
 800f8a4: e000         	b	0x800f8a8 <pid_calc+0x2d4> @ imm = #0x0
; 			return;
 800f8a6: bf00         	nop
; }
 800f8a8: 3738         	adds	r7, #0x38
 800f8aa: 46bd         	mov	sp, r7
 800f8ac: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800f8b0 <$d>:
 800f8b0: 19 86 61 18  	.word	0x18618619
 800f8b4: 00 00 00 00  	.word	0x00000000
 800f8b8: 00 24 74 49  	.word	0x49742400

0800f8bc <to16t>:
; {
 800f8bc: b480         	push	{r7}
 800f8be: b083         	sub	sp, #0xc
 800f8c0: af00         	add	r7, sp, #0x0
 800f8c2: ed87 0a01    	vstr	s0, [r7, #4]
; 	if (value > INT16_MAX) {
 800f8c6: edd7 7a01    	vldr	s15, [r7, #4]
 800f8ca: ed9f 7a11    	vldr	s14, [pc, #68]          @ 0x800f910 <to16t+0x54>
 800f8ce: eef4 7ac7    	vcmpe.f32	s15, s14
 800f8d2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800f8d6: dd02         	ble	0x800f8de <to16t+0x22>  @ imm = #0x4
; 		return INT16_MAX;
 800f8d8: f647 73ff    	movw	r3, #0x7fff
 800f8dc: e011         	b	0x800f902 <to16t+0x46>  @ imm = #0x22
; 	} else if (value < INT16_MIN) {
 800f8de: edd7 7a01    	vldr	s15, [r7, #4]
 800f8e2: ed9f 7a0c    	vldr	s14, [pc, #48]          @ 0x800f914 <to16t+0x58>
 800f8e6: eef4 7ac7    	vcmpe.f32	s15, s14
 800f8ea: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800f8ee: d501         	bpl	0x800f8f4 <to16t+0x38>  @ imm = #0x2
; 		return INT16_MIN;
 800f8f0: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800f918 <to16t+0x5c>
 800f8f2: e006         	b	0x800f902 <to16t+0x46>  @ imm = #0xc
; 		return (int16_t)value;
 800f8f4: edd7 7a01    	vldr	s15, [r7, #4]
 800f8f8: eefd 7ae7    	vcvt.s32.f32	s15, s15
 800f8fc: ee17 3a90    	vmov	r3, s15
 800f900: b21b         	sxth	r3, r3
; }
 800f902: 4618         	mov	r0, r3
 800f904: 370c         	adds	r7, #0xc
 800f906: 46bd         	mov	sp, r7
 800f908: f85d 7b04    	ldr	r7, [sp], #4
 800f90c: 4770         	bx	lr
 800f90e: bf00         	nop

0800f910 <$d>:
 800f910: 00 fe ff 46  	.word	0x46fffe00
 800f914: 00 00 00 c7  	.word	0xc7000000
 800f918: 00 80 ff ff  	.word	0xffff8000

0800f91c <canbus_id>:
; {
 800f91c: b480         	push	{r7}
 800f91e: b085         	sub	sp, #0x14
 800f920: af00         	add	r7, sp, #0x0
 800f922: 6078         	str	r0, [r7, #0x4]
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800f924: 2300         	movs	r3, #0x0
 800f926: 60fb         	str	r3, [r7, #0xc]
 800f928: e00c         	b	0x800f944 <canbus_id+0x28> @ imm = #0x18
; 		if (motor_devices[i] == dev) {
 800f92a: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800f958 <canbus_id+0x3c>
 800f92c: 68fb         	ldr	r3, [r7, #0xc]
 800f92e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800f932: 687a         	ldr	r2, [r7, #0x4]
 800f934: 429a         	cmp	r2, r3
 800f936: d102         	bne	0x800f93e <canbus_id+0x22> @ imm = #0x4
; 			return i;
 800f938: 68fb         	ldr	r3, [r7, #0xc]
 800f93a: b29b         	uxth	r3, r3
 800f93c: e006         	b	0x800f94c <canbus_id+0x30> @ imm = #0xc
; 	for (int i = 0; i < MOTOR_COUNT; i++) {
 800f93e: 68fb         	ldr	r3, [r7, #0xc]
 800f940: 3301         	adds	r3, #0x1
 800f942: 60fb         	str	r3, [r7, #0xc]
 800f944: 68fb         	ldr	r3, [r7, #0xc]
 800f946: 2b05         	cmp	r3, #0x5
 800f948: d9ef         	bls	0x800f92a <canbus_id+0xe> @ imm = #-0x22
; 	return 0;
 800f94a: 2300         	movs	r3, #0x0
; }
 800f94c: 4618         	mov	r0, r3
 800f94e: 3714         	adds	r7, #0x14
 800f950: 46bd         	mov	sp, r7
 800f952: f85d 7b04    	ldr	r7, [sp], #4
 800f956: 4770         	bx	lr

0800f958 <$d>:
 800f958: ec 05 00 20  	.word	0x200005ec

0800f95c <dji_set_speed>:
; {
 800f95c: b580         	push	{r7, lr}
 800f95e: b086         	sub	sp, #0x18
 800f960: af00         	add	r7, sp, #0x0
 800f962: 6078         	str	r0, [r7, #0x4]
 800f964: ed87 0a00    	vstr	s0, [r7]
; 	struct dji_motor_data *data = dev->data;
 800f968: 687b         	ldr	r3, [r7, #0x4]
 800f96a: 691b         	ldr	r3, [r3, #0x10]
 800f96c: 613b         	str	r3, [r7, #0x10]
; 	const struct dji_motor_config *cfg = dev->config;
 800f96e: 687b         	ldr	r3, [r7, #0x4]
 800f970: 685b         	ldr	r3, [r3, #0x4]
 800f972: 60fb         	str	r3, [r7, #0xc]
; 	if (speed_rpm > data->common.speed_limit[1]) {
 800f974: 693b         	ldr	r3, [r7, #0x10]
 800f976: edd3 7a06    	vldr	s15, [r3, #24]
 800f97a: ed97 7a00    	vldr	s14, [r7]
 800f97e: eeb4 7ae7    	vcmpe.f32	s14, s15
 800f982: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800f986: dd03         	ble	0x800f990 <dji_set_speed+0x34> @ imm = #0x6
; 		speed_rpm = data->common.speed_limit[1];
 800f988: 693b         	ldr	r3, [r7, #0x10]
 800f98a: 699b         	ldr	r3, [r3, #0x18]
 800f98c: 603b         	str	r3, [r7]
 800f98e: e00c         	b	0x800f9aa <dji_set_speed+0x4e> @ imm = #0x18
; 	} else if (speed_rpm < data->common.speed_limit[0]) {
 800f990: 693b         	ldr	r3, [r7, #0x10]
 800f992: edd3 7a05    	vldr	s15, [r3, #20]
 800f996: ed97 7a00    	vldr	s14, [r7]
 800f99a: eeb4 7ae7    	vcmpe.f32	s14, s15
 800f99e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800f9a2: d502         	bpl	0x800f9aa <dji_set_speed+0x4e> @ imm = #0x4
; 		speed_rpm = data->common.speed_limit[0];
 800f9a4: 693b         	ldr	r3, [r7, #0x10]
 800f9a6: 695b         	ldr	r3, [r3, #0x14]
 800f9a8: 603b         	str	r3, [r7]
; 	data->target_rpm = speed_rpm;
 800f9aa: 693b         	ldr	r3, [r7, #0x10]
 800f9ac: 683a         	ldr	r2, [r7]
 800f9ae: 665a         	str	r2, [r3, #0x64]
; 	for (int i = 0; i < sizeof(cfg->common.pid_datas) / sizeof(cfg->common.pid_datas[0]); i++) {
 800f9b0: 2300         	movs	r3, #0x0
 800f9b2: 617b         	str	r3, [r7, #0x14]
 800f9b4: e026         	b	0x800fa04 <dji_set_speed+0xa8> @ imm = #0x4c
; 		if (cfg->common.pid_datas[i]->pid_dev == NULL) {
 800f9b6: 68fb         	ldr	r3, [r7, #0xc]
 800f9b8: 697a         	ldr	r2, [r7, #0x14]
 800f9ba: 3210         	adds	r2, #0x10
 800f9bc: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800f9c0: 69db         	ldr	r3, [r3, #0x1c]
 800f9c2: 2b00         	cmp	r3, #0x0
 800f9c4: d022         	beq	0x800fa0c <dji_set_speed+0xb0> @ imm = #0x44
; 		if (strcmp(cfg->common.capabilities[i], "speed") == 0) {
 800f9c6: 697a         	ldr	r2, [r7, #0x14]
 800f9c8: 4613         	mov	r3, r2
 800f9ca: 005b         	lsls	r3, r3, #0x1
 800f9cc: 4413         	add	r3, r2
 800f9ce: 009b         	lsls	r3, r3, #0x2
 800f9d0: 3310         	adds	r3, #0x10
 800f9d2: 68fa         	ldr	r2, [r7, #0xc]
 800f9d4: 4413         	add	r3, r2
 800f9d6: 4910         	ldr	r1, [pc, #0x40]         @ 0x800fa18 <dji_set_speed+0xbc>
 800f9d8: 4618         	mov	r0, r3
 800f9da: f7f0 fe4b    	bl	0x8000674 <strcmp>      @ imm = #-0xf36a
 800f9de: 4603         	mov	r3, r0
 800f9e0: 2b00         	cmp	r3, #0x0
 800f9e2: d10c         	bne	0x800f9fe <dji_set_speed+0xa2> @ imm = #0x18
; 			pid_calc(cfg->common.pid_datas[i]);
 800f9e4: 68fb         	ldr	r3, [r7, #0xc]
 800f9e6: 697a         	ldr	r2, [r7, #0x14]
 800f9e8: 3210         	adds	r2, #0x10
 800f9ea: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800f9ee: 4618         	mov	r0, r3
 800f9f0: f7ff fdf0    	bl	0x800f5d4 <pid_calc>    @ imm = #-0x420
; 			data->current_mode_index = i;
 800f9f4: 697b         	ldr	r3, [r7, #0x14]
 800f9f6: b25a         	sxtb	r2, r3
 800f9f8: 693b         	ldr	r3, [r7, #0x10]
 800f9fa: f883 2032    	strb.w	r2, [r3, #0x32]
; 	for (int i = 0; i < sizeof(cfg->common.pid_datas) / sizeof(cfg->common.pid_datas[0]); i++) {
 800f9fe: 697b         	ldr	r3, [r7, #0x14]
 800fa00: 3301         	adds	r3, #0x1
 800fa02: 617b         	str	r3, [r7, #0x14]
 800fa04: 697b         	ldr	r3, [r7, #0x14]
 800fa06: 2b03         	cmp	r3, #0x3
 800fa08: d9d5         	bls	0x800f9b6 <dji_set_speed+0x5a> @ imm = #-0x56
 800fa0a: e000         	b	0x800fa0e <dji_set_speed+0xb2> @ imm = #0x0
; 			break;
 800fa0c: bf00         	nop
; 	return 0;
 800fa0e: 2300         	movs	r3, #0x0
; }
 800fa10: 4618         	mov	r0, r3
 800fa12: 3718         	adds	r7, #0x18
 800fa14: 46bd         	mov	sp, r7
 800fa16: bd80         	pop	{r7, pc}

0800fa18 <$d>:
 800fa18: f0 9d 02 08  	.word	0x08029df0

0800fa1c <dji_set_angle>:
; {
 800fa1c: b580         	push	{r7, lr}
 800fa1e: b086         	sub	sp, #0x18
 800fa20: af00         	add	r7, sp, #0x0
 800fa22: 6078         	str	r0, [r7, #0x4]
 800fa24: ed87 0a00    	vstr	s0, [r7]
; 	struct dji_motor_data *data = dev->data;
 800fa28: 687b         	ldr	r3, [r7, #0x4]
 800fa2a: 691b         	ldr	r3, [r3, #0x10]
 800fa2c: 613b         	str	r3, [r7, #0x10]
; 	const struct dji_motor_config *cfg = dev->config;
 800fa2e: 687b         	ldr	r3, [r7, #0x4]
 800fa30: 685b         	ldr	r3, [r3, #0x4]
 800fa32: 60fb         	str	r3, [r7, #0xc]
; 	data->target_angle = angle;
 800fa34: 693b         	ldr	r3, [r7, #0x10]
 800fa36: 683a         	ldr	r2, [r7]
 800fa38: 661a         	str	r2, [r3, #0x60]
; 	for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.pid_datas); i++) {
 800fa3a: 2300         	movs	r3, #0x0
 800fa3c: 617b         	str	r3, [r7, #0x14]
 800fa3e: e026         	b	0x800fa8e <dji_set_angle+0x72> @ imm = #0x4c
; 		if (cfg->common.pid_datas[i]->pid_dev == NULL) {
 800fa40: 68fb         	ldr	r3, [r7, #0xc]
 800fa42: 697a         	ldr	r2, [r7, #0x14]
 800fa44: 3210         	adds	r2, #0x10
 800fa46: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800fa4a: 69db         	ldr	r3, [r3, #0x1c]
 800fa4c: 2b00         	cmp	r3, #0x0
 800fa4e: d022         	beq	0x800fa96 <dji_set_angle+0x7a> @ imm = #0x44
; 		if (strcmp(cfg->common.capabilities[i], "angle") == 0) {
 800fa50: 697a         	ldr	r2, [r7, #0x14]
 800fa52: 4613         	mov	r3, r2
 800fa54: 005b         	lsls	r3, r3, #0x1
 800fa56: 4413         	add	r3, r2
 800fa58: 009b         	lsls	r3, r3, #0x2
 800fa5a: 3310         	adds	r3, #0x10
 800fa5c: 68fa         	ldr	r2, [r7, #0xc]
 800fa5e: 4413         	add	r3, r2
 800fa60: 4910         	ldr	r1, [pc, #0x40]         @ 0x800faa4 <dji_set_angle+0x88>
 800fa62: 4618         	mov	r0, r3
 800fa64: f7f0 fe06    	bl	0x8000674 <strcmp>      @ imm = #-0xf3f4
 800fa68: 4603         	mov	r3, r0
 800fa6a: 2b00         	cmp	r3, #0x0
 800fa6c: d10c         	bne	0x800fa88 <dji_set_angle+0x6c> @ imm = #0x18
; 			pid_calc(cfg->common.pid_datas[i]);
 800fa6e: 68fb         	ldr	r3, [r7, #0xc]
 800fa70: 697a         	ldr	r2, [r7, #0x14]
 800fa72: 3210         	adds	r2, #0x10
 800fa74: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800fa78: 4618         	mov	r0, r3
 800fa7a: f7ff fdab    	bl	0x800f5d4 <pid_calc>    @ imm = #-0x4aa
; 			data->current_mode_index = i;
 800fa7e: 697b         	ldr	r3, [r7, #0x14]
 800fa80: b25a         	sxtb	r2, r3
 800fa82: 693b         	ldr	r3, [r7, #0x10]
 800fa84: f883 2032    	strb.w	r2, [r3, #0x32]
; 	for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.pid_datas); i++) {
 800fa88: 697b         	ldr	r3, [r7, #0x14]
 800fa8a: 3301         	adds	r3, #0x1
 800fa8c: 617b         	str	r3, [r7, #0x14]
 800fa8e: 697b         	ldr	r3, [r7, #0x14]
 800fa90: 2b03         	cmp	r3, #0x3
 800fa92: d9d5         	bls	0x800fa40 <dji_set_angle+0x24> @ imm = #-0x56
 800fa94: e000         	b	0x800fa98 <dji_set_angle+0x7c> @ imm = #0x0
; 			break;
 800fa96: bf00         	nop
; 	return 0;
 800fa98: 2300         	movs	r3, #0x0
; }
 800fa9a: 4618         	mov	r0, r3
 800fa9c: 3718         	adds	r7, #0x18
 800fa9e: 46bd         	mov	sp, r7
 800faa0: bd80         	pop	{r7, pc}
 800faa2: bf00         	nop

0800faa4 <$d>:
 800faa4: f8 9d 02 08  	.word	0x08029df8

0800faa8 <dji_set_torque>:
; {
 800faa8: b580         	push	{r7, lr}
 800faaa: b086         	sub	sp, #0x18
 800faac: af00         	add	r7, sp, #0x0
 800faae: 6078         	str	r0, [r7, #0x4]
 800fab0: ed87 0a00    	vstr	s0, [r7]
; 	struct dji_motor_data *data = dev->data;
 800fab4: 687b         	ldr	r3, [r7, #0x4]
 800fab6: 691b         	ldr	r3, [r3, #0x10]
 800fab8: 613b         	str	r3, [r7, #0x10]
; 	const struct dji_motor_config *cfg = dev->config;
 800faba: 687b         	ldr	r3, [r7, #0x4]
 800fabc: 685b         	ldr	r3, [r3, #0x4]
 800fabe: 60fb         	str	r3, [r7, #0xc]
; 	if (torque > data->common.torque_limit[1]) {
 800fac0: 693b         	ldr	r3, [r7, #0x10]
 800fac2: edd3 7a08    	vldr	s15, [r3, #32]
 800fac6: ed97 7a00    	vldr	s14, [r7]
 800faca: eeb4 7ae7    	vcmpe.f32	s14, s15
 800face: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800fad2: dd03         	ble	0x800fadc <dji_set_torque+0x34> @ imm = #0x6
; 		torque = data->common.torque_limit[1];
 800fad4: 693b         	ldr	r3, [r7, #0x10]
 800fad6: 6a1b         	ldr	r3, [r3, #0x20]
 800fad8: 603b         	str	r3, [r7]
 800fada: e00c         	b	0x800faf6 <dji_set_torque+0x4e> @ imm = #0x18
; 	} else if (torque < data->common.torque_limit[0]) {
 800fadc: 693b         	ldr	r3, [r7, #0x10]
 800fade: edd3 7a07    	vldr	s15, [r3, #28]
 800fae2: ed97 7a00    	vldr	s14, [r7]
 800fae6: eeb4 7ae7    	vcmpe.f32	s14, s15
 800faea: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800faee: d502         	bpl	0x800faf6 <dji_set_torque+0x4e> @ imm = #0x4
; 		torque = data->common.torque_limit[0];
 800faf0: 693b         	ldr	r3, [r7, #0x10]
 800faf2: 69db         	ldr	r3, [r3, #0x1c]
 800faf4: 603b         	str	r3, [r7]
; 	data->target_torque = torque;
 800faf6: 693b         	ldr	r3, [r7, #0x10]
 800faf8: 683a         	ldr	r2, [r7]
 800fafa: 669a         	str	r2, [r3, #0x68]
; 	for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.pid_datas); i++) {
 800fafc: 2300         	movs	r3, #0x0
 800fafe: 617b         	str	r3, [r7, #0x14]
 800fb00: e02f         	b	0x800fb62 <dji_set_torque+0xba> @ imm = #0x5e
; 		if (cfg->common.pid_datas[i]->pid_dev == NULL) {
 800fb02: 68fb         	ldr	r3, [r7, #0xc]
 800fb04: 697a         	ldr	r2, [r7, #0x14]
 800fb06: 3210         	adds	r2, #0x10
 800fb08: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800fb0c: 69db         	ldr	r3, [r3, #0x1c]
 800fb0e: 2b00         	cmp	r3, #0x0
 800fb10: d108         	bne	0x800fb24 <dji_set_torque+0x7c> @ imm = #0x10
; 			data->current_mode_index = i + 1;
 800fb12: 697b         	ldr	r3, [r7, #0x14]
 800fb14: b2db         	uxtb	r3, r3
 800fb16: 3301         	adds	r3, #0x1
 800fb18: b2db         	uxtb	r3, r3
 800fb1a: b25a         	sxtb	r2, r3
 800fb1c: 693b         	ldr	r3, [r7, #0x10]
 800fb1e: f883 2032    	strb.w	r2, [r3, #0x32]
; 			break;
 800fb22: e021         	b	0x800fb68 <dji_set_torque+0xc0> @ imm = #0x42
; 		if (strcmp(cfg->common.capabilities[i], "torque") == 0) {
 800fb24: 697a         	ldr	r2, [r7, #0x14]
 800fb26: 4613         	mov	r3, r2
 800fb28: 005b         	lsls	r3, r3, #0x1
 800fb2a: 4413         	add	r3, r2
 800fb2c: 009b         	lsls	r3, r3, #0x2
 800fb2e: 3310         	adds	r3, #0x10
 800fb30: 68fa         	ldr	r2, [r7, #0xc]
 800fb32: 4413         	add	r3, r2
 800fb34: 490f         	ldr	r1, [pc, #0x3c]         @ 0x800fb74 <dji_set_torque+0xcc>
 800fb36: 4618         	mov	r0, r3
 800fb38: f7f0 fd9c    	bl	0x8000674 <strcmp>      @ imm = #-0xf4c8
 800fb3c: 4603         	mov	r3, r0
 800fb3e: 2b00         	cmp	r3, #0x0
 800fb40: d10c         	bne	0x800fb5c <dji_set_torque+0xb4> @ imm = #0x18
; 			pid_calc(cfg->common.pid_datas[i]);
 800fb42: 68fb         	ldr	r3, [r7, #0xc]
 800fb44: 697a         	ldr	r2, [r7, #0x14]
 800fb46: 3210         	adds	r2, #0x10
 800fb48: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800fb4c: 4618         	mov	r0, r3
 800fb4e: f7ff fd41    	bl	0x800f5d4 <pid_calc>    @ imm = #-0x57e
; 			data->current_mode_index = i;
 800fb52: 697b         	ldr	r3, [r7, #0x14]
 800fb54: b25a         	sxtb	r2, r3
 800fb56: 693b         	ldr	r3, [r7, #0x10]
 800fb58: f883 2032    	strb.w	r2, [r3, #0x32]
; 	for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.pid_datas); i++) {
 800fb5c: 697b         	ldr	r3, [r7, #0x14]
 800fb5e: 3301         	adds	r3, #0x1
 800fb60: 617b         	str	r3, [r7, #0x14]
 800fb62: 697b         	ldr	r3, [r7, #0x14]
 800fb64: 2b03         	cmp	r3, #0x3
 800fb66: d9cc         	bls	0x800fb02 <dji_set_torque+0x5a> @ imm = #-0x68
; 	return 0;
 800fb68: 2300         	movs	r3, #0x0
; }
 800fb6a: 4618         	mov	r0, r3
 800fb6c: 3718         	adds	r7, #0x18
 800fb6e: 46bd         	mov	sp, r7
 800fb70: bd80         	pop	{r7, pc}
 800fb72: bf00         	nop

0800fb74 <$d>:
 800fb74: 00 9e 02 08  	.word	0x08029e00

0800fb78 <dji_control>:
; {
 800fb78: b480         	push	{r7}
 800fb7a: b089         	sub	sp, #0x24
 800fb7c: af00         	add	r7, sp, #0x0
 800fb7e: 6078         	str	r0, [r7, #0x4]
 800fb80: 460b         	mov	r3, r1
 800fb82: 70fb         	strb	r3, [r7, #0x3]
; 	struct dji_motor_data *data = dev->data;
 800fb84: 687b         	ldr	r3, [r7, #0x4]
 800fb86: 691b         	ldr	r3, [r3, #0x10]
 800fb88: 61fb         	str	r3, [r7, #0x1c]
; 	const struct dji_motor_config *cfg = dev->config;
 800fb8a: 687b         	ldr	r3, [r7, #0x4]
 800fb8c: 685b         	ldr	r3, [r3, #0x4]
 800fb8e: 61bb         	str	r3, [r7, #0x18]
; 	frame.id = cfg->common.tx_id;
 800fb90: 69bb         	ldr	r3, [r7, #0x18]
 800fb92: 689b         	ldr	r3, [r3, #0x8]
 800fb94: 60bb         	str	r3, [r7, #0x8]
; 	switch (cmd) {
 800fb96: 78fb         	ldrb	r3, [r7, #0x3]
 800fb98: 2b04         	cmp	r3, #0x4
 800fb9a: d82a         	bhi	0x800fbf2 <dji_control+0x7a> @ imm = #0x54
 800fb9c: a201         	adr	r2, #4 <dji_control+0x29>
 800fb9e: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800fba2: bf00         	nop

0800fba4 <$d>:
 800fba4: b9 fb 00 08  	.word	0x0800fbb9
 800fba8: c3 fb 00 08  	.word	0x0800fbc3
 800fbac: cd fb 00 08  	.word	0x0800fbcd
 800fbb0: f1 fb 00 08  	.word	0x0800fbf1
 800fbb4: df fb 00 08  	.word	0x0800fbdf

0800fbb8 <$t>:
; 		data->online = true;
 800fbb8: 69fb         	ldr	r3, [r7, #0x1c]
 800fbba: 2201         	movs	r2, #0x1
 800fbbc: f883 2030    	strb.w	r2, [r3, #0x30]
; 		break;
 800fbc0: e017         	b	0x800fbf2 <dji_control+0x7a> @ imm = #0x2e
; 		data->online = false;
 800fbc2: 69fb         	ldr	r3, [r7, #0x1c]
 800fbc4: 2200         	movs	r2, #0x0
 800fbc6: f883 2030    	strb.w	r2, [r3, #0x30]
; 		break;
 800fbca: e012         	b	0x800fbf2 <dji_control+0x7a> @ imm = #0x24
; 		data->angle_add = 0;
 800fbcc: 69fb         	ldr	r3, [r7, #0x1c]
 800fbce: f04f 0200    	mov.w	r2, #0x0
 800fbd2: 641a         	str	r2, [r3, #0x40]
; 		data->common.angle = 0;
 800fbd4: 69fb         	ldr	r3, [r7, #0x1c]
 800fbd6: f04f 0200    	mov.w	r2, #0x0
 800fbda: 601a         	str	r2, [r3]
; 		break;
 800fbdc: e009         	b	0x800fbf2 <dji_control+0x7a> @ imm = #0x12
; 		data->missed_times = 0;
 800fbde: 69fb         	ldr	r3, [r7, #0x1c]
 800fbe0: 2200         	movs	r2, #0x0
 800fbe2: f883 204c    	strb.w	r2, [r3, #0x4c]
; 		data->online = true;
 800fbe6: 69fb         	ldr	r3, [r7, #0x1c]
 800fbe8: 2201         	movs	r2, #0x1
 800fbea: f883 2030    	strb.w	r2, [r3, #0x30]
; 		break;
 800fbee: e000         	b	0x800fbf2 <dji_control+0x7a> @ imm = #0x0
; 		break;
 800fbf0: bf00         	nop
; }
 800fbf2: bf00         	nop
 800fbf4: 3724         	adds	r7, #0x24
 800fbf6: 46bd         	mov	sp, r7
 800fbf8: f85d 7b04    	ldr	r7, [sp], #4
 800fbfc: 4770         	bx	lr
 800fbfe: bf00         	nop

0800fc00 <dji_get_angle>:
; {
 800fc00: b580         	push	{r7, lr}
 800fc02: b084         	sub	sp, #0x10
 800fc04: af00         	add	r7, sp, #0x0
 800fc06: 6078         	str	r0, [r7, #0x4]
; 	struct dji_motor_data *data = dev->data;
 800fc08: 687b         	ldr	r3, [r7, #0x4]
 800fc0a: 691b         	ldr	r3, [r3, #0x10]
 800fc0c: 60fb         	str	r3, [r7, #0xc]
; 	return fmodf(data->common.angle, 360.0f);
 800fc0e: 68fb         	ldr	r3, [r7, #0xc]
 800fc10: edd3 7a00    	vldr	s15, [r3]
 800fc14: eddf 0a06    	vldr	s1, [pc, #24]           @ 0x800fc30 <dji_get_angle+0x30>
 800fc18: eeb0 0a67    	vmov.f32	s0, s15
 800fc1c: f009 f9fe    	bl	0x801901c <fmodf>       @ imm = #0x93fc
 800fc20: eef0 7a40    	vmov.f32	s15, s0
; }
 800fc24: eeb0 0a67    	vmov.f32	s0, s15
 800fc28: 3710         	adds	r7, #0x10
 800fc2a: 46bd         	mov	sp, r7
 800fc2c: bd80         	pop	{r7, pc}
 800fc2e: bf00         	nop

0800fc30 <$d>:
 800fc30: 00 00 b4 43  	.word	0x43b40000

0800fc34 <dji_init>:
; {
 800fc34: b580         	push	{r7, lr}
 800fc36: b08e         	sub	sp, #0x38
 800fc38: af04         	add	r7, sp, #0x10
 800fc3a: 6078         	str	r0, [r7, #0x4]
; 	if (dev) {
 800fc3c: 687b         	ldr	r3, [r7, #0x4]
 800fc3e: 2b00         	cmp	r3, #0x0
 800fc40: f000 8184    	beq.w	0x800ff4c <dji_init+0x318> @ imm = #0x308
; 		const struct dji_motor_config *cfg = dev->config;
 800fc44: 687b         	ldr	r3, [r7, #0x4]
 800fc46: 685b         	ldr	r3, [r3, #0x4]
 800fc48: 623b         	str	r3, [r7, #0x20]
; 		struct dji_motor_data *data = dev->data;
 800fc4a: 687b         	ldr	r3, [r7, #0x4]
 800fc4c: 691b         	ldr	r3, [r3, #0x10]
 800fc4e: 61fb         	str	r3, [r7, #0x1c]
; 		uint8_t frame_id = frames_id(cfg->common.tx_id);
 800fc50: 6a3b         	ldr	r3, [r7, #0x20]
 800fc52: 689b         	ldr	r3, [r3, #0x8]
 800fc54: 4618         	mov	r0, r3
 800fc56: f013 fe9b    	bl	0x8023990 <frames_id>   @ imm = #0x13d36
 800fc5a: 4603         	mov	r3, r0
 800fc5c: 76fb         	strb	r3, [r7, #0x1b]
; 		uint8_t id = motor_id(dev);
 800fc5e: 6878         	ldr	r0, [r7, #0x4]
 800fc60: f013 feed    	bl	0x8023a3e <motor_id>    @ imm = #0x13dda
 800fc64: 4603         	mov	r3, r0
 800fc66: 76bb         	strb	r3, [r7, #0x1a]
; 		data->ctrl_struct->mask[frame_id] |= 1 << id;
 800fc68: 69fb         	ldr	r3, [r7, #0x1c]
 800fc6a: 6ada         	ldr	r2, [r3, #0x2c]
 800fc6c: 7efb         	ldrb	r3, [r7, #0x1b]
 800fc6e: 4413         	add	r3, r2
 800fc70: f893 303e    	ldrb.w	r3, [r3, #0x3e]
 800fc74: b25a         	sxtb	r2, r3
 800fc76: 7ebb         	ldrb	r3, [r7, #0x1a]
 800fc78: 2101         	movs	r1, #0x1
 800fc7a: fa01 f303    	lsl.w	r3, r1, r3
 800fc7e: b25b         	sxtb	r3, r3
 800fc80: 4313         	orrs	r3, r2
 800fc82: b259         	sxtb	r1, r3
 800fc84: 69fb         	ldr	r3, [r7, #0x1c]
 800fc86: 6ada         	ldr	r2, [r3, #0x2c]
 800fc88: 7efb         	ldrb	r3, [r7, #0x1b]
 800fc8a: b2c9         	uxtb	r1, r1
 800fc8c: 4413         	add	r3, r2
 800fc8e: 460a         	mov	r2, r1
 800fc90: f883 203e    	strb.w	r2, [r3, #0x3e]
; 		data->ctrl_struct->rx_ids[id] = cfg->common.rx_id;
 800fc94: 69fb         	ldr	r3, [r7, #0x1c]
 800fc96: 6ad9         	ldr	r1, [r3, #0x2c]
 800fc98: 7ebb         	ldrb	r3, [r7, #0x1a]
 800fc9a: 6a3a         	ldr	r2, [r7, #0x20]
 800fc9c: 68d2         	ldr	r2, [r2, #0xc]
 800fc9e: 009b         	lsls	r3, r3, #0x2
 800fca0: 440b         	add	r3, r1
 800fca2: 605a         	str	r2, [r3, #0x4]
; 		data->ctrl_struct->full_handle.handler = dji_tx_handler;
 800fca4: 69fb         	ldr	r3, [r7, #0x1c]
 800fca6: 6adb         	ldr	r3, [r3, #0x2c]
 800fca8: 4aab         	ldr	r2, [pc, #0x2ac]        @ 0x800ff58 <dji_init+0x324>
 800fcaa: 669a         	str	r2, [r3, #0x68]
; 		data->online = true;
 800fcac: 69fb         	ldr	r3, [r7, #0x1c]
 800fcae: 2201         	movs	r2, #0x1
 800fcb0: f883 2030    	strb.w	r2, [r3, #0x30]
; 		for (int i = 0;
 800fcb4: 2300         	movs	r3, #0x0
 800fcb6: 627b         	str	r3, [r7, #0x24]
 800fcb8: e0bd         	b	0x800fe36 <dji_init+0x202> @ imm = #0x17a
; 			if (cfg->common.pid_datas[i]->pid_dev == NULL) {
 800fcba: 6a3b         	ldr	r3, [r7, #0x20]
 800fcbc: 6a7a         	ldr	r2, [r7, #0x24]
 800fcbe: 3210         	adds	r2, #0x10
 800fcc0: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 800fcc4: 69db         	ldr	r3, [r3, #0x1c]
 800fcc6: 2b00         	cmp	r3, #0x0
 800fcc8: d110         	bne	0x800fcec <dji_init+0xb8> @ imm = #0x20
; 				if (i > 0) {
 800fcca: 6a7b         	ldr	r3, [r7, #0x24]
 800fccc: 2b00         	cmp	r3, #0x0
 800fcce: f340 80b7    	ble.w	0x800fe40 <dji_init+0x20c> @ imm = #0x16e
; 					pid_reg_output(cfg->common.pid_datas[i - 1],
 800fcd2: 6a7b         	ldr	r3, [r7, #0x24]
 800fcd4: 1e5a         	subs	r2, r3, #0x1
 800fcd6: 6a3b         	ldr	r3, [r7, #0x20]
 800fcd8: 3210         	adds	r2, #0x10
 800fcda: f853 2022    	ldr.w	r2, [r3, r2, lsl #2]
 800fcde: 69fb         	ldr	r3, [r7, #0x1c]
 800fce0: 3368         	adds	r3, #0x68
 800fce2: 4619         	mov	r1, r3
 800fce4: 4610         	mov	r0, r2
 800fce6: f013 fd73    	bl	0x80237d0 <pid_reg_output> @ imm = #0x13ae6
; 				break;
 800fcea: e0a9         	b	0x800fe40 <dji_init+0x20c> @ imm = #0x152
; 			if (strcmp(cfg->common.capabilities[i], "speed") == 0) {
 800fcec: 6a7a         	ldr	r2, [r7, #0x24]
 800fcee: 4613         	mov	r3, r2
 800fcf0: 005b         	lsls	r3, r3, #0x1
 800fcf2: 4413         	add	r3, r2
 800fcf4: 009b         	lsls	r3, r3, #0x2
 800fcf6: 3310         	adds	r3, #0x10
 800fcf8: 6a3a         	ldr	r2, [r7, #0x20]
 800fcfa: 4413         	add	r3, r2
 800fcfc: 4997         	ldr	r1, [pc, #0x25c]        @ 0x800ff5c <dji_init+0x328>
 800fcfe: 4618         	mov	r0, r3
 800fd00: f7f0 fcb8    	bl	0x8000674 <strcmp>      @ imm = #-0xf690
 800fd04: 4603         	mov	r3, r0
 800fd06: 2b00         	cmp	r3, #0x0
 800fd08: d11b         	bne	0x800fd42 <dji_init+0x10e> @ imm = #0x36
; 				pid_reg_input(cfg->common.pid_datas[i], &data->common.rpm,
 800fd0a: 6a3b         	ldr	r3, [r7, #0x20]
 800fd0c: 6a7a         	ldr	r2, [r7, #0x24]
 800fd0e: 3210         	adds	r2, #0x10
 800fd10: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 800fd14: 69fb         	ldr	r3, [r7, #0x1c]
 800fd16: 1d19         	adds	r1, r3, #0x4
 800fd18: 69fb         	ldr	r3, [r7, #0x1c]
 800fd1a: 3364         	adds	r3, #0x64
 800fd1c: 461a         	mov	r2, r3
 800fd1e: f013 fd41    	bl	0x80237a4 <pid_reg_input> @ imm = #0x13a82
; 				if (i > 0) {
 800fd22: 6a7b         	ldr	r3, [r7, #0x24]
 800fd24: 2b00         	cmp	r3, #0x0
 800fd26: dd76         	ble	0x800fe16 <dji_init+0x1e2> @ imm = #0xec
; 					pid_reg_output(cfg->common.pid_datas[i - 1],
 800fd28: 6a7b         	ldr	r3, [r7, #0x24]
 800fd2a: 1e5a         	subs	r2, r3, #0x1
 800fd2c: 6a3b         	ldr	r3, [r7, #0x20]
 800fd2e: 3210         	adds	r2, #0x10
 800fd30: f853 2022    	ldr.w	r2, [r3, r2, lsl #2]
 800fd34: 69fb         	ldr	r3, [r7, #0x1c]
 800fd36: 3364         	adds	r3, #0x64
 800fd38: 4619         	mov	r1, r3
 800fd3a: 4610         	mov	r0, r2
 800fd3c: f013 fd48    	bl	0x80237d0 <pid_reg_output> @ imm = #0x13a90
 800fd40: e069         	b	0x800fe16 <dji_init+0x1e2> @ imm = #0xd2
; 			} else if (strcmp(cfg->common.capabilities[i], "angle") == 0) {
 800fd42: 6a7a         	ldr	r2, [r7, #0x24]
 800fd44: 4613         	mov	r3, r2
 800fd46: 005b         	lsls	r3, r3, #0x1
 800fd48: 4413         	add	r3, r2
 800fd4a: 009b         	lsls	r3, r3, #0x2
 800fd4c: 3310         	adds	r3, #0x10
 800fd4e: 6a3a         	ldr	r2, [r7, #0x20]
 800fd50: 4413         	add	r3, r2
 800fd52: 4983         	ldr	r1, [pc, #0x20c]        @ 0x800ff60 <dji_init+0x32c>
 800fd54: 4618         	mov	r0, r3
 800fd56: f7f0 fc8d    	bl	0x8000674 <strcmp>      @ imm = #-0xf6e6
 800fd5a: 4603         	mov	r3, r0
 800fd5c: 2b00         	cmp	r3, #0x0
 800fd5e: d10d         	bne	0x800fd7c <dji_init+0x148> @ imm = #0x1a
; 				pid_reg_input(cfg->common.pid_datas[i], &data->pid_angle_input,
 800fd60: 6a3b         	ldr	r3, [r7, #0x20]
 800fd62: 6a7a         	ldr	r2, [r7, #0x24]
 800fd64: 3210         	adds	r2, #0x10
 800fd66: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 800fd6a: 69fb         	ldr	r3, [r7, #0x1c]
 800fd6c: f103 0154    	add.w	r1, r3, #0x54
 800fd70: 69fb         	ldr	r3, [r7, #0x1c]
 800fd72: 3358         	adds	r3, #0x58
 800fd74: 461a         	mov	r2, r3
 800fd76: f013 fd15    	bl	0x80237a4 <pid_reg_input> @ imm = #0x13a2a
 800fd7a: e04c         	b	0x800fe16 <dji_init+0x1e2> @ imm = #0x98
; 			} else if (strcmp(cfg->common.capabilities[i], "torque") == 0) {
 800fd7c: 6a7a         	ldr	r2, [r7, #0x24]
 800fd7e: 4613         	mov	r3, r2
 800fd80: 005b         	lsls	r3, r3, #0x1
 800fd82: 4413         	add	r3, r2
 800fd84: 009b         	lsls	r3, r3, #0x2
 800fd86: 3310         	adds	r3, #0x10
 800fd88: 6a3a         	ldr	r2, [r7, #0x20]
 800fd8a: 4413         	add	r3, r2
 800fd8c: 4975         	ldr	r1, [pc, #0x1d4]        @ 0x800ff64 <dji_init+0x330>
 800fd8e: 4618         	mov	r0, r3
 800fd90: f7f0 fc70    	bl	0x8000674 <strcmp>      @ imm = #-0xf720
 800fd94: 4603         	mov	r3, r0
 800fd96: 2b00         	cmp	r3, #0x0
 800fd98: d11c         	bne	0x800fdd4 <dji_init+0x1a0> @ imm = #0x38
; 				pid_reg_input(cfg->common.pid_datas[i], &data->common.torque,
 800fd9a: 6a3b         	ldr	r3, [r7, #0x20]
 800fd9c: 6a7a         	ldr	r2, [r7, #0x24]
 800fd9e: 3210         	adds	r2, #0x10
 800fda0: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 800fda4: 69fb         	ldr	r3, [r7, #0x1c]
 800fda6: f103 0108    	add.w	r1, r3, #0x8
 800fdaa: 69fb         	ldr	r3, [r7, #0x1c]
 800fdac: 3368         	adds	r3, #0x68
 800fdae: 461a         	mov	r2, r3
 800fdb0: f013 fcf8    	bl	0x80237a4 <pid_reg_input> @ imm = #0x139f0
; 				if (i > 0) {
 800fdb4: 6a7b         	ldr	r3, [r7, #0x24]
 800fdb6: 2b00         	cmp	r3, #0x0
 800fdb8: dd2d         	ble	0x800fe16 <dji_init+0x1e2> @ imm = #0x5a
; 					pid_reg_output(cfg->common.pid_datas[i - 1],
 800fdba: 6a7b         	ldr	r3, [r7, #0x24]
 800fdbc: 1e5a         	subs	r2, r3, #0x1
 800fdbe: 6a3b         	ldr	r3, [r7, #0x20]
 800fdc0: 3210         	adds	r2, #0x10
 800fdc2: f853 2022    	ldr.w	r2, [r3, r2, lsl #2]
 800fdc6: 69fb         	ldr	r3, [r7, #0x1c]
 800fdc8: 3368         	adds	r3, #0x68
 800fdca: 4619         	mov	r1, r3
 800fdcc: 4610         	mov	r0, r2
 800fdce: f013 fcff    	bl	0x80237d0 <pid_reg_output> @ imm = #0x139fe
 800fdd2: e020         	b	0x800fe16 <dji_init+0x1e2> @ imm = #0x40
; 				LOG_ERR("Unsupported motor mode");
 800fdd4: 2304         	movs	r3, #0x4
 800fdd6: 2b00         	cmp	r3, #0x0
 800fdd8: d017         	beq	0x800fe0a <dji_init+0x1d6> @ imm = #0x2e
 800fdda: 2301         	movs	r3, #0x1
 800fddc: 767b         	strb	r3, [r7, #0x19]
 800fdde: 7e7b         	ldrb	r3, [r7, #0x19]
 800fde0: f083 0301    	eor	r3, r3, #0x1
 800fde4: b2db         	uxtb	r3, r3
 800fde6: 2b00         	cmp	r3, #0x0
 800fde8: d111         	bne	0x800fe0e <dji_init+0x1da> @ imm = #0x22
 800fdea: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800ff68 <dji_init+0x334>
 800fdec: 6819         	ldr	r1, [r3]
 800fdee: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800ff6c <dji_init+0x338>
 800fdf0: 9302         	str	r3, [sp, #0x8]
 800fdf2: 2300         	movs	r3, #0x0
 800fdf4: 9301         	str	r3, [sp, #0x4]
 800fdf6: 2300         	movs	r3, #0x0
 800fdf8: 9300         	str	r3, [sp]
 800fdfa: 2300         	movs	r3, #0x0
 800fdfc: 2201         	movs	r2, #0x1
 800fdfe: 2000         	movs	r0, #0x0
 800fe00: f013 fd76    	bl	0x80238f0 <z_log_msg_runtime_create> @ imm = #0x13aec
 800fe04: 2300         	movs	r3, #0x0
 800fe06: 617b         	str	r3, [r7, #0x14]
 800fe08: e002         	b	0x800fe10 <dji_init+0x1dc> @ imm = #0x4
 800fe0a: bf00         	nop
 800fe0c: e000         	b	0x800fe10 <dji_init+0x1dc> @ imm = #0x0
 800fe0e: bf00         	nop
; 				return -1;
 800fe10: f04f 33ff    	mov.w	r3, #0xffffffff
 800fe14: e09b         	b	0x800ff4e <dji_init+0x31a> @ imm = #0x136
; 			pid_reg_time(cfg->common.pid_datas[i], &(data->curr_time),
 800fe16: 6a3b         	ldr	r3, [r7, #0x20]
 800fe18: 6a7a         	ldr	r2, [r7, #0x24]
 800fe1a: 3210         	adds	r2, #0x10
 800fe1c: f853 0022    	ldr.w	r0, [r3, r2, lsl #2]
 800fe20: 69fb         	ldr	r3, [r7, #0x1c]
 800fe22: f103 0144    	add.w	r1, r3, #0x44
 800fe26: 69fb         	ldr	r3, [r7, #0x1c]
 800fe28: 3348         	adds	r3, #0x48
 800fe2a: 461a         	mov	r2, r3
 800fe2c: f013 fce2    	bl	0x80237f4 <pid_reg_time> @ imm = #0x139c4
; 		     i < sizeof(cfg->common.pid_datas) / sizeof(cfg->common.pid_datas[0]); i++) {
 800fe30: 6a7b         	ldr	r3, [r7, #0x24]
 800fe32: 3301         	adds	r3, #0x1
 800fe34: 627b         	str	r3, [r7, #0x24]
 800fe36: 6a7b         	ldr	r3, [r7, #0x24]
 800fe38: 2b03         	cmp	r3, #0x3
 800fe3a: f67f af3e    	bls.w	0x800fcba <dji_init+0x86> @ imm = #-0x184
 800fe3e: e000         	b	0x800fe42 <dji_init+0x20e> @ imm = #0x0
; 				break;
 800fe40: bf00         	nop
; 		data->current_mode_index = 0;
 800fe42: 69fb         	ldr	r3, [r7, #0x1c]
 800fe44: 2200         	movs	r2, #0x0
 800fe46: f883 2032    	strb.w	r2, [r3, #0x32]
; 		data->ctrl_struct->motor_devs[id] = (struct device *)dev;
 800fe4a: 69fb         	ldr	r3, [r7, #0x1c]
 800fe4c: 6ada         	ldr	r2, [r3, #0x2c]
 800fe4e: 7ebb         	ldrb	r3, [r7, #0x1a]
 800fe50: 3310         	adds	r3, #0x10
 800fe52: 009b         	lsls	r3, r3, #0x2
 800fe54: 4413         	add	r3, r2
 800fe56: 687a         	ldr	r2, [r7, #0x4]
 800fe58: 605a         	str	r2, [r3, #0x4]
; 		data->prev_time = 0;
 800fe5a: 69fb         	ldr	r3, [r7, #0x1c]
 800fe5c: 2200         	movs	r2, #0x0
 800fe5e: 649a         	str	r2, [r3, #0x48]
; 		data->ctrl_struct->flags = 0;
 800fe60: 69fb         	ldr	r3, [r7, #0x1c]
 800fe62: 6adb         	ldr	r3, [r3, #0x2c]
 800fe64: 2200         	movs	r2, #0x0
 800fe66: f883 203d    	strb.w	r2, [r3, #0x3d]
; 		data->ctrl_struct->mapping[frame_id][id % 4] = id;
 800fe6a: 69fb         	ldr	r3, [r7, #0x1c]
 800fe6c: 6ad9         	ldr	r1, [r3, #0x2c]
 800fe6e: 7efa         	ldrb	r2, [r7, #0x1b]
 800fe70: 7ebb         	ldrb	r3, [r7, #0x1a]
 800fe72: f003 0303    	and	r3, r3, #0x3
 800fe76: 0092         	lsls	r2, r2, #0x2
 800fe78: 440a         	add	r2, r1
 800fe7a: 4413         	add	r3, r2
 800fe7c: 3329         	adds	r3, #0x29
 800fe7e: 7eba         	ldrb	r2, [r7, #0x1a]
 800fe80: 701a         	strb	r2, [r3]
; 		if (cfg->is_gm6020) {
 800fe82: 6a3b         	ldr	r3, [r7, #0x20]
 800fe84: f893 3054    	ldrb.w	r3, [r3, #0x54]
 800fe88: 2b00         	cmp	r3, #0x0
 800fe8a: d004         	beq	0x800fe96 <dji_init+0x262> @ imm = #0x8
; 			data->convert_num = GM6020_CONVERT_NUM;
 800fe8c: 69fb         	ldr	r3, [r7, #0x1c]
 800fe8e: 2201         	movs	r2, #0x1
 800fe90: f883 2031    	strb.w	r2, [r3, #0x31]
 800fe94: e031         	b	0x800fefa <dji_init+0x2c6> @ imm = #0x62
; 		} else if (cfg->is_m3508) {
 800fe96: 6a3b         	ldr	r3, [r7, #0x20]
 800fe98: f893 3055    	ldrb.w	r3, [r3, #0x55]
 800fe9c: 2b00         	cmp	r3, #0x0
 800fe9e: d004         	beq	0x800feaa <dji_init+0x276> @ imm = #0x8
; 			data->convert_num = M3508_CONVERT_NUM;
 800fea0: 69fb         	ldr	r3, [r7, #0x1c]
 800fea2: 2200         	movs	r2, #0x0
 800fea4: f883 2031    	strb.w	r2, [r3, #0x31]
 800fea8: e027         	b	0x800fefa <dji_init+0x2c6> @ imm = #0x4e
; 		} else if (cfg->is_m2006) {
 800feaa: 6a3b         	ldr	r3, [r7, #0x20]
 800feac: f893 3056    	ldrb.w	r3, [r3, #0x56]
 800feb0: 2b00         	cmp	r3, #0x0
 800feb2: d004         	beq	0x800febe <dji_init+0x28a> @ imm = #0x8
; 			data->convert_num = M2006_CONVERT_NUM;
 800feb4: 69fb         	ldr	r3, [r7, #0x1c]
 800feb6: 2202         	movs	r2, #0x2
 800feb8: f883 2031    	strb.w	r2, [r3, #0x31]
 800febc: e01d         	b	0x800fefa <dji_init+0x2c6> @ imm = #0x3a
; 			LOG_ERR("Unsupported motor type");
 800febe: 2304         	movs	r3, #0x4
 800fec0: 2b00         	cmp	r3, #0x0
 800fec2: d017         	beq	0x800fef4 <dji_init+0x2c0> @ imm = #0x2e
 800fec4: 2301         	movs	r3, #0x1
 800fec6: 74fb         	strb	r3, [r7, #0x13]
 800fec8: 7cfb         	ldrb	r3, [r7, #0x13]
 800feca: f083 0301    	eor	r3, r3, #0x1
 800fece: b2db         	uxtb	r3, r3
 800fed0: 2b00         	cmp	r3, #0x0
 800fed2: d111         	bne	0x800fef8 <dji_init+0x2c4> @ imm = #0x22
 800fed4: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800ff68 <dji_init+0x334>
 800fed6: 6819         	ldr	r1, [r3]
 800fed8: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800ff70 <dji_init+0x33c>
 800feda: 9302         	str	r3, [sp, #0x8]
 800fedc: 2300         	movs	r3, #0x0
 800fede: 9301         	str	r3, [sp, #0x4]
 800fee0: 2300         	movs	r3, #0x0
 800fee2: 9300         	str	r3, [sp]
 800fee4: 2300         	movs	r3, #0x0
 800fee6: 2201         	movs	r2, #0x1
 800fee8: 2000         	movs	r0, #0x0
 800feea: f013 fd01    	bl	0x80238f0 <z_log_msg_runtime_create> @ imm = #0x13a02
 800feee: 2300         	movs	r3, #0x0
 800fef0: 60fb         	str	r3, [r7, #0xc]
 800fef2: e002         	b	0x800fefa <dji_init+0x2c6> @ imm = #0x4
 800fef4: bf00         	nop
 800fef6: e000         	b	0x800fefa <dji_init+0x2c6> @ imm = #0x0
 800fef8: bf00         	nop
; 		if (!device_is_ready(cfg->common.phy)) {
 800fefa: 6a3b         	ldr	r3, [r7, #0x20]
 800fefc: 681b         	ldr	r3, [r3]
 800fefe: 4618         	mov	r0, r3
 800ff00: f013 fc44    	bl	0x802378c <device_is_ready> @ imm = #0x13888
 800ff04: 4603         	mov	r3, r0
 800ff06: f083 0301    	eor	r3, r3, #0x1
 800ff0a: b2db         	uxtb	r3, r3
 800ff0c: 2b00         	cmp	r3, #0x0
 800ff0e: d002         	beq	0x800ff16 <dji_init+0x2e2> @ imm = #0x4
; 			return -1;
 800ff10: f04f 33ff    	mov.w	r3, #0xffffffff
 800ff14: e01b         	b	0x800ff4e <dji_init+0x31a> @ imm = #0x36
; 		if (dji_miss_handle_timer.expiry_fn == NULL) {
 800ff16: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800ff74 <dji_init+0x340>
 800ff18: 6a1b         	ldr	r3, [r3, #0x20]
 800ff1a: 2b00         	cmp	r3, #0x0
 800ff1c: d116         	bne	0x800ff4c <dji_init+0x318> @ imm = #0x2c
; 			k_work_queue_init(&dji_work_queue);
 800ff1e: 4816         	ldr	r0, [pc, #0x58]         @ 0x800ff78 <dji_init+0x344>
 800ff20: f016 f855    	bl	0x8025fce <k_work_queue_init> @ imm = #0x160aa
; 			k_timer_init(&dji_miss_handle_timer, dji_init_isr_handler, NULL);
 800ff24: 2200         	movs	r2, #0x0
 800ff26: 4915         	ldr	r1, [pc, #0x54]         @ 0x800ff7c <dji_init+0x348>
 800ff28: 4812         	ldr	r0, [pc, #0x48]         @ 0x800ff74 <dji_init+0x340>
 800ff2a: f017 f9b9    	bl	0x80272a0 <k_timer_init> @ imm = #0x17372
; 			k_timer_start(&dji_miss_handle_timer, K_MSEC(100), K_MSEC(4));
 800ff2e: f44f 707a    	mov.w	r0, #0x3e8
 800ff32: f04f 0100    	mov.w	r1, #0x0
 800ff36: f04f 0228    	mov.w	r2, #0x28
 800ff3a: f04f 0300    	mov.w	r3, #0x0
 800ff3e: e9cd 2300    	strd	r2, r3, [sp]
 800ff42: 4602         	mov	r2, r0
 800ff44: 460b         	mov	r3, r1
 800ff46: 480b         	ldr	r0, [pc, #0x2c]         @ 0x800ff74 <dji_init+0x340>
 800ff48: f013 fc89    	bl	0x802385e <k_timer_start> @ imm = #0x13912
; 	return 0;
 800ff4c: 2300         	movs	r3, #0x0
; }
 800ff4e: 4618         	mov	r0, r3
 800ff50: 3728         	adds	r7, #0x28
 800ff52: 46bd         	mov	sp, r7
 800ff54: bd80         	pop	{r7, pc}
 800ff56: bf00         	nop

0800ff58 <$d>:
 800ff58: a5 0b 01 08  	.word	0x08010ba5
 800ff5c: f0 9d 02 08  	.word	0x08029df0
 800ff60: f8 9d 02 08  	.word	0x08029df8
 800ff64: 00 9e 02 08  	.word	0x08029e00
 800ff68: e8 05 00 20  	.word	0x200005e8
 800ff6c: 08 9e 02 08  	.word	0x08029e08
 800ff70: 20 9e 02 08  	.word	0x08029e20
 800ff74: f8 0b 00 20  	.word	0x20000bf8
 800ff78: 58 23 00 20  	.word	0x20002358
 800ff7c: e5 09 01 08  	.word	0x080109e5

0800ff80 <can_rx_callback>:
; {
 800ff80: b590         	push	{r4, r7, lr}
 800ff82: b0a9         	sub	sp, #0xa4
 800ff84: af06         	add	r7, sp, #0x18
 800ff86: 60f8         	str	r0, [r7, #0xc]
 800ff88: 60b9         	str	r1, [r7, #0x8]
 800ff8a: 607a         	str	r2, [r7, #0x4]
; 	uint32_t curr_time = k_cycle_get_32();
 800ff8c: f013 fc4f    	bl	0x802382e <k_cycle_get_32> @ imm = #0x1389e
 800ff90: f8c7 0084    	str.w	r0, [r7, #0x84]
; 	struct motor_controller *ctrl_struct = (struct motor_controller *)user_data;
 800ff94: 687b         	ldr	r3, [r7, #0x4]
 800ff96: 677b         	str	r3, [r7, #0x74]
; 	struct can_frame rx_frame = *frame;
 800ff98: 68bb         	ldr	r3, [r7, #0x8]
 800ff9a: f107 0418    	add.w	r4, r7, #0x18
 800ff9e: cb0f         	ldm	r3, {r0, r1, r2, r3}
 800ffa0: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
; 	uint8_t id = (rx_frame.id & 0xF) - 1;
 800ffa4: 69bb         	ldr	r3, [r7, #0x18]
 800ffa6: b2db         	uxtb	r3, r3
 800ffa8: f003 030f    	and	r3, r3, #0xf
 800ffac: b2db         	uxtb	r3, r3
 800ffae: 3b01         	subs	r3, #0x1
 800ffb0: f887 307b    	strb.w	r3, [r7, #0x7b]
; 	if (ctrl_struct->rx_ids[id] != rx_frame.id && id >= 4) {
 800ffb4: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 800ffb8: 6f7a         	ldr	r2, [r7, #0x74]
 800ffba: 009b         	lsls	r3, r3, #0x2
 800ffbc: 4413         	add	r3, r2
 800ffbe: 685b         	ldr	r3, [r3, #0x4]
 800ffc0: 461a         	mov	r2, r3
 800ffc2: 69bb         	ldr	r3, [r7, #0x18]
 800ffc4: 429a         	cmp	r2, r3
 800ffc6: d008         	beq	0x800ffda <can_rx_callback+0x5a> @ imm = #0x10
 800ffc8: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 800ffcc: 2b03         	cmp	r3, #0x3
 800ffce: d904         	bls	0x800ffda <can_rx_callback+0x5a> @ imm = #0x8
; 		id -= 4;
 800ffd0: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 800ffd4: 3b04         	subs	r3, #0x4
 800ffd6: f887 307b    	strb.w	r3, [r7, #0x7b]
; 	if (ctrl_struct->rx_ids[id] != rx_frame.id) {
 800ffda: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 800ffde: 6f7a         	ldr	r2, [r7, #0x74]
 800ffe0: 009b         	lsls	r3, r3, #0x2
 800ffe2: 4413         	add	r3, r2
 800ffe4: 685b         	ldr	r3, [r3, #0x4]
 800ffe6: 461a         	mov	r2, r3
 800ffe8: 69bb         	ldr	r3, [r7, #0x18]
 800ffea: 429a         	cmp	r2, r3
 800ffec: d02d         	beq	0x801004a <can_rx_callback+0xca> @ imm = #0x5a
; 		LOG_ERR("Unknown motor ID: %d, database: %d, received: %d", id,
 800ffee: 2304         	movs	r3, #0x4
 800fff0: 2b00         	cmp	r3, #0x0
 800fff2: d026         	beq	0x8010042 <can_rx_callback+0xc2> @ imm = #0x4c
 800fff4: 2301         	movs	r3, #0x1
 800fff6: f887 3059    	strb.w	r3, [r7, #0x59]
 800fffa: f897 3059    	ldrb.w	r3, [r7, #0x59]
 800fffe: f083 0301    	eor	r3, r3, #0x1
 8010002: b2db         	uxtb	r3, r3
 8010004: 2b00         	cmp	r3, #0x0
 8010006: d11e         	bne	0x8010046 <can_rx_callback+0xc6> @ imm = #0x3c
 8010008: 4b94         	ldr	r3, [pc, #0x250]        @ 0x801025c <can_rx_callback+0x2dc>
 801000a: 6818         	ldr	r0, [r3]
 801000c: f897 207b    	ldrb.w	r2, [r7, #0x7b]
 8010010: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 8010014: 6f79         	ldr	r1, [r7, #0x74]
 8010016: 009b         	lsls	r3, r3, #0x2
 8010018: 440b         	add	r3, r1
 801001a: 685b         	ldr	r3, [r3, #0x4]
 801001c: 69b9         	ldr	r1, [r7, #0x18]
 801001e: 9105         	str	r1, [sp, #0x14]
 8010020: 9304         	str	r3, [sp, #0x10]
 8010022: 9203         	str	r2, [sp, #0xc]
 8010024: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8010260 <can_rx_callback+0x2e0>
 8010026: 9302         	str	r3, [sp, #0x8]
 8010028: 2300         	movs	r3, #0x0
 801002a: 9301         	str	r3, [sp, #0x4]
 801002c: 2300         	movs	r3, #0x0
 801002e: 9300         	str	r3, [sp]
 8010030: 2300         	movs	r3, #0x0
 8010032: 2201         	movs	r2, #0x1
 8010034: 4601         	mov	r1, r0
 8010036: 2000         	movs	r0, #0x0
 8010038: f013 fc5a    	bl	0x80238f0 <z_log_msg_runtime_create> @ imm = #0x138b4
 801003c: 2300         	movs	r3, #0x0
 801003e: 657b         	str	r3, [r7, #0x54]
; 		return;
 8010040: e1a7         	b	0x8010392 <can_rx_callback+0x412> @ imm = #0x34e
; 		LOG_ERR("Unknown motor ID: %d, database: %d, received: %d", id,
 8010042: bf00         	nop
 8010044: e1a5         	b	0x8010392 <can_rx_callback+0x412> @ imm = #0x34a
 8010046: bf00         	nop
; 		return;
 8010048: e1a3         	b	0x8010392 <can_rx_callback+0x412> @ imm = #0x346
; 	int8_t bus_id = canbus_id(can_dev);
 801004a: 68f8         	ldr	r0, [r7, #0xc]
 801004c: f7ff fc66    	bl	0x800f91c <canbus_id>   @ imm = #-0x734
 8010050: 4603         	mov	r3, r0
 8010052: f887 3073    	strb.w	r3, [r7, #0x73]
; 	if (!ctrl_struct) {
 8010056: 6f7b         	ldr	r3, [r7, #0x74]
 8010058: 2b00         	cmp	r3, #0x0
 801005a: f000 8195    	beq.w	0x8010388 <can_rx_callback+0x408> @ imm = #0x32a
; 	struct dji_motor_data *motor_data = ctrl_struct->motor_devs[id]->data;
 801005e: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 8010062: 6f7a         	ldr	r2, [r7, #0x74]
 8010064: 3310         	adds	r3, #0x10
 8010066: 009b         	lsls	r3, r3, #0x2
 8010068: 4413         	add	r3, r2
 801006a: 685b         	ldr	r3, [r3, #0x4]
 801006c: 691b         	ldr	r3, [r3, #0x10]
 801006e: 66fb         	str	r3, [r7, #0x6c]
; 	uint32_t prev_time = motor_data->curr_time;
 8010070: 6efb         	ldr	r3, [r7, #0x6c]
 8010072: 6c5b         	ldr	r3, [r3, #0x44]
 8010074: 66bb         	str	r3, [r7, #0x68]
; 	if (k_spin_trylock(&motor_data->data_input_lock, &key) != 0) {
 8010076: 6efb         	ldr	r3, [r7, #0x6c]
 8010078: 335c         	adds	r3, #0x5c
 801007a: 653b         	str	r3, [r7, #0x50]
 801007c: f107 0314    	add.w	r3, r7, #0x14
 8010080: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010082: f3ef 8311    	mrs	r3, basepri
 8010086: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 8010088: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 801008a: 647b         	str	r3, [r7, #0x44]
 801008c: 2310         	movs	r3, #0x10
 801008e: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010090: 6c3b         	ldr	r3, [r7, #0x40]
 8010092: f383 8812    	msr	basepri_max, r3
; }
 8010096: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010098: f3bf 8f6f    	isb	sy
; }
 801009c: bf00         	nop
; 	return key;
 801009e: 6c7b         	ldr	r3, [r7, #0x44]
; 	int key = arch_irq_lock();
 80100a0: 63fb         	str	r3, [r7, #0x3c]
 80100a2: 6d3b         	ldr	r3, [r7, #0x50]
 80100a4: 63bb         	str	r3, [r7, #0x38]
; }
 80100a6: bf00         	nop
 80100a8: 6d3b         	ldr	r3, [r7, #0x50]
 80100aa: 637b         	str	r3, [r7, #0x34]
; }
 80100ac: bf00         	nop
; 	k->key = key;
 80100ae: 6cfb         	ldr	r3, [r7, #0x4c]
 80100b0: 6bfa         	ldr	r2, [r7, #0x3c]
 80100b2: 601a         	str	r2, [r3]
; 	return 0;
 80100b4: 2300         	movs	r3, #0x0
; 	if (k_spin_trylock(&motor_data->data_input_lock, &key) != 0) {
 80100b6: 2b00         	cmp	r3, #0x0
 80100b8: f040 8168    	bne.w	0x801038c <can_rx_callback+0x40c> @ imm = #0x2d0
; 	if (!motor_data) {
 80100bc: 6efb         	ldr	r3, [r7, #0x6c]
 80100be: 2b00         	cmp	r3, #0x0
 80100c0: f000 8166    	beq.w	0x8010390 <can_rx_callback+0x410> @ imm = #0x2cc
; 	if (motor_data->missed_times > 3) {
 80100c4: 6efb         	ldr	r3, [r7, #0x6c]
 80100c6: f993 304c    	ldrsb.w	r3, [r3, #0x4c]
 80100ca: 2b03         	cmp	r3, #0x3
 80100cc: dd63         	ble	0x8010196 <can_rx_callback+0x216> @ imm = #0xc6
; 		LOG_ERR("Motor %d is responding again, resuming...", id);
 80100ce: 2304         	movs	r3, #0x4
 80100d0: 2b00         	cmp	r3, #0x0
 80100d2: d01c         	beq	0x801010e <can_rx_callback+0x18e> @ imm = #0x38
 80100d4: 2301         	movs	r3, #0x1
 80100d6: f887 3067    	strb.w	r3, [r7, #0x67]
 80100da: f897 3067    	ldrb.w	r3, [r7, #0x67]
 80100de: f083 0301    	eor	r3, r3, #0x1
 80100e2: b2db         	uxtb	r3, r3
 80100e4: 2b00         	cmp	r3, #0x0
 80100e6: d114         	bne	0x8010112 <can_rx_callback+0x192> @ imm = #0x28
 80100e8: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x801025c <can_rx_callback+0x2dc>
 80100ea: 6819         	ldr	r1, [r3]
 80100ec: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 80100f0: 9303         	str	r3, [sp, #0xc]
 80100f2: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8010264 <can_rx_callback+0x2e4>
 80100f4: 9302         	str	r3, [sp, #0x8]
 80100f6: 2300         	movs	r3, #0x0
 80100f8: 9301         	str	r3, [sp, #0x4]
 80100fa: 2300         	movs	r3, #0x0
 80100fc: 9300         	str	r3, [sp]
 80100fe: 2300         	movs	r3, #0x0
 8010100: 2201         	movs	r2, #0x1
 8010102: 2000         	movs	r0, #0x0
 8010104: f013 fbf4    	bl	0x80238f0 <z_log_msg_runtime_create> @ imm = #0x137e8
 8010108: 2300         	movs	r3, #0x0
 801010a: 663b         	str	r3, [r7, #0x60]
 801010c: e002         	b	0x8010114 <can_rx_callback+0x194> @ imm = #0x4
 801010e: bf00         	nop
 8010110: e000         	b	0x8010114 <can_rx_callback+0x194> @ imm = #0x0
 8010112: bf00         	nop
; 		motor_data->missed_times = 0;
 8010114: 6efb         	ldr	r3, [r7, #0x6c]
 8010116: 2200         	movs	r2, #0x0
 8010118: f883 204c    	strb.w	r2, [r3, #0x4c]
; 		motor_data->online = true;
 801011c: 6efb         	ldr	r3, [r7, #0x6c]
 801011e: 2201         	movs	r2, #0x1
 8010120: f883 2030    	strb.w	r2, [r3, #0x30]
; 			(const struct dji_motor_config *)ctrl_struct->motor_devs[id]->config;
 8010124: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 8010128: 6f7a         	ldr	r2, [r7, #0x74]
 801012a: 3310         	adds	r3, #0x10
 801012c: 009b         	lsls	r3, r3, #0x2
 801012e: 4413         	add	r3, r2
 8010130: 685b         	ldr	r3, [r3, #0x4]
; 		const struct dji_motor_config *motor_cfg =
 8010132: 685b         	ldr	r3, [r3, #0x4]
 8010134: 65fb         	str	r3, [r7, #0x5c]
; 		int8_t frame_id = frames_id(motor_cfg->common.tx_id);
 8010136: 6dfb         	ldr	r3, [r7, #0x5c]
 8010138: 689b         	ldr	r3, [r3, #0x8]
 801013a: 4618         	mov	r0, r3
 801013c: f013 fc28    	bl	0x8023990 <frames_id>   @ imm = #0x13850
 8010140: 4603         	mov	r3, r0
 8010142: f887 305b    	strb.w	r3, [r7, #0x5b]
; 		ctrl_struct[bus_id].mask[frame_id] ^= 1 << id;
 8010146: f997 2073    	ldrsb.w	r2, [r7, #0x73]
 801014a: 4613         	mov	r3, r2
 801014c: 015b         	lsls	r3, r3, #0x5
 801014e: 4413         	add	r3, r2
 8010150: 009b         	lsls	r3, r3, #0x2
 8010152: 461a         	mov	r2, r3
 8010154: 6f7b         	ldr	r3, [r7, #0x74]
 8010156: 441a         	add	r2, r3
 8010158: f997 305b    	ldrsb.w	r3, [r7, #0x5b]
 801015c: 4413         	add	r3, r2
 801015e: f893 303e    	ldrb.w	r3, [r3, #0x3e]
 8010162: b25a         	sxtb	r2, r3
 8010164: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 8010168: 2101         	movs	r1, #0x1
 801016a: fa01 f303    	lsl.w	r3, r1, r3
 801016e: b25b         	sxtb	r3, r3
 8010170: 4053         	eors	r3, r2
 8010172: b259         	sxtb	r1, r3
 8010174: f997 2073    	ldrsb.w	r2, [r7, #0x73]
 8010178: 4613         	mov	r3, r2
 801017a: 015b         	lsls	r3, r3, #0x5
 801017c: 4413         	add	r3, r2
 801017e: 009b         	lsls	r3, r3, #0x2
 8010180: 461a         	mov	r2, r3
 8010182: 6f7b         	ldr	r3, [r7, #0x74]
 8010184: 441a         	add	r2, r3
 8010186: f997 305b    	ldrsb.w	r3, [r7, #0x5b]
 801018a: b2c9         	uxtb	r1, r1
 801018c: 4413         	add	r3, r2
 801018e: 460a         	mov	r2, r1
 8010190: f883 203e    	strb.w	r2, [r3, #0x3e]
 8010194: e00e         	b	0x80101b4 <can_rx_callback+0x234> @ imm = #0x1c
; 	} else if (motor_data->missed_times > 0) {
 8010196: 6efb         	ldr	r3, [r7, #0x6c]
 8010198: f993 304c    	ldrsb.w	r3, [r3, #0x4c]
 801019c: 2b00         	cmp	r3, #0x0
 801019e: dd09         	ble	0x80101b4 <can_rx_callback+0x234> @ imm = #0x12
; 		motor_data->missed_times--;
 80101a0: 6efb         	ldr	r3, [r7, #0x6c]
 80101a2: f993 304c    	ldrsb.w	r3, [r3, #0x4c]
 80101a6: b2db         	uxtb	r3, r3
 80101a8: 3b01         	subs	r3, #0x1
 80101aa: b2db         	uxtb	r3, r3
 80101ac: b25a         	sxtb	r2, r3
 80101ae: 6efb         	ldr	r3, [r7, #0x6c]
 80101b0: f883 204c    	strb.w	r2, [r3, #0x4c]
; 	motor_data->RAWprev_angle = motor_data->RAWangle;
 80101b4: 6efb         	ldr	r3, [r7, #0x6c]
 80101b6: 8e9a         	ldrh	r2, [r3, #0x34]
 80101b8: 6efb         	ldr	r3, [r7, #0x6c]
 80101ba: 86da         	strh	r2, [r3, #0x36]
; 	motor_data->RAWangle = COMBINE_HL8(rx_frame.data[0], rx_frame.data[1]);
 80101bc: f897 3020    	ldrb.w	r3, [r7, #0x20]
 80101c0: 021b         	lsls	r3, r3, #0x8
 80101c2: b29b         	uxth	r3, r3
 80101c4: f897 2021    	ldrb.w	r2, [r7, #0x21]
 80101c8: 4413         	add	r3, r2
 80101ca: b29a         	uxth	r2, r3
 80101cc: 6efb         	ldr	r3, [r7, #0x6c]
 80101ce: 869a         	strh	r2, [r3, #0x34]
; 	motor_data->RAWrpm = COMBINE_HL8(rx_frame.data[2], rx_frame.data[3]);
 80101d0: f897 3022    	ldrb.w	r3, [r7, #0x22]
 80101d4: 021b         	lsls	r3, r3, #0x8
 80101d6: b29b         	uxth	r3, r3
 80101d8: f897 2023    	ldrb.w	r2, [r7, #0x23]
 80101dc: 4413         	add	r3, r2
 80101de: b29b         	uxth	r3, r3
 80101e0: b21a         	sxth	r2, r3
 80101e2: 6efb         	ldr	r3, [r7, #0x6c]
 80101e4: 879a         	strh	r2, [r3, #0x3c]
; 	motor_data->RAWcurrent = COMBINE_HL8(rx_frame.data[4], rx_frame.data[5]);
 80101e6: f897 3024    	ldrb.w	r3, [r7, #0x24]
 80101ea: 021b         	lsls	r3, r3, #0x8
 80101ec: f897 2025    	ldrb.w	r2, [r7, #0x25]
 80101f0: 441a         	add	r2, r3
 80101f2: 6efb         	ldr	r3, [r7, #0x6c]
 80101f4: 639a         	str	r2, [r3, #0x38]
; 	motor_data->RAWtemp = rx_frame.data[6];
 80101f6: f897 3026    	ldrb.w	r3, [r7, #0x26]
 80101fa: b25a         	sxtb	r2, r3
 80101fc: 6efb         	ldr	r3, [r7, #0x6c]
 80101fe: f883 203e    	strb.w	r2, [r3, #0x3e]
; 	ctrl_struct[bus_id].flags |= 1 << id;
 8010202: f997 2073    	ldrsb.w	r2, [r7, #0x73]
 8010206: 4613         	mov	r3, r2
 8010208: 015b         	lsls	r3, r3, #0x5
 801020a: 4413         	add	r3, r2
 801020c: 009b         	lsls	r3, r3, #0x2
 801020e: 461a         	mov	r2, r3
 8010210: 6f7b         	ldr	r3, [r7, #0x74]
 8010212: 4413         	add	r3, r2
 8010214: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 8010218: b25a         	sxtb	r2, r3
 801021a: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 801021e: 2101         	movs	r1, #0x1
 8010220: fa01 f303    	lsl.w	r3, r1, r3
 8010224: b25b         	sxtb	r3, r3
 8010226: 4313         	orrs	r3, r2
 8010228: b259         	sxtb	r1, r3
 801022a: f997 2073    	ldrsb.w	r2, [r7, #0x73]
 801022e: 4613         	mov	r3, r2
 8010230: 015b         	lsls	r3, r3, #0x5
 8010232: 4413         	add	r3, r2
 8010234: 009b         	lsls	r3, r3, #0x2
 8010236: 461a         	mov	r2, r3
 8010238: 6f7b         	ldr	r3, [r7, #0x74]
 801023a: 4413         	add	r3, r2
 801023c: b2ca         	uxtb	r2, r1
 801023e: f883 203d    	strb.w	r2, [r3, #0x3d]
; 	motor_data->curr_time = curr_time;
 8010242: 6efb         	ldr	r3, [r7, #0x6c]
 8010244: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8010248: 645a         	str	r2, [r3, #0x44]
; 	motor_data->prev_time = prev_time;
 801024a: 6efb         	ldr	r3, [r7, #0x6c]
 801024c: 6eba         	ldr	r2, [r7, #0x68]
 801024e: 649a         	str	r2, [r3, #0x48]
; 	bool full = false;
 8010250: 2300         	movs	r3, #0x0
 8010252: f887 3083    	strb.w	r3, [r7, #0x83]
; 	for (int i = 0; i < 5; i++) {
 8010256: 2300         	movs	r3, #0x0
 8010258: 67fb         	str	r3, [r7, #0x7c]
 801025a: e05a         	b	0x8010312 <can_rx_callback+0x392> @ imm = #0xb4

0801025c <$d>:
 801025c: e8 05 00 20  	.word	0x200005e8
 8010260: 38 9e 02 08  	.word	0x08029e38
 8010264: 6c 9e 02 08  	.word	0x08029e6c

08010268 <$t>:
; 		uint8_t combined = ctrl_struct[bus_id].mask[i] & ctrl_struct[bus_id].flags;
 8010268: f997 2073    	ldrsb.w	r2, [r7, #0x73]
 801026c: 4613         	mov	r3, r2
 801026e: 015b         	lsls	r3, r3, #0x5
 8010270: 4413         	add	r3, r2
 8010272: 009b         	lsls	r3, r3, #0x2
 8010274: 461a         	mov	r2, r3
 8010276: 6f7b         	ldr	r3, [r7, #0x74]
 8010278: 441a         	add	r2, r3
 801027a: 6ffb         	ldr	r3, [r7, #0x7c]
 801027c: 4413         	add	r3, r2
 801027e: 333e         	adds	r3, #0x3e
 8010280: 7819         	ldrb	r1, [r3]
 8010282: f997 2073    	ldrsb.w	r2, [r7, #0x73]
 8010286: 4613         	mov	r3, r2
 8010288: 015b         	lsls	r3, r3, #0x5
 801028a: 4413         	add	r3, r2
 801028c: 009b         	lsls	r3, r3, #0x2
 801028e: 461a         	mov	r2, r3
 8010290: 6f7b         	ldr	r3, [r7, #0x74]
 8010292: 4413         	add	r3, r2
 8010294: f893 303d    	ldrb.w	r3, [r3, #0x3d]
 8010298: 400b         	ands	r3, r1
 801029a: f887 305a    	strb.w	r3, [r7, #0x5a]
; 		if (combined == ctrl_struct[bus_id].mask[i]) {
 801029e: f997 2073    	ldrsb.w	r2, [r7, #0x73]
 80102a2: 4613         	mov	r3, r2
 80102a4: 015b         	lsls	r3, r3, #0x5
 80102a6: 4413         	add	r3, r2
 80102a8: 009b         	lsls	r3, r3, #0x2
 80102aa: 461a         	mov	r2, r3
 80102ac: 6f7b         	ldr	r3, [r7, #0x74]
 80102ae: 441a         	add	r2, r3
 80102b0: 6ffb         	ldr	r3, [r7, #0x7c]
 80102b2: 4413         	add	r3, r2
 80102b4: 333e         	adds	r3, #0x3e
 80102b6: 781b         	ldrb	r3, [r3]
 80102b8: f897 205a    	ldrb.w	r2, [r7, #0x5a]
 80102bc: 429a         	cmp	r2, r3
 80102be: d125         	bne	0x801030c <can_rx_callback+0x38c> @ imm = #0x4a
; 			ctrl_struct->flags ^= ctrl_struct[bus_id].mask[i];
 80102c0: 6f7b         	ldr	r3, [r7, #0x74]
 80102c2: f893 103d    	ldrb.w	r1, [r3, #0x3d]
 80102c6: f997 2073    	ldrsb.w	r2, [r7, #0x73]
 80102ca: 4613         	mov	r3, r2
 80102cc: 015b         	lsls	r3, r3, #0x5
 80102ce: 4413         	add	r3, r2
 80102d0: 009b         	lsls	r3, r3, #0x2
 80102d2: 461a         	mov	r2, r3
 80102d4: 6f7b         	ldr	r3, [r7, #0x74]
 80102d6: 441a         	add	r2, r3
 80102d8: 6ffb         	ldr	r3, [r7, #0x7c]
 80102da: 4413         	add	r3, r2
 80102dc: 333e         	adds	r3, #0x3e
 80102de: 781b         	ldrb	r3, [r3]
 80102e0: 404b         	eors	r3, r1
 80102e2: b2da         	uxtb	r2, r3
 80102e4: 6f7b         	ldr	r3, [r7, #0x74]
 80102e6: f883 203d    	strb.w	r2, [r3, #0x3d]
; 			ctrl_struct[bus_id].full[i] = true;
 80102ea: f997 2073    	ldrsb.w	r2, [r7, #0x73]
 80102ee: 4613         	mov	r3, r2
 80102f0: 015b         	lsls	r3, r3, #0x5
 80102f2: 4413         	add	r3, r2
 80102f4: 009b         	lsls	r3, r3, #0x2
 80102f6: 461a         	mov	r2, r3
 80102f8: 6f7b         	ldr	r3, [r7, #0x74]
 80102fa: 441a         	add	r2, r3
 80102fc: 6ffb         	ldr	r3, [r7, #0x7c]
 80102fe: 4413         	add	r3, r2
 8010300: 3324         	adds	r3, #0x24
 8010302: 2201         	movs	r2, #0x1
 8010304: 701a         	strb	r2, [r3]
; 			full = true;
 8010306: 2301         	movs	r3, #0x1
 8010308: f887 3083    	strb.w	r3, [r7, #0x83]
; 	for (int i = 0; i < 5; i++) {
 801030c: 6ffb         	ldr	r3, [r7, #0x7c]
 801030e: 3301         	adds	r3, #0x1
 8010310: 67fb         	str	r3, [r7, #0x7c]
 8010312: 6ffb         	ldr	r3, [r7, #0x7c]
 8010314: 2b04         	cmp	r3, #0x4
 8010316: dda7         	ble	0x8010268 <can_rx_callback+0x2e8> @ imm = #-0xb2
; 	if (full && !k_work_is_pending(&ctrl_struct[bus_id].full_handle)) {
 8010318: f897 3083    	ldrb.w	r3, [r7, #0x83]
 801031c: 2b00         	cmp	r3, #0x0
 801031e: d020         	beq	0x8010362 <can_rx_callback+0x3e2> @ imm = #0x40
 8010320: f997 2073    	ldrsb.w	r2, [r7, #0x73]
 8010324: 4613         	mov	r3, r2
 8010326: 015b         	lsls	r3, r3, #0x5
 8010328: 4413         	add	r3, r2
 801032a: 009b         	lsls	r3, r3, #0x2
 801032c: 461a         	mov	r2, r3
 801032e: 6f7b         	ldr	r3, [r7, #0x74]
 8010330: 4413         	add	r3, r2
 8010332: 3364         	adds	r3, #0x64
 8010334: 4618         	mov	r0, r3
 8010336: f013 fa81    	bl	0x802383c <k_work_is_pending> @ imm = #0x13502
 801033a: 4603         	mov	r3, r0
 801033c: f083 0301    	eor	r3, r3, #0x1
 8010340: b2db         	uxtb	r3, r3
 8010342: 2b00         	cmp	r3, #0x0
 8010344: d00d         	beq	0x8010362 <can_rx_callback+0x3e2> @ imm = #0x1a
; 		k_work_submit_to_queue(&dji_work_queue, &ctrl_struct[bus_id].full_handle);
 8010346: f997 2073    	ldrsb.w	r2, [r7, #0x73]
 801034a: 4613         	mov	r3, r2
 801034c: 015b         	lsls	r3, r3, #0x5
 801034e: 4413         	add	r3, r2
 8010350: 009b         	lsls	r3, r3, #0x2
 8010352: 461a         	mov	r2, r3
 8010354: 6f7b         	ldr	r3, [r7, #0x74]
 8010356: 4413         	add	r3, r2
 8010358: 3364         	adds	r3, #0x64
 801035a: 4619         	mov	r1, r3
 801035c: 480e         	ldr	r0, [pc, #0x38]         @ 0x8010398 <can_rx_callback+0x418>
 801035e: f015 fdf6    	bl	0x8025f4e <k_work_submit_to_queue> @ imm = #0x15bec
; 	k_spin_unlock(&motor_data->data_input_lock, key);
 8010362: 6efb         	ldr	r3, [r7, #0x6c]
 8010364: 335c         	adds	r3, #0x5c
 8010366: 633b         	str	r3, [r7, #0x30]
 8010368: 697b         	ldr	r3, [r7, #0x14]
 801036a: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 801036c: 693b         	ldr	r3, [r7, #0x10]
 801036e: 62fb         	str	r3, [r7, #0x2c]
 8010370: 6afb         	ldr	r3, [r7, #0x2c]
 8010372: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010374: 6abb         	ldr	r3, [r7, #0x28]
 8010376: f383 8811    	msr	basepri, r3
; }
 801037a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801037c: f3bf 8f6f    	isb	sy
; }
 8010380: bf00         	nop
; }
 8010382: bf00         	nop
; }
 8010384: bf00         	nop
; 	return;
 8010386: e004         	b	0x8010392 <can_rx_callback+0x412> @ imm = #0x8
; 		return;
 8010388: bf00         	nop
 801038a: e002         	b	0x8010392 <can_rx_callback+0x412> @ imm = #0x4
; 		return;
 801038c: bf00         	nop
 801038e: e000         	b	0x8010392 <can_rx_callback+0x412> @ imm = #0x0
; 		return;
 8010390: bf00         	nop
; }
 8010392: 378c         	adds	r7, #0x8c
 8010394: 46bd         	mov	sp, r7
 8010396: bd90         	pop	{r4, r7, pc}

08010398 <$d>:
 8010398: 58 23 00 20  	.word	0x20002358

0801039c <proceed_delta_degree>:
; {
 801039c: b580         	push	{r7, lr}
 801039e: b088         	sub	sp, #0x20
 80103a0: af00         	add	r7, sp, #0x0
 80103a2: 6078         	str	r0, [r7, #0x4]
; 	struct dji_motor_data *data_temp = dev->data;
 80103a4: 687b         	ldr	r3, [r7, #0x4]
 80103a6: 691b         	ldr	r3, [r3, #0x10]
 80103a8: 61bb         	str	r3, [r7, #0x18]
; 	const struct dji_motor_config *config_temp = dev->config;
 80103aa: 687b         	ldr	r3, [r7, #0x4]
 80103ac: 685b         	ldr	r3, [r3, #0x4]
 80103ae: 617b         	str	r3, [r7, #0x14]
; 	int delta = data_temp->RAWangle - data_temp->RAWprev_angle;
 80103b0: 69bb         	ldr	r3, [r7, #0x18]
 80103b2: 8e9b         	ldrh	r3, [r3, #0x34]
 80103b4: 461a         	mov	r2, r3
 80103b6: 69bb         	ldr	r3, [r7, #0x18]
 80103b8: 8edb         	ldrh	r3, [r3, #0x36]
 80103ba: 1ad3         	subs	r3, r2, r3
 80103bc: 61fb         	str	r3, [r7, #0x1c]
; 	if (data_temp->RAWangle < 2048 && data_temp->RAWprev_angle > 6144) {
 80103be: 69bb         	ldr	r3, [r7, #0x18]
 80103c0: 8e9b         	ldrh	r3, [r3, #0x34]
 80103c2: f5b3 6f00    	cmp.w	r3, #0x800
 80103c6: d22b         	bhs	0x8010420 <proceed_delta_degree+0x84> @ imm = #0x56
 80103c8: 69bb         	ldr	r3, [r7, #0x18]
 80103ca: 8edb         	ldrh	r3, [r3, #0x36]
 80103cc: f5b3 5fc0    	cmp.w	r3, #0x1800
 80103d0: d926         	bls	0x8010420 <proceed_delta_degree+0x84> @ imm = #0x4c
; 		delta += 8192;
 80103d2: 69fb         	ldr	r3, [r7, #0x1c]
 80103d4: f503 5300    	add.w	r3, r3, #0x2000
 80103d8: 61fb         	str	r3, [r7, #0x1c]
; 		data_temp->common.round_cnt++;
 80103da: 69bb         	ldr	r3, [r7, #0x18]
 80103dc: 691b         	ldr	r3, [r3, #0x10]
 80103de: 1c5a         	adds	r2, r3, #0x1
 80103e0: 69bb         	ldr	r3, [r7, #0x18]
 80103e2: 611a         	str	r2, [r3, #0x10]
; 		if (data_temp->target_angle < 0 || data_temp->target_angle > 360) {
 80103e4: 69bb         	ldr	r3, [r7, #0x18]
 80103e6: edd3 7a18    	vldr	s15, [r3, #96]
 80103ea: eef5 7ac0    	vcmpe.f32	s15, #0
 80103ee: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80103f2: d40a         	bmi	0x801040a <proceed_delta_degree+0x6e> @ imm = #0x14
 80103f4: 69bb         	ldr	r3, [r7, #0x18]
 80103f6: edd3 7a18    	vldr	s15, [r3, #96]
 80103fa: ed9f 7a7f    	vldr	s14, [pc, #508]         @ 0x80105f8 <proceed_delta_degree+0x25c>
 80103fe: eef4 7ac7    	vcmpe.f32	s15, s14
 8010402: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8010406: dc00         	bgt	0x801040a <proceed_delta_degree+0x6e> @ imm = #0x0
 8010408: e039         	b	0x801047e <proceed_delta_degree+0xe2> @ imm = #0x72
; 			data_temp->target_angle -= 360;
 801040a: 69bb         	ldr	r3, [r7, #0x18]
 801040c: edd3 7a18    	vldr	s15, [r3, #96]
 8010410: ed9f 7a79    	vldr	s14, [pc, #484]         @ 0x80105f8 <proceed_delta_degree+0x25c>
 8010414: ee77 7ac7    	vsub.f32	s15, s15, s14
 8010418: 69bb         	ldr	r3, [r7, #0x18]
 801041a: edc3 7a18    	vstr	s15, [r3, #96]
; 		if (data_temp->target_angle < 0 || data_temp->target_angle > 360) {
 801041e: e02e         	b	0x801047e <proceed_delta_degree+0xe2> @ imm = #0x5c
; 	} else if (data_temp->RAWangle > 6144 && data_temp->RAWprev_angle < 2048) {
 8010420: 69bb         	ldr	r3, [r7, #0x18]
 8010422: 8e9b         	ldrh	r3, [r3, #0x34]
 8010424: f5b3 5fc0    	cmp.w	r3, #0x1800
 8010428: d929         	bls	0x801047e <proceed_delta_degree+0xe2> @ imm = #0x52
 801042a: 69bb         	ldr	r3, [r7, #0x18]
 801042c: 8edb         	ldrh	r3, [r3, #0x36]
 801042e: f5b3 6f00    	cmp.w	r3, #0x800
 8010432: d224         	bhs	0x801047e <proceed_delta_degree+0xe2> @ imm = #0x48
; 		delta -= 8192;
 8010434: 69fb         	ldr	r3, [r7, #0x1c]
 8010436: f5a3 5300    	sub.w	r3, r3, #0x2000
 801043a: 61fb         	str	r3, [r7, #0x1c]
; 		data_temp->common.round_cnt--;
 801043c: 69bb         	ldr	r3, [r7, #0x18]
 801043e: 691b         	ldr	r3, [r3, #0x10]
 8010440: 1e5a         	subs	r2, r3, #0x1
 8010442: 69bb         	ldr	r3, [r7, #0x18]
 8010444: 611a         	str	r2, [r3, #0x10]
; 		if (data_temp->target_angle < 0 || data_temp->target_angle > 360) {
 8010446: 69bb         	ldr	r3, [r7, #0x18]
 8010448: edd3 7a18    	vldr	s15, [r3, #96]
 801044c: eef5 7ac0    	vcmpe.f32	s15, #0
 8010450: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8010454: d409         	bmi	0x801046a <proceed_delta_degree+0xce> @ imm = #0x12
 8010456: 69bb         	ldr	r3, [r7, #0x18]
 8010458: edd3 7a18    	vldr	s15, [r3, #96]
 801045c: ed9f 7a66    	vldr	s14, [pc, #408]         @ 0x80105f8 <proceed_delta_degree+0x25c>
 8010460: eef4 7ac7    	vcmpe.f32	s15, s14
 8010464: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8010468: dd09         	ble	0x801047e <proceed_delta_degree+0xe2> @ imm = #0x12
; 			data_temp->target_angle += 360;
 801046a: 69bb         	ldr	r3, [r7, #0x18]
 801046c: edd3 7a18    	vldr	s15, [r3, #96]
 8010470: ed9f 7a61    	vldr	s14, [pc, #388]         @ 0x80105f8 <proceed_delta_degree+0x25c>
 8010474: ee77 7a87    	vadd.f32	s15, s15, s14
 8010478: 69bb         	ldr	r3, [r7, #0x18]
 801047a: edc3 7a18    	vstr	s15, [r3, #96]
; 	if (fabsf(config_temp->gear_ratio - 1) > 0.001f) {
 801047e: 697b         	ldr	r3, [r7, #0x14]
 8010480: edd3 7a14    	vldr	s15, [r3, #80]
 8010484: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 8010488: ee77 7ac7    	vsub.f32	s15, s15, s14
 801048c: edc7 7a03    	vstr	s15, [r7, #12]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 8010490: edd7 7a03    	vldr	s15, [r7, #12]
 8010494: eef0 7ae7    	vabs.f32	s15, s15
 8010498: edc7 7a02    	vstr	s15, [r7, #8]
;     return result;
 801049c: edd7 7a02    	vldr	s15, [r7, #8]
; 	if (fabsf(config_temp->gear_ratio - 1) > 0.001f) {
 80104a0: ed9f 7a56    	vldr	s14, [pc, #344]         @ 0x80105fc <proceed_delta_degree+0x260>
 80104a4: eef4 7ac7    	vcmpe.f32	s15, s14
 80104a8: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80104ac: dd42         	ble	0x8010534 <proceed_delta_degree+0x198> @ imm = #0x84
; 		data_temp->angle_add +=
 80104ae: 69bb         	ldr	r3, [r7, #0x18]
 80104b0: ed93 7a10    	vldr	s14, [r3, #64]
; 			(float)(delta)*convert[data_temp->convert_num][ANGLE2DEGREE] /
 80104b4: 69fb         	ldr	r3, [r7, #0x1c]
 80104b6: ee07 3a90    	vmov	s15, r3
 80104ba: eef8 6ae7    	vcvt.f32.s32	s13, s15
 80104be: 69bb         	ldr	r3, [r7, #0x18]
 80104c0: f893 3031    	ldrb.w	r3, [r3, #0x31]
 80104c4: 4619         	mov	r1, r3
 80104c6: 4a4e         	ldr	r2, [pc, #0x138]        @ 0x8010600 <proceed_delta_degree+0x264>
 80104c8: 460b         	mov	r3, r1
 80104ca: 005b         	lsls	r3, r3, #0x1
 80104cc: 440b         	add	r3, r1
 80104ce: 00db         	lsls	r3, r3, #0x3
 80104d0: 4413         	add	r3, r2
 80104d2: 3310         	adds	r3, #0x10
 80104d4: edd3 7a00    	vldr	s15, [r3]
 80104d8: ee26 6aa7    	vmul.f32	s12, s13, s15
; 			(config_temp->gear_ratio);
 80104dc: 697b         	ldr	r3, [r7, #0x14]
 80104de: edd3 6a14    	vldr	s13, [r3, #80]
; 			(float)(delta)*convert[data_temp->convert_num][ANGLE2DEGREE] /
 80104e2: eec6 7a26    	vdiv.f32	s15, s12, s13
; 		data_temp->angle_add +=
 80104e6: ee77 7a27    	vadd.f32	s15, s14, s15
 80104ea: 69bb         	ldr	r3, [r7, #0x18]
 80104ec: edc3 7a10    	vstr	s15, [r3, #64]
; 		data_temp->common.angle = fmodf(data_temp->angle_add, 360.0f);
 80104f0: 69bb         	ldr	r3, [r7, #0x18]
 80104f2: edd3 7a10    	vldr	s15, [r3, #64]
 80104f6: eddf 0a40    	vldr	s1, [pc, #256]          @ 0x80105f8 <proceed_delta_degree+0x25c>
 80104fa: eeb0 0a67    	vmov.f32	s0, s15
 80104fe: f008 fd8d    	bl	0x801901c <fmodf>       @ imm = #0x8b1a
 8010502: eef0 7a40    	vmov.f32	s15, s0
 8010506: 69bb         	ldr	r3, [r7, #0x18]
 8010508: edc3 7a00    	vstr	s15, [r3]
; 		while (data_temp->common.angle < 0) {
 801050c: e009         	b	0x8010522 <proceed_delta_degree+0x186> @ imm = #0x12
; 			data_temp->common.angle += 360.0f;
 801050e: 69bb         	ldr	r3, [r7, #0x18]
 8010510: edd3 7a00    	vldr	s15, [r3]
 8010514: ed9f 7a38    	vldr	s14, [pc, #224]         @ 0x80105f8 <proceed_delta_degree+0x25c>
 8010518: ee77 7a87    	vadd.f32	s15, s15, s14
 801051c: 69bb         	ldr	r3, [r7, #0x18]
 801051e: edc3 7a00    	vstr	s15, [r3]
; 		while (data_temp->common.angle < 0) {
 8010522: 69bb         	ldr	r3, [r7, #0x18]
 8010524: edd3 7a00    	vldr	s15, [r3]
 8010528: eef5 7ac0    	vcmpe.f32	s15, #0
 801052c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8010530: d4ed         	bmi	0x801050e <proceed_delta_degree+0x172> @ imm = #-0x26
 8010532: e017         	b	0x8010564 <proceed_delta_degree+0x1c8> @ imm = #0x2e
; 		data_temp->common.angle = (float)(data_temp->RAWangle) *
 8010534: 69bb         	ldr	r3, [r7, #0x18]
 8010536: 8e9b         	ldrh	r3, [r3, #0x34]
 8010538: ee07 3a90    	vmov	s15, r3
 801053c: eeb8 7a67    	vcvt.f32.u32	s14, s15
; 					  convert[data_temp->convert_num][ANGLE2DEGREE];
 8010540: 69bb         	ldr	r3, [r7, #0x18]
 8010542: f893 3031    	ldrb.w	r3, [r3, #0x31]
 8010546: 4619         	mov	r1, r3
 8010548: 4a2d         	ldr	r2, [pc, #0xb4]         @ 0x8010600 <proceed_delta_degree+0x264>
 801054a: 460b         	mov	r3, r1
 801054c: 005b         	lsls	r3, r3, #0x1
 801054e: 440b         	add	r3, r1
 8010550: 00db         	lsls	r3, r3, #0x3
 8010552: 4413         	add	r3, r2
 8010554: 3310         	adds	r3, #0x10
 8010556: edd3 7a00    	vldr	s15, [r3]
; 		data_temp->common.angle = (float)(data_temp->RAWangle) *
 801055a: ee67 7a27    	vmul.f32	s15, s14, s15
 801055e: 69bb         	ldr	r3, [r7, #0x18]
 8010560: edc3 7a00    	vstr	s15, [r3]
; 	float delta_angle = data_temp->common.angle - data_temp->target_angle;
 8010564: 69bb         	ldr	r3, [r7, #0x18]
 8010566: ed93 7a00    	vldr	s14, [r3]
 801056a: 69bb         	ldr	r3, [r7, #0x18]
 801056c: edd3 7a18    	vldr	s15, [r3, #96]
 8010570: ee77 7a67    	vsub.f32	s15, s14, s15
 8010574: edc7 7a04    	vstr	s15, [r7, #16]
; 	if (delta_angle > 0) {
 8010578: edd7 7a04    	vldr	s15, [r7, #16]
 801057c: eef5 7ac0    	vcmpe.f32	s15, #0
 8010580: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8010584: dd16         	ble	0x80105b4 <proceed_delta_degree+0x218> @ imm = #0x2c
; 		if (delta_angle < 180) {
 8010586: edd7 7a04    	vldr	s15, [r7, #16]
 801058a: ed9f 7a1e    	vldr	s14, [pc, #120]         @ 0x8010604 <proceed_delta_degree+0x268>
 801058e: eef4 7ac7    	vcmpe.f32	s15, s14
 8010592: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8010596: d503         	bpl	0x80105a0 <proceed_delta_degree+0x204> @ imm = #0x6
; 			data_temp->pid_angle_input = delta_angle;
 8010598: 69bb         	ldr	r3, [r7, #0x18]
 801059a: 693a         	ldr	r2, [r7, #0x10]
 801059c: 655a         	str	r2, [r3, #0x54]
; }
 801059e: e027         	b	0x80105f0 <proceed_delta_degree+0x254> @ imm = #0x4e
; 			data_temp->pid_angle_input = delta_angle - 360.0f;
 80105a0: edd7 7a04    	vldr	s15, [r7, #16]
 80105a4: ed9f 7a14    	vldr	s14, [pc, #80]          @ 0x80105f8 <proceed_delta_degree+0x25c>
 80105a8: ee77 7ac7    	vsub.f32	s15, s15, s14
 80105ac: 69bb         	ldr	r3, [r7, #0x18]
 80105ae: edc3 7a15    	vstr	s15, [r3, #84]
; }
 80105b2: e01d         	b	0x80105f0 <proceed_delta_degree+0x254> @ imm = #0x3a
; 	} else if (delta_angle < 0) {
 80105b4: edd7 7a04    	vldr	s15, [r7, #16]
 80105b8: eef5 7ac0    	vcmpe.f32	s15, #0
 80105bc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80105c0: d400         	bmi	0x80105c4 <proceed_delta_degree+0x228> @ imm = #0x0
; }
 80105c2: e015         	b	0x80105f0 <proceed_delta_degree+0x254> @ imm = #0x2a
; 		if (delta_angle > -180) {
 80105c4: edd7 7a04    	vldr	s15, [r7, #16]
 80105c8: ed9f 7a0f    	vldr	s14, [pc, #60]          @ 0x8010608 <proceed_delta_degree+0x26c>
 80105cc: eef4 7ac7    	vcmpe.f32	s15, s14
 80105d0: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80105d4: dd03         	ble	0x80105de <proceed_delta_degree+0x242> @ imm = #0x6
; 			data_temp->pid_angle_input = delta_angle;
 80105d6: 69bb         	ldr	r3, [r7, #0x18]
 80105d8: 693a         	ldr	r2, [r7, #0x10]
 80105da: 655a         	str	r2, [r3, #0x54]
; }
 80105dc: e008         	b	0x80105f0 <proceed_delta_degree+0x254> @ imm = #0x10
; 			data_temp->pid_angle_input = delta_angle + 360.0f;
 80105de: edd7 7a04    	vldr	s15, [r7, #16]
 80105e2: ed9f 7a05    	vldr	s14, [pc, #20]          @ 0x80105f8 <proceed_delta_degree+0x25c>
 80105e6: ee77 7a87    	vadd.f32	s15, s15, s14
 80105ea: 69bb         	ldr	r3, [r7, #0x18]
 80105ec: edc3 7a15    	vstr	s15, [r3, #84]
; }
 80105f0: bf00         	nop
 80105f2: 3720         	adds	r7, #0x20
 80105f4: 46bd         	mov	sp, r7
 80105f6: bd80         	pop	{r7, pc}

080105f8 <$d>:
 80105f8: 00 00 b4 43  	.word	0x43b40000
 80105fc: 6f 12 83 3a  	.word	0x3a83126f
 8010600: d4 b0 02 08  	.word	0x0802b0d4
 8010604: 00 00 34 43  	.word	0x43340000
 8010608: 00 00 34 c3  	.word	0xc3340000

0801060c <dji_timeout_handle>:
; {
 801060c: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8010610: b08e         	sub	sp, #0x38
 8010612: af04         	add	r7, sp, #0x10
 8010614: 60f8         	str	r0, [r7, #0xc]
 8010616: 60b9         	str	r1, [r7, #0x8]
 8010618: 607a         	str	r2, [r7, #0x4]
; 	struct dji_motor_data *motor_data = (struct dji_motor_data *)dev->data;
 801061a: 68fb         	ldr	r3, [r7, #0xc]
 801061c: 691b         	ldr	r3, [r3, #0x10]
 801061e: 627b         	str	r3, [r7, #0x24]
; 	const struct dji_motor_config *motor_cfg = (const struct dji_motor_config *)dev->config;
 8010620: 68fb         	ldr	r3, [r7, #0xc]
 8010622: 685b         	ldr	r3, [r3, #0x4]
 8010624: 623b         	str	r3, [r7, #0x20]
; 	if (motor_data->online == false) {
 8010626: 6a7b         	ldr	r3, [r7, #0x24]
 8010628: f893 3030    	ldrb.w	r3, [r3, #0x30]
 801062c: f083 0301    	eor	r3, r3, #0x1
 8010630: b2db         	uxtb	r3, r3
 8010632: 2b00         	cmp	r3, #0x0
 8010634: d17f         	bne	0x8010736 <dji_timeout_handle+0x12a> @ imm = #0xfe
; 	uint32_t prev_time = motor_data->curr_time;
 8010636: 6a7b         	ldr	r3, [r7, #0x24]
 8010638: 6c5b         	ldr	r3, [r3, #0x44]
 801063a: 61fb         	str	r3, [r7, #0x1c]
; 	if (k_cyc_to_us_near32(curr_time - prev_time) > 2000) {
 801063c: 68ba         	ldr	r2, [r7, #0x8]
 801063e: 69fb         	ldr	r3, [r7, #0x1c]
 8010640: 1ad3         	subs	r3, r2, r3
 8010642: f113 0f55    	cmn.w	r3, #0x55
 8010646: d80a         	bhi	0x801065e <dji_timeout_handle+0x52> @ imm = #0x14
 8010648: 68ba         	ldr	r2, [r7, #0x8]
 801064a: 69fb         	ldr	r3, [r7, #0x1c]
 801064c: 1ad3         	subs	r3, r2, r3
 801064e: 3354         	adds	r3, #0x54
 8010650: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x8010740 <dji_timeout_handle+0x134>
 8010652: 4293         	cmp	r3, r2
 8010654: bf8c         	ite	hi
 8010656: 2301         	movhi	r3, #0x1
 8010658: 2300         	movls	r3, #0x0
 801065a: b2db         	uxtb	r3, r3
 801065c: e01a         	b	0x8010694 <dji_timeout_handle+0x88> @ imm = #0x34
 801065e: 68ba         	ldr	r2, [r7, #0x8]
 8010660: 69fb         	ldr	r3, [r7, #0x1c]
 8010662: 1ad3         	subs	r3, r2, r3
 8010664: 2200         	movs	r2, #0x0
 8010666: 461c         	mov	r4, r3
 8010668: 4615         	mov	r5, r2
 801066a: f114 0854    	adds.w	r8, r4, #0x54
 801066e: f145 0900    	adc	r9, r5, #0x0
 8010672: f04f 02a8    	mov.w	r2, #0xa8
 8010676: f04f 0300    	mov.w	r3, #0x0
 801067a: 4640         	mov	r0, r8
 801067c: 4649         	mov	r1, r9
 801067e: f7ef ffdf    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x10042
 8010682: 4602         	mov	r2, r0
 8010684: 460b         	mov	r3, r1
 8010686: 4613         	mov	r3, r2
 8010688: f5b3 6ffa    	cmp.w	r3, #0x7d0
 801068c: bf8c         	ite	hi
 801068e: 2301         	movhi	r3, #0x1
 8010690: 2300         	movls	r3, #0x0
 8010692: b2db         	uxtb	r3, r3
 8010694: 2b00         	cmp	r3, #0x0
 8010696: d04f         	beq	0x8010738 <dji_timeout_handle+0x12c> @ imm = #0x9e
; 		motor_data->missed_times++;
 8010698: 6a7b         	ldr	r3, [r7, #0x24]
 801069a: f993 304c    	ldrsb.w	r3, [r3, #0x4c]
 801069e: b2db         	uxtb	r3, r3
 80106a0: 3301         	adds	r3, #0x1
 80106a2: b2db         	uxtb	r3, r3
 80106a4: b25a         	sxtb	r2, r3
 80106a6: 6a7b         	ldr	r3, [r7, #0x24]
 80106a8: f883 204c    	strb.w	r2, [r3, #0x4c]
; 		if (motor_data->missed_times > 3) {
 80106ac: 6a7b         	ldr	r3, [r7, #0x24]
 80106ae: f993 304c    	ldrsb.w	r3, [r3, #0x4c]
 80106b2: 2b03         	cmp	r3, #0x3
 80106b4: dd40         	ble	0x8010738 <dji_timeout_handle+0x12c> @ imm = #0x80
; 			LOG_ERR("Motor %d is not responding", motor_cfg->common.id);
 80106b6: 2304         	movs	r3, #0x4
 80106b8: 2b00         	cmp	r3, #0x0
 80106ba: d01a         	beq	0x80106f2 <dji_timeout_handle+0xe6> @ imm = #0x34
 80106bc: 2301         	movs	r3, #0x1
 80106be: 76fb         	strb	r3, [r7, #0x1b]
 80106c0: 7efb         	ldrb	r3, [r7, #0x1b]
 80106c2: f083 0301    	eor	r3, r3, #0x1
 80106c6: b2db         	uxtb	r3, r3
 80106c8: 2b00         	cmp	r3, #0x0
 80106ca: d114         	bne	0x80106f6 <dji_timeout_handle+0xea> @ imm = #0x28
 80106cc: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8010744 <dji_timeout_handle+0x138>
 80106ce: 6819         	ldr	r1, [r3]
 80106d0: 6a3b         	ldr	r3, [r7, #0x20]
 80106d2: 791b         	ldrb	r3, [r3, #0x4]
 80106d4: 9303         	str	r3, [sp, #0xc]
 80106d6: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8010748 <dji_timeout_handle+0x13c>
 80106d8: 9302         	str	r3, [sp, #0x8]
 80106da: 2300         	movs	r3, #0x0
 80106dc: 9301         	str	r3, [sp, #0x4]
 80106de: 2300         	movs	r3, #0x0
 80106e0: 9300         	str	r3, [sp]
 80106e2: 2300         	movs	r3, #0x0
 80106e4: 2201         	movs	r2, #0x1
 80106e6: 2000         	movs	r0, #0x0
 80106e8: f013 f902    	bl	0x80238f0 <z_log_msg_runtime_create> @ imm = #0x13204
 80106ec: 2300         	movs	r3, #0x0
 80106ee: 617b         	str	r3, [r7, #0x14]
 80106f0: e002         	b	0x80106f8 <dji_timeout_handle+0xec> @ imm = #0x4
 80106f2: bf00         	nop
 80106f4: e000         	b	0x80106f8 <dji_timeout_handle+0xec> @ imm = #0x0
 80106f6: bf00         	nop
; 			ctrl_struct->mask[frames_id(motor_cfg->common.tx_id)] ^=
 80106f8: 6a3b         	ldr	r3, [r7, #0x20]
 80106fa: 689b         	ldr	r3, [r3, #0x8]
 80106fc: 4618         	mov	r0, r3
 80106fe: f013 f947    	bl	0x8023990 <frames_id>   @ imm = #0x1328e
 8010702: 4603         	mov	r3, r0
 8010704: 687a         	ldr	r2, [r7, #0x4]
 8010706: 441a         	add	r2, r3
 8010708: f892 203e    	ldrb.w	r2, [r2, #0x3e]
 801070c: b251         	sxtb	r1, r2
; 				1 << (motor_cfg->common.id - 1);
 801070e: 6a3a         	ldr	r2, [r7, #0x20]
 8010710: 7912         	ldrb	r2, [r2, #0x4]
 8010712: 3a01         	subs	r2, #0x1
 8010714: 2001         	movs	r0, #0x1
 8010716: fa00 f202    	lsl.w	r2, r0, r2
; 			ctrl_struct->mask[frames_id(motor_cfg->common.tx_id)] ^=
 801071a: b252         	sxtb	r2, r2
 801071c: 404a         	eors	r2, r1
 801071e: b252         	sxtb	r2, r2
 8010720: b2d1         	uxtb	r1, r2
 8010722: 687a         	ldr	r2, [r7, #0x4]
 8010724: 4413         	add	r3, r2
 8010726: 460a         	mov	r2, r1
 8010728: f883 203e    	strb.w	r2, [r3, #0x3e]
; 			motor_data->online = false;
 801072c: 6a7b         	ldr	r3, [r7, #0x24]
 801072e: 2200         	movs	r2, #0x0
 8010730: f883 2030    	strb.w	r2, [r3, #0x30]
 8010734: e000         	b	0x8010738 <dji_timeout_handle+0x12c> @ imm = #0x0
; 		return;
 8010736: bf00         	nop
; }
 8010738: 3728         	adds	r7, #0x28
 801073a: 46bd         	mov	sp, r7
 801073c: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

08010740 <$d>:
 8010740: 27 21 05 00  	.word	0x00052127
 8010744: e8 05 00 20  	.word	0x200005e8
 8010748: 98 9e 02 08  	.word	0x08029e98

0801074c <motor_calc>:
; {
 801074c: b580         	push	{r7, lr}
 801074e: b094         	sub	sp, #0x50
 8010750: af00         	add	r7, sp, #0x0
 8010752: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev_temp = dev;
 8010754: 687b         	ldr	r3, [r7, #0x4]
 8010756: 647b         	str	r3, [r7, #0x44]
; 	struct dji_motor_data *data_temp = dev_temp->data;
 8010758: 6c7b         	ldr	r3, [r7, #0x44]
 801075a: 691b         	ldr	r3, [r3, #0x10]
 801075c: 643b         	str	r3, [r7, #0x40]
; 	if (k_spin_trylock(&data_temp->data_input_lock, &key) != 0) {
 801075e: 6c3b         	ldr	r3, [r7, #0x40]
 8010760: 335c         	adds	r3, #0x5c
 8010762: 63bb         	str	r3, [r7, #0x38]
 8010764: f107 030c    	add.w	r3, r7, #0xc
 8010768: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801076a: f3ef 8311    	mrs	r3, basepri
 801076e: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8010770: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 8010772: 62fb         	str	r3, [r7, #0x2c]
 8010774: 2310         	movs	r3, #0x10
 8010776: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010778: 6abb         	ldr	r3, [r7, #0x28]
 801077a: f383 8812    	msr	basepri_max, r3
; }
 801077e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010780: f3bf 8f6f    	isb	sy
; }
 8010784: bf00         	nop
; 	return key;
 8010786: 6afb         	ldr	r3, [r7, #0x2c]
; 	int key = arch_irq_lock();
 8010788: 627b         	str	r3, [r7, #0x24]
 801078a: 6bbb         	ldr	r3, [r7, #0x38]
 801078c: 623b         	str	r3, [r7, #0x20]
; }
 801078e: bf00         	nop
 8010790: 6bbb         	ldr	r3, [r7, #0x38]
 8010792: 61fb         	str	r3, [r7, #0x1c]
; }
 8010794: bf00         	nop
; 	k->key = key;
 8010796: 6b7b         	ldr	r3, [r7, #0x34]
 8010798: 6a7a         	ldr	r2, [r7, #0x24]
 801079a: 601a         	str	r2, [r3]
; 	return 0;
 801079c: 2300         	movs	r3, #0x0
; 	if (k_spin_trylock(&data_temp->data_input_lock, &key) != 0) {
 801079e: 2b00         	cmp	r3, #0x0
 80107a0: f040 8104    	bne.w	0x80109ac <motor_calc+0x260> @ imm = #0x208
; 	const struct dji_motor_config *config_temp = dev_temp->config;
 80107a4: 6c7b         	ldr	r3, [r7, #0x44]
 80107a6: 685b         	ldr	r3, [r3, #0x4]
 80107a8: 63fb         	str	r3, [r7, #0x3c]
; 	proceed_delta_degree(dev_temp);
 80107aa: 6c78         	ldr	r0, [r7, #0x44]
 80107ac: f7ff fdf6    	bl	0x801039c <proceed_delta_degree> @ imm = #-0x414
; 	data_temp->common.rpm = data_temp->RAWrpm * convert[data_temp->convert_num][SPEED2RPM] /
 80107b0: 6c3b         	ldr	r3, [r7, #0x40]
 80107b2: f9b3 303c    	ldrsh.w	r3, [r3, #0x3c]
 80107b6: ee07 3a90    	vmov	s15, r3
 80107ba: eeb8 7ae7    	vcvt.f32.s32	s14, s15
 80107be: 6c3b         	ldr	r3, [r7, #0x40]
 80107c0: f893 3031    	ldrb.w	r3, [r3, #0x31]
 80107c4: 4619         	mov	r1, r3
 80107c6: 4a7b         	ldr	r2, [pc, #0x1ec]        @ 0x80109b4 <motor_calc+0x268>
 80107c8: 460b         	mov	r3, r1
 80107ca: 005b         	lsls	r3, r3, #0x1
 80107cc: 440b         	add	r3, r1
 80107ce: 00db         	lsls	r3, r3, #0x3
 80107d0: 4413         	add	r3, r2
 80107d2: 3308         	adds	r3, #0x8
 80107d4: edd3 7a00    	vldr	s15, [r3]
 80107d8: ee67 6a27    	vmul.f32	s13, s14, s15
; 				config_temp->gear_ratio;
 80107dc: 6bfb         	ldr	r3, [r7, #0x3c]
 80107de: ed93 7a14    	vldr	s14, [r3, #80]
; 	data_temp->common.rpm = data_temp->RAWrpm * convert[data_temp->convert_num][SPEED2RPM] /
 80107e2: eec6 7a87    	vdiv.f32	s15, s13, s14
 80107e6: 6c3b         	ldr	r3, [r7, #0x40]
 80107e8: edc3 7a01    	vstr	s15, [r3, #4]
; 	data_temp->common.torque = data_temp->RAWcurrent *
 80107ec: 6c3b         	ldr	r3, [r7, #0x40]
 80107ee: 6b9b         	ldr	r3, [r3, #0x38]
 80107f0: ee07 3a90    	vmov	s15, r3
 80107f4: eeb8 7ae7    	vcvt.f32.s32	s14, s15
; 				   convert[data_temp->convert_num][CURRENT2TORQUE] *
 80107f8: 6c3b         	ldr	r3, [r7, #0x40]
 80107fa: f893 3031    	ldrb.w	r3, [r3, #0x31]
 80107fe: 4619         	mov	r1, r3
 8010800: 4a6c         	ldr	r2, [pc, #0x1b0]        @ 0x80109b4 <motor_calc+0x268>
 8010802: 460b         	mov	r3, r1
 8010804: 005b         	lsls	r3, r3, #0x1
 8010806: 440b         	add	r3, r1
 8010808: 00db         	lsls	r3, r3, #0x3
 801080a: 4413         	add	r3, r2
 801080c: edd3 7a00    	vldr	s15, [r3]
; 	data_temp->common.torque = data_temp->RAWcurrent *
 8010810: ee27 7a27    	vmul.f32	s14, s14, s15
; 				   config_temp->gear_ratio;
 8010814: 6bfb         	ldr	r3, [r7, #0x3c]
 8010816: edd3 7a14    	vldr	s15, [r3, #80]
; 				   convert[data_temp->convert_num][CURRENT2TORQUE] *
 801081a: ee67 7a27    	vmul.f32	s15, s14, s15
; 	data_temp->common.torque = data_temp->RAWcurrent *
 801081e: 6c3b         	ldr	r3, [r7, #0x40]
 8010820: edc3 7a02    	vstr	s15, [r3, #8]
; 	bool torque_proceeded = false;
 8010824: 2300         	movs	r3, #0x0
 8010826: f887 304f    	strb.w	r3, [r7, #0x4f]
; 	for (int i = data_temp->current_mode_index;
 801082a: 6c3b         	ldr	r3, [r7, #0x40]
 801082c: f993 3032    	ldrsb.w	r3, [r3, #0x32]
 8010830: 64bb         	str	r3, [r7, #0x48]
 8010832: e0a1         	b	0x8010978 <motor_calc+0x22c> @ imm = #0x142
; 		if (config_temp->common.pid_datas[i]->pid_dev == NULL) {
 8010834: 6bfb         	ldr	r3, [r7, #0x3c]
 8010836: 6cba         	ldr	r2, [r7, #0x48]
 8010838: 3210         	adds	r2, #0x10
 801083a: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 801083e: 69db         	ldr	r3, [r3, #0x1c]
 8010840: 2b00         	cmp	r3, #0x0
 8010842: d13e         	bne	0x80108c2 <motor_calc+0x176> @ imm = #0x7c
; 			if (torque_proceeded) {
 8010844: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 8010848: 2b00         	cmp	r3, #0x0
 801084a: f040 809a    	bne.w	0x8010982 <motor_calc+0x236> @ imm = #0x134
; 			if (data_temp->target_torque > data_temp->common.torque_limit[1]) {
 801084e: 6c3b         	ldr	r3, [r7, #0x40]
 8010850: ed93 7a1a    	vldr	s14, [r3, #104]
 8010854: 6c3b         	ldr	r3, [r7, #0x40]
 8010856: edd3 7a08    	vldr	s15, [r3, #32]
 801085a: eeb4 7ae7    	vcmpe.f32	s14, s15
 801085e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8010862: dd04         	ble	0x801086e <motor_calc+0x122> @ imm = #0x8
; 				data_temp->target_torque = data_temp->common.torque_limit[1];
 8010864: 6c3b         	ldr	r3, [r7, #0x40]
 8010866: 6a1a         	ldr	r2, [r3, #0x20]
 8010868: 6c3b         	ldr	r3, [r7, #0x40]
 801086a: 669a         	str	r2, [r3, #0x68]
 801086c: e00e         	b	0x801088c <motor_calc+0x140> @ imm = #0x1c
; 			} else if (data_temp->target_torque < data_temp->common.torque_limit[0]) {
 801086e: 6c3b         	ldr	r3, [r7, #0x40]
 8010870: ed93 7a1a    	vldr	s14, [r3, #104]
 8010874: 6c3b         	ldr	r3, [r7, #0x40]
 8010876: edd3 7a07    	vldr	s15, [r3, #28]
 801087a: eeb4 7ae7    	vcmpe.f32	s14, s15
 801087e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8010882: d503         	bpl	0x801088c <motor_calc+0x140> @ imm = #0x6
; 				data_temp->target_torque = data_temp->common.torque_limit[0];
 8010884: 6c3b         	ldr	r3, [r7, #0x40]
 8010886: 69da         	ldr	r2, [r3, #0x1c]
 8010888: 6c3b         	ldr	r3, [r7, #0x40]
 801088a: 669a         	str	r2, [r3, #0x68]
; 			data_temp->target_current = data_temp->target_torque /
 801088c: 6c3b         	ldr	r3, [r7, #0x40]
 801088e: edd3 6a1a    	vldr	s13, [r3, #104]
; 						    config_temp->gear_ratio *
 8010892: 6bfb         	ldr	r3, [r7, #0x3c]
 8010894: edd3 7a14    	vldr	s15, [r3, #80]
; 			data_temp->target_current = data_temp->target_torque /
 8010898: ee86 7aa7    	vdiv.f32	s14, s13, s15
; 						    convert[data_temp->convert_num][TORQUE2CURRENT];
 801089c: 6c3b         	ldr	r3, [r7, #0x40]
 801089e: f893 3031    	ldrb.w	r3, [r3, #0x31]
 80108a2: 4619         	mov	r1, r3
 80108a4: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x80109b4 <motor_calc+0x268>
 80108a6: 460b         	mov	r3, r1
 80108a8: 005b         	lsls	r3, r3, #0x1
 80108aa: 440b         	add	r3, r1
 80108ac: 00db         	lsls	r3, r3, #0x3
 80108ae: 4413         	add	r3, r2
 80108b0: 3304         	adds	r3, #0x4
 80108b2: edd3 7a00    	vldr	s15, [r3]
; 						    config_temp->gear_ratio *
 80108b6: ee67 7a27    	vmul.f32	s15, s14, s15
; 			data_temp->target_current = data_temp->target_torque /
 80108ba: 6c3b         	ldr	r3, [r7, #0x40]
 80108bc: edc3 7a1b    	vstr	s15, [r3, #108]
; 			break;
 80108c0: e062         	b	0x8010988 <motor_calc+0x23c> @ imm = #0xc4
; 		pid_calc(config_temp->common.pid_datas[i]);
 80108c2: 6bfb         	ldr	r3, [r7, #0x3c]
 80108c4: 6cba         	ldr	r2, [r7, #0x48]
 80108c6: 3210         	adds	r2, #0x10
 80108c8: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 80108cc: 4618         	mov	r0, r3
 80108ce: f7fe fe81    	bl	0x800f5d4 <pid_calc>    @ imm = #-0x12fe
; 		if (strcmp(config_temp->common.capabilities[i], "angle") == 0) {
 80108d2: 6cba         	ldr	r2, [r7, #0x48]
 80108d4: 4613         	mov	r3, r2
 80108d6: 005b         	lsls	r3, r3, #0x1
 80108d8: 4413         	add	r3, r2
 80108da: 009b         	lsls	r3, r3, #0x2
 80108dc: 3310         	adds	r3, #0x10
 80108de: 6bfa         	ldr	r2, [r7, #0x3c]
 80108e0: 4413         	add	r3, r2
 80108e2: 4935         	ldr	r1, [pc, #0xd4]         @ 0x80109b8 <motor_calc+0x26c>
 80108e4: 4618         	mov	r0, r3
 80108e6: f7ef fec5    	bl	0x8000674 <strcmp>      @ imm = #-0x10276
 80108ea: 4603         	mov	r3, r0
 80108ec: 2b00         	cmp	r3, #0x0
 80108ee: d11e         	bne	0x801092e <motor_calc+0x1e2> @ imm = #0x3c
; 			if (data_temp->target_rpm > data_temp->common.speed_limit[1]) {
 80108f0: 6c3b         	ldr	r3, [r7, #0x40]
 80108f2: ed93 7a19    	vldr	s14, [r3, #100]
 80108f6: 6c3b         	ldr	r3, [r7, #0x40]
 80108f8: edd3 7a06    	vldr	s15, [r3, #24]
 80108fc: eeb4 7ae7    	vcmpe.f32	s14, s15
 8010900: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8010904: dd04         	ble	0x8010910 <motor_calc+0x1c4> @ imm = #0x8
; 				data_temp->target_rpm = data_temp->common.speed_limit[1];
 8010906: 6c3b         	ldr	r3, [r7, #0x40]
 8010908: 699a         	ldr	r2, [r3, #0x18]
 801090a: 6c3b         	ldr	r3, [r7, #0x40]
 801090c: 665a         	str	r2, [r3, #0x64]
 801090e: e00e         	b	0x801092e <motor_calc+0x1e2> @ imm = #0x1c
; 			} else if (data_temp->target_rpm < data_temp->common.speed_limit[0]) {
 8010910: 6c3b         	ldr	r3, [r7, #0x40]
 8010912: ed93 7a19    	vldr	s14, [r3, #100]
 8010916: 6c3b         	ldr	r3, [r7, #0x40]
 8010918: edd3 7a05    	vldr	s15, [r3, #20]
 801091c: eeb4 7ae7    	vcmpe.f32	s14, s15
 8010920: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8010924: d503         	bpl	0x801092e <motor_calc+0x1e2> @ imm = #0x6
; 				data_temp->target_rpm = data_temp->common.speed_limit[0];
 8010926: 6c3b         	ldr	r3, [r7, #0x40]
 8010928: 695a         	ldr	r2, [r3, #0x14]
 801092a: 6c3b         	ldr	r3, [r7, #0x40]
 801092c: 665a         	str	r2, [r3, #0x64]
; 		if (strcmp(config_temp->common.capabilities[i], "torque") == 0) {
 801092e: 6cba         	ldr	r2, [r7, #0x48]
 8010930: 4613         	mov	r3, r2
 8010932: 005b         	lsls	r3, r3, #0x1
 8010934: 4413         	add	r3, r2
 8010936: 009b         	lsls	r3, r3, #0x2
 8010938: 3310         	adds	r3, #0x10
 801093a: 6bfa         	ldr	r2, [r7, #0x3c]
 801093c: 4413         	add	r3, r2
 801093e: 491f         	ldr	r1, [pc, #0x7c]         @ 0x80109bc <motor_calc+0x270>
 8010940: 4618         	mov	r0, r3
 8010942: f7ef fe97    	bl	0x8000674 <strcmp>      @ imm = #-0x102d2
 8010946: 4603         	mov	r3, r0
 8010948: 2b00         	cmp	r3, #0x0
 801094a: d103         	bne	0x8010954 <motor_calc+0x208> @ imm = #0x6
; 			torque_proceeded = true;
 801094c: 2301         	movs	r3, #0x1
 801094e: f887 304f    	strb.w	r3, [r7, #0x4f]
 8010952: e00e         	b	0x8010972 <motor_calc+0x226> @ imm = #0x1c
; 		} else if (strcmp(config_temp->common.capabilities[i], "mit") == 0) {
 8010954: 6cba         	ldr	r2, [r7, #0x48]
 8010956: 4613         	mov	r3, r2
 8010958: 005b         	lsls	r3, r3, #0x1
 801095a: 4413         	add	r3, r2
 801095c: 009b         	lsls	r3, r3, #0x2
 801095e: 3310         	adds	r3, #0x10
 8010960: 6bfa         	ldr	r2, [r7, #0x3c]
 8010962: 4413         	add	r3, r2
 8010964: 4916         	ldr	r1, [pc, #0x58]         @ 0x80109c0 <motor_calc+0x274>
 8010966: 4618         	mov	r0, r3
 8010968: f7ef fe84    	bl	0x8000674 <strcmp>      @ imm = #-0x102f8
 801096c: 4603         	mov	r3, r0
 801096e: 2b00         	cmp	r3, #0x0
 8010970: d009         	beq	0x8010986 <motor_calc+0x23a> @ imm = #0x12
; 	     i < SIZE_OF_ARRAY(config_temp->common.capabilities); i++) {
 8010972: 6cbb         	ldr	r3, [r7, #0x48]
 8010974: 3301         	adds	r3, #0x1
 8010976: 64bb         	str	r3, [r7, #0x48]
 8010978: 6cbb         	ldr	r3, [r7, #0x48]
 801097a: 2b03         	cmp	r3, #0x3
 801097c: f67f af5a    	bls.w	0x8010834 <motor_calc+0xe8> @ imm = #-0x14c
 8010980: e002         	b	0x8010988 <motor_calc+0x23c> @ imm = #0x4
; 				break;
 8010982: bf00         	nop
 8010984: e000         	b	0x8010988 <motor_calc+0x23c> @ imm = #0x0
; 			break;
 8010986: bf00         	nop
; 	k_spin_unlock(&data_temp->data_input_lock, key);
 8010988: 6c3b         	ldr	r3, [r7, #0x40]
 801098a: 335c         	adds	r3, #0x5c
 801098c: 61bb         	str	r3, [r7, #0x18]
 801098e: 68fb         	ldr	r3, [r7, #0xc]
 8010990: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8010992: 68bb         	ldr	r3, [r7, #0x8]
 8010994: 617b         	str	r3, [r7, #0x14]
 8010996: 697b         	ldr	r3, [r7, #0x14]
 8010998: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801099a: 693b         	ldr	r3, [r7, #0x10]
 801099c: f383 8811    	msr	basepri, r3
; }
 80109a0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80109a2: f3bf 8f6f    	isb	sy
; }
 80109a6: bf00         	nop
; }
 80109a8: bf00         	nop
; }
 80109aa: e000         	b	0x80109ae <motor_calc+0x262> @ imm = #0x0
; 		return;
 80109ac: bf00         	nop
; }
 80109ae: 3750         	adds	r7, #0x50
 80109b0: 46bd         	mov	sp, r7
 80109b2: bd80         	pop	{r7, pc}

080109b4 <$d>:
 80109b4: d4 b0 02 08  	.word	0x0802b0d4
 80109b8: f8 9d 02 08  	.word	0x08029df8
 80109bc: 00 9e 02 08  	.word	0x08029e00
 80109c0: b4 9e 02 08  	.word	0x08029eb4

080109c4 <dji_miss_isr_handler>:
; {
 80109c4: b580         	push	{r7, lr}
 80109c6: b082         	sub	sp, #0x8
 80109c8: af00         	add	r7, sp, #0x0
 80109ca: 6078         	str	r0, [r7, #0x4]
; 	k_work_submit_to_queue(&dji_work_queue, &dji_miss_handle);
 80109cc: 4903         	ldr	r1, [pc, #0xc]          @ 0x80109dc <dji_miss_isr_handler+0x18>
 80109ce: 4804         	ldr	r0, [pc, #0x10]         @ 0x80109e0 <dji_miss_isr_handler+0x1c>
 80109d0: f015 fabd    	bl	0x8025f4e <k_work_submit_to_queue> @ imm = #0x1557a
; }
 80109d4: bf00         	nop
 80109d6: 3708         	adds	r7, #0x8
 80109d8: 46bd         	mov	sp, r7
 80109da: bd80         	pop	{r7, pc}

080109dc <$d>:
 80109dc: c8 05 00 20  	.word	0x200005c8
 80109e0: 58 23 00 20  	.word	0x20002358

080109e4 <dji_init_isr_handler>:
; {
 80109e4: b580         	push	{r7, lr}
 80109e6: b084         	sub	sp, #0x10
 80109e8: af02         	add	r7, sp, #0x8
 80109ea: 6078         	str	r0, [r7, #0x4]
; 	k_work_queue_start(&dji_work_queue, dji_work_queue_stack, CAN_SEND_STACK_SIZE,
 80109ec: 2300         	movs	r3, #0x0
 80109ee: 9300         	str	r3, [sp]
 80109f0: f04f 33ff    	mov.w	r3, #0xffffffff
 80109f4: f44f 62c0    	mov.w	r2, #0x600
 80109f8: 4905         	ldr	r1, [pc, #0x14]         @ 0x8010a10 <dji_init_isr_handler+0x2c>
 80109fa: 4806         	ldr	r0, [pc, #0x18]         @ 0x8010a14 <dji_init_isr_handler+0x30>
 80109fc: f003 fe84    	bl	0x8014708 <k_work_queue_start> @ imm = #0x3d08
; 	k_work_submit_to_queue(&dji_work_queue, &dji_init_handle);
 8010a00: 4905         	ldr	r1, [pc, #0x14]         @ 0x8010a18 <dji_init_isr_handler+0x34>
 8010a02: 4804         	ldr	r0, [pc, #0x10]         @ 0x8010a14 <dji_init_isr_handler+0x30>
 8010a04: f015 faa3    	bl	0x8025f4e <k_work_submit_to_queue> @ imm = #0x15546
; }
 8010a08: bf00         	nop
 8010a0a: 3708         	adds	r7, #0x8
 8010a0c: 46bd         	mov	sp, r7
 8010a0e: bd80         	pop	{r7, pc}

08010a10 <$d>:
 8010a10: 08 3c 00 20  	.word	0x20003c08
 8010a14: 58 23 00 20  	.word	0x20002358
 8010a18: d8 05 00 20  	.word	0x200005d8

08010a1c <dji_miss_handler>:
; {
 8010a1c: b580         	push	{r7, lr}
 8010a1e: b086         	sub	sp, #0x18
 8010a20: af00         	add	r7, sp, #0x0
 8010a22: 6078         	str	r0, [r7, #0x4]
; 	int curr_time = k_cycle_get_32();
 8010a24: f012 ff03    	bl	0x802382e <k_cycle_get_32> @ imm = #0x12e06
 8010a28: 4603         	mov	r3, r0
 8010a2a: 60fb         	str	r3, [r7, #0xc]
; 	for (int i = 0; i < CAN_COUNT; i++) {
 8010a2c: 2300         	movs	r3, #0x0
 8010a2e: 617b         	str	r3, [r7, #0x14]
 8010a30: e02e         	b	0x8010a90 <dji_miss_handler+0x74> @ imm = #0x5c
; 		for (int j = 0; j < 8; j++) {
 8010a32: 2300         	movs	r3, #0x0
 8010a34: 613b         	str	r3, [r7, #0x10]
 8010a36: e025         	b	0x8010a84 <dji_miss_handler+0x68> @ imm = #0x4a
; 			if (ctrl_structs[i].motor_devs[j]) {
 8010a38: 4919         	ldr	r1, [pc, #0x64]         @ 0x8010aa0 <dji_miss_handler+0x84>
 8010a3a: 697a         	ldr	r2, [r7, #0x14]
 8010a3c: 4613         	mov	r3, r2
 8010a3e: 015b         	lsls	r3, r3, #0x5
 8010a40: 4413         	add	r3, r2
 8010a42: 693a         	ldr	r2, [r7, #0x10]
 8010a44: 4413         	add	r3, r2
 8010a46: 3310         	adds	r3, #0x10
 8010a48: 009b         	lsls	r3, r3, #0x2
 8010a4a: 440b         	add	r3, r1
 8010a4c: 685b         	ldr	r3, [r3, #0x4]
 8010a4e: 2b00         	cmp	r3, #0x0
 8010a50: d015         	beq	0x8010a7e <dji_miss_handler+0x62> @ imm = #0x2a
; 				dji_timeout_handle(ctrl_structs[i].motor_devs[j], curr_time,
 8010a52: 4913         	ldr	r1, [pc, #0x4c]         @ 0x8010aa0 <dji_miss_handler+0x84>
 8010a54: 697a         	ldr	r2, [r7, #0x14]
 8010a56: 4613         	mov	r3, r2
 8010a58: 015b         	lsls	r3, r3, #0x5
 8010a5a: 4413         	add	r3, r2
 8010a5c: 693a         	ldr	r2, [r7, #0x10]
 8010a5e: 4413         	add	r3, r2
 8010a60: 3310         	adds	r3, #0x10
 8010a62: 009b         	lsls	r3, r3, #0x2
 8010a64: 440b         	add	r3, r1
 8010a66: 6858         	ldr	r0, [r3, #0x4]
 8010a68: 68f9         	ldr	r1, [r7, #0xc]
 8010a6a: 697a         	ldr	r2, [r7, #0x14]
 8010a6c: 4613         	mov	r3, r2
 8010a6e: 015b         	lsls	r3, r3, #0x5
 8010a70: 4413         	add	r3, r2
 8010a72: 009b         	lsls	r3, r3, #0x2
 8010a74: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8010aa0 <dji_miss_handler+0x84>
 8010a76: 4413         	add	r3, r2
 8010a78: 461a         	mov	r2, r3
 8010a7a: f7ff fdc7    	bl	0x801060c <dji_timeout_handle> @ imm = #-0x472
; 		for (int j = 0; j < 8; j++) {
 8010a7e: 693b         	ldr	r3, [r7, #0x10]
 8010a80: 3301         	adds	r3, #0x1
 8010a82: 613b         	str	r3, [r7, #0x10]
 8010a84: 693b         	ldr	r3, [r7, #0x10]
 8010a86: 2b07         	cmp	r3, #0x7
 8010a88: ddd6         	ble	0x8010a38 <dji_miss_handler+0x1c> @ imm = #-0x54
; 	for (int i = 0; i < CAN_COUNT; i++) {
 8010a8a: 697b         	ldr	r3, [r7, #0x14]
 8010a8c: 3301         	adds	r3, #0x1
 8010a8e: 617b         	str	r3, [r7, #0x14]
 8010a90: 697b         	ldr	r3, [r7, #0x14]
 8010a92: 2b01         	cmp	r3, #0x1
 8010a94: ddcd         	ble	0x8010a32 <dji_miss_handler+0x16> @ imm = #-0x66
; }
 8010a96: bf00         	nop
 8010a98: bf00         	nop
 8010a9a: 3718         	adds	r7, #0x18
 8010a9c: 46bd         	mov	sp, r7
 8010a9e: bd80         	pop	{r7, pc}

08010aa0 <$d>:
 8010aa0: 04 06 00 20  	.word	0x20000604

08010aa4 <dji_init_handler>:
; {
 8010aa4: b580         	push	{r7, lr}
 8010aa6: b08c         	sub	sp, #0x30
 8010aa8: af04         	add	r7, sp, #0x10
 8010aaa: 6078         	str	r0, [r7, #0x4]
; 	k_timer_stop(&dji_miss_handle_timer);
 8010aac: 4836         	ldr	r0, [pc, #0xd8]         @ 0x8010b88 <dji_init_handler+0xe4>
 8010aae: f012 fee9    	bl	0x8023884 <k_timer_stop> @ imm = #0x12dd2
; 	struct device *can_dev = NULL;
 8010ab2: 2300         	movs	r3, #0x0
 8010ab4: 61bb         	str	r3, [r7, #0x18]
; 	for (int i = 0; i < CAN_COUNT; i++) {
 8010ab6: 2300         	movs	r3, #0x0
 8010ab8: 61fb         	str	r3, [r7, #0x1c]
 8010aba: e04c         	b	0x8010b56 <dji_init_handler+0xb2> @ imm = #0x98
; 		k_sem_init(&ctrl_structs[i].tx_queue_sem, 3, 3); // 初始化信号量
 8010abc: 69fa         	ldr	r2, [r7, #0x1c]
 8010abe: 4613         	mov	r3, r2
 8010ac0: 015b         	lsls	r3, r3, #0x5
 8010ac2: 4413         	add	r3, r2
 8010ac4: 009b         	lsls	r3, r3, #0x2
 8010ac6: 3370         	adds	r3, #0x70
 8010ac8: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x8010b8c <dji_init_handler+0xe8>
 8010aca: 4413         	add	r3, r2
 8010acc: 3304         	adds	r3, #0x4
 8010ace: 2203         	movs	r2, #0x3
 8010ad0: 2103         	movs	r1, #0x3
 8010ad2: 4618         	mov	r0, r3
 8010ad4: f012 fee1    	bl	0x802389a <k_sem_init>  @ imm = #0x12dc2
; 		can_dev = (struct device *)ctrl_structs[i].can_dev;
 8010ad8: 492c         	ldr	r1, [pc, #0xb0]         @ 0x8010b8c <dji_init_handler+0xe8>
 8010ada: 69fa         	ldr	r2, [r7, #0x1c]
 8010adc: 4613         	mov	r3, r2
 8010ade: 015b         	lsls	r3, r3, #0x5
 8010ae0: 4413         	add	r3, r2
 8010ae2: 009b         	lsls	r3, r3, #0x2
 8010ae4: 440b         	add	r3, r1
 8010ae6: 681b         	ldr	r3, [r3]
 8010ae8: 61bb         	str	r3, [r7, #0x18]
; 		can_start(can_dev);
 8010aea: 69b8         	ldr	r0, [r7, #0x18]
 8010aec: f012 ff2e    	bl	0x802394c <can_start>   @ imm = #0x12e5c
; 		int err = can_add_rx_filter(can_dev, can_rx_callback, &ctrl_structs[i], &filter20x);
 8010af0: 69fa         	ldr	r2, [r7, #0x1c]
 8010af2: 4613         	mov	r3, r2
 8010af4: 015b         	lsls	r3, r3, #0x5
 8010af6: 4413         	add	r3, r2
 8010af8: 009b         	lsls	r3, r3, #0x2
 8010afa: 4a24         	ldr	r2, [pc, #0x90]         @ 0x8010b8c <dji_init_handler+0xe8>
 8010afc: 441a         	add	r2, r3
 8010afe: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8010b90 <dji_init_handler+0xec>
 8010b00: 4924         	ldr	r1, [pc, #0x90]         @ 0x8010b94 <dji_init_handler+0xf0>
 8010b02: 69b8         	ldr	r0, [r7, #0x18]
 8010b04: f7f6 fe5e    	bl	0x80077c4 <can_add_rx_filter> @ imm = #-0x9344
 8010b08: 6178         	str	r0, [r7, #0x14]
; 		if (err < 0) {
 8010b0a: 697b         	ldr	r3, [r7, #0x14]
 8010b0c: 2b00         	cmp	r3, #0x0
 8010b0e: da1f         	bge	0x8010b50 <dji_init_handler+0xac> @ imm = #0x3e
; 			LOG_ERR("Error adding CAN filter (err %d)", err);
 8010b10: 2304         	movs	r3, #0x4
 8010b12: 2b00         	cmp	r3, #0x0
 8010b14: d019         	beq	0x8010b4a <dji_init_handler+0xa6> @ imm = #0x32
 8010b16: 2301         	movs	r3, #0x1
 8010b18: 74fb         	strb	r3, [r7, #0x13]
 8010b1a: 7cfb         	ldrb	r3, [r7, #0x13]
 8010b1c: f083 0301    	eor	r3, r3, #0x1
 8010b20: b2db         	uxtb	r3, r3
 8010b22: 2b00         	cmp	r3, #0x0
 8010b24: d113         	bne	0x8010b4e <dji_init_handler+0xaa> @ imm = #0x26
 8010b26: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8010b98 <dji_init_handler+0xf4>
 8010b28: 6819         	ldr	r1, [r3]
 8010b2a: 697b         	ldr	r3, [r7, #0x14]
 8010b2c: 9303         	str	r3, [sp, #0xc]
 8010b2e: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8010b9c <dji_init_handler+0xf8>
 8010b30: 9302         	str	r3, [sp, #0x8]
 8010b32: 2300         	movs	r3, #0x0
 8010b34: 9301         	str	r3, [sp, #0x4]
 8010b36: 2300         	movs	r3, #0x0
 8010b38: 9300         	str	r3, [sp]
 8010b3a: 2300         	movs	r3, #0x0
 8010b3c: 2201         	movs	r2, #0x1
 8010b3e: 2000         	movs	r0, #0x0
 8010b40: f012 fed6    	bl	0x80238f0 <z_log_msg_runtime_create> @ imm = #0x12dac
 8010b44: 2300         	movs	r3, #0x0
 8010b46: 60fb         	str	r3, [r7, #0xc]
 8010b48: e002         	b	0x8010b50 <dji_init_handler+0xac> @ imm = #0x4
 8010b4a: bf00         	nop
 8010b4c: e000         	b	0x8010b50 <dji_init_handler+0xac> @ imm = #0x0
 8010b4e: bf00         	nop
; 	for (int i = 0; i < CAN_COUNT; i++) {
 8010b50: 69fb         	ldr	r3, [r7, #0x1c]
 8010b52: 3301         	adds	r3, #0x1
 8010b54: 61fb         	str	r3, [r7, #0x1c]
 8010b56: 69fb         	ldr	r3, [r7, #0x1c]
 8010b58: 2b01         	cmp	r3, #0x1
 8010b5a: ddaf         	ble	0x8010abc <dji_init_handler+0x18> @ imm = #-0xa2
; 	dji_miss_handle_timer.expiry_fn = dji_miss_isr_handler;
 8010b5c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8010b88 <dji_init_handler+0xe4>
 8010b5e: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8010ba0 <dji_init_handler+0xfc>
 8010b60: 621a         	str	r2, [r3, #0x20]
; 	k_timer_start(&dji_miss_handle_timer, K_NO_WAIT, K_MSEC(4));
 8010b62: f04f 0000    	mov.w	r0, #0x0
 8010b66: f04f 0100    	mov.w	r1, #0x0
 8010b6a: f04f 0228    	mov.w	r2, #0x28
 8010b6e: f04f 0300    	mov.w	r3, #0x0
 8010b72: e9cd 2300    	strd	r2, r3, [sp]
 8010b76: 4602         	mov	r2, r0
 8010b78: 460b         	mov	r3, r1
 8010b7a: 4803         	ldr	r0, [pc, #0xc]          @ 0x8010b88 <dji_init_handler+0xe4>
 8010b7c: f012 fe6f    	bl	0x802385e <k_timer_start> @ imm = #0x12cde
; }
 8010b80: bf00         	nop
 8010b82: 3720         	adds	r7, #0x20
 8010b84: 46bd         	mov	sp, r7
 8010b86: bd80         	pop	{r7, pc}

08010b88 <$d>:
 8010b88: f8 0b 00 20  	.word	0x20000bf8
 8010b8c: 04 06 00 20  	.word	0x20000604
 8010b90: 44 b1 02 08  	.word	0x0802b144
 8010b94: 81 ff 00 08  	.word	0x0800ff81
 8010b98: e8 05 00 20  	.word	0x200005e8
 8010b9c: b8 9e 02 08  	.word	0x08029eb8
 8010ba0: c5 09 01 08  	.word	0x080109c5

08010ba4 <dji_tx_handler>:
; {
 8010ba4: b580         	push	{r7, lr}
 8010ba6: b094         	sub	sp, #0x50
 8010ba8: af04         	add	r7, sp, #0x10
 8010baa: 6078         	str	r0, [r7, #0x4]
; 	struct motor_controller *ctrl_struct =
 8010bac: 687b         	ldr	r3, [r7, #0x4]
 8010bae: 3b64         	subs	r3, #0x64
 8010bb0: 62fb         	str	r3, [r7, #0x2c]
; 	for (int i = 0; i < 5; i++) { // For each frame
 8010bb2: 2300         	movs	r3, #0x0
 8010bb4: 63fb         	str	r3, [r7, #0x3c]
 8010bb6: e0bd         	b	0x8010d34 <dji_tx_handler+0x190> @ imm = #0x17a
; 		if (ctrl_struct->full[i]) {
 8010bb8: 6afa         	ldr	r2, [r7, #0x2c]
 8010bba: 6bfb         	ldr	r3, [r7, #0x3c]
 8010bbc: 4413         	add	r3, r2
 8010bbe: 3324         	adds	r3, #0x24
 8010bc0: 781b         	ldrb	r3, [r3]
 8010bc2: 2b00         	cmp	r3, #0x0
 8010bc4: f000 80b3    	beq.w	0x8010d2e <dji_tx_handler+0x18a> @ imm = #0x166
; 			uint8_t id_temp = ctrl_struct->mapping[0][0];
 8010bc8: 6afb         	ldr	r3, [r7, #0x2c]
 8010bca: f893 3029    	ldrb.w	r3, [r3, #0x29]
 8010bce: f887 302b    	strb.w	r3, [r7, #0x2b]
; 			uint8_t data[8] = {0};
 8010bd2: 2300         	movs	r3, #0x0
 8010bd4: 60fb         	str	r3, [r7, #0xc]
 8010bd6: 2300         	movs	r3, #0x0
 8010bd8: 613b         	str	r3, [r7, #0x10]
; 			bool packed = false;
 8010bda: 2300         	movs	r3, #0x0
 8010bdc: f887 303b    	strb.w	r3, [r7, #0x3b]
; 			for (int j = 0; j < 4; j++) {
 8010be0: 2300         	movs	r3, #0x0
 8010be2: 637b         	str	r3, [r7, #0x34]
 8010be4: e03b         	b	0x8010c5e <dji_tx_handler+0xba> @ imm = #0x76
; 				id_temp = ctrl_struct->mapping[i][j];
 8010be6: 6afa         	ldr	r2, [r7, #0x2c]
 8010be8: 6bfb         	ldr	r3, [r7, #0x3c]
 8010bea: 009b         	lsls	r3, r3, #0x2
 8010bec: 441a         	add	r2, r3
 8010bee: 6b7b         	ldr	r3, [r7, #0x34]
 8010bf0: 4413         	add	r3, r2
 8010bf2: 3329         	adds	r3, #0x29
 8010bf4: 781b         	ldrb	r3, [r3]
 8010bf6: f887 302b    	strb.w	r3, [r7, #0x2b]
; 				const struct device *dev = ctrl_struct->motor_devs[id_temp];
 8010bfa: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8010bfe: 6afa         	ldr	r2, [r7, #0x2c]
 8010c00: 3310         	adds	r3, #0x10
 8010c02: 009b         	lsls	r3, r3, #0x2
 8010c04: 4413         	add	r3, r2
 8010c06: 685b         	ldr	r3, [r3, #0x4]
 8010c08: 61bb         	str	r3, [r7, #0x18]
; 				struct dji_motor_data *data_temp = dev->data;
 8010c0a: 69bb         	ldr	r3, [r7, #0x18]
 8010c0c: 691b         	ldr	r3, [r3, #0x10]
 8010c0e: 617b         	str	r3, [r7, #0x14]
; 				if (id_temp < 8 && data_temp->online) {
 8010c10: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8010c14: 2b07         	cmp	r3, #0x7
 8010c16: d81f         	bhi	0x8010c58 <dji_tx_handler+0xb4> @ imm = #0x3e
 8010c18: 697b         	ldr	r3, [r7, #0x14]
 8010c1a: f893 3030    	ldrb.w	r3, [r3, #0x30]
 8010c1e: 2b00         	cmp	r3, #0x0
 8010c20: d01a         	beq	0x8010c58 <dji_tx_handler+0xb4> @ imm = #0x34
; 					motor_calc(ctrl_struct->motor_devs[id_temp]);
 8010c22: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8010c26: 6afa         	ldr	r2, [r7, #0x2c]
 8010c28: 3310         	adds	r3, #0x10
 8010c2a: 009b         	lsls	r3, r3, #0x2
 8010c2c: 4413         	add	r3, r2
 8010c2e: 685b         	ldr	r3, [r3, #0x4]
 8010c30: 4618         	mov	r0, r3
 8010c32: f7ff fd8b    	bl	0x801074c <motor_calc>  @ imm = #-0x4ea
; 					can_pack_add(data, ctrl_struct->motor_devs[id_temp], j);
 8010c36: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8010c3a: 6afa         	ldr	r2, [r7, #0x2c]
 8010c3c: 3310         	adds	r3, #0x10
 8010c3e: 009b         	lsls	r3, r3, #0x2
 8010c40: 4413         	add	r3, r2
 8010c42: 6859         	ldr	r1, [r3, #0x4]
 8010c44: 6b7b         	ldr	r3, [r7, #0x34]
 8010c46: b2da         	uxtb	r2, r3
 8010c48: f107 030c    	add.w	r3, r7, #0xc
 8010c4c: 4618         	mov	r0, r3
 8010c4e: f012 ff6b    	bl	0x8023b28 <can_pack_add> @ imm = #0x12ed6
; 					packed = true;
 8010c52: 2301         	movs	r3, #0x1
 8010c54: f887 303b    	strb.w	r3, [r7, #0x3b]
; 			for (int j = 0; j < 4; j++) {
 8010c58: 6b7b         	ldr	r3, [r7, #0x34]
 8010c5a: 3301         	adds	r3, #0x1
 8010c5c: 637b         	str	r3, [r7, #0x34]
 8010c5e: 6b7b         	ldr	r3, [r7, #0x34]
 8010c60: 2b03         	cmp	r3, #0x3
 8010c62: ddc0         	ble	0x8010be6 <dji_tx_handler+0x42> @ imm = #-0x80
; 			if (packed) {
 8010c64: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8010c68: 2b00         	cmp	r3, #0x0
 8010c6a: d060         	beq	0x8010d2e <dji_tx_handler+0x18a> @ imm = #0xc0
; 				txframe.id = txframe_id(i);
 8010c6c: 6bf8         	ldr	r0, [r7, #0x3c]
 8010c6e: f012 febc    	bl	0x80239ea <txframe_id>  @ imm = #0x12d78
 8010c72: 4603         	mov	r3, r0
 8010c74: 461a         	mov	r2, r3
 8010c76: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8010d48 <dji_tx_handler+0x1a4>
 8010c78: 601a         	str	r2, [r3]
; 				txframe.dlc = 8;
 8010c7a: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8010d48 <dji_tx_handler+0x1a4>
 8010c7c: 2208         	movs	r2, #0x8
 8010c7e: 711a         	strb	r2, [r3, #0x4]
; 				txframe.flags = 0;
 8010c80: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8010d48 <dji_tx_handler+0x1a4>
 8010c82: 2200         	movs	r2, #0x0
 8010c84: 715a         	strb	r2, [r3, #0x5]
; 				memcpy(txframe.data, data, sizeof(data));
 8010c86: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8010d48 <dji_tx_handler+0x1a4>
 8010c88: 3308         	adds	r3, #0x8
 8010c8a: f107 020c    	add.w	r2, r7, #0xc
 8010c8e: e892 0003    	ldm.w	r2, {r0, r1}
 8010c92: e883 0003    	stm.w	r3, {r0, r1}
; 				const struct device *can_dev = ctrl_struct->can_dev;
 8010c96: 6afb         	ldr	r3, [r7, #0x2c]
 8010c98: 681b         	ldr	r3, [r3]
 8010c9a: 627b         	str	r3, [r7, #0x24]
; 				int err = k_sem_take(&ctrl_struct->tx_queue_sem, K_NO_WAIT);
 8010c9c: 6afb         	ldr	r3, [r7, #0x2c]
 8010c9e: f103 0174    	add.w	r1, r3, #0x74
 8010ca2: f04f 0200    	mov.w	r2, #0x0
 8010ca6: f04f 0300    	mov.w	r3, #0x0
 8010caa: 4608         	mov	r0, r1
 8010cac: f012 fe05    	bl	0x80238ba <k_sem_take>  @ imm = #0x12c0a
 8010cb0: 6338         	str	r0, [r7, #0x30]
; 				if (err == 0) {
 8010cb2: 6b3b         	ldr	r3, [r7, #0x30]
 8010cb4: 2b00         	cmp	r3, #0x0
 8010cb6: d10d         	bne	0x8010cd4 <dji_tx_handler+0x130> @ imm = #0x1a
; 					err = can_send(can_dev, &txframe, K_NO_WAIT,
 8010cb8: f04f 0200    	mov.w	r2, #0x0
 8010cbc: f04f 0300    	mov.w	r3, #0x0
; 						       can_tx_callback, &ctrl_struct->tx_queue_sem);
 8010cc0: 6af9         	ldr	r1, [r7, #0x2c]
 8010cc2: 3174         	adds	r1, #0x74
; 					err = can_send(can_dev, &txframe, K_NO_WAIT,
 8010cc4: 9101         	str	r1, [sp, #0x4]
 8010cc6: 4921         	ldr	r1, [pc, #0x84]         @ 0x8010d4c <dji_tx_handler+0x1a8>
 8010cc8: 9100         	str	r1, [sp]
 8010cca: 491f         	ldr	r1, [pc, #0x7c]         @ 0x8010d48 <dji_tx_handler+0x1a4>
 8010ccc: 6a78         	ldr	r0, [r7, #0x24]
 8010cce: f012 fe49    	bl	0x8023964 <can_send>    @ imm = #0x12c92
 8010cd2: 6338         	str	r0, [r7, #0x30]
; 				if (err != 0 && err != -EAGAIN && err != -EBUSY) {
 8010cd4: 6b3b         	ldr	r3, [r7, #0x30]
 8010cd6: 2b00         	cmp	r3, #0x0
 8010cd8: d029         	beq	0x8010d2e <dji_tx_handler+0x18a> @ imm = #0x52
 8010cda: 6b3b         	ldr	r3, [r7, #0x30]
 8010cdc: f113 0f0b    	cmn.w	r3, #0xb
 8010ce0: d025         	beq	0x8010d2e <dji_tx_handler+0x18a> @ imm = #0x4a
 8010ce2: 6b3b         	ldr	r3, [r7, #0x30]
 8010ce4: f113 0f10    	cmn.w	r3, #0x10
 8010ce8: d021         	beq	0x8010d2e <dji_tx_handler+0x18a> @ imm = #0x42
; 					LOG_ERR("Error sending CAN frame (err %d)", err);
 8010cea: 2304         	movs	r3, #0x4
 8010cec: 2b00         	cmp	r3, #0x0
 8010cee: d01b         	beq	0x8010d28 <dji_tx_handler+0x184> @ imm = #0x36
 8010cf0: 2301         	movs	r3, #0x1
 8010cf2: f887 3023    	strb.w	r3, [r7, #0x23]
 8010cf6: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8010cfa: f083 0301    	eor	r3, r3, #0x1
 8010cfe: b2db         	uxtb	r3, r3
 8010d00: 2b00         	cmp	r3, #0x0
 8010d02: d113         	bne	0x8010d2c <dji_tx_handler+0x188> @ imm = #0x26
 8010d04: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8010d50 <dji_tx_handler+0x1ac>
 8010d06: 6819         	ldr	r1, [r3]
 8010d08: 6b3b         	ldr	r3, [r7, #0x30]
 8010d0a: 9303         	str	r3, [sp, #0xc]
 8010d0c: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8010d54 <dji_tx_handler+0x1b0>
 8010d0e: 9302         	str	r3, [sp, #0x8]
 8010d10: 2300         	movs	r3, #0x0
 8010d12: 9301         	str	r3, [sp, #0x4]
 8010d14: 2300         	movs	r3, #0x0
 8010d16: 9300         	str	r3, [sp]
 8010d18: 2300         	movs	r3, #0x0
 8010d1a: 2201         	movs	r2, #0x1
 8010d1c: 2000         	movs	r0, #0x0
 8010d1e: f012 fde7    	bl	0x80238f0 <z_log_msg_runtime_create> @ imm = #0x12bce
 8010d22: 2300         	movs	r3, #0x0
 8010d24: 61fb         	str	r3, [r7, #0x1c]
 8010d26: e002         	b	0x8010d2e <dji_tx_handler+0x18a> @ imm = #0x4
 8010d28: bf00         	nop
 8010d2a: e000         	b	0x8010d2e <dji_tx_handler+0x18a> @ imm = #0x0
 8010d2c: bf00         	nop
; 	for (int i = 0; i < 5; i++) { // For each frame
 8010d2e: 6bfb         	ldr	r3, [r7, #0x3c]
 8010d30: 3301         	adds	r3, #0x1
 8010d32: 63fb         	str	r3, [r7, #0x3c]
 8010d34: 6bfb         	ldr	r3, [r7, #0x3c]
 8010d36: 2b04         	cmp	r3, #0x4
 8010d38: f77f af3e    	ble.w	0x8010bb8 <dji_tx_handler+0x14> @ imm = #-0x184
; }
 8010d3c: bf00         	nop
 8010d3e: bf00         	nop
 8010d40: 3740         	adds	r7, #0x40
 8010d42: 46bd         	mov	sp, r7
 8010d44: bd80         	pop	{r7, pc}
 8010d46: bf00         	nop

08010d48 <$d>:
 8010d48: 54 32 00 20  	.word	0x20003254
 8010d4c: 05 3b 02 08  	.word	0x08023b05
 8010d50: e8 05 00 20  	.word	0x200005e8
 8010d54: dc 9e 02 08  	.word	0x08029edc

08010d58 <uart_callback>:
; {
 8010d58: b580         	push	{r7, lr}
 8010d5a: b096         	sub	sp, #0x58
 8010d5c: af04         	add	r7, sp, #0x10
 8010d5e: 60f8         	str	r0, [r7, #0xc]
 8010d60: 60b9         	str	r1, [r7, #0x8]
 8010d62: 607a         	str	r2, [r7, #0x4]
; 	struct device *sbus_dev = (struct device *)user_data;
 8010d64: 687b         	ldr	r3, [r7, #0x4]
 8010d66: 647b         	str	r3, [r7, #0x44]
; 	struct sbus_driver_data *data = sbus_dev->data;
 8010d68: 6c7b         	ldr	r3, [r7, #0x44]
 8010d6a: 691b         	ldr	r3, [r3, #0x10]
 8010d6c: 643b         	str	r3, [r7, #0x40]
; 	switch (evt->type) {
 8010d6e: 68bb         	ldr	r3, [r7, #0x8]
 8010d70: 781b         	ldrb	r3, [r3]
 8010d72: 3b02         	subs	r3, #0x2
 8010d74: 2b04         	cmp	r3, #0x4
 8010d76: f200 80f1    	bhi.w	0x8010f5c <uart_callback+0x204> @ imm = #0x1e2
 8010d7a: a201         	adr	r2, #4 <uart_callback+0x27>
 8010d7c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08010d80 <$d>:
 8010d80: 95 0d 01 08  	.word	0x08010d95
 8010d84: 21 0e 01 08  	.word	0x08010e21
 8010d88: 5f 0e 01 08  	.word	0x08010e5f
 8010d8c: 5d 0f 01 08  	.word	0x08010f5d
 8010d90: 75 0e 01 08  	.word	0x08010e75

08010d94 <$t>:
; 		uint8_t *p = &(evt->data.rx.buf[evt->data.rx.offset]);
 8010d94: 68bb         	ldr	r3, [r7, #0x8]
 8010d96: 685a         	ldr	r2, [r3, #0x4]
 8010d98: 68bb         	ldr	r3, [r7, #0x8]
 8010d9a: 689b         	ldr	r3, [r3, #0x8]
 8010d9c: 4413         	add	r3, r2
 8010d9e: 627b         	str	r3, [r7, #0x24]
; 		uint16_t len = evt->data.rx.len;
 8010da0: 68bb         	ldr	r3, [r7, #0x8]
 8010da2: 68db         	ldr	r3, [r3, #0xc]
 8010da4: 847b         	strh	r3, [r7, #0x22]
; 		uint8_t *ptr_offset = p + find_begin(p, len);
 8010da6: 8c7b         	ldrh	r3, [r7, #0x22]
 8010da8: 4619         	mov	r1, r3
 8010daa: 6a78         	ldr	r0, [r7, #0x24]
 8010dac: f013 f90e    	bl	0x8023fcc <find_begin>  @ imm = #0x1321c
 8010db0: 4603         	mov	r3, r0
 8010db2: 461a         	mov	r2, r3
 8010db4: 6a7b         	ldr	r3, [r7, #0x24]
 8010db6: 4413         	add	r3, r2
 8010db8: 61fb         	str	r3, [r7, #0x1c]
; 		if (ptr_offset >= p && len >= 25 && ptr_offset < p + len) {
 8010dba: 69fa         	ldr	r2, [r7, #0x1c]
 8010dbc: 6a7b         	ldr	r3, [r7, #0x24]
 8010dbe: 429a         	cmp	r2, r3
 8010dc0: d30e         	blo	0x8010de0 <uart_callback+0x88> @ imm = #0x1c
 8010dc2: 8c7b         	ldrh	r3, [r7, #0x22]
 8010dc4: 2b18         	cmp	r3, #0x18
 8010dc6: d90b         	bls	0x8010de0 <uart_callback+0x88> @ imm = #0x16
 8010dc8: 8c7b         	ldrh	r3, [r7, #0x22]
 8010dca: 6a7a         	ldr	r2, [r7, #0x24]
 8010dcc: 4413         	add	r3, r2
 8010dce: 69fa         	ldr	r2, [r7, #0x1c]
 8010dd0: 429a         	cmp	r2, r3
 8010dd2: d205         	bhs	0x8010de0 <uart_callback+0x88> @ imm = #0xa
; 			memcpy(data->data, ptr_offset, 25);
 8010dd4: 6c3b         	ldr	r3, [r7, #0x40]
 8010dd6: 2219         	movs	r2, #0x19
 8010dd8: 69f9         	ldr	r1, [r7, #0x1c]
 8010dda: 4618         	mov	r0, r3
 8010ddc: f016 fb86    	bl	0x80274ec <memcpy>      @ imm = #0x1670c
; 		void *new_buf = NULL;
 8010de0: 2300         	movs	r3, #0x0
 8010de2: 61bb         	str	r3, [r7, #0x18]
; 		err = k_mem_slab_alloc(&uart_slab, &new_buf, K_NO_WAIT);
 8010de4: f04f 0200    	mov.w	r2, #0x0
 8010de8: f04f 0300    	mov.w	r3, #0x0
 8010dec: f107 0118    	add.w	r1, r7, #0x18
 8010df0: 485e         	ldr	r0, [pc, #0x178]        @ 0x8010f6c <uart_callback+0x214>
 8010df2: f002 fbc1    	bl	0x8013578 <k_mem_slab_alloc> @ imm = #0x2782
 8010df6: 63f8         	str	r0, [r7, #0x3c]
; 		if (err == 0 && new_buf != NULL && ((uintptr_t)new_buf & 0x3) == 0) {
 8010df8: 6bfb         	ldr	r3, [r7, #0x3c]
 8010dfa: 2b00         	cmp	r3, #0x0
 8010dfc: d10e         	bne	0x8010e1c <uart_callback+0xc4> @ imm = #0x1c
 8010dfe: 69bb         	ldr	r3, [r7, #0x18]
 8010e00: 2b00         	cmp	r3, #0x0
 8010e02: d00b         	beq	0x8010e1c <uart_callback+0xc4> @ imm = #0x16
 8010e04: 69bb         	ldr	r3, [r7, #0x18]
 8010e06: f003 0303    	and	r3, r3, #0x3
 8010e0a: 2b00         	cmp	r3, #0x0
 8010e0c: d106         	bne	0x8010e1c <uart_callback+0xc4> @ imm = #0xc
; 			err = uart_rx_buf_rsp(dev, new_buf, BUF_SIZE);
 8010e0e: 69bb         	ldr	r3, [r7, #0x18]
 8010e10: 2240         	movs	r2, #0x40
 8010e12: 4619         	mov	r1, r3
 8010e14: 68f8         	ldr	r0, [r7, #0xc]
 8010e16: f012 ff07    	bl	0x8023c28 <uart_rx_buf_rsp> @ imm = #0x12e0e
 8010e1a: 63f8         	str	r0, [r7, #0x3c]
; 		break;
 8010e1c: bf00         	nop
; }
 8010e1e: e0a0         	b	0x8010f62 <uart_callback+0x20a> @ imm = #0x140
; 		uint8_t *buf = NULL; // 使用 void* 类型
 8010e20: 2300         	movs	r3, #0x0
 8010e22: 617b         	str	r3, [r7, #0x14]
; 		err = k_mem_slab_alloc(&uart_slab, (void **)&buf, K_NO_WAIT);
 8010e24: f04f 0200    	mov.w	r2, #0x0
 8010e28: f04f 0300    	mov.w	r3, #0x0
 8010e2c: f107 0114    	add.w	r1, r7, #0x14
 8010e30: 484e         	ldr	r0, [pc, #0x138]        @ 0x8010f6c <uart_callback+0x214>
 8010e32: f002 fba1    	bl	0x8013578 <k_mem_slab_alloc> @ imm = #0x2742
 8010e36: 63f8         	str	r0, [r7, #0x3c]
; 		if (err == 0 && ((uintptr_t)buf & 0x3) == 0 && buf != NULL) {
 8010e38: 6bfb         	ldr	r3, [r7, #0x3c]
 8010e3a: 2b00         	cmp	r3, #0x0
 8010e3c: d10d         	bne	0x8010e5a <uart_callback+0x102> @ imm = #0x1a
 8010e3e: 697b         	ldr	r3, [r7, #0x14]
 8010e40: f003 0303    	and	r3, r3, #0x3
 8010e44: 2b00         	cmp	r3, #0x0
 8010e46: d108         	bne	0x8010e5a <uart_callback+0x102> @ imm = #0x10
 8010e48: 697b         	ldr	r3, [r7, #0x14]
 8010e4a: 2b00         	cmp	r3, #0x0
 8010e4c: d005         	beq	0x8010e5a <uart_callback+0x102> @ imm = #0xa
; 			uart_rx_buf_rsp(dev, buf, BUF_SIZE);
 8010e4e: 697b         	ldr	r3, [r7, #0x14]
 8010e50: 2240         	movs	r2, #0x40
 8010e52: 4619         	mov	r1, r3
 8010e54: 68f8         	ldr	r0, [r7, #0xc]
 8010e56: f012 fee7    	bl	0x8023c28 <uart_rx_buf_rsp> @ imm = #0x12dce
; 		break;
 8010e5a: bf00         	nop
; }
 8010e5c: e081         	b	0x8010f62 <uart_callback+0x20a> @ imm = #0x102
; 		void *buf = evt->data.rx_buf.buf;
 8010e5e: 68bb         	ldr	r3, [r7, #0x8]
 8010e60: 685b         	ldr	r3, [r3, #0x4]
 8010e62: 62bb         	str	r3, [r7, #0x28]
; 		if (buf != NULL) {
 8010e64: 6abb         	ldr	r3, [r7, #0x28]
 8010e66: 2b00         	cmp	r3, #0x0
 8010e68: d07a         	beq	0x8010f60 <uart_callback+0x208> @ imm = #0xf4
; 			k_mem_slab_free(&uart_slab, buf);
 8010e6a: 6ab9         	ldr	r1, [r7, #0x28]
 8010e6c: 483f         	ldr	r0, [pc, #0xfc]         @ 0x8010f6c <uart_callback+0x214>
 8010e6e: f013 fe9b    	bl	0x8024ba8 <k_mem_slab_free> @ imm = #0x13d36
; 		break;
 8010e72: e075         	b	0x8010f60 <uart_callback+0x208> @ imm = #0xea
; 		uint8_t *buf = NULL;
 8010e74: 2300         	movs	r3, #0x0
 8010e76: 613b         	str	r3, [r7, #0x10]
; 		err = k_mem_slab_alloc(&uart_slab, (void **)&buf, K_NO_WAIT);
 8010e78: f04f 0200    	mov.w	r2, #0x0
 8010e7c: f04f 0300    	mov.w	r3, #0x0
 8010e80: f107 0110    	add.w	r1, r7, #0x10
 8010e84: 4839         	ldr	r0, [pc, #0xe4]         @ 0x8010f6c <uart_callback+0x214>
 8010e86: f002 fb77    	bl	0x8013578 <k_mem_slab_alloc> @ imm = #0x26ee
 8010e8a: 63f8         	str	r0, [r7, #0x3c]
; 		if (err == 0 && buf != NULL && ((uintptr_t)buf & 0x3) == 0) {
 8010e8c: 6bfb         	ldr	r3, [r7, #0x3c]
 8010e8e: 2b00         	cmp	r3, #0x0
 8010e90: d140         	bne	0x8010f14 <uart_callback+0x1bc> @ imm = #0x80
 8010e92: 693b         	ldr	r3, [r7, #0x10]
 8010e94: 2b00         	cmp	r3, #0x0
 8010e96: d03d         	beq	0x8010f14 <uart_callback+0x1bc> @ imm = #0x7a
 8010e98: 693b         	ldr	r3, [r7, #0x10]
 8010e9a: f003 0303    	and	r3, r3, #0x3
 8010e9e: 2b00         	cmp	r3, #0x0
 8010ea0: d138         	bne	0x8010f14 <uart_callback+0x1bc> @ imm = #0x70
; 			memset(buf, 0, BUF_SIZE);
 8010ea2: 693b         	ldr	r3, [r7, #0x10]
 8010ea4: 2240         	movs	r2, #0x40
 8010ea6: 2100         	movs	r1, #0x0
 8010ea8: 4618         	mov	r0, r3
 8010eaa: f016 fb2d    	bl	0x8027508 <memset>      @ imm = #0x1665a
; 			err = uart_rx_enable(dev, buf, BUF_SIZE, 100);
 8010eae: 6939         	ldr	r1, [r7, #0x10]
 8010eb0: 2364         	movs	r3, #0x64
 8010eb2: 2240         	movs	r2, #0x40
 8010eb4: 68f8         	ldr	r0, [r7, #0xc]
 8010eb6: f012 fee9    	bl	0x8023c8c <uart_rx_enable> @ imm = #0x12dd2
 8010eba: 63f8         	str	r0, [r7, #0x3c]
; 			if (err) {
 8010ebc: 6bfb         	ldr	r3, [r7, #0x3c]
 8010ebe: 2b00         	cmp	r3, #0x0
 8010ec0: d04a         	beq	0x8010f58 <uart_callback+0x200> @ imm = #0x94
; 				LOG_ERR("Failed to enable RX: %d", err);
 8010ec2: 233c         	movs	r3, #0x3c
 8010ec4: 2b00         	cmp	r3, #0x0
 8010ec6: d01b         	beq	0x8010f00 <uart_callback+0x1a8> @ imm = #0x36
 8010ec8: 2301         	movs	r3, #0x1
 8010eca: f887 303b    	strb.w	r3, [r7, #0x3b]
 8010ece: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8010ed2: f083 0301    	eor	r3, r3, #0x1
 8010ed6: b2db         	uxtb	r3, r3
 8010ed8: 2b00         	cmp	r3, #0x0
 8010eda: d113         	bne	0x8010f04 <uart_callback+0x1ac> @ imm = #0x26
 8010edc: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8010f70 <uart_callback+0x218>
 8010ede: 6819         	ldr	r1, [r3]
 8010ee0: 6bfb         	ldr	r3, [r7, #0x3c]
 8010ee2: 9303         	str	r3, [sp, #0xc]
 8010ee4: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8010f74 <uart_callback+0x21c>
 8010ee6: 9302         	str	r3, [sp, #0x8]
 8010ee8: 2300         	movs	r3, #0x0
 8010eea: 9301         	str	r3, [sp, #0x4]
 8010eec: 2300         	movs	r3, #0x0
 8010eee: 9300         	str	r3, [sp]
 8010ef0: 2300         	movs	r3, #0x0
 8010ef2: 2201         	movs	r2, #0x1
 8010ef4: 2000         	movs	r0, #0x0
 8010ef6: f012 fee7    	bl	0x8023cc8 <z_log_msg_runtime_create> @ imm = #0x12dce
 8010efa: 2300         	movs	r3, #0x0
 8010efc: 637b         	str	r3, [r7, #0x34]
 8010efe: e002         	b	0x8010f06 <uart_callback+0x1ae> @ imm = #0x4
 8010f00: bf00         	nop
 8010f02: e000         	b	0x8010f06 <uart_callback+0x1ae> @ imm = #0x0
 8010f04: bf00         	nop
; 				k_mem_slab_free(&uart_slab, (void **)&buf);
 8010f06: f107 0310    	add.w	r3, r7, #0x10
 8010f0a: 4619         	mov	r1, r3
 8010f0c: 4817         	ldr	r0, [pc, #0x5c]         @ 0x8010f6c <uart_callback+0x214>
 8010f0e: f013 fe4b    	bl	0x8024ba8 <k_mem_slab_free> @ imm = #0x13c96
; 			if (err) {
 8010f12: e021         	b	0x8010f58 <uart_callback+0x200> @ imm = #0x42
; 			LOG_ERR("Failed to allocate memory: %d", err);
 8010f14: 233c         	movs	r3, #0x3c
 8010f16: 2b00         	cmp	r3, #0x0
 8010f18: d01b         	beq	0x8010f52 <uart_callback+0x1fa> @ imm = #0x36
 8010f1a: 2301         	movs	r3, #0x1
 8010f1c: f887 3033    	strb.w	r3, [r7, #0x33]
 8010f20: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8010f24: f083 0301    	eor	r3, r3, #0x1
 8010f28: b2db         	uxtb	r3, r3
 8010f2a: 2b00         	cmp	r3, #0x0
 8010f2c: d113         	bne	0x8010f56 <uart_callback+0x1fe> @ imm = #0x26
 8010f2e: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8010f70 <uart_callback+0x218>
 8010f30: 6819         	ldr	r1, [r3]
 8010f32: 6bfb         	ldr	r3, [r7, #0x3c]
 8010f34: 9303         	str	r3, [sp, #0xc]
 8010f36: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8010f78 <uart_callback+0x220>
 8010f38: 9302         	str	r3, [sp, #0x8]
 8010f3a: 2300         	movs	r3, #0x0
 8010f3c: 9301         	str	r3, [sp, #0x4]
 8010f3e: 2300         	movs	r3, #0x0
 8010f40: 9300         	str	r3, [sp]
 8010f42: 2300         	movs	r3, #0x0
 8010f44: 2201         	movs	r2, #0x1
 8010f46: 2000         	movs	r0, #0x0
 8010f48: f012 febe    	bl	0x8023cc8 <z_log_msg_runtime_create> @ imm = #0x12d7c
 8010f4c: 2300         	movs	r3, #0x0
 8010f4e: 62fb         	str	r3, [r7, #0x2c]
; 		break;
 8010f50: e002         	b	0x8010f58 <uart_callback+0x200> @ imm = #0x4
; 			LOG_ERR("Failed to allocate memory: %d", err);
 8010f52: bf00         	nop
 8010f54: e000         	b	0x8010f58 <uart_callback+0x200> @ imm = #0x0
 8010f56: bf00         	nop
; 		break;
 8010f58: bf00         	nop
; }
 8010f5a: e002         	b	0x8010f62 <uart_callback+0x20a> @ imm = #0x4
; 		break;
 8010f5c: bf00         	nop
 8010f5e: e000         	b	0x8010f62 <uart_callback+0x20a> @ imm = #0x0
; 		break;
 8010f60: bf00         	nop
; }
 8010f62: bf00         	nop
 8010f64: 3748         	adds	r7, #0x48
 8010f66: 46bd         	mov	sp, r7
 8010f68: bd80         	pop	{r7, pc}
 8010f6a: bf00         	nop

08010f6c <$d>:
 8010f6c: 30 0c 00 20  	.word	0x20000c30
 8010f70: 64 32 00 20  	.word	0x20003264
 8010f74: a0 9f 02 08  	.word	0x08029fa0
 8010f78: b8 9f 02 08  	.word	0x08029fb8

08010f7c <sbus_init>:
; {
 8010f7c: b590         	push	{r4, r7, lr}
 8010f7e: b095         	sub	sp, #0x54
 8010f80: af04         	add	r7, sp, #0x10
 8010f82: 6078         	str	r0, [r7, #0x4]
; 	if (!device_is_ready(uart_dev)) {
 8010f84: 4b88         	ldr	r3, [pc, #0x220]        @ 0x80111a8 <sbus_init+0x22c>
 8010f86: 681b         	ldr	r3, [r3]
 8010f88: 4618         	mov	r0, r3
 8010f8a: f012 fdf7    	bl	0x8023b7c <device_is_ready> @ imm = #0x12bee
 8010f8e: 4603         	mov	r3, r0
 8010f90: f083 0301    	eor	r3, r3, #0x1
 8010f94: b2db         	uxtb	r3, r3
 8010f96: 2b00         	cmp	r3, #0x0
 8010f98: d020         	beq	0x8010fdc <sbus_init+0x60> @ imm = #0x40
; 		LOG_ERR("UART device not ready");
 8010f9a: 233c         	movs	r3, #0x3c
 8010f9c: 2b00         	cmp	r3, #0x0
 8010f9e: d017         	beq	0x8010fd0 <sbus_init+0x54> @ imm = #0x2e
 8010fa0: 2301         	movs	r3, #0x1
 8010fa2: 76fb         	strb	r3, [r7, #0x1b]
 8010fa4: 7efb         	ldrb	r3, [r7, #0x1b]
 8010fa6: f083 0301    	eor	r3, r3, #0x1
 8010faa: b2db         	uxtb	r3, r3
 8010fac: 2b00         	cmp	r3, #0x0
 8010fae: d111         	bne	0x8010fd4 <sbus_init+0x58> @ imm = #0x22
 8010fb0: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x80111ac <sbus_init+0x230>
 8010fb2: 6819         	ldr	r1, [r3]
 8010fb4: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x80111b0 <sbus_init+0x234>
 8010fb6: 9302         	str	r3, [sp, #0x8]
 8010fb8: 2300         	movs	r3, #0x0
 8010fba: 9301         	str	r3, [sp, #0x4]
 8010fbc: 2300         	movs	r3, #0x0
 8010fbe: 9300         	str	r3, [sp]
 8010fc0: 2300         	movs	r3, #0x0
 8010fc2: 2201         	movs	r2, #0x1
 8010fc4: 2000         	movs	r0, #0x0
 8010fc6: f012 fe7f    	bl	0x8023cc8 <z_log_msg_runtime_create> @ imm = #0x12cfe
 8010fca: 2300         	movs	r3, #0x0
 8010fcc: 617b         	str	r3, [r7, #0x14]
 8010fce: e002         	b	0x8010fd6 <sbus_init+0x5a> @ imm = #0x4
 8010fd0: bf00         	nop
 8010fd2: e000         	b	0x8010fd6 <sbus_init+0x5a> @ imm = #0x0
 8010fd4: bf00         	nop
; 		return -ENODEV;
 8010fd6: f06f 0312    	mvn	r3, #0x12
 8010fda: e0e0         	b	0x801119e <sbus_init+0x222> @ imm = #0x1c0
; 	err = uart_callback_set(uart_dev, uart_callback, (void *)dev);
 8010fdc: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x80111a8 <sbus_init+0x22c>
 8010fde: 681b         	ldr	r3, [r3]
 8010fe0: 687a         	ldr	r2, [r7, #0x4]
 8010fe2: 4974         	ldr	r1, [pc, #0x1d0]        @ 0x80111b4 <sbus_init+0x238>
 8010fe4: 4618         	mov	r0, r3
 8010fe6: f012 fdee    	bl	0x8023bc6 <uart_callback_set> @ imm = #0x12bdc
 8010fea: 63f8         	str	r0, [r7, #0x3c]
; 	if (err) {
 8010fec: 6bfb         	ldr	r3, [r7, #0x3c]
 8010fee: 2b00         	cmp	r3, #0x0
 8010ff0: d023         	beq	0x801103a <sbus_init+0xbe> @ imm = #0x46
; 		LOG_ERR("Failed to set callback: %d", err);
 8010ff2: 233c         	movs	r3, #0x3c
 8010ff4: 2b00         	cmp	r3, #0x0
 8010ff6: d01b         	beq	0x8011030 <sbus_init+0xb4> @ imm = #0x36
 8010ff8: 2301         	movs	r3, #0x1
 8010ffa: f887 3023    	strb.w	r3, [r7, #0x23]
 8010ffe: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8011002: f083 0301    	eor	r3, r3, #0x1
 8011006: b2db         	uxtb	r3, r3
 8011008: 2b00         	cmp	r3, #0x0
 801100a: d113         	bne	0x8011034 <sbus_init+0xb8> @ imm = #0x26
 801100c: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x80111ac <sbus_init+0x230>
 801100e: 6819         	ldr	r1, [r3]
 8011010: 6bfb         	ldr	r3, [r7, #0x3c]
 8011012: 9303         	str	r3, [sp, #0xc]
 8011014: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x80111b8 <sbus_init+0x23c>
 8011016: 9302         	str	r3, [sp, #0x8]
 8011018: 2300         	movs	r3, #0x0
 801101a: 9301         	str	r3, [sp, #0x4]
 801101c: 2300         	movs	r3, #0x0
 801101e: 9300         	str	r3, [sp]
 8011020: 2300         	movs	r3, #0x0
 8011022: 2201         	movs	r2, #0x1
 8011024: 2000         	movs	r0, #0x0
 8011026: f012 fe4f    	bl	0x8023cc8 <z_log_msg_runtime_create> @ imm = #0x12c9e
 801102a: 2300         	movs	r3, #0x0
 801102c: 61fb         	str	r3, [r7, #0x1c]
 801102e: e002         	b	0x8011036 <sbus_init+0xba> @ imm = #0x4
 8011030: bf00         	nop
 8011032: e000         	b	0x8011036 <sbus_init+0xba> @ imm = #0x0
 8011034: bf00         	nop
; 		return err;
 8011036: 6bfb         	ldr	r3, [r7, #0x3c]
 8011038: e0b1         	b	0x801119e <sbus_init+0x222> @ imm = #0x162
; 	err = k_mem_slab_alloc(&uart_slab, (void **)&buf, K_NO_WAIT);
 801103a: f04f 0000    	mov.w	r0, #0x0
 801103e: f04f 0100    	mov.w	r1, #0x0
 8011042: f107 0410    	add.w	r4, r7, #0x10
 8011046: 4602         	mov	r2, r0
 8011048: 460b         	mov	r3, r1
 801104a: 4621         	mov	r1, r4
 801104c: 485b         	ldr	r0, [pc, #0x16c]        @ 0x80111bc <sbus_init+0x240>
 801104e: f002 fa93    	bl	0x8013578 <k_mem_slab_alloc> @ imm = #0x2526
 8011052: 63f8         	str	r0, [r7, #0x3c]
; 	memset(buf, 0, BUF_SIZE);
 8011054: 693b         	ldr	r3, [r7, #0x10]
 8011056: 2240         	movs	r2, #0x40
 8011058: 2100         	movs	r1, #0x0
 801105a: 4618         	mov	r0, r3
 801105c: f016 fa54    	bl	0x8027508 <memset>      @ imm = #0x164a8
; 	if (err) {
 8011060: 6bfb         	ldr	r3, [r7, #0x3c]
 8011062: 2b00         	cmp	r3, #0x0
 8011064: d023         	beq	0x80110ae <sbus_init+0x132> @ imm = #0x46
; 		LOG_ERR("Failed to allocate memory: %d", err);
 8011066: 233c         	movs	r3, #0x3c
 8011068: 2b00         	cmp	r3, #0x0
 801106a: d01b         	beq	0x80110a4 <sbus_init+0x128> @ imm = #0x36
 801106c: 2301         	movs	r3, #0x1
 801106e: f887 302b    	strb.w	r3, [r7, #0x2b]
 8011072: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8011076: f083 0301    	eor	r3, r3, #0x1
 801107a: b2db         	uxtb	r3, r3
 801107c: 2b00         	cmp	r3, #0x0
 801107e: d113         	bne	0x80110a8 <sbus_init+0x12c> @ imm = #0x26
 8011080: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x80111ac <sbus_init+0x230>
 8011082: 6819         	ldr	r1, [r3]
 8011084: 6bfb         	ldr	r3, [r7, #0x3c]
 8011086: 9303         	str	r3, [sp, #0xc]
 8011088: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x80111c0 <sbus_init+0x244>
 801108a: 9302         	str	r3, [sp, #0x8]
 801108c: 2300         	movs	r3, #0x0
 801108e: 9301         	str	r3, [sp, #0x4]
 8011090: 2300         	movs	r3, #0x0
 8011092: 9300         	str	r3, [sp]
 8011094: 2300         	movs	r3, #0x0
 8011096: 2201         	movs	r2, #0x1
 8011098: 2000         	movs	r0, #0x0
 801109a: f012 fe15    	bl	0x8023cc8 <z_log_msg_runtime_create> @ imm = #0x12c2a
 801109e: 2300         	movs	r3, #0x0
 80110a0: 627b         	str	r3, [r7, #0x24]
 80110a2: e002         	b	0x80110aa <sbus_init+0x12e> @ imm = #0x4
 80110a4: bf00         	nop
 80110a6: e000         	b	0x80110aa <sbus_init+0x12e> @ imm = #0x0
 80110a8: bf00         	nop
; 		return err;
 80110aa: 6bfb         	ldr	r3, [r7, #0x3c]
 80110ac: e077         	b	0x801119e <sbus_init+0x222> @ imm = #0xee
; 	const struct uart_config config = {.baudrate = 100000,
 80110ae: 4a45         	ldr	r2, [pc, #0x114]        @ 0x80111c4 <sbus_init+0x248>
 80110b0: f107 0308    	add.w	r3, r7, #0x8
 80110b4: e892 0003    	ldm.w	r2, {r0, r1}
 80110b8: e883 0003    	stm.w	r3, {r0, r1}
; 	err = uart_configure(uart_dev, &config);
 80110bc: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x80111a8 <sbus_init+0x22c>
 80110be: 681b         	ldr	r3, [r3]
 80110c0: f107 0208    	add.w	r2, r7, #0x8
 80110c4: 4611         	mov	r1, r2
 80110c6: 4618         	mov	r0, r3
 80110c8: f012 fdd2    	bl	0x8023c70 <uart_configure> @ imm = #0x12ba4
 80110cc: 63f8         	str	r0, [r7, #0x3c]
; 	if (err) {
 80110ce: 6bfb         	ldr	r3, [r7, #0x3c]
 80110d0: 2b00         	cmp	r3, #0x0
 80110d2: d029         	beq	0x8011128 <sbus_init+0x1ac> @ imm = #0x52
; 		LOG_ERR("Failed to configure UART: %d", err);
 80110d4: 233c         	movs	r3, #0x3c
 80110d6: 2b00         	cmp	r3, #0x0
 80110d8: d01b         	beq	0x8011112 <sbus_init+0x196> @ imm = #0x36
 80110da: 2301         	movs	r3, #0x1
 80110dc: f887 3033    	strb.w	r3, [r7, #0x33]
 80110e0: f897 3033    	ldrb.w	r3, [r7, #0x33]
 80110e4: f083 0301    	eor	r3, r3, #0x1
 80110e8: b2db         	uxtb	r3, r3
 80110ea: 2b00         	cmp	r3, #0x0
 80110ec: d113         	bne	0x8011116 <sbus_init+0x19a> @ imm = #0x26
 80110ee: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80111ac <sbus_init+0x230>
 80110f0: 6819         	ldr	r1, [r3]
 80110f2: 6bfb         	ldr	r3, [r7, #0x3c]
 80110f4: 9303         	str	r3, [sp, #0xc]
 80110f6: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x80111c8 <sbus_init+0x24c>
 80110f8: 9302         	str	r3, [sp, #0x8]
 80110fa: 2300         	movs	r3, #0x0
 80110fc: 9301         	str	r3, [sp, #0x4]
 80110fe: 2300         	movs	r3, #0x0
 8011100: 9300         	str	r3, [sp]
 8011102: 2300         	movs	r3, #0x0
 8011104: 2201         	movs	r2, #0x1
 8011106: 2000         	movs	r0, #0x0
 8011108: f012 fdde    	bl	0x8023cc8 <z_log_msg_runtime_create> @ imm = #0x12bbc
 801110c: 2300         	movs	r3, #0x0
 801110e: 62fb         	str	r3, [r7, #0x2c]
 8011110: e002         	b	0x8011118 <sbus_init+0x19c> @ imm = #0x4
 8011112: bf00         	nop
 8011114: e000         	b	0x8011118 <sbus_init+0x19c> @ imm = #0x0
 8011116: bf00         	nop
; 		k_mem_slab_free(&uart_slab, (void **)&buf);
 8011118: f107 0310    	add.w	r3, r7, #0x10
 801111c: 4619         	mov	r1, r3
 801111e: 4827         	ldr	r0, [pc, #0x9c]         @ 0x80111bc <sbus_init+0x240>
 8011120: f013 fd42    	bl	0x8024ba8 <k_mem_slab_free> @ imm = #0x13a84
; 		return err;
 8011124: 6bfb         	ldr	r3, [r7, #0x3c]
 8011126: e03a         	b	0x801119e <sbus_init+0x222> @ imm = #0x74
; 	uart_rx_disable(uart_dev);
 8011128: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80111a8 <sbus_init+0x22c>
 801112a: 681b         	ldr	r3, [r3]
 801112c: 4618         	mov	r0, r3
 801112e: f012 fdbf    	bl	0x8023cb0 <uart_rx_disable> @ imm = #0x12b7e
; 	err = uart_rx_enable(uart_dev, buf, BUF_SIZE, 100);
 8011132: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x80111a8 <sbus_init+0x22c>
 8011134: 6818         	ldr	r0, [r3]
 8011136: 6939         	ldr	r1, [r7, #0x10]
 8011138: 2364         	movs	r3, #0x64
 801113a: 2240         	movs	r2, #0x40
 801113c: f012 fda6    	bl	0x8023c8c <uart_rx_enable> @ imm = #0x12b4c
 8011140: 63f8         	str	r0, [r7, #0x3c]
; 	if (err) {
 8011142: 6bfb         	ldr	r3, [r7, #0x3c]
 8011144: 2b00         	cmp	r3, #0x0
 8011146: d029         	beq	0x801119c <sbus_init+0x220> @ imm = #0x52
; 		LOG_ERR("Failed to enable RX: %d", err);
 8011148: 233c         	movs	r3, #0x3c
 801114a: 2b00         	cmp	r3, #0x0
 801114c: d01b         	beq	0x8011186 <sbus_init+0x20a> @ imm = #0x36
 801114e: 2301         	movs	r3, #0x1
 8011150: f887 303b    	strb.w	r3, [r7, #0x3b]
 8011154: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8011158: f083 0301    	eor	r3, r3, #0x1
 801115c: b2db         	uxtb	r3, r3
 801115e: 2b00         	cmp	r3, #0x0
 8011160: d113         	bne	0x801118a <sbus_init+0x20e> @ imm = #0x26
 8011162: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80111ac <sbus_init+0x230>
 8011164: 6819         	ldr	r1, [r3]
 8011166: 6bfb         	ldr	r3, [r7, #0x3c]
 8011168: 9303         	str	r3, [sp, #0xc]
 801116a: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80111cc <sbus_init+0x250>
 801116c: 9302         	str	r3, [sp, #0x8]
 801116e: 2300         	movs	r3, #0x0
 8011170: 9301         	str	r3, [sp, #0x4]
 8011172: 2300         	movs	r3, #0x0
 8011174: 9300         	str	r3, [sp]
 8011176: 2300         	movs	r3, #0x0
 8011178: 2201         	movs	r2, #0x1
 801117a: 2000         	movs	r0, #0x0
 801117c: f012 fda4    	bl	0x8023cc8 <z_log_msg_runtime_create> @ imm = #0x12b48
 8011180: 2300         	movs	r3, #0x0
 8011182: 637b         	str	r3, [r7, #0x34]
 8011184: e002         	b	0x801118c <sbus_init+0x210> @ imm = #0x4
 8011186: bf00         	nop
 8011188: e000         	b	0x801118c <sbus_init+0x210> @ imm = #0x0
 801118a: bf00         	nop
; 		k_mem_slab_free(&uart_slab, (void **)&buf);
 801118c: f107 0310    	add.w	r3, r7, #0x10
 8011190: 4619         	mov	r1, r3
 8011192: 480a         	ldr	r0, [pc, #0x28]         @ 0x80111bc <sbus_init+0x240>
 8011194: f013 fd08    	bl	0x8024ba8 <k_mem_slab_free> @ imm = #0x13a10
; 		return err;
 8011198: 6bfb         	ldr	r3, [r7, #0x3c]
 801119a: e000         	b	0x801119e <sbus_init+0x222> @ imm = #0x0
; 	return 0;
 801119c: 2300         	movs	r3, #0x0
; }
 801119e: 4618         	mov	r0, r3
 80111a0: 3744         	adds	r7, #0x44
 80111a2: 46bd         	mov	sp, r7
 80111a4: bd90         	pop	{r4, r7, pc}
 80111a6: bf00         	nop

080111a8 <$d>:
 80111a8: b4 0a 00 20  	.word	0x20000ab4
 80111ac: 64 32 00 20  	.word	0x20003264
 80111b0: d8 9f 02 08  	.word	0x08029fd8
 80111b4: 59 0d 01 08  	.word	0x08010d59
 80111b8: f0 9f 02 08  	.word	0x08029ff0
 80111bc: 30 0c 00 20  	.word	0x20000c30
 80111c0: b8 9f 02 08  	.word	0x08029fb8
 80111c4: 2c a0 02 08  	.word	0x0802a02c
 80111c8: 0c a0 02 08  	.word	0x0802a00c
 80111cc: a0 9f 02 08  	.word	0x08029fa0

080111d0 <sbus_getchannel_percentage>:
; {
 80111d0: b580         	push	{r7, lr}
 80111d2: b086         	sub	sp, #0x18
 80111d4: af00         	add	r7, sp, #0x0
 80111d6: 6078         	str	r0, [r7, #0x4]
 80111d8: 460b         	mov	r3, r1
 80111da: 70fb         	strb	r3, [r7, #0x3]
; 	struct sbus_driver_data *data = dev->data;
 80111dc: 687b         	ldr	r3, [r7, #0x4]
 80111de: 691b         	ldr	r3, [r3, #0x10]
 80111e0: 617b         	str	r3, [r7, #0x14]
; 	sbus_parseframe(dev);
 80111e2: 6878         	ldr	r0, [r7, #0x4]
 80111e4: f012 fd8e    	bl	0x8023d04 <sbus_parseframe> @ imm = #0x12b1c
; 	float scale = 2.0f / (SBUS_MAX - SBUS_MIN);
 80111e8: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8011224 <sbus_getchannel_percentage+0x54>
 80111ea: 613b         	str	r3, [r7, #0x10]
; 	float out = (int16_t)(data->channels[channelid] - 1024) * scale;
 80111ec: 78fb         	ldrb	r3, [r7, #0x3]
 80111ee: 697a         	ldr	r2, [r7, #0x14]
 80111f0: 330c         	adds	r3, #0xc
 80111f2: 005b         	lsls	r3, r3, #0x1
 80111f4: 4413         	add	r3, r2
 80111f6: 885b         	ldrh	r3, [r3, #0x2]
 80111f8: f5a3 6380    	sub.w	r3, r3, #0x400
 80111fc: b29b         	uxth	r3, r3
 80111fe: b21b         	sxth	r3, r3
 8011200: ee07 3a90    	vmov	s15, r3
 8011204: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8011208: ed97 7a04    	vldr	s14, [r7, #16]
 801120c: ee67 7a27    	vmul.f32	s15, s14, s15
 8011210: edc7 7a03    	vstr	s15, [r7, #12]
; 	return out;
 8011214: 68fb         	ldr	r3, [r7, #0xc]
 8011216: ee07 3a90    	vmov	s15, r3
; }
 801121a: eeb0 0a67    	vmov.f32	s0, s15
 801121e: 3718         	adds	r7, #0x18
 8011220: 46bd         	mov	sp, r7
 8011222: bd80         	pop	{r7, pc}

08011224 <$d>:
 8011224: 9b 56 c3 3a  	.word	0x3ac3569b

08011228 <float_equal>:
; {
 8011228: b480         	push	{r7}
 801122a: b085         	sub	sp, #0x14
 801122c: af00         	add	r7, sp, #0x0
 801122e: ed87 0a01    	vstr	s0, [r7, #4]
 8011232: edc7 0a00    	vstr	s1, [r7]
; 	return fabsf(a - b) < 0.0001f;
 8011236: ed97 7a01    	vldr	s14, [r7, #4]
 801123a: edd7 7a00    	vldr	s15, [r7]
 801123e: ee77 7a67    	vsub.f32	s15, s14, s15
 8011242: edc7 7a03    	vstr	s15, [r7, #12]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 8011246: edd7 7a03    	vldr	s15, [r7, #12]
 801124a: eef0 7ae7    	vabs.f32	s15, s15
 801124e: edc7 7a02    	vstr	s15, [r7, #8]
;     return result;
 8011252: edd7 7a02    	vldr	s15, [r7, #8]
; 	return fabsf(a - b) < 0.0001f;
 8011256: ed9f 7a08    	vldr	s14, [pc, #32]          @ 0x8011278 <float_equal+0x50>
 801125a: eef4 7ac7    	vcmpe.f32	s15, s14
 801125e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011262: bf4c         	ite	mi
 8011264: 2301         	movmi	r3, #0x1
 8011266: 2300         	movpl	r3, #0x0
 8011268: b2db         	uxtb	r3, r3
; }
 801126a: 4618         	mov	r0, r3
 801126c: 3714         	adds	r7, #0x14
 801126e: 46bd         	mov	sp, r7
 8011270: f85d 7b04    	ldr	r7, [sp], #4
 8011274: 4770         	bx	lr
 8011276: bf00         	nop

08011278 <$d>:
 8011278: 17 b7 d1 38  	.word	0x38d1b717

0801127c <pid_calc>:
; {
 801127c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8011280: b08e         	sub	sp, #0x38
 8011282: af00         	add	r7, sp, #0x0
 8011284: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = data->pid_dev;
 8011286: 6879         	ldr	r1, [r7, #0x4]
 8011288: 69c9         	ldr	r1, [r1, #0x1c]
 801128a: 6379         	str	r1, [r7, #0x34]
; 	if (dev == NULL) {
 801128c: 6b79         	ldr	r1, [r7, #0x34]
 801128e: 2900         	cmp	r1, #0x0
 8011290: f000 8159    	beq.w	0x8011546 <pid_calc+0x2ca> @ imm = #0x2b2
; 	const struct pid_config *pid_para = dev->config;
 8011294: 6b79         	ldr	r1, [r7, #0x34]
 8011296: 6849         	ldr	r1, [r1, #0x4]
 8011298: 6339         	str	r1, [r7, #0x30]
; 	if (!pid_para->mit) {
 801129a: 6b39         	ldr	r1, [r7, #0x30]
 801129c: 7b09         	ldrb	r1, [r1, #0xc]
 801129e: f081 0101    	eor	r1, r1, #0x1
 80112a2: b2c9         	uxtb	r1, r1
 80112a4: 2900         	cmp	r1, #0x0
 80112a6: f000 80a3    	beq.w	0x80113f0 <pid_calc+0x174> @ imm = #0x146
; 		if (data->curr == NULL) {
 80112aa: 687b         	ldr	r3, [r7, #0x4]
 80112ac: 685b         	ldr	r3, [r3, #0x4]
 80112ae: 2b00         	cmp	r3, #0x0
 80112b0: f000 814b    	beq.w	0x801154a <pid_calc+0x2ce> @ imm = #0x296
; 		float kp = pid_para->k_p;
 80112b4: 6b3b         	ldr	r3, [r7, #0x30]
 80112b6: 681b         	ldr	r3, [r3]
 80112b8: 61bb         	str	r3, [r7, #0x18]
; 		float ki = pid_para->k_i;
 80112ba: 6b3b         	ldr	r3, [r7, #0x30]
 80112bc: 685b         	ldr	r3, [r3, #0x4]
 80112be: 617b         	str	r3, [r7, #0x14]
; 		float kd = pid_para->k_d;
 80112c0: 6b3b         	ldr	r3, [r7, #0x30]
 80112c2: 689b         	ldr	r3, [r3, #0x8]
 80112c4: 613b         	str	r3, [r7, #0x10]
; 		float err = *(data->ref) - *(data->curr);
 80112c6: 687b         	ldr	r3, [r7, #0x4]
 80112c8: 681b         	ldr	r3, [r3]
 80112ca: ed93 7a00    	vldr	s14, [r3]
 80112ce: 687b         	ldr	r3, [r7, #0x4]
 80112d0: 685b         	ldr	r3, [r3, #0x4]
 80112d2: edd3 7a00    	vldr	s15, [r3]
 80112d6: ee77 7a67    	vsub.f32	s15, s14, s15
 80112da: edc7 7a03    	vstr	s15, [r7, #12]
; 		float deltaT = k_cyc_to_us_near32(*(data->curr_time) - *(data->prev_time));
 80112de: 687b         	ldr	r3, [r7, #0x4]
 80112e0: 6a1b         	ldr	r3, [r3, #0x20]
 80112e2: 681a         	ldr	r2, [r3]
 80112e4: 687b         	ldr	r3, [r7, #0x4]
 80112e6: 6a5b         	ldr	r3, [r3, #0x24]
 80112e8: 681b         	ldr	r3, [r3]
 80112ea: 1ad3         	subs	r3, r2, r3
 80112ec: 2b00         	cmp	r3, #0x0
 80112ee: db11         	blt	0x8011314 <pid_calc+0x98> @ imm = #0x22
 80112f0: 687b         	ldr	r3, [r7, #0x4]
 80112f2: 6a1b         	ldr	r3, [r3, #0x20]
 80112f4: 681a         	ldr	r2, [r3]
 80112f6: 687b         	ldr	r3, [r7, #0x4]
 80112f8: 6a5b         	ldr	r3, [r3, #0x24]
 80112fa: 681b         	ldr	r3, [r3]
 80112fc: 1ad3         	subs	r3, r2, r3
 80112fe: 3354         	adds	r3, #0x54
 8011300: 08db         	lsrs	r3, r3, #0x3
 8011302: 4a95         	ldr	r2, [pc, #0x254]        @ 0x8011558 <pid_calc+0x2dc>
 8011304: fba2 2303    	umull	r2, r3, r2, r3
 8011308: 085b         	lsrs	r3, r3, #0x1
 801130a: ee07 3a90    	vmov	s15, r3
 801130e: eef8 7a67    	vcvt.f32.u32	s15, s15
 8011312: e01b         	b	0x801134c <pid_calc+0xd0> @ imm = #0x36
 8011314: 687b         	ldr	r3, [r7, #0x4]
 8011316: 6a1b         	ldr	r3, [r3, #0x20]
 8011318: 681a         	ldr	r2, [r3]
 801131a: 687b         	ldr	r3, [r7, #0x4]
 801131c: 6a5b         	ldr	r3, [r3, #0x24]
 801131e: 681b         	ldr	r3, [r3]
 8011320: 1ad3         	subs	r3, r2, r3
 8011322: 17da         	asrs	r2, r3, #0x1f
 8011324: 461c         	mov	r4, r3
 8011326: 4615         	mov	r5, r2
 8011328: f114 0a54    	adds.w	r10, r4, #0x54
 801132c: f145 0b00    	adc	r11, r5, #0x0
 8011330: f04f 02a8    	mov.w	r2, #0xa8
 8011334: f04f 0300    	mov.w	r3, #0x0
 8011338: 4650         	mov	r0, r10
 801133a: 4659         	mov	r1, r11
 801133c: f7ef f980    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x10d00
 8011340: 4602         	mov	r2, r0
 8011342: 460b         	mov	r3, r1
 8011344: ee07 2a90    	vmov	s15, r2
 8011348: eef8 7a67    	vcvt.f32.u32	s15, s15
 801134c: edc7 7a02    	vstr	s15, [r7, #8]
; 		if (!float_equal(ki, 0)) {
 8011350: eddf 0a82    	vldr	s1, [pc, #520]          @ 0x801155c <pid_calc+0x2e0>
 8011354: ed97 0a05    	vldr	s0, [r7, #20]
 8011358: f7ff ff66    	bl	0x8011228 <float_equal> @ imm = #-0x134
 801135c: 4603         	mov	r3, r0
 801135e: f083 0301    	eor	r3, r3, #0x1
 8011362: b2db         	uxtb	r3, r3
 8011364: 2b00         	cmp	r3, #0x0
 8011366: d015         	beq	0x8011394 <pid_calc+0x118> @ imm = #0x2a
; 			data->err_integral += (err * deltaT) / (1000000 * ki);
 8011368: 687b         	ldr	r3, [r7, #0x4]
 801136a: ed93 7a04    	vldr	s14, [r3, #16]
 801136e: edd7 6a03    	vldr	s13, [r7, #12]
 8011372: edd7 7a02    	vldr	s15, [r7, #8]
 8011376: ee26 6aa7    	vmul.f32	s12, s13, s15
 801137a: edd7 7a05    	vldr	s15, [r7, #20]
 801137e: eddf 6a78    	vldr	s13, [pc, #480]         @ 0x8011560 <pid_calc+0x2e4>
 8011382: ee67 6aa6    	vmul.f32	s13, s15, s13
 8011386: eec6 7a26    	vdiv.f32	s15, s12, s13
 801138a: ee77 7a27    	vadd.f32	s15, s14, s15
 801138e: 687b         	ldr	r3, [r7, #0x4]
 8011390: edc3 7a04    	vstr	s15, [r3, #16]
; 		if (!float_equal(kd, 0)) {
 8011394: eddf 0a71    	vldr	s1, [pc, #452]          @ 0x801155c <pid_calc+0x2e0>
 8011398: ed97 0a04    	vldr	s0, [r7, #16]
 801139c: f7ff ff44    	bl	0x8011228 <float_equal> @ imm = #-0x178
 80113a0: 4603         	mov	r3, r0
 80113a2: f083 0301    	eor	r3, r3, #0x1
 80113a6: b2db         	uxtb	r3, r3
 80113a8: 2b00         	cmp	r3, #0x0
 80113aa: d00c         	beq	0x80113c6 <pid_calc+0x14a> @ imm = #0x18
; 			data->err_derivate = kd * err / deltaT;
 80113ac: ed97 7a04    	vldr	s14, [r7, #16]
 80113b0: edd7 7a03    	vldr	s15, [r7, #12]
 80113b4: ee67 6a27    	vmul.f32	s13, s14, s15
 80113b8: ed97 7a02    	vldr	s14, [r7, #8]
 80113bc: eec6 7a87    	vdiv.f32	s15, s13, s14
 80113c0: 687b         	ldr	r3, [r7, #0x4]
 80113c2: edc3 7a05    	vstr	s15, [r3, #20]
; 		*(data->output) = kp * (err + data->err_integral + data->err_derivate);
 80113c6: 687b         	ldr	r3, [r7, #0x4]
 80113c8: ed93 7a04    	vldr	s14, [r3, #16]
 80113cc: edd7 7a03    	vldr	s15, [r7, #12]
 80113d0: ee37 7a27    	vadd.f32	s14, s14, s15
 80113d4: 687b         	ldr	r3, [r7, #0x4]
 80113d6: edd3 7a05    	vldr	s15, [r3, #20]
 80113da: ee37 7a27    	vadd.f32	s14, s14, s15
 80113de: 687b         	ldr	r3, [r7, #0x4]
 80113e0: 6a9b         	ldr	r3, [r3, #0x28]
 80113e2: edd7 7a06    	vldr	s15, [r7, #24]
 80113e6: ee67 7a27    	vmul.f32	s15, s14, s15
 80113ea: edc3 7a00    	vstr	s15, [r3]
 80113ee: e0af         	b	0x8011550 <pid_calc+0x2d4> @ imm = #0x15e
; 		if (data->curr == NULL) {
 80113f0: 6879         	ldr	r1, [r7, #0x4]
 80113f2: 6849         	ldr	r1, [r1, #0x4]
 80113f4: 2900         	cmp	r1, #0x0
 80113f6: f000 80aa    	beq.w	0x801154e <pid_calc+0x2d2> @ imm = #0x154
; 		float kp = pid_para->k_p;
 80113fa: 6b39         	ldr	r1, [r7, #0x30]
 80113fc: 6809         	ldr	r1, [r1]
 80113fe: 62f9         	str	r1, [r7, #0x2c]
; 		float ki = pid_para->k_i;
 8011400: 6b39         	ldr	r1, [r7, #0x30]
 8011402: 6849         	ldr	r1, [r1, #0x4]
 8011404: 62b9         	str	r1, [r7, #0x28]
; 		float kd = pid_para->k_d;
 8011406: 6b39         	ldr	r1, [r7, #0x30]
 8011408: 6889         	ldr	r1, [r1, #0x8]
 801140a: 6279         	str	r1, [r7, #0x24]
; 		float err = *(data->ref) - *(data->curr);
 801140c: 6879         	ldr	r1, [r7, #0x4]
 801140e: 6809         	ldr	r1, [r1]
 8011410: ed91 7a00    	vldr	s14, [r1]
 8011414: 6879         	ldr	r1, [r7, #0x4]
 8011416: 6849         	ldr	r1, [r1, #0x4]
 8011418: edd1 7a00    	vldr	s15, [r1]
 801141c: ee77 7a67    	vsub.f32	s15, s14, s15
 8011420: edc7 7a08    	vstr	s15, [r7, #32]
; 		float deltaT = k_cyc_to_us_near32(*(data->curr_time) - *(data->prev_time));
 8011424: 6879         	ldr	r1, [r7, #0x4]
 8011426: 6a09         	ldr	r1, [r1, #0x20]
 8011428: 6808         	ldr	r0, [r1]
 801142a: 6879         	ldr	r1, [r7, #0x4]
 801142c: 6a49         	ldr	r1, [r1, #0x24]
 801142e: 6809         	ldr	r1, [r1]
 8011430: 1a41         	subs	r1, r0, r1
 8011432: 2900         	cmp	r1, #0x0
 8011434: db11         	blt	0x801145a <pid_calc+0x1de> @ imm = #0x22
 8011436: 687b         	ldr	r3, [r7, #0x4]
 8011438: 6a1b         	ldr	r3, [r3, #0x20]
 801143a: 681a         	ldr	r2, [r3]
 801143c: 687b         	ldr	r3, [r7, #0x4]
 801143e: 6a5b         	ldr	r3, [r3, #0x24]
 8011440: 681b         	ldr	r3, [r3]
 8011442: 1ad3         	subs	r3, r2, r3
 8011444: 3354         	adds	r3, #0x54
 8011446: 08db         	lsrs	r3, r3, #0x3
 8011448: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x8011558 <pid_calc+0x2dc>
 801144a: fba2 2303    	umull	r2, r3, r2, r3
 801144e: 085b         	lsrs	r3, r3, #0x1
 8011450: ee07 3a90    	vmov	s15, r3
 8011454: eef8 7a67    	vcvt.f32.u32	s15, s15
 8011458: e01b         	b	0x8011492 <pid_calc+0x216> @ imm = #0x36
 801145a: 6879         	ldr	r1, [r7, #0x4]
 801145c: 6a09         	ldr	r1, [r1, #0x20]
 801145e: 6808         	ldr	r0, [r1]
 8011460: 6879         	ldr	r1, [r7, #0x4]
 8011462: 6a49         	ldr	r1, [r1, #0x24]
 8011464: 6809         	ldr	r1, [r1]
 8011466: 1a41         	subs	r1, r0, r1
 8011468: 17c8         	asrs	r0, r1, #0x1f
 801146a: 460a         	mov	r2, r1
 801146c: 4603         	mov	r3, r0
 801146e: f112 0854    	adds.w	r8, r2, #0x54
 8011472: f143 0900    	adc	r9, r3, #0x0
 8011476: f04f 02a8    	mov.w	r2, #0xa8
 801147a: f04f 0300    	mov.w	r3, #0x0
 801147e: 4640         	mov	r0, r8
 8011480: 4649         	mov	r1, r9
 8011482: f7ef f8dd    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x10e46
 8011486: 4602         	mov	r2, r0
 8011488: 460b         	mov	r3, r1
 801148a: ee07 2a90    	vmov	s15, r2
 801148e: eef8 7a67    	vcvt.f32.u32	s15, s15
 8011492: edc7 7a07    	vstr	s15, [r7, #28]
; 		if (!float_equal(ki, 0)) {
 8011496: eddf 0a31    	vldr	s1, [pc, #196]          @ 0x801155c <pid_calc+0x2e0>
 801149a: ed97 0a0a    	vldr	s0, [r7, #40]
 801149e: f7ff fec3    	bl	0x8011228 <float_equal> @ imm = #-0x27a
 80114a2: 4603         	mov	r3, r0
 80114a4: f083 0301    	eor	r3, r3, #0x1
 80114a8: b2db         	uxtb	r3, r3
 80114aa: 2b00         	cmp	r3, #0x0
 80114ac: d015         	beq	0x80114da <pid_calc+0x25e> @ imm = #0x2a
; 			data->err_integral += (err * deltaT) / (1000000 * ki);
 80114ae: 687b         	ldr	r3, [r7, #0x4]
 80114b0: ed93 7a04    	vldr	s14, [r3, #16]
 80114b4: edd7 6a08    	vldr	s13, [r7, #32]
 80114b8: edd7 7a07    	vldr	s15, [r7, #28]
 80114bc: ee26 6aa7    	vmul.f32	s12, s13, s15
 80114c0: edd7 7a0a    	vldr	s15, [r7, #40]
 80114c4: eddf 6a26    	vldr	s13, [pc, #152]         @ 0x8011560 <pid_calc+0x2e4>
 80114c8: ee67 6aa6    	vmul.f32	s13, s15, s13
 80114cc: eec6 7a26    	vdiv.f32	s15, s12, s13
 80114d0: ee77 7a27    	vadd.f32	s15, s14, s15
 80114d4: 687b         	ldr	r3, [r7, #0x4]
 80114d6: edc3 7a04    	vstr	s15, [r3, #16]
; 		if (!float_equal(kd, 0)) {
 80114da: eddf 0a20    	vldr	s1, [pc, #128]          @ 0x801155c <pid_calc+0x2e0>
 80114de: ed97 0a09    	vldr	s0, [r7, #36]
 80114e2: f7ff fea1    	bl	0x8011228 <float_equal> @ imm = #-0x2be
 80114e6: 4603         	mov	r3, r0
 80114e8: f083 0301    	eor	r3, r3, #0x1
 80114ec: b2db         	uxtb	r3, r3
 80114ee: 2b00         	cmp	r3, #0x0
 80114f0: d014         	beq	0x801151c <pid_calc+0x2a0> @ imm = #0x28
; 				kd * (*(data->detri_ref) - *(data->detri_curr)) / deltaT;
 80114f2: 687b         	ldr	r3, [r7, #0x4]
 80114f4: 689b         	ldr	r3, [r3, #0x8]
 80114f6: ed93 7a00    	vldr	s14, [r3]
 80114fa: 687b         	ldr	r3, [r7, #0x4]
 80114fc: 68db         	ldr	r3, [r3, #0xc]
 80114fe: edd3 7a00    	vldr	s15, [r3]
 8011502: ee37 7a67    	vsub.f32	s14, s14, s15
 8011506: edd7 7a09    	vldr	s15, [r7, #36]
 801150a: ee67 6a27    	vmul.f32	s13, s14, s15
 801150e: ed97 7a07    	vldr	s14, [r7, #28]
 8011512: eec6 7a87    	vdiv.f32	s15, s13, s14
; 			data->err_derivate =
 8011516: 687b         	ldr	r3, [r7, #0x4]
 8011518: edc3 7a05    	vstr	s15, [r3, #20]
; 		*(data->output) = kp * (err + data->err_integral + data->err_derivate);
 801151c: 687b         	ldr	r3, [r7, #0x4]
 801151e: ed93 7a04    	vldr	s14, [r3, #16]
 8011522: edd7 7a08    	vldr	s15, [r7, #32]
 8011526: ee37 7a27    	vadd.f32	s14, s14, s15
 801152a: 687b         	ldr	r3, [r7, #0x4]
 801152c: edd3 7a05    	vldr	s15, [r3, #20]
 8011530: ee37 7a27    	vadd.f32	s14, s14, s15
 8011534: 687b         	ldr	r3, [r7, #0x4]
 8011536: 6a9b         	ldr	r3, [r3, #0x28]
 8011538: edd7 7a0b    	vldr	s15, [r7, #44]
 801153c: ee67 7a27    	vmul.f32	s15, s14, s15
 8011540: edc3 7a00    	vstr	s15, [r3]
; 		return;
 8011544: e004         	b	0x8011550 <pid_calc+0x2d4> @ imm = #0x8
; 		return;
 8011546: bf00         	nop
 8011548: e002         	b	0x8011550 <pid_calc+0x2d4> @ imm = #0x4
; 			return;
 801154a: bf00         	nop
 801154c: e000         	b	0x8011550 <pid_calc+0x2d4> @ imm = #0x0
; 			return;
 801154e: bf00         	nop
; }
 8011550: 3738         	adds	r7, #0x38
 8011552: 46bd         	mov	sp, r7
 8011554: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08011558 <$d>:
 8011558: 19 86 61 18  	.word	0x18618619
 801155c: 00 00 00 00  	.word	0x00000000
 8011560: 00 24 74 49  	.word	0x49742400

08011564 <z_impl_motor_get_speed>:
; {
 8011564: b580         	push	{r7, lr}
 8011566: b084         	sub	sp, #0x10
 8011568: af00         	add	r7, sp, #0x0
 801156a: 6078         	str	r0, [r7, #0x4]
; 	const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 801156c: 687b         	ldr	r3, [r7, #0x4]
 801156e: 689b         	ldr	r3, [r3, #0x8]
 8011570: 60fb         	str	r3, [r7, #0xc]
; 	if (api->motor_get_speed == NULL) {
 8011572: 68fb         	ldr	r3, [r7, #0xc]
 8011574: 681b         	ldr	r3, [r3]
 8011576: 2b00         	cmp	r3, #0x0
 8011578: d102         	bne	0x8011580 <z_impl_motor_get_speed+0x1c> @ imm = #0x4
; 		return -ENOSYS;
 801157a: eddf 7a07    	vldr	s15, [pc, #28]          @ 0x8011598 <z_impl_motor_get_speed+0x34>
 801157e: e005         	b	0x801158c <z_impl_motor_get_speed+0x28> @ imm = #0xa
; 	return api->motor_get_speed(dev);
 8011580: 68fb         	ldr	r3, [r7, #0xc]
 8011582: 681b         	ldr	r3, [r3]
 8011584: 6878         	ldr	r0, [r7, #0x4]
 8011586: 4798         	blx	r3
 8011588: eef0 7a40    	vmov.f32	s15, s0
; }
 801158c: eeb0 0a67    	vmov.f32	s0, s15
 8011590: 3710         	adds	r7, #0x10
 8011592: 46bd         	mov	sp, r7
 8011594: bd80         	pop	{r7, pc}
 8011596: bf00         	nop

08011598 <$d>:
 8011598: 00 00 b0 c2  	.word	0xc2b00000

0801159c <z_impl_motor_get_angle>:
; {
 801159c: b580         	push	{r7, lr}
 801159e: b084         	sub	sp, #0x10
 80115a0: af00         	add	r7, sp, #0x0
 80115a2: 6078         	str	r0, [r7, #0x4]
; 	const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 80115a4: 687b         	ldr	r3, [r7, #0x4]
 80115a6: 689b         	ldr	r3, [r3, #0x8]
 80115a8: 60fb         	str	r3, [r7, #0xc]
; 	if (api->motor_get_angle == NULL) {
 80115aa: 68fb         	ldr	r3, [r7, #0xc]
 80115ac: 689b         	ldr	r3, [r3, #0x8]
 80115ae: 2b00         	cmp	r3, #0x0
 80115b0: d102         	bne	0x80115b8 <z_impl_motor_get_angle+0x1c> @ imm = #0x4
; 		return -ENOSYS;
 80115b2: eddf 7a07    	vldr	s15, [pc, #28]          @ 0x80115d0 <z_impl_motor_get_angle+0x34>
 80115b6: e005         	b	0x80115c4 <z_impl_motor_get_angle+0x28> @ imm = #0xa
; 	return api->motor_get_angle(dev);
 80115b8: 68fb         	ldr	r3, [r7, #0xc]
 80115ba: 689b         	ldr	r3, [r3, #0x8]
 80115bc: 6878         	ldr	r0, [r7, #0x4]
 80115be: 4798         	blx	r3
 80115c0: eef0 7a40    	vmov.f32	s15, s0
; }
 80115c4: eeb0 0a67    	vmov.f32	s0, s15
 80115c8: 3710         	adds	r7, #0x10
 80115ca: 46bd         	mov	sp, r7
 80115cc: bd80         	pop	{r7, pc}
 80115ce: bf00         	nop

080115d0 <$d>:
 80115d0: 00 00 b0 c2  	.word	0xc2b00000

080115d4 <steerwheel_set_speed>:
; {
 80115d4: b580         	push	{r7, lr}
 80115d6: b084         	sub	sp, #0x10
 80115d8: af00         	add	r7, sp, #0x0
 80115da: 6078         	str	r0, [r7, #0x4]
 80115dc: ed87 0a00    	vstr	s0, [r7]
; 	steerwheel_data_t *data = dev->data;
 80115e0: 687b         	ldr	r3, [r7, #0x4]
 80115e2: 691b         	ldr	r3, [r3, #0x10]
 80115e4: 60fb         	str	r3, [r7, #0xc]
; 	const steerwheel_cfg_t *cfg = dev->config;
 80115e6: 687b         	ldr	r3, [r7, #0x4]
 80115e8: 685b         	ldr	r3, [r3, #0x4]
 80115ea: 60bb         	str	r3, [r7, #0x8]
; 	data->current_angle = motor_get_angle(cfg->steer_motor);
 80115ec: 68bb         	ldr	r3, [r7, #0x8]
 80115ee: 695b         	ldr	r3, [r3, #0x14]
 80115f0: 4618         	mov	r0, r3
 80115f2: f012 fe21    	bl	0x8024238 <motor_get_angle> @ imm = #0x12c42
 80115f6: eef0 7a40    	vmov.f32	s15, s0
 80115fa: 68fb         	ldr	r3, [r7, #0xc]
 80115fc: edc3 7a00    	vstr	s15, [r3]
; 	data->current_speed = motor_get_speed(cfg->wheel_motor);
 8011600: 68bb         	ldr	r3, [r7, #0x8]
 8011602: 699b         	ldr	r3, [r3, #0x18]
 8011604: 4618         	mov	r0, r3
 8011606: f012 fe09    	bl	0x802421c <motor_get_speed> @ imm = #0x12c12
 801160a: eef0 7a40    	vmov.f32	s15, s0
 801160e: 68fb         	ldr	r3, [r7, #0xc]
 8011610: edc3 7a01    	vstr	s15, [r3, #4]
; 	if (data->current_speed < 0) {
 8011614: 68fb         	ldr	r3, [r7, #0xc]
 8011616: edd3 7a01    	vldr	s15, [r3, #4]
 801161a: eef5 7ac0    	vcmpe.f32	s15, #0
 801161e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011622: d51e         	bpl	0x8011662 <steerwheel_set_speed+0x8e> @ imm = #0x3c
; 		data->current_speed = -data->current_speed;
 8011624: 68fb         	ldr	r3, [r7, #0xc]
 8011626: edd3 7a01    	vldr	s15, [r3, #4]
 801162a: eef1 7a67    	vneg.f32	s15, s15
 801162e: 68fb         	ldr	r3, [r7, #0xc]
 8011630: edc3 7a01    	vstr	s15, [r3, #4]
; 			fmodf(data->current_angle + 180.0f - cfg->angle_offset, 360.0f);
 8011634: 68fb         	ldr	r3, [r7, #0xc]
 8011636: edd3 7a00    	vldr	s15, [r3]
 801163a: ed9f 7a23    	vldr	s14, [pc, #140]         @ 0x80116c8 <steerwheel_set_speed+0xf4>
 801163e: ee37 7a87    	vadd.f32	s14, s15, s14
 8011642: 68bb         	ldr	r3, [r7, #0x8]
 8011644: edd3 7a00    	vldr	s15, [r3]
 8011648: ee77 7a67    	vsub.f32	s15, s14, s15
 801164c: eddf 0a1f    	vldr	s1, [pc, #124]          @ 0x80116cc <steerwheel_set_speed+0xf8>
 8011650: eeb0 0a67    	vmov.f32	s0, s15
 8011654: f007 fce2    	bl	0x801901c <fmodf>       @ imm = #0x79c4
 8011658: eef0 7a40    	vmov.f32	s15, s0
; 		data->current_angle =
 801165c: 68fb         	ldr	r3, [r7, #0xc]
 801165e: edc3 7a00    	vstr	s15, [r3]
; 	data->set_rpm = (cfg->inverse_wheel ? -1 : 1) * RADPS_TO_RPM * speed / cfg->wheel_radius;
 8011662: 68bb         	ldr	r3, [r7, #0x8]
 8011664: 7c5b         	ldrb	r3, [r3, #0x11]
 8011666: 2b00         	cmp	r3, #0x0
 8011668: d002         	beq	0x8011670 <steerwheel_set_speed+0x9c> @ imm = #0x4
 801166a: eeff 7a00    	vmov.f32	s15, #-1.000000e+00
 801166e: e001         	b	0x8011674 <steerwheel_set_speed+0xa0> @ imm = #0x2
 8011670: eef7 7a00    	vmov.f32	s15, #1.000000e+00
 8011674: ed9f 7a16    	vldr	s14, [pc, #88]          @ 0x80116d0 <steerwheel_set_speed+0xfc>
 8011678: ee27 7a87    	vmul.f32	s14, s15, s14
 801167c: edd7 7a00    	vldr	s15, [r7]
 8011680: ee67 6a27    	vmul.f32	s13, s14, s15
 8011684: 68bb         	ldr	r3, [r7, #0x8]
 8011686: ed93 7a01    	vldr	s14, [r3, #4]
 801168a: eec6 7a87    	vdiv.f32	s15, s13, s14
 801168e: 68fb         	ldr	r3, [r7, #0xc]
 8011690: edc3 7a03    	vstr	s15, [r3, #12]
; 	if (data->negative) {
 8011694: 68fb         	ldr	r3, [r7, #0xc]
 8011696: 7c1b         	ldrb	r3, [r3, #0x10]
 8011698: 2b00         	cmp	r3, #0x0
 801169a: d007         	beq	0x80116ac <steerwheel_set_speed+0xd8> @ imm = #0xe
; 		data->set_rpm = -data->set_rpm;
 801169c: 68fb         	ldr	r3, [r7, #0xc]
 801169e: edd3 7a03    	vldr	s15, [r3, #12]
 80116a2: eef1 7a67    	vneg.f32	s15, s15
 80116a6: 68fb         	ldr	r3, [r7, #0xc]
 80116a8: edc3 7a03    	vstr	s15, [r3, #12]
; 	motor_set_speed(cfg->wheel_motor, data->set_rpm);
 80116ac: 68bb         	ldr	r3, [r7, #0x8]
 80116ae: 699a         	ldr	r2, [r3, #0x18]
 80116b0: 68fb         	ldr	r3, [r7, #0xc]
 80116b2: edd3 7a03    	vldr	s15, [r3, #12]
 80116b6: eeb0 0a67    	vmov.f32	s0, s15
 80116ba: 4610         	mov	r0, r2
 80116bc: f012 fdca    	bl	0x8024254 <motor_set_speed> @ imm = #0x12b94
; }
 80116c0: bf00         	nop
 80116c2: 3710         	adds	r7, #0x10
 80116c4: 46bd         	mov	sp, r7
 80116c6: bd80         	pop	{r7, pc}

080116c8 <$d>:
 80116c8: 00 00 34 43  	.word	0x43340000
 80116cc: 00 00 b4 43  	.word	0x43b40000
 80116d0: eb c9 18 41  	.word	0x4118c9eb

080116d4 <steerwheel_set_angle>:
; {
 80116d4: b580         	push	{r7, lr}
 80116d6: b088         	sub	sp, #0x20
 80116d8: af00         	add	r7, sp, #0x0
 80116da: 6078         	str	r0, [r7, #0x4]
 80116dc: ed87 0a00    	vstr	s0, [r7]
; 	steerwheel_data_t *data = dev->data;
 80116e0: 687b         	ldr	r3, [r7, #0x4]
 80116e2: 691b         	ldr	r3, [r3, #0x10]
 80116e4: 61fb         	str	r3, [r7, #0x1c]
; 	const steerwheel_cfg_t *cfg = dev->config;
 80116e6: 687b         	ldr	r3, [r7, #0x4]
 80116e8: 685b         	ldr	r3, [r3, #0x4]
 80116ea: 61bb         	str	r3, [r7, #0x18]
; 	data->current_angle = motor_get_angle(cfg->steer_motor);
 80116ec: 69bb         	ldr	r3, [r7, #0x18]
 80116ee: 695b         	ldr	r3, [r3, #0x14]
 80116f0: 4618         	mov	r0, r3
 80116f2: f012 fda1    	bl	0x8024238 <motor_get_angle> @ imm = #0x12b42
 80116f6: eef0 7a40    	vmov.f32	s15, s0
 80116fa: 69fb         	ldr	r3, [r7, #0x1c]
 80116fc: edc3 7a00    	vstr	s15, [r3]
; 	data->current_speed = motor_get_speed(cfg->wheel_motor);
 8011700: 69bb         	ldr	r3, [r7, #0x18]
 8011702: 699b         	ldr	r3, [r3, #0x18]
 8011704: 4618         	mov	r0, r3
 8011706: f012 fd89    	bl	0x802421c <motor_get_speed> @ imm = #0x12b12
 801170a: eef0 7a40    	vmov.f32	s15, s0
 801170e: 69fb         	ldr	r3, [r7, #0x1c]
 8011710: edc3 7a01    	vstr	s15, [r3, #4]
; 	if (cfg->inverse_steer) {
 8011714: 69bb         	ldr	r3, [r7, #0x18]
 8011716: 7c1b         	ldrb	r3, [r3, #0x10]
 8011718: 2b00         	cmp	r3, #0x0
 801171a: d005         	beq	0x8011728 <steerwheel_set_angle+0x54> @ imm = #0xa
; 		angle = -angle;
 801171c: edd7 7a00    	vldr	s15, [r7]
 8011720: eef1 7a67    	vneg.f32	s15, s15
 8011724: edc7 7a00    	vstr	s15, [r7]
; 	float target_angle = fmodf(angle + cfg->angle_offset, 360.0f);
 8011728: 69bb         	ldr	r3, [r7, #0x18]
 801172a: ed93 7a00    	vldr	s14, [r3]
 801172e: edd7 7a00    	vldr	s15, [r7]
 8011732: ee77 7a27    	vadd.f32	s15, s14, s15
 8011736: eddf 0a7b    	vldr	s1, [pc, #492]          @ 0x8011924 <steerwheel_set_angle+0x250>
 801173a: eeb0 0a67    	vmov.f32	s0, s15
 801173e: f007 fc6d    	bl	0x801901c <fmodf>       @ imm = #0x78da
 8011742: ed87 0a05    	vstr	s0, [r7, #20]
; 	float delta_angle = data->current_angle - target_angle;
 8011746: 69fb         	ldr	r3, [r7, #0x1c]
 8011748: ed93 7a00    	vldr	s14, [r3]
 801174c: edd7 7a05    	vldr	s15, [r7, #20]
 8011750: ee77 7a67    	vsub.f32	s15, s14, s15
 8011754: edc7 7a04    	vstr	s15, [r7, #16]
; 	data->set_angle = 0;
 8011758: 69fb         	ldr	r3, [r7, #0x1c]
 801175a: f04f 0200    	mov.w	r2, #0x0
 801175e: 609a         	str	r2, [r3, #0x8]
; 	bool prev_nega = data->negative;
 8011760: 69fb         	ldr	r3, [r7, #0x1c]
 8011762: 7c1b         	ldrb	r3, [r3, #0x10]
 8011764: 73fb         	strb	r3, [r7, #0xf]
; 	if (delta_angle > 0) {
 8011766: edd7 7a04    	vldr	s15, [r7, #16]
 801176a: eef5 7ac0    	vcmpe.f32	s15, #0
 801176e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011772: dd42         	ble	0x80117fa <steerwheel_set_angle+0x126> @ imm = #0x84
; 		if (delta_angle < 90) {
 8011774: edd7 7a04    	vldr	s15, [r7, #16]
 8011778: ed9f 7a6b    	vldr	s14, [pc, #428]         @ 0x8011928 <steerwheel_set_angle+0x254>
 801177c: eef4 7ac7    	vcmpe.f32	s15, s14
 8011780: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011784: d506         	bpl	0x8011794 <steerwheel_set_angle+0xc0> @ imm = #0xc
; 			data->set_angle = target_angle;
 8011786: 69fb         	ldr	r3, [r7, #0x1c]
 8011788: 697a         	ldr	r2, [r7, #0x14]
 801178a: 609a         	str	r2, [r3, #0x8]
; 			data->negative = false;
 801178c: 69fb         	ldr	r3, [r7, #0x1c]
 801178e: 2200         	movs	r2, #0x0
 8011790: 741a         	strb	r2, [r3, #0x10]
 8011792: e07b         	b	0x801188c <steerwheel_set_angle+0x1b8> @ imm = #0xf6
; 		} else if (delta_angle < 180) {
 8011794: edd7 7a04    	vldr	s15, [r7, #16]
 8011798: ed9f 7a64    	vldr	s14, [pc, #400]         @ 0x801192c <steerwheel_set_angle+0x258>
 801179c: eef4 7ac7    	vcmpe.f32	s15, s14
 80117a0: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80117a4: d50c         	bpl	0x80117c0 <steerwheel_set_angle+0xec> @ imm = #0x18
; 			data->set_angle = target_angle - 180.0f;
 80117a6: edd7 7a05    	vldr	s15, [r7, #20]
 80117aa: ed9f 7a60    	vldr	s14, [pc, #384]         @ 0x801192c <steerwheel_set_angle+0x258>
 80117ae: ee77 7ac7    	vsub.f32	s15, s15, s14
 80117b2: 69fb         	ldr	r3, [r7, #0x1c]
 80117b4: edc3 7a02    	vstr	s15, [r3, #8]
; 			data->negative = true;
 80117b8: 69fb         	ldr	r3, [r7, #0x1c]
 80117ba: 2201         	movs	r2, #0x1
 80117bc: 741a         	strb	r2, [r3, #0x10]
 80117be: e065         	b	0x801188c <steerwheel_set_angle+0x1b8> @ imm = #0xca
; 		} else if (delta_angle < 270) {
 80117c0: edd7 7a04    	vldr	s15, [r7, #16]
 80117c4: ed9f 7a5a    	vldr	s14, [pc, #360]         @ 0x8011930 <steerwheel_set_angle+0x25c>
 80117c8: eef4 7ac7    	vcmpe.f32	s15, s14
 80117cc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80117d0: d50c         	bpl	0x80117ec <steerwheel_set_angle+0x118> @ imm = #0x18
; 			data->set_angle = target_angle - 180.0f;
 80117d2: edd7 7a05    	vldr	s15, [r7, #20]
 80117d6: ed9f 7a55    	vldr	s14, [pc, #340]         @ 0x801192c <steerwheel_set_angle+0x258>
 80117da: ee77 7ac7    	vsub.f32	s15, s15, s14
 80117de: 69fb         	ldr	r3, [r7, #0x1c]
 80117e0: edc3 7a02    	vstr	s15, [r3, #8]
; 			data->negative = true;
 80117e4: 69fb         	ldr	r3, [r7, #0x1c]
 80117e6: 2201         	movs	r2, #0x1
 80117e8: 741a         	strb	r2, [r3, #0x10]
 80117ea: e04f         	b	0x801188c <steerwheel_set_angle+0x1b8> @ imm = #0x9e
; 			data->set_angle = target_angle;
 80117ec: 69fb         	ldr	r3, [r7, #0x1c]
 80117ee: 697a         	ldr	r2, [r7, #0x14]
 80117f0: 609a         	str	r2, [r3, #0x8]
; 			data->negative = false;
 80117f2: 69fb         	ldr	r3, [r7, #0x1c]
 80117f4: 2200         	movs	r2, #0x0
 80117f6: 741a         	strb	r2, [r3, #0x10]
 80117f8: e048         	b	0x801188c <steerwheel_set_angle+0x1b8> @ imm = #0x90
; 	} else if (delta_angle < 0) {
 80117fa: edd7 7a04    	vldr	s15, [r7, #16]
 80117fe: eef5 7ac0    	vcmpe.f32	s15, #0
 8011802: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011806: d541         	bpl	0x801188c <steerwheel_set_angle+0x1b8> @ imm = #0x82
; 		if (delta_angle > -90) {
 8011808: edd7 7a04    	vldr	s15, [r7, #16]
 801180c: ed9f 7a49    	vldr	s14, [pc, #292]         @ 0x8011934 <steerwheel_set_angle+0x260>
 8011810: eef4 7ac7    	vcmpe.f32	s15, s14
 8011814: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011818: dd06         	ble	0x8011828 <steerwheel_set_angle+0x154> @ imm = #0xc
; 			data->set_angle = target_angle;
 801181a: 69fb         	ldr	r3, [r7, #0x1c]
 801181c: 697a         	ldr	r2, [r7, #0x14]
 801181e: 609a         	str	r2, [r3, #0x8]
; 			data->negative = false;
 8011820: 69fb         	ldr	r3, [r7, #0x1c]
 8011822: 2200         	movs	r2, #0x0
 8011824: 741a         	strb	r2, [r3, #0x10]
 8011826: e031         	b	0x801188c <steerwheel_set_angle+0x1b8> @ imm = #0x62
; 		} else if (delta_angle > -180) {
 8011828: edd7 7a04    	vldr	s15, [r7, #16]
 801182c: ed9f 7a42    	vldr	s14, [pc, #264]         @ 0x8011938 <steerwheel_set_angle+0x264>
 8011830: eef4 7ac7    	vcmpe.f32	s15, s14
 8011834: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011838: dd0c         	ble	0x8011854 <steerwheel_set_angle+0x180> @ imm = #0x18
; 			data->set_angle = target_angle - 180.0f;
 801183a: edd7 7a05    	vldr	s15, [r7, #20]
 801183e: ed9f 7a3b    	vldr	s14, [pc, #236]         @ 0x801192c <steerwheel_set_angle+0x258>
 8011842: ee77 7ac7    	vsub.f32	s15, s15, s14
 8011846: 69fb         	ldr	r3, [r7, #0x1c]
 8011848: edc3 7a02    	vstr	s15, [r3, #8]
; 			data->negative = true;
 801184c: 69fb         	ldr	r3, [r7, #0x1c]
 801184e: 2201         	movs	r2, #0x1
 8011850: 741a         	strb	r2, [r3, #0x10]
 8011852: e01b         	b	0x801188c <steerwheel_set_angle+0x1b8> @ imm = #0x36
; 		} else if (delta_angle > -270) {
 8011854: edd7 7a04    	vldr	s15, [r7, #16]
 8011858: ed9f 7a38    	vldr	s14, [pc, #224]         @ 0x801193c <steerwheel_set_angle+0x268>
 801185c: eef4 7ac7    	vcmpe.f32	s15, s14
 8011860: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011864: dd0c         	ble	0x8011880 <steerwheel_set_angle+0x1ac> @ imm = #0x18
; 			data->set_angle = target_angle - 180.0f;
 8011866: edd7 7a05    	vldr	s15, [r7, #20]
 801186a: ed9f 7a30    	vldr	s14, [pc, #192]         @ 0x801192c <steerwheel_set_angle+0x258>
 801186e: ee77 7ac7    	vsub.f32	s15, s15, s14
 8011872: 69fb         	ldr	r3, [r7, #0x1c]
 8011874: edc3 7a02    	vstr	s15, [r3, #8]
; 			data->negative = true;
 8011878: 69fb         	ldr	r3, [r7, #0x1c]
 801187a: 2201         	movs	r2, #0x1
 801187c: 741a         	strb	r2, [r3, #0x10]
 801187e: e005         	b	0x801188c <steerwheel_set_angle+0x1b8> @ imm = #0xa
; 			data->set_angle = target_angle;
 8011880: 69fb         	ldr	r3, [r7, #0x1c]
 8011882: 697a         	ldr	r2, [r7, #0x14]
 8011884: 609a         	str	r2, [r3, #0x8]
; 			data->negative = false;
 8011886: 69fb         	ldr	r3, [r7, #0x1c]
 8011888: 2200         	movs	r2, #0x0
 801188a: 741a         	strb	r2, [r3, #0x10]
; 	if (data->current_speed < 0) {
 801188c: 69fb         	ldr	r3, [r7, #0x1c]
 801188e: edd3 7a01    	vldr	s15, [r3, #4]
 8011892: eef5 7ac0    	vcmpe.f32	s15, #0
 8011896: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 801189a: d51e         	bpl	0x80118da <steerwheel_set_angle+0x206> @ imm = #0x3c
; 		data->current_speed = -data->current_speed;
 801189c: 69fb         	ldr	r3, [r7, #0x1c]
 801189e: edd3 7a01    	vldr	s15, [r3, #4]
 80118a2: eef1 7a67    	vneg.f32	s15, s15
 80118a6: 69fb         	ldr	r3, [r7, #0x1c]
 80118a8: edc3 7a01    	vstr	s15, [r3, #4]
; 			fmodf(data->current_angle + 180.0f - cfg->angle_offset, 360.0f);
 80118ac: 69fb         	ldr	r3, [r7, #0x1c]
 80118ae: edd3 7a00    	vldr	s15, [r3]
 80118b2: ed9f 7a1e    	vldr	s14, [pc, #120]         @ 0x801192c <steerwheel_set_angle+0x258>
 80118b6: ee37 7a87    	vadd.f32	s14, s15, s14
 80118ba: 69bb         	ldr	r3, [r7, #0x18]
 80118bc: edd3 7a00    	vldr	s15, [r3]
 80118c0: ee77 7a67    	vsub.f32	s15, s14, s15
 80118c4: eddf 0a17    	vldr	s1, [pc, #92]           @ 0x8011924 <steerwheel_set_angle+0x250>
 80118c8: eeb0 0a67    	vmov.f32	s0, s15
 80118cc: f007 fba6    	bl	0x801901c <fmodf>       @ imm = #0x774c
 80118d0: eef0 7a40    	vmov.f32	s15, s0
; 		data->current_angle =
 80118d4: 69fb         	ldr	r3, [r7, #0x1c]
 80118d6: edc3 7a00    	vstr	s15, [r3]
; 	motor_set_angle(cfg->steer_motor, data->set_angle);
 80118da: 69bb         	ldr	r3, [r7, #0x18]
 80118dc: 695a         	ldr	r2, [r3, #0x14]
 80118de: 69fb         	ldr	r3, [r7, #0x1c]
 80118e0: edd3 7a02    	vldr	s15, [r3, #8]
 80118e4: eeb0 0a67    	vmov.f32	s0, s15
 80118e8: 4610         	mov	r0, r2
 80118ea: f012 fcc3    	bl	0x8024274 <motor_set_angle> @ imm = #0x12986
; 	if (data->negative != prev_nega) {
 80118ee: 69fb         	ldr	r3, [r7, #0x1c]
 80118f0: 7c1b         	ldrb	r3, [r3, #0x10]
 80118f2: 7bfa         	ldrb	r2, [r7, #0xf]
 80118f4: 429a         	cmp	r2, r3
 80118f6: d011         	beq	0x801191c <steerwheel_set_angle+0x248> @ imm = #0x22
; 		data->set_rpm = -data->set_rpm;
 80118f8: 69fb         	ldr	r3, [r7, #0x1c]
 80118fa: edd3 7a03    	vldr	s15, [r3, #12]
 80118fe: eef1 7a67    	vneg.f32	s15, s15
 8011902: 69fb         	ldr	r3, [r7, #0x1c]
 8011904: edc3 7a03    	vstr	s15, [r3, #12]
; 		motor_set_speed(cfg->wheel_motor, data->set_rpm);
 8011908: 69bb         	ldr	r3, [r7, #0x18]
 801190a: 699a         	ldr	r2, [r3, #0x18]
 801190c: 69fb         	ldr	r3, [r7, #0x1c]
 801190e: edd3 7a03    	vldr	s15, [r3, #12]
 8011912: eeb0 0a67    	vmov.f32	s0, s15
 8011916: 4610         	mov	r0, r2
 8011918: f012 fc9c    	bl	0x8024254 <motor_set_speed> @ imm = #0x12938
; }
 801191c: bf00         	nop
 801191e: 3720         	adds	r7, #0x20
 8011920: 46bd         	mov	sp, r7
 8011922: bd80         	pop	{r7, pc}

08011924 <$d>:
 8011924: 00 00 b4 43  	.word	0x43b40000
 8011928: 00 00 b4 42  	.word	0x42b40000
 801192c: 00 00 34 43  	.word	0x43340000
 8011930: 00 00 87 43  	.word	0x43870000
 8011934: 00 00 b4 c2  	.word	0xc2b40000
 8011938: 00 00 34 c3  	.word	0xc3340000
 801193c: 00 00 87 c3  	.word	0xc3870000

08011940 <steerwheel_get_angle>:
; {
 8011940: b580         	push	{r7, lr}
 8011942: b084         	sub	sp, #0x10
 8011944: af00         	add	r7, sp, #0x0
 8011946: 6078         	str	r0, [r7, #0x4]
; 	steerwheel_data_t *data = dev->data;
 8011948: 687b         	ldr	r3, [r7, #0x4]
 801194a: 691b         	ldr	r3, [r3, #0x10]
 801194c: 60fb         	str	r3, [r7, #0xc]
; 	const steerwheel_cfg_t *cfg = dev->config;
 801194e: 687b         	ldr	r3, [r7, #0x4]
 8011950: 685b         	ldr	r3, [r3, #0x4]
 8011952: 60bb         	str	r3, [r7, #0x8]
; 	data->current_angle = motor_get_angle(cfg->steer_motor);
 8011954: 68bb         	ldr	r3, [r7, #0x8]
 8011956: 695b         	ldr	r3, [r3, #0x14]
 8011958: 4618         	mov	r0, r3
 801195a: f012 fc6d    	bl	0x8024238 <motor_get_angle> @ imm = #0x128da
 801195e: eef0 7a40    	vmov.f32	s15, s0
 8011962: 68fb         	ldr	r3, [r7, #0xc]
 8011964: edc3 7a00    	vstr	s15, [r3]
; 	if (data->negative) {
 8011968: 68fb         	ldr	r3, [r7, #0xc]
 801196a: 7c1b         	ldrb	r3, [r3, #0x10]
 801196c: 2b00         	cmp	r3, #0x0
 801196e: d017         	beq	0x80119a0 <steerwheel_get_angle+0x60> @ imm = #0x2e
; 			fmodf(data->current_angle + 180.0f - cfg->angle_offset, 360.0f);
 8011970: 68fb         	ldr	r3, [r7, #0xc]
 8011972: edd3 7a00    	vldr	s15, [r3]
 8011976: ed9f 7a1e    	vldr	s14, [pc, #120]         @ 0x80119f0 <steerwheel_get_angle+0xb0>
 801197a: ee37 7a87    	vadd.f32	s14, s15, s14
 801197e: 68bb         	ldr	r3, [r7, #0x8]
 8011980: edd3 7a00    	vldr	s15, [r3]
 8011984: ee77 7a67    	vsub.f32	s15, s14, s15
 8011988: eddf 0a1a    	vldr	s1, [pc, #104]          @ 0x80119f4 <steerwheel_get_angle+0xb4>
 801198c: eeb0 0a67    	vmov.f32	s0, s15
 8011990: f007 fb44    	bl	0x801901c <fmodf>       @ imm = #0x7688
 8011994: eef0 7a40    	vmov.f32	s15, s0
; 		data->current_angle =
 8011998: 68fb         	ldr	r3, [r7, #0xc]
 801199a: edc3 7a00    	vstr	s15, [r3]
 801199e: e012         	b	0x80119c6 <steerwheel_get_angle+0x86> @ imm = #0x24
; 		data->current_angle = fmodf(data->current_angle - cfg->angle_offset, 360.0f);
 80119a0: 68fb         	ldr	r3, [r7, #0xc]
 80119a2: ed93 7a00    	vldr	s14, [r3]
 80119a6: 68bb         	ldr	r3, [r7, #0x8]
 80119a8: edd3 7a00    	vldr	s15, [r3]
 80119ac: ee77 7a67    	vsub.f32	s15, s14, s15
 80119b0: eddf 0a10    	vldr	s1, [pc, #64]           @ 0x80119f4 <steerwheel_get_angle+0xb4>
 80119b4: eeb0 0a67    	vmov.f32	s0, s15
 80119b8: f007 fb30    	bl	0x801901c <fmodf>       @ imm = #0x7660
 80119bc: eef0 7a40    	vmov.f32	s15, s0
 80119c0: 68fb         	ldr	r3, [r7, #0xc]
 80119c2: edc3 7a00    	vstr	s15, [r3]
; 	if (cfg->inverse_steer) {
 80119c6: 68bb         	ldr	r3, [r7, #0x8]
 80119c8: 7c1b         	ldrb	r3, [r3, #0x10]
 80119ca: 2b00         	cmp	r3, #0x0
 80119cc: d007         	beq	0x80119de <steerwheel_get_angle+0x9e> @ imm = #0xe
; 		data->current_angle = -data->current_angle;
 80119ce: 68fb         	ldr	r3, [r7, #0xc]
 80119d0: edd3 7a00    	vldr	s15, [r3]
 80119d4: eef1 7a67    	vneg.f32	s15, s15
 80119d8: 68fb         	ldr	r3, [r7, #0xc]
 80119da: edc3 7a00    	vstr	s15, [r3]
; 	return data->current_angle;
 80119de: 68fb         	ldr	r3, [r7, #0xc]
 80119e0: 681b         	ldr	r3, [r3]
 80119e2: ee07 3a90    	vmov	s15, r3
; }
 80119e6: eeb0 0a67    	vmov.f32	s0, s15
 80119ea: 3710         	adds	r7, #0x10
 80119ec: 46bd         	mov	sp, r7
 80119ee: bd80         	pop	{r7, pc}

080119f0 <$d>:
 80119f0: 00 00 34 43  	.word	0x43340000
 80119f4: 00 00 b4 43  	.word	0x43b40000

080119f8 <swchassis_init>:
; {
 80119f8: b580         	push	{r7, lr}
 80119fa: b088         	sub	sp, #0x20
 80119fc: af00         	add	r7, sp, #0x0
 80119fe: 6078         	str	r0, [r7, #0x4]
; 	chassis_data_t *data = dev->data;
 8011a00: 687b         	ldr	r3, [r7, #0x4]
 8011a02: 691b         	ldr	r3, [r3, #0x10]
 8011a04: 61bb         	str	r3, [r7, #0x18]
; 	const chassis_cfg_t *cfg = dev->config;
 8011a06: 687b         	ldr	r3, [r7, #0x4]
 8011a08: 685b         	ldr	r3, [r3, #0x4]
 8011a0a: 617b         	str	r3, [r7, #0x14]
; 	int idx = 0;
 8011a0c: 2300         	movs	r3, #0x0
 8011a0e: 61fb         	str	r3, [r7, #0x1c]
; 	while (cfg->steerwheels[idx] != NULL) {
 8011a10: e07b         	b	0x8011b0a <swchassis_init+0x112> @ imm = #0xf6
; 		arm_atan2_f32(cfg->pos_Y_offset[idx], cfg->pos_X_offset[idx], &arc);
 8011a12: 697a         	ldr	r2, [r7, #0x14]
 8011a14: 69fb         	ldr	r3, [r7, #0x1c]
 8011a16: 3308         	adds	r3, #0x8
 8011a18: 009b         	lsls	r3, r3, #0x2
 8011a1a: 4413         	add	r3, r2
 8011a1c: 3304         	adds	r3, #0x4
 8011a1e: edd3 7a00    	vldr	s15, [r3]
 8011a22: 697a         	ldr	r2, [r7, #0x14]
 8011a24: 69fb         	ldr	r3, [r7, #0x1c]
 8011a26: 3304         	adds	r3, #0x4
 8011a28: 009b         	lsls	r3, r3, #0x2
 8011a2a: 4413         	add	r3, r2
 8011a2c: 3304         	adds	r3, #0x4
 8011a2e: ed93 7a00    	vldr	s14, [r3]
 8011a32: f107 0308    	add.w	r3, r7, #0x8
 8011a36: 4618         	mov	r0, r3
 8011a38: eef0 0a47    	vmov.f32	s1, s14
 8011a3c: eeb0 0a67    	vmov.f32	s0, s15
 8011a40: f000 fb48    	bl	0x80120d4 <arm_atan2_f32> @ imm = #0x690
; 		if (arc < 0) {
 8011a44: edd7 7a02    	vldr	s15, [r7, #8]
 8011a48: eef5 7ac0    	vcmpe.f32	s15, #0
 8011a4c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011a50: d507         	bpl	0x8011a62 <swchassis_init+0x6a> @ imm = #0xe
; 			arc += 2 * PI;
 8011a52: edd7 7a02    	vldr	s15, [r7, #8]
 8011a56: ed9f 7a46    	vldr	s14, [pc, #280]         @ 0x8011b70 <swchassis_init+0x178>
 8011a5a: ee77 7a87    	vadd.f32	s15, s15, s14
 8011a5e: edc7 7a02    	vstr	s15, [r7, #8]
; 		data->angle_to_center[idx] = RAD2DEG(arc);
 8011a62: edd7 7a02    	vldr	s15, [r7, #8]
 8011a66: ed9f 7a43    	vldr	s14, [pc, #268]         @ 0x8011b74 <swchassis_init+0x17c>
 8011a6a: ee67 7a87    	vmul.f32	s15, s15, s14
 8011a6e: 69ba         	ldr	r2, [r7, #0x18]
 8011a70: 69fb         	ldr	r3, [r7, #0x1c]
 8011a72: 330a         	adds	r3, #0xa
 8011a74: 009b         	lsls	r3, r3, #0x2
 8011a76: 4413         	add	r3, r2
 8011a78: 3304         	adds	r3, #0x4
 8011a7a: edc3 7a00    	vstr	s15, [r3]
; 		arm_sqrt_f32(cfg->pos_X_offset[idx] * cfg->pos_X_offset[idx] +
 8011a7e: 697a         	ldr	r2, [r7, #0x14]
 8011a80: 69fb         	ldr	r3, [r7, #0x1c]
 8011a82: 3304         	adds	r3, #0x4
 8011a84: 009b         	lsls	r3, r3, #0x2
 8011a86: 4413         	add	r3, r2
 8011a88: 3304         	adds	r3, #0x4
 8011a8a: ed93 7a00    	vldr	s14, [r3]
 8011a8e: 697a         	ldr	r2, [r7, #0x14]
 8011a90: 69fb         	ldr	r3, [r7, #0x1c]
 8011a92: 3304         	adds	r3, #0x4
 8011a94: 009b         	lsls	r3, r3, #0x2
 8011a96: 4413         	add	r3, r2
 8011a98: 3304         	adds	r3, #0x4
 8011a9a: edd3 7a00    	vldr	s15, [r3]
 8011a9e: ee27 7a27    	vmul.f32	s14, s14, s15
; 				     cfg->pos_Y_offset[idx] * cfg->pos_Y_offset[idx],
 8011aa2: 697a         	ldr	r2, [r7, #0x14]
 8011aa4: 69fb         	ldr	r3, [r7, #0x1c]
 8011aa6: 3308         	adds	r3, #0x8
 8011aa8: 009b         	lsls	r3, r3, #0x2
 8011aaa: 4413         	add	r3, r2
 8011aac: 3304         	adds	r3, #0x4
 8011aae: edd3 6a00    	vldr	s13, [r3]
 8011ab2: 697a         	ldr	r2, [r7, #0x14]
 8011ab4: 69fb         	ldr	r3, [r7, #0x1c]
 8011ab6: 3308         	adds	r3, #0x8
 8011ab8: 009b         	lsls	r3, r3, #0x2
 8011aba: 4413         	add	r3, r2
 8011abc: 3304         	adds	r3, #0x4
 8011abe: edd3 7a00    	vldr	s15, [r3]
 8011ac2: ee66 7aa7    	vmul.f32	s15, s13, s15
; 		arm_sqrt_f32(cfg->pos_X_offset[idx] * cfg->pos_X_offset[idx] +
 8011ac6: ee77 7a27    	vadd.f32	s15, s14, s15
; 			     &data->distance_to_center[idx]);
 8011aca: 69fb         	ldr	r3, [r7, #0x1c]
 8011acc: 330e         	adds	r3, #0xe
 8011ace: 009b         	lsls	r3, r3, #0x2
 8011ad0: 69ba         	ldr	r2, [r7, #0x18]
 8011ad2: 4413         	add	r3, r2
 8011ad4: 3304         	adds	r3, #0x4
 8011ad6: edc7 7a04    	vstr	s15, [r7, #16]
 8011ada: 60fb         	str	r3, [r7, #0xc]
;     if (in >= 0.0f)
 8011adc: edd7 7a04    	vldr	s15, [r7, #16]
 8011ae0: eef5 7ac0    	vcmpe.f32	s15, #0
 8011ae4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011ae8: db07         	blt	0x8011afa <swchassis_init+0x102> @ imm = #0xe
;       __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
 8011aea: edd7 7a04    	vldr	s15, [r7, #16]
 8011aee: eef1 7ae7    	vsqrt.f32	s15, s15
 8011af2: 68fb         	ldr	r3, [r7, #0xc]
 8011af4: edc3 7a00    	vstr	s15, [r3]
;       return (ARM_MATH_SUCCESS);
 8011af8: e004         	b	0x8011b04 <swchassis_init+0x10c> @ imm = #0x8
;       *pOut = 0.0f;
 8011afa: 68fb         	ldr	r3, [r7, #0xc]
 8011afc: f04f 0200    	mov.w	r2, #0x0
 8011b00: 601a         	str	r2, [r3]
;       return (ARM_MATH_ARGUMENT_ERROR);
 8011b02: bf00         	nop
; 		idx++;
 8011b04: 69fb         	ldr	r3, [r7, #0x1c]
 8011b06: 3301         	adds	r3, #0x1
 8011b08: 61fb         	str	r3, [r7, #0x1c]
; 	while (cfg->steerwheels[idx] != NULL) {
 8011b0a: 697a         	ldr	r2, [r7, #0x14]
 8011b0c: 69fb         	ldr	r3, [r7, #0x1c]
 8011b0e: 009b         	lsls	r3, r3, #0x2
 8011b10: 4413         	add	r3, r2
 8011b12: 685b         	ldr	r3, [r3, #0x4]
 8011b14: 2b00         	cmp	r3, #0x0
 8011b16: f47f af7c    	bne.w	0x8011a12 <swchassis_init+0x1a> @ imm = #-0x108
; 	data->currTime = k_uptime_get_32();
 8011b1a: f012 fae4    	bl	0x80240e6 <k_uptime_get_32> @ imm = #0x125c8
 8011b1e: 4602         	mov	r2, r0
 8011b20: 69bb         	ldr	r3, [r7, #0x18]
 8011b22: 621a         	str	r2, [r3, #0x20]
; 	data->prevTime = data->currTime;
 8011b24: 69bb         	ldr	r3, [r7, #0x18]
 8011b26: 6a1a         	ldr	r2, [r3, #0x20]
 8011b28: 69bb         	ldr	r3, [r7, #0x18]
 8011b2a: 625a         	str	r2, [r3, #0x24]
; 	pid_reg_input(cfg->angle_pid, &(data->pid_input), &(data->static0));
 8011b2c: 697b         	ldr	r3, [r7, #0x14]
 8011b2e: 6818         	ldr	r0, [r3]
 8011b30: 69bb         	ldr	r3, [r7, #0x18]
 8011b32: f103 015c    	add.w	r1, r3, #0x5c
 8011b36: 69bb         	ldr	r3, [r7, #0x18]
 8011b38: 3360         	adds	r3, #0x60
 8011b3a: 461a         	mov	r2, r3
 8011b3c: f012 fafa    	bl	0x8024134 <pid_reg_input> @ imm = #0x125f4
; 	pid_reg_time(cfg->angle_pid, &(data->currTime), &(data->prevTime));
 8011b40: 697b         	ldr	r3, [r7, #0x14]
 8011b42: 6818         	ldr	r0, [r3]
 8011b44: 69bb         	ldr	r3, [r7, #0x18]
 8011b46: f103 0120    	add.w	r1, r3, #0x20
 8011b4a: 69bb         	ldr	r3, [r7, #0x18]
 8011b4c: 3324         	adds	r3, #0x24
 8011b4e: 461a         	mov	r2, r3
 8011b50: f012 fb18    	bl	0x8024184 <pid_reg_time> @ imm = #0x12630
; 	pid_reg_output(cfg->angle_pid, &(data->targetGyro));
 8011b54: 697b         	ldr	r3, [r7, #0x14]
 8011b56: 681a         	ldr	r2, [r3]
 8011b58: 69bb         	ldr	r3, [r7, #0x18]
 8011b5a: 3308         	adds	r3, #0x8
 8011b5c: 4619         	mov	r1, r3
 8011b5e: 4610         	mov	r0, r2
 8011b60: f012 fafe    	bl	0x8024160 <pid_reg_output> @ imm = #0x125fc
; 	return 0;
 8011b64: 2300         	movs	r3, #0x0
; }
 8011b66: 4618         	mov	r0, r3
 8011b68: 3720         	adds	r7, #0x20
 8011b6a: 46bd         	mov	sp, r7
 8011b6c: bd80         	pop	{r7, pc}
 8011b6e: bf00         	nop

08011b70 <$d>:
 8011b70: db 0f c9 40  	.word	0x40c90fdb
 8011b74: e1 2e 65 42  	.word	0x42652ee1

08011b78 <swchassis_resolve>:
; {
 8011b78: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8011b7c: b0a2         	sub	sp, #0x88
 8011b7e: af04         	add	r7, sp, #0x10
 8011b80: 6078         	str	r0, [r7, #0x4]
 8011b82: 6039         	str	r1, [r7]
; 	data->prevTime = data->currTime;
 8011b84: 687b         	ldr	r3, [r7, #0x4]
 8011b86: 6a1a         	ldr	r2, [r3, #0x20]
 8011b88: 687b         	ldr	r3, [r7, #0x4]
 8011b8a: 625a         	str	r2, [r3, #0x24]
; 	data->currTime = k_cycle_get_32();
 8011b8c: f012 fab4    	bl	0x80240f8 <k_cycle_get_32> @ imm = #0x12568
 8011b90: 4602         	mov	r2, r0
 8011b92: 687b         	ldr	r3, [r7, #0x4]
 8011b94: 621a         	str	r2, [r3, #0x20]
; 	if (data->angleControl) {
 8011b96: 687b         	ldr	r3, [r7, #0x4]
 8011b98: f893 3028    	ldrb.w	r3, [r3, #0x28]
 8011b9c: 2b00         	cmp	r3, #0x0
 8011b9e: d004         	beq	0x8011baa <swchassis_resolve+0x32> @ imm = #0x8
; 		pid_calc(cfg->angle_pid);
 8011ba0: 683b         	ldr	r3, [r7]
 8011ba2: 681b         	ldr	r3, [r3]
 8011ba4: 4618         	mov	r0, r3
 8011ba6: f7ff fb69    	bl	0x801127c <pid_calc>    @ imm = #-0x92e
; 	int idx = 0;
 8011baa: 2300         	movs	r3, #0x0
 8011bac: 677b         	str	r3, [r7, #0x74]
; 	float currentSpeedX[CONFIG_CHASSIS_MAX_STEERWHHEL_COUNT] = {0};
 8011bae: f107 0334    	add.w	r3, r7, #0x34
 8011bb2: 2200         	movs	r2, #0x0
 8011bb4: 601a         	str	r2, [r3]
 8011bb6: 605a         	str	r2, [r3, #0x4]
 8011bb8: 609a         	str	r2, [r3, #0x8]
 8011bba: 60da         	str	r2, [r3, #0xc]
; 	float currentSpeedY[CONFIG_CHASSIS_MAX_STEERWHHEL_COUNT] = {0};
 8011bbc: f107 0324    	add.w	r3, r7, #0x24
 8011bc0: 2200         	movs	r2, #0x0
 8011bc2: 601a         	str	r2, [r3]
 8011bc4: 605a         	str	r2, [r3, #0x4]
 8011bc6: 609a         	str	r2, [r3, #0x8]
 8011bc8: 60da         	str	r2, [r3, #0xc]
; 	float currentGyro = 0;
 8011bca: f04f 0300    	mov.w	r3, #0x0
 8011bce: 673b         	str	r3, [r7, #0x70]
; 	while (cfg->steerwheels[idx] != NULL) {
 8011bd0: e059         	b	0x8011c86 <swchassis_resolve+0x10e> @ imm = #0xb2
; 		float angle = steerwheel_get_angle(cfg->steerwheels[idx]);
 8011bd2: 683a         	ldr	r2, [r7]
 8011bd4: 6f7b         	ldr	r3, [r7, #0x74]
 8011bd6: 009b         	lsls	r3, r3, #0x2
 8011bd8: 4413         	add	r3, r2
 8011bda: 685b         	ldr	r3, [r3, #0x4]
 8011bdc: 4618         	mov	r0, r3
 8011bde: f7ff feaf    	bl	0x8011940 <steerwheel_get_angle> @ imm = #-0x2a2
 8011be2: ed87 0a16    	vstr	s0, [r7, #88]
; 		float speed = steerwheel_get_speed(cfg->steerwheels[idx]);
 8011be6: 683a         	ldr	r2, [r7]
 8011be8: 6f7b         	ldr	r3, [r7, #0x74]
 8011bea: 009b         	lsls	r3, r3, #0x2
 8011bec: 4413         	add	r3, r2
 8011bee: 685b         	ldr	r3, [r3, #0x4]
 8011bf0: 4618         	mov	r0, r3
 8011bf2: f012 fb4f    	bl	0x8024294 <steerwheel_get_speed> @ imm = #0x1269e
 8011bf6: ed87 0a15    	vstr	s0, [r7, #84]
; 		arm_sin_cos_f32(data->angle_to_center[idx] + data->currentYaw, &sin_theta,
 8011bfa: 687a         	ldr	r2, [r7, #0x4]
 8011bfc: 6f7b         	ldr	r3, [r7, #0x74]
 8011bfe: 330a         	adds	r3, #0xa
 8011c00: 009b         	lsls	r3, r3, #0x2
 8011c02: 4413         	add	r3, r2
 8011c04: 3304         	adds	r3, #0x4
 8011c06: ed93 7a00    	vldr	s14, [r3]
 8011c0a: 687b         	ldr	r3, [r7, #0x4]
 8011c0c: edd3 7a01    	vldr	s15, [r3, #4]
 8011c10: ee77 7a27    	vadd.f32	s15, s14, s15
 8011c14: f107 021c    	add.w	r2, r7, #0x1c
 8011c18: f107 0320    	add.w	r3, r7, #0x20
 8011c1c: 4611         	mov	r1, r2
 8011c1e: 4618         	mov	r0, r3
 8011c20: eeb0 0a67    	vmov.f32	s0, s15
 8011c24: f000 f9d8    	bl	0x8011fd8 <arm_sin_cos_f32> @ imm = #0x3b0
; 		currentSpeedX[idx] = speed * cos_theta;
 8011c28: ed97 7a07    	vldr	s14, [r7, #28]
 8011c2c: edd7 7a15    	vldr	s15, [r7, #84]
 8011c30: ee67 7a27    	vmul.f32	s15, s14, s15
 8011c34: 6f7b         	ldr	r3, [r7, #0x74]
 8011c36: 009b         	lsls	r3, r3, #0x2
 8011c38: 3378         	adds	r3, #0x78
 8011c3a: 443b         	add	r3, r7
 8011c3c: 3b44         	subs	r3, #0x44
 8011c3e: edc3 7a00    	vstr	s15, [r3]
; 		currentSpeedY[idx] = speed * sin_theta;
 8011c42: ed97 7a08    	vldr	s14, [r7, #32]
 8011c46: edd7 7a15    	vldr	s15, [r7, #84]
 8011c4a: ee67 7a27    	vmul.f32	s15, s14, s15
 8011c4e: 6f7b         	ldr	r3, [r7, #0x74]
 8011c50: 009b         	lsls	r3, r3, #0x2
 8011c52: 3378         	adds	r3, #0x78
 8011c54: 443b         	add	r3, r7
 8011c56: 3b54         	subs	r3, #0x54
 8011c58: edc3 7a00    	vstr	s15, [r3]
; 		printk("steerwheel%d: angle=%f speed=%f\n", idx, (double)angle, (double)speed);
 8011c5c: 6db8         	ldr	r0, [r7, #0x58]
 8011c5e: f7ee fbf7    	bl	0x8000450 <__extendsfdf2> @ imm = #-0x11812
 8011c62: 4604         	mov	r4, r0
 8011c64: 460d         	mov	r5, r1
 8011c66: 6d78         	ldr	r0, [r7, #0x54]
 8011c68: f7ee fbf2    	bl	0x8000450 <__extendsfdf2> @ imm = #-0x1181c
 8011c6c: 4602         	mov	r2, r0
 8011c6e: 460b         	mov	r3, r1
 8011c70: e9cd 2300    	strd	r2, r3, [sp]
 8011c74: 4622         	mov	r2, r4
 8011c76: 462b         	mov	r3, r5
 8011c78: 6f79         	ldr	r1, [r7, #0x74]
 8011c7a: 4887         	ldr	r0, [pc, #0x21c]        @ 0x8011e98 <swchassis_resolve+0x320>
 8011c7c: f009 fb89    	bl	0x801b392 <printk>      @ imm = #0x9712
; 		idx++;
 8011c80: 6f7b         	ldr	r3, [r7, #0x74]
 8011c82: 3301         	adds	r3, #0x1
 8011c84: 677b         	str	r3, [r7, #0x74]
; 	while (cfg->steerwheels[idx] != NULL) {
 8011c86: 683a         	ldr	r2, [r7]
 8011c88: 6f7b         	ldr	r3, [r7, #0x74]
 8011c8a: 009b         	lsls	r3, r3, #0x2
 8011c8c: 4413         	add	r3, r2
 8011c8e: 685b         	ldr	r3, [r3, #0x4]
 8011c90: 2b00         	cmp	r3, #0x0
 8011c92: d19e         	bne	0x8011bd2 <swchassis_resolve+0x5a> @ imm = #-0xc4
; 	idx = 0;
 8011c94: 2300         	movs	r3, #0x0
 8011c96: 677b         	str	r3, [r7, #0x74]
; 	if (data->targetGyro > 6) {
 8011c98: 687b         	ldr	r3, [r7, #0x4]
 8011c9a: edd3 7a02    	vldr	s15, [r3, #8]
 8011c9e: eeb1 7a08    	vmov.f32	s14, #6.000000e+00
 8011ca2: eef4 7ac7    	vcmpe.f32	s15, s14
 8011ca6: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011caa: dd03         	ble	0x8011cb4 <swchassis_resolve+0x13c> @ imm = #0x6
; 		data->targetGyro = 6;
 8011cac: 687b         	ldr	r3, [r7, #0x4]
 8011cae: 4a7b         	ldr	r2, [pc, #0x1ec]        @ 0x8011e9c <swchassis_resolve+0x324>
 8011cb0: 609a         	str	r2, [r3, #0x8]
 8011cb2: e0e2         	b	0x8011e7a <swchassis_resolve+0x302> @ imm = #0x1c4
; 	} else if (data->targetGyro < -6) {
 8011cb4: 687b         	ldr	r3, [r7, #0x4]
 8011cb6: edd3 7a02    	vldr	s15, [r3, #8]
 8011cba: eeb9 7a08    	vmov.f32	s14, #-6.000000e+00
 8011cbe: eef4 7ac7    	vcmpe.f32	s15, s14
 8011cc2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011cc6: d502         	bpl	0x8011cce <swchassis_resolve+0x156> @ imm = #0x4
; 		data->targetGyro = -6;
 8011cc8: 687b         	ldr	r3, [r7, #0x4]
 8011cca: 4a75         	ldr	r2, [pc, #0x1d4]        @ 0x8011ea0 <swchassis_resolve+0x328>
 8011ccc: 609a         	str	r2, [r3, #0x8]
; 	while (cfg->steerwheels[idx] != NULL) {
 8011cce: e0d4         	b	0x8011e7a <swchassis_resolve+0x302> @ imm = #0x1a8
; 		float theta = data->angle_to_center[idx] + data->currentYaw;
 8011cd0: 687a         	ldr	r2, [r7, #0x4]
 8011cd2: 6f7b         	ldr	r3, [r7, #0x74]
 8011cd4: 330a         	adds	r3, #0xa
 8011cd6: 009b         	lsls	r3, r3, #0x2
 8011cd8: 4413         	add	r3, r2
 8011cda: 3304         	adds	r3, #0x4
 8011cdc: ed93 7a00    	vldr	s14, [r3]
 8011ce0: 687b         	ldr	r3, [r7, #0x4]
 8011ce2: edd3 7a01    	vldr	s15, [r3, #4]
 8011ce6: ee77 7a27    	vadd.f32	s15, s14, s15
 8011cea: edc7 7a1b    	vstr	s15, [r7, #108]
; 		arm_sin_cos_f32(theta, &sin_theta, &cos_theta);
 8011cee: f107 0214    	add.w	r2, r7, #0x14
 8011cf2: f107 0318    	add.w	r3, r7, #0x18
 8011cf6: 4611         	mov	r1, r2
 8011cf8: 4618         	mov	r0, r3
 8011cfa: ed97 0a1b    	vldr	s0, [r7, #108]
 8011cfe: f000 f96b    	bl	0x8011fd8 <arm_sin_cos_f32> @ imm = #0x2d6
; 		float rollSpeedX = cfg->pos_Y_offset[idx] * data->targetGyro;
 8011d02: 683a         	ldr	r2, [r7]
 8011d04: 6f7b         	ldr	r3, [r7, #0x74]
 8011d06: 3308         	adds	r3, #0x8
 8011d08: 009b         	lsls	r3, r3, #0x2
 8011d0a: 4413         	add	r3, r2
 8011d0c: 3304         	adds	r3, #0x4
 8011d0e: ed93 7a00    	vldr	s14, [r3]
 8011d12: 687b         	ldr	r3, [r7, #0x4]
 8011d14: edd3 7a02    	vldr	s15, [r3, #8]
 8011d18: ee67 7a27    	vmul.f32	s15, s14, s15
 8011d1c: edc7 7a1a    	vstr	s15, [r7, #104]
; 		float rollSpeedY = -cfg->pos_X_offset[idx] * data->targetGyro;
 8011d20: 683a         	ldr	r2, [r7]
 8011d22: 6f7b         	ldr	r3, [r7, #0x74]
 8011d24: 3304         	adds	r3, #0x4
 8011d26: 009b         	lsls	r3, r3, #0x2
 8011d28: 4413         	add	r3, r2
 8011d2a: 3304         	adds	r3, #0x4
 8011d2c: edd3 7a00    	vldr	s15, [r3]
 8011d30: eeb1 7a67    	vneg.f32	s14, s15
 8011d34: 687b         	ldr	r3, [r7, #0x4]
 8011d36: edd3 7a02    	vldr	s15, [r3, #8]
 8011d3a: ee67 7a27    	vmul.f32	s15, s14, s15
 8011d3e: edc7 7a19    	vstr	s15, [r7, #100]
; 		float speedX = rollSpeedX + data->targetXSpeed;
 8011d42: 687b         	ldr	r3, [r7, #0x4]
 8011d44: edd3 7a04    	vldr	s15, [r3, #16]
 8011d48: ed97 7a1a    	vldr	s14, [r7, #104]
 8011d4c: ee77 7a27    	vadd.f32	s15, s14, s15
 8011d50: edc7 7a18    	vstr	s15, [r7, #96]
; 		float speedY = rollSpeedY + data->targetYSpeed;
 8011d54: 687b         	ldr	r3, [r7, #0x4]
 8011d56: edd3 7a05    	vldr	s15, [r3, #20]
 8011d5a: ed97 7a19    	vldr	s14, [r7, #100]
 8011d5e: ee77 7a27    	vadd.f32	s15, s14, s15
 8011d62: edc7 7a17    	vstr	s15, [r7, #92]
; 		arm_sqrt_f32(speedX * speedX + speedY * speedY, &steerwheel_speed);
 8011d66: edd7 7a18    	vldr	s15, [r7, #96]
 8011d6a: ee27 7aa7    	vmul.f32	s14, s15, s15
 8011d6e: edd7 7a17    	vldr	s15, [r7, #92]
 8011d72: ee67 7aa7    	vmul.f32	s15, s15, s15
 8011d76: ee77 7a27    	vadd.f32	s15, s14, s15
 8011d7a: edc7 7a12    	vstr	s15, [r7, #72]
 8011d7e: f107 0310    	add.w	r3, r7, #0x10
 8011d82: 647b         	str	r3, [r7, #0x44]
;     if (in >= 0.0f)
 8011d84: edd7 7a12    	vldr	s15, [r7, #72]
 8011d88: eef5 7ac0    	vcmpe.f32	s15, #0
 8011d8c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011d90: db07         	blt	0x8011da2 <swchassis_resolve+0x22a> @ imm = #0xe
;       __ASM("VSQRT.F32 %0,%1" : "=t"(*pOut) : "t"(in));
 8011d92: edd7 7a12    	vldr	s15, [r7, #72]
 8011d96: eef1 7ae7    	vsqrt.f32	s15, s15
 8011d9a: 6c7b         	ldr	r3, [r7, #0x44]
 8011d9c: edc3 7a00    	vstr	s15, [r3]
;       return (ARM_MATH_SUCCESS);
 8011da0: e004         	b	0x8011dac <swchassis_resolve+0x234> @ imm = #0x8
;       *pOut = 0.0f;
 8011da2: 6c7b         	ldr	r3, [r7, #0x44]
 8011da4: f04f 0200    	mov.w	r2, #0x0
 8011da8: 601a         	str	r2, [r3]
;       return (ARM_MATH_ARGUMENT_ERROR);
 8011daa: bf00         	nop
; 		float steerwheel_angle = 0;
 8011dac: f04f 0300    	mov.w	r3, #0x0
 8011db0: 60fb         	str	r3, [r7, #0xc]
; 		arm_atan2_f32(speedY, speedX, &steerwheel_angle);
 8011db2: f107 030c    	add.w	r3, r7, #0xc
 8011db6: 4618         	mov	r0, r3
 8011db8: edd7 0a18    	vldr	s1, [r7, #96]
 8011dbc: ed97 0a17    	vldr	s0, [r7, #92]
 8011dc0: f000 f988    	bl	0x80120d4 <arm_atan2_f32> @ imm = #0x310
; 		printk("steerwheel%d: angle=%f speed X=%f Y=%f  ", idx, (double)steerwheel_angle,
 8011dc4: 68fb         	ldr	r3, [r7, #0xc]
 8011dc6: 4618         	mov	r0, r3
 8011dc8: f7ee fb42    	bl	0x8000450 <__extendsfdf2> @ imm = #-0x1197c
 8011dcc: 4680         	mov	r8, r0
 8011dce: 4689         	mov	r9, r1
 8011dd0: 6e38         	ldr	r0, [r7, #0x60]
 8011dd2: f7ee fb3d    	bl	0x8000450 <__extendsfdf2> @ imm = #-0x11986
 8011dd6: 4604         	mov	r4, r0
 8011dd8: 460d         	mov	r5, r1
 8011dda: 6df8         	ldr	r0, [r7, #0x5c]
 8011ddc: f7ee fb38    	bl	0x8000450 <__extendsfdf2> @ imm = #-0x11990
 8011de0: 4602         	mov	r2, r0
 8011de2: 460b         	mov	r3, r1
 8011de4: e9cd 2302    	strd	r2, r3, [sp, #8]
 8011de8: e9cd 4500    	strd	r4, r5, [sp]
 8011dec: 4642         	mov	r2, r8
 8011dee: 464b         	mov	r3, r9
 8011df0: 6f79         	ldr	r1, [r7, #0x74]
 8011df2: 482c         	ldr	r0, [pc, #0xb0]         @ 0x8011ea4 <swchassis_resolve+0x32c>
 8011df4: f009 facd    	bl	0x801b392 <printk>      @ imm = #0x959a
; 		steerwheel_angle = -RAD2DEG(steerwheel_angle) + 90.0f;
 8011df8: edd7 7a03    	vldr	s15, [r7, #12]
 8011dfc: ed9f 7a2a    	vldr	s14, [pc, #168]         @ 0x8011ea8 <swchassis_resolve+0x330>
 8011e00: ee67 7a87    	vmul.f32	s15, s15, s14
 8011e04: ed9f 7a29    	vldr	s14, [pc, #164]         @ 0x8011eac <swchassis_resolve+0x334>
 8011e08: ee77 7a87    	vadd.f32	s15, s15, s14
 8011e0c: edc7 7a03    	vstr	s15, [r7, #12]
; 		printk("deg: %f\n", (double)steerwheel_angle);
 8011e10: 68fb         	ldr	r3, [r7, #0xc]
 8011e12: 4618         	mov	r0, r3
 8011e14: f7ee fb1c    	bl	0x8000450 <__extendsfdf2> @ imm = #-0x119c8
 8011e18: 4602         	mov	r2, r0
 8011e1a: 460b         	mov	r3, r1
 8011e1c: 4824         	ldr	r0, [pc, #0x90]         @ 0x8011eb0 <swchassis_resolve+0x338>
 8011e1e: f009 fab8    	bl	0x801b392 <printk>      @ imm = #0x9570
; 		if (fabsf(steerwheel_speed) > 0.05f) {
 8011e22: 693b         	ldr	r3, [r7, #0x10]
 8011e24: 653b         	str	r3, [r7, #0x50]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 8011e26: edd7 7a14    	vldr	s15, [r7, #80]
 8011e2a: eef0 7ae7    	vabs.f32	s15, s15
 8011e2e: edc7 7a13    	vstr	s15, [r7, #76]
;     return result;
 8011e32: edd7 7a13    	vldr	s15, [r7, #76]
; 		if (fabsf(steerwheel_speed) > 0.05f) {
 8011e36: ed9f 7a1f    	vldr	s14, [pc, #124]         @ 0x8011eb4 <swchassis_resolve+0x33c>
 8011e3a: eef4 7ac7    	vcmpe.f32	s15, s14
 8011e3e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011e42: dd0b         	ble	0x8011e5c <swchassis_resolve+0x2e4> @ imm = #0x16
; 			steerwheel_set_angle(cfg->steerwheels[idx], steerwheel_angle);
 8011e44: 683a         	ldr	r2, [r7]
 8011e46: 6f7b         	ldr	r3, [r7, #0x74]
 8011e48: 009b         	lsls	r3, r3, #0x2
 8011e4a: 4413         	add	r3, r2
 8011e4c: 685b         	ldr	r3, [r3, #0x4]
 8011e4e: edd7 7a03    	vldr	s15, [r7, #12]
 8011e52: eeb0 0a67    	vmov.f32	s0, s15
 8011e56: 4618         	mov	r0, r3
 8011e58: f7ff fc3c    	bl	0x80116d4 <steerwheel_set_angle> @ imm = #-0x788
; 		steerwheel_set_speed(cfg->steerwheels[idx], steerwheel_speed);
 8011e5c: 683a         	ldr	r2, [r7]
 8011e5e: 6f7b         	ldr	r3, [r7, #0x74]
 8011e60: 009b         	lsls	r3, r3, #0x2
 8011e62: 4413         	add	r3, r2
 8011e64: 685b         	ldr	r3, [r3, #0x4]
 8011e66: edd7 7a04    	vldr	s15, [r7, #16]
 8011e6a: eeb0 0a67    	vmov.f32	s0, s15
 8011e6e: 4618         	mov	r0, r3
 8011e70: f7ff fbb0    	bl	0x80115d4 <steerwheel_set_speed> @ imm = #-0x8a0
; 		idx++;
 8011e74: 6f7b         	ldr	r3, [r7, #0x74]
 8011e76: 3301         	adds	r3, #0x1
 8011e78: 677b         	str	r3, [r7, #0x74]
; 	while (cfg->steerwheels[idx] != NULL) {
 8011e7a: 683a         	ldr	r2, [r7]
 8011e7c: 6f7b         	ldr	r3, [r7, #0x74]
 8011e7e: 009b         	lsls	r3, r3, #0x2
 8011e80: 4413         	add	r3, r2
 8011e82: 685b         	ldr	r3, [r3, #0x4]
 8011e84: 2b00         	cmp	r3, #0x0
 8011e86: f47f af23    	bne.w	0x8011cd0 <swchassis_resolve+0x158> @ imm = #-0x1ba
; }
 8011e8a: bf00         	nop
 8011e8c: bf00         	nop
 8011e8e: 3778         	adds	r7, #0x78
 8011e90: 46bd         	mov	sp, r7
 8011e92: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 8011e96: bf00         	nop

08011e98 <$d>:
 8011e98: 48 a0 02 08  	.word	0x0802a048
 8011e9c: 00 00 c0 40  	.word	0x40c00000
 8011ea0: 00 00 c0 c0  	.word	0xc0c00000
 8011ea4: 6c a0 02 08  	.word	0x0802a06c
 8011ea8: e1 2e 65 c2  	.word	0xc2652ee1
 8011eac: 00 00 b4 42  	.word	0x42b40000
 8011eb0: 98 a0 02 08  	.word	0x0802a098
 8011eb4: cd cc 4c 3d  	.word	0x3d4ccccd

08011eb8 <swchassis_main_thread>:
; {
 8011eb8: b580         	push	{r7, lr}
 8011eba: b092         	sub	sp, #0x48
 8011ebc: af02         	add	r7, sp, #0x8
 8011ebe: 60f8         	str	r0, [r7, #0xc]
 8011ec0: 60b9         	str	r1, [r7, #0x8]
 8011ec2: 607a         	str	r2, [r7, #0x4]
; 	chassis_data_t *data = dev->data;
 8011ec4: 68fb         	ldr	r3, [r7, #0xc]
 8011ec6: 691b         	ldr	r3, [r3, #0x10]
 8011ec8: 63fb         	str	r3, [r7, #0x3c]
; 	const chassis_cfg_t *cfg = dev->config;
 8011eca: 68fb         	ldr	r3, [r7, #0xc]
 8011ecc: 685b         	ldr	r3, [r3, #0x4]
 8011ece: 63bb         	str	r3, [r7, #0x38]
; 	struct pos_data pos = {0};
 8011ed0: f107 0314    	add.w	r3, r7, #0x14
 8011ed4: 2200         	movs	r2, #0x0
 8011ed6: 601a         	str	r2, [r3]
 8011ed8: 605a         	str	r2, [r3, #0x4]
 8011eda: 609a         	str	r2, [r3, #0x8]
 8011edc: 60da         	str	r2, [r3, #0xc]
 8011ede: 611a         	str	r2, [r3, #0x10]
 8011ee0: 615a         	str	r2, [r3, #0x14]
 8011ee2: 619a         	str	r2, [r3, #0x18]
; 		if (data->chassis_sensor_zbus != NULL) {
 8011ee4: 6bfb         	ldr	r3, [r7, #0x3c]
 8011ee6: 6e5b         	ldr	r3, [r3, #0x64]
 8011ee8: 2b00         	cmp	r3, #0x0
 8011eea: d013         	beq	0x8011f14 <swchassis_main_thread+0x5c> @ imm = #0x26
; 			zbus_sub_wait_msg(&chassis_sensor_msg_suscriber, &chan, &pos, K_FOREVER);
 8011eec: f04f 32ff    	mov.w	r2, #0xffffffff
 8011ef0: f04f 33ff    	mov.w	r3, #0xffffffff
 8011ef4: f107 0014    	add.w	r0, r7, #0x14
 8011ef8: f107 0130    	add.w	r1, r7, #0x30
 8011efc: e9cd 2300    	strd	r2, r3, [sp]
 8011f00: 4602         	mov	r2, r0
 8011f02: 4831         	ldr	r0, [pc, #0xc4]         @ 0x8011fc8 <swchassis_main_thread+0x110>
 8011f04: f00a ff8d    	bl	0x801ce22 <zbus_sub_wait_msg> @ imm = #0xaf1a
; 			if (data->chassis_sensor_zbus != chan) {
 8011f08: 6bfb         	ldr	r3, [r7, #0x3c]
 8011f0a: 6e5a         	ldr	r2, [r3, #0x64]
 8011f0c: 6b3b         	ldr	r3, [r7, #0x30]
 8011f0e: 429a         	cmp	r2, r3
 8011f10: d004         	beq	0x8011f1c <swchassis_main_thread+0x64> @ imm = #0x8
 8011f12: e7e7         	b	0x8011ee4 <swchassis_main_thread+0x2c> @ imm = #-0x32
; 			k_msleep(1000);
 8011f14: f44f 707a    	mov.w	r0, #0x3e8
 8011f18: f012 f8a6    	bl	0x8024068 <k_msleep>    @ imm = #0x1214c
; 		data->currentYaw = pos.Yaw;
 8011f1c: 697a         	ldr	r2, [r7, #0x14]
 8011f1e: 6bfb         	ldr	r3, [r7, #0x3c]
 8011f20: 605a         	str	r2, [r3, #0x4]
; 		float delta_Yaw = data->targetYaw - data->currentYaw;
 8011f22: 6bfb         	ldr	r3, [r7, #0x3c]
 8011f24: ed93 7a00    	vldr	s14, [r3]
 8011f28: 6bfb         	ldr	r3, [r7, #0x3c]
 8011f2a: edd3 7a01    	vldr	s15, [r3, #4]
 8011f2e: ee77 7a67    	vsub.f32	s15, s14, s15
 8011f32: edc7 7a0d    	vstr	s15, [r7, #52]
; 		delta_Yaw = fmodf(delta_Yaw, 360.0f);
 8011f36: eddf 0a25    	vldr	s1, [pc, #148]          @ 0x8011fcc <swchassis_main_thread+0x114>
 8011f3a: ed97 0a0d    	vldr	s0, [r7, #52]
 8011f3e: f007 f86d    	bl	0x801901c <fmodf>       @ imm = #0x70da
 8011f42: ed87 0a0d    	vstr	s0, [r7, #52]
; 		if (delta_Yaw > 0) {
 8011f46: edd7 7a0d    	vldr	s15, [r7, #52]
 8011f4a: eef5 7ac0    	vcmpe.f32	s15, #0
 8011f4e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011f52: dd16         	ble	0x8011f82 <swchassis_main_thread+0xca> @ imm = #0x2c
; 			if (delta_Yaw < 180) {
 8011f54: edd7 7a0d    	vldr	s15, [r7, #52]
 8011f58: ed9f 7a1d    	vldr	s14, [pc, #116]         @ 0x8011fd0 <swchassis_main_thread+0x118>
 8011f5c: eef4 7ac7    	vcmpe.f32	s15, s14
 8011f60: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011f64: d503         	bpl	0x8011f6e <swchassis_main_thread+0xb6> @ imm = #0x6
; 				data->pid_input = delta_Yaw;
 8011f66: 6bfb         	ldr	r3, [r7, #0x3c]
 8011f68: 6b7a         	ldr	r2, [r7, #0x34]
 8011f6a: 65da         	str	r2, [r3, #0x5c]
 8011f6c: e026         	b	0x8011fbc <swchassis_main_thread+0x104> @ imm = #0x4c
; 				data->pid_input = delta_Yaw - 360.0f;
 8011f6e: edd7 7a0d    	vldr	s15, [r7, #52]
 8011f72: ed9f 7a16    	vldr	s14, [pc, #88]          @ 0x8011fcc <swchassis_main_thread+0x114>
 8011f76: ee77 7ac7    	vsub.f32	s15, s15, s14
 8011f7a: 6bfb         	ldr	r3, [r7, #0x3c]
 8011f7c: edc3 7a17    	vstr	s15, [r3, #92]
 8011f80: e01c         	b	0x8011fbc <swchassis_main_thread+0x104> @ imm = #0x38
; 		} else if (delta_Yaw < 0) {
 8011f82: edd7 7a0d    	vldr	s15, [r7, #52]
 8011f86: eef5 7ac0    	vcmpe.f32	s15, #0
 8011f8a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011f8e: d515         	bpl	0x8011fbc <swchassis_main_thread+0x104> @ imm = #0x2a
; 			if (delta_Yaw > -180) {
 8011f90: edd7 7a0d    	vldr	s15, [r7, #52]
 8011f94: ed9f 7a0f    	vldr	s14, [pc, #60]          @ 0x8011fd4 <swchassis_main_thread+0x11c>
 8011f98: eef4 7ac7    	vcmpe.f32	s15, s14
 8011f9c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8011fa0: dd03         	ble	0x8011faa <swchassis_main_thread+0xf2> @ imm = #0x6
; 				data->pid_input = delta_Yaw;
 8011fa2: 6bfb         	ldr	r3, [r7, #0x3c]
 8011fa4: 6b7a         	ldr	r2, [r7, #0x34]
 8011fa6: 65da         	str	r2, [r3, #0x5c]
 8011fa8: e008         	b	0x8011fbc <swchassis_main_thread+0x104> @ imm = #0x10
; 				data->pid_input = delta_Yaw + 360.0f;
 8011faa: edd7 7a0d    	vldr	s15, [r7, #52]
 8011fae: ed9f 7a07    	vldr	s14, [pc, #28]          @ 0x8011fcc <swchassis_main_thread+0x114>
 8011fb2: ee77 7a87    	vadd.f32	s15, s15, s14
 8011fb6: 6bfb         	ldr	r3, [r7, #0x3c]
 8011fb8: edc3 7a17    	vstr	s15, [r3, #92]
; 		swchassis_resolve(data, cfg);
 8011fbc: 6bb9         	ldr	r1, [r7, #0x38]
 8011fbe: 6bf8         	ldr	r0, [r7, #0x3c]
 8011fc0: f7ff fdda    	bl	0x8011b78 <swchassis_resolve> @ imm = #-0x44c
; 	while (true) {
 8011fc4: e78e         	b	0x8011ee4 <swchassis_main_thread+0x2c> @ imm = #-0xe4
 8011fc6: bf00         	nop

08011fc8 <$d>:
 8011fc8: 0c 82 02 08  	.word	0x0802820c
 8011fcc: 00 00 b4 43  	.word	0x43b40000
 8011fd0: 00 00 34 43  	.word	0x43340000
 8011fd4: 00 00 34 c3  	.word	0xc3340000

08011fd8 <arm_sin_cos_f32>:
;   in = theta * 0.00277777777778f;
 8011fd8: eddf 7a3a    	vldr	s15, [pc, #232]         @ 0x80120c4 <arm_sin_cos_f32+0xec>
;   findex = (float32_t)FAST_MATH_TABLE_SIZE * in;
 8011fdc: ed9f 6a3a    	vldr	s12, [pc, #232]         @ 0x80120c8 <arm_sin_cos_f32+0xf0>
;   f1 =  sinTable_f32[indexC  ];
 8011fe0: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x80120cc <arm_sin_cos_f32+0xf4>
;   temp = Dn * (d1 + d2) - 2 * Df;
 8011fe2: ed9f 7a3b    	vldr	s14, [pc, #236]         @ 0x80120d0 <arm_sin_cos_f32+0xf8>
;   in = theta * 0.00277777777778f;
 8011fe6: ee60 7a27    	vmul.f32	s15, s0, s15
; {
 8011fea: b500         	push	{lr}
;   if (in < 0.0f)
 8011fec: eef0 7ae7    	vabs.f32	s15, s15
;   in = in - (int32_t)in;
 8011ff0: eefd 6ae7    	vcvt.s32.f32	s13, s15
 8011ff4: eef0 2a00    	vmov.f32	s5, #2.000000e+00
 8011ff8: eef8 6ae6    	vcvt.f32.s32	s13, s13
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8011ffc: eeb0 1a08    	vmov.f32	s2, #3.000000e+00
;   in = in - (int32_t)in;
 8012000: ee77 7ae6    	vsub.f32	s15, s15, s13
;   if (theta < 0.0f)
 8012004: eeb5 0ac0    	vcmpe.f32	s0, #0
;   findex = (float32_t)FAST_MATH_TABLE_SIZE * in;
 8012008: ee67 7a86    	vmul.f32	s15, s15, s12
;   if (theta < 0.0f)
 801200c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
;   indexS = ((uint16_t)findex) & 0x1ff;
 8012010: eefc 6ae7    	vcvt.u32.f32	s13, s15
 8012014: ee16 3a90    	vmov	r3, s13
 8012018: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
;   fract = findex - (float32_t) indexS;
 801201c: ee06 3a90    	vmov	s13, r3
;   d1 = -sinTable_f32[indexS  ];
 8012020: eb02 0e83    	add.w	lr, r2, r3, lsl #2
;   indexC = (indexS + (FAST_MATH_TABLE_SIZE / 4)) & 0x1ff;
 8012024: f103 0c80    	add.w	r12, r3, #0x80
;   d2 = -sinTable_f32[indexS+1];
 8012028: ed9e 6a01    	vldr	s12, [lr, #4]
;   d1 = -sinTable_f32[indexS  ];
 801202c: edde 4a00    	vldr	s9, [lr]
;   fract = findex - (float32_t) indexS;
 8012030: eef8 6a66    	vcvt.f32.u32	s13, s13
;   f1 =  sinTable_f32[indexC  ];
 8012034: f3cc 0c08    	ubfx	r12, r12, #0x0, #0x9
 8012038: eb02 038c    	add.w	r3, r2, r12, lsl #2
;   fract = findex - (float32_t) indexS;
 801203c: ee77 7ae6    	vsub.f32	s15, s15, s13
;   f2 =  sinTable_f32[indexC+1];
 8012040: ed93 4a01    	vldr	s8, [r3, #4]
;   d1 = -sinTable_f32[indexS  ];
 8012044: eef1 6a64    	vneg.f32	s13, s9
 8012048: eeb0 5a46    	vmov.f32	s10, s12
;   Df = f2 - f1; // delta between the values of the functions
 801204c: ee36 2a64    	vsub.f32	s4, s12, s9
;   temp = Dn * (d1 + d2) - 2 * Df;
 8012050: ee76 3ac6    	vsub.f32	s7, s13, s12
 8012054: ee96 5aa2    	vfnms.f32	s10, s13, s5
;   temp = fract * temp + d1 * Dn;
 8012058: ee26 6a87    	vmul.f32	s12, s13, s14
;   f1 =  sinTable_f32[indexC  ];
 801205c: edd3 6a00    	vldr	s13, [r3]
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8012060: eef0 5a44    	vmov.f32	s11, s8
 8012064: eee6 5aa2    	vfma.f32	s11, s13, s5
;   Df = f2 - f1;          /* delta between the values of the functions */
 8012068: ee74 1a66    	vsub.f32	s3, s8, s13
;   temp = Dn * (d1 + d2) - 2 * Df;
 801206c: ee32 3a02    	vadd.f32	s6, s4, s4
;   temp = Dn * (d1 + d2) - 2 * Df;
 8012070: ee71 2aa1    	vadd.f32	s5, s3, s3
;   temp = Dn * (d1 + d2) - 2 * Df;
 8012074: ee36 4a84    	vadd.f32	s8, s13, s8
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8012078: ee67 5a65    	vnmul.f32	s11, s14, s11
;   temp = Dn * (d1 + d2) - 2 * Df;
 801207c: eed3 2a87    	vfnms.f32	s5, s7, s14
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8012080: ee27 5a45    	vnmul.f32	s10, s14, s10
;   temp = Dn * (d1 + d2) - 2 * Df;
 8012084: eef0 3a43    	vmov.f32	s7, s6
 8012088: eed4 3a07    	vfnms.f32	s7, s8, s14
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 801208c: eee2 5a01    	vfma.f32	s11, s4, s2
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8012090: eea1 5a81    	vfma.f32	s10, s3, s2
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8012094: eee7 5aa3    	vfma.f32	s11, s15, s7
;   temp = fract * temp + (3 * Df - (d2 + 2 * d1) * Dn);
 8012098: eea7 5aa2    	vfma.f32	s10, s15, s5
;   temp = fract * temp + d1 * Dn;
 801209c: ee26 7a87    	vmul.f32	s14, s13, s14
;   temp = fract * temp + d1 * Dn;
 80120a0: eea7 6a85    	vfma.f32	s12, s15, s10
;   temp = fract * temp + d1 * Dn;
 80120a4: eea7 7aa5    	vfma.f32	s14, s15, s11
;   *pCosVal = fract * temp + f1;
 80120a8: eee7 6a86    	vfma.f32	s13, s15, s12
;   *pSinVal = fract * temp + f1;
 80120ac: eee7 4a87    	vfma.f32	s9, s15, s14
;   *pCosVal = fract * temp + f1;
 80120b0: edc1 6a00    	vstr	s13, [r1]
;     *pSinVal = -*pSinVal;
 80120b4: bf48         	it	mi
 80120b6: eef1 4a64    	vnegmi.f32	s9, s9
;   *pSinVal = fract * temp + f1;
 80120ba: edc0 4a00    	vstr	s9, [r0]
; }
 80120be: f85d fb04    	ldr	pc, [sp], #4
 80120c2: bf00         	nop

080120c4 <$d>:
 80120c4: 61 0b 36 3b  	.word	0x3b360b61
 80120c8: 00 00 00 44  	.word	0x44000000
 80120cc: 1c b4 02 08  	.word	0x0802b41c
 80120d0: db 0f 49 3c  	.word	0x3c490fdb

080120d4 <arm_atan2_f32>:
;     if (x > 0.0f)
 80120d4: eef5 0ac0    	vcmpe.f32	s1, #0
 80120d8: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80120dc: dc14         	bgt	0x8012108 <arm_atan2_f32+0x34> @ imm = #0x28
;     if (x < 0.0f)
 80120de: d456         	bmi	0x801218e <arm_atan2_f32+0xba> @ imm = #0xac
;     if (x == 0.0f)
 80120e0: eef5 0a40    	vcmp.f32	s1, #0
 80120e4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80120e8: f040 8131    	bne.w	0x801234e <arm_atan2_f32+0x27a> @ imm = #0x262
;         if (y > 0.0f)
 80120ec: eeb5 0ac0    	vcmpe.f32	s0, #0
 80120f0: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80120f4: f300 8094    	bgt.w	0x8012220 <arm_atan2_f32+0x14c> @ imm = #0x128
;         if (y < 0.0f)
 80120f8: f140 8129    	bpl.w	0x801234e <arm_atan2_f32+0x27a> @ imm = #0x252
 80120fc: eddf 7aa8    	vldr	s15, [pc, #672]         @ 0x80123a0 <arm_atan2_f32+0x2cc>
;            *result=arm_atan_f32(y/x) - PI;
 8012100: edc0 7a00    	vstr	s15, [r0]
;         return(ARM_MATH_SUCCESS);
 8012104: 2000         	movs	r0, #0x0
 8012106: 4770         	bx	lr
;         *result=arm_atan_f32(y/x);
 8012108: eec0 7a20    	vdiv.f32	s15, s0, s1
;    if (x > 1.0f)
 801210c: eef7 6a00    	vmov.f32	s13, #1.000000e+00
;    if (x < 0.0f)
 8012110: eef5 7ac0    	vcmpe.f32	s15, #0
 8012114: eef1 fa10    	vmrs	APSR_nzcv, fpscr
;       x=-x;
 8012118: bf48         	it	mi
 801211a: eef1 7a67    	vnegmi.f32	s15, s15
;    if (x > 1.0f)
 801211e: eef4 7ae6    	vcmpe.f32	s15, s13
;       sign=1;
 8012122: bf4c         	ite	mi
 8012124: 2301         	movmi	r3, #0x1
;    int sign=0;
 8012126: 2300         	movpl	r3, #0x0
;    if (x > 1.0f)
 8012128: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 801212c: dd7b         	ble	0x8012226 <arm_atan2_f32+0x152> @ imm = #0xf6
;       x = 1.0f / x;
 801212e: ee86 7aa7    	vdiv.f32	s14, s13, s15
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 8012132: eddf 2a9c    	vldr	s5, [pc, #624]          @ 0x80123a4 <arm_atan2_f32+0x2d0>
 8012136: ed9f 3a9c    	vldr	s6, [pc, #624]          @ 0x80123a8 <arm_atan2_f32+0x2d4>
 801213a: eddf 3a9c    	vldr	s7, [pc, #624]          @ 0x80123ac <arm_atan2_f32+0x2d8>
 801213e: ed9f 4a9c    	vldr	s8, [pc, #624]          @ 0x80123b0 <arm_atan2_f32+0x2dc>
 8012142: eddf 4a9c    	vldr	s9, [pc, #624]          @ 0x80123b4 <arm_atan2_f32+0x2e0>
 8012146: ed9f 5a9c    	vldr	s10, [pc, #624]         @ 0x80123b8 <arm_atan2_f32+0x2e4>
 801214a: eddf 5a9c    	vldr	s11, [pc, #624]         @ 0x80123bc <arm_atan2_f32+0x2e8>
 801214e: ed9f 6a9c    	vldr	s12, [pc, #624]         @ 0x80123c0 <arm_atan2_f32+0x2ec>
 8012152: eddf 6a9c    	vldr	s13, [pc, #624]         @ 0x80123c4 <arm_atan2_f32+0x2f0>
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 8012156: eddf 7a9c    	vldr	s15, [pc, #624]         @ 0x80123c8 <arm_atan2_f32+0x2f4>
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 801215a: eea7 3a22    	vfma.f32	s6, s14, s5
 801215e: eee7 3a03    	vfma.f32	s7, s14, s6
 8012162: eea7 4a23    	vfma.f32	s8, s14, s7
 8012166: eee7 4a04    	vfma.f32	s9, s14, s8
 801216a: eea7 5a24    	vfma.f32	s10, s14, s9
 801216e: eee7 5a05    	vfma.f32	s11, s14, s10
 8012172: eea5 6a87    	vfma.f32	s12, s11, s14
 8012176: eee7 6a06    	vfma.f32	s13, s14, s12
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 801217a: eee7 7a66    	vfms.f32	s15, s14, s13
;    if (sign)
 801217e: 2b00         	cmp	r3, #0x0
 8012180: d0be         	beq	0x8012100 <arm_atan2_f32+0x2c> @ imm = #-0x84
;      res = -res;
 8012182: eef1 7a67    	vneg.f32	s15, s15
;            *result=arm_atan_f32(y/x) - PI;
 8012186: edc0 7a00    	vstr	s15, [r0]
;         return(ARM_MATH_SUCCESS);
 801218a: 2000         	movs	r0, #0x0
 801218c: 4770         	bx	lr
;         if (y > 0.0f)
 801218e: eeb5 0ac0    	vcmpe.f32	s0, #0
 8012192: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8012196: dd6b         	ble	0x8012270 <arm_atan2_f32+0x19c> @ imm = #0xd6
;            *result=arm_atan_f32(y/x) + PI;
 8012198: eec0 7a20    	vdiv.f32	s15, s0, s1
;    if (x > 1.0f)
 801219c: eef7 6a00    	vmov.f32	s13, #1.000000e+00
;    if (x < 0.0f)
 80121a0: eef5 7ac0    	vcmpe.f32	s15, #0
 80121a4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
;       x=-x;
 80121a8: bf48         	it	mi
 80121aa: eef1 7a67    	vnegmi.f32	s15, s15
;    if (x > 1.0f)
 80121ae: eef4 7ae6    	vcmpe.f32	s15, s13
;       sign=1;
 80121b2: bf4c         	ite	mi
 80121b4: 2301         	movmi	r3, #0x1
;    int sign=0;
 80121b6: 2300         	movpl	r3, #0x0
;    if (x > 1.0f)
 80121b8: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80121bc: f340 809f    	ble.w	0x80122fe <arm_atan2_f32+0x22a> @ imm = #0x13e
;       x = 1.0f / x;
 80121c0: ee86 7aa7    	vdiv.f32	s14, s13, s15
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 80121c4: eddf 2a77    	vldr	s5, [pc, #476]          @ 0x80123a4 <arm_atan2_f32+0x2d0>
 80121c8: ed9f 3a77    	vldr	s6, [pc, #476]          @ 0x80123a8 <arm_atan2_f32+0x2d4>
 80121cc: eddf 3a77    	vldr	s7, [pc, #476]          @ 0x80123ac <arm_atan2_f32+0x2d8>
 80121d0: ed9f 4a77    	vldr	s8, [pc, #476]          @ 0x80123b0 <arm_atan2_f32+0x2dc>
 80121d4: eddf 4a77    	vldr	s9, [pc, #476]          @ 0x80123b4 <arm_atan2_f32+0x2e0>
 80121d8: ed9f 5a77    	vldr	s10, [pc, #476]         @ 0x80123b8 <arm_atan2_f32+0x2e4>
 80121dc: eddf 5a77    	vldr	s11, [pc, #476]         @ 0x80123bc <arm_atan2_f32+0x2e8>
 80121e0: ed9f 6a77    	vldr	s12, [pc, #476]         @ 0x80123c0 <arm_atan2_f32+0x2ec>
 80121e4: eddf 6a77    	vldr	s13, [pc, #476]         @ 0x80123c4 <arm_atan2_f32+0x2f0>
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 80121e8: eddf 7a77    	vldr	s15, [pc, #476]         @ 0x80123c8 <arm_atan2_f32+0x2f4>
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 80121ec: eea7 3a22    	vfma.f32	s6, s14, s5
 80121f0: eee7 3a03    	vfma.f32	s7, s14, s6
 80121f4: eea7 4a23    	vfma.f32	s8, s14, s7
 80121f8: eee7 4a04    	vfma.f32	s9, s14, s8
 80121fc: eea7 5a24    	vfma.f32	s10, s14, s9
 8012200: eee7 5a05    	vfma.f32	s11, s14, s10
 8012204: eea7 6a25    	vfma.f32	s12, s14, s11
 8012208: eee7 6a06    	vfma.f32	s13, s14, s12
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 801220c: eee7 7a66    	vfms.f32	s15, s14, s13
;    if (sign)
 8012210: b10b         	cbz	r3, 0x8012216 <arm_atan2_f32+0x142> @ imm = #0x2
;      res = -res;
 8012212: eef1 7a67    	vneg.f32	s15, s15
;            *result=arm_atan_f32(y/x) + PI;
 8012216: ed9f 7a6d    	vldr	s14, [pc, #436]         @ 0x80123cc <arm_atan2_f32+0x2f8>
 801221a: ee77 7a87    	vadd.f32	s15, s15, s14
 801221e: e76f         	b	0x8012100 <arm_atan2_f32+0x2c> @ imm = #-0x122
 8012220: eddf 7a69    	vldr	s15, [pc, #420]         @ 0x80123c8 <arm_atan2_f32+0x2f4>
 8012224: e76c         	b	0x8012100 <arm_atan2_f32+0x2c> @ imm = #-0x128
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 8012226: eddf 6a5f    	vldr	s13, [pc, #380]         @ 0x80123a4 <arm_atan2_f32+0x2d0>
 801222a: ed9f 7a5f    	vldr	s14, [pc, #380]         @ 0x80123a8 <arm_atan2_f32+0x2d4>
 801222e: ed9f 4a5f    	vldr	s8, [pc, #380]          @ 0x80123ac <arm_atan2_f32+0x2d8>
 8012232: eddf 4a5f    	vldr	s9, [pc, #380]          @ 0x80123b0 <arm_atan2_f32+0x2dc>
 8012236: ed9f 5a5f    	vldr	s10, [pc, #380]         @ 0x80123b4 <arm_atan2_f32+0x2e0>
 801223a: eddf 5a5f    	vldr	s11, [pc, #380]         @ 0x80123b8 <arm_atan2_f32+0x2e4>
 801223e: ed9f 6a5f    	vldr	s12, [pc, #380]         @ 0x80123bc <arm_atan2_f32+0x2e8>
 8012242: eea7 7aa6    	vfma.f32	s14, s15, s13
 8012246: eddf 6a5e    	vldr	s13, [pc, #376]         @ 0x80123c0 <arm_atan2_f32+0x2ec>
 801224a: eea7 4a87    	vfma.f32	s8, s15, s14
 801224e: ed9f 7a5d    	vldr	s14, [pc, #372]         @ 0x80123c4 <arm_atan2_f32+0x2f0>
 8012252: eee7 4a84    	vfma.f32	s9, s15, s8
 8012256: eea7 5aa4    	vfma.f32	s10, s15, s9
 801225a: eee7 5a85    	vfma.f32	s11, s15, s10
 801225e: eea7 6aa5    	vfma.f32	s12, s15, s11
 8012262: eee7 6a86    	vfma.f32	s13, s15, s12
 8012266: eea7 7aa6    	vfma.f32	s14, s15, s13
 801226a: ee67 7a87    	vmul.f32	s15, s15, s14
;     for(i=1;i<ATAN2_NB_COEFS_F32;i++)
 801226e: e786         	b	0x801217e <arm_atan2_f32+0xaa> @ imm = #-0xf4
;         else if (y < 0.0f)
 8012270: d402         	bmi	0x8012278 <arm_atan2_f32+0x1a4> @ imm = #0x4
 8012272: eddf 7a56    	vldr	s15, [pc, #344]         @ 0x80123cc <arm_atan2_f32+0x2f8>
 8012276: e743         	b	0x8012100 <arm_atan2_f32+0x2c> @ imm = #-0x17a
;            *result=arm_atan_f32(y/x) - PI;
 8012278: eec0 7a20    	vdiv.f32	s15, s0, s1
;    if (x > 1.0f)
 801227c: eef7 6a00    	vmov.f32	s13, #1.000000e+00
;    if (x < 0.0f)
 8012280: eef5 7ac0    	vcmpe.f32	s15, #0
 8012284: eef1 fa10    	vmrs	APSR_nzcv, fpscr
;       x=-x;
 8012288: bf48         	it	mi
 801228a: eef1 7a67    	vnegmi.f32	s15, s15
;    if (x > 1.0f)
 801228e: eef4 7ae6    	vcmpe.f32	s15, s13
;       sign=1;
 8012292: bf4c         	ite	mi
 8012294: 2301         	movmi	r3, #0x1
;    int sign=0;
 8012296: 2300         	movpl	r3, #0x0
;    if (x > 1.0f)
 8012298: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 801229c: dd5a         	ble	0x8012354 <arm_atan2_f32+0x280> @ imm = #0xb4
;       x = 1.0f / x;
 801229e: ee86 7aa7    	vdiv.f32	s14, s13, s15
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 80122a2: eddf 2a40    	vldr	s5, [pc, #256]          @ 0x80123a4 <arm_atan2_f32+0x2d0>
 80122a6: ed9f 3a40    	vldr	s6, [pc, #256]          @ 0x80123a8 <arm_atan2_f32+0x2d4>
 80122aa: eddf 3a40    	vldr	s7, [pc, #256]          @ 0x80123ac <arm_atan2_f32+0x2d8>
 80122ae: ed9f 4a40    	vldr	s8, [pc, #256]          @ 0x80123b0 <arm_atan2_f32+0x2dc>
 80122b2: eddf 4a40    	vldr	s9, [pc, #256]          @ 0x80123b4 <arm_atan2_f32+0x2e0>
 80122b6: ed9f 5a40    	vldr	s10, [pc, #256]         @ 0x80123b8 <arm_atan2_f32+0x2e4>
 80122ba: eddf 5a40    	vldr	s11, [pc, #256]         @ 0x80123bc <arm_atan2_f32+0x2e8>
 80122be: ed9f 6a40    	vldr	s12, [pc, #256]         @ 0x80123c0 <arm_atan2_f32+0x2ec>
 80122c2: eddf 6a40    	vldr	s13, [pc, #256]         @ 0x80123c4 <arm_atan2_f32+0x2f0>
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 80122c6: eddf 7a40    	vldr	s15, [pc, #256]         @ 0x80123c8 <arm_atan2_f32+0x2f4>
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 80122ca: eea7 3a22    	vfma.f32	s6, s14, s5
 80122ce: eee7 3a03    	vfma.f32	s7, s14, s6
 80122d2: eea7 4a23    	vfma.f32	s8, s14, s7
 80122d6: eee7 4a04    	vfma.f32	s9, s14, s8
 80122da: eea7 5a24    	vfma.f32	s10, s14, s9
 80122de: eee7 5a05    	vfma.f32	s11, s14, s10
 80122e2: eea7 6a25    	vfma.f32	s12, s14, s11
 80122e6: eee7 6a06    	vfma.f32	s13, s14, s12
;       res = PIHALFF32 - arm_atan_limited_f32(x);
 80122ea: eee7 7a66    	vfms.f32	s15, s14, s13
;    if (sign)
 80122ee: b10b         	cbz	r3, 0x80122f4 <arm_atan2_f32+0x220> @ imm = #0x2
;      res = -res;
 80122f0: eef1 7a67    	vneg.f32	s15, s15
;            *result=arm_atan_f32(y/x) - PI;
 80122f4: ed9f 7a35    	vldr	s14, [pc, #212]         @ 0x80123cc <arm_atan2_f32+0x2f8>
 80122f8: ee77 7ac7    	vsub.f32	s15, s15, s14
 80122fc: e700         	b	0x8012100 <arm_atan2_f32+0x2c> @ imm = #-0x200
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 80122fe: eddf 6a29    	vldr	s13, [pc, #164]         @ 0x80123a4 <arm_atan2_f32+0x2d0>
 8012302: ed9f 7a29    	vldr	s14, [pc, #164]         @ 0x80123a8 <arm_atan2_f32+0x2d4>
 8012306: ed9f 4a29    	vldr	s8, [pc, #164]          @ 0x80123ac <arm_atan2_f32+0x2d8>
 801230a: eddf 4a29    	vldr	s9, [pc, #164]          @ 0x80123b0 <arm_atan2_f32+0x2dc>
 801230e: ed9f 5a29    	vldr	s10, [pc, #164]         @ 0x80123b4 <arm_atan2_f32+0x2e0>
 8012312: eddf 5a29    	vldr	s11, [pc, #164]         @ 0x80123b8 <arm_atan2_f32+0x2e4>
 8012316: ed9f 6a29    	vldr	s12, [pc, #164]         @ 0x80123bc <arm_atan2_f32+0x2e8>
 801231a: eea7 7aa6    	vfma.f32	s14, s15, s13
 801231e: eddf 6a28    	vldr	s13, [pc, #160]         @ 0x80123c0 <arm_atan2_f32+0x2ec>
 8012322: eea7 4a87    	vfma.f32	s8, s15, s14
 8012326: ed9f 7a27    	vldr	s14, [pc, #156]         @ 0x80123c4 <arm_atan2_f32+0x2f0>
 801232a: eee7 4a84    	vfma.f32	s9, s15, s8
 801232e: eea7 5aa4    	vfma.f32	s10, s15, s9
 8012332: eee7 5a85    	vfma.f32	s11, s15, s10
 8012336: eea7 6aa5    	vfma.f32	s12, s15, s11
 801233a: eee7 6a86    	vfma.f32	s13, s15, s12
 801233e: eea7 7aa6    	vfma.f32	s14, s15, s13
 8012342: ee67 7a87    	vmul.f32	s15, s15, s14
;    if (sign)
 8012346: 2b00         	cmp	r3, #0x0
 8012348: f43f af65    	beq.w	0x8012216 <arm_atan2_f32+0x142> @ imm = #-0x136
 801234c: e761         	b	0x8012212 <arm_atan2_f32+0x13e> @ imm = #-0x13e
;     return(ARM_MATH_NANINF);
 801234e: f06f 0003    	mvn	r0, #0x3
; }
 8012352: 4770         	bx	lr
;         res = x*res + atan2_coefs_f32[ATAN2_NB_COEFS_F32-1-i];
 8012354: eddf 6a13    	vldr	s13, [pc, #76]          @ 0x80123a4 <arm_atan2_f32+0x2d0>
 8012358: ed9f 7a13    	vldr	s14, [pc, #76]          @ 0x80123a8 <arm_atan2_f32+0x2d4>
 801235c: ed9f 4a13    	vldr	s8, [pc, #76]           @ 0x80123ac <arm_atan2_f32+0x2d8>
 8012360: eddf 4a13    	vldr	s9, [pc, #76]           @ 0x80123b0 <arm_atan2_f32+0x2dc>
 8012364: ed9f 5a13    	vldr	s10, [pc, #76]          @ 0x80123b4 <arm_atan2_f32+0x2e0>
 8012368: eddf 5a13    	vldr	s11, [pc, #76]          @ 0x80123b8 <arm_atan2_f32+0x2e4>
 801236c: ed9f 6a13    	vldr	s12, [pc, #76]          @ 0x80123bc <arm_atan2_f32+0x2e8>
 8012370: eea7 7aa6    	vfma.f32	s14, s15, s13
 8012374: eddf 6a12    	vldr	s13, [pc, #72]          @ 0x80123c0 <arm_atan2_f32+0x2ec>
 8012378: eea7 4a87    	vfma.f32	s8, s15, s14
 801237c: ed9f 7a11    	vldr	s14, [pc, #68]          @ 0x80123c4 <arm_atan2_f32+0x2f0>
 8012380: eee7 4a84    	vfma.f32	s9, s15, s8
 8012384: eea7 5aa4    	vfma.f32	s10, s15, s9
 8012388: eee7 5a85    	vfma.f32	s11, s15, s10
 801238c: eea7 6aa5    	vfma.f32	s12, s15, s11
 8012390: eee7 6a86    	vfma.f32	s13, s15, s12
 8012394: eea7 7aa6    	vfma.f32	s14, s15, s13
 8012398: ee67 7a87    	vmul.f32	s15, s15, s14
;     for(i=1;i<ATAN2_NB_COEFS_F32;i++)
 801239c: e7a7         	b	0x80122ee <arm_atan2_f32+0x21a> @ imm = #-0xb2
 801239e: bf00         	nop

080123a0 <$d>:
 80123a0: db 0f c9 bf  	.word	0xbfc90fdb
 80123a4: a5 92 04 bd  	.word	0xbd0492a5
 80123a8: e7 45 09 3e  	.word	0x3e0945e7
 80123ac: 08 b7 32 be  	.word	0xbe32b708
 80123b0: eb fc a9 bc  	.word	0xbca9fceb
 80123b4: 3c 69 5d 3e  	.word	0x3e5d693c
 80123b8: 43 56 90 bb  	.word	0xbb905643
 80123bc: e5 65 aa be  	.word	0xbeaa65e5
 80123c0: c9 0c c0 b7  	.word	0xb7c00cc9
 80123c4: 01 00 80 3f  	.word	0x3f800001
 80123c8: db 0f c9 3f  	.word	0x3fc90fdb
 80123cc: db 0f 49 40  	.word	0x40490fdb

080123d0 <arm_mat_add_f32>:
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 80123d0: 8803         	ldrh	r3, [r0]
 80123d2: f8b0 c002    	ldrh.w	r12, [r0, #0x2]
;   float32_t *pInB = pSrcB->pData;                /* input data matrix pointer B */
 80123d6: 6849         	ldr	r1, [r1, #0x4]
;   float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A */
 80123d8: 6840         	ldr	r0, [r0, #0x4]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 80123da: 6852         	ldr	r2, [r2, #0x4]
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 80123dc: fb0c f303    	mul	r3, r12, r3
;     while (blkCnt > 0U)
 80123e0: b14b         	cbz	r3, 0x80123f6 <arm_mat_add_f32+0x26> @ imm = #0x12
;       *pOut++ = *pInA++ + *pInB++;
 80123e2: ecf0 7a01    	vldmia	r0!, {s15}
 80123e6: ecb1 7a01    	vldmia	r1!, {s14}
 80123ea: ee77 7a87    	vadd.f32	s15, s15, s14
;     while (blkCnt > 0U)
 80123ee: 3b01         	subs	r3, #0x1
;       *pOut++ = *pInA++ + *pInB++;
 80123f0: ece2 7a01    	vstmia	r2!, {s15}
;     while (blkCnt > 0U)
 80123f4: d1f5         	bne	0x80123e2 <arm_mat_add_f32+0x12> @ imm = #-0x16
; }
 80123f6: 2000         	movs	r0, #0x0
 80123f8: 4770         	bx	lr
 80123fa: bf00         	nop

080123fc <arm_mat_init_f32>:
;   S->numRows = nRows;
 80123fc: 8001         	strh	r1, [r0]
;   S->numCols = nColumns;
 80123fe: 8042         	strh	r2, [r0, #0x2]
;   S->pData = pData;
 8012400: 6043         	str	r3, [r0, #0x4]
; }
 8012402: 4770         	bx	lr

08012404 <arm_mat_inverse_f32>:
; {
 8012404: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8012408: 4604         	mov	r4, r0
;   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
 801240a: 8806         	ldrh	r6, [r0]
;   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
 801240c: 8863         	ldrh	r3, [r4, #0x2]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 801240e: 6848         	ldr	r0, [r1, #0x4]
; {
 8012410: b083         	sub	sp, #0xc
 8012412: 460d         	mov	r5, r1
;   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
 8012414: 9301         	str	r3, [sp, #0x4]
;     while (rowCnt > 0U)
 8012416: b346         	cbz	r6, 0x801246a <arm_mat_inverse_f32+0x66> @ imm = #0x50
;   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
 8012418: 46b1         	mov	r9, r6
;     while (rowCnt > 0U)
 801241a: f04f 0a00    	mov.w	r10, #0x0
;       *pTmp++ = 1.0f;
 801241e: f04f 5b7e    	mov.w	r11, #0x3f800000
 8012422: e011         	b	0x8012448 <arm_mat_inverse_f32+0x44> @ imm = #0x22
;         *pTmp++ = 0.0f;
 8012424: f015 f870    	bl	0x8027508 <memset>      @ imm = #0x150e0
;       while (j > 0U)
 8012428: f1b9 0901    	subs.w	r9, r9, #0x1
;       *pTmp++ = 1.0f;
 801242c: f848 bb04    	str	r11, [r8], #4
;       while (j > 0U)
 8012430: f10a 0a01    	add.w	r10, r10, #0x1
 8012434: d019         	beq	0x801246a <arm_mat_inverse_f32+0x66> @ imm = #0x32
 8012436: ea4f 0789    	lsl.w	r7, r9, #0x2
;         *pTmp++ = 0.0f;
 801243a: 463a         	mov	r2, r7
 801243c: 2100         	movs	r1, #0x0
 801243e: 4640         	mov	r0, r8
 8012440: f015 f862    	bl	0x8027508 <memset>      @ imm = #0x150c4
 8012444: eb08 0007    	add.w	r0, r8, r7
;       while (j > 0U)
 8012448: ea4f 028a    	lsl.w	r2, r10, #0x2
;       *pTmp++ = 1.0f;
 801244c: eb00 0802    	add.w	r8, r0, r2
;         *pTmp++ = 0.0f;
 8012450: 2100         	movs	r1, #0x0
;       while (j > 0U)
 8012452: f1ba 0f00    	cmp.w	r10, #0x0
 8012456: d1e5         	bne	0x8012424 <arm_mat_inverse_f32+0x20> @ imm = #-0x36
;       *pTmp++ = 1.0f;
 8012458: 4680         	mov	r8, r0
;       while (j > 0U)
 801245a: f1b9 0901    	subs.w	r9, r9, #0x1
;       *pTmp++ = 1.0f;
 801245e: f848 bb04    	str	r11, [r8], #4
;       while (j > 0U)
 8012462: d002         	beq	0x801246a <arm_mat_inverse_f32+0x66> @ imm = #0x4
 8012464: f04f 0a01    	mov.w	r10, #0x1
 8012468: e7e5         	b	0x8012436 <arm_mat_inverse_f32+0x32> @ imm = #-0x36
;     for(column = 0U; column < numCols; column++)
 801246a: 9b01         	ldr	r3, [sp, #0x4]
 801246c: 2b00         	cmp	r3, #0x0
 801246e: f000 80ef    	beq.w	0x8012650 <arm_mat_inverse_f32+0x24c> @ imm = #0x1de
 8012472: f04f 0800    	mov.w	r8, #0x0
;       pivot = 1.0f / pivot;
 8012476: eef7 5a00    	vmov.f32	s11, #1.000000e+00
;     for(column = 0U; column < numCols; column++)
 801247a: 46c1         	mov	r9, r8
;   uint32_t selectedRow,pivotRow,i, rowNb, rowCnt, flag = 0U, j,column;      /* loop counters */
 801247c: 46c2         	mov	r10, r8
;       pTmp = ELEM(pSrc,column,column) ;
 801247e: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
 8012482: f8d4 b004    	ldr.w	r11, [r4, #0x4]
 8012486: f10c 0e01    	add.w	lr, r12, #0x1
 801248a: ea4f 0e8e    	lsl.w	lr, lr, #0x2
 801248e: fb0e b209    	mla	r2, lr, r9, r11
;       pivot = *pTmp;
 8012492: 464b         	mov	r3, r9
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 8012494: f109 0901    	add.w	r9, r9, #0x1
 8012498: 454e         	cmp	r6, r9
;       pivot = *pTmp;
 801249a: ed92 7a00    	vldr	s14, [r2]
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 801249e: f240 810d    	bls.w	0x80126bc <arm_mat_inverse_f32+0x2b8> @ imm = #0x21a
 80124a2: fb09 300c    	mla	r0, r9, r12, r3
 80124a6: f1ae 0e04    	sub.w	lr, lr, #0x4
 80124aa: eb0b 0080    	add.w	r0, r11, r0, lsl #2
 80124ae: 4649         	mov	r1, r9
 80124b0: 461f         	mov	r7, r3
;           newPivot = *pTmp;
 80124b2: edd0 7a00    	vldr	s15, [r0]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 80124b6: eeb0 6ac7    	vabs.f32	s12, s14
 80124ba: eef0 6ae7    	vabs.f32	s13, s15
;             pivot = newPivot;
 80124be: eeb4 6ae6    	vcmpe.f32	s12, s13
 80124c2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80124c6: bf48         	it	mi
 80124c8: 460f         	movmi	r7, r1
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 80124ca: f101 0101    	add.w	r1, r1, #0x1
;             pivot = newPivot;
 80124ce: bf48         	it	mi
 80124d0: eeb0 7a67    	vmovmi.f32	s14, s15
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 80124d4: 428e         	cmp	r6, r1
 80124d6: 4470         	add	r0, lr
 80124d8: d1eb         	bne	0x80124b2 <arm_mat_inverse_f32+0xae> @ imm = #-0x2a
;       if ((pivot != 0.0f) && (selectedRow != column))
 80124da: eeb5 7a40    	vcmp.f32	s14, #0
 80124de: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80124e2: f000 80b1    	beq.w	0x8012648 <arm_mat_inverse_f32+0x244> @ imm = #0x162
 80124e6: 4547         	cmp	r7, r8
 80124e8: f040 80b7    	bne.w	0x801265a <arm_mat_inverse_f32+0x256> @ imm = #0x16e
;       if ((flag != 1U) && (pivot == 0.0f))
 80124ec: f1ba 0f01    	cmp.w	r10, #0x1
 80124f0: f000 80dd    	beq.w	0x80126ae <arm_mat_inverse_f32+0x2aa> @ imm = #0x1ba
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 80124f4: fb0c 3203    	mla	r2, r12, r3, r3
 80124f8: eb0b 0282    	add.w	r2, r11, r2, lsl #2
 80124fc: ebac 0103    	sub.w	r1, r12, r3
 8012500: 2900         	cmp	r1, #0x0
;       pivot = 1.0f / pivot;
 8012502: eec5 7a87    	vdiv.f32	s15, s11, s14
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 8012506: dd09         	ble	0x801251c <arm_mat_inverse_f32+0x118> @ imm = #0x12
 8012508: eb02 0181    	add.w	r1, r2, r1, lsl #2
 801250c: ecb2 7a01    	vldmia	r2!, {s14}
 8012510: ee27 7a27    	vmul.f32	s14, s14, s15
 8012514: 428a         	cmp	r2, r1
 8012516: ed02 7a01    	vstr	s14, [r2, #-4]
 801251a: d1f7         	bne	0x801250c <arm_mat_inverse_f32+0x108> @ imm = #-0x12
;       SCALE_ROW_F32(pDst,0,pivot,pivotRow);
 801251c: 8868         	ldrh	r0, [r5, #0x2]
 801251e: 686a         	ldr	r2, [r5, #0x4]
 8012520: 0081         	lsls	r1, r0, #0x2
 8012522: fb01 2203    	mla	r2, r1, r3, r2
 8012526: 4411         	add	r1, r2
 8012528: b138         	cbz	r0, 0x801253a <arm_mat_inverse_f32+0x136> @ imm = #0xe
 801252a: ecb2 7a01    	vldmia	r2!, {s14}
 801252e: ee27 7a27    	vmul.f32	s14, s14, s15
 8012532: 428a         	cmp	r2, r1
 8012534: ed02 7a01    	vstr	s14, [r2, #-4]
 8012538: d1f7         	bne	0x801252a <arm_mat_inverse_f32+0x126> @ imm = #-0x12
;       rowNb = 0;
 801253a: 2000         	movs	r0, #0x0
;       for (;rowNb < pivotRow; rowNb++)
 801253c: f1b8 0f00    	cmp.w	r8, #0x0
 8012540: d036         	beq	0x80125b0 <arm_mat_inverse_f32+0x1ac> @ imm = #0x6c
;            pTmp = ELEM(pSrc,rowNb,column) ;
 8012542: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
 8012546: 6861         	ldr	r1, [r4, #0x4]
 8012548: fb00 320c    	mla	r2, r0, r12, r3
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 801254c: ebac 0703    	sub.w	r7, r12, r3
;            pTmp = ELEM(pSrc,rowNb,column) ;
 8012550: eb01 0282    	add.w	r2, r1, r2, lsl #2
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 8012554: fb0c 3c03    	mla	r12, r12, r3, r3
 8012558: 2f00         	cmp	r7, #0x0
;            pivot = *pTmp;
 801255a: edd2 7a00    	vldr	s15, [r2]
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 801255e: eb01 018c    	add.w	r1, r1, r12, lsl #2
 8012562: dd0b         	ble	0x801257c <arm_mat_inverse_f32+0x178> @ imm = #0x16
 8012564: eb02 0787    	add.w	r7, r2, r7, lsl #2
 8012568: ecb2 7a01    	vldmia	r2!, {s14}
 801256c: ecf1 6a01    	vldmia	r1!, {s13}
 8012570: eea6 7ae7    	vfms.f32	s14, s13, s15
 8012574: 42ba         	cmp	r2, r7
 8012576: ed02 7a01    	vstr	s14, [r2, #-4]
 801257a: d1f5         	bne	0x8012568 <arm_mat_inverse_f32+0x164> @ imm = #-0x16
;            MAS_ROW_F32(0     ,pDst,rowNb,pivot,pDst,pivotRow);
 801257c: f8b5 c002    	ldrh.w	r12, [r5, #0x2]
 8012580: 6869         	ldr	r1, [r5, #0x4]
 8012582: ea4f 078c    	lsl.w	r7, r12, #0x2
 8012586: fb07 1200    	mla	r2, r7, r0, r1
 801258a: fb07 1103    	mla	r1, r7, r3, r1
 801258e: 4417         	add	r7, r2
 8012590: f1bc 0f00    	cmp.w	r12, #0x0
 8012594: d009         	beq	0x80125aa <arm_mat_inverse_f32+0x1a6> @ imm = #0x12
 8012596: ecb2 7a01    	vldmia	r2!, {s14}
 801259a: ecf1 6a01    	vldmia	r1!, {s13}
 801259e: eea6 7ae7    	vfms.f32	s14, s13, s15
 80125a2: 42ba         	cmp	r2, r7
 80125a4: ed02 7a01    	vstr	s14, [r2, #-4]
 80125a8: d1f5         	bne	0x8012596 <arm_mat_inverse_f32+0x192> @ imm = #-0x16
;       for (;rowNb < pivotRow; rowNb++)
 80125aa: 3001         	adds	r0, #0x1
 80125ac: 4540         	cmp	r0, r8
 80125ae: d1c8         	bne	0x8012542 <arm_mat_inverse_f32+0x13e> @ imm = #-0x70
;       for (rowNb = pivotRow + 1; rowNb < numRows; rowNb++)
 80125b0: 454e         	cmp	r6, r9
 80125b2: d937         	bls	0x8012624 <arm_mat_inverse_f32+0x220> @ imm = #0x6e
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 80125b4: 4648         	mov	r0, r9
;            pTmp = ELEM(pSrc,rowNb,column) ;
 80125b6: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
 80125ba: 6861         	ldr	r1, [r4, #0x4]
 80125bc: fb00 320c    	mla	r2, r0, r12, r3
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 80125c0: ebac 0703    	sub.w	r7, r12, r3
;            pTmp = ELEM(pSrc,rowNb,column) ;
 80125c4: eb01 0282    	add.w	r2, r1, r2, lsl #2
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 80125c8: fb0c 3c03    	mla	r12, r12, r3, r3
 80125cc: 2f00         	cmp	r7, #0x0
;            pivot = *pTmp;
 80125ce: edd2 7a00    	vldr	s15, [r2]
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 80125d2: eb01 018c    	add.w	r1, r1, r12, lsl #2
 80125d6: dd0b         	ble	0x80125f0 <arm_mat_inverse_f32+0x1ec> @ imm = #0x16
 80125d8: eb02 0787    	add.w	r7, r2, r7, lsl #2
 80125dc: ecb2 7a01    	vldmia	r2!, {s14}
 80125e0: ecf1 6a01    	vldmia	r1!, {s13}
 80125e4: eea6 7ae7    	vfms.f32	s14, s13, s15
 80125e8: 42ba         	cmp	r2, r7
 80125ea: ed02 7a01    	vstr	s14, [r2, #-4]
 80125ee: d1f5         	bne	0x80125dc <arm_mat_inverse_f32+0x1d8> @ imm = #-0x16
;            MAS_ROW_F32(0     ,pDst,rowNb,pivot,pDst,pivotRow);
 80125f0: f8b5 c002    	ldrh.w	r12, [r5, #0x2]
 80125f4: 6869         	ldr	r1, [r5, #0x4]
 80125f6: ea4f 078c    	lsl.w	r7, r12, #0x2
 80125fa: fb00 1207    	mla	r2, r0, r7, r1
 80125fe: fb03 1107    	mla	r1, r3, r7, r1
 8012602: 4417         	add	r7, r2
 8012604: f1bc 0f00    	cmp.w	r12, #0x0
 8012608: d009         	beq	0x801261e <arm_mat_inverse_f32+0x21a> @ imm = #0x12
 801260a: ecb2 7a01    	vldmia	r2!, {s14}
 801260e: ecf1 6a01    	vldmia	r1!, {s13}
 8012612: eea6 7ae7    	vfms.f32	s14, s13, s15
 8012616: 42ba         	cmp	r2, r7
 8012618: ed02 7a01    	vstr	s14, [r2, #-4]
 801261c: d1f5         	bne	0x801260a <arm_mat_inverse_f32+0x206> @ imm = #-0x16
;       for (rowNb = pivotRow + 1; rowNb < numRows; rowNb++)
 801261e: 3001         	adds	r0, #0x1
 8012620: 4286         	cmp	r6, r0
 8012622: d1c8         	bne	0x80125b6 <arm_mat_inverse_f32+0x1b2> @ imm = #-0x70
;     for(column = 0U; column < numCols; column++)
 8012624: 9b01         	ldr	r3, [sp, #0x4]
 8012626: 454b         	cmp	r3, r9
 8012628: f108 0801    	add.w	r8, r8, #0x1
 801262c: f47f af27    	bne.w	0x801247e <arm_mat_inverse_f32+0x7a> @ imm = #-0x1b2
;     if ((flag != 1U) && (pivot == 0.0f))
 8012630: f1ba 0f01    	cmp.w	r10, #0x1
 8012634: d004         	beq	0x8012640 <arm_mat_inverse_f32+0x23c> @ imm = #0x8
 8012636: eef5 7a40    	vcmp.f32	s15, #0
 801263a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 801263e: d050         	beq	0x80126e2 <arm_mat_inverse_f32+0x2de> @ imm = #0xa0
;     status = ARM_MATH_SUCCESS;
 8012640: 2000         	movs	r0, #0x0
; }
 8012642: b003         	add	sp, #0xc
 8012644: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
;       if ((flag != 1U) && (pivot == 0.0f))
 8012648: f1ba 0f01    	cmp.w	r10, #0x1
 801264c: f43f af56    	beq.w	0x80124fc <arm_mat_inverse_f32+0xf8> @ imm = #-0x154
;         return ARM_MATH_SINGULAR;
 8012650: f06f 0004    	mvn	r0, #0x4
; }
 8012654: b003         	add	sp, #0xc
 8012656: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
;             SWAP_ROWS_F32(pSrc,column, pivotRow,selectedRow);
 801265a: fb07 310c    	mla	r1, r7, r12, r3
 801265e: ebac 0c03    	sub.w	r12, r12, r3
 8012662: f1bc 0f00    	cmp.w	r12, #0x0
 8012666: eb0b 0181    	add.w	r1, r11, r1, lsl #2
 801266a: dd0a         	ble	0x8012682 <arm_mat_inverse_f32+0x27e> @ imm = #0x14
 801266c: eb02 0e8c    	add.w	lr, r2, r12, lsl #2
 8012670: f8d1 c000    	ldr.w	r12, [r1]
 8012674: 6810         	ldr	r0, [r2]
 8012676: f842 cb04    	str	r12, [r2], #4
 801267a: 4572         	cmp	r2, lr
 801267c: f841 0b04    	str	r0, [r1], #4
 8012680: d1f6         	bne	0x8012670 <arm_mat_inverse_f32+0x26c> @ imm = #-0x14
;             SWAP_ROWS_F32(pDst,0, pivotRow,selectedRow);
 8012682: 8869         	ldrh	r1, [r5, #0x2]
 8012684: 686a         	ldr	r2, [r5, #0x4]
 8012686: ea4f 0c81    	lsl.w	r12, r1, #0x2
 801268a: fb0c 2707    	mla	r7, r12, r7, r2
 801268e: fb0c 2203    	mla	r2, r12, r3, r2
 8012692: b1a9         	cbz	r1, 0x80126c0 <arm_mat_inverse_f32+0x2bc> @ imm = #0x2a
 8012694: 4494         	add	r12, r2
 8012696: 6838         	ldr	r0, [r7]
 8012698: 6811         	ldr	r1, [r2]
 801269a: f842 0b04    	str	r0, [r2], #4
 801269e: 4562         	cmp	r2, r12
 80126a0: f847 1b04    	str	r1, [r7], #4
 80126a4: d1f7         	bne	0x8012696 <arm_mat_inverse_f32+0x292> @ imm = #-0x12
 80126a6: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
 80126aa: f8d4 b004    	ldr.w	r11, [r4, #0x4]
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 80126ae: fb0c 3203    	mla	r2, r12, r3, r3
 80126b2: eb0b 0282    	add.w	r2, r11, r2, lsl #2
 80126b6: f04f 0a01    	mov.w	r10, #0x1
 80126ba: e71f         	b	0x80124fc <arm_mat_inverse_f32+0xf8> @ imm = #-0x1c2
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 80126bc: 461f         	mov	r7, r3
 80126be: e70c         	b	0x80124da <arm_mat_inverse_f32+0xd6> @ imm = #-0x1e8
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 80126c0: 8861         	ldrh	r1, [r4, #0x2]
 80126c2: 6862         	ldr	r2, [r4, #0x4]
 80126c4: fb01 3003    	mla	r0, r1, r3, r3
 80126c8: 1ac9         	subs	r1, r1, r3
;       pivot = 1.0f / pivot;
 80126ca: eef7 6a00    	vmov.f32	s13, #1.000000e+00
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 80126ce: 2900         	cmp	r1, #0x0
;       pivot = 1.0f / pivot;
 80126d0: eec6 7a87    	vdiv.f32	s15, s13, s14
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 80126d4: eb02 0280    	add.w	r2, r2, r0, lsl #2
;             flag = 1U;
 80126d8: f04f 0a01    	mov.w	r10, #0x1
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 80126dc: f73f af14    	bgt.w	0x8012508 <arm_mat_inverse_f32+0x104> @ imm = #-0x1d8
 80126e0: e72b         	b	0x801253a <arm_mat_inverse_f32+0x136> @ imm = #-0x1aa
;       for (i = 0; i < numRows * numCols; i++)
 80126e2: fb03 f606    	mul	r6, r3, r6
;       pIn = pSrc->pData;
 80126e6: 6863         	ldr	r3, [r4, #0x4]
;       for (i = 0; i < numRows * numCols; i++)
 80126e8: b926         	cbnz	r6, 0x80126f4 <arm_mat_inverse_f32+0x2f0> @ imm = #0x8
 80126ea: e7b1         	b	0x8012650 <arm_mat_inverse_f32+0x24c> @ imm = #-0x9e
 80126ec: f10a 0a01    	add.w	r10, r10, #0x1
 80126f0: 45b2         	cmp	r10, r6
 80126f2: d0ad         	beq	0x8012650 <arm_mat_inverse_f32+0x24c> @ imm = #-0xa6
;         if (pIn[i] != 0.0f)
 80126f4: ecf3 7a01    	vldmia	r3!, {s15}
 80126f8: eef5 7a40    	vcmp.f32	s15, #0
 80126fc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8012700: d0f4         	beq	0x80126ec <arm_mat_inverse_f32+0x2e8> @ imm = #-0x18
;       if (i == numRows * numCols)
 8012702: 4556         	cmp	r6, r10
 8012704: d19c         	bne	0x8012640 <arm_mat_inverse_f32+0x23c> @ imm = #-0xc8
 8012706: e7a3         	b	0x8012650 <arm_mat_inverse_f32+0x24c> @ imm = #-0xba

08012708 <arm_mat_mult_f32>:
; {
 8012708: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 801270c: 460e         	mov	r6, r1
;   float32_t *pIn2 = pSrcB->pData;                /* Input data matrix pointer B */
 801270e: 684b         	ldr	r3, [r1, #0x4]
;   uint16_t numColsB = pSrcB->numCols;            /* Number of columns of input matrix B */
 8012710: 8849         	ldrh	r1, [r1, #0x2]
;         colCnt = numColsA;
 8012712: 8844         	ldrh	r4, [r0, #0x2]
;   float32_t *pIn1 = pSrcA->pData;                /* Input data matrix pointer A */
 8012714: f8d0 e004    	ldr.w	lr, [r0, #0x4]
;   uint32_t col, i = 0U, row = numRowsA, colCnt;  /* Loop counters */
 8012718: 8805         	ldrh	r5, [r0]
;   float32_t *pOut = pDst->pData;                 /* Output data matrix pointer */
 801271a: 6852         	ldr	r2, [r2, #0x4]
;   uint32_t col, i = 0U, row = numRowsA, colCnt;  /* Loop counters */
 801271c: 2901         	cmp	r1, #0x1
;           pIn2 += numColsB;
 801271e: ea4f 0081    	lsl.w	r0, r1, #0x2
;       pInA = pInA + numColsA;
 8012722: ea4f 0784    	lsl.w	r7, r4, #0x2
 8012726: d124         	bne	0x8012772 <arm_mat_mult_f32+0x6a> @ imm = #0x48
 8012728: eb02 0a00    	add.w	r10, r2, r0
 801272c: f103 0804    	add.w	r8, r3, #0x4
;       px = pOut + i;
 8012730: ebaa 0c00    	sub.w	r12, r10, r0
;       pIn2 = pSrcB->pData;
 8012734: 46c1         	mov	r9, r8
;         sum = 0.0f;
 8012736: eddf 7a20    	vldr	s15, [pc, #128]         @ 0x80127b8 <arm_mat_mult_f32+0xb0>
;         while (colCnt > 0U)
 801273a: b154         	cbz	r4, 0x8012752 <arm_mat_mult_f32+0x4a> @ imm = #0x14
;         colCnt = numColsA;
 801273c: 4622         	mov	r2, r4
;         while (colCnt > 0U)
 801273e: 4671         	mov	r1, lr
;           sum += *pIn1++ * *pIn2;
 8012740: edd3 6a00    	vldr	s13, [r3]
 8012744: ecb1 7a01    	vldmia	r1!, {s14}
;         while (colCnt > 0U)
 8012748: 3a01         	subs	r2, #0x1
;           sum += *pIn1++ * *pIn2;
 801274a: eee6 7a87    	vfma.f32	s15, s13, s14
;           pIn2 += numColsB;
 801274e: 4403         	add	r3, r0
;         while (colCnt > 0U)
 8012750: d1f6         	bne	0x8012740 <arm_mat_mult_f32+0x38> @ imm = #-0x14
;         *px++ = sum;
 8012752: ecec 7a01    	vstmia	r12!, {s15}
;       } while (col > 0U);
 8012756: 45d4         	cmp	r12, r10
;         pIn2 = pInB + (numColsB - col);
 8012758: 464b         	mov	r3, r9
;       } while (col > 0U);
 801275a: f109 0904    	add.w	r9, r9, #0x4
 801275e: d1ea         	bne	0x8012736 <arm_mat_mult_f32+0x2e> @ imm = #-0x2c
;     } while (row > 0U);
 8012760: 3d01         	subs	r5, #0x1
;       pInA = pInA + numColsA;
 8012762: 44be         	add	lr, r7
;     } while (row > 0U);
 8012764: 4482         	add	r10, r0
 8012766: d001         	beq	0x801276c <arm_mat_mult_f32+0x64> @ imm = #0x2
;       pIn2 = pSrcB->pData;
 8012768: 6873         	ldr	r3, [r6, #0x4]
 801276a: e7e1         	b	0x8012730 <arm_mat_mult_f32+0x28> @ imm = #-0x3e
; }
 801276c: 2000         	movs	r0, #0x0
 801276e: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}
 8012772: eb02 0c00    	add.w	r12, r2, r0
 8012776: f103 0804    	add.w	r8, r3, #0x4
;       px = pOut + i;
 801277a: ebac 0900    	sub.w	r9, r12, r0
;       pIn2 = pSrcB->pData;
 801277e: 46c2         	mov	r10, r8
;         sum = 0.0f;
 8012780: eddf 7a0d    	vldr	s15, [pc, #52]          @ 0x80127b8 <arm_mat_mult_f32+0xb0>
;         while (colCnt > 0U)
 8012784: b154         	cbz	r4, 0x801279c <arm_mat_mult_f32+0x94> @ imm = #0x14
;         colCnt = numColsA;
 8012786: 4622         	mov	r2, r4
;         while (colCnt > 0U)
 8012788: 4671         	mov	r1, lr
;           sum += *pIn1++ * *pIn2;
 801278a: ed93 7a00    	vldr	s14, [r3]
 801278e: ecf1 6a01    	vldmia	r1!, {s13}
;         while (colCnt > 0U)
 8012792: 3a01         	subs	r2, #0x1
;           sum += *pIn1++ * *pIn2;
 8012794: eee6 7a87    	vfma.f32	s15, s13, s14
;           pIn2 += numColsB;
 8012798: 4403         	add	r3, r0
;         while (colCnt > 0U)
 801279a: d1f6         	bne	0x801278a <arm_mat_mult_f32+0x82> @ imm = #-0x14
;         *px++ = sum;
 801279c: ece9 7a01    	vstmia	r9!, {s15}
;       } while (col > 0U);
 80127a0: 45e1         	cmp	r9, r12
;         pIn2 = pInB + (numColsB - col);
 80127a2: 4653         	mov	r3, r10
;       } while (col > 0U);
 80127a4: f10a 0a04    	add.w	r10, r10, #0x4
 80127a8: d1ea         	bne	0x8012780 <arm_mat_mult_f32+0x78> @ imm = #-0x2c
;     } while (row > 0U);
 80127aa: 3d01         	subs	r5, #0x1
;       pInA = pInA + numColsA;
 80127ac: 44be         	add	lr, r7
;     } while (row > 0U);
 80127ae: 4484         	add	r12, r0
 80127b0: d0dc         	beq	0x801276c <arm_mat_mult_f32+0x64> @ imm = #-0x48
;       pIn2 = pSrcB->pData;
 80127b2: 6873         	ldr	r3, [r6, #0x4]
 80127b4: e7e1         	b	0x801277a <arm_mat_mult_f32+0x72> @ imm = #-0x3e
 80127b6: bf00         	nop

080127b8 <$d>:
 80127b8: 00 00 00 00  	.word	0x00000000

080127bc <arm_mat_sub_f32>:
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 80127bc: 8803         	ldrh	r3, [r0]
 80127be: f8b0 c002    	ldrh.w	r12, [r0, #0x2]
;   float32_t *pInB = pSrcB->pData;                /* input data matrix pointer B */
 80127c2: 6849         	ldr	r1, [r1, #0x4]
;   float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A */
 80127c4: 6840         	ldr	r0, [r0, #0x4]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 80127c6: 6852         	ldr	r2, [r2, #0x4]
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 80127c8: fb0c f303    	mul	r3, r12, r3
;     while (blkCnt > 0U)
 80127cc: b14b         	cbz	r3, 0x80127e2 <arm_mat_sub_f32+0x26> @ imm = #0x12
;       *pOut++ = (*pInA++) - (*pInB++);
 80127ce: ecf0 7a01    	vldmia	r0!, {s15}
 80127d2: ecb1 7a01    	vldmia	r1!, {s14}
 80127d6: ee77 7ac7    	vsub.f32	s15, s15, s14
;     while (blkCnt > 0U)
 80127da: 3b01         	subs	r3, #0x1
;       *pOut++ = (*pInA++) - (*pInB++);
 80127dc: ece2 7a01    	vstmia	r2!, {s15}
;     while (blkCnt > 0U)
 80127e0: d1f5         	bne	0x80127ce <arm_mat_sub_f32+0x12> @ imm = #-0x16
; }
 80127e2: 2000         	movs	r0, #0x0
 80127e4: 4770         	bx	lr
 80127e6: bf00         	nop

080127e8 <arm_mat_trans_f32>:
; {
 80127e8: b5f0         	push	{r4, r5, r6, r7, lr}
;       col = nCols;
 80127ea: 8845         	ldrh	r5, [r0, #0x2]
;   uint16_t nRows = pSrc->numRows;                /* number of rows */
 80127ec: 8802         	ldrh	r2, [r0]
;   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
 80127ee: 6844         	ldr	r4, [r0, #0x4]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 80127f0: 684b         	ldr	r3, [r1, #0x4]
;   uint32_t col, row = nRows, i = 0U;             /* Loop counters */
 80127f2: b1b5         	cbz	r5, 0x8012822 <arm_mat_trans_f32+0x3a> @ imm = #0x2c
 80127f4: ea4f 0c82    	lsl.w	r12, r2, #0x2
 80127f8: 2a01         	cmp	r2, #0x1
 80127fa: 469e         	mov	lr, r3
 80127fc: eb03 070c    	add.w	r7, r3, r12
 8012800: ea4f 0685    	lsl.w	r6, r5, #0x2
 8012804: d114         	bne	0x8012830 <arm_mat_trans_f32+0x48> @ imm = #0x28
;       px = pOut + i;
 8012806: 4672         	mov	r2, lr
;       col = nCols;
 8012808: 462b         	mov	r3, r5
;       px = pOut + i;
 801280a: 4621         	mov	r1, r4
;         *px = *pIn++;
 801280c: f851 0b04    	ldr	r0, [r1], #4
 8012810: 6010         	str	r0, [r2]
;       while (col > 0U)
 8012812: 3b01         	subs	r3, #0x1
;         px += nRows;
 8012814: 4462         	add	r2, r12
;       while (col > 0U)
 8012816: d1f9         	bne	0x801280c <arm_mat_trans_f32+0x24> @ imm = #-0xe
;     } while (row > 0U);          /* row loop end */
 8012818: f10e 0e04    	add.w	lr, lr, #0x4
 801281c: 45be         	cmp	lr, r7
;         *px = *pIn++;
 801281e: 4434         	add	r4, r6
;     } while (row > 0U);          /* row loop end */
 8012820: d1f1         	bne	0x8012806 <arm_mat_trans_f32+0x1e> @ imm = #-0x1e
; }
 8012822: 2000         	movs	r0, #0x0
 8012824: bdf0         	pop	{r4, r5, r6, r7, pc}
;     } while (row > 0U);          /* row loop end */
 8012826: f10e 0e04    	add.w	lr, lr, #0x4
 801282a: 45be         	cmp	lr, r7
;         *px = *pIn++;
 801282c: 4434         	add	r4, r6
;     } while (row > 0U);          /* row loop end */
 801282e: d0f8         	beq	0x8012822 <arm_mat_trans_f32+0x3a> @ imm = #-0x10
;       px = pOut + i;
 8012830: 4672         	mov	r2, lr
;       col = nCols;
 8012832: 462b         	mov	r3, r5
;       px = pOut + i;
 8012834: 4621         	mov	r1, r4
;         *px = *pIn++;
 8012836: f851 0b04    	ldr	r0, [r1], #4
 801283a: 6010         	str	r0, [r2]
;       while (col > 0U)
 801283c: 3b01         	subs	r3, #0x1
;         px += nRows;
 801283e: 4462         	add	r2, r12
;       while (col > 0U)
 8012840: d1f9         	bne	0x8012836 <arm_mat_trans_f32+0x4e> @ imm = #-0xe
 8012842: e7f0         	b	0x8012826 <arm_mat_trans_f32+0x3e> @ imm = #-0x20

08012844 <HAL_RCC_GetSysClockFreq>:
; {
 8012844: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8012848: b090         	sub	sp, #0x40
 801284a: af00         	add	r7, sp, #0x0
;   uint32_t pllm = 0U;
 801284c: 2300         	movs	r3, #0x0
 801284e: 637b         	str	r3, [r7, #0x34]
;   uint32_t pllvco = 0U;
 8012850: 2300         	movs	r3, #0x0
 8012852: 63fb         	str	r3, [r7, #0x3c]
;   uint32_t pllp = 0U;
 8012854: 2300         	movs	r3, #0x0
 8012856: 633b         	str	r3, [r7, #0x30]
;   uint32_t sysclockfreq = 0U;
 8012858: 2300         	movs	r3, #0x0
 801285a: 63bb         	str	r3, [r7, #0x38]
;   switch (RCC->CFGR & RCC_CFGR_SWS)
 801285c: 4b59         	ldr	r3, [pc, #0x164]        @ 0x80129c4 <HAL_RCC_GetSysClockFreq+0x180>
 801285e: 689b         	ldr	r3, [r3, #0x8]
 8012860: f003 030c    	and	r3, r3, #0xc
 8012864: 2b08         	cmp	r3, #0x8
 8012866: d00d         	beq	0x8012884 <HAL_RCC_GetSysClockFreq+0x40> @ imm = #0x1a
 8012868: 2b08         	cmp	r3, #0x8
 801286a: f200 80a1    	bhi.w	0x80129b0 <HAL_RCC_GetSysClockFreq+0x16c> @ imm = #0x142
 801286e: 2b00         	cmp	r3, #0x0
 8012870: d002         	beq	0x8012878 <HAL_RCC_GetSysClockFreq+0x34> @ imm = #0x4
 8012872: 2b04         	cmp	r3, #0x4
 8012874: d003         	beq	0x801287e <HAL_RCC_GetSysClockFreq+0x3a> @ imm = #0x6
 8012876: e09b         	b	0x80129b0 <HAL_RCC_GetSysClockFreq+0x16c> @ imm = #0x136
;       sysclockfreq = HSI_VALUE;
 8012878: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x80129c8 <HAL_RCC_GetSysClockFreq+0x184>
 801287a: 63bb         	str	r3, [r7, #0x38]
;       break;
 801287c: e09b         	b	0x80129b6 <HAL_RCC_GetSysClockFreq+0x172> @ imm = #0x136
;       sysclockfreq = HSE_VALUE;
 801287e: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x80129cc <HAL_RCC_GetSysClockFreq+0x188>
 8012880: 63bb         	str	r3, [r7, #0x38]
;       break;
 8012882: e098         	b	0x80129b6 <HAL_RCC_GetSysClockFreq+0x172> @ imm = #0x130
;       pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8012884: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x80129c4 <HAL_RCC_GetSysClockFreq+0x180>
 8012886: 685b         	ldr	r3, [r3, #0x4]
 8012888: f003 033f    	and	r3, r3, #0x3f
 801288c: 637b         	str	r3, [r7, #0x34]
;       if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 801288e: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x80129c4 <HAL_RCC_GetSysClockFreq+0x180>
 8012890: 685b         	ldr	r3, [r3, #0x4]
 8012892: f403 0380    	and	r3, r3, #0x400000
 8012896: 2b00         	cmp	r3, #0x0
 8012898: d028         	beq	0x80128ec <HAL_RCC_GetSysClockFreq+0xa8> @ imm = #0x50
;         pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 801289a: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x80129c4 <HAL_RCC_GetSysClockFreq+0x180>
 801289c: 685b         	ldr	r3, [r3, #0x4]
 801289e: 099b         	lsrs	r3, r3, #0x6
 80128a0: 2200         	movs	r2, #0x0
 80128a2: 623b         	str	r3, [r7, #0x20]
 80128a4: 627a         	str	r2, [r7, #0x24]
 80128a6: 6a3b         	ldr	r3, [r7, #0x20]
 80128a8: f3c3 0008    	ubfx	r0, r3, #0x0, #0x9
 80128ac: 2100         	movs	r1, #0x0
 80128ae: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x80129cc <HAL_RCC_GetSysClockFreq+0x188>
 80128b0: fb03 f201    	mul	r2, r3, r1
 80128b4: 2300         	movs	r3, #0x0
 80128b6: fb00 f303    	mul	r3, r0, r3
 80128ba: 4413         	add	r3, r2
 80128bc: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x80129cc <HAL_RCC_GetSysClockFreq+0x188>
 80128be: fba0 1202    	umull	r1, r2, r0, r2
 80128c2: 62fa         	str	r2, [r7, #0x2c]
 80128c4: 460a         	mov	r2, r1
 80128c6: 62ba         	str	r2, [r7, #0x28]
 80128c8: 6afa         	ldr	r2, [r7, #0x2c]
 80128ca: 4413         	add	r3, r2
 80128cc: 62fb         	str	r3, [r7, #0x2c]
 80128ce: 6b7b         	ldr	r3, [r7, #0x34]
 80128d0: 2200         	movs	r2, #0x0
 80128d2: 61bb         	str	r3, [r7, #0x18]
 80128d4: 61fa         	str	r2, [r7, #0x1c]
 80128d6: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 80128da: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 80128de: f7ed feaf    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x122a2
 80128e2: 4602         	mov	r2, r0
 80128e4: 460b         	mov	r3, r1
 80128e6: 4613         	mov	r3, r2
 80128e8: 63fb         	str	r3, [r7, #0x3c]
 80128ea: e053         	b	0x8012994 <HAL_RCC_GetSysClockFreq+0x150> @ imm = #0xa6
;         pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80128ec: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80129c4 <HAL_RCC_GetSysClockFreq+0x180>
 80128ee: 685b         	ldr	r3, [r3, #0x4]
 80128f0: 099b         	lsrs	r3, r3, #0x6
 80128f2: 2200         	movs	r2, #0x0
 80128f4: 613b         	str	r3, [r7, #0x10]
 80128f6: 617a         	str	r2, [r7, #0x14]
 80128f8: 693b         	ldr	r3, [r7, #0x10]
 80128fa: f3c3 0a08    	ubfx	r10, r3, #0x0, #0x9
 80128fe: f04f 0b00    	mov.w	r11, #0x0
 8012902: 4652         	mov	r2, r10
 8012904: 465b         	mov	r3, r11
 8012906: f04f 0000    	mov.w	r0, #0x0
 801290a: f04f 0100    	mov.w	r1, #0x0
 801290e: 0159         	lsls	r1, r3, #0x5
 8012910: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 8012914: 0150         	lsls	r0, r2, #0x5
 8012916: 4602         	mov	r2, r0
 8012918: 460b         	mov	r3, r1
 801291a: ebb2 080a    	subs.w	r8, r2, r10
 801291e: eb63 090b    	sbc.w	r9, r3, r11
 8012922: f04f 0200    	mov.w	r2, #0x0
 8012926: f04f 0300    	mov.w	r3, #0x0
 801292a: ea4f 1389    	lsl.w	r3, r9, #0x6
 801292e: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 8012932: ea4f 1288    	lsl.w	r2, r8, #0x6
 8012936: ebb2 0408    	subs.w	r4, r2, r8
 801293a: eb63 0509    	sbc.w	r5, r3, r9
 801293e: f04f 0200    	mov.w	r2, #0x0
 8012942: f04f 0300    	mov.w	r3, #0x0
 8012946: 00eb         	lsls	r3, r5, #0x3
 8012948: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 801294c: 00e2         	lsls	r2, r4, #0x3
 801294e: 4614         	mov	r4, r2
 8012950: 461d         	mov	r5, r3
 8012952: eb14 030a    	adds.w	r3, r4, r10
 8012956: 603b         	str	r3, [r7]
 8012958: eb45 030b    	adc.w	r3, r5, r11
 801295c: 607b         	str	r3, [r7, #0x4]
 801295e: f04f 0200    	mov.w	r2, #0x0
 8012962: f04f 0300    	mov.w	r3, #0x0
 8012966: e9d7 4500    	ldrd	r4, r5, [r7]
 801296a: 4629         	mov	r1, r5
 801296c: 028b         	lsls	r3, r1, #0xa
 801296e: 4621         	mov	r1, r4
 8012970: ea43 5391    	orr.w	r3, r3, r1, lsr #22
 8012974: 4621         	mov	r1, r4
 8012976: 028a         	lsls	r2, r1, #0xa
 8012978: 4610         	mov	r0, r2
 801297a: 4619         	mov	r1, r3
 801297c: 6b7b         	ldr	r3, [r7, #0x34]
 801297e: 2200         	movs	r2, #0x0
 8012980: 60bb         	str	r3, [r7, #0x8]
 8012982: 60fa         	str	r2, [r7, #0xc]
 8012984: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 8012988: f7ed fe5a    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x1234c
 801298c: 4602         	mov	r2, r0
 801298e: 460b         	mov	r3, r1
 8012990: 4613         	mov	r3, r2
 8012992: 63fb         	str	r3, [r7, #0x3c]
;       pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) * 2U);
 8012994: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80129c4 <HAL_RCC_GetSysClockFreq+0x180>
 8012996: 685b         	ldr	r3, [r3, #0x4]
 8012998: 0c1b         	lsrs	r3, r3, #0x10
 801299a: f003 0303    	and	r3, r3, #0x3
 801299e: 3301         	adds	r3, #0x1
 80129a0: 005b         	lsls	r3, r3, #0x1
 80129a2: 633b         	str	r3, [r7, #0x30]
;       sysclockfreq = pllvco / pllp;
 80129a4: 6bfa         	ldr	r2, [r7, #0x3c]
 80129a6: 6b3b         	ldr	r3, [r7, #0x30]
 80129a8: fbb2 f3f3    	udiv	r3, r2, r3
 80129ac: 63bb         	str	r3, [r7, #0x38]
;       break;
 80129ae: e002         	b	0x80129b6 <HAL_RCC_GetSysClockFreq+0x172> @ imm = #0x4
;       sysclockfreq = HSI_VALUE;
 80129b0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80129c8 <HAL_RCC_GetSysClockFreq+0x184>
 80129b2: 63bb         	str	r3, [r7, #0x38]
;       break;
 80129b4: bf00         	nop
;   return sysclockfreq;
 80129b6: 6bbb         	ldr	r3, [r7, #0x38]
; }
 80129b8: 4618         	mov	r0, r3
 80129ba: 3740         	adds	r7, #0x40
 80129bc: 46bd         	mov	sp, r7
 80129be: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 80129c2: bf00         	nop

080129c4 <$d>:
 80129c4: 00 38 02 40  	.word	0x40023800
 80129c8: 00 24 f4 00  	.word	0x00f42400
 80129cc: 00 1b b7 00  	.word	0x00b71b00

080129d0 <LL_DMA_ConfigTransfer>:
; {
 80129d0: b480         	push	{r7}
 80129d2: b085         	sub	sp, #0x14
 80129d4: af00         	add	r7, sp, #0x0
 80129d6: 60f8         	str	r0, [r7, #0xc]
 80129d8: 60b9         	str	r1, [r7, #0x8]
 80129da: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR,
 80129dc: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8012a18 <LL_DMA_ConfigTransfer+0x48>
 80129de: 68bb         	ldr	r3, [r7, #0x8]
 80129e0: 4413         	add	r3, r2
 80129e2: 781b         	ldrb	r3, [r3]
 80129e4: 461a         	mov	r2, r3
 80129e6: 68fb         	ldr	r3, [r7, #0xc]
 80129e8: 4413         	add	r3, r2
 80129ea: 681b         	ldr	r3, [r3]
 80129ec: f423 335f    	bic	r3, r3, #0x37c00
 80129f0: f423 7378    	bic	r3, r3, #0x3e0
 80129f4: 4908         	ldr	r1, [pc, #0x20]         @ 0x8012a18 <LL_DMA_ConfigTransfer+0x48>
 80129f6: 68ba         	ldr	r2, [r7, #0x8]
 80129f8: 440a         	add	r2, r1
 80129fa: 7812         	ldrb	r2, [r2]
 80129fc: 4611         	mov	r1, r2
 80129fe: 68fa         	ldr	r2, [r7, #0xc]
 8012a00: 440a         	add	r2, r1
 8012a02: 4611         	mov	r1, r2
 8012a04: 687a         	ldr	r2, [r7, #0x4]
 8012a06: 4313         	orrs	r3, r2
 8012a08: 600b         	str	r3, [r1]
; }
 8012a0a: bf00         	nop
 8012a0c: 3714         	adds	r7, #0x14
 8012a0e: 46bd         	mov	sp, r7
 8012a10: f85d 7b04    	ldr	r7, [sp], #4
 8012a14: 4770         	bx	lr
 8012a16: bf00         	nop

08012a18 <$d>:
 8012a18: 30 bc 02 08  	.word	0x0802bc30

08012a1c <LL_DMA_SetDataLength>:
; {
 8012a1c: b480         	push	{r7}
 8012a1e: b085         	sub	sp, #0x14
 8012a20: af00         	add	r7, sp, #0x0
 8012a22: 60f8         	str	r0, [r7, #0xc]
 8012a24: 60b9         	str	r1, [r7, #0x8]
 8012a26: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT, NbData);
 8012a28: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8012a60 <LL_DMA_SetDataLength+0x44>
 8012a2a: 68bb         	ldr	r3, [r7, #0x8]
 8012a2c: 4413         	add	r3, r2
 8012a2e: 781b         	ldrb	r3, [r3]
 8012a30: 461a         	mov	r2, r3
 8012a32: 68fb         	ldr	r3, [r7, #0xc]
 8012a34: 4413         	add	r3, r2
 8012a36: 685b         	ldr	r3, [r3, #0x4]
 8012a38: 0c1b         	lsrs	r3, r3, #0x10
 8012a3a: 041b         	lsls	r3, r3, #0x10
 8012a3c: 4908         	ldr	r1, [pc, #0x20]         @ 0x8012a60 <LL_DMA_SetDataLength+0x44>
 8012a3e: 68ba         	ldr	r2, [r7, #0x8]
 8012a40: 440a         	add	r2, r1
 8012a42: 7812         	ldrb	r2, [r2]
 8012a44: 4611         	mov	r1, r2
 8012a46: 68fa         	ldr	r2, [r7, #0xc]
 8012a48: 440a         	add	r2, r1
 8012a4a: 4611         	mov	r1, r2
 8012a4c: 687a         	ldr	r2, [r7, #0x4]
 8012a4e: 4313         	orrs	r3, r2
 8012a50: 604b         	str	r3, [r1, #0x4]
; }
 8012a52: bf00         	nop
 8012a54: 3714         	adds	r7, #0x14
 8012a56: 46bd         	mov	sp, r7
 8012a58: f85d 7b04    	ldr	r7, [sp], #4
 8012a5c: 4770         	bx	lr
 8012a5e: bf00         	nop

08012a60 <$d>:
 8012a60: 30 bc 02 08  	.word	0x0802bc30

08012a64 <LL_DMA_SetChannelSelection>:
; {
 8012a64: b480         	push	{r7}
 8012a66: b085         	sub	sp, #0x14
 8012a68: af00         	add	r7, sp, #0x0
 8012a6a: 60f8         	str	r0, [r7, #0xc]
 8012a6c: 60b9         	str	r1, [r7, #0x8]
 8012a6e: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_CHSEL, Channel);
 8012a70: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8012aa8 <LL_DMA_SetChannelSelection+0x44>
 8012a72: 68bb         	ldr	r3, [r7, #0x8]
 8012a74: 4413         	add	r3, r2
 8012a76: 781b         	ldrb	r3, [r3]
 8012a78: 461a         	mov	r2, r3
 8012a7a: 68fb         	ldr	r3, [r7, #0xc]
 8012a7c: 4413         	add	r3, r2
 8012a7e: 681b         	ldr	r3, [r3]
 8012a80: f023 6260    	bic	r2, r3, #0xe000000
 8012a84: 4908         	ldr	r1, [pc, #0x20]         @ 0x8012aa8 <LL_DMA_SetChannelSelection+0x44>
 8012a86: 68bb         	ldr	r3, [r7, #0x8]
 8012a88: 440b         	add	r3, r1
 8012a8a: 781b         	ldrb	r3, [r3]
 8012a8c: 4619         	mov	r1, r3
 8012a8e: 68fb         	ldr	r3, [r7, #0xc]
 8012a90: 440b         	add	r3, r1
 8012a92: 4619         	mov	r1, r3
 8012a94: 687b         	ldr	r3, [r7, #0x4]
 8012a96: 4313         	orrs	r3, r2
 8012a98: 600b         	str	r3, [r1]
; }
 8012a9a: bf00         	nop
 8012a9c: 3714         	adds	r7, #0x14
 8012a9e: 46bd         	mov	sp, r7
 8012aa0: f85d 7b04    	ldr	r7, [sp], #4
 8012aa4: 4770         	bx	lr
 8012aa6: bf00         	nop

08012aa8 <$d>:
 8012aa8: 30 bc 02 08  	.word	0x0802bc30

08012aac <LL_DMA_SetMemoryBurstxfer>:
; {
 8012aac: b480         	push	{r7}
 8012aae: b085         	sub	sp, #0x14
 8012ab0: af00         	add	r7, sp, #0x0
 8012ab2: 60f8         	str	r0, [r7, #0xc]
 8012ab4: 60b9         	str	r1, [r7, #0x8]
 8012ab6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_MBURST, Mburst);
 8012ab8: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8012af0 <LL_DMA_SetMemoryBurstxfer+0x44>
 8012aba: 68bb         	ldr	r3, [r7, #0x8]
 8012abc: 4413         	add	r3, r2
 8012abe: 781b         	ldrb	r3, [r3]
 8012ac0: 461a         	mov	r2, r3
 8012ac2: 68fb         	ldr	r3, [r7, #0xc]
 8012ac4: 4413         	add	r3, r2
 8012ac6: 681b         	ldr	r3, [r3]
 8012ac8: f023 72c0    	bic	r2, r3, #0x1800000
 8012acc: 4908         	ldr	r1, [pc, #0x20]         @ 0x8012af0 <LL_DMA_SetMemoryBurstxfer+0x44>
 8012ace: 68bb         	ldr	r3, [r7, #0x8]
 8012ad0: 440b         	add	r3, r1
 8012ad2: 781b         	ldrb	r3, [r3]
 8012ad4: 4619         	mov	r1, r3
 8012ad6: 68fb         	ldr	r3, [r7, #0xc]
 8012ad8: 440b         	add	r3, r1
 8012ada: 4619         	mov	r1, r3
 8012adc: 687b         	ldr	r3, [r7, #0x4]
 8012ade: 4313         	orrs	r3, r2
 8012ae0: 600b         	str	r3, [r1]
; }
 8012ae2: bf00         	nop
 8012ae4: 3714         	adds	r7, #0x14
 8012ae6: 46bd         	mov	sp, r7
 8012ae8: f85d 7b04    	ldr	r7, [sp], #4
 8012aec: 4770         	bx	lr
 8012aee: bf00         	nop

08012af0 <$d>:
 8012af0: 30 bc 02 08  	.word	0x0802bc30

08012af4 <LL_DMA_SetPeriphBurstxfer>:
; {
 8012af4: b480         	push	{r7}
 8012af6: b085         	sub	sp, #0x14
 8012af8: af00         	add	r7, sp, #0x0
 8012afa: 60f8         	str	r0, [r7, #0xc]
 8012afc: 60b9         	str	r1, [r7, #0x8]
 8012afe: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_PBURST, Pburst);
 8012b00: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8012b38 <LL_DMA_SetPeriphBurstxfer+0x44>
 8012b02: 68bb         	ldr	r3, [r7, #0x8]
 8012b04: 4413         	add	r3, r2
 8012b06: 781b         	ldrb	r3, [r3]
 8012b08: 461a         	mov	r2, r3
 8012b0a: 68fb         	ldr	r3, [r7, #0xc]
 8012b0c: 4413         	add	r3, r2
 8012b0e: 681b         	ldr	r3, [r3]
 8012b10: f423 02c0    	bic	r2, r3, #0x600000
 8012b14: 4908         	ldr	r1, [pc, #0x20]         @ 0x8012b38 <LL_DMA_SetPeriphBurstxfer+0x44>
 8012b16: 68bb         	ldr	r3, [r7, #0x8]
 8012b18: 440b         	add	r3, r1
 8012b1a: 781b         	ldrb	r3, [r3]
 8012b1c: 4619         	mov	r1, r3
 8012b1e: 68fb         	ldr	r3, [r7, #0xc]
 8012b20: 440b         	add	r3, r1
 8012b22: 4619         	mov	r1, r3
 8012b24: 687b         	ldr	r3, [r7, #0x4]
 8012b26: 4313         	orrs	r3, r2
 8012b28: 600b         	str	r3, [r1]
; }
 8012b2a: bf00         	nop
 8012b2c: 3714         	adds	r7, #0x14
 8012b2e: 46bd         	mov	sp, r7
 8012b30: f85d 7b04    	ldr	r7, [sp], #4
 8012b34: 4770         	bx	lr
 8012b36: bf00         	nop

08012b38 <$d>:
 8012b38: 30 bc 02 08  	.word	0x0802bc30

08012b3c <LL_DMA_ConfigFifo>:
; {
 8012b3c: b480         	push	{r7}
 8012b3e: b085         	sub	sp, #0x14
 8012b40: af00         	add	r7, sp, #0x0
 8012b42: 60f8         	str	r0, [r7, #0xc]
 8012b44: 60b9         	str	r1, [r7, #0x8]
 8012b46: 607a         	str	r2, [r7, #0x4]
 8012b48: 603b         	str	r3, [r7]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FTH|DMA_SxFCR_DMDIS, FifoMode|FifoThreshold);
 8012b4a: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8012b84 <LL_DMA_ConfigFifo+0x48>
 8012b4c: 68bb         	ldr	r3, [r7, #0x8]
 8012b4e: 4413         	add	r3, r2
 8012b50: 781b         	ldrb	r3, [r3]
 8012b52: 461a         	mov	r2, r3
 8012b54: 68fb         	ldr	r3, [r7, #0xc]
 8012b56: 4413         	add	r3, r2
 8012b58: 695b         	ldr	r3, [r3, #0x14]
 8012b5a: f023 0207    	bic	r2, r3, #0x7
 8012b5e: 6879         	ldr	r1, [r7, #0x4]
 8012b60: 683b         	ldr	r3, [r7]
 8012b62: 430b         	orrs	r3, r1
 8012b64: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8012b84 <LL_DMA_ConfigFifo+0x48>
 8012b66: 68b9         	ldr	r1, [r7, #0x8]
 8012b68: 4401         	add	r1, r0
 8012b6a: 7809         	ldrb	r1, [r1]
 8012b6c: 4608         	mov	r0, r1
 8012b6e: 68f9         	ldr	r1, [r7, #0xc]
 8012b70: 4401         	add	r1, r0
 8012b72: 4313         	orrs	r3, r2
 8012b74: 614b         	str	r3, [r1, #0x14]
; }
 8012b76: bf00         	nop
 8012b78: 3714         	adds	r7, #0x14
 8012b7a: 46bd         	mov	sp, r7
 8012b7c: f85d 7b04    	ldr	r7, [sp], #4
 8012b80: 4770         	bx	lr
 8012b82: bf00         	nop

08012b84 <$d>:
 8012b84: 30 bc 02 08  	.word	0x0802bc30

08012b88 <LL_DMA_SetMemoryAddress>:
; {
 8012b88: b480         	push	{r7}
 8012b8a: b085         	sub	sp, #0x14
 8012b8c: af00         	add	r7, sp, #0x0
 8012b8e: 60f8         	str	r0, [r7, #0xc]
 8012b90: 60b9         	str	r1, [r7, #0x8]
 8012b92: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->M0AR, MemoryAddress);
 8012b94: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8012bb4 <LL_DMA_SetMemoryAddress+0x2c>
 8012b96: 68bb         	ldr	r3, [r7, #0x8]
 8012b98: 4413         	add	r3, r2
 8012b9a: 781b         	ldrb	r3, [r3]
 8012b9c: 461a         	mov	r2, r3
 8012b9e: 68fb         	ldr	r3, [r7, #0xc]
 8012ba0: 4413         	add	r3, r2
 8012ba2: 461a         	mov	r2, r3
 8012ba4: 687b         	ldr	r3, [r7, #0x4]
 8012ba6: 60d3         	str	r3, [r2, #0xc]
; }
 8012ba8: bf00         	nop
 8012baa: 3714         	adds	r7, #0x14
 8012bac: 46bd         	mov	sp, r7
 8012bae: f85d 7b04    	ldr	r7, [sp], #4
 8012bb2: 4770         	bx	lr

08012bb4 <$d>:
 8012bb4: 30 bc 02 08  	.word	0x0802bc30

08012bb8 <LL_DMA_SetPeriphAddress>:
; {
 8012bb8: b480         	push	{r7}
 8012bba: b085         	sub	sp, #0x14
 8012bbc: af00         	add	r7, sp, #0x0
 8012bbe: 60f8         	str	r0, [r7, #0xc]
 8012bc0: 60b9         	str	r1, [r7, #0x8]
 8012bc2: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->PAR, PeriphAddress);
 8012bc4: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8012be4 <LL_DMA_SetPeriphAddress+0x2c>
 8012bc6: 68bb         	ldr	r3, [r7, #0x8]
 8012bc8: 4413         	add	r3, r2
 8012bca: 781b         	ldrb	r3, [r3]
 8012bcc: 461a         	mov	r2, r3
 8012bce: 68fb         	ldr	r3, [r7, #0xc]
 8012bd0: 4413         	add	r3, r2
 8012bd2: 461a         	mov	r2, r3
 8012bd4: 687b         	ldr	r3, [r7, #0x4]
 8012bd6: 6093         	str	r3, [r2, #0x8]
; }
 8012bd8: bf00         	nop
 8012bda: 3714         	adds	r7, #0x14
 8012bdc: 46bd         	mov	sp, r7
 8012bde: f85d 7b04    	ldr	r7, [sp], #4
 8012be2: 4770         	bx	lr

08012be4 <$d>:
 8012be4: 30 bc 02 08  	.word	0x0802bc30

08012be8 <LL_FLASH_SetLatency>:
; {
 8012be8: b480         	push	{r7}
 8012bea: b083         	sub	sp, #0xc
 8012bec: af00         	add	r7, sp, #0x0
 8012bee: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 8012bf0: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8012c0c <LL_FLASH_SetLatency+0x24>
 8012bf2: 681b         	ldr	r3, [r3]
 8012bf4: f023 0207    	bic	r2, r3, #0x7
 8012bf8: 4904         	ldr	r1, [pc, #0x10]         @ 0x8012c0c <LL_FLASH_SetLatency+0x24>
 8012bfa: 687b         	ldr	r3, [r7, #0x4]
 8012bfc: 4313         	orrs	r3, r2
 8012bfe: 600b         	str	r3, [r1]
; }
 8012c00: bf00         	nop
 8012c02: 370c         	adds	r7, #0xc
 8012c04: 46bd         	mov	sp, r7
 8012c06: f85d 7b04    	ldr	r7, [sp], #4
 8012c0a: 4770         	bx	lr

08012c0c <$d>:
 8012c0c: 00 3c 02 40  	.word	0x40023c00

08012c10 <LL_FLASH_GetLatency>:
; {
 8012c10: b480         	push	{r7}
 8012c12: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
 8012c14: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8012c28 <LL_FLASH_GetLatency+0x18>
 8012c16: 681b         	ldr	r3, [r3]
 8012c18: f003 0307    	and	r3, r3, #0x7
; }
 8012c1c: 4618         	mov	r0, r3
 8012c1e: 46bd         	mov	sp, r7
 8012c20: f85d 7b04    	ldr	r7, [sp], #4
 8012c24: 4770         	bx	lr
 8012c26: bf00         	nop

08012c28 <$d>:
 8012c28: 00 3c 02 40  	.word	0x40023c00

08012c2c <LL_PWR_GetRegulVoltageScaling>:
; {
 8012c2c: b480         	push	{r7}
 8012c2e: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(PWR->CR, PWR_CR_VOS));
 8012c30: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8012c44 <LL_PWR_GetRegulVoltageScaling+0x18>
 8012c32: 681b         	ldr	r3, [r3]
 8012c34: f403 4380    	and	r3, r3, #0x4000
; }
 8012c38: 4618         	mov	r0, r3
 8012c3a: 46bd         	mov	sp, r7
 8012c3c: f85d 7b04    	ldr	r7, [sp], #4
 8012c40: 4770         	bx	lr
 8012c42: bf00         	nop

08012c44 <$d>:
 8012c44: 00 70 00 40  	.word	0x40007000

08012c48 <LL_SetFlashLatency>:
; {
 8012c48: b580         	push	{r7, lr}
 8012c4a: b086         	sub	sp, #0x18
 8012c4c: af00         	add	r7, sp, #0x0
 8012c4e: 6078         	str	r0, [r7, #0x4]
;   uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */
 8012c50: 2300         	movs	r3, #0x0
 8012c52: 613b         	str	r3, [r7, #0x10]
;   ErrorStatus status = SUCCESS;
 8012c54: 2300         	movs	r3, #0x0
 8012c56: 73fb         	strb	r3, [r7, #0xf]
;   if(HCLK_Frequency == 0U)
 8012c58: 687b         	ldr	r3, [r7, #0x4]
 8012c5a: 2b00         	cmp	r3, #0x0
 8012c5c: d102         	bne	0x8012c64 <LL_SetFlashLatency+0x1c> @ imm = #0x4
;     status = ERROR;
 8012c5e: 2301         	movs	r3, #0x1
 8012c60: 73fb         	strb	r3, [r7, #0xf]
 8012c62: e078         	b	0x8012d56 <LL_SetFlashLatency+0x10e> @ imm = #0xf0
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)
 8012c64: f7ff ffe2    	bl	0x8012c2c <LL_PWR_GetRegulVoltageScaling> @ imm = #-0x3c
 8012c68: 4603         	mov	r3, r0
 8012c6a: f5b3 4f80    	cmp.w	r3, #0x4000
 8012c6e: d12d         	bne	0x8012ccc <LL_SetFlashLatency+0x84> @ imm = #0x5a
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY5_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8012c70: 687b         	ldr	r3, [r7, #0x4]
 8012c72: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x8012d60 <LL_SetFlashLatency+0x118>
 8012c74: 4293         	cmp	r3, r2
 8012c76: d904         	bls	0x8012c82 <LL_SetFlashLatency+0x3a> @ imm = #0x8
 8012c78: 693b         	ldr	r3, [r7, #0x10]
 8012c7a: 2b00         	cmp	r3, #0x0
 8012c7c: d101         	bne	0x8012c82 <LL_SetFlashLatency+0x3a> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_5;
 8012c7e: 2305         	movs	r3, #0x5
 8012c80: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8012c82: 687b         	ldr	r3, [r7, #0x4]
 8012c84: 4a37         	ldr	r2, [pc, #0xdc]         @ 0x8012d64 <LL_SetFlashLatency+0x11c>
 8012c86: 4293         	cmp	r3, r2
 8012c88: d904         	bls	0x8012c94 <LL_SetFlashLatency+0x4c> @ imm = #0x8
 8012c8a: 693b         	ldr	r3, [r7, #0x10]
 8012c8c: 2b00         	cmp	r3, #0x0
 8012c8e: d101         	bne	0x8012c94 <LL_SetFlashLatency+0x4c> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 8012c90: 2304         	movs	r3, #0x4
 8012c92: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8012c94: 687b         	ldr	r3, [r7, #0x4]
 8012c96: 4a34         	ldr	r2, [pc, #0xd0]         @ 0x8012d68 <LL_SetFlashLatency+0x120>
 8012c98: 4293         	cmp	r3, r2
 8012c9a: d904         	bls	0x8012ca6 <LL_SetFlashLatency+0x5e> @ imm = #0x8
 8012c9c: 693b         	ldr	r3, [r7, #0x10]
 8012c9e: 2b00         	cmp	r3, #0x0
 8012ca0: d101         	bne	0x8012ca6 <LL_SetFlashLatency+0x5e> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 8012ca2: 2303         	movs	r3, #0x3
 8012ca4: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8012ca6: 687b         	ldr	r3, [r7, #0x4]
 8012ca8: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x8012d6c <LL_SetFlashLatency+0x124>
 8012caa: 4293         	cmp	r3, r2
 8012cac: d905         	bls	0x8012cba <LL_SetFlashLatency+0x72> @ imm = #0xa
 8012cae: 693b         	ldr	r3, [r7, #0x10]
 8012cb0: 2b00         	cmp	r3, #0x0
 8012cb2: d102         	bne	0x8012cba <LL_SetFlashLatency+0x72> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 8012cb4: 2302         	movs	r3, #0x2
 8012cb6: 613b         	str	r3, [r7, #0x10]
 8012cb8: e008         	b	0x8012ccc <LL_SetFlashLatency+0x84> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8012cba: 687b         	ldr	r3, [r7, #0x4]
 8012cbc: 4a2c         	ldr	r2, [pc, #0xb0]         @ 0x8012d70 <LL_SetFlashLatency+0x128>
 8012cbe: 4293         	cmp	r3, r2
 8012cc0: d904         	bls	0x8012ccc <LL_SetFlashLatency+0x84> @ imm = #0x8
 8012cc2: 693b         	ldr	r3, [r7, #0x10]
 8012cc4: 2b00         	cmp	r3, #0x0
 8012cc6: d101         	bne	0x8012ccc <LL_SetFlashLatency+0x84> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 8012cc8: 2301         	movs	r3, #0x1
 8012cca: 613b         	str	r3, [r7, #0x10]
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)
 8012ccc: f7ff ffae    	bl	0x8012c2c <LL_PWR_GetRegulVoltageScaling> @ imm = #-0xa4
 8012cd0: 4603         	mov	r3, r0
 8012cd2: 2b00         	cmp	r3, #0x0
 8012cd4: d124         	bne	0x8012d20 <LL_SetFlashLatency+0xd8> @ imm = #0x48
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8012cd6: 687b         	ldr	r3, [r7, #0x4]
 8012cd8: 4a22         	ldr	r2, [pc, #0x88]         @ 0x8012d64 <LL_SetFlashLatency+0x11c>
 8012cda: 4293         	cmp	r3, r2
 8012cdc: d904         	bls	0x8012ce8 <LL_SetFlashLatency+0xa0> @ imm = #0x8
 8012cde: 693b         	ldr	r3, [r7, #0x10]
 8012ce0: 2b00         	cmp	r3, #0x0
 8012ce2: d101         	bne	0x8012ce8 <LL_SetFlashLatency+0xa0> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 8012ce4: 2304         	movs	r3, #0x4
 8012ce6: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8012ce8: 687b         	ldr	r3, [r7, #0x4]
 8012cea: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x8012d68 <LL_SetFlashLatency+0x120>
 8012cec: 4293         	cmp	r3, r2
 8012cee: d904         	bls	0x8012cfa <LL_SetFlashLatency+0xb2> @ imm = #0x8
 8012cf0: 693b         	ldr	r3, [r7, #0x10]
 8012cf2: 2b00         	cmp	r3, #0x0
 8012cf4: d101         	bne	0x8012cfa <LL_SetFlashLatency+0xb2> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 8012cf6: 2303         	movs	r3, #0x3
 8012cf8: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8012cfa: 687b         	ldr	r3, [r7, #0x4]
 8012cfc: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8012d6c <LL_SetFlashLatency+0x124>
 8012cfe: 4293         	cmp	r3, r2
 8012d00: d905         	bls	0x8012d0e <LL_SetFlashLatency+0xc6> @ imm = #0xa
 8012d02: 693b         	ldr	r3, [r7, #0x10]
 8012d04: 2b00         	cmp	r3, #0x0
 8012d06: d102         	bne	0x8012d0e <LL_SetFlashLatency+0xc6> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 8012d08: 2302         	movs	r3, #0x2
 8012d0a: 613b         	str	r3, [r7, #0x10]
 8012d0c: e008         	b	0x8012d20 <LL_SetFlashLatency+0xd8> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8012d0e: 687b         	ldr	r3, [r7, #0x4]
 8012d10: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8012d70 <LL_SetFlashLatency+0x128>
 8012d12: 4293         	cmp	r3, r2
 8012d14: d904         	bls	0x8012d20 <LL_SetFlashLatency+0xd8> @ imm = #0x8
 8012d16: 693b         	ldr	r3, [r7, #0x10]
 8012d18: 2b00         	cmp	r3, #0x0
 8012d1a: d101         	bne	0x8012d20 <LL_SetFlashLatency+0xd8> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 8012d1c: 2301         	movs	r3, #0x1
 8012d1e: 613b         	str	r3, [r7, #0x10]
;     LL_FLASH_SetLatency(latency);
 8012d20: 6938         	ldr	r0, [r7, #0x10]
 8012d22: f7ff ff61    	bl	0x8012be8 <LL_FLASH_SetLatency> @ imm = #-0x13e
;     timeout = 2;
 8012d26: 2302         	movs	r3, #0x2
 8012d28: 617b         	str	r3, [r7, #0x14]
;     getlatency = LL_FLASH_GetLatency();
 8012d2a: f7ff ff71    	bl	0x8012c10 <LL_FLASH_GetLatency> @ imm = #-0x11e
 8012d2e: 60b8         	str	r0, [r7, #0x8]
;     timeout--;
 8012d30: 697b         	ldr	r3, [r7, #0x14]
 8012d32: 3b01         	subs	r3, #0x1
 8012d34: 617b         	str	r3, [r7, #0x14]
;     } while ((getlatency != latency) && (timeout > 0));
 8012d36: 68ba         	ldr	r2, [r7, #0x8]
 8012d38: 693b         	ldr	r3, [r7, #0x10]
 8012d3a: 429a         	cmp	r2, r3
 8012d3c: d002         	beq	0x8012d44 <LL_SetFlashLatency+0xfc> @ imm = #0x4
 8012d3e: 697b         	ldr	r3, [r7, #0x14]
 8012d40: 2b00         	cmp	r3, #0x0
 8012d42: d1f2         	bne	0x8012d2a <LL_SetFlashLatency+0xe2> @ imm = #-0x1c
;     if(getlatency != latency)
 8012d44: 68ba         	ldr	r2, [r7, #0x8]
 8012d46: 693b         	ldr	r3, [r7, #0x10]
 8012d48: 429a         	cmp	r2, r3
 8012d4a: d002         	beq	0x8012d52 <LL_SetFlashLatency+0x10a> @ imm = #0x4
;       status = ERROR;
 8012d4c: 2301         	movs	r3, #0x1
 8012d4e: 73fb         	strb	r3, [r7, #0xf]
 8012d50: e001         	b	0x8012d56 <LL_SetFlashLatency+0x10e> @ imm = #0x2
;       status = SUCCESS;
 8012d52: 2300         	movs	r3, #0x0
 8012d54: 73fb         	strb	r3, [r7, #0xf]
;   return status;
 8012d56: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8012d58: 4618         	mov	r0, r3
 8012d5a: 3718         	adds	r7, #0x18
 8012d5c: 46bd         	mov	sp, r7
 8012d5e: bd80         	pop	{r7, pc}

08012d60 <$d>:
 8012d60: 80 d1 f0 08  	.word	0x08f0d180
 8012d64: 00 0e 27 07  	.word	0x07270e00
 8012d68: 80 4a 5d 05  	.word	0x055d4a80
 8012d6c: 00 87 93 03  	.word	0x03938700
 8012d70: 80 c3 c9 01  	.word	0x01c9c380

08012d74 <z_device_state_init>:
; {
 8012d74: b580         	push	{r7, lr}
 8012d76: b082         	sub	sp, #0x8
 8012d78: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(device, dev) {
 8012d7a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8012da8 <z_device_state_init+0x34>
 8012d7c: 607b         	str	r3, [r7, #0x4]
 8012d7e: e005         	b	0x8012d8c <z_device_state_init+0x18> @ imm = #0xa
; 		k_object_init(dev);
 8012d80: 6878         	ldr	r0, [r7, #0x4]
 8012d82: f011 fbc4    	bl	0x802450e <k_object_init> @ imm = #0x11788
; 	STRUCT_SECTION_FOREACH(device, dev) {
 8012d86: 687b         	ldr	r3, [r7, #0x4]
 8012d88: 3314         	adds	r3, #0x14
 8012d8a: 607b         	str	r3, [r7, #0x4]
 8012d8c: 687b         	ldr	r3, [r7, #0x4]
 8012d8e: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8012dac <z_device_state_init+0x38>
 8012d90: 4293         	cmp	r3, r2
 8012d92: bf34         	ite	lo
 8012d94: 2301         	movlo	r3, #0x1
 8012d96: 2300         	movhs	r3, #0x0
 8012d98: b2db         	uxtb	r3, r3
 8012d9a: 2b00         	cmp	r3, #0x0
 8012d9c: d1f0         	bne	0x8012d80 <z_device_state_init+0xc> @ imm = #-0x20
; }
 8012d9e: bf00         	nop
 8012da0: bf00         	nop
 8012da2: 3708         	adds	r7, #0x8
 8012da4: 46bd         	mov	sp, r7
 8012da6: bd80         	pop	{r7, pc}

08012da8 <$d>:
 8012da8: 48 7a 02 08  	.word	0x08027a48
 8012dac: 18 7d 02 08  	.word	0x08027d18

08012db0 <k_sys_fatal_error_handler>:
; {
 8012db0: b580         	push	{r7, lr}
 8012db2: b088         	sub	sp, #0x20
 8012db4: af04         	add	r7, sp, #0x10
 8012db6: 6078         	str	r0, [r7, #0x4]
 8012db8: 6039         	str	r1, [r7]
; 	LOG_PANIC();
 8012dba: f011 fbfd    	bl	0x80245b8 <log_panic>   @ imm = #0x117fa
; 	LOG_ERR("Halting system");
 8012dbe: 2303         	movs	r3, #0x3
 8012dc0: 2b00         	cmp	r3, #0x0
 8012dc2: d016         	beq	0x8012df2 <k_sys_fatal_error_handler+0x42> @ imm = #0x2c
 8012dc4: 2301         	movs	r3, #0x1
 8012dc6: 73fb         	strb	r3, [r7, #0xf]
 8012dc8: 7bfb         	ldrb	r3, [r7, #0xf]
 8012dca: f083 0301    	eor	r3, r3, #0x1
 8012dce: b2db         	uxtb	r3, r3
 8012dd0: 2b00         	cmp	r3, #0x0
 8012dd2: d10e         	bne	0x8012df2 <k_sys_fatal_error_handler+0x42> @ imm = #0x1c
 8012dd4: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8012df8 <k_sys_fatal_error_handler+0x48>
 8012dd6: 6819         	ldr	r1, [r3]
 8012dd8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8012dfc <k_sys_fatal_error_handler+0x4c>
 8012dda: 9302         	str	r3, [sp, #0x8]
 8012ddc: 2300         	movs	r3, #0x0
 8012dde: 9301         	str	r3, [sp, #0x4]
 8012de0: 2300         	movs	r3, #0x0
 8012de2: 9300         	str	r3, [sp]
 8012de4: 2300         	movs	r3, #0x0
 8012de6: 2201         	movs	r2, #0x1
 8012de8: 2000         	movs	r0, #0x0
 8012dea: f011 fbc7    	bl	0x802457c <z_log_msg_runtime_create> @ imm = #0x1178e
 8012dee: 2300         	movs	r3, #0x0
 8012df0: 60bb         	str	r3, [r7, #0x8]
; 	arch_system_halt(reason);
 8012df2: 6878         	ldr	r0, [r7, #0x4]
 8012df4: f011 fbf2    	bl	0x80245dc <arch_system_halt> @ imm = #0x117e4

08012df8 <$d>:
 8012df8: 44 0b 00 20  	.word	0x20000b44
 8012dfc: e0 a0 02 08  	.word	0x0802a0e0

08012e00 <thread_name_get>:
; {
 8012e00: b580         	push	{r7, lr}
 8012e02: b084         	sub	sp, #0x10
 8012e04: af00         	add	r7, sp, #0x0
 8012e06: 6078         	str	r0, [r7, #0x4]
; 	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
 8012e08: 687b         	ldr	r3, [r7, #0x4]
 8012e0a: 2b00         	cmp	r3, #0x0
 8012e0c: d004         	beq	0x8012e18 <thread_name_get+0x18> @ imm = #0x8
 8012e0e: 6878         	ldr	r0, [r7, #0x4]
 8012e10: f013 fa03    	bl	0x802621a <k_thread_name_get> @ imm = #0x13406
 8012e14: 4603         	mov	r3, r0
 8012e16: e000         	b	0x8012e1a <thread_name_get+0x1a> @ imm = #0x0
 8012e18: 2300         	movs	r3, #0x0
 8012e1a: 60fb         	str	r3, [r7, #0xc]
; 	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
 8012e1c: 68fb         	ldr	r3, [r7, #0xc]
 8012e1e: 2b00         	cmp	r3, #0x0
 8012e20: d003         	beq	0x8012e2a <thread_name_get+0x2a> @ imm = #0x6
 8012e22: 68fb         	ldr	r3, [r7, #0xc]
 8012e24: 781b         	ldrb	r3, [r3]
 8012e26: 2b00         	cmp	r3, #0x0
 8012e28: d101         	bne	0x8012e2e <thread_name_get+0x2e> @ imm = #0x2
; 		thread_name = "unknown";
 8012e2a: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8012e38 <thread_name_get+0x38>
 8012e2c: 60fb         	str	r3, [r7, #0xc]
; 	return thread_name;
 8012e2e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8012e30: 4618         	mov	r0, r3
 8012e32: 3710         	adds	r7, #0x10
 8012e34: 46bd         	mov	sp, r7
 8012e36: bd80         	pop	{r7, pc}

08012e38 <$d>:
 8012e38: f0 a0 02 08  	.word	0x0802a0f0

08012e3c <reason_to_str>:
; {
 8012e3c: b480         	push	{r7}
 8012e3e: b083         	sub	sp, #0xc
 8012e40: af00         	add	r7, sp, #0x0
 8012e42: 6078         	str	r0, [r7, #0x4]
; 	switch (reason) {
 8012e44: 687b         	ldr	r3, [r7, #0x4]
 8012e46: 2b04         	cmp	r3, #0x4
 8012e48: d816         	bhi	0x8012e78 <reason_to_str+0x3c> @ imm = #0x2c
 8012e4a: a201         	adr	r2, #4 <reason_to_str+0x13>
 8012e4c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08012e50 <$d>:
 8012e50: 65 2e 01 08  	.word	0x08012e65
 8012e54: 69 2e 01 08  	.word	0x08012e69
 8012e58: 6d 2e 01 08  	.word	0x08012e6d
 8012e5c: 71 2e 01 08  	.word	0x08012e71
 8012e60: 75 2e 01 08  	.word	0x08012e75

08012e64 <$t>:
; 		return "CPU exception";
 8012e64: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8012e88 <reason_to_str+0x4c>
 8012e66: e008         	b	0x8012e7a <reason_to_str+0x3e> @ imm = #0x10
; 		return "Unhandled interrupt";
 8012e68: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8012e8c <reason_to_str+0x50>
 8012e6a: e006         	b	0x8012e7a <reason_to_str+0x3e> @ imm = #0xc
; 		return "Stack overflow";
 8012e6c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8012e90 <reason_to_str+0x54>
 8012e6e: e004         	b	0x8012e7a <reason_to_str+0x3e> @ imm = #0x8
; 		return "Kernel oops";
 8012e70: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8012e94 <reason_to_str+0x58>
 8012e72: e002         	b	0x8012e7a <reason_to_str+0x3e> @ imm = #0x4
; 		return "Kernel panic";
 8012e74: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8012e98 <reason_to_str+0x5c>
 8012e76: e000         	b	0x8012e7a <reason_to_str+0x3e> @ imm = #0x0
; 		return "Unknown error";
 8012e78: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8012e9c <reason_to_str+0x60>
; }
 8012e7a: 4618         	mov	r0, r3
 8012e7c: 370c         	adds	r7, #0xc
 8012e7e: 46bd         	mov	sp, r7
 8012e80: f85d 7b04    	ldr	r7, [sp], #4
 8012e84: 4770         	bx	lr
 8012e86: bf00         	nop

08012e88 <$d>:
 8012e88: f8 a0 02 08  	.word	0x0802a0f8
 8012e8c: 08 a1 02 08  	.word	0x0802a108
 8012e90: 1c a1 02 08  	.word	0x0802a11c
 8012e94: 2c a1 02 08  	.word	0x0802a12c
 8012e98: 38 a1 02 08  	.word	0x0802a138
 8012e9c: 48 a1 02 08  	.word	0x0802a148

08012ea0 <z_fatal_error>:
; {
 8012ea0: b590         	push	{r4, r7, lr}
 8012ea2: b099         	sub	sp, #0x64
 8012ea4: af06         	add	r7, sp, #0x18
 8012ea6: 6078         	str	r0, [r7, #0x4]
 8012ea8: 6039         	str	r1, [r7]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8012eaa: f3ef 8311    	mrs	r3, basepri
 8012eae: 623b         	str	r3, [r7, #0x20]
;   return(result);
 8012eb0: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 8012eb2: 61fb         	str	r3, [r7, #0x1c]
 8012eb4: 2310         	movs	r3, #0x10
 8012eb6: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8012eb8: 69bb         	ldr	r3, [r7, #0x18]
 8012eba: f383 8812    	msr	basepri_max, r3
; }
 8012ebe: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012ec0: f3bf 8f6f    	isb	sy
; }
 8012ec4: bf00         	nop
; 	return key;
 8012ec6: 69fb         	ldr	r3, [r7, #0x1c]
; 	unsigned int key = arch_irq_lock();
 8012ec8: 63bb         	str	r3, [r7, #0x38]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8012eca: 4b50         	ldr	r3, [pc, #0x140]        @ 0x801300c <z_fatal_error+0x16c>
 8012ecc: 689b         	ldr	r3, [r3, #0x8]
 8012ece: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8012ed0: 6a7b         	ldr	r3, [r7, #0x24]
; 	struct k_thread *thread = IS_ENABLED(CONFIG_MULTITHREADING) ? arch_current_thread() : NULL;
 8012ed2: 643b         	str	r3, [r7, #0x40]
; 	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason, reason_to_str(reason),
 8012ed4: 2303         	movs	r3, #0x3
 8012ed6: 2b00         	cmp	r3, #0x0
 8012ed8: d023         	beq	0x8012f22 <z_fatal_error+0x82> @ imm = #0x46
 8012eda: 2301         	movs	r3, #0x1
 8012edc: f887 303f    	strb.w	r3, [r7, #0x3f]
 8012ee0: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8012ee4: f083 0301    	eor	r3, r3, #0x1
 8012ee8: b2db         	uxtb	r3, r3
 8012eea: 2b00         	cmp	r3, #0x0
 8012eec: d119         	bne	0x8012f22 <z_fatal_error+0x82> @ imm = #0x32
 8012eee: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8013010 <z_fatal_error+0x170>
 8012ef0: 681c         	ldr	r4, [r3]
 8012ef2: 6878         	ldr	r0, [r7, #0x4]
 8012ef4: f7ff ffa2    	bl	0x8012e3c <reason_to_str> @ imm = #-0xbc
 8012ef8: 4603         	mov	r3, r0
 8012efa: 4a44         	ldr	r2, [pc, #0x110]        @ 0x801300c <z_fatal_error+0x16c>
 8012efc: 7c12         	ldrb	r2, [r2, #0x10]
 8012efe: 9205         	str	r2, [sp, #0x14]
 8012f00: 9304         	str	r3, [sp, #0x10]
 8012f02: 687b         	ldr	r3, [r7, #0x4]
 8012f04: 9303         	str	r3, [sp, #0xc]
 8012f06: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8013014 <z_fatal_error+0x174>
 8012f08: 9302         	str	r3, [sp, #0x8]
 8012f0a: 2300         	movs	r3, #0x0
 8012f0c: 9301         	str	r3, [sp, #0x4]
 8012f0e: 2300         	movs	r3, #0x0
 8012f10: 9300         	str	r3, [sp]
 8012f12: 2300         	movs	r3, #0x0
 8012f14: 2201         	movs	r2, #0x1
 8012f16: 4621         	mov	r1, r4
 8012f18: 2000         	movs	r0, #0x0
 8012f1a: f011 fb2f    	bl	0x802457c <z_log_msg_runtime_create> @ imm = #0x1165e
 8012f1e: 2300         	movs	r3, #0x0
 8012f20: 647b         	str	r3, [r7, #0x44]
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 8012f22: 683b         	ldr	r3, [r7]
 8012f24: 2b00         	cmp	r3, #0x0
 8012f26: d028         	beq	0x8012f7a <z_fatal_error+0xda> @ imm = #0x50
 8012f28: 683b         	ldr	r3, [r7]
 8012f2a: 617b         	str	r3, [r7, #0x14]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 8012f2c: 697b         	ldr	r3, [r7, #0x14]
 8012f2e: 69db         	ldr	r3, [r3, #0x1c]
 8012f30: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8012f34: 2b00         	cmp	r3, #0x0
 8012f36: bf14         	ite	ne
 8012f38: 2301         	movne	r3, #0x1
 8012f3a: 2300         	moveq	r3, #0x0
 8012f3c: b2db         	uxtb	r3, r3
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 8012f3e: 2b00         	cmp	r3, #0x0
 8012f40: d01b         	beq	0x8012f7a <z_fatal_error+0xda> @ imm = #0x36
; 		LOG_ERR("Fault during interrupt handling\n");
 8012f42: 2303         	movs	r3, #0x3
 8012f44: 2b00         	cmp	r3, #0x0
 8012f46: d018         	beq	0x8012f7a <z_fatal_error+0xda> @ imm = #0x30
 8012f48: 2301         	movs	r3, #0x1
 8012f4a: f887 3037    	strb.w	r3, [r7, #0x37]
 8012f4e: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8012f52: f083 0301    	eor	r3, r3, #0x1
 8012f56: b2db         	uxtb	r3, r3
 8012f58: 2b00         	cmp	r3, #0x0
 8012f5a: d10e         	bne	0x8012f7a <z_fatal_error+0xda> @ imm = #0x1c
 8012f5c: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8013010 <z_fatal_error+0x170>
 8012f5e: 6819         	ldr	r1, [r3]
 8012f60: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8013018 <z_fatal_error+0x178>
 8012f62: 9302         	str	r3, [sp, #0x8]
 8012f64: 2300         	movs	r3, #0x0
 8012f66: 9301         	str	r3, [sp, #0x4]
 8012f68: 2300         	movs	r3, #0x0
 8012f6a: 9300         	str	r3, [sp]
 8012f6c: 2300         	movs	r3, #0x0
 8012f6e: 2201         	movs	r2, #0x1
 8012f70: 2000         	movs	r0, #0x0
 8012f72: f011 fb03    	bl	0x802457c <z_log_msg_runtime_create> @ imm = #0x11606
 8012f76: 2300         	movs	r3, #0x0
 8012f78: 633b         	str	r3, [r7, #0x30]
; 		LOG_ERR("Current thread: %p (%s)", thread, thread_name_get(thread));
 8012f7a: 2303         	movs	r3, #0x3
 8012f7c: 2b00         	cmp	r3, #0x0
 8012f7e: d020         	beq	0x8012fc2 <z_fatal_error+0x122> @ imm = #0x40
 8012f80: 2301         	movs	r3, #0x1
 8012f82: f887 302f    	strb.w	r3, [r7, #0x2f]
 8012f86: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8012f8a: f083 0301    	eor	r3, r3, #0x1
 8012f8e: b2db         	uxtb	r3, r3
 8012f90: 2b00         	cmp	r3, #0x0
 8012f92: d116         	bne	0x8012fc2 <z_fatal_error+0x122> @ imm = #0x2c
 8012f94: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8013010 <z_fatal_error+0x170>
 8012f96: 681c         	ldr	r4, [r3]
 8012f98: 6c38         	ldr	r0, [r7, #0x40]
 8012f9a: f7ff ff31    	bl	0x8012e00 <thread_name_get> @ imm = #-0x19e
 8012f9e: 4603         	mov	r3, r0
 8012fa0: 9304         	str	r3, [sp, #0x10]
 8012fa2: 6c3b         	ldr	r3, [r7, #0x40]
 8012fa4: 9303         	str	r3, [sp, #0xc]
 8012fa6: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x801301c <z_fatal_error+0x17c>
 8012fa8: 9302         	str	r3, [sp, #0x8]
 8012faa: 2300         	movs	r3, #0x0
 8012fac: 9301         	str	r3, [sp, #0x4]
 8012fae: 2300         	movs	r3, #0x0
 8012fb0: 9300         	str	r3, [sp]
 8012fb2: 2300         	movs	r3, #0x0
 8012fb4: 2201         	movs	r2, #0x1
 8012fb6: 4621         	mov	r1, r4
 8012fb8: 2000         	movs	r0, #0x0
 8012fba: f011 fadf    	bl	0x802457c <z_log_msg_runtime_create> @ imm = #0x115be
 8012fbe: 2300         	movs	r3, #0x0
 8012fc0: 62bb         	str	r3, [r7, #0x28]
; 	coredump(reason, esf, thread);
 8012fc2: 6c3a         	ldr	r2, [r7, #0x40]
 8012fc4: 6839         	ldr	r1, [r7]
 8012fc6: 6878         	ldr	r0, [r7, #0x4]
 8012fc8: f011 fafc    	bl	0x80245c4 <coredump>    @ imm = #0x115f8
; 	k_sys_fatal_error_handler(reason, esf);
 8012fcc: 6839         	ldr	r1, [r7]
 8012fce: 6878         	ldr	r0, [r7, #0x4]
 8012fd0: f7ff feee    	bl	0x8012db0 <k_sys_fatal_error_handler> @ imm = #-0x224
; 		if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 8012fd4: 683b         	ldr	r3, [r7]
 8012fd6: 2b00         	cmp	r3, #0x0
 8012fd8: d006         	beq	0x8012fe8 <z_fatal_error+0x148> @ imm = #0xc
 8012fda: 683b         	ldr	r3, [r7]
 8012fdc: 613b         	str	r3, [r7, #0x10]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 8012fde: 693b         	ldr	r3, [r7, #0x10]
 8012fe0: 69db         	ldr	r3, [r3, #0x1c]
 8012fe2: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8012fe6: 2b00         	cmp	r3, #0x0
 8012fe8: 6bbb         	ldr	r3, [r7, #0x38]
 8012fea: 60fb         	str	r3, [r7, #0xc]
 8012fec: 68fb         	ldr	r3, [r7, #0xc]
 8012fee: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012ff0: 68bb         	ldr	r3, [r7, #0x8]
 8012ff2: f383 8811    	msr	basepri, r3
; }
 8012ff6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012ff8: f3bf 8f6f    	isb	sy
; }
 8012ffc: bf00         	nop
; }
 8012ffe: bf00         	nop
; 		k_thread_abort(thread);
 8013000: 6c38         	ldr	r0, [r7, #0x40]
 8013002: f011 fab0    	bl	0x8024566 <k_thread_abort> @ imm = #0x11560
; }
 8013006: 374c         	adds	r7, #0x4c
 8013008: 46bd         	mov	sp, r7
 801300a: bd90         	pop	{r4, r7, pc}

0801300c <$d>:
 801300c: a8 25 00 20  	.word	0x200025a8
 8013010: 44 0b 00 20  	.word	0x20000b44
 8013014: 58 a1 02 08  	.word	0x0802a158
 8013018: 80 a1 02 08  	.word	0x0802a180
 801301c: a4 a1 02 08  	.word	0x0802a1a4

08013020 <__NVIC_SetPriority>:
; {
 8013020: b480         	push	{r7}
 8013022: b083         	sub	sp, #0xc
 8013024: af00         	add	r7, sp, #0x0
 8013026: 4603         	mov	r3, r0
 8013028: 6039         	str	r1, [r7]
 801302a: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 801302c: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8013030: 2b00         	cmp	r3, #0x0
 8013032: db0a         	blt	0x801304a <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8013034: 683b         	ldr	r3, [r7]
 8013036: b2da         	uxtb	r2, r3
 8013038: 490c         	ldr	r1, [pc, #0x30]         @ 0x801306c <__NVIC_SetPriority+0x4c>
 801303a: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 801303e: 0112         	lsls	r2, r2, #0x4
 8013040: b2d2         	uxtb	r2, r2
 8013042: 440b         	add	r3, r1
 8013044: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8013048: e00a         	b	0x8013060 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 801304a: 683b         	ldr	r3, [r7]
 801304c: b2da         	uxtb	r2, r3
 801304e: 4908         	ldr	r1, [pc, #0x20]         @ 0x8013070 <__NVIC_SetPriority+0x50>
 8013050: 79fb         	ldrb	r3, [r7, #0x7]
 8013052: f003 030f    	and	r3, r3, #0xf
 8013056: 3b04         	subs	r3, #0x4
 8013058: 0112         	lsls	r2, r2, #0x4
 801305a: b2d2         	uxtb	r2, r2
 801305c: 440b         	add	r3, r1
 801305e: 761a         	strb	r2, [r3, #0x18]
; }
 8013060: bf00         	nop
 8013062: 370c         	adds	r7, #0xc
 8013064: 46bd         	mov	sp, r7
 8013066: f85d 7b04    	ldr	r7, [sp], #4
 801306a: 4770         	bx	lr

0801306c <$d>:
 801306c: 00 e1 00 e0  	.word	0xe000e100
 8013070: 00 ed 00 e0  	.word	0xe000ed00

08013074 <z_add_thread_timeout>:
; {
 8013074: b580         	push	{r7, lr}
 8013076: b084         	sub	sp, #0x10
 8013078: af00         	add	r7, sp, #0x0
 801307a: 60f8         	str	r0, [r7, #0xc]
 801307c: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 8013080: 68fb         	ldr	r3, [r7, #0xc]
 8013082: f103 0018    	add.w	r0, r3, #0x18
 8013086: e9d7 2300    	ldrd	r2, r3, [r7]
 801308a: 4903         	ldr	r1, [pc, #0xc]          @ 0x8013098 <z_add_thread_timeout+0x24>
 801308c: f003 fdc6    	bl	0x8016c1c <z_add_timeout> @ imm = #0x3b8c
; }
 8013090: bf00         	nop
 8013092: 3710         	adds	r7, #0x10
 8013094: 46bd         	mov	sp, r7
 8013096: bd80         	pop	{r7, pc}

08013098 <$d>:
 8013098: e3 6a 02 08  	.word	0x08026ae3

0801309c <z_dummy_thread_init>:
; {
 801309c: b580         	push	{r7, lr}
 801309e: b084         	sub	sp, #0x10
 80130a0: af00         	add	r7, sp, #0x0
 80130a2: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 80130a4: 687b         	ldr	r3, [r7, #0x4]
 80130a6: 2201         	movs	r2, #0x1
 80130a8: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 80130aa: 687b         	ldr	r3, [r7, #0x4]
 80130ac: 2201         	movs	r2, #0x1
 80130ae: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 80130b0: 687b         	ldr	r3, [r7, #0x4]
 80130b2: 2200         	movs	r2, #0x0
 80130b4: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 80130b8: 687b         	ldr	r3, [r7, #0x4]
 80130ba: 2200         	movs	r2, #0x0
 80130bc: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	k_thread_system_pool_assign(dummy_thread);
 80130c0: 6878         	ldr	r0, [r7, #0x4]
 80130c2: f004 fb63    	bl	0x801778c <k_thread_system_pool_assign> @ imm = #0x46c6
 80130c6: 687b         	ldr	r3, [r7, #0x4]
 80130c8: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 80130ca: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80130dc <z_dummy_thread_init+0x40>
 80130cc: 68fb         	ldr	r3, [r7, #0xc]
 80130ce: 6093         	str	r3, [r2, #0x8]
; }
 80130d0: bf00         	nop
; }
 80130d2: bf00         	nop
 80130d4: 3710         	adds	r7, #0x10
 80130d6: 46bd         	mov	sp, r7
 80130d8: bd80         	pop	{r7, pc}
 80130da: bf00         	nop

080130dc <$d>:
 80130dc: a8 25 00 20  	.word	0x200025a8

080130e0 <z_init_static_threads>:
; {
 80130e0: b5f0         	push	{r4, r5, r6, r7, lr}
 80130e2: b08f         	sub	sp, #0x3c
 80130e4: af06         	add	r7, sp, #0x18
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 80130e6: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80131ac <z_init_static_threads+0xcc>
 80130e8: 61fb         	str	r3, [r7, #0x1c]
 80130ea: e029         	b	0x8013140 <z_init_static_threads+0x60> @ imm = #0x52
; 		z_setup_new_thread(
 80130ec: 69fb         	ldr	r3, [r7, #0x1c]
 80130ee: 681e         	ldr	r6, [r3]
 80130f0: 69fb         	ldr	r3, [r7, #0x1c]
 80130f2: 685b         	ldr	r3, [r3, #0x4]
 80130f4: 60fb         	str	r3, [r7, #0xc]
 80130f6: 69fb         	ldr	r3, [r7, #0x1c]
 80130f8: 689a         	ldr	r2, [r3, #0x8]
 80130fa: 60ba         	str	r2, [r7, #0x8]
 80130fc: 69fb         	ldr	r3, [r7, #0x1c]
 80130fe: 68d8         	ldr	r0, [r3, #0xc]
 8013100: 6078         	str	r0, [r7, #0x4]
 8013102: 69fb         	ldr	r3, [r7, #0x1c]
 8013104: 691b         	ldr	r3, [r3, #0x10]
 8013106: 69fa         	ldr	r2, [r7, #0x1c]
 8013108: 6952         	ldr	r2, [r2, #0x14]
 801310a: 69f9         	ldr	r1, [r7, #0x1c]
 801310c: 6989         	ldr	r1, [r1, #0x18]
 801310e: 69f8         	ldr	r0, [r7, #0x1c]
 8013110: 69c0         	ldr	r0, [r0, #0x1c]
 8013112: 69fc         	ldr	r4, [r7, #0x1c]
 8013114: 6a24         	ldr	r4, [r4, #0x20]
 8013116: 69fd         	ldr	r5, [r7, #0x1c]
 8013118: 6a6d         	ldr	r5, [r5, #0x24]
 801311a: 9505         	str	r5, [sp, #0x14]
 801311c: 9404         	str	r4, [sp, #0x10]
 801311e: 9003         	str	r0, [sp, #0xc]
 8013120: 9102         	str	r1, [sp, #0x8]
 8013122: 9201         	str	r2, [sp, #0x4]
 8013124: 9300         	str	r3, [sp]
 8013126: 687b         	ldr	r3, [r7, #0x4]
 8013128: 68ba         	ldr	r2, [r7, #0x8]
 801312a: 68f9         	ldr	r1, [r7, #0xc]
 801312c: 4630         	mov	r0, r6
 801312e: f001 fd0d    	bl	0x8014b4c <z_setup_new_thread> @ imm = #0x1a1a
; 		thread_data->init_thread->init_data = thread_data;
 8013132: 69fb         	ldr	r3, [r7, #0x1c]
 8013134: 681b         	ldr	r3, [r3]
 8013136: 69fa         	ldr	r2, [r7, #0x1c]
 8013138: 665a         	str	r2, [r3, #0x64]
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 801313a: 69fb         	ldr	r3, [r7, #0x1c]
 801313c: 3330         	adds	r3, #0x30
 801313e: 61fb         	str	r3, [r7, #0x1c]
 8013140: 69fb         	ldr	r3, [r7, #0x1c]
 8013142: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x80131b0 <z_init_static_threads+0xd0>
 8013144: 4293         	cmp	r3, r2
 8013146: bf34         	ite	lo
 8013148: 2301         	movlo	r3, #0x1
 801314a: 2300         	movhs	r3, #0x0
 801314c: b2db         	uxtb	r3, r3
 801314e: 2b00         	cmp	r3, #0x0
 8013150: d1cc         	bne	0x80130ec <z_init_static_threads+0xc> @ imm = #-0x68
; 	k_sched_lock();
 8013152: f002 fdb9    	bl	0x8015cc8 <k_sched_lock> @ imm = #0x2b72
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 8013156: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80131ac <z_init_static_threads+0xcc>
 8013158: 61bb         	str	r3, [r7, #0x18]
 801315a: e018         	b	0x801318e <z_init_static_threads+0xae> @ imm = #0x30
; 		k_timeout_t init_delay = Z_THREAD_INIT_DELAY(thread_data);
 801315c: 69bb         	ldr	r3, [r7, #0x18]
 801315e: e9d3 230a    	ldrd	r2, r3, [r3, #40]
 8013162: e9c7 2304    	strd	r2, r3, [r7, #16]
; 		if (!K_TIMEOUT_EQ(init_delay, K_FOREVER)) {
 8013166: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 801316a: f04f 30ff    	mov.w	r0, #0xffffffff
 801316e: f04f 31ff    	mov.w	r1, #0xffffffff
 8013172: 428b         	cmp	r3, r1
 8013174: bf08         	it	eq
 8013176: 4282         	cmpeq	r2, r0
 8013178: d006         	beq	0x8013188 <z_init_static_threads+0xa8> @ imm = #0xc
; 			thread_schedule_new(thread_data->init_thread,
 801317a: 69bb         	ldr	r3, [r7, #0x18]
 801317c: 6819         	ldr	r1, [r3]
 801317e: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8013182: 4608         	mov	r0, r1
 8013184: f011 fa5f    	bl	0x8024646 <thread_schedule_new> @ imm = #0x114be
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 8013188: 69bb         	ldr	r3, [r7, #0x18]
 801318a: 3330         	adds	r3, #0x30
 801318c: 61bb         	str	r3, [r7, #0x18]
 801318e: 69bb         	ldr	r3, [r7, #0x18]
 8013190: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80131b0 <z_init_static_threads+0xd0>
 8013192: 4293         	cmp	r3, r2
 8013194: bf34         	ite	lo
 8013196: 2301         	movlo	r3, #0x1
 8013198: 2300         	movhs	r3, #0x0
 801319a: b2db         	uxtb	r3, r3
 801319c: 2b00         	cmp	r3, #0x0
 801319e: d1dd         	bne	0x801315c <z_init_static_threads+0x7c> @ imm = #-0x46
; 	k_sched_unlock();
 80131a0: f002 fdd2    	bl	0x8015d48 <k_sched_unlock> @ imm = #0x2ba4
; }
 80131a4: bf00         	nop
 80131a6: 3724         	adds	r7, #0x24
 80131a8: 46bd         	mov	sp, r7
 80131aa: bdf0         	pop	{r4, r5, r6, r7, pc}

080131ac <$d>:
 80131ac: a8 7f 02 08  	.word	0x08027fa8
 80131b0: 08 80 02 08  	.word	0x08028008

080131b4 <z_bss_zero>:
; {
 80131b4: b580         	push	{r7, lr}
 80131b6: af00         	add	r7, sp, #0x0
; 	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
 80131b8: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80131cc <z_bss_zero+0x18>
 80131ba: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80131d0 <z_bss_zero+0x1c>
 80131bc: 1ad3         	subs	r3, r2, r3
 80131be: 461a         	mov	r2, r3
 80131c0: 2100         	movs	r1, #0x0
 80131c2: 4803         	ldr	r0, [pc, #0xc]          @ 0x80131d0 <z_bss_zero+0x1c>
 80131c4: f011 fa90    	bl	0x80246e8 <z_early_memset> @ imm = #0x11520
; }
 80131c8: bd80         	pop	{r7, pc}
 80131ca: bf00         	nop

080131cc <$d>:
 80131cc: 08 33 00 20  	.word	0x20003308
 80131d0: 98 0c 00 20  	.word	0x20000c98

080131d4 <z_sys_init_run_level>:
; {
 80131d4: b580         	push	{r7, lr}
 80131d6: b086         	sub	sp, #0x18
 80131d8: af00         	add	r7, sp, #0x0
 80131da: 4603         	mov	r3, r0
 80131dc: 71fb         	strb	r3, [r7, #0x7]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 80131de: 79fb         	ldrb	r3, [r7, #0x7]
 80131e0: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8013228 <z_sys_init_run_level+0x54>
 80131e2: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80131e6: 617b         	str	r3, [r7, #0x14]
 80131e8: e011         	b	0x801320e <z_sys_init_run_level+0x3a> @ imm = #0x22
; 		const struct device *dev = entry->dev;
 80131ea: 697b         	ldr	r3, [r7, #0x14]
 80131ec: 685b         	ldr	r3, [r3, #0x4]
 80131ee: 613b         	str	r3, [r7, #0x10]
; 		if (dev != NULL) {
 80131f0: 693b         	ldr	r3, [r7, #0x10]
 80131f2: 2b00         	cmp	r3, #0x0
 80131f4: d004         	beq	0x8013200 <z_sys_init_run_level+0x2c> @ imm = #0x8
; 			result = do_device_init(entry);
 80131f6: 6978         	ldr	r0, [r7, #0x14]
 80131f8: f011 fa94    	bl	0x8024724 <do_device_init> @ imm = #0x11528
 80131fc: 60f8         	str	r0, [r7, #0xc]
 80131fe: e003         	b	0x8013208 <z_sys_init_run_level+0x34> @ imm = #0x6
; 			result = entry->init_fn.sys();
 8013200: 697b         	ldr	r3, [r7, #0x14]
 8013202: 681b         	ldr	r3, [r3]
 8013204: 4798         	blx	r3
 8013206: 60f8         	str	r0, [r7, #0xc]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 8013208: 697b         	ldr	r3, [r7, #0x14]
 801320a: 3308         	adds	r3, #0x8
 801320c: 617b         	str	r3, [r7, #0x14]
 801320e: 79fb         	ldrb	r3, [r7, #0x7]
 8013210: 3301         	adds	r3, #0x1
 8013212: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8013228 <z_sys_init_run_level+0x54>
 8013214: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8013218: 697a         	ldr	r2, [r7, #0x14]
 801321a: 429a         	cmp	r2, r3
 801321c: d3e5         	blo	0x80131ea <z_sys_init_run_level+0x16> @ imm = #-0x36
; }
 801321e: bf00         	nop
 8013220: bf00         	nop
 8013222: 3718         	adds	r7, #0x18
 8013224: 46bd         	mov	sp, r7
 8013226: bd80         	pop	{r7, pc}

08013228 <$d>:
 8013228: 48 0b 00 20  	.word	0x20000b48

0801322c <bg_thread_main>:
; {
 801322c: b580         	push	{r7, lr}
 801322e: b084         	sub	sp, #0x10
 8013230: af00         	add	r7, sp, #0x0
 8013232: 60f8         	str	r0, [r7, #0xc]
 8013234: 60b9         	str	r1, [r7, #0x8]
 8013236: 607a         	str	r2, [r7, #0x4]
; 	z_sys_post_kernel = true;
 8013238: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8013268 <bg_thread_main+0x3c>
 801323a: 2201         	movs	r2, #0x1
 801323c: 701a         	strb	r2, [r3]
; 	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 801323e: 2003         	movs	r0, #0x3
 8013240: f7ff ffc8    	bl	0x80131d4 <z_sys_init_run_level> @ imm = #-0x70
; 	boot_banner();
 8013244: f004 fadc    	bl	0x8017800 <boot_banner> @ imm = #0x45b8
; 	z_init_static();
 8013248: f011 faa2    	bl	0x8024790 <z_init_static> @ imm = #0x11544
; 	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
 801324c: 2004         	movs	r0, #0x4
 801324e: f7ff ffc1    	bl	0x80131d4 <z_sys_init_run_level> @ imm = #-0x7e
; 	z_init_static_threads();
 8013252: f7ff ff45    	bl	0x80130e0 <z_init_static_threads> @ imm = #-0x176
; 	(void)main();
 8013256: f7f0 fb99    	bl	0x800398c <main>        @ imm = #-0xf8ce
; 	z_thread_essential_clear(&z_main_thread);
 801325a: 4804         	ldr	r0, [pc, #0x10]         @ 0x801326c <bg_thread_main+0x40>
 801325c: f011 fa21    	bl	0x80246a2 <z_thread_essential_clear> @ imm = #0x11442
; } /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 8013260: bf00         	nop
 8013262: 3710         	adds	r7, #0x10
 8013264: 46bd         	mov	sp, r7
 8013266: bd80         	pop	{r7, pc}

08013268 <$d>:
 8013268: 06 33 00 20  	.word	0x20003306
 801326c: f0 25 00 20  	.word	0x200025f0

08013270 <init_idle_thread>:
; {
 8013270: b580         	push	{r7, lr}
 8013272: b08c         	sub	sp, #0x30
 8013274: af06         	add	r7, sp, #0x18
 8013276: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = &z_idle_threads[i];
 8013278: 687b         	ldr	r3, [r7, #0x4]
 801327a: f44f 728c    	mov.w	r2, #0x118
 801327e: fb02 f303    	mul	r3, r2, r3
 8013282: 4a16         	ldr	r2, [pc, #0x58]         @ 0x80132dc <init_idle_thread+0x6c>
 8013284: 4413         	add	r3, r2
 8013286: 617b         	str	r3, [r7, #0x14]
; 	k_thread_stack_t *stack = z_idle_stacks[i];
 8013288: 687a         	ldr	r2, [r7, #0x4]
 801328a: 4613         	mov	r3, r2
 801328c: 009b         	lsls	r3, r3, #0x2
 801328e: 4413         	add	r3, r2
 8013290: 019b         	lsls	r3, r3, #0x6
 8013292: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x80132e0 <init_idle_thread+0x70>
 8013294: 4413         	add	r3, r2
 8013296: 613b         	str	r3, [r7, #0x10]
; 	size_t stack_size = K_KERNEL_STACK_SIZEOF(z_idle_stacks[i]);
 8013298: f44f 73a0    	mov.w	r3, #0x140
 801329c: 60fb         	str	r3, [r7, #0xc]
; 	char *tname = "idle";
 801329e: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80132e4 <init_idle_thread+0x74>
 80132a0: 60bb         	str	r3, [r7, #0x8]
; 			  stack_size, idle, &_kernel.cpus[i],
 80132a2: 687b         	ldr	r3, [r7, #0x4]
 80132a4: 015b         	lsls	r3, r3, #0x5
 80132a6: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80132e8 <init_idle_thread+0x78>
 80132a8: 4413         	add	r3, r2
; 	z_setup_new_thread(thread, stack,
 80132aa: 68ba         	ldr	r2, [r7, #0x8]
 80132ac: 9205         	str	r2, [sp, #0x14]
 80132ae: 2201         	movs	r2, #0x1
 80132b0: 9204         	str	r2, [sp, #0x10]
 80132b2: 220f         	movs	r2, #0xf
 80132b4: 9203         	str	r2, [sp, #0xc]
 80132b6: 2200         	movs	r2, #0x0
 80132b8: 9202         	str	r2, [sp, #0x8]
 80132ba: 2200         	movs	r2, #0x0
 80132bc: 9201         	str	r2, [sp, #0x4]
 80132be: 9300         	str	r3, [sp]
 80132c0: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80132ec <init_idle_thread+0x7c>
 80132c2: 68fa         	ldr	r2, [r7, #0xc]
 80132c4: 6939         	ldr	r1, [r7, #0x10]
 80132c6: 6978         	ldr	r0, [r7, #0x14]
 80132c8: f001 fc40    	bl	0x8014b4c <z_setup_new_thread> @ imm = #0x1880
; 	z_mark_thread_as_not_suspended(thread);
 80132cc: 6978         	ldr	r0, [r7, #0x14]
 80132ce: f011 f9d7    	bl	0x8024680 <z_mark_thread_as_not_suspended> @ imm = #0x113ae
; }
 80132d2: bf00         	nop
 80132d4: 3718         	adds	r7, #0x18
 80132d6: 46bd         	mov	sp, r7
 80132d8: bd80         	pop	{r7, pc}
 80132da: bf00         	nop

080132dc <$d>:
 80132dc: 08 27 00 20  	.word	0x20002708
 80132e0: 08 52 00 20  	.word	0x20005208
 80132e4: c0 a1 02 08  	.word	0x0802a1c0
 80132e8: a8 25 00 20  	.word	0x200025a8
 80132ec: 03 4d 02 08  	.word	0x08024d03

080132f0 <z_init_cpu>:
; {
 80132f0: b580         	push	{r7, lr}
 80132f2: b082         	sub	sp, #0x8
 80132f4: af00         	add	r7, sp, #0x0
 80132f6: 6078         	str	r0, [r7, #0x4]
; 	init_idle_thread(id);
 80132f8: 6878         	ldr	r0, [r7, #0x4]
 80132fa: f7ff ffb9    	bl	0x8013270 <init_idle_thread> @ imm = #-0x8e
; 	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 80132fe: 687b         	ldr	r3, [r7, #0x4]
 8013300: f44f 728c    	mov.w	r2, #0x118
 8013304: fb02 f303    	mul	r3, r2, r3
 8013308: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8013378 <z_init_cpu+0x88>
 801330a: 441a         	add	r2, r3
 801330c: 491b         	ldr	r1, [pc, #0x6c]         @ 0x801337c <z_init_cpu+0x8c>
 801330e: 687b         	ldr	r3, [r7, #0x4]
 8013310: 015b         	lsls	r3, r3, #0x5
 8013312: 440b         	add	r3, r1
 8013314: 330c         	adds	r3, #0xc
 8013316: 601a         	str	r2, [r3]
; 	_kernel.cpus[id].id = id;
 8013318: 687b         	ldr	r3, [r7, #0x4]
 801331a: b2d9         	uxtb	r1, r3
 801331c: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x801337c <z_init_cpu+0x8c>
 801331e: 687b         	ldr	r3, [r7, #0x4]
 8013320: 015b         	lsls	r3, r3, #0x5
 8013322: 4413         	add	r3, r2
 8013324: 3310         	adds	r3, #0x10
 8013326: 460a         	mov	r2, r1
 8013328: 701a         	strb	r2, [r3]
; 		(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 801332a: 687b         	ldr	r3, [r7, #0x4]
 801332c: 02db         	lsls	r3, r3, #0xb
 801332e: 4a14         	ldr	r2, [pc, #0x50]         @ 0x8013380 <z_init_cpu+0x90>
 8013330: 4413         	add	r3, r2
 8013332: 4618         	mov	r0, r3
 8013334: f011 f966    	bl	0x8024604 <K_KERNEL_STACK_BUFFER> @ imm = #0x112cc
 8013338: 4603         	mov	r3, r0
 801333a: f503 6200    	add.w	r2, r3, #0x800
; 	_kernel.cpus[id].irq_stack =
 801333e: 490f         	ldr	r1, [pc, #0x3c]         @ 0x801337c <z_init_cpu+0x8c>
 8013340: 687b         	ldr	r3, [r7, #0x4]
 8013342: 015b         	lsls	r3, r3, #0x5
 8013344: 440b         	add	r3, r1
 8013346: 3304         	adds	r3, #0x4
 8013348: 601a         	str	r2, [r3]
; 	_kernel.cpus[id].usage = &_kernel.usage[id];
 801334a: 687b         	ldr	r3, [r7, #0x4]
 801334c: 011b         	lsls	r3, r3, #0x4
 801334e: 3338         	adds	r3, #0x38
 8013350: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x801337c <z_init_cpu+0x8c>
 8013352: 441a         	add	r2, r3
 8013354: 4909         	ldr	r1, [pc, #0x24]         @ 0x801337c <z_init_cpu+0x8c>
 8013356: 687b         	ldr	r3, [r7, #0x4]
 8013358: 015b         	lsls	r3, r3, #0x5
 801335a: 440b         	add	r3, r1
 801335c: 331c         	adds	r3, #0x1c
 801335e: 601a         	str	r2, [r3]
; 	_kernel.cpus[id].usage->track_usage =
 8013360: 4a06         	ldr	r2, [pc, #0x18]         @ 0x801337c <z_init_cpu+0x8c>
 8013362: 687b         	ldr	r3, [r7, #0x4]
 8013364: 015b         	lsls	r3, r3, #0x5
 8013366: 4413         	add	r3, r2
 8013368: 331c         	adds	r3, #0x1c
 801336a: 681b         	ldr	r3, [r3]
 801336c: 2201         	movs	r2, #0x1
 801336e: 721a         	strb	r2, [r3, #0x8]
; }
 8013370: bf00         	nop
 8013372: 3708         	adds	r7, #0x8
 8013374: 46bd         	mov	sp, r7
 8013376: bd80         	pop	{r7, pc}

08013378 <$d>:
 8013378: 08 27 00 20  	.word	0x20002708
 801337c: a8 25 00 20  	.word	0x200025a8
 8013380: 48 53 00 20  	.word	0x20005348

08013384 <prepare_multithreading>:
; {
 8013384: b580         	push	{r7, lr}
 8013386: b088         	sub	sp, #0x20
 8013388: af06         	add	r7, sp, #0x18
; 	z_sched_init();
 801338a: f002 fdbb    	bl	0x8015f04 <z_sched_init> @ imm = #0x2b76
; 	_kernel.ready_q.cache = &z_main_thread;
 801338e: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80133d8 <prepare_multithreading+0x54>
 8013390: 4a12         	ldr	r2, [pc, #0x48]         @ 0x80133dc <prepare_multithreading+0x58>
 8013392: 621a         	str	r2, [r3, #0x20]
; 	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 8013394: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80133e0 <prepare_multithreading+0x5c>
 8013396: 9305         	str	r3, [sp, #0x14]
 8013398: 2301         	movs	r3, #0x1
 801339a: 9304         	str	r3, [sp, #0x10]
 801339c: 2300         	movs	r3, #0x0
 801339e: 9303         	str	r3, [sp, #0xc]
 80133a0: 2300         	movs	r3, #0x0
 80133a2: 9302         	str	r3, [sp, #0x8]
 80133a4: 2300         	movs	r3, #0x0
 80133a6: 9301         	str	r3, [sp, #0x4]
 80133a8: 2300         	movs	r3, #0x0
 80133aa: 9300         	str	r3, [sp]
 80133ac: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80133e4 <prepare_multithreading+0x60>
 80133ae: f44f 6200    	mov.w	r2, #0x800
 80133b2: 490d         	ldr	r1, [pc, #0x34]         @ 0x80133e8 <prepare_multithreading+0x64>
 80133b4: 4809         	ldr	r0, [pc, #0x24]         @ 0x80133dc <prepare_multithreading+0x58>
 80133b6: f001 fbc9    	bl	0x8014b4c <z_setup_new_thread> @ imm = #0x1792
 80133ba: 6078         	str	r0, [r7, #0x4]
; 	z_mark_thread_as_not_suspended(&z_main_thread);
 80133bc: 4807         	ldr	r0, [pc, #0x1c]         @ 0x80133dc <prepare_multithreading+0x58>
 80133be: f011 f95f    	bl	0x8024680 <z_mark_thread_as_not_suspended> @ imm = #0x112be
; 	z_ready_thread(&z_main_thread);
 80133c2: 4806         	ldr	r0, [pc, #0x18]         @ 0x80133dc <prepare_multithreading+0x58>
 80133c4: f001 fe8a    	bl	0x80150dc <z_ready_thread> @ imm = #0x1d14
; 	z_init_cpu(0);
 80133c8: 2000         	movs	r0, #0x0
 80133ca: f7ff ff91    	bl	0x80132f0 <z_init_cpu>  @ imm = #-0xde
; 	return stack_ptr;
 80133ce: 687b         	ldr	r3, [r7, #0x4]
; }
 80133d0: 4618         	mov	r0, r3
 80133d2: 3708         	adds	r7, #0x8
 80133d4: 46bd         	mov	sp, r7
 80133d6: bd80         	pop	{r7, pc}

080133d8 <$d>:
 80133d8: a8 25 00 20  	.word	0x200025a8
 80133dc: f0 25 00 20  	.word	0x200025f0
 80133e0: c8 a1 02 08  	.word	0x0802a1c8
 80133e4: 2d 32 01 08  	.word	0x0801322d
 80133e8: 08 4a 00 20  	.word	0x20004a08

080133ec <switch_to_main_thread>:
; {
 80133ec: b580         	push	{r7, lr}
 80133ee: b082         	sub	sp, #0x8
 80133f0: af00         	add	r7, sp, #0x0
 80133f2: 6078         	str	r0, [r7, #0x4]
; 	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 80133f4: 4a02         	ldr	r2, [pc, #0x8]          @ 0x8013400 <switch_to_main_thread+0x14>
 80133f6: 6879         	ldr	r1, [r7, #0x4]
 80133f8: 4802         	ldr	r0, [pc, #0x8]          @ 0x8013404 <switch_to_main_thread+0x18>
 80133fa: f7f3 f9b9    	bl	0x8006770 <arch_switch_to_main_thread> @ imm = #-0xcc8e
 80133fe: bf00         	nop

08013400 <$d>:
 8013400: 2d 32 01 08  	.word	0x0801322d
 8013404: f0 25 00 20  	.word	0x200025f0

08013408 <z_cstart>:
; {
 8013408: b580         	push	{r7, lr}
 801340a: b082         	sub	sp, #0x8
 801340c: af00         	add	r7, sp, #0x0
; 	gcov_static_init();
 801340e: f011 f959    	bl	0x80246c4 <gcov_static_init> @ imm = #0x112b2
; 	z_sys_init_run_level(INIT_LEVEL_EARLY);
 8013412: 2000         	movs	r0, #0x0
 8013414: f7ff fede    	bl	0x80131d4 <z_sys_init_run_level> @ imm = #-0x244
; 		(uint32_t)(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
 8013418: 482d         	ldr	r0, [pc, #0xb4]         @ 0x80134d0 <z_cstart+0xc8>
 801341a: f011 f8f3    	bl	0x8024604 <K_KERNEL_STACK_BUFFER> @ imm = #0x111e6
 801341e: 4603         	mov	r3, r0
; 	uint32_t msp =
 8013420: f503 6300    	add.w	r3, r3, #0x800
 8013424: 607b         	str	r3, [r7, #0x4]
 8013426: 687b         	ldr	r3, [r7, #0x4]
 8013428: 603b         	str	r3, [r7]
;   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 801342a: 683b         	ldr	r3, [r7]
 801342c: f383 8808    	msr	msp, r3
; }
 8013430: bf00         	nop
; 	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
 8013432: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x80134d4 <z_cstart+0xcc>
 8013434: 695b         	ldr	r3, [r3, #0x14]
 8013436: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x80134d4 <z_cstart+0xcc>
 8013438: f443 7300    	orr	r3, r3, #0x200
 801343c: 6153         	str	r3, [r2, #0x14]
; }
 801343e: bf00         	nop
; 	NVIC_SetPriority(PendSV_IRQn, _EXC_PENDSV_PRIO);
 8013440: 21ff         	movs	r1, #0xff
 8013442: f06f 0001    	mvn	r0, #0x1
 8013446: f7ff fdeb    	bl	0x8013020 <__NVIC_SetPriority> @ imm = #-0x42a
; 	NVIC_SetPriority(SVCall_IRQn, _EXC_SVC_PRIO);
 801344a: 2100         	movs	r1, #0x0
 801344c: f06f 0004    	mvn	r0, #0x4
 8013450: f7ff fde6    	bl	0x8013020 <__NVIC_SetPriority> @ imm = #-0x434
; 	NVIC_SetPriority(MemoryManagement_IRQn, _EXC_FAULT_PRIO);
 8013454: 2100         	movs	r1, #0x0
 8013456: f06f 000b    	mvn	r0, #0xb
 801345a: f7ff fde1    	bl	0x8013020 <__NVIC_SetPriority> @ imm = #-0x43e
; 	NVIC_SetPriority(BusFault_IRQn, _EXC_FAULT_PRIO);
 801345e: 2100         	movs	r1, #0x0
 8013460: f06f 000a    	mvn	r0, #0xa
 8013464: f7ff fddc    	bl	0x8013020 <__NVIC_SetPriority> @ imm = #-0x448
; 	NVIC_SetPriority(UsageFault_IRQn, _EXC_FAULT_PRIO);
 8013468: 2100         	movs	r1, #0x0
 801346a: f06f 0009    	mvn	r0, #0x9
 801346e: f7ff fdd7    	bl	0x8013020 <__NVIC_SetPriority> @ imm = #-0x452
; 	NVIC_SetPriority(DebugMonitor_IRQn, _EXC_FAULT_PRIO);
 8013472: 2100         	movs	r1, #0x0
 8013474: f06f 0003    	mvn	r0, #0x3
 8013478: f7ff fdd2    	bl	0x8013020 <__NVIC_SetPriority> @ imm = #-0x45c
; 	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 801347c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80134d4 <z_cstart+0xcc>
 801347e: 6a5b         	ldr	r3, [r3, #0x24]
 8013480: 4a14         	ldr	r2, [pc, #0x50]         @ 0x80134d4 <z_cstart+0xcc>
 8013482: f443 23e0    	orr	r3, r3, #0x70000
 8013486: 6253         	str	r3, [r2, #0x24]
; }
 8013488: bf00         	nop
; 	z_arm_fault_init();
 801348a: f7f2 ff45    	bl	0x8006318 <z_arm_fault_init> @ imm = #-0xd176
; 	z_arm_cpu_idle_init();
 801348e: f7f3 f99f    	bl	0x80067d0 <z_arm_cpu_idle_init> @ imm = #-0xccc2
; 	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 8013492: 4b10         	ldr	r3, [pc, #0x40]         @ 0x80134d4 <z_cstart+0xcc>
 8013494: f04f 32ff    	mov.w	r2, #0xffffffff
 8013498: 629a         	str	r2, [r3, #0x28]
; 	SCB->HFSR = 0xffffffff;
 801349a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80134d4 <z_cstart+0xcc>
 801349c: f04f 32ff    	mov.w	r2, #0xffffffff
 80134a0: 62da         	str	r2, [r3, #0x2c]
; }
 80134a2: bf00         	nop
; }
 80134a4: bf00         	nop
; 	LOG_CORE_INIT();
 80134a6: f7f1 f93b    	bl	0x8004720 <log_core_init> @ imm = #-0xed8a
; 	z_dummy_thread_init(&_thread_dummy);
 80134aa: 480b         	ldr	r0, [pc, #0x2c]         @ 0x80134d8 <z_cstart+0xd0>
 80134ac: f7ff fdf6    	bl	0x801309c <z_dummy_thread_init> @ imm = #-0x414
; 	z_device_state_init();
 80134b0: f7ff fc60    	bl	0x8012d74 <z_device_state_init> @ imm = #-0x740
; 	soc_early_init_hook();
 80134b4: f7f0 ff3a    	bl	0x800432c <soc_early_init_hook> @ imm = #-0xf18c
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
 80134b8: 2001         	movs	r0, #0x1
 80134ba: f7ff fe8b    	bl	0x80131d4 <z_sys_init_run_level> @ imm = #-0x2ea
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 80134be: 2002         	movs	r0, #0x2
 80134c0: f7ff fe88    	bl	0x80131d4 <z_sys_init_run_level> @ imm = #-0x2f0
; 	switch_to_main_thread(prepare_multithreading());
 80134c4: f7ff ff5e    	bl	0x8013384 <prepare_multithreading> @ imm = #-0x144
 80134c8: 4603         	mov	r3, r0
 80134ca: 4618         	mov	r0, r3
 80134cc: f7ff ff8e    	bl	0x80133ec <switch_to_main_thread> @ imm = #-0xe4

080134d0 <$d>:
 80134d0: 48 53 00 20  	.word	0x20005348
 80134d4: 00 ed 00 e0  	.word	0xe000ed00
 80134d8: 58 29 00 20  	.word	0x20002958

080134dc <statics_init>:
; {
 80134dc: b580         	push	{r7, lr}
 80134de: b082         	sub	sp, #0x8
 80134e0: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(k_heap, heap) {
 80134e2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x801351c <statics_init+0x40>
 80134e4: 607b         	str	r3, [r7, #0x4]
 80134e6: e00a         	b	0x80134fe <statics_init+0x22> @ imm = #0x14
; 			k_heap_init(heap, heap->heap.init_mem, heap->heap.init_bytes);
 80134e8: 687b         	ldr	r3, [r7, #0x4]
 80134ea: 6859         	ldr	r1, [r3, #0x4]
 80134ec: 687b         	ldr	r3, [r7, #0x4]
 80134ee: 689b         	ldr	r3, [r3, #0x8]
 80134f0: 461a         	mov	r2, r3
 80134f2: 6878         	ldr	r0, [r7, #0x4]
 80134f4: f011 f96f    	bl	0x80247d6 <k_heap_init> @ imm = #0x112de
; 	STRUCT_SECTION_FOREACH(k_heap, heap) {
 80134f8: 687b         	ldr	r3, [r7, #0x4]
 80134fa: 3314         	adds	r3, #0x14
 80134fc: 607b         	str	r3, [r7, #0x4]
 80134fe: 687b         	ldr	r3, [r7, #0x4]
 8013500: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8013520 <statics_init+0x44>
 8013502: 4293         	cmp	r3, r2
 8013504: bf34         	ite	lo
 8013506: 2301         	movlo	r3, #0x1
 8013508: 2300         	movhs	r3, #0x0
 801350a: b2db         	uxtb	r3, r3
 801350c: 2b00         	cmp	r3, #0x0
 801350e: d1eb         	bne	0x80134e8 <statics_init+0xc> @ imm = #-0x2a
; 	return 0;
 8013510: 2300         	movs	r3, #0x0
; }
 8013512: 4618         	mov	r0, r3
 8013514: 3708         	adds	r7, #0x8
 8013516: 46bd         	mov	sp, r7
 8013518: bd80         	pop	{r7, pc}
 801351a: bf00         	nop

0801351c <$d>:
 801351c: 4c 0c 00 20  	.word	0x20000c4c
 8013520: 60 0c 00 20  	.word	0x20000c60

08013524 <init_mem_slab_obj_core_list>:
; {
 8013524: b580         	push	{r7, lr}
 8013526: b082         	sub	sp, #0x8
 8013528: af00         	add	r7, sp, #0x0
; 	int rc = 0;
 801352a: 2300         	movs	r3, #0x0
 801352c: 607b         	str	r3, [r7, #0x4]
; 	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 801352e: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8013570 <init_mem_slab_obj_core_list+0x4c>
 8013530: 603b         	str	r3, [r7]
 8013532: e00c         	b	0x801354e <init_mem_slab_obj_core_list+0x2a> @ imm = #0x18
; 		rc = create_free_list(slab);
 8013534: 6838         	ldr	r0, [r7]
 8013536: f011 fad1    	bl	0x8024adc <create_free_list> @ imm = #0x115a2
 801353a: 6078         	str	r0, [r7, #0x4]
; 		if (rc < 0) {
 801353c: 687b         	ldr	r3, [r7, #0x4]
 801353e: 2b00         	cmp	r3, #0x0
 8013540: db0f         	blt	0x8013562 <init_mem_slab_obj_core_list+0x3e> @ imm = #0x1e
; 		k_object_init(slab);
 8013542: 6838         	ldr	r0, [r7]
 8013544: f011 fa87    	bl	0x8024a56 <k_object_init> @ imm = #0x1150e
; 	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 8013548: 683b         	ldr	r3, [r7]
 801354a: 331c         	adds	r3, #0x1c
 801354c: 603b         	str	r3, [r7]
 801354e: 683b         	ldr	r3, [r7]
 8013550: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8013574 <init_mem_slab_obj_core_list+0x50>
 8013552: 4293         	cmp	r3, r2
 8013554: bf34         	ite	lo
 8013556: 2301         	movlo	r3, #0x1
 8013558: 2300         	movhs	r3, #0x0
 801355a: b2db         	uxtb	r3, r3
 801355c: 2b00         	cmp	r3, #0x0
 801355e: d1e9         	bne	0x8013534 <init_mem_slab_obj_core_list+0x10> @ imm = #-0x2e
; out:
 8013560: e000         	b	0x8013564 <init_mem_slab_obj_core_list+0x40> @ imm = #0x0
; 			goto out;
 8013562: bf00         	nop
; 	return rc;
 8013564: 687b         	ldr	r3, [r7, #0x4]
; }
 8013566: 4618         	mov	r0, r3
 8013568: 3708         	adds	r7, #0x8
 801356a: 46bd         	mov	sp, r7
 801356c: bd80         	pop	{r7, pc}
 801356e: bf00         	nop

08013570 <$d>:
 8013570: 30 0c 00 20  	.word	0x20000c30
 8013574: 4c 0c 00 20  	.word	0x20000c4c

08013578 <k_mem_slab_alloc>:
; {
 8013578: b580         	push	{r7, lr}
 801357a: b094         	sub	sp, #0x50
 801357c: af02         	add	r7, sp, #0x8
 801357e: 60f8         	str	r0, [r7, #0xc]
 8013580: 60b9         	str	r1, [r7, #0x8]
 8013582: e9c7 2300    	strd	r2, r3, [r7]
; 	k_spinlock_key_t key = k_spin_lock(&slab->lock);
 8013586: 68fb         	ldr	r3, [r7, #0xc]
 8013588: 3308         	adds	r3, #0x8
 801358a: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801358c: f3ef 8311    	mrs	r3, basepri
 8013590: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 8013592: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 8013594: 63bb         	str	r3, [r7, #0x38]
 8013596: 2310         	movs	r3, #0x10
 8013598: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801359a: 6b7b         	ldr	r3, [r7, #0x34]
 801359c: f383 8812    	msr	basepri_max, r3
; }
 80135a0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80135a2: f3bf 8f6f    	isb	sy
; }
 80135a6: bf00         	nop
; 	return key;
 80135a8: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 80135aa: 613b         	str	r3, [r7, #0x10]
 80135ac: 6c3b         	ldr	r3, [r7, #0x40]
 80135ae: 633b         	str	r3, [r7, #0x30]
; }
 80135b0: bf00         	nop
 80135b2: 6c3b         	ldr	r3, [r7, #0x40]
 80135b4: 62fb         	str	r3, [r7, #0x2c]
; }
 80135b6: bf00         	nop
; 	return k;
 80135b8: 693b         	ldr	r3, [r7, #0x10]
 80135ba: 61bb         	str	r3, [r7, #0x18]
; 	if (slab->free_list != NULL) {
 80135bc: 68fb         	ldr	r3, [r7, #0xc]
 80135be: 68db         	ldr	r3, [r3, #0xc]
 80135c0: 2b00         	cmp	r3, #0x0
 80135c2: d010         	beq	0x80135e6 <k_mem_slab_alloc+0x6e> @ imm = #0x20
; 		*mem = slab->free_list;
 80135c4: 68fb         	ldr	r3, [r7, #0xc]
 80135c6: 68da         	ldr	r2, [r3, #0xc]
 80135c8: 68bb         	ldr	r3, [r7, #0x8]
 80135ca: 601a         	str	r2, [r3]
; 		slab->free_list = *(char **)(slab->free_list);
 80135cc: 68fb         	ldr	r3, [r7, #0xc]
 80135ce: 68db         	ldr	r3, [r3, #0xc]
 80135d0: 681a         	ldr	r2, [r3]
 80135d2: 68fb         	ldr	r3, [r7, #0xc]
 80135d4: 60da         	str	r2, [r3, #0xc]
; 		slab->info.num_used++;
 80135d6: 68fb         	ldr	r3, [r7, #0xc]
 80135d8: 699b         	ldr	r3, [r3, #0x18]
 80135da: 1c5a         	adds	r2, r3, #0x1
 80135dc: 68fb         	ldr	r3, [r7, #0xc]
 80135de: 619a         	str	r2, [r3, #0x18]
; 		result = 0;
 80135e0: 2300         	movs	r3, #0x0
 80135e2: 647b         	str	r3, [r7, #0x44]
 80135e4: e029         	b	0x801363a <k_mem_slab_alloc+0xc2> @ imm = #0x52
; 	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
 80135e6: e9d7 2300    	ldrd	r2, r3, [r7]
 80135ea: f04f 0000    	mov.w	r0, #0x0
 80135ee: f04f 0100    	mov.w	r1, #0x0
 80135f2: 428b         	cmp	r3, r1
 80135f4: bf08         	it	eq
 80135f6: 4282         	cmpeq	r2, r0
 80135f8: d106         	bne	0x8013608 <k_mem_slab_alloc+0x90> @ imm = #0xc
; 		*mem = NULL;
 80135fa: 68bb         	ldr	r3, [r7, #0x8]
 80135fc: 2200         	movs	r2, #0x0
 80135fe: 601a         	str	r2, [r3]
; 		result = -ENOMEM;
 8013600: f06f 030b    	mvn	r3, #0xb
 8013604: 647b         	str	r3, [r7, #0x44]
 8013606: e018         	b	0x801363a <k_mem_slab_alloc+0xc2> @ imm = #0x30
; 		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
 8013608: 68fb         	ldr	r3, [r7, #0xc]
 801360a: f103 0008    	add.w	r0, r3, #0x8
 801360e: 68f9         	ldr	r1, [r7, #0xc]
 8013610: e9d7 2300    	ldrd	r2, r3, [r7]
 8013614: e9cd 2300    	strd	r2, r3, [sp]
 8013618: 460a         	mov	r2, r1
 801361a: 69b9         	ldr	r1, [r7, #0x18]
 801361c: f002 f960    	bl	0x80158e0 <z_pend_curr> @ imm = #0x22c0
 8013620: 6478         	str	r0, [r7, #0x44]
; 		if (result == 0) {
 8013622: 6c7b         	ldr	r3, [r7, #0x44]
 8013624: 2b00         	cmp	r3, #0x0
 8013626: d106         	bne	0x8013636 <k_mem_slab_alloc+0xbe> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8013628: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8013668 <k_mem_slab_alloc+0xf0>
 801362a: 689b         	ldr	r3, [r3, #0x8]
 801362c: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 801362e: 6abb         	ldr	r3, [r7, #0x28]
; 			*mem = arch_current_thread()->base.swap_data;
 8013630: 695a         	ldr	r2, [r3, #0x14]
 8013632: 68bb         	ldr	r3, [r7, #0x8]
 8013634: 601a         	str	r2, [r3]
; 		return result;
 8013636: 6c7b         	ldr	r3, [r7, #0x44]
 8013638: e012         	b	0x8013660 <k_mem_slab_alloc+0xe8> @ imm = #0x24
; 	k_spin_unlock(&slab->lock, key);
 801363a: 68fb         	ldr	r3, [r7, #0xc]
 801363c: 3308         	adds	r3, #0x8
 801363e: 627b         	str	r3, [r7, #0x24]
 8013640: 69bb         	ldr	r3, [r7, #0x18]
 8013642: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8013644: 697b         	ldr	r3, [r7, #0x14]
 8013646: 623b         	str	r3, [r7, #0x20]
 8013648: 6a3b         	ldr	r3, [r7, #0x20]
 801364a: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801364c: 69fb         	ldr	r3, [r7, #0x1c]
 801364e: f383 8811    	msr	basepri, r3
; }
 8013652: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013654: f3bf 8f6f    	isb	sy
; }
 8013658: bf00         	nop
; }
 801365a: bf00         	nop
; }
 801365c: bf00         	nop
; 	return result;
 801365e: 6c7b         	ldr	r3, [r7, #0x44]
; }
 8013660: 4618         	mov	r0, r3
 8013662: 3748         	adds	r7, #0x48
 8013664: 46bd         	mov	sp, r7
 8013666: bd80         	pop	{r7, pc}

08013668 <$d>:
 8013668: a8 25 00 20  	.word	0x200025a8

0801366c <z_impl_k_msgq_put>:
; {
 801366c: b580         	push	{r7, lr}
 801366e: b09c         	sub	sp, #0x70
 8013670: af02         	add	r7, sp, #0x8
 8013672: 60f8         	str	r0, [r7, #0xc]
 8013674: 60b9         	str	r1, [r7, #0x8]
 8013676: e9c7 2300    	strd	r2, r3, [r7]
; 	key = k_spin_lock(&msgq->lock);
 801367a: 68fb         	ldr	r3, [r7, #0xc]
 801367c: 3308         	adds	r3, #0x8
 801367e: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8013680: f3ef 8311    	mrs	r3, basepri
 8013684: 65bb         	str	r3, [r7, #0x58]
;   return(result);
 8013686: 6dbb         	ldr	r3, [r7, #0x58]
; 	key = __get_BASEPRI();
 8013688: 657b         	str	r3, [r7, #0x54]
 801368a: 2310         	movs	r3, #0x10
 801368c: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801368e: 6d3b         	ldr	r3, [r7, #0x50]
 8013690: f383 8812    	msr	basepri_max, r3
; }
 8013694: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013696: f3bf 8f6f    	isb	sy
; }
 801369a: bf00         	nop
; 	return key;
 801369c: 6d7b         	ldr	r3, [r7, #0x54]
; 	k.key = arch_irq_lock();
 801369e: 613b         	str	r3, [r7, #0x10]
 80136a0: 6dfb         	ldr	r3, [r7, #0x5c]
 80136a2: 64fb         	str	r3, [r7, #0x4c]
; }
 80136a4: bf00         	nop
 80136a6: 6dfb         	ldr	r3, [r7, #0x5c]
 80136a8: 64bb         	str	r3, [r7, #0x48]
; }
 80136aa: bf00         	nop
; 	return k;
 80136ac: 693b         	ldr	r3, [r7, #0x10]
 80136ae: 61bb         	str	r3, [r7, #0x18]
; 	if (msgq->used_msgs < msgq->max_msgs) {
 80136b0: 68fb         	ldr	r3, [r7, #0xc]
 80136b2: 6a1a         	ldr	r2, [r3, #0x20]
 80136b4: 68fb         	ldr	r3, [r7, #0xc]
 80136b6: 68db         	ldr	r3, [r3, #0xc]
 80136b8: 429a         	cmp	r2, r3
 80136ba: d267         	bhs	0x801378c <z_impl_k_msgq_put+0x120> @ imm = #0xce
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 80136bc: 68fb         	ldr	r3, [r7, #0xc]
 80136be: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 80136c0: 2300         	movs	r3, #0x0
 80136c2: 643b         	str	r3, [r7, #0x40]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80136c4: 6c7b         	ldr	r3, [r7, #0x44]
 80136c6: 63fb         	str	r3, [r7, #0x3c]
; 	struct k_thread *thread = NULL;
 80136c8: 2300         	movs	r3, #0x0
 80136ca: 63bb         	str	r3, [r7, #0x38]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 80136cc: 6bf8         	ldr	r0, [r7, #0x3c]
 80136ce: f011 fb5b    	bl	0x8024d88 <sys_dlist_peek_head> @ imm = #0x116b6
 80136d2: 6378         	str	r0, [r7, #0x34]
; 	if (n != NULL) {
 80136d4: 6b7b         	ldr	r3, [r7, #0x34]
 80136d6: 2b00         	cmp	r3, #0x0
 80136d8: d001         	beq	0x80136de <z_impl_k_msgq_put+0x72> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80136da: 6b7b         	ldr	r3, [r7, #0x34]
 80136dc: 63bb         	str	r3, [r7, #0x38]
; 	return thread;
 80136de: 6bbb         	ldr	r3, [r7, #0x38]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80136e0: 643b         	str	r3, [r7, #0x40]
; 		if (unlikely(thread != NULL)) {
 80136e2: 6c3b         	ldr	r3, [r7, #0x40]
 80136e4: 2b00         	cmp	r3, #0x0
 80136e6: bf14         	ite	ne
 80136e8: 2301         	movne	r3, #0x1
 80136ea: 2300         	moveq	r3, #0x0
 80136ec: b2db         	uxtb	r3, r3
 80136ee: 2b00         	cmp	r3, #0x0
 80136f0: d005         	beq	0x80136fe <z_impl_k_msgq_put+0x92> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 80136f2: 6c38         	ldr	r0, [r7, #0x40]
 80136f4: f011 fb90    	bl	0x8024e18 <unpend_thread_no_timeout> @ imm = #0x11720
; 			(void)z_abort_thread_timeout(thread);
 80136f8: 6c38         	ldr	r0, [r7, #0x40]
 80136fa: f011 fb6e    	bl	0x8024dda <z_abort_thread_timeout> @ imm = #0x116dc
; 	return thread;
 80136fe: 6c3b         	ldr	r3, [r7, #0x40]
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 8013700: 663b         	str	r3, [r7, #0x60]
; 		if (unlikely(pending_thread != NULL)) {
 8013702: 6e3b         	ldr	r3, [r7, #0x60]
 8013704: 2b00         	cmp	r3, #0x0
 8013706: bf14         	ite	ne
 8013708: 2301         	movne	r3, #0x1
 801370a: 2300         	moveq	r3, #0x0
 801370c: b2db         	uxtb	r3, r3
 801370e: 2b00         	cmp	r3, #0x0
 8013710: d01b         	beq	0x801374a <z_impl_k_msgq_put+0xde> @ imm = #0x36
; 			(void)memcpy(pending_thread->base.swap_data, data,
 8013712: 6e3b         	ldr	r3, [r7, #0x60]
 8013714: 6958         	ldr	r0, [r3, #0x14]
 8013716: 68fb         	ldr	r3, [r7, #0xc]
 8013718: 689b         	ldr	r3, [r3, #0x8]
 801371a: 461a         	mov	r2, r3
 801371c: 68b9         	ldr	r1, [r7, #0x8]
 801371e: f013 fee5    	bl	0x80274ec <memcpy>      @ imm = #0x13dca
 8013722: 6e3b         	ldr	r3, [r7, #0x60]
 8013724: 633b         	str	r3, [r7, #0x30]
 8013726: 2300         	movs	r3, #0x0
 8013728: 62fb         	str	r3, [r7, #0x2c]
; 	thread->arch.swap_return_value = value;
 801372a: 6b3b         	ldr	r3, [r7, #0x30]
 801372c: 6afa         	ldr	r2, [r7, #0x2c]
 801372e: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8013732: bf00         	nop
; 			z_ready_thread(pending_thread);
 8013734: 6e38         	ldr	r0, [r7, #0x60]
 8013736: f001 fcd1    	bl	0x80150dc <z_ready_thread> @ imm = #0x19a2
; 			z_reschedule(&msgq->lock, key);
 801373a: 68fb         	ldr	r3, [r7, #0xc]
 801373c: 3308         	adds	r3, #0x8
 801373e: 69b9         	ldr	r1, [r7, #0x18]
 8013740: 4618         	mov	r0, r3
 8013742: f013 fa13    	bl	0x8026b6c <z_reschedule> @ imm = #0x13426
; 			return 0;
 8013746: 2300         	movs	r3, #0x0
 8013748: e056         	b	0x80137f8 <z_impl_k_msgq_put+0x18c> @ imm = #0xac
; 			(void)memcpy(msgq->write_ptr, (char *)data, msgq->msg_size);
 801374a: 68fb         	ldr	r3, [r7, #0xc]
 801374c: 69d8         	ldr	r0, [r3, #0x1c]
 801374e: 68fb         	ldr	r3, [r7, #0xc]
 8013750: 689b         	ldr	r3, [r3, #0x8]
 8013752: 461a         	mov	r2, r3
 8013754: 68b9         	ldr	r1, [r7, #0x8]
 8013756: f013 fec9    	bl	0x80274ec <memcpy>      @ imm = #0x13d92
; 			msgq->write_ptr += msgq->msg_size;
 801375a: 68fb         	ldr	r3, [r7, #0xc]
 801375c: 69da         	ldr	r2, [r3, #0x1c]
 801375e: 68fb         	ldr	r3, [r7, #0xc]
 8013760: 689b         	ldr	r3, [r3, #0x8]
 8013762: 441a         	add	r2, r3
 8013764: 68fb         	ldr	r3, [r7, #0xc]
 8013766: 61da         	str	r2, [r3, #0x1c]
; 			if (msgq->write_ptr == msgq->buffer_end) {
 8013768: 68fb         	ldr	r3, [r7, #0xc]
 801376a: 69da         	ldr	r2, [r3, #0x1c]
 801376c: 68fb         	ldr	r3, [r7, #0xc]
 801376e: 695b         	ldr	r3, [r3, #0x14]
 8013770: 429a         	cmp	r2, r3
 8013772: d103         	bne	0x801377c <z_impl_k_msgq_put+0x110> @ imm = #0x6
; 				msgq->write_ptr = msgq->buffer_start;
 8013774: 68fb         	ldr	r3, [r7, #0xc]
 8013776: 691a         	ldr	r2, [r3, #0x10]
 8013778: 68fb         	ldr	r3, [r7, #0xc]
 801377a: 61da         	str	r2, [r3, #0x1c]
; 			msgq->used_msgs++;
 801377c: 68fb         	ldr	r3, [r7, #0xc]
 801377e: 6a1b         	ldr	r3, [r3, #0x20]
 8013780: 1c5a         	adds	r2, r3, #0x1
 8013782: 68fb         	ldr	r3, [r7, #0xc]
 8013784: 621a         	str	r2, [r3, #0x20]
; 		result = 0;
 8013786: 2300         	movs	r3, #0x0
 8013788: 667b         	str	r3, [r7, #0x64]
 801378a: e022         	b	0x80137d2 <z_impl_k_msgq_put+0x166> @ imm = #0x44
; 	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 801378c: e9d7 2300    	ldrd	r2, r3, [r7]
 8013790: f04f 0000    	mov.w	r0, #0x0
 8013794: f04f 0100    	mov.w	r1, #0x0
 8013798: 428b         	cmp	r3, r1
 801379a: bf08         	it	eq
 801379c: 4282         	cmpeq	r2, r0
 801379e: d103         	bne	0x80137a8 <z_impl_k_msgq_put+0x13c> @ imm = #0x6
; 		result = -ENOMSG;
 80137a0: f06f 0322    	mvn	r3, #0x22
 80137a4: 667b         	str	r3, [r7, #0x64]
 80137a6: e014         	b	0x80137d2 <z_impl_k_msgq_put+0x166> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80137a8: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8013800 <z_impl_k_msgq_put+0x194>
 80137aa: 689b         	ldr	r3, [r3, #0x8]
 80137ac: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 80137ae: 6abb         	ldr	r3, [r7, #0x28]
; 		arch_current_thread()->base.swap_data = (void *) data;
 80137b0: 68ba         	ldr	r2, [r7, #0x8]
 80137b2: 615a         	str	r2, [r3, #0x14]
; 		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
 80137b4: 68fb         	ldr	r3, [r7, #0xc]
 80137b6: f103 0008    	add.w	r0, r3, #0x8
 80137ba: 68f9         	ldr	r1, [r7, #0xc]
 80137bc: e9d7 2300    	ldrd	r2, r3, [r7]
 80137c0: e9cd 2300    	strd	r2, r3, [sp]
 80137c4: 460a         	mov	r2, r1
 80137c6: 69b9         	ldr	r1, [r7, #0x18]
 80137c8: f002 f88a    	bl	0x80158e0 <z_pend_curr> @ imm = #0x2114
 80137cc: 6678         	str	r0, [r7, #0x64]
; 		return result;
 80137ce: 6e7b         	ldr	r3, [r7, #0x64]
 80137d0: e012         	b	0x80137f8 <z_impl_k_msgq_put+0x18c> @ imm = #0x24
; 	k_spin_unlock(&msgq->lock, key);
 80137d2: 68fb         	ldr	r3, [r7, #0xc]
 80137d4: 3308         	adds	r3, #0x8
 80137d6: 627b         	str	r3, [r7, #0x24]
 80137d8: 69bb         	ldr	r3, [r7, #0x18]
 80137da: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 80137dc: 697b         	ldr	r3, [r7, #0x14]
 80137de: 623b         	str	r3, [r7, #0x20]
 80137e0: 6a3b         	ldr	r3, [r7, #0x20]
 80137e2: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80137e4: 69fb         	ldr	r3, [r7, #0x1c]
 80137e6: f383 8811    	msr	basepri, r3
; }
 80137ea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80137ec: f3bf 8f6f    	isb	sy
; }
 80137f0: bf00         	nop
; }
 80137f2: bf00         	nop
; }
 80137f4: bf00         	nop
; 	return result;
 80137f6: 6e7b         	ldr	r3, [r7, #0x64]
; }
 80137f8: 4618         	mov	r0, r3
 80137fa: 3768         	adds	r7, #0x68
 80137fc: 46bd         	mov	sp, r7
 80137fe: bd80         	pop	{r7, pc}

08013800 <$d>:
 8013800: a8 25 00 20  	.word	0x200025a8

08013804 <adjust_owner_prio>:
; {
 8013804: b5b0         	push	{r4, r5, r7, lr}
 8013806: b08c         	sub	sp, #0x30
 8013808: af08         	add	r7, sp, #0x20
 801380a: 6078         	str	r0, [r7, #0x4]
 801380c: 6039         	str	r1, [r7]
; 	if (mutex->owner->base.prio != new_prio) {
 801380e: 687b         	ldr	r3, [r7, #0x4]
 8013810: 689b         	ldr	r3, [r3, #0x8]
 8013812: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8013816: 461a         	mov	r2, r3
 8013818: 683b         	ldr	r3, [r7]
 801381a: 4293         	cmp	r3, r2
 801381c: d03a         	beq	0x8013894 <adjust_owner_prio+0x90> @ imm = #0x74
; 		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
 801381e: 2303         	movs	r3, #0x3
 8013820: 2b03         	cmp	r3, #0x3
 8013822: d92f         	bls	0x8013884 <adjust_owner_prio+0x80> @ imm = #0x5e
 8013824: 2301         	movs	r3, #0x1
 8013826: 72fb         	strb	r3, [r7, #0xb]
 8013828: 7afb         	ldrb	r3, [r7, #0xb]
 801382a: f083 0301    	eor	r3, r3, #0x1
 801382e: b2db         	uxtb	r3, r3
 8013830: 2b00         	cmp	r3, #0x0
 8013832: d127         	bne	0x8013884 <adjust_owner_prio+0x80> @ imm = #0x4e
 8013834: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x80138a0 <adjust_owner_prio+0x9c>
 8013836: 681d         	ldr	r5, [r3]
 8013838: 687b         	ldr	r3, [r7, #0x4]
 801383a: 689c         	ldr	r4, [r3, #0x8]
 801383c: 687b         	ldr	r3, [r7, #0x4]
 801383e: 689b         	ldr	r3, [r3, #0x8]
 8013840: 4618         	mov	r0, r3
 8013842: f011 fbcd    	bl	0x8024fe0 <z_is_thread_ready> @ imm = #0x1179a
 8013846: 4603         	mov	r3, r0
 8013848: 2b00         	cmp	r3, #0x0
 801384a: d001         	beq	0x8013850 <adjust_owner_prio+0x4c> @ imm = #0x2
 801384c: 2379         	movs	r3, #0x79
 801384e: e000         	b	0x8013852 <adjust_owner_prio+0x4e> @ imm = #0x0
 8013850: 236e         	movs	r3, #0x6e
 8013852: 687a         	ldr	r2, [r7, #0x4]
 8013854: 6892         	ldr	r2, [r2, #0x8]
 8013856: f992 200e    	ldrsb.w	r2, [r2, #0xe]
 801385a: 9207         	str	r2, [sp, #0x1c]
 801385c: 683a         	ldr	r2, [r7]
 801385e: 9206         	str	r2, [sp, #0x18]
 8013860: 9305         	str	r3, [sp, #0x14]
 8013862: 9404         	str	r4, [sp, #0x10]
 8013864: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80138a4 <adjust_owner_prio+0xa0>
 8013866: 9303         	str	r3, [sp, #0xc]
 8013868: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80138a8 <adjust_owner_prio+0xa4>
 801386a: 9302         	str	r3, [sp, #0x8]
 801386c: 2308         	movs	r3, #0x8
 801386e: 9301         	str	r3, [sp, #0x4]
 8013870: 2300         	movs	r3, #0x0
 8013872: 9300         	str	r3, [sp]
 8013874: 2300         	movs	r3, #0x0
 8013876: 2204         	movs	r2, #0x4
 8013878: 4629         	mov	r1, r5
 801387a: 2000         	movs	r0, #0x0
 801387c: f011 fc57    	bl	0x802512e <z_log_msg_runtime_create> @ imm = #0x118ae
 8013880: 2300         	movs	r3, #0x0
 8013882: 60fb         	str	r3, [r7, #0xc]
; 		return z_thread_prio_set(mutex->owner, new_prio);
 8013884: 687b         	ldr	r3, [r7, #0x4]
 8013886: 689b         	ldr	r3, [r3, #0x8]
 8013888: 6839         	ldr	r1, [r7]
 801388a: 4618         	mov	r0, r3
 801388c: f002 f8c4    	bl	0x8015a18 <z_thread_prio_set> @ imm = #0x2188
 8013890: 4603         	mov	r3, r0
 8013892: e000         	b	0x8013896 <adjust_owner_prio+0x92> @ imm = #0x0
; 	return false;
 8013894: 2300         	movs	r3, #0x0
; }
 8013896: 4618         	mov	r0, r3
 8013898: 3710         	adds	r7, #0x10
 801389a: 46bd         	mov	sp, r7
 801389c: bdb0         	pop	{r4, r5, r7, pc}
 801389e: bf00         	nop

080138a0 <$d>:
 80138a0: 60 0b 00 20  	.word	0x20000b60
 80138a4: 38 bc 02 08  	.word	0x0802bc38
 80138a8: d0 a1 02 08  	.word	0x0802a1d0

080138ac <z_impl_k_mutex_lock>:
; {
 80138ac: b580         	push	{r7, lr}
 80138ae: b0be         	sub	sp, #0xf8
 80138b0: af08         	add	r7, sp, #0x20
 80138b2: 60f8         	str	r0, [r7, #0xc]
 80138b4: e9c7 2300    	strd	r2, r3, [r7]
; 	bool resched = false;
 80138b8: 2300         	movs	r3, #0x0
 80138ba: f887 30d7    	strb.w	r3, [r7, #0xd7]
 80138be: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8013b58 <z_impl_k_mutex_lock+0x2ac>
 80138c0: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80138c4: f3ef 8311    	mrs	r3, basepri
 80138c8: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 80138cc: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 80138d0: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80138d4: 2310         	movs	r3, #0x10
 80138d6: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80138da: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80138de: f383 8812    	msr	basepri_max, r3
; }
 80138e2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80138e4: f3bf 8f6f    	isb	sy
; }
 80138e8: bf00         	nop
; 	return key;
 80138ea: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 80138ee: 617b         	str	r3, [r7, #0x14]
 80138f0: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 80138f4: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 80138f8: bf00         	nop
 80138fa: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 80138fe: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 8013902: bf00         	nop
; 	return k;
 8013904: 697b         	ldr	r3, [r7, #0x14]
 8013906: 627b         	str	r3, [r7, #0x24]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 8013908: 68fb         	ldr	r3, [r7, #0xc]
 801390a: 68db         	ldr	r3, [r3, #0xc]
 801390c: 2b00         	cmp	r3, #0x0
 801390e: bf0c         	ite	eq
 8013910: 2301         	moveq	r3, #0x1
 8013912: 2300         	movne	r3, #0x0
 8013914: b2db         	uxtb	r3, r3
 8013916: 2b00         	cmp	r3, #0x0
 8013918: d10c         	bne	0x8013934 <z_impl_k_mutex_lock+0x88> @ imm = #0x18
 801391a: 68fb         	ldr	r3, [r7, #0xc]
 801391c: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801391e: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8013b5c <z_impl_k_mutex_lock+0x2b0>
 8013920: 689b         	ldr	r3, [r3, #0x8]
 8013922: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 8013924: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 8013926: 429a         	cmp	r2, r3
 8013928: bf0c         	ite	eq
 801392a: 2301         	moveq	r3, #0x1
 801392c: 2300         	movne	r3, #0x0
 801392e: b2db         	uxtb	r3, r3
 8013930: 2b00         	cmp	r3, #0x0
 8013932: d001         	beq	0x8013938 <z_impl_k_mutex_lock+0x8c> @ imm = #0x2
 8013934: 2301         	movs	r3, #0x1
 8013936: e000         	b	0x801393a <z_impl_k_mutex_lock+0x8e> @ imm = #0x0
 8013938: 2300         	movs	r3, #0x0
 801393a: 2b00         	cmp	r3, #0x0
 801393c: d059         	beq	0x80139f2 <z_impl_k_mutex_lock+0x146> @ imm = #0xb2
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 801393e: 68fb         	ldr	r3, [r7, #0xc]
 8013940: 68db         	ldr	r3, [r3, #0xc]
; 					arch_current_thread()->base.prio :
 8013942: 2b00         	cmp	r3, #0x0
 8013944: d106         	bne	0x8013954 <z_impl_k_mutex_lock+0xa8> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8013946: 4b85         	ldr	r3, [pc, #0x214]        @ 0x8013b5c <z_impl_k_mutex_lock+0x2b0>
 8013948: 689b         	ldr	r3, [r3, #0x8]
 801394a: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 801394c: 6fbb         	ldr	r3, [r7, #0x78]
; 					arch_current_thread()->base.prio :
 801394e: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8013952: e001         	b	0x8013958 <z_impl_k_mutex_lock+0xac> @ imm = #0x2
 8013954: 68fb         	ldr	r3, [r7, #0xc]
 8013956: 691b         	ldr	r3, [r3, #0x10]
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 8013958: 68fa         	ldr	r2, [r7, #0xc]
 801395a: 6113         	str	r3, [r2, #0x10]
; 		mutex->lock_count++;
 801395c: 68fb         	ldr	r3, [r7, #0xc]
 801395e: 68db         	ldr	r3, [r3, #0xc]
 8013960: 1c5a         	adds	r2, r3, #0x1
 8013962: 68fb         	ldr	r3, [r7, #0xc]
 8013964: 60da         	str	r2, [r3, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8013966: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x8013b5c <z_impl_k_mutex_lock+0x2b0>
 8013968: 689b         	ldr	r3, [r3, #0x8]
 801396a: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 801396c: 6f7a         	ldr	r2, [r7, #0x74]
; 		mutex->owner = arch_current_thread();
 801396e: 68fb         	ldr	r3, [r7, #0xc]
 8013970: 609a         	str	r2, [r3, #0x8]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 8013972: 2303         	movs	r3, #0x3
 8013974: 2b03         	cmp	r3, #0x3
 8013976: d929         	bls	0x80139cc <z_impl_k_mutex_lock+0x120> @ imm = #0x52
 8013978: 2301         	movs	r3, #0x1
 801397a: f887 309f    	strb.w	r3, [r7, #0x9f]
 801397e: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 8013982: f083 0301    	eor	r3, r3, #0x1
 8013986: b2db         	uxtb	r3, r3
 8013988: 2b00         	cmp	r3, #0x0
 801398a: d11f         	bne	0x80139cc <z_impl_k_mutex_lock+0x120> @ imm = #0x3e
 801398c: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8013b60 <z_impl_k_mutex_lock+0x2b4>
 801398e: 6818         	ldr	r0, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8013990: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8013b5c <z_impl_k_mutex_lock+0x2b0>
 8013992: 689b         	ldr	r3, [r3, #0x8]
 8013994: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 8013996: 6f3b         	ldr	r3, [r7, #0x70]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 8013998: 68fa         	ldr	r2, [r7, #0xc]
 801399a: 68d2         	ldr	r2, [r2, #0xc]
 801399c: 68f9         	ldr	r1, [r7, #0xc]
 801399e: 6909         	ldr	r1, [r1, #0x10]
 80139a0: 9107         	str	r1, [sp, #0x1c]
 80139a2: 9206         	str	r2, [sp, #0x18]
 80139a4: 68fa         	ldr	r2, [r7, #0xc]
 80139a6: 9205         	str	r2, [sp, #0x14]
 80139a8: 9304         	str	r3, [sp, #0x10]
 80139aa: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8013b64 <z_impl_k_mutex_lock+0x2b8>
 80139ac: 9303         	str	r3, [sp, #0xc]
 80139ae: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8013b68 <z_impl_k_mutex_lock+0x2bc>
 80139b0: 9302         	str	r3, [sp, #0x8]
 80139b2: 2308         	movs	r3, #0x8
 80139b4: 9301         	str	r3, [sp, #0x4]
 80139b6: 2300         	movs	r3, #0x0
 80139b8: 9300         	str	r3, [sp]
 80139ba: 2300         	movs	r3, #0x0
 80139bc: 2204         	movs	r2, #0x4
 80139be: 4601         	mov	r1, r0
 80139c0: 2000         	movs	r0, #0x0
 80139c2: f011 fbb4    	bl	0x802512e <z_log_msg_runtime_create> @ imm = #0x11768
 80139c6: 2300         	movs	r3, #0x0
 80139c8: f8c7 3098    	str.w	r3, [r7, #0x98]
 80139cc: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8013b58 <z_impl_k_mutex_lock+0x2ac>
 80139ce: 66fb         	str	r3, [r7, #0x6c]
 80139d0: 6a7b         	ldr	r3, [r7, #0x24]
 80139d2: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 80139d4: 69bb         	ldr	r3, [r7, #0x18]
 80139d6: 66bb         	str	r3, [r7, #0x68]
 80139d8: 6ebb         	ldr	r3, [r7, #0x68]
 80139da: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80139dc: 6e7b         	ldr	r3, [r7, #0x64]
 80139de: f383 8811    	msr	basepri, r3
; }
 80139e2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80139e4: f3bf 8f6f    	isb	sy
; }
 80139e8: bf00         	nop
; }
 80139ea: bf00         	nop
; }
 80139ec: bf00         	nop
; 		return 0;
 80139ee: 2300         	movs	r3, #0x0
 80139f0: e193         	b	0x8013d1a <z_impl_k_mutex_lock+0x46e> @ imm = #0x326
; 	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
 80139f2: e9d7 2300    	ldrd	r2, r3, [r7]
 80139f6: f04f 0000    	mov.w	r0, #0x0
 80139fa: f04f 0100    	mov.w	r1, #0x0
 80139fe: 428b         	cmp	r3, r1
 8013a00: bf08         	it	eq
 8013a02: 4282         	cmpeq	r2, r0
 8013a04: bf0c         	ite	eq
 8013a06: 2301         	moveq	r3, #0x1
 8013a08: 2300         	movne	r3, #0x0
 8013a0a: b2db         	uxtb	r3, r3
 8013a0c: 2b00         	cmp	r3, #0x0
 8013a0e: d013         	beq	0x8013a38 <z_impl_k_mutex_lock+0x18c> @ imm = #0x26
 8013a10: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8013b58 <z_impl_k_mutex_lock+0x2ac>
 8013a12: 663b         	str	r3, [r7, #0x60]
 8013a14: 6a7b         	ldr	r3, [r7, #0x24]
 8013a16: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8013a18: 693b         	ldr	r3, [r7, #0x10]
 8013a1a: 65fb         	str	r3, [r7, #0x5c]
 8013a1c: 6dfb         	ldr	r3, [r7, #0x5c]
 8013a1e: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8013a20: 6dbb         	ldr	r3, [r7, #0x58]
 8013a22: f383 8811    	msr	basepri, r3
; }
 8013a26: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013a28: f3bf 8f6f    	isb	sy
; }
 8013a2c: bf00         	nop
; }
 8013a2e: bf00         	nop
; }
 8013a30: bf00         	nop
; 		return -EBUSY;
 8013a32: f06f 030f    	mvn	r3, #0xf
 8013a36: e170         	b	0x8013d1a <z_impl_k_mutex_lock+0x46e> @ imm = #0x2e0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8013a38: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8013b5c <z_impl_k_mutex_lock+0x2b0>
 8013a3a: 689b         	ldr	r3, [r3, #0x8]
 8013a3c: 657b         	str	r3, [r7, #0x54]
; 	return ret;
 8013a3e: 6d7b         	ldr	r3, [r7, #0x54]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 8013a40: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8013a44: 461a         	mov	r2, r3
; 					    mutex->owner->base.prio);
 8013a46: 68fb         	ldr	r3, [r7, #0xc]
 8013a48: 689b         	ldr	r3, [r3, #0x8]
 8013a4a: f993 300e    	ldrsb.w	r3, [r3, #0xe]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 8013a4e: 4619         	mov	r1, r3
 8013a50: 4610         	mov	r0, r2
 8013a52: f011 fba0    	bl	0x8025196 <new_prio_for_inheritance> @ imm = #0x11740
 8013a56: f8c7 00d0    	str.w	r0, [r7, #0xd0]
; 	LOG_DBG("adjusting prio up on mutex %p", mutex);
 8013a5a: 2303         	movs	r3, #0x3
 8013a5c: 2b03         	cmp	r3, #0x3
 8013a5e: d91d         	bls	0x8013a9c <z_impl_k_mutex_lock+0x1f0> @ imm = #0x3a
 8013a60: 2301         	movs	r3, #0x1
 8013a62: f887 30cf    	strb.w	r3, [r7, #0xcf]
 8013a66: f897 30cf    	ldrb.w	r3, [r7, #0xcf]
 8013a6a: f083 0301    	eor	r3, r3, #0x1
 8013a6e: b2db         	uxtb	r3, r3
 8013a70: 2b00         	cmp	r3, #0x0
 8013a72: d113         	bne	0x8013a9c <z_impl_k_mutex_lock+0x1f0> @ imm = #0x26
 8013a74: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8013b60 <z_impl_k_mutex_lock+0x2b4>
 8013a76: 6819         	ldr	r1, [r3]
 8013a78: 68fb         	ldr	r3, [r7, #0xc]
 8013a7a: 9304         	str	r3, [sp, #0x10]
 8013a7c: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8013b64 <z_impl_k_mutex_lock+0x2b8>
 8013a7e: 9303         	str	r3, [sp, #0xc]
 8013a80: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8013b6c <z_impl_k_mutex_lock+0x2c0>
 8013a82: 9302         	str	r3, [sp, #0x8]
 8013a84: 2308         	movs	r3, #0x8
 8013a86: 9301         	str	r3, [sp, #0x4]
 8013a88: 2300         	movs	r3, #0x0
 8013a8a: 9300         	str	r3, [sp]
 8013a8c: 2300         	movs	r3, #0x0
 8013a8e: 2204         	movs	r2, #0x4
 8013a90: 2000         	movs	r0, #0x0
 8013a92: f011 fb4c    	bl	0x802512e <z_log_msg_runtime_create> @ imm = #0x11698
 8013a96: 2300         	movs	r3, #0x0
 8013a98: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
 8013a9c: 68fb         	ldr	r3, [r7, #0xc]
 8013a9e: 689b         	ldr	r3, [r3, #0x8]
 8013aa0: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8013aa4: 4619         	mov	r1, r3
 8013aa6: f8d7 00d0    	ldr.w	r0, [r7, #0xd0]
 8013aaa: f011 faff    	bl	0x80250ac <z_is_prio_higher> @ imm = #0x115fe
 8013aae: 4603         	mov	r3, r0
 8013ab0: 2b00         	cmp	r3, #0x0
 8013ab2: d007         	beq	0x8013ac4 <z_impl_k_mutex_lock+0x218> @ imm = #0xe
; 		resched = adjust_owner_prio(mutex, new_prio);
 8013ab4: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 8013ab8: 68f8         	ldr	r0, [r7, #0xc]
 8013aba: f7ff fea3    	bl	0x8013804 <adjust_owner_prio> @ imm = #-0x2ba
 8013abe: 4603         	mov	r3, r0
 8013ac0: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
 8013ac4: 68f9         	ldr	r1, [r7, #0xc]
 8013ac6: e9d7 2300    	ldrd	r2, r3, [r7]
 8013aca: e9cd 2300    	strd	r2, r3, [sp]
 8013ace: 460a         	mov	r2, r1
 8013ad0: 6a79         	ldr	r1, [r7, #0x24]
 8013ad2: 4821         	ldr	r0, [pc, #0x84]         @ 0x8013b58 <z_impl_k_mutex_lock+0x2ac>
 8013ad4: f001 ff04    	bl	0x80158e0 <z_pend_curr> @ imm = #0x1e08
 8013ad8: f8c7 00c4    	str.w	r0, [r7, #0xc4]
; 	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);
 8013adc: 2303         	movs	r3, #0x3
 8013ade: 2b03         	cmp	r3, #0x3
 8013ae0: d920         	bls	0x8013b24 <z_impl_k_mutex_lock+0x278> @ imm = #0x40
 8013ae2: 2301         	movs	r3, #0x1
 8013ae4: f887 30c3    	strb.w	r3, [r7, #0xc3]
 8013ae8: f897 30c3    	ldrb.w	r3, [r7, #0xc3]
 8013aec: f083 0301    	eor	r3, r3, #0x1
 8013af0: b2db         	uxtb	r3, r3
 8013af2: 2b00         	cmp	r3, #0x0
 8013af4: d116         	bne	0x8013b24 <z_impl_k_mutex_lock+0x278> @ imm = #0x2c
 8013af6: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8013b60 <z_impl_k_mutex_lock+0x2b4>
 8013af8: 6819         	ldr	r1, [r3]
 8013afa: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8013afe: 9305         	str	r3, [sp, #0x14]
 8013b00: 68fb         	ldr	r3, [r7, #0xc]
 8013b02: 9304         	str	r3, [sp, #0x10]
 8013b04: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8013b64 <z_impl_k_mutex_lock+0x2b8>
 8013b06: 9303         	str	r3, [sp, #0xc]
 8013b08: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8013b70 <z_impl_k_mutex_lock+0x2c4>
 8013b0a: 9302         	str	r3, [sp, #0x8]
 8013b0c: 2308         	movs	r3, #0x8
 8013b0e: 9301         	str	r3, [sp, #0x4]
 8013b10: 2300         	movs	r3, #0x0
 8013b12: 9300         	str	r3, [sp]
 8013b14: 2300         	movs	r3, #0x0
 8013b16: 2204         	movs	r2, #0x4
 8013b18: 2000         	movs	r0, #0x0
 8013b1a: f011 fb08    	bl	0x802512e <z_log_msg_runtime_create> @ imm = #0x11610
 8013b1e: 2300         	movs	r3, #0x0
 8013b20: f8c7 30bc    	str.w	r3, [r7, #0xbc]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 8013b24: 2303         	movs	r3, #0x3
 8013b26: 2b03         	cmp	r3, #0x3
 8013b28: d939         	bls	0x8013b9e <z_impl_k_mutex_lock+0x2f2> @ imm = #0x72
 8013b2a: 2301         	movs	r3, #0x1
 8013b2c: f887 30bb    	strb.w	r3, [r7, #0xbb]
 8013b30: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 8013b34: f083 0301    	eor	r3, r3, #0x1
 8013b38: b2db         	uxtb	r3, r3
 8013b3a: 2b00         	cmp	r3, #0x0
 8013b3c: d12f         	bne	0x8013b9e <z_impl_k_mutex_lock+0x2f2> @ imm = #0x5e
 8013b3e: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8013b60 <z_impl_k_mutex_lock+0x2b4>
 8013b40: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8013b42: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8013b5c <z_impl_k_mutex_lock+0x2b0>
 8013b44: 689b         	ldr	r3, [r3, #0x8]
 8013b46: 653b         	str	r3, [r7, #0x50]
; 	return ret;
 8013b48: 6d3b         	ldr	r3, [r7, #0x50]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 8013b4a: f8d7 20c4    	ldr.w	r2, [r7, #0xc4]
 8013b4e: 2a00         	cmp	r2, #0x0
 8013b50: d010         	beq	0x8013b74 <z_impl_k_mutex_lock+0x2c8> @ imm = #0x20
 8013b52: 2279         	movs	r2, #0x79
 8013b54: e00f         	b	0x8013b76 <z_impl_k_mutex_lock+0x2ca> @ imm = #0x1e
 8013b56: bf00         	nop

08013b58 <$d>:
 8013b58: e4 32 00 20  	.word	0x200032e4
 8013b5c: a8 25 00 20  	.word	0x200025a8
 8013b60: 60 0b 00 20  	.word	0x20000b60
 8013b64: 4c bc 02 08  	.word	0x0802bc4c
 8013b68: 08 a2 02 08  	.word	0x0802a208
 8013b6c: 38 a2 02 08  	.word	0x0802a238
 8013b70: 5c a2 02 08  	.word	0x0802a25c

08013b74 <$t>:
 8013b74: 226e         	movs	r2, #0x6e
 8013b76: 9206         	str	r2, [sp, #0x18]
 8013b78: 68fa         	ldr	r2, [r7, #0xc]
 8013b7a: 9205         	str	r2, [sp, #0x14]
 8013b7c: 9304         	str	r3, [sp, #0x10]
 8013b7e: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8013d24 <z_impl_k_mutex_lock+0x478>
 8013b80: 9303         	str	r3, [sp, #0xc]
 8013b82: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8013d28 <z_impl_k_mutex_lock+0x47c>
 8013b84: 9302         	str	r3, [sp, #0x8]
 8013b86: 2308         	movs	r3, #0x8
 8013b88: 9301         	str	r3, [sp, #0x4]
 8013b8a: 2300         	movs	r3, #0x0
 8013b8c: 9300         	str	r3, [sp]
 8013b8e: 2300         	movs	r3, #0x0
 8013b90: 2204         	movs	r2, #0x4
 8013b92: 2000         	movs	r0, #0x0
 8013b94: f011 facb    	bl	0x802512e <z_log_msg_runtime_create> @ imm = #0x11596
 8013b98: 2300         	movs	r3, #0x0
 8013b9a: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (got_mutex == 0) {
 8013b9e: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8013ba2: 2b00         	cmp	r3, #0x0
 8013ba4: d101         	bne	0x8013baa <z_impl_k_mutex_lock+0x2fe> @ imm = #0x2
; 		return 0;
 8013ba6: 2300         	movs	r3, #0x0
 8013ba8: e0b7         	b	0x8013d1a <z_impl_k_mutex_lock+0x46e> @ imm = #0x16e
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 8013baa: 2303         	movs	r3, #0x3
 8013bac: 2b03         	cmp	r3, #0x3
 8013bae: d922         	bls	0x8013bf6 <z_impl_k_mutex_lock+0x34a> @ imm = #0x44
 8013bb0: 2301         	movs	r3, #0x1
 8013bb2: f887 30b3    	strb.w	r3, [r7, #0xb3]
 8013bb6: f897 30b3    	ldrb.w	r3, [r7, #0xb3]
 8013bba: f083 0301    	eor	r3, r3, #0x1
 8013bbe: b2db         	uxtb	r3, r3
 8013bc0: 2b00         	cmp	r3, #0x0
 8013bc2: d118         	bne	0x8013bf6 <z_impl_k_mutex_lock+0x34a> @ imm = #0x30
 8013bc4: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8013d2c <z_impl_k_mutex_lock+0x480>
 8013bc6: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8013bc8: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8013d30 <z_impl_k_mutex_lock+0x484>
 8013bca: 689b         	ldr	r3, [r3, #0x8]
 8013bcc: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 8013bce: 6cfb         	ldr	r3, [r7, #0x4c]
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 8013bd0: 68fa         	ldr	r2, [r7, #0xc]
 8013bd2: 9205         	str	r2, [sp, #0x14]
 8013bd4: 9304         	str	r3, [sp, #0x10]
 8013bd6: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8013d24 <z_impl_k_mutex_lock+0x478>
 8013bd8: 9303         	str	r3, [sp, #0xc]
 8013bda: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8013d34 <z_impl_k_mutex_lock+0x488>
 8013bdc: 9302         	str	r3, [sp, #0x8]
 8013bde: 2308         	movs	r3, #0x8
 8013be0: 9301         	str	r3, [sp, #0x4]
 8013be2: 2300         	movs	r3, #0x0
 8013be4: 9300         	str	r3, [sp]
 8013be6: 2300         	movs	r3, #0x0
 8013be8: 2204         	movs	r2, #0x4
 8013bea: 2000         	movs	r0, #0x0
 8013bec: f011 fa9f    	bl	0x802512e <z_log_msg_runtime_create> @ imm = #0x1153e
 8013bf0: 2300         	movs	r3, #0x0
 8013bf2: f8c7 30ac    	str.w	r3, [r7, #0xac]
 8013bf6: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8013d38 <z_impl_k_mutex_lock+0x48c>
 8013bf8: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8013bfa: f3ef 8311    	mrs	r3, basepri
 8013bfe: 647b         	str	r3, [r7, #0x44]
;   return(result);
 8013c00: 6c7b         	ldr	r3, [r7, #0x44]
; 	key = __get_BASEPRI();
 8013c02: 643b         	str	r3, [r7, #0x40]
 8013c04: 2310         	movs	r3, #0x10
 8013c06: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8013c08: 6bfb         	ldr	r3, [r7, #0x3c]
 8013c0a: f383 8812    	msr	basepri_max, r3
; }
 8013c0e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013c10: f3bf 8f6f    	isb	sy
; }
 8013c14: bf00         	nop
; 	return key;
 8013c16: 6c3b         	ldr	r3, [r7, #0x40]
; 	k.key = arch_irq_lock();
 8013c18: 61fb         	str	r3, [r7, #0x1c]
 8013c1a: 6cbb         	ldr	r3, [r7, #0x48]
 8013c1c: 63bb         	str	r3, [r7, #0x38]
; }
 8013c1e: bf00         	nop
 8013c20: 6cbb         	ldr	r3, [r7, #0x48]
 8013c22: 637b         	str	r3, [r7, #0x34]
; }
 8013c24: bf00         	nop
; 	return k;
 8013c26: 69fb         	ldr	r3, [r7, #0x1c]
 8013c28: 627b         	str	r3, [r7, #0x24]
; 	if (likely(mutex->owner != NULL)) {
 8013c2a: 68fb         	ldr	r3, [r7, #0xc]
 8013c2c: 689b         	ldr	r3, [r3, #0x8]
 8013c2e: 2b00         	cmp	r3, #0x0
 8013c30: bf14         	ite	ne
 8013c32: 2301         	movne	r3, #0x1
 8013c34: 2300         	moveq	r3, #0x0
 8013c36: b2db         	uxtb	r3, r3
 8013c38: 2b00         	cmp	r3, #0x0
 8013c3a: d052         	beq	0x8013ce2 <z_impl_k_mutex_lock+0x436> @ imm = #0xa4
; 		struct k_thread *waiter = z_waitq_head(&mutex->wait_q);
 8013c3c: 68fb         	ldr	r3, [r7, #0xc]
 8013c3e: 4618         	mov	r0, r3
 8013c40: f011 fa68    	bl	0x8025114 <z_waitq_head> @ imm = #0x114d0
 8013c44: f8c7 00a8    	str.w	r0, [r7, #0xa8]
; 			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
 8013c48: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 8013c4c: 2b00         	cmp	r3, #0x0
 8013c4e: d00c         	beq	0x8013c6a <z_impl_k_mutex_lock+0x3be> @ imm = #0x18
 8013c50: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 8013c54: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8013c58: 461a         	mov	r2, r3
 8013c5a: 68fb         	ldr	r3, [r7, #0xc]
 8013c5c: 691b         	ldr	r3, [r3, #0x10]
 8013c5e: 4619         	mov	r1, r3
 8013c60: 4610         	mov	r0, r2
 8013c62: f011 fa98    	bl	0x8025196 <new_prio_for_inheritance> @ imm = #0x11530
 8013c66: 4603         	mov	r3, r0
 8013c68: e001         	b	0x8013c6e <z_impl_k_mutex_lock+0x3c2> @ imm = #0x2
 8013c6a: 68fb         	ldr	r3, [r7, #0xc]
 8013c6c: 691b         	ldr	r3, [r3, #0x10]
; 		new_prio = (waiter != NULL) ?
 8013c6e: f8c7 30d0    	str.w	r3, [r7, #0xd0]
; 		LOG_DBG("adjusting prio down on mutex %p", mutex);
 8013c72: 2303         	movs	r3, #0x3
 8013c74: 2b03         	cmp	r3, #0x3
 8013c76: d91d         	bls	0x8013cb4 <z_impl_k_mutex_lock+0x408> @ imm = #0x3a
 8013c78: 2301         	movs	r3, #0x1
 8013c7a: f887 30a7    	strb.w	r3, [r7, #0xa7]
 8013c7e: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 8013c82: f083 0301    	eor	r3, r3, #0x1
 8013c86: b2db         	uxtb	r3, r3
 8013c88: 2b00         	cmp	r3, #0x0
 8013c8a: d113         	bne	0x8013cb4 <z_impl_k_mutex_lock+0x408> @ imm = #0x26
 8013c8c: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8013d2c <z_impl_k_mutex_lock+0x480>
 8013c8e: 6819         	ldr	r1, [r3]
 8013c90: 68fb         	ldr	r3, [r7, #0xc]
 8013c92: 9304         	str	r3, [sp, #0x10]
 8013c94: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8013d24 <z_impl_k_mutex_lock+0x478>
 8013c96: 9303         	str	r3, [sp, #0xc]
 8013c98: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8013d3c <z_impl_k_mutex_lock+0x490>
 8013c9a: 9302         	str	r3, [sp, #0x8]
 8013c9c: 2308         	movs	r3, #0x8
 8013c9e: 9301         	str	r3, [sp, #0x4]
 8013ca0: 2300         	movs	r3, #0x0
 8013ca2: 9300         	str	r3, [sp]
 8013ca4: 2300         	movs	r3, #0x0
 8013ca6: 2204         	movs	r2, #0x4
 8013ca8: 2000         	movs	r0, #0x0
 8013caa: f011 fa40    	bl	0x802512e <z_log_msg_runtime_create> @ imm = #0x11480
 8013cae: 2300         	movs	r3, #0x0
 8013cb0: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 		resched = adjust_owner_prio(mutex, new_prio) || resched;
 8013cb4: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 8013cb8: 68f8         	ldr	r0, [r7, #0xc]
 8013cba: f7ff fda3    	bl	0x8013804 <adjust_owner_prio> @ imm = #-0x4ba
 8013cbe: 4603         	mov	r3, r0
 8013cc0: 2b00         	cmp	r3, #0x0
 8013cc2: d103         	bne	0x8013ccc <z_impl_k_mutex_lock+0x420> @ imm = #0x6
 8013cc4: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 8013cc8: 2b00         	cmp	r3, #0x0
 8013cca: d001         	beq	0x8013cd0 <z_impl_k_mutex_lock+0x424> @ imm = #0x2
 8013ccc: 2301         	movs	r3, #0x1
 8013cce: e000         	b	0x8013cd2 <z_impl_k_mutex_lock+0x426> @ imm = #0x0
 8013cd0: 2300         	movs	r3, #0x0
 8013cd2: f887 30d7    	strb.w	r3, [r7, #0xd7]
 8013cd6: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 8013cda: f003 0301    	and	r3, r3, #0x1
 8013cde: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	if (resched) {
 8013ce2: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 8013ce6: 2b00         	cmp	r3, #0x0
 8013ce8: d004         	beq	0x8013cf4 <z_impl_k_mutex_lock+0x448> @ imm = #0x8
; 		z_reschedule(&lock, key);
 8013cea: 6a79         	ldr	r1, [r7, #0x24]
 8013cec: 4812         	ldr	r0, [pc, #0x48]         @ 0x8013d38 <z_impl_k_mutex_lock+0x48c>
 8013cee: f012 ff3d    	bl	0x8026b6c <z_reschedule> @ imm = #0x12e7a
 8013cf2: e010         	b	0x8013d16 <z_impl_k_mutex_lock+0x46a> @ imm = #0x20
 8013cf4: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8013d38 <z_impl_k_mutex_lock+0x48c>
 8013cf6: 633b         	str	r3, [r7, #0x30]
 8013cf8: 6a7b         	ldr	r3, [r7, #0x24]
 8013cfa: 623b         	str	r3, [r7, #0x20]
; 	arch_irq_unlock(key.key);
 8013cfc: 6a3b         	ldr	r3, [r7, #0x20]
 8013cfe: 62fb         	str	r3, [r7, #0x2c]
 8013d00: 6afb         	ldr	r3, [r7, #0x2c]
 8013d02: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8013d04: 6abb         	ldr	r3, [r7, #0x28]
 8013d06: f383 8811    	msr	basepri, r3
; }
 8013d0a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013d0c: f3bf 8f6f    	isb	sy
; }
 8013d10: bf00         	nop
; }
 8013d12: bf00         	nop
; }
 8013d14: bf00         	nop
; 	return -EAGAIN;
 8013d16: f06f 030a    	mvn	r3, #0xa
; }
 8013d1a: 4618         	mov	r0, r3
 8013d1c: 37d8         	adds	r7, #0xd8
 8013d1e: 46bd         	mov	sp, r7
 8013d20: bd80         	pop	{r7, pc}
 8013d22: bf00         	nop

08013d24 <$d>:
 8013d24: 4c bc 02 08  	.word	0x0802bc4c
 8013d28: 80 a2 02 08  	.word	0x0802a280
 8013d2c: 60 0b 00 20  	.word	0x20000b60
 8013d30: a8 25 00 20  	.word	0x200025a8
 8013d34: a0 a2 02 08  	.word	0x0802a2a0
 8013d38: e4 32 00 20  	.word	0x200032e4
 8013d3c: bc a2 02 08  	.word	0x0802a2bc

08013d40 <z_impl_k_mutex_unlock>:
; {
 8013d40: b580         	push	{r7, lr}
 8013d42: b0a4         	sub	sp, #0x90
 8013d44: af08         	add	r7, sp, #0x20
 8013d46: 6078         	str	r0, [r7, #0x4]
; 	CHECKIF(mutex->owner == NULL) {
 8013d48: 687b         	ldr	r3, [r7, #0x4]
 8013d4a: 689b         	ldr	r3, [r3, #0x8]
 8013d4c: 2b00         	cmp	r3, #0x0
 8013d4e: d102         	bne	0x8013d56 <z_impl_k_mutex_unlock+0x16> @ imm = #0x4
; 		return -EINVAL;
 8013d50: f06f 0315    	mvn	r3, #0x15
 8013d54: e0dc         	b	0x8013f10 <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1b8
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 8013d56: 687b         	ldr	r3, [r7, #0x4]
 8013d58: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8013d5a: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8013f18 <z_impl_k_mutex_unlock+0x1d8>
 8013d5c: 689b         	ldr	r3, [r3, #0x8]
 8013d5e: 65bb         	str	r3, [r7, #0x58]
; 	return ret;
 8013d60: 6dbb         	ldr	r3, [r7, #0x58]
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 8013d62: 429a         	cmp	r2, r3
 8013d64: d002         	beq	0x8013d6c <z_impl_k_mutex_unlock+0x2c> @ imm = #0x4
; 		return -EPERM;
 8013d66: f04f 33ff    	mov.w	r3, #0xffffffff
 8013d6a: e0d1         	b	0x8013f10 <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1a2
; 	LOG_DBG("mutex %p lock_count: %d", mutex, mutex->lock_count);
 8013d6c: 2303         	movs	r3, #0x3
 8013d6e: 2b03         	cmp	r3, #0x3
 8013d70: d91f         	bls	0x8013db2 <z_impl_k_mutex_unlock+0x72> @ imm = #0x3e
 8013d72: 2301         	movs	r3, #0x1
 8013d74: f887 306f    	strb.w	r3, [r7, #0x6f]
 8013d78: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 8013d7c: f083 0301    	eor	r3, r3, #0x1
 8013d80: b2db         	uxtb	r3, r3
 8013d82: 2b00         	cmp	r3, #0x0
 8013d84: d115         	bne	0x8013db2 <z_impl_k_mutex_unlock+0x72> @ imm = #0x2a
 8013d86: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8013f1c <z_impl_k_mutex_unlock+0x1dc>
 8013d88: 6819         	ldr	r1, [r3]
 8013d8a: 687b         	ldr	r3, [r7, #0x4]
 8013d8c: 68db         	ldr	r3, [r3, #0xc]
 8013d8e: 9305         	str	r3, [sp, #0x14]
 8013d90: 687b         	ldr	r3, [r7, #0x4]
 8013d92: 9304         	str	r3, [sp, #0x10]
 8013d94: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8013f20 <z_impl_k_mutex_unlock+0x1e0>
 8013d96: 9303         	str	r3, [sp, #0xc]
 8013d98: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8013f24 <z_impl_k_mutex_unlock+0x1e4>
 8013d9a: 9302         	str	r3, [sp, #0x8]
 8013d9c: 2308         	movs	r3, #0x8
 8013d9e: 9301         	str	r3, [sp, #0x4]
 8013da0: 2300         	movs	r3, #0x0
 8013da2: 9300         	str	r3, [sp]
 8013da4: 2300         	movs	r3, #0x0
 8013da6: 2204         	movs	r2, #0x4
 8013da8: 2000         	movs	r0, #0x0
 8013daa: f011 f9c0    	bl	0x802512e <z_log_msg_runtime_create> @ imm = #0x11380
 8013dae: 2300         	movs	r3, #0x0
 8013db0: 66bb         	str	r3, [r7, #0x68]
; 	if (mutex->lock_count > 1U) {
 8013db2: 687b         	ldr	r3, [r7, #0x4]
 8013db4: 68db         	ldr	r3, [r3, #0xc]
 8013db6: 2b01         	cmp	r3, #0x1
 8013db8: d905         	bls	0x8013dc6 <z_impl_k_mutex_unlock+0x86> @ imm = #0xa
; 		mutex->lock_count--;
 8013dba: 687b         	ldr	r3, [r7, #0x4]
 8013dbc: 68db         	ldr	r3, [r3, #0xc]
 8013dbe: 1e5a         	subs	r2, r3, #0x1
 8013dc0: 687b         	ldr	r3, [r7, #0x4]
 8013dc2: 60da         	str	r2, [r3, #0xc]
; 		goto k_mutex_unlock_return;
 8013dc4: e0a3         	b	0x8013f0e <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x146
 8013dc6: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8013f28 <z_impl_k_mutex_unlock+0x1e8>
 8013dc8: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8013dca: f3ef 8311    	mrs	r3, basepri
 8013dce: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 8013dd0: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 8013dd2: 63bb         	str	r3, [r7, #0x38]
 8013dd4: 2310         	movs	r3, #0x10
 8013dd6: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8013dd8: 6b7b         	ldr	r3, [r7, #0x34]
 8013dda: f383 8812    	msr	basepri_max, r3
; }
 8013dde: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013de0: f3bf 8f6f    	isb	sy
; }
 8013de4: bf00         	nop
; 	return key;
 8013de6: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 8013de8: 60fb         	str	r3, [r7, #0xc]
 8013dea: 6c3b         	ldr	r3, [r7, #0x40]
 8013dec: 633b         	str	r3, [r7, #0x30]
; }
 8013dee: bf00         	nop
 8013df0: 6c3b         	ldr	r3, [r7, #0x40]
 8013df2: 62fb         	str	r3, [r7, #0x2c]
; }
 8013df4: bf00         	nop
; 	return k;
 8013df6: 68fb         	ldr	r3, [r7, #0xc]
 8013df8: 617b         	str	r3, [r7, #0x14]
; 	adjust_owner_prio(mutex, mutex->owner_orig_prio);
 8013dfa: 687b         	ldr	r3, [r7, #0x4]
 8013dfc: 691b         	ldr	r3, [r3, #0x10]
 8013dfe: 4619         	mov	r1, r3
 8013e00: 6878         	ldr	r0, [r7, #0x4]
 8013e02: f7ff fcff    	bl	0x8013804 <adjust_owner_prio> @ imm = #-0x602
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 8013e06: 687b         	ldr	r3, [r7, #0x4]
 8013e08: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 8013e0a: 2300         	movs	r3, #0x0
 8013e0c: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8013e0e: 6d7b         	ldr	r3, [r7, #0x54]
 8013e10: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 8013e12: 2300         	movs	r3, #0x0
 8013e14: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8013e16: 6cf8         	ldr	r0, [r7, #0x4c]
 8013e18: f011 f85b    	bl	0x8024ed2 <sys_dlist_peek_head> @ imm = #0x110b6
 8013e1c: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8013e1e: 6c7b         	ldr	r3, [r7, #0x44]
 8013e20: 2b00         	cmp	r3, #0x0
 8013e22: d001         	beq	0x8013e28 <z_impl_k_mutex_unlock+0xe8> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8013e24: 6c7b         	ldr	r3, [r7, #0x44]
 8013e26: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 8013e28: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8013e2a: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 8013e2c: 6d3b         	ldr	r3, [r7, #0x50]
 8013e2e: 2b00         	cmp	r3, #0x0
 8013e30: bf14         	ite	ne
 8013e32: 2301         	movne	r3, #0x1
 8013e34: 2300         	moveq	r3, #0x0
 8013e36: b2db         	uxtb	r3, r3
 8013e38: 2b00         	cmp	r3, #0x0
 8013e3a: d005         	beq	0x8013e48 <z_impl_k_mutex_unlock+0x108> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 8013e3c: 6d38         	ldr	r0, [r7, #0x50]
 8013e3e: f011 f943    	bl	0x80250c8 <unpend_thread_no_timeout> @ imm = #0x11286
; 			(void)z_abort_thread_timeout(thread);
 8013e42: 6d38         	ldr	r0, [r7, #0x50]
 8013e44: f011 f890    	bl	0x8024f68 <z_abort_thread_timeout> @ imm = #0x11120
; 	return thread;
 8013e48: 6d3b         	ldr	r3, [r7, #0x50]
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 8013e4a: 667b         	str	r3, [r7, #0x64]
; 	mutex->owner = new_owner;
 8013e4c: 687b         	ldr	r3, [r7, #0x4]
 8013e4e: 6e7a         	ldr	r2, [r7, #0x64]
 8013e50: 609a         	str	r2, [r3, #0x8]
; 	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
 8013e52: 2303         	movs	r3, #0x3
 8013e54: 2b03         	cmp	r3, #0x3
 8013e56: d927         	bls	0x8013ea8 <z_impl_k_mutex_unlock+0x168> @ imm = #0x4e
 8013e58: 2301         	movs	r3, #0x1
 8013e5a: f887 3063    	strb.w	r3, [r7, #0x63]
 8013e5e: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8013e62: f083 0301    	eor	r3, r3, #0x1
 8013e66: b2db         	uxtb	r3, r3
 8013e68: 2b00         	cmp	r3, #0x0
 8013e6a: d11d         	bne	0x8013ea8 <z_impl_k_mutex_unlock+0x168> @ imm = #0x3a
 8013e6c: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8013f1c <z_impl_k_mutex_unlock+0x1dc>
 8013e6e: 6819         	ldr	r1, [r3]
 8013e70: 6e7b         	ldr	r3, [r7, #0x64]
 8013e72: 2b00         	cmp	r3, #0x0
 8013e74: d003         	beq	0x8013e7e <z_impl_k_mutex_unlock+0x13e> @ imm = #0x6
 8013e76: 6e7b         	ldr	r3, [r7, #0x64]
 8013e78: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8013e7c: e000         	b	0x8013e80 <z_impl_k_mutex_unlock+0x140> @ imm = #0x0
 8013e7e: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8013f2c <z_impl_k_mutex_unlock+0x1ec>
 8013e80: 9306         	str	r3, [sp, #0x18]
 8013e82: 6e7b         	ldr	r3, [r7, #0x64]
 8013e84: 9305         	str	r3, [sp, #0x14]
 8013e86: 687b         	ldr	r3, [r7, #0x4]
 8013e88: 9304         	str	r3, [sp, #0x10]
 8013e8a: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8013f20 <z_impl_k_mutex_unlock+0x1e0>
 8013e8c: 9303         	str	r3, [sp, #0xc]
 8013e8e: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8013f30 <z_impl_k_mutex_unlock+0x1f0>
 8013e90: 9302         	str	r3, [sp, #0x8]
 8013e92: 2308         	movs	r3, #0x8
 8013e94: 9301         	str	r3, [sp, #0x4]
 8013e96: 2300         	movs	r3, #0x0
 8013e98: 9300         	str	r3, [sp]
 8013e9a: 2300         	movs	r3, #0x0
 8013e9c: 2204         	movs	r2, #0x4
 8013e9e: 2000         	movs	r0, #0x0
 8013ea0: f011 f945    	bl	0x802512e <z_log_msg_runtime_create> @ imm = #0x1128a
 8013ea4: 2300         	movs	r3, #0x0
 8013ea6: 65fb         	str	r3, [r7, #0x5c]
; 	if (unlikely(new_owner != NULL)) {
 8013ea8: 6e7b         	ldr	r3, [r7, #0x64]
 8013eaa: 2b00         	cmp	r3, #0x0
 8013eac: bf14         	ite	ne
 8013eae: 2301         	movne	r3, #0x1
 8013eb0: 2300         	moveq	r3, #0x0
 8013eb2: b2db         	uxtb	r3, r3
 8013eb4: 2b00         	cmp	r3, #0x0
 8013eb6: d016         	beq	0x8013ee6 <z_impl_k_mutex_unlock+0x1a6> @ imm = #0x2c
; 		mutex->owner_orig_prio = new_owner->base.prio;
 8013eb8: 6e7b         	ldr	r3, [r7, #0x64]
 8013eba: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8013ebe: 461a         	mov	r2, r3
 8013ec0: 687b         	ldr	r3, [r7, #0x4]
 8013ec2: 611a         	str	r2, [r3, #0x10]
 8013ec4: 6e7b         	ldr	r3, [r7, #0x64]
 8013ec6: 62bb         	str	r3, [r7, #0x28]
 8013ec8: 2300         	movs	r3, #0x0
 8013eca: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 8013ecc: 6abb         	ldr	r3, [r7, #0x28]
 8013ece: 6a7a         	ldr	r2, [r7, #0x24]
 8013ed0: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8013ed4: bf00         	nop
; 		z_ready_thread(new_owner);
 8013ed6: 6e78         	ldr	r0, [r7, #0x64]
 8013ed8: f001 f900    	bl	0x80150dc <z_ready_thread> @ imm = #0x1200
; 		z_reschedule(&lock, key);
 8013edc: 6979         	ldr	r1, [r7, #0x14]
 8013ede: 4812         	ldr	r0, [pc, #0x48]         @ 0x8013f28 <z_impl_k_mutex_unlock+0x1e8>
 8013ee0: f012 fe44    	bl	0x8026b6c <z_reschedule> @ imm = #0x12c88
 8013ee4: e013         	b	0x8013f0e <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x26
; 		mutex->lock_count = 0U;
 8013ee6: 687b         	ldr	r3, [r7, #0x4]
 8013ee8: 2200         	movs	r2, #0x0
 8013eea: 60da         	str	r2, [r3, #0xc]
 8013eec: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8013f28 <z_impl_k_mutex_unlock+0x1e8>
 8013eee: 623b         	str	r3, [r7, #0x20]
 8013ef0: 697b         	ldr	r3, [r7, #0x14]
 8013ef2: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8013ef4: 693b         	ldr	r3, [r7, #0x10]
 8013ef6: 61fb         	str	r3, [r7, #0x1c]
 8013ef8: 69fb         	ldr	r3, [r7, #0x1c]
 8013efa: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8013efc: 69bb         	ldr	r3, [r7, #0x18]
 8013efe: f383 8811    	msr	basepri, r3
; }
 8013f02: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013f04: f3bf 8f6f    	isb	sy
; }
 8013f08: bf00         	nop
; }
 8013f0a: bf00         	nop
; }
 8013f0c: bf00         	nop
; 	return 0;
 8013f0e: 2300         	movs	r3, #0x0
; }
 8013f10: 4618         	mov	r0, r3
 8013f12: 3770         	adds	r7, #0x70
 8013f14: 46bd         	mov	sp, r7
 8013f16: bd80         	pop	{r7, pc}

08013f18 <$d>:
 8013f18: a8 25 00 20  	.word	0x200025a8
 8013f1c: 60 0b 00 20  	.word	0x20000b60
 8013f20: 60 bc 02 08  	.word	0x0802bc60
 8013f24: e0 a2 02 08  	.word	0x0802a2e0
 8013f28: e4 32 00 20  	.word	0x200032e4
 8013f2c: 18 fc ff ff  	.word	0xfffffc18
 8013f30: fc a2 02 08  	.word	0x0802a2fc

08013f34 <z_impl_k_queue_get>:
; {
 8013f34: b580         	push	{r7, lr}
 8013f36: b09a         	sub	sp, #0x68
 8013f38: af02         	add	r7, sp, #0x8
 8013f3a: 60f8         	str	r0, [r7, #0xc]
 8013f3c: e9c7 2300    	strd	r2, r3, [r7]
; 	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 8013f40: 68fb         	ldr	r3, [r7, #0xc]
 8013f42: 3308         	adds	r3, #0x8
 8013f44: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8013f46: f3ef 8311    	mrs	r3, basepri
 8013f4a: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 8013f4c: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 8013f4e: 64bb         	str	r3, [r7, #0x48]
 8013f50: 2310         	movs	r3, #0x10
 8013f52: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8013f54: 6c7b         	ldr	r3, [r7, #0x44]
 8013f56: f383 8812    	msr	basepri_max, r3
; }
 8013f5a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013f5c: f3bf 8f6f    	isb	sy
; }
 8013f60: bf00         	nop
; 	return key;
 8013f62: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 8013f64: 61bb         	str	r3, [r7, #0x18]
 8013f66: 6d3b         	ldr	r3, [r7, #0x50]
 8013f68: 643b         	str	r3, [r7, #0x40]
; }
 8013f6a: bf00         	nop
 8013f6c: 6d3b         	ldr	r3, [r7, #0x50]
 8013f6e: 63fb         	str	r3, [r7, #0x3c]
; }
 8013f70: bf00         	nop
; 	return k;
 8013f72: 69bb         	ldr	r3, [r7, #0x18]
 8013f74: 61fb         	str	r3, [r7, #0x1c]
; 	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
 8013f76: 68fb         	ldr	r3, [r7, #0xc]
 8013f78: 4618         	mov	r0, r3
 8013f7a: f011 f9e4    	bl	0x8025346 <sys_sflist_is_empty> @ imm = #0x113c8
 8013f7e: 4603         	mov	r3, r0
 8013f80: f083 0301    	eor	r3, r3, #0x1
 8013f84: b2db         	uxtb	r3, r3
 8013f86: 2b00         	cmp	r3, #0x0
 8013f88: d01d         	beq	0x8013fc6 <z_impl_k_queue_get+0x92> @ imm = #0x3a
; 		node = sys_sflist_get_not_empty(&queue->data_q);
 8013f8a: 68fb         	ldr	r3, [r7, #0xc]
 8013f8c: 4618         	mov	r0, r3
 8013f8e: f011 fa5c    	bl	0x802544a <sys_sflist_get_not_empty> @ imm = #0x114b8
 8013f92: 65b8         	str	r0, [r7, #0x58]
; 		data = z_queue_node_peek(node, true);
 8013f94: 2101         	movs	r1, #0x1
 8013f96: 6db8         	ldr	r0, [r7, #0x58]
 8013f98: f011 fac1    	bl	0x802551e <z_queue_node_peek> @ imm = #0x11582
 8013f9c: 6578         	str	r0, [r7, #0x54]
; 		k_spin_unlock(&queue->lock, key);
 8013f9e: 68fb         	ldr	r3, [r7, #0xc]
 8013fa0: 3308         	adds	r3, #0x8
 8013fa2: 63bb         	str	r3, [r7, #0x38]
 8013fa4: 69fb         	ldr	r3, [r7, #0x1c]
 8013fa6: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8013fa8: 697b         	ldr	r3, [r7, #0x14]
 8013faa: 637b         	str	r3, [r7, #0x34]
 8013fac: 6b7b         	ldr	r3, [r7, #0x34]
 8013fae: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8013fb0: 6b3b         	ldr	r3, [r7, #0x30]
 8013fb2: f383 8811    	msr	basepri, r3
; }
 8013fb6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013fb8: f3bf 8f6f    	isb	sy
; }
 8013fbc: bf00         	nop
; }
 8013fbe: bf00         	nop
; }
 8013fc0: bf00         	nop
; 		return data;
 8013fc2: 6d7b         	ldr	r3, [r7, #0x54]
 8013fc4: e036         	b	0x8014034 <z_impl_k_queue_get+0x100> @ imm = #0x6c
; 	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 8013fc6: e9d7 2300    	ldrd	r2, r3, [r7]
 8013fca: f04f 0000    	mov.w	r0, #0x0
 8013fce: f04f 0100    	mov.w	r1, #0x0
 8013fd2: 428b         	cmp	r3, r1
 8013fd4: bf08         	it	eq
 8013fd6: 4282         	cmpeq	r2, r0
 8013fd8: d113         	bne	0x8014002 <z_impl_k_queue_get+0xce> @ imm = #0x26
; 		k_spin_unlock(&queue->lock, key);
 8013fda: 68fb         	ldr	r3, [r7, #0xc]
 8013fdc: 3308         	adds	r3, #0x8
 8013fde: 62fb         	str	r3, [r7, #0x2c]
 8013fe0: 69fb         	ldr	r3, [r7, #0x1c]
 8013fe2: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8013fe4: 693b         	ldr	r3, [r7, #0x10]
 8013fe6: 62bb         	str	r3, [r7, #0x28]
 8013fe8: 6abb         	ldr	r3, [r7, #0x28]
 8013fea: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8013fec: 6a7b         	ldr	r3, [r7, #0x24]
 8013fee: f383 8811    	msr	basepri, r3
; }
 8013ff2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013ff4: f3bf 8f6f    	isb	sy
; }
 8013ff8: bf00         	nop
; }
 8013ffa: bf00         	nop
; }
 8013ffc: bf00         	nop
; 		return NULL;
 8013ffe: 2300         	movs	r3, #0x0
 8014000: e018         	b	0x8014034 <z_impl_k_queue_get+0x100> @ imm = #0x30
; 	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
 8014002: 68fb         	ldr	r3, [r7, #0xc]
 8014004: f103 0008    	add.w	r0, r3, #0x8
 8014008: 68fb         	ldr	r3, [r7, #0xc]
 801400a: f103 0108    	add.w	r1, r3, #0x8
 801400e: e9d7 2300    	ldrd	r2, r3, [r7]
 8014012: e9cd 2300    	strd	r2, r3, [sp]
 8014016: 460a         	mov	r2, r1
 8014018: 69f9         	ldr	r1, [r7, #0x1c]
 801401a: f001 fc61    	bl	0x80158e0 <z_pend_curr> @ imm = #0x18c2
 801401e: 65f8         	str	r0, [r7, #0x5c]
; 	return (ret != 0) ? NULL : arch_current_thread()->base.swap_data;
 8014020: 6dfb         	ldr	r3, [r7, #0x5c]
 8014022: 2b00         	cmp	r3, #0x0
 8014024: d105         	bne	0x8014032 <z_impl_k_queue_get+0xfe> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014026: 4b05         	ldr	r3, [pc, #0x14]         @ 0x801403c <z_impl_k_queue_get+0x108>
 8014028: 689b         	ldr	r3, [r3, #0x8]
 801402a: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 801402c: 6a3b         	ldr	r3, [r7, #0x20]
; 	return (ret != 0) ? NULL : arch_current_thread()->base.swap_data;
 801402e: 695b         	ldr	r3, [r3, #0x14]
 8014030: e000         	b	0x8014034 <z_impl_k_queue_get+0x100> @ imm = #0x0
 8014032: 2300         	movs	r3, #0x0
; }
 8014034: 4618         	mov	r0, r3
 8014036: 3760         	adds	r7, #0x60
 8014038: 46bd         	mov	sp, r7
 801403a: bd80         	pop	{r7, pc}

0801403c <$d>:
 801403c: a8 25 00 20  	.word	0x200025a8

08014040 <z_impl_k_sem_give>:
; {
 8014040: b580         	push	{r7, lr}
 8014042: b098         	sub	sp, #0x60
 8014044: af00         	add	r7, sp, #0x0
 8014046: 6078         	str	r0, [r7, #0x4]
 8014048: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8014158 <z_impl_k_sem_give+0x118>
 801404a: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801404c: f3ef 8311    	mrs	r3, basepri
 8014050: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 8014052: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 8014054: 63bb         	str	r3, [r7, #0x38]
 8014056: 2310         	movs	r3, #0x10
 8014058: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801405a: 6b7b         	ldr	r3, [r7, #0x34]
 801405c: f383 8812    	msr	basepri_max, r3
; }
 8014060: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014062: f3bf 8f6f    	isb	sy
; }
 8014066: bf00         	nop
; 	return key;
 8014068: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 801406a: 60fb         	str	r3, [r7, #0xc]
 801406c: 6c3b         	ldr	r3, [r7, #0x40]
 801406e: 633b         	str	r3, [r7, #0x30]
; }
 8014070: bf00         	nop
 8014072: 6c3b         	ldr	r3, [r7, #0x40]
 8014074: 62fb         	str	r3, [r7, #0x2c]
; }
 8014076: bf00         	nop
; 	return k;
 8014078: 68fb         	ldr	r3, [r7, #0xc]
 801407a: 617b         	str	r3, [r7, #0x14]
; 	bool resched = true;
 801407c: 2301         	movs	r3, #0x1
 801407e: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 8014082: 687b         	ldr	r3, [r7, #0x4]
 8014084: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 8014086: 2300         	movs	r3, #0x0
 8014088: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 801408a: 6d7b         	ldr	r3, [r7, #0x54]
 801408c: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 801408e: 2300         	movs	r3, #0x0
 8014090: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8014092: 6cf8         	ldr	r0, [r7, #0x4c]
 8014094: f011 fb8b    	bl	0x80257ae <sys_dlist_peek_head> @ imm = #0x11716
 8014098: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 801409a: 6c7b         	ldr	r3, [r7, #0x44]
 801409c: 2b00         	cmp	r3, #0x0
 801409e: d001         	beq	0x80140a4 <z_impl_k_sem_give+0x64> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80140a0: 6c7b         	ldr	r3, [r7, #0x44]
 80140a2: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 80140a4: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80140a6: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 80140a8: 6d3b         	ldr	r3, [r7, #0x50]
 80140aa: 2b00         	cmp	r3, #0x0
 80140ac: bf14         	ite	ne
 80140ae: 2301         	movne	r3, #0x1
 80140b0: 2300         	moveq	r3, #0x0
 80140b2: b2db         	uxtb	r3, r3
 80140b4: 2b00         	cmp	r3, #0x0
 80140b6: d005         	beq	0x80140c4 <z_impl_k_sem_give+0x84> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 80140b8: 6d38         	ldr	r0, [r7, #0x50]
 80140ba: f011 fbd6    	bl	0x802586a <unpend_thread_no_timeout> @ imm = #0x117ac
; 			(void)z_abort_thread_timeout(thread);
 80140be: 6d38         	ldr	r0, [r7, #0x50]
 80140c0: f011 fba8    	bl	0x8025814 <z_abort_thread_timeout> @ imm = #0x11750
; 	return thread;
 80140c4: 6d3b         	ldr	r3, [r7, #0x50]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 80140c6: 65bb         	str	r3, [r7, #0x58]
; 	if (unlikely(thread != NULL)) {
 80140c8: 6dbb         	ldr	r3, [r7, #0x58]
 80140ca: 2b00         	cmp	r3, #0x0
 80140cc: bf14         	ite	ne
 80140ce: 2301         	movne	r3, #0x1
 80140d0: 2300         	moveq	r3, #0x0
 80140d2: b2db         	uxtb	r3, r3
 80140d4: 2b00         	cmp	r3, #0x0
 80140d6: d00c         	beq	0x80140f2 <z_impl_k_sem_give+0xb2> @ imm = #0x18
 80140d8: 6dbb         	ldr	r3, [r7, #0x58]
 80140da: 62bb         	str	r3, [r7, #0x28]
 80140dc: 2300         	movs	r3, #0x0
 80140de: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 80140e0: 6abb         	ldr	r3, [r7, #0x28]
 80140e2: 6a7a         	ldr	r2, [r7, #0x24]
 80140e4: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 80140e8: bf00         	nop
; 		z_ready_thread(thread);
 80140ea: 6db8         	ldr	r0, [r7, #0x58]
 80140ec: f000 fff6    	bl	0x80150dc <z_ready_thread> @ imm = #0xfec
 80140f0: e013         	b	0x801411a <z_impl_k_sem_give+0xda> @ imm = #0x26
; 		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 80140f2: 687b         	ldr	r3, [r7, #0x4]
 80140f4: 689b         	ldr	r3, [r3, #0x8]
 80140f6: 687a         	ldr	r2, [r7, #0x4]
 80140f8: 6891         	ldr	r1, [r2, #0x8]
 80140fa: 687a         	ldr	r2, [r7, #0x4]
 80140fc: 68d2         	ldr	r2, [r2, #0xc]
 80140fe: 4291         	cmp	r1, r2
 8014100: d001         	beq	0x8014106 <z_impl_k_sem_give+0xc6> @ imm = #0x2
 8014102: 2201         	movs	r2, #0x1
 8014104: e000         	b	0x8014108 <z_impl_k_sem_give+0xc8> @ imm = #0x0
 8014106: 2200         	movs	r2, #0x0
 8014108: 441a         	add	r2, r3
 801410a: 687b         	ldr	r3, [r7, #0x4]
 801410c: 609a         	str	r2, [r3, #0x8]
; 		resched = handle_poll_events(sem);
 801410e: 6878         	ldr	r0, [r7, #0x4]
 8014110: f011 fbe7    	bl	0x80258e2 <handle_poll_events> @ imm = #0x117ce
 8014114: 4603         	mov	r3, r0
 8014116: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	if (unlikely(resched)) {
 801411a: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 801411e: 2b00         	cmp	r3, #0x0
 8014120: d004         	beq	0x801412c <z_impl_k_sem_give+0xec> @ imm = #0x8
; 		z_reschedule(&lock, key);
 8014122: 6979         	ldr	r1, [r7, #0x14]
 8014124: 480c         	ldr	r0, [pc, #0x30]         @ 0x8014158 <z_impl_k_sem_give+0x118>
 8014126: f012 fd21    	bl	0x8026b6c <z_reschedule> @ imm = #0x12a42
; }
 801412a: e010         	b	0x801414e <z_impl_k_sem_give+0x10e> @ imm = #0x20
 801412c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8014158 <z_impl_k_sem_give+0x118>
 801412e: 623b         	str	r3, [r7, #0x20]
 8014130: 697b         	ldr	r3, [r7, #0x14]
 8014132: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8014134: 693b         	ldr	r3, [r7, #0x10]
 8014136: 61fb         	str	r3, [r7, #0x1c]
 8014138: 69fb         	ldr	r3, [r7, #0x1c]
 801413a: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801413c: 69bb         	ldr	r3, [r7, #0x18]
 801413e: f383 8811    	msr	basepri, r3
; }
 8014142: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014144: f3bf 8f6f    	isb	sy
; }
 8014148: bf00         	nop
; }
 801414a: bf00         	nop
; }
 801414c: bf00         	nop
; }
 801414e: bf00         	nop
 8014150: 3760         	adds	r7, #0x60
 8014152: 46bd         	mov	sp, r7
 8014154: bd80         	pop	{r7, pc}
 8014156: bf00         	nop

08014158 <$d>:
 8014158: e4 32 00 20  	.word	0x200032e4

0801415c <z_impl_k_sem_take>:
; {
 801415c: b580         	push	{r7, lr}
 801415e: b098         	sub	sp, #0x60
 8014160: af02         	add	r7, sp, #0x8
 8014162: 60f8         	str	r0, [r7, #0xc]
 8014164: e9c7 2300    	strd	r2, r3, [r7]
 8014168: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8014240 <z_impl_k_sem_take+0xe4>
 801416a: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801416c: f3ef 8311    	mrs	r3, basepri
 8014170: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 8014172: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 8014174: 64bb         	str	r3, [r7, #0x48]
 8014176: 2310         	movs	r3, #0x10
 8014178: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801417a: 6c7b         	ldr	r3, [r7, #0x44]
 801417c: f383 8812    	msr	basepri_max, r3
; }
 8014180: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014182: f3bf 8f6f    	isb	sy
; }
 8014186: bf00         	nop
; 	return key;
 8014188: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 801418a: 61bb         	str	r3, [r7, #0x18]
 801418c: 6d3b         	ldr	r3, [r7, #0x50]
 801418e: 643b         	str	r3, [r7, #0x40]
; }
 8014190: bf00         	nop
 8014192: 6d3b         	ldr	r3, [r7, #0x50]
 8014194: 63fb         	str	r3, [r7, #0x3c]
; }
 8014196: bf00         	nop
; 	return k;
 8014198: 69bb         	ldr	r3, [r7, #0x18]
 801419a: 623b         	str	r3, [r7, #0x20]
; 	if (likely(sem->count > 0U)) {
 801419c: 68fb         	ldr	r3, [r7, #0xc]
 801419e: 689b         	ldr	r3, [r3, #0x8]
 80141a0: 2b00         	cmp	r3, #0x0
 80141a2: bf14         	ite	ne
 80141a4: 2301         	movne	r3, #0x1
 80141a6: 2300         	moveq	r3, #0x0
 80141a8: b2db         	uxtb	r3, r3
 80141aa: 2b00         	cmp	r3, #0x0
 80141ac: d018         	beq	0x80141e0 <z_impl_k_sem_take+0x84> @ imm = #0x30
; 		sem->count--;
 80141ae: 68fb         	ldr	r3, [r7, #0xc]
 80141b0: 689b         	ldr	r3, [r3, #0x8]
 80141b2: 1e5a         	subs	r2, r3, #0x1
 80141b4: 68fb         	ldr	r3, [r7, #0xc]
 80141b6: 609a         	str	r2, [r3, #0x8]
 80141b8: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8014240 <z_impl_k_sem_take+0xe4>
 80141ba: 63bb         	str	r3, [r7, #0x38]
 80141bc: 6a3b         	ldr	r3, [r7, #0x20]
 80141be: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 80141c0: 69fb         	ldr	r3, [r7, #0x1c]
 80141c2: 637b         	str	r3, [r7, #0x34]
 80141c4: 6b7b         	ldr	r3, [r7, #0x34]
 80141c6: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80141c8: 6b3b         	ldr	r3, [r7, #0x30]
 80141ca: f383 8811    	msr	basepri, r3
; }
 80141ce: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80141d0: f3bf 8f6f    	isb	sy
; }
 80141d4: bf00         	nop
; }
 80141d6: bf00         	nop
; }
 80141d8: bf00         	nop
; 		ret = 0;
 80141da: 2300         	movs	r3, #0x0
 80141dc: 657b         	str	r3, [r7, #0x54]
; 		goto out;
 80141de: e029         	b	0x8014234 <z_impl_k_sem_take+0xd8> @ imm = #0x52
; 	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 80141e0: e9d7 2300    	ldrd	r2, r3, [r7]
 80141e4: f04f 0000    	mov.w	r0, #0x0
 80141e8: f04f 0100    	mov.w	r1, #0x0
 80141ec: 428b         	cmp	r3, r1
 80141ee: bf08         	it	eq
 80141f0: 4282         	cmpeq	r2, r0
 80141f2: d114         	bne	0x801421e <z_impl_k_sem_take+0xc2> @ imm = #0x28
 80141f4: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8014240 <z_impl_k_sem_take+0xe4>
 80141f6: 62fb         	str	r3, [r7, #0x2c]
 80141f8: 6a3b         	ldr	r3, [r7, #0x20]
 80141fa: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 80141fc: 697b         	ldr	r3, [r7, #0x14]
 80141fe: 62bb         	str	r3, [r7, #0x28]
 8014200: 6abb         	ldr	r3, [r7, #0x28]
 8014202: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8014204: 6a7b         	ldr	r3, [r7, #0x24]
 8014206: f383 8811    	msr	basepri, r3
; }
 801420a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801420c: f3bf 8f6f    	isb	sy
; }
 8014210: bf00         	nop
; }
 8014212: bf00         	nop
; }
 8014214: bf00         	nop
; 		ret = -EBUSY;
 8014216: f06f 030f    	mvn	r3, #0xf
 801421a: 657b         	str	r3, [r7, #0x54]
 801421c: e00a         	b	0x8014234 <z_impl_k_sem_take+0xd8> @ imm = #0x14
; 	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 801421e: 68f9         	ldr	r1, [r7, #0xc]
 8014220: e9d7 2300    	ldrd	r2, r3, [r7]
 8014224: e9cd 2300    	strd	r2, r3, [sp]
 8014228: 460a         	mov	r2, r1
 801422a: 6a39         	ldr	r1, [r7, #0x20]
 801422c: 4804         	ldr	r0, [pc, #0x10]         @ 0x8014240 <z_impl_k_sem_take+0xe4>
 801422e: f001 fb57    	bl	0x80158e0 <z_pend_curr> @ imm = #0x16ae
 8014232: 6578         	str	r0, [r7, #0x54]
; 	return ret;
 8014234: 6d7b         	ldr	r3, [r7, #0x54]
; }
 8014236: 4618         	mov	r0, r3
 8014238: 3758         	adds	r7, #0x58
 801423a: 46bd         	mov	sp, r7
 801423c: bd80         	pop	{r7, pc}
 801423e: bf00         	nop

08014240 <$d>:
 8014240: e4 32 00 20  	.word	0x200032e4

08014244 <k_sys_work_q_init>:
; {
 8014244: b580         	push	{r7, lr}
 8014246: b084         	sub	sp, #0x10
 8014248: af02         	add	r7, sp, #0x8
; 	struct k_work_queue_config cfg = {
 801424a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8014274 <k_sys_work_q_init+0x30>
 801424c: 463b         	mov	r3, r7
 801424e: e892 0003    	ldm.w	r2, {r0, r1}
 8014252: e883 0003    	stm.w	r3, {r0, r1}
; 	k_work_queue_start(&k_sys_work_q,
 8014256: 463b         	mov	r3, r7
 8014258: 9300         	str	r3, [sp]
 801425a: f04f 33ff    	mov.w	r3, #0xffffffff
 801425e: f44f 6280    	mov.w	r2, #0x400
 8014262: 4905         	ldr	r1, [pc, #0x14]         @ 0x8014278 <k_sys_work_q_init+0x34>
 8014264: 4805         	ldr	r0, [pc, #0x14]         @ 0x801427c <k_sys_work_q_init+0x38>
 8014266: f000 fa4f    	bl	0x8014708 <k_work_queue_start> @ imm = #0x49e
; 	return 0;
 801426a: 2300         	movs	r3, #0x0
; }
 801426c: 4618         	mov	r0, r3
 801426e: 3708         	adds	r7, #0x8
 8014270: 46bd         	mov	sp, r7
 8014272: bd80         	pop	{r7, pc}

08014274 <$d>:
 8014274: 34 a3 02 08  	.word	0x0802a334
 8014278: 48 5b 00 20  	.word	0x20005b48
 801427c: 20 28 00 20  	.word	0x20002820

08014280 <finalize_cancel_locked>:
; {
 8014280: b580         	push	{r7, lr}
 8014282: b086         	sub	sp, #0x18
 8014284: af00         	add	r7, sp, #0x0
 8014286: 6078         	str	r0, [r7, #0x4]
; 	sys_snode_t *prev = NULL;
 8014288: 2300         	movs	r3, #0x0
 801428a: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_CANCELING_BIT);
 801428c: 687b         	ldr	r3, [r7, #0x4]
 801428e: 330c         	adds	r3, #0xc
 8014290: 2101         	movs	r1, #0x1
 8014292: 4618         	mov	r0, r3
 8014294: f011 fd39    	bl	0x8025d0a <flag_clear>  @ imm = #0x11a72
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 8014298: 4829         	ldr	r0, [pc, #0xa4]         @ 0x8014340 <finalize_cancel_locked+0xc0>
 801429a: f011 fb93    	bl	0x80259c4 <sys_slist_peek_head> @ imm = #0x11726
 801429e: 4603         	mov	r3, r0
 80142a0: 2b00         	cmp	r3, #0x0
 80142a2: d004         	beq	0x80142ae <finalize_cancel_locked+0x2e> @ imm = #0x8
 80142a4: 4826         	ldr	r0, [pc, #0x98]         @ 0x8014340 <finalize_cancel_locked+0xc0>
 80142a6: f011 fb8d    	bl	0x80259c4 <sys_slist_peek_head> @ imm = #0x1171a
 80142aa: 4603         	mov	r3, r0
 80142ac: e000         	b	0x80142b0 <finalize_cancel_locked+0x30> @ imm = #0x0
 80142ae: 2300         	movs	r3, #0x0
 80142b0: 617b         	str	r3, [r7, #0x14]
 80142b2: 697b         	ldr	r3, [r7, #0x14]
 80142b4: 2b00         	cmp	r3, #0x0
 80142b6: d00e         	beq	0x80142d6 <finalize_cancel_locked+0x56> @ imm = #0x1c
 80142b8: 697b         	ldr	r3, [r7, #0x14]
 80142ba: 4618         	mov	r0, r3
 80142bc: f011 fbb7    	bl	0x8025a2e <sys_slist_peek_next> @ imm = #0x1176e
 80142c0: 4603         	mov	r3, r0
 80142c2: 2b00         	cmp	r3, #0x0
 80142c4: d005         	beq	0x80142d2 <finalize_cancel_locked+0x52> @ imm = #0xa
 80142c6: 697b         	ldr	r3, [r7, #0x14]
 80142c8: 4618         	mov	r0, r3
 80142ca: f011 fbb0    	bl	0x8025a2e <sys_slist_peek_next> @ imm = #0x11760
 80142ce: 4603         	mov	r3, r0
 80142d0: e002         	b	0x80142d8 <finalize_cancel_locked+0x58> @ imm = #0x4
 80142d2: 2300         	movs	r3, #0x0
 80142d4: e000         	b	0x80142d8 <finalize_cancel_locked+0x58> @ imm = #0x0
 80142d6: 2300         	movs	r3, #0x0
 80142d8: 613b         	str	r3, [r7, #0x10]
 80142da: e028         	b	0x801432e <finalize_cancel_locked+0xae> @ imm = #0x50
; 		if (wc->work == work) {
 80142dc: 697b         	ldr	r3, [r7, #0x14]
 80142de: 685b         	ldr	r3, [r3, #0x4]
 80142e0: 687a         	ldr	r2, [r7, #0x4]
 80142e2: 429a         	cmp	r2, r3
 80142e4: d10b         	bne	0x80142fe <finalize_cancel_locked+0x7e> @ imm = #0x16
; 			sys_slist_remove(&pending_cancels, prev, &wc->node);
 80142e6: 697b         	ldr	r3, [r7, #0x14]
 80142e8: 461a         	mov	r2, r3
 80142ea: 68f9         	ldr	r1, [r7, #0xc]
 80142ec: 4814         	ldr	r0, [pc, #0x50]         @ 0x8014340 <finalize_cancel_locked+0xc0>
 80142ee: f011 fc0e    	bl	0x8025b0e <sys_slist_remove> @ imm = #0x1181c
; 			k_sem_give(&wc->sem);
 80142f2: 697b         	ldr	r3, [r7, #0x14]
 80142f4: 3308         	adds	r3, #0x8
 80142f6: 4618         	mov	r0, r3
 80142f8: f011 fcb3    	bl	0x8025c62 <k_sem_give>  @ imm = #0x11966
; 			break;
 80142fc: e01b         	b	0x8014336 <finalize_cancel_locked+0xb6> @ imm = #0x36
; 		prev = &wc->node;
 80142fe: 697b         	ldr	r3, [r7, #0x14]
 8014300: 60fb         	str	r3, [r7, #0xc]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 8014302: 693b         	ldr	r3, [r7, #0x10]
 8014304: 617b         	str	r3, [r7, #0x14]
 8014306: 697b         	ldr	r3, [r7, #0x14]
 8014308: 2b00         	cmp	r3, #0x0
 801430a: d00e         	beq	0x801432a <finalize_cancel_locked+0xaa> @ imm = #0x1c
 801430c: 697b         	ldr	r3, [r7, #0x14]
 801430e: 4618         	mov	r0, r3
 8014310: f011 fb8d    	bl	0x8025a2e <sys_slist_peek_next> @ imm = #0x1171a
 8014314: 4603         	mov	r3, r0
 8014316: 2b00         	cmp	r3, #0x0
 8014318: d005         	beq	0x8014326 <finalize_cancel_locked+0xa6> @ imm = #0xa
 801431a: 697b         	ldr	r3, [r7, #0x14]
 801431c: 4618         	mov	r0, r3
 801431e: f011 fb86    	bl	0x8025a2e <sys_slist_peek_next> @ imm = #0x1170c
 8014322: 4603         	mov	r3, r0
 8014324: e002         	b	0x801432c <finalize_cancel_locked+0xac> @ imm = #0x4
 8014326: 2300         	movs	r3, #0x0
 8014328: e000         	b	0x801432c <finalize_cancel_locked+0xac> @ imm = #0x0
 801432a: 2300         	movs	r3, #0x0
 801432c: 613b         	str	r3, [r7, #0x10]
 801432e: 697b         	ldr	r3, [r7, #0x14]
 8014330: 2b00         	cmp	r3, #0x0
 8014332: d1d3         	bne	0x80142dc <finalize_cancel_locked+0x5c> @ imm = #-0x5a
; }
 8014334: bf00         	nop
 8014336: bf00         	nop
 8014338: 3718         	adds	r7, #0x18
 801433a: 46bd         	mov	sp, r7
 801433c: bd80         	pop	{r7, pc}
 801433e: bf00         	nop

08014340 <$d>:
 8014340: e4 32 00 20  	.word	0x200032e4

08014344 <k_work_busy_get>:
; {
 8014344: b580         	push	{r7, lr}
 8014346: b090         	sub	sp, #0x40
 8014348: af00         	add	r7, sp, #0x0
 801434a: 6078         	str	r0, [r7, #0x4]
 801434c: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80143b4 <k_work_busy_get+0x70>
 801434e: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8014350: f3ef 8311    	mrs	r3, basepri
 8014354: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 8014356: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 8014358: 627b         	str	r3, [r7, #0x24]
 801435a: 2310         	movs	r3, #0x10
 801435c: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801435e: 6a3b         	ldr	r3, [r7, #0x20]
 8014360: f383 8812    	msr	basepri_max, r3
; }
 8014364: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014366: f3bf 8f6f    	isb	sy
; }
 801436a: bf00         	nop
; 	return key;
 801436c: 6a7b         	ldr	r3, [r7, #0x24]
; 	k.key = arch_irq_lock();
 801436e: 613b         	str	r3, [r7, #0x10]
 8014370: 6afb         	ldr	r3, [r7, #0x2c]
 8014372: 61fb         	str	r3, [r7, #0x1c]
; }
 8014374: bf00         	nop
 8014376: 6afb         	ldr	r3, [r7, #0x2c]
 8014378: 61bb         	str	r3, [r7, #0x18]
; }
 801437a: bf00         	nop
; 	return k;
 801437c: 693b         	ldr	r3, [r7, #0x10]
 801437e: 617b         	str	r3, [r7, #0x14]
; 	int ret = work_busy_get_locked(work);
 8014380: 6878         	ldr	r0, [r7, #0x4]
 8014382: f011 fd47    	bl	0x8025e14 <work_busy_get_locked> @ imm = #0x11a8e
 8014386: 63f8         	str	r0, [r7, #0x3c]
 8014388: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80143b4 <k_work_busy_get+0x70>
 801438a: 63bb         	str	r3, [r7, #0x38]
 801438c: 697b         	ldr	r3, [r7, #0x14]
 801438e: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8014390: 68fb         	ldr	r3, [r7, #0xc]
 8014392: 637b         	str	r3, [r7, #0x34]
 8014394: 6b7b         	ldr	r3, [r7, #0x34]
 8014396: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8014398: 6b3b         	ldr	r3, [r7, #0x30]
 801439a: f383 8811    	msr	basepri, r3
; }
 801439e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80143a0: f3bf 8f6f    	isb	sy
; }
 80143a4: bf00         	nop
; }
 80143a6: bf00         	nop
; }
 80143a8: bf00         	nop
; 	return ret;
 80143aa: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 80143ac: 4618         	mov	r0, r3
 80143ae: 3740         	adds	r7, #0x40
 80143b0: 46bd         	mov	sp, r7
 80143b2: bd80         	pop	{r7, pc}

080143b4 <$d>:
 80143b4: e4 32 00 20  	.word	0x200032e4

080143b8 <queue_submit_locked>:
; {
 80143b8: b580         	push	{r7, lr}
 80143ba: b086         	sub	sp, #0x18
 80143bc: af00         	add	r7, sp, #0x0
 80143be: 6078         	str	r0, [r7, #0x4]
 80143c0: 6039         	str	r1, [r7]
; 	if (queue == NULL) {
 80143c2: 687b         	ldr	r3, [r7, #0x4]
 80143c4: 2b00         	cmp	r3, #0x0
 80143c6: d102         	bne	0x80143ce <queue_submit_locked+0x16> @ imm = #0x4
; 		return -EINVAL;
 80143c8: f06f 0315    	mvn	r3, #0x15
 80143cc: e061         	b	0x8014492 <queue_submit_locked+0xda> @ imm = #0xc2
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80143ce: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x801449c <queue_submit_locked+0xe4>
 80143d0: 689b         	ldr	r3, [r3, #0x8]
 80143d2: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 80143d4: 68fa         	ldr	r2, [r7, #0xc]
; 	bool chained = (arch_current_thread() == &queue->thread) && !k_is_in_isr();
 80143d6: 687b         	ldr	r3, [r7, #0x4]
 80143d8: 429a         	cmp	r2, r3
 80143da: d109         	bne	0x80143f0 <queue_submit_locked+0x38> @ imm = #0x12
 80143dc: f011 fefe    	bl	0x80261dc <k_is_in_isr> @ imm = #0x11dfc
 80143e0: 4603         	mov	r3, r0
 80143e2: f083 0301    	eor	r3, r3, #0x1
 80143e6: b2db         	uxtb	r3, r3
 80143e8: 2b00         	cmp	r3, #0x0
 80143ea: d001         	beq	0x80143f0 <queue_submit_locked+0x38> @ imm = #0x2
 80143ec: 2301         	movs	r3, #0x1
 80143ee: e000         	b	0x80143f2 <queue_submit_locked+0x3a> @ imm = #0x0
 80143f0: 2300         	movs	r3, #0x0
 80143f2: 74fb         	strb	r3, [r7, #0x13]
 80143f4: 7cfb         	ldrb	r3, [r7, #0x13]
 80143f6: f003 0301    	and	r3, r3, #0x1
 80143fa: 74fb         	strb	r3, [r7, #0x13]
; 	bool draining = flag_test(&queue->flags, K_WORK_QUEUE_DRAIN_BIT);
 80143fc: 687b         	ldr	r3, [r7, #0x4]
 80143fe: f503 7398    	add.w	r3, r3, #0x130
 8014402: 2102         	movs	r1, #0x2
 8014404: 4618         	mov	r0, r3
 8014406: f011 fca9    	bl	0x8025d5c <flag_test>   @ imm = #0x11952
 801440a: 4603         	mov	r3, r0
 801440c: 74bb         	strb	r3, [r7, #0x12]
; 	bool plugged = flag_test(&queue->flags, K_WORK_QUEUE_PLUGGED_BIT);
 801440e: 687b         	ldr	r3, [r7, #0x4]
 8014410: f503 7398    	add.w	r3, r3, #0x130
 8014414: 2103         	movs	r1, #0x3
 8014416: 4618         	mov	r0, r3
 8014418: f011 fca0    	bl	0x8025d5c <flag_test>   @ imm = #0x11940
 801441c: 4603         	mov	r3, r0
 801441e: 747b         	strb	r3, [r7, #0x11]
; 	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
 8014420: 687b         	ldr	r3, [r7, #0x4]
 8014422: f503 7398    	add.w	r3, r3, #0x130
 8014426: 2100         	movs	r1, #0x0
 8014428: 4618         	mov	r0, r3
 801442a: f011 fc97    	bl	0x8025d5c <flag_test>   @ imm = #0x1192e
 801442e: 4603         	mov	r3, r0
 8014430: f083 0301    	eor	r3, r3, #0x1
 8014434: b2db         	uxtb	r3, r3
 8014436: 2b00         	cmp	r3, #0x0
 8014438: d003         	beq	0x8014442 <queue_submit_locked+0x8a> @ imm = #0x6
; 		ret = -ENODEV;
 801443a: f06f 0312    	mvn	r3, #0x12
 801443e: 617b         	str	r3, [r7, #0x14]
 8014440: e026         	b	0x8014490 <queue_submit_locked+0xd8> @ imm = #0x4c
; 	} else if (draining && !chained) {
 8014442: 7cbb         	ldrb	r3, [r7, #0x12]
 8014444: 2b00         	cmp	r3, #0x0
 8014446: d009         	beq	0x801445c <queue_submit_locked+0xa4> @ imm = #0x12
 8014448: 7cfb         	ldrb	r3, [r7, #0x13]
 801444a: f083 0301    	eor	r3, r3, #0x1
 801444e: b2db         	uxtb	r3, r3
 8014450: 2b00         	cmp	r3, #0x0
 8014452: d003         	beq	0x801445c <queue_submit_locked+0xa4> @ imm = #0x6
; 		ret = -EBUSY;
 8014454: f06f 030f    	mvn	r3, #0xf
 8014458: 617b         	str	r3, [r7, #0x14]
 801445a: e019         	b	0x8014490 <queue_submit_locked+0xd8> @ imm = #0x32
; 	} else if (plugged && !draining) {
 801445c: 7c7b         	ldrb	r3, [r7, #0x11]
 801445e: 2b00         	cmp	r3, #0x0
 8014460: d009         	beq	0x8014476 <queue_submit_locked+0xbe> @ imm = #0x12
 8014462: 7cbb         	ldrb	r3, [r7, #0x12]
 8014464: f083 0301    	eor	r3, r3, #0x1
 8014468: b2db         	uxtb	r3, r3
 801446a: 2b00         	cmp	r3, #0x0
 801446c: d003         	beq	0x8014476 <queue_submit_locked+0xbe> @ imm = #0x6
; 		ret = -EBUSY;
 801446e: f06f 030f    	mvn	r3, #0xf
 8014472: 617b         	str	r3, [r7, #0x14]
 8014474: e00c         	b	0x8014490 <queue_submit_locked+0xd8> @ imm = #0x18
; 		sys_slist_append(&queue->pending, &work->node);
 8014476: 687b         	ldr	r3, [r7, #0x4]
 8014478: f503 738c    	add.w	r3, r3, #0x118
 801447c: 683a         	ldr	r2, [r7]
 801447e: 4611         	mov	r1, r2
 8014480: 4618         	mov	r0, r3
 8014482: f011 fae5    	bl	0x8025a50 <sys_slist_append> @ imm = #0x115ca
; 		ret = 1;
 8014486: 2301         	movs	r3, #0x1
 8014488: 617b         	str	r3, [r7, #0x14]
; 		(void)notify_queue_locked(queue);
 801448a: 6878         	ldr	r0, [r7, #0x4]
 801448c: f011 fcec    	bl	0x8025e68 <notify_queue_locked> @ imm = #0x119d8
; 	return ret;
 8014490: 697b         	ldr	r3, [r7, #0x14]
; }
 8014492: 4618         	mov	r0, r3
 8014494: 3718         	adds	r7, #0x18
 8014496: 46bd         	mov	sp, r7
 8014498: bd80         	pop	{r7, pc}
 801449a: bf00         	nop

0801449c <$d>:
 801449c: a8 25 00 20  	.word	0x200025a8

080144a0 <z_work_submit_to_queue>:
; {
 80144a0: b580         	push	{r7, lr}
 80144a2: b090         	sub	sp, #0x40
 80144a4: af00         	add	r7, sp, #0x0
 80144a6: 6078         	str	r0, [r7, #0x4]
 80144a8: 6039         	str	r1, [r7]
 80144aa: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8014518 <z_work_submit_to_queue+0x78>
 80144ac: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80144ae: f3ef 8311    	mrs	r3, basepri
 80144b2: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 80144b4: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 80144b6: 627b         	str	r3, [r7, #0x24]
 80144b8: 2310         	movs	r3, #0x10
 80144ba: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80144bc: 6a3b         	ldr	r3, [r7, #0x20]
 80144be: f383 8812    	msr	basepri_max, r3
; }
 80144c2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80144c4: f3bf 8f6f    	isb	sy
; }
 80144c8: bf00         	nop
; 	return key;
 80144ca: 6a7b         	ldr	r3, [r7, #0x24]
; 	k.key = arch_irq_lock();
 80144cc: 613b         	str	r3, [r7, #0x10]
 80144ce: 6afb         	ldr	r3, [r7, #0x2c]
 80144d0: 61fb         	str	r3, [r7, #0x1c]
; }
 80144d2: bf00         	nop
 80144d4: 6afb         	ldr	r3, [r7, #0x2c]
 80144d6: 61bb         	str	r3, [r7, #0x18]
; }
 80144d8: bf00         	nop
; 	return k;
 80144da: 693b         	ldr	r3, [r7, #0x10]
 80144dc: 617b         	str	r3, [r7, #0x14]
; 	int ret = submit_to_queue_locked(work, &queue);
 80144de: 1d3b         	adds	r3, r7, #0x4
 80144e0: 4619         	mov	r1, r3
 80144e2: 6838         	ldr	r0, [r7]
 80144e4: f011 fcd8    	bl	0x8025e98 <submit_to_queue_locked> @ imm = #0x119b0
 80144e8: 63f8         	str	r0, [r7, #0x3c]
 80144ea: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8014518 <z_work_submit_to_queue+0x78>
 80144ec: 63bb         	str	r3, [r7, #0x38]
 80144ee: 697b         	ldr	r3, [r7, #0x14]
 80144f0: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 80144f2: 68fb         	ldr	r3, [r7, #0xc]
 80144f4: 637b         	str	r3, [r7, #0x34]
 80144f6: 6b7b         	ldr	r3, [r7, #0x34]
 80144f8: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80144fa: 6b3b         	ldr	r3, [r7, #0x30]
 80144fc: f383 8811    	msr	basepri, r3
; }
 8014500: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014502: f3bf 8f6f    	isb	sy
; }
 8014506: bf00         	nop
; }
 8014508: bf00         	nop
; }
 801450a: bf00         	nop
; 	return ret;
 801450c: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 801450e: 4618         	mov	r0, r3
 8014510: 3740         	adds	r7, #0x40
 8014512: 46bd         	mov	sp, r7
 8014514: bd80         	pop	{r7, pc}
 8014516: bf00         	nop

08014518 <$d>:
 8014518: e4 32 00 20  	.word	0x200032e4

0801451c <work_queue_main>:
; {
 801451c: b580         	push	{r7, lr}
 801451e: b0a4         	sub	sp, #0x90
 8014520: af04         	add	r7, sp, #0x10
 8014522: 60f8         	str	r0, [r7, #0xc]
 8014524: 60b9         	str	r1, [r7, #0x8]
 8014526: 607a         	str	r2, [r7, #0x4]
; 	struct k_work_q *queue = (struct k_work_q *)workq_ptr;
 8014528: 68fb         	ldr	r3, [r7, #0xc]
 801452a: 677b         	str	r3, [r7, #0x74]
; 		struct k_work *work = NULL;
 801452c: 2300         	movs	r3, #0x0
 801452e: 67fb         	str	r3, [r7, #0x7c]
; 		k_work_handler_t handler = NULL;
 8014530: 2300         	movs	r3, #0x0
 8014532: 67bb         	str	r3, [r7, #0x78]
 8014534: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8014704 <work_queue_main+0x1e8>
 8014536: 66bb         	str	r3, [r7, #0x68]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8014538: f3ef 8311    	mrs	r3, basepri
 801453c: 667b         	str	r3, [r7, #0x64]
;   return(result);
 801453e: 6e7b         	ldr	r3, [r7, #0x64]
; 	key = __get_BASEPRI();
 8014540: 663b         	str	r3, [r7, #0x60]
 8014542: 2310         	movs	r3, #0x10
 8014544: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8014546: 6dfb         	ldr	r3, [r7, #0x5c]
 8014548: f383 8812    	msr	basepri_max, r3
; }
 801454c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801454e: f3bf 8f6f    	isb	sy
; }
 8014552: bf00         	nop
; 	return key;
 8014554: 6e3b         	ldr	r3, [r7, #0x60]
; 	k.key = arch_irq_lock();
 8014556: 613b         	str	r3, [r7, #0x10]
 8014558: 6ebb         	ldr	r3, [r7, #0x68]
 801455a: 65bb         	str	r3, [r7, #0x58]
; }
 801455c: bf00         	nop
 801455e: 6ebb         	ldr	r3, [r7, #0x68]
 8014560: 657b         	str	r3, [r7, #0x54]
; }
 8014562: bf00         	nop
; 	return k;
 8014564: 693b         	ldr	r3, [r7, #0x10]
 8014566: 623b         	str	r3, [r7, #0x20]
; 		node = sys_slist_get(&queue->pending);
 8014568: 6f7b         	ldr	r3, [r7, #0x74]
 801456a: f503 738c    	add.w	r3, r3, #0x118
 801456e: 4618         	mov	r0, r3
 8014570: f011 fab9    	bl	0x8025ae6 <sys_slist_get> @ imm = #0x11572
 8014574: 6738         	str	r0, [r7, #0x70]
; 		if (node != NULL) {
 8014576: 6f3b         	ldr	r3, [r7, #0x70]
 8014578: 2b00         	cmp	r3, #0x0
 801457a: d018         	beq	0x80145ae <work_queue_main+0x92> @ imm = #0x30
; 			flag_set(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 801457c: 6f7b         	ldr	r3, [r7, #0x74]
 801457e: f503 7398    	add.w	r3, r3, #0x130
 8014582: 2101         	movs	r1, #0x1
 8014584: 4618         	mov	r0, r3
 8014586: f011 fbd5    	bl	0x8025d34 <flag_set>    @ imm = #0x117aa
; 			work = CONTAINER_OF(node, struct k_work, node);
 801458a: 6f3b         	ldr	r3, [r7, #0x70]
 801458c: 67fb         	str	r3, [r7, #0x7c]
; 			flag_set(&work->flags, K_WORK_RUNNING_BIT);
 801458e: 6ffb         	ldr	r3, [r7, #0x7c]
 8014590: 330c         	adds	r3, #0xc
 8014592: 2100         	movs	r1, #0x0
 8014594: 4618         	mov	r0, r3
 8014596: f011 fbcd    	bl	0x8025d34 <flag_set>    @ imm = #0x1179a
; 			flag_clear(&work->flags, K_WORK_QUEUED_BIT);
 801459a: 6ffb         	ldr	r3, [r7, #0x7c]
 801459c: 330c         	adds	r3, #0xc
 801459e: 2102         	movs	r1, #0x2
 80145a0: 4618         	mov	r0, r3
 80145a2: f011 fbb2    	bl	0x8025d0a <flag_clear>  @ imm = #0x11764
; 			handler = work->handler;
 80145a6: 6ffb         	ldr	r3, [r7, #0x7c]
 80145a8: 685b         	ldr	r3, [r3, #0x4]
 80145aa: 67bb         	str	r3, [r7, #0x78]
 80145ac: e011         	b	0x80145d2 <work_queue_main+0xb6> @ imm = #0x22
; 		} else if (flag_test_and_clear(&queue->flags, K_WORK_QUEUE_DRAIN_BIT)) {
 80145ae: 6f7b         	ldr	r3, [r7, #0x74]
 80145b0: f503 7398    	add.w	r3, r3, #0x130
 80145b4: 2102         	movs	r1, #0x2
 80145b6: 4618         	mov	r0, r3
 80145b8: f011 fbe7    	bl	0x8025d8a <flag_test_and_clear> @ imm = #0x117ce
 80145bc: 4603         	mov	r3, r0
 80145be: 2b00         	cmp	r3, #0x0
 80145c0: d007         	beq	0x80145d2 <work_queue_main+0xb6> @ imm = #0xe
; 			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
 80145c2: 6f7b         	ldr	r3, [r7, #0x74]
 80145c4: f503 7394    	add.w	r3, r3, #0x128
 80145c8: 2200         	movs	r2, #0x0
 80145ca: 2101         	movs	r1, #0x1
 80145cc: 4618         	mov	r0, r3
 80145ce: f011 fb84    	bl	0x8025cda <z_sched_wake_all> @ imm = #0x11708
; 		if (work == NULL) {
 80145d2: 6ffb         	ldr	r3, [r7, #0x7c]
 80145d4: 2b00         	cmp	r3, #0x0
 80145d6: d111         	bne	0x80145fc <work_queue_main+0xe0> @ imm = #0x22
; 			(void)z_sched_wait(&lock, key, &queue->notifyq, K_FOREVER, NULL);
 80145d8: 6f7b         	ldr	r3, [r7, #0x74]
 80145da: f503 7190    	add.w	r1, r3, #0x120
 80145de: f04f 32ff    	mov.w	r2, #0xffffffff
 80145e2: f04f 33ff    	mov.w	r3, #0xffffffff
 80145e6: 2000         	movs	r0, #0x0
 80145e8: 9002         	str	r0, [sp, #0x8]
 80145ea: e9cd 2300    	strd	r2, r3, [sp]
 80145ee: 460a         	mov	r2, r1
 80145f0: 6a39         	ldr	r1, [r7, #0x20]
 80145f2: 4844         	ldr	r0, [pc, #0x110]        @ 0x8014704 <work_queue_main+0x1e8>
 80145f4: f002 f894    	bl	0x8016720 <z_sched_wait> @ imm = #0x2128
; 			continue;
 80145f8: bf00         	nop
 80145fa: e797         	b	0x801452c <work_queue_main+0x10> @ imm = #-0xd2
 80145fc: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8014704 <work_queue_main+0x1e8>
 80145fe: 63bb         	str	r3, [r7, #0x38]
 8014600: 6a3b         	ldr	r3, [r7, #0x20]
 8014602: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8014604: 69bb         	ldr	r3, [r7, #0x18]
 8014606: 637b         	str	r3, [r7, #0x34]
 8014608: 6b7b         	ldr	r3, [r7, #0x34]
 801460a: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801460c: 6b3b         	ldr	r3, [r7, #0x30]
 801460e: f383 8811    	msr	basepri, r3
; }
 8014612: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014614: f3bf 8f6f    	isb	sy
; }
 8014618: bf00         	nop
; }
 801461a: bf00         	nop
; }
 801461c: bf00         	nop
; 		handler(work);
 801461e: 6fbb         	ldr	r3, [r7, #0x78]
 8014620: 6ff8         	ldr	r0, [r7, #0x7c]
 8014622: 4798         	blx	r3
 8014624: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8014704 <work_queue_main+0x1e8>
 8014626: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8014628: f3ef 8311    	mrs	r3, basepri
 801462c: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 801462e: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 8014630: 64bb         	str	r3, [r7, #0x48]
 8014632: 2310         	movs	r3, #0x10
 8014634: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8014636: 6c7b         	ldr	r3, [r7, #0x44]
 8014638: f383 8812    	msr	basepri_max, r3
; }
 801463c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801463e: f3bf 8f6f    	isb	sy
; }
 8014642: bf00         	nop
; 	return key;
 8014644: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 8014646: 617b         	str	r3, [r7, #0x14]
 8014648: 6d3b         	ldr	r3, [r7, #0x50]
 801464a: 643b         	str	r3, [r7, #0x40]
; }
 801464c: bf00         	nop
 801464e: 6d3b         	ldr	r3, [r7, #0x50]
 8014650: 63fb         	str	r3, [r7, #0x3c]
; }
 8014652: bf00         	nop
; 	return k;
 8014654: 697b         	ldr	r3, [r7, #0x14]
 8014656: 623b         	str	r3, [r7, #0x20]
; 		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
 8014658: 6ffb         	ldr	r3, [r7, #0x7c]
 801465a: 330c         	adds	r3, #0xc
 801465c: 2100         	movs	r1, #0x0
 801465e: 4618         	mov	r0, r3
 8014660: f011 fb53    	bl	0x8025d0a <flag_clear>  @ imm = #0x116a6
; 		if (flag_test(&work->flags, K_WORK_FLUSHING_BIT)) {
 8014664: 6ffb         	ldr	r3, [r7, #0x7c]
 8014666: 330c         	adds	r3, #0xc
 8014668: 2104         	movs	r1, #0x4
 801466a: 4618         	mov	r0, r3
 801466c: f011 fb76    	bl	0x8025d5c <flag_test>   @ imm = #0x116ec
 8014670: 4603         	mov	r3, r0
 8014672: 2b00         	cmp	r3, #0x0
 8014674: d002         	beq	0x801467c <work_queue_main+0x160> @ imm = #0x4
; 			finalize_flush_locked(work);
 8014676: 6ff8         	ldr	r0, [r7, #0x7c]
 8014678: f011 fbb7    	bl	0x8025dea <finalize_flush_locked> @ imm = #0x1176e
; 		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 801467c: 6ffb         	ldr	r3, [r7, #0x7c]
 801467e: 330c         	adds	r3, #0xc
 8014680: 2101         	movs	r1, #0x1
 8014682: 4618         	mov	r0, r3
 8014684: f011 fb6a    	bl	0x8025d5c <flag_test>   @ imm = #0x116d4
 8014688: 4603         	mov	r3, r0
 801468a: 2b00         	cmp	r3, #0x0
 801468c: d002         	beq	0x8014694 <work_queue_main+0x178> @ imm = #0x4
; 			finalize_cancel_locked(work);
 801468e: 6ff8         	ldr	r0, [r7, #0x7c]
 8014690: f7ff fdf6    	bl	0x8014280 <finalize_cancel_locked> @ imm = #-0x414
; 		flag_clear(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 8014694: 6f7b         	ldr	r3, [r7, #0x74]
 8014696: f503 7398    	add.w	r3, r3, #0x130
 801469a: 2101         	movs	r1, #0x1
 801469c: 4618         	mov	r0, r3
 801469e: f011 fb34    	bl	0x8025d0a <flag_clear>  @ imm = #0x11668
; 		yield = !flag_test(&queue->flags, K_WORK_QUEUE_NO_YIELD_BIT);
 80146a2: 6f7b         	ldr	r3, [r7, #0x74]
 80146a4: f503 7398    	add.w	r3, r3, #0x130
 80146a8: 2108         	movs	r1, #0x8
 80146aa: 4618         	mov	r0, r3
 80146ac: f011 fb56    	bl	0x8025d5c <flag_test>   @ imm = #0x116ac
 80146b0: 4603         	mov	r3, r0
 80146b2: 2b00         	cmp	r3, #0x0
 80146b4: bf14         	ite	ne
 80146b6: 2301         	movne	r3, #0x1
 80146b8: 2300         	moveq	r3, #0x0
 80146ba: b2db         	uxtb	r3, r3
 80146bc: f083 0301    	eor	r3, r3, #0x1
 80146c0: b2db         	uxtb	r3, r3
 80146c2: f887 306f    	strb.w	r3, [r7, #0x6f]
 80146c6: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 80146ca: f003 0301    	and	r3, r3, #0x1
 80146ce: f887 306f    	strb.w	r3, [r7, #0x6f]
 80146d2: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8014704 <work_queue_main+0x1e8>
 80146d4: 62fb         	str	r3, [r7, #0x2c]
 80146d6: 6a3b         	ldr	r3, [r7, #0x20]
 80146d8: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 80146da: 69fb         	ldr	r3, [r7, #0x1c]
 80146dc: 62bb         	str	r3, [r7, #0x28]
 80146de: 6abb         	ldr	r3, [r7, #0x28]
 80146e0: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80146e2: 6a7b         	ldr	r3, [r7, #0x24]
 80146e4: f383 8811    	msr	basepri, r3
; }
 80146e8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80146ea: f3bf 8f6f    	isb	sy
; }
 80146ee: bf00         	nop
; }
 80146f0: bf00         	nop
; }
 80146f2: bf00         	nop
; 		if (yield) {
 80146f4: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 80146f8: 2b00         	cmp	r3, #0x0
 80146fa: f43f af17    	beq.w	0x801452c <work_queue_main+0x10> @ imm = #-0x1d2
; 			k_yield();
 80146fe: f011 fa91    	bl	0x8025c24 <k_yield>     @ imm = #0x11522
; 	while (true) {
 8014702: e713         	b	0x801452c <work_queue_main+0x10> @ imm = #-0x1da

08014704 <$d>:
 8014704: e4 32 00 20  	.word	0x200032e4

08014708 <k_work_queue_start>:
; {
 8014708: b580         	push	{r7, lr}
 801470a: b08e         	sub	sp, #0x38
 801470c: af08         	add	r7, sp, #0x20
 801470e: 60f8         	str	r0, [r7, #0xc]
 8014710: 60b9         	str	r1, [r7, #0x8]
 8014712: 607a         	str	r2, [r7, #0x4]
 8014714: 603b         	str	r3, [r7]
; 	uint32_t flags = K_WORK_QUEUE_STARTED;
 8014716: 2301         	movs	r3, #0x1
 8014718: 617b         	str	r3, [r7, #0x14]
; 	sys_slist_init(&queue->pending);
 801471a: 68fb         	ldr	r3, [r7, #0xc]
 801471c: f503 738c    	add.w	r3, r3, #0x118
 8014720: 4618         	mov	r0, r3
 8014722: f011 f909    	bl	0x8025938 <sys_slist_init> @ imm = #0x11212
; 	z_waitq_init(&queue->notifyq);
 8014726: 68fb         	ldr	r3, [r7, #0xc]
 8014728: f503 7390    	add.w	r3, r3, #0x120
 801472c: 4618         	mov	r0, r3
 801472e: f011 faaf    	bl	0x8025c90 <z_waitq_init> @ imm = #0x1155e
; 	z_waitq_init(&queue->drainq);
 8014732: 68fb         	ldr	r3, [r7, #0xc]
 8014734: f503 7394    	add.w	r3, r3, #0x128
 8014738: 4618         	mov	r0, r3
 801473a: f011 faa9    	bl	0x8025c90 <z_waitq_init> @ imm = #0x11552
; 	if ((cfg != NULL) && cfg->no_yield) {
 801473e: 6a3b         	ldr	r3, [r7, #0x20]
 8014740: 2b00         	cmp	r3, #0x0
 8014742: d007         	beq	0x8014754 <k_work_queue_start+0x4c> @ imm = #0xe
 8014744: 6a3b         	ldr	r3, [r7, #0x20]
 8014746: 791b         	ldrb	r3, [r3, #0x4]
 8014748: 2b00         	cmp	r3, #0x0
 801474a: d003         	beq	0x8014754 <k_work_queue_start+0x4c> @ imm = #0x6
; 		flags |= K_WORK_QUEUE_NO_YIELD;
 801474c: 697b         	ldr	r3, [r7, #0x14]
 801474e: f443 7380    	orr	r3, r3, #0x100
 8014752: 617b         	str	r3, [r7, #0x14]
; 	flags_set(&queue->flags, flags);
 8014754: 68fb         	ldr	r3, [r7, #0xc]
 8014756: f503 7398    	add.w	r3, r3, #0x130
 801475a: 6979         	ldr	r1, [r7, #0x14]
 801475c: 4618         	mov	r0, r3
 801475e: f011 fb2a    	bl	0x8025db6 <flags_set>   @ imm = #0x11654
; 	(void)k_thread_create(&queue->thread, stack, stack_size, work_queue_main, queue, NULL, NULL,
 8014762: 68f8         	ldr	r0, [r7, #0xc]
; 			      prio, 0, K_FOREVER);
 8014764: f04f 32ff    	mov.w	r2, #0xffffffff
 8014768: f04f 33ff    	mov.w	r3, #0xffffffff
; 	(void)k_thread_create(&queue->thread, stack, stack_size, work_queue_main, queue, NULL, NULL,
 801476c: e9cd 2306    	strd	r2, r3, [sp, #24]
 8014770: 2300         	movs	r3, #0x0
 8014772: 9304         	str	r3, [sp, #0x10]
 8014774: 683b         	ldr	r3, [r7]
 8014776: 9303         	str	r3, [sp, #0xc]
 8014778: 2300         	movs	r3, #0x0
 801477a: 9302         	str	r3, [sp, #0x8]
 801477c: 2300         	movs	r3, #0x0
 801477e: 9301         	str	r3, [sp, #0x4]
 8014780: 68fb         	ldr	r3, [r7, #0xc]
 8014782: 9300         	str	r3, [sp]
 8014784: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80147d8 <k_work_queue_start+0xd0>
 8014786: 687a         	ldr	r2, [r7, #0x4]
 8014788: 68b9         	ldr	r1, [r7, #0x8]
 801478a: f011 fa2b    	bl	0x8025be4 <k_thread_create> @ imm = #0x11456
; 	if ((cfg != NULL) && (cfg->name != NULL)) {
 801478e: 6a3b         	ldr	r3, [r7, #0x20]
 8014790: 2b00         	cmp	r3, #0x0
 8014792: d00a         	beq	0x80147aa <k_work_queue_start+0xa2> @ imm = #0x14
 8014794: 6a3b         	ldr	r3, [r7, #0x20]
 8014796: 681b         	ldr	r3, [r3]
 8014798: 2b00         	cmp	r3, #0x0
 801479a: d006         	beq	0x80147aa <k_work_queue_start+0xa2> @ imm = #0xc
; 		k_thread_name_set(&queue->thread, cfg->name);
 801479c: 68fa         	ldr	r2, [r7, #0xc]
 801479e: 6a3b         	ldr	r3, [r7, #0x20]
 80147a0: 681b         	ldr	r3, [r3]
 80147a2: 4619         	mov	r1, r3
 80147a4: 4610         	mov	r0, r2
 80147a6: f011 fa4e    	bl	0x8025c46 <k_thread_name_set> @ imm = #0x1149c
; 	if ((cfg != NULL) && (cfg->essential)) {
 80147aa: 6a3b         	ldr	r3, [r7, #0x20]
 80147ac: 2b00         	cmp	r3, #0x0
 80147ae: d00a         	beq	0x80147c6 <k_work_queue_start+0xbe> @ imm = #0x14
 80147b0: 6a3b         	ldr	r3, [r7, #0x20]
 80147b2: 795b         	ldrb	r3, [r3, #0x5]
 80147b4: 2b00         	cmp	r3, #0x0
 80147b6: d006         	beq	0x80147c6 <k_work_queue_start+0xbe> @ imm = #0xc
; 		queue->thread.base.user_options |= K_ESSENTIAL;
 80147b8: 68fb         	ldr	r3, [r7, #0xc]
 80147ba: 7b1b         	ldrb	r3, [r3, #0xc]
 80147bc: f043 0301    	orr	r3, r3, #0x1
 80147c0: b2da         	uxtb	r2, r3
 80147c2: 68fb         	ldr	r3, [r7, #0xc]
 80147c4: 731a         	strb	r2, [r3, #0xc]
; 	k_thread_start(&queue->thread);
 80147c6: 68fb         	ldr	r3, [r7, #0xc]
 80147c8: 4618         	mov	r0, r3
 80147ca: f011 fa00    	bl	0x8025bce <k_thread_start> @ imm = #0x11400
; }
 80147ce: bf00         	nop
 80147d0: 3718         	adds	r7, #0x18
 80147d2: 46bd         	mov	sp, r7
 80147d4: bd80         	pop	{r7, pc}
 80147d6: bf00         	nop

080147d8 <$d>:
 80147d8: 1d 45 01 08  	.word	0x0801451d

080147dc <work_timeout>:
; {
 80147dc: b580         	push	{r7, lr}
 80147de: b092         	sub	sp, #0x48
 80147e0: af00         	add	r7, sp, #0x0
 80147e2: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dw = CONTAINER_OF(to, struct k_work_delayable, timeout);
 80147e4: 687b         	ldr	r3, [r7, #0x4]
 80147e6: 3b10         	subs	r3, #0x10
 80147e8: 647b         	str	r3, [r7, #0x44]
; 	struct k_work *wp = &dw->work;
 80147ea: 6c7b         	ldr	r3, [r7, #0x44]
 80147ec: 643b         	str	r3, [r7, #0x40]
 80147ee: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8014874 <work_timeout+0x98>
 80147f0: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80147f2: f3ef 8311    	mrs	r3, basepri
 80147f6: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 80147f8: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 80147fa: 637b         	str	r3, [r7, #0x34]
 80147fc: 2310         	movs	r3, #0x10
 80147fe: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8014800: 6b3b         	ldr	r3, [r7, #0x30]
 8014802: f383 8812    	msr	basepri_max, r3
; }
 8014806: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014808: f3bf 8f6f    	isb	sy
; }
 801480c: bf00         	nop
; 	return key;
 801480e: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 8014810: 60fb         	str	r3, [r7, #0xc]
 8014812: 6bfb         	ldr	r3, [r7, #0x3c]
 8014814: 62fb         	str	r3, [r7, #0x2c]
; }
 8014816: bf00         	nop
 8014818: 6bfb         	ldr	r3, [r7, #0x3c]
 801481a: 62bb         	str	r3, [r7, #0x28]
; }
 801481c: bf00         	nop
; 	return k;
 801481e: 68fb         	ldr	r3, [r7, #0xc]
 8014820: 61bb         	str	r3, [r7, #0x18]
; 	struct k_work_q *queue = NULL;
 8014822: 2300         	movs	r3, #0x0
 8014824: 617b         	str	r3, [r7, #0x14]
; 	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
 8014826: 6c3b         	ldr	r3, [r7, #0x40]
 8014828: 330c         	adds	r3, #0xc
 801482a: 2103         	movs	r1, #0x3
 801482c: 4618         	mov	r0, r3
 801482e: f011 faac    	bl	0x8025d8a <flag_test_and_clear> @ imm = #0x11558
 8014832: 4603         	mov	r3, r0
 8014834: 2b00         	cmp	r3, #0x0
 8014836: d008         	beq	0x801484a <work_timeout+0x6e> @ imm = #0x10
; 		queue = dw->queue;
 8014838: 6c7b         	ldr	r3, [r7, #0x44]
 801483a: 6a9b         	ldr	r3, [r3, #0x28]
 801483c: 617b         	str	r3, [r7, #0x14]
; 		(void)submit_to_queue_locked(wp, &queue);
 801483e: f107 0314    	add.w	r3, r7, #0x14
 8014842: 4619         	mov	r1, r3
 8014844: 6c38         	ldr	r0, [r7, #0x40]
 8014846: f011 fb27    	bl	0x8025e98 <submit_to_queue_locked> @ imm = #0x1164e
 801484a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8014874 <work_timeout+0x98>
 801484c: 627b         	str	r3, [r7, #0x24]
 801484e: 69bb         	ldr	r3, [r7, #0x18]
 8014850: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8014852: 693b         	ldr	r3, [r7, #0x10]
 8014854: 623b         	str	r3, [r7, #0x20]
 8014856: 6a3b         	ldr	r3, [r7, #0x20]
 8014858: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801485a: 69fb         	ldr	r3, [r7, #0x1c]
 801485c: f383 8811    	msr	basepri, r3
; }
 8014860: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014862: f3bf 8f6f    	isb	sy
; }
 8014866: bf00         	nop
; }
 8014868: bf00         	nop
; }
 801486a: bf00         	nop
; }
 801486c: bf00         	nop
 801486e: 3748         	adds	r7, #0x48
 8014870: 46bd         	mov	sp, r7
 8014872: bd80         	pop	{r7, pc}

08014874 <$d>:
 8014874: e4 32 00 20  	.word	0x200032e4

08014878 <schedule_for_queue_locked>:
; {
 8014878: b580         	push	{r7, lr}
 801487a: b086         	sub	sp, #0x18
 801487c: af00         	add	r7, sp, #0x0
 801487e: 60f8         	str	r0, [r7, #0xc]
 8014880: 60b9         	str	r1, [r7, #0x8]
 8014882: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = 1;
 8014886: 2301         	movs	r3, #0x1
 8014888: 617b         	str	r3, [r7, #0x14]
; 	struct k_work *work = &dwork->work;
 801488a: 68bb         	ldr	r3, [r7, #0x8]
 801488c: 613b         	str	r3, [r7, #0x10]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 801488e: e9d7 2300    	ldrd	r2, r3, [r7]
 8014892: f04f 0000    	mov.w	r0, #0x0
 8014896: f04f 0100    	mov.w	r1, #0x0
 801489a: 428b         	cmp	r3, r1
 801489c: bf08         	it	eq
 801489e: 4282         	cmpeq	r2, r0
 80148a0: d105         	bne	0x80148ae <schedule_for_queue_locked+0x36> @ imm = #0xa
; 		return submit_to_queue_locked(work, queuep);
 80148a2: 68f9         	ldr	r1, [r7, #0xc]
 80148a4: 6938         	ldr	r0, [r7, #0x10]
 80148a6: f011 faf7    	bl	0x8025e98 <submit_to_queue_locked> @ imm = #0x115ee
 80148aa: 4603         	mov	r3, r0
 80148ac: e012         	b	0x80148d4 <schedule_for_queue_locked+0x5c> @ imm = #0x24
; 	flag_set(&work->flags, K_WORK_DELAYED_BIT);
 80148ae: 693b         	ldr	r3, [r7, #0x10]
 80148b0: 330c         	adds	r3, #0xc
 80148b2: 2103         	movs	r1, #0x3
 80148b4: 4618         	mov	r0, r3
 80148b6: f011 fa3d    	bl	0x8025d34 <flag_set>    @ imm = #0x1147a
; 	dwork->queue = *queuep;
 80148ba: 68fb         	ldr	r3, [r7, #0xc]
 80148bc: 681a         	ldr	r2, [r3]
 80148be: 68bb         	ldr	r3, [r7, #0x8]
 80148c0: 629a         	str	r2, [r3, #0x28]
; 	z_add_timeout(&dwork->timeout, work_timeout, delay);
 80148c2: 68bb         	ldr	r3, [r7, #0x8]
 80148c4: f103 0010    	add.w	r0, r3, #0x10
 80148c8: e9d7 2300    	ldrd	r2, r3, [r7]
 80148cc: 4903         	ldr	r1, [pc, #0xc]          @ 0x80148dc <schedule_for_queue_locked+0x64>
 80148ce: f002 f9a5    	bl	0x8016c1c <z_add_timeout> @ imm = #0x234a
; 	return ret;
 80148d2: 697b         	ldr	r3, [r7, #0x14]
; }
 80148d4: 4618         	mov	r0, r3
 80148d6: 3718         	adds	r7, #0x18
 80148d8: 46bd         	mov	sp, r7
 80148da: bd80         	pop	{r7, pc}

080148dc <$d>:
 80148dc: dd 47 01 08  	.word	0x080147dd

080148e0 <k_work_reschedule_for_queue>:
; {
 80148e0: b580         	push	{r7, lr}
 80148e2: b092         	sub	sp, #0x48
 80148e4: af00         	add	r7, sp, #0x0
 80148e6: 60f8         	str	r0, [r7, #0xc]
 80148e8: 60b9         	str	r1, [r7, #0x8]
 80148ea: e9c7 2300    	strd	r2, r3, [r7]
 80148ee: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8014964 <k_work_reschedule_for_queue+0x84>
 80148f0: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80148f2: f3ef 8311    	mrs	r3, basepri
 80148f6: 633b         	str	r3, [r7, #0x30]
;   return(result);
 80148f8: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 80148fa: 62fb         	str	r3, [r7, #0x2c]
 80148fc: 2310         	movs	r3, #0x10
 80148fe: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8014900: 6abb         	ldr	r3, [r7, #0x28]
 8014902: f383 8812    	msr	basepri_max, r3
; }
 8014906: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014908: f3bf 8f6f    	isb	sy
; }
 801490c: bf00         	nop
; 	return key;
 801490e: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 8014910: 61bb         	str	r3, [r7, #0x18]
 8014912: 6b7b         	ldr	r3, [r7, #0x34]
 8014914: 627b         	str	r3, [r7, #0x24]
; }
 8014916: bf00         	nop
 8014918: 6b7b         	ldr	r3, [r7, #0x34]
 801491a: 623b         	str	r3, [r7, #0x20]
; }
 801491c: bf00         	nop
; 	return k;
 801491e: 69bb         	ldr	r3, [r7, #0x18]
 8014920: 61fb         	str	r3, [r7, #0x1c]
; 	(void)unschedule_locked(dwork);
 8014922: 68b8         	ldr	r0, [r7, #0x8]
 8014924: f011 fb88    	bl	0x8026038 <unschedule_locked> @ imm = #0x11710
; 	ret = schedule_for_queue_locked(&queue, dwork, delay);
 8014928: f107 000c    	add.w	r0, r7, #0xc
 801492c: e9d7 2300    	ldrd	r2, r3, [r7]
 8014930: 68b9         	ldr	r1, [r7, #0x8]
 8014932: f7ff ffa1    	bl	0x8014878 <schedule_for_queue_locked> @ imm = #-0xbe
 8014936: 6478         	str	r0, [r7, #0x44]
 8014938: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8014964 <k_work_reschedule_for_queue+0x84>
 801493a: 643b         	str	r3, [r7, #0x40]
 801493c: 69fb         	ldr	r3, [r7, #0x1c]
 801493e: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8014940: 697b         	ldr	r3, [r7, #0x14]
 8014942: 63fb         	str	r3, [r7, #0x3c]
 8014944: 6bfb         	ldr	r3, [r7, #0x3c]
 8014946: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8014948: 6bbb         	ldr	r3, [r7, #0x38]
 801494a: f383 8811    	msr	basepri, r3
; }
 801494e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014950: f3bf 8f6f    	isb	sy
; }
 8014954: bf00         	nop
; }
 8014956: bf00         	nop
; }
 8014958: bf00         	nop
; 	return ret;
 801495a: 6c7b         	ldr	r3, [r7, #0x44]
; }
 801495c: 4618         	mov	r0, r3
 801495e: 3748         	adds	r7, #0x48
 8014960: 46bd         	mov	sp, r7
 8014962: bd80         	pop	{r7, pc}

08014964 <$d>:
 8014964: e4 32 00 20  	.word	0x200032e4

08014968 <k_work_reschedule>:
; {
 8014968: b580         	push	{r7, lr}
 801496a: b086         	sub	sp, #0x18
 801496c: af00         	add	r7, sp, #0x0
 801496e: 60f8         	str	r0, [r7, #0xc]
 8014970: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
 8014974: e9d7 2300    	ldrd	r2, r3, [r7]
 8014978: 68f9         	ldr	r1, [r7, #0xc]
 801497a: 4804         	ldr	r0, [pc, #0x10]         @ 0x801498c <k_work_reschedule+0x24>
 801497c: f7ff ffb0    	bl	0x80148e0 <k_work_reschedule_for_queue> @ imm = #-0xa0
 8014980: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 8014982: 697b         	ldr	r3, [r7, #0x14]
; }
 8014984: 4618         	mov	r0, r3
 8014986: 3718         	adds	r7, #0x18
 8014988: 46bd         	mov	sp, r7
 801498a: bd80         	pop	{r7, pc}

0801498c <$d>:
 801498c: 20 28 00 20  	.word	0x20002820

08014990 <k_work_cancel_delayable>:
; {
 8014990: b580         	push	{r7, lr}
 8014992: b090         	sub	sp, #0x40
 8014994: af00         	add	r7, sp, #0x0
 8014996: 6078         	str	r0, [r7, #0x4]
 8014998: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8014a00 <k_work_cancel_delayable+0x70>
 801499a: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801499c: f3ef 8311    	mrs	r3, basepri
 80149a0: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 80149a2: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 80149a4: 627b         	str	r3, [r7, #0x24]
 80149a6: 2310         	movs	r3, #0x10
 80149a8: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80149aa: 6a3b         	ldr	r3, [r7, #0x20]
 80149ac: f383 8812    	msr	basepri_max, r3
; }
 80149b0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80149b2: f3bf 8f6f    	isb	sy
; }
 80149b6: bf00         	nop
; 	return key;
 80149b8: 6a7b         	ldr	r3, [r7, #0x24]
; 	k.key = arch_irq_lock();
 80149ba: 613b         	str	r3, [r7, #0x10]
 80149bc: 6afb         	ldr	r3, [r7, #0x2c]
 80149be: 61fb         	str	r3, [r7, #0x1c]
; }
 80149c0: bf00         	nop
 80149c2: 6afb         	ldr	r3, [r7, #0x2c]
 80149c4: 61bb         	str	r3, [r7, #0x18]
; }
 80149c6: bf00         	nop
; 	return k;
 80149c8: 693b         	ldr	r3, [r7, #0x10]
 80149ca: 617b         	str	r3, [r7, #0x14]
; 	int ret = cancel_delayable_async_locked(dwork);
 80149cc: 6878         	ldr	r0, [r7, #0x4]
 80149ce: f011 fb54    	bl	0x802607a <cancel_delayable_async_locked> @ imm = #0x116a8
 80149d2: 63f8         	str	r0, [r7, #0x3c]
 80149d4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8014a00 <k_work_cancel_delayable+0x70>
 80149d6: 63bb         	str	r3, [r7, #0x38]
 80149d8: 697b         	ldr	r3, [r7, #0x14]
 80149da: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 80149dc: 68fb         	ldr	r3, [r7, #0xc]
 80149de: 637b         	str	r3, [r7, #0x34]
 80149e0: 6b7b         	ldr	r3, [r7, #0x34]
 80149e2: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80149e4: 6b3b         	ldr	r3, [r7, #0x30]
 80149e6: f383 8811    	msr	basepri, r3
; }
 80149ea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80149ec: f3bf 8f6f    	isb	sy
; }
 80149f0: bf00         	nop
; }
 80149f2: bf00         	nop
; }
 80149f4: bf00         	nop
; 	return ret;
 80149f6: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 80149f8: 4618         	mov	r0, r3
 80149fa: 3740         	adds	r7, #0x40
 80149fc: 46bd         	mov	sp, r7
 80149fe: bd80         	pop	{r7, pc}

08014a00 <$d>:
 8014a00: e4 32 00 20  	.word	0x200032e4

08014a04 <z_add_thread_timeout>:
; {
 8014a04: b580         	push	{r7, lr}
 8014a06: b084         	sub	sp, #0x10
 8014a08: af00         	add	r7, sp, #0x0
 8014a0a: 60f8         	str	r0, [r7, #0xc]
 8014a0c: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 8014a10: 68fb         	ldr	r3, [r7, #0xc]
 8014a12: f103 0018    	add.w	r0, r3, #0x18
 8014a16: e9d7 2300    	ldrd	r2, r3, [r7]
 8014a1a: 4903         	ldr	r1, [pc, #0xc]          @ 0x8014a28 <z_add_thread_timeout+0x24>
 8014a1c: f002 f8fe    	bl	0x8016c1c <z_add_timeout> @ imm = #0x21fc
; }
 8014a20: bf00         	nop
 8014a22: 3710         	adds	r7, #0x10
 8014a24: 46bd         	mov	sp, r7
 8014a26: bd80         	pop	{r7, pc}

08014a28 <$d>:
 8014a28: e3 6a 02 08  	.word	0x08026ae3

08014a2c <z_impl_k_thread_name_set>:
; {
 8014a2c: b580         	push	{r7, lr}
 8014a2e: b084         	sub	sp, #0x10
 8014a30: af00         	add	r7, sp, #0x0
 8014a32: 6078         	str	r0, [r7, #0x4]
 8014a34: 6039         	str	r1, [r7]
; 	if (thread == NULL) {
 8014a36: 687b         	ldr	r3, [r7, #0x4]
 8014a38: 2b00         	cmp	r3, #0x0
 8014a3a: d104         	bne	0x8014a46 <z_impl_k_thread_name_set+0x1a> @ imm = #0x8
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014a3c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8014a68 <z_impl_k_thread_name_set+0x3c>
 8014a3e: 689b         	ldr	r3, [r3, #0x8]
 8014a40: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8014a42: 68fb         	ldr	r3, [r7, #0xc]
; 		thread = arch_current_thread();
 8014a44: 607b         	str	r3, [r7, #0x4]
; 	strncpy(thread->name, str, CONFIG_THREAD_MAX_NAME_LEN - 1);
 8014a46: 687b         	ldr	r3, [r7, #0x4]
 8014a48: 3394         	adds	r3, #0x94
 8014a4a: 221f         	movs	r2, #0x1f
 8014a4c: 6839         	ldr	r1, [r7]
 8014a4e: 4618         	mov	r0, r3
 8014a50: f012 fd62    	bl	0x8027518 <strncpy>     @ imm = #0x12ac4
; 	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 8014a54: 687b         	ldr	r3, [r7, #0x4]
 8014a56: 2200         	movs	r2, #0x0
 8014a58: f883 20b3    	strb.w	r2, [r3, #0xb3]
; 	return 0;
 8014a5c: 2300         	movs	r3, #0x0
; }
 8014a5e: 4618         	mov	r0, r3
 8014a60: 3710         	adds	r7, #0x10
 8014a62: 46bd         	mov	sp, r7
 8014a64: bd80         	pop	{r7, pc}
 8014a66: bf00         	nop

08014a68 <$d>:
 8014a68: a8 25 00 20  	.word	0x200025a8

08014a6c <setup_thread_stack>:
; {
 8014a6c: b580         	push	{r7, lr}
 8014a6e: b096         	sub	sp, #0x58
 8014a70: af0a         	add	r7, sp, #0x28
 8014a72: 60f8         	str	r0, [r7, #0xc]
 8014a74: 60b9         	str	r1, [r7, #0x8]
 8014a76: 607a         	str	r2, [r7, #0x4]
; 	size_t delta = 0;
 8014a78: 2300         	movs	r3, #0x0
 8014a7a: 62fb         	str	r3, [r7, #0x2c]
; 		stack_obj_size = K_KERNEL_STACK_LEN(stack_size);
 8014a7c: 687b         	ldr	r3, [r7, #0x4]
 8014a7e: 3307         	adds	r3, #0x7
 8014a80: f023 0307    	bic	r3, r3, #0x7
 8014a84: 3307         	adds	r3, #0x7
 8014a86: f023 0307    	bic	r3, r3, #0x7
 8014a8a: 62bb         	str	r3, [r7, #0x28]
; 		stack_buf_start = K_KERNEL_STACK_BUFFER(stack);
 8014a8c: 68b8         	ldr	r0, [r7, #0x8]
 8014a8e: f011 fb24    	bl	0x80260da <K_KERNEL_STACK_BUFFER> @ imm = #0x11648
 8014a92: 6278         	str	r0, [r7, #0x24]
; 		stack_buf_size = stack_obj_size - K_KERNEL_STACK_RESERVED;
 8014a94: 6abb         	ldr	r3, [r7, #0x28]
 8014a96: 623b         	str	r3, [r7, #0x20]
; 	stack_ptr = (char *)stack + stack_obj_size;
 8014a98: 68ba         	ldr	r2, [r7, #0x8]
 8014a9a: 6abb         	ldr	r3, [r7, #0x28]
 8014a9c: 4413         	add	r3, r2
 8014a9e: 61fb         	str	r3, [r7, #0x1c]
; 	LOG_DBG("stack %p for thread %p: obj_size=%zu buf_start=%p "
 8014aa0: 2303         	movs	r3, #0x3
 8014aa2: 2b03         	cmp	r3, #0x3
 8014aa4: d924         	bls	0x8014af0 <setup_thread_stack+0x84> @ imm = #0x48
 8014aa6: 2301         	movs	r3, #0x1
 8014aa8: 76fb         	strb	r3, [r7, #0x1b]
 8014aaa: 7efb         	ldrb	r3, [r7, #0x1b]
 8014aac: f083 0301    	eor	r3, r3, #0x1
 8014ab0: b2db         	uxtb	r3, r3
 8014ab2: 2b00         	cmp	r3, #0x0
 8014ab4: d11c         	bne	0x8014af0 <setup_thread_stack+0x84> @ imm = #0x38
 8014ab6: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8014b40 <setup_thread_stack+0xd4>
 8014ab8: 6819         	ldr	r1, [r3]
 8014aba: 69fb         	ldr	r3, [r7, #0x1c]
 8014abc: 9309         	str	r3, [sp, #0x24]
 8014abe: 6a3b         	ldr	r3, [r7, #0x20]
 8014ac0: 9308         	str	r3, [sp, #0x20]
 8014ac2: 6a7b         	ldr	r3, [r7, #0x24]
 8014ac4: 9307         	str	r3, [sp, #0x1c]
 8014ac6: 6abb         	ldr	r3, [r7, #0x28]
 8014ac8: 9306         	str	r3, [sp, #0x18]
 8014aca: 68fb         	ldr	r3, [r7, #0xc]
 8014acc: 9305         	str	r3, [sp, #0x14]
 8014ace: 68bb         	ldr	r3, [r7, #0x8]
 8014ad0: 9304         	str	r3, [sp, #0x10]
 8014ad2: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8014b44 <setup_thread_stack+0xd8>
 8014ad4: 9303         	str	r3, [sp, #0xc]
 8014ad6: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8014b48 <setup_thread_stack+0xdc>
 8014ad8: 9302         	str	r3, [sp, #0x8]
 8014ada: 2308         	movs	r3, #0x8
 8014adc: 9301         	str	r3, [sp, #0x4]
 8014ade: 2300         	movs	r3, #0x0
 8014ae0: 9300         	str	r3, [sp]
 8014ae2: 2300         	movs	r3, #0x0
 8014ae4: 2204         	movs	r2, #0x4
 8014ae6: 2000         	movs	r0, #0x0
 8014ae8: f011 fb5a    	bl	0x80261a0 <z_log_msg_runtime_create> @ imm = #0x116b4
 8014aec: 2300         	movs	r3, #0x0
 8014aee: 617b         	str	r3, [r7, #0x14]
; 	memset(stack_buf_start, 0xaa, stack_buf_size);
 8014af0: 6a3a         	ldr	r2, [r7, #0x20]
 8014af2: 21aa         	movs	r1, #0xaa
 8014af4: 6a78         	ldr	r0, [r7, #0x24]
 8014af6: f012 fd07    	bl	0x8027508 <memset>      @ imm = #0x12a0e
; 	delta += arch_tls_stack_setup(new_thread, stack_ptr);
 8014afa: 69f9         	ldr	r1, [r7, #0x1c]
 8014afc: 68f8         	ldr	r0, [r7, #0xc]
 8014afe: f007 fc02    	bl	0x801c306 <arch_tls_stack_setup> @ imm = #0x7804
 8014b02: 4602         	mov	r2, r0
 8014b04: 6afb         	ldr	r3, [r7, #0x2c]
 8014b06: 4413         	add	r3, r2
 8014b08: 62fb         	str	r3, [r7, #0x2c]
; 	delta = ROUND_UP(delta, ARCH_STACK_PTR_ALIGN);
 8014b0a: 6afb         	ldr	r3, [r7, #0x2c]
 8014b0c: 3307         	adds	r3, #0x7
 8014b0e: f023 0307    	bic	r3, r3, #0x7
 8014b12: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
 8014b14: 6a7a         	ldr	r2, [r7, #0x24]
 8014b16: 68fb         	ldr	r3, [r7, #0xc]
 8014b18: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	new_thread->stack_info.size = stack_buf_size;
 8014b1c: 68fb         	ldr	r3, [r7, #0xc]
 8014b1e: 6a3a         	ldr	r2, [r7, #0x20]
 8014b20: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	new_thread->stack_info.delta = delta;
 8014b24: 68fb         	ldr	r3, [r7, #0xc]
 8014b26: 6afa         	ldr	r2, [r7, #0x2c]
 8014b28: f8c3 20bc    	str.w	r2, [r3, #0xbc]
; 	stack_ptr -= delta;
 8014b2c: 6afb         	ldr	r3, [r7, #0x2c]
 8014b2e: 425b         	rsbs	r3, r3, #0
 8014b30: 69fa         	ldr	r2, [r7, #0x1c]
 8014b32: 4413         	add	r3, r2
 8014b34: 61fb         	str	r3, [r7, #0x1c]
; 	return stack_ptr;
 8014b36: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8014b38: 4618         	mov	r0, r3
 8014b3a: 3730         	adds	r7, #0x30
 8014b3c: 46bd         	mov	sp, r7
 8014b3e: bd80         	pop	{r7, pc}

08014b40 <$d>:
 8014b40: 64 0b 00 20  	.word	0x20000b64
 8014b44: 78 bc 02 08  	.word	0x0802bc78
 8014b48: 44 a3 02 08  	.word	0x0802a344

08014b4c <z_setup_new_thread>:
; {
 8014b4c: b580         	push	{r7, lr}
 8014b4e: b09c         	sub	sp, #0x70
 8014b50: af04         	add	r7, sp, #0x10
 8014b52: 60f8         	str	r0, [r7, #0xc]
 8014b54: 60b9         	str	r1, [r7, #0x8]
 8014b56: 607a         	str	r2, [r7, #0x4]
 8014b58: 603b         	str	r3, [r7]
; 	z_waitq_init(&new_thread->join_queue);
 8014b5a: 68fb         	ldr	r3, [r7, #0xc]
 8014b5c: 3368         	adds	r3, #0x68
 8014b5e: 4618         	mov	r0, r3
 8014b60: f011 fb12    	bl	0x8026188 <z_waitq_init> @ imm = #0x11624
; 	z_init_thread_base(&new_thread->base, prio, _THREAD_SUSPENDED, options);
 8014b64: 68f8         	ldr	r0, [r7, #0xc]
 8014b66: 6fbb         	ldr	r3, [r7, #0x78]
 8014b68: 2210         	movs	r2, #0x10
 8014b6a: 6f79         	ldr	r1, [r7, #0x74]
 8014b6c: f011 fb8e    	bl	0x802628c <z_init_thread_base> @ imm = #0x1171c
; 	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
 8014b70: 687a         	ldr	r2, [r7, #0x4]
 8014b72: 68b9         	ldr	r1, [r7, #0x8]
 8014b74: 68f8         	ldr	r0, [r7, #0xc]
 8014b76: f7ff ff79    	bl	0x8014a6c <setup_thread_stack> @ imm = #-0x10e
 8014b7a: 65f8         	str	r0, [r7, #0x5c]
; 	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 8014b7c: 6f3b         	ldr	r3, [r7, #0x70]
 8014b7e: 9302         	str	r3, [sp, #0x8]
 8014b80: 6efb         	ldr	r3, [r7, #0x6c]
 8014b82: 9301         	str	r3, [sp, #0x4]
 8014b84: 6ebb         	ldr	r3, [r7, #0x68]
 8014b86: 9300         	str	r3, [sp]
 8014b88: 683b         	ldr	r3, [r7]
 8014b8a: 6dfa         	ldr	r2, [r7, #0x5c]
 8014b8c: 68b9         	ldr	r1, [r7, #0x8]
 8014b8e: 68f8         	ldr	r0, [r7, #0xc]
 8014b90: f7f1 fd5e    	bl	0x8006650 <arch_new_thread> @ imm = #-0xe544
; 	new_thread->init_data = NULL;
 8014b94: 68fb         	ldr	r3, [r7, #0xc]
 8014b96: 2200         	movs	r2, #0x0
 8014b98: 665a         	str	r2, [r3, #0x64]
; 	new_thread->no_wake_on_timeout = false;
 8014b9a: 68fb         	ldr	r3, [r7, #0xc]
 8014b9c: 2200         	movs	r2, #0x0
 8014b9e: f883 207c    	strb.w	r2, [r3, #0x7c]
; 	new_thread->entry.pEntry = entry;
 8014ba2: 68fb         	ldr	r3, [r7, #0xc]
 8014ba4: 683a         	ldr	r2, [r7]
 8014ba6: f8c3 2080    	str.w	r2, [r3, #0x80]
; 	new_thread->entry.parameter1 = p1;
 8014baa: 68fb         	ldr	r3, [r7, #0xc]
 8014bac: 6eba         	ldr	r2, [r7, #0x68]
 8014bae: f8c3 2084    	str.w	r2, [r3, #0x84]
; 	new_thread->entry.parameter2 = p2;
 8014bb2: 68fb         	ldr	r3, [r7, #0xc]
 8014bb4: 6efa         	ldr	r2, [r7, #0x6c]
 8014bb6: f8c3 2088    	str.w	r2, [r3, #0x88]
; 	new_thread->entry.parameter3 = p3;
 8014bba: 68fb         	ldr	r3, [r7, #0xc]
 8014bbc: 6f3a         	ldr	r2, [r7, #0x70]
 8014bbe: f8c3 208c    	str.w	r2, [r3, #0x8c]
 8014bc2: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8014c98 <z_setup_new_thread+0x14c>
 8014bc4: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8014bc6: f3ef 8311    	mrs	r3, basepri
 8014bca: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 8014bcc: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 8014bce: 647b         	str	r3, [r7, #0x44]
 8014bd0: 2310         	movs	r3, #0x10
 8014bd2: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8014bd4: 6c3b         	ldr	r3, [r7, #0x40]
 8014bd6: f383 8812    	msr	basepri_max, r3
; }
 8014bda: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014bdc: f3bf 8f6f    	isb	sy
; }
 8014be0: bf00         	nop
; 	return key;
 8014be2: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 8014be4: 617b         	str	r3, [r7, #0x14]
 8014be6: 6cfb         	ldr	r3, [r7, #0x4c]
 8014be8: 63fb         	str	r3, [r7, #0x3c]
; }
 8014bea: bf00         	nop
 8014bec: 6cfb         	ldr	r3, [r7, #0x4c]
 8014bee: 63bb         	str	r3, [r7, #0x38]
; }
 8014bf0: bf00         	nop
; 	return k;
 8014bf2: 697b         	ldr	r3, [r7, #0x14]
 8014bf4: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->next_thread = _kernel.threads;
 8014bf6: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8014c9c <z_setup_new_thread+0x150>
 8014bf8: 6b1a         	ldr	r2, [r3, #0x30]
 8014bfa: 68fb         	ldr	r3, [r7, #0xc]
 8014bfc: f8c3 2090    	str.w	r2, [r3, #0x90]
; 	_kernel.threads = new_thread;
 8014c00: 4a26         	ldr	r2, [pc, #0x98]         @ 0x8014c9c <z_setup_new_thread+0x150>
 8014c02: 68fb         	ldr	r3, [r7, #0xc]
 8014c04: 6313         	str	r3, [r2, #0x30]
 8014c06: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8014c98 <z_setup_new_thread+0x14c>
 8014c08: 65bb         	str	r3, [r7, #0x58]
 8014c0a: 6afb         	ldr	r3, [r7, #0x2c]
 8014c0c: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8014c0e: 693b         	ldr	r3, [r7, #0x10]
 8014c10: 657b         	str	r3, [r7, #0x54]
 8014c12: 6d7b         	ldr	r3, [r7, #0x54]
 8014c14: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8014c16: 6d3b         	ldr	r3, [r7, #0x50]
 8014c18: f383 8811    	msr	basepri, r3
; }
 8014c1c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8014c1e: f3bf 8f6f    	isb	sy
; }
 8014c22: bf00         	nop
; }
 8014c24: bf00         	nop
; }
 8014c26: bf00         	nop
; 	if (name != NULL) {
 8014c28: 6ffb         	ldr	r3, [r7, #0x7c]
 8014c2a: 2b00         	cmp	r3, #0x0
 8014c2c: d00b         	beq	0x8014c46 <z_setup_new_thread+0xfa> @ imm = #0x16
; 		strncpy(new_thread->name, name,
 8014c2e: 68fb         	ldr	r3, [r7, #0xc]
 8014c30: 3394         	adds	r3, #0x94
 8014c32: 221f         	movs	r2, #0x1f
 8014c34: 6ff9         	ldr	r1, [r7, #0x7c]
 8014c36: 4618         	mov	r0, r3
 8014c38: f012 fc6e    	bl	0x8027518 <strncpy>     @ imm = #0x128dc
; 		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 8014c3c: 68fb         	ldr	r3, [r7, #0xc]
 8014c3e: 2200         	movs	r2, #0x0
 8014c40: f883 20b3    	strb.w	r2, [r3, #0xb3]
 8014c44: e003         	b	0x8014c4e <z_setup_new_thread+0x102> @ imm = #0x6
; 		new_thread->name[0] = '\0';
 8014c46: 68fb         	ldr	r3, [r7, #0xc]
 8014c48: 2200         	movs	r2, #0x0
 8014c4a: f883 2094    	strb.w	r2, [r3, #0x94]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014c4e: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8014c9c <z_setup_new_thread+0x150>
 8014c50: 689b         	ldr	r3, [r3, #0x8]
 8014c52: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 8014c54: 6b7b         	ldr	r3, [r7, #0x34]
; 	if (!arch_current_thread()) {
 8014c56: 2b00         	cmp	r3, #0x0
 8014c58: d105         	bne	0x8014c66 <z_setup_new_thread+0x11a> @ imm = #0xa
; 		new_thread->resource_pool = NULL;
 8014c5a: 68fb         	ldr	r3, [r7, #0xc]
 8014c5c: 2200         	movs	r2, #0x0
 8014c5e: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 		return stack_ptr;
 8014c62: 6dfb         	ldr	r3, [r7, #0x5c]
 8014c64: e014         	b	0x8014c90 <z_setup_new_thread+0x144> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014c66: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8014c9c <z_setup_new_thread+0x150>
 8014c68: 689b         	ldr	r3, [r3, #0x8]
 8014c6a: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 8014c6c: 6b3b         	ldr	r3, [r7, #0x30]
; 	new_thread->resource_pool = arch_current_thread()->resource_pool;
 8014c6e: f8d3 20c0    	ldr.w	r2, [r3, #0xc0]
 8014c72: 68fb         	ldr	r3, [r7, #0xc]
 8014c74: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 	new_thread->base.usage = (struct k_cycle_stats) {};
 8014c78: 68fb         	ldr	r3, [r7, #0xc]
 8014c7a: 3330         	adds	r3, #0x30
 8014c7c: 2200         	movs	r2, #0x0
 8014c7e: 601a         	str	r2, [r3]
 8014c80: 605a         	str	r2, [r3, #0x4]
 8014c82: 609a         	str	r2, [r3, #0x8]
 8014c84: 60da         	str	r2, [r3, #0xc]
; 	new_thread->base.usage.track_usage =
 8014c86: 68fb         	ldr	r3, [r7, #0xc]
 8014c88: 2201         	movs	r2, #0x1
 8014c8a: f883 2038    	strb.w	r2, [r3, #0x38]
; 	return stack_ptr;
 8014c8e: 6dfb         	ldr	r3, [r7, #0x5c]
; }
 8014c90: 4618         	mov	r0, r3
 8014c92: 3760         	adds	r7, #0x60
 8014c94: 46bd         	mov	sp, r7
 8014c96: bd80         	pop	{r7, pc}

08014c98 <$d>:
 8014c98: fc 32 00 20  	.word	0x200032fc
 8014c9c: a8 25 00 20  	.word	0x200025a8

08014ca0 <z_thread_mark_switched_in>:
; {
 8014ca0: b580         	push	{r7, lr}
 8014ca2: b082         	sub	sp, #0x8
 8014ca4: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014ca6: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8014cbc <z_thread_mark_switched_in+0x1c>
 8014ca8: 689b         	ldr	r3, [r3, #0x8]
 8014caa: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 8014cac: 687b         	ldr	r3, [r7, #0x4]
; 	z_sched_usage_start(arch_current_thread());
 8014cae: 4618         	mov	r0, r3
 8014cb0: f002 fc0c    	bl	0x80174cc <z_sched_usage_start> @ imm = #0x2818
; }
 8014cb4: bf00         	nop
 8014cb6: 3708         	adds	r7, #0x8
 8014cb8: 46bd         	mov	sp, r7
 8014cba: bd80         	pop	{r7, pc}

08014cbc <$d>:
 8014cbc: a8 25 00 20  	.word	0x200025a8

08014cc0 <z_add_thread_timeout>:
; {
 8014cc0: b580         	push	{r7, lr}
 8014cc2: b084         	sub	sp, #0x10
 8014cc4: af00         	add	r7, sp, #0x0
 8014cc6: 60f8         	str	r0, [r7, #0xc]
 8014cc8: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 8014ccc: 68fb         	ldr	r3, [r7, #0xc]
 8014cce: f103 0018    	add.w	r0, r3, #0x18
 8014cd2: e9d7 2300    	ldrd	r2, r3, [r7]
 8014cd6: 4903         	ldr	r1, [pc, #0xc]          @ 0x8014ce4 <z_add_thread_timeout+0x24>
 8014cd8: f001 ffa0    	bl	0x8016c1c <z_add_timeout> @ imm = #0x1f40
; }
 8014cdc: bf00         	nop
 8014cde: 3710         	adds	r7, #0x10
 8014ce0: 46bd         	mov	sp, r7
 8014ce2: bd80         	pop	{r7, pc}

08014ce4 <$d>:
 8014ce4: e3 6a 02 08  	.word	0x08026ae3

08014ce8 <z_sched_lock>:
; {
 8014ce8: b480         	push	{r7}
 8014cea: b083         	sub	sp, #0xc
 8014cec: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014cee: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8014d0c <z_sched_lock+0x24>
 8014cf0: 689b         	ldr	r3, [r3, #0x8]
 8014cf2: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 8014cf4: 687b         	ldr	r3, [r7, #0x4]
; 	--arch_current_thread()->base.sched_locked;
 8014cf6: 7bda         	ldrb	r2, [r3, #0xf]
 8014cf8: 3a01         	subs	r2, #0x1
 8014cfa: b2d2         	uxtb	r2, r2
 8014cfc: 73da         	strb	r2, [r3, #0xf]
; }
 8014cfe: bf00         	nop
 8014d00: 370c         	adds	r7, #0xc
 8014d02: 46bd         	mov	sp, r7
 8014d04: f85d 7b04    	ldr	r7, [sp], #4
 8014d08: 4770         	bx	lr
 8014d0a: bf00         	nop

08014d0c <$d>:
 8014d0c: a8 25 00 20  	.word	0x200025a8

08014d10 <z_dummy_thread_init>:
; {
 8014d10: b580         	push	{r7, lr}
 8014d12: b084         	sub	sp, #0x10
 8014d14: af00         	add	r7, sp, #0x0
 8014d16: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 8014d18: 687b         	ldr	r3, [r7, #0x4]
 8014d1a: 2201         	movs	r2, #0x1
 8014d1c: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 8014d1e: 687b         	ldr	r3, [r7, #0x4]
 8014d20: 2201         	movs	r2, #0x1
 8014d22: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 8014d24: 687b         	ldr	r3, [r7, #0x4]
 8014d26: 2200         	movs	r2, #0x0
 8014d28: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 8014d2c: 687b         	ldr	r3, [r7, #0x4]
 8014d2e: 2200         	movs	r2, #0x0
 8014d30: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	k_thread_system_pool_assign(dummy_thread);
 8014d34: 6878         	ldr	r0, [r7, #0x4]
 8014d36: f002 fd29    	bl	0x801778c <k_thread_system_pool_assign> @ imm = #0x2a52
 8014d3a: 687b         	ldr	r3, [r7, #0x4]
 8014d3c: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 8014d3e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8014d50 <z_dummy_thread_init+0x40>
 8014d40: 68fb         	ldr	r3, [r7, #0xc]
 8014d42: 6093         	str	r3, [r2, #0x8]
; }
 8014d44: bf00         	nop
; }
 8014d46: bf00         	nop
 8014d48: 3710         	adds	r7, #0x10
 8014d4a: 46bd         	mov	sp, r7
 8014d4c: bd80         	pop	{r7, pc}
 8014d4e: bf00         	nop

08014d50 <$d>:
 8014d50: a8 25 00 20  	.word	0x200025a8

08014d54 <move_thread_to_end_of_prio_q>:
; {
 8014d54: b580         	push	{r7, lr}
 8014d56: b09a         	sub	sp, #0x68
 8014d58: af00         	add	r7, sp, #0x0
 8014d5a: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 8014d5c: 6878         	ldr	r0, [r7, #0x4]
 8014d5e: f011 fcf8    	bl	0x8026752 <z_is_thread_queued> @ imm = #0x119f0
 8014d62: 4603         	mov	r3, r0
 8014d64: 2b00         	cmp	r3, #0x0
 8014d66: d01d         	beq	0x8014da4 <move_thread_to_end_of_prio_q+0x50> @ imm = #0x3a
 8014d68: 687b         	ldr	r3, [r7, #0x4]
 8014d6a: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8014d6c: 6e7b         	ldr	r3, [r7, #0x64]
 8014d6e: 7b5b         	ldrb	r3, [r3, #0xd]
 8014d70: f003 037f    	and	r3, r3, #0x7f
 8014d74: b2da         	uxtb	r2, r3
 8014d76: 6e7b         	ldr	r3, [r7, #0x64]
 8014d78: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8014d7a: 6e78         	ldr	r0, [r7, #0x64]
 8014d7c: f011 fdd4    	bl	0x8026928 <should_queue_thread> @ imm = #0x11ba8
 8014d80: 4603         	mov	r3, r0
 8014d82: 2b00         	cmp	r3, #0x0
 8014d84: d00d         	beq	0x8014da2 <move_thread_to_end_of_prio_q+0x4e> @ imm = #0x1a
 8014d86: 6e7b         	ldr	r3, [r7, #0x64]
 8014d88: 663b         	str	r3, [r7, #0x60]
 8014d8a: 6e3b         	ldr	r3, [r7, #0x60]
 8014d8c: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 8014d8e: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x8014f2c <move_thread_to_end_of_prio_q+0x1d8>
 8014d90: 65bb         	str	r3, [r7, #0x58]
 8014d92: 6e3b         	ldr	r3, [r7, #0x60]
 8014d94: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8014d96: 6d7b         	ldr	r3, [r7, #0x54]
 8014d98: 4618         	mov	r0, r3
 8014d9a: f011 fbfa    	bl	0x8026592 <sys_dlist_remove> @ imm = #0x117f4
; }
 8014d9e: bf00         	nop
; }
 8014da0: bf00         	nop
; }
 8014da2: bf00         	nop
 8014da4: 687b         	ldr	r3, [r7, #0x4]
 8014da6: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 8014da8: 69fb         	ldr	r3, [r7, #0x1c]
 8014daa: 7b5b         	ldrb	r3, [r3, #0xd]
 8014dac: f063 037f    	orn	r3, r3, #0x7f
 8014db0: b2da         	uxtb	r2, r3
 8014db2: 69fb         	ldr	r3, [r7, #0x1c]
 8014db4: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8014db6: 69f8         	ldr	r0, [r7, #0x1c]
 8014db8: f011 fdb6    	bl	0x8026928 <should_queue_thread> @ imm = #0x11b6c
 8014dbc: 4603         	mov	r3, r0
 8014dbe: 2b00         	cmp	r3, #0x0
 8014dc0: d042         	beq	0x8014e48 <move_thread_to_end_of_prio_q+0xf4> @ imm = #0x84
 8014dc2: 69fb         	ldr	r3, [r7, #0x1c]
 8014dc4: 61bb         	str	r3, [r7, #0x18]
 8014dc6: 69bb         	ldr	r3, [r7, #0x18]
 8014dc8: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 8014dca: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8014f2c <move_thread_to_end_of_prio_q+0x1d8>
 8014dcc: 613b         	str	r3, [r7, #0x10]
 8014dce: 69bb         	ldr	r3, [r7, #0x18]
 8014dd0: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8014dd2: 6938         	ldr	r0, [r7, #0x10]
 8014dd4: f011 fb70    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x116e0
 8014dd8: 4603         	mov	r3, r0
 8014dda: 2b00         	cmp	r3, #0x0
 8014ddc: d004         	beq	0x8014de8 <move_thread_to_end_of_prio_q+0x94> @ imm = #0x8
 8014dde: 6938         	ldr	r0, [r7, #0x10]
 8014de0: f011 fb6a    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x116d4
 8014de4: 4603         	mov	r3, r0
 8014de6: e000         	b	0x8014dea <move_thread_to_end_of_prio_q+0x96> @ imm = #0x0
 8014de8: 2300         	movs	r3, #0x0
 8014dea: 60bb         	str	r3, [r7, #0x8]
 8014dec: e023         	b	0x8014e36 <move_thread_to_end_of_prio_q+0xe2> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8014dee: 68b9         	ldr	r1, [r7, #0x8]
 8014df0: 68f8         	ldr	r0, [r7, #0xc]
 8014df2: f011 fd7d    	bl	0x80268f0 <z_sched_prio_cmp> @ imm = #0x11afa
 8014df6: 4603         	mov	r3, r0
 8014df8: 2b00         	cmp	r3, #0x0
 8014dfa: dd06         	ble	0x8014e0a <move_thread_to_end_of_prio_q+0xb6> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8014dfc: 68bb         	ldr	r3, [r7, #0x8]
 8014dfe: 68fa         	ldr	r2, [r7, #0xc]
 8014e00: 4611         	mov	r1, r2
 8014e02: 4618         	mov	r0, r3
 8014e04: f011 fbab    	bl	0x802655e <sys_dlist_insert> @ imm = #0x11756
; 			return;
 8014e08: e01d         	b	0x8014e46 <move_thread_to_end_of_prio_q+0xf2> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8014e0a: 68bb         	ldr	r3, [r7, #0x8]
 8014e0c: 2b00         	cmp	r3, #0x0
 8014e0e: d010         	beq	0x8014e32 <move_thread_to_end_of_prio_q+0xde> @ imm = #0x20
 8014e10: 68bb         	ldr	r3, [r7, #0x8]
 8014e12: 4619         	mov	r1, r3
 8014e14: 6938         	ldr	r0, [r7, #0x10]
 8014e16: f011 fb75    	bl	0x8026504 <sys_dlist_peek_next> @ imm = #0x116ea
 8014e1a: 4603         	mov	r3, r0
 8014e1c: 2b00         	cmp	r3, #0x0
 8014e1e: d006         	beq	0x8014e2e <move_thread_to_end_of_prio_q+0xda> @ imm = #0xc
 8014e20: 68bb         	ldr	r3, [r7, #0x8]
 8014e22: 4619         	mov	r1, r3
 8014e24: 6938         	ldr	r0, [r7, #0x10]
 8014e26: f011 fb6d    	bl	0x8026504 <sys_dlist_peek_next> @ imm = #0x116da
 8014e2a: 4603         	mov	r3, r0
 8014e2c: e002         	b	0x8014e34 <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x4
 8014e2e: 2300         	movs	r3, #0x0
 8014e30: e000         	b	0x8014e34 <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x0
 8014e32: 2300         	movs	r3, #0x0
 8014e34: 60bb         	str	r3, [r7, #0x8]
 8014e36: 68bb         	ldr	r3, [r7, #0x8]
 8014e38: 2b00         	cmp	r3, #0x0
 8014e3a: d1d8         	bne	0x8014dee <move_thread_to_end_of_prio_q+0x9a> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8014e3c: 68fb         	ldr	r3, [r7, #0xc]
 8014e3e: 4619         	mov	r1, r3
 8014e40: 6938         	ldr	r0, [r7, #0x10]
 8014e42: f011 fb72    	bl	0x802652a <sys_dlist_append> @ imm = #0x116e4
; }
 8014e46: bf00         	nop
; }
 8014e48: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014e4a: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8014f30 <move_thread_to_end_of_prio_q+0x1dc>
 8014e4c: 689b         	ldr	r3, [r3, #0x8]
 8014e4e: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 8014e50: 6a3b         	ldr	r3, [r7, #0x20]
; 	update_cache(thread == arch_current_thread());
 8014e52: 687a         	ldr	r2, [r7, #0x4]
 8014e54: 429a         	cmp	r2, r3
 8014e56: bf0c         	ite	eq
 8014e58: 2301         	moveq	r3, #0x1
 8014e5a: 2300         	movne	r3, #0x0
 8014e5c: b2db         	uxtb	r3, r3
 8014e5e: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 8014e60: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8014f2c <move_thread_to_end_of_prio_q+0x1d8>
 8014e62: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 8014e64: 2300         	movs	r3, #0x0
 8014e66: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8014e68: 6cf8         	ldr	r0, [r7, #0x4c]
 8014e6a: f011 fb25    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x1164a
 8014e6e: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8014e70: 6c7b         	ldr	r3, [r7, #0x44]
 8014e72: 2b00         	cmp	r3, #0x0
 8014e74: d001         	beq	0x8014e7a <move_thread_to_end_of_prio_q+0x126> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8014e76: 6c7b         	ldr	r3, [r7, #0x44]
 8014e78: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 8014e7a: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 8014e7c: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8014e7e: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8014e80: 6c3b         	ldr	r3, [r7, #0x40]
 8014e82: 2b00         	cmp	r3, #0x0
 8014e84: d102         	bne	0x8014e8c <move_thread_to_end_of_prio_q+0x138> @ imm = #0x4
 8014e86: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8014f30 <move_thread_to_end_of_prio_q+0x1dc>
 8014e88: 68db         	ldr	r3, [r3, #0xc]
 8014e8a: e000         	b	0x8014e8e <move_thread_to_end_of_prio_q+0x13a> @ imm = #0x0
 8014e8c: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 8014e8e: 63fb         	str	r3, [r7, #0x3c]
 8014e90: 6bfb         	ldr	r3, [r7, #0x3c]
 8014e92: 63bb         	str	r3, [r7, #0x38]
 8014e94: 6d3b         	ldr	r3, [r7, #0x50]
 8014e96: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 8014e98: 6b7b         	ldr	r3, [r7, #0x34]
 8014e9a: 2b00         	cmp	r3, #0x0
 8014e9c: d001         	beq	0x8014ea2 <move_thread_to_end_of_prio_q+0x14e> @ imm = #0x2
; 		return true;
 8014e9e: 2301         	movs	r3, #0x1
 8014ea0: e026         	b	0x8014ef0 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014ea2: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8014f30 <move_thread_to_end_of_prio_q+0x1dc>
 8014ea4: 689b         	ldr	r3, [r3, #0x8]
 8014ea6: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 8014ea8: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8014eaa: 4618         	mov	r0, r3
 8014eac: f011 fbee    	bl	0x802668c <z_is_thread_prevented_from_running> @ imm = #0x117dc
 8014eb0: 4603         	mov	r3, r0
 8014eb2: 2b00         	cmp	r3, #0x0
 8014eb4: d001         	beq	0x8014eba <move_thread_to_end_of_prio_q+0x166> @ imm = #0x2
; 		return true;
 8014eb6: 2301         	movs	r3, #0x1
 8014eb8: e01a         	b	0x8014ef0 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014eba: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8014f30 <move_thread_to_end_of_prio_q+0x1dc>
 8014ebc: 689b         	ldr	r3, [r3, #0x8]
 8014ebe: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 8014ec0: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8014ec2: 4618         	mov	r0, r3
 8014ec4: f011 fbb3    	bl	0x802662e <thread_is_preemptible> @ imm = #0x11766
 8014ec8: 4603         	mov	r3, r0
 8014eca: 2b00         	cmp	r3, #0x0
 8014ecc: d105         	bne	0x8014eda <move_thread_to_end_of_prio_q+0x186> @ imm = #0xa
 8014ece: 6bb8         	ldr	r0, [r7, #0x38]
 8014ed0: f011 fbbe    	bl	0x8026650 <thread_is_metairq> @ imm = #0x1177c
 8014ed4: 4603         	mov	r3, r0
 8014ed6: 2b00         	cmp	r3, #0x0
 8014ed8: d001         	beq	0x8014ede <move_thread_to_end_of_prio_q+0x18a> @ imm = #0x2
; 		return true;
 8014eda: 2301         	movs	r3, #0x1
 8014edc: e008         	b	0x8014ef0 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8014ede: 6bb8         	ldr	r0, [r7, #0x38]
 8014ee0: f011 fbe9    	bl	0x80266b6 <z_is_thread_timeout_active> @ imm = #0x117d2
 8014ee4: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8014ee6: 2b00         	cmp	r3, #0x0
 8014ee8: d001         	beq	0x8014eee <move_thread_to_end_of_prio_q+0x19a> @ imm = #0x2
; 		return true;
 8014eea: 2301         	movs	r3, #0x1
 8014eec: e000         	b	0x8014ef0 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x0
; 	return false;
 8014eee: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8014ef0: 2b00         	cmp	r3, #0x0
 8014ef2: d010         	beq	0x8014f16 <move_thread_to_end_of_prio_q+0x1c2> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014ef4: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8014f30 <move_thread_to_end_of_prio_q+0x1dc>
 8014ef6: 689b         	ldr	r3, [r3, #0x8]
 8014ef8: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8014efa: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 8014efc: 6bfa         	ldr	r2, [r7, #0x3c]
 8014efe: 429a         	cmp	r2, r3
 8014f00: d002         	beq	0x8014f08 <move_thread_to_end_of_prio_q+0x1b4> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8014f02: 6bf8         	ldr	r0, [r7, #0x3c]
 8014f04: f001 fcb2    	bl	0x801686c <z_reset_time_slice> @ imm = #0x1964
; 		update_metairq_preempt(thread);
 8014f08: 6bf8         	ldr	r0, [r7, #0x3c]
 8014f0a: f011 fd54    	bl	0x80269b6 <update_metairq_preempt> @ imm = #0x11aa8
; 		_kernel.ready_q.cache = thread;
 8014f0e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8014f30 <move_thread_to_end_of_prio_q+0x1dc>
 8014f10: 6bfb         	ldr	r3, [r7, #0x3c]
 8014f12: 6213         	str	r3, [r2, #0x20]
; }
 8014f14: e005         	b	0x8014f22 <move_thread_to_end_of_prio_q+0x1ce> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8014f16: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8014f30 <move_thread_to_end_of_prio_q+0x1dc>
 8014f18: 689b         	ldr	r3, [r3, #0x8]
 8014f1a: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8014f1c: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 8014f1e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8014f30 <move_thread_to_end_of_prio_q+0x1dc>
 8014f20: 6213         	str	r3, [r2, #0x20]
; }
 8014f22: bf00         	nop
; }
 8014f24: bf00         	nop
 8014f26: 3768         	adds	r7, #0x68
 8014f28: 46bd         	mov	sp, r7
 8014f2a: bd80         	pop	{r7, pc}

08014f2c <$d>:
 8014f2c: cc 25 00 20  	.word	0x200025cc
 8014f30: a8 25 00 20  	.word	0x200025a8

08014f34 <ready_thread>:
; {
 8014f34: b580         	push	{r7, lr}
 8014f36: b094         	sub	sp, #0x50
 8014f38: af00         	add	r7, sp, #0x0
 8014f3a: 6078         	str	r0, [r7, #0x4]
; 	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 8014f3c: 6878         	ldr	r0, [r7, #0x4]
 8014f3e: f011 fc08    	bl	0x8026752 <z_is_thread_queued> @ imm = #0x11810
 8014f42: 4603         	mov	r3, r0
 8014f44: f083 0301    	eor	r3, r3, #0x1
 8014f48: b2db         	uxtb	r3, r3
 8014f4a: 2b00         	cmp	r3, #0x0
 8014f4c: f000 80be    	beq.w	0x80150cc <ready_thread+0x198> @ imm = #0x17c
 8014f50: 6878         	ldr	r0, [r7, #0x4]
 8014f52: f011 fbc9    	bl	0x80266e8 <z_is_thread_ready> @ imm = #0x11792
 8014f56: 4603         	mov	r3, r0
 8014f58: 2b00         	cmp	r3, #0x0
 8014f5a: f000 80b7    	beq.w	0x80150cc <ready_thread+0x198> @ imm = #0x16e
 8014f5e: 687b         	ldr	r3, [r7, #0x4]
 8014f60: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 8014f62: 69fb         	ldr	r3, [r7, #0x1c]
 8014f64: 7b5b         	ldrb	r3, [r3, #0xd]
 8014f66: f063 037f    	orn	r3, r3, #0x7f
 8014f6a: b2da         	uxtb	r2, r3
 8014f6c: 69fb         	ldr	r3, [r7, #0x1c]
 8014f6e: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8014f70: 69f8         	ldr	r0, [r7, #0x1c]
 8014f72: f011 fcd9    	bl	0x8026928 <should_queue_thread> @ imm = #0x119b2
 8014f76: 4603         	mov	r3, r0
 8014f78: 2b00         	cmp	r3, #0x0
 8014f7a: d042         	beq	0x8015002 <ready_thread+0xce> @ imm = #0x84
 8014f7c: 69fb         	ldr	r3, [r7, #0x1c]
 8014f7e: 61bb         	str	r3, [r7, #0x18]
 8014f80: 69bb         	ldr	r3, [r7, #0x18]
 8014f82: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 8014f84: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x80150d4 <ready_thread+0x1a0>
 8014f86: 613b         	str	r3, [r7, #0x10]
 8014f88: 69bb         	ldr	r3, [r7, #0x18]
 8014f8a: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8014f8c: 6938         	ldr	r0, [r7, #0x10]
 8014f8e: f011 fa93    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x11526
 8014f92: 4603         	mov	r3, r0
 8014f94: 2b00         	cmp	r3, #0x0
 8014f96: d004         	beq	0x8014fa2 <ready_thread+0x6e> @ imm = #0x8
 8014f98: 6938         	ldr	r0, [r7, #0x10]
 8014f9a: f011 fa8d    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x1151a
 8014f9e: 4603         	mov	r3, r0
 8014fa0: e000         	b	0x8014fa4 <ready_thread+0x70> @ imm = #0x0
 8014fa2: 2300         	movs	r3, #0x0
 8014fa4: 60bb         	str	r3, [r7, #0x8]
 8014fa6: e023         	b	0x8014ff0 <ready_thread+0xbc> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8014fa8: 68b9         	ldr	r1, [r7, #0x8]
 8014faa: 68f8         	ldr	r0, [r7, #0xc]
 8014fac: f011 fca0    	bl	0x80268f0 <z_sched_prio_cmp> @ imm = #0x11940
 8014fb0: 4603         	mov	r3, r0
 8014fb2: 2b00         	cmp	r3, #0x0
 8014fb4: dd06         	ble	0x8014fc4 <ready_thread+0x90> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8014fb6: 68bb         	ldr	r3, [r7, #0x8]
 8014fb8: 68fa         	ldr	r2, [r7, #0xc]
 8014fba: 4611         	mov	r1, r2
 8014fbc: 4618         	mov	r0, r3
 8014fbe: f011 face    	bl	0x802655e <sys_dlist_insert> @ imm = #0x1159c
; 			return;
 8014fc2: e01d         	b	0x8015000 <ready_thread+0xcc> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8014fc4: 68bb         	ldr	r3, [r7, #0x8]
 8014fc6: 2b00         	cmp	r3, #0x0
 8014fc8: d010         	beq	0x8014fec <ready_thread+0xb8> @ imm = #0x20
 8014fca: 68bb         	ldr	r3, [r7, #0x8]
 8014fcc: 4619         	mov	r1, r3
 8014fce: 6938         	ldr	r0, [r7, #0x10]
 8014fd0: f011 fa98    	bl	0x8026504 <sys_dlist_peek_next> @ imm = #0x11530
 8014fd4: 4603         	mov	r3, r0
 8014fd6: 2b00         	cmp	r3, #0x0
 8014fd8: d006         	beq	0x8014fe8 <ready_thread+0xb4> @ imm = #0xc
 8014fda: 68bb         	ldr	r3, [r7, #0x8]
 8014fdc: 4619         	mov	r1, r3
 8014fde: 6938         	ldr	r0, [r7, #0x10]
 8014fe0: f011 fa90    	bl	0x8026504 <sys_dlist_peek_next> @ imm = #0x11520
 8014fe4: 4603         	mov	r3, r0
 8014fe6: e002         	b	0x8014fee <ready_thread+0xba> @ imm = #0x4
 8014fe8: 2300         	movs	r3, #0x0
 8014fea: e000         	b	0x8014fee <ready_thread+0xba> @ imm = #0x0
 8014fec: 2300         	movs	r3, #0x0
 8014fee: 60bb         	str	r3, [r7, #0x8]
 8014ff0: 68bb         	ldr	r3, [r7, #0x8]
 8014ff2: 2b00         	cmp	r3, #0x0
 8014ff4: d1d8         	bne	0x8014fa8 <ready_thread+0x74> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8014ff6: 68fb         	ldr	r3, [r7, #0xc]
 8014ff8: 4619         	mov	r1, r3
 8014ffa: 6938         	ldr	r0, [r7, #0x10]
 8014ffc: f011 fa95    	bl	0x802652a <sys_dlist_append> @ imm = #0x1152a
; }
 8015000: bf00         	nop
; }
 8015002: bf00         	nop
 8015004: 2300         	movs	r3, #0x0
 8015006: 64fb         	str	r3, [r7, #0x4c]
; 	return &_kernel.ready_q.runq;
 8015008: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x80150d4 <ready_thread+0x1a0>
 801500a: 64bb         	str	r3, [r7, #0x48]
; 	struct k_thread *thread = NULL;
 801500c: 2300         	movs	r3, #0x0
 801500e: 647b         	str	r3, [r7, #0x44]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8015010: 6cb8         	ldr	r0, [r7, #0x48]
 8015012: f011 fa51    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x114a2
 8015016: 6438         	str	r0, [r7, #0x40]
; 	if (n != NULL) {
 8015018: 6c3b         	ldr	r3, [r7, #0x40]
 801501a: 2b00         	cmp	r3, #0x0
 801501c: d001         	beq	0x8015022 <ready_thread+0xee> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 801501e: 6c3b         	ldr	r3, [r7, #0x40]
 8015020: 647b         	str	r3, [r7, #0x44]
; 	return thread;
 8015022: 6c7b         	ldr	r3, [r7, #0x44]
; 	return _priq_run_best(curr_cpu_runq());
 8015024: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8015026: 63fb         	str	r3, [r7, #0x3c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8015028: 6bfb         	ldr	r3, [r7, #0x3c]
 801502a: 2b00         	cmp	r3, #0x0
 801502c: d102         	bne	0x8015034 <ready_thread+0x100> @ imm = #0x4
 801502e: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80150d8 <ready_thread+0x1a4>
 8015030: 68db         	ldr	r3, [r3, #0xc]
 8015032: e000         	b	0x8015036 <ready_thread+0x102> @ imm = #0x0
 8015034: 6bfb         	ldr	r3, [r7, #0x3c]
; 	struct k_thread *thread = next_up();
 8015036: 63bb         	str	r3, [r7, #0x38]
 8015038: 6bbb         	ldr	r3, [r7, #0x38]
 801503a: 637b         	str	r3, [r7, #0x34]
 801503c: 6cfb         	ldr	r3, [r7, #0x4c]
 801503e: 633b         	str	r3, [r7, #0x30]
; 	if (preempt_ok != 0) {
 8015040: 6b3b         	ldr	r3, [r7, #0x30]
 8015042: 2b00         	cmp	r3, #0x0
 8015044: d001         	beq	0x801504a <ready_thread+0x116> @ imm = #0x2
; 		return true;
 8015046: 2301         	movs	r3, #0x1
 8015048: e026         	b	0x8015098 <ready_thread+0x164> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801504a: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80150d8 <ready_thread+0x1a4>
 801504c: 689b         	ldr	r3, [r3, #0x8]
 801504e: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 8015050: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8015052: 4618         	mov	r0, r3
 8015054: f011 fb1a    	bl	0x802668c <z_is_thread_prevented_from_running> @ imm = #0x11634
 8015058: 4603         	mov	r3, r0
 801505a: 2b00         	cmp	r3, #0x0
 801505c: d001         	beq	0x8015062 <ready_thread+0x12e> @ imm = #0x2
; 		return true;
 801505e: 2301         	movs	r3, #0x1
 8015060: e01a         	b	0x8015098 <ready_thread+0x164> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015062: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x80150d8 <ready_thread+0x1a4>
 8015064: 689b         	ldr	r3, [r3, #0x8]
 8015066: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8015068: 6abb         	ldr	r3, [r7, #0x28]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 801506a: 4618         	mov	r0, r3
 801506c: f011 fadf    	bl	0x802662e <thread_is_preemptible> @ imm = #0x115be
 8015070: 4603         	mov	r3, r0
 8015072: 2b00         	cmp	r3, #0x0
 8015074: d105         	bne	0x8015082 <ready_thread+0x14e> @ imm = #0xa
 8015076: 6b78         	ldr	r0, [r7, #0x34]
 8015078: f011 faea    	bl	0x8026650 <thread_is_metairq> @ imm = #0x115d4
 801507c: 4603         	mov	r3, r0
 801507e: 2b00         	cmp	r3, #0x0
 8015080: d001         	beq	0x8015086 <ready_thread+0x152> @ imm = #0x2
; 		return true;
 8015082: 2301         	movs	r3, #0x1
 8015084: e008         	b	0x8015098 <ready_thread+0x164> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8015086: 6b78         	ldr	r0, [r7, #0x34]
 8015088: f011 fb15    	bl	0x80266b6 <z_is_thread_timeout_active> @ imm = #0x1162a
 801508c: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 801508e: 2b00         	cmp	r3, #0x0
 8015090: d001         	beq	0x8015096 <ready_thread+0x162> @ imm = #0x2
; 		return true;
 8015092: 2301         	movs	r3, #0x1
 8015094: e000         	b	0x8015098 <ready_thread+0x164> @ imm = #0x0
; 	return false;
 8015096: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8015098: 2b00         	cmp	r3, #0x0
 801509a: d010         	beq	0x80150be <ready_thread+0x18a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801509c: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80150d8 <ready_thread+0x1a4>
 801509e: 689b         	ldr	r3, [r3, #0x8]
 80150a0: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 80150a2: 6a7b         	ldr	r3, [r7, #0x24]
; 		if (thread != arch_current_thread()) {
 80150a4: 6bba         	ldr	r2, [r7, #0x38]
 80150a6: 429a         	cmp	r2, r3
 80150a8: d002         	beq	0x80150b0 <ready_thread+0x17c> @ imm = #0x4
; 			z_reset_time_slice(thread);
 80150aa: 6bb8         	ldr	r0, [r7, #0x38]
 80150ac: f001 fbde    	bl	0x801686c <z_reset_time_slice> @ imm = #0x17bc
; 		update_metairq_preempt(thread);
 80150b0: 6bb8         	ldr	r0, [r7, #0x38]
 80150b2: f011 fc80    	bl	0x80269b6 <update_metairq_preempt> @ imm = #0x11900
; 		_kernel.ready_q.cache = thread;
 80150b6: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80150d8 <ready_thread+0x1a4>
 80150b8: 6bbb         	ldr	r3, [r7, #0x38]
 80150ba: 6213         	str	r3, [r2, #0x20]
; }
 80150bc: e005         	b	0x80150ca <ready_thread+0x196> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80150be: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80150d8 <ready_thread+0x1a4>
 80150c0: 689b         	ldr	r3, [r3, #0x8]
 80150c2: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 80150c4: 6a3b         	ldr	r3, [r7, #0x20]
; 		_kernel.ready_q.cache = arch_current_thread();
 80150c6: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80150d8 <ready_thread+0x1a4>
 80150c8: 6213         	str	r3, [r2, #0x20]
; }
 80150ca: bf00         	nop
; }
 80150cc: bf00         	nop
 80150ce: 3750         	adds	r7, #0x50
 80150d0: 46bd         	mov	sp, r7
 80150d2: bd80         	pop	{r7, pc}

080150d4 <$d>:
 80150d4: cc 25 00 20  	.word	0x200025cc
 80150d8: a8 25 00 20  	.word	0x200025a8

080150dc <z_ready_thread>:
; {
 80150dc: b580         	push	{r7, lr}
 80150de: b090         	sub	sp, #0x40
 80150e0: af00         	add	r7, sp, #0x0
 80150e2: 6078         	str	r0, [r7, #0x4]
; 	K_SPINLOCK(&_sched_spinlock) {
 80150e4: 2300         	movs	r3, #0x0
 80150e6: 61bb         	str	r3, [r7, #0x18]
 80150e8: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8015168 <z_ready_thread+0x8c>
 80150ea: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80150ec: f3ef 8311    	mrs	r3, basepri
 80150f0: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 80150f2: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 80150f4: 637b         	str	r3, [r7, #0x34]
 80150f6: 2310         	movs	r3, #0x10
 80150f8: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80150fa: 6b3b         	ldr	r3, [r7, #0x30]
 80150fc: f383 8812    	msr	basepri_max, r3
; }
 8015100: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015102: f3bf 8f6f    	isb	sy
; }
 8015106: bf00         	nop
; 	return key;
 8015108: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 801510a: 60fb         	str	r3, [r7, #0xc]
 801510c: 6bfb         	ldr	r3, [r7, #0x3c]
 801510e: 62fb         	str	r3, [r7, #0x2c]
; }
 8015110: bf00         	nop
 8015112: 6bfb         	ldr	r3, [r7, #0x3c]
 8015114: 62bb         	str	r3, [r7, #0x28]
; }
 8015116: bf00         	nop
; 	return k;
 8015118: 68fb         	ldr	r3, [r7, #0xc]
 801511a: 617b         	str	r3, [r7, #0x14]
; 	K_SPINLOCK(&_sched_spinlock) {
 801511c: e01b         	b	0x8015156 <z_ready_thread+0x7a> @ imm = #0x36
; 		if (thread_active_elsewhere(thread) == NULL) {
 801511e: 6878         	ldr	r0, [r7, #0x4]
 8015120: f011 fc53    	bl	0x80269ca <thread_active_elsewhere> @ imm = #0x118a6
 8015124: 4603         	mov	r3, r0
 8015126: 2b00         	cmp	r3, #0x0
 8015128: d102         	bne	0x8015130 <z_ready_thread+0x54> @ imm = #0x4
; 			ready_thread(thread);
 801512a: 6878         	ldr	r0, [r7, #0x4]
 801512c: f7ff ff02    	bl	0x8014f34 <ready_thread> @ imm = #-0x1fc
 8015130: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8015168 <z_ready_thread+0x8c>
 8015132: 627b         	str	r3, [r7, #0x24]
 8015134: 697b         	ldr	r3, [r7, #0x14]
 8015136: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8015138: 693b         	ldr	r3, [r7, #0x10]
 801513a: 623b         	str	r3, [r7, #0x20]
 801513c: 6a3b         	ldr	r3, [r7, #0x20]
 801513e: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015140: 69fb         	ldr	r3, [r7, #0x1c]
 8015142: f383 8811    	msr	basepri, r3
; }
 8015146: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015148: f3bf 8f6f    	isb	sy
; }
 801514c: bf00         	nop
; }
 801514e: bf00         	nop
; }
 8015150: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8015152: 2301         	movs	r3, #0x1
 8015154: 61bb         	str	r3, [r7, #0x18]
 8015156: 69bb         	ldr	r3, [r7, #0x18]
 8015158: 2b00         	cmp	r3, #0x0
 801515a: d0e0         	beq	0x801511e <z_ready_thread+0x42> @ imm = #-0x40
; }
 801515c: bf00         	nop
 801515e: bf00         	nop
 8015160: 3740         	adds	r7, #0x40
 8015162: 46bd         	mov	sp, r7
 8015164: bd80         	pop	{r7, pc}
 8015166: bf00         	nop

08015168 <$d>:
 8015168: ec 32 00 20  	.word	0x200032ec

0801516c <thread_halt_spin>:
; {
 801516c: b590         	push	{r4, r7, lr}
 801516e: b091         	sub	sp, #0x44
 8015170: af00         	add	r7, sp, #0x0
 8015172: 6078         	str	r0, [r7, #0x4]
 8015174: 6039         	str	r1, [r7]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015176: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x801522c <thread_halt_spin+0xc0>
 8015178: 689b         	ldr	r3, [r3, #0x8]
 801517a: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 801517c: 6bbb         	ldr	r3, [r7, #0x38]
; 	if (is_halting(arch_current_thread())) {
 801517e: 4618         	mov	r0, r3
 8015180: f011 fbf0    	bl	0x8026964 <is_halting>  @ imm = #0x117e0
 8015184: 4603         	mov	r3, r0
 8015186: 2b00         	cmp	r3, #0x0
 8015188: d014         	beq	0x80151b4 <thread_halt_spin+0x48> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801518a: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x801522c <thread_halt_spin+0xc0>
 801518c: 689b         	ldr	r3, [r3, #0x8]
 801518e: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 8015190: 6b3c         	ldr	r4, [r7, #0x30]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015192: 4b26         	ldr	r3, [pc, #0x98]         @ 0x801522c <thread_halt_spin+0xc0>
 8015194: 689b         	ldr	r3, [r3, #0x8]
 8015196: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 8015198: 6b7b         	ldr	r3, [r7, #0x34]
; 			    is_aborting(arch_current_thread()) ? _THREAD_DEAD : _THREAD_SUSPENDED);
 801519a: 4618         	mov	r0, r3
 801519c: f011 fbcf    	bl	0x802693e <is_aborting> @ imm = #0x1179e
 80151a0: 4603         	mov	r3, r0
; 		halt_thread(arch_current_thread(),
 80151a2: 2b00         	cmp	r3, #0x0
 80151a4: d001         	beq	0x80151aa <thread_halt_spin+0x3e> @ imm = #0x2
 80151a6: 2308         	movs	r3, #0x8
 80151a8: e000         	b	0x80151ac <thread_halt_spin+0x40> @ imm = #0x0
 80151aa: 2310         	movs	r3, #0x10
 80151ac: 4619         	mov	r1, r3
 80151ae: 4620         	mov	r0, r4
 80151b0: f001 f8f0    	bl	0x8016394 <halt_thread> @ imm = #0x11e0
 80151b4: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8015230 <thread_halt_spin+0xc4>
 80151b6: 62fb         	str	r3, [r7, #0x2c]
 80151b8: 683b         	ldr	r3, [r7]
 80151ba: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 80151bc: 68fb         	ldr	r3, [r7, #0xc]
 80151be: 62bb         	str	r3, [r7, #0x28]
 80151c0: 6abb         	ldr	r3, [r7, #0x28]
 80151c2: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80151c4: 6a7b         	ldr	r3, [r7, #0x24]
 80151c6: f383 8811    	msr	basepri, r3
; }
 80151ca: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80151cc: f3bf 8f6f    	isb	sy
; }
 80151d0: bf00         	nop
; }
 80151d2: bf00         	nop
; }
 80151d4: bf00         	nop
; 	while (is_halting(thread)) {
 80151d6: e01d         	b	0x8015214 <thread_halt_spin+0xa8> @ imm = #0x3a
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80151d8: f3ef 8311    	mrs	r3, basepri
 80151dc: 61bb         	str	r3, [r7, #0x18]
;   return(result);
 80151de: 69bb         	ldr	r3, [r7, #0x18]
; 	key = __get_BASEPRI();
 80151e0: 617b         	str	r3, [r7, #0x14]
 80151e2: 2310         	movs	r3, #0x10
 80151e4: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80151e6: 693b         	ldr	r3, [r7, #0x10]
 80151e8: f383 8812    	msr	basepri_max, r3
; }
 80151ec: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80151ee: f3bf 8f6f    	isb	sy
; }
 80151f2: bf00         	nop
; 	return key;
 80151f4: 697b         	ldr	r3, [r7, #0x14]
; 		unsigned int k = arch_irq_lock();
 80151f6: 63fb         	str	r3, [r7, #0x3c]
; 		arch_spin_relax(); /* Requires interrupts be masked */
 80151f8: f00f fd9b    	bl	0x8024d32 <arch_spin_relax> @ imm = #0xfb36
 80151fc: 6bfb         	ldr	r3, [r7, #0x3c]
 80151fe: 623b         	str	r3, [r7, #0x20]
 8015200: 6a3b         	ldr	r3, [r7, #0x20]
 8015202: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015204: 69fb         	ldr	r3, [r7, #0x1c]
 8015206: f383 8811    	msr	basepri, r3
; }
 801520a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801520c: f3bf 8f6f    	isb	sy
; }
 8015210: bf00         	nop
; }
 8015212: bf00         	nop
; 	while (is_halting(thread)) {
 8015214: 6878         	ldr	r0, [r7, #0x4]
 8015216: f011 fba5    	bl	0x8026964 <is_halting>  @ imm = #0x1174a
 801521a: 4603         	mov	r3, r0
 801521c: 2b00         	cmp	r3, #0x0
 801521e: d1db         	bne	0x80151d8 <thread_halt_spin+0x6c> @ imm = #-0x4a
; }
 8015220: bf00         	nop
 8015222: bf00         	nop
 8015224: 3744         	adds	r7, #0x44
 8015226: 46bd         	mov	sp, r7
 8015228: bd90         	pop	{r4, r7, pc}
 801522a: bf00         	nop

0801522c <$d>:
 801522c: a8 25 00 20  	.word	0x200025a8
 8015230: ec 32 00 20  	.word	0x200032ec

08015234 <z_thread_halt>:
; {
 8015234: b580         	push	{r7, lr}
 8015236: b094         	sub	sp, #0x50
 8015238: af00         	add	r7, sp, #0x0
 801523a: 60f8         	str	r0, [r7, #0xc]
 801523c: 60b9         	str	r1, [r7, #0x8]
 801523e: 4613         	mov	r3, r2
 8015240: 71fb         	strb	r3, [r7, #0x7]
; 	_wait_q_t *wq = &thread->join_queue;
 8015242: 68fb         	ldr	r3, [r7, #0xc]
 8015244: 3368         	adds	r3, #0x68
 8015246: 64fb         	str	r3, [r7, #0x4c]
; 	struct _cpu *cpu = thread_active_elsewhere(thread);
 8015248: 68f8         	ldr	r0, [r7, #0xc]
 801524a: f011 fbbe    	bl	0x80269ca <thread_active_elsewhere> @ imm = #0x1177c
 801524e: 64b8         	str	r0, [r7, #0x48]
; 	if (cpu != NULL) {
 8015250: 6cbb         	ldr	r3, [r7, #0x48]
 8015252: 2b00         	cmp	r3, #0x0
 8015254: d02f         	beq	0x80152b6 <z_thread_halt+0x82> @ imm = #0x5e
; 		thread->base.thread_state |= (terminate ? _THREAD_ABORTING
 8015256: 68fb         	ldr	r3, [r7, #0xc]
 8015258: 7b5b         	ldrb	r3, [r3, #0xd]
 801525a: 79fa         	ldrb	r2, [r7, #0x7]
 801525c: 2a00         	cmp	r2, #0x0
 801525e: d001         	beq	0x8015264 <z_thread_halt+0x30> @ imm = #0x2
 8015260: 2220         	movs	r2, #0x20
 8015262: e000         	b	0x8015266 <z_thread_halt+0x32> @ imm = #0x0
 8015264: 2240         	movs	r2, #0x40
 8015266: 4313         	orrs	r3, r2
 8015268: b2da         	uxtb	r2, r3
 801526a: 68fb         	ldr	r3, [r7, #0xc]
 801526c: 735a         	strb	r2, [r3, #0xd]
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801526e: f3ef 8305    	mrs	r3, ipsr
 8015272: 647b         	str	r3, [r7, #0x44]
;   return(result);
 8015274: 6c7b         	ldr	r3, [r7, #0x44]
; 	return (__get_IPSR()) ? (true) : (false);
 8015276: 2b00         	cmp	r3, #0x0
 8015278: bf14         	ite	ne
 801527a: 2301         	movne	r3, #0x1
 801527c: 2300         	moveq	r3, #0x0
 801527e: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 8015280: 2b00         	cmp	r3, #0x0
 8015282: d004         	beq	0x801528e <z_thread_halt+0x5a> @ imm = #0x8
; 			thread_halt_spin(thread, key);
 8015284: 68b9         	ldr	r1, [r7, #0x8]
 8015286: 68f8         	ldr	r0, [r7, #0xc]
 8015288: f7ff ff70    	bl	0x801516c <thread_halt_spin> @ imm = #-0x120
; }
 801528c: e04f         	b	0x801532e <z_thread_halt+0xfa> @ imm = #0x9e
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801528e: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8015338 <z_thread_halt+0x104>
 8015290: 689b         	ldr	r3, [r3, #0x8]
 8015292: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 8015294: 6bbb         	ldr	r3, [r7, #0x38]
; 			add_to_waitq_locked(arch_current_thread(), wq);
 8015296: 6cf9         	ldr	r1, [r7, #0x4c]
 8015298: 4618         	mov	r0, r3
 801529a: f011 fba1    	bl	0x80269e0 <add_to_waitq_locked> @ imm = #0x11742
 801529e: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x801533c <z_thread_halt+0x108>
 80152a0: 643b         	str	r3, [r7, #0x40]
 80152a2: 68bb         	ldr	r3, [r7, #0x8]
 80152a4: 613b         	str	r3, [r7, #0x10]
 80152a6: 6c3b         	ldr	r3, [r7, #0x40]
 80152a8: 63fb         	str	r3, [r7, #0x3c]
; }
 80152aa: bf00         	nop
; 	return z_swap_irqlock(key.key);
 80152ac: 693b         	ldr	r3, [r7, #0x10]
 80152ae: 4618         	mov	r0, r3
 80152b0: f011 faf3    	bl	0x802689a <z_swap_irqlock> @ imm = #0x115e6
 80152b4: e03b         	b	0x801532e <z_thread_halt+0xfa> @ imm = #0x76
; 		halt_thread(thread, terminate ? _THREAD_DEAD : _THREAD_SUSPENDED);
 80152b6: 79fb         	ldrb	r3, [r7, #0x7]
 80152b8: 2b00         	cmp	r3, #0x0
 80152ba: d001         	beq	0x80152c0 <z_thread_halt+0x8c> @ imm = #0x2
 80152bc: 2308         	movs	r3, #0x8
 80152be: e000         	b	0x80152c2 <z_thread_halt+0x8e> @ imm = #0x0
 80152c0: 2310         	movs	r3, #0x10
 80152c2: 4619         	mov	r1, r3
 80152c4: 68f8         	ldr	r0, [r7, #0xc]
 80152c6: f001 f865    	bl	0x8016394 <halt_thread> @ imm = #0x10ca
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80152ca: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8015338 <z_thread_halt+0x104>
 80152cc: 689b         	ldr	r3, [r3, #0x8]
 80152ce: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 80152d0: 6b7b         	ldr	r3, [r7, #0x34]
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 80152d2: 68fa         	ldr	r2, [r7, #0xc]
 80152d4: 429a         	cmp	r2, r3
 80152d6: d119         	bne	0x801530c <z_thread_halt+0xd8> @ imm = #0x32
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80152d8: f3ef 8305    	mrs	r3, ipsr
 80152dc: 633b         	str	r3, [r7, #0x30]
;   return(result);
 80152de: 6b3b         	ldr	r3, [r7, #0x30]
; 	return (__get_IPSR()) ? (true) : (false);
 80152e0: 2b00         	cmp	r3, #0x0
 80152e2: bf14         	ite	ne
 80152e4: 2301         	movne	r3, #0x1
 80152e6: 2300         	moveq	r3, #0x0
 80152e8: b2db         	uxtb	r3, r3
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 80152ea: f083 0301    	eor	r3, r3, #0x1
 80152ee: b2db         	uxtb	r3, r3
 80152f0: 2b00         	cmp	r3, #0x0
 80152f2: d00b         	beq	0x801530c <z_thread_halt+0xd8> @ imm = #0x16
 80152f4: 4b11         	ldr	r3, [pc, #0x44]         @ 0x801533c <z_thread_halt+0x108>
 80152f6: 62fb         	str	r3, [r7, #0x2c]
 80152f8: 68bb         	ldr	r3, [r7, #0x8]
 80152fa: 617b         	str	r3, [r7, #0x14]
 80152fc: 6afb         	ldr	r3, [r7, #0x2c]
 80152fe: 62bb         	str	r3, [r7, #0x28]
; }
 8015300: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8015302: 697b         	ldr	r3, [r7, #0x14]
 8015304: 4618         	mov	r0, r3
 8015306: f011 fac8    	bl	0x802689a <z_swap_irqlock> @ imm = #0x11590
; 			z_swap(&_sched_spinlock, key);
 801530a: e010         	b	0x801532e <z_thread_halt+0xfa> @ imm = #0x20
 801530c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x801533c <z_thread_halt+0x108>
 801530e: 627b         	str	r3, [r7, #0x24]
 8015310: 68bb         	ldr	r3, [r7, #0x8]
 8015312: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8015314: 69bb         	ldr	r3, [r7, #0x18]
 8015316: 623b         	str	r3, [r7, #0x20]
 8015318: 6a3b         	ldr	r3, [r7, #0x20]
 801531a: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801531c: 69fb         	ldr	r3, [r7, #0x1c]
 801531e: f383 8811    	msr	basepri, r3
; }
 8015322: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015324: f3bf 8f6f    	isb	sy
; }
 8015328: bf00         	nop
; }
 801532a: bf00         	nop
; }
 801532c: bf00         	nop
; }
 801532e: bf00         	nop
 8015330: 3750         	adds	r7, #0x50
 8015332: 46bd         	mov	sp, r7
 8015334: bd80         	pop	{r7, pc}
 8015336: bf00         	nop

08015338 <$d>:
 8015338: a8 25 00 20  	.word	0x200025a8
 801533c: ec 32 00 20  	.word	0x200032ec

08015340 <z_impl_k_thread_suspend>:
; {
 8015340: b580         	push	{r7, lr}
 8015342: b0ac         	sub	sp, #0xb0
 8015344: af00         	add	r7, sp, #0x0
 8015346: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015348: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8015584 <z_impl_k_thread_suspend+0x244>
 801534a: 689b         	ldr	r3, [r3, #0x8]
 801534c: f8c7 30ac    	str.w	r3, [r7, #0xac]
; 	return ret;
 8015350: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 8015354: 687a         	ldr	r2, [r7, #0x4]
 8015356: 429a         	cmp	r2, r3
 8015358: f040 80d7    	bne.w	0x801550a <z_impl_k_thread_suspend+0x1ca> @ imm = #0x1ae
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801535c: f3ef 8305    	mrs	r3, ipsr
 8015360: f8c7 30a8    	str.w	r3, [r7, #0xa8]
;   return(result);
 8015364: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
; 	return (__get_IPSR()) ? (true) : (false);
 8015368: 2b00         	cmp	r3, #0x0
 801536a: bf14         	ite	ne
 801536c: 2301         	movne	r3, #0x1
 801536e: 2300         	moveq	r3, #0x0
 8015370: b2db         	uxtb	r3, r3
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 8015372: f083 0301    	eor	r3, r3, #0x1
 8015376: b2db         	uxtb	r3, r3
 8015378: 2b00         	cmp	r3, #0x0
 801537a: f000 80c6    	beq.w	0x801550a <z_impl_k_thread_suspend+0x1ca> @ imm = #0x18c
 801537e: 4b82         	ldr	r3, [pc, #0x208]        @ 0x8015588 <z_impl_k_thread_suspend+0x248>
 8015380: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015382: f3ef 8311    	mrs	r3, basepri
 8015386: 657b         	str	r3, [r7, #0x54]
;   return(result);
 8015388: 6d7b         	ldr	r3, [r7, #0x54]
; 	key = __get_BASEPRI();
 801538a: 653b         	str	r3, [r7, #0x50]
 801538c: 2310         	movs	r3, #0x10
 801538e: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015390: 6cfb         	ldr	r3, [r7, #0x4c]
 8015392: f383 8812    	msr	basepri_max, r3
; }
 8015396: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015398: f3bf 8f6f    	isb	sy
; }
 801539c: bf00         	nop
; 	return key;
 801539e: 6d3b         	ldr	r3, [r7, #0x50]
; 	k.key = arch_irq_lock();
 80153a0: 60fb         	str	r3, [r7, #0xc]
 80153a2: 6dbb         	ldr	r3, [r7, #0x58]
 80153a4: 64bb         	str	r3, [r7, #0x48]
; }
 80153a6: bf00         	nop
 80153a8: 6dbb         	ldr	r3, [r7, #0x58]
 80153aa: 647b         	str	r3, [r7, #0x44]
; }
 80153ac: bf00         	nop
; 	return k;
 80153ae: 68fb         	ldr	r3, [r7, #0xc]
 80153b0: 613b         	str	r3, [r7, #0x10]
; 		z_mark_thread_as_suspended(thread);
 80153b2: 6878         	ldr	r0, [r7, #0x4]
 80153b4: f011 f9da    	bl	0x802676c <z_mark_thread_as_suspended> @ imm = #0x113b4
 80153b8: 687b         	ldr	r3, [r7, #0x4]
 80153ba: 66fb         	str	r3, [r7, #0x6c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 80153bc: 6efb         	ldr	r3, [r7, #0x6c]
 80153be: 7b5b         	ldrb	r3, [r3, #0xd]
 80153c0: f003 037f    	and	r3, r3, #0x7f
 80153c4: b2da         	uxtb	r2, r3
 80153c6: 6efb         	ldr	r3, [r7, #0x6c]
 80153c8: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 80153ca: 6ef8         	ldr	r0, [r7, #0x6c]
 80153cc: f011 faac    	bl	0x8026928 <should_queue_thread> @ imm = #0x11558
 80153d0: 4603         	mov	r3, r0
 80153d2: 2b00         	cmp	r3, #0x0
 80153d4: d00d         	beq	0x80153f2 <z_impl_k_thread_suspend+0xb2> @ imm = #0x1a
 80153d6: 6efb         	ldr	r3, [r7, #0x6c]
 80153d8: 66bb         	str	r3, [r7, #0x68]
 80153da: 6ebb         	ldr	r3, [r7, #0x68]
 80153dc: 667b         	str	r3, [r7, #0x64]
; 	return &_kernel.ready_q.runq;
 80153de: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x801558c <z_impl_k_thread_suspend+0x24c>
 80153e0: 663b         	str	r3, [r7, #0x60]
 80153e2: 6ebb         	ldr	r3, [r7, #0x68]
 80153e4: 65fb         	str	r3, [r7, #0x5c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 80153e6: 6dfb         	ldr	r3, [r7, #0x5c]
 80153e8: 4618         	mov	r0, r3
 80153ea: f011 f8d2    	bl	0x8026592 <sys_dlist_remove> @ imm = #0x111a4
; }
 80153ee: bf00         	nop
; }
 80153f0: bf00         	nop
; }
 80153f2: bf00         	nop
 80153f4: 2301         	movs	r3, #0x1
 80153f6: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	return &_kernel.ready_q.runq;
 80153fa: 4b64         	ldr	r3, [pc, #0x190]        @ 0x801558c <z_impl_k_thread_suspend+0x24c>
 80153fc: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	struct k_thread *thread = NULL;
 8015400: 2300         	movs	r3, #0x0
 8015402: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8015406: f8d7 0098    	ldr.w	r0, [r7, #0x98]
 801540a: f011 f855    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x110aa
 801540e: f8c7 0090    	str.w	r0, [r7, #0x90]
; 	if (n != NULL) {
 8015412: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 8015416: 2b00         	cmp	r3, #0x0
 8015418: d003         	beq	0x8015422 <z_impl_k_thread_suspend+0xe2> @ imm = #0x6
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 801541a: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 801541e: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	return thread;
 8015422: f8d7 3094    	ldr.w	r3, [r7, #0x94]
; 	return _priq_run_best(curr_cpu_runq());
 8015426: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8015428: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 801542c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8015430: 2b00         	cmp	r3, #0x0
 8015432: d102         	bne	0x801543a <z_impl_k_thread_suspend+0xfa> @ imm = #0x4
 8015434: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8015584 <z_impl_k_thread_suspend+0x244>
 8015436: 68db         	ldr	r3, [r3, #0xc]
 8015438: e001         	b	0x801543e <z_impl_k_thread_suspend+0xfe> @ imm = #0x2
 801543a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	struct k_thread *thread = next_up();
 801543e: f8c7 3088    	str.w	r3, [r7, #0x88]
 8015442: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8015446: f8c7 3084    	str.w	r3, [r7, #0x84]
 801544a: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 801544e: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	if (preempt_ok != 0) {
 8015452: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8015456: 2b00         	cmp	r3, #0x0
 8015458: d001         	beq	0x801545e <z_impl_k_thread_suspend+0x11e> @ imm = #0x2
; 		return true;
 801545a: 2301         	movs	r3, #0x1
 801545c: e028         	b	0x80154b0 <z_impl_k_thread_suspend+0x170> @ imm = #0x50
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801545e: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8015584 <z_impl_k_thread_suspend+0x244>
 8015460: 689b         	ldr	r3, [r3, #0x8]
 8015462: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 8015464: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8015466: 4618         	mov	r0, r3
 8015468: f011 f910    	bl	0x802668c <z_is_thread_prevented_from_running> @ imm = #0x11220
 801546c: 4603         	mov	r3, r0
 801546e: 2b00         	cmp	r3, #0x0
 8015470: d001         	beq	0x8015476 <z_impl_k_thread_suspend+0x136> @ imm = #0x2
; 		return true;
 8015472: 2301         	movs	r3, #0x1
 8015474: e01c         	b	0x80154b0 <z_impl_k_thread_suspend+0x170> @ imm = #0x38
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015476: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8015584 <z_impl_k_thread_suspend+0x244>
 8015478: 689b         	ldr	r3, [r3, #0x8]
 801547a: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 801547c: 6fbb         	ldr	r3, [r7, #0x78]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 801547e: 4618         	mov	r0, r3
 8015480: f011 f8d5    	bl	0x802662e <thread_is_preemptible> @ imm = #0x111aa
 8015484: 4603         	mov	r3, r0
 8015486: 2b00         	cmp	r3, #0x0
 8015488: d106         	bne	0x8015498 <z_impl_k_thread_suspend+0x158> @ imm = #0xc
 801548a: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 801548e: f011 f8df    	bl	0x8026650 <thread_is_metairq> @ imm = #0x111be
 8015492: 4603         	mov	r3, r0
 8015494: 2b00         	cmp	r3, #0x0
 8015496: d001         	beq	0x801549c <z_impl_k_thread_suspend+0x15c> @ imm = #0x2
; 		return true;
 8015498: 2301         	movs	r3, #0x1
 801549a: e009         	b	0x80154b0 <z_impl_k_thread_suspend+0x170> @ imm = #0x12
; 	    && z_is_thread_timeout_active(thread)) {
 801549c: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 80154a0: f011 f909    	bl	0x80266b6 <z_is_thread_timeout_active> @ imm = #0x11212
 80154a4: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 80154a6: 2b00         	cmp	r3, #0x0
 80154a8: d001         	beq	0x80154ae <z_impl_k_thread_suspend+0x16e> @ imm = #0x2
; 		return true;
 80154aa: 2301         	movs	r3, #0x1
 80154ac: e000         	b	0x80154b0 <z_impl_k_thread_suspend+0x170> @ imm = #0x0
; 	return false;
 80154ae: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 80154b0: 2b00         	cmp	r3, #0x0
 80154b2: d014         	beq	0x80154de <z_impl_k_thread_suspend+0x19e> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80154b4: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8015584 <z_impl_k_thread_suspend+0x244>
 80154b6: 689b         	ldr	r3, [r3, #0x8]
 80154b8: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 80154ba: 6f7b         	ldr	r3, [r7, #0x74]
; 		if (thread != arch_current_thread()) {
 80154bc: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 80154c0: 429a         	cmp	r2, r3
 80154c2: d003         	beq	0x80154cc <z_impl_k_thread_suspend+0x18c> @ imm = #0x6
; 			z_reset_time_slice(thread);
 80154c4: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 80154c8: f001 f9d0    	bl	0x801686c <z_reset_time_slice> @ imm = #0x13a0
; 		update_metairq_preempt(thread);
 80154cc: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 80154d0: f011 fa71    	bl	0x80269b6 <update_metairq_preempt> @ imm = #0x114e2
; 		_kernel.ready_q.cache = thread;
 80154d4: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8015584 <z_impl_k_thread_suspend+0x244>
 80154d6: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80154da: 6213         	str	r3, [r2, #0x20]
; }
 80154dc: e005         	b	0x80154ea <z_impl_k_thread_suspend+0x1aa> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80154de: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8015584 <z_impl_k_thread_suspend+0x244>
 80154e0: 689b         	ldr	r3, [r3, #0x8]
 80154e2: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 80154e4: 6f3b         	ldr	r3, [r7, #0x70]
; 		_kernel.ready_q.cache = arch_current_thread();
 80154e6: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x8015584 <z_impl_k_thread_suspend+0x244>
 80154e8: 6213         	str	r3, [r2, #0x20]
; }
 80154ea: bf00         	nop
 80154ec: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8015588 <z_impl_k_thread_suspend+0x248>
 80154ee: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 80154f2: 693b         	ldr	r3, [r7, #0x10]
 80154f4: 60bb         	str	r3, [r7, #0x8]
 80154f6: f8d7 30a4    	ldr.w	r3, [r7, #0xa4]
 80154fa: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; }
 80154fe: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8015500: 68bb         	ldr	r3, [r7, #0x8]
 8015502: 4618         	mov	r0, r3
 8015504: f011 f9c9    	bl	0x802689a <z_swap_irqlock> @ imm = #0x11392
 8015508: e039         	b	0x801557e <z_impl_k_thread_suspend+0x23e> @ imm = #0x72
; 	(void)z_abort_thread_timeout(thread);
 801550a: 6878         	ldr	r0, [r7, #0x4]
 801550c: f011 f881    	bl	0x8026612 <z_abort_thread_timeout> @ imm = #0x11102
 8015510: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8015588 <z_impl_k_thread_suspend+0x248>
 8015512: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015514: f3ef 8311    	mrs	r3, basepri
 8015518: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 801551a: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 801551c: 63bb         	str	r3, [r7, #0x38]
 801551e: 2310         	movs	r3, #0x10
 8015520: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015522: 6b7b         	ldr	r3, [r7, #0x34]
 8015524: f383 8812    	msr	basepri_max, r3
; }
 8015528: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801552a: f3bf 8f6f    	isb	sy
; }
 801552e: bf00         	nop
; 	return key;
 8015530: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 8015532: 617b         	str	r3, [r7, #0x14]
 8015534: 6c3b         	ldr	r3, [r7, #0x40]
 8015536: 633b         	str	r3, [r7, #0x30]
; }
 8015538: bf00         	nop
 801553a: 6c3b         	ldr	r3, [r7, #0x40]
 801553c: 62fb         	str	r3, [r7, #0x2c]
; }
 801553e: bf00         	nop
; 	return k;
 8015540: 697b         	ldr	r3, [r7, #0x14]
 8015542: 61fb         	str	r3, [r7, #0x1c]
; 	if ((thread->base.thread_state & _THREAD_SUSPENDED) != 0U) {
 8015544: 687b         	ldr	r3, [r7, #0x4]
 8015546: 7b5b         	ldrb	r3, [r3, #0xd]
 8015548: f003 0310    	and	r3, r3, #0x10
 801554c: 2b00         	cmp	r3, #0x0
 801554e: d011         	beq	0x8015574 <z_impl_k_thread_suspend+0x234> @ imm = #0x22
 8015550: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8015588 <z_impl_k_thread_suspend+0x248>
 8015552: 62bb         	str	r3, [r7, #0x28]
 8015554: 69fb         	ldr	r3, [r7, #0x1c]
 8015556: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8015558: 69bb         	ldr	r3, [r7, #0x18]
 801555a: 627b         	str	r3, [r7, #0x24]
 801555c: 6a7b         	ldr	r3, [r7, #0x24]
 801555e: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015560: 6a3b         	ldr	r3, [r7, #0x20]
 8015562: f383 8811    	msr	basepri, r3
; }
 8015566: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015568: f3bf 8f6f    	isb	sy
; }
 801556c: bf00         	nop
; }
 801556e: bf00         	nop
; }
 8015570: bf00         	nop
; 		return;
 8015572: e004         	b	0x801557e <z_impl_k_thread_suspend+0x23e> @ imm = #0x8
; 	z_thread_halt(thread, key, false);
 8015574: 2200         	movs	r2, #0x0
 8015576: 69f9         	ldr	r1, [r7, #0x1c]
 8015578: 6878         	ldr	r0, [r7, #0x4]
 801557a: f7ff fe5b    	bl	0x8015234 <z_thread_halt> @ imm = #-0x34a
; }
 801557e: 37b0         	adds	r7, #0xb0
 8015580: 46bd         	mov	sp, r7
 8015582: bd80         	pop	{r7, pc}

08015584 <$d>:
 8015584: a8 25 00 20  	.word	0x200025a8
 8015588: ec 32 00 20  	.word	0x200032ec
 801558c: cc 25 00 20  	.word	0x200025cc

08015590 <z_impl_k_thread_resume>:
; {
 8015590: b580         	push	{r7, lr}
 8015592: b08e         	sub	sp, #0x38
 8015594: af00         	add	r7, sp, #0x0
 8015596: 6078         	str	r0, [r7, #0x4]
 8015598: 4b20         	ldr	r3, [pc, #0x80]         @ 0x801561c <z_impl_k_thread_resume+0x8c>
 801559a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801559c: f3ef 8311    	mrs	r3, basepri
 80155a0: 633b         	str	r3, [r7, #0x30]
;   return(result);
 80155a2: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 80155a4: 62fb         	str	r3, [r7, #0x2c]
 80155a6: 2310         	movs	r3, #0x10
 80155a8: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80155aa: 6abb         	ldr	r3, [r7, #0x28]
 80155ac: f383 8812    	msr	basepri_max, r3
; }
 80155b0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80155b2: f3bf 8f6f    	isb	sy
; }
 80155b6: bf00         	nop
; 	return key;
 80155b8: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 80155ba: 60bb         	str	r3, [r7, #0x8]
 80155bc: 6b7b         	ldr	r3, [r7, #0x34]
 80155be: 627b         	str	r3, [r7, #0x24]
; }
 80155c0: bf00         	nop
 80155c2: 6b7b         	ldr	r3, [r7, #0x34]
 80155c4: 623b         	str	r3, [r7, #0x20]
; }
 80155c6: bf00         	nop
; 	return k;
 80155c8: 68bb         	ldr	r3, [r7, #0x8]
 80155ca: 613b         	str	r3, [r7, #0x10]
; 	if (!z_is_thread_suspended(thread)) {
 80155cc: 6878         	ldr	r0, [r7, #0x4]
 80155ce: f011 f84a    	bl	0x8026666 <z_is_thread_suspended> @ imm = #0x11094
 80155d2: 4603         	mov	r3, r0
 80155d4: f083 0301    	eor	r3, r3, #0x1
 80155d8: b2db         	uxtb	r3, r3
 80155da: 2b00         	cmp	r3, #0x0
 80155dc: d010         	beq	0x8015600 <z_impl_k_thread_resume+0x70> @ imm = #0x20
 80155de: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x801561c <z_impl_k_thread_resume+0x8c>
 80155e0: 61fb         	str	r3, [r7, #0x1c]
 80155e2: 693b         	ldr	r3, [r7, #0x10]
 80155e4: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 80155e6: 68fb         	ldr	r3, [r7, #0xc]
 80155e8: 61bb         	str	r3, [r7, #0x18]
 80155ea: 69bb         	ldr	r3, [r7, #0x18]
 80155ec: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80155ee: 697b         	ldr	r3, [r7, #0x14]
 80155f0: f383 8811    	msr	basepri, r3
; }
 80155f4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80155f6: f3bf 8f6f    	isb	sy
; }
 80155fa: bf00         	nop
; }
 80155fc: bf00         	nop
; }
 80155fe: e009         	b	0x8015614 <z_impl_k_thread_resume+0x84> @ imm = #0x12
; 	z_mark_thread_as_not_suspended(thread);
 8015600: 6878         	ldr	r0, [r7, #0x4]
 8015602: f011 f8c4    	bl	0x802678e <z_mark_thread_as_not_suspended> @ imm = #0x11188
; 	ready_thread(thread);
 8015606: 6878         	ldr	r0, [r7, #0x4]
 8015608: f7ff fc94    	bl	0x8014f34 <ready_thread> @ imm = #-0x6d8
; 	z_reschedule(&_sched_spinlock, key);
 801560c: 6939         	ldr	r1, [r7, #0x10]
 801560e: 4803         	ldr	r0, [pc, #0xc]          @ 0x801561c <z_impl_k_thread_resume+0x8c>
 8015610: f011 faac    	bl	0x8026b6c <z_reschedule> @ imm = #0x11558
; }
 8015614: 3738         	adds	r7, #0x38
 8015616: 46bd         	mov	sp, r7
 8015618: bd80         	pop	{r7, pc}
 801561a: bf00         	nop

0801561c <$d>:
 801561c: ec 32 00 20  	.word	0x200032ec

08015620 <unready_thread>:
; {
 8015620: b580         	push	{r7, lr}
 8015622: b094         	sub	sp, #0x50
 8015624: af00         	add	r7, sp, #0x0
 8015626: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 8015628: 6878         	ldr	r0, [r7, #0x4]
 801562a: f011 f892    	bl	0x8026752 <z_is_thread_queued> @ imm = #0x11124
 801562e: 4603         	mov	r3, r0
 8015630: 2b00         	cmp	r3, #0x0
 8015632: d01d         	beq	0x8015670 <unready_thread+0x50> @ imm = #0x3a
 8015634: 687b         	ldr	r3, [r7, #0x4]
 8015636: 64fb         	str	r3, [r7, #0x4c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8015638: 6cfb         	ldr	r3, [r7, #0x4c]
 801563a: 7b5b         	ldrb	r3, [r3, #0xd]
 801563c: f003 037f    	and	r3, r3, #0x7f
 8015640: b2da         	uxtb	r2, r3
 8015642: 6cfb         	ldr	r3, [r7, #0x4c]
 8015644: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8015646: 6cf8         	ldr	r0, [r7, #0x4c]
 8015648: f011 f96e    	bl	0x8026928 <should_queue_thread> @ imm = #0x112dc
 801564c: 4603         	mov	r3, r0
 801564e: 2b00         	cmp	r3, #0x0
 8015650: d00d         	beq	0x801566e <unready_thread+0x4e> @ imm = #0x1a
 8015652: 6cfb         	ldr	r3, [r7, #0x4c]
 8015654: 64bb         	str	r3, [r7, #0x48]
 8015656: 6cbb         	ldr	r3, [r7, #0x48]
 8015658: 647b         	str	r3, [r7, #0x44]
; 	return &_kernel.ready_q.runq;
 801565a: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8015754 <unready_thread+0x134>
 801565c: 643b         	str	r3, [r7, #0x40]
 801565e: 6cbb         	ldr	r3, [r7, #0x48]
 8015660: 63fb         	str	r3, [r7, #0x3c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8015662: 6bfb         	ldr	r3, [r7, #0x3c]
 8015664: 4618         	mov	r0, r3
 8015666: f010 ff94    	bl	0x8026592 <sys_dlist_remove> @ imm = #0x10f28
; }
 801566a: bf00         	nop
; }
 801566c: bf00         	nop
; }
 801566e: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015670: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8015758 <unready_thread+0x138>
 8015672: 689b         	ldr	r3, [r3, #0x8]
 8015674: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8015676: 68bb         	ldr	r3, [r7, #0x8]
; 	update_cache(thread == arch_current_thread());
 8015678: 687a         	ldr	r2, [r7, #0x4]
 801567a: 429a         	cmp	r2, r3
 801567c: bf0c         	ite	eq
 801567e: 2301         	moveq	r3, #0x1
 8015680: 2300         	movne	r3, #0x0
 8015682: b2db         	uxtb	r3, r3
 8015684: 63bb         	str	r3, [r7, #0x38]
; 	return &_kernel.ready_q.runq;
 8015686: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8015754 <unready_thread+0x134>
 8015688: 637b         	str	r3, [r7, #0x34]
; 	struct k_thread *thread = NULL;
 801568a: 2300         	movs	r3, #0x0
 801568c: 633b         	str	r3, [r7, #0x30]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 801568e: 6b78         	ldr	r0, [r7, #0x34]
 8015690: f010 ff12    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x10e24
 8015694: 62f8         	str	r0, [r7, #0x2c]
; 	if (n != NULL) {
 8015696: 6afb         	ldr	r3, [r7, #0x2c]
 8015698: 2b00         	cmp	r3, #0x0
 801569a: d001         	beq	0x80156a0 <unready_thread+0x80> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 801569c: 6afb         	ldr	r3, [r7, #0x2c]
 801569e: 633b         	str	r3, [r7, #0x30]
; 	return thread;
 80156a0: 6b3b         	ldr	r3, [r7, #0x30]
; 	return _priq_run_best(curr_cpu_runq());
 80156a2: bf00         	nop
; 	struct k_thread *thread = runq_best();
 80156a4: 62bb         	str	r3, [r7, #0x28]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 80156a6: 6abb         	ldr	r3, [r7, #0x28]
 80156a8: 2b00         	cmp	r3, #0x0
 80156aa: d102         	bne	0x80156b2 <unready_thread+0x92> @ imm = #0x4
 80156ac: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8015758 <unready_thread+0x138>
 80156ae: 68db         	ldr	r3, [r3, #0xc]
 80156b0: e000         	b	0x80156b4 <unready_thread+0x94> @ imm = #0x0
 80156b2: 6abb         	ldr	r3, [r7, #0x28]
; 	struct k_thread *thread = next_up();
 80156b4: 627b         	str	r3, [r7, #0x24]
 80156b6: 6a7b         	ldr	r3, [r7, #0x24]
 80156b8: 623b         	str	r3, [r7, #0x20]
 80156ba: 6bbb         	ldr	r3, [r7, #0x38]
 80156bc: 61fb         	str	r3, [r7, #0x1c]
; 	if (preempt_ok != 0) {
 80156be: 69fb         	ldr	r3, [r7, #0x1c]
 80156c0: 2b00         	cmp	r3, #0x0
 80156c2: d001         	beq	0x80156c8 <unready_thread+0xa8> @ imm = #0x2
; 		return true;
 80156c4: 2301         	movs	r3, #0x1
 80156c6: e026         	b	0x8015716 <unready_thread+0xf6> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80156c8: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8015758 <unready_thread+0x138>
 80156ca: 689b         	ldr	r3, [r3, #0x8]
 80156cc: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 80156ce: 69bb         	ldr	r3, [r7, #0x18]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 80156d0: 4618         	mov	r0, r3
 80156d2: f010 ffdb    	bl	0x802668c <z_is_thread_prevented_from_running> @ imm = #0x10fb6
 80156d6: 4603         	mov	r3, r0
 80156d8: 2b00         	cmp	r3, #0x0
 80156da: d001         	beq	0x80156e0 <unready_thread+0xc0> @ imm = #0x2
; 		return true;
 80156dc: 2301         	movs	r3, #0x1
 80156de: e01a         	b	0x8015716 <unready_thread+0xf6> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80156e0: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8015758 <unready_thread+0x138>
 80156e2: 689b         	ldr	r3, [r3, #0x8]
 80156e4: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 80156e6: 697b         	ldr	r3, [r7, #0x14]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 80156e8: 4618         	mov	r0, r3
 80156ea: f010 ffa0    	bl	0x802662e <thread_is_preemptible> @ imm = #0x10f40
 80156ee: 4603         	mov	r3, r0
 80156f0: 2b00         	cmp	r3, #0x0
 80156f2: d105         	bne	0x8015700 <unready_thread+0xe0> @ imm = #0xa
 80156f4: 6a38         	ldr	r0, [r7, #0x20]
 80156f6: f010 ffab    	bl	0x8026650 <thread_is_metairq> @ imm = #0x10f56
 80156fa: 4603         	mov	r3, r0
 80156fc: 2b00         	cmp	r3, #0x0
 80156fe: d001         	beq	0x8015704 <unready_thread+0xe4> @ imm = #0x2
; 		return true;
 8015700: 2301         	movs	r3, #0x1
 8015702: e008         	b	0x8015716 <unready_thread+0xf6> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8015704: 6a38         	ldr	r0, [r7, #0x20]
 8015706: f010 ffd6    	bl	0x80266b6 <z_is_thread_timeout_active> @ imm = #0x10fac
 801570a: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 801570c: 2b00         	cmp	r3, #0x0
 801570e: d001         	beq	0x8015714 <unready_thread+0xf4> @ imm = #0x2
; 		return true;
 8015710: 2301         	movs	r3, #0x1
 8015712: e000         	b	0x8015716 <unready_thread+0xf6> @ imm = #0x0
; 	return false;
 8015714: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8015716: 2b00         	cmp	r3, #0x0
 8015718: d010         	beq	0x801573c <unready_thread+0x11c> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801571a: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8015758 <unready_thread+0x138>
 801571c: 689b         	ldr	r3, [r3, #0x8]
 801571e: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8015720: 693b         	ldr	r3, [r7, #0x10]
; 		if (thread != arch_current_thread()) {
 8015722: 6a7a         	ldr	r2, [r7, #0x24]
 8015724: 429a         	cmp	r2, r3
 8015726: d002         	beq	0x801572e <unready_thread+0x10e> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8015728: 6a78         	ldr	r0, [r7, #0x24]
 801572a: f001 f89f    	bl	0x801686c <z_reset_time_slice> @ imm = #0x113e
; 		update_metairq_preempt(thread);
 801572e: 6a78         	ldr	r0, [r7, #0x24]
 8015730: f011 f941    	bl	0x80269b6 <update_metairq_preempt> @ imm = #0x11282
; 		_kernel.ready_q.cache = thread;
 8015734: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8015758 <unready_thread+0x138>
 8015736: 6a7b         	ldr	r3, [r7, #0x24]
 8015738: 6213         	str	r3, [r2, #0x20]
; }
 801573a: e005         	b	0x8015748 <unready_thread+0x128> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801573c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8015758 <unready_thread+0x138>
 801573e: 689b         	ldr	r3, [r3, #0x8]
 8015740: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8015742: 68fb         	ldr	r3, [r7, #0xc]
; 		_kernel.ready_q.cache = arch_current_thread();
 8015744: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8015758 <unready_thread+0x138>
 8015746: 6213         	str	r3, [r2, #0x20]
; }
 8015748: bf00         	nop
; }
 801574a: bf00         	nop
 801574c: 3750         	adds	r7, #0x50
 801574e: 46bd         	mov	sp, r7
 8015750: bd80         	pop	{r7, pc}
 8015752: bf00         	nop

08015754 <$d>:
 8015754: cc 25 00 20  	.word	0x200025cc
 8015758: a8 25 00 20  	.word	0x200025a8

0801575c <z_unpend_thread_no_timeout>:
; {
 801575c: b580         	push	{r7, lr}
 801575e: b090         	sub	sp, #0x40
 8015760: af00         	add	r7, sp, #0x0
 8015762: 6078         	str	r0, [r7, #0x4]
; 	K_SPINLOCK(&_sched_spinlock) {
 8015764: 2300         	movs	r3, #0x0
 8015766: 61bb         	str	r3, [r7, #0x18]
 8015768: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80157e4 <z_unpend_thread_no_timeout+0x88>
 801576a: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801576c: f3ef 8311    	mrs	r3, basepri
 8015770: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 8015772: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 8015774: 637b         	str	r3, [r7, #0x34]
 8015776: 2310         	movs	r3, #0x10
 8015778: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801577a: 6b3b         	ldr	r3, [r7, #0x30]
 801577c: f383 8812    	msr	basepri_max, r3
; }
 8015780: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015782: f3bf 8f6f    	isb	sy
; }
 8015786: bf00         	nop
; 	return key;
 8015788: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 801578a: 60fb         	str	r3, [r7, #0xc]
 801578c: 6bfb         	ldr	r3, [r7, #0x3c]
 801578e: 62fb         	str	r3, [r7, #0x2c]
; }
 8015790: bf00         	nop
 8015792: 6bfb         	ldr	r3, [r7, #0x3c]
 8015794: 62bb         	str	r3, [r7, #0x28]
; }
 8015796: bf00         	nop
; 	return k;
 8015798: 68fb         	ldr	r3, [r7, #0xc]
 801579a: 617b         	str	r3, [r7, #0x14]
; 	K_SPINLOCK(&_sched_spinlock) {
 801579c: e019         	b	0x80157d2 <z_unpend_thread_no_timeout+0x76> @ imm = #0x32
; 		if (thread->base.pended_on != NULL) {
 801579e: 687b         	ldr	r3, [r7, #0x4]
 80157a0: 689b         	ldr	r3, [r3, #0x8]
 80157a2: 2b00         	cmp	r3, #0x0
 80157a4: d002         	beq	0x80157ac <z_unpend_thread_no_timeout+0x50> @ imm = #0x4
; 			unpend_thread_no_timeout(thread);
 80157a6: 6878         	ldr	r0, [r7, #0x4]
 80157a8: f011 f850    	bl	0x802684c <unpend_thread_no_timeout> @ imm = #0x110a0
 80157ac: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80157e4 <z_unpend_thread_no_timeout+0x88>
 80157ae: 627b         	str	r3, [r7, #0x24]
 80157b0: 697b         	ldr	r3, [r7, #0x14]
 80157b2: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 80157b4: 693b         	ldr	r3, [r7, #0x10]
 80157b6: 623b         	str	r3, [r7, #0x20]
 80157b8: 6a3b         	ldr	r3, [r7, #0x20]
 80157ba: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80157bc: 69fb         	ldr	r3, [r7, #0x1c]
 80157be: f383 8811    	msr	basepri, r3
; }
 80157c2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80157c4: f3bf 8f6f    	isb	sy
; }
 80157c8: bf00         	nop
; }
 80157ca: bf00         	nop
; }
 80157cc: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 80157ce: 2301         	movs	r3, #0x1
 80157d0: 61bb         	str	r3, [r7, #0x18]
 80157d2: 69bb         	ldr	r3, [r7, #0x18]
 80157d4: 2b00         	cmp	r3, #0x0
 80157d6: d0e2         	beq	0x801579e <z_unpend_thread_no_timeout+0x42> @ imm = #-0x3c
; }
 80157d8: bf00         	nop
 80157da: bf00         	nop
 80157dc: 3740         	adds	r7, #0x40
 80157de: 46bd         	mov	sp, r7
 80157e0: bd80         	pop	{r7, pc}
 80157e2: bf00         	nop

080157e4 <$d>:
 80157e4: ec 32 00 20  	.word	0x200032ec

080157e8 <z_sched_wake_thread>:
; {
 80157e8: b580         	push	{r7, lr}
 80157ea: b090         	sub	sp, #0x40
 80157ec: af00         	add	r7, sp, #0x0
 80157ee: 6078         	str	r0, [r7, #0x4]
 80157f0: 460b         	mov	r3, r1
 80157f2: 70fb         	strb	r3, [r7, #0x3]
; 	K_SPINLOCK(&_sched_spinlock) {
 80157f4: 2300         	movs	r3, #0x0
 80157f6: 617b         	str	r3, [r7, #0x14]
 80157f8: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x80158dc <z_sched_wake_thread+0xf4>
 80157fa: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80157fc: f3ef 8311    	mrs	r3, basepri
 8015800: 637b         	str	r3, [r7, #0x34]
;   return(result);
 8015802: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 8015804: 633b         	str	r3, [r7, #0x30]
 8015806: 2310         	movs	r3, #0x10
 8015808: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801580a: 6afb         	ldr	r3, [r7, #0x2c]
 801580c: f383 8812    	msr	basepri_max, r3
; }
 8015810: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015812: f3bf 8f6f    	isb	sy
; }
 8015816: bf00         	nop
; 	return key;
 8015818: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 801581a: 60bb         	str	r3, [r7, #0x8]
 801581c: 6bbb         	ldr	r3, [r7, #0x38]
 801581e: 62bb         	str	r3, [r7, #0x28]
; }
 8015820: bf00         	nop
 8015822: 6bbb         	ldr	r3, [r7, #0x38]
 8015824: 627b         	str	r3, [r7, #0x24]
; }
 8015826: bf00         	nop
; 	return k;
 8015828: 68bb         	ldr	r3, [r7, #0x8]
 801582a: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 801582c: e04d         	b	0x80158ca <z_sched_wake_thread+0xe2> @ imm = #0x9a
; 		bool killed = (thread->base.thread_state &
 801582e: 687b         	ldr	r3, [r7, #0x4]
 8015830: 7b5b         	ldrb	r3, [r3, #0xd]
 8015832: f003 0328    	and	r3, r3, #0x28
 8015836: 2b00         	cmp	r3, #0x0
 8015838: bf14         	ite	ne
 801583a: 2301         	movne	r3, #0x1
 801583c: 2300         	moveq	r3, #0x0
 801583e: f887 303f    	strb.w	r3, [r7, #0x3f]
; 		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
 8015842: 687b         	ldr	r3, [r7, #0x4]
 8015844: f893 307c    	ldrb.w	r3, [r3, #0x7c]
 8015848: 2b00         	cmp	r3, #0x0
 801584a: d004         	beq	0x8015856 <z_sched_wake_thread+0x6e> @ imm = #0x8
 801584c: 78fb         	ldrb	r3, [r7, #0x3]
 801584e: 2b00         	cmp	r3, #0x0
 8015850: d001         	beq	0x8015856 <z_sched_wake_thread+0x6e> @ imm = #0x2
 8015852: 2301         	movs	r3, #0x1
 8015854: e000         	b	0x8015858 <z_sched_wake_thread+0x70> @ imm = #0x0
 8015856: 2300         	movs	r3, #0x0
 8015858: f887 303e    	strb.w	r3, [r7, #0x3e]
 801585c: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 8015860: f003 0301    	and	r3, r3, #0x1
 8015864: f887 303e    	strb.w	r3, [r7, #0x3e]
; 		thread->no_wake_on_timeout = false;
 8015868: 687b         	ldr	r3, [r7, #0x4]
 801586a: 2200         	movs	r2, #0x0
 801586c: f883 207c    	strb.w	r2, [r3, #0x7c]
; 		if (do_nothing) {
 8015870: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 8015874: 2b00         	cmp	r3, #0x0
 8015876: d114         	bne	0x80158a2 <z_sched_wake_thread+0xba> @ imm = #0x28
; 		if (!killed) {
 8015878: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 801587c: f083 0301    	eor	r3, r3, #0x1
 8015880: b2db         	uxtb	r3, r3
 8015882: 2b00         	cmp	r3, #0x0
 8015884: d00e         	beq	0x80158a4 <z_sched_wake_thread+0xbc> @ imm = #0x1c
; 			if (thread->base.pended_on != NULL) {
 8015886: 687b         	ldr	r3, [r7, #0x4]
 8015888: 689b         	ldr	r3, [r3, #0x8]
 801588a: 2b00         	cmp	r3, #0x0
 801588c: d002         	beq	0x8015894 <z_sched_wake_thread+0xac> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 801588e: 6878         	ldr	r0, [r7, #0x4]
 8015890: f010 ffdc    	bl	0x802684c <unpend_thread_no_timeout> @ imm = #0x10fb8
; 			z_mark_thread_as_not_suspended(thread);
 8015894: 6878         	ldr	r0, [r7, #0x4]
 8015896: f010 ff7a    	bl	0x802678e <z_mark_thread_as_not_suspended> @ imm = #0x10ef4
; 			ready_thread(thread);
 801589a: 6878         	ldr	r0, [r7, #0x4]
 801589c: f7ff fb4a    	bl	0x8014f34 <ready_thread> @ imm = #-0x96c
 80158a0: e000         	b	0x80158a4 <z_sched_wake_thread+0xbc> @ imm = #0x0
; 			continue;
 80158a2: bf00         	nop
 80158a4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80158dc <z_sched_wake_thread+0xf4>
 80158a6: 623b         	str	r3, [r7, #0x20]
 80158a8: 693b         	ldr	r3, [r7, #0x10]
 80158aa: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 80158ac: 68fb         	ldr	r3, [r7, #0xc]
 80158ae: 61fb         	str	r3, [r7, #0x1c]
 80158b0: 69fb         	ldr	r3, [r7, #0x1c]
 80158b2: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80158b4: 69bb         	ldr	r3, [r7, #0x18]
 80158b6: f383 8811    	msr	basepri, r3
; }
 80158ba: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80158bc: f3bf 8f6f    	isb	sy
; }
 80158c0: bf00         	nop
; }
 80158c2: bf00         	nop
; }
 80158c4: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 80158c6: 2301         	movs	r3, #0x1
 80158c8: 617b         	str	r3, [r7, #0x14]
 80158ca: 697b         	ldr	r3, [r7, #0x14]
 80158cc: 2b00         	cmp	r3, #0x0
 80158ce: d0ae         	beq	0x801582e <z_sched_wake_thread+0x46> @ imm = #-0xa4
; }
 80158d0: bf00         	nop
 80158d2: bf00         	nop
 80158d4: 3740         	adds	r7, #0x40
 80158d6: 46bd         	mov	sp, r7
 80158d8: bd80         	pop	{r7, pc}
 80158da: bf00         	nop

080158dc <$d>:
 80158dc: ec 32 00 20  	.word	0x200032ec

080158e0 <z_pend_curr>:
; {
 80158e0: b580         	push	{r7, lr}
 80158e2: b092         	sub	sp, #0x48
 80158e4: af00         	add	r7, sp, #0x0
 80158e6: 60f8         	str	r0, [r7, #0xc]
 80158e8: 60b9         	str	r1, [r7, #0x8]
 80158ea: 607a         	str	r2, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80158ec: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8015960 <z_pend_curr+0x80>
 80158ee: 689b         	ldr	r3, [r3, #0x8]
 80158f0: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 80158f2: 69fb         	ldr	r3, [r7, #0x1c]
; 	pending_current = arch_current_thread();
 80158f4: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8015964 <z_pend_curr+0x84>
 80158f6: 6013         	str	r3, [r2]
 80158f8: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8015968 <z_pend_curr+0x88>
 80158fa: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80158fc: f3ef 8311    	mrs	r3, basepri
 8015900: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8015902: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 8015904: 62fb         	str	r3, [r7, #0x2c]
 8015906: 2310         	movs	r3, #0x10
 8015908: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801590a: 6abb         	ldr	r3, [r7, #0x28]
 801590c: f383 8812    	msr	basepri_max, r3
; }
 8015910: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015912: f3bf 8f6f    	isb	sy
; }
 8015916: bf00         	nop
; 	return key;
 8015918: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 801591a: 61bb         	str	r3, [r7, #0x18]
 801591c: 6b7b         	ldr	r3, [r7, #0x34]
 801591e: 627b         	str	r3, [r7, #0x24]
; }
 8015920: bf00         	nop
 8015922: 6b7b         	ldr	r3, [r7, #0x34]
 8015924: 623b         	str	r3, [r7, #0x20]
; }
 8015926: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015928: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8015960 <z_pend_curr+0x80>
 801592a: 689b         	ldr	r3, [r3, #0x8]
 801592c: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 801592e: 6bb8         	ldr	r0, [r7, #0x38]
; 	pend_locked(arch_current_thread(), wait_q, timeout);
 8015930: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 8015934: 6879         	ldr	r1, [r7, #0x4]
 8015936: f011 f8c0    	bl	0x8026aba <pend_locked> @ imm = #0x11180
 801593a: 68fb         	ldr	r3, [r7, #0xc]
 801593c: 63fb         	str	r3, [r7, #0x3c]
; }
 801593e: bf00         	nop
 8015940: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8015968 <z_pend_curr+0x88>
 8015942: 647b         	str	r3, [r7, #0x44]
 8015944: 68bb         	ldr	r3, [r7, #0x8]
 8015946: 617b         	str	r3, [r7, #0x14]
 8015948: 6c7b         	ldr	r3, [r7, #0x44]
 801594a: 643b         	str	r3, [r7, #0x40]
 801594c: bf00         	nop
; 	return z_swap_irqlock(key.key);
 801594e: 697b         	ldr	r3, [r7, #0x14]
 8015950: 4618         	mov	r0, r3
 8015952: f010 ffa2    	bl	0x802689a <z_swap_irqlock> @ imm = #0x10f44
 8015956: 4603         	mov	r3, r0
; }
 8015958: 4618         	mov	r0, r3
 801595a: 3748         	adds	r7, #0x48
 801595c: 46bd         	mov	sp, r7
 801595e: bd80         	pop	{r7, pc}

08015960 <$d>:
 8015960: a8 25 00 20  	.word	0x200025a8
 8015964: f8 32 00 20  	.word	0x200032f8
 8015968: ec 32 00 20  	.word	0x200032ec

0801596c <z_unpend1_no_timeout>:
; {
 801596c: b580         	push	{r7, lr}
 801596e: b094         	sub	sp, #0x50
 8015970: af00         	add	r7, sp, #0x0
 8015972: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = NULL;
 8015974: 2300         	movs	r3, #0x0
 8015976: 64fb         	str	r3, [r7, #0x4c]
; 	K_SPINLOCK(&_sched_spinlock) {
 8015978: 2300         	movs	r3, #0x0
 801597a: 61bb         	str	r3, [r7, #0x18]
 801597c: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8015a14 <z_unpend1_no_timeout+0xa8>
 801597e: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015980: f3ef 8311    	mrs	r3, basepri
 8015984: 647b         	str	r3, [r7, #0x44]
;   return(result);
 8015986: 6c7b         	ldr	r3, [r7, #0x44]
; 	key = __get_BASEPRI();
 8015988: 643b         	str	r3, [r7, #0x40]
 801598a: 2310         	movs	r3, #0x10
 801598c: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801598e: 6bfb         	ldr	r3, [r7, #0x3c]
 8015990: f383 8812    	msr	basepri_max, r3
; }
 8015994: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015996: f3bf 8f6f    	isb	sy
; }
 801599a: bf00         	nop
; 	return key;
 801599c: 6c3b         	ldr	r3, [r7, #0x40]
; 	k.key = arch_irq_lock();
 801599e: 60fb         	str	r3, [r7, #0xc]
 80159a0: 6cbb         	ldr	r3, [r7, #0x48]
 80159a2: 63bb         	str	r3, [r7, #0x38]
; }
 80159a4: bf00         	nop
 80159a6: 6cbb         	ldr	r3, [r7, #0x48]
 80159a8: 637b         	str	r3, [r7, #0x34]
; }
 80159aa: bf00         	nop
; 	return k;
 80159ac: 68fb         	ldr	r3, [r7, #0xc]
 80159ae: 617b         	str	r3, [r7, #0x14]
; 	K_SPINLOCK(&_sched_spinlock) {
 80159b0: e027         	b	0x8015a02 <z_unpend1_no_timeout+0x96> @ imm = #0x4e
; 		thread = _priq_wait_best(&wait_q->waitq);
 80159b2: 687b         	ldr	r3, [r7, #0x4]
 80159b4: 633b         	str	r3, [r7, #0x30]
; 	struct k_thread *thread = NULL;
 80159b6: 2300         	movs	r3, #0x0
 80159b8: 62fb         	str	r3, [r7, #0x2c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 80159ba: 6b38         	ldr	r0, [r7, #0x30]
 80159bc: f010 fd7c    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x10af8
 80159c0: 62b8         	str	r0, [r7, #0x28]
; 	if (n != NULL) {
 80159c2: 6abb         	ldr	r3, [r7, #0x28]
 80159c4: 2b00         	cmp	r3, #0x0
 80159c6: d001         	beq	0x80159cc <z_unpend1_no_timeout+0x60> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80159c8: 6abb         	ldr	r3, [r7, #0x28]
 80159ca: 62fb         	str	r3, [r7, #0x2c]
; 	return thread;
 80159cc: 6afb         	ldr	r3, [r7, #0x2c]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80159ce: 64fb         	str	r3, [r7, #0x4c]
; 		if (thread != NULL) {
 80159d0: 6cfb         	ldr	r3, [r7, #0x4c]
 80159d2: 2b00         	cmp	r3, #0x0
 80159d4: d002         	beq	0x80159dc <z_unpend1_no_timeout+0x70> @ imm = #0x4
; 			unpend_thread_no_timeout(thread);
 80159d6: 6cf8         	ldr	r0, [r7, #0x4c]
 80159d8: f010 ff38    	bl	0x802684c <unpend_thread_no_timeout> @ imm = #0x10e70
 80159dc: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8015a14 <z_unpend1_no_timeout+0xa8>
 80159de: 627b         	str	r3, [r7, #0x24]
 80159e0: 697b         	ldr	r3, [r7, #0x14]
 80159e2: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 80159e4: 693b         	ldr	r3, [r7, #0x10]
 80159e6: 623b         	str	r3, [r7, #0x20]
 80159e8: 6a3b         	ldr	r3, [r7, #0x20]
 80159ea: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80159ec: 69fb         	ldr	r3, [r7, #0x1c]
 80159ee: f383 8811    	msr	basepri, r3
; }
 80159f2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80159f4: f3bf 8f6f    	isb	sy
; }
 80159f8: bf00         	nop
; }
 80159fa: bf00         	nop
; }
 80159fc: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 80159fe: 2301         	movs	r3, #0x1
 8015a00: 61bb         	str	r3, [r7, #0x18]
 8015a02: 69bb         	ldr	r3, [r7, #0x18]
 8015a04: 2b00         	cmp	r3, #0x0
 8015a06: d0d4         	beq	0x80159b2 <z_unpend1_no_timeout+0x46> @ imm = #-0x58
; 	return thread;
 8015a08: 6cfb         	ldr	r3, [r7, #0x4c]
; }
 8015a0a: 4618         	mov	r0, r3
 8015a0c: 3750         	adds	r7, #0x50
 8015a0e: 46bd         	mov	sp, r7
 8015a10: bd80         	pop	{r7, pc}
 8015a12: bf00         	nop

08015a14 <$d>:
 8015a14: ec 32 00 20  	.word	0x200032ec

08015a18 <z_thread_prio_set>:
; {
 8015a18: b580         	push	{r7, lr}
 8015a1a: b0a8         	sub	sp, #0xa0
 8015a1c: af00         	add	r7, sp, #0x0
 8015a1e: 6078         	str	r0, [r7, #0x4]
 8015a20: 6039         	str	r1, [r7]
; 	bool need_sched = 0;
 8015a22: 2300         	movs	r3, #0x0
 8015a24: f887 309f    	strb.w	r3, [r7, #0x9f]
; 	int old_prio = thread->base.prio;
 8015a28: 687b         	ldr	r3, [r7, #0x4]
 8015a2a: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8015a2e: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	K_SPINLOCK(&_sched_spinlock) {
 8015a32: 2300         	movs	r3, #0x0
 8015a34: 617b         	str	r3, [r7, #0x14]
 8015a36: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8015c8c <z_thread_prio_set+0x274>
 8015a38: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015a3c: f3ef 8311    	mrs	r3, basepri
 8015a40: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 8015a44: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 8015a48: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8015a4c: 2310         	movs	r3, #0x10
 8015a4e: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015a52: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8015a56: f383 8812    	msr	basepri_max, r3
; }
 8015a5a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015a5c: f3bf 8f6f    	isb	sy
; }
 8015a60: bf00         	nop
; 	return key;
 8015a62: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 8015a66: 60bb         	str	r3, [r7, #0x8]
 8015a68: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 8015a6c: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 8015a70: bf00         	nop
 8015a72: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 8015a76: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 8015a7a: bf00         	nop
; 	return k;
 8015a7c: 68bb         	ldr	r3, [r7, #0x8]
 8015a7e: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 8015a80: e0fa         	b	0x8015c78 <z_thread_prio_set+0x260> @ imm = #0x1f4
; 		need_sched = z_is_thread_ready(thread);
 8015a82: 6878         	ldr	r0, [r7, #0x4]
 8015a84: f010 fe30    	bl	0x80266e8 <z_is_thread_ready> @ imm = #0x10c60
 8015a88: 4603         	mov	r3, r0
 8015a8a: f887 309f    	strb.w	r3, [r7, #0x9f]
; 		if (need_sched) {
 8015a8e: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 8015a92: 2b00         	cmp	r3, #0x0
 8015a94: f000 80d9    	beq.w	0x8015c4a <z_thread_prio_set+0x232> @ imm = #0x1b2
 8015a98: 687b         	ldr	r3, [r7, #0x4]
 8015a9a: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8015a9c: 6e7b         	ldr	r3, [r7, #0x64]
 8015a9e: 7b5b         	ldrb	r3, [r3, #0xd]
 8015aa0: f003 037f    	and	r3, r3, #0x7f
 8015aa4: b2da         	uxtb	r2, r3
 8015aa6: 6e7b         	ldr	r3, [r7, #0x64]
 8015aa8: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8015aaa: 6e78         	ldr	r0, [r7, #0x64]
 8015aac: f010 ff3c    	bl	0x8026928 <should_queue_thread> @ imm = #0x10e78
 8015ab0: 4603         	mov	r3, r0
 8015ab2: 2b00         	cmp	r3, #0x0
 8015ab4: d00d         	beq	0x8015ad2 <z_thread_prio_set+0xba> @ imm = #0x1a
 8015ab6: 6e7b         	ldr	r3, [r7, #0x64]
 8015ab8: 663b         	str	r3, [r7, #0x60]
 8015aba: 6e3b         	ldr	r3, [r7, #0x60]
 8015abc: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 8015abe: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8015c90 <z_thread_prio_set+0x278>
 8015ac0: 65bb         	str	r3, [r7, #0x58]
 8015ac2: 6e3b         	ldr	r3, [r7, #0x60]
 8015ac4: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8015ac6: 6d7b         	ldr	r3, [r7, #0x54]
 8015ac8: 4618         	mov	r0, r3
 8015aca: f010 fd62    	bl	0x8026592 <sys_dlist_remove> @ imm = #0x10ac4
; }
 8015ace: bf00         	nop
; }
 8015ad0: bf00         	nop
; }
 8015ad2: bf00         	nop
; 				thread->base.prio = prio;
 8015ad4: 683b         	ldr	r3, [r7]
 8015ad6: b25a         	sxtb	r2, r3
 8015ad8: 687b         	ldr	r3, [r7, #0x4]
 8015ada: 739a         	strb	r2, [r3, #0xe]
 8015adc: 687b         	ldr	r3, [r7, #0x4]
 8015ade: 67fb         	str	r3, [r7, #0x7c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 8015ae0: 6ffb         	ldr	r3, [r7, #0x7c]
 8015ae2: 7b5b         	ldrb	r3, [r3, #0xd]
 8015ae4: f063 037f    	orn	r3, r3, #0x7f
 8015ae8: b2da         	uxtb	r2, r3
 8015aea: 6ffb         	ldr	r3, [r7, #0x7c]
 8015aec: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8015aee: 6ff8         	ldr	r0, [r7, #0x7c]
 8015af0: f010 ff1a    	bl	0x8026928 <should_queue_thread> @ imm = #0x10e34
 8015af4: 4603         	mov	r3, r0
 8015af6: 2b00         	cmp	r3, #0x0
 8015af8: d042         	beq	0x8015b80 <z_thread_prio_set+0x168> @ imm = #0x84
 8015afa: 6ffb         	ldr	r3, [r7, #0x7c]
 8015afc: 67bb         	str	r3, [r7, #0x78]
 8015afe: 6fbb         	ldr	r3, [r7, #0x78]
 8015b00: 677b         	str	r3, [r7, #0x74]
; 	return &_kernel.ready_q.runq;
 8015b02: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8015c90 <z_thread_prio_set+0x278>
 8015b04: 673b         	str	r3, [r7, #0x70]
 8015b06: 6fbb         	ldr	r3, [r7, #0x78]
 8015b08: 66fb         	str	r3, [r7, #0x6c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8015b0a: 6f38         	ldr	r0, [r7, #0x70]
 8015b0c: f010 fcd4    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x109a8
 8015b10: 4603         	mov	r3, r0
 8015b12: 2b00         	cmp	r3, #0x0
 8015b14: d004         	beq	0x8015b20 <z_thread_prio_set+0x108> @ imm = #0x8
 8015b16: 6f38         	ldr	r0, [r7, #0x70]
 8015b18: f010 fcce    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x1099c
 8015b1c: 4603         	mov	r3, r0
 8015b1e: e000         	b	0x8015b22 <z_thread_prio_set+0x10a> @ imm = #0x0
 8015b20: 2300         	movs	r3, #0x0
 8015b22: 66bb         	str	r3, [r7, #0x68]
 8015b24: e023         	b	0x8015b6e <z_thread_prio_set+0x156> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8015b26: 6eb9         	ldr	r1, [r7, #0x68]
 8015b28: 6ef8         	ldr	r0, [r7, #0x6c]
 8015b2a: f010 fee1    	bl	0x80268f0 <z_sched_prio_cmp> @ imm = #0x10dc2
 8015b2e: 4603         	mov	r3, r0
 8015b30: 2b00         	cmp	r3, #0x0
 8015b32: dd06         	ble	0x8015b42 <z_thread_prio_set+0x12a> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8015b34: 6ebb         	ldr	r3, [r7, #0x68]
 8015b36: 6efa         	ldr	r2, [r7, #0x6c]
 8015b38: 4611         	mov	r1, r2
 8015b3a: 4618         	mov	r0, r3
 8015b3c: f010 fd0f    	bl	0x802655e <sys_dlist_insert> @ imm = #0x10a1e
; 			return;
 8015b40: e01d         	b	0x8015b7e <z_thread_prio_set+0x166> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8015b42: 6ebb         	ldr	r3, [r7, #0x68]
 8015b44: 2b00         	cmp	r3, #0x0
 8015b46: d010         	beq	0x8015b6a <z_thread_prio_set+0x152> @ imm = #0x20
 8015b48: 6ebb         	ldr	r3, [r7, #0x68]
 8015b4a: 4619         	mov	r1, r3
 8015b4c: 6f38         	ldr	r0, [r7, #0x70]
 8015b4e: f010 fcd9    	bl	0x8026504 <sys_dlist_peek_next> @ imm = #0x109b2
 8015b52: 4603         	mov	r3, r0
 8015b54: 2b00         	cmp	r3, #0x0
 8015b56: d006         	beq	0x8015b66 <z_thread_prio_set+0x14e> @ imm = #0xc
 8015b58: 6ebb         	ldr	r3, [r7, #0x68]
 8015b5a: 4619         	mov	r1, r3
 8015b5c: 6f38         	ldr	r0, [r7, #0x70]
 8015b5e: f010 fcd1    	bl	0x8026504 <sys_dlist_peek_next> @ imm = #0x109a2
 8015b62: 4603         	mov	r3, r0
 8015b64: e002         	b	0x8015b6c <z_thread_prio_set+0x154> @ imm = #0x4
 8015b66: 2300         	movs	r3, #0x0
 8015b68: e000         	b	0x8015b6c <z_thread_prio_set+0x154> @ imm = #0x0
 8015b6a: 2300         	movs	r3, #0x0
 8015b6c: 66bb         	str	r3, [r7, #0x68]
 8015b6e: 6ebb         	ldr	r3, [r7, #0x68]
 8015b70: 2b00         	cmp	r3, #0x0
 8015b72: d1d8         	bne	0x8015b26 <z_thread_prio_set+0x10e> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8015b74: 6efb         	ldr	r3, [r7, #0x6c]
 8015b76: 4619         	mov	r1, r3
 8015b78: 6f38         	ldr	r0, [r7, #0x70]
 8015b7a: f010 fcd6    	bl	0x802652a <sys_dlist_append> @ imm = #0x109ac
; }
 8015b7e: bf00         	nop
; }
 8015b80: bf00         	nop
 8015b82: 2301         	movs	r3, #0x1
 8015b84: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 8015b86: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8015c90 <z_thread_prio_set+0x278>
 8015b88: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 8015b8a: 2300         	movs	r3, #0x0
 8015b8c: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8015b8e: 6cf8         	ldr	r0, [r7, #0x4c]
 8015b90: f010 fc92    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x10924
 8015b94: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8015b96: 6c7b         	ldr	r3, [r7, #0x44]
 8015b98: 2b00         	cmp	r3, #0x0
 8015b9a: d001         	beq	0x8015ba0 <z_thread_prio_set+0x188> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8015b9c: 6c7b         	ldr	r3, [r7, #0x44]
 8015b9e: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 8015ba0: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 8015ba2: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8015ba4: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8015ba6: 6c3b         	ldr	r3, [r7, #0x40]
 8015ba8: 2b00         	cmp	r3, #0x0
 8015baa: d102         	bne	0x8015bb2 <z_thread_prio_set+0x19a> @ imm = #0x4
 8015bac: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8015c94 <z_thread_prio_set+0x27c>
 8015bae: 68db         	ldr	r3, [r3, #0xc]
 8015bb0: e000         	b	0x8015bb4 <z_thread_prio_set+0x19c> @ imm = #0x0
 8015bb2: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 8015bb4: 63fb         	str	r3, [r7, #0x3c]
 8015bb6: 6bfb         	ldr	r3, [r7, #0x3c]
 8015bb8: 63bb         	str	r3, [r7, #0x38]
 8015bba: 6d3b         	ldr	r3, [r7, #0x50]
 8015bbc: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 8015bbe: 6b7b         	ldr	r3, [r7, #0x34]
 8015bc0: 2b00         	cmp	r3, #0x0
 8015bc2: d001         	beq	0x8015bc8 <z_thread_prio_set+0x1b0> @ imm = #0x2
; 		return true;
 8015bc4: 2301         	movs	r3, #0x1
 8015bc6: e026         	b	0x8015c16 <z_thread_prio_set+0x1fe> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015bc8: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8015c94 <z_thread_prio_set+0x27c>
 8015bca: 689b         	ldr	r3, [r3, #0x8]
 8015bcc: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 8015bce: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8015bd0: 4618         	mov	r0, r3
 8015bd2: f010 fd5b    	bl	0x802668c <z_is_thread_prevented_from_running> @ imm = #0x10ab6
 8015bd6: 4603         	mov	r3, r0
 8015bd8: 2b00         	cmp	r3, #0x0
 8015bda: d001         	beq	0x8015be0 <z_thread_prio_set+0x1c8> @ imm = #0x2
; 		return true;
 8015bdc: 2301         	movs	r3, #0x1
 8015bde: e01a         	b	0x8015c16 <z_thread_prio_set+0x1fe> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015be0: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8015c94 <z_thread_prio_set+0x27c>
 8015be2: 689b         	ldr	r3, [r3, #0x8]
 8015be4: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 8015be6: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8015be8: 4618         	mov	r0, r3
 8015bea: f010 fd20    	bl	0x802662e <thread_is_preemptible> @ imm = #0x10a40
 8015bee: 4603         	mov	r3, r0
 8015bf0: 2b00         	cmp	r3, #0x0
 8015bf2: d105         	bne	0x8015c00 <z_thread_prio_set+0x1e8> @ imm = #0xa
 8015bf4: 6bb8         	ldr	r0, [r7, #0x38]
 8015bf6: f010 fd2b    	bl	0x8026650 <thread_is_metairq> @ imm = #0x10a56
 8015bfa: 4603         	mov	r3, r0
 8015bfc: 2b00         	cmp	r3, #0x0
 8015bfe: d001         	beq	0x8015c04 <z_thread_prio_set+0x1ec> @ imm = #0x2
; 		return true;
 8015c00: 2301         	movs	r3, #0x1
 8015c02: e008         	b	0x8015c16 <z_thread_prio_set+0x1fe> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8015c04: 6bb8         	ldr	r0, [r7, #0x38]
 8015c06: f010 fd56    	bl	0x80266b6 <z_is_thread_timeout_active> @ imm = #0x10aac
 8015c0a: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8015c0c: 2b00         	cmp	r3, #0x0
 8015c0e: d001         	beq	0x8015c14 <z_thread_prio_set+0x1fc> @ imm = #0x2
; 		return true;
 8015c10: 2301         	movs	r3, #0x1
 8015c12: e000         	b	0x8015c16 <z_thread_prio_set+0x1fe> @ imm = #0x0
; 	return false;
 8015c14: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8015c16: 2b00         	cmp	r3, #0x0
 8015c18: d010         	beq	0x8015c3c <z_thread_prio_set+0x224> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015c1a: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8015c94 <z_thread_prio_set+0x27c>
 8015c1c: 689b         	ldr	r3, [r3, #0x8]
 8015c1e: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8015c20: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 8015c22: 6bfa         	ldr	r2, [r7, #0x3c]
 8015c24: 429a         	cmp	r2, r3
 8015c26: d002         	beq	0x8015c2e <z_thread_prio_set+0x216> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8015c28: 6bf8         	ldr	r0, [r7, #0x3c]
 8015c2a: f000 fe1f    	bl	0x801686c <z_reset_time_slice> @ imm = #0xc3e
; 		update_metairq_preempt(thread);
 8015c2e: 6bf8         	ldr	r0, [r7, #0x3c]
 8015c30: f010 fec1    	bl	0x80269b6 <update_metairq_preempt> @ imm = #0x10d82
; 		_kernel.ready_q.cache = thread;
 8015c34: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8015c94 <z_thread_prio_set+0x27c>
 8015c36: 6bfb         	ldr	r3, [r7, #0x3c]
 8015c38: 6213         	str	r3, [r2, #0x20]
; }
 8015c3a: e00a         	b	0x8015c52 <z_thread_prio_set+0x23a> @ imm = #0x14
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015c3c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8015c94 <z_thread_prio_set+0x27c>
 8015c3e: 689b         	ldr	r3, [r3, #0x8]
 8015c40: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8015c42: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 8015c44: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8015c94 <z_thread_prio_set+0x27c>
 8015c46: 6213         	str	r3, [r2, #0x20]
; }
 8015c48: e003         	b	0x8015c52 <z_thread_prio_set+0x23a> @ imm = #0x6
; 			thread->base.prio = prio;
 8015c4a: 683b         	ldr	r3, [r7]
 8015c4c: b25a         	sxtb	r2, r3
 8015c4e: 687b         	ldr	r3, [r7, #0x4]
 8015c50: 739a         	strb	r2, [r3, #0xe]
 8015c52: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8015c8c <z_thread_prio_set+0x274>
 8015c54: 623b         	str	r3, [r7, #0x20]
 8015c56: 693b         	ldr	r3, [r7, #0x10]
 8015c58: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8015c5a: 68fb         	ldr	r3, [r7, #0xc]
 8015c5c: 61fb         	str	r3, [r7, #0x1c]
 8015c5e: 69fb         	ldr	r3, [r7, #0x1c]
 8015c60: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015c62: 69bb         	ldr	r3, [r7, #0x18]
 8015c64: f383 8811    	msr	basepri, r3
; }
 8015c68: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015c6a: f3bf 8f6f    	isb	sy
; }
 8015c6e: bf00         	nop
; }
 8015c70: bf00         	nop
; }
 8015c72: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8015c74: 2301         	movs	r3, #0x1
 8015c76: 617b         	str	r3, [r7, #0x14]
 8015c78: 697b         	ldr	r3, [r7, #0x14]
 8015c7a: 2b00         	cmp	r3, #0x0
 8015c7c: f43f af01    	beq.w	0x8015a82 <z_thread_prio_set+0x6a> @ imm = #-0x1fe
; 	return need_sched;
 8015c80: f897 309f    	ldrb.w	r3, [r7, #0x9f]
; }
 8015c84: 4618         	mov	r0, r3
 8015c86: 37a0         	adds	r7, #0xa0
 8015c88: 46bd         	mov	sp, r7
 8015c8a: bd80         	pop	{r7, pc}

08015c8c <$d>:
 8015c8c: ec 32 00 20  	.word	0x200032ec
 8015c90: cc 25 00 20  	.word	0x200025cc
 8015c94: a8 25 00 20  	.word	0x200025a8

08015c98 <need_swap>:
; {
 8015c98: b480         	push	{r7}
 8015c9a: b083         	sub	sp, #0xc
 8015c9c: af00         	add	r7, sp, #0x0
; 	new_thread = _kernel.ready_q.cache;
 8015c9e: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8015cc4 <need_swap+0x2c>
 8015ca0: 6a1b         	ldr	r3, [r3, #0x20]
 8015ca2: 607b         	str	r3, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015ca4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8015cc4 <need_swap+0x2c>
 8015ca6: 689b         	ldr	r3, [r3, #0x8]
 8015ca8: 603b         	str	r3, [r7]
; 	return ret;
 8015caa: 683b         	ldr	r3, [r7]
; 	return new_thread != arch_current_thread();
 8015cac: 687a         	ldr	r2, [r7, #0x4]
 8015cae: 429a         	cmp	r2, r3
 8015cb0: bf14         	ite	ne
 8015cb2: 2301         	movne	r3, #0x1
 8015cb4: 2300         	moveq	r3, #0x0
 8015cb6: b2db         	uxtb	r3, r3
; }
 8015cb8: 4618         	mov	r0, r3
 8015cba: 370c         	adds	r7, #0xc
 8015cbc: 46bd         	mov	sp, r7
 8015cbe: f85d 7b04    	ldr	r7, [sp], #4
 8015cc2: 4770         	bx	lr

08015cc4 <$d>:
 8015cc4: a8 25 00 20  	.word	0x200025a8

08015cc8 <k_sched_lock>:
; {
 8015cc8: b580         	push	{r7, lr}
 8015cca: b08e         	sub	sp, #0x38
 8015ccc: af00         	add	r7, sp, #0x0
; 	K_SPINLOCK(&_sched_spinlock) {
 8015cce: 2300         	movs	r3, #0x0
 8015cd0: 613b         	str	r3, [r7, #0x10]
 8015cd2: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8015d44 <k_sched_lock+0x7c>
 8015cd4: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015cd6: f3ef 8311    	mrs	r3, basepri
 8015cda: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8015cdc: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 8015cde: 62fb         	str	r3, [r7, #0x2c]
 8015ce0: 2310         	movs	r3, #0x10
 8015ce2: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015ce4: 6abb         	ldr	r3, [r7, #0x28]
 8015ce6: f383 8812    	msr	basepri_max, r3
; }
 8015cea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015cec: f3bf 8f6f    	isb	sy
; }
 8015cf0: bf00         	nop
; 	return key;
 8015cf2: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 8015cf4: 607b         	str	r3, [r7, #0x4]
 8015cf6: 6b7b         	ldr	r3, [r7, #0x34]
 8015cf8: 627b         	str	r3, [r7, #0x24]
; }
 8015cfa: bf00         	nop
 8015cfc: 6b7b         	ldr	r3, [r7, #0x34]
 8015cfe: 623b         	str	r3, [r7, #0x20]
; }
 8015d00: bf00         	nop
; 	return k;
 8015d02: 687b         	ldr	r3, [r7, #0x4]
 8015d04: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&_sched_spinlock) {
 8015d06: e014         	b	0x8015d32 <k_sched_lock+0x6a> @ imm = #0x28
; 		z_sched_lock();
 8015d08: f7fe ffee    	bl	0x8014ce8 <z_sched_lock> @ imm = #-0x1024
 8015d0c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8015d44 <k_sched_lock+0x7c>
 8015d0e: 61fb         	str	r3, [r7, #0x1c]
 8015d10: 68fb         	ldr	r3, [r7, #0xc]
 8015d12: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8015d14: 68bb         	ldr	r3, [r7, #0x8]
 8015d16: 61bb         	str	r3, [r7, #0x18]
 8015d18: 69bb         	ldr	r3, [r7, #0x18]
 8015d1a: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015d1c: 697b         	ldr	r3, [r7, #0x14]
 8015d1e: f383 8811    	msr	basepri, r3
; }
 8015d22: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015d24: f3bf 8f6f    	isb	sy
; }
 8015d28: bf00         	nop
; }
 8015d2a: bf00         	nop
; }
 8015d2c: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8015d2e: 2301         	movs	r3, #0x1
 8015d30: 613b         	str	r3, [r7, #0x10]
 8015d32: 693b         	ldr	r3, [r7, #0x10]
 8015d34: 2b00         	cmp	r3, #0x0
 8015d36: d0e7         	beq	0x8015d08 <k_sched_lock+0x40> @ imm = #-0x32
; }
 8015d38: bf00         	nop
 8015d3a: bf00         	nop
 8015d3c: 3738         	adds	r7, #0x38
 8015d3e: 46bd         	mov	sp, r7
 8015d40: bd80         	pop	{r7, pc}
 8015d42: bf00         	nop

08015d44 <$d>:
 8015d44: ec 32 00 20  	.word	0x200032ec

08015d48 <k_sched_unlock>:
; {
 8015d48: b580         	push	{r7, lr}
 8015d4a: b0a4         	sub	sp, #0x90
 8015d4c: af06         	add	r7, sp, #0x18
; 	K_SPINLOCK(&_sched_spinlock) {
 8015d4e: 2300         	movs	r3, #0x0
 8015d50: 60fb         	str	r3, [r7, #0xc]
 8015d52: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8015eec <k_sched_unlock+0x1a4>
 8015d54: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015d56: f3ef 8311    	mrs	r3, basepri
 8015d5a: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 8015d5c: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 8015d5e: 667b         	str	r3, [r7, #0x64]
 8015d60: 2310         	movs	r3, #0x10
 8015d62: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015d64: 6e3b         	ldr	r3, [r7, #0x60]
 8015d66: f383 8812    	msr	basepri_max, r3
; }
 8015d6a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015d6c: f3bf 8f6f    	isb	sy
; }
 8015d70: bf00         	nop
; 	return key;
 8015d72: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 8015d74: 603b         	str	r3, [r7]
 8015d76: 6efb         	ldr	r3, [r7, #0x6c]
 8015d78: 65fb         	str	r3, [r7, #0x5c]
; }
 8015d7a: bf00         	nop
 8015d7c: 6efb         	ldr	r3, [r7, #0x6c]
 8015d7e: 65bb         	str	r3, [r7, #0x58]
; }
 8015d80: bf00         	nop
; 	return k;
 8015d82: 683b         	ldr	r3, [r7]
 8015d84: 60bb         	str	r3, [r7, #0x8]
; 	K_SPINLOCK(&_sched_spinlock) {
 8015d86: e07e         	b	0x8015e86 <k_sched_unlock+0x13e> @ imm = #0xfc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015d88: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8015ef0 <k_sched_unlock+0x1a8>
 8015d8a: 689b         	ldr	r3, [r3, #0x8]
 8015d8c: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 8015d8e: 69bb         	ldr	r3, [r7, #0x18]
; 		++arch_current_thread()->base.sched_locked;
 8015d90: 7bda         	ldrb	r2, [r3, #0xf]
 8015d92: 3201         	adds	r2, #0x1
 8015d94: b2d2         	uxtb	r2, r2
 8015d96: 73da         	strb	r2, [r3, #0xf]
 8015d98: 2300         	movs	r3, #0x0
 8015d9a: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 8015d9c: 4b55         	ldr	r3, [pc, #0x154]        @ 0x8015ef4 <k_sched_unlock+0x1ac>
 8015d9e: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 8015da0: 2300         	movs	r3, #0x0
 8015da2: 643b         	str	r3, [r7, #0x40]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8015da4: 6c78         	ldr	r0, [r7, #0x44]
 8015da6: f010 fb87    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x1070e
 8015daa: 63f8         	str	r0, [r7, #0x3c]
; 	if (n != NULL) {
 8015dac: 6bfb         	ldr	r3, [r7, #0x3c]
 8015dae: 2b00         	cmp	r3, #0x0
 8015db0: d001         	beq	0x8015db6 <k_sched_unlock+0x6e> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8015db2: 6bfb         	ldr	r3, [r7, #0x3c]
 8015db4: 643b         	str	r3, [r7, #0x40]
; 	return thread;
 8015db6: 6c3b         	ldr	r3, [r7, #0x40]
; 	return _priq_run_best(curr_cpu_runq());
 8015db8: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8015dba: 63bb         	str	r3, [r7, #0x38]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8015dbc: 6bbb         	ldr	r3, [r7, #0x38]
 8015dbe: 2b00         	cmp	r3, #0x0
 8015dc0: d102         	bne	0x8015dc8 <k_sched_unlock+0x80> @ imm = #0x4
 8015dc2: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8015ef0 <k_sched_unlock+0x1a8>
 8015dc4: 68db         	ldr	r3, [r3, #0xc]
 8015dc6: e000         	b	0x8015dca <k_sched_unlock+0x82> @ imm = #0x0
 8015dc8: 6bbb         	ldr	r3, [r7, #0x38]
; 	struct k_thread *thread = next_up();
 8015dca: 637b         	str	r3, [r7, #0x34]
 8015dcc: 6b7b         	ldr	r3, [r7, #0x34]
 8015dce: 633b         	str	r3, [r7, #0x30]
 8015dd0: 6cbb         	ldr	r3, [r7, #0x48]
 8015dd2: 62fb         	str	r3, [r7, #0x2c]
; 	if (preempt_ok != 0) {
 8015dd4: 6afb         	ldr	r3, [r7, #0x2c]
 8015dd6: 2b00         	cmp	r3, #0x0
 8015dd8: d001         	beq	0x8015dde <k_sched_unlock+0x96> @ imm = #0x2
; 		return true;
 8015dda: 2301         	movs	r3, #0x1
 8015ddc: e026         	b	0x8015e2c <k_sched_unlock+0xe4> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015dde: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8015ef0 <k_sched_unlock+0x1a8>
 8015de0: 689b         	ldr	r3, [r3, #0x8]
 8015de2: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8015de4: 6abb         	ldr	r3, [r7, #0x28]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8015de6: 4618         	mov	r0, r3
 8015de8: f010 fc50    	bl	0x802668c <z_is_thread_prevented_from_running> @ imm = #0x108a0
 8015dec: 4603         	mov	r3, r0
 8015dee: 2b00         	cmp	r3, #0x0
 8015df0: d001         	beq	0x8015df6 <k_sched_unlock+0xae> @ imm = #0x2
; 		return true;
 8015df2: 2301         	movs	r3, #0x1
 8015df4: e01a         	b	0x8015e2c <k_sched_unlock+0xe4> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015df6: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8015ef0 <k_sched_unlock+0x1a8>
 8015df8: 689b         	ldr	r3, [r3, #0x8]
 8015dfa: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8015dfc: 6a7b         	ldr	r3, [r7, #0x24]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8015dfe: 4618         	mov	r0, r3
 8015e00: f010 fc15    	bl	0x802662e <thread_is_preemptible> @ imm = #0x1082a
 8015e04: 4603         	mov	r3, r0
 8015e06: 2b00         	cmp	r3, #0x0
 8015e08: d105         	bne	0x8015e16 <k_sched_unlock+0xce> @ imm = #0xa
 8015e0a: 6b38         	ldr	r0, [r7, #0x30]
 8015e0c: f010 fc20    	bl	0x8026650 <thread_is_metairq> @ imm = #0x10840
 8015e10: 4603         	mov	r3, r0
 8015e12: 2b00         	cmp	r3, #0x0
 8015e14: d001         	beq	0x8015e1a <k_sched_unlock+0xd2> @ imm = #0x2
; 		return true;
 8015e16: 2301         	movs	r3, #0x1
 8015e18: e008         	b	0x8015e2c <k_sched_unlock+0xe4> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8015e1a: 6b38         	ldr	r0, [r7, #0x30]
 8015e1c: f010 fc4b    	bl	0x80266b6 <z_is_thread_timeout_active> @ imm = #0x10896
 8015e20: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8015e22: 2b00         	cmp	r3, #0x0
 8015e24: d001         	beq	0x8015e2a <k_sched_unlock+0xe2> @ imm = #0x2
; 		return true;
 8015e26: 2301         	movs	r3, #0x1
 8015e28: e000         	b	0x8015e2c <k_sched_unlock+0xe4> @ imm = #0x0
; 	return false;
 8015e2a: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8015e2c: 2b00         	cmp	r3, #0x0
 8015e2e: d010         	beq	0x8015e52 <k_sched_unlock+0x10a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015e30: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8015ef0 <k_sched_unlock+0x1a8>
 8015e32: 689b         	ldr	r3, [r3, #0x8]
 8015e34: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 8015e36: 6a3b         	ldr	r3, [r7, #0x20]
; 		if (thread != arch_current_thread()) {
 8015e38: 6b7a         	ldr	r2, [r7, #0x34]
 8015e3a: 429a         	cmp	r2, r3
 8015e3c: d002         	beq	0x8015e44 <k_sched_unlock+0xfc> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8015e3e: 6b78         	ldr	r0, [r7, #0x34]
 8015e40: f000 fd14    	bl	0x801686c <z_reset_time_slice> @ imm = #0xa28
; 		update_metairq_preempt(thread);
 8015e44: 6b78         	ldr	r0, [r7, #0x34]
 8015e46: f010 fdb6    	bl	0x80269b6 <update_metairq_preempt> @ imm = #0x10b6c
; 		_kernel.ready_q.cache = thread;
 8015e4a: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x8015ef0 <k_sched_unlock+0x1a8>
 8015e4c: 6b7b         	ldr	r3, [r7, #0x34]
 8015e4e: 6213         	str	r3, [r2, #0x20]
; }
 8015e50: e005         	b	0x8015e5e <k_sched_unlock+0x116> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015e52: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8015ef0 <k_sched_unlock+0x1a8>
 8015e54: 689b         	ldr	r3, [r3, #0x8]
 8015e56: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 8015e58: 69fb         	ldr	r3, [r7, #0x1c]
; 		_kernel.ready_q.cache = arch_current_thread();
 8015e5a: 4a25         	ldr	r2, [pc, #0x94]         @ 0x8015ef0 <k_sched_unlock+0x1a8>
 8015e5c: 6213         	str	r3, [r2, #0x20]
; }
 8015e5e: bf00         	nop
 8015e60: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8015eec <k_sched_unlock+0x1a4>
 8015e62: 657b         	str	r3, [r7, #0x54]
 8015e64: 68bb         	ldr	r3, [r7, #0x8]
 8015e66: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 8015e68: 687b         	ldr	r3, [r7, #0x4]
 8015e6a: 653b         	str	r3, [r7, #0x50]
 8015e6c: 6d3b         	ldr	r3, [r7, #0x50]
 8015e6e: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8015e70: 6cfb         	ldr	r3, [r7, #0x4c]
 8015e72: f383 8811    	msr	basepri, r3
; }
 8015e76: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015e78: f3bf 8f6f    	isb	sy
; }
 8015e7c: bf00         	nop
; }
 8015e7e: bf00         	nop
; }
 8015e80: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8015e82: 2301         	movs	r3, #0x1
 8015e84: 60fb         	str	r3, [r7, #0xc]
 8015e86: 68fb         	ldr	r3, [r7, #0xc]
 8015e88: 2b00         	cmp	r3, #0x0
 8015e8a: f43f af7d    	beq.w	0x8015d88 <k_sched_unlock+0x40> @ imm = #-0x106
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 8015e8e: 2303         	movs	r3, #0x3
 8015e90: 2b03         	cmp	r3, #0x3
 8015e92: d925         	bls	0x8015ee0 <k_sched_unlock+0x198> @ imm = #0x4a
 8015e94: 2301         	movs	r3, #0x1
 8015e96: f887 3077    	strb.w	r3, [r7, #0x77]
 8015e9a: f897 3077    	ldrb.w	r3, [r7, #0x77]
 8015e9e: f083 0301    	eor	r3, r3, #0x1
 8015ea2: b2db         	uxtb	r3, r3
 8015ea4: 2b00         	cmp	r3, #0x0
 8015ea6: d11b         	bne	0x8015ee0 <k_sched_unlock+0x198> @ imm = #0x36
 8015ea8: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8015ef8 <k_sched_unlock+0x1b0>
 8015eaa: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015eac: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8015ef0 <k_sched_unlock+0x1a8>
 8015eae: 689b         	ldr	r3, [r3, #0x8]
 8015eb0: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8015eb2: 693b         	ldr	r3, [r7, #0x10]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015eb4: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8015ef0 <k_sched_unlock+0x1a8>
 8015eb6: 6892         	ldr	r2, [r2, #0x8]
 8015eb8: 617a         	str	r2, [r7, #0x14]
; 	return ret;
 8015eba: 697a         	ldr	r2, [r7, #0x14]
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 8015ebc: 7bd2         	ldrb	r2, [r2, #0xf]
 8015ebe: 9205         	str	r2, [sp, #0x14]
 8015ec0: 9304         	str	r3, [sp, #0x10]
 8015ec2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8015efc <k_sched_unlock+0x1b4>
 8015ec4: 9303         	str	r3, [sp, #0xc]
 8015ec6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8015f00 <k_sched_unlock+0x1b8>
 8015ec8: 9302         	str	r3, [sp, #0x8]
 8015eca: 2308         	movs	r3, #0x8
 8015ecc: 9301         	str	r3, [sp, #0x4]
 8015ece: 2300         	movs	r3, #0x0
 8015ed0: 9300         	str	r3, [sp]
 8015ed2: 2300         	movs	r3, #0x0
 8015ed4: 2204         	movs	r2, #0x4
 8015ed6: 2000         	movs	r0, #0x0
 8015ed8: f010 fcec    	bl	0x80268b4 <z_log_msg_runtime_create> @ imm = #0x109d8
 8015edc: 2300         	movs	r3, #0x0
 8015ede: 673b         	str	r3, [r7, #0x70]
; 	z_reschedule_unlocked();
 8015ee0: f010 fc9b    	bl	0x802681a <z_reschedule_unlocked> @ imm = #0x10936
; }
 8015ee4: bf00         	nop
 8015ee6: 3778         	adds	r7, #0x78
 8015ee8: 46bd         	mov	sp, r7
 8015eea: bd80         	pop	{r7, pc}

08015eec <$d>:
 8015eec: ec 32 00 20  	.word	0x200032ec
 8015ef0: a8 25 00 20  	.word	0x200025a8
 8015ef4: cc 25 00 20  	.word	0x200025cc
 8015ef8: 68 0b 00 20  	.word	0x20000b68
 8015efc: 8c bc 02 08  	.word	0x0802bc8c
 8015f00: dc a3 02 08  	.word	0x0802a3dc

08015f04 <z_sched_init>:
; {
 8015f04: b580         	push	{r7, lr}
 8015f06: af00         	add	r7, sp, #0x0
; 	init_ready_q(&_kernel.ready_q);
 8015f08: 4802         	ldr	r0, [pc, #0x8]          @ 0x8015f14 <z_sched_init+0x10>
 8015f0a: f010 fea3    	bl	0x8026c54 <init_ready_q> @ imm = #0x10d46
; }
 8015f0e: bf00         	nop
 8015f10: bd80         	pop	{r7, pc}
 8015f12: bf00         	nop

08015f14 <$d>:
 8015f14: c8 25 00 20  	.word	0x200025c8

08015f18 <z_impl_k_thread_priority_set>:
; {
 8015f18: b580         	push	{r7, lr}
 8015f1a: b084         	sub	sp, #0x10
 8015f1c: af00         	add	r7, sp, #0x0
 8015f1e: 6078         	str	r0, [r7, #0x4]
 8015f20: 6039         	str	r1, [r7]
; 	bool need_sched = z_thread_prio_set((struct k_thread *)thread, prio);
 8015f22: 6839         	ldr	r1, [r7]
 8015f24: 6878         	ldr	r0, [r7, #0x4]
 8015f26: f7ff fd77    	bl	0x8015a18 <z_thread_prio_set> @ imm = #-0x512
 8015f2a: 4603         	mov	r3, r0
 8015f2c: 73fb         	strb	r3, [r7, #0xf]
; 	if ((need_sched) && (IS_ENABLED(CONFIG_SMP) ||
 8015f2e: 7bfb         	ldrb	r3, [r7, #0xf]
 8015f30: 2b00         	cmp	r3, #0x0
 8015f32: d008         	beq	0x8015f46 <z_impl_k_thread_priority_set+0x2e> @ imm = #0x10
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015f34: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8015f50 <z_impl_k_thread_priority_set+0x38>
 8015f36: 689b         	ldr	r3, [r3, #0x8]
 8015f38: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8015f3a: 68bb         	ldr	r3, [r7, #0x8]
; 			     (arch_current_thread()->base.sched_locked == 0U))) {
 8015f3c: 7bdb         	ldrb	r3, [r3, #0xf]
; 	if ((need_sched) && (IS_ENABLED(CONFIG_SMP) ||
 8015f3e: 2b00         	cmp	r3, #0x0
 8015f40: d101         	bne	0x8015f46 <z_impl_k_thread_priority_set+0x2e> @ imm = #0x2
; 		z_reschedule_unlocked();
 8015f42: f010 fc6a    	bl	0x802681a <z_reschedule_unlocked> @ imm = #0x108d4
; }
 8015f46: bf00         	nop
 8015f48: 3710         	adds	r7, #0x10
 8015f4a: 46bd         	mov	sp, r7
 8015f4c: bd80         	pop	{r7, pc}
 8015f4e: bf00         	nop

08015f50 <$d>:
 8015f50: a8 25 00 20  	.word	0x200025a8

08015f54 <z_impl_k_yield>:
; {
 8015f54: b580         	push	{r7, lr}
 8015f56: b0a4         	sub	sp, #0x90
 8015f58: af00         	add	r7, sp, #0x0
 8015f5a: 4b86         	ldr	r3, [pc, #0x218]        @ 0x8016174 <z_impl_k_yield+0x220>
 8015f5c: f8c7 308c    	str.w	r3, [r7, #0x8c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8015f60: f3ef 8311    	mrs	r3, basepri
 8015f64: f8c7 3088    	str.w	r3, [r7, #0x88]
;   return(result);
 8015f68: f8d7 3088    	ldr.w	r3, [r7, #0x88]
; 	key = __get_BASEPRI();
 8015f6c: f8c7 3084    	str.w	r3, [r7, #0x84]
 8015f70: 2310         	movs	r3, #0x10
 8015f72: f8c7 3080    	str.w	r3, [r7, #0x80]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8015f76: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8015f7a: f383 8812    	msr	basepri_max, r3
; }
 8015f7e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8015f80: f3bf 8f6f    	isb	sy
; }
 8015f84: bf00         	nop
; 	return key;
 8015f86: f8d7 3084    	ldr.w	r3, [r7, #0x84]
; 	k.key = arch_irq_lock();
 8015f8a: 603b         	str	r3, [r7]
 8015f8c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8015f90: 67fb         	str	r3, [r7, #0x7c]
; }
 8015f92: bf00         	nop
 8015f94: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8015f98: 67bb         	str	r3, [r7, #0x78]
; }
 8015f9a: bf00         	nop
; 	return k;
 8015f9c: 683b         	ldr	r3, [r7]
 8015f9e: 60bb         	str	r3, [r7, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015fa0: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8016178 <z_impl_k_yield+0x224>
 8015fa2: 689b         	ldr	r3, [r3, #0x8]
 8015fa4: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8015fa6: 68fb         	ldr	r3, [r7, #0xc]
 8015fa8: 623b         	str	r3, [r7, #0x20]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8015faa: 6a3b         	ldr	r3, [r7, #0x20]
 8015fac: 7b5b         	ldrb	r3, [r3, #0xd]
 8015fae: f003 037f    	and	r3, r3, #0x7f
 8015fb2: b2da         	uxtb	r2, r3
 8015fb4: 6a3b         	ldr	r3, [r7, #0x20]
 8015fb6: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8015fb8: 6a38         	ldr	r0, [r7, #0x20]
 8015fba: f010 fcb5    	bl	0x8026928 <should_queue_thread> @ imm = #0x1096a
 8015fbe: 4603         	mov	r3, r0
 8015fc0: 2b00         	cmp	r3, #0x0
 8015fc2: d00d         	beq	0x8015fe0 <z_impl_k_yield+0x8c> @ imm = #0x1a
 8015fc4: 6a3b         	ldr	r3, [r7, #0x20]
 8015fc6: 61fb         	str	r3, [r7, #0x1c]
 8015fc8: 69fb         	ldr	r3, [r7, #0x1c]
 8015fca: 61bb         	str	r3, [r7, #0x18]
; 	return &_kernel.ready_q.runq;
 8015fcc: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x801617c <z_impl_k_yield+0x228>
 8015fce: 617b         	str	r3, [r7, #0x14]
 8015fd0: 69fb         	ldr	r3, [r7, #0x1c]
 8015fd2: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8015fd4: 693b         	ldr	r3, [r7, #0x10]
 8015fd6: 4618         	mov	r0, r3
 8015fd8: f010 fadb    	bl	0x8026592 <sys_dlist_remove> @ imm = #0x105b6
; }
 8015fdc: bf00         	nop
; }
 8015fde: bf00         	nop
; }
 8015fe0: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8015fe2: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8016178 <z_impl_k_yield+0x224>
 8015fe4: 689b         	ldr	r3, [r3, #0x8]
 8015fe6: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8015fe8: 6a7b         	ldr	r3, [r7, #0x24]
 8015fea: 63fb         	str	r3, [r7, #0x3c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 8015fec: 6bfb         	ldr	r3, [r7, #0x3c]
 8015fee: 7b5b         	ldrb	r3, [r3, #0xd]
 8015ff0: f063 037f    	orn	r3, r3, #0x7f
 8015ff4: b2da         	uxtb	r2, r3
 8015ff6: 6bfb         	ldr	r3, [r7, #0x3c]
 8015ff8: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8015ffa: 6bf8         	ldr	r0, [r7, #0x3c]
 8015ffc: f010 fc94    	bl	0x8026928 <should_queue_thread> @ imm = #0x10928
 8016000: 4603         	mov	r3, r0
 8016002: 2b00         	cmp	r3, #0x0
 8016004: d042         	beq	0x801608c <z_impl_k_yield+0x138> @ imm = #0x84
 8016006: 6bfb         	ldr	r3, [r7, #0x3c]
 8016008: 63bb         	str	r3, [r7, #0x38]
 801600a: 6bbb         	ldr	r3, [r7, #0x38]
 801600c: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 801600e: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x801617c <z_impl_k_yield+0x228>
 8016010: 633b         	str	r3, [r7, #0x30]
 8016012: 6bbb         	ldr	r3, [r7, #0x38]
 8016014: 62fb         	str	r3, [r7, #0x2c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8016016: 6b38         	ldr	r0, [r7, #0x30]
 8016018: f010 fa4e    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x1049c
 801601c: 4603         	mov	r3, r0
 801601e: 2b00         	cmp	r3, #0x0
 8016020: d004         	beq	0x801602c <z_impl_k_yield+0xd8> @ imm = #0x8
 8016022: 6b38         	ldr	r0, [r7, #0x30]
 8016024: f010 fa48    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x10490
 8016028: 4603         	mov	r3, r0
 801602a: e000         	b	0x801602e <z_impl_k_yield+0xda> @ imm = #0x0
 801602c: 2300         	movs	r3, #0x0
 801602e: 62bb         	str	r3, [r7, #0x28]
 8016030: e023         	b	0x801607a <z_impl_k_yield+0x126> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8016032: 6ab9         	ldr	r1, [r7, #0x28]
 8016034: 6af8         	ldr	r0, [r7, #0x2c]
 8016036: f010 fc5b    	bl	0x80268f0 <z_sched_prio_cmp> @ imm = #0x108b6
 801603a: 4603         	mov	r3, r0
 801603c: 2b00         	cmp	r3, #0x0
 801603e: dd06         	ble	0x801604e <z_impl_k_yield+0xfa> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8016040: 6abb         	ldr	r3, [r7, #0x28]
 8016042: 6afa         	ldr	r2, [r7, #0x2c]
 8016044: 4611         	mov	r1, r2
 8016046: 4618         	mov	r0, r3
 8016048: f010 fa89    	bl	0x802655e <sys_dlist_insert> @ imm = #0x10512
; 			return;
 801604c: e01d         	b	0x801608a <z_impl_k_yield+0x136> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 801604e: 6abb         	ldr	r3, [r7, #0x28]
 8016050: 2b00         	cmp	r3, #0x0
 8016052: d010         	beq	0x8016076 <z_impl_k_yield+0x122> @ imm = #0x20
 8016054: 6abb         	ldr	r3, [r7, #0x28]
 8016056: 4619         	mov	r1, r3
 8016058: 6b38         	ldr	r0, [r7, #0x30]
 801605a: f010 fa53    	bl	0x8026504 <sys_dlist_peek_next> @ imm = #0x104a6
 801605e: 4603         	mov	r3, r0
 8016060: 2b00         	cmp	r3, #0x0
 8016062: d006         	beq	0x8016072 <z_impl_k_yield+0x11e> @ imm = #0xc
 8016064: 6abb         	ldr	r3, [r7, #0x28]
 8016066: 4619         	mov	r1, r3
 8016068: 6b38         	ldr	r0, [r7, #0x30]
 801606a: f010 fa4b    	bl	0x8026504 <sys_dlist_peek_next> @ imm = #0x10496
 801606e: 4603         	mov	r3, r0
 8016070: e002         	b	0x8016078 <z_impl_k_yield+0x124> @ imm = #0x4
 8016072: 2300         	movs	r3, #0x0
 8016074: e000         	b	0x8016078 <z_impl_k_yield+0x124> @ imm = #0x0
 8016076: 2300         	movs	r3, #0x0
 8016078: 62bb         	str	r3, [r7, #0x28]
 801607a: 6abb         	ldr	r3, [r7, #0x28]
 801607c: 2b00         	cmp	r3, #0x0
 801607e: d1d8         	bne	0x8016032 <z_impl_k_yield+0xde> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8016080: 6afb         	ldr	r3, [r7, #0x2c]
 8016082: 4619         	mov	r1, r3
 8016084: 6b38         	ldr	r0, [r7, #0x30]
 8016086: f010 fa50    	bl	0x802652a <sys_dlist_append> @ imm = #0x104a0
; }
 801608a: bf00         	nop
; }
 801608c: bf00         	nop
 801608e: 2301         	movs	r3, #0x1
 8016090: 66fb         	str	r3, [r7, #0x6c]
; 	return &_kernel.ready_q.runq;
 8016092: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x801617c <z_impl_k_yield+0x228>
 8016094: 66bb         	str	r3, [r7, #0x68]
; 	struct k_thread *thread = NULL;
 8016096: 2300         	movs	r3, #0x0
 8016098: 667b         	str	r3, [r7, #0x64]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 801609a: 6eb8         	ldr	r0, [r7, #0x68]
 801609c: f010 fa0c    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x10418
 80160a0: 6638         	str	r0, [r7, #0x60]
; 	if (n != NULL) {
 80160a2: 6e3b         	ldr	r3, [r7, #0x60]
 80160a4: 2b00         	cmp	r3, #0x0
 80160a6: d001         	beq	0x80160ac <z_impl_k_yield+0x158> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80160a8: 6e3b         	ldr	r3, [r7, #0x60]
 80160aa: 667b         	str	r3, [r7, #0x64]
; 	return thread;
 80160ac: 6e7b         	ldr	r3, [r7, #0x64]
; 	return _priq_run_best(curr_cpu_runq());
 80160ae: bf00         	nop
; 	struct k_thread *thread = runq_best();
 80160b0: 65fb         	str	r3, [r7, #0x5c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 80160b2: 6dfb         	ldr	r3, [r7, #0x5c]
 80160b4: 2b00         	cmp	r3, #0x0
 80160b6: d102         	bne	0x80160be <z_impl_k_yield+0x16a> @ imm = #0x4
 80160b8: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8016178 <z_impl_k_yield+0x224>
 80160ba: 68db         	ldr	r3, [r3, #0xc]
 80160bc: e000         	b	0x80160c0 <z_impl_k_yield+0x16c> @ imm = #0x0
 80160be: 6dfb         	ldr	r3, [r7, #0x5c]
; 	struct k_thread *thread = next_up();
 80160c0: 65bb         	str	r3, [r7, #0x58]
 80160c2: 6dbb         	ldr	r3, [r7, #0x58]
 80160c4: 657b         	str	r3, [r7, #0x54]
 80160c6: 6efb         	ldr	r3, [r7, #0x6c]
 80160c8: 653b         	str	r3, [r7, #0x50]
; 	if (preempt_ok != 0) {
 80160ca: 6d3b         	ldr	r3, [r7, #0x50]
 80160cc: 2b00         	cmp	r3, #0x0
 80160ce: d001         	beq	0x80160d4 <z_impl_k_yield+0x180> @ imm = #0x2
; 		return true;
 80160d0: 2301         	movs	r3, #0x1
 80160d2: e026         	b	0x8016122 <z_impl_k_yield+0x1ce> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80160d4: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8016178 <z_impl_k_yield+0x224>
 80160d6: 689b         	ldr	r3, [r3, #0x8]
 80160d8: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 80160da: 6cfb         	ldr	r3, [r7, #0x4c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 80160dc: 4618         	mov	r0, r3
 80160de: f010 fad5    	bl	0x802668c <z_is_thread_prevented_from_running> @ imm = #0x105aa
 80160e2: 4603         	mov	r3, r0
 80160e4: 2b00         	cmp	r3, #0x0
 80160e6: d001         	beq	0x80160ec <z_impl_k_yield+0x198> @ imm = #0x2
; 		return true;
 80160e8: 2301         	movs	r3, #0x1
 80160ea: e01a         	b	0x8016122 <z_impl_k_yield+0x1ce> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80160ec: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8016178 <z_impl_k_yield+0x224>
 80160ee: 689b         	ldr	r3, [r3, #0x8]
 80160f0: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 80160f2: 6cbb         	ldr	r3, [r7, #0x48]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 80160f4: 4618         	mov	r0, r3
 80160f6: f010 fa9a    	bl	0x802662e <thread_is_preemptible> @ imm = #0x10534
 80160fa: 4603         	mov	r3, r0
 80160fc: 2b00         	cmp	r3, #0x0
 80160fe: d105         	bne	0x801610c <z_impl_k_yield+0x1b8> @ imm = #0xa
 8016100: 6d78         	ldr	r0, [r7, #0x54]
 8016102: f010 faa5    	bl	0x8026650 <thread_is_metairq> @ imm = #0x1054a
 8016106: 4603         	mov	r3, r0
 8016108: 2b00         	cmp	r3, #0x0
 801610a: d001         	beq	0x8016110 <z_impl_k_yield+0x1bc> @ imm = #0x2
; 		return true;
 801610c: 2301         	movs	r3, #0x1
 801610e: e008         	b	0x8016122 <z_impl_k_yield+0x1ce> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8016110: 6d78         	ldr	r0, [r7, #0x54]
 8016112: f010 fad0    	bl	0x80266b6 <z_is_thread_timeout_active> @ imm = #0x105a0
 8016116: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8016118: 2b00         	cmp	r3, #0x0
 801611a: d001         	beq	0x8016120 <z_impl_k_yield+0x1cc> @ imm = #0x2
; 		return true;
 801611c: 2301         	movs	r3, #0x1
 801611e: e000         	b	0x8016122 <z_impl_k_yield+0x1ce> @ imm = #0x0
; 	return false;
 8016120: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8016122: 2b00         	cmp	r3, #0x0
 8016124: d010         	beq	0x8016148 <z_impl_k_yield+0x1f4> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016126: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8016178 <z_impl_k_yield+0x224>
 8016128: 689b         	ldr	r3, [r3, #0x8]
 801612a: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 801612c: 6c7b         	ldr	r3, [r7, #0x44]
; 		if (thread != arch_current_thread()) {
 801612e: 6dba         	ldr	r2, [r7, #0x58]
 8016130: 429a         	cmp	r2, r3
 8016132: d002         	beq	0x801613a <z_impl_k_yield+0x1e6> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8016134: 6db8         	ldr	r0, [r7, #0x58]
 8016136: f000 fb99    	bl	0x801686c <z_reset_time_slice> @ imm = #0x732
; 		update_metairq_preempt(thread);
 801613a: 6db8         	ldr	r0, [r7, #0x58]
 801613c: f010 fc3b    	bl	0x80269b6 <update_metairq_preempt> @ imm = #0x10876
; 		_kernel.ready_q.cache = thread;
 8016140: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8016178 <z_impl_k_yield+0x224>
 8016142: 6dbb         	ldr	r3, [r7, #0x58]
 8016144: 6213         	str	r3, [r2, #0x20]
; }
 8016146: e005         	b	0x8016154 <z_impl_k_yield+0x200> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016148: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8016178 <z_impl_k_yield+0x224>
 801614a: 689b         	ldr	r3, [r3, #0x8]
 801614c: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 801614e: 6c3b         	ldr	r3, [r7, #0x40]
; 		_kernel.ready_q.cache = arch_current_thread();
 8016150: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8016178 <z_impl_k_yield+0x224>
 8016152: 6213         	str	r3, [r2, #0x20]
; }
 8016154: bf00         	nop
 8016156: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8016174 <z_impl_k_yield+0x220>
 8016158: 677b         	str	r3, [r7, #0x74]
 801615a: 68bb         	ldr	r3, [r7, #0x8]
 801615c: 607b         	str	r3, [r7, #0x4]
 801615e: 6f7b         	ldr	r3, [r7, #0x74]
 8016160: 673b         	str	r3, [r7, #0x70]
; }
 8016162: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8016164: 687b         	ldr	r3, [r7, #0x4]
 8016166: 4618         	mov	r0, r3
 8016168: f010 fb97    	bl	0x802689a <z_swap_irqlock> @ imm = #0x1072e
; }
 801616c: bf00         	nop
 801616e: 3790         	adds	r7, #0x90
 8016170: 46bd         	mov	sp, r7
 8016172: bd80         	pop	{r7, pc}

08016174 <$d>:
 8016174: ec 32 00 20  	.word	0x200032ec
 8016178: a8 25 00 20  	.word	0x200025a8
 801617c: cc 25 00 20  	.word	0x200025cc

08016180 <z_tick_sleep>:
; {
 8016180: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8016184: b0a0         	sub	sp, #0x80
 8016186: af06         	add	r7, sp, #0x18
 8016188: e9c7 0100    	strd	r0, r1, [r7]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 801618c: 2303         	movs	r3, #0x3
 801618e: 2b03         	cmp	r3, #0x3
 8016190: d921         	bls	0x80161d6 <z_tick_sleep+0x56> @ imm = #0x42
 8016192: 2301         	movs	r3, #0x1
 8016194: f887 3067    	strb.w	r3, [r7, #0x67]
 8016198: f897 3067    	ldrb.w	r3, [r7, #0x67]
 801619c: f083 0301    	eor	r3, r3, #0x1
 80161a0: b2db         	uxtb	r3, r3
 80161a2: 2b00         	cmp	r3, #0x0
 80161a4: d117         	bne	0x80161d6 <z_tick_sleep+0x56> @ imm = #0x2e
 80161a6: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x80162d8 <z_tick_sleep+0x158>
 80161a8: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80161aa: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x80162dc <z_tick_sleep+0x15c>
 80161ac: 689b         	ldr	r3, [r3, #0x8]
 80161ae: 657b         	str	r3, [r7, #0x54]
; 	return ret;
 80161b0: 6d7b         	ldr	r3, [r7, #0x54]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 80161b2: 683a         	ldr	r2, [r7]
 80161b4: 9205         	str	r2, [sp, #0x14]
 80161b6: 9304         	str	r3, [sp, #0x10]
 80161b8: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80162e0 <z_tick_sleep+0x160>
 80161ba: 9303         	str	r3, [sp, #0xc]
 80161bc: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80162e4 <z_tick_sleep+0x164>
 80161be: 9302         	str	r3, [sp, #0x8]
 80161c0: 2308         	movs	r3, #0x8
 80161c2: 9301         	str	r3, [sp, #0x4]
 80161c4: 2300         	movs	r3, #0x0
 80161c6: 9300         	str	r3, [sp]
 80161c8: 2300         	movs	r3, #0x0
 80161ca: 2204         	movs	r2, #0x4
 80161cc: 2000         	movs	r0, #0x0
 80161ce: f010 fb71    	bl	0x80268b4 <z_log_msg_runtime_create> @ imm = #0x106e2
 80161d2: 2300         	movs	r3, #0x0
 80161d4: 65fb         	str	r3, [r7, #0x5c]
; 	if (ticks == 0) {
 80161d6: e9d7 2300    	ldrd	r2, r3, [r7]
 80161da: 4313         	orrs	r3, r2
 80161dc: d103         	bne	0x80161e6 <z_tick_sleep+0x66> @ imm = #0x6
; 		k_yield();
 80161de: f010 f9ef    	bl	0x80265c0 <k_yield>     @ imm = #0x103de
; 		return 0;
 80161e2: 2300         	movs	r3, #0x0
 80161e4: e073         	b	0x80162ce <z_tick_sleep+0x14e> @ imm = #0xe6
; 	if (Z_TICK_ABS(ticks) <= 0) {
 80161e6: e9d7 2300    	ldrd	r2, r3, [r7]
 80161ea: f06f 0001    	mvn	r0, #0x1
 80161ee: f04f 31ff    	mov.w	r1, #0xffffffff
 80161f2: 1a84         	subs	r4, r0, r2
 80161f4: eb61 0503    	sbc.w	r5, r1, r3
 80161f8: 2c01         	cmp	r4, #0x1
 80161fa: f175 0300    	sbcs	r3, r5, #0x0
 80161fe: da06         	bge	0x801620e <z_tick_sleep+0x8e> @ imm = #0xc
; 		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 8016200: f010 feea    	bl	0x8026fd8 <sys_clock_tick_get_32> @ imm = #0x10dd4
 8016204: 4602         	mov	r2, r0
 8016206: 683b         	ldr	r3, [r7]
 8016208: 4413         	add	r3, r2
 801620a: 663b         	str	r3, [r7, #0x60]
 801620c: e004         	b	0x8016218 <z_tick_sleep+0x98> @ imm = #0x8
; 		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 801620e: 683a         	ldr	r2, [r7]
 8016210: f06f 0301    	mvn	r3, #0x1
 8016214: 1a9b         	subs	r3, r3, r2
 8016216: 663b         	str	r3, [r7, #0x60]
; 	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
 8016218: e9d7 2300    	ldrd	r2, r3, [r7]
 801621c: e9c7 2306    	strd	r2, r3, [r7, #24]
 8016220: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80162e8 <z_tick_sleep+0x168>
 8016222: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016224: f3ef 8311    	mrs	r3, basepri
 8016228: 637b         	str	r3, [r7, #0x34]
;   return(result);
 801622a: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 801622c: 633b         	str	r3, [r7, #0x30]
 801622e: 2310         	movs	r3, #0x10
 8016230: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016232: 6afb         	ldr	r3, [r7, #0x2c]
 8016234: f383 8812    	msr	basepri_max, r3
; }
 8016238: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801623a: f3bf 8f6f    	isb	sy
; }
 801623e: bf00         	nop
; 	return key;
 8016240: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 8016242: 613b         	str	r3, [r7, #0x10]
 8016244: 6bbb         	ldr	r3, [r7, #0x38]
 8016246: 62bb         	str	r3, [r7, #0x28]
; }
 8016248: bf00         	nop
 801624a: 6bbb         	ldr	r3, [r7, #0x38]
 801624c: 627b         	str	r3, [r7, #0x24]
; }
 801624e: bf00         	nop
; 	return k;
 8016250: 693b         	ldr	r3, [r7, #0x10]
 8016252: 617b         	str	r3, [r7, #0x14]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016254: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80162dc <z_tick_sleep+0x15c>
 8016256: 689b         	ldr	r3, [r3, #0x8]
 8016258: 63fb         	str	r3, [r7, #0x3c]
; 	return ret;
 801625a: 6bfb         	ldr	r3, [r7, #0x3c]
; 	pending_current = arch_current_thread();
 801625c: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x80162ec <z_tick_sleep+0x16c>
 801625e: 6013         	str	r3, [r2]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016260: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80162dc <z_tick_sleep+0x15c>
 8016262: 689b         	ldr	r3, [r3, #0x8]
 8016264: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 8016266: 6c3b         	ldr	r3, [r7, #0x40]
; 	unready_thread(arch_current_thread());
 8016268: 4618         	mov	r0, r3
 801626a: f7ff f9d9    	bl	0x8015620 <unready_thread> @ imm = #-0xc4e
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801626e: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x80162dc <z_tick_sleep+0x15c>
 8016270: 689b         	ldr	r3, [r3, #0x8]
 8016272: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 8016274: 6c79         	ldr	r1, [r7, #0x44]
; 	z_add_thread_timeout(arch_current_thread(), timeout);
 8016276: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 801627a: 4608         	mov	r0, r1
 801627c: f7fe fd20    	bl	0x8014cc0 <z_add_thread_timeout> @ imm = #-0x15c0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016280: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80162dc <z_tick_sleep+0x15c>
 8016282: 689b         	ldr	r3, [r3, #0x8]
 8016284: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 8016286: 6cbb         	ldr	r3, [r7, #0x48]
; 	z_mark_thread_as_suspended(arch_current_thread());
 8016288: 4618         	mov	r0, r3
 801628a: f010 fa6f    	bl	0x802676c <z_mark_thread_as_suspended> @ imm = #0x104de
 801628e: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80162e8 <z_tick_sleep+0x168>
 8016290: 653b         	str	r3, [r7, #0x50]
 8016292: 697b         	ldr	r3, [r7, #0x14]
 8016294: 60fb         	str	r3, [r7, #0xc]
 8016296: 6d3b         	ldr	r3, [r7, #0x50]
 8016298: 64fb         	str	r3, [r7, #0x4c]
; }
 801629a: bf00         	nop
; 	return z_swap_irqlock(key.key);
 801629c: 68fb         	ldr	r3, [r7, #0xc]
 801629e: 4618         	mov	r0, r3
 80162a0: f010 fafb    	bl	0x802689a <z_swap_irqlock> @ imm = #0x105f6
; 	uint32_t left_ticks = expected_wakeup_ticks - sys_clock_tick_get_32();
 80162a4: f010 fe98    	bl	0x8026fd8 <sys_clock_tick_get_32> @ imm = #0x10d30
 80162a8: 4602         	mov	r2, r0
 80162aa: 6e3b         	ldr	r3, [r7, #0x60]
 80162ac: 1a9b         	subs	r3, r3, r2
 80162ae: 65bb         	str	r3, [r7, #0x58]
; 	ticks = (k_ticks_t)(int32_t)left_ticks;
 80162b0: 6dbb         	ldr	r3, [r7, #0x58]
 80162b2: 17da         	asrs	r2, r3, #0x1f
 80162b4: 4698         	mov	r8, r3
 80162b6: 4691         	mov	r9, r2
 80162b8: e9c7 8900    	strd	r8, r9, [r7]
; 	if (ticks > 0) {
 80162bc: e9d7 2300    	ldrd	r2, r3, [r7]
 80162c0: 2a01         	cmp	r2, #0x1
 80162c2: f173 0300    	sbcs	r3, r3, #0x0
 80162c6: db01         	blt	0x80162cc <z_tick_sleep+0x14c> @ imm = #0x2
; 		return ticks;
 80162c8: 683b         	ldr	r3, [r7]
 80162ca: e000         	b	0x80162ce <z_tick_sleep+0x14e> @ imm = #0x0
; 	return 0;
 80162cc: 2300         	movs	r3, #0x0
; }
 80162ce: 4618         	mov	r0, r3
 80162d0: 3768         	adds	r7, #0x68
 80162d2: 46bd         	mov	sp, r7
 80162d4: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

080162d8 <$d>:
 80162d8: 68 0b 00 20  	.word	0x20000b68
 80162dc: a8 25 00 20  	.word	0x200025a8
 80162e0: 9c bc 02 08  	.word	0x0802bc9c
 80162e4: fc a3 02 08  	.word	0x0802a3fc
 80162e8: ec 32 00 20  	.word	0x200032ec
 80162ec: f8 32 00 20  	.word	0x200032f8

080162f0 <z_impl_k_sleep>:
; {
 80162f0: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 80162f4: b086         	sub	sp, #0x18
 80162f6: af00         	add	r7, sp, #0x0
 80162f8: e9c7 0100    	strd	r0, r1, [r7]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 80162fc: e9d7 2300    	ldrd	r2, r3, [r7]
 8016300: f04f 30ff    	mov.w	r0, #0xffffffff
 8016304: f04f 31ff    	mov.w	r1, #0xffffffff
 8016308: 428b         	cmp	r3, r1
 801630a: bf08         	it	eq
 801630c: 4282         	cmpeq	r2, r0
 801630e: d109         	bne	0x8016324 <z_impl_k_sleep+0x34> @ imm = #0x12
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016310: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8016370 <z_impl_k_sleep+0x80>
 8016312: 689b         	ldr	r3, [r3, #0x8]
 8016314: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8016316: 68bb         	ldr	r3, [r7, #0x8]
; 		k_thread_suspend(arch_current_thread());
 8016318: 4618         	mov	r0, r3
 801631a: f010 f957    	bl	0x80265cc <k_thread_suspend> @ imm = #0x102ae
; 		return (int32_t) K_TICKS_FOREVER;
 801631e: f04f 33ff    	mov.w	r3, #0xffffffff
 8016322: e020         	b	0x8016366 <z_impl_k_sleep+0x76> @ imm = #0x40
; 	ticks = timeout.ticks;
 8016324: e9d7 2300    	ldrd	r2, r3, [r7]
 8016328: e9c7 2304    	strd	r2, r3, [r7, #16]
; 	ticks = z_tick_sleep(ticks);
 801632c: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 8016330: f7ff ff26    	bl	0x8016180 <z_tick_sleep> @ imm = #-0x1b4
 8016334: 4603         	mov	r3, r0
 8016336: 17da         	asrs	r2, r3, #0x1f
 8016338: 4698         	mov	r8, r3
 801633a: 4691         	mov	r9, r2
 801633c: e9c7 8904    	strd	r8, r9, [r7, #16]
; 	int32_t ret = k_ticks_to_ms_ceil64(ticks);
 8016340: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8016344: f112 0409    	adds.w	r4, r2, #0x9
 8016348: f143 0500    	adc	r5, r3, #0x0
 801634c: f04f 020a    	mov.w	r2, #0xa
 8016350: f04f 0300    	mov.w	r3, #0x0
 8016354: 4620         	mov	r0, r4
 8016356: 4629         	mov	r1, r5
 8016358: f7ea f972    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x15d1c
 801635c: 4602         	mov	r2, r0
 801635e: 460b         	mov	r3, r1
 8016360: 4613         	mov	r3, r2
 8016362: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8016364: 68fb         	ldr	r3, [r7, #0xc]
; }
 8016366: 4618         	mov	r0, r3
 8016368: 3718         	adds	r7, #0x18
 801636a: 46bd         	mov	sp, r7
 801636c: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

08016370 <$d>:
 8016370: a8 25 00 20  	.word	0x200025a8

08016374 <z_impl_k_sched_current_thread_query>:
; {
 8016374: b480         	push	{r7}
 8016376: b083         	sub	sp, #0xc
 8016378: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801637a: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8016390 <z_impl_k_sched_current_thread_query+0x1c>
 801637c: 689b         	ldr	r3, [r3, #0x8]
 801637e: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 8016380: 687b         	ldr	r3, [r7, #0x4]
; }
 8016382: 4618         	mov	r0, r3
 8016384: 370c         	adds	r7, #0xc
 8016386: 46bd         	mov	sp, r7
 8016388: f85d 7b04    	ldr	r7, [sp], #4
 801638c: 4770         	bx	lr
 801638e: bf00         	nop

08016390 <$d>:
 8016390: a8 25 00 20  	.word	0x200025a8

08016394 <halt_thread>:
; {
 8016394: b580         	push	{r7, lr}
 8016396: b096         	sub	sp, #0x58
 8016398: af00         	add	r7, sp, #0x0
 801639a: 6078         	str	r0, [r7, #0x4]
 801639c: 460b         	mov	r3, r1
 801639e: 70fb         	strb	r3, [r7, #0x3]
; 	bool dummify = false;
 80163a0: 2300         	movs	r3, #0x0
 80163a2: f887 3057    	strb.w	r3, [r7, #0x57]
; 	if ((thread->base.thread_state & new_state) == 0U) {
 80163a6: 687b         	ldr	r3, [r7, #0x4]
 80163a8: 7b5a         	ldrb	r2, [r3, #0xd]
 80163aa: 78fb         	ldrb	r3, [r7, #0x3]
 80163ac: 4013         	ands	r3, r2
 80163ae: b2db         	uxtb	r3, r3
 80163b0: 2b00         	cmp	r3, #0x0
 80163b2: f040 80cd    	bne.w	0x8016550 <halt_thread+0x1bc> @ imm = #0x19a
; 		thread->base.thread_state |= new_state;
 80163b6: 687b         	ldr	r3, [r7, #0x4]
 80163b8: 7b5a         	ldrb	r2, [r3, #0xd]
 80163ba: 78fb         	ldrb	r3, [r7, #0x3]
 80163bc: 4313         	orrs	r3, r2
 80163be: b2da         	uxtb	r2, r3
 80163c0: 687b         	ldr	r3, [r7, #0x4]
 80163c2: 735a         	strb	r2, [r3, #0xd]
; 		if (z_is_thread_queued(thread)) {
 80163c4: 6878         	ldr	r0, [r7, #0x4]
 80163c6: f010 f9c4    	bl	0x8026752 <z_is_thread_queued> @ imm = #0x10388
 80163ca: 4603         	mov	r3, r0
 80163cc: 2b00         	cmp	r3, #0x0
 80163ce: d01d         	beq	0x801640c <halt_thread+0x78> @ imm = #0x3a
 80163d0: 687b         	ldr	r3, [r7, #0x4]
 80163d2: 653b         	str	r3, [r7, #0x50]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 80163d4: 6d3b         	ldr	r3, [r7, #0x50]
 80163d6: 7b5b         	ldrb	r3, [r3, #0xd]
 80163d8: f003 037f    	and	r3, r3, #0x7f
 80163dc: b2da         	uxtb	r2, r3
 80163de: 6d3b         	ldr	r3, [r7, #0x50]
 80163e0: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 80163e2: 6d38         	ldr	r0, [r7, #0x50]
 80163e4: f010 faa0    	bl	0x8026928 <should_queue_thread> @ imm = #0x10540
 80163e8: 4603         	mov	r3, r0
 80163ea: 2b00         	cmp	r3, #0x0
 80163ec: d00d         	beq	0x801640a <halt_thread+0x76> @ imm = #0x1a
 80163ee: 6d3b         	ldr	r3, [r7, #0x50]
 80163f0: 64fb         	str	r3, [r7, #0x4c]
 80163f2: 6cfb         	ldr	r3, [r7, #0x4c]
 80163f4: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 80163f6: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8016558 <halt_thread+0x1c4>
 80163f8: 647b         	str	r3, [r7, #0x44]
 80163fa: 6cfb         	ldr	r3, [r7, #0x4c]
 80163fc: 643b         	str	r3, [r7, #0x40]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 80163fe: 6c3b         	ldr	r3, [r7, #0x40]
 8016400: 4618         	mov	r0, r3
 8016402: f010 f8c6    	bl	0x8026592 <sys_dlist_remove> @ imm = #0x1018c
; }
 8016406: bf00         	nop
; }
 8016408: bf00         	nop
; }
 801640a: bf00         	nop
; 		if (new_state == _THREAD_DEAD) {
 801640c: 78fb         	ldrb	r3, [r7, #0x3]
 801640e: 2b08         	cmp	r3, #0x8
 8016410: d123         	bne	0x801645a <halt_thread+0xc6> @ imm = #0x46
; 			if (thread->base.pended_on != NULL) {
 8016412: 687b         	ldr	r3, [r7, #0x4]
 8016414: 689b         	ldr	r3, [r3, #0x8]
 8016416: 2b00         	cmp	r3, #0x0
 8016418: d002         	beq	0x8016420 <halt_thread+0x8c> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 801641a: 6878         	ldr	r0, [r7, #0x4]
 801641c: f010 fa16    	bl	0x802684c <unpend_thread_no_timeout> @ imm = #0x1042c
; 			(void)z_abort_thread_timeout(thread);
 8016420: 6878         	ldr	r0, [r7, #0x4]
 8016422: f010 f8f6    	bl	0x8026612 <z_abort_thread_timeout> @ imm = #0x101ec
; 			unpend_all(&thread->join_queue);
 8016426: 687b         	ldr	r3, [r7, #0x4]
 8016428: 3368         	adds	r3, #0x68
 801642a: 4618         	mov	r0, r3
 801642c: f010 fc52    	bl	0x8026cd4 <unpend_all>  @ imm = #0x108a4
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016430: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x801655c <halt_thread+0x1c8>
 8016432: 689b         	ldr	r3, [r3, #0x8]
 8016434: 63fb         	str	r3, [r7, #0x3c]
; 	return ret;
 8016436: 6bfb         	ldr	r3, [r7, #0x3c]
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 8016438: 687a         	ldr	r2, [r7, #0x4]
 801643a: 429a         	cmp	r2, r3
 801643c: d10d         	bne	0x801645a <halt_thread+0xc6> @ imm = #0x1a
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801643e: f3ef 8305    	mrs	r3, ipsr
 8016442: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 8016444: 6bbb         	ldr	r3, [r7, #0x38]
; 	return (__get_IPSR()) ? (true) : (false);
 8016446: 2b00         	cmp	r3, #0x0
 8016448: bf14         	ite	ne
 801644a: 2301         	movne	r3, #0x1
 801644c: 2300         	moveq	r3, #0x0
 801644e: b2db         	uxtb	r3, r3
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 8016450: 2b00         	cmp	r3, #0x0
 8016452: d002         	beq	0x801645a <halt_thread+0xc6> @ imm = #0x4
; 				dummify = true;
 8016454: 2301         	movs	r3, #0x1
 8016456: f887 3057    	strb.w	r3, [r7, #0x57]
 801645a: 2301         	movs	r3, #0x1
 801645c: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 801645e: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8016558 <halt_thread+0x1c4>
 8016460: 633b         	str	r3, [r7, #0x30]
; 	struct k_thread *thread = NULL;
 8016462: 2300         	movs	r3, #0x0
 8016464: 62fb         	str	r3, [r7, #0x2c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8016466: 6b38         	ldr	r0, [r7, #0x30]
 8016468: f010 f826    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0x1004c
 801646c: 62b8         	str	r0, [r7, #0x28]
; 	if (n != NULL) {
 801646e: 6abb         	ldr	r3, [r7, #0x28]
 8016470: 2b00         	cmp	r3, #0x0
 8016472: d001         	beq	0x8016478 <halt_thread+0xe4> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8016474: 6abb         	ldr	r3, [r7, #0x28]
 8016476: 62fb         	str	r3, [r7, #0x2c]
; 	return thread;
 8016478: 6afb         	ldr	r3, [r7, #0x2c]
; 	return _priq_run_best(curr_cpu_runq());
 801647a: bf00         	nop
; 	struct k_thread *thread = runq_best();
 801647c: 627b         	str	r3, [r7, #0x24]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 801647e: 6a7b         	ldr	r3, [r7, #0x24]
 8016480: 2b00         	cmp	r3, #0x0
 8016482: d102         	bne	0x801648a <halt_thread+0xf6> @ imm = #0x4
 8016484: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x801655c <halt_thread+0x1c8>
 8016486: 68db         	ldr	r3, [r3, #0xc]
 8016488: e000         	b	0x801648c <halt_thread+0xf8> @ imm = #0x0
 801648a: 6a7b         	ldr	r3, [r7, #0x24]
; 	struct k_thread *thread = next_up();
 801648c: 623b         	str	r3, [r7, #0x20]
 801648e: 6a3b         	ldr	r3, [r7, #0x20]
 8016490: 61fb         	str	r3, [r7, #0x1c]
 8016492: 6b7b         	ldr	r3, [r7, #0x34]
 8016494: 61bb         	str	r3, [r7, #0x18]
; 	if (preempt_ok != 0) {
 8016496: 69bb         	ldr	r3, [r7, #0x18]
 8016498: 2b00         	cmp	r3, #0x0
 801649a: d001         	beq	0x80164a0 <halt_thread+0x10c> @ imm = #0x2
; 		return true;
 801649c: 2301         	movs	r3, #0x1
 801649e: e026         	b	0x80164ee <halt_thread+0x15a> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80164a0: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x801655c <halt_thread+0x1c8>
 80164a2: 689b         	ldr	r3, [r3, #0x8]
 80164a4: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 80164a6: 697b         	ldr	r3, [r7, #0x14]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 80164a8: 4618         	mov	r0, r3
 80164aa: f010 f8ef    	bl	0x802668c <z_is_thread_prevented_from_running> @ imm = #0x101de
 80164ae: 4603         	mov	r3, r0
 80164b0: 2b00         	cmp	r3, #0x0
 80164b2: d001         	beq	0x80164b8 <halt_thread+0x124> @ imm = #0x2
; 		return true;
 80164b4: 2301         	movs	r3, #0x1
 80164b6: e01a         	b	0x80164ee <halt_thread+0x15a> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80164b8: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x801655c <halt_thread+0x1c8>
 80164ba: 689b         	ldr	r3, [r3, #0x8]
 80164bc: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 80164be: 693b         	ldr	r3, [r7, #0x10]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 80164c0: 4618         	mov	r0, r3
 80164c2: f010 f8b4    	bl	0x802662e <thread_is_preemptible> @ imm = #0x10168
 80164c6: 4603         	mov	r3, r0
 80164c8: 2b00         	cmp	r3, #0x0
 80164ca: d105         	bne	0x80164d8 <halt_thread+0x144> @ imm = #0xa
 80164cc: 69f8         	ldr	r0, [r7, #0x1c]
 80164ce: f010 f8bf    	bl	0x8026650 <thread_is_metairq> @ imm = #0x1017e
 80164d2: 4603         	mov	r3, r0
 80164d4: 2b00         	cmp	r3, #0x0
 80164d6: d001         	beq	0x80164dc <halt_thread+0x148> @ imm = #0x2
; 		return true;
 80164d8: 2301         	movs	r3, #0x1
 80164da: e008         	b	0x80164ee <halt_thread+0x15a> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 80164dc: 69f8         	ldr	r0, [r7, #0x1c]
 80164de: f010 f8ea    	bl	0x80266b6 <z_is_thread_timeout_active> @ imm = #0x101d4
 80164e2: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 80164e4: 2b00         	cmp	r3, #0x0
 80164e6: d001         	beq	0x80164ec <halt_thread+0x158> @ imm = #0x2
; 		return true;
 80164e8: 2301         	movs	r3, #0x1
 80164ea: e000         	b	0x80164ee <halt_thread+0x15a> @ imm = #0x0
; 	return false;
 80164ec: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 80164ee: 2b00         	cmp	r3, #0x0
 80164f0: d010         	beq	0x8016514 <halt_thread+0x180> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80164f2: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x801655c <halt_thread+0x1c8>
 80164f4: 689b         	ldr	r3, [r3, #0x8]
 80164f6: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 80164f8: 68fb         	ldr	r3, [r7, #0xc]
; 		if (thread != arch_current_thread()) {
 80164fa: 6a3a         	ldr	r2, [r7, #0x20]
 80164fc: 429a         	cmp	r2, r3
 80164fe: d002         	beq	0x8016506 <halt_thread+0x172> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8016500: 6a38         	ldr	r0, [r7, #0x20]
 8016502: f000 f9b3    	bl	0x801686c <z_reset_time_slice> @ imm = #0x366
; 		update_metairq_preempt(thread);
 8016506: 6a38         	ldr	r0, [r7, #0x20]
 8016508: f010 fa55    	bl	0x80269b6 <update_metairq_preempt> @ imm = #0x104aa
; 		_kernel.ready_q.cache = thread;
 801650c: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x801655c <halt_thread+0x1c8>
 801650e: 6a3b         	ldr	r3, [r7, #0x20]
 8016510: 6213         	str	r3, [r2, #0x20]
; }
 8016512: e005         	b	0x8016520 <halt_thread+0x18c> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016514: 4b11         	ldr	r3, [pc, #0x44]         @ 0x801655c <halt_thread+0x1c8>
 8016516: 689b         	ldr	r3, [r3, #0x8]
 8016518: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 801651a: 68bb         	ldr	r3, [r7, #0x8]
; 		_kernel.ready_q.cache = arch_current_thread();
 801651c: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x801655c <halt_thread+0x1c8>
 801651e: 6213         	str	r3, [r2, #0x20]
; }
 8016520: bf00         	nop
; 		if (new_state == _THREAD_SUSPENDED) {
 8016522: 78fb         	ldrb	r3, [r7, #0x3]
 8016524: 2b10         	cmp	r3, #0x10
 8016526: d103         	bne	0x8016530 <halt_thread+0x19c> @ imm = #0x6
; 			clear_halting(thread);
 8016528: 6878         	ldr	r0, [r7, #0x4]
 801652a: f010 fa2e    	bl	0x802698a <clear_halting> @ imm = #0x1045c
; 			return;
 801652e: e00f         	b	0x8016550 <halt_thread+0x1bc> @ imm = #0x1e
; 		arch_float_disable(thread);
 8016530: 6878         	ldr	r0, [r7, #0x4]
 8016532: f7f0 f8c7    	bl	0x80066c4 <arch_float_disable> @ imm = #-0xfe72
; 		z_thread_monitor_exit(thread);
 8016536: 6878         	ldr	r0, [r7, #0x4]
 8016538: f000 fa4e    	bl	0x80169d8 <z_thread_monitor_exit> @ imm = #0x49c
; 		if (dummify && !IS_ENABLED(CONFIG_ARCH_POSIX)) {
 801653c: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8016540: 2b00         	cmp	r3, #0x0
 8016542: d002         	beq	0x801654a <halt_thread+0x1b6> @ imm = #0x4
; 			z_dummy_thread_init(&_thread_dummy);
 8016544: 4806         	ldr	r0, [pc, #0x18]         @ 0x8016560 <halt_thread+0x1cc>
 8016546: f7fe fbe3    	bl	0x8014d10 <z_dummy_thread_init> @ imm = #-0x183a
; 		clear_halting(thread);
 801654a: 6878         	ldr	r0, [r7, #0x4]
 801654c: f010 fa1d    	bl	0x802698a <clear_halting> @ imm = #0x1043a
; }
 8016550: 3758         	adds	r7, #0x58
 8016552: 46bd         	mov	sp, r7
 8016554: bd80         	pop	{r7, pc}
 8016556: bf00         	nop

08016558 <$d>:
 8016558: cc 25 00 20  	.word	0x200025cc
 801655c: a8 25 00 20  	.word	0x200025a8
 8016560: 58 29 00 20  	.word	0x20002958

08016564 <z_thread_abort>:
; {
 8016564: b580         	push	{r7, lr}
 8016566: b094         	sub	sp, #0x50
 8016568: af00         	add	r7, sp, #0x0
 801656a: 6078         	str	r0, [r7, #0x4]
 801656c: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8016630 <z_thread_abort+0xcc>
 801656e: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016570: f3ef 8311    	mrs	r3, basepri
 8016574: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 8016576: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 8016578: 647b         	str	r3, [r7, #0x44]
 801657a: 2310         	movs	r3, #0x10
 801657c: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801657e: 6c3b         	ldr	r3, [r7, #0x40]
 8016580: f383 8812    	msr	basepri_max, r3
; }
 8016584: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016586: f3bf 8f6f    	isb	sy
; }
 801658a: bf00         	nop
; 	return key;
 801658c: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 801658e: 60bb         	str	r3, [r7, #0x8]
 8016590: 6cfb         	ldr	r3, [r7, #0x4c]
 8016592: 63fb         	str	r3, [r7, #0x3c]
; }
 8016594: bf00         	nop
 8016596: 6cfb         	ldr	r3, [r7, #0x4c]
 8016598: 63bb         	str	r3, [r7, #0x38]
; }
 801659a: bf00         	nop
; 	return k;
 801659c: 68bb         	ldr	r3, [r7, #0x8]
 801659e: 617b         	str	r3, [r7, #0x14]
; 	if (z_is_thread_essential(thread)) {
 80165a0: 6878         	ldr	r0, [r7, #0x4]
 80165a2: f010 f927    	bl	0x80267f4 <z_is_thread_essential> @ imm = #0x1024e
 80165a6: 4603         	mov	r3, r0
 80165a8: 2b00         	cmp	r3, #0x0
 80165aa: d020         	beq	0x80165ee <z_thread_abort+0x8a> @ imm = #0x40
 80165ac: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8016630 <z_thread_abort+0xcc>
 80165ae: 62fb         	str	r3, [r7, #0x2c]
 80165b0: 697b         	ldr	r3, [r7, #0x14]
 80165b2: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 80165b4: 68fb         	ldr	r3, [r7, #0xc]
 80165b6: 62bb         	str	r3, [r7, #0x28]
 80165b8: 6abb         	ldr	r3, [r7, #0x28]
 80165ba: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80165bc: 6a7b         	ldr	r3, [r7, #0x24]
 80165be: f383 8811    	msr	basepri, r3
; }
 80165c2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80165c4: f3bf 8f6f    	isb	sy
; }
 80165c8: bf00         	nop
; }
 80165ca: bf00         	nop
; }
 80165cc: bf00         	nop
 80165ce: 2300         	movs	r3, #0x0
 80165d0: 637b         	str	r3, [r7, #0x34]
 80165d2: 6b7b         	ldr	r3, [r7, #0x34]
 80165d4: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80165d6: 6b3b         	ldr	r3, [r7, #0x30]
 80165d8: f383 8811    	msr	basepri, r3
; }
 80165dc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80165de: f3bf 8f6f    	isb	sy
; }
 80165e2: bf00         	nop
; }
 80165e4: bf00         	nop
; 		k_panic();
 80165e6: 2304         	movs	r3, #0x4
 80165e8: 4618         	mov	r0, r3
 80165ea: df02         	svc	#0x2
; 		return;
 80165ec: e01c         	b	0x8016628 <z_thread_abort+0xc4> @ imm = #0x38
; 	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 80165ee: 687b         	ldr	r3, [r7, #0x4]
 80165f0: 7b5b         	ldrb	r3, [r3, #0xd]
 80165f2: f003 0308    	and	r3, r3, #0x8
 80165f6: 2b00         	cmp	r3, #0x0
 80165f8: d011         	beq	0x801661e <z_thread_abort+0xba> @ imm = #0x22
 80165fa: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8016630 <z_thread_abort+0xcc>
 80165fc: 623b         	str	r3, [r7, #0x20]
 80165fe: 697b         	ldr	r3, [r7, #0x14]
 8016600: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8016602: 693b         	ldr	r3, [r7, #0x10]
 8016604: 61fb         	str	r3, [r7, #0x1c]
 8016606: 69fb         	ldr	r3, [r7, #0x1c]
 8016608: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801660a: 69bb         	ldr	r3, [r7, #0x18]
 801660c: f383 8811    	msr	basepri, r3
; }
 8016610: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016612: f3bf 8f6f    	isb	sy
; }
 8016616: bf00         	nop
; }
 8016618: bf00         	nop
; }
 801661a: bf00         	nop
; 		return;
 801661c: e004         	b	0x8016628 <z_thread_abort+0xc4> @ imm = #0x8
; 	z_thread_halt(thread, key, true);
 801661e: 2201         	movs	r2, #0x1
 8016620: 6979         	ldr	r1, [r7, #0x14]
 8016622: 6878         	ldr	r0, [r7, #0x4]
 8016624: f7fe fe06    	bl	0x8015234 <z_thread_halt> @ imm = #-0x13f4
; }
 8016628: 3750         	adds	r7, #0x50
 801662a: 46bd         	mov	sp, r7
 801662c: bd80         	pop	{r7, pc}
 801662e: bf00         	nop

08016630 <$d>:
 8016630: ec 32 00 20  	.word	0x200032ec

08016634 <z_sched_wake>:
; {
 8016634: b580         	push	{r7, lr}
 8016636: b09c         	sub	sp, #0x70
 8016638: af00         	add	r7, sp, #0x0
 801663a: 60f8         	str	r0, [r7, #0xc]
 801663c: 60b9         	str	r1, [r7, #0x8]
 801663e: 607a         	str	r2, [r7, #0x4]
; 	bool ret = false;
 8016640: 2300         	movs	r3, #0x0
 8016642: f887 306f    	strb.w	r3, [r7, #0x6f]
; 	K_SPINLOCK(&_sched_spinlock) {
 8016646: 2300         	movs	r3, #0x0
 8016648: 623b         	str	r3, [r7, #0x20]
 801664a: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x801671c <z_sched_wake+0xe8>
 801664c: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801664e: f3ef 8311    	mrs	r3, basepri
 8016652: 663b         	str	r3, [r7, #0x60]
;   return(result);
 8016654: 6e3b         	ldr	r3, [r7, #0x60]
; 	key = __get_BASEPRI();
 8016656: 65fb         	str	r3, [r7, #0x5c]
 8016658: 2310         	movs	r3, #0x10
 801665a: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801665c: 6dbb         	ldr	r3, [r7, #0x58]
 801665e: f383 8812    	msr	basepri_max, r3
; }
 8016662: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016664: f3bf 8f6f    	isb	sy
; }
 8016668: bf00         	nop
; 	return key;
 801666a: 6dfb         	ldr	r3, [r7, #0x5c]
; 	k.key = arch_irq_lock();
 801666c: 617b         	str	r3, [r7, #0x14]
 801666e: 6e7b         	ldr	r3, [r7, #0x64]
 8016670: 657b         	str	r3, [r7, #0x54]
; }
 8016672: bf00         	nop
 8016674: 6e7b         	ldr	r3, [r7, #0x64]
 8016676: 653b         	str	r3, [r7, #0x50]
; }
 8016678: bf00         	nop
; 	return k;
 801667a: 697b         	ldr	r3, [r7, #0x14]
 801667c: 61fb         	str	r3, [r7, #0x1c]
; 	K_SPINLOCK(&_sched_spinlock) {
 801667e: e043         	b	0x8016708 <z_sched_wake+0xd4> @ imm = #0x86
; 		thread = _priq_wait_best(&wait_q->waitq);
 8016680: 68fb         	ldr	r3, [r7, #0xc]
 8016682: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 8016684: 2300         	movs	r3, #0x0
 8016686: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8016688: 6cf8         	ldr	r0, [r7, #0x4c]
 801668a: f00f ff15    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #0xfe2a
 801668e: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8016690: 6c7b         	ldr	r3, [r7, #0x44]
 8016692: 2b00         	cmp	r3, #0x0
 8016694: d001         	beq	0x801669a <z_sched_wake+0x66> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8016696: 6c7b         	ldr	r3, [r7, #0x44]
 8016698: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 801669a: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 801669c: 66bb         	str	r3, [r7, #0x68]
; 		if (thread != NULL) {
 801669e: 6ebb         	ldr	r3, [r7, #0x68]
 80166a0: 2b00         	cmp	r3, #0x0
 80166a2: d01e         	beq	0x80166e2 <z_sched_wake+0xae> @ imm = #0x3c
; 			z_thread_return_value_set_with_data(thread,
 80166a4: 68bb         	ldr	r3, [r7, #0x8]
 80166a6: 6eba         	ldr	r2, [r7, #0x68]
 80166a8: 643a         	str	r2, [r7, #0x40]
 80166aa: 63fb         	str	r3, [r7, #0x3c]
 80166ac: 687b         	ldr	r3, [r7, #0x4]
 80166ae: 63bb         	str	r3, [r7, #0x38]
 80166b0: 6c3b         	ldr	r3, [r7, #0x40]
 80166b2: 637b         	str	r3, [r7, #0x34]
 80166b4: 6bfb         	ldr	r3, [r7, #0x3c]
 80166b6: 633b         	str	r3, [r7, #0x30]
; 	thread->arch.swap_return_value = value;
 80166b8: 6b7b         	ldr	r3, [r7, #0x34]
 80166ba: 6b3a         	ldr	r2, [r7, #0x30]
 80166bc: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 80166c0: bf00         	nop
; 	thread->base.swap_data = data;
 80166c2: 6c3b         	ldr	r3, [r7, #0x40]
 80166c4: 6bba         	ldr	r2, [r7, #0x38]
 80166c6: 615a         	str	r2, [r3, #0x14]
; }
 80166c8: bf00         	nop
; 			unpend_thread_no_timeout(thread);
 80166ca: 6eb8         	ldr	r0, [r7, #0x68]
 80166cc: f010 f8be    	bl	0x802684c <unpend_thread_no_timeout> @ imm = #0x1017c
; 			(void)z_abort_thread_timeout(thread);
 80166d0: 6eb8         	ldr	r0, [r7, #0x68]
 80166d2: f00f ff9e    	bl	0x8026612 <z_abort_thread_timeout> @ imm = #0xff3c
; 			ready_thread(thread);
 80166d6: 6eb8         	ldr	r0, [r7, #0x68]
 80166d8: f7fe fc2c    	bl	0x8014f34 <ready_thread> @ imm = #-0x17a8
; 			ret = true;
 80166dc: 2301         	movs	r3, #0x1
 80166de: f887 306f    	strb.w	r3, [r7, #0x6f]
 80166e2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x801671c <z_sched_wake+0xe8>
 80166e4: 62fb         	str	r3, [r7, #0x2c]
 80166e6: 69fb         	ldr	r3, [r7, #0x1c]
 80166e8: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 80166ea: 69bb         	ldr	r3, [r7, #0x18]
 80166ec: 62bb         	str	r3, [r7, #0x28]
 80166ee: 6abb         	ldr	r3, [r7, #0x28]
 80166f0: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80166f2: 6a7b         	ldr	r3, [r7, #0x24]
 80166f4: f383 8811    	msr	basepri, r3
; }
 80166f8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80166fa: f3bf 8f6f    	isb	sy
; }
 80166fe: bf00         	nop
; }
 8016700: bf00         	nop
; }
 8016702: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8016704: 2301         	movs	r3, #0x1
 8016706: 623b         	str	r3, [r7, #0x20]
 8016708: 6a3b         	ldr	r3, [r7, #0x20]
 801670a: 2b00         	cmp	r3, #0x0
 801670c: d0b8         	beq	0x8016680 <z_sched_wake+0x4c> @ imm = #-0x90
; 	return ret;
 801670e: f897 306f    	ldrb.w	r3, [r7, #0x6f]
; }
 8016712: 4618         	mov	r0, r3
 8016714: 3770         	adds	r7, #0x70
 8016716: 46bd         	mov	sp, r7
 8016718: bd80         	pop	{r7, pc}
 801671a: bf00         	nop

0801671c <$d>:
 801671c: ec 32 00 20  	.word	0x200032ec

08016720 <z_sched_wait>:
; {
 8016720: b580         	push	{r7, lr}
 8016722: b088         	sub	sp, #0x20
 8016724: af02         	add	r7, sp, #0x8
 8016726: 60f8         	str	r0, [r7, #0xc]
 8016728: 60b9         	str	r1, [r7, #0x8]
 801672a: 607a         	str	r2, [r7, #0x4]
; 	int ret = z_pend_curr(lock, key, wait_q, timeout);
 801672c: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8016730: e9cd 2300    	strd	r2, r3, [sp]
 8016734: 687a         	ldr	r2, [r7, #0x4]
 8016736: 68b9         	ldr	r1, [r7, #0x8]
 8016738: 68f8         	ldr	r0, [r7, #0xc]
 801673a: f7ff f8d1    	bl	0x80158e0 <z_pend_curr> @ imm = #-0xe5e
 801673e: 6178         	str	r0, [r7, #0x14]
; 	if (data != NULL) {
 8016740: 6abb         	ldr	r3, [r7, #0x28]
 8016742: 2b00         	cmp	r3, #0x0
 8016744: d006         	beq	0x8016754 <z_sched_wait+0x34> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016746: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8016760 <z_sched_wait+0x40>
 8016748: 689b         	ldr	r3, [r3, #0x8]
 801674a: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 801674c: 693b         	ldr	r3, [r7, #0x10]
; 		*data = arch_current_thread()->base.swap_data;
 801674e: 695a         	ldr	r2, [r3, #0x14]
 8016750: 6abb         	ldr	r3, [r7, #0x28]
 8016752: 601a         	str	r2, [r3]
; 	return ret;
 8016754: 697b         	ldr	r3, [r7, #0x14]
; }
 8016756: 4618         	mov	r0, r3
 8016758: 3718         	adds	r7, #0x18
 801675a: 46bd         	mov	sp, r7
 801675c: bd80         	pop	{r7, pc}
 801675e: bf00         	nop

08016760 <$d>:
 8016760: a8 25 00 20  	.word	0x200025a8

08016764 <z_is_idle_thread_object>:
; {
 8016764: b480         	push	{r7}
 8016766: b083         	sub	sp, #0xc
 8016768: af00         	add	r7, sp, #0x0
 801676a: 6078         	str	r0, [r7, #0x4]
; 	return thread == &z_idle_threads[0];
 801676c: 687b         	ldr	r3, [r7, #0x4]
 801676e: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8016788 <z_is_idle_thread_object+0x24>
 8016770: 4293         	cmp	r3, r2
 8016772: bf0c         	ite	eq
 8016774: 2301         	moveq	r3, #0x1
 8016776: 2300         	movne	r3, #0x0
 8016778: b2db         	uxtb	r3, r3
; }
 801677a: 4618         	mov	r0, r3
 801677c: 370c         	adds	r7, #0xc
 801677e: 46bd         	mov	sp, r7
 8016780: f85d 7b04    	ldr	r7, [sp], #4
 8016784: 4770         	bx	lr
 8016786: bf00         	nop

08016788 <$d>:
 8016788: 08 27 00 20  	.word	0x20002708

0801678c <slice_time>:
; {
 801678c: b480         	push	{r7}
 801678e: b085         	sub	sp, #0x14
 8016790: af00         	add	r7, sp, #0x0
 8016792: 6078         	str	r0, [r7, #0x4]
; 	int ret = slice_ticks;
 8016794: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80167a8 <slice_time+0x1c>
 8016796: 681b         	ldr	r3, [r3]
 8016798: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 801679a: 68fb         	ldr	r3, [r7, #0xc]
; }
 801679c: 4618         	mov	r0, r3
 801679e: 3714         	adds	r7, #0x14
 80167a0: 46bd         	mov	sp, r7
 80167a2: f85d 7b04    	ldr	r7, [sp], #4
 80167a6: 4770         	bx	lr

080167a8 <$d>:
 80167a8: ec 32 00 20  	.word	0x200032ec

080167ac <thread_is_sliceable>:
; {
 80167ac: b580         	push	{r7, lr}
 80167ae: b084         	sub	sp, #0x10
 80167b0: af00         	add	r7, sp, #0x0
 80167b2: 6078         	str	r0, [r7, #0x4]
; 	bool ret = thread_is_preemptible(thread)
 80167b4: 6878         	ldr	r0, [r7, #0x4]
 80167b6: f010 fab4    	bl	0x8026d22 <thread_is_preemptible> @ imm = #0x10568
 80167ba: 4603         	mov	r3, r0
; 		&& !z_is_idle_thread_object(thread);
 80167bc: 2b00         	cmp	r3, #0x0
 80167be: d029         	beq	0x8016814 <thread_is_sliceable+0x68> @ imm = #0x52
; 		&& slice_time(thread) != 0
 80167c0: 6878         	ldr	r0, [r7, #0x4]
 80167c2: f7ff ffe3    	bl	0x801678c <slice_time>  @ imm = #-0x3a
 80167c6: 4603         	mov	r3, r0
 80167c8: 2b00         	cmp	r3, #0x0
 80167ca: d023         	beq	0x8016814 <thread_is_sliceable+0x68> @ imm = #0x46
; 		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 80167cc: 687b         	ldr	r3, [r7, #0x4]
 80167ce: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80167d2: 461a         	mov	r2, r3
 80167d4: 4b15         	ldr	r3, [pc, #0x54]         @ 0x801682c <thread_is_sliceable+0x80>
 80167d6: 681b         	ldr	r3, [r3]
 80167d8: 4619         	mov	r1, r3
 80167da: 4610         	mov	r0, r2
 80167dc: f010 fad9    	bl	0x8026d92 <z_is_prio_higher> @ imm = #0x105b2
 80167e0: 4603         	mov	r3, r0
 80167e2: f083 0301    	eor	r3, r3, #0x1
 80167e6: b2db         	uxtb	r3, r3
 80167e8: 2b00         	cmp	r3, #0x0
 80167ea: d013         	beq	0x8016814 <thread_is_sliceable+0x68> @ imm = #0x26
; 		&& !z_is_thread_prevented_from_running(thread)
 80167ec: 6878         	ldr	r0, [r7, #0x4]
 80167ee: f010 faa9    	bl	0x8026d44 <z_is_thread_prevented_from_running> @ imm = #0x10552
 80167f2: 4603         	mov	r3, r0
 80167f4: f083 0301    	eor	r3, r3, #0x1
 80167f8: b2db         	uxtb	r3, r3
 80167fa: 2b00         	cmp	r3, #0x0
 80167fc: d00a         	beq	0x8016814 <thread_is_sliceable+0x68> @ imm = #0x14
; 		&& !z_is_idle_thread_object(thread);
 80167fe: 6878         	ldr	r0, [r7, #0x4]
 8016800: f7ff ffb0    	bl	0x8016764 <z_is_idle_thread_object> @ imm = #-0xa0
 8016804: 4603         	mov	r3, r0
 8016806: f083 0301    	eor	r3, r3, #0x1
 801680a: b2db         	uxtb	r3, r3
 801680c: 2b00         	cmp	r3, #0x0
 801680e: d001         	beq	0x8016814 <thread_is_sliceable+0x68> @ imm = #0x2
 8016810: 2301         	movs	r3, #0x1
 8016812: e000         	b	0x8016816 <thread_is_sliceable+0x6a> @ imm = #0x0
 8016814: 2300         	movs	r3, #0x0
; 	bool ret = thread_is_preemptible(thread)
 8016816: 73fb         	strb	r3, [r7, #0xf]
 8016818: 7bfb         	ldrb	r3, [r7, #0xf]
 801681a: f003 0301    	and	r3, r3, #0x1
 801681e: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 8016820: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8016822: 4618         	mov	r0, r3
 8016824: 3710         	adds	r7, #0x10
 8016826: 46bd         	mov	sp, r7
 8016828: bd80         	pop	{r7, pc}
 801682a: bf00         	nop

0801682c <$d>:
 801682c: f0 32 00 20  	.word	0x200032f0

08016830 <slice_timeout>:
; {
 8016830: b480         	push	{r7}
 8016832: b085         	sub	sp, #0x14
 8016834: af00         	add	r7, sp, #0x0
 8016836: 6078         	str	r0, [r7, #0x4]
; 	int cpu = ARRAY_INDEX(slice_timeouts, timeout);
 8016838: 687b         	ldr	r3, [r7, #0x4]
 801683a: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8016860 <slice_timeout+0x30>
 801683c: 1a9b         	subs	r3, r3, r2
 801683e: 10db         	asrs	r3, r3, #0x3
 8016840: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8016864 <slice_timeout+0x34>
 8016842: fb02 f303    	mul	r3, r2, r3
 8016846: 60fb         	str	r3, [r7, #0xc]
; 	slice_expired[cpu] = true;
 8016848: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8016868 <slice_timeout+0x38>
 801684a: 68fb         	ldr	r3, [r7, #0xc]
 801684c: 4413         	add	r3, r2
 801684e: 2201         	movs	r2, #0x1
 8016850: 701a         	strb	r2, [r3]
; }
 8016852: bf00         	nop
 8016854: 3714         	adds	r7, #0x14
 8016856: 46bd         	mov	sp, r7
 8016858: f85d 7b04    	ldr	r7, [sp], #4
 801685c: 4770         	bx	lr
 801685e: bf00         	nop

08016860 <$d>:
 8016860: 70 2a 00 20  	.word	0x20002a70
 8016864: ab aa aa aa  	.word	0xaaaaaaab
 8016868: f4 32 00 20  	.word	0x200032f4

0801686c <z_reset_time_slice>:
; {
 801686c: e92d 4390    	push.w	{r4, r7, r8, r9, lr}
 8016870: b085         	sub	sp, #0x14
 8016872: af00         	add	r7, sp, #0x0
 8016874: 6078         	str	r0, [r7, #0x4]
; 	int cpu = _current_cpu->id;
 8016876: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80168dc <z_reset_time_slice+0x70>
 8016878: 7c1b         	ldrb	r3, [r3, #0x10]
 801687a: 60fb         	str	r3, [r7, #0xc]
; 	z_abort_timeout(&slice_timeouts[cpu]);
 801687c: 68fa         	ldr	r2, [r7, #0xc]
 801687e: 4613         	mov	r3, r2
 8016880: 005b         	lsls	r3, r3, #0x1
 8016882: 4413         	add	r3, r2
 8016884: 00db         	lsls	r3, r3, #0x3
 8016886: 4a16         	ldr	r2, [pc, #0x58]         @ 0x80168e0 <z_reset_time_slice+0x74>
 8016888: 4413         	add	r3, r2
 801688a: 4618         	mov	r0, r3
 801688c: f000 faba    	bl	0x8016e04 <z_abort_timeout> @ imm = #0x574
; 	slice_expired[cpu] = false;
 8016890: 4a14         	ldr	r2, [pc, #0x50]         @ 0x80168e4 <z_reset_time_slice+0x78>
 8016892: 68fb         	ldr	r3, [r7, #0xc]
 8016894: 4413         	add	r3, r2
 8016896: 2200         	movs	r2, #0x0
 8016898: 701a         	strb	r2, [r3]
; 	if (thread_is_sliceable(thread)) {
 801689a: 6878         	ldr	r0, [r7, #0x4]
 801689c: f7ff ff86    	bl	0x80167ac <thread_is_sliceable> @ imm = #-0xf4
 80168a0: 4603         	mov	r3, r0
 80168a2: 2b00         	cmp	r3, #0x0
 80168a4: d014         	beq	0x80168d0 <z_reset_time_slice+0x64> @ imm = #0x28
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 80168a6: 68fa         	ldr	r2, [r7, #0xc]
 80168a8: 4613         	mov	r3, r2
 80168aa: 005b         	lsls	r3, r3, #0x1
 80168ac: 4413         	add	r3, r2
 80168ae: 00db         	lsls	r3, r3, #0x3
 80168b0: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80168e0 <z_reset_time_slice+0x74>
 80168b2: 189c         	adds	r4, r3, r2
; 			      K_TICKS(slice_time(thread) - 1));
 80168b4: 6878         	ldr	r0, [r7, #0x4]
 80168b6: f7ff ff69    	bl	0x801678c <slice_time>  @ imm = #-0x12e
 80168ba: 4603         	mov	r3, r0
 80168bc: 3b01         	subs	r3, #0x1
 80168be: 17da         	asrs	r2, r3, #0x1f
 80168c0: 4698         	mov	r8, r3
 80168c2: 4691         	mov	r9, r2
 80168c4: 4642         	mov	r2, r8
 80168c6: 464b         	mov	r3, r9
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 80168c8: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80168e8 <z_reset_time_slice+0x7c>
 80168ca: 4620         	mov	r0, r4
 80168cc: f000 f9a6    	bl	0x8016c1c <z_add_timeout> @ imm = #0x34c
; }
 80168d0: bf00         	nop
 80168d2: 3714         	adds	r7, #0x14
 80168d4: 46bd         	mov	sp, r7
 80168d6: e8bd 8390    	pop.w	{r4, r7, r8, r9, pc}
 80168da: bf00         	nop

080168dc <$d>:
 80168dc: a8 25 00 20  	.word	0x200025a8
 80168e0: 70 2a 00 20  	.word	0x20002a70
 80168e4: f4 32 00 20  	.word	0x200032f4
 80168e8: 31 68 01 08  	.word	0x08016831

080168ec <z_time_slice>:
; {
 80168ec: b580         	push	{r7, lr}
 80168ee: b092         	sub	sp, #0x48
 80168f0: af00         	add	r7, sp, #0x0
 80168f2: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80169c8 <z_time_slice+0xdc>
 80168f4: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80168f6: f3ef 8311    	mrs	r3, basepri
 80168fa: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 80168fc: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 80168fe: 637b         	str	r3, [r7, #0x34]
 8016900: 2310         	movs	r3, #0x10
 8016902: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016904: 6b3b         	ldr	r3, [r7, #0x30]
 8016906: f383 8812    	msr	basepri_max, r3
; }
 801690a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801690c: f3bf 8f6f    	isb	sy
; }
 8016910: bf00         	nop
; 	return key;
 8016912: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 8016914: 603b         	str	r3, [r7]
 8016916: 6bfb         	ldr	r3, [r7, #0x3c]
 8016918: 62fb         	str	r3, [r7, #0x2c]
; }
 801691a: bf00         	nop
 801691c: 6bfb         	ldr	r3, [r7, #0x3c]
 801691e: 62bb         	str	r3, [r7, #0x28]
; }
 8016920: bf00         	nop
; 	return k;
 8016922: 683b         	ldr	r3, [r7]
 8016924: 60fb         	str	r3, [r7, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8016926: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80169cc <z_time_slice+0xe0>
 8016928: 689b         	ldr	r3, [r3, #0x8]
 801692a: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 801692c: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *curr = arch_current_thread();
 801692e: 647b         	str	r3, [r7, #0x44]
; 	if (pending_current == curr) {
 8016930: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x80169d0 <z_time_slice+0xe4>
 8016932: 681b         	ldr	r3, [r3]
 8016934: 6c7a         	ldr	r2, [r7, #0x44]
 8016936: 429a         	cmp	r2, r3
 8016938: d113         	bne	0x8016962 <z_time_slice+0x76> @ imm = #0x26
; 		z_reset_time_slice(curr);
 801693a: 6c78         	ldr	r0, [r7, #0x44]
 801693c: f7ff ff96    	bl	0x801686c <z_reset_time_slice> @ imm = #-0xd4
 8016940: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80169c8 <z_time_slice+0xdc>
 8016942: 627b         	str	r3, [r7, #0x24]
 8016944: 68fb         	ldr	r3, [r7, #0xc]
 8016946: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 8016948: 687b         	ldr	r3, [r7, #0x4]
 801694a: 623b         	str	r3, [r7, #0x20]
 801694c: 6a3b         	ldr	r3, [r7, #0x20]
 801694e: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016950: 69fb         	ldr	r3, [r7, #0x1c]
 8016952: f383 8811    	msr	basepri, r3
; }
 8016956: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016958: f3bf 8f6f    	isb	sy
; }
 801695c: bf00         	nop
; }
 801695e: bf00         	nop
; }
 8016960: e02f         	b	0x80169c2 <z_time_slice+0xd6> @ imm = #0x5e
; 	pending_current = NULL;
 8016962: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x80169d0 <z_time_slice+0xe4>
 8016964: 2200         	movs	r2, #0x0
 8016966: 601a         	str	r2, [r3]
; 	if (slice_expired[_current_cpu->id] && thread_is_sliceable(curr)) {
 8016968: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80169cc <z_time_slice+0xe0>
 801696a: 7c1b         	ldrb	r3, [r3, #0x10]
 801696c: 461a         	mov	r2, r3
 801696e: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80169d4 <z_time_slice+0xe8>
 8016970: 5c9b         	ldrb	r3, [r3, r2]
 8016972: 2b00         	cmp	r3, #0x0
 8016974: d014         	beq	0x80169a0 <z_time_slice+0xb4> @ imm = #0x28
 8016976: 6c78         	ldr	r0, [r7, #0x44]
 8016978: f7ff ff18    	bl	0x80167ac <thread_is_sliceable> @ imm = #-0x1d0
 801697c: 4603         	mov	r3, r0
 801697e: 2b00         	cmp	r3, #0x0
 8016980: d00e         	beq	0x80169a0 <z_time_slice+0xb4> @ imm = #0x1c
; 		if (!z_is_thread_prevented_from_running(curr)) {
 8016982: 6c78         	ldr	r0, [r7, #0x44]
 8016984: f010 f9de    	bl	0x8026d44 <z_is_thread_prevented_from_running> @ imm = #0x103bc
 8016988: 4603         	mov	r3, r0
 801698a: f083 0301    	eor	r3, r3, #0x1
 801698e: b2db         	uxtb	r3, r3
 8016990: 2b00         	cmp	r3, #0x0
 8016992: d002         	beq	0x801699a <z_time_slice+0xae> @ imm = #0x4
; 			move_thread_to_end_of_prio_q(curr);
 8016994: 6c78         	ldr	r0, [r7, #0x44]
 8016996: f7fe f9dd    	bl	0x8014d54 <move_thread_to_end_of_prio_q> @ imm = #-0x1c46
; 		z_reset_time_slice(curr);
 801699a: 6c78         	ldr	r0, [r7, #0x44]
 801699c: f7ff ff66    	bl	0x801686c <z_reset_time_slice> @ imm = #-0x134
 80169a0: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80169c8 <z_time_slice+0xdc>
 80169a2: 61bb         	str	r3, [r7, #0x18]
 80169a4: 68fb         	ldr	r3, [r7, #0xc]
 80169a6: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 80169a8: 68bb         	ldr	r3, [r7, #0x8]
 80169aa: 617b         	str	r3, [r7, #0x14]
 80169ac: 697b         	ldr	r3, [r7, #0x14]
 80169ae: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80169b0: 693b         	ldr	r3, [r7, #0x10]
 80169b2: f383 8811    	msr	basepri, r3
; }
 80169b6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80169b8: f3bf 8f6f    	isb	sy
; }
 80169bc: bf00         	nop
; }
 80169be: bf00         	nop
; }
 80169c0: bf00         	nop
; }
 80169c2: 3748         	adds	r7, #0x48
 80169c4: 46bd         	mov	sp, r7
 80169c6: bd80         	pop	{r7, pc}

080169c8 <$d>:
 80169c8: ec 32 00 20  	.word	0x200032ec
 80169cc: a8 25 00 20  	.word	0x200025a8
 80169d0: f8 32 00 20  	.word	0x200032f8
 80169d4: f4 32 00 20  	.word	0x200032f4

080169d8 <z_thread_monitor_exit>:
; {
 80169d8: b480         	push	{r7}
 80169da: b091         	sub	sp, #0x44
 80169dc: af00         	add	r7, sp, #0x0
 80169de: 6078         	str	r0, [r7, #0x4]
 80169e0: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8016a90 <z_thread_monitor_exit+0xb8>
 80169e2: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80169e4: f3ef 8311    	mrs	r3, basepri
 80169e8: 637b         	str	r3, [r7, #0x34]
;   return(result);
 80169ea: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 80169ec: 633b         	str	r3, [r7, #0x30]
 80169ee: 2310         	movs	r3, #0x10
 80169f0: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80169f2: 6afb         	ldr	r3, [r7, #0x2c]
 80169f4: f383 8812    	msr	basepri_max, r3
; }
 80169f8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80169fa: f3bf 8f6f    	isb	sy
; }
 80169fe: bf00         	nop
; 	return key;
 8016a00: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 8016a02: 60fb         	str	r3, [r7, #0xc]
 8016a04: 6bbb         	ldr	r3, [r7, #0x38]
 8016a06: 62bb         	str	r3, [r7, #0x28]
; }
 8016a08: bf00         	nop
 8016a0a: 6bbb         	ldr	r3, [r7, #0x38]
 8016a0c: 627b         	str	r3, [r7, #0x24]
; }
 8016a0e: bf00         	nop
; 	return k;
 8016a10: 68fb         	ldr	r3, [r7, #0xc]
 8016a12: 617b         	str	r3, [r7, #0x14]
; 	if (thread == _kernel.threads) {
 8016a14: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8016a94 <z_thread_monitor_exit+0xbc>
 8016a16: 6b1b         	ldr	r3, [r3, #0x30]
 8016a18: 687a         	ldr	r2, [r7, #0x4]
 8016a1a: 429a         	cmp	r2, r3
 8016a1c: d106         	bne	0x8016a2c <z_thread_monitor_exit+0x54> @ imm = #0xc
; 		_kernel.threads = _kernel.threads->next_thread;
 8016a1e: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8016a94 <z_thread_monitor_exit+0xbc>
 8016a20: 6b1b         	ldr	r3, [r3, #0x30]
 8016a22: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 8016a26: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8016a94 <z_thread_monitor_exit+0xbc>
 8016a28: 6313         	str	r3, [r2, #0x30]
 8016a2a: e019         	b	0x8016a60 <z_thread_monitor_exit+0x88> @ imm = #0x32
; 		prev_thread = _kernel.threads;
 8016a2c: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8016a94 <z_thread_monitor_exit+0xbc>
 8016a2e: 6b1b         	ldr	r3, [r3, #0x30]
 8016a30: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 8016a32: e003         	b	0x8016a3c <z_thread_monitor_exit+0x64> @ imm = #0x6
; 			prev_thread = prev_thread->next_thread;
 8016a34: 6bfb         	ldr	r3, [r7, #0x3c]
 8016a36: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 8016a3a: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 8016a3c: 6bfb         	ldr	r3, [r7, #0x3c]
 8016a3e: 2b00         	cmp	r3, #0x0
 8016a40: d005         	beq	0x8016a4e <z_thread_monitor_exit+0x76> @ imm = #0xa
; 			(thread != prev_thread->next_thread)) {
 8016a42: 6bfb         	ldr	r3, [r7, #0x3c]
 8016a44: f8d3 3090    	ldr.w	r3, [r3, #0x90]
; 		while ((prev_thread != NULL) &&
 8016a48: 687a         	ldr	r2, [r7, #0x4]
 8016a4a: 429a         	cmp	r2, r3
 8016a4c: d1f2         	bne	0x8016a34 <z_thread_monitor_exit+0x5c> @ imm = #-0x1c
; 		if (prev_thread != NULL) {
 8016a4e: 6bfb         	ldr	r3, [r7, #0x3c]
 8016a50: 2b00         	cmp	r3, #0x0
 8016a52: d005         	beq	0x8016a60 <z_thread_monitor_exit+0x88> @ imm = #0xa
; 			prev_thread->next_thread = thread->next_thread;
 8016a54: 687b         	ldr	r3, [r7, #0x4]
 8016a56: f8d3 2090    	ldr.w	r2, [r3, #0x90]
 8016a5a: 6bfb         	ldr	r3, [r7, #0x3c]
 8016a5c: f8c3 2090    	str.w	r2, [r3, #0x90]
 8016a60: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8016a90 <z_thread_monitor_exit+0xb8>
 8016a62: 623b         	str	r3, [r7, #0x20]
 8016a64: 697b         	ldr	r3, [r7, #0x14]
 8016a66: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8016a68: 693b         	ldr	r3, [r7, #0x10]
 8016a6a: 61fb         	str	r3, [r7, #0x1c]
 8016a6c: 69fb         	ldr	r3, [r7, #0x1c]
 8016a6e: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016a70: 69bb         	ldr	r3, [r7, #0x18]
 8016a72: f383 8811    	msr	basepri, r3
; }
 8016a76: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016a78: f3bf 8f6f    	isb	sy
; }
 8016a7c: bf00         	nop
; }
 8016a7e: bf00         	nop
; }
 8016a80: bf00         	nop
; }
 8016a82: bf00         	nop
 8016a84: 3744         	adds	r7, #0x44
 8016a86: 46bd         	mov	sp, r7
 8016a88: f85d 7b04    	ldr	r7, [sp], #4
 8016a8c: 4770         	bx	lr
 8016a8e: bf00         	nop

08016a90 <$d>:
 8016a90: fc 32 00 20  	.word	0x200032fc
 8016a94: a8 25 00 20  	.word	0x200025a8

08016a98 <k_thread_foreach_unlocked>:
; {
 8016a98: b580         	push	{r7, lr}
 8016a9a: b09a         	sub	sp, #0x68
 8016a9c: af00         	add	r7, sp, #0x0
 8016a9e: 6078         	str	r0, [r7, #0x4]
 8016aa0: 6039         	str	r1, [r7]
 8016aa2: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8016b74 <k_thread_foreach_unlocked+0xdc>
 8016aa4: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016aa6: f3ef 8311    	mrs	r3, basepri
 8016aaa: 65fb         	str	r3, [r7, #0x5c]
;   return(result);
 8016aac: 6dfb         	ldr	r3, [r7, #0x5c]
; 	key = __get_BASEPRI();
 8016aae: 65bb         	str	r3, [r7, #0x58]
 8016ab0: 2310         	movs	r3, #0x10
 8016ab2: 657b         	str	r3, [r7, #0x54]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016ab4: 6d7b         	ldr	r3, [r7, #0x54]
 8016ab6: f383 8812    	msr	basepri_max, r3
; }
 8016aba: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016abc: f3bf 8f6f    	isb	sy
; }
 8016ac0: bf00         	nop
; 	return key;
 8016ac2: 6dbb         	ldr	r3, [r7, #0x58]
; 	k.key = arch_irq_lock();
 8016ac4: 60bb         	str	r3, [r7, #0x8]
 8016ac6: 6e3b         	ldr	r3, [r7, #0x60]
 8016ac8: 653b         	str	r3, [r7, #0x50]
; }
 8016aca: bf00         	nop
 8016acc: 6e3b         	ldr	r3, [r7, #0x60]
 8016ace: 64fb         	str	r3, [r7, #0x4c]
; }
 8016ad0: bf00         	nop
; 	return k;
 8016ad2: 68bb         	ldr	r3, [r7, #0x8]
 8016ad4: 61bb         	str	r3, [r7, #0x18]
; 	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
 8016ad6: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8016b78 <k_thread_foreach_unlocked+0xe0>
 8016ad8: 6b1b         	ldr	r3, [r3, #0x30]
 8016ada: 667b         	str	r3, [r7, #0x64]
 8016adc: e032         	b	0x8016b44 <k_thread_foreach_unlocked+0xac> @ imm = #0x64
 8016ade: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8016b74 <k_thread_foreach_unlocked+0xdc>
 8016ae0: 633b         	str	r3, [r7, #0x30]
 8016ae2: 69bb         	ldr	r3, [r7, #0x18]
 8016ae4: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8016ae6: 693b         	ldr	r3, [r7, #0x10]
 8016ae8: 62fb         	str	r3, [r7, #0x2c]
 8016aea: 6afb         	ldr	r3, [r7, #0x2c]
 8016aec: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016aee: 6abb         	ldr	r3, [r7, #0x28]
 8016af0: f383 8811    	msr	basepri, r3
; }
 8016af4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016af6: f3bf 8f6f    	isb	sy
; }
 8016afa: bf00         	nop
; }
 8016afc: bf00         	nop
; }
 8016afe: bf00         	nop
; 		user_cb(thread, user_data);
 8016b00: 687b         	ldr	r3, [r7, #0x4]
 8016b02: 6839         	ldr	r1, [r7]
 8016b04: 6e78         	ldr	r0, [r7, #0x64]
 8016b06: 4798         	blx	r3
 8016b08: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8016b74 <k_thread_foreach_unlocked+0xdc>
 8016b0a: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016b0c: f3ef 8311    	mrs	r3, basepri
 8016b10: 647b         	str	r3, [r7, #0x44]
;   return(result);
 8016b12: 6c7b         	ldr	r3, [r7, #0x44]
; 	key = __get_BASEPRI();
 8016b14: 643b         	str	r3, [r7, #0x40]
 8016b16: 2310         	movs	r3, #0x10
 8016b18: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016b1a: 6bfb         	ldr	r3, [r7, #0x3c]
 8016b1c: f383 8812    	msr	basepri_max, r3
; }
 8016b20: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016b22: f3bf 8f6f    	isb	sy
; }
 8016b26: bf00         	nop
; 	return key;
 8016b28: 6c3b         	ldr	r3, [r7, #0x40]
; 	k.key = arch_irq_lock();
 8016b2a: 60fb         	str	r3, [r7, #0xc]
 8016b2c: 6cbb         	ldr	r3, [r7, #0x48]
 8016b2e: 63bb         	str	r3, [r7, #0x38]
; }
 8016b30: bf00         	nop
 8016b32: 6cbb         	ldr	r3, [r7, #0x48]
 8016b34: 637b         	str	r3, [r7, #0x34]
; }
 8016b36: bf00         	nop
; 	return k;
 8016b38: 68fb         	ldr	r3, [r7, #0xc]
 8016b3a: 61bb         	str	r3, [r7, #0x18]
; 	for (thread = _kernel.threads; thread; thread = thread->next_thread) {
 8016b3c: 6e7b         	ldr	r3, [r7, #0x64]
 8016b3e: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 8016b42: 667b         	str	r3, [r7, #0x64]
 8016b44: 6e7b         	ldr	r3, [r7, #0x64]
 8016b46: 2b00         	cmp	r3, #0x0
 8016b48: d1c9         	bne	0x8016ade <k_thread_foreach_unlocked+0x46> @ imm = #-0x6e
 8016b4a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8016b74 <k_thread_foreach_unlocked+0xdc>
 8016b4c: 627b         	str	r3, [r7, #0x24]
 8016b4e: 69bb         	ldr	r3, [r7, #0x18]
 8016b50: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8016b52: 697b         	ldr	r3, [r7, #0x14]
 8016b54: 623b         	str	r3, [r7, #0x20]
 8016b56: 6a3b         	ldr	r3, [r7, #0x20]
 8016b58: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016b5a: 69fb         	ldr	r3, [r7, #0x1c]
 8016b5c: f383 8811    	msr	basepri, r3
; }
 8016b60: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016b62: f3bf 8f6f    	isb	sy
; }
 8016b66: bf00         	nop
; }
 8016b68: bf00         	nop
; }
 8016b6a: bf00         	nop
; }
 8016b6c: bf00         	nop
 8016b6e: 3768         	adds	r7, #0x68
 8016b70: 46bd         	mov	sp, r7
 8016b72: bd80         	pop	{r7, pc}

08016b74 <$d>:
 8016b74: fc 32 00 20  	.word	0x200032fc
 8016b78: a8 25 00 20  	.word	0x200025a8

08016b7c <z_data_copy>:
; {
 8016b7c: b580         	push	{r7, lr}
 8016b7e: af00         	add	r7, sp, #0x0
; 		       __data_region_end - __data_region_start);
 8016b80: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8016ba4 <z_data_copy+0x28>
 8016b82: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8016ba8 <z_data_copy+0x2c>
 8016b84: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__data_region_start, &__data_region_load_start,
 8016b86: 461a         	mov	r2, r3
 8016b88: 4908         	ldr	r1, [pc, #0x20]         @ 0x8016bac <z_data_copy+0x30>
 8016b8a: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8016ba8 <z_data_copy+0x2c>
 8016b8c: f00d fdbb    	bl	0x8024706 <z_early_memcpy> @ imm = #0xdb76
; 		       __ramfunc_end - __ramfunc_region_start);
 8016b90: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8016bb0 <z_data_copy+0x34>
 8016b92: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8016bb4 <z_data_copy+0x38>
 8016b94: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__ramfunc_region_start, &__ramfunc_load_start,
 8016b96: 461a         	mov	r2, r3
 8016b98: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8016bb8 <z_data_copy+0x3c>
 8016b9a: 4806         	ldr	r0, [pc, #0x18]         @ 0x8016bb4 <z_data_copy+0x38>
 8016b9c: f00d fdb3    	bl	0x8024706 <z_early_memcpy> @ imm = #0xdb66
; }
 8016ba0: bf00         	nop
 8016ba2: bd80         	pop	{r7, pc}

08016ba4 <$d>:
 8016ba4: 95 0c 00 20  	.word	0x20000c95
 8016ba8: 00 00 00 20  	.word	0x20000000
 8016bac: 5c c2 02 08  	.word	0x0802c25c
 8016bb0: 00 00 00 20  	.word	0x20000000
 8016bb4: 00 00 00 20  	.word	0x20000000
 8016bb8: 5c c2 02 08  	.word	0x0802c25c

08016bbc <first>:
; {
 8016bbc: b580         	push	{r7, lr}
 8016bbe: b082         	sub	sp, #0x8
 8016bc0: af00         	add	r7, sp, #0x0
; 	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);
 8016bc2: 4804         	ldr	r0, [pc, #0x10]         @ 0x8016bd4 <first+0x18>
 8016bc4: f010 f926    	bl	0x8026e14 <sys_dlist_peek_head> @ imm = #0x1024c
 8016bc8: 6078         	str	r0, [r7, #0x4]
; 	return (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);
 8016bca: 687b         	ldr	r3, [r7, #0x4]
; }
 8016bcc: 4618         	mov	r0, r3
 8016bce: 3708         	adds	r7, #0x8
 8016bd0: 46bd         	mov	sp, r7
 8016bd2: bd80         	pop	{r7, pc}

08016bd4 <$d>:
 8016bd4: 6c 0b 00 20  	.word	0x20000b6c

08016bd8 <next>:
; {
 8016bd8: b580         	push	{r7, lr}
 8016bda: b084         	sub	sp, #0x10
 8016bdc: af00         	add	r7, sp, #0x0
 8016bde: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);
 8016be0: 687b         	ldr	r3, [r7, #0x4]
 8016be2: 4619         	mov	r1, r3
 8016be4: 4804         	ldr	r0, [pc, #0x10]         @ 0x8016bf8 <next+0x20>
 8016be6: f010 f93b    	bl	0x8026e60 <sys_dlist_peek_next> @ imm = #0x10276
 8016bea: 60f8         	str	r0, [r7, #0xc]
; 	return (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);
 8016bec: 68fb         	ldr	r3, [r7, #0xc]
; }
 8016bee: 4618         	mov	r0, r3
 8016bf0: 3710         	adds	r7, #0x10
 8016bf2: 46bd         	mov	sp, r7
 8016bf4: bd80         	pop	{r7, pc}
 8016bf6: bf00         	nop

08016bf8 <$d>:
 8016bf8: 6c 0b 00 20  	.word	0x20000b6c

08016bfc <elapsed>:
; {
 8016bfc: b580         	push	{r7, lr}
 8016bfe: af00         	add	r7, sp, #0x0
; 	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 8016c00: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8016c18 <elapsed+0x1c>
 8016c02: 681b         	ldr	r3, [r3]
 8016c04: 2b00         	cmp	r3, #0x0
 8016c06: d103         	bne	0x8016c10 <elapsed+0x14> @ imm = #0x6
 8016c08: f7f8 fc02    	bl	0x800f410 <sys_clock_elapsed> @ imm = #-0x77fc
 8016c0c: 4603         	mov	r3, r0
 8016c0e: e000         	b	0x8016c12 <elapsed+0x16> @ imm = #0x0
 8016c10: 2300         	movs	r3, #0x0
; }
 8016c12: 4618         	mov	r0, r3
 8016c14: bd80         	pop	{r7, pc}
 8016c16: bf00         	nop

08016c18 <$d>:
 8016c18: fc 32 00 20  	.word	0x200032fc

08016c1c <z_add_timeout>:
; {
 8016c1c: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8016c20: b0a1         	sub	sp, #0x84
 8016c22: af00         	add	r7, sp, #0x0
 8016c24: 6378         	str	r0, [r7, #0x34]
 8016c26: 6339         	str	r1, [r7, #0x30]
 8016c28: e9c7 230a    	strd	r2, r3, [r7, #40]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8016c2c: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 8016c30: f04f 32ff    	mov.w	r2, #0xffffffff
 8016c34: f04f 33ff    	mov.w	r3, #0xffffffff
 8016c38: 4299         	cmp	r1, r3
 8016c3a: bf08         	it	eq
 8016c3c: 4290         	cmpeq	r0, r2
 8016c3e: d100         	bne	0x8016c42 <z_add_timeout+0x26> @ imm = #0x0
 8016c40: e0d4         	b	0x8016dec <z_add_timeout+0x1d0> @ imm = #0x1a8
; 	to->fn = fn;
 8016c42: 6b7a         	ldr	r2, [r7, #0x34]
 8016c44: 6b3b         	ldr	r3, [r7, #0x30]
 8016c46: 6093         	str	r3, [r2, #0x8]
; 	K_SPINLOCK(&timeout_lock) {
 8016c48: 2300         	movs	r3, #0x0
 8016c4a: 64bb         	str	r3, [r7, #0x48]
 8016c4c: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8016df4 <z_add_timeout+0x1d8>
 8016c4e: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016c50: f3ef 8311    	mrs	r3, basepri
 8016c54: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 8016c56: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 8016c58: 667b         	str	r3, [r7, #0x64]
 8016c5a: 2310         	movs	r3, #0x10
 8016c5c: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016c5e: 6e3b         	ldr	r3, [r7, #0x60]
 8016c60: f383 8812    	msr	basepri_max, r3
; }
 8016c64: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016c66: f3bf 8f6f    	isb	sy
; }
 8016c6a: bf00         	nop
; 	return key;
 8016c6c: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 8016c6e: 63fb         	str	r3, [r7, #0x3c]
 8016c70: 6efb         	ldr	r3, [r7, #0x6c]
 8016c72: 65fb         	str	r3, [r7, #0x5c]
; }
 8016c74: bf00         	nop
 8016c76: 6efb         	ldr	r3, [r7, #0x6c]
 8016c78: 65bb         	str	r3, [r7, #0x58]
; }
 8016c7a: bf00         	nop
; 	return k;
 8016c7c: 6bfb         	ldr	r3, [r7, #0x3c]
 8016c7e: 647b         	str	r3, [r7, #0x44]
; 	K_SPINLOCK(&timeout_lock) {
 8016c80: e0b0         	b	0x8016de4 <z_add_timeout+0x1c8> @ imm = #0x160
; 		    (Z_TICK_ABS(timeout.ticks) >= 0)) {
 8016c82: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8016c86: f06f 0001    	mvn	r0, #0x1
 8016c8a: f04f 31ff    	mov.w	r1, #0xffffffff
 8016c8e: 1a80         	subs	r0, r0, r2
 8016c90: 6238         	str	r0, [r7, #0x20]
 8016c92: eb61 0303    	sbc.w	r3, r1, r3
 8016c96: 627b         	str	r3, [r7, #0x24]
; 		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 8016c98: 6a7b         	ldr	r3, [r7, #0x24]
 8016c9a: 2b00         	cmp	r3, #0x0
 8016c9c: db24         	blt	0x8016ce8 <z_add_timeout+0xcc> @ imm = #0x48
; 			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 8016c9e: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8016ca2: 4610         	mov	r0, r2
 8016ca4: 4619         	mov	r1, r3
 8016ca6: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8016df8 <z_add_timeout+0x1dc>
 8016ca8: e9d3 2300    	ldrd	r2, r3, [r3]
 8016cac: 1884         	adds	r4, r0, r2
 8016cae: eb41 0503    	adc.w	r5, r1, r3
 8016cb2: f06f 0201    	mvn	r2, #0x1
 8016cb6: f04f 33ff    	mov.w	r3, #0xffffffff
 8016cba: 1b12         	subs	r2, r2, r4
 8016cbc: 61ba         	str	r2, [r7, #0x18]
 8016cbe: eb63 0305    	sbc.w	r3, r3, r5
 8016cc2: 61fb         	str	r3, [r7, #0x1c]
 8016cc4: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8016cc8: e9c7 231c    	strd	r2, r3, [r7, #112]
; 			to->dticks = MAX(1, ticks);
 8016ccc: e9d7 231c    	ldrd	r2, r3, [r7, #112]
 8016cd0: 2a01         	cmp	r2, #0x1
 8016cd2: f173 0100    	sbcs	r1, r3, #0x0
 8016cd6: da03         	bge	0x8016ce0 <z_add_timeout+0xc4> @ imm = #0x6
 8016cd8: f04f 0201    	mov.w	r2, #0x1
 8016cdc: f04f 0300    	mov.w	r3, #0x0
 8016ce0: 6b79         	ldr	r1, [r7, #0x34]
 8016ce2: e9c1 2304    	strd	r2, r3, [r1, #16]
 8016ce6: e016         	b	0x8016d16 <z_add_timeout+0xfa> @ imm = #0x2c
; 			to->dticks = timeout.ticks + 1 + elapsed();
 8016ce8: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8016cec: f112 0801    	adds.w	r8, r2, #0x1
 8016cf0: f143 0900    	adc	r9, r3, #0x0
 8016cf4: f7ff ff82    	bl	0x8016bfc <elapsed>     @ imm = #-0xfc
 8016cf8: 4603         	mov	r3, r0
 8016cfa: 17da         	asrs	r2, r3, #0x1f
 8016cfc: 469a         	mov	r10, r3
 8016cfe: 4693         	mov	r11, r2
 8016d00: eb18 030a    	adds.w	r3, r8, r10
 8016d04: 613b         	str	r3, [r7, #0x10]
 8016d06: eb49 030b    	adc.w	r3, r9, r11
 8016d0a: 617b         	str	r3, [r7, #0x14]
 8016d0c: 6b7b         	ldr	r3, [r7, #0x34]
 8016d0e: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 8016d12: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 8016d16: f7ff ff51    	bl	0x8016bbc <first>       @ imm = #-0x15e
 8016d1a: 67f8         	str	r0, [r7, #0x7c]
 8016d1c: e033         	b	0x8016d86 <z_add_timeout+0x16a> @ imm = #0x66
; 			if (t->dticks > to->dticks) {
 8016d1e: 6ffb         	ldr	r3, [r7, #0x7c]
 8016d20: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8016d24: 6b7b         	ldr	r3, [r7, #0x34]
 8016d26: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8016d2a: 4282         	cmp	r2, r0
 8016d2c: 418b         	sbcs	r3, r1
 8016d2e: da16         	bge	0x8016d5e <z_add_timeout+0x142> @ imm = #0x2c
; 				t->dticks -= to->dticks;
 8016d30: 6ffb         	ldr	r3, [r7, #0x7c]
 8016d32: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8016d36: 6b7b         	ldr	r3, [r7, #0x34]
 8016d38: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8016d3c: 1a86         	subs	r6, r0, r2
 8016d3e: 60be         	str	r6, [r7, #0x8]
 8016d40: eb61 0303    	sbc.w	r3, r1, r3
 8016d44: 60fb         	str	r3, [r7, #0xc]
 8016d46: 6ffb         	ldr	r3, [r7, #0x7c]
 8016d48: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 8016d4c: e9c3 1204    	strd	r1, r2, [r3, #16]
; 				sys_dlist_insert(&t->node, &to->node);
 8016d50: 6ffa         	ldr	r2, [r7, #0x7c]
 8016d52: 6b7b         	ldr	r3, [r7, #0x34]
 8016d54: 4619         	mov	r1, r3
 8016d56: 4610         	mov	r0, r2
 8016d58: f010 f8af    	bl	0x8026eba <sys_dlist_insert> @ imm = #0x1015e
; 				break;
 8016d5c: e016         	b	0x8016d8c <z_add_timeout+0x170> @ imm = #0x2c
; 			to->dticks -= t->dticks;
 8016d5e: 6b7b         	ldr	r3, [r7, #0x34]
 8016d60: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8016d64: 6ffb         	ldr	r3, [r7, #0x7c]
 8016d66: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8016d6a: 1a86         	subs	r6, r0, r2
 8016d6c: 603e         	str	r6, [r7]
 8016d6e: eb61 0303    	sbc.w	r3, r1, r3
 8016d72: 607b         	str	r3, [r7, #0x4]
 8016d74: 6b7b         	ldr	r3, [r7, #0x34]
 8016d76: e9d7 1200    	ldrd	r1, r2, [r7]
 8016d7a: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 8016d7e: 6ff8         	ldr	r0, [r7, #0x7c]
 8016d80: f7ff ff2a    	bl	0x8016bd8 <next>        @ imm = #-0x1ac
 8016d84: 67f8         	str	r0, [r7, #0x7c]
 8016d86: 6ffb         	ldr	r3, [r7, #0x7c]
 8016d88: 2b00         	cmp	r3, #0x0
 8016d8a: d1c8         	bne	0x8016d1e <z_add_timeout+0x102> @ imm = #-0x70
; 		if (t == NULL) {
 8016d8c: 6ffb         	ldr	r3, [r7, #0x7c]
 8016d8e: 2b00         	cmp	r3, #0x0
 8016d90: d104         	bne	0x8016d9c <z_add_timeout+0x180> @ imm = #0x8
; 			sys_dlist_append(&timeout_list, &to->node);
 8016d92: 6b7b         	ldr	r3, [r7, #0x34]
 8016d94: 4619         	mov	r1, r3
 8016d96: 4819         	ldr	r0, [pc, #0x64]         @ 0x8016dfc <z_add_timeout+0x1e0>
 8016d98: f010 f875    	bl	0x8026e86 <sys_dlist_append> @ imm = #0x100ea
; 		if (to == first() && announce_remaining == 0) {
 8016d9c: f7ff ff0e    	bl	0x8016bbc <first>       @ imm = #-0x1e4
 8016da0: 4602         	mov	r2, r0
 8016da2: 6b7b         	ldr	r3, [r7, #0x34]
 8016da4: 4293         	cmp	r3, r2
 8016da6: d10a         	bne	0x8016dbe <z_add_timeout+0x1a2> @ imm = #0x14
 8016da8: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8016e00 <z_add_timeout+0x1e4>
 8016daa: 681b         	ldr	r3, [r3]
 8016dac: 2b00         	cmp	r3, #0x0
 8016dae: d106         	bne	0x8016dbe <z_add_timeout+0x1a2> @ imm = #0xc
; 			sys_clock_set_timeout(next_timeout(), false);
 8016db0: f010 f8d4    	bl	0x8026f5c <next_timeout> @ imm = #0x101a8
 8016db4: 4603         	mov	r3, r0
 8016db6: 2100         	movs	r1, #0x0
 8016db8: 4618         	mov	r0, r3
 8016dba: f7f8 fa25    	bl	0x800f208 <sys_clock_set_timeout> @ imm = #-0x7bb6
 8016dbe: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8016df4 <z_add_timeout+0x1d8>
 8016dc0: 657b         	str	r3, [r7, #0x54]
 8016dc2: 6c7b         	ldr	r3, [r7, #0x44]
 8016dc4: 643b         	str	r3, [r7, #0x40]
; 	arch_irq_unlock(key.key);
 8016dc6: 6c3b         	ldr	r3, [r7, #0x40]
 8016dc8: 653b         	str	r3, [r7, #0x50]
 8016dca: 6d3b         	ldr	r3, [r7, #0x50]
 8016dcc: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016dce: 6cfb         	ldr	r3, [r7, #0x4c]
 8016dd0: f383 8811    	msr	basepri, r3
; }
 8016dd4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016dd6: f3bf 8f6f    	isb	sy
; }
 8016dda: bf00         	nop
; }
 8016ddc: bf00         	nop
; }
 8016dde: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 8016de0: 2301         	movs	r3, #0x1
 8016de2: 64bb         	str	r3, [r7, #0x48]
 8016de4: 6cbb         	ldr	r3, [r7, #0x48]
 8016de6: 2b00         	cmp	r3, #0x0
 8016de8: f43f af4b    	beq.w	0x8016c82 <z_add_timeout+0x66> @ imm = #-0x16a
; }
 8016dec: 3784         	adds	r7, #0x84
 8016dee: 46bd         	mov	sp, r7
 8016df0: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}

08016df4 <$d>:
 8016df4: fc 32 00 20  	.word	0x200032fc
 8016df8: 88 2a 00 20  	.word	0x20002a88
 8016dfc: 6c 0b 00 20  	.word	0x20000b6c
 8016e00: fc 32 00 20  	.word	0x200032fc

08016e04 <z_abort_timeout>:
; {
 8016e04: b580         	push	{r7, lr}
 8016e06: b090         	sub	sp, #0x40
 8016e08: af00         	add	r7, sp, #0x0
 8016e0a: 6078         	str	r0, [r7, #0x4]
; 	int ret = -EINVAL;
 8016e0c: f06f 0315    	mvn	r3, #0x15
 8016e10: 63fb         	str	r3, [r7, #0x3c]
; 	K_SPINLOCK(&timeout_lock) {
 8016e12: 2300         	movs	r3, #0x0
 8016e14: 617b         	str	r3, [r7, #0x14]
 8016e16: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8016e9c <z_abort_timeout+0x98>
 8016e18: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016e1a: f3ef 8311    	mrs	r3, basepri
 8016e1e: 637b         	str	r3, [r7, #0x34]
;   return(result);
 8016e20: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 8016e22: 633b         	str	r3, [r7, #0x30]
 8016e24: 2310         	movs	r3, #0x10
 8016e26: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016e28: 6afb         	ldr	r3, [r7, #0x2c]
 8016e2a: f383 8812    	msr	basepri_max, r3
; }
 8016e2e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016e30: f3bf 8f6f    	isb	sy
; }
 8016e34: bf00         	nop
; 	return key;
 8016e36: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 8016e38: 60bb         	str	r3, [r7, #0x8]
 8016e3a: 6bbb         	ldr	r3, [r7, #0x38]
 8016e3c: 62bb         	str	r3, [r7, #0x28]
; }
 8016e3e: bf00         	nop
 8016e40: 6bbb         	ldr	r3, [r7, #0x38]
 8016e42: 627b         	str	r3, [r7, #0x24]
; }
 8016e44: bf00         	nop
; 	return k;
 8016e46: 68bb         	ldr	r3, [r7, #0x8]
 8016e48: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&timeout_lock) {
 8016e4a: e01e         	b	0x8016e8a <z_abort_timeout+0x86> @ imm = #0x3c
; 		if (sys_dnode_is_linked(&to->node)) {
 8016e4c: 687b         	ldr	r3, [r7, #0x4]
 8016e4e: 4618         	mov	r0, r3
 8016e50: f00f ffbd    	bl	0x8026dce <sys_dnode_is_linked> @ imm = #0xff7a
 8016e54: 4603         	mov	r3, r0
 8016e56: 2b00         	cmp	r3, #0x0
 8016e58: d004         	beq	0x8016e64 <z_abort_timeout+0x60> @ imm = #0x8
; 			remove_timeout(to);
 8016e5a: 6878         	ldr	r0, [r7, #0x4]
 8016e5c: f010 f85e    	bl	0x8026f1c <remove_timeout> @ imm = #0x100bc
; 			ret = 0;
 8016e60: 2300         	movs	r3, #0x0
 8016e62: 63fb         	str	r3, [r7, #0x3c]
 8016e64: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8016e9c <z_abort_timeout+0x98>
 8016e66: 623b         	str	r3, [r7, #0x20]
 8016e68: 693b         	ldr	r3, [r7, #0x10]
 8016e6a: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8016e6c: 68fb         	ldr	r3, [r7, #0xc]
 8016e6e: 61fb         	str	r3, [r7, #0x1c]
 8016e70: 69fb         	ldr	r3, [r7, #0x1c]
 8016e72: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016e74: 69bb         	ldr	r3, [r7, #0x18]
 8016e76: f383 8811    	msr	basepri, r3
; }
 8016e7a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016e7c: f3bf 8f6f    	isb	sy
; }
 8016e80: bf00         	nop
; }
 8016e82: bf00         	nop
; }
 8016e84: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 8016e86: 2301         	movs	r3, #0x1
 8016e88: 617b         	str	r3, [r7, #0x14]
 8016e8a: 697b         	ldr	r3, [r7, #0x14]
 8016e8c: 2b00         	cmp	r3, #0x0
 8016e8e: d0dd         	beq	0x8016e4c <z_abort_timeout+0x48> @ imm = #-0x46
; 	return ret;
 8016e90: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 8016e92: 4618         	mov	r0, r3
 8016e94: 3740         	adds	r7, #0x40
 8016e96: 46bd         	mov	sp, r7
 8016e98: bd80         	pop	{r7, pc}
 8016e9a: bf00         	nop

08016e9c <$d>:
 8016e9c: fc 32 00 20  	.word	0x200032fc

08016ea0 <sys_clock_announce>:
; {
 8016ea0: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8016ea4: b0a4         	sub	sp, #0x90
 8016ea6: af00         	add	r7, sp, #0x0
 8016ea8: 6278         	str	r0, [r7, #0x24]
 8016eaa: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8017078 <sys_clock_announce+0x1d8>
 8016eac: f8c7 3084    	str.w	r3, [r7, #0x84]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016eb0: f3ef 8311    	mrs	r3, basepri
 8016eb4: f8c7 3080    	str.w	r3, [r7, #0x80]
;   return(result);
 8016eb8: f8d7 3080    	ldr.w	r3, [r7, #0x80]
; 	key = __get_BASEPRI();
 8016ebc: 67fb         	str	r3, [r7, #0x7c]
 8016ebe: 2310         	movs	r3, #0x10
 8016ec0: 67bb         	str	r3, [r7, #0x78]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016ec2: 6fbb         	ldr	r3, [r7, #0x78]
 8016ec4: f383 8812    	msr	basepri_max, r3
; }
 8016ec8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016eca: f3bf 8f6f    	isb	sy
; }
 8016ece: bf00         	nop
; 	return key;
 8016ed0: 6ffb         	ldr	r3, [r7, #0x7c]
; 	k.key = arch_irq_lock();
 8016ed2: 637b         	str	r3, [r7, #0x34]
 8016ed4: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8016ed8: 677b         	str	r3, [r7, #0x74]
; }
 8016eda: bf00         	nop
 8016edc: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8016ee0: 673b         	str	r3, [r7, #0x70]
; }
 8016ee2: bf00         	nop
; 	return k;
 8016ee4: 6b7b         	ldr	r3, [r7, #0x34]
 8016ee6: 63fb         	str	r3, [r7, #0x3c]
; 	announce_remaining = ticks;
 8016ee8: 4a64         	ldr	r2, [pc, #0x190]        @ 0x801707c <sys_clock_announce+0x1dc>
 8016eea: 6a7b         	ldr	r3, [r7, #0x24]
 8016eec: 6013         	str	r3, [r2]
; 	for (t = first();
 8016eee: f7ff fe65    	bl	0x8016bbc <first>       @ imm = #-0x336
 8016ef2: f8c7 008c    	str.w	r0, [r7, #0x8c]
 8016ef6: e061         	b	0x8016fbc <sys_clock_announce+0x11c> @ imm = #0xc2
; 		int dt = t->dticks;
 8016ef8: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8016efc: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8016f00: 4613         	mov	r3, r2
 8016f02: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		curr_tick += dt;
 8016f06: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8016f0a: 17da         	asrs	r2, r3, #0x1f
 8016f0c: 469a         	mov	r10, r3
 8016f0e: 4693         	mov	r11, r2
 8016f10: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8017080 <sys_clock_announce+0x1e0>
 8016f12: e9d3 2300    	ldrd	r2, r3, [r3]
 8016f16: eb1a 0102    	adds.w	r1, r10, r2
 8016f1a: 6139         	str	r1, [r7, #0x10]
 8016f1c: eb4b 0303    	adc.w	r3, r11, r3
 8016f20: 617b         	str	r3, [r7, #0x14]
 8016f22: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8017080 <sys_clock_announce+0x1e0>
 8016f24: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 8016f28: e9c3 1200    	strd	r1, r2, [r3]
; 		t->dticks = 0;
 8016f2c: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8016f30: f04f 0200    	mov.w	r2, #0x0
 8016f34: f04f 0300    	mov.w	r3, #0x0
 8016f38: e9c1 2304    	strd	r2, r3, [r1, #16]
; 		remove_timeout(t);
 8016f3c: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 8016f40: f00f ffec    	bl	0x8026f1c <remove_timeout> @ imm = #0xffd8
 8016f44: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8017078 <sys_clock_announce+0x1d8>
 8016f46: 657b         	str	r3, [r7, #0x54]
 8016f48: 6bfb         	ldr	r3, [r7, #0x3c]
 8016f4a: 633b         	str	r3, [r7, #0x30]
; 	arch_irq_unlock(key.key);
 8016f4c: 6b3b         	ldr	r3, [r7, #0x30]
 8016f4e: 653b         	str	r3, [r7, #0x50]
 8016f50: 6d3b         	ldr	r3, [r7, #0x50]
 8016f52: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8016f54: 6cfb         	ldr	r3, [r7, #0x4c]
 8016f56: f383 8811    	msr	basepri, r3
; }
 8016f5a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016f5c: f3bf 8f6f    	isb	sy
; }
 8016f60: bf00         	nop
; }
 8016f62: bf00         	nop
; }
 8016f64: bf00         	nop
; 		t->fn(t);
 8016f66: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8016f6a: 689b         	ldr	r3, [r3, #0x8]
 8016f6c: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 8016f70: 4798         	blx	r3
 8016f72: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8017078 <sys_clock_announce+0x1d8>
 8016f74: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8016f76: f3ef 8311    	mrs	r3, basepri
 8016f7a: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 8016f7c: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 8016f7e: 667b         	str	r3, [r7, #0x64]
 8016f80: 2310         	movs	r3, #0x10
 8016f82: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8016f84: 6e3b         	ldr	r3, [r7, #0x60]
 8016f86: f383 8812    	msr	basepri_max, r3
; }
 8016f8a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8016f8c: f3bf 8f6f    	isb	sy
; }
 8016f90: bf00         	nop
; 	return key;
 8016f92: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 8016f94: 62fb         	str	r3, [r7, #0x2c]
 8016f96: 6efb         	ldr	r3, [r7, #0x6c]
 8016f98: 65fb         	str	r3, [r7, #0x5c]
; }
 8016f9a: bf00         	nop
 8016f9c: 6efb         	ldr	r3, [r7, #0x6c]
 8016f9e: 65bb         	str	r3, [r7, #0x58]
; }
 8016fa0: bf00         	nop
; 	return k;
 8016fa2: 6afb         	ldr	r3, [r7, #0x2c]
 8016fa4: 63fb         	str	r3, [r7, #0x3c]
; 		announce_remaining -= dt;
 8016fa6: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x801707c <sys_clock_announce+0x1dc>
 8016fa8: 681a         	ldr	r2, [r3]
 8016faa: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8016fae: 1ad2         	subs	r2, r2, r3
 8016fb0: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x801707c <sys_clock_announce+0x1dc>
 8016fb2: 601a         	str	r2, [r3]
; 	     t = first()) {
 8016fb4: f7ff fe02    	bl	0x8016bbc <first>       @ imm = #-0x3fc
 8016fb8: f8c7 008c    	str.w	r0, [r7, #0x8c]
; 	     (t != NULL) && (t->dticks <= announce_remaining);
 8016fbc: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8016fc0: 2b00         	cmp	r3, #0x0
 8016fc2: d00d         	beq	0x8016fe0 <sys_clock_announce+0x140> @ imm = #0x1a
 8016fc4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8016fc8: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8016fcc: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x801707c <sys_clock_announce+0x1dc>
 8016fce: 681b         	ldr	r3, [r3]
 8016fd0: 17da         	asrs	r2, r3, #0x1f
 8016fd2: 61bb         	str	r3, [r7, #0x18]
 8016fd4: 61fa         	str	r2, [r7, #0x1c]
 8016fd6: 69bb         	ldr	r3, [r7, #0x18]
 8016fd8: 4283         	cmp	r3, r0
 8016fda: 69fb         	ldr	r3, [r7, #0x1c]
 8016fdc: 418b         	sbcs	r3, r1
 8016fde: da8b         	bge	0x8016ef8 <sys_clock_announce+0x58> @ imm = #-0xea
; 	if (t != NULL) {
 8016fe0: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8016fe4: 2b00         	cmp	r3, #0x0
 8016fe6: d014         	beq	0x8017012 <sys_clock_announce+0x172> @ imm = #0x28
; 		t->dticks -= announce_remaining;
 8016fe8: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8016fec: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8016ff0: 4922         	ldr	r1, [pc, #0x88]         @ 0x801707c <sys_clock_announce+0x1dc>
 8016ff2: 6809         	ldr	r1, [r1]
 8016ff4: 17c8         	asrs	r0, r1, #0x1f
 8016ff6: 4688         	mov	r8, r1
 8016ff8: 4681         	mov	r9, r0
 8016ffa: ebb2 0108    	subs.w	r1, r2, r8
 8016ffe: 60b9         	str	r1, [r7, #0x8]
 8017000: eb63 0309    	sbc.w	r3, r3, r9
 8017004: 60fb         	str	r3, [r7, #0xc]
 8017006: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 801700a: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 801700e: e9c3 1204    	strd	r1, r2, [r3, #16]
; 	curr_tick += announce_remaining;
 8017012: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x801707c <sys_clock_announce+0x1dc>
 8017014: 681b         	ldr	r3, [r3]
 8017016: 17da         	asrs	r2, r3, #0x1f
 8017018: 461c         	mov	r4, r3
 801701a: 4615         	mov	r5, r2
 801701c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8017080 <sys_clock_announce+0x1e0>
 801701e: e9d3 2300    	ldrd	r2, r3, [r3]
 8017022: 18a1         	adds	r1, r4, r2
 8017024: 6039         	str	r1, [r7]
 8017026: eb45 0303    	adc.w	r3, r5, r3
 801702a: 607b         	str	r3, [r7, #0x4]
 801702c: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8017080 <sys_clock_announce+0x1e0>
 801702e: e9d7 1200    	ldrd	r1, r2, [r7]
 8017032: e9c3 1200    	strd	r1, r2, [r3]
; 	announce_remaining = 0;
 8017036: 4b11         	ldr	r3, [pc, #0x44]         @ 0x801707c <sys_clock_announce+0x1dc>
 8017038: 2200         	movs	r2, #0x0
 801703a: 601a         	str	r2, [r3]
; 	sys_clock_set_timeout(next_timeout(), false);
 801703c: f00f ff8e    	bl	0x8026f5c <next_timeout> @ imm = #0xff1c
 8017040: 4603         	mov	r3, r0
 8017042: 2100         	movs	r1, #0x0
 8017044: 4618         	mov	r0, r3
 8017046: f7f8 f8df    	bl	0x800f208 <sys_clock_set_timeout> @ imm = #-0x7e42
 801704a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8017078 <sys_clock_announce+0x1d8>
 801704c: 64bb         	str	r3, [r7, #0x48]
 801704e: 6bfb         	ldr	r3, [r7, #0x3c]
 8017050: 63bb         	str	r3, [r7, #0x38]
; 	arch_irq_unlock(key.key);
 8017052: 6bbb         	ldr	r3, [r7, #0x38]
 8017054: 647b         	str	r3, [r7, #0x44]
 8017056: 6c7b         	ldr	r3, [r7, #0x44]
 8017058: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801705a: 6c3b         	ldr	r3, [r7, #0x40]
 801705c: f383 8811    	msr	basepri, r3
; }
 8017060: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017062: f3bf 8f6f    	isb	sy
; }
 8017066: bf00         	nop
; }
 8017068: bf00         	nop
; }
 801706a: bf00         	nop
; 	z_time_slice();
 801706c: f7ff fc3e    	bl	0x80168ec <z_time_slice> @ imm = #-0x784
; }
 8017070: 3790         	adds	r7, #0x90
 8017072: 46bd         	mov	sp, r7
 8017074: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08017078 <$d>:
 8017078: fc 32 00 20  	.word	0x200032fc
 801707c: fc 32 00 20  	.word	0x200032fc
 8017080: 88 2a 00 20  	.word	0x20002a88

08017084 <sys_clock_tick_get>:
; {
 8017084: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8017088: b090         	sub	sp, #0x40
 801708a: af00         	add	r7, sp, #0x0
; 	uint64_t t = 0U;
 801708c: f04f 0200    	mov.w	r2, #0x0
 8017090: f04f 0300    	mov.w	r3, #0x0
 8017094: e9c7 230e    	strd	r2, r3, [r7, #56]
; 	K_SPINLOCK(&timeout_lock) {
 8017098: 2300         	movs	r3, #0x0
 801709a: 613b         	str	r3, [r7, #0x10]
 801709c: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x801712c <sys_clock_tick_get+0xa8>
 801709e: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80170a0: f3ef 8311    	mrs	r3, basepri
 80170a4: 633b         	str	r3, [r7, #0x30]
;   return(result);
 80170a6: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 80170a8: 62fb         	str	r3, [r7, #0x2c]
 80170aa: 2310         	movs	r3, #0x10
 80170ac: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80170ae: 6abb         	ldr	r3, [r7, #0x28]
 80170b0: f383 8812    	msr	basepri_max, r3
; }
 80170b4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80170b6: f3bf 8f6f    	isb	sy
; }
 80170ba: bf00         	nop
; 	return key;
 80170bc: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 80170be: 607b         	str	r3, [r7, #0x4]
 80170c0: 6b7b         	ldr	r3, [r7, #0x34]
 80170c2: 627b         	str	r3, [r7, #0x24]
; }
 80170c4: bf00         	nop
 80170c6: 6b7b         	ldr	r3, [r7, #0x34]
 80170c8: 623b         	str	r3, [r7, #0x20]
; }
 80170ca: bf00         	nop
; 	return k;
 80170cc: 687b         	ldr	r3, [r7, #0x4]
 80170ce: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&timeout_lock) {
 80170d0: e021         	b	0x8017116 <sys_clock_tick_get+0x92> @ imm = #0x42
; 		t = curr_tick + elapsed();
 80170d2: f7ff fd93    	bl	0x8016bfc <elapsed>     @ imm = #-0x4da
 80170d6: 4603         	mov	r3, r0
 80170d8: 17da         	asrs	r2, r3, #0x1f
 80170da: 461c         	mov	r4, r3
 80170dc: 4615         	mov	r5, r2
 80170de: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8017130 <sys_clock_tick_get+0xac>
 80170e0: e9d3 2300    	ldrd	r2, r3, [r3]
 80170e4: eb14 0802    	adds.w	r8, r4, r2
 80170e8: eb45 0903    	adc.w	r9, r5, r3
 80170ec: e9c7 890e    	strd	r8, r9, [r7, #56]
 80170f0: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x801712c <sys_clock_tick_get+0xa8>
 80170f2: 61fb         	str	r3, [r7, #0x1c]
 80170f4: 68fb         	ldr	r3, [r7, #0xc]
 80170f6: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 80170f8: 68bb         	ldr	r3, [r7, #0x8]
 80170fa: 61bb         	str	r3, [r7, #0x18]
 80170fc: 69bb         	ldr	r3, [r7, #0x18]
 80170fe: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017100: 697b         	ldr	r3, [r7, #0x14]
 8017102: f383 8811    	msr	basepri, r3
; }
 8017106: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017108: f3bf 8f6f    	isb	sy
; }
 801710c: bf00         	nop
; }
 801710e: bf00         	nop
; }
 8017110: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 8017112: 2301         	movs	r3, #0x1
 8017114: 613b         	str	r3, [r7, #0x10]
 8017116: 693b         	ldr	r3, [r7, #0x10]
 8017118: 2b00         	cmp	r3, #0x0
 801711a: d0da         	beq	0x80170d2 <sys_clock_tick_get+0x4e> @ imm = #-0x4c
; 	return t;
 801711c: e9d7 230e    	ldrd	r2, r3, [r7, #56]
; }
 8017120: 4610         	mov	r0, r2
 8017122: 4619         	mov	r1, r3
 8017124: 3740         	adds	r7, #0x40
 8017126: 46bd         	mov	sp, r7
 8017128: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

0801712c <$d>:
 801712c: fc 32 00 20  	.word	0x200032fc
 8017130: 88 2a 00 20  	.word	0x20002a88

08017134 <z_timer_expiration_handler>:
; {
 8017134: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8017138: b0ae         	sub	sp, #0xb8
 801713a: af00         	add	r7, sp, #0x0
 801713c: 61f8         	str	r0, [r7, #0x1c]
; 	struct k_timer *timer = CONTAINER_OF(t, struct k_timer, timeout);
 801713e: 69fb         	ldr	r3, [r7, #0x1c]
 8017140: f8c7 30b4    	str.w	r3, [r7, #0xb4]
 8017144: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x80173bc <z_timer_expiration_handler+0x288>
 8017146: f8c7 30ac    	str.w	r3, [r7, #0xac]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801714a: f3ef 8311    	mrs	r3, basepri
 801714e: f8c7 30a8    	str.w	r3, [r7, #0xa8]
;   return(result);
 8017152: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
; 	key = __get_BASEPRI();
 8017156: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 801715a: 2310         	movs	r3, #0x10
 801715c: f8c7 30a0    	str.w	r3, [r7, #0xa0]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8017160: f8d7 30a0    	ldr.w	r3, [r7, #0xa0]
 8017164: f383 8812    	msr	basepri_max, r3
; }
 8017168: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801716a: f3bf 8f6f    	isb	sy
; }
 801716e: bf00         	nop
; 	return key;
 8017170: f8d7 30a4    	ldr.w	r3, [r7, #0xa4]
; 	k.key = arch_irq_lock();
 8017174: 62fb         	str	r3, [r7, #0x2c]
 8017176: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 801717a: f8c7 309c    	str.w	r3, [r7, #0x9c]
; }
 801717e: bf00         	nop
 8017180: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 8017184: f8c7 3098    	str.w	r3, [r7, #0x98]
; }
 8017188: bf00         	nop
; 	return k;
 801718a: 6afb         	ldr	r3, [r7, #0x2c]
 801718c: 647b         	str	r3, [r7, #0x44]
; 	if (sys_dnode_is_linked(&t->node)) {
 801718e: 69fb         	ldr	r3, [r7, #0x1c]
 8017190: 4618         	mov	r0, r3
 8017192: f00f ffff    	bl	0x8027194 <sys_dnode_is_linked> @ imm = #0xfffe
 8017196: 4603         	mov	r3, r0
 8017198: 2b00         	cmp	r3, #0x0
 801719a: d016         	beq	0x80171ca <z_timer_expiration_handler+0x96> @ imm = #0x2c
 801719c: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x80173bc <z_timer_expiration_handler+0x288>
 801719e: f8c7 3094    	str.w	r3, [r7, #0x94]
 80171a2: 6c7b         	ldr	r3, [r7, #0x44]
 80171a4: 633b         	str	r3, [r7, #0x30]
; 	arch_irq_unlock(key.key);
 80171a6: 6b3b         	ldr	r3, [r7, #0x30]
 80171a8: f8c7 3090    	str.w	r3, [r7, #0x90]
 80171ac: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 80171b0: f8c7 308c    	str.w	r3, [r7, #0x8c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80171b4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80171b8: f383 8811    	msr	basepri, r3
; }
 80171bc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80171be: f3bf 8f6f    	isb	sy
; }
 80171c2: bf00         	nop
; }
 80171c4: bf00         	nop
; }
 80171c6: bf00         	nop
; 		return;
 80171c8: e0f4         	b	0x80173b4 <z_timer_expiration_handler+0x280> @ imm = #0x1e8
; 	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
 80171ca: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 80171ce: e9d3 010a    	ldrd	r0, r1, [r3, #40]
 80171d2: f04f 0200    	mov.w	r2, #0x0
 80171d6: f04f 0300    	mov.w	r3, #0x0
 80171da: 4299         	cmp	r1, r3
 80171dc: bf08         	it	eq
 80171de: 4290         	cmpeq	r0, r2
 80171e0: d063         	beq	0x80172aa <z_timer_expiration_handler+0x176> @ imm = #0xc6
; 	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
 80171e2: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 80171e6: e9d3 010a    	ldrd	r0, r1, [r3, #40]
 80171ea: f04f 32ff    	mov.w	r2, #0xffffffff
 80171ee: f04f 33ff    	mov.w	r3, #0xffffffff
; 	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
 80171f2: 4299         	cmp	r1, r3
 80171f4: bf08         	it	eq
 80171f6: 4290         	cmpeq	r0, r2
 80171f8: d057         	beq	0x80172aa <z_timer_expiration_handler+0x176> @ imm = #0xae
; 		k_timeout_t next = timer->period;
 80171fa: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 80171fe: e9d3 230a    	ldrd	r2, r3, [r3, #40]
 8017202: e9c7 2308    	strd	r2, r3, [r7, #32]
; 		next.ticks = MAX(next.ticks - 1, 0);
 8017206: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 801720a: 2a01         	cmp	r2, #0x1
 801720c: f173 0100    	sbcs	r1, r3, #0x0
 8017210: da03         	bge	0x801721a <z_timer_expiration_handler+0xe6> @ imm = #0x6
 8017212: f04f 0201    	mov.w	r2, #0x1
 8017216: f04f 0300    	mov.w	r3, #0x0
 801721a: 1e51         	subs	r1, r2, #0x1
 801721c: 6039         	str	r1, [r7]
 801721e: f143 33ff    	adc	r3, r3, #0xffffffff
 8017222: 607b         	str	r3, [r7, #0x4]
 8017224: e9d7 2300    	ldrd	r2, r3, [r7]
 8017228: e9c7 2308    	strd	r2, r3, [r7, #32]
; 		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
 801722c: f00f fff1    	bl	0x8027212 <k_uptime_ticks> @ imm = #0xffe2
 8017230: 4602         	mov	r2, r0
 8017232: 460b         	mov	r3, r1
 8017234: 1c51         	adds	r1, r2, #0x1
 8017236: 6139         	str	r1, [r7, #0x10]
 8017238: f143 0300    	adc	r3, r3, #0x0
 801723c: 617b         	str	r3, [r7, #0x14]
 801723e: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8017242: 6939         	ldr	r1, [r7, #0x10]
 8017244: eb11 0a02    	adds.w	r10, r1, r2
 8017248: 6979         	ldr	r1, [r7, #0x14]
 801724a: eb41 0b03    	adc.w	r11, r1, r3
 801724e: f1ba 0f01    	cmp.w	r10, #0x1
 8017252: f17b 0300    	sbcs	r3, r11, #0x0
 8017256: db17         	blt	0x8017288 <z_timer_expiration_handler+0x154> @ imm = #0x2e
 8017258: f00f ffdb    	bl	0x8027212 <k_uptime_ticks> @ imm = #0xffb6
 801725c: 4602         	mov	r2, r0
 801725e: 460b         	mov	r3, r1
 8017260: f112 0801    	adds.w	r8, r2, #0x1
 8017264: f143 0900    	adc	r9, r3, #0x0
 8017268: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 801726c: eb18 0402    	adds.w	r4, r8, r2
 8017270: eb49 0503    	adc.w	r5, r9, r3
 8017274: f06f 0201    	mvn	r2, #0x1
 8017278: f04f 33ff    	mov.w	r3, #0xffffffff
 801727c: 1b12         	subs	r2, r2, r4
 801727e: 60ba         	str	r2, [r7, #0x8]
 8017280: eb63 0305    	sbc.w	r3, r3, r5
 8017284: 60fb         	str	r3, [r7, #0xc]
 8017286: e005         	b	0x8017294 <z_timer_expiration_handler+0x160> @ imm = #0xa
 8017288: f06f 0301    	mvn	r3, #0x1
 801728c: f04f 34ff    	mov.w	r4, #0xffffffff
 8017290: e9c7 3402    	strd	r3, r4, [r7, #8]
 8017294: e9d7 3402    	ldrd	r3, r4, [r7, #8]
 8017298: e9c7 3408    	strd	r3, r4, [r7, #32]
; 		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 801729c: f8d7 00b4    	ldr.w	r0, [r7, #0xb4]
 80172a0: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 80172a4: 4946         	ldr	r1, [pc, #0x118]        @ 0x80173c0 <z_timer_expiration_handler+0x28c>
 80172a6: f7ff fcb9    	bl	0x8016c1c <z_add_timeout> @ imm = #-0x68e
; 	timer->status += 1U;
 80172aa: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 80172ae: 6b1b         	ldr	r3, [r3, #0x30]
 80172b0: 1c5a         	adds	r2, r3, #0x1
 80172b2: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 80172b6: 631a         	str	r2, [r3, #0x30]
; 	if (timer->expiry_fn != NULL) {
 80172b8: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 80172bc: 6a1b         	ldr	r3, [r3, #0x20]
 80172be: 2b00         	cmp	r3, #0x0
 80172c0: d037         	beq	0x8017332 <z_timer_expiration_handler+0x1fe> @ imm = #0x6e
 80172c2: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x80173bc <z_timer_expiration_handler+0x288>
 80172c4: 673b         	str	r3, [r7, #0x70]
 80172c6: 6c7b         	ldr	r3, [r7, #0x44]
 80172c8: 63bb         	str	r3, [r7, #0x38]
; 	arch_irq_unlock(key.key);
 80172ca: 6bbb         	ldr	r3, [r7, #0x38]
 80172cc: 66fb         	str	r3, [r7, #0x6c]
 80172ce: 6efb         	ldr	r3, [r7, #0x6c]
 80172d0: 66bb         	str	r3, [r7, #0x68]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80172d2: 6ebb         	ldr	r3, [r7, #0x68]
 80172d4: f383 8811    	msr	basepri, r3
; }
 80172d8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80172da: f3bf 8f6f    	isb	sy
; }
 80172de: bf00         	nop
; }
 80172e0: bf00         	nop
; }
 80172e2: bf00         	nop
; 		timer->expiry_fn(timer);
 80172e4: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 80172e8: 6a1b         	ldr	r3, [r3, #0x20]
 80172ea: f8d7 00b4    	ldr.w	r0, [r7, #0xb4]
 80172ee: 4798         	blx	r3
 80172f0: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x80173bc <z_timer_expiration_handler+0x288>
 80172f2: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80172f6: f3ef 8311    	mrs	r3, basepri
 80172fa: f8c7 3084    	str.w	r3, [r7, #0x84]
;   return(result);
 80172fe: f8d7 3084    	ldr.w	r3, [r7, #0x84]
; 	key = __get_BASEPRI();
 8017302: f8c7 3080    	str.w	r3, [r7, #0x80]
 8017306: 2310         	movs	r3, #0x10
 8017308: 67fb         	str	r3, [r7, #0x7c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801730a: 6ffb         	ldr	r3, [r7, #0x7c]
 801730c: f383 8812    	msr	basepri_max, r3
; }
 8017310: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017312: f3bf 8f6f    	isb	sy
; }
 8017316: bf00         	nop
; 	return key;
 8017318: f8d7 3080    	ldr.w	r3, [r7, #0x80]
; 	k.key = arch_irq_lock();
 801731c: 637b         	str	r3, [r7, #0x34]
 801731e: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8017322: 67bb         	str	r3, [r7, #0x78]
; }
 8017324: bf00         	nop
 8017326: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 801732a: 677b         	str	r3, [r7, #0x74]
; }
 801732c: bf00         	nop
; 	return k;
 801732e: 6b7b         	ldr	r3, [r7, #0x34]
 8017330: 647b         	str	r3, [r7, #0x44]
; 	thread = z_waitq_head(&timer->wait_q);
 8017332: f8d7 30b4    	ldr.w	r3, [r7, #0xb4]
 8017336: 3318         	adds	r3, #0x18
 8017338: 4618         	mov	r0, r3
 801733a: f00f ffa4    	bl	0x8027286 <z_waitq_head> @ imm = #0xff48
 801733e: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (thread == NULL) {
 8017342: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8017346: 2b00         	cmp	r3, #0x0
 8017348: d111         	bne	0x801736e <z_timer_expiration_handler+0x23a> @ imm = #0x22
 801734a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80173bc <z_timer_expiration_handler+0x288>
 801734c: 667b         	str	r3, [r7, #0x64]
 801734e: 6c7b         	ldr	r3, [r7, #0x44]
 8017350: 63fb         	str	r3, [r7, #0x3c]
; 	arch_irq_unlock(key.key);
 8017352: 6bfb         	ldr	r3, [r7, #0x3c]
 8017354: 663b         	str	r3, [r7, #0x60]
 8017356: 6e3b         	ldr	r3, [r7, #0x60]
 8017358: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801735a: 6dfb         	ldr	r3, [r7, #0x5c]
 801735c: f383 8811    	msr	basepri, r3
; }
 8017360: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017362: f3bf 8f6f    	isb	sy
; }
 8017366: bf00         	nop
; }
 8017368: bf00         	nop
; }
 801736a: bf00         	nop
; 		return;
 801736c: e022         	b	0x80173b4 <z_timer_expiration_handler+0x280> @ imm = #0x44
; 	z_unpend_thread_no_timeout(thread);
 801736e: f8d7 00b0    	ldr.w	r0, [r7, #0xb0]
 8017372: f7fe f9f3    	bl	0x801575c <z_unpend_thread_no_timeout> @ imm = #-0x1c1a
 8017376: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 801737a: 64fb         	str	r3, [r7, #0x4c]
 801737c: 2300         	movs	r3, #0x0
 801737e: 64bb         	str	r3, [r7, #0x48]
; 	thread->arch.swap_return_value = value;
 8017380: 6cfb         	ldr	r3, [r7, #0x4c]
 8017382: 6cba         	ldr	r2, [r7, #0x48]
 8017384: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8017388: bf00         	nop
 801738a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80173bc <z_timer_expiration_handler+0x288>
 801738c: 65bb         	str	r3, [r7, #0x58]
 801738e: 6c7b         	ldr	r3, [r7, #0x44]
 8017390: 643b         	str	r3, [r7, #0x40]
; 	arch_irq_unlock(key.key);
 8017392: 6c3b         	ldr	r3, [r7, #0x40]
 8017394: 657b         	str	r3, [r7, #0x54]
 8017396: 6d7b         	ldr	r3, [r7, #0x54]
 8017398: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801739a: 6d3b         	ldr	r3, [r7, #0x50]
 801739c: f383 8811    	msr	basepri, r3
; }
 80173a0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80173a2: f3bf 8f6f    	isb	sy
; }
 80173a6: bf00         	nop
; }
 80173a8: bf00         	nop
; }
 80173aa: bf00         	nop
; 	z_ready_thread(thread);
 80173ac: f8d7 00b0    	ldr.w	r0, [r7, #0xb0]
 80173b0: f7fd fe94    	bl	0x80150dc <z_ready_thread> @ imm = #-0x22d8
; }
 80173b4: 37b8         	adds	r7, #0xb8
 80173b6: 46bd         	mov	sp, r7
 80173b8: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080173bc <$d>:
 80173bc: 00 33 00 20  	.word	0x20003300
 80173c0: 35 71 01 08  	.word	0x08017135

080173c4 <z_impl_k_timer_start>:
; {
 80173c4: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 80173c8: b094         	sub	sp, #0x50
 80173ca: af00         	add	r7, sp, #0x0
 80173cc: 60f8         	str	r0, [r7, #0xc]
 80173ce: e9c7 2300    	strd	r2, r3, [r7]
 80173d2: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x80174c4 <z_impl_k_timer_start+0x100>
 80173d4: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80173d6: f3ef 8311    	mrs	r3, basepri
 80173da: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 80173dc: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 80173de: 647b         	str	r3, [r7, #0x44]
 80173e0: 2310         	movs	r3, #0x10
 80173e2: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80173e4: 6c3b         	ldr	r3, [r7, #0x40]
 80173e6: f383 8812    	msr	basepri_max, r3
; }
 80173ea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80173ec: f3bf 8f6f    	isb	sy
; }
 80173f0: bf00         	nop
; 	return key;
 80173f2: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 80173f4: 617b         	str	r3, [r7, #0x14]
 80173f6: 6cfb         	ldr	r3, [r7, #0x4c]
 80173f8: 63fb         	str	r3, [r7, #0x3c]
; }
 80173fa: bf00         	nop
 80173fc: 6cfb         	ldr	r3, [r7, #0x4c]
 80173fe: 63bb         	str	r3, [r7, #0x38]
; }
 8017400: bf00         	nop
; 	return k;
 8017402: 697b         	ldr	r3, [r7, #0x14]
 8017404: 61fb         	str	r3, [r7, #0x1c]
; 	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
 8017406: e9d7 2300    	ldrd	r2, r3, [r7]
 801740a: f04f 30ff    	mov.w	r0, #0xffffffff
 801740e: f04f 31ff    	mov.w	r1, #0xffffffff
 8017412: 428b         	cmp	r3, r1
 8017414: bf08         	it	eq
 8017416: 4282         	cmpeq	r2, r0
 8017418: d111         	bne	0x801743e <z_impl_k_timer_start+0x7a> @ imm = #0x22
 801741a: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80174c4 <z_impl_k_timer_start+0x100>
 801741c: 637b         	str	r3, [r7, #0x34]
 801741e: 69fb         	ldr	r3, [r7, #0x1c]
 8017420: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8017422: 693b         	ldr	r3, [r7, #0x10]
 8017424: 633b         	str	r3, [r7, #0x30]
 8017426: 6b3b         	ldr	r3, [r7, #0x30]
 8017428: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801742a: 6afb         	ldr	r3, [r7, #0x2c]
 801742c: f383 8811    	msr	basepri, r3
; }
 8017430: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017432: f3bf 8f6f    	isb	sy
; }
 8017436: bf00         	nop
; }
 8017438: bf00         	nop
; }
 801743a: bf00         	nop
 801743c: e03e         	b	0x80174bc <z_impl_k_timer_start+0xf8> @ imm = #0x7c
; 	if (Z_TICK_ABS(duration.ticks) < 0) {
 801743e: e9d7 2300    	ldrd	r2, r3, [r7]
 8017442: f06f 0001    	mvn	r0, #0x1
 8017446: f04f 31ff    	mov.w	r1, #0xffffffff
 801744a: ebb0 0802    	subs.w	r8, r0, r2
 801744e: eb61 0903    	sbc.w	r9, r1, r3
 8017452: f1b9 0f00    	cmp.w	r9, #0x0
 8017456: da0e         	bge	0x8017476 <z_impl_k_timer_start+0xb2> @ imm = #0x1c
; 		duration.ticks = MAX(duration.ticks - 1, 0);
 8017458: e9d7 2300    	ldrd	r2, r3, [r7]
 801745c: 2a01         	cmp	r2, #0x1
 801745e: f173 0100    	sbcs	r1, r3, #0x0
 8017462: da03         	bge	0x801746c <z_impl_k_timer_start+0xa8> @ imm = #0x6
 8017464: f04f 0201    	mov.w	r2, #0x1
 8017468: f04f 0300    	mov.w	r3, #0x0
 801746c: 1e54         	subs	r4, r2, #0x1
 801746e: f143 35ff    	adc	r5, r3, #0xffffffff
 8017472: e9c7 4500    	strd	r4, r5, [r7]
; 	(void)z_abort_timeout(&timer->timeout);
 8017476: 68fb         	ldr	r3, [r7, #0xc]
 8017478: 4618         	mov	r0, r3
 801747a: f7ff fcc3    	bl	0x8016e04 <z_abort_timeout> @ imm = #-0x67a
; 	timer->period = period;
 801747e: 68f9         	ldr	r1, [r7, #0xc]
 8017480: e9d7 231a    	ldrd	r2, r3, [r7, #104]
 8017484: e9c1 230a    	strd	r2, r3, [r1, #40]
; 	timer->status = 0U;
 8017488: 68fb         	ldr	r3, [r7, #0xc]
 801748a: 2200         	movs	r2, #0x0
 801748c: 631a         	str	r2, [r3, #0x30]
; 	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 801748e: 68f8         	ldr	r0, [r7, #0xc]
 8017490: e9d7 2300    	ldrd	r2, r3, [r7]
 8017494: 490c         	ldr	r1, [pc, #0x30]         @ 0x80174c8 <z_impl_k_timer_start+0x104>
 8017496: f7ff fbc1    	bl	0x8016c1c <z_add_timeout> @ imm = #-0x87e
 801749a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80174c4 <z_impl_k_timer_start+0x100>
 801749c: 62bb         	str	r3, [r7, #0x28]
 801749e: 69fb         	ldr	r3, [r7, #0x1c]
 80174a0: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 80174a2: 69bb         	ldr	r3, [r7, #0x18]
 80174a4: 627b         	str	r3, [r7, #0x24]
 80174a6: 6a7b         	ldr	r3, [r7, #0x24]
 80174a8: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80174aa: 6a3b         	ldr	r3, [r7, #0x20]
 80174ac: f383 8811    	msr	basepri, r3
; }
 80174b0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80174b2: f3bf 8f6f    	isb	sy
; }
 80174b6: bf00         	nop
; }
 80174b8: bf00         	nop
; }
 80174ba: bf00         	nop
; }
 80174bc: 3750         	adds	r7, #0x50
 80174be: 46bd         	mov	sp, r7
 80174c0: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

080174c4 <$d>:
 80174c4: 00 33 00 20  	.word	0x20003300
 80174c8: 35 71 01 08  	.word	0x08017135

080174cc <z_sched_usage_start>:
; {
 80174cc: b580         	push	{r7, lr}
 80174ce: b082         	sub	sp, #0x8
 80174d0: af00         	add	r7, sp, #0x0
 80174d2: 6078         	str	r0, [r7, #0x4]
; 	_current_cpu->usage0 = usage_now();
 80174d4: f00f ff40    	bl	0x8027358 <usage_now>   @ imm = #0xfe80
 80174d8: 4603         	mov	r3, r0
 80174da: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80174e8 <z_sched_usage_start+0x1c>
 80174dc: 6193         	str	r3, [r2, #0x18]
; }
 80174de: bf00         	nop
 80174e0: 3708         	adds	r7, #0x8
 80174e2: 46bd         	mov	sp, r7
 80174e4: bd80         	pop	{r7, pc}
 80174e6: bf00         	nop

080174e8 <$d>:
 80174e8: a8 25 00 20  	.word	0x200025a8

080174ec <z_sched_usage_stop>:
; {
 80174ec: b580         	push	{r7, lr}
 80174ee: b090         	sub	sp, #0x40
 80174f0: af00         	add	r7, sp, #0x0
 80174f2: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8017594 <z_sched_usage_stop+0xa8>
 80174f4: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80174f6: f3ef 8311    	mrs	r3, basepri
 80174fa: 62fb         	str	r3, [r7, #0x2c]
;   return(result);
 80174fc: 6afb         	ldr	r3, [r7, #0x2c]
; 	key = __get_BASEPRI();
 80174fe: 62bb         	str	r3, [r7, #0x28]
 8017500: 2310         	movs	r3, #0x10
 8017502: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8017504: 6a7b         	ldr	r3, [r7, #0x24]
 8017506: f383 8812    	msr	basepri_max, r3
; }
 801750a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801750c: f3bf 8f6f    	isb	sy
; }
 8017510: bf00         	nop
; 	return key;
 8017512: 6abb         	ldr	r3, [r7, #0x28]
; 	k.key = arch_irq_lock();
 8017514: 607b         	str	r3, [r7, #0x4]
 8017516: 6b3b         	ldr	r3, [r7, #0x30]
 8017518: 623b         	str	r3, [r7, #0x20]
; }
 801751a: bf00         	nop
 801751c: 6b3b         	ldr	r3, [r7, #0x30]
 801751e: 61fb         	str	r3, [r7, #0x1c]
; }
 8017520: bf00         	nop
; 	return k;
 8017522: 687b         	ldr	r3, [r7, #0x4]
 8017524: 60fb         	str	r3, [r7, #0xc]
; 	struct _cpu     *cpu = _current_cpu;
 8017526: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8017598 <z_sched_usage_stop+0xac>
 8017528: 63fb         	str	r3, [r7, #0x3c]
; 	uint32_t u0 = cpu->usage0;
 801752a: 6bfb         	ldr	r3, [r7, #0x3c]
 801752c: 699b         	ldr	r3, [r3, #0x18]
 801752e: 63bb         	str	r3, [r7, #0x38]
; 	if (u0 != 0) {
 8017530: 6bbb         	ldr	r3, [r7, #0x38]
 8017532: 2b00         	cmp	r3, #0x0
 8017534: d015         	beq	0x8017562 <z_sched_usage_stop+0x76> @ imm = #0x2a
; 		uint32_t cycles = usage_now() - u0;
 8017536: f00f ff0f    	bl	0x8027358 <usage_now>   @ imm = #0xfe1e
 801753a: 4602         	mov	r2, r0
 801753c: 6bbb         	ldr	r3, [r7, #0x38]
 801753e: 1ad3         	subs	r3, r2, r3
 8017540: 637b         	str	r3, [r7, #0x34]
; 		if (cpu->current->base.usage.track_usage) {
 8017542: 6bfb         	ldr	r3, [r7, #0x3c]
 8017544: 689b         	ldr	r3, [r3, #0x8]
 8017546: f893 3038    	ldrb.w	r3, [r3, #0x38]
 801754a: 2b00         	cmp	r3, #0x0
 801754c: d005         	beq	0x801755a <z_sched_usage_stop+0x6e> @ imm = #0xa
; 			sched_thread_update_usage(cpu->current, cycles);
 801754e: 6bfb         	ldr	r3, [r7, #0x3c]
 8017550: 689b         	ldr	r3, [r3, #0x8]
 8017552: 6b79         	ldr	r1, [r7, #0x34]
 8017554: 4618         	mov	r0, r3
 8017556: f00f ff3a    	bl	0x80273ce <sched_thread_update_usage> @ imm = #0xfe74
; 		sched_cpu_update_usage(cpu, cycles);
 801755a: 6b79         	ldr	r1, [r7, #0x34]
 801755c: 6bf8         	ldr	r0, [r7, #0x3c]
 801755e: f00f ff0b    	bl	0x8027378 <sched_cpu_update_usage> @ imm = #0xfe16
; 	cpu->usage0 = 0;
 8017562: 6bfb         	ldr	r3, [r7, #0x3c]
 8017564: 2200         	movs	r2, #0x0
 8017566: 619a         	str	r2, [r3, #0x18]
 8017568: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8017594 <z_sched_usage_stop+0xa8>
 801756a: 61bb         	str	r3, [r7, #0x18]
 801756c: 68fb         	ldr	r3, [r7, #0xc]
 801756e: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8017570: 68bb         	ldr	r3, [r7, #0x8]
 8017572: 617b         	str	r3, [r7, #0x14]
 8017574: 697b         	ldr	r3, [r7, #0x14]
 8017576: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017578: 693b         	ldr	r3, [r7, #0x10]
 801757a: f383 8811    	msr	basepri, r3
; }
 801757e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017580: f3bf 8f6f    	isb	sy
; }
 8017584: bf00         	nop
; }
 8017586: bf00         	nop
; }
 8017588: bf00         	nop
; }
 801758a: bf00         	nop
 801758c: 3740         	adds	r7, #0x40
 801758e: 46bd         	mov	sp, r7
 8017590: bd80         	pop	{r7, pc}
 8017592: bf00         	nop

08017594 <$d>:
 8017594: 00 33 00 20  	.word	0x20003300
 8017598: a8 25 00 20  	.word	0x200025a8

0801759c <z_sched_cpu_usage>:
; {
 801759c: b5b0         	push	{r4, r5, r7, lr}
 801759e: b092         	sub	sp, #0x48
 80175a0: af00         	add	r7, sp, #0x0
 80175a2: 4603         	mov	r3, r0
 80175a4: 6039         	str	r1, [r7]
 80175a6: 71fb         	strb	r3, [r7, #0x7]
 80175a8: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x801768c <z_sched_cpu_usage+0xf0>
 80175aa: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80175ac: f3ef 8311    	mrs	r3, basepri
 80175b0: 637b         	str	r3, [r7, #0x34]
;   return(result);
 80175b2: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 80175b4: 633b         	str	r3, [r7, #0x30]
 80175b6: 2310         	movs	r3, #0x10
 80175b8: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80175ba: 6afb         	ldr	r3, [r7, #0x2c]
 80175bc: f383 8812    	msr	basepri_max, r3
; }
 80175c0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80175c2: f3bf 8f6f    	isb	sy
; }
 80175c6: bf00         	nop
; 	return key;
 80175c8: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 80175ca: 60fb         	str	r3, [r7, #0xc]
 80175cc: 6bbb         	ldr	r3, [r7, #0x38]
 80175ce: 62bb         	str	r3, [r7, #0x28]
; }
 80175d0: bf00         	nop
 80175d2: 6bbb         	ldr	r3, [r7, #0x38]
 80175d4: 627b         	str	r3, [r7, #0x24]
; }
 80175d6: bf00         	nop
; 	return k;
 80175d8: 68fb         	ldr	r3, [r7, #0xc]
 80175da: 617b         	str	r3, [r7, #0x14]
; 	cpu = _current_cpu;
 80175dc: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8017690 <z_sched_cpu_usage+0xf4>
 80175de: 647b         	str	r3, [r7, #0x44]
; 	if (&_kernel.cpus[cpu_id] == cpu) {
 80175e0: 79fb         	ldrb	r3, [r7, #0x7]
 80175e2: 015b         	lsls	r3, r3, #0x5
 80175e4: 4a2a         	ldr	r2, [pc, #0xa8]         @ 0x8017690 <z_sched_cpu_usage+0xf4>
 80175e6: 4413         	add	r3, r2
 80175e8: 6c7a         	ldr	r2, [r7, #0x44]
 80175ea: 429a         	cmp	r2, r3
 80175ec: d11a         	bne	0x8017624 <z_sched_cpu_usage+0x88> @ imm = #0x34
; 		uint32_t  now = usage_now();
 80175ee: f00f feb3    	bl	0x8027358 <usage_now>   @ imm = #0xfd66
 80175f2: 6438         	str	r0, [r7, #0x40]
; 		uint32_t cycles = now - cpu->usage0;
 80175f4: 6c7b         	ldr	r3, [r7, #0x44]
 80175f6: 699b         	ldr	r3, [r3, #0x18]
 80175f8: 6c3a         	ldr	r2, [r7, #0x40]
 80175fa: 1ad3         	subs	r3, r2, r3
 80175fc: 63fb         	str	r3, [r7, #0x3c]
; 		if (cpu->current->base.usage.track_usage) {
 80175fe: 6c7b         	ldr	r3, [r7, #0x44]
 8017600: 689b         	ldr	r3, [r3, #0x8]
 8017602: f893 3038    	ldrb.w	r3, [r3, #0x38]
 8017606: 2b00         	cmp	r3, #0x0
 8017608: d005         	beq	0x8017616 <z_sched_cpu_usage+0x7a> @ imm = #0xa
; 			sched_thread_update_usage(cpu->current, cycles);
 801760a: 6c7b         	ldr	r3, [r7, #0x44]
 801760c: 689b         	ldr	r3, [r3, #0x8]
 801760e: 6bf9         	ldr	r1, [r7, #0x3c]
 8017610: 4618         	mov	r0, r3
 8017612: f00f fedc    	bl	0x80273ce <sched_thread_update_usage> @ imm = #0xfdb8
; 		sched_cpu_update_usage(cpu, cycles);
 8017616: 6bf9         	ldr	r1, [r7, #0x3c]
 8017618: 6c78         	ldr	r0, [r7, #0x44]
 801761a: f00f fead    	bl	0x8027378 <sched_cpu_update_usage> @ imm = #0xfd5a
; 		cpu->usage0 = now;
 801761e: 6c7b         	ldr	r3, [r7, #0x44]
 8017620: 6c3a         	ldr	r2, [r7, #0x40]
 8017622: 619a         	str	r2, [r3, #0x18]
; 	stats->total_cycles     = cpu->usage->total;
 8017624: 6c7b         	ldr	r3, [r7, #0x44]
 8017626: 69db         	ldr	r3, [r3, #0x1c]
 8017628: e9d3 2300    	ldrd	r2, r3, [r3]
 801762c: 6839         	ldr	r1, [r7]
 801762e: e9c1 2302    	strd	r2, r3, [r1, #8]
; 		_kernel.cpus[cpu_id].idle_thread->base.usage.total;
 8017632: 79fb         	ldrb	r3, [r7, #0x7]
 8017634: 4a16         	ldr	r2, [pc, #0x58]         @ 0x8017690 <z_sched_cpu_usage+0xf4>
 8017636: 015b         	lsls	r3, r3, #0x5
 8017638: 4413         	add	r3, r2
 801763a: 330c         	adds	r3, #0xc
 801763c: 681b         	ldr	r3, [r3]
 801763e: e9d3 230c    	ldrd	r2, r3, [r3, #48]
; 	stats->idle_cycles =
 8017642: 6839         	ldr	r1, [r7]
 8017644: e9c1 2304    	strd	r2, r3, [r1, #16]
; 	stats->execution_cycles = stats->total_cycles + stats->idle_cycles;
 8017648: 683b         	ldr	r3, [r7]
 801764a: e9d3 0102    	ldrd	r0, r1, [r3, #8]
 801764e: 683b         	ldr	r3, [r7]
 8017650: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8017654: 1884         	adds	r4, r0, r2
 8017656: eb41 0503    	adc.w	r5, r1, r3
 801765a: 683b         	ldr	r3, [r7]
 801765c: e9c3 4500    	strd	r4, r5, [r3]
 8017660: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x801768c <z_sched_cpu_usage+0xf0>
 8017662: 623b         	str	r3, [r7, #0x20]
 8017664: 697b         	ldr	r3, [r7, #0x14]
 8017666: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8017668: 693b         	ldr	r3, [r7, #0x10]
 801766a: 61fb         	str	r3, [r7, #0x1c]
 801766c: 69fb         	ldr	r3, [r7, #0x1c]
 801766e: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017670: 69bb         	ldr	r3, [r7, #0x18]
 8017672: f383 8811    	msr	basepri, r3
; }
 8017676: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017678: f3bf 8f6f    	isb	sy
; }
 801767c: bf00         	nop
; }
 801767e: bf00         	nop
; }
 8017680: bf00         	nop
; }
 8017682: bf00         	nop
 8017684: 3748         	adds	r7, #0x48
 8017686: 46bd         	mov	sp, r7
 8017688: bdb0         	pop	{r4, r5, r7, pc}
 801768a: bf00         	nop

0801768c <$d>:
 801768c: 00 33 00 20  	.word	0x20003300
 8017690: a8 25 00 20  	.word	0x200025a8

08017694 <z_sched_thread_usage>:
; {
 8017694: b580         	push	{r7, lr}
 8017696: b092         	sub	sp, #0x48
 8017698: af00         	add	r7, sp, #0x0
 801769a: 6078         	str	r0, [r7, #0x4]
 801769c: 6039         	str	r1, [r7]
 801769e: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8017760 <z_sched_thread_usage+0xcc>
 80176a0: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80176a2: f3ef 8311    	mrs	r3, basepri
 80176a6: 637b         	str	r3, [r7, #0x34]
;   return(result);
 80176a8: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 80176aa: 633b         	str	r3, [r7, #0x30]
 80176ac: 2310         	movs	r3, #0x10
 80176ae: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80176b0: 6afb         	ldr	r3, [r7, #0x2c]
 80176b2: f383 8812    	msr	basepri_max, r3
; }
 80176b6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80176b8: f3bf 8f6f    	isb	sy
; }
 80176bc: bf00         	nop
; 	return key;
 80176be: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 80176c0: 60fb         	str	r3, [r7, #0xc]
 80176c2: 6bbb         	ldr	r3, [r7, #0x38]
 80176c4: 62bb         	str	r3, [r7, #0x28]
; }
 80176c6: bf00         	nop
 80176c8: 6bbb         	ldr	r3, [r7, #0x38]
 80176ca: 627b         	str	r3, [r7, #0x24]
; }
 80176cc: bf00         	nop
; 	return k;
 80176ce: 68fb         	ldr	r3, [r7, #0xc]
 80176d0: 617b         	str	r3, [r7, #0x14]
; 	cpu = _current_cpu;
 80176d2: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8017764 <z_sched_thread_usage+0xd0>
 80176d4: 647b         	str	r3, [r7, #0x44]
; 	if (thread == cpu->current) {
 80176d6: 6c7b         	ldr	r3, [r7, #0x44]
 80176d8: 689b         	ldr	r3, [r3, #0x8]
 80176da: 687a         	ldr	r2, [r7, #0x4]
 80176dc: 429a         	cmp	r2, r3
 80176de: d117         	bne	0x8017710 <z_sched_thread_usage+0x7c> @ imm = #0x2e
; 		uint32_t now = usage_now();
 80176e0: f00f fe3a    	bl	0x8027358 <usage_now>   @ imm = #0xfc74
 80176e4: 6438         	str	r0, [r7, #0x40]
; 		uint32_t cycles = now - cpu->usage0;
 80176e6: 6c7b         	ldr	r3, [r7, #0x44]
 80176e8: 699b         	ldr	r3, [r3, #0x18]
 80176ea: 6c3a         	ldr	r2, [r7, #0x40]
 80176ec: 1ad3         	subs	r3, r2, r3
 80176ee: 63fb         	str	r3, [r7, #0x3c]
; 		if (thread->base.usage.track_usage) {
 80176f0: 687b         	ldr	r3, [r7, #0x4]
 80176f2: f893 3038    	ldrb.w	r3, [r3, #0x38]
 80176f6: 2b00         	cmp	r3, #0x0
 80176f8: d003         	beq	0x8017702 <z_sched_thread_usage+0x6e> @ imm = #0x6
; 			sched_thread_update_usage(thread, cycles);
 80176fa: 6bf9         	ldr	r1, [r7, #0x3c]
 80176fc: 6878         	ldr	r0, [r7, #0x4]
 80176fe: f00f fe66    	bl	0x80273ce <sched_thread_update_usage> @ imm = #0xfccc
; 		sched_cpu_update_usage(cpu, cycles);
 8017702: 6bf9         	ldr	r1, [r7, #0x3c]
 8017704: 6c78         	ldr	r0, [r7, #0x44]
 8017706: f00f fe37    	bl	0x8027378 <sched_cpu_update_usage> @ imm = #0xfc6e
; 		cpu->usage0 = now;
 801770a: 6c7b         	ldr	r3, [r7, #0x44]
 801770c: 6c3a         	ldr	r2, [r7, #0x40]
 801770e: 619a         	str	r2, [r3, #0x18]
; 	stats->execution_cycles = thread->base.usage.total;
 8017710: 687b         	ldr	r3, [r7, #0x4]
 8017712: e9d3 230c    	ldrd	r2, r3, [r3, #48]
 8017716: 6839         	ldr	r1, [r7]
 8017718: e9c1 2300    	strd	r2, r3, [r1]
; 	stats->total_cycles     = thread->base.usage.total;
 801771c: 687b         	ldr	r3, [r7, #0x4]
 801771e: e9d3 230c    	ldrd	r2, r3, [r3, #48]
 8017722: 6839         	ldr	r1, [r7]
 8017724: e9c1 2302    	strd	r2, r3, [r1, #8]
; 	stats->idle_cycles = 0;
 8017728: 6839         	ldr	r1, [r7]
 801772a: f04f 0200    	mov.w	r2, #0x0
 801772e: f04f 0300    	mov.w	r3, #0x0
 8017732: e9c1 2304    	strd	r2, r3, [r1, #16]
 8017736: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8017760 <z_sched_thread_usage+0xcc>
 8017738: 623b         	str	r3, [r7, #0x20]
 801773a: 697b         	ldr	r3, [r7, #0x14]
 801773c: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 801773e: 693b         	ldr	r3, [r7, #0x10]
 8017740: 61fb         	str	r3, [r7, #0x1c]
 8017742: 69fb         	ldr	r3, [r7, #0x1c]
 8017744: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017746: 69bb         	ldr	r3, [r7, #0x18]
 8017748: f383 8811    	msr	basepri, r3
; }
 801774c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801774e: f3bf 8f6f    	isb	sy
; }
 8017752: bf00         	nop
; }
 8017754: bf00         	nop
; }
 8017756: bf00         	nop
; }
 8017758: bf00         	nop
 801775a: 3748         	adds	r7, #0x48
 801775c: 46bd         	mov	sp, r7
 801775e: bd80         	pop	{r7, pc}

08017760 <$d>:
 8017760: 00 33 00 20  	.word	0x20003300
 8017764: a8 25 00 20  	.word	0x200025a8

08017768 <k_aligned_alloc>:
; {
 8017768: b580         	push	{r7, lr}
 801776a: b084         	sub	sp, #0x10
 801776c: af00         	add	r7, sp, #0x0
 801776e: 6078         	str	r0, [r7, #0x4]
 8017770: 6039         	str	r1, [r7]
; 	void *ret = z_heap_aligned_alloc(_SYSTEM_HEAP, align, size);
 8017772: 683a         	ldr	r2, [r7]
 8017774: 6879         	ldr	r1, [r7, #0x4]
 8017776: 4804         	ldr	r0, [pc, #0x10]         @ 0x8017788 <k_aligned_alloc+0x20>
 8017778: f00f fe5c    	bl	0x8027434 <z_heap_aligned_alloc> @ imm = #0xfcb8
 801777c: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 801777e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8017780: 4618         	mov	r0, r3
 8017782: 3710         	adds	r7, #0x10
 8017784: 46bd         	mov	sp, r7
 8017786: bd80         	pop	{r7, pc}

08017788 <$d>:
 8017788: 4c 0c 00 20  	.word	0x20000c4c

0801778c <k_thread_system_pool_assign>:
; {
 801778c: b480         	push	{r7}
 801778e: b083         	sub	sp, #0xc
 8017790: af00         	add	r7, sp, #0x0
 8017792: 6078         	str	r0, [r7, #0x4]
; 	thread->resource_pool = _SYSTEM_HEAP;
 8017794: 687b         	ldr	r3, [r7, #0x4]
 8017796: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80177a8 <k_thread_system_pool_assign+0x1c>
 8017798: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; }
 801779c: bf00         	nop
 801779e: 370c         	adds	r7, #0xc
 80177a0: 46bd         	mov	sp, r7
 80177a2: f85d 7b04    	ldr	r7, [sp], #4
 80177a6: 4770         	bx	lr

080177a8 <$d>:
 80177a8: 4c 0c 00 20  	.word	0x20000c4c

080177ac <z_thread_aligned_alloc>:
; {
 80177ac: b580         	push	{r7, lr}
 80177ae: b086         	sub	sp, #0x18
 80177b0: af00         	add	r7, sp, #0x0
 80177b2: 6078         	str	r0, [r7, #0x4]
 80177b4: 6039         	str	r1, [r7]
; 	if (k_is_in_isr()) {
 80177b6: f00e fd11    	bl	0x80261dc <k_is_in_isr> @ imm = #0xea22
 80177ba: 4603         	mov	r3, r0
 80177bc: 2b00         	cmp	r3, #0x0
 80177be: d002         	beq	0x80177c6 <z_thread_aligned_alloc+0x1a> @ imm = #0x4
; 		heap = _SYSTEM_HEAP;
 80177c0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80177f8 <z_thread_aligned_alloc+0x4c>
 80177c2: 613b         	str	r3, [r7, #0x10]
 80177c4: e006         	b	0x80177d4 <z_thread_aligned_alloc+0x28> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80177c6: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80177fc <z_thread_aligned_alloc+0x50>
 80177c8: 689b         	ldr	r3, [r3, #0x8]
 80177ca: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 80177cc: 68fb         	ldr	r3, [r7, #0xc]
; 		heap = arch_current_thread()->resource_pool;
 80177ce: f8d3 30c0    	ldr.w	r3, [r3, #0xc0]
 80177d2: 613b         	str	r3, [r7, #0x10]
; 	if (heap != NULL) {
 80177d4: 693b         	ldr	r3, [r7, #0x10]
 80177d6: 2b00         	cmp	r3, #0x0
 80177d8: d006         	beq	0x80177e8 <z_thread_aligned_alloc+0x3c> @ imm = #0xc
; 		ret = z_heap_aligned_alloc(heap, align, size);
 80177da: 683a         	ldr	r2, [r7]
 80177dc: 6879         	ldr	r1, [r7, #0x4]
 80177de: 6938         	ldr	r0, [r7, #0x10]
 80177e0: f00f fe28    	bl	0x8027434 <z_heap_aligned_alloc> @ imm = #0xfc50
 80177e4: 6178         	str	r0, [r7, #0x14]
 80177e6: e001         	b	0x80177ec <z_thread_aligned_alloc+0x40> @ imm = #0x2
; 		ret = NULL;
 80177e8: 2300         	movs	r3, #0x0
 80177ea: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 80177ec: 697b         	ldr	r3, [r7, #0x14]
; }
 80177ee: 4618         	mov	r0, r3
 80177f0: 3718         	adds	r7, #0x18
 80177f2: 46bd         	mov	sp, r7
 80177f4: bd80         	pop	{r7, pc}
 80177f6: bf00         	nop

080177f8 <$d>:
 80177f8: 4c 0c 00 20  	.word	0x20000c4c
 80177fc: a8 25 00 20  	.word	0x200025a8

08017800 <boot_banner>:
; {
 8017800: b580         	push	{r7, lr}
 8017802: af00         	add	r7, sp, #0x0
; 	printk("*** " CONFIG_BOOT_BANNER_STRING " " BANNER_VERSION BANNER_POSTFIX " ***\n");
 8017804: 4802         	ldr	r0, [pc, #0x8]          @ 0x8017810 <boot_banner+0x10>
 8017806: f003 fdc4    	bl	0x801b392 <printk>      @ imm = #0x3b88
; }
 801780a: bf00         	nop
 801780c: bd80         	pop	{r7, pc}
 801780e: bf00         	nop

08017810 <$d>:
 8017810: 18 a4 02 08  	.word	0x0802a418

08017814 <snprintf>:
 8017814: b40c         	push	{r2, r3}
 8017816: b530         	push	{r4, r5, lr}
 8017818: b089         	sub	sp, #0x24
 801781a: 4605         	mov	r5, r0
 801781c: 460c         	mov	r4, r1
 801781e: 221c         	movs	r2, #0x1c
 8017820: 2100         	movs	r1, #0x0
 8017822: a801         	add	r0, sp, #0x4
 8017824: f00f fe70    	bl	0x8027508 <memset>      @ imm = #0xfce0
 8017828: 2302         	movs	r3, #0x2
 801782a: f88d 3006    	strb.w	r3, [sp, #0x6]
 801782e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8017868 <snprintf+0x54>
 8017830: 9302         	str	r3, [sp, #0x8]
 8017832: 9505         	str	r5, [sp, #0x14]
 8017834: 4623         	mov	r3, r4
 8017836: b12c         	cbz	r4, 0x8017844 <snprintf+0x30> @ imm = #0xa
 8017838: f1b4 4f00    	cmp.w	r4, #0x80000000
 801783c: bf28         	it	hs
 801783e: f04f 4300    	movhs.w	r3, #0x80000000
 8017842: 3b01         	subs	r3, #0x1
 8017844: 441d         	add	r5, r3
 8017846: aa0d         	add	r2, sp, #0x34
 8017848: 990c         	ldr	r1, [sp, #0x30]
 801784a: 9506         	str	r5, [sp, #0x18]
 801784c: a801         	add	r0, sp, #0x4
 801784e: 9200         	str	r2, [sp]
 8017850: f000 f8a8    	bl	0x80179a4 <vfprintf>    @ imm = #0x150
 8017854: b114         	cbz	r4, 0x801785c <snprintf+0x48> @ imm = #0x4
 8017856: 9b05         	ldr	r3, [sp, #0x14]
 8017858: 2200         	movs	r2, #0x0
 801785a: 701a         	strb	r2, [r3]
 801785c: b009         	add	sp, #0x24
 801785e: e8bd 4030    	pop.w	{r4, r5, lr}
 8017862: b002         	add	sp, #0x8
 8017864: 4770         	bx	lr
 8017866: bf00         	nop

08017868 <$d>:
 8017868: bd 78 02 08  	.word	0x080278bd

0801786c <skip_to_arg>:
 801786c: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 8017870: 2601         	movs	r6, #0x1
 8017872: 4607         	mov	r7, r0
 8017874: 42b2         	cmp	r2, r6
 8017876: dc01         	bgt	0x801787c <skip_to_arg+0x10> @ imm = #0x2
 8017878: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 801787c: 463b         	mov	r3, r7
 801787e: 461f         	mov	r7, r3
 8017880: f813 4b01    	ldrb	r4, [r3], #1
 8017884: 2c00         	cmp	r4, #0x0
 8017886: d0f7         	beq	0x8017878 <skip_to_arg+0xc> @ imm = #-0x12
 8017888: 2c25         	cmp	r4, #0x25
 801788a: d1f8         	bne	0x801787e <skip_to_arg+0x12> @ imm = #-0x10
 801788c: 781c         	ldrb	r4, [r3]
 801788e: 2c25         	cmp	r4, #0x25
 8017890: f107 0702    	add.w	r7, r7, #0x2
 8017894: d0f2         	beq	0x801787c <skip_to_arg+0x10> @ imm = #-0x1c
 8017896: 2300         	movs	r3, #0x0
 8017898: f8df 8104    	ldr.w	r8, [pc, #0x104]        @ 0x80179a0 <skip_to_arg+0x134>
 801789c: 469c         	mov	r12, r3
 801789e: 461d         	mov	r5, r3
 80178a0: 2d1f         	cmp	r5, #0x1f
 80178a2: d818         	bhi	0x80178d6 <skip_to_arg+0x6a> @ imm = #0x30
 80178a4: f1a4 0e20    	sub.w	lr, r4, #0x20
 80178a8: f1be 0f10    	cmp.w	lr, #0x10
 80178ac: d909         	bls	0x80178c2 <skip_to_arg+0x56> @ imm = #0x12
 80178ae: f1a4 0e30    	sub.w	lr, r4, #0x30
 80178b2: f1be 0f09    	cmp.w	lr, #0x9
 80178b6: d81e         	bhi	0x80178f6 <skip_to_arg+0x8a> @ imm = #0x3c
 80178b8: 240a         	movs	r4, #0xa
 80178ba: fb04 e303    	mla	r3, r4, r3, lr
 80178be: 2520         	movs	r5, #0x20
 80178c0: e004         	b	0x80178cc <skip_to_arg+0x60> @ imm = #0x8
 80178c2: fa28 fe0e    	lsr.w	lr, r8, lr
 80178c6: f01e 0f01    	tst.w	lr, #0x1
 80178ca: d006         	beq	0x80178da <skip_to_arg+0x6e> @ imm = #0xc
 80178cc: f817 4b01    	ldrb	r4, [r7], #1
 80178d0: 2c00         	cmp	r4, #0x0
 80178d2: d1e5         	bne	0x80178a0 <skip_to_arg+0x34> @ imm = #-0x36
 80178d4: e028         	b	0x8017928 <skip_to_arg+0xbc> @ imm = #0x50
 80178d6: 2d7f         	cmp	r5, #0x7f
 80178d8: d81c         	bhi	0x8017914 <skip_to_arg+0xa8> @ imm = #0x38
 80178da: f1a4 0e30    	sub.w	lr, r4, #0x30
 80178de: f1be 0f09    	cmp.w	lr, #0x9
 80178e2: d9e9         	bls	0x80178b8 <skip_to_arg+0x4c> @ imm = #-0x2e
 80178e4: 2c24         	cmp	r4, #0x24
 80178e6: d110         	bne	0x801790a <skip_to_arg+0x9e> @ imm = #0x20
 80178e8: f1bc 0f00    	cmp.w	r12, #0x0
 80178ec: d046         	beq	0x801797c <skip_to_arg+0x110> @ imm = #0x8c
 80178ee: 42b3         	cmp	r3, r6
 80178f0: d046         	beq	0x8017980 <skip_to_arg+0x114> @ imm = #0x8c
 80178f2: 2300         	movs	r3, #0x0
 80178f4: e7ea         	b	0x80178cc <skip_to_arg+0x60> @ imm = #-0x2c
 80178f6: f024 0e04    	bic	lr, r4, #0x4
 80178fa: f1be 0f2a    	cmp.w	lr, #0x2a
 80178fe: d0f8         	beq	0x80178f2 <skip_to_arg+0x86> @ imm = #-0x10
 8017900: 2c6c         	cmp	r4, #0x6c
 8017902: d109         	bne	0x8017918 <skip_to_arg+0xac> @ imm = #0x12
 8017904: f045 0580    	orr	r5, r5, #0x80
 8017908: e7e0         	b	0x80178cc <skip_to_arg+0x60> @ imm = #-0x40
 801790a: f024 0e04    	bic	lr, r4, #0x4
 801790e: f1be 0f2a    	cmp.w	lr, #0x2a
 8017912: d0ee         	beq	0x80178f2 <skip_to_arg+0x86> @ imm = #-0x24
 8017914: 2c6c         	cmp	r4, #0x6c
 8017916: d022         	beq	0x801795e <skip_to_arg+0xf2> @ imm = #0x44
 8017918: 2c6c         	cmp	r4, #0x6c
 801791a: d81b         	bhi	0x8017954 <skip_to_arg+0xe8> @ imm = #0x36
 801791c: 2c68         	cmp	r4, #0x68
 801791e: d023         	beq	0x8017968 <skip_to_arg+0xfc> @ imm = #0x46
 8017920: 2c6a         	cmp	r4, #0x6a
 8017922: d028         	beq	0x8017976 <skip_to_arg+0x10a> @ imm = #0x50
 8017924: 2c4c         	cmp	r4, #0x4c
 8017926: d026         	beq	0x8017976 <skip_to_arg+0x10a> @ imm = #0x4c
 8017928: f1bc 0f00    	cmp.w	r12, #0x0
 801792c: d0a4         	beq	0x8017878 <skip_to_arg+0xc> @ imm = #-0xb8
 801792e: 45b4         	cmp	r12, r6
 8017930: d1a0         	bne	0x8017874 <skip_to_arg+0x8> @ imm = #-0xc0
 8017932: f044 0720    	orr	r7, r4, #0x20
 8017936: f1a7 0c65    	sub.w	r12, r7, #0x65
 801793a: f1bc 0f02    	cmp.w	r12, #0x2
 801793e: 680b         	ldr	r3, [r1]
 8017940: d901         	bls	0x8017946 <skip_to_arg+0xda> @ imm = #0x2
 8017942: 2f61         	cmp	r7, #0x61
 8017944: d11e         	bne	0x8017984 <skip_to_arg+0x118> @ imm = #0x3c
 8017946: 3307         	adds	r3, #0x7
 8017948: f023 0307    	bic	r3, r3, #0x7
 801794c: 3308         	adds	r3, #0x8
 801794e: 600b         	str	r3, [r1]
 8017950: 3601         	adds	r6, #0x1
 8017952: e78e         	b	0x8017872 <skip_to_arg+0x6> @ imm = #-0xe4
 8017954: 2c74         	cmp	r4, #0x74
 8017956: d0b9         	beq	0x80178cc <skip_to_arg+0x60> @ imm = #-0x8e
 8017958: 2c7a         	cmp	r4, #0x7a
 801795a: d0b7         	beq	0x80178cc <skip_to_arg+0x60> @ imm = #-0x92
 801795c: e7e4         	b	0x8017928 <skip_to_arg+0xbc> @ imm = #-0x38
 801795e: 062c         	lsls	r4, r5, #0x18
 8017960: bf48         	it	mi
 8017962: f445 7500    	orrmi	r5, r5, #0x200
 8017966: e7cd         	b	0x8017904 <skip_to_arg+0x98> @ imm = #-0x66
 8017968: 05ec         	lsls	r4, r5, #0x17
 801796a: bf48         	it	mi
 801796c: f445 7500    	orrmi	r5, r5, #0x200
 8017970: f445 7580    	orr	r5, r5, #0x100
 8017974: e7aa         	b	0x80178cc <skip_to_arg+0x60> @ imm = #-0xac
 8017976: f445 7520    	orr	r5, r5, #0x280
 801797a: e7a7         	b	0x80178cc <skip_to_arg+0x60> @ imm = #-0xb2
 801797c: 469c         	mov	r12, r3
 801797e: e7b8         	b	0x80178f2 <skip_to_arg+0x86> @ imm = #-0x90
 8017980: 2463         	movs	r4, #0x63
 8017982: e7d6         	b	0x8017932 <skip_to_arg+0xc6> @ imm = #-0x54
 8017984: 2c69         	cmp	r4, #0x69
 8017986: d002         	beq	0x801798e <skip_to_arg+0x122> @ imm = #0x4
 8017988: d807         	bhi	0x801799a <skip_to_arg+0x12e> @ imm = #0xe
 801798a: 2c63         	cmp	r4, #0x63
 801798c: d003         	beq	0x8017996 <skip_to_arg+0x12a> @ imm = #0x6
 801798e: 062f         	lsls	r7, r5, #0x18
 8017990: d501         	bpl	0x8017996 <skip_to_arg+0x12a> @ imm = #0x2
 8017992: 05ac         	lsls	r4, r5, #0x16
 8017994: d4d7         	bmi	0x8017946 <skip_to_arg+0xda> @ imm = #-0x52
 8017996: 3304         	adds	r3, #0x4
 8017998: e7d9         	b	0x801794e <skip_to_arg+0xe2> @ imm = #-0x4e
 801799a: 2c73         	cmp	r4, #0x73
 801799c: e7f6         	b	0x801798c <skip_to_arg+0x120> @ imm = #-0x14
 801799e: bf00         	nop

080179a0 <$d>:
 80179a0: 89 28 01 00  	.word	0x00012889

080179a4 <vfprintf>:
 80179a4: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80179a8: b093         	sub	sp, #0x4c
 80179aa: 6843         	ldr	r3, [r0, #0x4]
 80179ac: 9301         	str	r3, [sp, #0x4]
 80179ae: 7883         	ldrb	r3, [r0, #0x2]
 80179b0: 4680         	mov	r8, r0
 80179b2: 0798         	lsls	r0, r3, #0x1e
 80179b4: e9cd 1206    	strd	r1, r2, [sp, #24]
 80179b8: d517         	bpl	0x80179ea <vfprintf+0x46> @ imm = #0x2e
 80179ba: 920b         	str	r2, [sp, #0x2c]
 80179bc: 460b         	mov	r3, r1
 80179be: 2500         	movs	r5, #0x0
 80179c0: 781f         	ldrb	r7, [r3]
 80179c2: b1a7         	cbz	r7, 0x80179ee <vfprintf+0x4a> @ imm = #0x28
 80179c4: 2f25         	cmp	r7, #0x25
 80179c6: d016         	beq	0x80179f6 <vfprintf+0x52> @ imm = #0x2c
 80179c8: 3301         	adds	r3, #0x1
 80179ca: 9305         	str	r3, [sp, #0x14]
 80179cc: 9b01         	ldr	r3, [sp, #0x4]
 80179ce: 4641         	mov	r1, r8
 80179d0: 4638         	mov	r0, r7
 80179d2: 4798         	blx	r3
 80179d4: 2800         	cmp	r0, #0x0
 80179d6: f105 0501    	add.w	r5, r5, #0x1
 80179da: f280 8435    	bge.w	0x8018248 <vfprintf+0x8a4> @ imm = #0x86a
 80179de: f898 3002    	ldrb.w	r3, [r8, #0x2]
 80179e2: f043 0304    	orr	r3, r3, #0x4
 80179e6: f888 3002    	strb.w	r3, [r8, #0x2]
 80179ea: f04f 35ff    	mov.w	r5, #0xffffffff
 80179ee: 4628         	mov	r0, r5
 80179f0: b013         	add	sp, #0x4c
 80179f2: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80179f6: 785f         	ldrb	r7, [r3, #0x1]
 80179f8: 1c9a         	adds	r2, r3, #0x2
 80179fa: 2f25         	cmp	r7, #0x25
 80179fc: 9205         	str	r2, [sp, #0x14]
 80179fe: d0e5         	beq	0x80179cc <vfprintf+0x28> @ imm = #-0x36
 8017a00: 2400         	movs	r4, #0x0
 8017a02: 4626         	mov	r6, r4
 8017a04: 46a2         	mov	r10, r4
 8017a06: 46a3         	mov	r11, r4
 8017a08: f1bb 0f1f    	cmp.w	r11, #0x1f
 8017a0c: d832         	bhi	0x8017a74 <vfprintf+0xd0> @ imm = #0x64
 8017a0e: f1a7 0320    	sub.w	r3, r7, #0x20
 8017a12: 2b10         	cmp	r3, #0x10
 8017a14: d80a         	bhi	0x8017a2c <vfprintf+0x88> @ imm = #0x14
 8017a16: e8df f003    	tbb	[pc, r3]

08017a1a <$d>:
 8017a1a: 24 09 09 2a  	.word	0x2a090924
 8017a1e: 09 09 09 1b  	.word	0x1b090909
 8017a22: 09 09 09 22  	.word	0x22090909
 8017a26: 09 27 09 09  	.word	0x09092709
 8017a2a: 19           	.byte	0x19

08017a2b <$d>:
 8017a2b: 00           	.byte	0x00

08017a2c <$t>:
 8017a2c: f1a7 0330    	sub.w	r3, r7, #0x30
 8017a30: 2b09         	cmp	r3, #0x9
 8017a32: d92d         	bls	0x8017a90 <vfprintf+0xec> @ imm = #0x5a
 8017a34: 2f2a         	cmp	r7, #0x2a
 8017a36: d139         	bne	0x8017aac <vfprintf+0x108> @ imm = #0x72
 8017a38: b954         	cbnz	r4, 0x8017a50 <vfprintf+0xac> @ imm = #0x14
 8017a3a: 9b0b         	ldr	r3, [sp, #0x2c]
 8017a3c: f01b 0f40    	tst.w	r11, #0x40
 8017a40: f853 2b04    	ldr	r2, [r3], #4
 8017a44: 930b         	str	r3, [sp, #0x2c]
 8017a46: d029         	beq	0x8017a9c <vfprintf+0xf8> @ imm = #0x52
 8017a48: 4616         	mov	r6, r2
 8017a4a: e001         	b	0x8017a50 <vfprintf+0xac> @ imm = #0x2
 8017a4c: f04b 0b01    	orr	r11, r11, #0x1
 8017a50: 9b05         	ldr	r3, [sp, #0x14]
 8017a52: f813 7b01    	ldrb	r7, [r3], #1
 8017a56: 9305         	str	r3, [sp, #0x14]
 8017a58: 2f00         	cmp	r7, #0x0
 8017a5a: d1d5         	bne	0x8017a08 <vfprintf+0x64> @ imm = #-0x56
 8017a5c: e05b         	b	0x8017b16 <vfprintf+0x172> @ imm = #0xb6
 8017a5e: f04b 0b02    	orr	r11, r11, #0x2
 8017a62: f04b 0b04    	orr	r11, r11, #0x4
 8017a66: e7f3         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x1a
 8017a68: f04b 0b08    	orr	r11, r11, #0x8
 8017a6c: e7f0         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x20
 8017a6e: f04b 0b10    	orr	r11, r11, #0x10
 8017a72: e7ed         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x26
 8017a74: f1bb 0f7f    	cmp.w	r11, #0x7f
 8017a78: d83f         	bhi	0x8017afa <vfprintf+0x156> @ imm = #0x7e
 8017a7a: f1a7 0330    	sub.w	r3, r7, #0x30
 8017a7e: 2b09         	cmp	r3, #0x9
 8017a80: d8d8         	bhi	0x8017a34 <vfprintf+0x90> @ imm = #-0x50
 8017a82: f01b 0f40    	tst.w	r11, #0x40
 8017a86: d003         	beq	0x8017a90 <vfprintf+0xec> @ imm = #0x6
 8017a88: 220a         	movs	r2, #0xa
 8017a8a: fb02 3606    	mla	r6, r2, r6, r3
 8017a8e: e7df         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x42
 8017a90: 220a         	movs	r2, #0xa
 8017a92: fb02 3a0a    	mla	r10, r2, r10, r3
 8017a96: f04b 0b20    	orr	r11, r11, #0x20
 8017a9a: e7d9         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x4e
 8017a9c: f1b2 0a00    	subs.w	r10, r2, #0x0
 8017aa0: daf9         	bge	0x8017a96 <vfprintf+0xf2> @ imm = #-0xe
 8017aa2: f1ca 0a00    	rsb.w	r10, r10, #0x0
 8017aa6: f04b 0b28    	orr	r11, r11, #0x28
 8017aaa: e7d1         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x5e
 8017aac: 2f2e         	cmp	r7, #0x2e
 8017aae: d105         	bne	0x8017abc <vfprintf+0x118> @ imm = #0xa
 8017ab0: f01b 0f40    	tst.w	r11, #0x40
 8017ab4: d19b         	bne	0x80179ee <vfprintf+0x4a> @ imm = #-0xca
 8017ab6: f04b 0b40    	orr	r11, r11, #0x40
 8017aba: e7c9         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x6e
 8017abc: 2f24         	cmp	r7, #0x24
 8017abe: d11c         	bne	0x8017afa <vfprintf+0x156> @ imm = #0x38
 8017ac0: 2c00         	cmp	r4, #0x0
 8017ac2: f000 8141    	beq.w	0x8017d48 <vfprintf+0x3a4> @ imm = #0x282
 8017ac6: 9b07         	ldr	r3, [sp, #0x1c]
 8017ac8: 930b         	str	r3, [sp, #0x2c]
 8017aca: f01b 0f40    	tst.w	r11, #0x40
 8017ace: d10a         	bne	0x8017ae6 <vfprintf+0x142> @ imm = #0x14
 8017ad0: 4652         	mov	r2, r10
 8017ad2: 9806         	ldr	r0, [sp, #0x18]
 8017ad4: a90b         	add	r1, sp, #0x2c
 8017ad6: f7ff fec9    	bl	0x801786c <skip_to_arg> @ imm = #-0x26e
 8017ada: 9b0b         	ldr	r3, [sp, #0x2c]
 8017adc: 1d1a         	adds	r2, r3, #0x4
 8017ade: f8d3 a000    	ldr.w	r10, [r3]
 8017ae2: 920b         	str	r2, [sp, #0x2c]
 8017ae4: e7b4         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x98
 8017ae6: 4632         	mov	r2, r6
 8017ae8: 9806         	ldr	r0, [sp, #0x18]
 8017aea: a90b         	add	r1, sp, #0x2c
 8017aec: f7ff febe    	bl	0x801786c <skip_to_arg> @ imm = #-0x284
 8017af0: 9b0b         	ldr	r3, [sp, #0x2c]
 8017af2: 1d1a         	adds	r2, r3, #0x4
 8017af4: 681e         	ldr	r6, [r3]
 8017af6: 920b         	str	r2, [sp, #0x2c]
 8017af8: e7aa         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0xac
 8017afa: 2f6c         	cmp	r7, #0x6c
 8017afc: f000 8111    	beq.w	0x8017d22 <vfprintf+0x37e> @ imm = #0x222
 8017b00: f200 8108    	bhi.w	0x8017d14 <vfprintf+0x370> @ imm = #0x210
 8017b04: 2f68         	cmp	r7, #0x68
 8017b06: f000 8114    	beq.w	0x8017d32 <vfprintf+0x38e> @ imm = #0x228
 8017b0a: 2f6a         	cmp	r7, #0x6a
 8017b0c: f000 8119    	beq.w	0x8017d42 <vfprintf+0x39e> @ imm = #0x232
 8017b10: 2f4c         	cmp	r7, #0x4c
 8017b12: f000 8116    	beq.w	0x8017d42 <vfprintf+0x39e> @ imm = #0x22c
 8017b16: b134         	cbz	r4, 0x8017b26 <vfprintf+0x182> @ imm = #0xc
 8017b18: 9b07         	ldr	r3, [sp, #0x1c]
 8017b1a: 9806         	ldr	r0, [sp, #0x18]
 8017b1c: 930b         	str	r3, [sp, #0x2c]
 8017b1e: 4622         	mov	r2, r4
 8017b20: a90b         	add	r1, sp, #0x2c
 8017b22: f7ff fea3    	bl	0x801786c <skip_to_arg> @ imm = #-0x2ba
 8017b26: 2e00         	cmp	r6, #0x0
 8017b28: f047 0920    	orr	r9, r7, #0x20
 8017b2c: bfb8         	it	lt
 8017b2e: f02b 0b40    	biclt	r11, r11, #0x40
 8017b32: f1a9 0365    	sub.w	r3, r9, #0x65
 8017b36: bfbc         	itt	lt
 8017b38: fa1f fb8b    	uxthlt.w	r11, r11
 8017b3c: 2600         	movlt	r6, #0x0
 8017b3e: 2b02         	cmp	r3, #0x2
 8017b40: f240 8107    	bls.w	0x8017d52 <vfprintf+0x3ae> @ imm = #0x20e
 8017b44: f1b9 0f61    	cmp.w	r9, #0x61
 8017b48: f040 8264    	bne.w	0x8018014 <vfprintf+0x670> @ imm = #0x4c8
 8017b4c: 43ff         	mvns	r7, r7
 8017b4e: f007 0320    	and	r3, r7, #0x20
 8017b52: 9304         	str	r3, [sp, #0x10]
 8017b54: 9b0b         	ldr	r3, [sp, #0x2c]
 8017b56: 3307         	adds	r3, #0x7
 8017b58: f023 0307    	bic	r3, r3, #0x7
 8017b5c: f01b 0f40    	tst.w	r11, #0x40
 8017b60: f103 0208    	add.w	r2, r3, #0x8
 8017b64: bf08         	it	eq
 8017b66: f04f 36ff    	moveq.w	r6, #0xffffffff
 8017b6a: ed93 0b00    	vldr	d0, [r3]
 8017b6e: 920b         	str	r2, [sp, #0x2c]
 8017b70: 4631         	mov	r1, r6
 8017b72: 9a04         	ldr	r2, [sp, #0x10]
 8017b74: a80c         	add	r0, sp, #0x30
 8017b76: f00f fe0a    	bl	0x802778e <__dtox_engine> @ imm = #0xfc14
 8017b7a: 3001         	adds	r0, #0x1
 8017b7c: b2c3         	uxtb	r3, r0
 8017b7e: 42b3         	cmp	r3, r6
 8017b80: f44b 54c0    	orr	r4, r11, #0x1800
 8017b84: 9302         	str	r3, [sp, #0x8]
 8017b86: db01         	blt	0x8017b8c <vfprintf+0x1e8> @ imm = #0x2
 8017b88: 9b02         	ldr	r3, [sp, #0x8]
 8017b8a: 1e5e         	subs	r6, r3, #0x1
 8017b8c: 2301         	movs	r3, #0x1
 8017b8e: 9f0c         	ldr	r7, [sp, #0x30]
 8017b90: 9303         	str	r3, [sp, #0xc]
 8017b92: 46a3         	mov	r11, r4
 8017b94: f04f 0970    	mov.w	r9, #0x70
 8017b98: f107 0309    	add.w	r3, r7, #0x9
 8017b9c: 2b12         	cmp	r3, #0x12
 8017b9e: d90d         	bls	0x8017bbc <vfprintf+0x218> @ imm = #0x1a
 8017ba0: f107 0363    	add.w	r3, r7, #0x63
 8017ba4: 2bc6         	cmp	r3, #0xc6
 8017ba6: f240 810d    	bls.w	0x8017dc4 <vfprintf+0x420> @ imm = #0x21a
 8017baa: f207 33e7    	addw	r3, r7, #0x3e7
 8017bae: f240 72ce    	movw	r2, #0x7ce
 8017bb2: 4293         	cmp	r3, r2
 8017bb4: bf94         	ite	ls
 8017bb6: 2303         	movls	r3, #0x3
 8017bb8: 2304         	movhi	r3, #0x4
 8017bba: 9303         	str	r3, [sp, #0xc]
 8017bbc: f89d 2034    	ldrb.w	r2, [sp, #0x34]
 8017bc0: f002 030c    	and	r3, r2, #0xc
 8017bc4: f012 0201    	ands	r2, r2, #0x1
 8017bc8: f040 8117    	bne.w	0x8017dfa <vfprintf+0x456> @ imm = #0x22e
 8017bcc: f01b 0f02    	tst.w	r11, #0x2
 8017bd0: f040 8110    	bne.w	0x8017df4 <vfprintf+0x450> @ imm = #0x220
 8017bd4: f01b 0404    	ands	r4, r11, #0x4
 8017bd8: f000 80f6    	beq.w	0x8017dc8 <vfprintf+0x424> @ imm = #0x1ec
 8017bdc: 2b00         	cmp	r3, #0x0
 8017bde: f040 810f    	bne.w	0x8017e00 <vfprintf+0x45c> @ imm = #0x21e
 8017be2: 2320         	movs	r3, #0x20
 8017be4: f41b 5f40    	tst.w	r11, #0x3000
 8017be8: d11f         	bne	0x8017c2a <vfprintf+0x286> @ imm = #0x3e
 8017bea: 9a02         	ldr	r2, [sp, #0x8]
 8017bec: 3248         	adds	r2, #0x48
 8017bee: 2e00         	cmp	r6, #0x0
 8017bf0: 446a         	add	r2, sp, r2
 8017bf2: bf08         	it	eq
 8017bf4: 2601         	moveq	r6, #0x1
 8017bf6: 3a13         	subs	r2, #0x13
 8017bf8: 9902         	ldr	r1, [sp, #0x8]
 8017bfa: b121         	cbz	r1, 0x8017c06 <vfprintf+0x262> @ imm = #0x8
 8017bfc: f812 1d01    	ldrb	r1, [r2, #-1]!
 8017c00: 2930         	cmp	r1, #0x30
 8017c02: f000 8134    	beq.w	0x8017e6e <vfprintf+0x4ca> @ imm = #0x268
 8017c06: f01b 0f10    	tst.w	r11, #0x10
 8017c0a: 9a02         	ldr	r2, [sp, #0x8]
 8017c0c: bf18         	it	ne
 8017c0e: 4632         	movne	r2, r6
 8017c10: 1d39         	adds	r1, r7, #0x4
 8017c12: f2c0 8131    	blt.w	0x8017e78 <vfprintf+0x4d4> @ imm = #0x262
 8017c16: 42b7         	cmp	r7, r6
 8017c18: f280 812e    	bge.w	0x8017e78 <vfprintf+0x4d4> @ imm = #0x25c
 8017c1c: 42ba         	cmp	r2, r7
 8017c1e: f44b 5b00    	orr	r11, r11, #0x2000
 8017c22: f340 812b    	ble.w	0x8017e7c <vfprintf+0x4d8> @ imm = #0x256
 8017c26: 1c7e         	adds	r6, r7, #0x1
 8017c28: 1b96         	subs	r6, r2, r6
 8017c2a: f41b 5200    	ands	r2, r11, #0x2000
 8017c2e: 9208         	str	r2, [sp, #0x20]
 8017c30: f000 8126    	beq.w	0x8017e80 <vfprintf+0x4dc> @ imm = #0x24c
 8017c34: ea27 74e7    	bic.w	r4, r7, r7, asr #31
 8017c38: 3401         	adds	r4, #0x1
 8017c3a: b103         	cbz	r3, 0x8017c3e <vfprintf+0x29a> @ imm = #0x0
 8017c3c: 3401         	adds	r4, #0x1
 8017c3e: 2e00         	cmp	r6, #0x0
 8017c40: f000 8126    	beq.w	0x8017e90 <vfprintf+0x4ec> @ imm = #0x24c
 8017c44: 1c72         	adds	r2, r6, #0x1
 8017c46: 4414         	add	r4, r2
 8017c48: 45a2         	cmp	r10, r4
 8017c4a: bfcc         	ite	gt
 8017c4c: ebaa 0404    	subgt.w	r4, r10, r4
 8017c50: 2400         	movle	r4, #0x0
 8017c52: f01b 0f09    	tst.w	r11, #0x9
 8017c56: d104         	bne	0x8017c62 <vfprintf+0x2be> @ imm = #0x8
 8017c58: 442c         	add	r4, r5
 8017c5a: 42a5         	cmp	r5, r4
 8017c5c: f040 811d    	bne.w	0x8017e9a <vfprintf+0x4f6> @ imm = #0x23a
 8017c60: 2400         	movs	r4, #0x0
 8017c62: b143         	cbz	r3, 0x8017c76 <vfprintf+0x2d2> @ imm = #0x10
 8017c64: 4618         	mov	r0, r3
 8017c66: 4641         	mov	r1, r8
 8017c68: 9b01         	ldr	r3, [sp, #0x4]
 8017c6a: 4798         	blx	r3
 8017c6c: 2800         	cmp	r0, #0x0
 8017c6e: f105 0501    	add.w	r5, r5, #0x1
 8017c72: f6ff aeb4    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x298
 8017c76: f41b 6f00    	tst.w	r11, #0x800
 8017c7a: d013         	beq	0x8017ca4 <vfprintf+0x300> @ imm = #0x26
 8017c7c: 9b01         	ldr	r3, [sp, #0x4]
 8017c7e: 4641         	mov	r1, r8
 8017c80: 2030         	movs	r0, #0x30
 8017c82: 4798         	blx	r3
 8017c84: 2800         	cmp	r0, #0x0
 8017c86: f6ff aeaa    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x2ac
 8017c8a: 9b04         	ldr	r3, [sp, #0x10]
 8017c8c: f1c3 0078    	rsb.w	r0, r3, #0x78
 8017c90: 4641         	mov	r1, r8
 8017c92: 9b01         	ldr	r3, [sp, #0x4]
 8017c94: f000 00f8    	and	r0, r0, #0xf8
 8017c98: 4798         	blx	r3
 8017c9a: 2800         	cmp	r0, #0x0
 8017c9c: f105 0502    	add.w	r5, r5, #0x2
 8017ca0: f6ff ae9d    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x2c6
 8017ca4: f01b 0f08    	tst.w	r11, #0x8
 8017ca8: d105         	bne	0x8017cb6 <vfprintf+0x312> @ imm = #0xa
 8017caa: 442c         	add	r4, r5
 8017cac: 42ac         	cmp	r4, r5
 8017cae: f040 8100    	bne.w	0x8017eb2 <vfprintf+0x50e> @ imm = #0x200
 8017cb2: 4625         	mov	r5, r4
 8017cb4: 2400         	movs	r4, #0x0
 8017cb6: 9b08         	ldr	r3, [sp, #0x20]
 8017cb8: 2b00         	cmp	r3, #0x0
 8017cba: f000 811a    	beq.w	0x8017ef2 <vfprintf+0x54e> @ imm = #0x234
 8017cbe: ea27 7ae7    	bic.w	r10, r7, r7, asr #31
 8017cc2: eba7 070a    	sub.w	r7, r7, r10
 8017cc6: 4276         	rsbs	r6, r6, #0
 8017cc8: 9b02         	ldr	r3, [sp, #0x8]
 8017cca: 42bb         	cmp	r3, r7
 8017ccc: bf84         	itt	hi
 8017cce: ab0c         	addhi	r3, sp, #0x30
 8017cd0: 18fb         	addhi	r3, r7, r3
 8017cd2: f10a 3aff    	add.w	r10, r10, #0xffffffff
 8017cd6: bf88         	it	hi
 8017cd8: 7958         	ldrbhi	r0, [r3, #0x5]
 8017cda: 9b01         	ldr	r3, [sp, #0x4]
 8017cdc: bf98         	it	ls
 8017cde: 2030         	movls	r0, #0x30
 8017ce0: 4556         	cmp	r6, r10
 8017ce2: f105 0901    	add.w	r9, r5, #0x1
 8017ce6: 4641         	mov	r1, r8
 8017ce8: f300 80ed    	bgt.w	0x8017ec6 <vfprintf+0x522> @ imm = #0x1da
 8017cec: 4798         	blx	r3
 8017cee: 2800         	cmp	r0, #0x0
 8017cf0: f107 0701    	add.w	r7, r7, #0x1
 8017cf4: f6ff ae73    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x31a
 8017cf8: f1ba 3fff    	cmp.w	r10, #0xffffffff
 8017cfc: d108         	bne	0x8017d10 <vfprintf+0x36c> @ imm = #0x10
 8017cfe: 9b01         	ldr	r3, [sp, #0x4]
 8017d00: 4641         	mov	r1, r8
 8017d02: 202e         	movs	r0, #0x2e
 8017d04: 4798         	blx	r3
 8017d06: 2800         	cmp	r0, #0x0
 8017d08: f6ff ae69    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x32e
 8017d0c: f105 0902    	add.w	r9, r5, #0x2
 8017d10: 464d         	mov	r5, r9
 8017d12: e7d9         	b	0x8017cc8 <vfprintf+0x324> @ imm = #-0x4e
 8017d14: 2f74         	cmp	r7, #0x74
 8017d16: f43f ae9b    	beq.w	0x8017a50 <vfprintf+0xac> @ imm = #-0x2ca
 8017d1a: 2f7a         	cmp	r7, #0x7a
 8017d1c: f43f ae98    	beq.w	0x8017a50 <vfprintf+0xac> @ imm = #-0x2d0
 8017d20: e6f9         	b	0x8017b16 <vfprintf+0x172> @ imm = #-0x20e
 8017d22: f01b 0f80    	tst.w	r11, #0x80
 8017d26: bf18         	it	ne
 8017d28: f44b 7b00    	orrne	r11, r11, #0x200
 8017d2c: f04b 0b80    	orr	r11, r11, #0x80
 8017d30: e68e         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x2e4
 8017d32: f41b 7f80    	tst.w	r11, #0x100
 8017d36: bf18         	it	ne
 8017d38: f44b 7b00    	orrne	r11, r11, #0x200
 8017d3c: f44b 7b80    	orr	r11, r11, #0x100
 8017d40: e686         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x2f4
 8017d42: f44b 7b20    	orr	r11, r11, #0x280
 8017d46: e683         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x2fa
 8017d48: 4626         	mov	r6, r4
 8017d4a: 46b3         	mov	r11, r6
 8017d4c: 4654         	mov	r4, r10
 8017d4e: 46b2         	mov	r10, r6
 8017d50: e67e         	b	0x8017a50 <vfprintf+0xac> @ imm = #-0x304
 8017d52: 43ff         	mvns	r7, r7
 8017d54: f007 0320    	and	r3, r7, #0x20
 8017d58: 9304         	str	r3, [sp, #0x10]
 8017d5a: 9b0b         	ldr	r3, [sp, #0x2c]
 8017d5c: 3307         	adds	r3, #0x7
 8017d5e: f023 0307    	bic	r3, r3, #0x7
 8017d62: f01b 0f40    	tst.w	r11, #0x40
 8017d66: f103 0208    	add.w	r2, r3, #0x8
 8017d6a: bf08         	it	eq
 8017d6c: 2606         	moveq	r6, #0x6
 8017d6e: f1b9 0f65    	cmp.w	r9, #0x65
 8017d72: ed93 0b00    	vldr	d0, [r3]
 8017d76: 920b         	str	r2, [sp, #0x2c]
 8017d78: d111         	bne	0x8017d9e <vfprintf+0x3fa> @ imm = #0x22
 8017d7a: 1c71         	adds	r1, r6, #0x1
 8017d7c: 2200         	movs	r2, #0x0
 8017d7e: b2c9         	uxtb	r1, r1
 8017d80: f44b 5b80    	orr	r11, r11, #0x1000
 8017d84: 4613         	mov	r3, r2
 8017d86: 2911         	cmp	r1, #0x11
 8017d88: bf28         	it	hs
 8017d8a: 2111         	movhs	r1, #0x11
 8017d8c: a80c         	add	r0, sp, #0x30
 8017d8e: f000 fafb    	bl	0x8018388 <__dtoa_engine> @ imm = #0x5f6
 8017d92: b2c3         	uxtb	r3, r0
 8017d94: 9302         	str	r3, [sp, #0x8]
 8017d96: 2302         	movs	r3, #0x2
 8017d98: 9f0c         	ldr	r7, [sp, #0x30]
 8017d9a: 9303         	str	r3, [sp, #0xc]
 8017d9c: e6fc         	b	0x8017b98 <vfprintf+0x1f4> @ imm = #-0x208
 8017d9e: f1b9 0f66    	cmp.w	r9, #0x66
 8017da2: d105         	bne	0x8017db0 <vfprintf+0x40c> @ imm = #0xa
 8017da4: f44b 5b00    	orr	r11, r11, #0x2000
 8017da8: 4633         	mov	r3, r6
 8017daa: 2201         	movs	r2, #0x1
 8017dac: 2111         	movs	r1, #0x11
 8017dae: e7ea         	b	0x8017d86 <vfprintf+0x3e2> @ imm = #-0x2c
 8017db0: b2f1         	uxtb	r1, r6
 8017db2: 2901         	cmp	r1, #0x1
 8017db4: f04f 0200    	mov.w	r2, #0x0
 8017db8: bf38         	it	lo
 8017dba: 2101         	movlo	r1, #0x1
 8017dbc: 4613         	mov	r3, r2
 8017dbe: f04f 0965    	mov.w	r9, #0x65
 8017dc2: e7e0         	b	0x8017d86 <vfprintf+0x3e2> @ imm = #-0x40
 8017dc4: 2302         	movs	r3, #0x2
 8017dc6: e6f8         	b	0x8017bba <vfprintf+0x216> @ imm = #-0x210
 8017dc8: 2b00         	cmp	r3, #0x0
 8017dca: f43f af0b    	beq.w	0x8017be4 <vfprintf+0x240> @ imm = #-0x1ea
 8017dce: f1ba 0f03    	cmp.w	r10, #0x3
 8017dd2: dc3b         	bgt	0x8017e4c <vfprintf+0x4a8> @ imm = #0x76
 8017dd4: f89d 3034    	ldrb.w	r3, [sp, #0x34]
 8017dd8: 4ea5         	ldr	r6, [pc, #0x294]        @ 0x8018070 <vfprintf+0x6cc>
 8017dda: f013 0f08    	tst.w	r3, #0x8
 8017dde: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8018074 <vfprintf+0x6d0>
 8017de0: bf08         	it	eq
 8017de2: 461e         	moveq	r6, r3
 8017de4: 4637         	mov	r7, r6
 8017de6: 46b9         	mov	r9, r7
 8017de8: f817 0b01    	ldrb	r0, [r7], #1
 8017dec: bbb0         	cbnz	r0, 0x8017e5c <vfprintf+0x4b8> @ imm = #0x6c
 8017dee: 1bae         	subs	r6, r5, r6
 8017df0: 44b1         	add	r9, r6
 8017df2: e07b         	b	0x8017eec <vfprintf+0x548> @ imm = #0xf6
 8017df4: bb33         	cbnz	r3, 0x8017e44 <vfprintf+0x4a0> @ imm = #0x4c
 8017df6: 232b         	movs	r3, #0x2b
 8017df8: e6f4         	b	0x8017be4 <vfprintf+0x240> @ imm = #-0x218
 8017dfa: bb2b         	cbnz	r3, 0x8017e48 <vfprintf+0x4a4> @ imm = #0x4a
 8017dfc: 232d         	movs	r3, #0x2d
 8017dfe: e6f1         	b	0x8017be4 <vfprintf+0x240> @ imm = #-0x21e
 8017e00: 2220         	movs	r2, #0x20
 8017e02: f1ba 0f04    	cmp.w	r10, #0x4
 8017e06: dd13         	ble	0x8017e30 <vfprintf+0x48c> @ imm = #0x26
 8017e08: f01b 0f08    	tst.w	r11, #0x8
 8017e0c: f1aa 0404    	sub.w	r4, r10, #0x4
 8017e10: d10f         	bne	0x8017e32 <vfprintf+0x48e> @ imm = #0x1e
 8017e12: 442c         	add	r4, r5
 8017e14: 9b01         	ldr	r3, [sp, #0x4]
 8017e16: 9202         	str	r2, [sp, #0x8]
 8017e18: 4641         	mov	r1, r8
 8017e1a: 2020         	movs	r0, #0x20
 8017e1c: 4798         	blx	r3
 8017e1e: 2800         	cmp	r0, #0x0
 8017e20: f105 0501    	add.w	r5, r5, #0x1
 8017e24: f6ff addb    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x44a
 8017e28: 42a5         	cmp	r5, r4
 8017e2a: 9a02         	ldr	r2, [sp, #0x8]
 8017e2c: d1f2         	bne	0x8017e14 <vfprintf+0x470> @ imm = #-0x1c
 8017e2e: b19a         	cbz	r2, 0x8017e58 <vfprintf+0x4b4> @ imm = #0x26
 8017e30: 2400         	movs	r4, #0x0
 8017e32: 9b01         	ldr	r3, [sp, #0x4]
 8017e34: 4641         	mov	r1, r8
 8017e36: 4610         	mov	r0, r2
 8017e38: 4798         	blx	r3
 8017e3a: 2800         	cmp	r0, #0x0
 8017e3c: f105 0501    	add.w	r5, r5, #0x1
 8017e40: dac8         	bge	0x8017dd4 <vfprintf+0x430> @ imm = #-0x70
 8017e42: e5cc         	b	0x80179de <vfprintf+0x3a> @ imm = #-0x468
 8017e44: 222b         	movs	r2, #0x2b
 8017e46: e7dc         	b	0x8017e02 <vfprintf+0x45e> @ imm = #-0x48
 8017e48: 222d         	movs	r2, #0x2d
 8017e4a: e7da         	b	0x8017e02 <vfprintf+0x45e> @ imm = #-0x4c
 8017e4c: f01b 0f08    	tst.w	r11, #0x8
 8017e50: f1aa 0403    	sub.w	r4, r10, #0x3
 8017e54: d1be         	bne	0x8017dd4 <vfprintf+0x430> @ imm = #-0x84
 8017e56: e7dc         	b	0x8017e12 <vfprintf+0x46e> @ imm = #-0x48
 8017e58: 4614         	mov	r4, r2
 8017e5a: e7bb         	b	0x8017dd4 <vfprintf+0x430> @ imm = #-0x8a
 8017e5c: 9b04         	ldr	r3, [sp, #0x10]
 8017e5e: 1ac0         	subs	r0, r0, r3
 8017e60: 4641         	mov	r1, r8
 8017e62: 9b01         	ldr	r3, [sp, #0x4]
 8017e64: b2c0         	uxtb	r0, r0
 8017e66: 4798         	blx	r3
 8017e68: 2800         	cmp	r0, #0x0
 8017e6a: dabc         	bge	0x8017de6 <vfprintf+0x442> @ imm = #-0x88
 8017e6c: e5b7         	b	0x80179de <vfprintf+0x3a> @ imm = #-0x492
 8017e6e: 9902         	ldr	r1, [sp, #0x8]
 8017e70: 3901         	subs	r1, #0x1
 8017e72: b2c9         	uxtb	r1, r1
 8017e74: 9102         	str	r1, [sp, #0x8]
 8017e76: e6bf         	b	0x8017bf8 <vfprintf+0x254> @ imm = #-0x282
 8017e78: 1e56         	subs	r6, r2, #0x1
 8017e7a: e6d6         	b	0x8017c2a <vfprintf+0x286> @ imm = #-0x254
 8017e7c: 2600         	movs	r6, #0x0
 8017e7e: e6d4         	b	0x8017c2a <vfprintf+0x286> @ imm = #-0x258
 8017e80: f41b 6f00    	tst.w	r11, #0x800
 8017e84: 9a03         	ldr	r2, [sp, #0xc]
 8017e86: bf0c         	ite	eq
 8017e88: 2403         	moveq	r4, #0x3
 8017e8a: 2405         	movne	r4, #0x5
 8017e8c: 4414         	add	r4, r2
 8017e8e: e6d4         	b	0x8017c3a <vfprintf+0x296> @ imm = #-0x258
 8017e90: f01b 0f10    	tst.w	r11, #0x10
 8017e94: bf18         	it	ne
 8017e96: 3401         	addne	r4, #0x1
 8017e98: e6d6         	b	0x8017c48 <vfprintf+0x2a4> @ imm = #-0x254
 8017e9a: 9309         	str	r3, [sp, #0x24]
 8017e9c: 4641         	mov	r1, r8
 8017e9e: 9b01         	ldr	r3, [sp, #0x4]
 8017ea0: 2020         	movs	r0, #0x20
 8017ea2: 4798         	blx	r3
 8017ea4: 2800         	cmp	r0, #0x0
 8017ea6: 9b09         	ldr	r3, [sp, #0x24]
 8017ea8: f105 0501    	add.w	r5, r5, #0x1
 8017eac: f6bf aed5    	bge.w	0x8017c5a <vfprintf+0x2b6> @ imm = #-0x256
 8017eb0: e595         	b	0x80179de <vfprintf+0x3a> @ imm = #-0x4d6
 8017eb2: 9b01         	ldr	r3, [sp, #0x4]
 8017eb4: 4641         	mov	r1, r8
 8017eb6: 2030         	movs	r0, #0x30
 8017eb8: 4798         	blx	r3
 8017eba: 2800         	cmp	r0, #0x0
 8017ebc: f105 0501    	add.w	r5, r5, #0x1
 8017ec0: f6bf aef4    	bge.w	0x8017cac <vfprintf+0x308> @ imm = #-0x218
 8017ec4: e58b         	b	0x80179de <vfprintf+0x3a> @ imm = #-0x4ea
 8017ec6: 4798         	blx	r3
 8017ec8: 2800         	cmp	r0, #0x0
 8017eca: f6ff ad88    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x4f0
 8017ece: f01b 0f10    	tst.w	r11, #0x10
 8017ed2: d00b         	beq	0x8017eec <vfprintf+0x548> @ imm = #0x16
 8017ed4: f1ba 3fff    	cmp.w	r10, #0xffffffff
 8017ed8: d108         	bne	0x8017eec <vfprintf+0x548> @ imm = #0x10
 8017eda: f105 0902    	add.w	r9, r5, #0x2
 8017ede: 4641         	mov	r1, r8
 8017ee0: 202e         	movs	r0, #0x2e
 8017ee2: 9b01         	ldr	r3, [sp, #0x4]
 8017ee4: 4798         	blx	r3
 8017ee6: 2800         	cmp	r0, #0x0
 8017ee8: f6ff ad79    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x50e
 8017eec: 464d         	mov	r5, r9
 8017eee: 444c         	add	r4, r9
 8017ef0: e232         	b	0x8018358 <vfprintf+0x9b4> @ imm = #0x464
 8017ef2: f89d 0035    	ldrb.w	r0, [sp, #0x35]
 8017ef6: 9b01         	ldr	r3, [sp, #0x4]
 8017ef8: 4641         	mov	r1, r8
 8017efa: 4798         	blx	r3
 8017efc: 2800         	cmp	r0, #0x0
 8017efe: f6ff ad6e    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x524
 8017f02: 2e00         	cmp	r6, #0x0
 8017f04: dd69         	ble	0x8017fda <vfprintf+0x636> @ imm = #0xd2
 8017f06: 9b01         	ldr	r3, [sp, #0x4]
 8017f08: 4641         	mov	r1, r8
 8017f0a: 202e         	movs	r0, #0x2e
 8017f0c: 4798         	blx	r3
 8017f0e: 2800         	cmp	r0, #0x0
 8017f10: f6ff ad65    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x536
 8017f14: f04f 0a01    	mov.w	r10, #0x1
 8017f18: 9b02         	ldr	r3, [sp, #0x8]
 8017f1a: 459a         	cmp	r10, r3
 8017f1c: bfbb         	ittet	lt
 8017f1e: ab0c         	addlt	r3, sp, #0x30
 8017f20: 4453         	addlt	r3, r10
 8017f22: 2030         	movge	r0, #0x30
 8017f24: 7958         	ldrblt	r0, [r3, #0x5]
 8017f26: 9b01         	ldr	r3, [sp, #0x4]
 8017f28: 4641         	mov	r1, r8
 8017f2a: 4798         	blx	r3
 8017f2c: 2800         	cmp	r0, #0x0
 8017f2e: 46d3         	mov	r11, r10
 8017f30: f6ff ad55    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x556
 8017f34: f10a 0a01    	add.w	r10, r10, #0x1
 8017f38: 4556         	cmp	r6, r10
 8017f3a: daed         	bge	0x8017f18 <vfprintf+0x574> @ imm = #-0x26
 8017f3c: 3502         	adds	r5, #0x2
 8017f3e: 445d         	add	r5, r11
 8017f40: 9b04         	ldr	r3, [sp, #0x10]
 8017f42: eba9 0003    	sub.w	r0, r9, r3
 8017f46: 4641         	mov	r1, r8
 8017f48: 9b01         	ldr	r3, [sp, #0x4]
 8017f4a: b2c0         	uxtb	r0, r0
 8017f4c: 4798         	blx	r3
 8017f4e: 2800         	cmp	r0, #0x0
 8017f50: f6ff ad45    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x576
 8017f54: 2f00         	cmp	r7, #0x0
 8017f56: bfb4         	ite	lt
 8017f58: 202d         	movlt	r0, #0x2d
 8017f5a: 202b         	movge	r0, #0x2b
 8017f5c: 9b01         	ldr	r3, [sp, #0x4]
 8017f5e: 4641         	mov	r1, r8
 8017f60: bfb8         	it	lt
 8017f62: 427f         	rsblt	r7, r7, #0
 8017f64: 4798         	blx	r3
 8017f66: 2800         	cmp	r0, #0x0
 8017f68: f6ff ad39    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x58e
 8017f6c: 9b03         	ldr	r3, [sp, #0xc]
 8017f6e: 2b04         	cmp	r3, #0x4
 8017f70: d141         	bne	0x8017ff6 <vfprintf+0x652> @ imm = #0x82
 8017f72: f44f 797a    	mov.w	r9, #0x3e8
 8017f76: fbb7 f6f9    	udiv	r6, r7, r9
 8017f7a: f106 0030    	add.w	r0, r6, #0x30
 8017f7e: 9b01         	ldr	r3, [sp, #0x4]
 8017f80: 4641         	mov	r1, r8
 8017f82: b2c0         	uxtb	r0, r0
 8017f84: 4798         	blx	r3
 8017f86: 2800         	cmp	r0, #0x0
 8017f88: f105 0503    	add.w	r5, r5, #0x3
 8017f8c: f6ff ad27    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x5b2
 8017f90: fb09 7716    	mls	r7, r9, r6, r7
 8017f94: f04f 0964    	mov.w	r9, #0x64
 8017f98: fbb7 f6f9    	udiv	r6, r7, r9
 8017f9c: f106 0030    	add.w	r0, r6, #0x30
 8017fa0: 9b01         	ldr	r3, [sp, #0x4]
 8017fa2: 4641         	mov	r1, r8
 8017fa4: b2c0         	uxtb	r0, r0
 8017fa6: 4798         	blx	r3
 8017fa8: 2800         	cmp	r0, #0x0
 8017faa: f105 0501    	add.w	r5, r5, #0x1
 8017fae: f6ff ad16    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x5d4
 8017fb2: fb09 7716    	mls	r7, r9, r6, r7
 8017fb6: f04f 090a    	mov.w	r9, #0xa
 8017fba: fbb7 f6f9    	udiv	r6, r7, r9
 8017fbe: f106 0030    	add.w	r0, r6, #0x30
 8017fc2: 9b01         	ldr	r3, [sp, #0x4]
 8017fc4: 4641         	mov	r1, r8
 8017fc6: b2c0         	uxtb	r0, r0
 8017fc8: 4798         	blx	r3
 8017fca: 2800         	cmp	r0, #0x0
 8017fcc: f105 0501    	add.w	r5, r5, #0x1
 8017fd0: f6ff ad05    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x5f6
 8017fd4: fb09 7716    	mls	r7, r9, r6, r7
 8017fd8: e015         	b	0x8018006 <vfprintf+0x662> @ imm = #0x2a
 8017fda: f01b 0f10    	tst.w	r11, #0x10
 8017fde: d101         	bne	0x8017fe4 <vfprintf+0x640> @ imm = #0x2
 8017fe0: 3501         	adds	r5, #0x1
 8017fe2: e7ad         	b	0x8017f40 <vfprintf+0x59c> @ imm = #-0xa6
 8017fe4: 9b01         	ldr	r3, [sp, #0x4]
 8017fe6: 4641         	mov	r1, r8
 8017fe8: 202e         	movs	r0, #0x2e
 8017fea: 4798         	blx	r3
 8017fec: 2800         	cmp	r0, #0x0
 8017fee: f105 0502    	add.w	r5, r5, #0x2
 8017ff2: daa5         	bge	0x8017f40 <vfprintf+0x59c> @ imm = #-0xb6
 8017ff4: e4f3         	b	0x80179de <vfprintf+0x3a> @ imm = #-0x61a
 8017ff6: 9b03         	ldr	r3, [sp, #0xc]
 8017ff8: 2b03         	cmp	r3, #0x3
 8017ffa: f105 0502    	add.w	r5, r5, #0x2
 8017ffe: d0c9         	beq	0x8017f94 <vfprintf+0x5f0> @ imm = #-0x6e
 8018000: 9b03         	ldr	r3, [sp, #0xc]
 8018002: 2b01         	cmp	r3, #0x1
 8018004: d1d7         	bne	0x8017fb6 <vfprintf+0x612> @ imm = #-0x52
 8018006: f107 0030    	add.w	r0, r7, #0x30
 801800a: f105 0901    	add.w	r9, r5, #0x1
 801800e: 4641         	mov	r1, r8
 8018010: b2c0         	uxtb	r0, r0
 8018012: e766         	b	0x8017ee2 <vfprintf+0x53e> @ imm = #-0x134
 8018014: f1a7 0363    	sub.w	r3, r7, #0x63
 8018018: 2b12         	cmp	r3, #0x12
 801801a: f200 80fe    	bhi.w	0x801821a <vfprintf+0x876> @ imm = #0x1fc
 801801e: e8df f013    	tbh	[pc, r3, lsl #1]

08018022 <$d>:
 8018022: 13 00 56 00  	.word	0x00560013
 8018026: fc 00 fc 00  	.word	0x00fc00fc
 801802a: fc 00 fc 00  	.word	0x00fc00fc
 801802e: 56 00 fc 00  	.word	0x00fc0056
 8018032: fc 00 fc 00  	.word	0x00fc00fc
 8018036: fc 00 fc 00  	.word	0x00fc00fc
 801803a: 16 01 f7 00  	.word	0x00f70116
 801803e: fc 00 fc 00  	.word	0x00fc00fc
 8018042: 2b 00 fc 00  	.word	0x00fc002b
 8018046: b8 00        	.short	0x00b8

08018048 <$t>:
 8018048: 9b0b         	ldr	r3, [sp, #0x2c]
 801804a: 1d1a         	adds	r2, r3, #0x4
 801804c: 681b         	ldr	r3, [r3]
 801804e: 920b         	str	r2, [sp, #0x2c]
 8018050: f88d 3030    	strb.w	r3, [sp, #0x30]
 8018054: 2401         	movs	r4, #0x1
 8018056: af0c         	add	r7, sp, #0x30
 8018058: f01b 0f08    	tst.w	r11, #0x8
 801805c: d02d         	beq	0x80180ba <vfprintf+0x716> @ imm = #0x5a
 801805e: 193e         	adds	r6, r7, r4
 8018060: 46b9         	mov	r9, r7
 8018062: 45b1         	cmp	r9, r6
 8018064: d12b         	bne	0x80180be <vfprintf+0x71a> @ imm = #0x56
 8018066: 1bef         	subs	r7, r5, r7
 8018068: 44b9         	add	r9, r7
 801806a: ebaa 0404    	sub.w	r4, r10, r4
 801806e: e73d         	b	0x8017eec <vfprintf+0x548> @ imm = #-0x186

08018070 <$d>:
 8018070: 51 c2 02 08  	.word	0x0802c251
 8018074: 4d c2 02 08  	.word	0x0802c24d

08018078 <$t>:
 8018078: 9b0b         	ldr	r3, [sp, #0x2c]
 801807a: 1d1a         	adds	r2, r3, #0x4
 801807c: 920b         	str	r2, [sp, #0x2c]
 801807e: 681f         	ldr	r7, [r3]
 8018080: 4bab         	ldr	r3, [pc, #0x2ac]        @ 0x8018330 <vfprintf+0x98c>
 8018082: 2f00         	cmp	r7, #0x0
 8018084: bf08         	it	eq
 8018086: 461f         	moveq	r7, r3
 8018088: f01b 0f40    	tst.w	r11, #0x40
 801808c: bf14         	ite	ne
 801808e: 4631         	movne	r1, r6
 8018090: f04f 31ff    	moveq.w	r1, #0xffffffff
 8018094: 4638         	mov	r0, r7
 8018096: f00f fa4f    	bl	0x8027538 <strnlen>     @ imm = #0xf49e
 801809a: 4604         	mov	r4, r0
 801809c: e7dc         	b	0x8018058 <vfprintf+0x6b4> @ imm = #-0x48
 801809e: 9b01         	ldr	r3, [sp, #0x4]
 80180a0: 4641         	mov	r1, r8
 80180a2: 2020         	movs	r0, #0x20
 80180a4: 4798         	blx	r3
 80180a6: 2800         	cmp	r0, #0x0
 80180a8: f6ff ac99    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x6ce
 80180ac: 3e01         	subs	r6, #0x1
 80180ae: 42b4         	cmp	r4, r6
 80180b0: d3f5         	blo	0x801809e <vfprintf+0x6fa> @ imm = #-0x16
 80180b2: 4455         	add	r5, r10
 80180b4: 1bad         	subs	r5, r5, r6
 80180b6: 46b2         	mov	r10, r6
 80180b8: e7d1         	b	0x801805e <vfprintf+0x6ba> @ imm = #-0x5e
 80180ba: 4656         	mov	r6, r10
 80180bc: e7f7         	b	0x80180ae <vfprintf+0x70a> @ imm = #-0x12
 80180be: f819 0b01    	ldrb	r0, [r9], #1
 80180c2: 9b01         	ldr	r3, [sp, #0x4]
 80180c4: 4641         	mov	r1, r8
 80180c6: 4798         	blx	r3
 80180c8: 2800         	cmp	r0, #0x0
 80180ca: daca         	bge	0x8018062 <vfprintf+0x6be> @ imm = #-0x6c
 80180cc: e487         	b	0x80179de <vfprintf+0x3a> @ imm = #-0x6f2
 80180ce: f01b 0f80    	tst.w	r11, #0x80
 80180d2: 9b0b         	ldr	r3, [sp, #0x2c]
 80180d4: d035         	beq	0x8018142 <vfprintf+0x79e> @ imm = #0x6a
 80180d6: f41b 7f00    	tst.w	r11, #0x200
 80180da: d02d         	beq	0x8018138 <vfprintf+0x794> @ imm = #0x5a
 80180dc: 3307         	adds	r3, #0x7
 80180de: f023 0307    	bic	r3, r3, #0x7
 80180e2: e9d3 0100    	ldrd	r0, r1, [r3]
 80180e6: f103 0208    	add.w	r2, r3, #0x8
 80180ea: 920b         	str	r2, [sp, #0x2c]
 80180ec: f02b 0910    	bic	r9, r11, #0x10
 80180f0: 2900         	cmp	r1, #0x0
 80180f2: fa1f f989    	uxth.w	r9, r9
 80180f6: da36         	bge	0x8018166 <vfprintf+0x7c2> @ imm = #0x6c
 80180f8: 4240         	rsbs	r0, r0, #0
 80180fa: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80180fe: f449 6980    	orr	r9, r9, #0x400
 8018102: f10d 0b30    	add.w	r11, sp, #0x30
 8018106: 230a         	movs	r3, #0xa
 8018108: 465a         	mov	r2, r11
 801810a: f00f fa21    	bl	0x8027550 <__ultoa_invert> @ imm = #0xf442
 801810e: f019 0f40    	tst.w	r9, #0x40
 8018112: eba0 0b0b    	sub.w	r11, r0, r11
 8018116: d065         	beq	0x80181e4 <vfprintf+0x840> @ imm = #0xca
 8018118: f029 0201    	bic	r2, r9, #0x1
 801811c: 455e         	cmp	r6, r11
 801811e: b292         	uxth	r2, r2
 8018120: f340 80b2    	ble.w	0x8018288 <vfprintf+0x8e4> @ imm = #0x164
 8018124: 2f00         	cmp	r7, #0x0
 8018126: f000 80a9    	beq.w	0x801827c <vfprintf+0x8d8> @ imm = #0x152
 801812a: f019 0310    	ands	r3, r9, #0x10
 801812e: 4634         	mov	r4, r6
 8018130: 4691         	mov	r9, r2
 8018132: d026         	beq	0x8018182 <vfprintf+0x7de> @ imm = #0x4c
 8018134: 3402         	adds	r4, #0x2
 8018136: e05c         	b	0x80181f2 <vfprintf+0x84e> @ imm = #0xb8
 8018138: 1d1a         	adds	r2, r3, #0x4
 801813a: 6818         	ldr	r0, [r3]
 801813c: 920b         	str	r2, [sp, #0x2c]
 801813e: 17c1         	asrs	r1, r0, #0x1f
 8018140: e7d4         	b	0x80180ec <vfprintf+0x748> @ imm = #-0x58
 8018142: 1d1a         	adds	r2, r3, #0x4
 8018144: f41b 7f80    	tst.w	r11, #0x100
 8018148: 6819         	ldr	r1, [r3]
 801814a: 920b         	str	r2, [sp, #0x2c]
 801814c: d101         	bne	0x8018152 <vfprintf+0x7ae> @ imm = #0x2
 801814e: 4608         	mov	r0, r1
 8018150: e7f5         	b	0x801813e <vfprintf+0x79a> @ imm = #-0x16
 8018152: f41b 7f00    	tst.w	r11, #0x200
 8018156: bf15         	itete	ne
 8018158: b248         	sxtbne	r0, r1
 801815a: b208         	sxtheq	r0, r1
 801815c: f341 11c0    	sbfxne	r1, r1, #0x7, #0x1
 8018160: f341 31c0    	sbfxeq	r1, r1, #0xf, #0x1
 8018164: e7c2         	b	0x80180ec <vfprintf+0x748> @ imm = #-0x7c
 8018166: ea50 0301    	orrs.w	r3, r0, r1
 801816a: d1ca         	bne	0x8018102 <vfprintf+0x75e> @ imm = #-0x6c
 801816c: f01b 0f40    	tst.w	r11, #0x40
 8018170: d0c7         	beq	0x8018102 <vfprintf+0x75e> @ imm = #-0x72
 8018172: 2e00         	cmp	r6, #0x0
 8018174: d1c5         	bne	0x8018102 <vfprintf+0x75e> @ imm = #-0x76
 8018176: f02b 0b11    	bic	r11, r11, #0x11
 801817a: fa1f f98b    	uxth.w	r9, r11
 801817e: 4634         	mov	r4, r6
 8018180: 46b3         	mov	r11, r6
 8018182: f240 4306    	movw	r3, #0x406
 8018186: ea19 0303    	ands.w	r3, r9, r3
 801818a: bf1c         	itt	ne
 801818c: 3401         	addne	r4, #0x1
 801818e: 2300         	movne	r3, #0x0
 8018190: e02f         	b	0x80181f2 <vfprintf+0x84e> @ imm = #0x5e
 8018192: f02b 0b10    	bic	r11, r11, #0x10
 8018196: fa1f fb8b    	uxth.w	r11, r11
 801819a: 230a         	movs	r3, #0xa
 801819c: f01b 0480    	ands	r4, r11, #0x80
 80181a0: 9a0b         	ldr	r2, [sp, #0x2c]
 80181a2: d057         	beq	0x8018254 <vfprintf+0x8b0> @ imm = #0xae
 80181a4: f41b 7100    	ands	r1, r11, #0x200
 80181a8: bf1d         	ittte	ne
 80181aa: 3207         	addne	r2, #0x7
 80181ac: f022 0207    	bicne	r2, r2, #0x7
 80181b0: f102 0108    	addne.w	r1, r2, #0x8
 80181b4: 1d10         	addeq	r0, r2, #0x4
 80181b6: bf19         	ittee	ne
 80181b8: 910b         	strne	r1, [sp, #0x2c]
 80181ba: e9d2 0100    	ldrdne	r0, r1, [r2]
 80181be: 900b         	streq	r0, [sp, #0x2c]
 80181c0: 6810         	ldreq	r0, [r2]
 80181c2: ea50 0201    	orrs.w	r2, r0, r1
 80181c6: d152         	bne	0x801826e <vfprintf+0x8ca> @ imm = #0xa4
 80181c8: f02b 0916    	bic	r9, r11, #0x16
 80181cc: f01b 0f40    	tst.w	r11, #0x40
 80181d0: fa1f f989    	uxth.w	r9, r9
 80181d4: d04f         	beq	0x8018276 <vfprintf+0x8d2> @ imm = #0x9e
 80181d6: 2e00         	cmp	r6, #0x0
 80181d8: d14d         	bne	0x8018276 <vfprintf+0x8d2> @ imm = #0x9a
 80181da: f02b 0b17    	bic	r11, r11, #0x17
 80181de: fa1f f98b    	uxth.w	r9, r11
 80181e2: 46b3         	mov	r11, r6
 80181e4: f019 0310    	ands	r3, r9, #0x10
 80181e8: d052         	beq	0x8018290 <vfprintf+0x8ec> @ imm = #0xa4
 80181ea: 2f00         	cmp	r7, #0x0
 80181ec: d14e         	bne	0x801828c <vfprintf+0x8e8> @ imm = #0x9c
 80181ee: f10b 0401    	add.w	r4, r11, #0x1
 80181f2: f019 0f08    	tst.w	r9, #0x8
 80181f6: d15e         	bne	0x80182b6 <vfprintf+0x912> @ imm = #0xbc
 80181f8: f019 0f01    	tst.w	r9, #0x1
 80181fc: d006         	beq	0x801820c <vfprintf+0x868> @ imm = #0xc
 80181fe: 45a2         	cmp	r10, r4
 8018200: dd6e         	ble	0x80182e0 <vfprintf+0x93c> @ imm = #0xdc
 8018202: ebaa 0404    	sub.w	r4, r10, r4
 8018206: eb04 060b    	add.w	r6, r4, r11
 801820a: 4654         	mov	r4, r10
 801820c: 4622         	mov	r2, r4
 801820e: e04d         	b	0x80182ac <vfprintf+0x908> @ imm = #0x9a
 8018210: f04b 0b10    	orr	r11, r11, #0x10
 8018214: 2310         	movs	r3, #0x10
 8018216: 2778         	movs	r7, #0x78
 8018218: e7c0         	b	0x801819c <vfprintf+0x7f8> @ imm = #-0x80
 801821a: f1b9 0f78    	cmp.w	r9, #0x78
 801821e: d104         	bne	0x801822a <vfprintf+0x886> @ imm = #0x8
 8018220: f1c7 0378    	rsb.w	r3, r7, #0x78
 8018224: f043 0310    	orr	r3, r3, #0x10
 8018228: e7b8         	b	0x801819c <vfprintf+0x7f8> @ imm = #-0x90
 801822a: 9b01         	ldr	r3, [sp, #0x4]
 801822c: 4641         	mov	r1, r8
 801822e: 2025         	movs	r0, #0x25
 8018230: 4798         	blx	r3
 8018232: 2800         	cmp	r0, #0x0
 8018234: f6ff abd3    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x85a
 8018238: 9b01         	ldr	r3, [sp, #0x4]
 801823a: 4641         	mov	r1, r8
 801823c: 4638         	mov	r0, r7
 801823e: 4798         	blx	r3
 8018240: 2800         	cmp	r0, #0x0
 8018242: f6ff abcc    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x868
 8018246: 3502         	adds	r5, #0x2
 8018248: 9b05         	ldr	r3, [sp, #0x14]
 801824a: f7ff bbb9    	b.w	0x80179c0 <vfprintf+0x1c> @ imm = #-0x88e
 801824e: 2308         	movs	r3, #0x8
 8018250: 2700         	movs	r7, #0x0
 8018252: e7a3         	b	0x801819c <vfprintf+0x7f8> @ imm = #-0xba
 8018254: 1d11         	adds	r1, r2, #0x4
 8018256: 910b         	str	r1, [sp, #0x2c]
 8018258: f41b 7180    	ands	r1, r11, #0x100
 801825c: 6810         	ldr	r0, [r2]
 801825e: d0b0         	beq	0x80181c2 <vfprintf+0x81e> @ imm = #-0xa0
 8018260: f41b 7100    	ands	r1, r11, #0x200
 8018264: bf1a         	itte	ne
 8018266: b2c0         	uxtbne	r0, r0
 8018268: 4621         	movne	r1, r4
 801826a: b280         	uxtheq	r0, r0
 801826c: e7a9         	b	0x80181c2 <vfprintf+0x81e> @ imm = #-0xae
 801826e: f02b 0b06    	bic	r11, r11, #0x6
 8018272: fa1f f98b    	uxth.w	r9, r11
 8018276: f10d 0b30    	add.w	r11, sp, #0x30
 801827a: e745         	b	0x8018108 <vfprintf+0x764> @ imm = #-0x176
 801827c: f029 0911    	bic	r9, r9, #0x11
 8018280: fa1f f989    	uxth.w	r9, r9
 8018284: 4634         	mov	r4, r6
 8018286: e77c         	b	0x8018182 <vfprintf+0x7de> @ imm = #-0x108
 8018288: 4691         	mov	r9, r2
 801828a: e7ab         	b	0x80181e4 <vfprintf+0x840> @ imm = #-0xaa
 801828c: 465c         	mov	r4, r11
 801828e: e751         	b	0x8018134 <vfprintf+0x790> @ imm = #-0x15e
 8018290: 465c         	mov	r4, r11
 8018292: e776         	b	0x8018182 <vfprintf+0x7de> @ imm = #-0x114
 8018294: e9cd 2302    	strd	r2, r3, [sp, #8]
 8018298: 4641         	mov	r1, r8
 801829a: 9b01         	ldr	r3, [sp, #0x4]
 801829c: 2020         	movs	r0, #0x20
 801829e: 4798         	blx	r3
 80182a0: 2800         	cmp	r0, #0x0
 80182a2: f6ff ab9c    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x8c8
 80182a6: 9a02         	ldr	r2, [sp, #0x8]
 80182a8: 9b03         	ldr	r3, [sp, #0xc]
 80182aa: 3201         	adds	r2, #0x1
 80182ac: 4592         	cmp	r10, r2
 80182ae: dcf1         	bgt	0x8018294 <vfprintf+0x8f0> @ imm = #-0x1e
 80182b0: 1b2c         	subs	r4, r5, r4
 80182b2: 18a5         	adds	r5, r4, r2
 80182b4: 4614         	mov	r4, r2
 80182b6: b1f3         	cbz	r3, 0x80182f6 <vfprintf+0x952> @ imm = #0x3c
 80182b8: 9b01         	ldr	r3, [sp, #0x4]
 80182ba: 4641         	mov	r1, r8
 80182bc: 2030         	movs	r0, #0x30
 80182be: 4798         	blx	r3
 80182c0: 2800         	cmp	r0, #0x0
 80182c2: f6ff ab8c    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x8e8
 80182c6: b96f         	cbnz	r7, 0x80182e4 <vfprintf+0x940> @ imm = #0x1a
 80182c8: 3501         	adds	r5, #0x1
 80182ca: 46a9         	mov	r9, r5
 80182cc: 442e         	add	r6, r5
 80182ce: eba6 0309    	sub.w	r3, r6, r9
 80182d2: 455b         	cmp	r3, r11
 80182d4: dc21         	bgt	0x801831a <vfprintf+0x976> @ imm = #0x42
 80182d6: 465d         	mov	r5, r11
 80182d8: ae0c         	add	r6, sp, #0x30
 80182da: bb5d         	cbnz	r5, 0x8018334 <vfprintf+0x990> @ imm = #0x56
 80182dc: 44d9         	add	r9, r11
 80182de: e6c4         	b	0x801806a <vfprintf+0x6c6> @ imm = #-0x278
 80182e0: 465e         	mov	r6, r11
 80182e2: e793         	b	0x801820c <vfprintf+0x868> @ imm = #-0xda
 80182e4: 3502         	adds	r5, #0x2
 80182e6: 4641         	mov	r1, r8
 80182e8: 4638         	mov	r0, r7
 80182ea: 9b01         	ldr	r3, [sp, #0x4]
 80182ec: 4798         	blx	r3
 80182ee: 2800         	cmp	r0, #0x0
 80182f0: daeb         	bge	0x80182ca <vfprintf+0x926> @ imm = #-0x2a
 80182f2: f7ff bb74    	b.w	0x80179de <vfprintf+0x3a> @ imm = #-0x918
 80182f6: f240 4306    	movw	r3, #0x406
 80182fa: ea19 0f03    	tst.w	r9, r3
 80182fe: d0e4         	beq	0x80182ca <vfprintf+0x926> @ imm = #-0x38
 8018300: f019 0f02    	tst.w	r9, #0x2
 8018304: bf14         	ite	ne
 8018306: 202b         	movne	r0, #0x2b
 8018308: 2020         	moveq	r0, #0x20
 801830a: f419 6f80    	tst.w	r9, #0x400
 801830e: f105 0501    	add.w	r5, r5, #0x1
 8018312: 4641         	mov	r1, r8
 8018314: bf18         	it	ne
 8018316: 202d         	movne	r0, #0x2d
 8018318: e7e7         	b	0x80182ea <vfprintf+0x946> @ imm = #-0x32
 801831a: 9b01         	ldr	r3, [sp, #0x4]
 801831c: 4641         	mov	r1, r8
 801831e: 2030         	movs	r0, #0x30
 8018320: 4798         	blx	r3
 8018322: 2800         	cmp	r0, #0x0
 8018324: f109 0901    	add.w	r9, r9, #0x1
 8018328: dad1         	bge	0x80182ce <vfprintf+0x92a> @ imm = #-0x5e
 801832a: f7ff bb58    	b.w	0x80179de <vfprintf+0x3a> @ imm = #-0x950
 801832e: bf00         	nop

08018330 <$d>:
 8018330: 55 c2 02 08  	.word	0x0802c255

08018334 <$t>:
 8018334: 3d01         	subs	r5, #0x1
 8018336: 9b01         	ldr	r3, [sp, #0x4]
 8018338: 5d70         	ldrb	r0, [r6, r5]
 801833a: 4641         	mov	r1, r8
 801833c: 4798         	blx	r3
 801833e: 2800         	cmp	r0, #0x0
 8018340: dacb         	bge	0x80182da <vfprintf+0x936> @ imm = #-0x6a
 8018342: f7ff bb4c    	b.w	0x80179de <vfprintf+0x3a> @ imm = #-0x968
 8018346: 9b01         	ldr	r3, [sp, #0x4]
 8018348: 4641         	mov	r1, r8
 801834a: 2020         	movs	r0, #0x20
 801834c: 4798         	blx	r3
 801834e: 2800         	cmp	r0, #0x0
 8018350: f105 0501    	add.w	r5, r5, #0x1
 8018354: f6ff ab43    	blt.w	0x80179de <vfprintf+0x3a> @ imm = #-0x97a
 8018358: 1b63         	subs	r3, r4, r5
 801835a: 2b00         	cmp	r3, #0x0
 801835c: dcf3         	bgt	0x8018346 <vfprintf+0x9a2> @ imm = #-0x1a
 801835e: e773         	b	0x8018248 <vfprintf+0x8a4> @ imm = #-0x11a

08018360 <div10>:
 8018360: b51f         	push	{r0, r1, r2, r3, r4, lr}
 8018362: ab02         	add	r3, sp, #0x8
 8018364: 9300         	str	r3, [sp]
 8018366: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8018384 <div10+0x24>
 8018368: f04f 33cc    	mov.w	r3, #0xcccccccc
 801836c: f00f f9d5    	bl	0x802771a <__umul128>   @ imm = #0xf3aa
 8018370: e9dd 0102    	ldrd	r0, r1, [sp, #8]
 8018374: 08c0         	lsrs	r0, r0, #0x3
 8018376: ea40 7041    	orr.w	r0, r0, r1, lsl #29
 801837a: 08c9         	lsrs	r1, r1, #0x3
 801837c: b005         	add	sp, #0x14
 801837e: f85d fb04    	ldr	pc, [sp], #4
 8018382: bf00         	nop

08018384 <$d>:
 8018384: cd cc cc cc  	.word	0xcccccccd

08018388 <__dtoa_engine>:
 8018388: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 801838c: ec55 4b10    	vmov	r4, r5, d0
 8018390: b09d         	sub	sp, #0x74
 8018392: e9cd 320c    	strd	r3, r2, [sp, #48]
 8018396: 462a         	mov	r2, r5
 8018398: 910b         	str	r1, [sp, #0x2c]
 801839a: f3c5 0313    	ubfx	r3, r5, #0x0, #0x14
 801839e: 0d29         	lsrs	r1, r5, #0x14
 80183a0: 0fd2         	lsrs	r2, r2, #0x1f
 80183a2: f3c5 550a    	ubfx	r5, r5, #0x14, #0xb
 80183a6: 9007         	str	r0, [sp, #0x1c]
 80183a8: ed8d 0a05    	vstr	s0, [sp, #20]
 80183ac: 920a         	str	r2, [sp, #0x28]
 80183ae: b975         	cbnz	r5, 0x80183ce <__dtoa_engine+0x46> @ imm = #0x1c
 80183b0: 4622         	mov	r2, r4
 80183b2: 431a         	orrs	r2, r3
 80183b4: d11b         	bne	0x80183ee <__dtoa_engine+0x66> @ imm = #0x36
 80183b6: 2330         	movs	r3, #0x30
 80183b8: 7143         	strb	r3, [r0, #0x5]
 80183ba: 9b0a         	ldr	r3, [sp, #0x28]
 80183bc: 6005         	str	r5, [r0]
 80183be: f043 0302    	orr	r3, r3, #0x2
 80183c2: 7103         	strb	r3, [r0, #0x4]
 80183c4: 2701         	movs	r7, #0x1
 80183c6: 4638         	mov	r0, r7
 80183c8: b01d         	add	sp, #0x74
 80183ca: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80183ce: f240 72ff    	movw	r2, #0x7ff
 80183d2: 4295         	cmp	r5, r2
 80183d4: d14d         	bne	0x8018472 <__dtoa_engine+0xea> @ imm = #0x9a
 80183d6: 9a05         	ldr	r2, [sp, #0x14]
 80183d8: 4313         	orrs	r3, r2
 80183da: 9b0a         	ldr	r3, [sp, #0x28]
 80183dc: 9a07         	ldr	r2, [sp, #0x1c]
 80183de: bf14         	ite	ne
 80183e0: f043 0308    	orrne	r3, r3, #0x8
 80183e4: f043 0304    	orreq	r3, r3, #0x4
 80183e8: 7113         	strb	r3, [r2, #0x4]
 80183ea: 2700         	movs	r7, #0x0
 80183ec: e7eb         	b	0x80183c6 <__dtoa_engine+0x3e> @ imm = #-0x2a
 80183ee: 9a05         	ldr	r2, [sp, #0x14]
 80183f0: 4db2         	ldr	r5, [pc, #0x2c8]        @ 0x80186bc <__dtoa_engine+0x334>
 80183f2: f002 0201    	and	r2, r2, #0x1
 80183f6: 9209         	str	r2, [sp, #0x24]
 80183f8: 9a05         	ldr	r2, [sp, #0x14]
 80183fa: ea4f 0883    	lsl.w	r8, r3, #0x2
 80183fe: ea48 7892    	orr.w	r8, r8, r2, lsr #30
 8018402: 0097         	lsls	r7, r2, #0x2
 8018404: 2201         	movs	r2, #0x1
 8018406: 469a         	mov	r10, r3
 8018408: 4616         	mov	r6, r2
 801840a: f1c5 0b00    	rsb.w	r11, r5, #0x0
 801840e: 4658         	mov	r0, r11
 8018410: 9208         	str	r2, [sp, #0x20]
 8018412: f000 fa17    	bl	0x8018844 <__log10Pow5> @ imm = #0x42e
 8018416: f1b5 3fff    	cmp.w	r5, #0xffffffff
 801841a: bfac         	ite	ge
 801841c: 4681         	movge	r9, r0
 801841e: f1a0 0901    	sublt.w	r9, r0, #0x1
 8018422: ebab 0b09    	sub.w	r11, r11, r9
 8018426: eb09 0305    	add.w	r3, r9, r5
 801842a: 4658         	mov	r0, r11
 801842c: 9306         	str	r3, [sp, #0x18]
 801842e: f000 fa0f    	bl	0x8018850 <__pow5bits>  @ imm = #0x41e
 8018432: a918         	add	r1, sp, #0x60
 8018434: f1a0 057d    	sub.w	r5, r0, #0x7d
 8018438: 4658         	mov	r0, r11
 801843a: f000 fa29    	bl	0x8018890 <__double_computePow5> @ imm = #0x452
 801843e: ab14         	add	r3, sp, #0x50
 8018440: 9a08         	ldr	r2, [sp, #0x20]
 8018442: 9301         	str	r3, [sp, #0x4]
 8018444: eba9 0505    	sub.w	r5, r9, r5
 8018448: ab12         	add	r3, sp, #0x48
 801844a: 9202         	str	r2, [sp, #0x8]
 801844c: 9300         	str	r3, [sp]
 801844e: 9805         	ldr	r0, [sp, #0x14]
 8018450: 462b         	mov	r3, r5
 8018452: aa18         	add	r2, sp, #0x60
 8018454: 4651         	mov	r1, r10
 8018456: f00f f8a3    	bl	0x80275a0 <mulShiftAll64> @ imm = #0xf146
 801845a: f1b9 0f01    	cmp.w	r9, #0x1
 801845e: 4604         	mov	r4, r0
 8018460: 460d         	mov	r5, r1
 8018462: f200 80d8    	bhi.w	0x8018616 <__dtoa_engine+0x28e> @ imm = #0x1b0
 8018466: 9b09         	ldr	r3, [sp, #0x24]
 8018468: 2b00         	cmp	r3, #0x0
 801846a: f040 80cb    	bne.w	0x8018604 <__dtoa_engine+0x27c> @ imm = #0x196
 801846e: 2701         	movs	r7, #0x1
 8018470: e06f         	b	0x8018552 <__dtoa_engine+0x1ca> @ imm = #0xde
 8018472: 9a05         	ldr	r2, [sp, #0x14]
 8018474: f002 0201    	and	r2, r2, #0x1
 8018478: 9209         	str	r2, [sp, #0x24]
 801847a: 9a05         	ldr	r2, [sp, #0x14]
 801847c: f443 1a80    	orr	r10, r3, #0x100000
 8018480: ea4f 088a    	lsl.w	r8, r10, #0x2
 8018484: 4313         	orrs	r3, r2
 8018486: f2a5 4535    	subw	r5, r5, #0x435
 801848a: ea48 7892    	orr.w	r8, r8, r2, lsr #30
 801848e: ea4f 0782    	lsl.w	r7, r2, #0x2
 8018492: d14b         	bne	0x801852c <__dtoa_engine+0x1a4> @ imm = #0x96
 8018494: f240 73fe    	movw	r3, #0x7fe
 8018498: 4219         	tst	r1, r3
 801849a: bf0c         	ite	eq
 801849c: 2601         	moveq	r6, #0x1
 801849e: 2600         	movne	r6, #0x0
 80184a0: 2d00         	cmp	r5, #0x0
 80184a2: 4632         	mov	r2, r6
 80184a4: dbb1         	blt	0x801840a <__dtoa_engine+0x82> @ imm = #-0x9e
 80184a6: 4628         	mov	r0, r5
 80184a8: f000 f9c6    	bl	0x8018838 <__log10Pow2> @ imm = #0x38c
 80184ac: 4603         	mov	r3, r0
 80184ae: 2d03         	cmp	r5, #0x3
 80184b0: bfc8         	it	gt
 80184b2: 3b01         	subgt	r3, #0x1
 80184b4: 4618         	mov	r0, r3
 80184b6: 9306         	str	r3, [sp, #0x18]
 80184b8: f000 f9ca    	bl	0x8018850 <__pow5bits>  @ imm = #0x394
 80184bc: 9b06         	ldr	r3, [sp, #0x18]
 80184be: 307c         	adds	r0, #0x7c
 80184c0: 1b5d         	subs	r5, r3, r5
 80184c2: 4405         	add	r5, r0
 80184c4: a918         	add	r1, sp, #0x60
 80184c6: 4618         	mov	r0, r3
 80184c8: f000 fa56    	bl	0x8018978 <__double_computeInvPow5> @ imm = #0x4ac
 80184cc: ab14         	add	r3, sp, #0x50
 80184ce: 9301         	str	r3, [sp, #0x4]
 80184d0: ab12         	add	r3, sp, #0x48
 80184d2: 9300         	str	r3, [sp]
 80184d4: 9805         	ldr	r0, [sp, #0x14]
 80184d6: 9602         	str	r6, [sp, #0x8]
 80184d8: 462b         	mov	r3, r5
 80184da: aa18         	add	r2, sp, #0x60
 80184dc: 4651         	mov	r1, r10
 80184de: f00f f85f    	bl	0x80275a0 <mulShiftAll64> @ imm = #0xf0be
 80184e2: 9b06         	ldr	r3, [sp, #0x18]
 80184e4: 2b15         	cmp	r3, #0x15
 80184e6: 4604         	mov	r4, r0
 80184e8: 460d         	mov	r5, r1
 80184ea: f200 8088    	bhi.w	0x80185fe <__dtoa_engine+0x276> @ imm = #0x110
 80184ee: ab16         	add	r3, sp, #0x58
 80184f0: 4a73         	ldr	r2, [pc, #0x1cc]        @ 0x80186c0 <__dtoa_engine+0x338>
 80184f2: 9300         	str	r3, [sp]
 80184f4: 4638         	mov	r0, r7
 80184f6: f04f 33cc    	mov.w	r3, #0xcccccccc
 80184fa: 4641         	mov	r1, r8
 80184fc: f00f f90d    	bl	0x802771a <__umul128>   @ imm = #0xf21a
 8018500: 9b16         	ldr	r3, [sp, #0x58]
 8018502: 9a17         	ldr	r2, [sp, #0x5c]
 8018504: 089b         	lsrs	r3, r3, #0x2
 8018506: ea43 7382    	orr.w	r3, r3, r2, lsl #30
 801850a: eb03 0383    	add.w	r3, r3, r3, lsl #2
 801850e: 42bb         	cmp	r3, r7
 8018510: e9dd 9a12    	ldrd	r9, r10, [sp, #72]
 8018514: d10c         	bne	0x8018530 <__dtoa_engine+0x1a8> @ imm = #0x18
 8018516: 4638         	mov	r0, r7
 8018518: 4641         	mov	r1, r8
 801851a: f000 f9a1    	bl	0x8018860 <__pow5Factor> @ imm = #0x342
 801851e: 9b06         	ldr	r3, [sp, #0x18]
 8018520: 4283         	cmp	r3, r0
 8018522: bf8c         	ite	hi
 8018524: 2700         	movhi	r7, #0x0
 8018526: 2701         	movls	r7, #0x1
 8018528: 2600         	movs	r6, #0x0
 801852a: e012         	b	0x8018552 <__dtoa_engine+0x1ca> @ imm = #0x24
 801852c: 2601         	movs	r6, #0x1
 801852e: e7b7         	b	0x80184a0 <__dtoa_engine+0x118> @ imm = #-0x92
 8018530: 9b09         	ldr	r3, [sp, #0x24]
 8018532: 2b00         	cmp	r3, #0x0
 8018534: d153         	bne	0x80185de <__dtoa_engine+0x256> @ imm = #0xa6
 8018536: 3f01         	subs	r7, #0x1
 8018538: f148 31ff    	adc	r1, r8, #0xffffffff
 801853c: 1bb8         	subs	r0, r7, r6
 801853e: f161 0100    	sbc	r1, r1, #0x0
 8018542: f000 f98d    	bl	0x8018860 <__pow5Factor> @ imm = #0x31a
 8018546: 9b06         	ldr	r3, [sp, #0x18]
 8018548: 9f09         	ldr	r7, [sp, #0x24]
 801854a: 4283         	cmp	r3, r0
 801854c: bf8c         	ite	hi
 801854e: 2600         	movhi	r6, #0x0
 8018550: 2601         	movls	r6, #0x1
 8018552: 9b0d         	ldr	r3, [sp, #0x34]
 8018554: 2b00         	cmp	r3, #0x0
 8018556: f040 8093    	bne.w	0x8018680 <__dtoa_engine+0x2f8> @ imm = #0x126
 801855a: f8dd b02c    	ldr.w	r11, [sp, #0x2c]
 801855e: f04f 0800    	mov.w	r8, #0x0
 8018562: f8cd 8020    	str.w	r8, [sp, #0x20]
 8018566: f8cd 8014    	str.w	r8, [sp, #0x14]
 801856a: f04f 0a0a    	mov.w	r10, #0xa
 801856e: e9dd 0112    	ldrd	r0, r1, [sp, #72]
 8018572: f7ff fef5    	bl	0x8018360 <div10>       @ imm = #-0x216
 8018576: 9b14         	ldr	r3, [sp, #0x50]
 8018578: 9310         	str	r3, [sp, #0x40]
 801857a: e9cd 010e    	strd	r0, r1, [sp, #56]
 801857e: 4618         	mov	r0, r3
 8018580: 9915         	ldr	r1, [sp, #0x54]
 8018582: f7ff feed    	bl	0x8018360 <div10>       @ imm = #-0x226
 8018586: 9b0e         	ldr	r3, [sp, #0x38]
 8018588: 9a0f         	ldr	r2, [sp, #0x3c]
 801858a: 9111         	str	r1, [sp, #0x44]
 801858c: 4298         	cmp	r0, r3
 801858e: 460b         	mov	r3, r1
 8018590: 4193         	sbcs	r3, r2
 8018592: 4681         	mov	r9, r0
 8018594: f080 808e    	bhs.w	0x80186b4 <__dtoa_engine+0x32c> @ imm = #0x11c
 8018598: 4620         	mov	r0, r4
 801859a: 4629         	mov	r1, r5
 801859c: f7ff fee0    	bl	0x8018360 <div10>       @ imm = #-0x240
 80185a0: 9a10         	ldr	r2, [sp, #0x40]
 80185a2: fb0a f309    	mul	r3, r10, r9
 80185a6: 4293         	cmp	r3, r2
 80185a8: bf14         	ite	ne
 80185aa: 2600         	movne	r6, #0x0
 80185ac: f006 0601    	andeq	r6, r6, #0x1
 80185b0: 9b0e         	ldr	r3, [sp, #0x38]
 80185b2: 9312         	str	r3, [sp, #0x48]
 80185b4: 9b0f         	ldr	r3, [sp, #0x3c]
 80185b6: e9cd 3913    	strd	r3, r9, [sp, #76]
 80185ba: 9b11         	ldr	r3, [sp, #0x44]
 80185bc: 9315         	str	r3, [sp, #0x54]
 80185be: 9b08         	ldr	r3, [sp, #0x20]
 80185c0: f1b8 0f00    	cmp.w	r8, #0x0
 80185c4: bf14         	ite	ne
 80185c6: 2700         	movne	r7, #0x0
 80185c8: f007 0701    	andeq	r7, r7, #0x1
 80185cc: 3301         	adds	r3, #0x1
 80185ce: fb0a 4810    	mls	r8, r10, r0, r4
 80185d2: fa5f f888    	uxtb.w	r8, r8
 80185d6: 9308         	str	r3, [sp, #0x20]
 80185d8: 4604         	mov	r4, r0
 80185da: 460d         	mov	r5, r1
 80185dc: e7c7         	b	0x801856e <__dtoa_engine+0x1e6> @ imm = #-0x72
 80185de: 1cb8         	adds	r0, r7, #0x2
 80185e0: f148 0100    	adc	r1, r8, #0x0
 80185e4: f000 f93c    	bl	0x8018860 <__pow5Factor> @ imm = #0x278
 80185e8: 9b06         	ldr	r3, [sp, #0x18]
 80185ea: 4283         	cmp	r3, r0
 80185ec: bf8c         	ite	hi
 80185ee: 2000         	movhi	r0, #0x0
 80185f0: 2001         	movls	r0, #0x1
 80185f2: ebb9 0000    	subs.w	r0, r9, r0
 80185f6: f16a 0200    	sbc	r2, r10, #0x0
 80185fa: e9cd 0212    	strd	r0, r2, [sp, #72]
 80185fe: 2700         	movs	r7, #0x0
 8018600: 463e         	mov	r6, r7
 8018602: e7a6         	b	0x8018552 <__dtoa_engine+0x1ca> @ imm = #-0xb4
 8018604: 9b12         	ldr	r3, [sp, #0x48]
 8018606: 9a13         	ldr	r2, [sp, #0x4c]
 8018608: 3b01         	subs	r3, #0x1
 801860a: f142 32ff    	adc	r2, r2, #0xffffffff
 801860e: e9cd 3212    	strd	r3, r2, [sp, #72]
 8018612: 2701         	movs	r7, #0x1
 8018614: e788         	b	0x8018528 <__dtoa_engine+0x1a0> @ imm = #-0xf0
 8018616: f1b9 0f3e    	cmp.w	r9, #0x3e
 801861a: d8f0         	bhi	0x80185fe <__dtoa_engine+0x276> @ imm = #-0x20
 801861c: f04f 33ff    	mov.w	r3, #0xffffffff
 8018620: f1a9 0020    	sub.w	r0, r9, #0x20
 8018624: fa03 f209    	lsl.w	r2, r3, r9
 8018628: fa03 f000    	lsl.w	r0, r3, r0
 801862c: f1c9 0120    	rsb.w	r1, r9, #0x20
 8018630: fa23 f101    	lsr.w	r1, r3, r1
 8018634: 4302         	orrs	r2, r0
 8018636: 430a         	orrs	r2, r1
 8018638: fa03 f309    	lsl.w	r3, r3, r9
 801863c: ea27 0703    	bic.w	r7, r7, r3
 8018640: ea28 0802    	bic.w	r8, r8, r2
 8018644: ea57 0708    	orrs.w	r7, r7, r8
 8018648: bf0c         	ite	eq
 801864a: 2701         	moveq	r7, #0x1
 801864c: 2700         	movne	r7, #0x0
 801864e: e76b         	b	0x8018528 <__dtoa_engine+0x1a0> @ imm = #-0x12a
 8018650: fb00 fc02    	mul	r12, r0, r2
 8018654: fba1 1200    	umull	r1, r2, r1, r0
 8018658: 3301         	adds	r3, #0x1
 801865a: 4462         	add	r2, r12
 801865c: 428c         	cmp	r4, r1
 801865e: eb75 0c02    	sbcs.w	r12, r5, r2
 8018662: d2f5         	bhs	0x8018650 <__dtoa_engine+0x2c8> @ imm = #-0x16
 8018664: 9a06         	ldr	r2, [sp, #0x18]
 8018666: 4413         	add	r3, r2
 8018668: 9a0c         	ldr	r2, [sp, #0x30]
 801866a: 4413         	add	r3, r2
 801866c: 0fd2         	lsrs	r2, r2, #0x1f
 801866e: 4293         	cmp	r3, r2
 8018670: bfb8         	it	lt
 8018672: 4613         	movlt	r3, r2
 8018674: 9a0b         	ldr	r2, [sp, #0x2c]
 8018676: 429a         	cmp	r2, r3
 8018678: bfa8         	it	ge
 801867a: 461a         	movge	r2, r3
 801867c: 4693         	mov	r11, r2
 801867e: e76e         	b	0x801855e <__dtoa_engine+0x1d6> @ imm = #-0x124
 8018680: 210a         	movs	r1, #0xa
 8018682: 2200         	movs	r2, #0x0
 8018684: 2301         	movs	r3, #0x1
 8018686: 4608         	mov	r0, r1
 8018688: e7e8         	b	0x801865c <__dtoa_engine+0x2d4> @ imm = #-0x30
 801868a: fb0a f003    	mul	r0, r10, r3
 801868e: fba2 230a    	umull	r2, r3, r2, r10
 8018692: 3101         	adds	r1, #0x1
 8018694: 4403         	add	r3, r0
 8018696: 4294         	cmp	r4, r2
 8018698: eb75 0003    	sbcs.w	r0, r5, r3
 801869c: d2f5         	bhs	0x801868a <__dtoa_engine+0x302> @ imm = #-0x16
 801869e: 4559         	cmp	r1, r11
 80186a0: dd10         	ble	0x80186c4 <__dtoa_engine+0x33c> @ imm = #0x20
 80186a2: f1bb 0f00    	cmp.w	r11, #0x0
 80186a6: d102         	bne	0x80186ae <__dtoa_engine+0x326> @ imm = #0x4
 80186a8: ea54 0305    	orrs.w	r3, r4, r5
 80186ac: d00a         	beq	0x80186c4 <__dtoa_engine+0x33c> @ imm = #0x14
 80186ae: 2301         	movs	r3, #0x1
 80186b0: 9305         	str	r3, [sp, #0x14]
 80186b2: e771         	b	0x8018598 <__dtoa_engine+0x210> @ imm = #-0x11e
 80186b4: 220a         	movs	r2, #0xa
 80186b6: 2300         	movs	r3, #0x0
 80186b8: 2101         	movs	r1, #0x1
 80186ba: e7ec         	b	0x8018696 <__dtoa_engine+0x30e> @ imm = #-0x28

080186bc <$d>:
 80186bc: cc fb ff ff  	.word	0xfffffbcc
 80186c0: cd cc cc cc  	.word	0xcccccccd

080186c4 <$t>:
 80186c4: b37e         	cbz	r6, 0x8018726 <__dtoa_engine+0x39e> @ imm = #0x5e
 80186c6: f04f 0a0a    	mov.w	r10, #0xa
 80186ca: 9b14         	ldr	r3, [sp, #0x50]
 80186cc: 9915         	ldr	r1, [sp, #0x54]
 80186ce: 930f         	str	r3, [sp, #0x3c]
 80186d0: 4618         	mov	r0, r3
 80186d2: f7ff fe45    	bl	0x8018360 <div10>       @ imm = #-0x376
 80186d6: 9b0f         	ldr	r3, [sp, #0x3c]
 80186d8: 910e         	str	r1, [sp, #0x38]
 80186da: fb0a f200    	mul	r2, r10, r0
 80186de: 429a         	cmp	r2, r3
 80186e0: 4681         	mov	r9, r0
 80186e2: d120         	bne	0x8018726 <__dtoa_engine+0x39e> @ imm = #0x40
 80186e4: e9dd 0112    	ldrd	r0, r1, [sp, #72]
 80186e8: f7ff fe3a    	bl	0x8018360 <div10>       @ imm = #-0x38c
 80186ec: 9010         	str	r0, [sp, #0x40]
 80186ee: 910f         	str	r1, [sp, #0x3c]
 80186f0: 4620         	mov	r0, r4
 80186f2: 4629         	mov	r1, r5
 80186f4: f7ff fe34    	bl	0x8018360 <div10>       @ imm = #-0x398
 80186f8: 9b0f         	ldr	r3, [sp, #0x3c]
 80186fa: 9a10         	ldr	r2, [sp, #0x40]
 80186fc: 9212         	str	r2, [sp, #0x48]
 80186fe: e9cd 3913    	strd	r3, r9, [sp, #76]
 8018702: 9b0e         	ldr	r3, [sp, #0x38]
 8018704: 9315         	str	r3, [sp, #0x54]
 8018706: 9b08         	ldr	r3, [sp, #0x20]
 8018708: f1b8 0f00    	cmp.w	r8, #0x0
 801870c: bf14         	ite	ne
 801870e: 2700         	movne	r7, #0x0
 8018710: f007 0701    	andeq	r7, r7, #0x1
 8018714: 3301         	adds	r3, #0x1
 8018716: fb0a 4810    	mls	r8, r10, r0, r4
 801871a: fa5f f888    	uxtb.w	r8, r8
 801871e: 9308         	str	r3, [sp, #0x20]
 8018720: 4604         	mov	r4, r0
 8018722: 460d         	mov	r5, r1
 8018724: e7d1         	b	0x80186ca <__dtoa_engine+0x342> @ imm = #-0x5e
 8018726: 9b06         	ldr	r3, [sp, #0x18]
 8018728: 9a08         	ldr	r2, [sp, #0x20]
 801872a: 4413         	add	r3, r2
 801872c: 4699         	mov	r9, r3
 801872e: 2f00         	cmp	r7, #0x0
 8018730: d05a         	beq	0x80187e8 <__dtoa_engine+0x460> @ imm = #0xb4
 8018732: f1b8 0f05    	cmp.w	r8, #0x5
 8018736: d157         	bne	0x80187e8 <__dtoa_engine+0x460> @ imm = #0xae
 8018738: f014 0301    	ands	r3, r4, #0x1
 801873c: d14a         	bne	0x80187d4 <__dtoa_engine+0x44c> @ imm = #0x94
 801873e: 9a05         	ldr	r2, [sp, #0x14]
 8018740: b932         	cbnz	r2, 0x8018750 <__dtoa_engine+0x3c8> @ imm = #0xc
 8018742: e9dd 2314    	ldrd	r2, r3, [sp, #80]
 8018746: 429d         	cmp	r5, r3
 8018748: bf08         	it	eq
 801874a: 4294         	cmpeq	r4, r2
 801874c: d05f         	beq	0x801880e <__dtoa_engine+0x486> @ imm = #0xbe
 801874e: 9b05         	ldr	r3, [sp, #0x14]
 8018750: 1918         	adds	r0, r3, r4
 8018752: f04f 040a    	mov.w	r4, #0xa
 8018756: f145 0100    	adc	r1, r5, #0x0
 801875a: 2200         	movs	r2, #0x0
 801875c: 2601         	movs	r6, #0x1
 801875e: 4625         	mov	r5, r4
 8018760: 42a0         	cmp	r0, r4
 8018762: eb71 0702    	sbcs.w	r7, r1, r2
 8018766: d255         	bhs	0x8018814 <__dtoa_engine+0x48c> @ imm = #0xaa
 8018768: b1f3         	cbz	r3, 0x80187a8 <__dtoa_engine+0x420> @ imm = #0x3c
 801876a: 45b3         	cmp	r11, r6
 801876c: da1c         	bge	0x80187a8 <__dtoa_engine+0x420> @ imm = #0x38
 801876e: 9b0d         	ldr	r3, [sp, #0x34]
 8018770: b173         	cbz	r3, 0x8018790 <__dtoa_engine+0x408> @ imm = #0x1c
 8018772: 9a0c         	ldr	r2, [sp, #0x30]
 8018774: eb06 0309    	add.w	r3, r6, r9
 8018778: 441a         	add	r2, r3
 801877a: 4613         	mov	r3, r2
 801877c: 2a01         	cmp	r2, #0x1
 801877e: 9a0b         	ldr	r2, [sp, #0x2c]
 8018780: bfb8         	it	lt
 8018782: 2301         	movlt	r3, #0x1
 8018784: 429a         	cmp	r2, r3
 8018786: bfa8         	it	ge
 8018788: 461a         	movge	r2, r3
 801878a: 4296         	cmp	r6, r2
 801878c: 4693         	mov	r11, r2
 801878e: dd0b         	ble	0x80187a8 <__dtoa_engine+0x420> @ imm = #0x16
 8018790: 3005         	adds	r0, #0x5
 8018792: f04f 020a    	mov.w	r2, #0xa
 8018796: f04f 0300    	mov.w	r3, #0x0
 801879a: f141 0100    	adc	r1, r1, #0x0
 801879e: f7e7 ff4f    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x18162
 80187a2: f109 0901    	add.w	r9, r9, #0x1
 80187a6: 3e01         	subs	r6, #0x1
 80187a8: 455e         	cmp	r6, r11
 80187aa: bfa8         	it	ge
 80187ac: 465e         	movge	r6, r11
 80187ae: b237         	sxth	r7, r6
 80187b0: fa0f f989    	sxth.w	r9, r9
 80187b4: 9b07         	ldr	r3, [sp, #0x1c]
 80187b6: fa09 f686    	sxtah	r6, r9, r6
 80187ba: f107 0805    	add.w	r8, r7, #0x5
 80187be: 3e01         	subs	r6, #0x1
 80187c0: 4498         	add	r8, r3
 80187c2: f04f 0900    	mov.w	r9, #0x0
 80187c6: 45b9         	cmp	r9, r7
 80187c8: db2b         	blt	0x8018822 <__dtoa_engine+0x49a> @ imm = #0x56
 80187ca: 9b07         	ldr	r3, [sp, #0x1c]
 80187cc: 9a0a         	ldr	r2, [sp, #0x28]
 80187ce: 601e         	str	r6, [r3]
 80187d0: 711a         	strb	r2, [r3, #0x4]
 80187d2: e5f8         	b	0x80183c6 <__dtoa_engine+0x3e> @ imm = #-0x410
 80187d4: 9b05         	ldr	r3, [sp, #0x14]
 80187d6: b92b         	cbnz	r3, 0x80187e4 <__dtoa_engine+0x45c> @ imm = #0xa
 80187d8: e9dd 2314    	ldrd	r2, r3, [sp, #80]
 80187dc: 429d         	cmp	r5, r3
 80187de: bf08         	it	eq
 80187e0: 4294         	cmpeq	r4, r2
 80187e2: d009         	beq	0x80187f8 <__dtoa_engine+0x470> @ imm = #0x12
 80187e4: 2301         	movs	r3, #0x1
 80187e6: e7b3         	b	0x8018750 <__dtoa_engine+0x3c8> @ imm = #-0x9a
 80187e8: 9b05         	ldr	r3, [sp, #0x14]
 80187ea: b953         	cbnz	r3, 0x8018802 <__dtoa_engine+0x47a> @ imm = #0x14
 80187ec: e9dd 2314    	ldrd	r2, r3, [sp, #80]
 80187f0: 429d         	cmp	r5, r3
 80187f2: bf08         	it	eq
 80187f4: 4294         	cmpeq	r4, r2
 80187f6: d104         	bne	0x8018802 <__dtoa_engine+0x47a> @ imm = #0x8
 80187f8: 9b09         	ldr	r3, [sp, #0x24]
 80187fa: 2b00         	cmp	r3, #0x0
 80187fc: d1f2         	bne	0x80187e4 <__dtoa_engine+0x45c> @ imm = #-0x1c
 80187fe: 2e00         	cmp	r6, #0x0
 8018800: d0f0         	beq	0x80187e4 <__dtoa_engine+0x45c> @ imm = #-0x20
 8018802: f1b8 0f04    	cmp.w	r8, #0x4
 8018806: bf94         	ite	ls
 8018808: 2300         	movls	r3, #0x0
 801880a: 2301         	movhi	r3, #0x1
 801880c: e7a0         	b	0x8018750 <__dtoa_engine+0x3c8> @ imm = #-0xc0
 801880e: f04f 0804    	mov.w	r8, #0x4
 8018812: e7f1         	b	0x80187f8 <__dtoa_engine+0x470> @ imm = #-0x1e
 8018814: fb05 f702    	mul	r7, r5, r2
 8018818: fba4 4205    	umull	r4, r2, r4, r5
 801881c: 3601         	adds	r6, #0x1
 801881e: 443a         	add	r2, r7
 8018820: e79e         	b	0x8018760 <__dtoa_engine+0x3d8> @ imm = #-0xc4
 8018822: 220a         	movs	r2, #0xa
 8018824: 2300         	movs	r3, #0x0
 8018826: f7e7 ff0b    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x181ea
 801882a: 3230         	adds	r2, #0x30
 801882c: f808 2d01    	strb	r2, [r8, #-1]!
 8018830: f109 0901    	add.w	r9, r9, #0x1
 8018834: e7c7         	b	0x80187c6 <__dtoa_engine+0x43e> @ imm = #-0x72
 8018836: bf00         	nop

08018838 <__log10Pow2>:
 8018838: 4b01         	ldr	r3, [pc, #0x4]          @ 0x8018840 <__log10Pow2+0x8>
 801883a: 4358         	muls	r0, r3, r0
 801883c: 0c80         	lsrs	r0, r0, #0x12
 801883e: 4770         	bx	lr

08018840 <$d>:
 8018840: 41 34 01 00  	.word	0x00013441

08018844 <__log10Pow5>:
 8018844: 4b01         	ldr	r3, [pc, #0x4]          @ 0x801884c <__log10Pow5+0x8>
 8018846: 4358         	muls	r0, r3, r0
 8018848: 0d00         	lsrs	r0, r0, #0x14
 801884a: 4770         	bx	lr

0801884c <$d>:
 801884c: fb 2e 0b 00  	.word	0x000b2efb

08018850 <__pow5bits>:
 8018850: 4b02         	ldr	r3, [pc, #0x8]          @ 0x801885c <__pow5bits+0xc>
 8018852: 4358         	muls	r0, r3, r0
 8018854: 0cc0         	lsrs	r0, r0, #0x13
 8018856: 3001         	adds	r0, #0x1
 8018858: 4770         	bx	lr
 801885a: bf00         	nop

0801885c <$d>:
 801885c: 4f 93 12 00  	.word	0x0012934f

08018860 <__pow5Factor>:
 8018860: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x801888c <__pow5Factor+0x2c>
 8018862: b570         	push	{r4, r5, r6, lr}
 8018864: 4603         	mov	r3, r0
 8018866: f04f 36cc    	mov.w	r6, #0xcccccccc
 801886a: 2000         	movs	r0, #0x0
 801886c: f04f 3533    	mov.w	r5, #0x33333333
 8018870: fb06 f403    	mul	r4, r6, r3
 8018874: fb02 4401    	mla	r4, r2, r1, r4
 8018878: fba3 3102    	umull	r3, r1, r3, r2
 801887c: 4421         	add	r1, r4
 801887e: 429d         	cmp	r5, r3
 8018880: eb75 0401    	sbcs.w	r4, r5, r1
 8018884: d301         	blo	0x801888a <__pow5Factor+0x2a> @ imm = #0x2
 8018886: 3001         	adds	r0, #0x1
 8018888: e7f2         	b	0x8018870 <__pow5Factor+0x10> @ imm = #-0x1c
 801888a: bd70         	pop	{r4, r5, r6, pc}

0801888c <$d>:
 801888c: cd cc cc cc  	.word	0xcccccccd

08018890 <__double_computePow5>:
 8018890: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8018894: 231a         	movs	r3, #0x1a
 8018896: 4e35         	ldr	r6, [pc, #0xd4]         @ 0x801896c <__double_computePow5+0xdc>
 8018898: fbb0 faf3    	udiv	r10, r0, r3
 801889c: fb03 031a    	mls	r3, r3, r10, r0
 80188a0: b089         	sub	sp, #0x24
 80188a2: 4604         	mov	r4, r0
 80188a4: 460d         	mov	r5, r1
 80188a6: eb06 160a    	add.w	r6, r6, r10, lsl #4
 80188aa: b953         	cbnz	r3, 0x80188c2 <__double_computePow5+0x32> @ imm = #0x14
 80188ac: e9d6 2300    	ldrd	r2, r3, [r6]
 80188b0: e9c1 2300    	strd	r2, r3, [r1]
 80188b4: e9d6 0102    	ldrd	r0, r1, [r6, #8]
 80188b8: e9c5 0102    	strd	r0, r1, [r5, #8]
 80188bc: b009         	add	sp, #0x24
 80188be: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80188c2: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8018970 <__double_computePow5+0xe0>
 80188c4: eb02 03c3    	add.w	r3, r2, r3, lsl #3
 80188c8: e9d3 8900    	ldrd	r8, r9, [r3]
 80188cc: ab04         	add	r3, sp, #0x10
 80188ce: 9300         	str	r3, [sp]
 80188d0: e9d6 2302    	ldrd	r2, r3, [r6, #8]
 80188d4: 4640         	mov	r0, r8
 80188d6: 4649         	mov	r1, r9
 80188d8: f00e ff1f    	bl	0x802771a <__umul128>   @ imm = #0xee3e
 80188dc: ab06         	add	r3, sp, #0x18
 80188de: 9300         	str	r3, [sp]
 80188e0: e9d6 2300    	ldrd	r2, r3, [r6]
 80188e4: 4683         	mov	r11, r0
 80188e6: 460f         	mov	r7, r1
 80188e8: 4640         	mov	r0, r8
 80188ea: 4649         	mov	r1, r9
 80188ec: f00e ff15    	bl	0x802771a <__umul128>   @ imm = #0xee2a
 80188f0: e9dd 6206    	ldrd	r6, r2, [sp, #24]
 80188f4: eb16 060b    	adds.w	r6, r6, r11
 80188f8: eb52 0807    	adcs.w	r8, r2, r7
 80188fc: f04f 0300    	mov.w	r3, #0x0
 8018900: bf28         	it	hs
 8018902: 2301         	movhs	r3, #0x1
 8018904: 4681         	mov	r9, r0
 8018906: b133         	cbz	r3, 0x8018916 <__double_computePow5+0x86> @ imm = #0xc
 8018908: 9b04         	ldr	r3, [sp, #0x10]
 801890a: 9a05         	ldr	r2, [sp, #0x14]
 801890c: 3301         	adds	r3, #0x1
 801890e: f142 0200    	adc	r2, r2, #0x0
 8018912: e9cd 3204    	strd	r3, r2, [sp, #16]
 8018916: 4620         	mov	r0, r4
 8018918: 9103         	str	r1, [sp, #0xc]
 801891a: f7ff ff99    	bl	0x8018850 <__pow5bits>  @ imm = #-0xce
 801891e: 4607         	mov	r7, r0
 8018920: 201a         	movs	r0, #0x1a
 8018922: fb00 f00a    	mul	r0, r0, r10
 8018926: f7ff ff93    	bl	0x8018850 <__pow5bits>  @ imm = #-0xda
 801892a: 1a3f         	subs	r7, r7, r0
 801892c: 4632         	mov	r2, r6
 801892e: 4643         	mov	r3, r8
 8018930: 9903         	ldr	r1, [sp, #0xc]
 8018932: 9700         	str	r7, [sp]
 8018934: 4648         	mov	r0, r9
 8018936: f00e ff0b    	bl	0x8027750 <__shiftright128> @ imm = #0xee16
 801893a: ea4f 1c14    	lsr.w	r12, r4, #0x4
 801893e: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8018974 <__double_computePow5+0xe4>
 8018940: 0064         	lsls	r4, r4, #0x1
 8018942: f004 031e    	and	r3, r4, #0x1e
 8018946: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 801894a: 40dc         	lsrs	r4, r3
 801894c: f004 0403    	and	r4, r4, #0x3
 8018950: 1824         	adds	r4, r4, r0
 8018952: f141 0100    	adc	r1, r1, #0x0
 8018956: e9c5 4100    	strd	r4, r1, [r5]
 801895a: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 801895e: 9700         	str	r7, [sp]
 8018960: 4630         	mov	r0, r6
 8018962: 4641         	mov	r1, r8
 8018964: f00e fef4    	bl	0x8027750 <__shiftright128> @ imm = #0xede8
 8018968: e7a6         	b	0x80188b8 <__double_computePow5+0x28> @ imm = #-0xb4
 801896a: bf00         	nop

0801896c <$d>:
 801896c: 28 a5 02 08  	.word	0x0802a528
 8018970: 58 a4 02 08  	.word	0x0802a458
 8018974: ac bc 02 08  	.word	0x0802bcac

08018978 <__double_computeInvPow5>:
 8018978: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 801897c: 271a         	movs	r7, #0x1a
 801897e: f8df a0ec    	ldr.w	r10, [pc, #0xec]        @ 0x8018a6c <__double_computeInvPow5+0xf4>
 8018982: f100 0519    	add.w	r5, r0, #0x19
 8018986: fbb5 f5f7    	udiv	r5, r5, r7
 801898a: 436f         	muls	r7, r5, r7
 801898c: 1a3a         	subs	r2, r7, r0
 801898e: ea4f 1b05    	lsl.w	r11, r5, #0x4
 8018992: b089         	sub	sp, #0x24
 8018994: 4604         	mov	r4, r0
 8018996: 460e         	mov	r6, r1
 8018998: eb0a 1505    	add.w	r5, r10, r5, lsl #4
 801899c: d10a         	bne	0x80189b4 <__double_computeInvPow5+0x3c> @ imm = #0x14
 801899e: e9d5 2300    	ldrd	r2, r3, [r5]
 80189a2: e9c1 2300    	strd	r2, r3, [r1]
 80189a6: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 80189aa: e9c6 0102    	strd	r0, r1, [r6, #8]
 80189ae: b009         	add	sp, #0x24
 80189b0: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80189b4: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8018a64 <__double_computeInvPow5+0xec>
 80189b6: eb03 03c2    	add.w	r3, r3, r2, lsl #3
 80189ba: e9d3 8900    	ldrd	r8, r9, [r3]
 80189be: ab04         	add	r3, sp, #0x10
 80189c0: 9300         	str	r3, [sp]
 80189c2: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 80189c6: 4640         	mov	r0, r8
 80189c8: 4649         	mov	r1, r9
 80189ca: f00e fea6    	bl	0x802771a <__umul128>   @ imm = #0xed4c
 80189ce: f85a 200b    	ldr.w	r2, [r10, r11]
 80189d2: 686b         	ldr	r3, [r5, #0x4]
 80189d4: 3a01         	subs	r2, #0x1
 80189d6: e9cd 0102    	strd	r0, r1, [sp, #8]
 80189da: a906         	add	r1, sp, #0x18
 80189dc: f163 0300    	sbc	r3, r3, #0x0
 80189e0: 9100         	str	r1, [sp]
 80189e2: 4640         	mov	r0, r8
 80189e4: 4649         	mov	r1, r9
 80189e6: f00e fe98    	bl	0x802771a <__umul128>   @ imm = #0xed30
 80189ea: e9dd 5206    	ldrd	r5, r2, [sp, #24]
 80189ee: 468a         	mov	r10, r1
 80189f0: 9902         	ldr	r1, [sp, #0x8]
 80189f2: 186d         	adds	r5, r5, r1
 80189f4: 9903         	ldr	r1, [sp, #0xc]
 80189f6: eb52 0801    	adcs.w	r8, r2, r1
 80189fa: f04f 0300    	mov.w	r3, #0x0
 80189fe: bf28         	it	hs
 8018a00: 2301         	movhs	r3, #0x1
 8018a02: 4681         	mov	r9, r0
 8018a04: b133         	cbz	r3, 0x8018a14 <__double_computeInvPow5+0x9c> @ imm = #0xc
 8018a06: 9b04         	ldr	r3, [sp, #0x10]
 8018a08: 9a05         	ldr	r2, [sp, #0x14]
 8018a0a: 3301         	adds	r3, #0x1
 8018a0c: f142 0200    	adc	r2, r2, #0x0
 8018a10: e9cd 3204    	strd	r3, r2, [sp, #16]
 8018a14: 4638         	mov	r0, r7
 8018a16: f7ff ff1b    	bl	0x8018850 <__pow5bits>  @ imm = #-0x1ca
 8018a1a: 4607         	mov	r7, r0
 8018a1c: 4620         	mov	r0, r4
 8018a1e: f7ff ff17    	bl	0x8018850 <__pow5bits>  @ imm = #-0x1d2
 8018a22: 1a3f         	subs	r7, r7, r0
 8018a24: 462a         	mov	r2, r5
 8018a26: 4643         	mov	r3, r8
 8018a28: 9700         	str	r7, [sp]
 8018a2a: 4648         	mov	r0, r9
 8018a2c: 4651         	mov	r1, r10
 8018a2e: f00e fe8f    	bl	0x8027750 <__shiftright128> @ imm = #0xed1e
 8018a32: ea4f 1c14    	lsr.w	r12, r4, #0x4
 8018a36: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8018a68 <__double_computeInvPow5+0xf0>
 8018a38: 0064         	lsls	r4, r4, #0x1
 8018a3a: f004 031e    	and	r3, r4, #0x1e
 8018a3e: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 8018a42: 40dc         	lsrs	r4, r3
 8018a44: f004 0403    	and	r4, r4, #0x3
 8018a48: 3401         	adds	r4, #0x1
 8018a4a: 1824         	adds	r4, r4, r0
 8018a4c: f141 0100    	adc	r1, r1, #0x0
 8018a50: e9c6 4100    	strd	r4, r1, [r6]
 8018a54: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 8018a58: 9700         	str	r7, [sp]
 8018a5a: 4628         	mov	r0, r5
 8018a5c: 4641         	mov	r1, r8
 8018a5e: f00e fe77    	bl	0x8027750 <__shiftright128> @ imm = #0xecee
 8018a62: e7a2         	b	0x80189aa <__double_computeInvPow5+0x32> @ imm = #-0xbc

08018a64 <$d>:
 8018a64: 58 a4 02 08  	.word	0x0802a458
 8018a68: 00 bd 02 08  	.word	0x0802bd00
 8018a6c: f8 a5 02 08  	.word	0x0802a5f8

08018a70 <acosf>:
 8018a70: ee10 3a10    	vmov	r3, s0
 8018a74: f023 4200    	bic	r2, r3, #0x80000000
 8018a78: f1b2 5f7e    	cmp.w	r2, #0x3f800000
 8018a7c: eef0 7a40    	vmov.f32	s15, s0
 8018a80: d109         	bne	0x8018a96 <acosf+0x26>  @ imm = #0x12
 8018a82: 2b00         	cmp	r3, #0x0
 8018a84: f300 80c0    	bgt.w	0x8018c08 <acosf+0x198> @ imm = #0x180
 8018a88: eddf 7a61    	vldr	s15, [pc, #388]         @ 0x8018c10 <acosf+0x1a0>
 8018a8c: ed9f 0a61    	vldr	s0, [pc, #388]          @ 0x8018c14 <acosf+0x1a4>
 8018a90: ee30 0a27    	vadd.f32	s0, s0, s15
 8018a94: 4770         	bx	lr
 8018a96: d901         	bls	0x8018a9c <acosf+0x2c>  @ imm = #0x2
 8018a98: f000 bd14    	b.w	0x80194c4 <__math_invalidf> @ imm = #0xa28
 8018a9c: f1b2 5f7c    	cmp.w	r2, #0x3f000000
 8018aa0: d23e         	bhs	0x8018b20 <acosf+0xb0>  @ imm = #0x7c
 8018aa2: f1b2 5f0c    	cmp.w	r2, #0x23000000
 8018aa6: ed9f 0a5c    	vldr	s0, [pc, #368]          @ 0x8018c18 <acosf+0x1a8>
 8018aaa: eddf 6a5c    	vldr	s13, [pc, #368]         @ 0x8018c1c <acosf+0x1ac>
 8018aae: d802         	bhi	0x8018ab6 <acosf+0x46>  @ imm = #0x4
 8018ab0: ee30 0a26    	vadd.f32	s0, s0, s13
 8018ab4: 4770         	bx	lr
 8018ab6: ee27 7aa7    	vmul.f32	s14, s15, s15
 8018aba: eddf 5a59    	vldr	s11, [pc, #356]         @ 0x8018c20 <acosf+0x1b0>
 8018abe: ed9f 6a59    	vldr	s12, [pc, #356]         @ 0x8018c24 <acosf+0x1b4>
 8018ac2: ed9f 5a59    	vldr	s10, [pc, #356]         @ 0x8018c28 <acosf+0x1b8>
 8018ac6: ee07 6a25    	vmla.f32	s12, s14, s11
 8018aca: eddf 5a58    	vldr	s11, [pc, #352]         @ 0x8018c2c <acosf+0x1bc>
 8018ace: ee56 5a07    	vnmls.f32	s11, s12, s14
 8018ad2: ed9f 6a57    	vldr	s12, [pc, #348]         @ 0x8018c30 <acosf+0x1c0>
 8018ad6: ee05 6a87    	vmla.f32	s12, s11, s14
 8018ada: eddf 5a56    	vldr	s11, [pc, #344]         @ 0x8018c34 <acosf+0x1c4>
 8018ade: ee56 5a07    	vnmls.f32	s11, s12, s14
 8018ae2: ed9f 6a55    	vldr	s12, [pc, #340]         @ 0x8018c38 <acosf+0x1c8>
 8018ae6: ee05 6a87    	vmla.f32	s12, s11, s14
 8018aea: eddf 5a54    	vldr	s11, [pc, #336]         @ 0x8018c3c <acosf+0x1cc>
 8018aee: ee17 5a25    	vnmls.f32	s10, s14, s11
 8018af2: eddf 5a53    	vldr	s11, [pc, #332]         @ 0x8018c40 <acosf+0x1d0>
 8018af6: ee45 5a07    	vmla.f32	s11, s10, s14
 8018afa: ed9f 5a52    	vldr	s10, [pc, #328]         @ 0x8018c44 <acosf+0x1d4>
 8018afe: ee15 5a87    	vnmls.f32	s10, s11, s14
 8018b02: eef7 5a00    	vmov.f32	s11, #1.000000e+00
 8018b06: ee45 5a07    	vmla.f32	s11, s10, s14
 8018b0a: ee26 6a07    	vmul.f32	s12, s12, s14
 8018b0e: ee86 7a25    	vdiv.f32	s14, s12, s11
 8018b12: ee47 6a67    	vmls.f32	s13, s14, s15
 8018b16: ee77 6ae6    	vsub.f32	s13, s15, s13
 8018b1a: ee30 0a66    	vsub.f32	s0, s0, s13
 8018b1e: 4770         	bx	lr
 8018b20: 2b00         	cmp	r3, #0x0
 8018b22: ed9f 1a3f    	vldr	s2, [pc, #252]          @ 0x8018c20 <acosf+0x1b0>
 8018b26: eddf 2a3f    	vldr	s5, [pc, #252]          @ 0x8018c24 <acosf+0x1b4>
 8018b2a: ed9f 3a40    	vldr	s6, [pc, #256]          @ 0x8018c2c <acosf+0x1bc>
 8018b2e: eddf 3a40    	vldr	s7, [pc, #256]          @ 0x8018c30 <acosf+0x1c0>
 8018b32: ed9f 4a40    	vldr	s8, [pc, #256]          @ 0x8018c34 <acosf+0x1c4>
 8018b36: ed9f 7a40    	vldr	s14, [pc, #256]         @ 0x8018c38 <acosf+0x1c8>
 8018b3a: eddf 1a40    	vldr	s3, [pc, #256]          @ 0x8018c3c <acosf+0x1cc>
 8018b3e: eddf 4a3a    	vldr	s9, [pc, #232]          @ 0x8018c28 <acosf+0x1b8>
 8018b42: ed9f 5a3f    	vldr	s10, [pc, #252]         @ 0x8018c40 <acosf+0x1d0>
 8018b46: eddf 5a3f    	vldr	s11, [pc, #252]         @ 0x8018c44 <acosf+0x1d4>
 8018b4a: eef7 6a00    	vmov.f32	s13, #1.000000e+00
 8018b4e: eeb6 6a00    	vmov.f32	s12, #5.000000e-01
 8018b52: da28         	bge	0x8018ba6 <acosf+0x136> @ imm = #0x50
 8018b54: ee30 0a26    	vadd.f32	s0, s0, s13
 8018b58: ee20 0a06    	vmul.f32	s0, s0, s12
 8018b5c: eeb1 6ac0    	vsqrt.f32	s12, s0
 8018b60: ee40 2a01    	vmla.f32	s5, s0, s2
 8018b64: ee50 4a21    	vnmls.f32	s9, s0, s3
 8018b68: ee12 3a80    	vnmls.f32	s6, s5, s0
 8018b6c: ee04 5a80    	vmla.f32	s10, s9, s0
 8018b70: ee43 3a00    	vmla.f32	s7, s6, s0
 8018b74: ee55 5a00    	vnmls.f32	s11, s10, s0
 8018b78: ee13 4a80    	vnmls.f32	s8, s7, s0
 8018b7c: ee45 6a80    	vmla.f32	s13, s11, s0
 8018b80: ee04 7a00    	vmla.f32	s14, s8, s0
 8018b84: eddf 7a25    	vldr	s15, [pc, #148]         @ 0x8018c1c <acosf+0x1ac>
 8018b88: ee27 7a00    	vmul.f32	s14, s14, s0
 8018b8c: ed9f 0a21    	vldr	s0, [pc, #132]          @ 0x8018c14 <acosf+0x1a4>
 8018b90: eec7 5a26    	vdiv.f32	s11, s14, s13
 8018b94: ee55 7a86    	vnmls.f32	s15, s11, s12
 8018b98: ee77 7a86    	vadd.f32	s15, s15, s12
 8018b9c: ee77 7aa7    	vadd.f32	s15, s15, s15
 8018ba0: ee30 0a67    	vsub.f32	s0, s0, s15
 8018ba4: 4770         	bx	lr
 8018ba6: ee36 0ac0    	vsub.f32	s0, s13, s0
 8018baa: ee20 0a06    	vmul.f32	s0, s0, s12
 8018bae: eeb1 2ac0    	vsqrt.f32	s4, s0
 8018bb2: ee40 2a01    	vmla.f32	s5, s0, s2
 8018bb6: ee50 4a21    	vnmls.f32	s9, s0, s3
 8018bba: ee12 3a80    	vnmls.f32	s6, s5, s0
 8018bbe: ee04 5a80    	vmla.f32	s10, s9, s0
 8018bc2: ee43 3a00    	vmla.f32	s7, s6, s0
 8018bc6: ee55 5a00    	vnmls.f32	s11, s10, s0
 8018bca: ee13 4a80    	vnmls.f32	s8, s7, s0
 8018bce: ee12 3a10    	vmov	r3, s4
 8018bd2: ee04 7a00    	vmla.f32	s14, s8, s0
 8018bd6: f423 637f    	bic	r3, r3, #0xff0
 8018bda: f023 030f    	bic	r3, r3, #0xf
 8018bde: ee06 3a10    	vmov	s12, r3
 8018be2: ee45 6a80    	vmla.f32	s13, s11, s0
 8018be6: ee27 7a00    	vmul.f32	s14, s14, s0
 8018bea: ee06 0a46    	vmls.f32	s0, s12, s12
 8018bee: eec7 5a26    	vdiv.f32	s11, s14, s13
 8018bf2: ee36 7a02    	vadd.f32	s14, s12, s4
 8018bf6: eec0 7a07    	vdiv.f32	s15, s0, s14
 8018bfa: ee45 7a82    	vmla.f32	s15, s11, s4
 8018bfe: ee37 0a86    	vadd.f32	s0, s15, s12
 8018c02: ee30 0a00    	vadd.f32	s0, s0, s0
 8018c06: 4770         	bx	lr
 8018c08: ed9f 0a0f    	vldr	s0, [pc, #60]           @ 0x8018c48 <acosf+0x1d8>
 8018c0c: 4770         	bx	lr
 8018c0e: bf00         	nop

08018c10 <$d>:
 8018c10: 68 21 22 34  	.word	0x34222168
 8018c14: da 0f 49 40  	.word	0x40490fda
 8018c18: da 0f c9 3f  	.word	0x3fc90fda
 8018c1c: 68 21 a2 33  	.word	0x33a22168
 8018c20: 08 ef 11 38  	.word	0x3811ef08
 8018c24: 04 7f 4f 3a  	.word	0x3a4f7f04
 8018c28: 61 33 30 3f  	.word	0x3f303361
 8018c2c: 46 11 24 3d  	.word	0x3d241146
 8018c30: a8 0a 4e 3e  	.word	0x3e4e0aa8
 8018c34: 90 b0 a6 3e  	.word	0x3ea6b090
 8018c38: ab aa 2a 3e  	.word	0x3e2aaaab
 8018c3c: 2e c6 9d 3d  	.word	0x3d9dc62e
 8018c40: 2d 57 01 40  	.word	0x4001572d
 8018c44: 39 d1 19 40  	.word	0x4019d139
 8018c48: 00 00 00 00  	.word	0x00000000

08018c4c <asinf>:
 8018c4c: ee10 2a10    	vmov	r2, s0
 8018c50: f022 4300    	bic	r3, r2, #0x80000000
 8018c54: f1b3 5f7e    	cmp.w	r3, #0x3f800000
 8018c58: eef0 7a40    	vmov.f32	s15, s0
 8018c5c: d10c         	bne	0x8018c78 <asinf+0x2c>  @ imm = #0x18
 8018c5e: ed9f 7a5c    	vldr	s14, [pc, #368]         @ 0x8018dd0 <asinf+0x184>
 8018c62: eddf 6a5c    	vldr	s13, [pc, #368]         @ 0x8018dd4 <asinf+0x188>
 8018c66: ee20 7a07    	vmul.f32	s14, s0, s14
 8018c6a: ee00 7a26    	vmla.f32	s14, s0, s13
 8018c6e: eef0 7a47    	vmov.f32	s15, s14
 8018c72: eeb0 0a67    	vmov.f32	s0, s15
 8018c76: 4770         	bx	lr
 8018c78: d901         	bls	0x8018c7e <asinf+0x32>  @ imm = #0x2
 8018c7a: f000 bc23    	b.w	0x80194c4 <__math_invalidf> @ imm = #0x846
 8018c7e: f1b3 5f7c    	cmp.w	r3, #0x3f000000
 8018c82: eef7 6a00    	vmov.f32	s13, #1.000000e+00
 8018c86: d20b         	bhs	0x8018ca0 <asinf+0x54>  @ imm = #0x16
 8018c88: f1b3 5f48    	cmp.w	r3, #0x32000000
 8018c8c: d250         	bhs	0x8018d30 <asinf+0xe4>  @ imm = #0xa0
 8018c8e: ed9f 7a52    	vldr	s14, [pc, #328]         @ 0x8018dd8 <asinf+0x18c>
 8018c92: ee30 7a07    	vadd.f32	s14, s0, s14
 8018c96: eeb4 7ae6    	vcmpe.f32	s14, s13
 8018c9a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8018c9e: dce8         	bgt	0x8018c72 <asinf+0x26>  @ imm = #-0x30
 8018ca0: eef0 7ae7    	vabs.f32	s15, s15
 8018ca4: ee76 7ae7    	vsub.f32	s15, s13, s15
 8018ca8: eeb6 7a00    	vmov.f32	s14, #5.000000e-01
 8018cac: ee67 7a87    	vmul.f32	s15, s15, s14
 8018cb0: ed9f 6a4a    	vldr	s12, [pc, #296]         @ 0x8018ddc <asinf+0x190>
 8018cb4: ed9f 7a4a    	vldr	s14, [pc, #296]         @ 0x8018de0 <asinf+0x194>
 8018cb8: eddf 5a4a    	vldr	s11, [pc, #296]         @ 0x8018de4 <asinf+0x198>
 8018cbc: ee07 6a87    	vmla.f32	s12, s15, s14
 8018cc0: ed9f 7a49    	vldr	s14, [pc, #292]         @ 0x8018de8 <asinf+0x19c>
 8018cc4: ee16 7a27    	vnmls.f32	s14, s12, s15
 8018cc8: ed9f 6a48    	vldr	s12, [pc, #288]         @ 0x8018dec <asinf+0x1a0>
 8018ccc: ee07 6a27    	vmla.f32	s12, s14, s15
 8018cd0: ed9f 7a47    	vldr	s14, [pc, #284]         @ 0x8018df0 <asinf+0x1a4>
 8018cd4: ee16 7a27    	vnmls.f32	s14, s12, s15
 8018cd8: ed9f 6a46    	vldr	s12, [pc, #280]         @ 0x8018df4 <asinf+0x1a8>
 8018cdc: ee07 6a27    	vmla.f32	s12, s14, s15
 8018ce0: ed9f 7a45    	vldr	s14, [pc, #276]         @ 0x8018df8 <asinf+0x1ac>
 8018ce4: ee17 7aa5    	vnmls.f32	s14, s15, s11
 8018ce8: eddf 5a44    	vldr	s11, [pc, #272]         @ 0x8018dfc <asinf+0x1b0>
 8018cec: ee47 5a27    	vmla.f32	s11, s14, s15
 8018cf0: ed9f 7a43    	vldr	s14, [pc, #268]         @ 0x8018e00 <asinf+0x1b4>
 8018cf4: ee15 7aa7    	vnmls.f32	s14, s11, s15
 8018cf8: ee26 6a27    	vmul.f32	s12, s12, s15
 8018cfc: ee47 6a27    	vmla.f32	s13, s14, s15
 8018d00: eeb1 7ae7    	vsqrt.f32	s14, s15
 8018d04: 493f         	ldr	r1, [pc, #0xfc]         @ 0x8018e04 <asinf+0x1b8>
 8018d06: 428b         	cmp	r3, r1
 8018d08: eec6 5a26    	vdiv.f32	s11, s12, s13
 8018d0c: d93f         	bls	0x8018d8e <asinf+0x142> @ imm = #0x7e
 8018d0e: ee05 7a87    	vmla.f32	s14, s11, s14
 8018d12: eddf 7a3d    	vldr	s15, [pc, #244]         @ 0x8018e08 <asinf+0x1bc>
 8018d16: ee37 7a07    	vadd.f32	s14, s14, s14
 8018d1a: ee37 7a27    	vadd.f32	s14, s14, s15
 8018d1e: eddf 7a2d    	vldr	s15, [pc, #180]         @ 0x8018dd4 <asinf+0x188>
 8018d22: ee77 7ac7    	vsub.f32	s15, s15, s14
 8018d26: 2a00         	cmp	r2, #0x0
 8018d28: bfd8         	it	le
 8018d2a: eef1 7a67    	vnegle.f32	s15, s15
 8018d2e: e7a0         	b	0x8018c72 <asinf+0x26>  @ imm = #-0xc0
 8018d30: ee20 7a00    	vmul.f32	s14, s0, s0
 8018d34: eddf 5a2a    	vldr	s11, [pc, #168]         @ 0x8018de0 <asinf+0x194>
 8018d38: ed9f 6a28    	vldr	s12, [pc, #160]         @ 0x8018ddc <asinf+0x190>
 8018d3c: ed9f 5a29    	vldr	s10, [pc, #164]         @ 0x8018de4 <asinf+0x198>
 8018d40: ee07 6a25    	vmla.f32	s12, s14, s11
 8018d44: eddf 5a28    	vldr	s11, [pc, #160]         @ 0x8018de8 <asinf+0x19c>
 8018d48: ee56 5a07    	vnmls.f32	s11, s12, s14
 8018d4c: ed9f 6a27    	vldr	s12, [pc, #156]         @ 0x8018dec <asinf+0x1a0>
 8018d50: ee05 6a87    	vmla.f32	s12, s11, s14
 8018d54: eddf 5a26    	vldr	s11, [pc, #152]         @ 0x8018df0 <asinf+0x1a4>
 8018d58: ee56 5a07    	vnmls.f32	s11, s12, s14
 8018d5c: ed9f 6a25    	vldr	s12, [pc, #148]         @ 0x8018df4 <asinf+0x1a8>
 8018d60: ee05 6a87    	vmla.f32	s12, s11, s14
 8018d64: eddf 5a24    	vldr	s11, [pc, #144]         @ 0x8018df8 <asinf+0x1ac>
 8018d68: ee57 5a05    	vnmls.f32	s11, s14, s10
 8018d6c: ed9f 5a23    	vldr	s10, [pc, #140]         @ 0x8018dfc <asinf+0x1b0>
 8018d70: ee05 5a87    	vmla.f32	s10, s11, s14
 8018d74: eddf 5a22    	vldr	s11, [pc, #136]         @ 0x8018e00 <asinf+0x1b4>
 8018d78: ee55 5a07    	vnmls.f32	s11, s10, s14
 8018d7c: ee26 6a07    	vmul.f32	s12, s12, s14
 8018d80: ee45 6a87    	vmla.f32	s13, s11, s14
 8018d84: ee86 7a26    	vdiv.f32	s14, s12, s13
 8018d88: ee47 7a00    	vmla.f32	s15, s14, s0
 8018d8c: e771         	b	0x8018c72 <asinf+0x26>  @ imm = #-0x11e
 8018d8e: ee17 3a10    	vmov	r3, s14
 8018d92: f423 637f    	bic	r3, r3, #0xff0
 8018d96: f023 030f    	bic	r3, r3, #0xf
 8018d9a: ee06 3a90    	vmov	s13, r3
 8018d9e: ee46 7ae6    	vmls.f32	s15, s13, s13
 8018da2: ee37 5a07    	vadd.f32	s10, s14, s14
 8018da6: ee37 7a26    	vadd.f32	s14, s14, s13
 8018daa: ee76 6aa6    	vadd.f32	s13, s13, s13
 8018dae: ee87 6a87    	vdiv.f32	s12, s15, s14
 8018db2: ed9f 7a07    	vldr	s14, [pc, #28]          @ 0x8018dd0 <asinf+0x184>
 8018db6: eddf 7a15    	vldr	s15, [pc, #84]          @ 0x8018e0c <asinf+0x1c0>
 8018dba: ee36 6a06    	vadd.f32	s12, s12, s12
 8018dbe: ee77 6ae6    	vsub.f32	s13, s15, s13
 8018dc2: ee37 7a46    	vsub.f32	s14, s14, s12
 8018dc6: ee15 7a25    	vnmls.f32	s14, s10, s11
 8018dca: ee37 7a66    	vsub.f32	s14, s14, s13
 8018dce: e7a8         	b	0x8018d22 <asinf+0xd6>  @ imm = #-0xb0

08018dd0 <$d>:
 8018dd0: 2e bd 3b b3  	.word	0xb33bbd2e
 8018dd4: db 0f c9 3f  	.word	0x3fc90fdb
 8018dd8: ca f2 49 71  	.word	0x7149f2ca
 8018ddc: 04 7f 4f 3a  	.word	0x3a4f7f04
 8018de0: 08 ef 11 38  	.word	0x3811ef08
 8018de4: 2e c6 9d 3d  	.word	0x3d9dc62e
 8018de8: 46 11 24 3d  	.word	0x3d241146
 8018dec: a8 0a 4e 3e  	.word	0x3e4e0aa8
 8018df0: 90 b0 a6 3e  	.word	0x3ea6b090
 8018df4: ab aa 2a 3e  	.word	0x3e2aaaab
 8018df8: 61 33 30 3f  	.word	0x3f303361
 8018dfc: 2d 57 01 40  	.word	0x4001572d
 8018e00: 39 d1 19 40  	.word	0x4019d139
 8018e04: 99 99 79 3f  	.word	0x3f799999
 8018e08: 2e bd 3b 33  	.word	0x333bbd2e
 8018e0c: db 0f 49 3f  	.word	0x3f490fdb

08018e10 <atan2f>:
 8018e10: ee10 2a90    	vmov	r2, s1
 8018e14: f022 4100    	bic	r1, r2, #0x80000000
 8018e18: f1b1 4fff    	cmp.w	r1, #0x7f800000
 8018e1c: b510         	push	{r4, lr}
 8018e1e: eef0 7a40    	vmov.f32	s15, s0
 8018e22: d806         	bhi	0x8018e32 <atan2f+0x22> @ imm = #0xc
 8018e24: ee10 0a10    	vmov	r0, s0
 8018e28: f020 4300    	bic	r3, r0, #0x80000000
 8018e2c: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8018e30: d904         	bls	0x8018e3c <atan2f+0x2c> @ imm = #0x8
 8018e32: ee77 7aa0    	vadd.f32	s15, s15, s1
 8018e36: eeb0 0a67    	vmov.f32	s0, s15
 8018e3a: bd10         	pop	{r4, pc}
 8018e3c: f1b2 5f7e    	cmp.w	r2, #0x3f800000
 8018e40: d103         	bne	0x8018e4a <atan2f+0x3a> @ imm = #0x6
 8018e42: e8bd 4010    	pop.w	{r4, lr}
 8018e46: f000 be6f    	b.w	0x8019b28 <atanf>       @ imm = #0xcde
 8018e4a: 1794         	asrs	r4, r2, #0x1e
 8018e4c: f004 0402    	and	r4, r4, #0x2
 8018e50: ea44 74d0    	orr.w	r4, r4, r0, lsr #31
 8018e54: b98b         	cbnz	r3, 0x8018e7a <atan2f+0x6a> @ imm = #0x22
 8018e56: 2c02         	cmp	r4, #0x2
 8018e58: d008         	beq	0x8018e6c <atan2f+0x5c> @ imm = #0x10
 8018e5a: 2c03         	cmp	r4, #0x3
 8018e5c: d1eb         	bne	0x8018e36 <atan2f+0x26> @ imm = #-0x2a
 8018e5e: eddf 7a41    	vldr	s15, [pc, #260]         @ 0x8018f64 <atan2f+0x154>
 8018e62: ed9f 7a41    	vldr	s14, [pc, #260]         @ 0x8018f68 <atan2f+0x158>
 8018e66: ee77 7ac7    	vsub.f32	s15, s15, s14
 8018e6a: e7e4         	b	0x8018e36 <atan2f+0x26> @ imm = #-0x38
 8018e6c: eddf 7a3f    	vldr	s15, [pc, #252]         @ 0x8018f6c <atan2f+0x15c>
 8018e70: ed9f 7a3d    	vldr	s14, [pc, #244]         @ 0x8018f68 <atan2f+0x158>
 8018e74: ee77 7a87    	vadd.f32	s15, s15, s14
 8018e78: e7dd         	b	0x8018e36 <atan2f+0x26> @ imm = #-0x46
 8018e7a: b939         	cbnz	r1, 0x8018e8c <atan2f+0x7c> @ imm = #0xe
 8018e7c: 2800         	cmp	r0, #0x0
 8018e7e: da02         	bge	0x8018e86 <atan2f+0x76> @ imm = #0x4
 8018e80: eddf 7a3b    	vldr	s15, [pc, #236]         @ 0x8018f70 <atan2f+0x160>
 8018e84: e7ed         	b	0x8018e62 <atan2f+0x52> @ imm = #-0x26
 8018e86: eddf 7a3b    	vldr	s15, [pc, #236]         @ 0x8018f74 <atan2f+0x164>
 8018e8a: e7f1         	b	0x8018e70 <atan2f+0x60> @ imm = #-0x1e
 8018e8c: f1b1 4fff    	cmp.w	r1, #0x7f800000
 8018e90: d12d         	bne	0x8018eee <atan2f+0xde> @ imm = #0x5a
 8018e92: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8018e96: d11d         	bne	0x8018ed4 <atan2f+0xc4> @ imm = #0x3a
 8018e98: 2c02         	cmp	r4, #0x2
 8018e9a: eddf 7a33    	vldr	s15, [pc, #204]         @ 0x8018f68 <atan2f+0x158>
 8018e9e: d00b         	beq	0x8018eb8 <atan2f+0xa8> @ imm = #0x16
 8018ea0: 2c03         	cmp	r4, #0x3
 8018ea2: d010         	beq	0x8018ec6 <atan2f+0xb6> @ imm = #0x20
 8018ea4: 2c01         	cmp	r4, #0x1
 8018ea6: d002         	beq	0x8018eae <atan2f+0x9e> @ imm = #0x4
 8018ea8: ed9f 7a33    	vldr	s14, [pc, #204]         @ 0x8018f78 <atan2f+0x168>
 8018eac: e7e2         	b	0x8018e74 <atan2f+0x64> @ imm = #-0x3c
 8018eae: ed9f 7a33    	vldr	s14, [pc, #204]         @ 0x8018f7c <atan2f+0x16c>
 8018eb2: ee77 7a67    	vsub.f32	s15, s14, s15
 8018eb6: e7be         	b	0x8018e36 <atan2f+0x26> @ imm = #-0x84
 8018eb8: eddf 6a2f    	vldr	s13, [pc, #188]         @ 0x8018f78 <atan2f+0x168>
 8018ebc: eeb0 7a08    	vmov.f32	s14, #3.000000e+00
 8018ec0: ee46 7a87    	vmla.f32	s15, s13, s14
 8018ec4: e7b7         	b	0x8018e36 <atan2f+0x26> @ imm = #-0x92
 8018ec6: eddf 6a2c    	vldr	s13, [pc, #176]         @ 0x8018f78 <atan2f+0x168>
 8018eca: eeb8 7a08    	vmov.f32	s14, #-3.000000e+00
 8018ece: ee56 7a87    	vnmls.f32	s15, s13, s14
 8018ed2: e7b0         	b	0x8018e36 <atan2f+0x26> @ imm = #-0xa0
 8018ed4: 2c02         	cmp	r4, #0x2
 8018ed6: d0c9         	beq	0x8018e6c <atan2f+0x5c> @ imm = #-0x6e
 8018ed8: 2c03         	cmp	r4, #0x3
 8018eda: d0c0         	beq	0x8018e5e <atan2f+0x4e> @ imm = #-0x80
 8018edc: eddf 7a28    	vldr	s15, [pc, #160]         @ 0x8018f80 <atan2f+0x170>
 8018ee0: ed9f 7a28    	vldr	s14, [pc, #160]         @ 0x8018f84 <atan2f+0x174>
 8018ee4: 2c01         	cmp	r4, #0x1
 8018ee6: bf18         	it	ne
 8018ee8: eef0 7a47    	vmovne.f32	s15, s14
 8018eec: e7a3         	b	0x8018e36 <atan2f+0x26> @ imm = #-0xba
 8018eee: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8018ef2: d0c3         	beq	0x8018e7c <atan2f+0x6c> @ imm = #-0x7a
 8018ef4: 1a5b         	subs	r3, r3, r1
 8018ef6: f1b3 5ff4    	cmp.w	r3, #0x1e800000
 8018efa: ea4f 51e3    	asr.w	r1, r3, #0x17
 8018efe: db12         	blt	0x8018f26 <atan2f+0x116> @ imm = #0x24
 8018f00: eddf 7a1c    	vldr	s15, [pc, #112]         @ 0x8018f74 <atan2f+0x164>
 8018f04: ed9f 7a20    	vldr	s14, [pc, #128]         @ 0x8018f88 <atan2f+0x178>
 8018f08: ee77 7ac7    	vsub.f32	s15, s15, s14
 8018f0c: 2c01         	cmp	r4, #0x1
 8018f0e: d01a         	beq	0x8018f46 <atan2f+0x136> @ imm = #0x34
 8018f10: 2c02         	cmp	r4, #0x2
 8018f12: d01f         	beq	0x8018f54 <atan2f+0x144> @ imm = #0x3e
 8018f14: 2c00         	cmp	r4, #0x0
 8018f16: d08e         	beq	0x8018e36 <atan2f+0x26> @ imm = #-0xe4
 8018f18: ed9f 7a1c    	vldr	s14, [pc, #112]         @ 0x8018f8c <atan2f+0x17c>
 8018f1c: ee77 7a87    	vadd.f32	s15, s15, s14
 8018f20: ed9f 7a12    	vldr	s14, [pc, #72]          @ 0x8018f6c <atan2f+0x15c>
 8018f24: e79f         	b	0x8018e66 <atan2f+0x56> @ imm = #-0xc2
 8018f26: 2a00         	cmp	r2, #0x0
 8018f28: da01         	bge	0x8018f2e <atan2f+0x11e> @ imm = #0x2
 8018f2a: 313c         	adds	r1, #0x3c
 8018f2c: db08         	blt	0x8018f40 <atan2f+0x130> @ imm = #0x10
 8018f2e: ee87 0aa0    	vdiv.f32	s0, s15, s1
 8018f32: eeb0 0ac0    	vabs.f32	s0, s0
 8018f36: f000 fdf7    	bl	0x8019b28 <atanf>       @ imm = #0xbee
 8018f3a: eef0 7a40    	vmov.f32	s15, s0
 8018f3e: e7e5         	b	0x8018f0c <atan2f+0xfc> @ imm = #-0x36
 8018f40: eddf 7a10    	vldr	s15, [pc, #64]          @ 0x8018f84 <atan2f+0x174>
 8018f44: e7e2         	b	0x8018f0c <atan2f+0xfc> @ imm = #-0x3c
 8018f46: ee17 3a90    	vmov	r3, s15
 8018f4a: f103 4300    	add.w	r3, r3, #0x80000000
 8018f4e: ee07 3a90    	vmov	s15, r3
 8018f52: e770         	b	0x8018e36 <atan2f+0x26> @ imm = #-0x120
 8018f54: ed9f 7a0d    	vldr	s14, [pc, #52]          @ 0x8018f8c <atan2f+0x17c>
 8018f58: ee77 7a87    	vadd.f32	s15, s15, s14
 8018f5c: ed9f 7a03    	vldr	s14, [pc, #12]          @ 0x8018f6c <atan2f+0x15c>
 8018f60: e7a7         	b	0x8018eb2 <atan2f+0xa2> @ imm = #-0xb2
 8018f62: bf00         	nop

08018f64 <$d>:
 8018f64: db 0f 49 c0  	.word	0xc0490fdb
 8018f68: 60 42 a2 0d  	.word	0x0da24260
 8018f6c: db 0f 49 40  	.word	0x40490fdb
 8018f70: db 0f c9 bf  	.word	0xbfc90fdb
 8018f74: db 0f c9 3f  	.word	0x3fc90fdb
 8018f78: db 0f 49 3f  	.word	0x3f490fdb
 8018f7c: db 0f 49 bf  	.word	0xbf490fdb
 8018f80: 00 00 00 80  	.word	0x80000000
 8018f84: 00 00 00 00  	.word	0x00000000
 8018f88: 2e bd 3b 33  	.word	0x333bbd2e
 8018f8c: 2e bd bb 33  	.word	0x33bbbd2e

08018f90 <cosf>:
 8018f90: ee10 3a10    	vmov	r3, s0
 8018f94: b507         	push	{r0, r1, r2, lr}
 8018f96: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x8019014 <cosf+0x84>
 8018f98: f023 4300    	bic	r3, r3, #0x80000000
 8018f9c: 4293         	cmp	r3, r2
 8018f9e: d806         	bhi	0x8018fae <cosf+0x1e>   @ imm = #0xc
 8018fa0: eddf 0a1d    	vldr	s1, [pc, #116]          @ 0x8019018 <cosf+0x88>
 8018fa4: b003         	add	sp, #0xc
 8018fa6: f85d eb04    	ldr	lr, [sp], #4
 8018faa: f000 ba9f    	b.w	0x80194ec <__kernel_cosf> @ imm = #0x53e
 8018fae: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8018fb2: d304         	blo	0x8018fbe <cosf+0x2e>   @ imm = #0x8
 8018fb4: b003         	add	sp, #0xc
 8018fb6: f85d eb04    	ldr	lr, [sp], #4
 8018fba: f000 ba83    	b.w	0x80194c4 <__math_invalidf> @ imm = #0x506
 8018fbe: 4668         	mov	r0, sp
 8018fc0: f000 f8d0    	bl	0x8019164 <__rem_pio2f> @ imm = #0x1a0
 8018fc4: f000 0003    	and	r0, r0, #0x3
 8018fc8: 2801         	cmp	r0, #0x1
 8018fca: d00b         	beq	0x8018fe4 <cosf+0x54>   @ imm = #0x16
 8018fcc: 2802         	cmp	r0, #0x2
 8018fce: d012         	beq	0x8018ff6 <cosf+0x66>   @ imm = #0x24
 8018fd0: b9c0         	cbnz	r0, 0x8019004 <cosf+0x74> @ imm = #0x30
 8018fd2: eddd 0a01    	vldr	s1, [sp, #4]
 8018fd6: ed9d 0a00    	vldr	s0, [sp]
 8018fda: f000 fa87    	bl	0x80194ec <__kernel_cosf> @ imm = #0x50e
 8018fde: b003         	add	sp, #0xc
 8018fe0: f85d fb04    	ldr	pc, [sp], #4
 8018fe4: eddd 0a01    	vldr	s1, [sp, #4]
 8018fe8: ed9d 0a00    	vldr	s0, [sp]
 8018fec: f000 fd54    	bl	0x8019a98 <__kernel_sinf> @ imm = #0xaa8
 8018ff0: eeb1 0a40    	vneg.f32	s0, s0
 8018ff4: e7f3         	b	0x8018fde <cosf+0x4e>   @ imm = #-0x1a
 8018ff6: eddd 0a01    	vldr	s1, [sp, #4]
 8018ffa: ed9d 0a00    	vldr	s0, [sp]
 8018ffe: f000 fa75    	bl	0x80194ec <__kernel_cosf> @ imm = #0x4ea
 8019002: e7f5         	b	0x8018ff0 <cosf+0x60>   @ imm = #-0x16
 8019004: eddd 0a01    	vldr	s1, [sp, #4]
 8019008: ed9d 0a00    	vldr	s0, [sp]
 801900c: 2001         	movs	r0, #0x1
 801900e: f000 fd43    	bl	0x8019a98 <__kernel_sinf> @ imm = #0xa86
 8019012: e7e4         	b	0x8018fde <cosf+0x4e>   @ imm = #-0x38

08019014 <$d>:
 8019014: d8 0f 49 3f  	.word	0x3f490fd8
 8019018: 00 00 00 00  	.word	0x00000000

0801901c <fmodf>:
 801901c: b5f8         	push	{r3, r4, r5, r6, r7, lr}
 801901e: ed2d 8b02    	vpush	{d8}
 8019022: eeb0 8a40    	vmov.f32	s16, s0
 8019026: eef0 8a60    	vmov.f32	s17, s1
 801902a: f000 fa0f    	bl	0x801944c <__fpclassifyf> @ imm = #0x41e
 801902e: b930         	cbnz	r0, 0x801903e <fmodf+0x22> @ imm = #0xc
 8019030: ee38 8a28    	vadd.f32	s16, s16, s17
 8019034: eeb0 0a48    	vmov.f32	s0, s16
 8019038: ecbd 8b02    	vpop	{d8}
 801903c: bdf8         	pop	{r3, r4, r5, r6, r7, pc}
 801903e: eeb0 0a68    	vmov.f32	s0, s17
 8019042: f000 fa03    	bl	0x801944c <__fpclassifyf> @ imm = #0x406
 8019046: 2800         	cmp	r0, #0x0
 8019048: d0f2         	beq	0x8019030 <fmodf+0x14>  @ imm = #-0x1c
 801904a: eeb0 0a48    	vmov.f32	s0, s16
 801904e: f000 f9fd    	bl	0x801944c <__fpclassifyf> @ imm = #0x3fa
 8019052: 2801         	cmp	r0, #0x1
 8019054: d107         	bne	0x8019066 <fmodf+0x4a>  @ imm = #0xe
 8019056: eeb0 0a48    	vmov.f32	s0, s16
 801905a: ecbd 8b02    	vpop	{d8}
 801905e: e8bd 40f8    	pop.w	{r3, r4, r5, r6, r7, lr}
 8019062: f000 ba2f    	b.w	0x80194c4 <__math_invalidf> @ imm = #0x45e
 8019066: ee18 4a90    	vmov	r4, s17
 801906a: f034 4000    	bics	r0, r4, #0x80000000
 801906e: d102         	bne	0x8019076 <fmodf+0x5a>  @ imm = #0x4
 8019070: eeb0 0a68    	vmov.f32	s0, s17
 8019074: e7f1         	b	0x801905a <fmodf+0x3e>  @ imm = #-0x1e
 8019076: ee18 3a10    	vmov	r3, s16
 801907a: f023 4600    	bic	r6, r3, #0x80000000
 801907e: 4286         	cmp	r6, r0
 8019080: dbd8         	blt	0x8019034 <fmodf+0x18>  @ imm = #-0x50
 8019082: f003 4500    	and	r5, r3, #0x80000000
 8019086: d105         	bne	0x8019094 <fmodf+0x78>  @ imm = #0xa
 8019088: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8019160 <fmodf+0x144>
 801908a: eb03 7355    	add.w	r3, r3, r5, lsr #29
 801908e: ed93 8a00    	vldr	s16, [r3]
 8019092: e7cf         	b	0x8019034 <fmodf+0x18>  @ imm = #-0x62
 8019094: f013 4fff    	tst.w	r3, #0x7f800000
 8019098: d140         	bne	0x801911c <fmodf+0x100> @ imm = #0x80
 801909a: 0232         	lsls	r2, r6, #0x8
 801909c: f06f 017d    	mvn	r1, #0x7d
 80190a0: 2a00         	cmp	r2, #0x0
 80190a2: dc38         	bgt	0x8019116 <fmodf+0xfa>  @ imm = #0x70
 80190a4: f014 4fff    	tst.w	r4, #0x7f800000
 80190a8: d13e         	bne	0x8019128 <fmodf+0x10c> @ imm = #0x7c
 80190aa: 0207         	lsls	r7, r0, #0x8
 80190ac: f06f 027d    	mvn	r2, #0x7d
 80190b0: 2f00         	cmp	r7, #0x0
 80190b2: da36         	bge	0x8019122 <fmodf+0x106> @ imm = #0x6c
 80190b4: f111 0f7e    	cmn.w	r1, #0x7e
 80190b8: bfb9         	ittee	lt
 80190ba: f06f 037d    	mvnlt	r3, #0x7d
 80190be: 1a5b         	sublt	r3, r3, r1
 80190c0: f3c3 0316    	ubfxge	r3, r3, #0x0, #0x17
 80190c4: f443 0300    	orrge	r3, r3, #0x800000
 80190c8: bfb8         	it	lt
 80190ca: fa06 f303    	lsllt.w	r3, r6, r3
 80190ce: f112 0f7e    	cmn.w	r2, #0x7e
 80190d2: bfb5         	itete	lt
 80190d4: f06f 047d    	mvnlt	r4, #0x7d
 80190d8: f3c4 0416    	ubfxge	r4, r4, #0x0, #0x17
 80190dc: 1aa4         	sublt	r4, r4, r2
 80190de: f444 0000    	orrge	r0, r4, #0x800000
 80190e2: bfb8         	it	lt
 80190e4: 40a0         	lsllt	r0, r4
 80190e6: 1a89         	subs	r1, r1, r2
 80190e8: 1a1c         	subs	r4, r3, r0
 80190ea: bb01         	cbnz	r1, 0x801912e <fmodf+0x112> @ imm = #0x40
 80190ec: ea13 0324    	ands.w	r3, r3, r4, asr #32
 80190f0: bf38         	it	lo
 80190f2: 4623         	movlo	r3, r4
 80190f4: 2b00         	cmp	r3, #0x0
 80190f6: d0c7         	beq	0x8019088 <fmodf+0x6c>  @ imm = #-0x72
 80190f8: f5b3 0f00    	cmp.w	r3, #0x800000
 80190fc: db1f         	blt	0x801913e <fmodf+0x122> @ imm = #0x3e
 80190fe: f112 0f7e    	cmn.w	r2, #0x7e
 8019102: db1f         	blt	0x8019144 <fmodf+0x128> @ imm = #0x3e
 8019104: f5a3 0300    	sub.w	r3, r3, #0x800000
 8019108: 432b         	orrs	r3, r5
 801910a: 327f         	adds	r2, #0x7f
 801910c: ea43 53c2    	orr.w	r3, r3, r2, lsl #23
 8019110: ee08 3a10    	vmov	s16, r3
 8019114: e78e         	b	0x8019034 <fmodf+0x18>  @ imm = #-0xe4
 8019116: 3901         	subs	r1, #0x1
 8019118: 0052         	lsls	r2, r2, #0x1
 801911a: e7c1         	b	0x80190a0 <fmodf+0x84>  @ imm = #-0x7e
 801911c: 15f1         	asrs	r1, r6, #0x17
 801911e: 397f         	subs	r1, #0x7f
 8019120: e7c0         	b	0x80190a4 <fmodf+0x88>  @ imm = #-0x80
 8019122: 3a01         	subs	r2, #0x1
 8019124: 007f         	lsls	r7, r7, #0x1
 8019126: e7c3         	b	0x80190b0 <fmodf+0x94>  @ imm = #-0x7a
 8019128: 15c2         	asrs	r2, r0, #0x17
 801912a: 3a7f         	subs	r2, #0x7f
 801912c: e7c2         	b	0x80190b4 <fmodf+0x98>  @ imm = #-0x7c
 801912e: 2c00         	cmp	r4, #0x0
 8019130: da02         	bge	0x8019138 <fmodf+0x11c> @ imm = #0x4
 8019132: 005b         	lsls	r3, r3, #0x1
 8019134: 3901         	subs	r1, #0x1
 8019136: e7d7         	b	0x80190e8 <fmodf+0xcc>  @ imm = #-0x52
 8019138: d0a6         	beq	0x8019088 <fmodf+0x6c>  @ imm = #-0xb4
 801913a: 0063         	lsls	r3, r4, #0x1
 801913c: e7fa         	b	0x8019134 <fmodf+0x118> @ imm = #-0xc
 801913e: 005b         	lsls	r3, r3, #0x1
 8019140: 3a01         	subs	r2, #0x1
 8019142: e7d9         	b	0x80190f8 <fmodf+0xdc>  @ imm = #-0x4e
 8019144: f1c2 22ff    	rsb.w	r2, r2, #0xff00ff00
 8019148: f502 027f    	add.w	r2, r2, #0xff0000
 801914c: 3282         	adds	r2, #0x82
 801914e: 4113         	asrs	r3, r2
 8019150: 432b         	orrs	r3, r5
 8019152: ee07 3a10    	vmov	s14, r3
 8019156: eef7 7a00    	vmov.f32	s15, #1.000000e+00
 801915a: ee27 8a27    	vmul.f32	s16, s14, s15
 801915e: e769         	b	0x8019034 <fmodf+0x18>  @ imm = #-0x12e

08019160 <$d>:
 8019160: 54 bd 02 08  	.word	0x0802bd54

08019164 <__rem_pio2f>:
 8019164: b5f0         	push	{r4, r5, r6, r7, lr}
 8019166: ee10 5a10    	vmov	r5, s0
 801916a: 4a86         	ldr	r2, [pc, #0x218]        @ 0x8019384 <__rem_pio2f+0x220>
 801916c: f025 4300    	bic	r3, r5, #0x80000000
 8019170: 4293         	cmp	r3, r2
 8019172: b087         	sub	sp, #0x1c
 8019174: 4604         	mov	r4, r0
 8019176: d805         	bhi	0x8019184 <__rem_pio2f+0x20> @ imm = #0xa
 8019178: 2300         	movs	r3, #0x0
 801917a: ed80 0a00    	vstr	s0, [r0]
 801917e: 6043         	str	r3, [r0, #0x4]
 8019180: 2000         	movs	r0, #0x0
 8019182: e022         	b	0x80191ca <__rem_pio2f+0x66> @ imm = #0x44
 8019184: 4a80         	ldr	r2, [pc, #0x200]        @ 0x8019388 <__rem_pio2f+0x224>
 8019186: 4293         	cmp	r3, r2
 8019188: d83a         	bhi	0x8019200 <__rem_pio2f+0x9c> @ imm = #0x74
 801918a: f025 4300    	bic	r3, r5, #0x80000000
 801918e: 2d00         	cmp	r5, #0x0
 8019190: eddf 7a7e    	vldr	s15, [pc, #504]         @ 0x801938c <__rem_pio2f+0x228>
 8019194: 4a7e         	ldr	r2, [pc, #0x1f8]        @ 0x8019390 <__rem_pio2f+0x22c>
 8019196: f023 030f    	bic	r3, r3, #0xf
 801919a: dd18         	ble	0x80191ce <__rem_pio2f+0x6a> @ imm = #0x30
 801919c: 4293         	cmp	r3, r2
 801919e: ee30 0a67    	vsub.f32	s0, s0, s15
 80191a2: bf09         	itett	eq
 80191a4: eddf 7a7b    	vldreq	s15, [pc, #492]         @ 0x8019394 <__rem_pio2f+0x230>
 80191a8: ed9f 7a7b    	vldrne	s14, [pc, #492]         @ 0x8019398 <__rem_pio2f+0x234>
 80191ac: ed9f 7a7b    	vldreq	s14, [pc, #492]         @ 0x801939c <__rem_pio2f+0x238>
 80191b0: ee30 0a67    	vsubeq.f32	s0, s0, s15
 80191b4: ee70 7a47    	vsub.f32	s15, s0, s14
 80191b8: ee30 0a67    	vsub.f32	s0, s0, s15
 80191bc: edc0 7a00    	vstr	s15, [r0]
 80191c0: ee30 0a47    	vsub.f32	s0, s0, s14
 80191c4: ed80 0a01    	vstr	s0, [r0, #4]
 80191c8: 2001         	movs	r0, #0x1
 80191ca: b007         	add	sp, #0x1c
 80191cc: bdf0         	pop	{r4, r5, r6, r7, pc}
 80191ce: 4293         	cmp	r3, r2
 80191d0: ee30 0a27    	vadd.f32	s0, s0, s15
 80191d4: bf09         	itett	eq
 80191d6: eddf 7a6f    	vldreq	s15, [pc, #444]         @ 0x8019394 <__rem_pio2f+0x230>
 80191da: ed9f 7a6f    	vldrne	s14, [pc, #444]         @ 0x8019398 <__rem_pio2f+0x234>
 80191de: ed9f 7a6f    	vldreq	s14, [pc, #444]         @ 0x801939c <__rem_pio2f+0x238>
 80191e2: ee30 0a27    	vaddeq.f32	s0, s0, s15
 80191e6: ee70 7a07    	vadd.f32	s15, s0, s14
 80191ea: ee30 0a67    	vsub.f32	s0, s0, s15
 80191ee: edc0 7a00    	vstr	s15, [r0]
 80191f2: ee30 0a07    	vadd.f32	s0, s0, s14
 80191f6: ed80 0a01    	vstr	s0, [r0, #4]
 80191fa: f04f 30ff    	mov.w	r0, #0xffffffff
 80191fe: e7e4         	b	0x80191ca <__rem_pio2f+0x66> @ imm = #-0x38
 8019200: 4a67         	ldr	r2, [pc, #0x19c]        @ 0x80193a0 <__rem_pio2f+0x23c>
 8019202: 4293         	cmp	r3, r2
 8019204: d870         	bhi	0x80192e8 <__rem_pio2f+0x184> @ imm = #0xe0
 8019206: eeb0 0ac0    	vabs.f32	s0, s0
 801920a: ed9f 7a66    	vldr	s14, [pc, #408]         @ 0x80193a4 <__rem_pio2f+0x240>
 801920e: eef6 7a00    	vmov.f32	s15, #5.000000e-01
 8019212: ee40 7a07    	vmla.f32	s15, s0, s14
 8019216: eefd 7ae7    	vcvt.s32.f32	s15, s15
 801921a: eef8 6ae7    	vcvt.f32.s32	s13, s15
 801921e: ee17 0a90    	vmov	r0, s15
 8019222: eddf 7a5a    	vldr	s15, [pc, #360]         @ 0x801938c <__rem_pio2f+0x228>
 8019226: ee06 0ae7    	vmls.f32	s0, s13, s15
 801922a: 281f         	cmp	r0, #0x1f
 801922c: eddf 7a5a    	vldr	s15, [pc, #360]         @ 0x8019398 <__rem_pio2f+0x234>
 8019230: ee66 7aa7    	vmul.f32	s15, s13, s15
 8019234: ee30 7a67    	vsub.f32	s14, s0, s15
 8019238: ee17 6a10    	vmov	r6, s14
 801923c: dc09         	bgt	0x8019252 <__rem_pio2f+0xee> @ imm = #0x12
 801923e: 495a         	ldr	r1, [pc, #0x168]        @ 0x80193a8 <__rem_pio2f+0x244>
 8019240: 1e47         	subs	r7, r0, #0x1
 8019242: f025 4200    	bic	r2, r5, #0x80000000
 8019246: f851 1027    	ldr.w	r1, [r1, r7, lsl #2]
 801924a: f022 02ff    	bic	r2, r2, #0xff
 801924e: 428a         	cmp	r2, r1
 8019250: d106         	bne	0x8019260 <__rem_pio2f+0xfc> @ imm = #0xc
 8019252: f3c6 51c7    	ubfx	r1, r6, #0x17, #0x8
 8019256: 15da         	asrs	r2, r3, #0x17
 8019258: ebc1 53d3    	rsb	r3, r1, r3, lsr #23
 801925c: 2b08         	cmp	r3, #0x8
 801925e: dc14         	bgt	0x801928a <__rem_pio2f+0x126> @ imm = #0x28
 8019260: 6026         	str	r6, [r4]
 8019262: ed94 7a00    	vldr	s14, [r4]
 8019266: ee30 0a47    	vsub.f32	s0, s0, s14
 801926a: 2d00         	cmp	r5, #0x0
 801926c: ee30 0a67    	vsub.f32	s0, s0, s15
 8019270: ed84 0a01    	vstr	s0, [r4, #4]
 8019274: daa9         	bge	0x80191ca <__rem_pio2f+0x66> @ imm = #-0xae
 8019276: eeb1 7a47    	vneg.f32	s14, s14
 801927a: eeb1 0a40    	vneg.f32	s0, s0
 801927e: ed84 7a00    	vstr	s14, [r4]
 8019282: ed84 0a01    	vstr	s0, [r4, #4]
 8019286: 4240         	rsbs	r0, r0, #0
 8019288: e79f         	b	0x80191ca <__rem_pio2f+0x66> @ imm = #-0xc2
 801928a: eddf 7a42    	vldr	s15, [pc, #264]         @ 0x8019394 <__rem_pio2f+0x230>
 801928e: ed9f 6a43    	vldr	s12, [pc, #268]         @ 0x801939c <__rem_pio2f+0x238>
 8019292: ee66 7aa7    	vmul.f32	s15, s13, s15
 8019296: ee30 7a67    	vsub.f32	s14, s0, s15
 801929a: ee30 0a47    	vsub.f32	s0, s0, s14
 801929e: ee70 7a67    	vsub.f32	s15, s0, s15
 80192a2: ee56 7a86    	vnmls.f32	s15, s13, s12
 80192a6: ee37 6a67    	vsub.f32	s12, s14, s15
 80192aa: ee16 1a10    	vmov	r1, s12
 80192ae: f3c1 53c7    	ubfx	r3, r1, #0x17, #0x8
 80192b2: 1ad3         	subs	r3, r2, r3
 80192b4: 2b19         	cmp	r3, #0x19
 80192b6: dc04         	bgt	0x80192c2 <__rem_pio2f+0x15e> @ imm = #0x8
 80192b8: ed84 6a00    	vstr	s12, [r4]
 80192bc: eeb0 0a47    	vmov.f32	s0, s14
 80192c0: e7cf         	b	0x8019262 <__rem_pio2f+0xfe> @ imm = #-0x62
 80192c2: eddf 7a3a    	vldr	s15, [pc, #232]         @ 0x80193ac <__rem_pio2f+0x248>
 80192c6: ee66 7aa7    	vmul.f32	s15, s13, s15
 80192ca: ee37 0a67    	vsub.f32	s0, s14, s15
 80192ce: ee37 7a40    	vsub.f32	s14, s14, s0
 80192d2: ee77 7a67    	vsub.f32	s15, s14, s15
 80192d6: ed9f 7a36    	vldr	s14, [pc, #216]         @ 0x80193b0 <__rem_pio2f+0x24c>
 80192da: ee56 7a87    	vnmls.f32	s15, s13, s14
 80192de: ee30 7a67    	vsub.f32	s14, s0, s15
 80192e2: ed84 7a00    	vstr	s14, [r4]
 80192e6: e7bc         	b	0x8019262 <__rem_pio2f+0xfe> @ imm = #-0x88
 80192e8: f1b3 4fff    	cmp.w	r3, #0x7f800000
 80192ec: d306         	blo	0x80192fc <__rem_pio2f+0x198> @ imm = #0xc
 80192ee: ee30 0a40    	vsub.f32	s0, s0, s0
 80192f2: ed80 0a01    	vstr	s0, [r0, #4]
 80192f6: ed80 0a00    	vstr	s0, [r0]
 80192fa: e741         	b	0x8019180 <__rem_pio2f+0x1c> @ imm = #-0x17e
 80192fc: 15da         	asrs	r2, r3, #0x17
 80192fe: 3a86         	subs	r2, #0x86
 8019300: eba3 53c2    	sub.w	r3, r3, r2, lsl #23
 8019304: ee07 3a90    	vmov	s15, r3
 8019308: eebd 7ae7    	vcvt.s32.f32	s14, s15
 801930c: eddf 6a29    	vldr	s13, [pc, #164]         @ 0x80193b4 <__rem_pio2f+0x250>
 8019310: eeb8 7ac7    	vcvt.f32.s32	s14, s14
 8019314: ee77 7ac7    	vsub.f32	s15, s15, s14
 8019318: ed8d 7a03    	vstr	s14, [sp, #12]
 801931c: ee67 7aa6    	vmul.f32	s15, s15, s13
 8019320: eebd 7ae7    	vcvt.s32.f32	s14, s15
 8019324: eeb8 7ac7    	vcvt.f32.s32	s14, s14
 8019328: ee77 7ac7    	vsub.f32	s15, s15, s14
 801932c: ed8d 7a04    	vstr	s14, [sp, #16]
 8019330: ee67 7aa6    	vmul.f32	s15, s15, s13
 8019334: eef5 7a40    	vcmp.f32	s15, #0
 8019338: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 801933c: edcd 7a05    	vstr	s15, [sp, #20]
 8019340: d11e         	bne	0x8019380 <__rem_pio2f+0x21c> @ imm = #0x3c
 8019342: eeb5 7a40    	vcmp.f32	s14, #0
 8019346: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 801934a: bf0c         	ite	eq
 801934c: 2301         	moveq	r3, #0x1
 801934e: 2302         	movne	r3, #0x2
 8019350: 4919         	ldr	r1, [pc, #0x64]         @ 0x80193b8 <__rem_pio2f+0x254>
 8019352: 9101         	str	r1, [sp, #0x4]
 8019354: 2102         	movs	r1, #0x2
 8019356: 9100         	str	r1, [sp]
 8019358: a803         	add	r0, sp, #0xc
 801935a: 4621         	mov	r1, r4
 801935c: f000 f91e    	bl	0x801959c <__kernel_rem_pio2f> @ imm = #0x23c
 8019360: 2d00         	cmp	r5, #0x0
 8019362: f6bf af32    	bge.w	0x80191ca <__rem_pio2f+0x66> @ imm = #-0x19c
 8019366: edd4 7a00    	vldr	s15, [r4]
 801936a: eef1 7a67    	vneg.f32	s15, s15
 801936e: edc4 7a00    	vstr	s15, [r4]
 8019372: edd4 7a01    	vldr	s15, [r4, #4]
 8019376: eef1 7a67    	vneg.f32	s15, s15
 801937a: edc4 7a01    	vstr	s15, [r4, #4]
 801937e: e782         	b	0x8019286 <__rem_pio2f+0x122> @ imm = #-0xfc
 8019380: 2303         	movs	r3, #0x3
 8019382: e7e5         	b	0x8019350 <__rem_pio2f+0x1ec> @ imm = #-0x36

08019384 <$d>:
 8019384: d8 0f 49 3f  	.word	0x3f490fd8
 8019388: e3 cb 16 40  	.word	0x4016cbe3
 801938c: 80 0f c9 3f  	.word	0x3fc90f80
 8019390: d0 0f c9 3f  	.word	0x3fc90fd0
 8019394: 00 44 35 37  	.word	0x37354400
 8019398: 43 44 35 37  	.word	0x37354443
 801939c: 08 a3 85 2e  	.word	0x2e85a308
 80193a0: 80 0f 49 43  	.word	0x43490f80
 80193a4: 84 f9 22 3f  	.word	0x3f22f984
 80193a8: 5c bd 02 08  	.word	0x0802bd5c
 80193ac: 00 a3 85 2e  	.word	0x2e85a300
 80193b0: 32 31 8d 24  	.word	0x248d3132
 80193b4: 00 00 80 43  	.word	0x43800000
 80193b8: dc bd 02 08  	.word	0x0802bddc

080193bc <sinf>:
 80193bc: ee10 3a10    	vmov	r3, s0
 80193c0: b507         	push	{r0, r1, r2, lr}
 80193c2: 4a20         	ldr	r2, [pc, #0x80]         @ 0x8019444 <sinf+0x88>
 80193c4: f023 4300    	bic	r3, r3, #0x80000000
 80193c8: 4293         	cmp	r3, r2
 80193ca: d807         	bhi	0x80193dc <sinf+0x20>   @ imm = #0xe
 80193cc: eddf 0a1e    	vldr	s1, [pc, #120]          @ 0x8019448 <sinf+0x8c>
 80193d0: 2000         	movs	r0, #0x0
 80193d2: b003         	add	sp, #0xc
 80193d4: f85d eb04    	ldr	lr, [sp], #4
 80193d8: f000 bb5e    	b.w	0x8019a98 <__kernel_sinf> @ imm = #0x6bc
 80193dc: f1b3 4fff    	cmp.w	r3, #0x7f800000
 80193e0: d304         	blo	0x80193ec <sinf+0x30>   @ imm = #0x8
 80193e2: b003         	add	sp, #0xc
 80193e4: f85d eb04    	ldr	lr, [sp], #4
 80193e8: f000 b86c    	b.w	0x80194c4 <__math_invalidf> @ imm = #0xd8
 80193ec: 4668         	mov	r0, sp
 80193ee: f7ff feb9    	bl	0x8019164 <__rem_pio2f> @ imm = #-0x28e
 80193f2: f000 0003    	and	r0, r0, #0x3
 80193f6: 2801         	cmp	r0, #0x1
 80193f8: d00c         	beq	0x8019414 <sinf+0x58>   @ imm = #0x18
 80193fa: 2802         	cmp	r0, #0x2
 80193fc: d011         	beq	0x8019422 <sinf+0x66>   @ imm = #0x22
 80193fe: b9d0         	cbnz	r0, 0x8019436 <sinf+0x7a> @ imm = #0x34
 8019400: eddd 0a01    	vldr	s1, [sp, #4]
 8019404: ed9d 0a00    	vldr	s0, [sp]
 8019408: 2001         	movs	r0, #0x1
 801940a: f000 fb45    	bl	0x8019a98 <__kernel_sinf> @ imm = #0x68a
 801940e: b003         	add	sp, #0xc
 8019410: f85d fb04    	ldr	pc, [sp], #4
 8019414: eddd 0a01    	vldr	s1, [sp, #4]
 8019418: ed9d 0a00    	vldr	s0, [sp]
 801941c: f000 f866    	bl	0x80194ec <__kernel_cosf> @ imm = #0xcc
 8019420: e7f5         	b	0x801940e <sinf+0x52>   @ imm = #-0x16
 8019422: eddd 0a01    	vldr	s1, [sp, #4]
 8019426: ed9d 0a00    	vldr	s0, [sp]
 801942a: 2001         	movs	r0, #0x1
 801942c: f000 fb34    	bl	0x8019a98 <__kernel_sinf> @ imm = #0x668
 8019430: eeb1 0a40    	vneg.f32	s0, s0
 8019434: e7eb         	b	0x801940e <sinf+0x52>   @ imm = #-0x2a
 8019436: eddd 0a01    	vldr	s1, [sp, #4]
 801943a: ed9d 0a00    	vldr	s0, [sp]
 801943e: f000 f855    	bl	0x80194ec <__kernel_cosf> @ imm = #0xaa
 8019442: e7f5         	b	0x8019430 <sinf+0x74>   @ imm = #-0x16

08019444 <$d>:
 8019444: d8 0f 49 3f  	.word	0x3f490fd8
 8019448: 00 00 00 00  	.word	0x00000000

0801944c <__fpclassifyf>:
 801944c: ee10 3a10    	vmov	r3, s0
 8019450: f033 4000    	bics	r0, r3, #0x80000000
 8019454: d00d         	beq	0x8019472 <__fpclassifyf+0x26> @ imm = #0x1a
 8019456: f5a0 0300    	sub.w	r3, r0, #0x800000
 801945a: f1b3 4ffe    	cmp.w	r3, #0x7f000000
 801945e: d30a         	blo	0x8019476 <__fpclassifyf+0x2a> @ imm = #0x14
 8019460: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8019480 <__fpclassifyf+0x34>
 8019462: 1e42         	subs	r2, r0, #0x1
 8019464: 429a         	cmp	r2, r3
 8019466: d908         	bls	0x801947a <__fpclassifyf+0x2e> @ imm = #0x10
 8019468: f1a0 43ff    	sub.w	r3, r0, #0x7f800000
 801946c: 4258         	rsbs	r0, r3, #0
 801946e: 4158         	adcs	r0, r3
 8019470: 4770         	bx	lr
 8019472: 2002         	movs	r0, #0x2
 8019474: 4770         	bx	lr
 8019476: 2004         	movs	r0, #0x4
 8019478: 4770         	bx	lr
 801947a: 2003         	movs	r0, #0x3
 801947c: 4770         	bx	lr
 801947e: bf00         	nop

08019480 <$d>:
 8019480: fe ff 7f 00  	.word	0x007ffffe

08019484 <__math_uflowf>:
 8019484: ed9f 0a05    	vldr	s0, [pc, #20]           @ 0x801949c <__math_uflowf+0x18>
 8019488: eddf 7a05    	vldr	s15, [pc, #20]          @ 0x80194a0 <__math_uflowf+0x1c>
 801948c: 2800         	cmp	r0, #0x0
 801948e: bf08         	it	eq
 8019490: eef0 7a40    	vmoveq.f32	s15, s0
 8019494: ee27 0a80    	vmul.f32	s0, s15, s0
 8019498: 4770         	bx	lr
 801949a: bf00         	nop

0801949c <$d>:
 801949c: 00 00 80 00  	.word	0x00800000
 80194a0: 00 00 80 80  	.word	0x80800000

080194a4 <__math_oflowf>:
 80194a4: ed9f 0a05    	vldr	s0, [pc, #20]           @ 0x80194bc <__math_oflowf+0x18>
 80194a8: eddf 7a05    	vldr	s15, [pc, #20]          @ 0x80194c0 <__math_oflowf+0x1c>
 80194ac: 2800         	cmp	r0, #0x0
 80194ae: bf08         	it	eq
 80194b0: eef0 7a40    	vmoveq.f32	s15, s0
 80194b4: ee27 0a80    	vmul.f32	s0, s15, s0
 80194b8: 4770         	bx	lr
 80194ba: bf00         	nop

080194bc <$d>:
 80194bc: ff ff 7f 7f  	.word	0x7f7fffff
 80194c0: ff ff 7f ff  	.word	0xff7fffff

080194c4 <__math_invalidf>:
 80194c4: b508         	push	{r3, lr}
 80194c6: ed2d 8b02    	vpush	{d8}
 80194ca: eeb0 8a40    	vmov.f32	s16, s0
 80194ce: f7ff ffbd    	bl	0x801944c <__fpclassifyf> @ imm = #-0x86
 80194d2: b920         	cbnz	r0, 0x80194de <__math_invalidf+0x1a> @ imm = #0x8
 80194d4: ee38 0a08    	vadd.f32	s0, s16, s16
 80194d8: ecbd 8b02    	vpop	{d8}
 80194dc: bd08         	pop	{r3, pc}
 80194de: eddf 7a02    	vldr	s15, [pc, #8]           @ 0x80194e8 <__math_invalidf+0x24>
 80194e2: ee87 0aa7    	vdiv.f32	s0, s15, s15
 80194e6: e7f7         	b	0x80194d8 <__math_invalidf+0x14> @ imm = #-0x12

080194e8 <$d>:
 80194e8: 00 00 00 00  	.word	0x00000000

080194ec <__kernel_cosf>:
 80194ec: ee10 3a10    	vmov	r3, s0
 80194f0: f023 4300    	bic	r3, r3, #0x80000000
 80194f4: f1b3 5f48    	cmp.w	r3, #0x32000000
 80194f8: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 80194fc: d33b         	blo	0x8019576 <__kernel_cosf+0x8a> @ imm = #0x76
 80194fe: ee60 6a00    	vmul.f32	s13, s0, s0
 8019502: eddf 5a1e    	vldr	s11, [pc, #120]         @ 0x801957c <__kernel_cosf+0x90>
 8019506: ed9f 6a1e    	vldr	s12, [pc, #120]         @ 0x8019580 <__kernel_cosf+0x94>
 801950a: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x8019584 <__kernel_cosf+0x98>
 801950c: ee06 6aa5    	vmla.f32	s12, s13, s11
 8019510: 4293         	cmp	r3, r2
 8019512: eddf 5a1d    	vldr	s11, [pc, #116]         @ 0x8019588 <__kernel_cosf+0x9c>
 8019516: ee56 5a26    	vnmls.f32	s11, s12, s13
 801951a: ed9f 6a1c    	vldr	s12, [pc, #112]         @ 0x801958c <__kernel_cosf+0xa0>
 801951e: ee05 6aa6    	vmla.f32	s12, s11, s13
 8019522: eddf 5a1b    	vldr	s11, [pc, #108]         @ 0x8019590 <__kernel_cosf+0xa4>
 8019526: ee56 5a26    	vnmls.f32	s11, s12, s13
 801952a: ed9f 6a1a    	vldr	s12, [pc, #104]         @ 0x8019594 <__kernel_cosf+0xa8>
 801952e: ee05 6aa6    	vmla.f32	s12, s11, s13
 8019532: ee60 0a20    	vmul.f32	s1, s0, s1
 8019536: ee26 6a26    	vmul.f32	s12, s12, s13
 801953a: eef6 7a00    	vmov.f32	s15, #5.000000e-01
 801953e: ee56 0a26    	vnmls.f32	s1, s12, s13
 8019542: ee66 7aa7    	vmul.f32	s15, s13, s15
 8019546: d804         	bhi	0x8019552 <__kernel_cosf+0x66> @ imm = #0x8
 8019548: ee77 7ae0    	vsub.f32	s15, s15, s1
 801954c: ee37 0a67    	vsub.f32	s0, s14, s15
 8019550: 4770         	bx	lr
 8019552: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8019598 <__kernel_cosf+0xac>
 8019554: 4293         	cmp	r3, r2
 8019556: bf9a         	itte	ls
 8019558: f103 437f    	addls.w	r3, r3, #0xff000000
 801955c: ee06 3a90    	vmovls	s13, r3
 8019560: eef5 6a02    	vmovhi.f32	s13, #2.812500e-01
 8019564: ee77 7ae6    	vsub.f32	s15, s15, s13
 8019568: ee37 0a66    	vsub.f32	s0, s14, s13
 801956c: ee77 7ae0    	vsub.f32	s15, s15, s1
 8019570: ee30 0a67    	vsub.f32	s0, s0, s15
 8019574: 4770         	bx	lr
 8019576: eeb0 0a47    	vmov.f32	s0, s14
 801957a: 4770         	bx	lr

0801957c <$d>:
 801957c: 4e d7 47 ad  	.word	0xad47d74e
 8019580: f6 74 0f 31  	.word	0x310f74f6
 8019584: 99 99 99 3e  	.word	0x3e999999
 8019588: 7c f2 93 34  	.word	0x3493f27c
 801958c: 01 0d d0 37  	.word	0x37d00d01
 8019590: 61 0b b6 3a  	.word	0x3ab60b61
 8019594: ab aa 2a 3d  	.word	0x3d2aaaab
 8019598: 00 00 48 3f  	.word	0x3f480000

0801959c <__kernel_rem_pio2f>:
 801959c: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80195a0: ed2d 8b04    	vpush	{d8, d9}
 80195a4: b0d9         	sub	sp, #0x164
 80195a6: 4690         	mov	r8, r2
 80195a8: 469b         	mov	r11, r3
 80195aa: 9a66         	ldr	r2, [sp, #0x198]
 80195ac: 4bbe         	ldr	r3, [pc, #0x2f8]        @ 0x80198a8 <__kernel_rem_pio2f+0x30c>
 80195ae: f8dd c19c    	ldr.w	r12, [sp, #0x19c]
 80195b2: f853 a022    	ldr.w	r10, [r3, r2, lsl #2]
 80195b6: 9001         	str	r0, [sp, #0x4]
 80195b8: f118 0f04    	cmn.w	r8, #0x4
 80195bc: 460f         	mov	r7, r1
 80195be: f10b 33ff    	add.w	r3, r11, #0xffffffff
 80195c2: db25         	blt	0x8019610 <__kernel_rem_pio2f+0x74> @ imm = #0x4a
 80195c4: f1b8 0203    	subs.w	r2, r8, #0x3
 80195c8: bf48         	it	mi
 80195ca: f108 0204    	addmi.w	r2, r8, #0x4
 80195ce: 10d2         	asrs	r2, r2, #0x3
 80195d0: 1c55         	adds	r5, r2, #0x1
 80195d2: 00e9         	lsls	r1, r5, #0x3
 80195d4: 1ad4         	subs	r4, r2, r3
 80195d6: ed9f 7ab8    	vldr	s14, [pc, #736]         @ 0x80198b8 <__kernel_rem_pio2f+0x31c>
 80195da: 9102         	str	r1, [sp, #0x8]
 80195dc: eba8 05c5    	sub.w	r5, r8, r5, lsl #3
 80195e0: eb0a 0603    	add.w	r6, r10, r3
 80195e4: f10d 0970    	add.w	r9, sp, #0x70
 80195e8: eb0c 0e84    	add.w	lr, r12, r4, lsl #2
 80195ec: 2100         	movs	r1, #0x0
 80195ee: 42b1         	cmp	r1, r6
 80195f0: dd10         	ble	0x8019614 <__kernel_rem_pio2f+0x78> @ imm = #0x20
 80195f2: a91c         	add	r1, sp, #0x70
 80195f4: eb01 018b    	add.w	r1, r1, r11, lsl #2
 80195f8: f50d 7988    	add.w	r9, sp, #0x110
 80195fc: 2600         	movs	r6, #0x0
 80195fe: 4556         	cmp	r6, r10
 8019600: dc26         	bgt	0x8019650 <__kernel_rem_pio2f+0xb4> @ imm = #0x4c
 8019602: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8019606: eddf 7aac    	vldr	s15, [pc, #688]         @ 0x80198b8 <__kernel_rem_pio2f+0x31c>
 801960a: 460c         	mov	r4, r1
 801960c: 2000         	movs	r0, #0x0
 801960e: e016         	b	0x801963e <__kernel_rem_pio2f+0xa2> @ imm = #0x2c
 8019610: 2200         	movs	r2, #0x0
 8019612: e7dd         	b	0x80195d0 <__kernel_rem_pio2f+0x34> @ imm = #-0x46
 8019614: 42cc         	cmn	r4, r1
 8019616: bf5d         	ittte	pl
 8019618: f85e 0021    	ldrpl.w	r0, [lr, r1, lsl #2]
 801961c: ee07 0a90    	vmovpl	s15, r0
 8019620: eef8 7ae7    	vcvtpl.f32.s32	s15, s15
 8019624: eef0 7a47    	vmovmi.f32	s15, s14
 8019628: ece9 7a01    	vstmia	r9!, {s15}
 801962c: 3101         	adds	r1, #0x1
 801962e: e7de         	b	0x80195ee <__kernel_rem_pio2f+0x52> @ imm = #-0x44
 8019630: ecfe 6a01    	vldmia	lr!, {s13}
 8019634: ed94 7a00    	vldr	s14, [r4]
 8019638: ee46 7a87    	vmla.f32	s15, s13, s14
 801963c: 3001         	adds	r0, #0x1
 801963e: 4298         	cmp	r0, r3
 8019640: f1a4 0404    	sub.w	r4, r4, #0x4
 8019644: ddf4         	ble	0x8019630 <__kernel_rem_pio2f+0x94> @ imm = #-0x18
 8019646: ece9 7a01    	vstmia	r9!, {s15}
 801964a: 3601         	adds	r6, #0x1
 801964c: 3104         	adds	r1, #0x4
 801964e: e7d6         	b	0x80195fe <__kernel_rem_pio2f+0x62> @ imm = #-0x54
 8019650: a908         	add	r1, sp, #0x20
 8019652: eb01 018a    	add.w	r1, r1, r10, lsl #2
 8019656: eb0c 0282    	add.w	r2, r12, r2, lsl #2
 801965a: eddf 8a96    	vldr	s17, [pc, #600]         @ 0x80198b4 <__kernel_rem_pio2f+0x318>
 801965e: ed9f 9a94    	vldr	s18, [pc, #592]         @ 0x80198b0 <__kernel_rem_pio2f+0x314>
 8019662: 9104         	str	r1, [sp, #0x10]
 8019664: 9203         	str	r2, [sp, #0xc]
 8019666: 4654         	mov	r4, r10
 8019668: 00a2         	lsls	r2, r4, #0x2
 801966a: 9205         	str	r2, [sp, #0x14]
 801966c: aa58         	add	r2, sp, #0x160
 801966e: eb02 0284    	add.w	r2, r2, r4, lsl #2
 8019672: ed12 0a14    	vldr	s0, [r2, #-80]
 8019676: a944         	add	r1, sp, #0x110
 8019678: aa08         	add	r2, sp, #0x20
 801967a: eb01 0184    	add.w	r1, r1, r4, lsl #2
 801967e: 4616         	mov	r6, r2
 8019680: 4620         	mov	r0, r4
 8019682: 2800         	cmp	r0, #0x0
 8019684: f1a1 0104    	sub.w	r1, r1, #0x4
 8019688: dc4e         	bgt	0x8019728 <__kernel_rem_pio2f+0x18c> @ imm = #0x9c
 801968a: 4628         	mov	r0, r5
 801968c: e9cd 3206    	strd	r3, r2, [sp, #24]
 8019690: f000 fb2e    	bl	0x8019cf0 <scalbnf>     @ imm = #0x65c
 8019694: eeb0 8a40    	vmov.f32	s16, s0
 8019698: eeb4 0a00    	vmov.f32	s0, #1.250000e-01
 801969c: ee28 0a00    	vmul.f32	s0, s16, s0
 80196a0: f000 fb6c    	bl	0x8019d7c <floorf>      @ imm = #0x6d8
 80196a4: eef2 7a00    	vmov.f32	s15, #8.000000e+00
 80196a8: ee00 8a67    	vmls.f32	s16, s0, s15
 80196ac: 2d00         	cmp	r5, #0x0
 80196ae: e9dd 3206    	ldrd	r3, r2, [sp, #24]
 80196b2: eefd 7ac8    	vcvt.s32.f32	s15, s16
 80196b6: ee17 9a90    	vmov	r9, s15
 80196ba: eef8 7ae7    	vcvt.f32.s32	s15, s15
 80196be: ee38 8a67    	vsub.f32	s16, s16, s15
 80196c2: dd43         	ble	0x801974c <__kernel_rem_pio2f+0x1b0> @ imm = #0x86
 80196c4: 1e60         	subs	r0, r4, #0x1
 80196c6: a908         	add	r1, sp, #0x20
 80196c8: f1c5 0c08    	rsb.w	r12, r5, #0x8
 80196cc: f851 6020    	ldr.w	r6, [r1, r0, lsl #2]
 80196d0: fa46 f10c    	asr.w	r1, r6, r12
 80196d4: 4489         	add	r9, r1
 80196d6: fa01 f10c    	lsl.w	r1, r1, r12
 80196da: 1a76         	subs	r6, r6, r1
 80196dc: a908         	add	r1, sp, #0x20
 80196de: f841 6020    	str.w	r6, [r1, r0, lsl #2]
 80196e2: f1c5 0107    	rsb.w	r1, r5, #0x7
 80196e6: 410e         	asrs	r6, r1
 80196e8: 2e00         	cmp	r6, #0x0
 80196ea: dd3e         	ble	0x801976a <__kernel_rem_pio2f+0x1ce> @ imm = #0x7c
 80196ec: f04f 0c00    	mov.w	r12, #0x0
 80196f0: f109 0901    	add.w	r9, r9, #0x1
 80196f4: 4660         	mov	r0, r12
 80196f6: 4564         	cmp	r4, r12
 80196f8: dc6a         	bgt	0x80197d0 <__kernel_rem_pio2f+0x234> @ imm = #0xd4
 80196fa: 2d00         	cmp	r5, #0x0
 80196fc: dd05         	ble	0x801970a <__kernel_rem_pio2f+0x16e> @ imm = #0xa
 80196fe: 2d01         	cmp	r5, #0x1
 8019700: f000 8083    	beq.w	0x801980a <__kernel_rem_pio2f+0x26e> @ imm = #0x106
 8019704: 2d02         	cmp	r5, #0x2
 8019706: f000 808b    	beq.w	0x8019820 <__kernel_rem_pio2f+0x284> @ imm = #0x116
 801970a: 2e02         	cmp	r6, #0x2
 801970c: d12d         	bne	0x801976a <__kernel_rem_pio2f+0x1ce> @ imm = #0x5a
 801970e: eeb7 0a00    	vmov.f32	s0, #1.000000e+00
 8019712: ee30 8a48    	vsub.f32	s16, s0, s16
 8019716: b340         	cbz	r0, 0x801976a <__kernel_rem_pio2f+0x1ce> @ imm = #0x50
 8019718: 4628         	mov	r0, r5
 801971a: 9306         	str	r3, [sp, #0x18]
 801971c: f000 fae8    	bl	0x8019cf0 <scalbnf>     @ imm = #0x5d0
 8019720: 9b06         	ldr	r3, [sp, #0x18]
 8019722: ee38 8a40    	vsub.f32	s16, s16, s0
 8019726: e020         	b	0x801976a <__kernel_rem_pio2f+0x1ce> @ imm = #0x40
 8019728: ee60 7a28    	vmul.f32	s15, s0, s17
 801972c: 3801         	subs	r0, #0x1
 801972e: eefd 7ae7    	vcvt.s32.f32	s15, s15
 8019732: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8019736: ee07 0ac9    	vmls.f32	s0, s15, s18
 801973a: eebd 0ac0    	vcvt.s32.f32	s0, s0
 801973e: eca6 0a01    	vstmia	r6!, {s0}
 8019742: ed91 0a00    	vldr	s0, [r1]
 8019746: ee37 0a80    	vadd.f32	s0, s15, s0
 801974a: e79a         	b	0x8019682 <__kernel_rem_pio2f+0xe6> @ imm = #-0xcc
 801974c: d105         	bne	0x801975a <__kernel_rem_pio2f+0x1be> @ imm = #0xa
 801974e: 1e61         	subs	r1, r4, #0x1
 8019750: a808         	add	r0, sp, #0x20
 8019752: f850 6021    	ldr.w	r6, [r0, r1, lsl #2]
 8019756: 11f6         	asrs	r6, r6, #0x7
 8019758: e7c6         	b	0x80196e8 <__kernel_rem_pio2f+0x14c> @ imm = #-0x74
 801975a: eef6 7a00    	vmov.f32	s15, #5.000000e-01
 801975e: eeb4 8ae7    	vcmpe.f32	s16, s15
 8019762: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8019766: da31         	bge	0x80197cc <__kernel_rem_pio2f+0x230> @ imm = #0x62
 8019768: 2600         	movs	r6, #0x0
 801976a: eeb5 8a40    	vcmp.f32	s16, #0
 801976e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8019772: f040 80a3    	bne.w	0x80198bc <__kernel_rem_pio2f+0x320> @ imm = #0x146
 8019776: 1e61         	subs	r1, r4, #0x1
 8019778: 2000         	movs	r0, #0x0
 801977a: 4551         	cmp	r1, r10
 801977c: da57         	bge	0x801982e <__kernel_rem_pio2f+0x292> @ imm = #0xae
 801977e: 2800         	cmp	r0, #0x0
 8019780: d071         	beq	0x8019866 <__kernel_rem_pio2f+0x2ca> @ imm = #0xe2
 8019782: 3c01         	subs	r4, #0x1
 8019784: ab08         	add	r3, sp, #0x20
 8019786: 3d08         	subs	r5, #0x8
 8019788: f853 3024    	ldr.w	r3, [r3, r4, lsl #2]
 801978c: 2b00         	cmp	r3, #0x0
 801978e: d0f8         	beq	0x8019782 <__kernel_rem_pio2f+0x1e6> @ imm = #-0x10
 8019790: 4628         	mov	r0, r5
 8019792: eeb7 0a00    	vmov.f32	s0, #1.000000e+00
 8019796: f000 faab    	bl	0x8019cf0 <scalbnf>     @ imm = #0x556
 801979a: 1c63         	adds	r3, r4, #0x1
 801979c: aa44         	add	r2, sp, #0x110
 801979e: ed9f 7a45    	vldr	s14, [pc, #276]         @ 0x80198b4 <__kernel_rem_pio2f+0x318>
 80197a2: 0099         	lsls	r1, r3, #0x2
 80197a4: eb02 0283    	add.w	r2, r2, r3, lsl #2
 80197a8: 4623         	mov	r3, r4
 80197aa: 2b00         	cmp	r3, #0x0
 80197ac: f280 80b4    	bge.w	0x8019918 <__kernel_rem_pio2f+0x37c> @ imm = #0x168
 80197b0: 4623         	mov	r3, r4
 80197b2: 2b00         	cmp	r3, #0x0
 80197b4: f2c0 80d2    	blt.w	0x801995c <__kernel_rem_pio2f+0x3c0> @ imm = #0x1a4
 80197b8: aa44         	add	r2, sp, #0x110
 80197ba: eb02 0583    	add.w	r5, r2, r3, lsl #2
 80197be: f8df c0ec    	ldr.w	r12, [pc, #0xec]        @ 0x80198ac <__kernel_rem_pio2f+0x310>
 80197c2: eddf 7a3d    	vldr	s15, [pc, #244]         @ 0x80198b8 <__kernel_rem_pio2f+0x31c>
 80197c6: 2000         	movs	r0, #0x0
 80197c8: 1ae2         	subs	r2, r4, r3
 80197ca: e0bc         	b	0x8019946 <__kernel_rem_pio2f+0x3aa> @ imm = #0x178
 80197cc: 2602         	movs	r6, #0x2
 80197ce: e78d         	b	0x80196ec <__kernel_rem_pio2f+0x150> @ imm = #-0xe6
 80197d0: 4696         	mov	lr, r2
 80197d2: f85e 1b04    	ldr	r1, [lr], #4
 80197d6: b960         	cbnz	r0, 0x80197f2 <__kernel_rem_pio2f+0x256> @ imm = #0x18
 80197d8: b181         	cbz	r1, 0x80197fc <__kernel_rem_pio2f+0x260> @ imm = #0x20
 80197da: f10c 0c01    	add.w	r12, r12, #0x1
 80197de: f5c1 7180    	rsb.w	r1, r1, #0x100
 80197e2: 4564         	cmp	r4, r12
 80197e4: f84e 1c04    	str	r1, [lr, #-4]
 80197e8: dd0d         	ble	0x8019806 <__kernel_rem_pio2f+0x26a> @ imm = #0x1a
 80197ea: f8de 1000    	ldr.w	r1, [lr]
 80197ee: f102 0e08    	add.w	lr, r2, #0x8
 80197f2: f1c1 01ff    	rsb.w	r1, r1, #0xff
 80197f6: f84e 1c04    	str	r1, [lr, #-4]
 80197fa: 2101         	movs	r1, #0x1
 80197fc: f10c 0c01    	add.w	r12, r12, #0x1
 8019800: 4672         	mov	r2, lr
 8019802: 4608         	mov	r0, r1
 8019804: e777         	b	0x80196f6 <__kernel_rem_pio2f+0x15a> @ imm = #-0x112
 8019806: 2001         	movs	r0, #0x1
 8019808: e777         	b	0x80196fa <__kernel_rem_pio2f+0x15e> @ imm = #-0x112
 801980a: 1e61         	subs	r1, r4, #0x1
 801980c: aa08         	add	r2, sp, #0x20
 801980e: f852 2021    	ldr.w	r2, [r2, r1, lsl #2]
 8019812: f002 027f    	and	r2, r2, #0x7f
 8019816: f10d 0c20    	add.w	r12, sp, #0x20
 801981a: f84c 2021    	str.w	r2, [r12, r1, lsl #2]
 801981e: e774         	b	0x801970a <__kernel_rem_pio2f+0x16e> @ imm = #-0x118
 8019820: 1e61         	subs	r1, r4, #0x1
 8019822: aa08         	add	r2, sp, #0x20
 8019824: f852 2021    	ldr.w	r2, [r2, r1, lsl #2]
 8019828: f002 023f    	and	r2, r2, #0x3f
 801982c: e7f3         	b	0x8019816 <__kernel_rem_pio2f+0x27a> @ imm = #-0x1a
 801982e: aa08         	add	r2, sp, #0x20
 8019830: f852 2021    	ldr.w	r2, [r2, r1, lsl #2]
 8019834: 3901         	subs	r1, #0x1
 8019836: 4310         	orrs	r0, r2
 8019838: e79f         	b	0x801977a <__kernel_rem_pio2f+0x1de> @ imm = #-0xc2
 801983a: 3201         	adds	r2, #0x1
 801983c: f851 0d04    	ldr	r0, [r1, #-4]!
 8019840: 2800         	cmp	r0, #0x0
 8019842: d0fa         	beq	0x801983a <__kernel_rem_pio2f+0x29e> @ imm = #-0xc
 8019844: 9905         	ldr	r1, [sp, #0x14]
 8019846: f501 71b0    	add.w	r1, r1, #0x160
 801984a: 4469         	add	r1, sp, r1
 801984c: eb04 000b    	add.w	r0, r4, r11
 8019850: f10d 0c70    	add.w	r12, sp, #0x70
 8019854: 1c66         	adds	r6, r4, #0x1
 8019856: 394c         	subs	r1, #0x4c
 8019858: eb0c 0080    	add.w	r0, r12, r0, lsl #2
 801985c: 4422         	add	r2, r4
 801985e: 42b2         	cmp	r2, r6
 8019860: da04         	bge	0x801986c <__kernel_rem_pio2f+0x2d0> @ imm = #0x8
 8019862: 4614         	mov	r4, r2
 8019864: e700         	b	0x8019668 <__kernel_rem_pio2f+0xcc> @ imm = #-0x200
 8019866: 9904         	ldr	r1, [sp, #0x10]
 8019868: 2201         	movs	r2, #0x1
 801986a: e7e7         	b	0x801983c <__kernel_rem_pio2f+0x2a0> @ imm = #-0x32
 801986c: 9c03         	ldr	r4, [sp, #0xc]
 801986e: f8dd c004    	ldr.w	r12, [sp, #0x4]
 8019872: f854 4026    	ldr.w	r4, [r4, r6, lsl #2]
 8019876: 9405         	str	r4, [sp, #0x14]
 8019878: ee07 4a90    	vmov	s15, r4
 801987c: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8019880: 2400         	movs	r4, #0x0
 8019882: ece0 7a01    	vstmia	r0!, {s15}
 8019886: eddf 7a0c    	vldr	s15, [pc, #48]          @ 0x80198b8 <__kernel_rem_pio2f+0x31c>
 801988a: 4686         	mov	lr, r0
 801988c: 429c         	cmp	r4, r3
 801988e: dd03         	ble	0x8019898 <__kernel_rem_pio2f+0x2fc> @ imm = #0x6
 8019890: ece1 7a01    	vstmia	r1!, {s15}
 8019894: 3601         	adds	r6, #0x1
 8019896: e7e2         	b	0x801985e <__kernel_rem_pio2f+0x2c2> @ imm = #-0x3c
 8019898: ecfc 6a01    	vldmia	r12!, {s13}
 801989c: ed3e 7a01    	vldmdb	lr!, {s14}
 80198a0: 3401         	adds	r4, #0x1
 80198a2: ee46 7a87    	vmla.f32	s15, s13, s14
 80198a6: e7f1         	b	0x801988c <__kernel_rem_pio2f+0x2f0> @ imm = #-0x1e

080198a8 <$d>:
 80198a8: 20 c1 02 08  	.word	0x0802c120
 80198ac: f4 c0 02 08  	.word	0x0802c0f4
 80198b0: 00 00 80 43  	.word	0x43800000
 80198b4: 00 00 80 3b  	.word	0x3b800000
 80198b8: 00 00 00 00  	.word	0x00000000

080198bc <$t>:
 80198bc: 9b02         	ldr	r3, [sp, #0x8]
 80198be: eeb0 0a48    	vmov.f32	s0, s16
 80198c2: eba3 0008    	sub.w	r0, r3, r8
 80198c6: f000 fa13    	bl	0x8019cf0 <scalbnf>     @ imm = #0x426
 80198ca: ed1f 7a07    	vldr	s14, [pc, #-28]         @ 0x80198b0 <__kernel_rem_pio2f+0x314>
 80198ce: eeb4 0ac7    	vcmpe.f32	s0, s14
 80198d2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80198d6: db19         	blt	0x801990c <__kernel_rem_pio2f+0x370> @ imm = #0x32
 80198d8: ed5f 7a0a    	vldr	s15, [pc, #-40]         @ 0x80198b4 <__kernel_rem_pio2f+0x318>
 80198dc: ee60 7a27    	vmul.f32	s15, s0, s15
 80198e0: aa08         	add	r2, sp, #0x20
 80198e2: eefd 7ae7    	vcvt.s32.f32	s15, s15
 80198e6: 3508         	adds	r5, #0x8
 80198e8: eef8 7ae7    	vcvt.f32.s32	s15, s15
 80198ec: ee07 0ac7    	vmls.f32	s0, s15, s14
 80198f0: eefd 7ae7    	vcvt.s32.f32	s15, s15
 80198f4: eebd 0ac0    	vcvt.s32.f32	s0, s0
 80198f8: ee10 3a10    	vmov	r3, s0
 80198fc: f842 3024    	str.w	r3, [r2, r4, lsl #2]
 8019900: ee17 3a90    	vmov	r3, s15
 8019904: 3401         	adds	r4, #0x1
 8019906: f842 3024    	str.w	r3, [r2, r4, lsl #2]
 801990a: e741         	b	0x8019790 <__kernel_rem_pio2f+0x1f4> @ imm = #-0x17e
 801990c: eebd 0ac0    	vcvt.s32.f32	s0, s0
 8019910: aa08         	add	r2, sp, #0x20
 8019912: ee10 3a10    	vmov	r3, s0
 8019916: e7f6         	b	0x8019906 <__kernel_rem_pio2f+0x36a> @ imm = #-0x14
 8019918: a808         	add	r0, sp, #0x20
 801991a: f850 0023    	ldr.w	r0, [r0, r3, lsl #2]
 801991e: 9001         	str	r0, [sp, #0x4]
 8019920: ee07 0a90    	vmov	s15, r0
 8019924: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8019928: 3b01         	subs	r3, #0x1
 801992a: ee67 7a80    	vmul.f32	s15, s15, s0
 801992e: ee20 0a07    	vmul.f32	s0, s0, s14
 8019932: ed62 7a01    	vstmdb	r2!, {s15}
 8019936: e738         	b	0x80197aa <__kernel_rem_pio2f+0x20e> @ imm = #-0x190
 8019938: ecfc 6a01    	vldmia	r12!, {s13}
 801993c: ecb5 7a01    	vldmia	r5!, {s14}
 8019940: ee46 7a87    	vmla.f32	s15, s13, s14
 8019944: 3001         	adds	r0, #0x1
 8019946: 4550         	cmp	r0, r10
 8019948: dc01         	bgt	0x801994e <__kernel_rem_pio2f+0x3b2> @ imm = #0x2
 801994a: 4282         	cmp	r2, r0
 801994c: daf4         	bge	0x8019938 <__kernel_rem_pio2f+0x39c> @ imm = #-0x18
 801994e: a858         	add	r0, sp, #0x160
 8019950: eb00 0282    	add.w	r2, r0, r2, lsl #2
 8019954: ed42 7a28    	vstr	s15, [r2, #-160]
 8019958: 3b01         	subs	r3, #0x1
 801995a: e72a         	b	0x80197b2 <__kernel_rem_pio2f+0x216> @ imm = #-0x1ac
 801995c: 9b66         	ldr	r3, [sp, #0x198]
 801995e: 2b02         	cmp	r3, #0x2
 8019960: dc09         	bgt	0x8019976 <__kernel_rem_pio2f+0x3da> @ imm = #0x12
 8019962: 2b00         	cmp	r3, #0x0
 8019964: dc2b         	bgt	0x80199be <__kernel_rem_pio2f+0x422> @ imm = #0x56
 8019966: d044         	beq	0x80199f2 <__kernel_rem_pio2f+0x456> @ imm = #0x88
 8019968: f009 0007    	and	r0, r9, #0x7
 801996c: b059         	add	sp, #0x164
 801996e: ecbd 8b04    	vpop	{d8, d9}
 8019972: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8019976: 9b66         	ldr	r3, [sp, #0x198]
 8019978: 2b03         	cmp	r3, #0x3
 801997a: d1f5         	bne	0x8019968 <__kernel_rem_pio2f+0x3cc> @ imm = #-0x16
 801997c: aa30         	add	r2, sp, #0xc0
 801997e: 1f0b         	subs	r3, r1, #0x4
 8019980: 4413         	add	r3, r2
 8019982: 461a         	mov	r2, r3
 8019984: 4620         	mov	r0, r4
 8019986: 2800         	cmp	r0, #0x0
 8019988: f1a2 0204    	sub.w	r2, r2, #0x4
 801998c: dc52         	bgt	0x8019a34 <__kernel_rem_pio2f+0x498> @ imm = #0xa4
 801998e: 4622         	mov	r2, r4
 8019990: 2a01         	cmp	r2, #0x1
 8019992: f1a3 0304    	sub.w	r3, r3, #0x4
 8019996: dc5d         	bgt	0x8019a54 <__kernel_rem_pio2f+0x4b8> @ imm = #0xba
 8019998: ab30         	add	r3, sp, #0xc0
 801999a: ed5f 7a39    	vldr	s15, [pc, #-228]        @ 0x80198b8 <__kernel_rem_pio2f+0x31c>
 801999e: 440b         	add	r3, r1
 80199a0: 2c01         	cmp	r4, #0x1
 80199a2: dc67         	bgt	0x8019a74 <__kernel_rem_pio2f+0x4d8> @ imm = #0xce
 80199a4: eddd 6a30    	vldr	s13, [sp, #192]
 80199a8: ed9d 7a31    	vldr	s14, [sp, #196]
 80199ac: 2e00         	cmp	r6, #0x0
 80199ae: d167         	bne	0x8019a80 <__kernel_rem_pio2f+0x4e4> @ imm = #0xce
 80199b0: edc7 6a00    	vstr	s13, [r7]
 80199b4: ed87 7a01    	vstr	s14, [r7, #4]
 80199b8: edc7 7a02    	vstr	s15, [r7, #8]
 80199bc: e7d4         	b	0x8019968 <__kernel_rem_pio2f+0x3cc> @ imm = #-0x58
 80199be: ab30         	add	r3, sp, #0xc0
 80199c0: ed1f 7a43    	vldr	s14, [pc, #-268]        @ 0x80198b8 <__kernel_rem_pio2f+0x31c>
 80199c4: 440b         	add	r3, r1
 80199c6: 4622         	mov	r2, r4
 80199c8: 2a00         	cmp	r2, #0x0
 80199ca: da24         	bge	0x8019a16 <__kernel_rem_pio2f+0x47a> @ imm = #0x48
 80199cc: b34e         	cbz	r6, 0x8019a22 <__kernel_rem_pio2f+0x486> @ imm = #0x52
 80199ce: eef1 7a47    	vneg.f32	s15, s14
 80199d2: edc7 7a00    	vstr	s15, [r7]
 80199d6: eddd 7a30    	vldr	s15, [sp, #192]
 80199da: ee77 7ac7    	vsub.f32	s15, s15, s14
 80199de: aa31         	add	r2, sp, #0xc4
 80199e0: 2301         	movs	r3, #0x1
 80199e2: 429c         	cmp	r4, r3
 80199e4: da20         	bge	0x8019a28 <__kernel_rem_pio2f+0x48c> @ imm = #0x40
 80199e6: b10e         	cbz	r6, 0x80199ec <__kernel_rem_pio2f+0x450> @ imm = #0x2
 80199e8: eef1 7a67    	vneg.f32	s15, s15
 80199ec: edc7 7a01    	vstr	s15, [r7, #4]
 80199f0: e7ba         	b	0x8019968 <__kernel_rem_pio2f+0x3cc> @ imm = #-0x8c
 80199f2: ab30         	add	r3, sp, #0xc0
 80199f4: ed5f 7a50    	vldr	s15, [pc, #-320]        @ 0x80198b8 <__kernel_rem_pio2f+0x31c>
 80199f8: 440b         	add	r3, r1
 80199fa: 2c00         	cmp	r4, #0x0
 80199fc: da05         	bge	0x8019a0a <__kernel_rem_pio2f+0x46e> @ imm = #0xa
 80199fe: b10e         	cbz	r6, 0x8019a04 <__kernel_rem_pio2f+0x468> @ imm = #0x2
 8019a00: eef1 7a67    	vneg.f32	s15, s15
 8019a04: edc7 7a00    	vstr	s15, [r7]
 8019a08: e7ae         	b	0x8019968 <__kernel_rem_pio2f+0x3cc> @ imm = #-0xa4
 8019a0a: ed33 7a01    	vldmdb	r3!, {s14}
 8019a0e: 3c01         	subs	r4, #0x1
 8019a10: ee77 7a87    	vadd.f32	s15, s15, s14
 8019a14: e7f1         	b	0x80199fa <__kernel_rem_pio2f+0x45e> @ imm = #-0x1e
 8019a16: ed73 7a01    	vldmdb	r3!, {s15}
 8019a1a: 3a01         	subs	r2, #0x1
 8019a1c: ee37 7a27    	vadd.f32	s14, s14, s15
 8019a20: e7d2         	b	0x80199c8 <__kernel_rem_pio2f+0x42c> @ imm = #-0x5c
 8019a22: eef0 7a47    	vmov.f32	s15, s14
 8019a26: e7d4         	b	0x80199d2 <__kernel_rem_pio2f+0x436> @ imm = #-0x58
 8019a28: ecb2 7a01    	vldmia	r2!, {s14}
 8019a2c: 3301         	adds	r3, #0x1
 8019a2e: ee77 7a87    	vadd.f32	s15, s15, s14
 8019a32: e7d6         	b	0x80199e2 <__kernel_rem_pio2f+0x446> @ imm = #-0x54
 8019a34: edd2 7a00    	vldr	s15, [r2]
 8019a38: edd2 6a01    	vldr	s13, [r2, #4]
 8019a3c: ee37 7aa6    	vadd.f32	s14, s15, s13
 8019a40: 3801         	subs	r0, #0x1
 8019a42: ee77 7ac7    	vsub.f32	s15, s15, s14
 8019a46: ed82 7a00    	vstr	s14, [r2]
 8019a4a: ee77 7aa6    	vadd.f32	s15, s15, s13
 8019a4e: edc2 7a01    	vstr	s15, [r2, #4]
 8019a52: e798         	b	0x8019986 <__kernel_rem_pio2f+0x3ea> @ imm = #-0xd0
 8019a54: edd3 7a00    	vldr	s15, [r3]
 8019a58: edd3 6a01    	vldr	s13, [r3, #4]
 8019a5c: ee37 7aa6    	vadd.f32	s14, s15, s13
 8019a60: 3a01         	subs	r2, #0x1
 8019a62: ee77 7ac7    	vsub.f32	s15, s15, s14
 8019a66: ed83 7a00    	vstr	s14, [r3]
 8019a6a: ee77 7aa6    	vadd.f32	s15, s15, s13
 8019a6e: edc3 7a01    	vstr	s15, [r3, #4]
 8019a72: e78d         	b	0x8019990 <__kernel_rem_pio2f+0x3f4> @ imm = #-0xe6
 8019a74: ed33 7a01    	vldmdb	r3!, {s14}
 8019a78: 3c01         	subs	r4, #0x1
 8019a7a: ee77 7a87    	vadd.f32	s15, s15, s14
 8019a7e: e78f         	b	0x80199a0 <__kernel_rem_pio2f+0x404> @ imm = #-0xe2
 8019a80: eef1 6a66    	vneg.f32	s13, s13
 8019a84: eeb1 7a47    	vneg.f32	s14, s14
 8019a88: edc7 6a00    	vstr	s13, [r7]
 8019a8c: ed87 7a01    	vstr	s14, [r7, #4]
 8019a90: eef1 7a67    	vneg.f32	s15, s15
 8019a94: e790         	b	0x80199b8 <__kernel_rem_pio2f+0x41c> @ imm = #-0xe0
 8019a96: bf00         	nop

08019a98 <__kernel_sinf>:
 8019a98: ee10 3a10    	vmov	r3, s0
 8019a9c: f023 4300    	bic	r3, r3, #0x80000000
 8019aa0: f1b3 5f48    	cmp.w	r3, #0x32000000
 8019aa4: eef0 7a40    	vmov.f32	s15, s0
 8019aa8: d201         	bhs	0x8019aae <__kernel_sinf+0x16> @ imm = #0x2
 8019aaa: f000 b913    	b.w	0x8019cd4 <__math_inexactf> @ imm = #0x226
 8019aae: ee60 6a00    	vmul.f32	s13, s0, s0
 8019ab2: ed9f 7a16    	vldr	s14, [pc, #88]          @ 0x8019b0c <__kernel_sinf+0x74>
 8019ab6: eddf 5a16    	vldr	s11, [pc, #88]          @ 0x8019b10 <__kernel_sinf+0x78>
 8019aba: ee56 5a87    	vnmls.f32	s11, s13, s14
 8019abe: ed9f 7a15    	vldr	s14, [pc, #84]          @ 0x8019b14 <__kernel_sinf+0x7c>
 8019ac2: ee05 7aa6    	vmla.f32	s14, s11, s13
 8019ac6: eddf 5a14    	vldr	s11, [pc, #80]          @ 0x8019b18 <__kernel_sinf+0x80>
 8019aca: ee57 5a26    	vnmls.f32	s11, s14, s13
 8019ace: ed9f 7a13    	vldr	s14, [pc, #76]          @ 0x8019b1c <__kernel_sinf+0x84>
 8019ad2: ee20 6a26    	vmul.f32	s12, s0, s13
 8019ad6: ee05 7aa6    	vmla.f32	s14, s11, s13
 8019ada: b940         	cbnz	r0, 0x8019aee <__kernel_sinf+0x56> @ imm = #0x10
 8019adc: eddf 5a10    	vldr	s11, [pc, #64]          @ 0x8019b20 <__kernel_sinf+0x88>
 8019ae0: ee56 5a87    	vnmls.f32	s11, s13, s14
 8019ae4: ee45 7a86    	vmla.f32	s15, s11, s12
 8019ae8: eeb0 0a67    	vmov.f32	s0, s15
 8019aec: 4770         	bx	lr
 8019aee: ee26 7a07    	vmul.f32	s14, s12, s14
 8019af2: eef6 5a00    	vmov.f32	s11, #5.000000e-01
 8019af6: ee10 7aa5    	vnmls.f32	s14, s1, s11
 8019afa: ee57 0a26    	vnmls.f32	s1, s14, s13
 8019afe: ed9f 7a09    	vldr	s14, [pc, #36]          @ 0x8019b24 <__kernel_sinf+0x8c>
 8019b02: ee46 0a47    	vmls.f32	s1, s12, s14
 8019b06: ee30 0a60    	vsub.f32	s0, s0, s1
 8019b0a: 4770         	bx	lr

08019b0c <$d>:
 8019b0c: d3 c9 2e 2f  	.word	0x2f2ec9d3
 8019b10: 34 2f d7 32  	.word	0x32d72f34
 8019b14: 1b ef 38 36  	.word	0x3638ef1b
 8019b18: 01 0d 50 39  	.word	0x39500d01
 8019b1c: 89 88 08 3c  	.word	0x3c088889
 8019b20: ab aa 2a 3e  	.word	0x3e2aaaab
 8019b24: ab aa 2a be  	.word	0xbe2aaaab

08019b28 <atanf>:
 8019b28: ee10 2a10    	vmov	r2, s0
 8019b2c: f022 4300    	bic	r3, r2, #0x80000000
 8019b30: f1b3 4fa1    	cmp.w	r3, #0x50800000
 8019b34: d312         	blo	0x8019b5c <atanf+0x34>  @ imm = #0x24
 8019b36: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8019b3a: d902         	bls	0x8019b42 <atanf+0x1a>  @ imm = #0x4
 8019b3c: ee30 0a00    	vadd.f32	s0, s0, s0
 8019b40: 4770         	bx	lr
 8019b42: 2a00         	cmp	r2, #0x0
 8019b44: ed9f 0a4f    	vldr	s0, [pc, #316]          @ 0x8019c84 <atanf+0x15c>
 8019b48: bfcb         	itete	gt
 8019b4a: eddf 7a4f    	vldrgt	s15, [pc, #316]         @ 0x8019c88 <atanf+0x160>
 8019b4e: eddf 7a4f    	vldrle	s15, [pc, #316]         @ 0x8019c8c <atanf+0x164>
 8019b52: ee37 0a80    	vaddgt.f32	s0, s15, s0
 8019b56: ee37 0ac0    	vsuble.f32	s0, s15, s0
 8019b5a: 4770         	bx	lr
 8019b5c: 494c         	ldr	r1, [pc, #0x130]        @ 0x8019c90 <atanf+0x168>
 8019b5e: 428b         	cmp	r3, r1
 8019b60: d811         	bhi	0x8019b86 <atanf+0x5e>  @ imm = #0x22
 8019b62: f1b3 5f44    	cmp.w	r3, #0x31000000
 8019b66: d20b         	bhs	0x8019b80 <atanf+0x58>  @ imm = #0x16
 8019b68: eddf 7a4a    	vldr	s15, [pc, #296]         @ 0x8019c94 <atanf+0x16c>
 8019b6c: ee70 7a27    	vadd.f32	s15, s0, s15
 8019b70: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 8019b74: eef4 7ac7    	vcmpe.f32	s15, s14
 8019b78: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8019b7c: f300 8081    	bgt.w	0x8019c82 <atanf+0x15a> @ imm = #0x102
 8019b80: f04f 33ff    	mov.w	r3, #0xffffffff
 8019b84: e015         	b	0x8019bb2 <atanf+0x8a>  @ imm = #0x2a
 8019b86: 4944         	ldr	r1, [pc, #0x110]        @ 0x8019c98 <atanf+0x170>
 8019b88: eef0 7ac0    	vabs.f32	s15, s0
 8019b8c: 428b         	cmp	r3, r1
 8019b8e: d84f         	bhi	0x8019c30 <atanf+0x108> @ imm = #0x9e
 8019b90: f5a1 01d0    	sub.w	r1, r1, #0x680000
 8019b94: 428b         	cmp	r3, r1
 8019b96: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 8019b9a: d841         	bhi	0x8019c20 <atanf+0xf8>  @ imm = #0x82
 8019b9c: ee77 6aa7    	vadd.f32	s13, s15, s15
 8019ba0: 2300         	movs	r3, #0x0
 8019ba2: ee36 7ac7    	vsub.f32	s14, s13, s14
 8019ba6: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8019baa: ee77 7aa6    	vadd.f32	s15, s15, s13
 8019bae: ee87 0a27    	vdiv.f32	s0, s14, s15
 8019bb2: 1c59         	adds	r1, r3, #0x1
 8019bb4: ee60 6a00    	vmul.f32	s13, s0, s0
 8019bb8: eddf 7a38    	vldr	s15, [pc, #224]         @ 0x8019c9c <atanf+0x174>
 8019bbc: ed9f 6a38    	vldr	s12, [pc, #224]         @ 0x8019ca0 <atanf+0x178>
 8019bc0: eddf 5a38    	vldr	s11, [pc, #224]         @ 0x8019ca4 <atanf+0x17c>
 8019bc4: ee26 7aa6    	vmul.f32	s14, s13, s13
 8019bc8: ee07 6a27    	vmla.f32	s12, s14, s15
 8019bcc: eddf 7a36    	vldr	s15, [pc, #216]         @ 0x8019ca8 <atanf+0x180>
 8019bd0: ee46 7a07    	vmla.f32	s15, s12, s14
 8019bd4: ed9f 6a35    	vldr	s12, [pc, #212]         @ 0x8019cac <atanf+0x184>
 8019bd8: ee07 6a87    	vmla.f32	s12, s15, s14
 8019bdc: eddf 7a34    	vldr	s15, [pc, #208]         @ 0x8019cb0 <atanf+0x188>
 8019be0: ee46 7a07    	vmla.f32	s15, s12, s14
 8019be4: ed9f 6a33    	vldr	s12, [pc, #204]         @ 0x8019cb4 <atanf+0x18c>
 8019be8: ee07 6a87    	vmla.f32	s12, s15, s14
 8019bec: eddf 7a32    	vldr	s15, [pc, #200]         @ 0x8019cb8 <atanf+0x190>
 8019bf0: ee57 5a27    	vnmls.f32	s11, s14, s15
 8019bf4: eddf 7a31    	vldr	s15, [pc, #196]         @ 0x8019cbc <atanf+0x194>
 8019bf8: ee55 7a87    	vnmls.f32	s15, s11, s14
 8019bfc: eddf 5a30    	vldr	s11, [pc, #192]         @ 0x8019cc0 <atanf+0x198>
 8019c00: ee57 5a87    	vnmls.f32	s11, s15, s14
 8019c04: eddf 7a2f    	vldr	s15, [pc, #188]         @ 0x8019cc4 <atanf+0x19c>
 8019c08: ee55 7a87    	vnmls.f32	s15, s11, s14
 8019c0c: ee67 7a87    	vmul.f32	s15, s15, s14
 8019c10: ee46 7a26    	vmla.f32	s15, s12, s13
 8019c14: ee67 7a80    	vmul.f32	s15, s15, s0
 8019c18: d11f         	bne	0x8019c5a <atanf+0x132> @ imm = #0x3e
 8019c1a: ee30 0a67    	vsub.f32	s0, s0, s15
 8019c1e: 4770         	bx	lr
 8019c20: ee77 6ac7    	vsub.f32	s13, s15, s14
 8019c24: ee77 7a87    	vadd.f32	s15, s15, s14
 8019c28: 2301         	movs	r3, #0x1
 8019c2a: ee86 0aa7    	vdiv.f32	s0, s13, s15
 8019c2e: e7c0         	b	0x8019bb2 <atanf+0x8a>  @ imm = #-0x80
 8019c30: 4925         	ldr	r1, [pc, #0x94]         @ 0x8019cc8 <atanf+0x1a0>
 8019c32: 428b         	cmp	r3, r1
 8019c34: d80b         	bhi	0x8019c4e <atanf+0x126> @ imm = #0x16
 8019c36: eef7 6a08    	vmov.f32	s13, #1.500000e+00
 8019c3a: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 8019c3e: ee07 7aa6    	vmla.f32	s14, s15, s13
 8019c42: 2302         	movs	r3, #0x2
 8019c44: ee37 6ae6    	vsub.f32	s12, s15, s13
 8019c48: ee86 0a07    	vdiv.f32	s0, s12, s14
 8019c4c: e7b1         	b	0x8019bb2 <atanf+0x8a>  @ imm = #-0x9e
 8019c4e: eebf 7a00    	vmov.f32	s14, #-1.000000e+00
 8019c52: ee87 0a27    	vdiv.f32	s0, s14, s15
 8019c56: 2303         	movs	r3, #0x3
 8019c58: e7ab         	b	0x8019bb2 <atanf+0x8a>  @ imm = #-0xaa
 8019c5a: 491c         	ldr	r1, [pc, #0x70]         @ 0x8019ccc <atanf+0x1a4>
 8019c5c: 481c         	ldr	r0, [pc, #0x70]         @ 0x8019cd0 <atanf+0x1a8>
 8019c5e: eb01 0183    	add.w	r1, r1, r3, lsl #2
 8019c62: eb00 0383    	add.w	r3, r0, r3, lsl #2
 8019c66: ed93 7a00    	vldr	s14, [r3]
 8019c6a: ee77 7ac7    	vsub.f32	s15, s15, s14
 8019c6e: 2a00         	cmp	r2, #0x0
 8019c70: ee77 7ac0    	vsub.f32	s15, s15, s0
 8019c74: ed91 0a00    	vldr	s0, [r1]
 8019c78: ee30 0a67    	vsub.f32	s0, s0, s15
 8019c7c: bfb8         	it	lt
 8019c7e: eeb1 0a40    	vneglt.f32	s0, s0
 8019c82: 4770         	bx	lr

08019c84 <$d>:
 8019c84: 68 21 a2 33  	.word	0x33a22168
 8019c88: da 0f c9 3f  	.word	0x3fc90fda
 8019c8c: da 0f c9 bf  	.word	0xbfc90fda
 8019c90: ff ff df 3e  	.word	0x3edfffff
 8019c94: ca f2 49 71  	.word	0x7149f2ca
 8019c98: ff ff 97 3f  	.word	0x3f97ffff
 8019c9c: d7 69 85 3c  	.word	0x3c8569d7
 8019ca0: 59 da 4b 3d  	.word	0x3d4bda59
 8019ca4: 6b f1 6e 3d  	.word	0x3d6ef16b
 8019ca8: 35 6b 88 3d  	.word	0x3d886b35
 8019cac: 6e 2e ba 3d  	.word	0x3dba2e6e
 8019cb0: 25 49 12 3e  	.word	0x3e124925
 8019cb4: ab aa aa 3e  	.word	0x3eaaaaab
 8019cb8: 21 a2 15 bd  	.word	0xbd15a221
 8019cbc: 95 87 9d 3d  	.word	0x3d9d8795
 8019cc0: 38 8e e3 3d  	.word	0x3de38e38
 8019cc4: cd cc 4c 3e  	.word	0x3e4ccccd
 8019cc8: ff ff 1b 40  	.word	0x401bffff
 8019ccc: 3c c1 02 08  	.word	0x0802c13c
 8019cd0: 2c c1 02 08  	.word	0x0802c12c

08019cd4 <__math_inexactf>:
 8019cd4: ed9f 7a05    	vldr	s14, [pc, #20]          @ 0x8019cec <__math_inexactf+0x18>
 8019cd8: eef7 7a00    	vmov.f32	s15, #1.000000e+00
 8019cdc: ee77 7a87    	vadd.f32	s15, s15, s14
 8019ce0: b082         	sub	sp, #0x8
 8019ce2: edcd 7a01    	vstr	s15, [sp, #4]
 8019ce6: 9b01         	ldr	r3, [sp, #0x4]
 8019ce8: b002         	add	sp, #0x8
 8019cea: 4770         	bx	lr

08019cec <$d>:
 8019cec: 00 00 80 00  	.word	0x00800000

08019cf0 <scalbnf>:
 8019cf0: 4602         	mov	r2, r0
 8019cf2: ee10 0a10    	vmov	r0, s0
 8019cf6: f3c0 53c7    	ubfx	r3, r0, #0x17, #0x8
 8019cfa: f020 4100    	bic	r1, r0, #0x80000000
 8019cfe: b983         	cbnz	r3, 0x8019d22 <scalbnf+0x32> @ imm = #0x20
 8019d00: b3a9         	cbz	r1, 0x8019d6e <scalbnf+0x7e> @ imm = #0x6a
 8019d02: eddf 7a1b    	vldr	s15, [pc, #108]         @ 0x8019d70 <scalbnf+0x80>
 8019d06: 491b         	ldr	r1, [pc, #0x6c]         @ 0x8019d74 <scalbnf+0x84>
 8019d08: ee60 7a27    	vmul.f32	s15, s0, s15
 8019d0c: 428a         	cmp	r2, r1
 8019d0e: ee17 0a90    	vmov	r0, s15
 8019d12: f3c0 53c7    	ubfx	r3, r0, #0x17, #0x8
 8019d16: f1a3 0319    	sub.w	r3, r3, #0x19
 8019d1a: da07         	bge	0x8019d2c <scalbnf+0x3c> @ imm = #0xe
 8019d1c: 0fc0         	lsrs	r0, r0, #0x1f
 8019d1e: f7ff bbb1    	b.w	0x8019484 <__math_uflowf> @ imm = #-0x89e
 8019d22: 2bff         	cmp	r3, #0xff
 8019d24: d102         	bne	0x8019d2c <scalbnf+0x3c> @ imm = #0x4
 8019d26: ee30 0a00    	vadd.f32	s0, s0, s0
 8019d2a: 4770         	bx	lr
 8019d2c: f24c 3150    	movw	r1, #0xc350
 8019d30: 428a         	cmp	r2, r1
 8019d32: dd02         	ble	0x8019d3a <scalbnf+0x4a> @ imm = #0x4
 8019d34: 0fc0         	lsrs	r0, r0, #0x1f
 8019d36: f7ff bbb5    	b.w	0x80194a4 <__math_oflowf> @ imm = #-0x896
 8019d3a: 4413         	add	r3, r2
 8019d3c: 2bfe         	cmp	r3, #0xfe
 8019d3e: dcf9         	bgt	0x8019d34 <scalbnf+0x44> @ imm = #-0xe
 8019d40: 2b00         	cmp	r3, #0x0
 8019d42: dd06         	ble	0x8019d52 <scalbnf+0x62> @ imm = #0xc
 8019d44: f020 40ff    	bic	r0, r0, #0x7f800000
 8019d48: ea40 53c3    	orr.w	r3, r0, r3, lsl #23
 8019d4c: ee00 3a10    	vmov	s0, r3
 8019d50: 4770         	bx	lr
 8019d52: f113 0f18    	cmn.w	r3, #0x18
 8019d56: dbe1         	blt	0x8019d1c <scalbnf+0x2c> @ imm = #-0x3e
 8019d58: 3319         	adds	r3, #0x19
 8019d5a: f020 40ff    	bic	r0, r0, #0x7f800000
 8019d5e: ea40 50c3    	orr.w	r0, r0, r3, lsl #23
 8019d62: ed9f 0a05    	vldr	s0, [pc, #20]           @ 0x8019d78 <scalbnf+0x88>
 8019d66: ee07 0a90    	vmov	s15, r0
 8019d6a: ee27 0a80    	vmul.f32	s0, s15, s0
 8019d6e: 4770         	bx	lr

08019d70 <$d>:
 8019d70: 00 00 00 4c  	.word	0x4c000000
 8019d74: b0 3c ff ff  	.word	0xffff3cb0
 8019d78: 00 00 00 33  	.word	0x33000000

08019d7c <floorf>:
 8019d7c: ee10 1a10    	vmov	r1, s0
 8019d80: f3c1 53c7    	ubfx	r3, r1, #0x17, #0x8
 8019d84: 3b7f         	subs	r3, #0x7f
 8019d86: 2b16         	cmp	r3, #0x16
 8019d88: f021 4000    	bic	r0, r1, #0x80000000
 8019d8c: dc1a         	bgt	0x8019dc4 <floorf+0x48> @ imm = #0x34
 8019d8e: 2b00         	cmp	r3, #0x0
 8019d90: 460a         	mov	r2, r1
 8019d92: da09         	bge	0x8019da8 <floorf+0x2c> @ imm = #0x12
 8019d94: 2900         	cmp	r1, #0x0
 8019d96: da1b         	bge	0x8019dd0 <floorf+0x54> @ imm = #0x36
 8019d98: 2800         	cmp	r0, #0x0
 8019d9a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8019dd4 <floorf+0x58>
 8019d9c: bf08         	it	eq
 8019d9e: f04f 4300    	moveq.w	r3, #0x80000000
 8019da2: ee00 3a10    	vmov	s0, r3
 8019da6: 4770         	bx	lr
 8019da8: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8019dd8 <floorf+0x5c>
 8019daa: 4119         	asrs	r1, r3
 8019dac: 4211         	tst	r1, r2
 8019dae: d0fa         	beq	0x8019da6 <floorf+0x2a> @ imm = #-0xc
 8019db0: 2a00         	cmp	r2, #0x0
 8019db2: bfbe         	ittt	lt
 8019db4: f44f 0000    	movlt.w	r0, #0x800000
 8019db8: fa40 f303    	asrlt.w	r3, r0, r3
 8019dbc: 18d2         	addlt	r2, r2, r3
 8019dbe: ea22 0301    	bic.w	r3, r2, r1
 8019dc2: e7ee         	b	0x8019da2 <floorf+0x26> @ imm = #-0x24
 8019dc4: f1b0 4fff    	cmp.w	r0, #0x7f800000
 8019dc8: d3ed         	blo	0x8019da6 <floorf+0x2a> @ imm = #-0x26
 8019dca: ee30 0a00    	vadd.f32	s0, s0, s0
 8019dce: 4770         	bx	lr
 8019dd0: 2300         	movs	r3, #0x0
 8019dd2: e7e6         	b	0x8019da2 <floorf+0x26> @ imm = #-0x34

08019dd4 <$d>:
 8019dd4: 00 00 80 bf  	.word	0xbf800000
 8019dd8: ff ff 7f 00  	.word	0x007fffff

08019ddc <_OffsetAbsSyms>:
; GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
 8019ddc: b480         	push	{r7}
 8019dde: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 8019de0: bf00         	nop
 8019de2: 46bd         	mov	sp, r7
 8019de4: f85d 7b04    	ldr	r7, [sp], #4
 8019de8: 4770         	bx	lr

08019dea <device_is_ready>:
; {
 8019dea: b580         	push	{r7, lr}
 8019dec: b082         	sub	sp, #0x8
 8019dee: af00         	add	r7, sp, #0x0
 8019df0: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8019df2: 6878         	ldr	r0, [r7, #0x4]
 8019df4: f00a fb95    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0xa72a
 8019df8: 4603         	mov	r3, r0
; }
 8019dfa: 4618         	mov	r0, r3
 8019dfc: 3708         	adds	r7, #0x8
 8019dfe: 46bd         	mov	sp, r7
 8019e00: bd80         	pop	{r7, pc}

08019e02 <arch_k_cycle_get_32>:
; {
 8019e02: b580         	push	{r7, lr}
 8019e04: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 8019e06: f7f5 fb53    	bl	0x800f4b0 <sys_clock_cycle_get_32> @ imm = #-0xa95a
 8019e0a: 4603         	mov	r3, r0
; }
 8019e0c: 4618         	mov	r0, r3
 8019e0e: bd80         	pop	{r7, pc}

08019e10 <k_msleep>:
; {
 8019e10: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8019e14: b082         	sub	sp, #0x8
 8019e16: af00         	add	r7, sp, #0x0
 8019e18: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 8019e1a: 6879         	ldr	r1, [r7, #0x4]
 8019e1c: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 8019e20: 17c8         	asrs	r0, r1, #0x1f
 8019e22: 4688         	mov	r8, r1
 8019e24: 4681         	mov	r9, r0
 8019e26: 4640         	mov	r0, r8
 8019e28: 4649         	mov	r1, r9
 8019e2a: f04f 0400    	mov.w	r4, #0x0
 8019e2e: f04f 0500    	mov.w	r5, #0x0
 8019e32: 008d         	lsls	r5, r1, #0x2
 8019e34: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 8019e38: 0084         	lsls	r4, r0, #0x2
 8019e3a: 4620         	mov	r0, r4
 8019e3c: 4629         	mov	r1, r5
 8019e3e: eb10 0208    	adds.w	r2, r0, r8
 8019e42: eb41 0309    	adc.w	r3, r1, r9
 8019e46: eb12 0a02    	adds.w	r10, r2, r2
 8019e4a: eb43 0b03    	adc.w	r11, r3, r3
 8019e4e: 4652         	mov	r2, r10
 8019e50: 465b         	mov	r3, r11
 8019e52: 4610         	mov	r0, r2
 8019e54: 4619         	mov	r1, r3
 8019e56: f000 f82e    	bl	0x8019eb6 <k_sleep>     @ imm = #0x5c
 8019e5a: 4601         	mov	r1, r0
 8019e5c: 460b         	mov	r3, r1
; }
 8019e5e: 4618         	mov	r0, r3
 8019e60: 3708         	adds	r7, #0x8
 8019e62: 46bd         	mov	sp, r7
 8019e64: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08019e68 <k_cycle_get_32>:
; {
 8019e68: b580         	push	{r7, lr}
 8019e6a: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 8019e6c: f7ff ffc9    	bl	0x8019e02 <arch_k_cycle_get_32> @ imm = #-0x6e
 8019e70: 4603         	mov	r3, r0
; }
 8019e72: 4618         	mov	r0, r3
 8019e74: bd80         	pop	{r7, pc}

08019e76 <k_thread_create>:
; {
 8019e76: b580         	push	{r7, lr}
 8019e78: b08c         	sub	sp, #0x30
 8019e7a: af08         	add	r7, sp, #0x20
 8019e7c: 60f8         	str	r0, [r7, #0xc]
 8019e7e: 60b9         	str	r1, [r7, #0x8]
 8019e80: 607a         	str	r2, [r7, #0x4]
 8019e82: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 8019e84: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8019e88: e9cd 2306    	strd	r2, r3, [sp, #24]
 8019e8c: 6abb         	ldr	r3, [r7, #0x28]
 8019e8e: 9304         	str	r3, [sp, #0x10]
 8019e90: 6a7b         	ldr	r3, [r7, #0x24]
 8019e92: 9303         	str	r3, [sp, #0xc]
 8019e94: 6a3b         	ldr	r3, [r7, #0x20]
 8019e96: 9302         	str	r3, [sp, #0x8]
 8019e98: 69fb         	ldr	r3, [r7, #0x1c]
 8019e9a: 9301         	str	r3, [sp, #0x4]
 8019e9c: 69bb         	ldr	r3, [r7, #0x18]
 8019e9e: 9300         	str	r3, [sp]
 8019ea0: 683b         	ldr	r3, [r7]
 8019ea2: 687a         	ldr	r2, [r7, #0x4]
 8019ea4: 68b9         	ldr	r1, [r7, #0x8]
 8019ea6: 68f8         	ldr	r0, [r7, #0xc]
 8019ea8: f00c f9c3    	bl	0x8026232 <z_impl_k_thread_create> @ imm = #0xc386
 8019eac: 4603         	mov	r3, r0
; }
 8019eae: 4618         	mov	r0, r3
 8019eb0: 3710         	adds	r7, #0x10
 8019eb2: 46bd         	mov	sp, r7
 8019eb4: bd80         	pop	{r7, pc}

08019eb6 <k_sleep>:
; {
 8019eb6: b580         	push	{r7, lr}
 8019eb8: b082         	sub	sp, #0x8
 8019eba: af00         	add	r7, sp, #0x0
 8019ebc: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8019ec0: e9d7 0100    	ldrd	r0, r1, [r7]
 8019ec4: f7fc fa14    	bl	0x80162f0 <z_impl_k_sleep> @ imm = #-0x3bd8
 8019ec8: 4603         	mov	r3, r0
; }
 8019eca: 4618         	mov	r0, r3
 8019ecc: 3708         	adds	r7, #0x8
 8019ece: 46bd         	mov	sp, r7
 8019ed0: bd80         	pop	{r7, pc}

08019ed2 <z_impl_sbus_get_percent>:
; static inline float z_impl_sbus_get_percent(const struct device *dev, uint8_t channelid) {
 8019ed2: b580         	push	{r7, lr}
 8019ed4: b084         	sub	sp, #0x10
 8019ed6: af00         	add	r7, sp, #0x0
 8019ed8: 6078         	str	r0, [r7, #0x4]
 8019eda: 460b         	mov	r3, r1
 8019edc: 70fb         	strb	r3, [r7, #0x3]
;     const struct sbus_driver_api *api = (const struct sbus_driver_api *)dev->api;
 8019ede: 687b         	ldr	r3, [r7, #0x4]
 8019ee0: 689b         	ldr	r3, [r3, #0x8]
 8019ee2: 60fb         	str	r3, [r7, #0xc]
;     if (api->getchannel_percentage) {
 8019ee4: 68fb         	ldr	r3, [r7, #0xc]
 8019ee6: 681b         	ldr	r3, [r3]
 8019ee8: 2b00         	cmp	r3, #0x0
 8019eea: d009         	beq	0x8019f00 <z_impl_sbus_get_percent+0x2e> @ imm = #0x12
;         float temp = api->getchannel_percentage(dev, channelid);
 8019eec: 68fb         	ldr	r3, [r7, #0xc]
 8019eee: 681b         	ldr	r3, [r3]
 8019ef0: 78fa         	ldrb	r2, [r7, #0x3]
 8019ef2: 4611         	mov	r1, r2
 8019ef4: 6878         	ldr	r0, [r7, #0x4]
 8019ef6: 4798         	blx	r3
 8019ef8: ed87 0a02    	vstr	s0, [r7, #8]
;         return temp;
 8019efc: 68bb         	ldr	r3, [r7, #0x8]
 8019efe: e001         	b	0x8019f04 <z_impl_sbus_get_percent+0x32> @ imm = #0x2
;     return 0.0f;
 8019f00: f04f 0300    	mov.w	r3, #0x0
; }
 8019f04: ee07 3a90    	vmov	s15, r3
 8019f08: eeb0 0a67    	vmov.f32	s0, s15
 8019f0c: 3710         	adds	r7, #0x10
 8019f0e: 46bd         	mov	sp, r7
 8019f10: bd80         	pop	{r7, pc}

08019f12 <sbus_get_percent>:
; {
 8019f12: b580         	push	{r7, lr}
 8019f14: b082         	sub	sp, #0x8
 8019f16: af00         	add	r7, sp, #0x0
 8019f18: 6078         	str	r0, [r7, #0x4]
 8019f1a: 460b         	mov	r3, r1
 8019f1c: 70fb         	strb	r3, [r7, #0x3]
; 	return z_impl_sbus_get_percent(dev, channelid);
 8019f1e: 78fb         	ldrb	r3, [r7, #0x3]
 8019f20: 4619         	mov	r1, r3
 8019f22: 6878         	ldr	r0, [r7, #0x4]
 8019f24: f7ff ffd5    	bl	0x8019ed2 <z_impl_sbus_get_percent> @ imm = #-0x56
 8019f28: eef0 7a40    	vmov.f32	s15, s0
; }
 8019f2c: eeb0 0a67    	vmov.f32	s0, s15
 8019f30: 3708         	adds	r7, #0x8
 8019f32: 46bd         	mov	sp, r7
 8019f34: bd80         	pop	{r7, pc}

08019f36 <sensor_trigger_set>:
; {
 8019f36: b580         	push	{r7, lr}
 8019f38: b086         	sub	sp, #0x18
 8019f3a: af00         	add	r7, sp, #0x0
 8019f3c: 60f8         	str	r0, [r7, #0xc]
 8019f3e: 60b9         	str	r1, [r7, #0x8]
 8019f40: 607a         	str	r2, [r7, #0x4]
; 	const struct sensor_driver_api *api =
 8019f42: 68fb         	ldr	r3, [r7, #0xc]
 8019f44: 689b         	ldr	r3, [r3, #0x8]
 8019f46: 617b         	str	r3, [r7, #0x14]
; 	if (api->trigger_set == NULL) {
 8019f48: 697b         	ldr	r3, [r7, #0x14]
 8019f4a: 689b         	ldr	r3, [r3, #0x8]
 8019f4c: 2b00         	cmp	r3, #0x0
 8019f4e: d102         	bne	0x8019f56 <sensor_trigger_set+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8019f50: f06f 0357    	mvn	r3, #0x57
 8019f54: e006         	b	0x8019f64 <sensor_trigger_set+0x2e> @ imm = #0xc
; 	return api->trigger_set(dev, trig, handler);
 8019f56: 697b         	ldr	r3, [r7, #0x14]
 8019f58: 689b         	ldr	r3, [r3, #0x8]
 8019f5a: 687a         	ldr	r2, [r7, #0x4]
 8019f5c: 68b9         	ldr	r1, [r7, #0x8]
 8019f5e: 68f8         	ldr	r0, [r7, #0xc]
 8019f60: 4798         	blx	r3
 8019f62: 4603         	mov	r3, r0
; }
 8019f64: 4618         	mov	r0, r3
 8019f66: 3718         	adds	r7, #0x18
 8019f68: 46bd         	mov	sp, r7
 8019f6a: bd80         	pop	{r7, pc}

08019f6c <z_impl_sensor_sample_fetch>:
; {
 8019f6c: b580         	push	{r7, lr}
 8019f6e: b084         	sub	sp, #0x10
 8019f70: af00         	add	r7, sp, #0x0
 8019f72: 6078         	str	r0, [r7, #0x4]
; 	const struct sensor_driver_api *api =
 8019f74: 687b         	ldr	r3, [r7, #0x4]
 8019f76: 689b         	ldr	r3, [r3, #0x8]
 8019f78: 60fb         	str	r3, [r7, #0xc]
; 	return api->sample_fetch(dev, SENSOR_CHAN_ALL);
 8019f7a: 68fb         	ldr	r3, [r7, #0xc]
 8019f7c: 68db         	ldr	r3, [r3, #0xc]
 8019f7e: 213c         	movs	r1, #0x3c
 8019f80: 6878         	ldr	r0, [r7, #0x4]
 8019f82: 4798         	blx	r3
 8019f84: 4603         	mov	r3, r0
; }
 8019f86: 4618         	mov	r0, r3
 8019f88: 3710         	adds	r7, #0x10
 8019f8a: 46bd         	mov	sp, r7
 8019f8c: bd80         	pop	{r7, pc}

08019f8e <z_impl_sensor_channel_get>:
; {
 8019f8e: b580         	push	{r7, lr}
 8019f90: b086         	sub	sp, #0x18
 8019f92: af00         	add	r7, sp, #0x0
 8019f94: 60f8         	str	r0, [r7, #0xc]
 8019f96: 460b         	mov	r3, r1
 8019f98: 607a         	str	r2, [r7, #0x4]
 8019f9a: 817b         	strh	r3, [r7, #0xa]
; 	const struct sensor_driver_api *api =
 8019f9c: 68fb         	ldr	r3, [r7, #0xc]
 8019f9e: 689b         	ldr	r3, [r3, #0x8]
 8019fa0: 617b         	str	r3, [r7, #0x14]
; 	return api->channel_get(dev, chan, val);
 8019fa2: 697b         	ldr	r3, [r7, #0x14]
 8019fa4: 691b         	ldr	r3, [r3, #0x10]
 8019fa6: 8979         	ldrh	r1, [r7, #0xa]
 8019fa8: 687a         	ldr	r2, [r7, #0x4]
 8019faa: 68f8         	ldr	r0, [r7, #0xc]
 8019fac: 4798         	blx	r3
 8019fae: 4603         	mov	r3, r0
; }
 8019fb0: 4618         	mov	r0, r3
 8019fb2: 3718         	adds	r7, #0x18
 8019fb4: 46bd         	mov	sp, r7
 8019fb6: bd80         	pop	{r7, pc}

08019fb8 <sensor_sample_fetch>:
; {
 8019fb8: b580         	push	{r7, lr}
 8019fba: b082         	sub	sp, #0x8
 8019fbc: af00         	add	r7, sp, #0x0
 8019fbe: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_sensor_sample_fetch(dev);
 8019fc0: 6878         	ldr	r0, [r7, #0x4]
 8019fc2: f7ff ffd3    	bl	0x8019f6c <z_impl_sensor_sample_fetch> @ imm = #-0x5a
 8019fc6: 4603         	mov	r3, r0
; }
 8019fc8: 4618         	mov	r0, r3
 8019fca: 3708         	adds	r7, #0x8
 8019fcc: 46bd         	mov	sp, r7
 8019fce: bd80         	pop	{r7, pc}

08019fd0 <sensor_channel_get>:
; {
 8019fd0: b580         	push	{r7, lr}
 8019fd2: b084         	sub	sp, #0x10
 8019fd4: af00         	add	r7, sp, #0x0
 8019fd6: 60f8         	str	r0, [r7, #0xc]
 8019fd8: 460b         	mov	r3, r1
 8019fda: 607a         	str	r2, [r7, #0x4]
 8019fdc: 817b         	strh	r3, [r7, #0xa]
; 	return z_impl_sensor_channel_get(dev, chan, val);
 8019fde: 897b         	ldrh	r3, [r7, #0xa]
 8019fe0: 687a         	ldr	r2, [r7, #0x4]
 8019fe2: 4619         	mov	r1, r3
 8019fe4: 68f8         	ldr	r0, [r7, #0xc]
 8019fe6: f7ff ffd2    	bl	0x8019f8e <z_impl_sensor_channel_get> @ imm = #-0x5c
 8019fea: 4603         	mov	r3, r0
; }
 8019fec: 4618         	mov	r0, r3
 8019fee: 3710         	adds	r7, #0x10
 8019ff0: 46bd         	mov	sp, r7
 8019ff2: bd80         	pop	{r7, pc}

08019ff4 <Kalman_Filter_xhatMinusUpdate>:
; {
 8019ff4: b580         	push	{r7, lr}
 8019ff6: b082         	sub	sp, #0x8
 8019ff8: af00         	add	r7, sp, #0x0
 8019ffa: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq1) {
 8019ffc: 687b         	ldr	r3, [r7, #0x4]
 8019ffe: f893 3028    	ldrb.w	r3, [r3, #0x28]
 801a002: 2b00         	cmp	r3, #0x0
 801a004: d158         	bne	0x801a0b8 <Kalman_Filter_xhatMinusUpdate+0xc4> @ imm = #0xb0
; 		if (kf->uSize > 0) {
 801a006: 687b         	ldr	r3, [r7, #0x4]
 801a008: 7b5b         	ldrb	r3, [r3, #0xd]
 801a00a: 2b00         	cmp	r3, #0x0
 801a00c: d044         	beq	0x801a098 <Kalman_Filter_xhatMinusUpdate+0xa4> @ imm = #0x88
; 			kf->temp_vector.numRows = kf->xhatSize;
 801a00e: 687b         	ldr	r3, [r7, #0x4]
 801a010: 7b1b         	ldrb	r3, [r3, #0xc]
 801a012: 461a         	mov	r2, r3
 801a014: 687b         	ldr	r3, [r7, #0x4]
 801a016: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 			kf->temp_vector.numCols = 1;
 801a01a: 687b         	ldr	r3, [r7, #0x4]
 801a01c: 2201         	movs	r2, #0x1
 801a01e: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 			kf->MatStatus = Matrix_Multiply(&kf->F, &kf->xhat, &kf->temp_vector);
 801a022: 687b         	ldr	r3, [r7, #0x4]
 801a024: f103 0060    	add.w	r0, r3, #0x60
 801a028: 687b         	ldr	r3, [r7, #0x4]
 801a02a: f103 0130    	add.w	r1, r3, #0x30
 801a02e: 687b         	ldr	r3, [r7, #0x4]
 801a030: 33b8         	adds	r3, #0xb8
 801a032: 461a         	mov	r2, r3
 801a034: f7f8 fb68    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x7930
 801a038: 4603         	mov	r3, r0
 801a03a: 461a         	mov	r2, r3
 801a03c: 687b         	ldr	r3, [r7, #0x4]
 801a03e: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 			kf->temp_vector1.numRows = kf->xhatSize;
 801a042: 687b         	ldr	r3, [r7, #0x4]
 801a044: 7b1b         	ldrb	r3, [r3, #0xc]
 801a046: 461a         	mov	r2, r3
 801a048: 687b         	ldr	r3, [r7, #0x4]
 801a04a: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 			kf->temp_vector1.numCols = 1;
 801a04e: 687b         	ldr	r3, [r7, #0x4]
 801a050: 2201         	movs	r2, #0x1
 801a052: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 			kf->MatStatus = Matrix_Multiply(&kf->B, &kf->u, &kf->temp_vector1);
 801a056: 687b         	ldr	r3, [r7, #0x4]
 801a058: f103 0070    	add.w	r0, r3, #0x70
 801a05c: 687b         	ldr	r3, [r7, #0x4]
 801a05e: f103 0140    	add.w	r1, r3, #0x40
 801a062: 687b         	ldr	r3, [r7, #0x4]
 801a064: 33c0         	adds	r3, #0xc0
 801a066: 461a         	mov	r2, r3
 801a068: f7f8 fb4e    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x7964
 801a06c: 4603         	mov	r3, r0
 801a06e: 461a         	mov	r2, r3
 801a070: 687b         	ldr	r3, [r7, #0x4]
 801a072: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 				Matrix_Add(&kf->temp_vector, &kf->temp_vector1, &kf->xhatminus);
 801a076: 687b         	ldr	r3, [r7, #0x4]
 801a078: f103 00b8    	add.w	r0, r3, #0xb8
 801a07c: 687b         	ldr	r3, [r7, #0x4]
 801a07e: f103 01c0    	add.w	r1, r3, #0xc0
 801a082: 687b         	ldr	r3, [r7, #0x4]
 801a084: 3338         	adds	r3, #0x38
 801a086: 461a         	mov	r2, r3
 801a088: f7f8 f9a2    	bl	0x80123d0 <arm_mat_add_f32> @ imm = #-0x7cbc
 801a08c: 4603         	mov	r3, r0
 801a08e: 461a         	mov	r2, r3
; 			kf->MatStatus =
 801a090: 687b         	ldr	r3, [r7, #0x4]
 801a092: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801a096: e00f         	b	0x801a0b8 <Kalman_Filter_xhatMinusUpdate+0xc4> @ imm = #0x1e
; 			kf->MatStatus = Matrix_Multiply(&kf->F, &kf->xhat, &kf->xhatminus);
 801a098: 687b         	ldr	r3, [r7, #0x4]
 801a09a: f103 0060    	add.w	r0, r3, #0x60
 801a09e: 687b         	ldr	r3, [r7, #0x4]
 801a0a0: f103 0130    	add.w	r1, r3, #0x30
 801a0a4: 687b         	ldr	r3, [r7, #0x4]
 801a0a6: 3338         	adds	r3, #0x38
 801a0a8: 461a         	mov	r2, r3
 801a0aa: f7f8 fb2d    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x79a6
 801a0ae: 4603         	mov	r3, r0
 801a0b0: 461a         	mov	r2, r3
 801a0b2: 687b         	ldr	r3, [r7, #0x4]
 801a0b4: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801a0b8: bf00         	nop
 801a0ba: 3708         	adds	r7, #0x8
 801a0bc: 46bd         	mov	sp, r7
 801a0be: bd80         	pop	{r7, pc}

0801a0c0 <Kalman_Filter_PminusUpdate>:
; {
 801a0c0: b580         	push	{r7, lr}
 801a0c2: b082         	sub	sp, #0x8
 801a0c4: af00         	add	r7, sp, #0x0
 801a0c6: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq2) {
 801a0c8: 687b         	ldr	r3, [r7, #0x4]
 801a0ca: f893 3029    	ldrb.w	r3, [r3, #0x29]
 801a0ce: 2b00         	cmp	r3, #0x0
 801a0d0: d149         	bne	0x801a166 <Kalman_Filter_PminusUpdate+0xa6> @ imm = #0x92
; 		kf->MatStatus = Matrix_Transpose(&kf->F, &kf->FT);
 801a0d2: 687b         	ldr	r3, [r7, #0x4]
 801a0d4: f103 0260    	add.w	r2, r3, #0x60
 801a0d8: 687b         	ldr	r3, [r7, #0x4]
 801a0da: 3368         	adds	r3, #0x68
 801a0dc: 4619         	mov	r1, r3
 801a0de: 4610         	mov	r0, r2
 801a0e0: f7f8 fb82    	bl	0x80127e8 <arm_mat_trans_f32> @ imm = #-0x78fc
 801a0e4: 4603         	mov	r3, r0
 801a0e6: 461a         	mov	r2, r3
 801a0e8: 687b         	ldr	r3, [r7, #0x4]
 801a0ea: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->F, &kf->P, &kf->Pminus);
 801a0ee: 687b         	ldr	r3, [r7, #0x4]
 801a0f0: f103 0060    	add.w	r0, r3, #0x60
 801a0f4: 687b         	ldr	r3, [r7, #0x4]
 801a0f6: f103 0150    	add.w	r1, r3, #0x50
 801a0fa: 687b         	ldr	r3, [r7, #0x4]
 801a0fc: 3358         	adds	r3, #0x58
 801a0fe: 461a         	mov	r2, r3
 801a100: f7f8 fb02    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x79fc
 801a104: 4603         	mov	r3, r0
 801a106: 461a         	mov	r2, r3
 801a108: 687b         	ldr	r3, [r7, #0x4]
 801a10a: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->Pminus.numRows;
 801a10e: 687b         	ldr	r3, [r7, #0x4]
 801a110: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 801a114: 687b         	ldr	r3, [r7, #0x4]
 801a116: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->FT.numCols;
 801a11a: 687b         	ldr	r3, [r7, #0x4]
 801a11c: f8b3 206a    	ldrh.w	r2, [r3, #0x6a]
 801a120: 687b         	ldr	r3, [r7, #0x4]
 801a122: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->Pminus, &kf->FT,
 801a126: 687b         	ldr	r3, [r7, #0x4]
 801a128: f103 0058    	add.w	r0, r3, #0x58
 801a12c: 687b         	ldr	r3, [r7, #0x4]
 801a12e: f103 0168    	add.w	r1, r3, #0x68
 801a132: 687b         	ldr	r3, [r7, #0x4]
 801a134: 33a8         	adds	r3, #0xa8
 801a136: 461a         	mov	r2, r3
 801a138: f7f8 fae6    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x7a34
 801a13c: 4603         	mov	r3, r0
 801a13e: 461a         	mov	r2, r3
 801a140: 687b         	ldr	r3, [r7, #0x4]
 801a142: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Add(&kf->temp_matrix, &kf->Q, &kf->Pminus);
 801a146: 687b         	ldr	r3, [r7, #0x4]
 801a148: f103 00a8    	add.w	r0, r3, #0xa8
 801a14c: 687b         	ldr	r3, [r7, #0x4]
 801a14e: f103 0188    	add.w	r1, r3, #0x88
 801a152: 687b         	ldr	r3, [r7, #0x4]
 801a154: 3358         	adds	r3, #0x58
 801a156: 461a         	mov	r2, r3
 801a158: f7f8 f93a    	bl	0x80123d0 <arm_mat_add_f32> @ imm = #-0x7d8c
 801a15c: 4603         	mov	r3, r0
 801a15e: 461a         	mov	r2, r3
 801a160: 687b         	ldr	r3, [r7, #0x4]
 801a162: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801a166: bf00         	nop
 801a168: 3708         	adds	r7, #0x8
 801a16a: 46bd         	mov	sp, r7
 801a16c: bd80         	pop	{r7, pc}

0801a16e <Kalman_Filter_SetK>:
; {
 801a16e: b580         	push	{r7, lr}
 801a170: b082         	sub	sp, #0x8
 801a172: af00         	add	r7, sp, #0x0
 801a174: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq3) {
 801a176: 687b         	ldr	r3, [r7, #0x4]
 801a178: f893 302a    	ldrb.w	r3, [r3, #0x2a]
 801a17c: 2b00         	cmp	r3, #0x0
 801a17e: f040 809c    	bne.w	0x801a2ba <Kalman_Filter_SetK+0x14c> @ imm = #0x138
; 		kf->MatStatus = Matrix_Transpose(&kf->H, &kf->HT); // z|x => x|z
 801a182: 687b         	ldr	r3, [r7, #0x4]
 801a184: f103 0278    	add.w	r2, r3, #0x78
 801a188: 687b         	ldr	r3, [r7, #0x4]
 801a18a: 3380         	adds	r3, #0x80
 801a18c: 4619         	mov	r1, r3
 801a18e: 4610         	mov	r0, r2
 801a190: f7f8 fb2a    	bl	0x80127e8 <arm_mat_trans_f32> @ imm = #-0x79ac
 801a194: 4603         	mov	r3, r0
 801a196: 461a         	mov	r2, r3
 801a198: 687b         	ldr	r3, [r7, #0x4]
 801a19a: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->H.numRows;
 801a19e: 687b         	ldr	r3, [r7, #0x4]
 801a1a0: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 801a1a4: 687b         	ldr	r3, [r7, #0x4]
 801a1a6: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->Pminus.numCols;
 801a1aa: 687b         	ldr	r3, [r7, #0x4]
 801a1ac: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 801a1b0: 687b         	ldr	r3, [r7, #0x4]
 801a1b2: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->H, &kf->Pminus,
 801a1b6: 687b         	ldr	r3, [r7, #0x4]
 801a1b8: f103 0078    	add.w	r0, r3, #0x78
 801a1bc: 687b         	ldr	r3, [r7, #0x4]
 801a1be: f103 0158    	add.w	r1, r3, #0x58
 801a1c2: 687b         	ldr	r3, [r7, #0x4]
 801a1c4: 33a8         	adds	r3, #0xa8
 801a1c6: 461a         	mov	r2, r3
 801a1c8: f7f8 fa9e    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x7ac4
 801a1cc: 4603         	mov	r3, r0
 801a1ce: 461a         	mov	r2, r3
 801a1d0: 687b         	ldr	r3, [r7, #0x4]
 801a1d2: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 801a1d6: 687b         	ldr	r3, [r7, #0x4]
 801a1d8: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 801a1dc: 687b         	ldr	r3, [r7, #0x4]
 801a1de: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 		kf->temp_matrix1.numCols = kf->HT.numCols;
 801a1e2: 687b         	ldr	r3, [r7, #0x4]
 801a1e4: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 801a1e8: 687b         	ldr	r3, [r7, #0x4]
 801a1ea: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->HT,
 801a1ee: 687b         	ldr	r3, [r7, #0x4]
 801a1f0: f103 00a8    	add.w	r0, r3, #0xa8
 801a1f4: 687b         	ldr	r3, [r7, #0x4]
 801a1f6: f103 0180    	add.w	r1, r3, #0x80
 801a1fa: 687b         	ldr	r3, [r7, #0x4]
 801a1fc: 33b0         	adds	r3, #0xb0
 801a1fe: 461a         	mov	r2, r3
 801a200: f7f8 fa82    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x7afc
 801a204: 4603         	mov	r3, r0
 801a206: 461a         	mov	r2, r3
 801a208: 687b         	ldr	r3, [r7, #0x4]
 801a20a: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->S.numRows = kf->R.numRows;
 801a20e: 687b         	ldr	r3, [r7, #0x4]
 801a210: f8b3 2090    	ldrh.w	r2, [r3, #0x90]
 801a214: 687b         	ldr	r3, [r7, #0x4]
 801a216: f8a3 20a0    	strh.w	r2, [r3, #0xa0]
; 		kf->S.numCols = kf->R.numCols;
 801a21a: 687b         	ldr	r3, [r7, #0x4]
 801a21c: f8b3 2092    	ldrh.w	r2, [r3, #0x92]
 801a220: 687b         	ldr	r3, [r7, #0x4]
 801a222: f8a3 20a2    	strh.w	r2, [r3, #0xa2]
; 		kf->MatStatus = Matrix_Add(&kf->temp_matrix1, &kf->R, &kf->S); // S = H P'(k) HT + R
 801a226: 687b         	ldr	r3, [r7, #0x4]
 801a228: f103 00b0    	add.w	r0, r3, #0xb0
 801a22c: 687b         	ldr	r3, [r7, #0x4]
 801a22e: f103 0190    	add.w	r1, r3, #0x90
 801a232: 687b         	ldr	r3, [r7, #0x4]
 801a234: 33a0         	adds	r3, #0xa0
 801a236: 461a         	mov	r2, r3
 801a238: f7f8 f8ca    	bl	0x80123d0 <arm_mat_add_f32> @ imm = #-0x7e6c
 801a23c: 4603         	mov	r3, r0
 801a23e: 461a         	mov	r2, r3
 801a240: 687b         	ldr	r3, [r7, #0x4]
 801a242: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 			&kf->S, &kf->temp_matrix1); // temp_matrix1 = inv(H·P'(k)·HT + R)
 801a246: 687b         	ldr	r3, [r7, #0x4]
 801a248: f103 02a0    	add.w	r2, r3, #0xa0
; 		kf->MatStatus = Matrix_Inverse(
 801a24c: 687b         	ldr	r3, [r7, #0x4]
 801a24e: 33b0         	adds	r3, #0xb0
 801a250: 4619         	mov	r1, r3
 801a252: 4610         	mov	r0, r2
 801a254: f7f8 f8d6    	bl	0x8012404 <arm_mat_inverse_f32> @ imm = #-0x7e54
 801a258: 4603         	mov	r3, r0
 801a25a: 461a         	mov	r2, r3
 801a25c: 687b         	ldr	r3, [r7, #0x4]
 801a25e: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->Pminus.numRows;
 801a262: 687b         	ldr	r3, [r7, #0x4]
 801a264: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 801a268: 687b         	ldr	r3, [r7, #0x4]
 801a26a: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->HT.numCols;
 801a26e: 687b         	ldr	r3, [r7, #0x4]
 801a270: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 801a274: 687b         	ldr	r3, [r7, #0x4]
 801a276: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->Pminus, &kf->HT,
 801a27a: 687b         	ldr	r3, [r7, #0x4]
 801a27c: f103 0058    	add.w	r0, r3, #0x58
 801a280: 687b         	ldr	r3, [r7, #0x4]
 801a282: f103 0180    	add.w	r1, r3, #0x80
 801a286: 687b         	ldr	r3, [r7, #0x4]
 801a288: 33a8         	adds	r3, #0xa8
 801a28a: 461a         	mov	r2, r3
 801a28c: f7f8 fa3c    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x7b88
 801a290: 4603         	mov	r3, r0
 801a292: 461a         	mov	r2, r3
 801a294: 687b         	ldr	r3, [r7, #0x4]
 801a296: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->temp_matrix1, &kf->K);
 801a29a: 687b         	ldr	r3, [r7, #0x4]
 801a29c: f103 00a8    	add.w	r0, r3, #0xa8
 801a2a0: 687b         	ldr	r3, [r7, #0x4]
 801a2a2: f103 01b0    	add.w	r1, r3, #0xb0
 801a2a6: 687b         	ldr	r3, [r7, #0x4]
 801a2a8: 3398         	adds	r3, #0x98
 801a2aa: 461a         	mov	r2, r3
 801a2ac: f7f8 fa2c    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x7ba8
 801a2b0: 4603         	mov	r3, r0
 801a2b2: 461a         	mov	r2, r3
 801a2b4: 687b         	ldr	r3, [r7, #0x4]
 801a2b6: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801a2ba: bf00         	nop
 801a2bc: 3708         	adds	r7, #0x8
 801a2be: 46bd         	mov	sp, r7
 801a2c0: bd80         	pop	{r7, pc}

0801a2c2 <Kalman_Filter_xhatUpdate>:
; {
 801a2c2: b580         	push	{r7, lr}
 801a2c4: b082         	sub	sp, #0x8
 801a2c6: af00         	add	r7, sp, #0x0
 801a2c8: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq4) {
 801a2ca: 687b         	ldr	r3, [r7, #0x4]
 801a2cc: f893 302b    	ldrb.w	r3, [r3, #0x2b]
 801a2d0: 2b00         	cmp	r3, #0x0
 801a2d2: d15d         	bne	0x801a390 <Kalman_Filter_xhatUpdate+0xce> @ imm = #0xba
; 		kf->temp_vector.numRows = kf->H.numRows;
 801a2d4: 687b         	ldr	r3, [r7, #0x4]
 801a2d6: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 801a2da: 687b         	ldr	r3, [r7, #0x4]
 801a2dc: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 		kf->temp_vector.numCols = 1;
 801a2e0: 687b         	ldr	r3, [r7, #0x4]
 801a2e2: 2201         	movs	r2, #0x1
 801a2e4: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 		kf->MatStatus = Matrix_Multiply(&kf->H, &kf->xhatminus,
 801a2e8: 687b         	ldr	r3, [r7, #0x4]
 801a2ea: f103 0078    	add.w	r0, r3, #0x78
 801a2ee: 687b         	ldr	r3, [r7, #0x4]
 801a2f0: f103 0138    	add.w	r1, r3, #0x38
 801a2f4: 687b         	ldr	r3, [r7, #0x4]
 801a2f6: 33b8         	adds	r3, #0xb8
 801a2f8: 461a         	mov	r2, r3
 801a2fa: f7f8 fa05    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x7bf6
 801a2fe: 4603         	mov	r3, r0
 801a300: 461a         	mov	r2, r3
 801a302: 687b         	ldr	r3, [r7, #0x4]
 801a304: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_vector1.numRows = kf->z.numRows;
 801a308: 687b         	ldr	r3, [r7, #0x4]
 801a30a: f8b3 2048    	ldrh.w	r2, [r3, #0x48]
 801a30e: 687b         	ldr	r3, [r7, #0x4]
 801a310: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 		kf->temp_vector1.numCols = 1;
 801a314: 687b         	ldr	r3, [r7, #0x4]
 801a316: 2201         	movs	r2, #0x1
 801a318: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 			Matrix_Subtract(&kf->z, &kf->temp_vector,
 801a31c: 687b         	ldr	r3, [r7, #0x4]
 801a31e: f103 0048    	add.w	r0, r3, #0x48
 801a322: 687b         	ldr	r3, [r7, #0x4]
 801a324: f103 01b8    	add.w	r1, r3, #0xb8
 801a328: 687b         	ldr	r3, [r7, #0x4]
 801a32a: 33c0         	adds	r3, #0xc0
 801a32c: 461a         	mov	r2, r3
 801a32e: f7f8 fa45    	bl	0x80127bc <arm_mat_sub_f32> @ imm = #-0x7b76
 801a332: 4603         	mov	r3, r0
 801a334: 461a         	mov	r2, r3
; 		kf->MatStatus =
 801a336: 687b         	ldr	r3, [r7, #0x4]
 801a338: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_vector.numRows = kf->K.numRows;
 801a33c: 687b         	ldr	r3, [r7, #0x4]
 801a33e: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 801a342: 687b         	ldr	r3, [r7, #0x4]
 801a344: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 		kf->temp_vector.numCols = 1;
 801a348: 687b         	ldr	r3, [r7, #0x4]
 801a34a: 2201         	movs	r2, #0x1
 801a34c: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 			Matrix_Multiply(&kf->K, &kf->temp_vector1,
 801a350: 687b         	ldr	r3, [r7, #0x4]
 801a352: f103 0098    	add.w	r0, r3, #0x98
 801a356: 687b         	ldr	r3, [r7, #0x4]
 801a358: f103 01c0    	add.w	r1, r3, #0xc0
 801a35c: 687b         	ldr	r3, [r7, #0x4]
 801a35e: 33b8         	adds	r3, #0xb8
 801a360: 461a         	mov	r2, r3
 801a362: f7f8 f9d1    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x7c5e
 801a366: 4603         	mov	r3, r0
 801a368: 461a         	mov	r2, r3
; 		kf->MatStatus =
 801a36a: 687b         	ldr	r3, [r7, #0x4]
 801a36c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Add(&kf->xhatminus, &kf->temp_vector, &kf->xhat);
 801a370: 687b         	ldr	r3, [r7, #0x4]
 801a372: f103 0038    	add.w	r0, r3, #0x38
 801a376: 687b         	ldr	r3, [r7, #0x4]
 801a378: f103 01b8    	add.w	r1, r3, #0xb8
 801a37c: 687b         	ldr	r3, [r7, #0x4]
 801a37e: 3330         	adds	r3, #0x30
 801a380: 461a         	mov	r2, r3
 801a382: f7f8 f825    	bl	0x80123d0 <arm_mat_add_f32> @ imm = #-0x7fb6
 801a386: 4603         	mov	r3, r0
 801a388: 461a         	mov	r2, r3
 801a38a: 687b         	ldr	r3, [r7, #0x4]
 801a38c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801a390: bf00         	nop
 801a392: 3708         	adds	r7, #0x8
 801a394: 46bd         	mov	sp, r7
 801a396: bd80         	pop	{r7, pc}

0801a398 <Kalman_Filter_P_Update>:
; {
 801a398: b580         	push	{r7, lr}
 801a39a: b082         	sub	sp, #0x8
 801a39c: af00         	add	r7, sp, #0x0
 801a39e: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq5) {
 801a3a0: 687b         	ldr	r3, [r7, #0x4]
 801a3a2: f893 302c    	ldrb.w	r3, [r3, #0x2c]
 801a3a6: 2b00         	cmp	r3, #0x0
 801a3a8: d147         	bne	0x801a43a <Kalman_Filter_P_Update+0xa2> @ imm = #0x8e
; 		kf->temp_matrix.numRows = kf->K.numRows;
 801a3aa: 687b         	ldr	r3, [r7, #0x4]
 801a3ac: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 801a3b0: 687b         	ldr	r3, [r7, #0x4]
 801a3b2: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->H.numCols;
 801a3b6: 687b         	ldr	r3, [r7, #0x4]
 801a3b8: f8b3 207a    	ldrh.w	r2, [r3, #0x7a]
 801a3bc: 687b         	ldr	r3, [r7, #0x4]
 801a3be: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 801a3c2: 687b         	ldr	r3, [r7, #0x4]
 801a3c4: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 801a3c8: 687b         	ldr	r3, [r7, #0x4]
 801a3ca: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 		kf->temp_matrix1.numCols = kf->Pminus.numCols;
 801a3ce: 687b         	ldr	r3, [r7, #0x4]
 801a3d0: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 801a3d4: 687b         	ldr	r3, [r7, #0x4]
 801a3d6: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 			Matrix_Multiply(&kf->K, &kf->H, &kf->temp_matrix); // temp_matrix = K(k)·H
 801a3da: 687b         	ldr	r3, [r7, #0x4]
 801a3dc: f103 0098    	add.w	r0, r3, #0x98
 801a3e0: 687b         	ldr	r3, [r7, #0x4]
 801a3e2: f103 0178    	add.w	r1, r3, #0x78
 801a3e6: 687b         	ldr	r3, [r7, #0x4]
 801a3e8: 33a8         	adds	r3, #0xa8
 801a3ea: 461a         	mov	r2, r3
 801a3ec: f7f8 f98c    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x7ce8
 801a3f0: 4603         	mov	r3, r0
 801a3f2: 461a         	mov	r2, r3
; 		kf->MatStatus =
 801a3f4: 687b         	ldr	r3, [r7, #0x4]
 801a3f6: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->Pminus,
 801a3fa: 687b         	ldr	r3, [r7, #0x4]
 801a3fc: f103 00a8    	add.w	r0, r3, #0xa8
 801a400: 687b         	ldr	r3, [r7, #0x4]
 801a402: f103 0158    	add.w	r1, r3, #0x58
 801a406: 687b         	ldr	r3, [r7, #0x4]
 801a408: 33b0         	adds	r3, #0xb0
 801a40a: 461a         	mov	r2, r3
 801a40c: f7f8 f97c    	bl	0x8012708 <arm_mat_mult_f32> @ imm = #-0x7d08
 801a410: 4603         	mov	r3, r0
 801a412: 461a         	mov	r2, r3
 801a414: 687b         	ldr	r3, [r7, #0x4]
 801a416: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Subtract(&kf->Pminus, &kf->temp_matrix1, &kf->P);
 801a41a: 687b         	ldr	r3, [r7, #0x4]
 801a41c: f103 0058    	add.w	r0, r3, #0x58
 801a420: 687b         	ldr	r3, [r7, #0x4]
 801a422: f103 01b0    	add.w	r1, r3, #0xb0
 801a426: 687b         	ldr	r3, [r7, #0x4]
 801a428: 3350         	adds	r3, #0x50
 801a42a: 461a         	mov	r2, r3
 801a42c: f7f8 f9c6    	bl	0x80127bc <arm_mat_sub_f32> @ imm = #-0x7c74
 801a430: 4603         	mov	r3, r0
 801a432: 461a         	mov	r2, r3
 801a434: 687b         	ldr	r3, [r7, #0x4]
 801a436: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801a43a: bf00         	nop
 801a43c: 3708         	adds	r7, #0x8
 801a43e: 46bd         	mov	sp, r7
 801a440: bd80         	pop	{r7, pc}

0801a442 <Norm3d>:
; {
 801a442: b580         	push	{r7, lr}
 801a444: b084         	sub	sp, #0x10
 801a446: af00         	add	r7, sp, #0x0
 801a448: 6078         	str	r0, [r7, #0x4]
; 	float len = Sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
 801a44a: 687b         	ldr	r3, [r7, #0x4]
 801a44c: ed93 7a00    	vldr	s14, [r3]
 801a450: 687b         	ldr	r3, [r7, #0x4]
 801a452: edd3 7a00    	vldr	s15, [r3]
 801a456: ee27 7a27    	vmul.f32	s14, s14, s15
 801a45a: 687b         	ldr	r3, [r7, #0x4]
 801a45c: 3304         	adds	r3, #0x4
 801a45e: edd3 6a00    	vldr	s13, [r3]
 801a462: 687b         	ldr	r3, [r7, #0x4]
 801a464: 3304         	adds	r3, #0x4
 801a466: edd3 7a00    	vldr	s15, [r3]
 801a46a: ee66 7aa7    	vmul.f32	s15, s13, s15
 801a46e: ee37 7a27    	vadd.f32	s14, s14, s15
 801a472: 687b         	ldr	r3, [r7, #0x4]
 801a474: 3308         	adds	r3, #0x8
 801a476: edd3 6a00    	vldr	s13, [r3]
 801a47a: 687b         	ldr	r3, [r7, #0x4]
 801a47c: 3308         	adds	r3, #0x8
 801a47e: edd3 7a00    	vldr	s15, [r3]
 801a482: ee66 7aa7    	vmul.f32	s15, s13, s15
 801a486: ee77 7a27    	vadd.f32	s15, s14, s15
 801a48a: eeb0 0a67    	vmov.f32	s0, s15
 801a48e: f7e8 fc8b    	bl	0x8002da8 <Sqrt>        @ imm = #-0x176ea
 801a492: ed87 0a03    	vstr	s0, [r7, #12]
; 	v[0] /= len;
 801a496: 687b         	ldr	r3, [r7, #0x4]
 801a498: edd3 6a00    	vldr	s13, [r3]
 801a49c: ed97 7a03    	vldr	s14, [r7, #12]
 801a4a0: eec6 7a87    	vdiv.f32	s15, s13, s14
 801a4a4: 687b         	ldr	r3, [r7, #0x4]
 801a4a6: edc3 7a00    	vstr	s15, [r3]
; 	v[1] /= len;
 801a4aa: 687b         	ldr	r3, [r7, #0x4]
 801a4ac: 3304         	adds	r3, #0x4
 801a4ae: edd3 6a00    	vldr	s13, [r3]
 801a4b2: 687b         	ldr	r3, [r7, #0x4]
 801a4b4: 3304         	adds	r3, #0x4
 801a4b6: ed97 7a03    	vldr	s14, [r7, #12]
 801a4ba: eec6 7a87    	vdiv.f32	s15, s13, s14
 801a4be: edc3 7a00    	vstr	s15, [r3]
; 	v[2] /= len;
 801a4c2: 687b         	ldr	r3, [r7, #0x4]
 801a4c4: 3308         	adds	r3, #0x8
 801a4c6: edd3 6a00    	vldr	s13, [r3]
 801a4ca: 687b         	ldr	r3, [r7, #0x4]
 801a4cc: 3308         	adds	r3, #0x8
 801a4ce: ed97 7a03    	vldr	s14, [r7, #12]
 801a4d2: eec6 7a87    	vdiv.f32	s15, s13, s14
 801a4d6: edc3 7a00    	vstr	s15, [r3]
; 	return v;
 801a4da: 687b         	ldr	r3, [r7, #0x4]
; }
 801a4dc: 4618         	mov	r0, r3
 801a4de: 3710         	adds	r7, #0x10
 801a4e0: 46bd         	mov	sp, r7
 801a4e2: bd80         	pop	{r7, pc}

0801a4e4 <Cross3d>:
; {
 801a4e4: b480         	push	{r7}
 801a4e6: b085         	sub	sp, #0x14
 801a4e8: af00         	add	r7, sp, #0x0
 801a4ea: 60f8         	str	r0, [r7, #0xc]
 801a4ec: 60b9         	str	r1, [r7, #0x8]
 801a4ee: 607a         	str	r2, [r7, #0x4]
; 	res[0] = v1[1] * v2[2] - v1[2] * v2[1];
 801a4f0: 68fb         	ldr	r3, [r7, #0xc]
 801a4f2: 3304         	adds	r3, #0x4
 801a4f4: ed93 7a00    	vldr	s14, [r3]
 801a4f8: 68bb         	ldr	r3, [r7, #0x8]
 801a4fa: 3308         	adds	r3, #0x8
 801a4fc: edd3 7a00    	vldr	s15, [r3]
 801a500: ee27 7a27    	vmul.f32	s14, s14, s15
 801a504: 68fb         	ldr	r3, [r7, #0xc]
 801a506: 3308         	adds	r3, #0x8
 801a508: edd3 6a00    	vldr	s13, [r3]
 801a50c: 68bb         	ldr	r3, [r7, #0x8]
 801a50e: 3304         	adds	r3, #0x4
 801a510: edd3 7a00    	vldr	s15, [r3]
 801a514: ee66 7aa7    	vmul.f32	s15, s13, s15
 801a518: ee77 7a67    	vsub.f32	s15, s14, s15
 801a51c: 687b         	ldr	r3, [r7, #0x4]
 801a51e: edc3 7a00    	vstr	s15, [r3]
; 	res[1] = v1[2] * v2[0] - v1[0] * v2[2];
 801a522: 68fb         	ldr	r3, [r7, #0xc]
 801a524: 3308         	adds	r3, #0x8
 801a526: ed93 7a00    	vldr	s14, [r3]
 801a52a: 68bb         	ldr	r3, [r7, #0x8]
 801a52c: edd3 7a00    	vldr	s15, [r3]
 801a530: ee27 7a27    	vmul.f32	s14, s14, s15
 801a534: 68fb         	ldr	r3, [r7, #0xc]
 801a536: edd3 6a00    	vldr	s13, [r3]
 801a53a: 68bb         	ldr	r3, [r7, #0x8]
 801a53c: 3308         	adds	r3, #0x8
 801a53e: edd3 7a00    	vldr	s15, [r3]
 801a542: ee66 7aa7    	vmul.f32	s15, s13, s15
 801a546: 687b         	ldr	r3, [r7, #0x4]
 801a548: 3304         	adds	r3, #0x4
 801a54a: ee77 7a67    	vsub.f32	s15, s14, s15
 801a54e: edc3 7a00    	vstr	s15, [r3]
; 	res[2] = v1[0] * v2[1] - v1[1] * v2[0];
 801a552: 68fb         	ldr	r3, [r7, #0xc]
 801a554: ed93 7a00    	vldr	s14, [r3]
 801a558: 68bb         	ldr	r3, [r7, #0x8]
 801a55a: 3304         	adds	r3, #0x4
 801a55c: edd3 7a00    	vldr	s15, [r3]
 801a560: ee27 7a27    	vmul.f32	s14, s14, s15
 801a564: 68fb         	ldr	r3, [r7, #0xc]
 801a566: 3304         	adds	r3, #0x4
 801a568: edd3 6a00    	vldr	s13, [r3]
 801a56c: 68bb         	ldr	r3, [r7, #0x8]
 801a56e: edd3 7a00    	vldr	s15, [r3]
 801a572: ee66 7aa7    	vmul.f32	s15, s13, s15
 801a576: 687b         	ldr	r3, [r7, #0x4]
 801a578: 3308         	adds	r3, #0x8
 801a57a: ee77 7a67    	vsub.f32	s15, s14, s15
 801a57e: edc3 7a00    	vstr	s15, [r3]
; }
 801a582: bf00         	nop
 801a584: 3714         	adds	r7, #0x14
 801a586: 46bd         	mov	sp, r7
 801a588: f85d 7b04    	ldr	r7, [sp], #4
 801a58c: 4770         	bx	lr

0801a58e <Dot3d>:
; {
 801a58e: b480         	push	{r7}
 801a590: b083         	sub	sp, #0xc
 801a592: af00         	add	r7, sp, #0x0
 801a594: 6078         	str	r0, [r7, #0x4]
 801a596: 6039         	str	r1, [r7]
; 	return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
 801a598: 687b         	ldr	r3, [r7, #0x4]
 801a59a: ed93 7a00    	vldr	s14, [r3]
 801a59e: 683b         	ldr	r3, [r7]
 801a5a0: edd3 7a00    	vldr	s15, [r3]
 801a5a4: ee27 7a27    	vmul.f32	s14, s14, s15
 801a5a8: 687b         	ldr	r3, [r7, #0x4]
 801a5aa: 3304         	adds	r3, #0x4
 801a5ac: edd3 6a00    	vldr	s13, [r3]
 801a5b0: 683b         	ldr	r3, [r7]
 801a5b2: 3304         	adds	r3, #0x4
 801a5b4: edd3 7a00    	vldr	s15, [r3]
 801a5b8: ee66 7aa7    	vmul.f32	s15, s13, s15
 801a5bc: ee37 7a27    	vadd.f32	s14, s14, s15
 801a5c0: 687b         	ldr	r3, [r7, #0x4]
 801a5c2: 3308         	adds	r3, #0x8
 801a5c4: edd3 6a00    	vldr	s13, [r3]
 801a5c8: 683b         	ldr	r3, [r7]
 801a5ca: 3308         	adds	r3, #0x8
 801a5cc: edd3 7a00    	vldr	s15, [r3]
 801a5d0: ee66 7aa7    	vmul.f32	s15, s13, s15
 801a5d4: ee77 7a27    	vadd.f32	s15, s14, s15
; }
 801a5d8: eeb0 0a67    	vmov.f32	s0, s15
 801a5dc: 370c         	adds	r7, #0xc
 801a5de: 46bd         	mov	sp, r7
 801a5e0: f85d 7b04    	ldr	r7, [sp], #4
 801a5e4: 4770         	bx	lr

0801a5e6 <z_impl_uart_tx>:
; {
 801a5e6: b590         	push	{r4, r7, lr}
 801a5e8: b087         	sub	sp, #0x1c
 801a5ea: af00         	add	r7, sp, #0x0
 801a5ec: 60f8         	str	r0, [r7, #0xc]
 801a5ee: 60b9         	str	r1, [r7, #0x8]
 801a5f0: 607a         	str	r2, [r7, #0x4]
 801a5f2: 603b         	str	r3, [r7]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 801a5f4: 68fb         	ldr	r3, [r7, #0xc]
 801a5f6: 689b         	ldr	r3, [r3, #0x8]
 801a5f8: 617b         	str	r3, [r7, #0x14]
; 	return api->tx(dev, buf, len, timeout);
 801a5fa: 697b         	ldr	r3, [r7, #0x14]
 801a5fc: 685c         	ldr	r4, [r3, #0x4]
 801a5fe: 683b         	ldr	r3, [r7]
 801a600: 687a         	ldr	r2, [r7, #0x4]
 801a602: 68b9         	ldr	r1, [r7, #0x8]
 801a604: 68f8         	ldr	r0, [r7, #0xc]
 801a606: 47a0         	blx	r4
 801a608: 4603         	mov	r3, r0
; }
 801a60a: 4618         	mov	r0, r3
 801a60c: 371c         	adds	r7, #0x1c
 801a60e: 46bd         	mov	sp, r7
 801a610: bd90         	pop	{r4, r7, pc}

0801a612 <uart_tx>:
; {
 801a612: b580         	push	{r7, lr}
 801a614: b084         	sub	sp, #0x10
 801a616: af00         	add	r7, sp, #0x0
 801a618: 60f8         	str	r0, [r7, #0xc]
 801a61a: 60b9         	str	r1, [r7, #0x8]
 801a61c: 607a         	str	r2, [r7, #0x4]
 801a61e: 603b         	str	r3, [r7]
; 	return z_impl_uart_tx(dev, buf, len, timeout);
 801a620: 683b         	ldr	r3, [r7]
 801a622: 687a         	ldr	r2, [r7, #0x4]
 801a624: 68b9         	ldr	r1, [r7, #0x8]
 801a626: 68f8         	ldr	r0, [r7, #0xc]
 801a628: f7ff ffdd    	bl	0x801a5e6 <z_impl_uart_tx> @ imm = #-0x46
 801a62c: 4603         	mov	r3, r0
; }
 801a62e: 4618         	mov	r0, r3
 801a630: 3710         	adds	r7, #0x10
 801a632: 46bd         	mov	sp, r7
 801a634: bd80         	pop	{r7, pc}

0801a636 <z_impl_chassis_set_speed>:
; {
 801a636: b580         	push	{r7, lr}
 801a638: b086         	sub	sp, #0x18
 801a63a: af00         	add	r7, sp, #0x0
 801a63c: 60f8         	str	r0, [r7, #0xc]
 801a63e: ed87 0a02    	vstr	s0, [r7, #8]
 801a642: edc7 0a01    	vstr	s1, [r7, #4]
; 	const struct chassis_driver_api *api = (const struct chassis_driver_api *)dev->api;
 801a646: 68fb         	ldr	r3, [r7, #0xc]
 801a648: 689b         	ldr	r3, [r3, #0x8]
 801a64a: 617b         	str	r3, [r7, #0x14]
; 	if (api->set_speed != NULL) {
 801a64c: 697b         	ldr	r3, [r7, #0x14]
 801a64e: 681b         	ldr	r3, [r3]
 801a650: 2b00         	cmp	r3, #0x0
 801a652: d007         	beq	0x801a664 <z_impl_chassis_set_speed+0x2e> @ imm = #0xe
; 		api->set_speed(dev, speedX, speedY);
 801a654: 697b         	ldr	r3, [r7, #0x14]
 801a656: 681b         	ldr	r3, [r3]
 801a658: edd7 0a01    	vldr	s1, [r7, #4]
 801a65c: ed97 0a02    	vldr	s0, [r7, #8]
 801a660: 68f8         	ldr	r0, [r7, #0xc]
 801a662: 4798         	blx	r3
; }
 801a664: bf00         	nop
 801a666: 3718         	adds	r7, #0x18
 801a668: 46bd         	mov	sp, r7
 801a66a: bd80         	pop	{r7, pc}

0801a66c <z_impl_chassis_set_angle>:
; {
 801a66c: b580         	push	{r7, lr}
 801a66e: b084         	sub	sp, #0x10
 801a670: af00         	add	r7, sp, #0x0
 801a672: 6078         	str	r0, [r7, #0x4]
 801a674: ed87 0a00    	vstr	s0, [r7]
; 	const struct chassis_driver_api *api = (const struct chassis_driver_api *)dev->api;
 801a678: 687b         	ldr	r3, [r7, #0x4]
 801a67a: 689b         	ldr	r3, [r3, #0x8]
 801a67c: 60fb         	str	r3, [r7, #0xc]
; 	if (api->set_angle != NULL) {
 801a67e: 68fb         	ldr	r3, [r7, #0xc]
 801a680: 685b         	ldr	r3, [r3, #0x4]
 801a682: 2b00         	cmp	r3, #0x0
 801a684: d005         	beq	0x801a692 <z_impl_chassis_set_angle+0x26> @ imm = #0xa
; 		api->set_angle(dev, angle);
 801a686: 68fb         	ldr	r3, [r7, #0xc]
 801a688: 685b         	ldr	r3, [r3, #0x4]
 801a68a: ed97 0a00    	vldr	s0, [r7]
 801a68e: 6878         	ldr	r0, [r7, #0x4]
 801a690: 4798         	blx	r3
; }
 801a692: bf00         	nop
 801a694: 3710         	adds	r7, #0x10
 801a696: 46bd         	mov	sp, r7
 801a698: bd80         	pop	{r7, pc}

0801a69a <z_impl_chassis_set_gyro>:
; {
 801a69a: b580         	push	{r7, lr}
 801a69c: b084         	sub	sp, #0x10
 801a69e: af00         	add	r7, sp, #0x0
 801a6a0: 6078         	str	r0, [r7, #0x4]
 801a6a2: ed87 0a00    	vstr	s0, [r7]
; 	const struct chassis_driver_api *api = (const struct chassis_driver_api *)dev->api;
 801a6a6: 687b         	ldr	r3, [r7, #0x4]
 801a6a8: 689b         	ldr	r3, [r3, #0x8]
 801a6aa: 60fb         	str	r3, [r7, #0xc]
; 	if (api->set_gyro != NULL) {
 801a6ac: 68fb         	ldr	r3, [r7, #0xc]
 801a6ae: 689b         	ldr	r3, [r3, #0x8]
 801a6b0: 2b00         	cmp	r3, #0x0
 801a6b2: d005         	beq	0x801a6c0 <z_impl_chassis_set_gyro+0x26> @ imm = #0xa
; 		api->set_gyro(dev, gyro);
 801a6b4: 68fb         	ldr	r3, [r7, #0xc]
 801a6b6: 689b         	ldr	r3, [r3, #0x8]
 801a6b8: ed97 0a00    	vldr	s0, [r7]
 801a6bc: 6878         	ldr	r0, [r7, #0x4]
 801a6be: 4798         	blx	r3
; }
 801a6c0: bf00         	nop
 801a6c2: 3710         	adds	r7, #0x10
 801a6c4: 46bd         	mov	sp, r7
 801a6c6: bd80         	pop	{r7, pc}

0801a6c8 <chassis_set_sensor_zbus>:
; {
 801a6c8: b480         	push	{r7}
 801a6ca: b085         	sub	sp, #0x14
 801a6cc: af00         	add	r7, sp, #0x0
 801a6ce: 6078         	str	r0, [r7, #0x4]
 801a6d0: 6039         	str	r1, [r7]
; 	chassis_data_t *data = dev->data;
 801a6d2: 687b         	ldr	r3, [r7, #0x4]
 801a6d4: 691b         	ldr	r3, [r3, #0x10]
 801a6d6: 60fb         	str	r3, [r7, #0xc]
; 	data->chassis_sensor_zbus = (struct zbus_channel *)chan;
 801a6d8: 68fb         	ldr	r3, [r7, #0xc]
 801a6da: 683a         	ldr	r2, [r7]
 801a6dc: 665a         	str	r2, [r3, #0x64]
; }
 801a6de: bf00         	nop
 801a6e0: 3714         	adds	r7, #0x14
 801a6e2: 46bd         	mov	sp, r7
 801a6e4: f85d 7b04    	ldr	r7, [sp], #4
 801a6e8: 4770         	bx	lr

0801a6ea <chassis_set_speed>:
; {
 801a6ea: b580         	push	{r7, lr}
 801a6ec: b084         	sub	sp, #0x10
 801a6ee: af00         	add	r7, sp, #0x0
 801a6f0: 60f8         	str	r0, [r7, #0xc]
 801a6f2: ed87 0a02    	vstr	s0, [r7, #8]
 801a6f6: edc7 0a01    	vstr	s1, [r7, #4]
; 	z_impl_chassis_set_speed(dev, speedX, speedY);
 801a6fa: edd7 0a01    	vldr	s1, [r7, #4]
 801a6fe: ed97 0a02    	vldr	s0, [r7, #8]
 801a702: 68f8         	ldr	r0, [r7, #0xc]
 801a704: f7ff ff97    	bl	0x801a636 <z_impl_chassis_set_speed> @ imm = #-0xd2
; }
 801a708: bf00         	nop
 801a70a: 3710         	adds	r7, #0x10
 801a70c: 46bd         	mov	sp, r7
 801a70e: bd80         	pop	{r7, pc}

0801a710 <chassis_set_angle>:
; {
 801a710: b580         	push	{r7, lr}
 801a712: b082         	sub	sp, #0x8
 801a714: af00         	add	r7, sp, #0x0
 801a716: 6078         	str	r0, [r7, #0x4]
 801a718: ed87 0a00    	vstr	s0, [r7]
; 	z_impl_chassis_set_angle(dev, angle);
 801a71c: ed97 0a00    	vldr	s0, [r7]
 801a720: 6878         	ldr	r0, [r7, #0x4]
 801a722: f7ff ffa3    	bl	0x801a66c <z_impl_chassis_set_angle> @ imm = #-0xba
; }
 801a726: bf00         	nop
 801a728: 3708         	adds	r7, #0x8
 801a72a: 46bd         	mov	sp, r7
 801a72c: bd80         	pop	{r7, pc}

0801a72e <chassis_set_gyro>:
; {
 801a72e: b580         	push	{r7, lr}
 801a730: b082         	sub	sp, #0x8
 801a732: af00         	add	r7, sp, #0x0
 801a734: 6078         	str	r0, [r7, #0x4]
 801a736: ed87 0a00    	vstr	s0, [r7]
; 	z_impl_chassis_set_gyro(dev, gyro);
 801a73a: ed97 0a00    	vldr	s0, [r7]
 801a73e: 6878         	ldr	r0, [r7, #0x4]
 801a740: f7ff ffab    	bl	0x801a69a <z_impl_chassis_set_gyro> @ imm = #-0xaa
; }
 801a744: bf00         	nop
 801a746: 3708         	adds	r7, #0x8
 801a748: 46bd         	mov	sp, r7
 801a74a: bd80         	pop	{r7, pc}

0801a74c <big_heap_chunks>:
; {
 801a74c: b480         	push	{r7}
 801a74e: b083         	sub	sp, #0xc
 801a750: af00         	add	r7, sp, #0x0
 801a752: 6078         	str	r0, [r7, #0x4]
; 		return false;
 801a754: 2300         	movs	r3, #0x0
; }
 801a756: 4618         	mov	r0, r3
 801a758: 370c         	adds	r7, #0xc
 801a75a: 46bd         	mov	sp, r7
 801a75c: f85d 7b04    	ldr	r7, [sp], #4
 801a760: 4770         	bx	lr

0801a762 <big_heap_bytes>:
; {
 801a762: b580         	push	{r7, lr}
 801a764: b082         	sub	sp, #0x8
 801a766: af00         	add	r7, sp, #0x0
 801a768: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(bytes / CHUNK_UNIT);
 801a76a: 687b         	ldr	r3, [r7, #0x4]
 801a76c: 08db         	lsrs	r3, r3, #0x3
 801a76e: 4618         	mov	r0, r3
 801a770: f7ff ffec    	bl	0x801a74c <big_heap_chunks> @ imm = #-0x28
 801a774: 4603         	mov	r3, r0
; }
 801a776: 4618         	mov	r0, r3
 801a778: 3708         	adds	r7, #0x8
 801a77a: 46bd         	mov	sp, r7
 801a77c: bd80         	pop	{r7, pc}

0801a77e <big_heap>:
; {
 801a77e: b580         	push	{r7, lr}
 801a780: b082         	sub	sp, #0x8
 801a782: af00         	add	r7, sp, #0x0
 801a784: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(h->end_chunk);
 801a786: 687b         	ldr	r3, [r7, #0x4]
 801a788: 689b         	ldr	r3, [r3, #0x8]
 801a78a: 4618         	mov	r0, r3
 801a78c: f7ff ffde    	bl	0x801a74c <big_heap_chunks> @ imm = #-0x44
 801a790: 4603         	mov	r3, r0
; }
 801a792: 4618         	mov	r0, r3
 801a794: 3708         	adds	r7, #0x8
 801a796: 46bd         	mov	sp, r7
 801a798: bd80         	pop	{r7, pc}

0801a79a <chunk_buf>:
; {
 801a79a: b480         	push	{r7}
 801a79c: b083         	sub	sp, #0xc
 801a79e: af00         	add	r7, sp, #0x0
 801a7a0: 6078         	str	r0, [r7, #0x4]
; 	return (chunk_unit_t *)h;
 801a7a2: 687b         	ldr	r3, [r7, #0x4]
; }
 801a7a4: 4618         	mov	r0, r3
 801a7a6: 370c         	adds	r7, #0xc
 801a7a8: 46bd         	mov	sp, r7
 801a7aa: f85d 7b04    	ldr	r7, [sp], #4
 801a7ae: 4770         	bx	lr

0801a7b0 <chunk_field>:
; {
 801a7b0: b580         	push	{r7, lr}
 801a7b2: b086         	sub	sp, #0x18
 801a7b4: af00         	add	r7, sp, #0x0
 801a7b6: 60f8         	str	r0, [r7, #0xc]
 801a7b8: 60b9         	str	r1, [r7, #0x8]
 801a7ba: 4613         	mov	r3, r2
 801a7bc: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 801a7be: 68f8         	ldr	r0, [r7, #0xc]
 801a7c0: f7ff ffeb    	bl	0x801a79a <chunk_buf>   @ imm = #-0x2a
 801a7c4: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 801a7c6: 68bb         	ldr	r3, [r7, #0x8]
 801a7c8: 00db         	lsls	r3, r3, #0x3
 801a7ca: 697a         	ldr	r2, [r7, #0x14]
 801a7cc: 4413         	add	r3, r2
 801a7ce: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 801a7d0: 68f8         	ldr	r0, [r7, #0xc]
 801a7d2: f7ff ffd4    	bl	0x801a77e <big_heap>    @ imm = #-0x58
 801a7d6: 4603         	mov	r3, r0
 801a7d8: 2b00         	cmp	r3, #0x0
 801a7da: d005         	beq	0x801a7e8 <chunk_field+0x38> @ imm = #0xa
; 		return ((uint32_t *)cmem)[f];
 801a7dc: 79fb         	ldrb	r3, [r7, #0x7]
 801a7de: 009b         	lsls	r3, r3, #0x2
 801a7e0: 693a         	ldr	r2, [r7, #0x10]
 801a7e2: 4413         	add	r3, r2
 801a7e4: 681b         	ldr	r3, [r3]
 801a7e6: e004         	b	0x801a7f2 <chunk_field+0x42> @ imm = #0x8
; 		return ((uint16_t *)cmem)[f];
 801a7e8: 79fb         	ldrb	r3, [r7, #0x7]
 801a7ea: 005b         	lsls	r3, r3, #0x1
 801a7ec: 693a         	ldr	r2, [r7, #0x10]
 801a7ee: 4413         	add	r3, r2
 801a7f0: 881b         	ldrh	r3, [r3]
; }
 801a7f2: 4618         	mov	r0, r3
 801a7f4: 3718         	adds	r7, #0x18
 801a7f6: 46bd         	mov	sp, r7
 801a7f8: bd80         	pop	{r7, pc}

0801a7fa <chunk_set>:
; {
 801a7fa: b580         	push	{r7, lr}
 801a7fc: b086         	sub	sp, #0x18
 801a7fe: af00         	add	r7, sp, #0x0
 801a800: 60f8         	str	r0, [r7, #0xc]
 801a802: 60b9         	str	r1, [r7, #0x8]
 801a804: 603b         	str	r3, [r7]
 801a806: 4613         	mov	r3, r2
 801a808: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 801a80a: 68f8         	ldr	r0, [r7, #0xc]
 801a80c: f7ff ffc5    	bl	0x801a79a <chunk_buf>   @ imm = #-0x76
 801a810: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 801a812: 68bb         	ldr	r3, [r7, #0x8]
 801a814: 00db         	lsls	r3, r3, #0x3
 801a816: 697a         	ldr	r2, [r7, #0x14]
 801a818: 4413         	add	r3, r2
 801a81a: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 801a81c: 68f8         	ldr	r0, [r7, #0xc]
 801a81e: f7ff ffae    	bl	0x801a77e <big_heap>    @ imm = #-0xa4
 801a822: 4603         	mov	r3, r0
 801a824: 2b00         	cmp	r3, #0x0
 801a826: d006         	beq	0x801a836 <chunk_set+0x3c> @ imm = #0xc
; 		((uint32_t *)cmem)[f] = val;
 801a828: 79fb         	ldrb	r3, [r7, #0x7]
 801a82a: 009b         	lsls	r3, r3, #0x2
 801a82c: 693a         	ldr	r2, [r7, #0x10]
 801a82e: 4413         	add	r3, r2
 801a830: 683a         	ldr	r2, [r7]
 801a832: 601a         	str	r2, [r3]
; }
 801a834: e006         	b	0x801a844 <chunk_set+0x4a> @ imm = #0xc
; 		((uint16_t *)cmem)[f] = val;
 801a836: 79fb         	ldrb	r3, [r7, #0x7]
 801a838: 005b         	lsls	r3, r3, #0x1
 801a83a: 693a         	ldr	r2, [r7, #0x10]
 801a83c: 4413         	add	r3, r2
 801a83e: 683a         	ldr	r2, [r7]
 801a840: b292         	uxth	r2, r2
 801a842: 801a         	strh	r2, [r3]
; }
 801a844: bf00         	nop
 801a846: 3718         	adds	r7, #0x18
 801a848: 46bd         	mov	sp, r7
 801a84a: bd80         	pop	{r7, pc}

0801a84c <chunk_used>:
; {
 801a84c: b580         	push	{r7, lr}
 801a84e: b082         	sub	sp, #0x8
 801a850: af00         	add	r7, sp, #0x0
 801a852: 6078         	str	r0, [r7, #0x4]
 801a854: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, SIZE_AND_USED) & 1U;
 801a856: 2201         	movs	r2, #0x1
 801a858: 6839         	ldr	r1, [r7]
 801a85a: 6878         	ldr	r0, [r7, #0x4]
 801a85c: f7ff ffa8    	bl	0x801a7b0 <chunk_field> @ imm = #-0xb0
 801a860: 4603         	mov	r3, r0
 801a862: f003 0301    	and	r3, r3, #0x1
 801a866: 2b00         	cmp	r3, #0x0
 801a868: bf14         	ite	ne
 801a86a: 2301         	movne	r3, #0x1
 801a86c: 2300         	moveq	r3, #0x0
 801a86e: b2db         	uxtb	r3, r3
; }
 801a870: 4618         	mov	r0, r3
 801a872: 3708         	adds	r7, #0x8
 801a874: 46bd         	mov	sp, r7
 801a876: bd80         	pop	{r7, pc}

0801a878 <chunk_size>:
; {
 801a878: b580         	push	{r7, lr}
 801a87a: b082         	sub	sp, #0x8
 801a87c: af00         	add	r7, sp, #0x0
 801a87e: 6078         	str	r0, [r7, #0x4]
 801a880: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, SIZE_AND_USED) >> 1;
 801a882: 2201         	movs	r2, #0x1
 801a884: 6839         	ldr	r1, [r7]
 801a886: 6878         	ldr	r0, [r7, #0x4]
 801a888: f7ff ff92    	bl	0x801a7b0 <chunk_field> @ imm = #-0xdc
 801a88c: 4603         	mov	r3, r0
 801a88e: 085b         	lsrs	r3, r3, #0x1
; }
 801a890: 4618         	mov	r0, r3
 801a892: 3708         	adds	r7, #0x8
 801a894: 46bd         	mov	sp, r7
 801a896: bd80         	pop	{r7, pc}

0801a898 <set_chunk_used>:
; {
 801a898: b580         	push	{r7, lr}
 801a89a: b086         	sub	sp, #0x18
 801a89c: af00         	add	r7, sp, #0x0
 801a89e: 60f8         	str	r0, [r7, #0xc]
 801a8a0: 60b9         	str	r1, [r7, #0x8]
 801a8a2: 4613         	mov	r3, r2
 801a8a4: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 801a8a6: 68f8         	ldr	r0, [r7, #0xc]
 801a8a8: f7ff ff77    	bl	0x801a79a <chunk_buf>   @ imm = #-0x112
 801a8ac: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 801a8ae: 68bb         	ldr	r3, [r7, #0x8]
 801a8b0: 00db         	lsls	r3, r3, #0x3
 801a8b2: 697a         	ldr	r2, [r7, #0x14]
 801a8b4: 4413         	add	r3, r2
 801a8b6: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 801a8b8: 68f8         	ldr	r0, [r7, #0xc]
 801a8ba: f7ff ff60    	bl	0x801a77e <big_heap>    @ imm = #-0x140
 801a8be: 4603         	mov	r3, r0
 801a8c0: 2b00         	cmp	r3, #0x0
 801a8c2: d014         	beq	0x801a8ee <set_chunk_used+0x56> @ imm = #0x28
; 		if (used) {
 801a8c4: 79fb         	ldrb	r3, [r7, #0x7]
 801a8c6: 2b00         	cmp	r3, #0x0
 801a8c8: d008         	beq	0x801a8dc <set_chunk_used+0x44> @ imm = #0x10
; 			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
 801a8ca: 693b         	ldr	r3, [r7, #0x10]
 801a8cc: 3304         	adds	r3, #0x4
 801a8ce: 681a         	ldr	r2, [r3]
 801a8d0: 693b         	ldr	r3, [r7, #0x10]
 801a8d2: 3304         	adds	r3, #0x4
 801a8d4: f042 0201    	orr	r2, r2, #0x1
 801a8d8: 601a         	str	r2, [r3]
; }
 801a8da: e01e         	b	0x801a91a <set_chunk_used+0x82> @ imm = #0x3c
; 			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
 801a8dc: 693b         	ldr	r3, [r7, #0x10]
 801a8de: 3304         	adds	r3, #0x4
 801a8e0: 681a         	ldr	r2, [r3]
 801a8e2: 693b         	ldr	r3, [r7, #0x10]
 801a8e4: 3304         	adds	r3, #0x4
 801a8e6: f022 0201    	bic	r2, r2, #0x1
 801a8ea: 601a         	str	r2, [r3]
; }
 801a8ec: e015         	b	0x801a91a <set_chunk_used+0x82> @ imm = #0x2a
; 		if (used) {
 801a8ee: 79fb         	ldrb	r3, [r7, #0x7]
 801a8f0: 2b00         	cmp	r3, #0x0
 801a8f2: d009         	beq	0x801a908 <set_chunk_used+0x70> @ imm = #0x12
; 			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 801a8f4: 693b         	ldr	r3, [r7, #0x10]
 801a8f6: 3302         	adds	r3, #0x2
 801a8f8: 881a         	ldrh	r2, [r3]
 801a8fa: 693b         	ldr	r3, [r7, #0x10]
 801a8fc: 3302         	adds	r3, #0x2
 801a8fe: f042 0201    	orr	r2, r2, #0x1
 801a902: b292         	uxth	r2, r2
 801a904: 801a         	strh	r2, [r3]
; }
 801a906: e008         	b	0x801a91a <set_chunk_used+0x82> @ imm = #0x10
; 			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
 801a908: 693b         	ldr	r3, [r7, #0x10]
 801a90a: 3302         	adds	r3, #0x2
 801a90c: 881a         	ldrh	r2, [r3]
 801a90e: 693b         	ldr	r3, [r7, #0x10]
 801a910: 3302         	adds	r3, #0x2
 801a912: f022 0201    	bic	r2, r2, #0x1
 801a916: b292         	uxth	r2, r2
 801a918: 801a         	strh	r2, [r3]
; }
 801a91a: bf00         	nop
 801a91c: 3718         	adds	r7, #0x18
 801a91e: 46bd         	mov	sp, r7
 801a920: bd80         	pop	{r7, pc}

0801a922 <set_chunk_size>:
; {
 801a922: b580         	push	{r7, lr}
 801a924: b084         	sub	sp, #0x10
 801a926: af00         	add	r7, sp, #0x0
 801a928: 60f8         	str	r0, [r7, #0xc]
 801a92a: 60b9         	str	r1, [r7, #0x8]
 801a92c: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, SIZE_AND_USED, size << 1);
 801a92e: 687b         	ldr	r3, [r7, #0x4]
 801a930: 005b         	lsls	r3, r3, #0x1
 801a932: 2201         	movs	r2, #0x1
 801a934: 68b9         	ldr	r1, [r7, #0x8]
 801a936: 68f8         	ldr	r0, [r7, #0xc]
 801a938: f7ff ff5f    	bl	0x801a7fa <chunk_set>   @ imm = #-0x142
; }
 801a93c: bf00         	nop
 801a93e: 3710         	adds	r7, #0x10
 801a940: 46bd         	mov	sp, r7
 801a942: bd80         	pop	{r7, pc}

0801a944 <prev_free_chunk>:
; {
 801a944: b580         	push	{r7, lr}
 801a946: b082         	sub	sp, #0x8
 801a948: af00         	add	r7, sp, #0x0
 801a94a: 6078         	str	r0, [r7, #0x4]
 801a94c: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, FREE_PREV);
 801a94e: 2202         	movs	r2, #0x2
 801a950: 6839         	ldr	r1, [r7]
 801a952: 6878         	ldr	r0, [r7, #0x4]
 801a954: f7ff ff2c    	bl	0x801a7b0 <chunk_field> @ imm = #-0x1a8
 801a958: 4603         	mov	r3, r0
; }
 801a95a: 4618         	mov	r0, r3
 801a95c: 3708         	adds	r7, #0x8
 801a95e: 46bd         	mov	sp, r7
 801a960: bd80         	pop	{r7, pc}

0801a962 <next_free_chunk>:
; {
 801a962: b580         	push	{r7, lr}
 801a964: b082         	sub	sp, #0x8
 801a966: af00         	add	r7, sp, #0x0
 801a968: 6078         	str	r0, [r7, #0x4]
 801a96a: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, FREE_NEXT);
 801a96c: 2203         	movs	r2, #0x3
 801a96e: 6839         	ldr	r1, [r7]
 801a970: 6878         	ldr	r0, [r7, #0x4]
 801a972: f7ff ff1d    	bl	0x801a7b0 <chunk_field> @ imm = #-0x1c6
 801a976: 4603         	mov	r3, r0
; }
 801a978: 4618         	mov	r0, r3
 801a97a: 3708         	adds	r7, #0x8
 801a97c: 46bd         	mov	sp, r7
 801a97e: bd80         	pop	{r7, pc}

0801a980 <set_prev_free_chunk>:
; {
 801a980: b580         	push	{r7, lr}
 801a982: b084         	sub	sp, #0x10
 801a984: af00         	add	r7, sp, #0x0
 801a986: 60f8         	str	r0, [r7, #0xc]
 801a988: 60b9         	str	r1, [r7, #0x8]
 801a98a: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_PREV, prev);
 801a98c: 687b         	ldr	r3, [r7, #0x4]
 801a98e: 2202         	movs	r2, #0x2
 801a990: 68b9         	ldr	r1, [r7, #0x8]
 801a992: 68f8         	ldr	r0, [r7, #0xc]
 801a994: f7ff ff31    	bl	0x801a7fa <chunk_set>   @ imm = #-0x19e
; }
 801a998: bf00         	nop
 801a99a: 3710         	adds	r7, #0x10
 801a99c: 46bd         	mov	sp, r7
 801a99e: bd80         	pop	{r7, pc}

0801a9a0 <set_next_free_chunk>:
; {
 801a9a0: b580         	push	{r7, lr}
 801a9a2: b084         	sub	sp, #0x10
 801a9a4: af00         	add	r7, sp, #0x0
 801a9a6: 60f8         	str	r0, [r7, #0xc]
 801a9a8: 60b9         	str	r1, [r7, #0x8]
 801a9aa: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_NEXT, next);
 801a9ac: 687b         	ldr	r3, [r7, #0x4]
 801a9ae: 2203         	movs	r2, #0x3
 801a9b0: 68b9         	ldr	r1, [r7, #0x8]
 801a9b2: 68f8         	ldr	r0, [r7, #0xc]
 801a9b4: f7ff ff21    	bl	0x801a7fa <chunk_set>   @ imm = #-0x1be
; }
 801a9b8: bf00         	nop
 801a9ba: 3710         	adds	r7, #0x10
 801a9bc: 46bd         	mov	sp, r7
 801a9be: bd80         	pop	{r7, pc}

0801a9c0 <left_chunk>:
; {
 801a9c0: b580         	push	{r7, lr}
 801a9c2: b082         	sub	sp, #0x8
 801a9c4: af00         	add	r7, sp, #0x0
 801a9c6: 6078         	str	r0, [r7, #0x4]
 801a9c8: 6039         	str	r1, [r7]
; 	return c - chunk_field(h, c, LEFT_SIZE);
 801a9ca: 2200         	movs	r2, #0x0
 801a9cc: 6839         	ldr	r1, [r7]
 801a9ce: 6878         	ldr	r0, [r7, #0x4]
 801a9d0: f7ff feee    	bl	0x801a7b0 <chunk_field> @ imm = #-0x224
 801a9d4: 4602         	mov	r2, r0
 801a9d6: 683b         	ldr	r3, [r7]
 801a9d8: 1a9b         	subs	r3, r3, r2
; }
 801a9da: 4618         	mov	r0, r3
 801a9dc: 3708         	adds	r7, #0x8
 801a9de: 46bd         	mov	sp, r7
 801a9e0: bd80         	pop	{r7, pc}

0801a9e2 <right_chunk>:
; {
 801a9e2: b580         	push	{r7, lr}
 801a9e4: b082         	sub	sp, #0x8
 801a9e6: af00         	add	r7, sp, #0x0
 801a9e8: 6078         	str	r0, [r7, #0x4]
 801a9ea: 6039         	str	r1, [r7]
; 	return c + chunk_size(h, c);
 801a9ec: 6839         	ldr	r1, [r7]
 801a9ee: 6878         	ldr	r0, [r7, #0x4]
 801a9f0: f7ff ff42    	bl	0x801a878 <chunk_size>  @ imm = #-0x17c
 801a9f4: 4602         	mov	r2, r0
 801a9f6: 683b         	ldr	r3, [r7]
 801a9f8: 4413         	add	r3, r2
; }
 801a9fa: 4618         	mov	r0, r3
 801a9fc: 3708         	adds	r7, #0x8
 801a9fe: 46bd         	mov	sp, r7
 801aa00: bd80         	pop	{r7, pc}

0801aa02 <set_left_chunk_size>:
; {
 801aa02: b580         	push	{r7, lr}
 801aa04: b084         	sub	sp, #0x10
 801aa06: af00         	add	r7, sp, #0x0
 801aa08: 60f8         	str	r0, [r7, #0xc]
 801aa0a: 60b9         	str	r1, [r7, #0x8]
 801aa0c: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, LEFT_SIZE, size);
 801aa0e: 687b         	ldr	r3, [r7, #0x4]
 801aa10: 2200         	movs	r2, #0x0
 801aa12: 68b9         	ldr	r1, [r7, #0x8]
 801aa14: 68f8         	ldr	r0, [r7, #0xc]
 801aa16: f7ff fef0    	bl	0x801a7fa <chunk_set>   @ imm = #-0x220
; }
 801aa1a: bf00         	nop
 801aa1c: 3710         	adds	r7, #0x10
 801aa1e: 46bd         	mov	sp, r7
 801aa20: bd80         	pop	{r7, pc}

0801aa22 <solo_free_header>:
; {
 801aa22: b580         	push	{r7, lr}
 801aa24: b082         	sub	sp, #0x8
 801aa26: af00         	add	r7, sp, #0x0
 801aa28: 6078         	str	r0, [r7, #0x4]
 801aa2a: 6039         	str	r1, [r7]
; 	return big_heap(h) && (chunk_size(h, c) == 1U);
 801aa2c: 6878         	ldr	r0, [r7, #0x4]
 801aa2e: f7ff fea6    	bl	0x801a77e <big_heap>    @ imm = #-0x2b4
 801aa32: 4603         	mov	r3, r0
 801aa34: 2b00         	cmp	r3, #0x0
 801aa36: d008         	beq	0x801aa4a <solo_free_header+0x28> @ imm = #0x10
 801aa38: 6839         	ldr	r1, [r7]
 801aa3a: 6878         	ldr	r0, [r7, #0x4]
 801aa3c: f7ff ff1c    	bl	0x801a878 <chunk_size>  @ imm = #-0x1c8
 801aa40: 4603         	mov	r3, r0
 801aa42: 2b01         	cmp	r3, #0x1
 801aa44: d101         	bne	0x801aa4a <solo_free_header+0x28> @ imm = #0x2
 801aa46: 2301         	movs	r3, #0x1
 801aa48: e000         	b	0x801aa4c <solo_free_header+0x2a> @ imm = #0x0
 801aa4a: 2300         	movs	r3, #0x0
 801aa4c: f003 0301    	and	r3, r3, #0x1
 801aa50: b2db         	uxtb	r3, r3
; }
 801aa52: 4618         	mov	r0, r3
 801aa54: 3708         	adds	r7, #0x8
 801aa56: 46bd         	mov	sp, r7
 801aa58: bd80         	pop	{r7, pc}

0801aa5a <chunk_header_bytes>:
; {
 801aa5a: b580         	push	{r7, lr}
 801aa5c: b082         	sub	sp, #0x8
 801aa5e: af00         	add	r7, sp, #0x0
 801aa60: 6078         	str	r0, [r7, #0x4]
; 	return big_heap(h) ? 8 : 4;
 801aa62: 6878         	ldr	r0, [r7, #0x4]
 801aa64: f7ff fe8b    	bl	0x801a77e <big_heap>    @ imm = #-0x2ea
 801aa68: 4603         	mov	r3, r0
 801aa6a: 2b00         	cmp	r3, #0x0
 801aa6c: d001         	beq	0x801aa72 <chunk_header_bytes+0x18> @ imm = #0x2
 801aa6e: 2308         	movs	r3, #0x8
 801aa70: e000         	b	0x801aa74 <chunk_header_bytes+0x1a> @ imm = #0x0
 801aa72: 2304         	movs	r3, #0x4
; }
 801aa74: 4618         	mov	r0, r3
 801aa76: 3708         	adds	r7, #0x8
 801aa78: 46bd         	mov	sp, r7
 801aa7a: bd80         	pop	{r7, pc}

0801aa7c <heap_footer_bytes>:
; {
 801aa7c: b580         	push	{r7, lr}
 801aa7e: b082         	sub	sp, #0x8
 801aa80: af00         	add	r7, sp, #0x0
 801aa82: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_bytes(size) ? 8 : 4;
 801aa84: 6878         	ldr	r0, [r7, #0x4]
 801aa86: f7ff fe6c    	bl	0x801a762 <big_heap_bytes> @ imm = #-0x328
 801aa8a: 4603         	mov	r3, r0
 801aa8c: 2b00         	cmp	r3, #0x0
 801aa8e: d001         	beq	0x801aa94 <heap_footer_bytes+0x18> @ imm = #0x2
 801aa90: 2308         	movs	r3, #0x8
 801aa92: e000         	b	0x801aa96 <heap_footer_bytes+0x1a> @ imm = #0x0
 801aa94: 2304         	movs	r3, #0x4
; }
 801aa96: 4618         	mov	r0, r3
 801aa98: 3708         	adds	r7, #0x8
 801aa9a: 46bd         	mov	sp, r7
 801aa9c: bd80         	pop	{r7, pc}

0801aa9e <chunksz>:
; {
 801aa9e: b480         	push	{r7}
 801aaa0: b083         	sub	sp, #0xc
 801aaa2: af00         	add	r7, sp, #0x0
 801aaa4: 6078         	str	r0, [r7, #0x4]
; 	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 801aaa6: 687b         	ldr	r3, [r7, #0x4]
 801aaa8: 3307         	adds	r3, #0x7
 801aaaa: 08db         	lsrs	r3, r3, #0x3
; }
 801aaac: 4618         	mov	r0, r3
 801aaae: 370c         	adds	r7, #0xc
 801aab0: 46bd         	mov	sp, r7
 801aab2: f85d 7b04    	ldr	r7, [sp], #4
 801aab6: 4770         	bx	lr

0801aab8 <bytes_to_chunksz>:
; {
 801aab8: b580         	push	{r7, lr}
 801aaba: b082         	sub	sp, #0x8
 801aabc: af00         	add	r7, sp, #0x0
 801aabe: 6078         	str	r0, [r7, #0x4]
 801aac0: 6039         	str	r1, [r7]
; 	return chunksz(chunk_header_bytes(h) + bytes);
 801aac2: 6878         	ldr	r0, [r7, #0x4]
 801aac4: f7ff ffc9    	bl	0x801aa5a <chunk_header_bytes> @ imm = #-0x6e
 801aac8: 4602         	mov	r2, r0
 801aaca: 683b         	ldr	r3, [r7]
 801aacc: 4413         	add	r3, r2
 801aace: 4618         	mov	r0, r3
 801aad0: f7ff ffe5    	bl	0x801aa9e <chunksz>     @ imm = #-0x36
 801aad4: 4603         	mov	r3, r0
; }
 801aad6: 4618         	mov	r0, r3
 801aad8: 3708         	adds	r7, #0x8
 801aada: 46bd         	mov	sp, r7
 801aadc: bd80         	pop	{r7, pc}

0801aade <min_chunk_size>:
; {
 801aade: b580         	push	{r7, lr}
 801aae0: b082         	sub	sp, #0x8
 801aae2: af00         	add	r7, sp, #0x0
 801aae4: 6078         	str	r0, [r7, #0x4]
; 	return bytes_to_chunksz(h, 1);
 801aae6: 2101         	movs	r1, #0x1
 801aae8: 6878         	ldr	r0, [r7, #0x4]
 801aaea: f7ff ffe5    	bl	0x801aab8 <bytes_to_chunksz> @ imm = #-0x36
 801aaee: 4603         	mov	r3, r0
; }
 801aaf0: 4618         	mov	r0, r3
 801aaf2: 3708         	adds	r7, #0x8
 801aaf4: 46bd         	mov	sp, r7
 801aaf6: bd80         	pop	{r7, pc}

0801aaf8 <bucket_idx>:
; {
 801aaf8: b580         	push	{r7, lr}
 801aafa: b084         	sub	sp, #0x10
 801aafc: af00         	add	r7, sp, #0x0
 801aafe: 6078         	str	r0, [r7, #0x4]
 801ab00: 6039         	str	r1, [r7]
; 	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
 801ab02: 6878         	ldr	r0, [r7, #0x4]
 801ab04: f7ff ffeb    	bl	0x801aade <min_chunk_size> @ imm = #-0x2a
 801ab08: 4602         	mov	r2, r0
 801ab0a: 683b         	ldr	r3, [r7]
 801ab0c: 1a9b         	subs	r3, r3, r2
 801ab0e: 3301         	adds	r3, #0x1
 801ab10: 60fb         	str	r3, [r7, #0xc]
; 	return 31 - __builtin_clz(usable_sz);
 801ab12: 68fb         	ldr	r3, [r7, #0xc]
 801ab14: fab3 f383    	clz	r3, r3
 801ab18: f1c3 031f    	rsb.w	r3, r3, #0x1f
; }
 801ab1c: 4618         	mov	r0, r3
 801ab1e: 3710         	adds	r7, #0x10
 801ab20: 46bd         	mov	sp, r7
 801ab22: bd80         	pop	{r7, pc}

0801ab24 <size_too_big>:
; {
 801ab24: b480         	push	{r7}
 801ab26: b083         	sub	sp, #0xc
 801ab28: af00         	add	r7, sp, #0x0
 801ab2a: 6078         	str	r0, [r7, #0x4]
 801ab2c: 6039         	str	r1, [r7]
; 	return (bytes / CHUNK_UNIT) >= h->end_chunk;
 801ab2e: 683b         	ldr	r3, [r7]
 801ab30: 08da         	lsrs	r2, r3, #0x3
 801ab32: 687b         	ldr	r3, [r7, #0x4]
 801ab34: 689b         	ldr	r3, [r3, #0x8]
 801ab36: 429a         	cmp	r2, r3
 801ab38: bf2c         	ite	hs
 801ab3a: 2301         	movhs	r3, #0x1
 801ab3c: 2300         	movlo	r3, #0x0
 801ab3e: b2db         	uxtb	r3, r3
; }
 801ab40: 4618         	mov	r0, r3
 801ab42: 370c         	adds	r7, #0xc
 801ab44: 46bd         	mov	sp, r7
 801ab46: f85d 7b04    	ldr	r7, [sp], #4
 801ab4a: 4770         	bx	lr

0801ab4c <chunk_mem>:
; {
 801ab4c: b590         	push	{r4, r7, lr}
 801ab4e: b085         	sub	sp, #0x14
 801ab50: af00         	add	r7, sp, #0x0
 801ab52: 6078         	str	r0, [r7, #0x4]
 801ab54: 6039         	str	r1, [r7]
; 	chunk_unit_t *buf = chunk_buf(h);
 801ab56: 6878         	ldr	r0, [r7, #0x4]
 801ab58: f7ff fe1f    	bl	0x801a79a <chunk_buf>   @ imm = #-0x3c2
 801ab5c: 60f8         	str	r0, [r7, #0xc]
; 	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
 801ab5e: 683b         	ldr	r3, [r7]
 801ab60: 00dc         	lsls	r4, r3, #0x3
 801ab62: 6878         	ldr	r0, [r7, #0x4]
 801ab64: f7ff ff79    	bl	0x801aa5a <chunk_header_bytes> @ imm = #-0x10e
 801ab68: 4603         	mov	r3, r0
 801ab6a: 4423         	add	r3, r4
 801ab6c: 68fa         	ldr	r2, [r7, #0xc]
 801ab6e: 4413         	add	r3, r2
 801ab70: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 801ab72: 68bb         	ldr	r3, [r7, #0x8]
; }
 801ab74: 4618         	mov	r0, r3
 801ab76: 3714         	adds	r7, #0x14
 801ab78: 46bd         	mov	sp, r7
 801ab7a: bd90         	pop	{r4, r7, pc}

0801ab7c <free_list_remove_bidx>:
; {
 801ab7c: b580         	push	{r7, lr}
 801ab7e: b088         	sub	sp, #0x20
 801ab80: af00         	add	r7, sp, #0x0
 801ab82: 60f8         	str	r0, [r7, #0xc]
 801ab84: 60b9         	str	r1, [r7, #0x8]
 801ab86: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap_bucket *b = &h->buckets[bidx];
 801ab88: 687b         	ldr	r3, [r7, #0x4]
 801ab8a: 3304         	adds	r3, #0x4
 801ab8c: 009b         	lsls	r3, r3, #0x2
 801ab8e: 68fa         	ldr	r2, [r7, #0xc]
 801ab90: 4413         	add	r3, r2
 801ab92: 61fb         	str	r3, [r7, #0x1c]
; 	if (next_free_chunk(h, c) == c) {
 801ab94: 68b9         	ldr	r1, [r7, #0x8]
 801ab96: 68f8         	ldr	r0, [r7, #0xc]
 801ab98: f7ff fee3    	bl	0x801a962 <next_free_chunk> @ imm = #-0x23a
 801ab9c: 4602         	mov	r2, r0
 801ab9e: 68bb         	ldr	r3, [r7, #0x8]
 801aba0: 4293         	cmp	r3, r2
 801aba2: d10d         	bne	0x801abc0 <free_list_remove_bidx+0x44> @ imm = #0x1a
; 		h->avail_buckets &= ~BIT(bidx);
 801aba4: 68fb         	ldr	r3, [r7, #0xc]
 801aba6: 68da         	ldr	r2, [r3, #0xc]
 801aba8: 2101         	movs	r1, #0x1
 801abaa: 687b         	ldr	r3, [r7, #0x4]
 801abac: fa01 f303    	lsl.w	r3, r1, r3
 801abb0: 43db         	mvns	r3, r3
 801abb2: 401a         	ands	r2, r3
 801abb4: 68fb         	ldr	r3, [r7, #0xc]
 801abb6: 60da         	str	r2, [r3, #0xc]
; 		b->next = 0;
 801abb8: 69fb         	ldr	r3, [r7, #0x1c]
 801abba: 2200         	movs	r2, #0x0
 801abbc: 601a         	str	r2, [r3]
; }
 801abbe: e016         	b	0x801abee <free_list_remove_bidx+0x72> @ imm = #0x2c
; 		chunkid_t first = prev_free_chunk(h, c),
 801abc0: 68b9         	ldr	r1, [r7, #0x8]
 801abc2: 68f8         	ldr	r0, [r7, #0xc]
 801abc4: f7ff febe    	bl	0x801a944 <prev_free_chunk> @ imm = #-0x284
 801abc8: 61b8         	str	r0, [r7, #0x18]
; 			  second = next_free_chunk(h, c);
 801abca: 68b9         	ldr	r1, [r7, #0x8]
 801abcc: 68f8         	ldr	r0, [r7, #0xc]
 801abce: f7ff fec8    	bl	0x801a962 <next_free_chunk> @ imm = #-0x270
 801abd2: 6178         	str	r0, [r7, #0x14]
; 		b->next = second;
 801abd4: 69fb         	ldr	r3, [r7, #0x1c]
 801abd6: 697a         	ldr	r2, [r7, #0x14]
 801abd8: 601a         	str	r2, [r3]
; 		set_next_free_chunk(h, first, second);
 801abda: 697a         	ldr	r2, [r7, #0x14]
 801abdc: 69b9         	ldr	r1, [r7, #0x18]
 801abde: 68f8         	ldr	r0, [r7, #0xc]
 801abe0: f7ff fede    	bl	0x801a9a0 <set_next_free_chunk> @ imm = #-0x244
; 		set_prev_free_chunk(h, second, first);
 801abe4: 69ba         	ldr	r2, [r7, #0x18]
 801abe6: 6979         	ldr	r1, [r7, #0x14]
 801abe8: 68f8         	ldr	r0, [r7, #0xc]
 801abea: f7ff fec9    	bl	0x801a980 <set_prev_free_chunk> @ imm = #-0x26e
; }
 801abee: bf00         	nop
 801abf0: 3720         	adds	r7, #0x20
 801abf2: 46bd         	mov	sp, r7
 801abf4: bd80         	pop	{r7, pc}

0801abf6 <free_list_remove>:
; {
 801abf6: b580         	push	{r7, lr}
 801abf8: b084         	sub	sp, #0x10
 801abfa: af00         	add	r7, sp, #0x0
 801abfc: 6078         	str	r0, [r7, #0x4]
 801abfe: 6039         	str	r1, [r7]
; 	if (!solo_free_header(h, c)) {
 801ac00: 6839         	ldr	r1, [r7]
 801ac02: 6878         	ldr	r0, [r7, #0x4]
 801ac04: f7ff ff0d    	bl	0x801aa22 <solo_free_header> @ imm = #-0x1e6
 801ac08: 4603         	mov	r3, r0
 801ac0a: f083 0301    	eor	r3, r3, #0x1
 801ac0e: b2db         	uxtb	r3, r3
 801ac10: 2b00         	cmp	r3, #0x0
 801ac12: d00e         	beq	0x801ac32 <free_list_remove+0x3c> @ imm = #0x1c
; 		int bidx = bucket_idx(h, chunk_size(h, c));
 801ac14: 6839         	ldr	r1, [r7]
 801ac16: 6878         	ldr	r0, [r7, #0x4]
 801ac18: f7ff fe2e    	bl	0x801a878 <chunk_size>  @ imm = #-0x3a4
 801ac1c: 4603         	mov	r3, r0
 801ac1e: 4619         	mov	r1, r3
 801ac20: 6878         	ldr	r0, [r7, #0x4]
 801ac22: f7ff ff69    	bl	0x801aaf8 <bucket_idx>  @ imm = #-0x12e
 801ac26: 60f8         	str	r0, [r7, #0xc]
; 		free_list_remove_bidx(h, c, bidx);
 801ac28: 68fa         	ldr	r2, [r7, #0xc]
 801ac2a: 6839         	ldr	r1, [r7]
 801ac2c: 6878         	ldr	r0, [r7, #0x4]
 801ac2e: f7ff ffa5    	bl	0x801ab7c <free_list_remove_bidx> @ imm = #-0xb6
; }
 801ac32: bf00         	nop
 801ac34: 3710         	adds	r7, #0x10
 801ac36: 46bd         	mov	sp, r7
 801ac38: bd80         	pop	{r7, pc}

0801ac3a <free_list_add_bidx>:
; {
 801ac3a: b580         	push	{r7, lr}
 801ac3c: b088         	sub	sp, #0x20
 801ac3e: af00         	add	r7, sp, #0x0
 801ac40: 60f8         	str	r0, [r7, #0xc]
 801ac42: 60b9         	str	r1, [r7, #0x8]
 801ac44: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap_bucket *b = &h->buckets[bidx];
 801ac46: 687b         	ldr	r3, [r7, #0x4]
 801ac48: 3304         	adds	r3, #0x4
 801ac4a: 009b         	lsls	r3, r3, #0x2
 801ac4c: 68fa         	ldr	r2, [r7, #0xc]
 801ac4e: 4413         	add	r3, r2
 801ac50: 61fb         	str	r3, [r7, #0x1c]
; 	if (b->next == 0U) {
 801ac52: 69fb         	ldr	r3, [r7, #0x1c]
 801ac54: 681b         	ldr	r3, [r3]
 801ac56: 2b00         	cmp	r3, #0x0
 801ac58: d116         	bne	0x801ac88 <free_list_add_bidx+0x4e> @ imm = #0x2c
; 		h->avail_buckets |= BIT(bidx);
 801ac5a: 68fb         	ldr	r3, [r7, #0xc]
 801ac5c: 68da         	ldr	r2, [r3, #0xc]
 801ac5e: 2101         	movs	r1, #0x1
 801ac60: 687b         	ldr	r3, [r7, #0x4]
 801ac62: fa01 f303    	lsl.w	r3, r1, r3
 801ac66: 431a         	orrs	r2, r3
 801ac68: 68fb         	ldr	r3, [r7, #0xc]
 801ac6a: 60da         	str	r2, [r3, #0xc]
; 		b->next = c;
 801ac6c: 69fb         	ldr	r3, [r7, #0x1c]
 801ac6e: 68ba         	ldr	r2, [r7, #0x8]
 801ac70: 601a         	str	r2, [r3]
; 		set_prev_free_chunk(h, c, c);
 801ac72: 68ba         	ldr	r2, [r7, #0x8]
 801ac74: 68b9         	ldr	r1, [r7, #0x8]
 801ac76: 68f8         	ldr	r0, [r7, #0xc]
 801ac78: f7ff fe82    	bl	0x801a980 <set_prev_free_chunk> @ imm = #-0x2fc
; 		set_next_free_chunk(h, c, c);
 801ac7c: 68ba         	ldr	r2, [r7, #0x8]
 801ac7e: 68b9         	ldr	r1, [r7, #0x8]
 801ac80: 68f8         	ldr	r0, [r7, #0xc]
 801ac82: f7ff fe8d    	bl	0x801a9a0 <set_next_free_chunk> @ imm = #-0x2e6
; }
 801ac86: e01b         	b	0x801acc0 <free_list_add_bidx+0x86> @ imm = #0x36
; 		chunkid_t second = b->next;
 801ac88: 69fb         	ldr	r3, [r7, #0x1c]
 801ac8a: 681b         	ldr	r3, [r3]
 801ac8c: 61bb         	str	r3, [r7, #0x18]
; 		chunkid_t first = prev_free_chunk(h, second);
 801ac8e: 69b9         	ldr	r1, [r7, #0x18]
 801ac90: 68f8         	ldr	r0, [r7, #0xc]
 801ac92: f7ff fe57    	bl	0x801a944 <prev_free_chunk> @ imm = #-0x352
 801ac96: 6178         	str	r0, [r7, #0x14]
; 		set_prev_free_chunk(h, c, first);
 801ac98: 697a         	ldr	r2, [r7, #0x14]
 801ac9a: 68b9         	ldr	r1, [r7, #0x8]
 801ac9c: 68f8         	ldr	r0, [r7, #0xc]
 801ac9e: f7ff fe6f    	bl	0x801a980 <set_prev_free_chunk> @ imm = #-0x322
; 		set_next_free_chunk(h, c, second);
 801aca2: 69ba         	ldr	r2, [r7, #0x18]
 801aca4: 68b9         	ldr	r1, [r7, #0x8]
 801aca6: 68f8         	ldr	r0, [r7, #0xc]
 801aca8: f7ff fe7a    	bl	0x801a9a0 <set_next_free_chunk> @ imm = #-0x30c
; 		set_next_free_chunk(h, first, c);
 801acac: 68ba         	ldr	r2, [r7, #0x8]
 801acae: 6979         	ldr	r1, [r7, #0x14]
 801acb0: 68f8         	ldr	r0, [r7, #0xc]
 801acb2: f7ff fe75    	bl	0x801a9a0 <set_next_free_chunk> @ imm = #-0x316
; 		set_prev_free_chunk(h, second, c);
 801acb6: 68ba         	ldr	r2, [r7, #0x8]
 801acb8: 69b9         	ldr	r1, [r7, #0x18]
 801acba: 68f8         	ldr	r0, [r7, #0xc]
 801acbc: f7ff fe60    	bl	0x801a980 <set_prev_free_chunk> @ imm = #-0x340
; }
 801acc0: bf00         	nop
 801acc2: 3720         	adds	r7, #0x20
 801acc4: 46bd         	mov	sp, r7
 801acc6: bd80         	pop	{r7, pc}

0801acc8 <free_list_add>:
; {
 801acc8: b580         	push	{r7, lr}
 801acca: b084         	sub	sp, #0x10
 801accc: af00         	add	r7, sp, #0x0
 801acce: 6078         	str	r0, [r7, #0x4]
 801acd0: 6039         	str	r1, [r7]
; 	if (!solo_free_header(h, c)) {
 801acd2: 6839         	ldr	r1, [r7]
 801acd4: 6878         	ldr	r0, [r7, #0x4]
 801acd6: f7ff fea4    	bl	0x801aa22 <solo_free_header> @ imm = #-0x2b8
 801acda: 4603         	mov	r3, r0
 801acdc: f083 0301    	eor	r3, r3, #0x1
 801ace0: b2db         	uxtb	r3, r3
 801ace2: 2b00         	cmp	r3, #0x0
 801ace4: d00e         	beq	0x801ad04 <free_list_add+0x3c> @ imm = #0x1c
; 		int bidx = bucket_idx(h, chunk_size(h, c));
 801ace6: 6839         	ldr	r1, [r7]
 801ace8: 6878         	ldr	r0, [r7, #0x4]
 801acea: f7ff fdc5    	bl	0x801a878 <chunk_size>  @ imm = #-0x476
 801acee: 4603         	mov	r3, r0
 801acf0: 4619         	mov	r1, r3
 801acf2: 6878         	ldr	r0, [r7, #0x4]
 801acf4: f7ff ff00    	bl	0x801aaf8 <bucket_idx>  @ imm = #-0x200
 801acf8: 60f8         	str	r0, [r7, #0xc]
; 		free_list_add_bidx(h, c, bidx);
 801acfa: 68fa         	ldr	r2, [r7, #0xc]
 801acfc: 6839         	ldr	r1, [r7]
 801acfe: 6878         	ldr	r0, [r7, #0x4]
 801ad00: f7ff ff9b    	bl	0x801ac3a <free_list_add_bidx> @ imm = #-0xca
; }
 801ad04: bf00         	nop
 801ad06: 3710         	adds	r7, #0x10
 801ad08: 46bd         	mov	sp, r7
 801ad0a: bd80         	pop	{r7, pc}

0801ad0c <split_chunks>:
; {
 801ad0c: b580         	push	{r7, lr}
 801ad0e: b088         	sub	sp, #0x20
 801ad10: af00         	add	r7, sp, #0x0
 801ad12: 60f8         	str	r0, [r7, #0xc]
 801ad14: 60b9         	str	r1, [r7, #0x8]
 801ad16: 607a         	str	r2, [r7, #0x4]
; 	chunksz_t sz0 = chunk_size(h, lc);
 801ad18: 68b9         	ldr	r1, [r7, #0x8]
 801ad1a: 68f8         	ldr	r0, [r7, #0xc]
 801ad1c: f7ff fdac    	bl	0x801a878 <chunk_size>  @ imm = #-0x4a8
 801ad20: 61f8         	str	r0, [r7, #0x1c]
; 	chunksz_t lsz = rc - lc;
 801ad22: 687a         	ldr	r2, [r7, #0x4]
 801ad24: 68bb         	ldr	r3, [r7, #0x8]
 801ad26: 1ad3         	subs	r3, r2, r3
 801ad28: 61bb         	str	r3, [r7, #0x18]
; 	chunksz_t rsz = sz0 - lsz;
 801ad2a: 69fa         	ldr	r2, [r7, #0x1c]
 801ad2c: 69bb         	ldr	r3, [r7, #0x18]
 801ad2e: 1ad3         	subs	r3, r2, r3
 801ad30: 617b         	str	r3, [r7, #0x14]
; 	set_chunk_size(h, lc, lsz);
 801ad32: 69ba         	ldr	r2, [r7, #0x18]
 801ad34: 68b9         	ldr	r1, [r7, #0x8]
 801ad36: 68f8         	ldr	r0, [r7, #0xc]
 801ad38: f7ff fdf3    	bl	0x801a922 <set_chunk_size> @ imm = #-0x41a
; 	set_chunk_size(h, rc, rsz);
 801ad3c: 697a         	ldr	r2, [r7, #0x14]
 801ad3e: 6879         	ldr	r1, [r7, #0x4]
 801ad40: 68f8         	ldr	r0, [r7, #0xc]
 801ad42: f7ff fdee    	bl	0x801a922 <set_chunk_size> @ imm = #-0x424
; 	set_left_chunk_size(h, rc, lsz);
 801ad46: 69ba         	ldr	r2, [r7, #0x18]
 801ad48: 6879         	ldr	r1, [r7, #0x4]
 801ad4a: 68f8         	ldr	r0, [r7, #0xc]
 801ad4c: f7ff fe59    	bl	0x801aa02 <set_left_chunk_size> @ imm = #-0x34e
; 	set_left_chunk_size(h, right_chunk(h, rc), rsz);
 801ad50: 6879         	ldr	r1, [r7, #0x4]
 801ad52: 68f8         	ldr	r0, [r7, #0xc]
 801ad54: f7ff fe45    	bl	0x801a9e2 <right_chunk> @ imm = #-0x376
 801ad58: 4603         	mov	r3, r0
 801ad5a: 697a         	ldr	r2, [r7, #0x14]
 801ad5c: 4619         	mov	r1, r3
 801ad5e: 68f8         	ldr	r0, [r7, #0xc]
 801ad60: f7ff fe4f    	bl	0x801aa02 <set_left_chunk_size> @ imm = #-0x362
; }
 801ad64: bf00         	nop
 801ad66: 3720         	adds	r7, #0x20
 801ad68: 46bd         	mov	sp, r7
 801ad6a: bd80         	pop	{r7, pc}

0801ad6c <merge_chunks>:
; {
 801ad6c: b590         	push	{r4, r7, lr}
 801ad6e: b087         	sub	sp, #0x1c
 801ad70: af00         	add	r7, sp, #0x0
 801ad72: 60f8         	str	r0, [r7, #0xc]
 801ad74: 60b9         	str	r1, [r7, #0x8]
 801ad76: 607a         	str	r2, [r7, #0x4]
; 	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
 801ad78: 68b9         	ldr	r1, [r7, #0x8]
 801ad7a: 68f8         	ldr	r0, [r7, #0xc]
 801ad7c: f7ff fd7c    	bl	0x801a878 <chunk_size>  @ imm = #-0x508
 801ad80: 4604         	mov	r4, r0
 801ad82: 6879         	ldr	r1, [r7, #0x4]
 801ad84: 68f8         	ldr	r0, [r7, #0xc]
 801ad86: f7ff fd77    	bl	0x801a878 <chunk_size>  @ imm = #-0x512
 801ad8a: 4603         	mov	r3, r0
 801ad8c: 4423         	add	r3, r4
 801ad8e: 617b         	str	r3, [r7, #0x14]
; 	set_chunk_size(h, lc, newsz);
 801ad90: 697a         	ldr	r2, [r7, #0x14]
 801ad92: 68b9         	ldr	r1, [r7, #0x8]
 801ad94: 68f8         	ldr	r0, [r7, #0xc]
 801ad96: f7ff fdc4    	bl	0x801a922 <set_chunk_size> @ imm = #-0x478
; 	set_left_chunk_size(h, right_chunk(h, rc), newsz);
 801ad9a: 6879         	ldr	r1, [r7, #0x4]
 801ad9c: 68f8         	ldr	r0, [r7, #0xc]
 801ad9e: f7ff fe20    	bl	0x801a9e2 <right_chunk> @ imm = #-0x3c0
 801ada2: 4603         	mov	r3, r0
 801ada4: 697a         	ldr	r2, [r7, #0x14]
 801ada6: 4619         	mov	r1, r3
 801ada8: 68f8         	ldr	r0, [r7, #0xc]
 801adaa: f7ff fe2a    	bl	0x801aa02 <set_left_chunk_size> @ imm = #-0x3ac
; }
 801adae: bf00         	nop
 801adb0: 371c         	adds	r7, #0x1c
 801adb2: 46bd         	mov	sp, r7
 801adb4: bd90         	pop	{r4, r7, pc}

0801adb6 <free_chunk>:
; {
 801adb6: b580         	push	{r7, lr}
 801adb8: b082         	sub	sp, #0x8
 801adba: af00         	add	r7, sp, #0x0
 801adbc: 6078         	str	r0, [r7, #0x4]
 801adbe: 6039         	str	r1, [r7]
; 	if (!chunk_used(h, right_chunk(h, c))) {
 801adc0: 6839         	ldr	r1, [r7]
 801adc2: 6878         	ldr	r0, [r7, #0x4]
 801adc4: f7ff fe0d    	bl	0x801a9e2 <right_chunk> @ imm = #-0x3e6
 801adc8: 4603         	mov	r3, r0
 801adca: 4619         	mov	r1, r3
 801adcc: 6878         	ldr	r0, [r7, #0x4]
 801adce: f7ff fd3d    	bl	0x801a84c <chunk_used>  @ imm = #-0x586
 801add2: 4603         	mov	r3, r0
 801add4: f083 0301    	eor	r3, r3, #0x1
 801add8: b2db         	uxtb	r3, r3
 801adda: 2b00         	cmp	r3, #0x0
 801addc: d012         	beq	0x801ae04 <free_chunk+0x4e> @ imm = #0x24
; 		free_list_remove(h, right_chunk(h, c));
 801adde: 6839         	ldr	r1, [r7]
 801ade0: 6878         	ldr	r0, [r7, #0x4]
 801ade2: f7ff fdfe    	bl	0x801a9e2 <right_chunk> @ imm = #-0x404
 801ade6: 4603         	mov	r3, r0
 801ade8: 4619         	mov	r1, r3
 801adea: 6878         	ldr	r0, [r7, #0x4]
 801adec: f7ff ff03    	bl	0x801abf6 <free_list_remove> @ imm = #-0x1fa
; 		merge_chunks(h, c, right_chunk(h, c));
 801adf0: 6839         	ldr	r1, [r7]
 801adf2: 6878         	ldr	r0, [r7, #0x4]
 801adf4: f7ff fdf5    	bl	0x801a9e2 <right_chunk> @ imm = #-0x416
 801adf8: 4603         	mov	r3, r0
 801adfa: 461a         	mov	r2, r3
 801adfc: 6839         	ldr	r1, [r7]
 801adfe: 6878         	ldr	r0, [r7, #0x4]
 801ae00: f7ff ffb4    	bl	0x801ad6c <merge_chunks> @ imm = #-0x98
; 	if (!chunk_used(h, left_chunk(h, c))) {
 801ae04: 6839         	ldr	r1, [r7]
 801ae06: 6878         	ldr	r0, [r7, #0x4]
 801ae08: f7ff fdda    	bl	0x801a9c0 <left_chunk>  @ imm = #-0x44c
 801ae0c: 4603         	mov	r3, r0
 801ae0e: 4619         	mov	r1, r3
 801ae10: 6878         	ldr	r0, [r7, #0x4]
 801ae12: f7ff fd1b    	bl	0x801a84c <chunk_used>  @ imm = #-0x5ca
 801ae16: 4603         	mov	r3, r0
 801ae18: f083 0301    	eor	r3, r3, #0x1
 801ae1c: b2db         	uxtb	r3, r3
 801ae1e: 2b00         	cmp	r3, #0x0
 801ae20: d017         	beq	0x801ae52 <free_chunk+0x9c> @ imm = #0x2e
; 		free_list_remove(h, left_chunk(h, c));
 801ae22: 6839         	ldr	r1, [r7]
 801ae24: 6878         	ldr	r0, [r7, #0x4]
 801ae26: f7ff fdcb    	bl	0x801a9c0 <left_chunk>  @ imm = #-0x46a
 801ae2a: 4603         	mov	r3, r0
 801ae2c: 4619         	mov	r1, r3
 801ae2e: 6878         	ldr	r0, [r7, #0x4]
 801ae30: f7ff fee1    	bl	0x801abf6 <free_list_remove> @ imm = #-0x23e
; 		merge_chunks(h, left_chunk(h, c), c);
 801ae34: 6839         	ldr	r1, [r7]
 801ae36: 6878         	ldr	r0, [r7, #0x4]
 801ae38: f7ff fdc2    	bl	0x801a9c0 <left_chunk>  @ imm = #-0x47c
 801ae3c: 4603         	mov	r3, r0
 801ae3e: 683a         	ldr	r2, [r7]
 801ae40: 4619         	mov	r1, r3
 801ae42: 6878         	ldr	r0, [r7, #0x4]
 801ae44: f7ff ff92    	bl	0x801ad6c <merge_chunks> @ imm = #-0xdc
; 		c = left_chunk(h, c);
 801ae48: 6839         	ldr	r1, [r7]
 801ae4a: 6878         	ldr	r0, [r7, #0x4]
 801ae4c: f7ff fdb8    	bl	0x801a9c0 <left_chunk>  @ imm = #-0x490
 801ae50: 6038         	str	r0, [r7]
; 	free_list_add(h, c);
 801ae52: 6839         	ldr	r1, [r7]
 801ae54: 6878         	ldr	r0, [r7, #0x4]
 801ae56: f7ff ff37    	bl	0x801acc8 <free_list_add> @ imm = #-0x192
; }
 801ae5a: bf00         	nop
 801ae5c: 3708         	adds	r7, #0x8
 801ae5e: 46bd         	mov	sp, r7
 801ae60: bd80         	pop	{r7, pc}

0801ae62 <mem_to_chunkid>:
; {
 801ae62: b580         	push	{r7, lr}
 801ae64: b084         	sub	sp, #0x10
 801ae66: af00         	add	r7, sp, #0x0
 801ae68: 6078         	str	r0, [r7, #0x4]
 801ae6a: 6039         	str	r1, [r7]
; 	uint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);
 801ae6c: 683b         	ldr	r3, [r7]
 801ae6e: 60fb         	str	r3, [r7, #0xc]
 801ae70: 6878         	ldr	r0, [r7, #0x4]
 801ae72: f7ff fc92    	bl	0x801a79a <chunk_buf>   @ imm = #-0x6dc
 801ae76: 60b8         	str	r0, [r7, #0x8]
; 	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 801ae78: 6878         	ldr	r0, [r7, #0x4]
 801ae7a: f7ff fdee    	bl	0x801aa5a <chunk_header_bytes> @ imm = #-0x424
 801ae7e: 4603         	mov	r3, r0
 801ae80: 425b         	rsbs	r3, r3, #0
 801ae82: 68fa         	ldr	r2, [r7, #0xc]
 801ae84: 441a         	add	r2, r3
 801ae86: 68bb         	ldr	r3, [r7, #0x8]
 801ae88: 1ad3         	subs	r3, r2, r3
 801ae8a: 08db         	lsrs	r3, r3, #0x3
; }
 801ae8c: 4618         	mov	r0, r3
 801ae8e: 3710         	adds	r7, #0x10
 801ae90: 46bd         	mov	sp, r7
 801ae92: bd80         	pop	{r7, pc}

0801ae94 <sys_heap_free>:
; {
 801ae94: b580         	push	{r7, lr}
 801ae96: b084         	sub	sp, #0x10
 801ae98: af00         	add	r7, sp, #0x0
 801ae9a: 6078         	str	r0, [r7, #0x4]
 801ae9c: 6039         	str	r1, [r7]
; 	if (mem == NULL) {
 801ae9e: 683b         	ldr	r3, [r7]
 801aea0: 2b00         	cmp	r3, #0x0
 801aea2: d011         	beq	0x801aec8 <sys_heap_free+0x34> @ imm = #0x22
; 	struct z_heap *h = heap->heap;
 801aea4: 687b         	ldr	r3, [r7, #0x4]
 801aea6: 681b         	ldr	r3, [r3]
 801aea8: 60fb         	str	r3, [r7, #0xc]
; 	chunkid_t c = mem_to_chunkid(h, mem);
 801aeaa: 6839         	ldr	r1, [r7]
 801aeac: 68f8         	ldr	r0, [r7, #0xc]
 801aeae: f7ff ffd8    	bl	0x801ae62 <mem_to_chunkid> @ imm = #-0x50
 801aeb2: 60b8         	str	r0, [r7, #0x8]
; 	set_chunk_used(h, c, false);
 801aeb4: 2200         	movs	r2, #0x0
 801aeb6: 68b9         	ldr	r1, [r7, #0x8]
 801aeb8: 68f8         	ldr	r0, [r7, #0xc]
 801aeba: f7ff fced    	bl	0x801a898 <set_chunk_used> @ imm = #-0x626
; 	free_chunk(h, c);
 801aebe: 68b9         	ldr	r1, [r7, #0x8]
 801aec0: 68f8         	ldr	r0, [r7, #0xc]
 801aec2: f7ff ff78    	bl	0x801adb6 <free_chunk>  @ imm = #-0x110
 801aec6: e000         	b	0x801aeca <sys_heap_free+0x36> @ imm = #0x0
; 		return; /* ISO C free() semantics */
 801aec8: bf00         	nop
; }
 801aeca: 3710         	adds	r7, #0x10
 801aecc: 46bd         	mov	sp, r7
 801aece: bd80         	pop	{r7, pc}

0801aed0 <alloc_chunk>:
; {
 801aed0: b580         	push	{r7, lr}
 801aed2: b08a         	sub	sp, #0x28
 801aed4: af00         	add	r7, sp, #0x0
 801aed6: 6078         	str	r0, [r7, #0x4]
 801aed8: 6039         	str	r1, [r7]
; 	int bi = bucket_idx(h, sz);
 801aeda: 6839         	ldr	r1, [r7]
 801aedc: 6878         	ldr	r0, [r7, #0x4]
 801aede: f7ff fe0b    	bl	0x801aaf8 <bucket_idx>  @ imm = #-0x3ea
 801aee2: 6238         	str	r0, [r7, #0x20]
; 	struct z_heap_bucket *b = &h->buckets[bi];
 801aee4: 6a3b         	ldr	r3, [r7, #0x20]
 801aee6: 3304         	adds	r3, #0x4
 801aee8: 009b         	lsls	r3, r3, #0x2
 801aeea: 687a         	ldr	r2, [r7, #0x4]
 801aeec: 4413         	add	r3, r2
 801aeee: 61fb         	str	r3, [r7, #0x1c]
; 	if (b->next != 0U) {
 801aef0: 69fb         	ldr	r3, [r7, #0x1c]
 801aef2: 681b         	ldr	r3, [r3]
 801aef4: 2b00         	cmp	r3, #0x0
 801aef6: d028         	beq	0x801af4a <alloc_chunk+0x7a> @ imm = #0x50
; 		chunkid_t first = b->next;
 801aef8: 69fb         	ldr	r3, [r7, #0x1c]
 801aefa: 681b         	ldr	r3, [r3]
 801aefc: 61bb         	str	r3, [r7, #0x18]
; 		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
 801aefe: 2303         	movs	r3, #0x3
 801af00: 627b         	str	r3, [r7, #0x24]
; 			chunkid_t c = b->next;
 801af02: 69fb         	ldr	r3, [r7, #0x1c]
 801af04: 681b         	ldr	r3, [r3]
 801af06: 617b         	str	r3, [r7, #0x14]
; 			if (chunk_size(h, c) >= sz) {
 801af08: 6979         	ldr	r1, [r7, #0x14]
 801af0a: 6878         	ldr	r0, [r7, #0x4]
 801af0c: f7ff fcb4    	bl	0x801a878 <chunk_size>  @ imm = #-0x698
 801af10: 4602         	mov	r2, r0
 801af12: 683b         	ldr	r3, [r7]
 801af14: 4293         	cmp	r3, r2
 801af16: d806         	bhi	0x801af26 <alloc_chunk+0x56> @ imm = #0xc
; 				free_list_remove_bidx(h, c, bi);
 801af18: 6a3a         	ldr	r2, [r7, #0x20]
 801af1a: 6979         	ldr	r1, [r7, #0x14]
 801af1c: 6878         	ldr	r0, [r7, #0x4]
 801af1e: f7ff fe2d    	bl	0x801ab7c <free_list_remove_bidx> @ imm = #-0x3a6
; 				return c;
 801af22: 697b         	ldr	r3, [r7, #0x14]
 801af24: e032         	b	0x801af8c <alloc_chunk+0xbc> @ imm = #0x64
; 			b->next = next_free_chunk(h, c);
 801af26: 6979         	ldr	r1, [r7, #0x14]
 801af28: 6878         	ldr	r0, [r7, #0x4]
 801af2a: f7ff fd1a    	bl	0x801a962 <next_free_chunk> @ imm = #-0x5cc
 801af2e: 4602         	mov	r2, r0
 801af30: 69fb         	ldr	r3, [r7, #0x1c]
 801af32: 601a         	str	r2, [r3]
; 		} while (--i && b->next != first);
 801af34: 6a7b         	ldr	r3, [r7, #0x24]
 801af36: 3b01         	subs	r3, #0x1
 801af38: 627b         	str	r3, [r7, #0x24]
 801af3a: 6a7b         	ldr	r3, [r7, #0x24]
 801af3c: 2b00         	cmp	r3, #0x0
 801af3e: d004         	beq	0x801af4a <alloc_chunk+0x7a> @ imm = #0x8
 801af40: 69fb         	ldr	r3, [r7, #0x1c]
 801af42: 681b         	ldr	r3, [r3]
 801af44: 69ba         	ldr	r2, [r7, #0x18]
 801af46: 429a         	cmp	r2, r3
 801af48: d1db         	bne	0x801af02 <alloc_chunk+0x32> @ imm = #-0x4a
; 	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
 801af4a: 687b         	ldr	r3, [r7, #0x4]
 801af4c: 68da         	ldr	r2, [r3, #0xc]
 801af4e: 6a3b         	ldr	r3, [r7, #0x20]
 801af50: 3301         	adds	r3, #0x1
 801af52: 2101         	movs	r1, #0x1
 801af54: fa01 f303    	lsl.w	r3, r1, r3
 801af58: 425b         	rsbs	r3, r3, #0
 801af5a: 4013         	ands	r3, r2
 801af5c: 613b         	str	r3, [r7, #0x10]
; 	if (bmask != 0U) {
 801af5e: 693b         	ldr	r3, [r7, #0x10]
 801af60: 2b00         	cmp	r3, #0x0
 801af62: d012         	beq	0x801af8a <alloc_chunk+0xba> @ imm = #0x24
; 		int minbucket = __builtin_ctz(bmask);
 801af64: 693b         	ldr	r3, [r7, #0x10]
 801af66: fa93 f3a3    	rbit	r3, r3
 801af6a: fab3 f383    	clz	r3, r3
 801af6e: 60fb         	str	r3, [r7, #0xc]
; 		chunkid_t c = h->buckets[minbucket].next;
 801af70: 687b         	ldr	r3, [r7, #0x4]
 801af72: 68fa         	ldr	r2, [r7, #0xc]
 801af74: 3204         	adds	r2, #0x4
 801af76: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 801af7a: 60bb         	str	r3, [r7, #0x8]
; 		free_list_remove_bidx(h, c, minbucket);
 801af7c: 68fa         	ldr	r2, [r7, #0xc]
 801af7e: 68b9         	ldr	r1, [r7, #0x8]
 801af80: 6878         	ldr	r0, [r7, #0x4]
 801af82: f7ff fdfb    	bl	0x801ab7c <free_list_remove_bidx> @ imm = #-0x40a
; 		return c;
 801af86: 68bb         	ldr	r3, [r7, #0x8]
 801af88: e000         	b	0x801af8c <alloc_chunk+0xbc> @ imm = #0x0
; 	return 0;
 801af8a: 2300         	movs	r3, #0x0
; }
 801af8c: 4618         	mov	r0, r3
 801af8e: 3728         	adds	r7, #0x28
 801af90: 46bd         	mov	sp, r7
 801af92: bd80         	pop	{r7, pc}

0801af94 <sys_heap_alloc>:
; {
 801af94: b580         	push	{r7, lr}
 801af96: b086         	sub	sp, #0x18
 801af98: af00         	add	r7, sp, #0x0
 801af9a: 6078         	str	r0, [r7, #0x4]
 801af9c: 6039         	str	r1, [r7]
; 	struct z_heap *h = heap->heap;
 801af9e: 687b         	ldr	r3, [r7, #0x4]
 801afa0: 681b         	ldr	r3, [r3]
 801afa2: 617b         	str	r3, [r7, #0x14]
; 	if ((bytes == 0U) || size_too_big(h, bytes)) {
 801afa4: 683b         	ldr	r3, [r7]
 801afa6: 2b00         	cmp	r3, #0x0
 801afa8: d006         	beq	0x801afb8 <sys_heap_alloc+0x24> @ imm = #0xc
 801afaa: 6839         	ldr	r1, [r7]
 801afac: 6978         	ldr	r0, [r7, #0x14]
 801afae: f7ff fdb9    	bl	0x801ab24 <size_too_big> @ imm = #-0x48e
 801afb2: 4603         	mov	r3, r0
 801afb4: 2b00         	cmp	r3, #0x0
 801afb6: d001         	beq	0x801afbc <sys_heap_alloc+0x28> @ imm = #0x2
; 		return NULL;
 801afb8: 2300         	movs	r3, #0x0
 801afba: e030         	b	0x801b01e <sys_heap_alloc+0x8a> @ imm = #0x60
; 	chunksz_t chunk_sz = bytes_to_chunksz(h, bytes);
 801afbc: 6839         	ldr	r1, [r7]
 801afbe: 6978         	ldr	r0, [r7, #0x14]
 801afc0: f7ff fd7a    	bl	0x801aab8 <bytes_to_chunksz> @ imm = #-0x50c
 801afc4: 6138         	str	r0, [r7, #0x10]
; 	chunkid_t c = alloc_chunk(h, chunk_sz);
 801afc6: 6939         	ldr	r1, [r7, #0x10]
 801afc8: 6978         	ldr	r0, [r7, #0x14]
 801afca: f7ff ff81    	bl	0x801aed0 <alloc_chunk> @ imm = #-0xfe
 801afce: 60f8         	str	r0, [r7, #0xc]
; 	if (c == 0U) {
 801afd0: 68fb         	ldr	r3, [r7, #0xc]
 801afd2: 2b00         	cmp	r3, #0x0
 801afd4: d101         	bne	0x801afda <sys_heap_alloc+0x46> @ imm = #0x2
; 		return NULL;
 801afd6: 2300         	movs	r3, #0x0
 801afd8: e021         	b	0x801b01e <sys_heap_alloc+0x8a> @ imm = #0x42
; 	if (chunk_size(h, c) > chunk_sz) {
 801afda: 68f9         	ldr	r1, [r7, #0xc]
 801afdc: 6978         	ldr	r0, [r7, #0x14]
 801afde: f7ff fc4b    	bl	0x801a878 <chunk_size>  @ imm = #-0x76a
 801afe2: 4602         	mov	r2, r0
 801afe4: 693b         	ldr	r3, [r7, #0x10]
 801afe6: 4293         	cmp	r3, r2
 801afe8: d20e         	bhs	0x801b008 <sys_heap_alloc+0x74> @ imm = #0x1c
; 		split_chunks(h, c, c + chunk_sz);
 801afea: 68fa         	ldr	r2, [r7, #0xc]
 801afec: 693b         	ldr	r3, [r7, #0x10]
 801afee: 4413         	add	r3, r2
 801aff0: 461a         	mov	r2, r3
 801aff2: 68f9         	ldr	r1, [r7, #0xc]
 801aff4: 6978         	ldr	r0, [r7, #0x14]
 801aff6: f7ff fe89    	bl	0x801ad0c <split_chunks> @ imm = #-0x2ee
; 		free_list_add(h, c + chunk_sz);
 801affa: 68fa         	ldr	r2, [r7, #0xc]
 801affc: 693b         	ldr	r3, [r7, #0x10]
 801affe: 4413         	add	r3, r2
 801b000: 4619         	mov	r1, r3
 801b002: 6978         	ldr	r0, [r7, #0x14]
 801b004: f7ff fe60    	bl	0x801acc8 <free_list_add> @ imm = #-0x340
; 	set_chunk_used(h, c, true);
 801b008: 2201         	movs	r2, #0x1
 801b00a: 68f9         	ldr	r1, [r7, #0xc]
 801b00c: 6978         	ldr	r0, [r7, #0x14]
 801b00e: f7ff fc43    	bl	0x801a898 <set_chunk_used> @ imm = #-0x77a
; 	mem = chunk_mem(h, c);
 801b012: 68f9         	ldr	r1, [r7, #0xc]
 801b014: 6978         	ldr	r0, [r7, #0x14]
 801b016: f7ff fd99    	bl	0x801ab4c <chunk_mem>   @ imm = #-0x4ce
 801b01a: 60b8         	str	r0, [r7, #0x8]
; 	return mem;
 801b01c: 68bb         	ldr	r3, [r7, #0x8]
; }
 801b01e: 4618         	mov	r0, r3
 801b020: 3718         	adds	r7, #0x18
 801b022: 46bd         	mov	sp, r7
 801b024: bd80         	pop	{r7, pc}

0801b026 <sys_heap_aligned_alloc>:
; {
 801b026: b580         	push	{r7, lr}
 801b028: b08e         	sub	sp, #0x38
 801b02a: af00         	add	r7, sp, #0x0
 801b02c: 60f8         	str	r0, [r7, #0xc]
 801b02e: 60b9         	str	r1, [r7, #0x8]
 801b030: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap *h = heap->heap;
 801b032: 68fb         	ldr	r3, [r7, #0xc]
 801b034: 681b         	ldr	r3, [r3]
 801b036: 62fb         	str	r3, [r7, #0x2c]
; 	rew = align & -align;
 801b038: 68bb         	ldr	r3, [r7, #0x8]
 801b03a: 425b         	rsbs	r3, r3, #0
 801b03c: 68ba         	ldr	r2, [r7, #0x8]
 801b03e: 4013         	ands	r3, r2
 801b040: 633b         	str	r3, [r7, #0x30]
; 	if (align != rew) {
 801b042: 68ba         	ldr	r2, [r7, #0x8]
 801b044: 6b3b         	ldr	r3, [r7, #0x30]
 801b046: 429a         	cmp	r2, r3
 801b048: d012         	beq	0x801b070 <sys_heap_aligned_alloc+0x4a> @ imm = #0x24
; 		align -= rew;
 801b04a: 68ba         	ldr	r2, [r7, #0x8]
 801b04c: 6b3b         	ldr	r3, [r7, #0x30]
 801b04e: 1ad3         	subs	r3, r2, r3
 801b050: 60bb         	str	r3, [r7, #0x8]
; 		gap = MIN(rew, chunk_header_bytes(h));
 801b052: 6af8         	ldr	r0, [r7, #0x2c]
 801b054: f7ff fd01    	bl	0x801aa5a <chunk_header_bytes> @ imm = #-0x5fe
 801b058: 4602         	mov	r2, r0
 801b05a: 6b3b         	ldr	r3, [r7, #0x30]
 801b05c: 4293         	cmp	r3, r2
 801b05e: d304         	blo	0x801b06a <sys_heap_aligned_alloc+0x44> @ imm = #0x8
 801b060: 6af8         	ldr	r0, [r7, #0x2c]
 801b062: f7ff fcfa    	bl	0x801aa5a <chunk_header_bytes> @ imm = #-0x60c
 801b066: 4603         	mov	r3, r0
 801b068: e000         	b	0x801b06c <sys_heap_aligned_alloc+0x46> @ imm = #0x0
 801b06a: 6b3b         	ldr	r3, [r7, #0x30]
 801b06c: 637b         	str	r3, [r7, #0x34]
 801b06e: e012         	b	0x801b096 <sys_heap_aligned_alloc+0x70> @ imm = #0x24
; 		if (align <= chunk_header_bytes(h)) {
 801b070: 6af8         	ldr	r0, [r7, #0x2c]
 801b072: f7ff fcf2    	bl	0x801aa5a <chunk_header_bytes> @ imm = #-0x61c
 801b076: 4602         	mov	r2, r0
 801b078: 68bb         	ldr	r3, [r7, #0x8]
 801b07a: 4293         	cmp	r3, r2
 801b07c: d805         	bhi	0x801b08a <sys_heap_aligned_alloc+0x64> @ imm = #0xa
; 			return sys_heap_alloc(heap, bytes);
 801b07e: 6879         	ldr	r1, [r7, #0x4]
 801b080: 68f8         	ldr	r0, [r7, #0xc]
 801b082: f7ff ff87    	bl	0x801af94 <sys_heap_alloc> @ imm = #-0xf2
 801b086: 4603         	mov	r3, r0
 801b088: e072         	b	0x801b170 <sys_heap_aligned_alloc+0x14a> @ imm = #0xe4
; 		rew = 0;
 801b08a: 2300         	movs	r3, #0x0
 801b08c: 633b         	str	r3, [r7, #0x30]
; 		gap = chunk_header_bytes(h);
 801b08e: 6af8         	ldr	r0, [r7, #0x2c]
 801b090: f7ff fce3    	bl	0x801aa5a <chunk_header_bytes> @ imm = #-0x63a
 801b094: 6378         	str	r0, [r7, #0x34]
; 	if ((bytes == 0) || size_too_big(h, bytes)) {
 801b096: 687b         	ldr	r3, [r7, #0x4]
 801b098: 2b00         	cmp	r3, #0x0
 801b09a: d006         	beq	0x801b0aa <sys_heap_aligned_alloc+0x84> @ imm = #0xc
 801b09c: 6879         	ldr	r1, [r7, #0x4]
 801b09e: 6af8         	ldr	r0, [r7, #0x2c]
 801b0a0: f7ff fd40    	bl	0x801ab24 <size_too_big> @ imm = #-0x580
 801b0a4: 4603         	mov	r3, r0
 801b0a6: 2b00         	cmp	r3, #0x0
 801b0a8: d001         	beq	0x801b0ae <sys_heap_aligned_alloc+0x88> @ imm = #0x2
; 		return NULL;
 801b0aa: 2300         	movs	r3, #0x0
 801b0ac: e060         	b	0x801b170 <sys_heap_aligned_alloc+0x14a> @ imm = #0xc0
; 	chunksz_t padded_sz = bytes_to_chunksz(h, bytes + align - gap);
 801b0ae: 687a         	ldr	r2, [r7, #0x4]
 801b0b0: 68bb         	ldr	r3, [r7, #0x8]
 801b0b2: 441a         	add	r2, r3
 801b0b4: 6b7b         	ldr	r3, [r7, #0x34]
 801b0b6: 1ad3         	subs	r3, r2, r3
 801b0b8: 4619         	mov	r1, r3
 801b0ba: 6af8         	ldr	r0, [r7, #0x2c]
 801b0bc: f7ff fcfc    	bl	0x801aab8 <bytes_to_chunksz> @ imm = #-0x608
 801b0c0: 62b8         	str	r0, [r7, #0x28]
; 	chunkid_t c0 = alloc_chunk(h, padded_sz);
 801b0c2: 6ab9         	ldr	r1, [r7, #0x28]
 801b0c4: 6af8         	ldr	r0, [r7, #0x2c]
 801b0c6: f7ff ff03    	bl	0x801aed0 <alloc_chunk> @ imm = #-0x1fa
 801b0ca: 6278         	str	r0, [r7, #0x24]
; 	if (c0 == 0) {
 801b0cc: 6a7b         	ldr	r3, [r7, #0x24]
 801b0ce: 2b00         	cmp	r3, #0x0
 801b0d0: d101         	bne	0x801b0d6 <sys_heap_aligned_alloc+0xb0> @ imm = #0x2
; 		return NULL;
 801b0d2: 2300         	movs	r3, #0x0
 801b0d4: e04c         	b	0x801b170 <sys_heap_aligned_alloc+0x14a> @ imm = #0x98
; 	uint8_t *mem = chunk_mem(h, c0);
 801b0d6: 6a79         	ldr	r1, [r7, #0x24]
 801b0d8: 6af8         	ldr	r0, [r7, #0x2c]
 801b0da: f7ff fd37    	bl	0x801ab4c <chunk_mem>   @ imm = #-0x592
 801b0de: 6238         	str	r0, [r7, #0x20]
; 	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
 801b0e0: 6a3a         	ldr	r2, [r7, #0x20]
 801b0e2: 6b3b         	ldr	r3, [r7, #0x30]
 801b0e4: 4413         	add	r3, r2
 801b0e6: 461a         	mov	r2, r3
 801b0e8: 68bb         	ldr	r3, [r7, #0x8]
 801b0ea: 4413         	add	r3, r2
 801b0ec: 1e5a         	subs	r2, r3, #0x1
 801b0ee: 68bb         	ldr	r3, [r7, #0x8]
 801b0f0: fbb2 f3f3    	udiv	r3, r2, r3
 801b0f4: 68ba         	ldr	r2, [r7, #0x8]
 801b0f6: fb03 f202    	mul	r2, r3, r2
 801b0fa: 6b3b         	ldr	r3, [r7, #0x30]
 801b0fc: 1ad3         	subs	r3, r2, r3
 801b0fe: 623b         	str	r3, [r7, #0x20]
; 	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
 801b100: 6a3a         	ldr	r2, [r7, #0x20]
 801b102: 687b         	ldr	r3, [r7, #0x4]
 801b104: 4413         	add	r3, r2
 801b106: 3307         	adds	r3, #0x7
 801b108: f023 0307    	bic	r3, r3, #0x7
 801b10c: 61fb         	str	r3, [r7, #0x1c]
; 	chunkid_t c = mem_to_chunkid(h, mem);
 801b10e: 6a39         	ldr	r1, [r7, #0x20]
 801b110: 6af8         	ldr	r0, [r7, #0x2c]
 801b112: f7ff fea6    	bl	0x801ae62 <mem_to_chunkid> @ imm = #-0x2b4
 801b116: 61b8         	str	r0, [r7, #0x18]
; 	chunkid_t c_end = end - chunk_buf(h);
 801b118: 6af8         	ldr	r0, [r7, #0x2c]
 801b11a: f7ff fb3e    	bl	0x801a79a <chunk_buf>   @ imm = #-0x984
 801b11e: 4602         	mov	r2, r0
 801b120: 69fb         	ldr	r3, [r7, #0x1c]
 801b122: 1a9b         	subs	r3, r3, r2
 801b124: 10db         	asrs	r3, r3, #0x3
 801b126: 617b         	str	r3, [r7, #0x14]
; 	if (c > c0) {
 801b128: 69ba         	ldr	r2, [r7, #0x18]
 801b12a: 6a7b         	ldr	r3, [r7, #0x24]
 801b12c: 429a         	cmp	r2, r3
 801b12e: d908         	bls	0x801b142 <sys_heap_aligned_alloc+0x11c> @ imm = #0x10
; 		split_chunks(h, c0, c);
 801b130: 69ba         	ldr	r2, [r7, #0x18]
 801b132: 6a79         	ldr	r1, [r7, #0x24]
 801b134: 6af8         	ldr	r0, [r7, #0x2c]
 801b136: f7ff fde9    	bl	0x801ad0c <split_chunks> @ imm = #-0x42e
; 		free_list_add(h, c0);
 801b13a: 6a79         	ldr	r1, [r7, #0x24]
 801b13c: 6af8         	ldr	r0, [r7, #0x2c]
 801b13e: f7ff fdc3    	bl	0x801acc8 <free_list_add> @ imm = #-0x47a
; 	if (right_chunk(h, c) > c_end) {
 801b142: 69b9         	ldr	r1, [r7, #0x18]
 801b144: 6af8         	ldr	r0, [r7, #0x2c]
 801b146: f7ff fc4c    	bl	0x801a9e2 <right_chunk> @ imm = #-0x768
 801b14a: 4602         	mov	r2, r0
 801b14c: 697b         	ldr	r3, [r7, #0x14]
 801b14e: 4293         	cmp	r3, r2
 801b150: d208         	bhs	0x801b164 <sys_heap_aligned_alloc+0x13e> @ imm = #0x10
; 		split_chunks(h, c, c_end);
 801b152: 697a         	ldr	r2, [r7, #0x14]
 801b154: 69b9         	ldr	r1, [r7, #0x18]
 801b156: 6af8         	ldr	r0, [r7, #0x2c]
 801b158: f7ff fdd8    	bl	0x801ad0c <split_chunks> @ imm = #-0x450
; 		free_list_add(h, c_end);
 801b15c: 6979         	ldr	r1, [r7, #0x14]
 801b15e: 6af8         	ldr	r0, [r7, #0x2c]
 801b160: f7ff fdb2    	bl	0x801acc8 <free_list_add> @ imm = #-0x49c
; 	set_chunk_used(h, c, true);
 801b164: 2201         	movs	r2, #0x1
 801b166: 69b9         	ldr	r1, [r7, #0x18]
 801b168: 6af8         	ldr	r0, [r7, #0x2c]
 801b16a: f7ff fb95    	bl	0x801a898 <set_chunk_used> @ imm = #-0x8d6
; 	return mem;
 801b16e: 6a3b         	ldr	r3, [r7, #0x20]
; }
 801b170: 4618         	mov	r0, r3
 801b172: 3738         	adds	r7, #0x38
 801b174: 46bd         	mov	sp, r7
 801b176: bd80         	pop	{r7, pc}

0801b178 <sys_heap_init>:
; {
 801b178: b580         	push	{r7, lr}
 801b17a: b08c         	sub	sp, #0x30
 801b17c: af00         	add	r7, sp, #0x0
 801b17e: 60f8         	str	r0, [r7, #0xc]
 801b180: 60b9         	str	r1, [r7, #0x8]
 801b182: 607a         	str	r2, [r7, #0x4]
; 	bytes -= heap_footer_bytes(bytes);
 801b184: 6878         	ldr	r0, [r7, #0x4]
 801b186: f7ff fc79    	bl	0x801aa7c <heap_footer_bytes> @ imm = #-0x70e
 801b18a: 4602         	mov	r2, r0
 801b18c: 687b         	ldr	r3, [r7, #0x4]
 801b18e: 1a9b         	subs	r3, r3, r2
 801b190: 607b         	str	r3, [r7, #0x4]
; 	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 801b192: 68bb         	ldr	r3, [r7, #0x8]
 801b194: 3307         	adds	r3, #0x7
 801b196: f023 0307    	bic	r3, r3, #0x7
 801b19a: 62bb         	str	r3, [r7, #0x28]
; 	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 801b19c: 68ba         	ldr	r2, [r7, #0x8]
 801b19e: 687b         	ldr	r3, [r7, #0x4]
 801b1a0: 4413         	add	r3, r2
 801b1a2: f023 0307    	bic	r3, r3, #0x7
 801b1a6: 627b         	str	r3, [r7, #0x24]
; 	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
 801b1a8: 6a7a         	ldr	r2, [r7, #0x24]
 801b1aa: 6abb         	ldr	r3, [r7, #0x28]
 801b1ac: 1ad3         	subs	r3, r2, r3
 801b1ae: 08db         	lsrs	r3, r3, #0x3
 801b1b0: 623b         	str	r3, [r7, #0x20]
; 	struct z_heap *h = (struct z_heap *)addr;
 801b1b2: 6abb         	ldr	r3, [r7, #0x28]
 801b1b4: 61fb         	str	r3, [r7, #0x1c]
; 	heap->heap = h;
 801b1b6: 68fb         	ldr	r3, [r7, #0xc]
 801b1b8: 69fa         	ldr	r2, [r7, #0x1c]
 801b1ba: 601a         	str	r2, [r3]
; 	h->end_chunk = heap_sz;
 801b1bc: 69fb         	ldr	r3, [r7, #0x1c]
 801b1be: 6a3a         	ldr	r2, [r7, #0x20]
 801b1c0: 609a         	str	r2, [r3, #0x8]
; 	h->avail_buckets = 0;
 801b1c2: 69fb         	ldr	r3, [r7, #0x1c]
 801b1c4: 2200         	movs	r2, #0x0
 801b1c6: 60da         	str	r2, [r3, #0xc]
; 	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 801b1c8: 6a39         	ldr	r1, [r7, #0x20]
 801b1ca: 69f8         	ldr	r0, [r7, #0x1c]
 801b1cc: f7ff fc94    	bl	0x801aaf8 <bucket_idx>  @ imm = #-0x6d8
 801b1d0: 4603         	mov	r3, r0
 801b1d2: 3301         	adds	r3, #0x1
 801b1d4: 61bb         	str	r3, [r7, #0x18]
; 	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 801b1d6: 69bb         	ldr	r3, [r7, #0x18]
 801b1d8: 3304         	adds	r3, #0x4
 801b1da: 009b         	lsls	r3, r3, #0x2
 801b1dc: 4618         	mov	r0, r3
 801b1de: f7ff fc5e    	bl	0x801aa9e <chunksz>     @ imm = #-0x744
 801b1e2: 6178         	str	r0, [r7, #0x14]
; 	for (int i = 0; i < nb_buckets; i++) {
 801b1e4: 2300         	movs	r3, #0x0
 801b1e6: 62fb         	str	r3, [r7, #0x2c]
 801b1e8: e008         	b	0x801b1fc <sys_heap_init+0x84> @ imm = #0x10
; 		h->buckets[i].next = 0;
 801b1ea: 69fb         	ldr	r3, [r7, #0x1c]
 801b1ec: 6afa         	ldr	r2, [r7, #0x2c]
 801b1ee: 3204         	adds	r2, #0x4
 801b1f0: 2100         	movs	r1, #0x0
 801b1f2: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 	for (int i = 0; i < nb_buckets; i++) {
 801b1f6: 6afb         	ldr	r3, [r7, #0x2c]
 801b1f8: 3301         	adds	r3, #0x1
 801b1fa: 62fb         	str	r3, [r7, #0x2c]
 801b1fc: 6afa         	ldr	r2, [r7, #0x2c]
 801b1fe: 69bb         	ldr	r3, [r7, #0x18]
 801b200: 429a         	cmp	r2, r3
 801b202: dbf2         	blt	0x801b1ea <sys_heap_init+0x72> @ imm = #-0x1c
; 	set_chunk_size(h, 0, chunk0_size);
 801b204: 697a         	ldr	r2, [r7, #0x14]
 801b206: 2100         	movs	r1, #0x0
 801b208: 69f8         	ldr	r0, [r7, #0x1c]
 801b20a: f7ff fb8a    	bl	0x801a922 <set_chunk_size> @ imm = #-0x8ec
; 	set_left_chunk_size(h, 0, 0);
 801b20e: 2200         	movs	r2, #0x0
 801b210: 2100         	movs	r1, #0x0
 801b212: 69f8         	ldr	r0, [r7, #0x1c]
 801b214: f7ff fbf5    	bl	0x801aa02 <set_left_chunk_size> @ imm = #-0x816
; 	set_chunk_used(h, 0, true);
 801b218: 2201         	movs	r2, #0x1
 801b21a: 2100         	movs	r1, #0x0
 801b21c: 69f8         	ldr	r0, [r7, #0x1c]
 801b21e: f7ff fb3b    	bl	0x801a898 <set_chunk_used> @ imm = #-0x98a
; 	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
 801b222: 6a3a         	ldr	r2, [r7, #0x20]
 801b224: 697b         	ldr	r3, [r7, #0x14]
 801b226: 1ad3         	subs	r3, r2, r3
 801b228: 461a         	mov	r2, r3
 801b22a: 6979         	ldr	r1, [r7, #0x14]
 801b22c: 69f8         	ldr	r0, [r7, #0x1c]
 801b22e: f7ff fb78    	bl	0x801a922 <set_chunk_size> @ imm = #-0x910
; 	set_left_chunk_size(h, chunk0_size, chunk0_size);
 801b232: 697a         	ldr	r2, [r7, #0x14]
 801b234: 6979         	ldr	r1, [r7, #0x14]
 801b236: 69f8         	ldr	r0, [r7, #0x1c]
 801b238: f7ff fbe3    	bl	0x801aa02 <set_left_chunk_size> @ imm = #-0x83a
; 	set_chunk_size(h, heap_sz, 0);
 801b23c: 2200         	movs	r2, #0x0
 801b23e: 6a39         	ldr	r1, [r7, #0x20]
 801b240: 69f8         	ldr	r0, [r7, #0x1c]
 801b242: f7ff fb6e    	bl	0x801a922 <set_chunk_size> @ imm = #-0x924
; 	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
 801b246: 6a3a         	ldr	r2, [r7, #0x20]
 801b248: 697b         	ldr	r3, [r7, #0x14]
 801b24a: 1ad3         	subs	r3, r2, r3
 801b24c: 461a         	mov	r2, r3
 801b24e: 6a39         	ldr	r1, [r7, #0x20]
 801b250: 69f8         	ldr	r0, [r7, #0x1c]
 801b252: f7ff fbd6    	bl	0x801aa02 <set_left_chunk_size> @ imm = #-0x854
; 	set_chunk_used(h, heap_sz, true);
 801b256: 2201         	movs	r2, #0x1
 801b258: 6a39         	ldr	r1, [r7, #0x20]
 801b25a: 69f8         	ldr	r0, [r7, #0x1c]
 801b25c: f7ff fb1c    	bl	0x801a898 <set_chunk_used> @ imm = #-0x9c8
; 	free_list_add(h, chunk0_size);
 801b260: 6979         	ldr	r1, [r7, #0x14]
 801b262: 69f8         	ldr	r0, [r7, #0x1c]
 801b264: f7ff fd30    	bl	0x801acc8 <free_list_add> @ imm = #-0x5a0
; }
 801b268: bf00         	nop
 801b26a: 3730         	adds	r7, #0x30
 801b26c: 46bd         	mov	sp, r7
 801b26e: bd80         	pop	{r7, pc}

0801b270 <ptr_in_rodata>:
; {
 801b270: b580         	push	{r7, lr}
 801b272: b082         	sub	sp, #0x8
 801b274: af00         	add	r7, sp, #0x0
 801b276: 6078         	str	r0, [r7, #0x4]
; 	return linker_is_in_rodata(addr);
 801b278: 6878         	ldr	r0, [r7, #0x4]
 801b27a: f7e8 fbe7    	bl	0x8003a4c <linker_is_in_rodata> @ imm = #-0x17832
 801b27e: 4603         	mov	r3, r0
; }
 801b280: 4618         	mov	r0, r3
 801b282: 3708         	adds	r7, #0x8
 801b284: 46bd         	mov	sp, r7
 801b286: bd80         	pop	{r7, pc}

0801b288 <cbprintf_via_va_list>:
; {
 801b288: b590         	push	{r4, r7, lr}
 801b28a: b087         	sub	sp, #0x1c
 801b28c: af00         	add	r7, sp, #0x0
 801b28e: 60f8         	str	r0, [r7, #0xc]
 801b290: 60b9         	str	r1, [r7, #0x8]
 801b292: 607a         	str	r2, [r7, #0x4]
 801b294: 603b         	str	r3, [r7]
; 	u.ptr = buf;
 801b296: 6abb         	ldr	r3, [r7, #0x28]
 801b298: 617b         	str	r3, [r7, #0x14]
; 	return formatter(out, ctx, fmt, u.ap);
 801b29a: 68bc         	ldr	r4, [r7, #0x8]
 801b29c: 697b         	ldr	r3, [r7, #0x14]
 801b29e: 683a         	ldr	r2, [r7]
 801b2a0: 6879         	ldr	r1, [r7, #0x4]
 801b2a2: 68f8         	ldr	r0, [r7, #0xc]
 801b2a4: 47a0         	blx	r4
 801b2a6: 4603         	mov	r3, r0
; }
 801b2a8: 4618         	mov	r0, r3
 801b2aa: 371c         	adds	r7, #0x1c
 801b2ac: 46bd         	mov	sp, r7
 801b2ae: bd90         	pop	{r4, r7, pc}

0801b2b0 <cbpprintf_external>:
; {
 801b2b0: b580         	push	{r7, lr}
 801b2b2: b090         	sub	sp, #0x40
 801b2b4: af02         	add	r7, sp, #0x8
 801b2b6: 60f8         	str	r0, [r7, #0xc]
 801b2b8: 60b9         	str	r1, [r7, #0x8]
 801b2ba: 607a         	str	r2, [r7, #0x4]
 801b2bc: 603b         	str	r3, [r7]
; 	uint8_t *buf = packaged;
 801b2be: 683b         	ldr	r3, [r7]
 801b2c0: 62fb         	str	r3, [r7, #0x2c]
; 	struct cbprintf_package_hdr_ext *hdr = packaged;
 801b2c2: 683b         	ldr	r3, [r7]
 801b2c4: 62bb         	str	r3, [r7, #0x28]
; 	if (buf == NULL) {
 801b2c6: 6afb         	ldr	r3, [r7, #0x2c]
 801b2c8: 2b00         	cmp	r3, #0x0
 801b2ca: d102         	bne	0x801b2d2 <cbpprintf_external+0x22> @ imm = #0x4
; 		return -EINVAL;
 801b2cc: f06f 0315    	mvn	r3, #0x15
 801b2d0: e043         	b	0x801b35a <cbpprintf_external+0xaa> @ imm = #0x86
; 	args_size = hdr->hdr.desc.len * sizeof(int);
 801b2d2: 6abb         	ldr	r3, [r7, #0x28]
 801b2d4: 781b         	ldrb	r3, [r3]
 801b2d6: 009b         	lsls	r3, r3, #0x2
 801b2d8: 627b         	str	r3, [r7, #0x24]
; 	s_nbr     = hdr->hdr.desc.str_cnt;
 801b2da: 6abb         	ldr	r3, [r7, #0x28]
 801b2dc: 785b         	ldrb	r3, [r3, #0x1]
 801b2de: 623b         	str	r3, [r7, #0x20]
; 	ros_nbr   = hdr->hdr.desc.ro_str_cnt;
 801b2e0: 6abb         	ldr	r3, [r7, #0x28]
 801b2e2: 789b         	ldrb	r3, [r3, #0x2]
 801b2e4: 61fb         	str	r3, [r7, #0x1c]
; 	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
 801b2e6: 6abb         	ldr	r3, [r7, #0x28]
 801b2e8: 78db         	ldrb	r3, [r3, #0x3]
 801b2ea: 61bb         	str	r3, [r7, #0x18]
; 	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
 801b2ec: 6a7a         	ldr	r2, [r7, #0x24]
 801b2ee: 69fb         	ldr	r3, [r7, #0x1c]
 801b2f0: 441a         	add	r2, r3
 801b2f2: 69bb         	ldr	r3, [r7, #0x18]
 801b2f4: 005b         	lsls	r3, r3, #0x1
 801b2f6: 4413         	add	r3, r2
 801b2f8: 6afa         	ldr	r2, [r7, #0x2c]
 801b2fa: 4413         	add	r3, r2
 801b2fc: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 801b2fe: 2300         	movs	r3, #0x0
 801b300: 633b         	str	r3, [r7, #0x30]
 801b302: e018         	b	0x801b336 <cbpprintf_external+0x86> @ imm = #0x30
; 		s_idx = *(uint8_t *)s;
 801b304: 6b7b         	ldr	r3, [r7, #0x34]
 801b306: 781b         	ldrb	r3, [r3]
 801b308: 617b         	str	r3, [r7, #0x14]
; 		++s;
 801b30a: 6b7b         	ldr	r3, [r7, #0x34]
 801b30c: 3301         	adds	r3, #0x1
 801b30e: 637b         	str	r3, [r7, #0x34]
; 		ps = (char **)(buf + s_idx * sizeof(int));
 801b310: 697b         	ldr	r3, [r7, #0x14]
 801b312: 009b         	lsls	r3, r3, #0x2
 801b314: 6afa         	ldr	r2, [r7, #0x2c]
 801b316: 4413         	add	r3, r2
 801b318: 613b         	str	r3, [r7, #0x10]
; 		*ps = s;
 801b31a: 693b         	ldr	r3, [r7, #0x10]
 801b31c: 6b7a         	ldr	r2, [r7, #0x34]
 801b31e: 601a         	str	r2, [r3]
; 		s += strlen(s) + 1;
 801b320: 6b78         	ldr	r0, [r7, #0x34]
 801b322: f7e5 f9b1    	bl	0x8000688 <strlen>      @ imm = #-0x1ac9e
 801b326: 4603         	mov	r3, r0
 801b328: 3301         	adds	r3, #0x1
 801b32a: 6b7a         	ldr	r2, [r7, #0x34]
 801b32c: 4413         	add	r3, r2
 801b32e: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 801b330: 6b3b         	ldr	r3, [r7, #0x30]
 801b332: 3301         	adds	r3, #0x1
 801b334: 633b         	str	r3, [r7, #0x30]
 801b336: 6b3a         	ldr	r2, [r7, #0x30]
 801b338: 6a3b         	ldr	r3, [r7, #0x20]
 801b33a: 429a         	cmp	r2, r3
 801b33c: d3e2         	blo	0x801b304 <cbpprintf_external+0x54> @ imm = #-0x3c
; 	buf += sizeof(*hdr);
 801b33e: 6afb         	ldr	r3, [r7, #0x2c]
 801b340: 3308         	adds	r3, #0x8
 801b342: 62fb         	str	r3, [r7, #0x2c]
; 	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
 801b344: 6abb         	ldr	r3, [r7, #0x28]
 801b346: 685a         	ldr	r2, [r3, #0x4]
 801b348: 6afb         	ldr	r3, [r7, #0x2c]
 801b34a: 9300         	str	r3, [sp]
 801b34c: 4613         	mov	r3, r2
 801b34e: 687a         	ldr	r2, [r7, #0x4]
 801b350: 68b9         	ldr	r1, [r7, #0x8]
 801b352: 68f8         	ldr	r0, [r7, #0xc]
 801b354: f7ff ff98    	bl	0x801b288 <cbprintf_via_va_list> @ imm = #-0xd0
 801b358: 4603         	mov	r3, r0
; }
 801b35a: 4618         	mov	r0, r3
 801b35c: 3738         	adds	r7, #0x38
 801b35e: 46bd         	mov	sp, r7
 801b360: bd80         	pop	{r7, pc}

0801b362 <arch_printk_char_out>:
; {
 801b362: b480         	push	{r7}
 801b364: b083         	sub	sp, #0xc
 801b366: af00         	add	r7, sp, #0x0
 801b368: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801b36a: 2300         	movs	r3, #0x0
; }
 801b36c: 4618         	mov	r0, r3
 801b36e: 370c         	adds	r7, #0xc
 801b370: 46bd         	mov	sp, r7
 801b372: f85d 7b04    	ldr	r7, [sp], #4
 801b376: 4770         	bx	lr

0801b378 <vprintk>:
; {
 801b378: b580         	push	{r7, lr}
 801b37a: b08c         	sub	sp, #0x30
 801b37c: af00         	add	r7, sp, #0x0
 801b37e: 6078         	str	r0, [r7, #0x4]
 801b380: 6039         	str	r1, [r7]
; 		z_log_vprintk(fmt, ap);
 801b382: 6839         	ldr	r1, [r7]
 801b384: 6878         	ldr	r0, [r7, #0x4]
 801b386: f000 f99b    	bl	0x801b6c0 <z_log_vprintk> @ imm = #0x336
; 		return;
 801b38a: bf00         	nop
; }
 801b38c: 3730         	adds	r7, #0x30
 801b38e: 46bd         	mov	sp, r7
 801b390: bd80         	pop	{r7, pc}

0801b392 <printk>:
; {
 801b392: b40f         	push	{r0, r1, r2, r3}
 801b394: b580         	push	{r7, lr}
 801b396: b082         	sub	sp, #0x8
 801b398: af00         	add	r7, sp, #0x0
; 	va_start(ap, fmt);
 801b39a: f107 0314    	add.w	r3, r7, #0x14
 801b39e: 607b         	str	r3, [r7, #0x4]
; 	vprintk(fmt, ap);
 801b3a0: 6879         	ldr	r1, [r7, #0x4]
 801b3a2: 6938         	ldr	r0, [r7, #0x10]
 801b3a4: f7ff ffe8    	bl	0x801b378 <vprintk>     @ imm = #-0x30
; }
 801b3a8: bf00         	nop
 801b3aa: 3708         	adds	r7, #0x8
 801b3ac: 46bd         	mov	sp, r7
 801b3ae: e8bd 4080    	pop.w	{r7, lr}
 801b3b2: b004         	add	sp, #0x10
 801b3b4: 4770         	bx	lr

0801b3b6 <k_sched_current_thread_query>:
; {
 801b3b6: b580         	push	{r7, lr}
 801b3b8: af00         	add	r7, sp, #0x0
; 	return z_impl_k_sched_current_thread_query();
 801b3ba: f7fa ffdb    	bl	0x8016374 <z_impl_k_sched_current_thread_query> @ imm = #-0x504a
 801b3be: 4603         	mov	r3, r0
; }
 801b3c0: 4618         	mov	r0, r3
 801b3c2: bd80         	pop	{r7, pc}

0801b3c4 <k_thread_abort>:
; {
 801b3c4: b580         	push	{r7, lr}
 801b3c6: b082         	sub	sp, #0x8
 801b3c8: af00         	add	r7, sp, #0x0
 801b3ca: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 801b3cc: 6878         	ldr	r0, [r7, #0x4]
 801b3ce: f7ea ffdf    	bl	0x8006390 <z_impl_k_thread_abort> @ imm = #-0x15042
; }
 801b3d2: bf00         	nop
 801b3d4: 3708         	adds	r7, #0x8
 801b3d6: 46bd         	mov	sp, r7
 801b3d8: bd80         	pop	{r7, pc}

0801b3da <_ConfigAbsSyms>:
; GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
 801b3da: b480         	push	{r7}
 801b3dc: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 801b3de: bf00         	nop
 801b3e0: 46bd         	mov	sp, r7
 801b3e2: f85d 7b04    	ldr	r7, [sp], #4
 801b3e6: 4770         	bx	lr

0801b3e8 <st_stm32_common_config>:
; {
 801b3e8: b580         	push	{r7, lr}
 801b3ea: af00         	add	r7, sp, #0x0
; 	LL_DBGMCU_DisableDBGStopMode();
 801b3ec: f7e8 ff5e    	bl	0x80042ac <LL_DBGMCU_DisableDBGStopMode> @ imm = #-0x17144
; 	return 0;
 801b3f0: 2300         	movs	r3, #0x0
; }
 801b3f2: 4618         	mov	r0, r3
 801b3f4: bd80         	pop	{r7, pc}

0801b3f6 <K_KERNEL_STACK_BUFFER>:
; {
 801b3f6: b480         	push	{r7}
 801b3f8: b083         	sub	sp, #0xc
 801b3fa: af00         	add	r7, sp, #0x0
 801b3fc: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 801b3fe: 687b         	ldr	r3, [r7, #0x4]
; }
 801b400: 4618         	mov	r0, r3
 801b402: 370c         	adds	r7, #0xc
 801b404: 46bd         	mov	sp, r7
 801b406: f85d 7b04    	ldr	r7, [sp], #4
 801b40a: 4770         	bx	lr

0801b40c <k_thread_stack_space_get>:
; {
 801b40c: b580         	push	{r7, lr}
 801b40e: b082         	sub	sp, #0x8
 801b410: af00         	add	r7, sp, #0x0
 801b412: 6078         	str	r0, [r7, #0x4]
 801b414: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_stack_space_get(thread, unused_ptr);
 801b416: 6839         	ldr	r1, [r7]
 801b418: 6878         	ldr	r0, [r7, #0x4]
 801b41a: f00a ff83    	bl	0x8026324 <z_impl_k_thread_stack_space_get> @ imm = #0xaf06
 801b41e: 4603         	mov	r3, r0
; }
 801b420: 4618         	mov	r0, r3
 801b422: 3708         	adds	r7, #0x8
 801b424: 46bd         	mov	sp, r7
 801b426: bd80         	pop	{r7, pc}

0801b428 <z_log_msg_runtime_create>:
; {
 801b428: b580         	push	{r7, lr}
 801b42a: b08a         	sub	sp, #0x28
 801b42c: af04         	add	r7, sp, #0x10
 801b42e: 60b9         	str	r1, [r7, #0x8]
 801b430: 607b         	str	r3, [r7, #0x4]
 801b432: 4603         	mov	r3, r0
 801b434: 73fb         	strb	r3, [r7, #0xf]
 801b436: 4613         	mov	r3, r2
 801b438: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801b43a: f107 032c    	add.w	r3, r7, #0x2c
 801b43e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801b440: 7bba         	ldrb	r2, [r7, #0xe]
 801b442: 7bf8         	ldrb	r0, [r7, #0xf]
 801b444: 697b         	ldr	r3, [r7, #0x14]
 801b446: 9303         	str	r3, [sp, #0xc]
 801b448: 6abb         	ldr	r3, [r7, #0x28]
 801b44a: 9302         	str	r3, [sp, #0x8]
 801b44c: 6a7b         	ldr	r3, [r7, #0x24]
 801b44e: 9301         	str	r3, [sp, #0x4]
 801b450: 6a3b         	ldr	r3, [r7, #0x20]
 801b452: 9300         	str	r3, [sp]
 801b454: 687b         	ldr	r3, [r7, #0x4]
 801b456: 68b9         	ldr	r1, [r7, #0x8]
 801b458: f7e9 fb74    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x16918
; }
 801b45c: bf00         	nop
 801b45e: 3718         	adds	r7, #0x18
 801b460: 46bd         	mov	sp, r7
 801b462: bd80         	pop	{r7, pc}

0801b464 <isr_stacks>:
; {
 801b464: b580         	push	{r7, lr}
 801b466: b082         	sub	sp, #0x8
 801b468: af00         	add	r7, sp, #0x0
; 	return CONFIG_MP_MAX_NUM_CPUS;
 801b46a: 2301         	movs	r3, #0x1
; 	unsigned int num_cpus = arch_num_cpus();
 801b46c: 603b         	str	r3, [r7]
; 	for (int i = 0; i < num_cpus; i++) {
 801b46e: 2300         	movs	r3, #0x0
 801b470: 607b         	str	r3, [r7, #0x4]
 801b472: e005         	b	0x801b480 <isr_stacks+0x1c> @ imm = #0xa
; 		isr_stack(i);
 801b474: 6878         	ldr	r0, [r7, #0x4]
 801b476: f7e9 f895    	bl	0x80045a4 <isr_stack>   @ imm = #-0x16ed6
; 	for (int i = 0; i < num_cpus; i++) {
 801b47a: 687b         	ldr	r3, [r7, #0x4]
 801b47c: 3301         	adds	r3, #0x1
 801b47e: 607b         	str	r3, [r7, #0x4]
 801b480: 687b         	ldr	r3, [r7, #0x4]
 801b482: 683a         	ldr	r2, [r7]
 801b484: 429a         	cmp	r2, r3
 801b486: d8f5         	bhi	0x801b474 <isr_stacks+0x10> @ imm = #-0x16
; }
 801b488: bf00         	nop
 801b48a: bf00         	nop
 801b48c: 3708         	adds	r7, #0x8
 801b48e: 46bd         	mov	sp, r7
 801b490: bd80         	pop	{r7, pc}

0801b492 <atomic_add>:
; {
 801b492: b490         	push	{r4, r7}
 801b494: b082         	sub	sp, #0x8
 801b496: af00         	add	r7, sp, #0x0
 801b498: 6078         	str	r0, [r7, #0x4]
 801b49a: 6039         	str	r1, [r7]
; 	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 801b49c: 683a         	ldr	r2, [r7]
 801b49e: 687b         	ldr	r3, [r7, #0x4]
 801b4a0: f3bf 8f5b    	dmb	ish
 801b4a4: e853 1f00    	ldrex	r1, [r3]
 801b4a8: eb01 0002    	add.w	r0, r1, r2
 801b4ac: e843 0400    	strex	r4, r0, [r3]
 801b4b0: 2c00         	cmp	r4, #0x0
 801b4b2: d1f7         	bne	0x801b4a4 <atomic_add+0x12> @ imm = #-0x12
 801b4b4: f3bf 8f5b    	dmb	ish
 801b4b8: 460b         	mov	r3, r1
; }
 801b4ba: 4618         	mov	r0, r3
 801b4bc: 3708         	adds	r7, #0x8
 801b4be: 46bd         	mov	sp, r7
 801b4c0: bc90         	pop	{r4, r7}
 801b4c2: 4770         	bx	lr

0801b4c4 <atomic_sub>:
; {
 801b4c4: b490         	push	{r4, r7}
 801b4c6: b082         	sub	sp, #0x8
 801b4c8: af00         	add	r7, sp, #0x0
 801b4ca: 6078         	str	r0, [r7, #0x4]
 801b4cc: 6039         	str	r1, [r7]
; 	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 801b4ce: 683a         	ldr	r2, [r7]
 801b4d0: 687b         	ldr	r3, [r7, #0x4]
 801b4d2: f3bf 8f5b    	dmb	ish
 801b4d6: e853 1f00    	ldrex	r1, [r3]
 801b4da: eba1 0002    	sub.w	r0, r1, r2
 801b4de: e843 0400    	strex	r4, r0, [r3]
 801b4e2: 2c00         	cmp	r4, #0x0
 801b4e4: d1f7         	bne	0x801b4d6 <atomic_sub+0x12> @ imm = #-0x12
 801b4e6: f3bf 8f5b    	dmb	ish
 801b4ea: 460b         	mov	r3, r1
; }
 801b4ec: 4618         	mov	r0, r3
 801b4ee: 3708         	adds	r7, #0x8
 801b4f0: 46bd         	mov	sp, r7
 801b4f2: bc90         	pop	{r4, r7}
 801b4f4: 4770         	bx	lr

0801b4f6 <atomic_inc>:
; {
 801b4f6: b580         	push	{r7, lr}
 801b4f8: b082         	sub	sp, #0x8
 801b4fa: af00         	add	r7, sp, #0x0
 801b4fc: 6078         	str	r0, [r7, #0x4]
; 	return atomic_add(target, 1);
 801b4fe: 2101         	movs	r1, #0x1
 801b500: 6878         	ldr	r0, [r7, #0x4]
 801b502: f7ff ffc6    	bl	0x801b492 <atomic_add>  @ imm = #-0x74
 801b506: 4603         	mov	r3, r0
; }
 801b508: 4618         	mov	r0, r3
 801b50a: 3708         	adds	r7, #0x8
 801b50c: 46bd         	mov	sp, r7
 801b50e: bd80         	pop	{r7, pc}

0801b510 <atomic_dec>:
; {
 801b510: b580         	push	{r7, lr}
 801b512: b082         	sub	sp, #0x8
 801b514: af00         	add	r7, sp, #0x0
 801b516: 6078         	str	r0, [r7, #0x4]
; 	return atomic_sub(target, 1);
 801b518: 2101         	movs	r1, #0x1
 801b51a: 6878         	ldr	r0, [r7, #0x4]
 801b51c: f7ff ffd2    	bl	0x801b4c4 <atomic_sub>  @ imm = #-0x5c
 801b520: 4603         	mov	r3, r0
; }
 801b522: 4618         	mov	r0, r3
 801b524: 3708         	adds	r7, #0x8
 801b526: 46bd         	mov	sp, r7
 801b528: bd80         	pop	{r7, pc}

0801b52a <z_log_item_is_msg>:
; {
 801b52a: b480         	push	{r7}
 801b52c: b083         	sub	sp, #0xc
 801b52e: af00         	add	r7, sp, #0x0
 801b530: 6078         	str	r0, [r7, #0x4]
; 	return msg->generic.type == Z_LOG_MSG_LOG;
 801b532: 687b         	ldr	r3, [r7, #0x4]
 801b534: 781b         	ldrb	r3, [r3]
 801b536: f003 0304    	and	r3, r3, #0x4
 801b53a: b2db         	uxtb	r3, r3
 801b53c: 2b00         	cmp	r3, #0x0
 801b53e: bf0c         	ite	eq
 801b540: 2301         	moveq	r3, #0x1
 801b542: 2300         	movne	r3, #0x0
 801b544: b2db         	uxtb	r3, r3
; }
 801b546: 4618         	mov	r0, r3
 801b548: 370c         	adds	r7, #0xc
 801b54a: 46bd         	mov	sp, r7
 801b54c: f85d 7b04    	ldr	r7, [sp], #4
 801b550: 4770         	bx	lr

0801b552 <k_msleep>:
; {
 801b552: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801b556: b082         	sub	sp, #0x8
 801b558: af00         	add	r7, sp, #0x0
 801b55a: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 801b55c: 6879         	ldr	r1, [r7, #0x4]
 801b55e: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 801b562: 17c8         	asrs	r0, r1, #0x1f
 801b564: 4688         	mov	r8, r1
 801b566: 4681         	mov	r9, r0
 801b568: 4640         	mov	r0, r8
 801b56a: 4649         	mov	r1, r9
 801b56c: f04f 0400    	mov.w	r4, #0x0
 801b570: f04f 0500    	mov.w	r5, #0x0
 801b574: 008d         	lsls	r5, r1, #0x2
 801b576: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 801b57a: 0084         	lsls	r4, r0, #0x2
 801b57c: 4620         	mov	r0, r4
 801b57e: 4629         	mov	r1, r5
 801b580: eb10 0208    	adds.w	r2, r0, r8
 801b584: eb41 0309    	adc.w	r3, r1, r9
 801b588: eb12 0a02    	adds.w	r10, r2, r2
 801b58c: eb43 0b03    	adc.w	r11, r3, r3
 801b590: 4652         	mov	r2, r10
 801b592: 465b         	mov	r3, r11
 801b594: 4610         	mov	r0, r2
 801b596: 4619         	mov	r1, r3
 801b598: f000 f823    	bl	0x801b5e2 <k_sleep>     @ imm = #0x46
 801b59c: 4601         	mov	r1, r0
 801b59e: 460b         	mov	r3, r1
; }
 801b5a0: 4618         	mov	r0, r3
 801b5a2: 3708         	adds	r7, #0x8
 801b5a4: 46bd         	mov	sp, r7
 801b5a6: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801b5aa <k_uptime_get>:
; {
 801b5aa: b580         	push	{r7, lr}
 801b5ac: af00         	add	r7, sp, #0x0
; 	return k_ticks_to_ms_floor64(k_uptime_ticks());
 801b5ae: f000 f826    	bl	0x801b5fe <k_uptime_ticks> @ imm = #0x4c
 801b5b2: 4602         	mov	r2, r0
 801b5b4: 460b         	mov	r3, r1
 801b5b6: 4610         	mov	r0, r2
 801b5b8: 4619         	mov	r1, r3
 801b5ba: f04f 020a    	mov.w	r2, #0xa
 801b5be: f04f 0300    	mov.w	r3, #0x0
 801b5c2: f7e5 f83d    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x1af86
 801b5c6: 4602         	mov	r2, r0
 801b5c8: 460b         	mov	r3, r1
; }
 801b5ca: 4610         	mov	r0, r2
 801b5cc: 4619         	mov	r1, r3
 801b5ce: bd80         	pop	{r7, pc}

0801b5d0 <k_uptime_get_32>:
; {
 801b5d0: b580         	push	{r7, lr}
 801b5d2: af00         	add	r7, sp, #0x0
; 	return (uint32_t)k_uptime_get();
 801b5d4: f7ff ffe9    	bl	0x801b5aa <k_uptime_get> @ imm = #-0x2e
 801b5d8: 4602         	mov	r2, r0
 801b5da: 460b         	mov	r3, r1
 801b5dc: 4613         	mov	r3, r2
; }
 801b5de: 4618         	mov	r0, r3
 801b5e0: bd80         	pop	{r7, pc}

0801b5e2 <k_sleep>:
; {
 801b5e2: b580         	push	{r7, lr}
 801b5e4: b082         	sub	sp, #0x8
 801b5e6: af00         	add	r7, sp, #0x0
 801b5e8: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 801b5ec: e9d7 0100    	ldrd	r0, r1, [r7]
 801b5f0: f7fa fe7e    	bl	0x80162f0 <z_impl_k_sleep> @ imm = #-0x5304
 801b5f4: 4603         	mov	r3, r0
; }
 801b5f6: 4618         	mov	r0, r3
 801b5f8: 3708         	adds	r7, #0x8
 801b5fa: 46bd         	mov	sp, r7
 801b5fc: bd80         	pop	{r7, pc}

0801b5fe <k_uptime_ticks>:
; {
 801b5fe: b580         	push	{r7, lr}
 801b600: af00         	add	r7, sp, #0x0
; 	return z_impl_k_uptime_ticks();
 801b602: f00b fcf2    	bl	0x8026fea <z_impl_k_uptime_ticks> @ imm = #0xb9e4
 801b606: 4602         	mov	r2, r0
 801b608: 460b         	mov	r3, r1
; }
 801b60a: 4610         	mov	r0, r2
 801b60c: 4619         	mov	r1, r3
 801b60e: bd80         	pop	{r7, pc}

0801b610 <log_backend_init>:
; {
 801b610: b580         	push	{r7, lr}
 801b612: b082         	sub	sp, #0x8
 801b614: af00         	add	r7, sp, #0x0
 801b616: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->init) {
 801b618: 687b         	ldr	r3, [r7, #0x4]
 801b61a: 681b         	ldr	r3, [r3]
 801b61c: 68db         	ldr	r3, [r3, #0xc]
 801b61e: 2b00         	cmp	r3, #0x0
 801b620: d004         	beq	0x801b62c <log_backend_init+0x1c> @ imm = #0x8
; 		backend->api->init(backend);
 801b622: 687b         	ldr	r3, [r7, #0x4]
 801b624: 681b         	ldr	r3, [r3]
 801b626: 68db         	ldr	r3, [r3, #0xc]
 801b628: 6878         	ldr	r0, [r7, #0x4]
 801b62a: 4798         	blx	r3
; }
 801b62c: bf00         	nop
 801b62e: 3708         	adds	r7, #0x8
 801b630: 46bd         	mov	sp, r7
 801b632: bd80         	pop	{r7, pc}

0801b634 <log_backend_is_ready>:
; {
 801b634: b580         	push	{r7, lr}
 801b636: b082         	sub	sp, #0x8
 801b638: af00         	add	r7, sp, #0x0
 801b63a: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->is_ready != NULL) {
 801b63c: 687b         	ldr	r3, [r7, #0x4]
 801b63e: 681b         	ldr	r3, [r3]
 801b640: 691b         	ldr	r3, [r3, #0x10]
 801b642: 2b00         	cmp	r3, #0x0
 801b644: d006         	beq	0x801b654 <log_backend_is_ready+0x20> @ imm = #0xc
; 		return backend->api->is_ready(backend);
 801b646: 687b         	ldr	r3, [r7, #0x4]
 801b648: 681b         	ldr	r3, [r3]
 801b64a: 691b         	ldr	r3, [r3, #0x10]
 801b64c: 6878         	ldr	r0, [r7, #0x4]
 801b64e: 4798         	blx	r3
 801b650: 4603         	mov	r3, r0
 801b652: e000         	b	0x801b656 <log_backend_is_ready+0x22> @ imm = #0x0
; 	return 0;
 801b654: 2300         	movs	r3, #0x0
; }
 801b656: 4618         	mov	r0, r3
 801b658: 3708         	adds	r7, #0x8
 801b65a: 46bd         	mov	sp, r7
 801b65c: bd80         	pop	{r7, pc}

0801b65e <log_backend_msg_process>:
; {
 801b65e: b580         	push	{r7, lr}
 801b660: b082         	sub	sp, #0x8
 801b662: af00         	add	r7, sp, #0x0
 801b664: 6078         	str	r0, [r7, #0x4]
 801b666: 6039         	str	r1, [r7]
; 	backend->api->process(backend, msg);
 801b668: 687b         	ldr	r3, [r7, #0x4]
 801b66a: 681b         	ldr	r3, [r3]
 801b66c: 681b         	ldr	r3, [r3]
 801b66e: 6839         	ldr	r1, [r7]
 801b670: 6878         	ldr	r0, [r7, #0x4]
 801b672: 4798         	blx	r3
; }
 801b674: bf00         	nop
 801b676: 3708         	adds	r7, #0x8
 801b678: 46bd         	mov	sp, r7
 801b67a: bd80         	pop	{r7, pc}

0801b67c <log_backend_panic>:
; {
 801b67c: b580         	push	{r7, lr}
 801b67e: b082         	sub	sp, #0x8
 801b680: af00         	add	r7, sp, #0x0
 801b682: 6078         	str	r0, [r7, #0x4]
; 	backend->api->panic(backend);
 801b684: 687b         	ldr	r3, [r7, #0x4]
 801b686: 681b         	ldr	r3, [r3]
 801b688: 689b         	ldr	r3, [r3, #0x8]
 801b68a: 6878         	ldr	r0, [r7, #0x4]
 801b68c: 4798         	blx	r3
; }
 801b68e: bf00         	nop
 801b690: 3708         	adds	r7, #0x8
 801b692: 46bd         	mov	sp, r7
 801b694: bd80         	pop	{r7, pc}

0801b696 <log_backend_is_active>:
; {
 801b696: b480         	push	{r7}
 801b698: b083         	sub	sp, #0xc
 801b69a: af00         	add	r7, sp, #0x0
 801b69c: 6078         	str	r0, [r7, #0x4]
; 	return backend->cb->active;
 801b69e: 687b         	ldr	r3, [r7, #0x4]
 801b6a0: 685b         	ldr	r3, [r3, #0x4]
 801b6a2: 795b         	ldrb	r3, [r3, #0x5]
; }
 801b6a4: 4618         	mov	r0, r3
 801b6a6: 370c         	adds	r7, #0xc
 801b6a8: 46bd         	mov	sp, r7
 801b6aa: f85d 7b04    	ldr	r7, [sp], #4
 801b6ae: 4770         	bx	lr

0801b6b0 <dummy_timestamp>:
; {
 801b6b0: b480         	push	{r7}
 801b6b2: af00         	add	r7, sp, #0x0
; 	return 0;
 801b6b4: 2300         	movs	r3, #0x0
; }
 801b6b6: 4618         	mov	r0, r3
 801b6b8: 46bd         	mov	sp, r7
 801b6ba: f85d 7b04    	ldr	r7, [sp], #4
 801b6be: 4770         	bx	lr

0801b6c0 <z_log_vprintk>:
; {
 801b6c0: b580         	push	{r7, lr}
 801b6c2: b086         	sub	sp, #0x18
 801b6c4: af04         	add	r7, sp, #0x10
 801b6c6: 6078         	str	r0, [r7, #0x4]
 801b6c8: 6039         	str	r1, [r7]
; 	z_log_msg_runtime_vcreate(Z_LOG_LOCAL_DOMAIN_ID, NULL,
 801b6ca: 683b         	ldr	r3, [r7]
 801b6cc: 9303         	str	r3, [sp, #0xc]
 801b6ce: 687b         	ldr	r3, [r7, #0x4]
 801b6d0: 9302         	str	r3, [sp, #0x8]
 801b6d2: 2300         	movs	r3, #0x0
 801b6d4: 9301         	str	r3, [sp, #0x4]
 801b6d6: 2300         	movs	r3, #0x0
 801b6d8: 9300         	str	r3, [sp]
 801b6da: 2300         	movs	r3, #0x0
 801b6dc: 2200         	movs	r2, #0x0
 801b6de: 2100         	movs	r1, #0x0
 801b6e0: 2000         	movs	r0, #0x0
 801b6e2: f7e9 fa2f    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x16ba2
; }
 801b6e6: 3708         	adds	r7, #0x8
 801b6e8: 46bd         	mov	sp, r7
 801b6ea: bd80         	pop	{r7, pc}

0801b6ec <default_lf_get_timestamp>:
; {
 801b6ec: b580         	push	{r7, lr}
 801b6ee: af00         	add	r7, sp, #0x0
; 		k_uptime_get() : k_uptime_get_32();
 801b6f0: f7ff ff6e    	bl	0x801b5d0 <k_uptime_get_32> @ imm = #-0x124
 801b6f4: 4603         	mov	r3, r0
; }
 801b6f6: 4618         	mov	r0, r3
 801b6f8: bd80         	pop	{r7, pc}

0801b6fa <activate_foreach_backend>:
; {
 801b6fa: b580         	push	{r7, lr}
 801b6fc: b086         	sub	sp, #0x18
 801b6fe: af00         	add	r7, sp, #0x0
 801b700: 6078         	str	r0, [r7, #0x4]
; 	uint32_t mask_cpy = mask;
 801b702: 687b         	ldr	r3, [r7, #0x4]
 801b704: 617b         	str	r3, [r7, #0x14]
; 	while (mask_cpy) {
 801b706: e02b         	b	0x801b760 <activate_foreach_backend+0x66> @ imm = #0x56
; 		uint32_t i = __builtin_ctz(mask_cpy);
 801b708: 697b         	ldr	r3, [r7, #0x14]
 801b70a: fa93 f3a3    	rbit	r3, r3
 801b70e: fab3 f383    	clz	r3, r3
 801b712: 613b         	str	r3, [r7, #0x10]
; 		const struct log_backend *backend = log_backend_get(i);
 801b714: 6938         	ldr	r0, [r7, #0x10]
 801b716: f7e8 ffe1    	bl	0x80046dc <log_backend_get> @ imm = #-0x1703e
 801b71a: 60f8         	str	r0, [r7, #0xc]
; 		mask_cpy &= ~BIT(i);
 801b71c: 2201         	movs	r2, #0x1
 801b71e: 693b         	ldr	r3, [r7, #0x10]
 801b720: fa02 f303    	lsl.w	r3, r2, r3
 801b724: 43db         	mvns	r3, r3
 801b726: 697a         	ldr	r2, [r7, #0x14]
 801b728: 4013         	ands	r3, r2
 801b72a: 617b         	str	r3, [r7, #0x14]
; 		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
 801b72c: 68fb         	ldr	r3, [r7, #0xc]
 801b72e: 7b1b         	ldrb	r3, [r3, #0xc]
 801b730: 2b00         	cmp	r3, #0x0
 801b732: d015         	beq	0x801b760 <activate_foreach_backend+0x66> @ imm = #0x2a
 801b734: 68f8         	ldr	r0, [r7, #0xc]
 801b736: f7ff ff7d    	bl	0x801b634 <log_backend_is_ready> @ imm = #-0x106
 801b73a: 4603         	mov	r3, r0
 801b73c: 2b00         	cmp	r3, #0x0
 801b73e: d10f         	bne	0x801b760 <activate_foreach_backend+0x66> @ imm = #0x1e
; 			mask &= ~BIT(i);
 801b740: 2201         	movs	r2, #0x1
 801b742: 693b         	ldr	r3, [r7, #0x10]
 801b744: fa02 f303    	lsl.w	r3, r2, r3
 801b748: 43db         	mvns	r3, r3
 801b74a: 687a         	ldr	r2, [r7, #0x4]
 801b74c: 4013         	ands	r3, r2
 801b74e: 607b         	str	r3, [r7, #0x4]
; 					   backend->cb->ctx,
 801b750: 68fb         	ldr	r3, [r7, #0xc]
 801b752: 685b         	ldr	r3, [r3, #0x4]
; 			log_backend_enable(backend,
 801b754: 681b         	ldr	r3, [r3]
 801b756: 2204         	movs	r2, #0x4
 801b758: 4619         	mov	r1, r3
 801b75a: 68f8         	ldr	r0, [r7, #0xc]
 801b75c: f000 f8ce    	bl	0x801b8fc <log_backend_enable> @ imm = #0x19c
; 	while (mask_cpy) {
 801b760: 697b         	ldr	r3, [r7, #0x14]
 801b762: 2b00         	cmp	r3, #0x0
 801b764: d1d0         	bne	0x801b708 <activate_foreach_backend+0xe> @ imm = #-0x60
; 	return mask;
 801b766: 687b         	ldr	r3, [r7, #0x4]
; }
 801b768: 4618         	mov	r0, r3
 801b76a: 3718         	adds	r7, #0x18
 801b76c: 46bd         	mov	sp, r7
 801b76e: bd80         	pop	{r7, pc}

0801b770 <msg_filter_check>:
; {
 801b770: b580         	push	{r7, lr}
 801b772: b082         	sub	sp, #0x8
 801b774: af00         	add	r7, sp, #0x0
 801b776: 6078         	str	r0, [r7, #0x4]
 801b778: 6039         	str	r1, [r7]
; 	if (!z_log_item_is_msg(msg)) {
 801b77a: 6838         	ldr	r0, [r7]
 801b77c: f7ff fed5    	bl	0x801b52a <z_log_item_is_msg> @ imm = #-0x256
 801b780: 4603         	mov	r3, r0
 801b782: f083 0301    	eor	r3, r3, #0x1
 801b786: b2db         	uxtb	r3, r3
 801b788: 2b00         	cmp	r3, #0x0
 801b78a: d001         	beq	0x801b790 <msg_filter_check+0x20> @ imm = #0x2
; 		return true;
 801b78c: 2301         	movs	r3, #0x1
 801b78e: e000         	b	0x801b792 <msg_filter_check+0x22> @ imm = #0x0
; 		return true;
 801b790: 2301         	movs	r3, #0x1
; }
 801b792: 4618         	mov	r0, r3
 801b794: 3708         	adds	r7, #0x8
 801b796: 46bd         	mov	sp, r7
 801b798: bd80         	pop	{r7, pc}

0801b79a <msg_commit>:
; {
 801b79a: b580         	push	{r7, lr}
 801b79c: b084         	sub	sp, #0x10
 801b79e: af00         	add	r7, sp, #0x0
 801b7a0: 6078         	str	r0, [r7, #0x4]
 801b7a2: 6039         	str	r1, [r7]
; 	union log_msg_generic *m = (union log_msg_generic *)msg;
 801b7a4: 683b         	ldr	r3, [r7]
 801b7a6: 60fb         	str	r3, [r7, #0xc]
; 		msg_process(m);
 801b7a8: 68f8         	ldr	r0, [r7, #0xc]
 801b7aa: f7e9 f883    	bl	0x80048b4 <msg_process> @ imm = #-0x16efa
; }
 801b7ae: 3710         	adds	r7, #0x10
 801b7b0: 46bd         	mov	sp, r7
 801b7b2: bd80         	pop	{r7, pc}

0801b7b4 <z_log_get_tag>:
; {
 801b7b4: b480         	push	{r7}
 801b7b6: af00         	add	r7, sp, #0x0
; 	return CONFIG_LOG_TAG_MAX_LEN > 0 ? tag : NULL;
 801b7b8: 2300         	movs	r3, #0x0
; }
 801b7ba: 4618         	mov	r0, r3
 801b7bc: 46bd         	mov	sp, r7
 801b7be: f85d 7b04    	ldr	r7, [sp], #4
 801b7c2: 4770         	bx	lr

0801b7c4 <enable_logger>:
; {
 801b7c4: b580         	push	{r7, lr}
 801b7c6: af00         	add	r7, sp, #0x0
; 		(void)z_log_init(false, false);
 801b7c8: 2100         	movs	r1, #0x0
 801b7ca: 2000         	movs	r0, #0x0
 801b7cc: f7e8 ffc2    	bl	0x8004754 <z_log_init>  @ imm = #-0x1707c
; 	return 0;
 801b7d0: 2300         	movs	r3, #0x0
; }
 801b7d2: 4618         	mov	r0, r3
 801b7d4: bd80         	pop	{r7, pc}

0801b7d6 <z_log_is_local_domain>:
; {
 801b7d6: b480         	push	{r7}
 801b7d8: b083         	sub	sp, #0xc
 801b7da: af00         	add	r7, sp, #0x0
 801b7dc: 4603         	mov	r3, r0
 801b7de: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 801b7e0: 2301         	movs	r3, #0x1
; }
 801b7e2: 4618         	mov	r0, r3
 801b7e4: 370c         	adds	r7, #0xc
 801b7e6: 46bd         	mov	sp, r7
 801b7e8: f85d 7b04    	ldr	r7, [sp], #4
 801b7ec: 4770         	bx	lr

0801b7ee <log_backend_id_set>:
; {
 801b7ee: b480         	push	{r7}
 801b7f0: b083         	sub	sp, #0xc
 801b7f2: af00         	add	r7, sp, #0x0
 801b7f4: 6078         	str	r0, [r7, #0x4]
 801b7f6: 460b         	mov	r3, r1
 801b7f8: 70fb         	strb	r3, [r7, #0x3]
; 	backend->cb->id = id;
 801b7fa: 687b         	ldr	r3, [r7, #0x4]
 801b7fc: 685b         	ldr	r3, [r3, #0x4]
 801b7fe: 78fa         	ldrb	r2, [r7, #0x3]
 801b800: 711a         	strb	r2, [r3, #0x4]
; }
 801b802: bf00         	nop
 801b804: 370c         	adds	r7, #0xc
 801b806: 46bd         	mov	sp, r7
 801b808: f85d 7b04    	ldr	r7, [sp], #4
 801b80c: 4770         	bx	lr

0801b80e <log_backend_activate>:
; {
 801b80e: b480         	push	{r7}
 801b810: b083         	sub	sp, #0xc
 801b812: af00         	add	r7, sp, #0x0
 801b814: 6078         	str	r0, [r7, #0x4]
 801b816: 6039         	str	r1, [r7]
; 	backend->cb->ctx = ctx;
 801b818: 687b         	ldr	r3, [r7, #0x4]
 801b81a: 685b         	ldr	r3, [r3, #0x4]
 801b81c: 683a         	ldr	r2, [r7]
 801b81e: 601a         	str	r2, [r3]
; 	backend->cb->active = true;
 801b820: 687b         	ldr	r3, [r7, #0x4]
 801b822: 685b         	ldr	r3, [r3, #0x4]
 801b824: 2201         	movs	r2, #0x1
 801b826: 715a         	strb	r2, [r3, #0x5]
; }
 801b828: bf00         	nop
 801b82a: 370c         	adds	r7, #0xc
 801b82c: 46bd         	mov	sp, r7
 801b82e: f85d 7b04    	ldr	r7, [sp], #4
 801b832: 4770         	bx	lr

0801b834 <log_link_sources_count>:
; {
 801b834: b480         	push	{r7}
 801b836: b083         	sub	sp, #0xc
 801b838: af00         	add	r7, sp, #0x0
 801b83a: 6078         	str	r0, [r7, #0x4]
 801b83c: 6039         	str	r1, [r7]
; 	return link->ctrl_blk->source_cnt[domain_id];
 801b83e: 687b         	ldr	r3, [r7, #0x4]
 801b840: 689a         	ldr	r2, [r3, #0x8]
 801b842: 683b         	ldr	r3, [r7]
 801b844: 005b         	lsls	r3, r3, #0x1
 801b846: 4413         	add	r3, r2
 801b848: 889b         	ldrh	r3, [r3, #0x4]
; }
 801b84a: 4618         	mov	r0, r3
 801b84c: 370c         	adds	r7, #0xc
 801b84e: 46bd         	mov	sp, r7
 801b850: f85d 7b04    	ldr	r7, [sp], #4
 801b854: 4770         	bx	lr

0801b856 <log_link_get_source_name>:
; {
 801b856: b590         	push	{r4, r7, lr}
 801b858: b087         	sub	sp, #0x1c
 801b85a: af02         	add	r7, sp, #0x8
 801b85c: 60f8         	str	r0, [r7, #0xc]
 801b85e: 60b9         	str	r1, [r7, #0x8]
 801b860: 603b         	str	r3, [r7]
 801b862: 4613         	mov	r3, r2
 801b864: 80fb         	strh	r3, [r7, #0x6]
; 	return link->api->get_source_name(link, domain_id, source_id,
 801b866: 68fb         	ldr	r3, [r7, #0xc]
 801b868: 681b         	ldr	r3, [r3]
 801b86a: 68dc         	ldr	r4, [r3, #0xc]
 801b86c: 88fa         	ldrh	r2, [r7, #0x6]
 801b86e: 6a3b         	ldr	r3, [r7, #0x20]
 801b870: 9300         	str	r3, [sp]
 801b872: 683b         	ldr	r3, [r7]
 801b874: 68b9         	ldr	r1, [r7, #0x8]
 801b876: 68f8         	ldr	r0, [r7, #0xc]
 801b878: 47a0         	blx	r4
 801b87a: 4603         	mov	r3, r0
; }
 801b87c: 4618         	mov	r0, r3
 801b87e: 3714         	adds	r7, #0x14
 801b880: 46bd         	mov	sp, r7
 801b882: bd90         	pop	{r4, r7, pc}

0801b884 <link_source_count>:
; {
 801b884: b580         	push	{r7, lr}
 801b886: b084         	sub	sp, #0x10
 801b888: af00         	add	r7, sp, #0x0
 801b88a: 4603         	mov	r3, r0
 801b88c: 71fb         	strb	r3, [r7, #0x7]
; 	const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 801b88e: f107 020b    	add.w	r2, r7, #0xb
 801b892: 79fb         	ldrb	r3, [r7, #0x7]
 801b894: 4611         	mov	r1, r2
 801b896: 4618         	mov	r0, r3
 801b898: f7e9 f89e    	bl	0x80049d8 <get_link_domain> @ imm = #-0x16ec4
 801b89c: 60f8         	str	r0, [r7, #0xc]
; 	return log_link_sources_count(link, rel_domain_id);
 801b89e: 7afb         	ldrb	r3, [r7, #0xb]
 801b8a0: 4619         	mov	r1, r3
 801b8a2: 68f8         	ldr	r0, [r7, #0xc]
 801b8a4: f7ff ffc6    	bl	0x801b834 <log_link_sources_count> @ imm = #-0x74
 801b8a8: 4603         	mov	r3, r0
; }
 801b8aa: 4618         	mov	r0, r3
 801b8ac: 3710         	adds	r7, #0x10
 801b8ae: 46bd         	mov	sp, r7
 801b8b0: bd80         	pop	{r7, pc}

0801b8b2 <log_src_cnt_get>:
; {
 801b8b2: b580         	push	{r7, lr}
 801b8b4: b082         	sub	sp, #0x8
 801b8b6: af00         	add	r7, sp, #0x0
 801b8b8: 6078         	str	r0, [r7, #0x4]
; 	if (z_log_is_local_domain(domain_id)) {
 801b8ba: 687b         	ldr	r3, [r7, #0x4]
 801b8bc: b2db         	uxtb	r3, r3
 801b8be: 4618         	mov	r0, r3
 801b8c0: f7ff ff89    	bl	0x801b7d6 <z_log_is_local_domain> @ imm = #-0xee
 801b8c4: 4603         	mov	r3, r0
 801b8c6: 2b00         	cmp	r3, #0x0
 801b8c8: d003         	beq	0x801b8d2 <log_src_cnt_get+0x20> @ imm = #0x6
; 		return z_log_sources_count();
 801b8ca: f7e9 f869    	bl	0x80049a0 <z_log_sources_count> @ imm = #-0x16f2e
 801b8ce: 4603         	mov	r3, r0
 801b8d0: e005         	b	0x801b8de <log_src_cnt_get+0x2c> @ imm = #0xa
; 	return link_source_count(domain_id);
 801b8d2: 687b         	ldr	r3, [r7, #0x4]
 801b8d4: b2db         	uxtb	r3, r3
 801b8d6: 4618         	mov	r0, r3
 801b8d8: f7ff ffd4    	bl	0x801b884 <link_source_count> @ imm = #-0x58
 801b8dc: 4603         	mov	r3, r0
; }
 801b8de: 4618         	mov	r0, r3
 801b8e0: 3708         	adds	r7, #0x8
 801b8e2: 46bd         	mov	sp, r7
 801b8e4: bd80         	pop	{r7, pc}

0801b8e6 <backend_filter_set>:
; {
 801b8e6: b480         	push	{r7}
 801b8e8: b083         	sub	sp, #0xc
 801b8ea: af00         	add	r7, sp, #0x0
 801b8ec: 6078         	str	r0, [r7, #0x4]
 801b8ee: 6039         	str	r1, [r7]
; 		return;
 801b8f0: bf00         	nop
; }
 801b8f2: 370c         	adds	r7, #0xc
 801b8f4: 46bd         	mov	sp, r7
 801b8f6: f85d 7b04    	ldr	r7, [sp], #4
 801b8fa: 4770         	bx	lr

0801b8fc <log_backend_enable>:
; {
 801b8fc: b580         	push	{r7, lr}
 801b8fe: b086         	sub	sp, #0x18
 801b900: af00         	add	r7, sp, #0x0
 801b902: 60f8         	str	r0, [r7, #0xc]
 801b904: 60b9         	str	r1, [r7, #0x8]
 801b906: 607a         	str	r2, [r7, #0x4]
; 	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;
 801b908: 2301         	movs	r3, #0x1
 801b90a: 617b         	str	r3, [r7, #0x14]
; 	id += backend - log_backend_get(0);
 801b90c: 2000         	movs	r0, #0x0
 801b90e: f7e9 f851    	bl	0x80049b4 <log_backend_get> @ imm = #-0x16f5e
 801b912: 4602         	mov	r2, r0
 801b914: 68fb         	ldr	r3, [r7, #0xc]
 801b916: 1a9b         	subs	r3, r3, r2
 801b918: 111b         	asrs	r3, r3, #0x4
 801b91a: 461a         	mov	r2, r3
 801b91c: 697b         	ldr	r3, [r7, #0x14]
 801b91e: 4413         	add	r3, r2
 801b920: 617b         	str	r3, [r7, #0x14]
; 	log_backend_id_set(backend, id);
 801b922: 697b         	ldr	r3, [r7, #0x14]
 801b924: b2db         	uxtb	r3, r3
 801b926: 4619         	mov	r1, r3
 801b928: 68f8         	ldr	r0, [r7, #0xc]
 801b92a: f7ff ff60    	bl	0x801b7ee <log_backend_id_set> @ imm = #-0x140
; 	backend->cb->level = level;
 801b92e: 68fb         	ldr	r3, [r7, #0xc]
 801b930: 685b         	ldr	r3, [r3, #0x4]
 801b932: 687a         	ldr	r2, [r7, #0x4]
 801b934: b2d2         	uxtb	r2, r2
 801b936: 719a         	strb	r2, [r3, #0x6]
; 	backend_filter_set(backend, level);
 801b938: 6879         	ldr	r1, [r7, #0x4]
 801b93a: 68f8         	ldr	r0, [r7, #0xc]
 801b93c: f7ff ffd3    	bl	0x801b8e6 <backend_filter_set> @ imm = #-0x5a
; 	log_backend_activate(backend, ctx);
 801b940: 68b9         	ldr	r1, [r7, #0x8]
 801b942: 68f8         	ldr	r0, [r7, #0xc]
 801b944: f7ff ff63    	bl	0x801b80e <log_backend_activate> @ imm = #-0x13a
; 	z_log_notify_backend_enabled();
 801b948: f7e8 ffe2    	bl	0x8004910 <z_log_notify_backend_enabled> @ imm = #-0x1703c
; }
 801b94c: bf00         	nop
 801b94e: 3718         	adds	r7, #0x18
 801b950: 46bd         	mov	sp, r7
 801b952: bd80         	pop	{r7, pc}

0801b954 <z_snode_next_peek>:
; {
 801b954: b480         	push	{r7}
 801b956: b083         	sub	sp, #0xc
 801b958: af00         	add	r7, sp, #0x0
 801b95a: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 801b95c: 687b         	ldr	r3, [r7, #0x4]
 801b95e: 681b         	ldr	r3, [r3]
; }
 801b960: 4618         	mov	r0, r3
 801b962: 370c         	adds	r7, #0xc
 801b964: 46bd         	mov	sp, r7
 801b966: f85d 7b04    	ldr	r7, [sp], #4
 801b96a: 4770         	bx	lr

0801b96c <z_snode_next_set>:
; {
 801b96c: b480         	push	{r7}
 801b96e: b083         	sub	sp, #0xc
 801b970: af00         	add	r7, sp, #0x0
 801b972: 6078         	str	r0, [r7, #0x4]
 801b974: 6039         	str	r1, [r7]
; 	parent->next = child;
 801b976: 687b         	ldr	r3, [r7, #0x4]
 801b978: 683a         	ldr	r2, [r7]
 801b97a: 601a         	str	r2, [r3]
; }
 801b97c: bf00         	nop
 801b97e: 370c         	adds	r7, #0xc
 801b980: 46bd         	mov	sp, r7
 801b982: f85d 7b04    	ldr	r7, [sp], #4
 801b986: 4770         	bx	lr

0801b988 <z_slist_head_set>:
; {
 801b988: b480         	push	{r7}
 801b98a: b083         	sub	sp, #0xc
 801b98c: af00         	add	r7, sp, #0x0
 801b98e: 6078         	str	r0, [r7, #0x4]
 801b990: 6039         	str	r1, [r7]
; 	list->head = node;
 801b992: 687b         	ldr	r3, [r7, #0x4]
 801b994: 683a         	ldr	r2, [r7]
 801b996: 601a         	str	r2, [r3]
; }
 801b998: bf00         	nop
 801b99a: 370c         	adds	r7, #0xc
 801b99c: 46bd         	mov	sp, r7
 801b99e: f85d 7b04    	ldr	r7, [sp], #4
 801b9a2: 4770         	bx	lr

0801b9a4 <z_slist_tail_set>:
; {
 801b9a4: b480         	push	{r7}
 801b9a6: b083         	sub	sp, #0xc
 801b9a8: af00         	add	r7, sp, #0x0
 801b9aa: 6078         	str	r0, [r7, #0x4]
 801b9ac: 6039         	str	r1, [r7]
; 	list->tail = node;
 801b9ae: 687b         	ldr	r3, [r7, #0x4]
 801b9b0: 683a         	ldr	r2, [r7]
 801b9b2: 605a         	str	r2, [r3, #0x4]
; }
 801b9b4: bf00         	nop
 801b9b6: 370c         	adds	r7, #0xc
 801b9b8: 46bd         	mov	sp, r7
 801b9ba: f85d 7b04    	ldr	r7, [sp], #4
 801b9be: 4770         	bx	lr

0801b9c0 <sys_slist_peek_head>:
; {
 801b9c0: b480         	push	{r7}
 801b9c2: b083         	sub	sp, #0xc
 801b9c4: af00         	add	r7, sp, #0x0
 801b9c6: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 801b9c8: 687b         	ldr	r3, [r7, #0x4]
 801b9ca: 681b         	ldr	r3, [r3]
; }
 801b9cc: 4618         	mov	r0, r3
 801b9ce: 370c         	adds	r7, #0xc
 801b9d0: 46bd         	mov	sp, r7
 801b9d2: f85d 7b04    	ldr	r7, [sp], #4
 801b9d6: 4770         	bx	lr

0801b9d8 <sys_slist_peek_tail>:
; {
 801b9d8: b480         	push	{r7}
 801b9da: b083         	sub	sp, #0xc
 801b9dc: af00         	add	r7, sp, #0x0
 801b9de: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 801b9e0: 687b         	ldr	r3, [r7, #0x4]
 801b9e2: 685b         	ldr	r3, [r3, #0x4]
; }
 801b9e4: 4618         	mov	r0, r3
 801b9e6: 370c         	adds	r7, #0xc
 801b9e8: 46bd         	mov	sp, r7
 801b9ea: f85d 7b04    	ldr	r7, [sp], #4
 801b9ee: 4770         	bx	lr

0801b9f0 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 801b9f0: b580         	push	{r7, lr}
 801b9f2: b082         	sub	sp, #0x8
 801b9f4: af00         	add	r7, sp, #0x0
 801b9f6: 6078         	str	r0, [r7, #0x4]
 801b9f8: 6878         	ldr	r0, [r7, #0x4]
 801b9fa: f7ff ffe1    	bl	0x801b9c0 <sys_slist_peek_head> @ imm = #-0x3e
 801b9fe: 4603         	mov	r3, r0
 801ba00: 2b00         	cmp	r3, #0x0
 801ba02: bf0c         	ite	eq
 801ba04: 2301         	moveq	r3, #0x1
 801ba06: 2300         	movne	r3, #0x0
 801ba08: b2db         	uxtb	r3, r3
 801ba0a: 4618         	mov	r0, r3
 801ba0c: 3708         	adds	r7, #0x8
 801ba0e: 46bd         	mov	sp, r7
 801ba10: bd80         	pop	{r7, pc}

0801ba12 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 801ba12: b580         	push	{r7, lr}
 801ba14: b082         	sub	sp, #0x8
 801ba16: af00         	add	r7, sp, #0x0
 801ba18: 6078         	str	r0, [r7, #0x4]
 801ba1a: 6878         	ldr	r0, [r7, #0x4]
 801ba1c: f7ff ff9a    	bl	0x801b954 <z_snode_next_peek> @ imm = #-0xcc
 801ba20: 4603         	mov	r3, r0
 801ba22: 4618         	mov	r0, r3
 801ba24: 3708         	adds	r7, #0x8
 801ba26: 46bd         	mov	sp, r7
 801ba28: bd80         	pop	{r7, pc}

0801ba2a <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801ba2a: b580         	push	{r7, lr}
 801ba2c: b082         	sub	sp, #0x8
 801ba2e: af00         	add	r7, sp, #0x0
 801ba30: 6078         	str	r0, [r7, #0x4]
 801ba32: 687b         	ldr	r3, [r7, #0x4]
 801ba34: 2b00         	cmp	r3, #0x0
 801ba36: d004         	beq	0x801ba42 <sys_slist_peek_next+0x18> @ imm = #0x8
 801ba38: 6878         	ldr	r0, [r7, #0x4]
 801ba3a: f7ff ffea    	bl	0x801ba12 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 801ba3e: 4603         	mov	r3, r0
 801ba40: e000         	b	0x801ba44 <sys_slist_peek_next+0x1a> @ imm = #0x0
 801ba42: 2300         	movs	r3, #0x0
 801ba44: 4618         	mov	r0, r3
 801ba46: 3708         	adds	r7, #0x8
 801ba48: 46bd         	mov	sp, r7
 801ba4a: bd80         	pop	{r7, pc}

0801ba4c <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 801ba4c: b580         	push	{r7, lr}
 801ba4e: b082         	sub	sp, #0x8
 801ba50: af00         	add	r7, sp, #0x0
 801ba52: 6078         	str	r0, [r7, #0x4]
 801ba54: 6039         	str	r1, [r7]
 801ba56: 6878         	ldr	r0, [r7, #0x4]
 801ba58: f7ff ffb2    	bl	0x801b9c0 <sys_slist_peek_head> @ imm = #-0x9c
 801ba5c: 4603         	mov	r3, r0
 801ba5e: 4619         	mov	r1, r3
 801ba60: 6838         	ldr	r0, [r7]
 801ba62: f7ff ff83    	bl	0x801b96c <z_snode_next_set> @ imm = #-0xfa
 801ba66: 6839         	ldr	r1, [r7]
 801ba68: 6878         	ldr	r0, [r7, #0x4]
 801ba6a: f7ff ff8d    	bl	0x801b988 <z_slist_head_set> @ imm = #-0xe6
 801ba6e: 6878         	ldr	r0, [r7, #0x4]
 801ba70: f7ff ffb2    	bl	0x801b9d8 <sys_slist_peek_tail> @ imm = #-0x9c
 801ba74: 4603         	mov	r3, r0
 801ba76: 2b00         	cmp	r3, #0x0
 801ba78: d107         	bne	0x801ba8a <sys_slist_prepend+0x3e> @ imm = #0xe
 801ba7a: 6878         	ldr	r0, [r7, #0x4]
 801ba7c: f7ff ffa0    	bl	0x801b9c0 <sys_slist_peek_head> @ imm = #-0xc0
 801ba80: 4603         	mov	r3, r0
 801ba82: 4619         	mov	r1, r3
 801ba84: 6878         	ldr	r0, [r7, #0x4]
 801ba86: f7ff ff8d    	bl	0x801b9a4 <z_slist_tail_set> @ imm = #-0xe6
 801ba8a: 3708         	adds	r7, #0x8
 801ba8c: 46bd         	mov	sp, r7
 801ba8e: bd80         	pop	{r7, pc}

0801ba90 <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 801ba90: b580         	push	{r7, lr}
 801ba92: b084         	sub	sp, #0x10
 801ba94: af00         	add	r7, sp, #0x0
 801ba96: 6078         	str	r0, [r7, #0x4]
 801ba98: 6878         	ldr	r0, [r7, #0x4]
 801ba9a: f7ff ff91    	bl	0x801b9c0 <sys_slist_peek_head> @ imm = #-0xde
 801ba9e: 60f8         	str	r0, [r7, #0xc]
 801baa0: 68f8         	ldr	r0, [r7, #0xc]
 801baa2: f7ff ff57    	bl	0x801b954 <z_snode_next_peek> @ imm = #-0x152
 801baa6: 4603         	mov	r3, r0
 801baa8: 4619         	mov	r1, r3
 801baaa: 6878         	ldr	r0, [r7, #0x4]
 801baac: f7ff ff6c    	bl	0x801b988 <z_slist_head_set> @ imm = #-0x128
 801bab0: 6878         	ldr	r0, [r7, #0x4]
 801bab2: f7ff ff91    	bl	0x801b9d8 <sys_slist_peek_tail> @ imm = #-0xde
 801bab6: 4602         	mov	r2, r0
 801bab8: 68fb         	ldr	r3, [r7, #0xc]
 801baba: 4293         	cmp	r3, r2
 801babc: d107         	bne	0x801bace <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 801babe: 6878         	ldr	r0, [r7, #0x4]
 801bac0: f7ff ff7e    	bl	0x801b9c0 <sys_slist_peek_head> @ imm = #-0x104
 801bac4: 4603         	mov	r3, r0
 801bac6: 4619         	mov	r1, r3
 801bac8: 6878         	ldr	r0, [r7, #0x4]
 801baca: f7ff ff6b    	bl	0x801b9a4 <z_slist_tail_set> @ imm = #-0x12a
 801bace: 68fb         	ldr	r3, [r7, #0xc]
 801bad0: 4618         	mov	r0, r3
 801bad2: 3710         	adds	r7, #0x10
 801bad4: 46bd         	mov	sp, r7
 801bad6: bd80         	pop	{r7, pc}

0801bad8 <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 801bad8: b580         	push	{r7, lr}
 801bada: b082         	sub	sp, #0x8
 801badc: af00         	add	r7, sp, #0x0
 801bade: 6078         	str	r0, [r7, #0x4]
 801bae0: 6878         	ldr	r0, [r7, #0x4]
 801bae2: f7ff ff85    	bl	0x801b9f0 <sys_slist_is_empty> @ imm = #-0xf6
 801bae6: 4603         	mov	r3, r0
 801bae8: 2b00         	cmp	r3, #0x0
 801baea: d104         	bne	0x801baf6 <sys_slist_get+0x1e> @ imm = #0x8
 801baec: 6878         	ldr	r0, [r7, #0x4]
 801baee: f7ff ffcf    	bl	0x801ba90 <sys_slist_get_not_empty> @ imm = #-0x62
 801baf2: 4603         	mov	r3, r0
 801baf4: e000         	b	0x801baf8 <sys_slist_get+0x20> @ imm = #0x0
 801baf6: 2300         	movs	r3, #0x0
 801baf8: 4618         	mov	r0, r3
 801bafa: 3708         	adds	r7, #0x8
 801bafc: 46bd         	mov	sp, r7
 801bafe: bd80         	pop	{r7, pc}

0801bb00 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 801bb00: b580         	push	{r7, lr}
 801bb02: b084         	sub	sp, #0x10
 801bb04: af00         	add	r7, sp, #0x0
 801bb06: 60f8         	str	r0, [r7, #0xc]
 801bb08: 60b9         	str	r1, [r7, #0x8]
 801bb0a: 607a         	str	r2, [r7, #0x4]
 801bb0c: 68bb         	ldr	r3, [r7, #0x8]
 801bb0e: 2b00         	cmp	r3, #0x0
 801bb10: d117         	bne	0x801bb42 <sys_slist_remove+0x42> @ imm = #0x2e
 801bb12: 6878         	ldr	r0, [r7, #0x4]
 801bb14: f7ff ff1e    	bl	0x801b954 <z_snode_next_peek> @ imm = #-0x1c4
 801bb18: 4603         	mov	r3, r0
 801bb1a: 4619         	mov	r1, r3
 801bb1c: 68f8         	ldr	r0, [r7, #0xc]
 801bb1e: f7ff ff33    	bl	0x801b988 <z_slist_head_set> @ imm = #-0x19a
 801bb22: 68f8         	ldr	r0, [r7, #0xc]
 801bb24: f7ff ff58    	bl	0x801b9d8 <sys_slist_peek_tail> @ imm = #-0x150
 801bb28: 4602         	mov	r2, r0
 801bb2a: 687b         	ldr	r3, [r7, #0x4]
 801bb2c: 4293         	cmp	r3, r2
 801bb2e: d11b         	bne	0x801bb68 <sys_slist_remove+0x68> @ imm = #0x36
 801bb30: 68f8         	ldr	r0, [r7, #0xc]
 801bb32: f7ff ff45    	bl	0x801b9c0 <sys_slist_peek_head> @ imm = #-0x176
 801bb36: 4603         	mov	r3, r0
 801bb38: 4619         	mov	r1, r3
 801bb3a: 68f8         	ldr	r0, [r7, #0xc]
 801bb3c: f7ff ff32    	bl	0x801b9a4 <z_slist_tail_set> @ imm = #-0x19c
 801bb40: e012         	b	0x801bb68 <sys_slist_remove+0x68> @ imm = #0x24
 801bb42: 6878         	ldr	r0, [r7, #0x4]
 801bb44: f7ff ff06    	bl	0x801b954 <z_snode_next_peek> @ imm = #-0x1f4
 801bb48: 4603         	mov	r3, r0
 801bb4a: 4619         	mov	r1, r3
 801bb4c: 68b8         	ldr	r0, [r7, #0x8]
 801bb4e: f7ff ff0d    	bl	0x801b96c <z_snode_next_set> @ imm = #-0x1e6
 801bb52: 68f8         	ldr	r0, [r7, #0xc]
 801bb54: f7ff ff40    	bl	0x801b9d8 <sys_slist_peek_tail> @ imm = #-0x180
 801bb58: 4602         	mov	r2, r0
 801bb5a: 687b         	ldr	r3, [r7, #0x4]
 801bb5c: 4293         	cmp	r3, r2
 801bb5e: d103         	bne	0x801bb68 <sys_slist_remove+0x68> @ imm = #0x6
 801bb60: 68b9         	ldr	r1, [r7, #0x8]
 801bb62: 68f8         	ldr	r0, [r7, #0xc]
 801bb64: f7ff ff1e    	bl	0x801b9a4 <z_slist_tail_set> @ imm = #-0x1c4
 801bb68: 2100         	movs	r1, #0x0
 801bb6a: 6878         	ldr	r0, [r7, #0x4]
 801bb6c: f7ff fefe    	bl	0x801b96c <z_snode_next_set> @ imm = #-0x204
 801bb70: 3710         	adds	r7, #0x10
 801bb72: 46bd         	mov	sp, r7
 801bb74: bd80         	pop	{r7, pc}

0801bb76 <log_cache_get>:
; {
 801bb76: b590         	push	{r4, r7, lr}
 801bb78: b089         	sub	sp, #0x24
 801bb7a: af00         	add	r7, sp, #0x0
 801bb7c: 60f8         	str	r0, [r7, #0xc]
 801bb7e: 60b9         	str	r1, [r7, #0x8]
 801bb80: 607a         	str	r2, [r7, #0x4]
; 	sys_snode_t *prev_node = NULL;
 801bb82: 2300         	movs	r3, #0x0
 801bb84: 61fb         	str	r3, [r7, #0x1c]
; 	bool hit = false;
 801bb86: 2300         	movs	r3, #0x0
 801bb88: 75fb         	strb	r3, [r7, #0x17]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 801bb8a: 68fb         	ldr	r3, [r7, #0xc]
 801bb8c: 4618         	mov	r0, r3
 801bb8e: f7ff ff17    	bl	0x801b9c0 <sys_slist_peek_head> @ imm = #-0x1d2
 801bb92: 4603         	mov	r3, r0
 801bb94: 2b00         	cmp	r3, #0x0
 801bb96: d005         	beq	0x801bba4 <log_cache_get+0x2e> @ imm = #0xa
 801bb98: 68fb         	ldr	r3, [r7, #0xc]
 801bb9a: 4618         	mov	r0, r3
 801bb9c: f7ff ff10    	bl	0x801b9c0 <sys_slist_peek_head> @ imm = #-0x1e0
 801bba0: 4603         	mov	r3, r0
 801bba2: e000         	b	0x801bba6 <log_cache_get+0x30> @ imm = #0x0
 801bba4: 2300         	movs	r3, #0x0
 801bba6: 61bb         	str	r3, [r7, #0x18]
 801bba8: e02f         	b	0x801bc0a <log_cache_get+0x94> @ imm = #0x5e
; 		if (cache->cmp(entry->id, id)) {
 801bbaa: 68fb         	ldr	r3, [r7, #0xc]
 801bbac: 691b         	ldr	r3, [r3, #0x10]
 801bbae: 69ba         	ldr	r2, [r7, #0x18]
 801bbb0: 6852         	ldr	r2, [r2, #0x4]
 801bbb2: 68b9         	ldr	r1, [r7, #0x8]
 801bbb4: 4610         	mov	r0, r2
 801bbb6: 4798         	blx	r3
 801bbb8: 4603         	mov	r3, r0
 801bbba: 2b00         	cmp	r3, #0x0
 801bbbc: d007         	beq	0x801bbce <log_cache_get+0x58> @ imm = #0xe
; 			cache->hit++;
 801bbbe: 68fb         	ldr	r3, [r7, #0xc]
 801bbc0: 695b         	ldr	r3, [r3, #0x14]
 801bbc2: 1c5a         	adds	r2, r3, #0x1
 801bbc4: 68fb         	ldr	r3, [r7, #0xc]
 801bbc6: 615a         	str	r2, [r3, #0x14]
; 			hit = true;
 801bbc8: 2301         	movs	r3, #0x1
 801bbca: 75fb         	strb	r3, [r7, #0x17]
; 			break;
 801bbcc: e022         	b	0x801bc14 <log_cache_get+0x9e> @ imm = #0x44
; 		if (&entry->node == sys_slist_peek_tail(&cache->active)) {
 801bbce: 69bc         	ldr	r4, [r7, #0x18]
 801bbd0: 68fb         	ldr	r3, [r7, #0xc]
 801bbd2: 4618         	mov	r0, r3
 801bbd4: f7ff ff00    	bl	0x801b9d8 <sys_slist_peek_tail> @ imm = #-0x200
 801bbd8: 4603         	mov	r3, r0
 801bbda: 429c         	cmp	r4, r3
 801bbdc: d019         	beq	0x801bc12 <log_cache_get+0x9c> @ imm = #0x32
; 		prev_node = &entry->node;
 801bbde: 69bb         	ldr	r3, [r7, #0x18]
 801bbe0: 61fb         	str	r3, [r7, #0x1c]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 801bbe2: 69bb         	ldr	r3, [r7, #0x18]
 801bbe4: 2b00         	cmp	r3, #0x0
 801bbe6: d00e         	beq	0x801bc06 <log_cache_get+0x90> @ imm = #0x1c
 801bbe8: 69bb         	ldr	r3, [r7, #0x18]
 801bbea: 4618         	mov	r0, r3
 801bbec: f7ff ff1d    	bl	0x801ba2a <sys_slist_peek_next> @ imm = #-0x1c6
 801bbf0: 4603         	mov	r3, r0
 801bbf2: 2b00         	cmp	r3, #0x0
 801bbf4: d005         	beq	0x801bc02 <log_cache_get+0x8c> @ imm = #0xa
 801bbf6: 69bb         	ldr	r3, [r7, #0x18]
 801bbf8: 4618         	mov	r0, r3
 801bbfa: f7ff ff16    	bl	0x801ba2a <sys_slist_peek_next> @ imm = #-0x1d4
 801bbfe: 4603         	mov	r3, r0
 801bc00: e002         	b	0x801bc08 <log_cache_get+0x92> @ imm = #0x4
 801bc02: 2300         	movs	r3, #0x0
 801bc04: e000         	b	0x801bc08 <log_cache_get+0x92> @ imm = #0x0
 801bc06: 2300         	movs	r3, #0x0
 801bc08: 61bb         	str	r3, [r7, #0x18]
 801bc0a: 69bb         	ldr	r3, [r7, #0x18]
 801bc0c: 2b00         	cmp	r3, #0x0
 801bc0e: d1cc         	bne	0x801bbaa <log_cache_get+0x34> @ imm = #-0x68
 801bc10: e000         	b	0x801bc14 <log_cache_get+0x9e> @ imm = #0x0
; 			break;
 801bc12: bf00         	nop
; 	if (hit) {
 801bc14: 7dfb         	ldrb	r3, [r7, #0x17]
 801bc16: 2b00         	cmp	r3, #0x0
 801bc18: d00c         	beq	0x801bc34 <log_cache_get+0xbe> @ imm = #0x18
; 		sys_slist_remove(&cache->active, prev_node, &entry->node);
 801bc1a: 68fb         	ldr	r3, [r7, #0xc]
 801bc1c: 69ba         	ldr	r2, [r7, #0x18]
 801bc1e: 69f9         	ldr	r1, [r7, #0x1c]
 801bc20: 4618         	mov	r0, r3
 801bc22: f7ff ff6d    	bl	0x801bb00 <sys_slist_remove> @ imm = #-0x126
; 		sys_slist_prepend(&cache->active, &entry->node);
 801bc26: 68fb         	ldr	r3, [r7, #0xc]
 801bc28: 69ba         	ldr	r2, [r7, #0x18]
 801bc2a: 4611         	mov	r1, r2
 801bc2c: 4618         	mov	r0, r3
 801bc2e: f7ff ff0d    	bl	0x801ba4c <sys_slist_prepend> @ imm = #-0x1e6
 801bc32: e016         	b	0x801bc62 <log_cache_get+0xec> @ imm = #0x2c
; 		cache->miss++;
 801bc34: 68fb         	ldr	r3, [r7, #0xc]
 801bc36: 699b         	ldr	r3, [r3, #0x18]
 801bc38: 1c5a         	adds	r2, r3, #0x1
 801bc3a: 68fb         	ldr	r3, [r7, #0xc]
 801bc3c: 619a         	str	r2, [r3, #0x18]
; 		sys_snode_t *from_idle = sys_slist_get(&cache->idle);
 801bc3e: 68fb         	ldr	r3, [r7, #0xc]
 801bc40: 3308         	adds	r3, #0x8
 801bc42: 4618         	mov	r0, r3
 801bc44: f7ff ff48    	bl	0x801bad8 <sys_slist_get> @ imm = #-0x170
 801bc48: 6138         	str	r0, [r7, #0x10]
; 		if (from_idle) {
 801bc4a: 693b         	ldr	r3, [r7, #0x10]
 801bc4c: 2b00         	cmp	r3, #0x0
 801bc4e: d002         	beq	0x801bc56 <log_cache_get+0xe0> @ imm = #0x4
; 			entry = CONTAINER_OF(from_idle, struct log_cache_entry, node);
 801bc50: 693b         	ldr	r3, [r7, #0x10]
 801bc52: 61bb         	str	r3, [r7, #0x18]
 801bc54: e005         	b	0x801bc62 <log_cache_get+0xec> @ imm = #0xa
; 			sys_slist_remove(&cache->active, prev_node, &entry->node);
 801bc56: 68fb         	ldr	r3, [r7, #0xc]
 801bc58: 69ba         	ldr	r2, [r7, #0x18]
 801bc5a: 69f9         	ldr	r1, [r7, #0x1c]
 801bc5c: 4618         	mov	r0, r3
 801bc5e: f7ff ff4f    	bl	0x801bb00 <sys_slist_remove> @ imm = #-0x162
; 	*data = entry->data;
 801bc62: 69bb         	ldr	r3, [r7, #0x18]
 801bc64: f103 0208    	add.w	r2, r3, #0x8
 801bc68: 687b         	ldr	r3, [r7, #0x4]
 801bc6a: 601a         	str	r2, [r3]
; 	entry->id = id;
 801bc6c: 69bb         	ldr	r3, [r7, #0x18]
 801bc6e: 68ba         	ldr	r2, [r7, #0x8]
 801bc70: 605a         	str	r2, [r3, #0x4]
; 	return hit;
 801bc72: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 801bc74: 4618         	mov	r0, r3
 801bc76: 3724         	adds	r7, #0x24
 801bc78: 46bd         	mov	sp, r7
 801bc7a: bd90         	pop	{r4, r7, pc}

0801bc7c <log_cache_put>:
; {
 801bc7c: b580         	push	{r7, lr}
 801bc7e: b084         	sub	sp, #0x10
 801bc80: af00         	add	r7, sp, #0x0
 801bc82: 6078         	str	r0, [r7, #0x4]
 801bc84: 6039         	str	r1, [r7]
; 	struct log_cache_entry *entry = CONTAINER_OF(data, struct log_cache_entry, data[0]);
 801bc86: 683b         	ldr	r3, [r7]
 801bc88: 3b08         	subs	r3, #0x8
 801bc8a: 60fb         	str	r3, [r7, #0xc]
; 	sys_slist_prepend(&cache->active, &entry->node);
 801bc8c: 687b         	ldr	r3, [r7, #0x4]
 801bc8e: 68fa         	ldr	r2, [r7, #0xc]
 801bc90: 4611         	mov	r1, r2
 801bc92: 4618         	mov	r0, r3
 801bc94: f7ff feda    	bl	0x801ba4c <sys_slist_prepend> @ imm = #-0x24c
; }
 801bc98: bf00         	nop
 801bc9a: 3710         	adds	r7, #0x10
 801bc9c: 46bd         	mov	sp, r7
 801bc9e: bd80         	pop	{r7, pc}

0801bca0 <z_log_msg_runtime_create>:
; {
 801bca0: b580         	push	{r7, lr}
 801bca2: b08a         	sub	sp, #0x28
 801bca4: af04         	add	r7, sp, #0x10
 801bca6: 60b9         	str	r1, [r7, #0x8]
 801bca8: 607b         	str	r3, [r7, #0x4]
 801bcaa: 4603         	mov	r3, r0
 801bcac: 73fb         	strb	r3, [r7, #0xf]
 801bcae: 4613         	mov	r3, r2
 801bcb0: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801bcb2: f107 032c    	add.w	r3, r7, #0x2c
 801bcb6: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801bcb8: 7bba         	ldrb	r2, [r7, #0xe]
 801bcba: 7bf8         	ldrb	r0, [r7, #0xf]
 801bcbc: 697b         	ldr	r3, [r7, #0x14]
 801bcbe: 9303         	str	r3, [sp, #0xc]
 801bcc0: 6abb         	ldr	r3, [r7, #0x28]
 801bcc2: 9302         	str	r3, [sp, #0x8]
 801bcc4: 6a7b         	ldr	r3, [r7, #0x24]
 801bcc6: 9301         	str	r3, [sp, #0x4]
 801bcc8: 6a3b         	ldr	r3, [r7, #0x20]
 801bcca: 9300         	str	r3, [sp]
 801bccc: 687b         	ldr	r3, [r7, #0x4]
 801bcce: 68b9         	ldr	r1, [r7, #0x8]
 801bcd0: f7e8 ff38    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x17190
; }
 801bcd4: bf00         	nop
 801bcd6: 3718         	adds	r7, #0x18
 801bcd8: 46bd         	mov	sp, r7
 801bcda: bd80         	pop	{r7, pc}

0801bcdc <log_msg_get_domain>:
; {
 801bcdc: b480         	push	{r7}
 801bcde: b083         	sub	sp, #0xc
 801bce0: af00         	add	r7, sp, #0x0
 801bce2: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 801bce4: 687b         	ldr	r3, [r7, #0x4]
 801bce6: 781b         	ldrb	r3, [r3]
 801bce8: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 801bcec: b2db         	uxtb	r3, r3
; }
 801bcee: 4618         	mov	r0, r3
 801bcf0: 370c         	adds	r7, #0xc
 801bcf2: 46bd         	mov	sp, r7
 801bcf4: f85d 7b04    	ldr	r7, [sp], #4
 801bcf8: 4770         	bx	lr

0801bcfa <log_msg_get_source>:
; {
 801bcfa: b480         	push	{r7}
 801bcfc: b083         	sub	sp, #0xc
 801bcfe: af00         	add	r7, sp, #0x0
 801bd00: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.source;
 801bd02: 687b         	ldr	r3, [r7, #0x4]
 801bd04: 685b         	ldr	r3, [r3, #0x4]
; }
 801bd06: 4618         	mov	r0, r3
 801bd08: 370c         	adds	r7, #0xc
 801bd0a: 46bd         	mov	sp, r7
 801bd0c: f85d 7b04    	ldr	r7, [sp], #4
 801bd10: 4770         	bx	lr

0801bd12 <log_source_id>:
; {
 801bd12: b580         	push	{r7, lr}
 801bd14: b082         	sub	sp, #0x8
 801bd16: af00         	add	r7, sp, #0x0
 801bd18: 6078         	str	r0, [r7, #0x4]
; 		log_dynamic_source_id((struct log_source_dynamic_data *)source) :
 801bd1a: 6878         	ldr	r0, [r7, #0x4]
 801bd1c: f7e8 ff02    	bl	0x8004b24 <log_const_source_id> @ imm = #-0x171fc
 801bd20: 4603         	mov	r3, r0
; }
 801bd22: 4618         	mov	r0, r3
 801bd24: 3708         	adds	r7, #0x8
 801bd26: 46bd         	mov	sp, r7
 801bd28: bd80         	pop	{r7, pc}

0801bd2a <z_log_is_local_domain>:
; {
 801bd2a: b480         	push	{r7}
 801bd2c: b083         	sub	sp, #0xc
 801bd2e: af00         	add	r7, sp, #0x0
 801bd30: 4603         	mov	r3, r0
 801bd32: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 801bd34: 2301         	movs	r3, #0x1
; }
 801bd36: 4618         	mov	r0, r3
 801bd38: 370c         	adds	r7, #0xc
 801bd3a: 46bd         	mov	sp, r7
 801bd3c: f85d 7b04    	ldr	r7, [sp], #4
 801bd40: 4770         	bx	lr

0801bd42 <z_log_msg_finalize>:
; {
 801bd42: b580         	push	{r7, lr}
 801bd44: b086         	sub	sp, #0x18
 801bd46: af00         	add	r7, sp, #0x0
 801bd48: 60f8         	str	r0, [r7, #0xc]
 801bd4a: 60b9         	str	r1, [r7, #0x8]
 801bd4c: 607a         	str	r2, [r7, #0x4]
 801bd4e: 603b         	str	r3, [r7]
; 	if (!msg) {
 801bd50: 68fb         	ldr	r3, [r7, #0xc]
 801bd52: 2b00         	cmp	r3, #0x0
 801bd54: d103         	bne	0x801bd5e <z_log_msg_finalize+0x1c> @ imm = #0x6
; 		z_log_dropped(false);
 801bd56: 2000         	movs	r0, #0x0
 801bd58: f7e8 fde6    	bl	0x8004928 <z_log_dropped> @ imm = #-0x17434
; 		return;
 801bd5c: e01c         	b	0x801bd98 <z_log_msg_finalize+0x56> @ imm = #0x38
; 	if (data) {
 801bd5e: 683b         	ldr	r3, [r7]
 801bd60: 2b00         	cmp	r3, #0x0
 801bd62: d010         	beq	0x801bd86 <z_log_msg_finalize+0x44> @ imm = #0x20
; 		uint8_t *d = msg->data + desc.package_len;
 801bd64: 68fb         	ldr	r3, [r7, #0xc]
 801bd66: 3310         	adds	r3, #0x10
 801bd68: 687a         	ldr	r2, [r7, #0x4]
 801bd6a: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 801bd6e: b292         	uxth	r2, r2
 801bd70: 4413         	add	r3, r2
 801bd72: 617b         	str	r3, [r7, #0x14]
; 		memcpy(d, data, desc.data_len);
 801bd74: 88fb         	ldrh	r3, [r7, #0x6]
 801bd76: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 801bd7a: b29b         	uxth	r3, r3
 801bd7c: 461a         	mov	r2, r3
 801bd7e: 6839         	ldr	r1, [r7]
 801bd80: 6978         	ldr	r0, [r7, #0x14]
 801bd82: f00b fbb3    	bl	0x80274ec <memcpy>      @ imm = #0xb766
; 	msg->hdr.desc = desc;
 801bd86: 68fb         	ldr	r3, [r7, #0xc]
 801bd88: 687a         	ldr	r2, [r7, #0x4]
 801bd8a: 601a         	str	r2, [r3]
; 	msg->hdr.source = source;
 801bd8c: 68fb         	ldr	r3, [r7, #0xc]
 801bd8e: 68ba         	ldr	r2, [r7, #0x8]
 801bd90: 605a         	str	r2, [r3, #0x4]
; 	z_log_msg_commit(msg);
 801bd92: 68f8         	ldr	r0, [r7, #0xc]
 801bd94: f7e8 fdde    	bl	0x8004954 <z_log_msg_commit> @ imm = #-0x17444
; }
 801bd98: 3718         	adds	r7, #0x18
 801bd9a: 46bd         	mov	sp, r7
 801bd9c: bd80         	pop	{r7, pc}

0801bd9e <log_msg_get_source_id>:
; {
 801bd9e: b580         	push	{r7, lr}
 801bda0: b084         	sub	sp, #0x10
 801bda2: af00         	add	r7, sp, #0x0
 801bda4: 6078         	str	r0, [r7, #0x4]
; 	if (!z_log_is_local_domain(log_msg_get_domain(msg))) {
 801bda6: 6878         	ldr	r0, [r7, #0x4]
 801bda8: f7ff ff98    	bl	0x801bcdc <log_msg_get_domain> @ imm = #-0xd0
 801bdac: 4603         	mov	r3, r0
 801bdae: 4618         	mov	r0, r3
 801bdb0: f7ff ffbb    	bl	0x801bd2a <z_log_is_local_domain> @ imm = #-0x8a
 801bdb4: 4603         	mov	r3, r0
 801bdb6: f083 0301    	eor	r3, r3, #0x1
 801bdba: b2db         	uxtb	r3, r3
 801bdbc: 2b00         	cmp	r3, #0x0
 801bdbe: d005         	beq	0x801bdcc <log_msg_get_source_id+0x2e> @ imm = #0xa
; 		return (int16_t)(uintptr_t)log_msg_get_source(msg);
 801bdc0: 6878         	ldr	r0, [r7, #0x4]
 801bdc2: f7ff ff9a    	bl	0x801bcfa <log_msg_get_source> @ imm = #-0xcc
 801bdc6: 4603         	mov	r3, r0
 801bdc8: b21b         	sxth	r3, r3
 801bdca: e00e         	b	0x801bdea <log_msg_get_source_id+0x4c> @ imm = #0x1c
; 	void *source = (void *)log_msg_get_source(msg);
 801bdcc: 6878         	ldr	r0, [r7, #0x4]
 801bdce: f7ff ff94    	bl	0x801bcfa <log_msg_get_source> @ imm = #-0xd8
 801bdd2: 60f8         	str	r0, [r7, #0xc]
; 	if (source != NULL) {
 801bdd4: 68fb         	ldr	r3, [r7, #0xc]
 801bdd6: 2b00         	cmp	r3, #0x0
 801bdd8: d005         	beq	0x801bde6 <log_msg_get_source_id+0x48> @ imm = #0xa
; 		return log_source_id(source);
 801bdda: 68f8         	ldr	r0, [r7, #0xc]
 801bddc: f7ff ff99    	bl	0x801bd12 <log_source_id> @ imm = #-0xce
 801bde0: 4603         	mov	r3, r0
 801bde2: b21b         	sxth	r3, r3
 801bde4: e001         	b	0x801bdea <log_msg_get_source_id+0x4c> @ imm = #0x2
; 	return -1;
 801bde6: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 801bdea: 4618         	mov	r0, r3
 801bdec: 3710         	adds	r7, #0x10
 801bdee: 46bd         	mov	sp, r7
 801bdf0: bd80         	pop	{r7, pc}

0801bdf2 <log_msg_get_domain>:
; {
 801bdf2: b480         	push	{r7}
 801bdf4: b083         	sub	sp, #0xc
 801bdf6: af00         	add	r7, sp, #0x0
 801bdf8: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 801bdfa: 687b         	ldr	r3, [r7, #0x4]
 801bdfc: 781b         	ldrb	r3, [r3]
 801bdfe: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 801be02: b2db         	uxtb	r3, r3
; }
 801be04: 4618         	mov	r0, r3
 801be06: 370c         	adds	r7, #0xc
 801be08: 46bd         	mov	sp, r7
 801be0a: f85d 7b04    	ldr	r7, [sp], #4
 801be0e: 4770         	bx	lr

0801be10 <log_msg_get_level>:
; {
 801be10: b480         	push	{r7}
 801be12: b083         	sub	sp, #0xc
 801be14: af00         	add	r7, sp, #0x0
 801be16: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.level;
 801be18: 687b         	ldr	r3, [r7, #0x4]
 801be1a: 881b         	ldrh	r3, [r3]
 801be1c: f3c3 1382    	ubfx	r3, r3, #0x6, #0x3
 801be20: b2db         	uxtb	r3, r3
; }
 801be22: 4618         	mov	r0, r3
 801be24: 370c         	adds	r7, #0xc
 801be26: 46bd         	mov	sp, r7
 801be28: f85d 7b04    	ldr	r7, [sp], #4
 801be2c: 4770         	bx	lr

0801be2e <log_msg_get_timestamp>:
; {
 801be2e: b480         	push	{r7}
 801be30: b083         	sub	sp, #0xc
 801be32: af00         	add	r7, sp, #0x0
 801be34: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.timestamp;
 801be36: 687b         	ldr	r3, [r7, #0x4]
 801be38: 689b         	ldr	r3, [r3, #0x8]
; }
 801be3a: 4618         	mov	r0, r3
 801be3c: 370c         	adds	r7, #0xc
 801be3e: 46bd         	mov	sp, r7
 801be40: f85d 7b04    	ldr	r7, [sp], #4
 801be44: 4770         	bx	lr

0801be46 <log_msg_get_tid>:
; {
 801be46: b480         	push	{r7}
 801be48: b083         	sub	sp, #0xc
 801be4a: af00         	add	r7, sp, #0x0
 801be4c: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 801be4e: 2300         	movs	r3, #0x0
; }
 801be50: 4618         	mov	r0, r3
 801be52: 370c         	adds	r7, #0xc
 801be54: 46bd         	mov	sp, r7
 801be56: f85d 7b04    	ldr	r7, [sp], #4
 801be5a: 4770         	bx	lr

0801be5c <log_msg_get_data>:
; {
 801be5c: b480         	push	{r7}
 801be5e: b083         	sub	sp, #0xc
 801be60: af00         	add	r7, sp, #0x0
 801be62: 6078         	str	r0, [r7, #0x4]
 801be64: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.data_len;
 801be66: 687b         	ldr	r3, [r7, #0x4]
 801be68: 885b         	ldrh	r3, [r3, #0x2]
 801be6a: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 801be6e: b29b         	uxth	r3, r3
 801be70: 461a         	mov	r2, r3
 801be72: 683b         	ldr	r3, [r7]
 801be74: 601a         	str	r2, [r3]
; 	return msg->data + msg->hdr.desc.package_len;
 801be76: 687b         	ldr	r3, [r7, #0x4]
 801be78: 3310         	adds	r3, #0x10
 801be7a: 687a         	ldr	r2, [r7, #0x4]
 801be7c: 6812         	ldr	r2, [r2]
 801be7e: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 801be82: b292         	uxth	r2, r2
 801be84: 4413         	add	r3, r2
; }
 801be86: 4618         	mov	r0, r3
 801be88: 370c         	adds	r7, #0xc
 801be8a: 46bd         	mov	sp, r7
 801be8c: f85d 7b04    	ldr	r7, [sp], #4
 801be90: 4770         	bx	lr

0801be92 <log_msg_get_package>:
; {
 801be92: b480         	push	{r7}
 801be94: b083         	sub	sp, #0xc
 801be96: af00         	add	r7, sp, #0x0
 801be98: 6078         	str	r0, [r7, #0x4]
 801be9a: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.package_len;
 801be9c: 687b         	ldr	r3, [r7, #0x4]
 801be9e: 681b         	ldr	r3, [r3]
 801bea0: f3c3 234a    	ubfx	r3, r3, #0x9, #0xb
 801bea4: b29b         	uxth	r3, r3
 801bea6: 461a         	mov	r2, r3
 801bea8: 683b         	ldr	r3, [r7]
 801beaa: 601a         	str	r2, [r3]
; 	return msg->data;
 801beac: 687b         	ldr	r3, [r7, #0x4]
 801beae: 3310         	adds	r3, #0x10
; }
 801beb0: 4618         	mov	r0, r3
 801beb2: 370c         	adds	r7, #0xc
 801beb4: 46bd         	mov	sp, r7
 801beb6: f85d 7b04    	ldr	r7, [sp], #4
 801beba: 4770         	bx	lr

0801bebc <log_output_write>:
; {
 801bebc: b580         	push	{r7, lr}
 801bebe: b086         	sub	sp, #0x18
 801bec0: af00         	add	r7, sp, #0x0
 801bec2: 60f8         	str	r0, [r7, #0xc]
 801bec4: 60b9         	str	r1, [r7, #0x8]
 801bec6: 607a         	str	r2, [r7, #0x4]
 801bec8: 603b         	str	r3, [r7]
; 	while (len != 0) {
 801beca: e00d         	b	0x801bee8 <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 801becc: 68fb         	ldr	r3, [r7, #0xc]
 801bece: 683a         	ldr	r2, [r7]
 801bed0: 6879         	ldr	r1, [r7, #0x4]
 801bed2: 68b8         	ldr	r0, [r7, #0x8]
 801bed4: 4798         	blx	r3
 801bed6: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 801bed8: 697b         	ldr	r3, [r7, #0x14]
 801beda: 687a         	ldr	r2, [r7, #0x4]
 801bedc: 1ad3         	subs	r3, r2, r3
 801bede: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 801bee0: 697b         	ldr	r3, [r7, #0x14]
 801bee2: 68ba         	ldr	r2, [r7, #0x8]
 801bee4: 4413         	add	r3, r2
 801bee6: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 801bee8: 687b         	ldr	r3, [r7, #0x4]
 801beea: 2b00         	cmp	r3, #0x0
 801beec: d1ee         	bne	0x801becc <log_output_write+0x10> @ imm = #-0x24
; }
 801beee: bf00         	nop
 801bef0: bf00         	nop
 801bef2: 3718         	adds	r7, #0x18
 801bef4: 46bd         	mov	sp, r7
 801bef6: bd80         	pop	{r7, pc}

0801bef8 <log_output_flush>:
; {
 801bef8: b580         	push	{r7, lr}
 801befa: b082         	sub	sp, #0x8
 801befc: af00         	add	r7, sp, #0x0
 801befe: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 801bf00: 687b         	ldr	r3, [r7, #0x4]
 801bf02: 6818         	ldr	r0, [r3]
 801bf04: 687b         	ldr	r3, [r7, #0x4]
 801bf06: 6899         	ldr	r1, [r3, #0x8]
 801bf08: 687b         	ldr	r3, [r7, #0x4]
 801bf0a: 685b         	ldr	r3, [r3, #0x4]
 801bf0c: 681b         	ldr	r3, [r3]
 801bf0e: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 801bf10: 687b         	ldr	r3, [r7, #0x4]
 801bf12: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 801bf14: 685b         	ldr	r3, [r3, #0x4]
 801bf16: f7ff ffd1    	bl	0x801bebc <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 801bf1a: 687b         	ldr	r3, [r7, #0x4]
 801bf1c: 685b         	ldr	r3, [r3, #0x4]
 801bf1e: 2200         	movs	r2, #0x0
 801bf20: 601a         	str	r2, [r3]
; }
 801bf22: bf00         	nop
 801bf24: 3708         	adds	r7, #0x8
 801bf26: 46bd         	mov	sp, r7
 801bf28: bd80         	pop	{r7, pc}

0801bf2a <out_func>:
; {
 801bf2a: b580         	push	{r7, lr}
 801bf2c: b084         	sub	sp, #0x10
 801bf2e: af00         	add	r7, sp, #0x0
 801bf30: 6078         	str	r0, [r7, #0x4]
 801bf32: 6039         	str	r1, [r7]
; 	const struct log_output *out_ctx = (const struct log_output *)ctx;
 801bf34: 683b         	ldr	r3, [r7]
 801bf36: 60fb         	str	r3, [r7, #0xc]
; 		char x = (char)c;
 801bf38: 687b         	ldr	r3, [r7, #0x4]
 801bf3a: b2db         	uxtb	r3, r3
 801bf3c: 72fb         	strb	r3, [r7, #0xb]
; 		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
 801bf3e: 68fb         	ldr	r3, [r7, #0xc]
 801bf40: 681b         	ldr	r3, [r3]
 801bf42: 68fa         	ldr	r2, [r7, #0xc]
 801bf44: 6852         	ldr	r2, [r2, #0x4]
 801bf46: 6852         	ldr	r2, [r2, #0x4]
 801bf48: f107 000b    	add.w	r0, r7, #0xb
 801bf4c: 2101         	movs	r1, #0x1
 801bf4e: 4798         	blx	r3
; 		return 0;
 801bf50: 2300         	movs	r3, #0x0
; }
 801bf52: 4618         	mov	r0, r3
 801bf54: 3710         	adds	r7, #0x10
 801bf56: 46bd         	mov	sp, r7
 801bf58: bd80         	pop	{r7, pc}

0801bf5a <cr_out_func>:
; {
 801bf5a: b580         	push	{r7, lr}
 801bf5c: b082         	sub	sp, #0x8
 801bf5e: af00         	add	r7, sp, #0x0
 801bf60: 6078         	str	r0, [r7, #0x4]
 801bf62: 6039         	str	r1, [r7]
; 	if (c == '\n') {
 801bf64: 687b         	ldr	r3, [r7, #0x4]
 801bf66: 2b0a         	cmp	r3, #0xa
 801bf68: d103         	bne	0x801bf72 <cr_out_func+0x18> @ imm = #0x6
; 		out_func((int)'\r', ctx);
 801bf6a: 6839         	ldr	r1, [r7]
 801bf6c: 200d         	movs	r0, #0xd
 801bf6e: f7ff ffdc    	bl	0x801bf2a <out_func>    @ imm = #-0x48
; 	out_func(c, ctx);
 801bf72: 6839         	ldr	r1, [r7]
 801bf74: 6878         	ldr	r0, [r7, #0x4]
 801bf76: f7ff ffd8    	bl	0x801bf2a <out_func>    @ imm = #-0x50
; 	return 0;
 801bf7a: 2300         	movs	r3, #0x0
; }
 801bf7c: 4618         	mov	r0, r3
 801bf7e: 3708         	adds	r7, #0x8
 801bf80: 46bd         	mov	sp, r7
 801bf82: bd80         	pop	{r7, pc}

0801bf84 <color_prefix>:
; {
 801bf84: b580         	push	{r7, lr}
 801bf86: b084         	sub	sp, #0x10
 801bf88: af00         	add	r7, sp, #0x0
 801bf8a: 60f8         	str	r0, [r7, #0xc]
 801bf8c: 460b         	mov	r3, r1
 801bf8e: 607a         	str	r2, [r7, #0x4]
 801bf90: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, true, level);
 801bf92: 7af9         	ldrb	r1, [r7, #0xb]
 801bf94: 687b         	ldr	r3, [r7, #0x4]
 801bf96: 2201         	movs	r2, #0x1
 801bf98: 68f8         	ldr	r0, [r7, #0xc]
 801bf9a: f7e8 ff45    	bl	0x8004e28 <color_print> @ imm = #-0x17176
; }
 801bf9e: bf00         	nop
 801bfa0: 3710         	adds	r7, #0x10
 801bfa2: 46bd         	mov	sp, r7
 801bfa4: bd80         	pop	{r7, pc}

0801bfa6 <color_postfix>:
; {
 801bfa6: b580         	push	{r7, lr}
 801bfa8: b084         	sub	sp, #0x10
 801bfaa: af00         	add	r7, sp, #0x0
 801bfac: 60f8         	str	r0, [r7, #0xc]
 801bfae: 460b         	mov	r3, r1
 801bfb0: 607a         	str	r2, [r7, #0x4]
 801bfb2: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, false, level);
 801bfb4: 7af9         	ldrb	r1, [r7, #0xb]
 801bfb6: 687b         	ldr	r3, [r7, #0x4]
 801bfb8: 2200         	movs	r2, #0x0
 801bfba: 68f8         	ldr	r0, [r7, #0xc]
 801bfbc: f7e8 ff34    	bl	0x8004e28 <color_print> @ imm = #-0x17198
; }
 801bfc0: bf00         	nop
 801bfc2: 3710         	adds	r7, #0x10
 801bfc4: 46bd         	mov	sp, r7
 801bfc6: bd80         	pop	{r7, pc}

0801bfc8 <log_msg_hexdump>:
; {
 801bfc8: b580         	push	{r7, lr}
 801bfca: b088         	sub	sp, #0x20
 801bfcc: af02         	add	r7, sp, #0x8
 801bfce: 60f8         	str	r0, [r7, #0xc]
 801bfd0: 60b9         	str	r1, [r7, #0x8]
 801bfd2: 607a         	str	r2, [r7, #0x4]
 801bfd4: 603b         	str	r3, [r7]
; 		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 801bfd6: 687b         	ldr	r3, [r7, #0x4]
 801bfd8: 2b10         	cmp	r3, #0x10
 801bfda: bf28         	it	hs
 801bfdc: 2310         	movhs	r3, #0x10
 801bfde: 617b         	str	r3, [r7, #0x14]
; 		hexdump_line_print(output, data, length,
 801bfe0: 6a3b         	ldr	r3, [r7, #0x20]
 801bfe2: 9300         	str	r3, [sp]
 801bfe4: 683b         	ldr	r3, [r7]
 801bfe6: 697a         	ldr	r2, [r7, #0x14]
 801bfe8: 68b9         	ldr	r1, [r7, #0x8]
 801bfea: 68f8         	ldr	r0, [r7, #0xc]
 801bfec: f7e8 ffba    	bl	0x8004f64 <hexdump_line_print> @ imm = #-0x1708c
; 		data += length;
 801bff0: 68ba         	ldr	r2, [r7, #0x8]
 801bff2: 697b         	ldr	r3, [r7, #0x14]
 801bff4: 4413         	add	r3, r2
 801bff6: 60bb         	str	r3, [r7, #0x8]
; 		len -= length;
 801bff8: 687a         	ldr	r2, [r7, #0x4]
 801bffa: 697b         	ldr	r3, [r7, #0x14]
 801bffc: 1ad3         	subs	r3, r2, r3
 801bffe: 607b         	str	r3, [r7, #0x4]
; 	} while (len);
 801c000: 687b         	ldr	r3, [r7, #0x4]
 801c002: 2b00         	cmp	r3, #0x0
 801c004: d1e7         	bne	0x801bfd6 <log_msg_hexdump+0xe> @ imm = #-0x32
; }
 801c006: bf00         	nop
 801c008: bf00         	nop
 801c00a: 3718         	adds	r7, #0x18
 801c00c: 46bd         	mov	sp, r7
 801c00e: bd80         	pop	{r7, pc}

0801c010 <postfix_print>:
; {
 801c010: b580         	push	{r7, lr}
 801c012: b084         	sub	sp, #0x10
 801c014: af00         	add	r7, sp, #0x0
 801c016: 60f8         	str	r0, [r7, #0xc]
 801c018: 60b9         	str	r1, [r7, #0x8]
 801c01a: 4613         	mov	r3, r2
 801c01c: 71fb         	strb	r3, [r7, #0x7]
; 	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
 801c01e: 68bb         	ldr	r3, [r7, #0x8]
 801c020: f003 0301    	and	r3, r3, #0x1
 801c024: 2b00         	cmp	r3, #0x0
 801c026: bf14         	ite	ne
 801c028: 2301         	movne	r3, #0x1
 801c02a: 2300         	moveq	r3, #0x0
 801c02c: b2db         	uxtb	r3, r3
 801c02e: 79fa         	ldrb	r2, [r7, #0x7]
 801c030: 4619         	mov	r1, r3
 801c032: 68f8         	ldr	r0, [r7, #0xc]
 801c034: f7ff ffb7    	bl	0x801bfa6 <color_postfix> @ imm = #-0x92
; 	newline_print(output, flags);
 801c038: 68b9         	ldr	r1, [r7, #0x8]
 801c03a: 68f8         	ldr	r0, [r7, #0xc]
 801c03c: f7e8 ff70    	bl	0x8004f20 <newline_print> @ imm = #-0x17120
; }
 801c040: bf00         	nop
 801c042: 3710         	adds	r7, #0x10
 801c044: 46bd         	mov	sp, r7
 801c046: bd80         	pop	{r7, pc}

0801c048 <log_output_msg_process>:
; {
 801c048: b580         	push	{r7, lr}
 801c04a: b092         	sub	sp, #0x48
 801c04c: af06         	add	r7, sp, #0x18
 801c04e: 60f8         	str	r0, [r7, #0xc]
 801c050: 60b9         	str	r1, [r7, #0x8]
 801c052: 607a         	str	r2, [r7, #0x4]
; 	log_timestamp_t timestamp = log_msg_get_timestamp(msg);
 801c054: 68b8         	ldr	r0, [r7, #0x8]
 801c056: f7ff feea    	bl	0x801be2e <log_msg_get_timestamp> @ imm = #-0x22c
 801c05a: 62f8         	str	r0, [r7, #0x2c]
; 	uint8_t level = log_msg_get_level(msg);
 801c05c: 68b8         	ldr	r0, [r7, #0x8]
 801c05e: f7ff fed7    	bl	0x801be10 <log_msg_get_level> @ imm = #-0x252
 801c062: 4603         	mov	r3, r0
 801c064: f887 302b    	strb.w	r3, [r7, #0x2b]
; 	uint8_t domain_id = log_msg_get_domain(msg);
 801c068: 68b8         	ldr	r0, [r7, #0x8]
 801c06a: f7ff fec2    	bl	0x801bdf2 <log_msg_get_domain> @ imm = #-0x27c
 801c06e: 4603         	mov	r3, r0
 801c070: f887 302a    	strb.w	r3, [r7, #0x2a]
; 	int16_t source_id = log_msg_get_source_id(msg);
 801c074: 68b8         	ldr	r0, [r7, #0x8]
 801c076: f7ff fe92    	bl	0x801bd9e <log_msg_get_source_id> @ imm = #-0x2dc
 801c07a: 4603         	mov	r3, r0
 801c07c: 853b         	strh	r3, [r7, #0x28]
; 	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
 801c07e: f9b7 3028    	ldrsh.w	r3, [r7, #0x28]
 801c082: 2b00         	cmp	r3, #0x0
 801c084: db09         	blt	0x801c09a <log_output_msg_process+0x52> @ imm = #0x12
 801c086: f897 302a    	ldrb.w	r3, [r7, #0x2a]
 801c08a: f9b7 2028    	ldrsh.w	r2, [r7, #0x28]
 801c08e: 4611         	mov	r1, r2
 801c090: 4618         	mov	r0, r3
 801c092: f7e8 fd1f    	bl	0x8004ad4 <log_source_name_get> @ imm = #-0x175c2
 801c096: 4603         	mov	r3, r0
 801c098: e000         	b	0x801c09c <log_output_msg_process+0x54> @ imm = #0x0
 801c09a: 2300         	movs	r3, #0x0
 801c09c: 627b         	str	r3, [r7, #0x24]
; 	uint8_t *package = log_msg_get_package(msg, &plen);
 801c09e: f107 0318    	add.w	r3, r7, #0x18
 801c0a2: 4619         	mov	r1, r3
 801c0a4: 68b8         	ldr	r0, [r7, #0x8]
 801c0a6: f7ff fef4    	bl	0x801be92 <log_msg_get_package> @ imm = #-0x218
 801c0aa: 6238         	str	r0, [r7, #0x20]
; 	uint8_t *data = log_msg_get_data(msg, &dlen);
 801c0ac: f107 0314    	add.w	r3, r7, #0x14
 801c0b0: 4619         	mov	r1, r3
 801c0b2: 68b8         	ldr	r0, [r7, #0x8]
 801c0b4: f7ff fed2    	bl	0x801be5c <log_msg_get_data> @ imm = #-0x25c
 801c0b8: 61f8         	str	r0, [r7, #0x1c]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 801c0ba: 68b8         	ldr	r0, [r7, #0x8]
 801c0bc: f7ff fec3    	bl	0x801be46 <log_msg_get_tid> @ imm = #-0x27a
; 			   plen > 0 ? package : NULL, data, dlen, flags);
 801c0c0: 69bb         	ldr	r3, [r7, #0x18]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 801c0c2: 2b00         	cmp	r3, #0x0
 801c0c4: d001         	beq	0x801c0ca <log_output_msg_process+0x82> @ imm = #0x2
 801c0c6: 6a3b         	ldr	r3, [r7, #0x20]
 801c0c8: e000         	b	0x801c0cc <log_output_msg_process+0x84> @ imm = #0x0
 801c0ca: 2300         	movs	r3, #0x0
 801c0cc: 697a         	ldr	r2, [r7, #0x14]
 801c0ce: 6879         	ldr	r1, [r7, #0x4]
 801c0d0: 9105         	str	r1, [sp, #0x14]
 801c0d2: 9204         	str	r2, [sp, #0x10]
 801c0d4: 69fa         	ldr	r2, [r7, #0x1c]
 801c0d6: 9203         	str	r2, [sp, #0xc]
 801c0d8: 9302         	str	r3, [sp, #0x8]
 801c0da: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 801c0de: 9301         	str	r3, [sp, #0x4]
 801c0e0: 9000         	str	r0, [sp]
 801c0e2: 6a7b         	ldr	r3, [r7, #0x24]
 801c0e4: 2200         	movs	r2, #0x0
 801c0e6: 6af9         	ldr	r1, [r7, #0x2c]
 801c0e8: 68f8         	ldr	r0, [r7, #0xc]
 801c0ea: f7e9 f835    	bl	0x8005158 <log_output_process> @ imm = #-0x16f96
; }
 801c0ee: bf00         	nop
 801c0f0: 3730         	adds	r7, #0x30
 801c0f2: 46bd         	mov	sp, r7
 801c0f4: bd80         	pop	{r7, pc}

0801c0f6 <log_output_write>:
; {
 801c0f6: b580         	push	{r7, lr}
 801c0f8: b086         	sub	sp, #0x18
 801c0fa: af00         	add	r7, sp, #0x0
 801c0fc: 60f8         	str	r0, [r7, #0xc]
 801c0fe: 60b9         	str	r1, [r7, #0x8]
 801c100: 607a         	str	r2, [r7, #0x4]
 801c102: 603b         	str	r3, [r7]
; 	while (len != 0) {
 801c104: e00d         	b	0x801c122 <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 801c106: 68fb         	ldr	r3, [r7, #0xc]
 801c108: 683a         	ldr	r2, [r7]
 801c10a: 6879         	ldr	r1, [r7, #0x4]
 801c10c: 68b8         	ldr	r0, [r7, #0x8]
 801c10e: 4798         	blx	r3
 801c110: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 801c112: 697b         	ldr	r3, [r7, #0x14]
 801c114: 687a         	ldr	r2, [r7, #0x4]
 801c116: 1ad3         	subs	r3, r2, r3
 801c118: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 801c11a: 697b         	ldr	r3, [r7, #0x14]
 801c11c: 68ba         	ldr	r2, [r7, #0x8]
 801c11e: 4413         	add	r3, r2
 801c120: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 801c122: 687b         	ldr	r3, [r7, #0x4]
 801c124: 2b00         	cmp	r3, #0x0
 801c126: d1ee         	bne	0x801c106 <log_output_write+0x10> @ imm = #-0x24
; }
 801c128: bf00         	nop
 801c12a: bf00         	nop
 801c12c: 3718         	adds	r7, #0x18
 801c12e: 46bd         	mov	sp, r7
 801c130: bd80         	pop	{r7, pc}

0801c132 <log_output_flush>:
; {
 801c132: b580         	push	{r7, lr}
 801c134: b082         	sub	sp, #0x8
 801c136: af00         	add	r7, sp, #0x0
 801c138: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 801c13a: 687b         	ldr	r3, [r7, #0x4]
 801c13c: 6818         	ldr	r0, [r3]
 801c13e: 687b         	ldr	r3, [r7, #0x4]
 801c140: 6899         	ldr	r1, [r3, #0x8]
 801c142: 687b         	ldr	r3, [r7, #0x4]
 801c144: 685b         	ldr	r3, [r3, #0x4]
 801c146: 681b         	ldr	r3, [r3]
 801c148: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 801c14a: 687b         	ldr	r3, [r7, #0x4]
 801c14c: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 801c14e: 685b         	ldr	r3, [r3, #0x4]
 801c150: f7ff ffd1    	bl	0x801c0f6 <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 801c154: 687b         	ldr	r3, [r7, #0x4]
 801c156: 685b         	ldr	r3, [r3, #0x4]
 801c158: 2200         	movs	r2, #0x0
 801c15a: 601a         	str	r2, [r3]
; }
 801c15c: bf00         	nop
 801c15e: 3708         	adds	r7, #0x8
 801c160: 46bd         	mov	sp, r7
 801c162: bd80         	pop	{r7, pc}

0801c164 <log_output_ctx_set>:
; {
 801c164: b480         	push	{r7}
 801c166: b083         	sub	sp, #0xc
 801c168: af00         	add	r7, sp, #0x0
 801c16a: 6078         	str	r0, [r7, #0x4]
 801c16c: 6039         	str	r1, [r7]
; 	output->control_block->ctx = ctx;
 801c16e: 687b         	ldr	r3, [r7, #0x4]
 801c170: 685b         	ldr	r3, [r3, #0x4]
 801c172: 683a         	ldr	r2, [r7]
 801c174: 605a         	str	r2, [r3, #0x4]
; }
 801c176: bf00         	nop
 801c178: 370c         	adds	r7, #0xc
 801c17a: 46bd         	mov	sp, r7
 801c17c: f85d 7b04    	ldr	r7, [sp], #4
 801c180: 4770         	bx	lr

0801c182 <log_backend_std_get_flags>:
; {
 801c182: b480         	push	{r7}
 801c184: b083         	sub	sp, #0xc
 801c186: af00         	add	r7, sp, #0x0
; 	uint32_t flags = (LOG_OUTPUT_FLAG_LEVEL | LOG_OUTPUT_FLAG_TIMESTAMP);
 801c188: 230a         	movs	r3, #0xa
 801c18a: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_COLORS;
 801c18c: 687b         	ldr	r3, [r7, #0x4]
 801c18e: f043 0301    	orr	r3, r3, #0x1
 801c192: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP;
 801c194: 687b         	ldr	r3, [r7, #0x4]
 801c196: f043 0304    	orr	r3, r3, #0x4
 801c19a: 607b         	str	r3, [r7, #0x4]
; 	return flags;
 801c19c: 687b         	ldr	r3, [r7, #0x4]
; }
 801c19e: 4618         	mov	r0, r3
 801c1a0: 370c         	adds	r7, #0xc
 801c1a2: 46bd         	mov	sp, r7
 801c1a4: f85d 7b04    	ldr	r7, [sp], #4
 801c1a8: 4770         	bx	lr

0801c1aa <log_backend_std_panic>:
; {
 801c1aa: b580         	push	{r7, lr}
 801c1ac: b082         	sub	sp, #0x8
 801c1ae: af00         	add	r7, sp, #0x0
 801c1b0: 6078         	str	r0, [r7, #0x4]
; 	log_output_flush(output);
 801c1b2: 6878         	ldr	r0, [r7, #0x4]
 801c1b4: f7ff ffbd    	bl	0x801c132 <log_output_flush> @ imm = #-0x86
; }
 801c1b8: bf00         	nop
 801c1ba: 3708         	adds	r7, #0x8
 801c1bc: 46bd         	mov	sp, r7
 801c1be: bd80         	pop	{r7, pc}

0801c1c0 <z_impl_uart_poll_out>:
; {
 801c1c0: b580         	push	{r7, lr}
 801c1c2: b084         	sub	sp, #0x10
 801c1c4: af00         	add	r7, sp, #0x0
 801c1c6: 6078         	str	r0, [r7, #0x4]
 801c1c8: 460b         	mov	r3, r1
 801c1ca: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 801c1cc: 687b         	ldr	r3, [r7, #0x4]
 801c1ce: 689b         	ldr	r3, [r3, #0x8]
 801c1d0: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 801c1d2: 68fb         	ldr	r3, [r7, #0xc]
 801c1d4: 69db         	ldr	r3, [r3, #0x1c]
 801c1d6: 78fa         	ldrb	r2, [r7, #0x3]
 801c1d8: 4611         	mov	r1, r2
 801c1da: 6878         	ldr	r0, [r7, #0x4]
 801c1dc: 4798         	blx	r3
; }
 801c1de: bf00         	nop
 801c1e0: 3710         	adds	r7, #0x10
 801c1e2: 46bd         	mov	sp, r7
 801c1e4: bd80         	pop	{r7, pc}

0801c1e6 <uart_poll_out>:
; {
 801c1e6: b580         	push	{r7, lr}
 801c1e8: b082         	sub	sp, #0x8
 801c1ea: af00         	add	r7, sp, #0x0
 801c1ec: 6078         	str	r0, [r7, #0x4]
 801c1ee: 460b         	mov	r3, r1
 801c1f0: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 801c1f2: 78fb         	ldrb	r3, [r7, #0x3]
 801c1f4: 4619         	mov	r1, r3
 801c1f6: 6878         	ldr	r0, [r7, #0x4]
 801c1f8: f7ff ffe2    	bl	0x801c1c0 <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 801c1fc: bf00         	nop
 801c1fe: 3708         	adds	r7, #0x8
 801c200: 46bd         	mov	sp, r7
 801c202: bd80         	pop	{r7, pc}

0801c204 <pm_device_runtime_get>:
; {
 801c204: b480         	push	{r7}
 801c206: b083         	sub	sp, #0xc
 801c208: af00         	add	r7, sp, #0x0
 801c20a: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801c20c: 2300         	movs	r3, #0x0
; }
 801c20e: 4618         	mov	r0, r3
 801c210: 370c         	adds	r7, #0xc
 801c212: 46bd         	mov	sp, r7
 801c214: f85d 7b04    	ldr	r7, [sp], #4
 801c218: 4770         	bx	lr

0801c21a <pm_device_runtime_put_async>:
; {
 801c21a: b480         	push	{r7}
 801c21c: b085         	sub	sp, #0x14
 801c21e: af00         	add	r7, sp, #0x0
 801c220: 60f8         	str	r0, [r7, #0xc]
 801c222: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 801c226: 2300         	movs	r3, #0x0
; }
 801c228: 4618         	mov	r0, r3
 801c22a: 3714         	adds	r7, #0x14
 801c22c: 46bd         	mov	sp, r7
 801c22e: f85d 7b04    	ldr	r7, [sp], #4
 801c232: 4770         	bx	lr

0801c234 <process>:
; {
 801c234: b580         	push	{r7, lr}
 801c236: b086         	sub	sp, #0x18
 801c238: af00         	add	r7, sp, #0x0
 801c23a: 6078         	str	r0, [r7, #0x4]
 801c23c: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 801c23e: 687b         	ldr	r3, [r7, #0x4]
 801c240: 685b         	ldr	r3, [r3, #0x4]
 801c242: 681b         	ldr	r3, [r3]
 801c244: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 801c246: 697b         	ldr	r3, [r7, #0x14]
 801c248: 685b         	ldr	r3, [r3, #0x4]
 801c24a: 613b         	str	r3, [r7, #0x10]
; 	uint32_t flags = log_backend_std_get_flags();
 801c24c: f7ff ff99    	bl	0x801c182 <log_backend_std_get_flags> @ imm = #-0xce
 801c250: 60f8         	str	r0, [r7, #0xc]
; 	log_format_func_t log_output_func = log_format_func_t_get(data->log_format_current);
 801c252: 693b         	ldr	r3, [r7, #0x10]
 801c254: 691b         	ldr	r3, [r3, #0x10]
 801c256: 4618         	mov	r0, r3
 801c258: f7e8 fa52    	bl	0x8004700 <log_format_func_t_get> @ imm = #-0x17b5c
 801c25c: 60b8         	str	r0, [r7, #0x8]
; 	log_output_func(ctx->output, &msg->log, flags);
 801c25e: 697b         	ldr	r3, [r7, #0x14]
 801c260: 6818         	ldr	r0, [r3]
 801c262: 6839         	ldr	r1, [r7]
 801c264: 68bb         	ldr	r3, [r7, #0x8]
 801c266: 68fa         	ldr	r2, [r7, #0xc]
 801c268: 4798         	blx	r3
; }
 801c26a: bf00         	nop
 801c26c: 3718         	adds	r7, #0x18
 801c26e: 46bd         	mov	sp, r7
 801c270: bd80         	pop	{r7, pc}

0801c272 <format_set>:
; {
 801c272: b480         	push	{r7}
 801c274: b085         	sub	sp, #0x14
 801c276: af00         	add	r7, sp, #0x0
 801c278: 6078         	str	r0, [r7, #0x4]
 801c27a: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 801c27c: 687b         	ldr	r3, [r7, #0x4]
 801c27e: 685b         	ldr	r3, [r3, #0x4]
 801c280: 681b         	ldr	r3, [r3]
 801c282: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 801c284: 68fb         	ldr	r3, [r7, #0xc]
 801c286: 685b         	ldr	r3, [r3, #0x4]
 801c288: 60bb         	str	r3, [r7, #0x8]
; 	data->log_format_current = log_type;
 801c28a: 68bb         	ldr	r3, [r7, #0x8]
 801c28c: 683a         	ldr	r2, [r7]
 801c28e: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 801c290: 2300         	movs	r3, #0x0
; }
 801c292: 4618         	mov	r0, r3
 801c294: 3714         	adds	r7, #0x14
 801c296: 46bd         	mov	sp, r7
 801c298: f85d 7b04    	ldr	r7, [sp], #4
 801c29c: 4770         	bx	lr

0801c29e <z_log_msg_runtime_create>:
; {
 801c29e: b580         	push	{r7, lr}
 801c2a0: b08a         	sub	sp, #0x28
 801c2a2: af04         	add	r7, sp, #0x10
 801c2a4: 60b9         	str	r1, [r7, #0x8]
 801c2a6: 607b         	str	r3, [r7, #0x4]
 801c2a8: 4603         	mov	r3, r0
 801c2aa: 73fb         	strb	r3, [r7, #0xf]
 801c2ac: 4613         	mov	r3, r2
 801c2ae: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801c2b0: f107 032c    	add.w	r3, r7, #0x2c
 801c2b4: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801c2b6: 7bba         	ldrb	r2, [r7, #0xe]
 801c2b8: 7bf8         	ldrb	r0, [r7, #0xf]
 801c2ba: 697b         	ldr	r3, [r7, #0x14]
 801c2bc: 9303         	str	r3, [sp, #0xc]
 801c2be: 6abb         	ldr	r3, [r7, #0x28]
 801c2c0: 9302         	str	r3, [sp, #0x8]
 801c2c2: 6a7b         	ldr	r3, [r7, #0x24]
 801c2c4: 9301         	str	r3, [sp, #0x4]
 801c2c6: 6a3b         	ldr	r3, [r7, #0x20]
 801c2c8: 9300         	str	r3, [sp]
 801c2ca: 687b         	ldr	r3, [r7, #0x4]
 801c2cc: 68b9         	ldr	r1, [r7, #0x8]
 801c2ce: f7e8 fc39    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x1778e
; }
 801c2d2: bf00         	nop
 801c2d4: 3718         	adds	r7, #0x18
 801c2d6: 46bd         	mov	sp, r7
 801c2d8: bd80         	pop	{r7, pc}

0801c2da <z_do_kernel_oops>:
; {
 801c2da: b580         	push	{r7, lr}
 801c2dc: b088         	sub	sp, #0x20
 801c2de: af00         	add	r7, sp, #0x0
 801c2e0: 60f8         	str	r0, [r7, #0xc]
 801c2e2: 60b9         	str	r1, [r7, #0x8]
 801c2e4: 607a         	str	r2, [r7, #0x4]
; 	unsigned int reason = esf->basic.r0;
 801c2e6: 68fb         	ldr	r3, [r7, #0xc]
 801c2e8: 681b         	ldr	r3, [r3]
 801c2ea: 61fb         	str	r3, [r7, #0x1c]
 801c2ec: 68fb         	ldr	r3, [r7, #0xc]
 801c2ee: 61bb         	str	r3, [r7, #0x18]
 801c2f0: 687b         	ldr	r3, [r7, #0x4]
 801c2f2: 617b         	str	r3, [r7, #0x14]
; }
 801c2f4: bf00         	nop
; 	z_arm_fatal_error(reason, esf);
 801c2f6: 68f9         	ldr	r1, [r7, #0xc]
 801c2f8: 69f8         	ldr	r0, [r7, #0x1c]
 801c2fa: f7e9 f925    	bl	0x8005548 <z_arm_fatal_error> @ imm = #-0x16db6
; }
 801c2fe: bf00         	nop
 801c300: 3720         	adds	r7, #0x20
 801c302: 46bd         	mov	sp, r7
 801c304: bd80         	pop	{r7, pc}

0801c306 <arch_tls_stack_setup>:
; {
 801c306: b580         	push	{r7, lr}
 801c308: b082         	sub	sp, #0x8
 801c30a: af00         	add	r7, sp, #0x0
 801c30c: 6078         	str	r0, [r7, #0x4]
 801c30e: 6039         	str	r1, [r7]
; 	stack_ptr -= z_tls_data_size();
 801c310: f7e9 f966    	bl	0x80055e0 <z_tls_data_size> @ imm = #-0x16d34
 801c314: 4603         	mov	r3, r0
 801c316: 425b         	rsbs	r3, r3, #0
 801c318: 683a         	ldr	r2, [r7]
 801c31a: 4413         	add	r3, r2
 801c31c: 603b         	str	r3, [r7]
; 	z_tls_copy(stack_ptr);
 801c31e: 6838         	ldr	r0, [r7]
 801c320: f7e9 f96c    	bl	0x80055fc <z_tls_copy>  @ imm = #-0x16d28
; 	stack_ptr -= sizeof(uintptr_t) * 2;
 801c324: 683b         	ldr	r3, [r7]
 801c326: 3b08         	subs	r3, #0x8
 801c328: 603b         	str	r3, [r7]
; 	new_thread->tls = POINTER_TO_UINT(stack_ptr);
 801c32a: 683a         	ldr	r2, [r7]
 801c32c: 687b         	ldr	r3, [r7, #0x4]
 801c32e: f8c3 20c4    	str.w	r2, [r3, #0xc4]
; 	return (z_tls_data_size() + (sizeof(uintptr_t) * 2));
 801c332: f7e9 f955    	bl	0x80055e0 <z_tls_data_size> @ imm = #-0x16d56
 801c336: 4603         	mov	r3, r0
 801c338: 3308         	adds	r3, #0x8
; }
 801c33a: 4618         	mov	r0, r3
 801c33c: 3708         	adds	r7, #0x8
 801c33e: 46bd         	mov	sp, r7
 801c340: bd80         	pop	{r7, pc}

0801c342 <z_log_msg_runtime_create>:
; {
 801c342: b580         	push	{r7, lr}
 801c344: b08a         	sub	sp, #0x28
 801c346: af04         	add	r7, sp, #0x10
 801c348: 60b9         	str	r1, [r7, #0x8]
 801c34a: 607b         	str	r3, [r7, #0x4]
 801c34c: 4603         	mov	r3, r0
 801c34e: 73fb         	strb	r3, [r7, #0xf]
 801c350: 4613         	mov	r3, r2
 801c352: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801c354: f107 032c    	add.w	r3, r7, #0x2c
 801c358: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801c35a: 7bba         	ldrb	r2, [r7, #0xe]
 801c35c: 7bf8         	ldrb	r0, [r7, #0xf]
 801c35e: 697b         	ldr	r3, [r7, #0x14]
 801c360: 9303         	str	r3, [sp, #0xc]
 801c362: 6abb         	ldr	r3, [r7, #0x28]
 801c364: 9302         	str	r3, [sp, #0x8]
 801c366: 6a7b         	ldr	r3, [r7, #0x24]
 801c368: 9301         	str	r3, [sp, #0x4]
 801c36a: 6a3b         	ldr	r3, [r7, #0x20]
 801c36c: 9300         	str	r3, [sp]
 801c36e: 687b         	ldr	r3, [r7, #0x4]
 801c370: 68b9         	ldr	r1, [r7, #0x8]
 801c372: f7e8 fbe7    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x17832
; }
 801c376: bf00         	nop
 801c378: 3718         	adds	r7, #0x18
 801c37a: 46bd         	mov	sp, r7
 801c37c: bd80         	pop	{r7, pc}

0801c37e <fault_show>:
; {
 801c37e: b480         	push	{r7}
 801c380: b083         	sub	sp, #0xc
 801c382: af00         	add	r7, sp, #0x0
 801c384: 6078         	str	r0, [r7, #0x4]
 801c386: 6039         	str	r1, [r7]
; }
 801c388: bf00         	nop
 801c38a: 370c         	adds	r7, #0xc
 801c38c: 46bd         	mov	sp, r7
 801c38e: f85d 7b04    	ldr	r7, [sp], #4
 801c392: 4770         	bx	lr

0801c394 <memory_fault_recoverable>:
; {
 801c394: b480         	push	{r7}
 801c396: b083         	sub	sp, #0xc
 801c398: af00         	add	r7, sp, #0x0
 801c39a: 6078         	str	r0, [r7, #0x4]
 801c39c: 460b         	mov	r3, r1
 801c39e: 70fb         	strb	r3, [r7, #0x3]
; 	return false;
 801c3a0: 2300         	movs	r3, #0x0
; }
 801c3a2: 4618         	mov	r0, r3
 801c3a4: 370c         	adds	r7, #0xc
 801c3a6: 46bd         	mov	sp, r7
 801c3a8: f85d 7b04    	ldr	r7, [sp], #4
 801c3ac: 4770         	bx	lr

0801c3ae <arch_irq_enable>:
; {
 801c3ae: b580         	push	{r7, lr}
 801c3b0: b082         	sub	sp, #0x8
 801c3b2: af00         	add	r7, sp, #0x0
 801c3b4: 6078         	str	r0, [r7, #0x4]
; 	NVIC_EnableIRQ((IRQn_Type)irq);
 801c3b6: 687b         	ldr	r3, [r7, #0x4]
 801c3b8: b25b         	sxtb	r3, r3
 801c3ba: 4618         	mov	r0, r3
 801c3bc: f7ea f8b4    	bl	0x8006528 <__NVIC_EnableIRQ> @ imm = #-0x15e98
; }
 801c3c0: bf00         	nop
 801c3c2: 3708         	adds	r7, #0x8
 801c3c4: 46bd         	mov	sp, r7
 801c3c6: bd80         	pop	{r7, pc}

0801c3c8 <z_arm_irq_priority_set>:
; {
 801c3c8: b580         	push	{r7, lr}
 801c3ca: b084         	sub	sp, #0x10
 801c3cc: af00         	add	r7, sp, #0x0
 801c3ce: 60f8         	str	r0, [r7, #0xc]
 801c3d0: 60b9         	str	r1, [r7, #0x8]
 801c3d2: 607a         	str	r2, [r7, #0x4]
; 		prio += _IRQ_PRIO_OFFSET;
 801c3d4: 68bb         	ldr	r3, [r7, #0x8]
 801c3d6: 3301         	adds	r3, #0x1
 801c3d8: 60bb         	str	r3, [r7, #0x8]
; 	NVIC_SetPriority((IRQn_Type)irq, prio);
 801c3da: 68fb         	ldr	r3, [r7, #0xc]
 801c3dc: b25b         	sxtb	r3, r3
 801c3de: 68b9         	ldr	r1, [r7, #0x8]
 801c3e0: 4618         	mov	r0, r3
 801c3e2: f7ea f8bf    	bl	0x8006564 <__NVIC_SetPriority> @ imm = #-0x15e82
; }
 801c3e6: bf00         	nop
 801c3e8: 3710         	adds	r7, #0x10
 801c3ea: 46bd         	mov	sp, r7
 801c3ec: bd80         	pop	{r7, pc}

0801c3ee <z_irq_spurious>:
; {
 801c3ee: b580         	push	{r7, lr}
 801c3f0: b082         	sub	sp, #0x8
 801c3f2: af00         	add	r7, sp, #0x0
 801c3f4: 6078         	str	r0, [r7, #0x4]
; 	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 801c3f6: 2100         	movs	r1, #0x0
 801c3f8: 2001         	movs	r0, #0x1
 801c3fa: f7e9 f8a5    	bl	0x8005548 <z_arm_fatal_error> @ imm = #-0x16eb6
; }
 801c3fe: bf00         	nop
 801c400: 3708         	adds	r7, #0x8
 801c402: 46bd         	mov	sp, r7
 801c404: bd80         	pop	{r7, pc}

0801c406 <z_prep_c>:
; {
 801c406: b580         	push	{r7, lr}
 801c408: af00         	add	r7, sp, #0x0
; 	relocate_vector_table();
 801c40a: f7ea f8d5    	bl	0x80065b8 <relocate_vector_table> @ imm = #-0x15e56
; 	z_arm_floating_point_init();
 801c40e: f7ea f8ed    	bl	0x80065ec <z_arm_floating_point_init> @ imm = #-0x15e26
; 	z_bss_zero();
 801c412: f7f6 fecf    	bl	0x80131b4 <z_bss_zero>  @ imm = #-0x9262
; 	z_data_copy();
 801c416: f7fa fbb1    	bl	0x8016b7c <z_data_copy> @ imm = #-0x589e
; 	z_arm_interrupt_init();
 801c41a: f000 f85b    	bl	0x801c4d4 <z_arm_interrupt_init> @ imm = #0xb6
; 	z_cstart();
 801c41e: f7f6 fff3    	bl	0x8013408 <z_cstart>    @ imm = #-0x901a

0801c422 <z_arm_prepare_switch_to_main>:
; {
 801c422: b480         	push	{r7}
 801c424: b085         	sub	sp, #0x14
 801c426: af00         	add	r7, sp, #0x0
 801c428: 2300         	movs	r3, #0x0
 801c42a: 607b         	str	r3, [r7, #0x4]
;   __builtin_arm_set_fpscr(fpscr);
 801c42c: 687b         	ldr	r3, [r7, #0x4]
 801c42e: eee1 3a10    	vmsr	fpscr, r3
; }
 801c432: bf00         	nop
;   __ASM volatile ("MRS %0, control" : "=r" (result) );
 801c434: f3ef 8314    	mrs	r3, control
 801c438: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 801c43a: 68bb         	ldr	r3, [r7, #0x8]
; 	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
 801c43c: f023 0304    	bic	r3, r3, #0x4
 801c440: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 801c442: 68fb         	ldr	r3, [r7, #0xc]
 801c444: f383 8814    	msr	control, r3
;   __ASM volatile ("isb 0xF":::"memory");
 801c448: f3bf 8f6f    	isb	sy
; }
 801c44c: bf00         	nop
; }
 801c44e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801c450: f3bf 8f6f    	isb	sy
; }
 801c454: bf00         	nop
; }
 801c456: bf00         	nop
; }
 801c458: bf00         	nop
; }
 801c45a: bf00         	nop
 801c45c: 3714         	adds	r7, #0x14
 801c45e: 46bd         	mov	sp, r7
 801c460: f85d 7b04    	ldr	r7, [sp], #4
 801c464: 4770         	bx	lr

0801c466 <arch_irq_unlock_outlined>:
; {
 801c466: b480         	push	{r7}
 801c468: b085         	sub	sp, #0x14
 801c46a: af00         	add	r7, sp, #0x0
 801c46c: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("cpsie f" : : : "memory");
 801c46e: b661         	cpsie f
; }
 801c470: bf00         	nop
;   __ASM volatile ("cpsie i" : : : "memory");
 801c472: b662         	cpsie i
; }
 801c474: bf00         	nop
 801c476: 687b         	ldr	r3, [r7, #0x4]
 801c478: 60fb         	str	r3, [r7, #0xc]
 801c47a: 68fb         	ldr	r3, [r7, #0xc]
 801c47c: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801c47e: 68bb         	ldr	r3, [r7, #0x8]
 801c480: f383 8811    	msr	basepri, r3
; }
 801c484: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801c486: f3bf 8f6f    	isb	sy
; }
 801c48a: bf00         	nop
; }
 801c48c: bf00         	nop
; }
 801c48e: bf00         	nop
 801c490: 3714         	adds	r7, #0x14
 801c492: 46bd         	mov	sp, r7
 801c494: f85d 7b04    	ldr	r7, [sp], #4
 801c498: 4770         	bx	lr

0801c49a <arch_cpu_idle>:
; {
 801c49a: b480         	push	{r7}
 801c49c: b083         	sub	sp, #0xc
 801c49e: af00         	add	r7, sp, #0x0
;   __ASM volatile ("cpsid i" : : : "memory");
 801c4a0: b672         	cpsid i
; }
 801c4a2: bf00         	nop
 801c4a4: 2300         	movs	r3, #0x0
 801c4a6: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801c4a8: 687b         	ldr	r3, [r7, #0x4]
 801c4aa: f383 8811    	msr	basepri, r3
; }
 801c4ae: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801c4b0: f3bf 8f6f    	isb	sy
; }
 801c4b4: bf00         	nop
;   __ASM volatile ("dsb 0xF":::"memory");
 801c4b6: f3bf 8f4f    	dsb	sy
; }
 801c4ba: bf00         	nop
; 	SLEEP_IF_ALLOWED(__WFI);
 801c4bc: bf30         	wfi
;   __ASM volatile ("cpsie i" : : : "memory");
 801c4be: b662         	cpsie i
; }
 801c4c0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801c4c2: f3bf 8f6f    	isb	sy
; }
 801c4c6: bf00         	nop
; }
 801c4c8: bf00         	nop
 801c4ca: 370c         	adds	r7, #0xc
 801c4cc: 46bd         	mov	sp, r7
 801c4ce: f85d 7b04    	ldr	r7, [sp], #4
 801c4d2: 4770         	bx	lr

0801c4d4 <z_arm_interrupt_init>:
; {
 801c4d4: b580         	push	{r7, lr}
 801c4d6: b082         	sub	sp, #0x8
 801c4d8: af00         	add	r7, sp, #0x0
; 	int irq = 0;
 801c4da: 2300         	movs	r3, #0x0
 801c4dc: 607b         	str	r3, [r7, #0x4]
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 801c4de: e008         	b	0x801c4f2 <z_arm_interrupt_init+0x1e> @ imm = #0x10
; 		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
 801c4e0: 687b         	ldr	r3, [r7, #0x4]
 801c4e2: b25b         	sxtb	r3, r3
 801c4e4: 2101         	movs	r1, #0x1
 801c4e6: 4618         	mov	r0, r3
 801c4e8: f7ea f97e    	bl	0x80067e8 <__NVIC_SetPriority> @ imm = #-0x15d04
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 801c4ec: 687b         	ldr	r3, [r7, #0x4]
 801c4ee: 3301         	adds	r3, #0x1
 801c4f0: 607b         	str	r3, [r7, #0x4]
 801c4f2: 687b         	ldr	r3, [r7, #0x4]
 801c4f4: 2b51         	cmp	r3, #0x51
 801c4f6: ddf3         	ble	0x801c4e0 <z_arm_interrupt_init+0xc> @ imm = #-0x1a
; }
 801c4f8: bf00         	nop
 801c4fa: bf00         	nop
 801c4fc: 3708         	adds	r7, #0x8
 801c4fe: 46bd         	mov	sp, r7
 801c500: bd80         	pop	{r7, pc}

0801c502 <cbputc>:
; {
 801c502: b580         	push	{r7, lr}
 801c504: b084         	sub	sp, #0x10
 801c506: af00         	add	r7, sp, #0x0
 801c508: 4603         	mov	r3, r0
 801c50a: 6039         	str	r1, [r7]
 801c50c: 71fb         	strb	r3, [r7, #0x7]
; 	struct cb_bits *s = (struct cb_bits *) _s;
 801c50e: 683b         	ldr	r3, [r7]
 801c510: 60fb         	str	r3, [r7, #0xc]
; 	(*s->out) (c, s->ctx);
 801c512: 68fb         	ldr	r3, [r7, #0xc]
 801c514: 691b         	ldr	r3, [r3, #0x10]
 801c516: 79f8         	ldrb	r0, [r7, #0x7]
 801c518: 68fa         	ldr	r2, [r7, #0xc]
 801c51a: 6952         	ldr	r2, [r2, #0x14]
 801c51c: 4611         	mov	r1, r2
 801c51e: 4798         	blx	r3
; 	return 0;
 801c520: 2300         	movs	r3, #0x0
; }
 801c522: 4618         	mov	r0, r3
 801c524: 3710         	adds	r7, #0x10
 801c526: 46bd         	mov	sp, r7
 801c528: bd80         	pop	{r7, pc}

0801c52a <zephyr_fputc>:
; {
 801c52a: b580         	push	{r7, lr}
 801c52c: b082         	sub	sp, #0x8
 801c52e: af00         	add	r7, sp, #0x0
 801c530: 6078         	str	r0, [r7, #0x4]
 801c532: 6039         	str	r1, [r7]
; 	return z_impl_zephyr_fputc(c, stream);
 801c534: 6839         	ldr	r1, [r7]
 801c536: 6878         	ldr	r0, [r7, #0x4]
 801c538: f7ea f9c4    	bl	0x80068c4 <z_impl_zephyr_fputc> @ imm = #-0x15c78
 801c53c: 4603         	mov	r3, r0
; }
 801c53e: 4618         	mov	r0, r3
 801c540: 3708         	adds	r7, #0x8
 801c542: 46bd         	mov	sp, r7
 801c544: bd80         	pop	{r7, pc}

0801c546 <picolibc_put>:
; {
 801c546: b580         	push	{r7, lr}
 801c548: b082         	sub	sp, #0x8
 801c54a: af00         	add	r7, sp, #0x0
 801c54c: 4603         	mov	r3, r0
 801c54e: 6039         	str	r1, [r7]
 801c550: 71fb         	strb	r3, [r7, #0x7]
; 	zephyr_fputc(a, f);
 801c552: 79fb         	ldrb	r3, [r7, #0x7]
 801c554: 6839         	ldr	r1, [r7]
 801c556: 4618         	mov	r0, r3
 801c558: f7ff ffe7    	bl	0x801c52a <zephyr_fputc> @ imm = #-0x32
; 	return 0;
 801c55c: 2300         	movs	r3, #0x0
; }
 801c55e: 4618         	mov	r0, r3
 801c560: 3708         	adds	r7, #0x8
 801c562: 46bd         	mov	sp, r7
 801c564: bd80         	pop	{r7, pc}

0801c566 <k_mutex_lock>:
; {
 801c566: b580         	push	{r7, lr}
 801c568: b084         	sub	sp, #0x10
 801c56a: af00         	add	r7, sp, #0x0
 801c56c: 60f8         	str	r0, [r7, #0xc]
 801c56e: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_mutex_lock(mutex, timeout);
 801c572: e9d7 2300    	ldrd	r2, r3, [r7]
 801c576: 68f8         	ldr	r0, [r7, #0xc]
 801c578: f7f7 f998    	bl	0x80138ac <z_impl_k_mutex_lock> @ imm = #-0x8cd0
 801c57c: 4603         	mov	r3, r0
; }
 801c57e: 4618         	mov	r0, r3
 801c580: 3710         	adds	r7, #0x10
 801c582: 46bd         	mov	sp, r7
 801c584: bd80         	pop	{r7, pc}

0801c586 <k_mutex_unlock>:
; {
 801c586: b580         	push	{r7, lr}
 801c588: b082         	sub	sp, #0x8
 801c58a: af00         	add	r7, sp, #0x0
 801c58c: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_unlock(mutex);
 801c58e: 6878         	ldr	r0, [r7, #0x4]
 801c590: f7f7 fbd6    	bl	0x8013d40 <z_impl_k_mutex_unlock> @ imm = #-0x8854
 801c594: 4603         	mov	r3, r0
; }
 801c596: 4618         	mov	r0, r3
 801c598: 3708         	adds	r7, #0x8
 801c59a: 46bd         	mov	sp, r7
 801c59c: bd80         	pop	{r7, pc}

0801c59e <sys_mutex_lock>:
; {
 801c59e: b580         	push	{r7, lr}
 801c5a0: b084         	sub	sp, #0x10
 801c5a2: af00         	add	r7, sp, #0x0
 801c5a4: 60f8         	str	r0, [r7, #0xc]
 801c5a6: e9c7 2300    	strd	r2, r3, [r7]
; 	return k_mutex_lock(&mutex->kernel_mutex, timeout);
 801c5aa: 68f9         	ldr	r1, [r7, #0xc]
 801c5ac: e9d7 2300    	ldrd	r2, r3, [r7]
 801c5b0: 4608         	mov	r0, r1
 801c5b2: f7ff ffd8    	bl	0x801c566 <k_mutex_lock> @ imm = #-0x50
 801c5b6: 4603         	mov	r3, r0
; }
 801c5b8: 4618         	mov	r0, r3
 801c5ba: 3710         	adds	r7, #0x10
 801c5bc: 46bd         	mov	sp, r7
 801c5be: bd80         	pop	{r7, pc}

0801c5c0 <sys_mutex_unlock>:
; {
 801c5c0: b580         	push	{r7, lr}
 801c5c2: b082         	sub	sp, #0x8
 801c5c4: af00         	add	r7, sp, #0x0
 801c5c6: 6078         	str	r0, [r7, #0x4]
; 	return k_mutex_unlock(&mutex->kernel_mutex);
 801c5c8: 687b         	ldr	r3, [r7, #0x4]
 801c5ca: 4618         	mov	r0, r3
 801c5cc: f7ff ffdb    	bl	0x801c586 <k_mutex_unlock> @ imm = #-0x4a
 801c5d0: 4603         	mov	r3, r0
; }
 801c5d2: 4618         	mov	r0, r3
 801c5d4: 3708         	adds	r7, #0x8
 801c5d6: 46bd         	mov	sp, r7
 801c5d8: bd80         	pop	{r7, pc}

0801c5da <z_log_msg_runtime_create>:
; {
 801c5da: b580         	push	{r7, lr}
 801c5dc: b08a         	sub	sp, #0x28
 801c5de: af04         	add	r7, sp, #0x10
 801c5e0: 60b9         	str	r1, [r7, #0x8]
 801c5e2: 607b         	str	r3, [r7, #0x4]
 801c5e4: 4603         	mov	r3, r0
 801c5e6: 73fb         	strb	r3, [r7, #0xf]
 801c5e8: 4613         	mov	r3, r2
 801c5ea: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801c5ec: f107 032c    	add.w	r3, r7, #0x2c
 801c5f0: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801c5f2: 7bba         	ldrb	r2, [r7, #0xe]
 801c5f4: 7bf8         	ldrb	r0, [r7, #0xf]
 801c5f6: 697b         	ldr	r3, [r7, #0x14]
 801c5f8: 9303         	str	r3, [sp, #0xc]
 801c5fa: 6abb         	ldr	r3, [r7, #0x28]
 801c5fc: 9302         	str	r3, [sp, #0x8]
 801c5fe: 6a7b         	ldr	r3, [r7, #0x24]
 801c600: 9301         	str	r3, [sp, #0x4]
 801c602: 6a3b         	ldr	r3, [r7, #0x20]
 801c604: 9300         	str	r3, [sp]
 801c606: 687b         	ldr	r3, [r7, #0x4]
 801c608: 68b9         	ldr	r1, [r7, #0x8]
 801c60a: f7e8 fa9b    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x17aca
; }
 801c60e: bf00         	nop
 801c610: 3718         	adds	r7, #0x18
 801c612: 46bd         	mov	sp, r7
 801c614: bd80         	pop	{r7, pc}

0801c616 <k_work_queue_thread_get>:
; {
 801c616: b480         	push	{r7}
 801c618: b083         	sub	sp, #0xc
 801c61a: af00         	add	r7, sp, #0x0
 801c61c: 6078         	str	r0, [r7, #0x4]
; 	return &queue->thread;
 801c61e: 687b         	ldr	r3, [r7, #0x4]
; }
 801c620: 4618         	mov	r0, r3
 801c622: 370c         	adds	r7, #0xc
 801c624: 46bd         	mov	sp, r7
 801c626: f85d 7b04    	ldr	r7, [sp], #4
 801c62a: 4770         	bx	lr

0801c62c <k_queue_get>:
; {
 801c62c: b580         	push	{r7, lr}
 801c62e: b084         	sub	sp, #0x10
 801c630: af00         	add	r7, sp, #0x0
 801c632: 60f8         	str	r0, [r7, #0xc]
 801c634: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_queue_get(queue, timeout);
 801c638: e9d7 2300    	ldrd	r2, r3, [r7]
 801c63c: 68f8         	ldr	r0, [r7, #0xc]
 801c63e: f7f7 fc79    	bl	0x8013f34 <z_impl_k_queue_get> @ imm = #-0x870e
 801c642: 4603         	mov	r3, r0
; }
 801c644: 4618         	mov	r0, r3
 801c646: 3710         	adds	r7, #0x10
 801c648: 46bd         	mov	sp, r7
 801c64a: bd80         	pop	{r7, pc}

0801c64c <net_buf_simple_reset>:
; {
 801c64c: b480         	push	{r7}
 801c64e: b083         	sub	sp, #0xc
 801c650: af00         	add	r7, sp, #0x0
 801c652: 6078         	str	r0, [r7, #0x4]
; 	buf->len  = 0U;
 801c654: 687b         	ldr	r3, [r7, #0x4]
 801c656: 2200         	movs	r2, #0x0
 801c658: 809a         	strh	r2, [r3, #0x4]
; 	buf->data = buf->__buf;
 801c65a: 687b         	ldr	r3, [r7, #0x4]
 801c65c: 689a         	ldr	r2, [r3, #0x8]
 801c65e: 687b         	ldr	r3, [r7, #0x4]
 801c660: 601a         	str	r2, [r3]
; }
 801c662: bf00         	nop
 801c664: 370c         	adds	r7, #0xc
 801c666: 46bd         	mov	sp, r7
 801c668: f85d 7b04    	ldr	r7, [sp], #4
 801c66c: 4770         	bx	lr

0801c66e <net_buf_destroy>:
; {
 801c66e: b580         	push	{r7, lr}
 801c670: b084         	sub	sp, #0x10
 801c672: af00         	add	r7, sp, #0x0
 801c674: 6078         	str	r0, [r7, #0x4]
; 	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 801c676: 687b         	ldr	r3, [r7, #0x4]
 801c678: 7a9b         	ldrb	r3, [r3, #0xa]
 801c67a: 4618         	mov	r0, r3
 801c67c: f7ea f9b8    	bl	0x80069f0 <net_buf_pool_get> @ imm = #-0x15c90
 801c680: 60f8         	str	r0, [r7, #0xc]
; 	if (buf->__buf) {
 801c682: 687b         	ldr	r3, [r7, #0x4]
 801c684: 695b         	ldr	r3, [r3, #0x14]
 801c686: 2b00         	cmp	r3, #0x0
 801c688: d011         	beq	0x801c6ae <net_buf_destroy+0x40> @ imm = #0x22
; 		if (!(buf->flags & NET_BUF_EXTERNAL_DATA)) {
 801c68a: 687b         	ldr	r3, [r7, #0x4]
 801c68c: 7a5b         	ldrb	r3, [r3, #0x9]
 801c68e: f003 0301    	and	r3, r3, #0x1
 801c692: 2b00         	cmp	r3, #0x0
 801c694: d108         	bne	0x801c6a8 <net_buf_destroy+0x3a> @ imm = #0x10
; 			pool->alloc->cb->unref(buf, buf->__buf);
 801c696: 68fb         	ldr	r3, [r7, #0xc]
 801c698: 69db         	ldr	r3, [r3, #0x1c]
 801c69a: 681b         	ldr	r3, [r3]
 801c69c: 689b         	ldr	r3, [r3, #0x8]
 801c69e: 687a         	ldr	r2, [r7, #0x4]
 801c6a0: 6952         	ldr	r2, [r2, #0x14]
 801c6a2: 4611         	mov	r1, r2
 801c6a4: 6878         	ldr	r0, [r7, #0x4]
 801c6a6: 4798         	blx	r3
; 		buf->__buf = NULL;
 801c6a8: 687b         	ldr	r3, [r7, #0x4]
 801c6aa: 2200         	movs	r2, #0x0
 801c6ac: 615a         	str	r2, [r3, #0x14]
; 	k_lifo_put(&pool->free, buf);
 801c6ae: 68fb         	ldr	r3, [r7, #0xc]
 801c6b0: 6879         	ldr	r1, [r7, #0x4]
 801c6b2: 4618         	mov	r0, r3
 801c6b4: f009 f838    	bl	0x8025728 <k_queue_prepend> @ imm = #0x9070
; }
 801c6b8: bf00         	nop
 801c6ba: 3710         	adds	r7, #0x10
 801c6bc: 46bd         	mov	sp, r7
 801c6be: bd80         	pop	{r7, pc}

0801c6c0 <net_buf_add_mem>:
; {
 801c6c0: b580         	push	{r7, lr}
 801c6c2: b084         	sub	sp, #0x10
 801c6c4: af00         	add	r7, sp, #0x0
 801c6c6: 60f8         	str	r0, [r7, #0xc]
 801c6c8: 60b9         	str	r1, [r7, #0x8]
 801c6ca: 607a         	str	r2, [r7, #0x4]
; 	return net_buf_simple_add_mem(&buf->b, mem, len);
 801c6cc: 68fb         	ldr	r3, [r7, #0xc]
 801c6ce: 330c         	adds	r3, #0xc
 801c6d0: 687a         	ldr	r2, [r7, #0x4]
 801c6d2: 68b9         	ldr	r1, [r7, #0x8]
 801c6d4: 4618         	mov	r0, r3
 801c6d6: f000 f9af    	bl	0x801ca38 <net_buf_simple_add_mem> @ imm = #0x35e
 801c6da: 4603         	mov	r3, r0
; }
 801c6dc: 4618         	mov	r0, r3
 801c6de: 3710         	adds	r7, #0x10
 801c6e0: 46bd         	mov	sp, r7
 801c6e2: bd80         	pop	{r7, pc}

0801c6e4 <net_buf_headroom>:
; {
 801c6e4: b580         	push	{r7, lr}
 801c6e6: b082         	sub	sp, #0x8
 801c6e8: af00         	add	r7, sp, #0x0
 801c6ea: 6078         	str	r0, [r7, #0x4]
; 	return net_buf_simple_headroom(&buf->b);
 801c6ec: 687b         	ldr	r3, [r7, #0x4]
 801c6ee: 330c         	adds	r3, #0xc
 801c6f0: 4618         	mov	r0, r3
 801c6f2: f000 f9ce    	bl	0x801ca92 <net_buf_simple_headroom> @ imm = #0x39c
 801c6f6: 4603         	mov	r3, r0
; }
 801c6f8: 4618         	mov	r0, r3
 801c6fa: 3708         	adds	r7, #0x8
 801c6fc: 46bd         	mov	sp, r7
 801c6fe: bd80         	pop	{r7, pc}

0801c700 <pool_get_uninit>:
; {
 801c700: b580         	push	{r7, lr}
 801c702: b086         	sub	sp, #0x18
 801c704: af00         	add	r7, sp, #0x0
 801c706: 6078         	str	r0, [r7, #0x4]
 801c708: 460b         	mov	r3, r1
 801c70a: 807b         	strh	r3, [r7, #0x2]
; 	size_t struct_size = ROUND_UP(sizeof(struct net_buf) + pool->user_data_size,
 801c70c: 687b         	ldr	r3, [r7, #0x4]
 801c70e: 7d1b         	ldrb	r3, [r3, #0x14]
 801c710: 331b         	adds	r3, #0x1b
 801c712: f023 0303    	bic	r3, r3, #0x3
 801c716: 617b         	str	r3, [r7, #0x14]
; 	size_t byte_offset = (pool->buf_count - uninit_count) * struct_size;
 801c718: 687b         	ldr	r3, [r7, #0x4]
 801c71a: 8a1b         	ldrh	r3, [r3, #0x10]
 801c71c: 461a         	mov	r2, r3
 801c71e: 887b         	ldrh	r3, [r7, #0x2]
 801c720: 1ad3         	subs	r3, r2, r3
 801c722: 461a         	mov	r2, r3
 801c724: 697b         	ldr	r3, [r7, #0x14]
 801c726: fb02 f303    	mul	r3, r2, r3
 801c72a: 613b         	str	r3, [r7, #0x10]
; 	buf = (struct net_buf *)(((uint8_t *)pool->__bufs) + byte_offset);
 801c72c: 687b         	ldr	r3, [r7, #0x4]
 801c72e: 6a1a         	ldr	r2, [r3, #0x20]
 801c730: 693b         	ldr	r3, [r7, #0x10]
 801c732: 4413         	add	r3, r2
 801c734: 60fb         	str	r3, [r7, #0xc]
; 	buf->pool_id = pool_id(pool);
 801c736: 6878         	ldr	r0, [r7, #0x4]
 801c738: f7ea f970    	bl	0x8006a1c <pool_id>     @ imm = #-0x15d20
 801c73c: 4603         	mov	r3, r0
 801c73e: b2da         	uxtb	r2, r3
 801c740: 68fb         	ldr	r3, [r7, #0xc]
 801c742: 729a         	strb	r2, [r3, #0xa]
; 	buf->user_data_size = pool->user_data_size;
 801c744: 687b         	ldr	r3, [r7, #0x4]
 801c746: 7d1a         	ldrb	r2, [r3, #0x14]
 801c748: 68fb         	ldr	r3, [r7, #0xc]
 801c74a: 72da         	strb	r2, [r3, #0xb]
; 	return buf;
 801c74c: 68fb         	ldr	r3, [r7, #0xc]
; }
 801c74e: 4618         	mov	r0, r3
 801c750: 3718         	adds	r7, #0x18
 801c752: 46bd         	mov	sp, r7
 801c754: bd80         	pop	{r7, pc}

0801c756 <net_buf_reset>:
; {
 801c756: b580         	push	{r7, lr}
 801c758: b082         	sub	sp, #0x8
 801c75a: af00         	add	r7, sp, #0x0
 801c75c: 6078         	str	r0, [r7, #0x4]
; 	net_buf_simple_reset(&buf->b);
 801c75e: 687b         	ldr	r3, [r7, #0x4]
 801c760: 330c         	adds	r3, #0xc
 801c762: 4618         	mov	r0, r3
 801c764: f7ff ff72    	bl	0x801c64c <net_buf_simple_reset> @ imm = #-0x11c
; }
 801c768: bf00         	nop
 801c76a: 3708         	adds	r7, #0x8
 801c76c: 46bd         	mov	sp, r7
 801c76e: bd80         	pop	{r7, pc}

0801c770 <generic_data_ref>:
; {
 801c770: b480         	push	{r7}
 801c772: b085         	sub	sp, #0x14
 801c774: af00         	add	r7, sp, #0x0
 801c776: 6078         	str	r0, [r7, #0x4]
 801c778: 6039         	str	r1, [r7]
; 	ref_count = data - sizeof(void *);
 801c77a: 683b         	ldr	r3, [r7]
 801c77c: 3b04         	subs	r3, #0x4
 801c77e: 60fb         	str	r3, [r7, #0xc]
; 	(*ref_count)++;
 801c780: 68fb         	ldr	r3, [r7, #0xc]
 801c782: 781b         	ldrb	r3, [r3]
 801c784: 3301         	adds	r3, #0x1
 801c786: b2da         	uxtb	r2, r3
 801c788: 68fb         	ldr	r3, [r7, #0xc]
 801c78a: 701a         	strb	r2, [r3]
; 	return data;
 801c78c: 683b         	ldr	r3, [r7]
; }
 801c78e: 4618         	mov	r0, r3
 801c790: 3714         	adds	r7, #0x14
 801c792: 46bd         	mov	sp, r7
 801c794: f85d 7b04    	ldr	r7, [sp], #4
 801c798: 4770         	bx	lr

0801c79a <heap_data_alloc>:
; {
 801c79a: b580         	push	{r7, lr}
 801c79c: b086         	sub	sp, #0x18
 801c79e: af00         	add	r7, sp, #0x0
 801c7a0: 60f8         	str	r0, [r7, #0xc]
 801c7a2: 60b9         	str	r1, [r7, #0x8]
 801c7a4: e9c7 2300    	strd	r2, r3, [r7]
; 	ref_count = k_malloc(sizeof(void *) + *size);
 801c7a8: 68bb         	ldr	r3, [r7, #0x8]
 801c7aa: 681b         	ldr	r3, [r3]
 801c7ac: 3304         	adds	r3, #0x4
 801c7ae: 4618         	mov	r0, r3
 801c7b0: f00a fe8e    	bl	0x80274d0 <k_malloc>    @ imm = #0xad1c
 801c7b4: 6178         	str	r0, [r7, #0x14]
; 	if (!ref_count) {
 801c7b6: 697b         	ldr	r3, [r7, #0x14]
 801c7b8: 2b00         	cmp	r3, #0x0
 801c7ba: d101         	bne	0x801c7c0 <heap_data_alloc+0x26> @ imm = #0x2
; 		return NULL;
 801c7bc: 2300         	movs	r3, #0x0
 801c7be: e004         	b	0x801c7ca <heap_data_alloc+0x30> @ imm = #0x8
; 	*ref_count = 1U;
 801c7c0: 697b         	ldr	r3, [r7, #0x14]
 801c7c2: 2201         	movs	r2, #0x1
 801c7c4: 701a         	strb	r2, [r3]
; 	return ref_count + sizeof(void *);
 801c7c6: 697b         	ldr	r3, [r7, #0x14]
 801c7c8: 3304         	adds	r3, #0x4
; }
 801c7ca: 4618         	mov	r0, r3
 801c7cc: 3718         	adds	r7, #0x18
 801c7ce: 46bd         	mov	sp, r7
 801c7d0: bd80         	pop	{r7, pc}

0801c7d2 <heap_data_unref>:
; {
 801c7d2: b580         	push	{r7, lr}
 801c7d4: b084         	sub	sp, #0x10
 801c7d6: af00         	add	r7, sp, #0x0
 801c7d8: 6078         	str	r0, [r7, #0x4]
 801c7da: 6039         	str	r1, [r7]
; 	ref_count = data - sizeof(void *);
 801c7dc: 683b         	ldr	r3, [r7]
 801c7de: 3b04         	subs	r3, #0x4
 801c7e0: 60fb         	str	r3, [r7, #0xc]
; 	if (--(*ref_count)) {
 801c7e2: 68fb         	ldr	r3, [r7, #0xc]
 801c7e4: 781b         	ldrb	r3, [r3]
 801c7e6: 3b01         	subs	r3, #0x1
 801c7e8: b2da         	uxtb	r2, r3
 801c7ea: 68fb         	ldr	r3, [r7, #0xc]
 801c7ec: 701a         	strb	r2, [r3]
 801c7ee: 68fb         	ldr	r3, [r7, #0xc]
 801c7f0: 781b         	ldrb	r3, [r3]
 801c7f2: 2b00         	cmp	r3, #0x0
 801c7f4: d103         	bne	0x801c7fe <heap_data_unref+0x2c> @ imm = #0x6
; 	k_free(ref_count);
 801c7f6: 68f8         	ldr	r0, [r7, #0xc]
 801c7f8: f00a fe52    	bl	0x80274a0 <k_free>      @ imm = #0xaca4
 801c7fc: e000         	b	0x801c800 <heap_data_unref+0x2e> @ imm = #0x0
; 		return;
 801c7fe: bf00         	nop
; }
 801c800: 3710         	adds	r7, #0x10
 801c802: 46bd         	mov	sp, r7
 801c804: bd80         	pop	{r7, pc}

0801c806 <data_alloc>:
; {
 801c806: b590         	push	{r4, r7, lr}
 801c808: b087         	sub	sp, #0x1c
 801c80a: af00         	add	r7, sp, #0x0
 801c80c: 60f8         	str	r0, [r7, #0xc]
 801c80e: 60b9         	str	r1, [r7, #0x8]
 801c810: e9c7 2300    	strd	r2, r3, [r7]
; 	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 801c814: 68fb         	ldr	r3, [r7, #0xc]
 801c816: 7a9b         	ldrb	r3, [r3, #0xa]
 801c818: 4618         	mov	r0, r3
 801c81a: f7ea f8e9    	bl	0x80069f0 <net_buf_pool_get> @ imm = #-0x15e2e
 801c81e: 6178         	str	r0, [r7, #0x14]
; 	return pool->alloc->cb->alloc(buf, size, timeout);
 801c820: 697b         	ldr	r3, [r7, #0x14]
 801c822: 69db         	ldr	r3, [r3, #0x1c]
 801c824: 681b         	ldr	r3, [r3]
 801c826: 681c         	ldr	r4, [r3]
 801c828: e9d7 2300    	ldrd	r2, r3, [r7]
 801c82c: 68b9         	ldr	r1, [r7, #0x8]
 801c82e: 68f8         	ldr	r0, [r7, #0xc]
 801c830: 47a0         	blx	r4
 801c832: 4603         	mov	r3, r0
; }
 801c834: 4618         	mov	r0, r3
 801c836: 371c         	adds	r7, #0x1c
 801c838: 46bd         	mov	sp, r7
 801c83a: bd90         	pop	{r4, r7, pc}

0801c83c <data_ref>:
; {
 801c83c: b580         	push	{r7, lr}
 801c83e: b084         	sub	sp, #0x10
 801c840: af00         	add	r7, sp, #0x0
 801c842: 6078         	str	r0, [r7, #0x4]
 801c844: 6039         	str	r1, [r7]
; 	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 801c846: 687b         	ldr	r3, [r7, #0x4]
 801c848: 7a9b         	ldrb	r3, [r3, #0xa]
 801c84a: 4618         	mov	r0, r3
 801c84c: f7ea f8d0    	bl	0x80069f0 <net_buf_pool_get> @ imm = #-0x15e60
 801c850: 60f8         	str	r0, [r7, #0xc]
; 	return pool->alloc->cb->ref(buf, data);
 801c852: 68fb         	ldr	r3, [r7, #0xc]
 801c854: 69db         	ldr	r3, [r3, #0x1c]
 801c856: 681b         	ldr	r3, [r3]
 801c858: 685b         	ldr	r3, [r3, #0x4]
 801c85a: 6839         	ldr	r1, [r7]
 801c85c: 6878         	ldr	r0, [r7, #0x4]
 801c85e: 4798         	blx	r3
 801c860: 4603         	mov	r3, r0
; }
 801c862: 4618         	mov	r0, r3
 801c864: 3710         	adds	r7, #0x10
 801c866: 46bd         	mov	sp, r7
 801c868: bd80         	pop	{r7, pc}

0801c86a <net_buf_unref>:
; {
 801c86a: b580         	push	{r7, lr}
 801c86c: b084         	sub	sp, #0x10
 801c86e: af00         	add	r7, sp, #0x0
 801c870: 6078         	str	r0, [r7, #0x4]
; 	while (buf) {
 801c872: e026         	b	0x801c8c2 <net_buf_unref+0x58> @ imm = #0x4c
; 		struct net_buf *frags = buf->frags;
 801c874: 687b         	ldr	r3, [r7, #0x4]
 801c876: 685b         	ldr	r3, [r3, #0x4]
 801c878: 60fb         	str	r3, [r7, #0xc]
; 		if (--buf->ref > 0) {
 801c87a: 687b         	ldr	r3, [r7, #0x4]
 801c87c: 7a1b         	ldrb	r3, [r3, #0x8]
 801c87e: 3b01         	subs	r3, #0x1
 801c880: b2da         	uxtb	r2, r3
 801c882: 687b         	ldr	r3, [r7, #0x4]
 801c884: 721a         	strb	r2, [r3, #0x8]
 801c886: 687b         	ldr	r3, [r7, #0x4]
 801c888: 7a1b         	ldrb	r3, [r3, #0x8]
 801c88a: 2b00         	cmp	r3, #0x0
 801c88c: d11d         	bne	0x801c8ca <net_buf_unref+0x60> @ imm = #0x3a
; 		buf->data = NULL;
 801c88e: 687b         	ldr	r3, [r7, #0x4]
 801c890: 2200         	movs	r2, #0x0
 801c892: 60da         	str	r2, [r3, #0xc]
; 		buf->frags = NULL;
 801c894: 687b         	ldr	r3, [r7, #0x4]
 801c896: 2200         	movs	r2, #0x0
 801c898: 605a         	str	r2, [r3, #0x4]
; 		pool = net_buf_pool_get(buf->pool_id);
 801c89a: 687b         	ldr	r3, [r7, #0x4]
 801c89c: 7a9b         	ldrb	r3, [r3, #0xa]
 801c89e: 4618         	mov	r0, r3
 801c8a0: f7ea f8a6    	bl	0x80069f0 <net_buf_pool_get> @ imm = #-0x15eb4
 801c8a4: 60b8         	str	r0, [r7, #0x8]
; 		if (pool->destroy) {
 801c8a6: 68bb         	ldr	r3, [r7, #0x8]
 801c8a8: 699b         	ldr	r3, [r3, #0x18]
 801c8aa: 2b00         	cmp	r3, #0x0
 801c8ac: d004         	beq	0x801c8b8 <net_buf_unref+0x4e> @ imm = #0x8
; 			pool->destroy(buf);
 801c8ae: 68bb         	ldr	r3, [r7, #0x8]
 801c8b0: 699b         	ldr	r3, [r3, #0x18]
 801c8b2: 6878         	ldr	r0, [r7, #0x4]
 801c8b4: 4798         	blx	r3
 801c8b6: e002         	b	0x801c8be <net_buf_unref+0x54> @ imm = #0x4
; 			net_buf_destroy(buf);
 801c8b8: 6878         	ldr	r0, [r7, #0x4]
 801c8ba: f7ff fed8    	bl	0x801c66e <net_buf_destroy> @ imm = #-0x250
; 		buf = frags;
 801c8be: 68fb         	ldr	r3, [r7, #0xc]
 801c8c0: 607b         	str	r3, [r7, #0x4]
; 	while (buf) {
 801c8c2: 687b         	ldr	r3, [r7, #0x4]
 801c8c4: 2b00         	cmp	r3, #0x0
 801c8c6: d1d5         	bne	0x801c874 <net_buf_unref+0xa> @ imm = #-0x56
 801c8c8: e000         	b	0x801c8cc <net_buf_unref+0x62> @ imm = #0x0
; 			return;
 801c8ca: bf00         	nop
; }
 801c8cc: 3710         	adds	r7, #0x10
 801c8ce: 46bd         	mov	sp, r7
 801c8d0: bd80         	pop	{r7, pc}

0801c8d2 <net_buf_clone>:
; {
 801c8d2: b590         	push	{r4, r7, lr}
 801c8d4: b08b         	sub	sp, #0x2c
 801c8d6: af00         	add	r7, sp, #0x0
 801c8d8: 60f8         	str	r0, [r7, #0xc]
 801c8da: e9c7 2300    	strd	r2, r3, [r7]
; 	k_timepoint_t end = sys_timepoint_calc(timeout);
 801c8de: f107 0118    	add.w	r1, r7, #0x18
 801c8e2: e9d7 2300    	ldrd	r2, r3, [r7]
 801c8e6: 4608         	mov	r0, r1
 801c8e8: f00a fb88    	bl	0x8026ffc <sys_timepoint_calc> @ imm = #0xa710
; 	pool = net_buf_pool_get(buf->pool_id);
 801c8ec: 68fb         	ldr	r3, [r7, #0xc]
 801c8ee: 7a9b         	ldrb	r3, [r3, #0xa]
 801c8f0: 4618         	mov	r0, r3
 801c8f2: f7ea f87d    	bl	0x80069f0 <net_buf_pool_get> @ imm = #-0x15f06
 801c8f6: 6278         	str	r0, [r7, #0x24]
; 	clone = net_buf_alloc_len(pool, 0, timeout);
 801c8f8: e9d7 2300    	ldrd	r2, r3, [r7]
 801c8fc: 2100         	movs	r1, #0x0
 801c8fe: 6a78         	ldr	r0, [r7, #0x24]
 801c900: f7ea f8a2    	bl	0x8006a48 <net_buf_alloc_len> @ imm = #-0x15ebc
 801c904: 6238         	str	r0, [r7, #0x20]
; 	if (!clone) {
 801c906: 6a3b         	ldr	r3, [r7, #0x20]
 801c908: 2b00         	cmp	r3, #0x0
 801c90a: d101         	bne	0x801c910 <net_buf_clone+0x3e> @ imm = #0x2
; 		return NULL;
 801c90c: 2300         	movs	r3, #0x0
 801c90e: e06a         	b	0x801c9e6 <net_buf_clone+0x114> @ imm = #0xd4
; 	if (pool->alloc->cb->ref && !(buf->flags & NET_BUF_EXTERNAL_DATA)) {
 801c910: 6a7b         	ldr	r3, [r7, #0x24]
 801c912: 69db         	ldr	r3, [r3, #0x1c]
 801c914: 681b         	ldr	r3, [r3]
 801c916: 685b         	ldr	r3, [r3, #0x4]
 801c918: 2b00         	cmp	r3, #0x0
 801c91a: d021         	beq	0x801c960 <net_buf_clone+0x8e> @ imm = #0x42
 801c91c: 68fb         	ldr	r3, [r7, #0xc]
 801c91e: 7a5b         	ldrb	r3, [r3, #0x9]
 801c920: f003 0301    	and	r3, r3, #0x1
 801c924: 2b00         	cmp	r3, #0x0
 801c926: d11b         	bne	0x801c960 <net_buf_clone+0x8e> @ imm = #0x36
; 		clone->__buf = buf->__buf ? data_ref(buf, buf->__buf) : NULL;
 801c928: 68fb         	ldr	r3, [r7, #0xc]
 801c92a: 695b         	ldr	r3, [r3, #0x14]
 801c92c: 2b00         	cmp	r3, #0x0
 801c92e: d007         	beq	0x801c940 <net_buf_clone+0x6e> @ imm = #0xe
 801c930: 68fb         	ldr	r3, [r7, #0xc]
 801c932: 695b         	ldr	r3, [r3, #0x14]
 801c934: 4619         	mov	r1, r3
 801c936: 68f8         	ldr	r0, [r7, #0xc]
 801c938: f7ff ff80    	bl	0x801c83c <data_ref>    @ imm = #-0x100
 801c93c: 4603         	mov	r3, r0
 801c93e: e000         	b	0x801c942 <net_buf_clone+0x70> @ imm = #0x0
 801c940: 2300         	movs	r3, #0x0
 801c942: 6a3a         	ldr	r2, [r7, #0x20]
 801c944: 6153         	str	r3, [r2, #0x14]
; 		clone->data = buf->data;
 801c946: 68fb         	ldr	r3, [r7, #0xc]
 801c948: 68da         	ldr	r2, [r3, #0xc]
 801c94a: 6a3b         	ldr	r3, [r7, #0x20]
 801c94c: 60da         	str	r2, [r3, #0xc]
; 		clone->len = buf->len;
 801c94e: 68fb         	ldr	r3, [r7, #0xc]
 801c950: 8a1a         	ldrh	r2, [r3, #0x10]
 801c952: 6a3b         	ldr	r3, [r7, #0x20]
 801c954: 821a         	strh	r2, [r3, #0x10]
; 		clone->size = buf->size;
 801c956: 68fb         	ldr	r3, [r7, #0xc]
 801c958: 8a5a         	ldrh	r2, [r3, #0x12]
 801c95a: 6a3b         	ldr	r3, [r7, #0x20]
 801c95c: 825a         	strh	r2, [r3, #0x12]
 801c95e: e036         	b	0x801c9ce <net_buf_clone+0xfc> @ imm = #0x6c
; 		size_t size = buf->size;
 801c960: 68fb         	ldr	r3, [r7, #0xc]
 801c962: 8a5b         	ldrh	r3, [r3, #0x12]
 801c964: 617b         	str	r3, [r7, #0x14]
; 		timeout = sys_timepoint_timeout(end);
 801c966: 4639         	mov	r1, r7
 801c968: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 801c96c: 4608         	mov	r0, r1
 801c96e: f00a fbaa    	bl	0x80270c6 <sys_timepoint_timeout> @ imm = #0xa754
; 		clone->__buf = data_alloc(clone, &size, timeout);
 801c972: f107 0114    	add.w	r1, r7, #0x14
 801c976: e9d7 2300    	ldrd	r2, r3, [r7]
 801c97a: 6a38         	ldr	r0, [r7, #0x20]
 801c97c: f7ff ff43    	bl	0x801c806 <data_alloc>  @ imm = #-0x17a
 801c980: 4602         	mov	r2, r0
 801c982: 6a3b         	ldr	r3, [r7, #0x20]
 801c984: 615a         	str	r2, [r3, #0x14]
; 		if (!clone->__buf || size < buf->size) {
 801c986: 6a3b         	ldr	r3, [r7, #0x20]
 801c988: 695b         	ldr	r3, [r3, #0x14]
 801c98a: 2b00         	cmp	r3, #0x0
 801c98c: d005         	beq	0x801c99a <net_buf_clone+0xc8> @ imm = #0xa
 801c98e: 68fb         	ldr	r3, [r7, #0xc]
 801c990: 8a5b         	ldrh	r3, [r3, #0x12]
 801c992: 461a         	mov	r2, r3
 801c994: 697b         	ldr	r3, [r7, #0x14]
 801c996: 429a         	cmp	r2, r3
 801c998: d904         	bls	0x801c9a4 <net_buf_clone+0xd2> @ imm = #0x8
; 			net_buf_destroy(clone);
 801c99a: 6a38         	ldr	r0, [r7, #0x20]
 801c99c: f7ff fe67    	bl	0x801c66e <net_buf_destroy> @ imm = #-0x332
; 			return NULL;
 801c9a0: 2300         	movs	r3, #0x0
 801c9a2: e020         	b	0x801c9e6 <net_buf_clone+0x114> @ imm = #0x40
; 		clone->size = size;
 801c9a4: 697b         	ldr	r3, [r7, #0x14]
 801c9a6: b29a         	uxth	r2, r3
 801c9a8: 6a3b         	ldr	r3, [r7, #0x20]
 801c9aa: 825a         	strh	r2, [r3, #0x12]
; 		clone->data = clone->__buf + net_buf_headroom(buf);
 801c9ac: 6a3b         	ldr	r3, [r7, #0x20]
 801c9ae: 695c         	ldr	r4, [r3, #0x14]
 801c9b0: 68f8         	ldr	r0, [r7, #0xc]
 801c9b2: f7ff fe97    	bl	0x801c6e4 <net_buf_headroom> @ imm = #-0x2d2
 801c9b6: 4603         	mov	r3, r0
 801c9b8: 18e2         	adds	r2, r4, r3
 801c9ba: 6a3b         	ldr	r3, [r7, #0x20]
 801c9bc: 60da         	str	r2, [r3, #0xc]
; 		net_buf_add_mem(clone, buf->data, buf->len);
 801c9be: 68fb         	ldr	r3, [r7, #0xc]
 801c9c0: 68d9         	ldr	r1, [r3, #0xc]
 801c9c2: 68fb         	ldr	r3, [r7, #0xc]
 801c9c4: 8a1b         	ldrh	r3, [r3, #0x10]
 801c9c6: 461a         	mov	r2, r3
 801c9c8: 6a38         	ldr	r0, [r7, #0x20]
 801c9ca: f7ff fe79    	bl	0x801c6c0 <net_buf_add_mem> @ imm = #-0x30e
; 	memcpy(clone->user_data, buf->user_data, clone->user_data_size);
 801c9ce: 6a3b         	ldr	r3, [r7, #0x20]
 801c9d0: f103 0018    	add.w	r0, r3, #0x18
 801c9d4: 68fb         	ldr	r3, [r7, #0xc]
 801c9d6: f103 0118    	add.w	r1, r3, #0x18
 801c9da: 6a3b         	ldr	r3, [r7, #0x20]
 801c9dc: 7adb         	ldrb	r3, [r3, #0xb]
 801c9de: 461a         	mov	r2, r3
 801c9e0: f00a fd84    	bl	0x80274ec <memcpy>      @ imm = #0xab08
; 	return clone;
 801c9e4: 6a3b         	ldr	r3, [r7, #0x20]
; }
 801c9e6: 4618         	mov	r0, r3
 801c9e8: 372c         	adds	r7, #0x2c
 801c9ea: 46bd         	mov	sp, r7
 801c9ec: bd90         	pop	{r4, r7, pc}

0801c9ee <net_buf_simple_tail>:
; {
 801c9ee: b480         	push	{r7}
 801c9f0: b083         	sub	sp, #0xc
 801c9f2: af00         	add	r7, sp, #0x0
 801c9f4: 6078         	str	r0, [r7, #0x4]
; 	return buf->data + buf->len;
 801c9f6: 687b         	ldr	r3, [r7, #0x4]
 801c9f8: 681b         	ldr	r3, [r3]
 801c9fa: 687a         	ldr	r2, [r7, #0x4]
 801c9fc: 8892         	ldrh	r2, [r2, #0x4]
 801c9fe: 4413         	add	r3, r2
; }
 801ca00: 4618         	mov	r0, r3
 801ca02: 370c         	adds	r7, #0xc
 801ca04: 46bd         	mov	sp, r7
 801ca06: f85d 7b04    	ldr	r7, [sp], #4
 801ca0a: 4770         	bx	lr

0801ca0c <net_buf_simple_add>:
; {
 801ca0c: b580         	push	{r7, lr}
 801ca0e: b084         	sub	sp, #0x10
 801ca10: af00         	add	r7, sp, #0x0
 801ca12: 6078         	str	r0, [r7, #0x4]
 801ca14: 6039         	str	r1, [r7]
; 	uint8_t *tail = net_buf_simple_tail(buf);
 801ca16: 6878         	ldr	r0, [r7, #0x4]
 801ca18: f7ff ffe9    	bl	0x801c9ee <net_buf_simple_tail> @ imm = #-0x2e
 801ca1c: 60f8         	str	r0, [r7, #0xc]
; 	buf->len += len;
 801ca1e: 687b         	ldr	r3, [r7, #0x4]
 801ca20: 889a         	ldrh	r2, [r3, #0x4]
 801ca22: 683b         	ldr	r3, [r7]
 801ca24: b29b         	uxth	r3, r3
 801ca26: 4413         	add	r3, r2
 801ca28: b29a         	uxth	r2, r3
 801ca2a: 687b         	ldr	r3, [r7, #0x4]
 801ca2c: 809a         	strh	r2, [r3, #0x4]
; 	return tail;
 801ca2e: 68fb         	ldr	r3, [r7, #0xc]
; }
 801ca30: 4618         	mov	r0, r3
 801ca32: 3710         	adds	r7, #0x10
 801ca34: 46bd         	mov	sp, r7
 801ca36: bd80         	pop	{r7, pc}

0801ca38 <net_buf_simple_add_mem>:
; {
 801ca38: b580         	push	{r7, lr}
 801ca3a: b084         	sub	sp, #0x10
 801ca3c: af00         	add	r7, sp, #0x0
 801ca3e: 60f8         	str	r0, [r7, #0xc]
 801ca40: 60b9         	str	r1, [r7, #0x8]
 801ca42: 607a         	str	r2, [r7, #0x4]
; 	return memcpy(net_buf_simple_add(buf, len), mem, len);
 801ca44: 6879         	ldr	r1, [r7, #0x4]
 801ca46: 68f8         	ldr	r0, [r7, #0xc]
 801ca48: f7ff ffe0    	bl	0x801ca0c <net_buf_simple_add> @ imm = #-0x40
 801ca4c: 4603         	mov	r3, r0
 801ca4e: 687a         	ldr	r2, [r7, #0x4]
 801ca50: 68b9         	ldr	r1, [r7, #0x8]
 801ca52: 4618         	mov	r0, r3
 801ca54: f00a fd4a    	bl	0x80274ec <memcpy>      @ imm = #0xaa94
 801ca58: 4603         	mov	r3, r0
; }
 801ca5a: 4618         	mov	r0, r3
 801ca5c: 3710         	adds	r7, #0x10
 801ca5e: 46bd         	mov	sp, r7
 801ca60: bd80         	pop	{r7, pc}

0801ca62 <net_buf_simple_remove_mem>:
; {
 801ca62: b480         	push	{r7}
 801ca64: b083         	sub	sp, #0xc
 801ca66: af00         	add	r7, sp, #0x0
 801ca68: 6078         	str	r0, [r7, #0x4]
 801ca6a: 6039         	str	r1, [r7]
; 	buf->len -= len;
 801ca6c: 687b         	ldr	r3, [r7, #0x4]
 801ca6e: 889a         	ldrh	r2, [r3, #0x4]
 801ca70: 683b         	ldr	r3, [r7]
 801ca72: b29b         	uxth	r3, r3
 801ca74: 1ad3         	subs	r3, r2, r3
 801ca76: b29a         	uxth	r2, r3
 801ca78: 687b         	ldr	r3, [r7, #0x4]
 801ca7a: 809a         	strh	r2, [r3, #0x4]
; 	return buf->data + buf->len;
 801ca7c: 687b         	ldr	r3, [r7, #0x4]
 801ca7e: 681b         	ldr	r3, [r3]
 801ca80: 687a         	ldr	r2, [r7, #0x4]
 801ca82: 8892         	ldrh	r2, [r2, #0x4]
 801ca84: 4413         	add	r3, r2
; }
 801ca86: 4618         	mov	r0, r3
 801ca88: 370c         	adds	r7, #0xc
 801ca8a: 46bd         	mov	sp, r7
 801ca8c: f85d 7b04    	ldr	r7, [sp], #4
 801ca90: 4770         	bx	lr

0801ca92 <net_buf_simple_headroom>:
; {
 801ca92: b480         	push	{r7}
 801ca94: b083         	sub	sp, #0xc
 801ca96: af00         	add	r7, sp, #0x0
 801ca98: 6078         	str	r0, [r7, #0x4]
; 	return buf->data - buf->__buf;
 801ca9a: 687b         	ldr	r3, [r7, #0x4]
 801ca9c: 681a         	ldr	r2, [r3]
 801ca9e: 687b         	ldr	r3, [r7, #0x4]
 801caa0: 689b         	ldr	r3, [r3, #0x8]
 801caa2: 1ad3         	subs	r3, r2, r3
; }
 801caa4: 4618         	mov	r0, r3
 801caa6: 370c         	adds	r7, #0xc
 801caa8: 46bd         	mov	sp, r7
 801caaa: f85d 7b04    	ldr	r7, [sp], #4
 801caae: 4770         	bx	lr

0801cab0 <z_snode_next_peek>:
; {
 801cab0: b480         	push	{r7}
 801cab2: b083         	sub	sp, #0xc
 801cab4: af00         	add	r7, sp, #0x0
 801cab6: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 801cab8: 687b         	ldr	r3, [r7, #0x4]
 801caba: 681b         	ldr	r3, [r3]
; }
 801cabc: 4618         	mov	r0, r3
 801cabe: 370c         	adds	r7, #0xc
 801cac0: 46bd         	mov	sp, r7
 801cac2: f85d 7b04    	ldr	r7, [sp], #4
 801cac6: 4770         	bx	lr

0801cac8 <sys_slist_peek_head>:
; {
 801cac8: b480         	push	{r7}
 801caca: b083         	sub	sp, #0xc
 801cacc: af00         	add	r7, sp, #0x0
 801cace: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 801cad0: 687b         	ldr	r3, [r7, #0x4]
 801cad2: 681b         	ldr	r3, [r3]
; }
 801cad4: 4618         	mov	r0, r3
 801cad6: 370c         	adds	r7, #0xc
 801cad8: 46bd         	mov	sp, r7
 801cada: f85d 7b04    	ldr	r7, [sp], #4
 801cade: 4770         	bx	lr

0801cae0 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 801cae0: b580         	push	{r7, lr}
 801cae2: b082         	sub	sp, #0x8
 801cae4: af00         	add	r7, sp, #0x0
 801cae6: 6078         	str	r0, [r7, #0x4]
 801cae8: 6878         	ldr	r0, [r7, #0x4]
 801caea: f7ff ffe1    	bl	0x801cab0 <z_snode_next_peek> @ imm = #-0x3e
 801caee: 4603         	mov	r3, r0
 801caf0: 4618         	mov	r0, r3
 801caf2: 3708         	adds	r7, #0x8
 801caf4: 46bd         	mov	sp, r7
 801caf6: bd80         	pop	{r7, pc}

0801caf8 <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801caf8: b580         	push	{r7, lr}
 801cafa: b082         	sub	sp, #0x8
 801cafc: af00         	add	r7, sp, #0x0
 801cafe: 6078         	str	r0, [r7, #0x4]
 801cb00: 687b         	ldr	r3, [r7, #0x4]
 801cb02: 2b00         	cmp	r3, #0x0
 801cb04: d004         	beq	0x801cb10 <sys_slist_peek_next+0x18> @ imm = #0x8
 801cb06: 6878         	ldr	r0, [r7, #0x4]
 801cb08: f7ff ffea    	bl	0x801cae0 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 801cb0c: 4603         	mov	r3, r0
 801cb0e: e000         	b	0x801cb12 <sys_slist_peek_next+0x1a> @ imm = #0x0
 801cb10: 2300         	movs	r3, #0x0
 801cb12: 4618         	mov	r0, r3
 801cb14: 3708         	adds	r7, #0x8
 801cb16: 46bd         	mov	sp, r7
 801cb18: bd80         	pop	{r7, pc}

0801cb1a <k_thread_priority_get>:
; {
 801cb1a: b580         	push	{r7, lr}
 801cb1c: b082         	sub	sp, #0x8
 801cb1e: af00         	add	r7, sp, #0x0
 801cb20: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_thread_priority_get(thread);
 801cb22: 6878         	ldr	r0, [r7, #0x4]
 801cb24: f009 fb6c    	bl	0x8026200 <z_impl_k_thread_priority_get> @ imm = #0x96d8
 801cb28: 4603         	mov	r3, r0
; }
 801cb2a: 4618         	mov	r0, r3
 801cb2c: 3708         	adds	r7, #0x8
 801cb2e: 46bd         	mov	sp, r7
 801cb30: bd80         	pop	{r7, pc}

0801cb32 <k_thread_priority_set>:
; {
 801cb32: b580         	push	{r7, lr}
 801cb34: b082         	sub	sp, #0x8
 801cb36: af00         	add	r7, sp, #0x0
 801cb38: 6078         	str	r0, [r7, #0x4]
 801cb3a: 6039         	str	r1, [r7]
; 	z_impl_k_thread_priority_set(thread, prio);
 801cb3c: 6839         	ldr	r1, [r7]
 801cb3e: 6878         	ldr	r0, [r7, #0x4]
 801cb40: f7f9 f9ea    	bl	0x8015f18 <z_impl_k_thread_priority_set> @ imm = #-0x6c2c
; }
 801cb44: bf00         	nop
 801cb46: 3708         	adds	r7, #0x8
 801cb48: 46bd         	mov	sp, r7
 801cb4a: bd80         	pop	{r7, pc}

0801cb4c <k_queue_get>:
; {
 801cb4c: b580         	push	{r7, lr}
 801cb4e: b084         	sub	sp, #0x10
 801cb50: af00         	add	r7, sp, #0x0
 801cb52: 60f8         	str	r0, [r7, #0xc]
 801cb54: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_queue_get(queue, timeout);
 801cb58: e9d7 2300    	ldrd	r2, r3, [r7]
 801cb5c: 68f8         	ldr	r0, [r7, #0xc]
 801cb5e: f7f7 f9e9    	bl	0x8013f34 <z_impl_k_queue_get> @ imm = #-0x8c2e
 801cb62: 4603         	mov	r3, r0
; }
 801cb64: 4618         	mov	r0, r3
 801cb66: 3710         	adds	r7, #0x10
 801cb68: 46bd         	mov	sp, r7
 801cb6a: bd80         	pop	{r7, pc}

0801cb6c <k_sem_take>:
; {
 801cb6c: b580         	push	{r7, lr}
 801cb6e: b084         	sub	sp, #0x10
 801cb70: af00         	add	r7, sp, #0x0
 801cb72: 60f8         	str	r0, [r7, #0xc]
 801cb74: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 801cb78: e9d7 2300    	ldrd	r2, r3, [r7]
 801cb7c: 68f8         	ldr	r0, [r7, #0xc]
 801cb7e: f7f7 faed    	bl	0x801415c <z_impl_k_sem_take> @ imm = #-0x8a26
 801cb82: 4603         	mov	r3, r0
; }
 801cb84: 4618         	mov	r0, r3
 801cb86: 3710         	adds	r7, #0x10
 801cb88: 46bd         	mov	sp, r7
 801cb8a: bd80         	pop	{r7, pc}

0801cb8c <k_sem_give>:
; {
 801cb8c: b580         	push	{r7, lr}
 801cb8e: b082         	sub	sp, #0x8
 801cb90: af00         	add	r7, sp, #0x0
 801cb92: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801cb94: 6878         	ldr	r0, [r7, #0x4]
 801cb96: f7f7 fa53    	bl	0x8014040 <z_impl_k_sem_give> @ imm = #-0x8b5a
; }
 801cb9a: bf00         	nop
 801cb9c: 3708         	adds	r7, #0x8
 801cb9e: 46bd         	mov	sp, r7
 801cba0: bd80         	pop	{r7, pc}

0801cba2 <k_msgq_put>:
; {
 801cba2: b580         	push	{r7, lr}
 801cba4: b084         	sub	sp, #0x10
 801cba6: af00         	add	r7, sp, #0x0
 801cba8: 60f8         	str	r0, [r7, #0xc]
 801cbaa: 60b9         	str	r1, [r7, #0x8]
 801cbac: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_msgq_put(msgq, data, timeout);
 801cbb0: e9d7 2300    	ldrd	r2, r3, [r7]
 801cbb4: 68b9         	ldr	r1, [r7, #0x8]
 801cbb6: 68f8         	ldr	r0, [r7, #0xc]
 801cbb8: f7f6 fd58    	bl	0x801366c <z_impl_k_msgq_put> @ imm = #-0x9550
 801cbbc: 4603         	mov	r3, r0
; }
 801cbbe: 4618         	mov	r0, r3
 801cbc0: 3710         	adds	r7, #0x10
 801cbc2: 46bd         	mov	sp, r7
 801cbc4: bd80         	pop	{r7, pc}

0801cbc6 <z_log_msg_runtime_create>:
; {
 801cbc6: b580         	push	{r7, lr}
 801cbc8: b08a         	sub	sp, #0x28
 801cbca: af04         	add	r7, sp, #0x10
 801cbcc: 60b9         	str	r1, [r7, #0x8]
 801cbce: 607b         	str	r3, [r7, #0x4]
 801cbd0: 4603         	mov	r3, r0
 801cbd2: 73fb         	strb	r3, [r7, #0xf]
 801cbd4: 4613         	mov	r3, r2
 801cbd6: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801cbd8: f107 032c    	add.w	r3, r7, #0x2c
 801cbdc: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801cbde: 7bba         	ldrb	r2, [r7, #0xe]
 801cbe0: 7bf8         	ldrb	r0, [r7, #0xf]
 801cbe2: 697b         	ldr	r3, [r7, #0x14]
 801cbe4: 9303         	str	r3, [sp, #0xc]
 801cbe6: 6abb         	ldr	r3, [r7, #0x28]
 801cbe8: 9302         	str	r3, [sp, #0x8]
 801cbea: 6a7b         	ldr	r3, [r7, #0x24]
 801cbec: 9301         	str	r3, [sp, #0x4]
 801cbee: 6a3b         	ldr	r3, [r7, #0x20]
 801cbf0: 9300         	str	r3, [sp]
 801cbf2: 687b         	ldr	r3, [r7, #0x4]
 801cbf4: 68b9         	ldr	r1, [r7, #0x8]
 801cbf6: f7e7 ffa5    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x180b6
; }
 801cbfa: bf00         	nop
 801cbfc: 3718         	adds	r7, #0x18
 801cbfe: 46bd         	mov	sp, r7
 801cc00: bd80         	pop	{r7, pc}

0801cc02 <net_buf_user_data>:
; {
 801cc02: b480         	push	{r7}
 801cc04: b083         	sub	sp, #0xc
 801cc06: af00         	add	r7, sp, #0x0
 801cc08: 6078         	str	r0, [r7, #0x4]
; 	return (void *)buf->user_data;
 801cc0a: 687b         	ldr	r3, [r7, #0x4]
 801cc0c: 3318         	adds	r3, #0x18
; }
 801cc0e: 4618         	mov	r0, r3
 801cc10: 370c         	adds	r7, #0xc
 801cc12: 46bd         	mov	sp, r7
 801cc14: f85d 7b04    	ldr	r7, [sp], #4
 801cc18: 4770         	bx	lr

0801cc1a <net_buf_add_mem>:
; {
 801cc1a: b580         	push	{r7, lr}
 801cc1c: b084         	sub	sp, #0x10
 801cc1e: af00         	add	r7, sp, #0x0
 801cc20: 60f8         	str	r0, [r7, #0xc]
 801cc22: 60b9         	str	r1, [r7, #0x8]
 801cc24: 607a         	str	r2, [r7, #0x4]
; 	return net_buf_simple_add_mem(&buf->b, mem, len);
 801cc26: 68fb         	ldr	r3, [r7, #0xc]
 801cc28: 330c         	adds	r3, #0xc
 801cc2a: 687a         	ldr	r2, [r7, #0x4]
 801cc2c: 68b9         	ldr	r1, [r7, #0x8]
 801cc2e: 4618         	mov	r0, r3
 801cc30: f7ff ff02    	bl	0x801ca38 <net_buf_simple_add_mem> @ imm = #-0x1fc
 801cc34: 4603         	mov	r3, r0
; }
 801cc36: 4618         	mov	r0, r3
 801cc38: 3710         	adds	r7, #0x10
 801cc3a: 46bd         	mov	sp, r7
 801cc3c: bd80         	pop	{r7, pc}

0801cc3e <net_buf_remove_mem>:
; {
 801cc3e: b580         	push	{r7, lr}
 801cc40: b082         	sub	sp, #0x8
 801cc42: af00         	add	r7, sp, #0x0
 801cc44: 6078         	str	r0, [r7, #0x4]
 801cc46: 6039         	str	r1, [r7]
; 	return net_buf_simple_remove_mem(&buf->b, len);
 801cc48: 687b         	ldr	r3, [r7, #0x4]
 801cc4a: 330c         	adds	r3, #0xc
 801cc4c: 6839         	ldr	r1, [r7]
 801cc4e: 4618         	mov	r0, r3
 801cc50: f7ff ff07    	bl	0x801ca62 <net_buf_simple_remove_mem> @ imm = #-0x1f2
 801cc54: 4603         	mov	r3, r0
; }
 801cc56: 4618         	mov	r0, r3
 801cc58: 3708         	adds	r7, #0x8
 801cc5a: 46bd         	mov	sp, r7
 801cc5c: bd80         	pop	{r7, pc}

0801cc5e <zbus_chan_msg>:
; {
 801cc5e: b480         	push	{r7}
 801cc60: b083         	sub	sp, #0xc
 801cc62: af00         	add	r7, sp, #0x0
 801cc64: 6078         	str	r0, [r7, #0x4]
; 	return chan->message;
 801cc66: 687b         	ldr	r3, [r7, #0x4]
 801cc68: 681b         	ldr	r3, [r3]
; }
 801cc6a: 4618         	mov	r0, r3
 801cc6c: 370c         	adds	r7, #0xc
 801cc6e: 46bd         	mov	sp, r7
 801cc70: f85d 7b04    	ldr	r7, [sp], #4
 801cc74: 4770         	bx	lr

0801cc76 <zbus_chan_msg_size>:
; {
 801cc76: b480         	push	{r7}
 801cc78: b083         	sub	sp, #0xc
 801cc7a: af00         	add	r7, sp, #0x0
 801cc7c: 6078         	str	r0, [r7, #0x4]
; 	return chan->message_size;
 801cc7e: 687b         	ldr	r3, [r7, #0x4]
 801cc80: 685b         	ldr	r3, [r3, #0x4]
 801cc82: b29b         	uxth	r3, r3
; }
 801cc84: 4618         	mov	r0, r3
 801cc86: 370c         	adds	r7, #0xc
 801cc88: 46bd         	mov	sp, r7
 801cc8a: f85d 7b04    	ldr	r7, [sp], #4
 801cc8e: 4770         	bx	lr

0801cc90 <_zbus_create_net_buf>:
; {
 801cc90: b580         	push	{r7, lr}
 801cc92: b084         	sub	sp, #0x10
 801cc94: af00         	add	r7, sp, #0x0
 801cc96: 60f8         	str	r0, [r7, #0xc]
 801cc98: 60b9         	str	r1, [r7, #0x8]
 801cc9a: e9c7 2300    	strd	r2, r3, [r7]
; 	return net_buf_alloc_len(pool, size, timeout);
 801cc9e: e9d7 2300    	ldrd	r2, r3, [r7]
 801cca2: 68b9         	ldr	r1, [r7, #0x8]
 801cca4: 68f8         	ldr	r0, [r7, #0xc]
 801cca6: f7e9 fecf    	bl	0x8006a48 <net_buf_alloc_len> @ imm = #-0x16262
 801ccaa: 4603         	mov	r3, r0
; }
 801ccac: 4618         	mov	r0, r3
 801ccae: 3710         	adds	r7, #0x10
 801ccb0: 46bd         	mov	sp, r7
 801ccb2: bd80         	pop	{r7, pc}

0801ccb4 <_zbus_notify_observer>:
; {
 801ccb4: b590         	push	{r4, r7, lr}
 801ccb6: b08b         	sub	sp, #0x2c
 801ccb8: af00         	add	r7, sp, #0x0
 801ccba: 60f8         	str	r0, [r7, #0xc]
 801ccbc: 60b9         	str	r1, [r7, #0x8]
 801ccbe: e9c7 2300    	strd	r2, r3, [r7]
; 	switch (obs->type) {
 801ccc2: 68bb         	ldr	r3, [r7, #0x8]
 801ccc4: 781b         	ldrb	r3, [r3]
 801ccc6: 2b02         	cmp	r3, #0x2
 801ccc8: d01e         	beq	0x801cd08 <_zbus_notify_observer+0x54> @ imm = #0x3c
 801ccca: 2b02         	cmp	r3, #0x2
 801cccc: dc36         	bgt	0x801cd3c <_zbus_notify_observer+0x88> @ imm = #0x6c
 801ccce: 2b00         	cmp	r3, #0x0
 801ccd0: d002         	beq	0x801ccd8 <_zbus_notify_observer+0x24> @ imm = #0x4
 801ccd2: 2b01         	cmp	r3, #0x1
 801ccd4: d006         	beq	0x801cce4 <_zbus_notify_observer+0x30> @ imm = #0xc
 801ccd6: e031         	b	0x801cd3c <_zbus_notify_observer+0x88> @ imm = #0x62
; 		obs->callback(chan);
 801ccd8: 68bb         	ldr	r3, [r7, #0x8]
 801ccda: 689b         	ldr	r3, [r3, #0x8]
 801ccdc: 68fa         	ldr	r2, [r7, #0xc]
 801ccde: 4610         	mov	r0, r2
 801cce0: 4798         	blx	r3
; 		break;
 801cce2: e02b         	b	0x801cd3c <_zbus_notify_observer+0x88> @ imm = #0x56
; 		return k_msgq_put(obs->queue, &chan, sys_timepoint_timeout(end_time));
 801cce4: 68bb         	ldr	r3, [r7, #0x8]
 801cce6: 689c         	ldr	r4, [r3, #0x8]
 801cce8: f107 0110    	add.w	r1, r7, #0x10
 801ccec: e9d7 2300    	ldrd	r2, r3, [r7]
 801ccf0: 4608         	mov	r0, r1
 801ccf2: f00a f9e8    	bl	0x80270c6 <sys_timepoint_timeout> @ imm = #0xa3d0
 801ccf6: f107 010c    	add.w	r1, r7, #0xc
 801ccfa: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 801ccfe: 4620         	mov	r0, r4
 801cd00: f7ff ff4f    	bl	0x801cba2 <k_msgq_put>  @ imm = #-0x162
 801cd04: 4603         	mov	r3, r0
 801cd06: e01a         	b	0x801cd3e <_zbus_notify_observer+0x8a> @ imm = #0x34
; 		struct net_buf *cloned_buf = net_buf_clone(buf, sys_timepoint_timeout(end_time));
 801cd08: f107 0118    	add.w	r1, r7, #0x18
 801cd0c: e9d7 2300    	ldrd	r2, r3, [r7]
 801cd10: 4608         	mov	r0, r1
 801cd12: f00a f9d8    	bl	0x80270c6 <sys_timepoint_timeout> @ imm = #0xa3b0
 801cd16: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 801cd1a: 6bb8         	ldr	r0, [r7, #0x38]
 801cd1c: f7ff fdd9    	bl	0x801c8d2 <net_buf_clone> @ imm = #-0x44e
 801cd20: 6278         	str	r0, [r7, #0x24]
; 		if (cloned_buf == NULL) {
 801cd22: 6a7b         	ldr	r3, [r7, #0x24]
 801cd24: 2b00         	cmp	r3, #0x0
 801cd26: d102         	bne	0x801cd2e <_zbus_notify_observer+0x7a> @ imm = #0x4
; 			return -ENOMEM;
 801cd28: f06f 030b    	mvn	r3, #0xb
 801cd2c: e007         	b	0x801cd3e <_zbus_notify_observer+0x8a> @ imm = #0xe
; 		k_fifo_put(obs->message_fifo, cloned_buf);
 801cd2e: 68bb         	ldr	r3, [r7, #0x8]
 801cd30: 689b         	ldr	r3, [r3, #0x8]
 801cd32: 6a79         	ldr	r1, [r7, #0x24]
 801cd34: 4618         	mov	r0, r3
 801cd36: f008 fce6    	bl	0x8025706 <k_queue_append> @ imm = #0x89cc
; 		break;
 801cd3a: bf00         	nop
; 	return 0;
 801cd3c: 2300         	movs	r3, #0x0
; }
 801cd3e: 4618         	mov	r0, r3
 801cd40: 372c         	adds	r7, #0x2c
 801cd42: 46bd         	mov	sp, r7
 801cd44: bd90         	pop	{r4, r7, pc}

0801cd46 <chan_unlock>:
; {
 801cd46: b580         	push	{r7, lr}
 801cd48: b082         	sub	sp, #0x8
 801cd4a: af00         	add	r7, sp, #0x0
 801cd4c: 6078         	str	r0, [r7, #0x4]
 801cd4e: 6039         	str	r1, [r7]
; 	k_sem_give(&chan->data->sem);
 801cd50: 687b         	ldr	r3, [r7, #0x4]
 801cd52: 691b         	ldr	r3, [r3, #0x10]
 801cd54: 3304         	adds	r3, #0x4
 801cd56: 4618         	mov	r0, r3
 801cd58: f7ff ff18    	bl	0x801cb8c <k_sem_give>  @ imm = #-0x1d0
; 	if (prio < ZBUS_MIN_THREAD_PRIORITY) {
 801cd5c: 683b         	ldr	r3, [r7]
 801cd5e: 2b0d         	cmp	r3, #0xd
 801cd60: dc06         	bgt	0x801cd70 <chan_unlock+0x2a> @ imm = #0xc
; 		k_thread_priority_set(k_current_get(), prio);
 801cd62: f7e9 ff93    	bl	0x8006c8c <k_current_get> @ imm = #-0x160da
 801cd66: 4603         	mov	r3, r0
 801cd68: 6839         	ldr	r1, [r7]
 801cd6a: 4618         	mov	r0, r3
 801cd6c: f7ff fee1    	bl	0x801cb32 <k_thread_priority_set> @ imm = #-0x23e
; }
 801cd70: bf00         	nop
 801cd72: 3708         	adds	r7, #0x8
 801cd74: 46bd         	mov	sp, r7
 801cd76: bd80         	pop	{r7, pc}

0801cd78 <zbus_chan_pub>:
; {
 801cd78: b580         	push	{r7, lr}
 801cd7a: b08c         	sub	sp, #0x30
 801cd7c: af02         	add	r7, sp, #0x8
 801cd7e: 60f8         	str	r0, [r7, #0xc]
 801cd80: 60b9         	str	r1, [r7, #0x8]
 801cd82: e9c7 2300    	strd	r2, r3, [r7]
; 	if (k_is_in_isr()) {
 801cd86: f009 fa29    	bl	0x80261dc <k_is_in_isr> @ imm = #0x9452
 801cd8a: 4603         	mov	r3, r0
 801cd8c: 2b00         	cmp	r3, #0x0
 801cd8e: d005         	beq	0x801cd9c <zbus_chan_pub+0x24> @ imm = #0xa
; 		timeout = K_NO_WAIT;
 801cd90: f04f 0200    	mov.w	r2, #0x0
 801cd94: f04f 0300    	mov.w	r3, #0x0
 801cd98: e9c7 2300    	strd	r2, r3, [r7]
; 	k_timepoint_t end_time = sys_timepoint_calc(timeout);
 801cd9c: f107 0118    	add.w	r1, r7, #0x18
 801cda0: e9d7 2300    	ldrd	r2, r3, [r7]
 801cda4: 4608         	mov	r0, r1
 801cda6: f00a f929    	bl	0x8026ffc <sys_timepoint_calc> @ imm = #0xa252
; 	if (chan->validator != NULL && !chan->validator(msg, chan->message_size)) {
 801cdaa: 68fb         	ldr	r3, [r7, #0xc]
 801cdac: 68db         	ldr	r3, [r3, #0xc]
 801cdae: 2b00         	cmp	r3, #0x0
 801cdb0: d00f         	beq	0x801cdd2 <zbus_chan_pub+0x5a> @ imm = #0x1e
 801cdb2: 68fb         	ldr	r3, [r7, #0xc]
 801cdb4: 68db         	ldr	r3, [r3, #0xc]
 801cdb6: 68fa         	ldr	r2, [r7, #0xc]
 801cdb8: 6852         	ldr	r2, [r2, #0x4]
 801cdba: 4611         	mov	r1, r2
 801cdbc: 68b8         	ldr	r0, [r7, #0x8]
 801cdbe: 4798         	blx	r3
 801cdc0: 4603         	mov	r3, r0
 801cdc2: f083 0301    	eor	r3, r3, #0x1
 801cdc6: b2db         	uxtb	r3, r3
 801cdc8: 2b00         	cmp	r3, #0x0
 801cdca: d002         	beq	0x801cdd2 <zbus_chan_pub+0x5a> @ imm = #0x4
; 		return -ENOMSG;
 801cdcc: f06f 0322    	mvn	r3, #0x22
 801cdd0: e023         	b	0x801ce1a <zbus_chan_pub+0xa2> @ imm = #0x46
; 	int context_priority = ZBUS_MIN_THREAD_PRIORITY;
 801cdd2: 230e         	movs	r3, #0xe
 801cdd4: 617b         	str	r3, [r7, #0x14]
; 	err = chan_lock(chan, timeout, &context_priority);
 801cdd6: f107 0314    	add.w	r3, r7, #0x14
 801cdda: 9300         	str	r3, [sp]
 801cddc: e9d7 2300    	ldrd	r2, r3, [r7]
 801cde0: 68f8         	ldr	r0, [r7, #0xc]
 801cde2: f7ea f90b    	bl	0x8006ffc <chan_lock>   @ imm = #-0x15dea
 801cde6: 6278         	str	r0, [r7, #0x24]
; 	if (err) {
 801cde8: 6a7b         	ldr	r3, [r7, #0x24]
 801cdea: 2b00         	cmp	r3, #0x0
 801cdec: d001         	beq	0x801cdf2 <zbus_chan_pub+0x7a> @ imm = #0x2
; 		return err;
 801cdee: 6a7b         	ldr	r3, [r7, #0x24]
 801cdf0: e013         	b	0x801ce1a <zbus_chan_pub+0xa2> @ imm = #0x26
; 	memcpy(chan->message, msg, chan->message_size);
 801cdf2: 68fb         	ldr	r3, [r7, #0xc]
 801cdf4: 6818         	ldr	r0, [r3]
 801cdf6: 68fb         	ldr	r3, [r7, #0xc]
 801cdf8: 685b         	ldr	r3, [r3, #0x4]
 801cdfa: 461a         	mov	r2, r3
 801cdfc: 68b9         	ldr	r1, [r7, #0x8]
 801cdfe: f00a fb75    	bl	0x80274ec <memcpy>      @ imm = #0xa6ea
; 	err = _zbus_vded_exec(chan, end_time);
 801ce02: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 801ce06: 68f8         	ldr	r0, [r7, #0xc]
 801ce08: f7e9 ff9a    	bl	0x8006d40 <_zbus_vded_exec> @ imm = #-0x160cc
 801ce0c: 6278         	str	r0, [r7, #0x24]
; 	chan_unlock(chan, context_priority);
 801ce0e: 697b         	ldr	r3, [r7, #0x14]
 801ce10: 4619         	mov	r1, r3
 801ce12: 68f8         	ldr	r0, [r7, #0xc]
 801ce14: f7ff ff97    	bl	0x801cd46 <chan_unlock> @ imm = #-0xd2
; 	return err;
 801ce18: 6a7b         	ldr	r3, [r7, #0x24]
; }
 801ce1a: 4618         	mov	r0, r3
 801ce1c: 3728         	adds	r7, #0x28
 801ce1e: 46bd         	mov	sp, r7
 801ce20: bd80         	pop	{r7, pc}

0801ce22 <zbus_sub_wait_msg>:
; {
 801ce22: b590         	push	{r4, r7, lr}
 801ce24: b087         	sub	sp, #0x1c
 801ce26: af00         	add	r7, sp, #0x0
 801ce28: 60f8         	str	r0, [r7, #0xc]
 801ce2a: 60b9         	str	r1, [r7, #0x8]
 801ce2c: 607a         	str	r2, [r7, #0x4]
; 	struct net_buf *buf = k_fifo_get(sub->message_fifo, timeout);
 801ce2e: 68fb         	ldr	r3, [r7, #0xc]
 801ce30: 689b         	ldr	r3, [r3, #0x8]
 801ce32: 4619         	mov	r1, r3
 801ce34: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 801ce38: 4608         	mov	r0, r1
 801ce3a: f7ff fe87    	bl	0x801cb4c <k_queue_get> @ imm = #-0x2f2
 801ce3e: 6178         	str	r0, [r7, #0x14]
 801ce40: 697b         	ldr	r3, [r7, #0x14]
 801ce42: 613b         	str	r3, [r7, #0x10]
; 	if (buf == NULL) {
 801ce44: 693b         	ldr	r3, [r7, #0x10]
 801ce46: 2b00         	cmp	r3, #0x0
 801ce48: d102         	bne	0x801ce50 <zbus_sub_wait_msg+0x2e> @ imm = #0x4
; 		return -ENOMSG;
 801ce4a: f06f 0322    	mvn	r3, #0x22
 801ce4e: e020         	b	0x801ce92 <zbus_sub_wait_msg+0x70> @ imm = #0x40
; 	*chan = *((struct zbus_channel **)net_buf_user_data(buf));
 801ce50: 6938         	ldr	r0, [r7, #0x10]
 801ce52: f7ff fed6    	bl	0x801cc02 <net_buf_user_data> @ imm = #-0x254
 801ce56: 4603         	mov	r3, r0
 801ce58: 681a         	ldr	r2, [r3]
 801ce5a: 68bb         	ldr	r3, [r7, #0x8]
 801ce5c: 601a         	str	r2, [r3]
; 	memcpy(msg, net_buf_remove_mem(buf, zbus_chan_msg_size(*chan)), zbus_chan_msg_size(*chan));
 801ce5e: 68bb         	ldr	r3, [r7, #0x8]
 801ce60: 681b         	ldr	r3, [r3]
 801ce62: 4618         	mov	r0, r3
 801ce64: f7ff ff07    	bl	0x801cc76 <zbus_chan_msg_size> @ imm = #-0x1f2
 801ce68: 4603         	mov	r3, r0
 801ce6a: 4619         	mov	r1, r3
 801ce6c: 6938         	ldr	r0, [r7, #0x10]
 801ce6e: f7ff fee6    	bl	0x801cc3e <net_buf_remove_mem> @ imm = #-0x234
 801ce72: 4604         	mov	r4, r0
 801ce74: 68bb         	ldr	r3, [r7, #0x8]
 801ce76: 681b         	ldr	r3, [r3]
 801ce78: 4618         	mov	r0, r3
 801ce7a: f7ff fefc    	bl	0x801cc76 <zbus_chan_msg_size> @ imm = #-0x208
 801ce7e: 4603         	mov	r3, r0
 801ce80: 461a         	mov	r2, r3
 801ce82: 4621         	mov	r1, r4
 801ce84: 6878         	ldr	r0, [r7, #0x4]
 801ce86: f00a fb31    	bl	0x80274ec <memcpy>      @ imm = #0xa662
; 	net_buf_unref(buf);
 801ce8a: 6938         	ldr	r0, [r7, #0x10]
 801ce8c: f7ff fced    	bl	0x801c86a <net_buf_unref> @ imm = #-0x626
; 	return 0;
 801ce90: 2300         	movs	r3, #0x0
; }
 801ce92: 4618         	mov	r0, r3
 801ce94: 371c         	adds	r7, #0x1c
 801ce96: 46bd         	mov	sp, r7
 801ce98: bd90         	pop	{r4, r7, pc}

0801ce9a <clock_control_on>:
; {
 801ce9a: b580         	push	{r7, lr}
 801ce9c: b084         	sub	sp, #0x10
 801ce9e: af00         	add	r7, sp, #0x0
 801cea0: 6078         	str	r0, [r7, #0x4]
 801cea2: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801cea4: 687b         	ldr	r3, [r7, #0x4]
 801cea6: 689b         	ldr	r3, [r3, #0x8]
 801cea8: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801ceaa: 68fb         	ldr	r3, [r7, #0xc]
 801ceac: 681b         	ldr	r3, [r3]
 801ceae: 6839         	ldr	r1, [r7]
 801ceb0: 6878         	ldr	r0, [r7, #0x4]
 801ceb2: 4798         	blx	r3
 801ceb4: 4603         	mov	r3, r0
; }
 801ceb6: 4618         	mov	r0, r3
 801ceb8: 3710         	adds	r7, #0x10
 801ceba: 46bd         	mov	sp, r7
 801cebc: bd80         	pop	{r7, pc}

0801cebe <z_stm32_hsem_lock>:
; {
 801cebe: b480         	push	{r7}
 801cec0: b083         	sub	sp, #0xc
 801cec2: af00         	add	r7, sp, #0x0
 801cec4: 6078         	str	r0, [r7, #0x4]
 801cec6: 6039         	str	r1, [r7]
; }
 801cec8: bf00         	nop
 801ceca: 370c         	adds	r7, #0xc
 801cecc: 46bd         	mov	sp, r7
 801cece: f85d 7b04    	ldr	r7, [sp], #4
 801ced2: 4770         	bx	lr

0801ced4 <z_stm32_hsem_unlock>:
; {
 801ced4: b480         	push	{r7}
 801ced6: b083         	sub	sp, #0xc
 801ced8: af00         	add	r7, sp, #0x0
 801ceda: 6078         	str	r0, [r7, #0x4]
; }
 801cedc: bf00         	nop
 801cede: 370c         	adds	r7, #0xc
 801cee0: 46bd         	mov	sp, r7
 801cee2: f85d 7b04    	ldr	r7, [sp], #4
 801cee6: 4770         	bx	lr

0801cee8 <stm32_exti_linenum_to_src_cfg_line>:
; {
 801cee8: b480         	push	{r7}
 801ceea: b083         	sub	sp, #0xc
 801ceec: af00         	add	r7, sp, #0x0
 801ceee: 4603         	mov	r3, r0
 801cef0: 71fb         	strb	r3, [r7, #0x7]
; 	return (0xF << ((linenum % 4 * 4) + 16)) | (linenum / 4);
 801cef2: 79fb         	ldrb	r3, [r7, #0x7]
 801cef4: f003 0303    	and	r3, r3, #0x3
 801cef8: 3304         	adds	r3, #0x4
 801cefa: 009b         	lsls	r3, r3, #0x2
 801cefc: 220f         	movs	r2, #0xf
 801cefe: fa02 f303    	lsl.w	r3, r2, r3
 801cf02: 79fa         	ldrb	r2, [r7, #0x7]
 801cf04: 0892         	lsrs	r2, r2, #0x2
 801cf06: b2d2         	uxtb	r2, r2
 801cf08: 4313         	orrs	r3, r2
; }
 801cf0a: 4618         	mov	r0, r3
 801cf0c: 370c         	adds	r7, #0xc
 801cf0e: 46bd         	mov	sp, r7
 801cf10: f85d 7b04    	ldr	r7, [sp], #4
 801cf14: 4770         	bx	lr

0801cf16 <stm32_exti_is_pending>:
; {
 801cf16: b580         	push	{r7, lr}
 801cf18: b082         	sub	sp, #0x8
 801cf1a: af00         	add	r7, sp, #0x0
 801cf1c: 6078         	str	r0, [r7, #0x4]
; 	return LL_EXTI_IsActiveFlag_0_31(line);
 801cf1e: 6878         	ldr	r0, [r7, #0x4]
 801cf20: f7ea f968    	bl	0x80071f4 <LL_EXTI_IsActiveFlag_0_31> @ imm = #-0x15d30
 801cf24: 4603         	mov	r3, r0
; }
 801cf26: 4618         	mov	r0, r3
 801cf28: 3708         	adds	r7, #0x8
 801cf2a: 46bd         	mov	sp, r7
 801cf2c: bd80         	pop	{r7, pc}

0801cf2e <stm32_exti_clear_pending>:
; {
 801cf2e: b580         	push	{r7, lr}
 801cf30: b082         	sub	sp, #0x8
 801cf32: af00         	add	r7, sp, #0x0
 801cf34: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_ClearFlag_0_31(line);
 801cf36: 6878         	ldr	r0, [r7, #0x4]
 801cf38: f7ea f972    	bl	0x8007220 <LL_EXTI_ClearFlag_0_31> @ imm = #-0x15d1c
; }
 801cf3c: bf00         	nop
 801cf3e: 3708         	adds	r7, #0x8
 801cf40: 46bd         	mov	sp, r7
 801cf42: bd80         	pop	{r7, pc}

0801cf44 <linenum_to_ll_exti_line>:
; {
 801cf44: b480         	push	{r7}
 801cf46: b083         	sub	sp, #0xc
 801cf48: af00         	add	r7, sp, #0x0
 801cf4a: 4603         	mov	r3, r0
 801cf4c: 71fb         	strb	r3, [r7, #0x7]
; 	return BIT(linenum);
 801cf4e: 79fb         	ldrb	r3, [r7, #0x7]
 801cf50: 2201         	movs	r2, #0x1
 801cf52: fa02 f303    	lsl.w	r3, r2, r3
; }
 801cf56: 4618         	mov	r0, r3
 801cf58: 370c         	adds	r7, #0xc
 801cf5a: 46bd         	mov	sp, r7
 801cf5c: f85d 7b04    	ldr	r7, [sp], #4
 801cf60: 4770         	bx	lr

0801cf62 <ll_exti_line_to_linenum>:
; {
 801cf62: b480         	push	{r7}
 801cf64: b083         	sub	sp, #0xc
 801cf66: af00         	add	r7, sp, #0x0
 801cf68: 6078         	str	r0, [r7, #0x4]
; 	return LOG2(line);
 801cf6a: 687b         	ldr	r3, [r7, #0x4]
 801cf6c: 2b00         	cmp	r3, #0x0
 801cf6e: d007         	beq	0x801cf80 <ll_exti_line_to_linenum+0x1e> @ imm = #0xe
 801cf70: 687b         	ldr	r3, [r7, #0x4]
 801cf72: fab3 f383    	clz	r3, r3
 801cf76: b2db         	uxtb	r3, r3
 801cf78: f1c3 031f    	rsb.w	r3, r3, #0x1f
 801cf7c: b2db         	uxtb	r3, r3
 801cf7e: e000         	b	0x801cf82 <ll_exti_line_to_linenum+0x20> @ imm = #0x0
 801cf80: 23ff         	movs	r3, #0xff
; }
 801cf82: 4618         	mov	r0, r3
 801cf84: 370c         	adds	r7, #0xc
 801cf86: 46bd         	mov	sp, r7
 801cf88: f85d 7b04    	ldr	r7, [sp], #4
 801cf8c: 4770         	bx	lr

0801cf8e <stm32_gpio_intc_get_pin_irq_line>:
; {
 801cf8e: b580         	push	{r7, lr}
 801cf90: b082         	sub	sp, #0x8
 801cf92: af00         	add	r7, sp, #0x0
 801cf94: 6078         	str	r0, [r7, #0x4]
 801cf96: 460b         	mov	r3, r1
 801cf98: 70fb         	strb	r3, [r7, #0x3]
; 	return linenum_to_ll_exti_line(pin);
 801cf9a: 78fb         	ldrb	r3, [r7, #0x3]
 801cf9c: 4618         	mov	r0, r3
 801cf9e: f7ff ffd1    	bl	0x801cf44 <linenum_to_ll_exti_line> @ imm = #-0x5e
 801cfa2: 4603         	mov	r3, r0
; }
 801cfa4: 4618         	mov	r0, r3
 801cfa6: 3708         	adds	r7, #0x8
 801cfa8: 46bd         	mov	sp, r7
 801cfaa: bd80         	pop	{r7, pc}

0801cfac <stm32_gpio_intc_disable_line>:
; {
 801cfac: b580         	push	{r7, lr}
 801cfae: b082         	sub	sp, #0x8
 801cfb0: af00         	add	r7, sp, #0x0
 801cfb2: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_DisableIT_0_31(line);
 801cfb4: 6878         	ldr	r0, [r7, #0x4]
 801cfb6: f7ea f8bd    	bl	0x8007134 <LL_EXTI_DisableIT_0_31> @ imm = #-0x15e86
; }
 801cfba: bf00         	nop
 801cfbc: 3708         	adds	r7, #0x8
 801cfbe: 46bd         	mov	sp, r7
 801cfc0: bd80         	pop	{r7, pc}

0801cfc2 <stm32_exti_set_line_src_port>:
; {
 801cfc2: b580         	push	{r7, lr}
 801cfc4: b084         	sub	sp, #0x10
 801cfc6: af00         	add	r7, sp, #0x0
 801cfc8: 4603         	mov	r3, r0
 801cfca: 6039         	str	r1, [r7]
 801cfcc: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 801cfce: 79fb         	ldrb	r3, [r7, #0x7]
 801cfd0: 4618         	mov	r0, r3
 801cfd2: f7ff ff89    	bl	0x801cee8 <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0xee
 801cfd6: 60f8         	str	r0, [r7, #0xc]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 801cfd8: f44f 1180    	mov.w	r1, #0x100000
 801cfdc: 2000         	movs	r0, #0x0
 801cfde: f7ff ff6e    	bl	0x801cebe <z_stm32_hsem_lock> @ imm = #-0x124
; 	LL_SYSCFG_SetEXTISource(port, ll_line);
 801cfe2: 68f9         	ldr	r1, [r7, #0xc]
 801cfe4: 6838         	ldr	r0, [r7]
 801cfe6: f7ea f92b    	bl	0x8007240 <LL_SYSCFG_SetEXTISource> @ imm = #-0x15daa
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 801cfea: 2000         	movs	r0, #0x0
 801cfec: f7ff ff72    	bl	0x801ced4 <z_stm32_hsem_unlock> @ imm = #-0x11c
; }
 801cff0: bf00         	nop
 801cff2: 3710         	adds	r7, #0x10
 801cff4: 46bd         	mov	sp, r7
 801cff6: bd80         	pop	{r7, pc}

0801cff8 <stm32_exti_get_line_src_port>:
; {
 801cff8: b580         	push	{r7, lr}
 801cffa: b084         	sub	sp, #0x10
 801cffc: af00         	add	r7, sp, #0x0
 801cffe: 4603         	mov	r3, r0
 801d000: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 801d002: 79fb         	ldrb	r3, [r7, #0x7]
 801d004: 4618         	mov	r0, r3
 801d006: f7ff ff6f    	bl	0x801cee8 <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0x122
 801d00a: 60f8         	str	r0, [r7, #0xc]
; 	port = LL_SYSCFG_GetEXTISource(ll_line);
 801d00c: 68f8         	ldr	r0, [r7, #0xc]
 801d00e: f7ea f94d    	bl	0x80072ac <LL_SYSCFG_GetEXTISource> @ imm = #-0x15d66
 801d012: 60b8         	str	r0, [r7, #0x8]
; 	return port;
 801d014: 68bb         	ldr	r3, [r7, #0x8]
; }
 801d016: 4618         	mov	r0, r3
 801d018: 3710         	adds	r7, #0x10
 801d01a: 46bd         	mov	sp, r7
 801d01c: bd80         	pop	{r7, pc}

0801d01e <k_sem_init>:
; {
 801d01e: b580         	push	{r7, lr}
 801d020: b084         	sub	sp, #0x10
 801d022: af00         	add	r7, sp, #0x0
 801d024: 60f8         	str	r0, [r7, #0xc]
 801d026: 60b9         	str	r1, [r7, #0x8]
 801d028: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 801d02a: 687a         	ldr	r2, [r7, #0x4]
 801d02c: 68b9         	ldr	r1, [r7, #0x8]
 801d02e: 68f8         	ldr	r0, [r7, #0xc]
 801d030: f008 fc35    	bl	0x802589e <z_impl_k_sem_init> @ imm = #0x886a
 801d034: 4603         	mov	r3, r0
; }
 801d036: 4618         	mov	r0, r3
 801d038: 3710         	adds	r7, #0x10
 801d03a: 46bd         	mov	sp, r7
 801d03c: bd80         	pop	{r7, pc}

0801d03e <k_sem_take>:
; {
 801d03e: b580         	push	{r7, lr}
 801d040: b084         	sub	sp, #0x10
 801d042: af00         	add	r7, sp, #0x0
 801d044: 60f8         	str	r0, [r7, #0xc]
 801d046: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 801d04a: e9d7 2300    	ldrd	r2, r3, [r7]
 801d04e: 68f8         	ldr	r0, [r7, #0xc]
 801d050: f7f7 f884    	bl	0x801415c <z_impl_k_sem_take> @ imm = #-0x8ef8
 801d054: 4603         	mov	r3, r0
; }
 801d056: 4618         	mov	r0, r3
 801d058: 3710         	adds	r7, #0x10
 801d05a: 46bd         	mov	sp, r7
 801d05c: bd80         	pop	{r7, pc}

0801d05e <k_sem_give>:
; {
 801d05e: b580         	push	{r7, lr}
 801d060: b082         	sub	sp, #0x8
 801d062: af00         	add	r7, sp, #0x0
 801d064: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801d066: 6878         	ldr	r0, [r7, #0x4]
 801d068: f7f6 ffea    	bl	0x8014040 <z_impl_k_sem_give> @ imm = #-0x902c
; }
 801d06c: bf00         	nop
 801d06e: 3708         	adds	r7, #0x8
 801d070: 46bd         	mov	sp, r7
 801d072: bd80         	pop	{r7, pc}

0801d074 <z_impl_can_get_core_clock>:
; {
 801d074: b580         	push	{r7, lr}
 801d076: b084         	sub	sp, #0x10
 801d078: af00         	add	r7, sp, #0x0
 801d07a: 6078         	str	r0, [r7, #0x4]
 801d07c: 6039         	str	r1, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 801d07e: 687b         	ldr	r3, [r7, #0x4]
 801d080: 689b         	ldr	r3, [r3, #0x8]
 801d082: 60fb         	str	r3, [r7, #0xc]
; 	return api->get_core_clock(dev, rate);
 801d084: 68fb         	ldr	r3, [r7, #0xc]
 801d086: 6a9b         	ldr	r3, [r3, #0x28]
 801d088: 6839         	ldr	r1, [r7]
 801d08a: 6878         	ldr	r0, [r7, #0x4]
 801d08c: 4798         	blx	r3
 801d08e: 4603         	mov	r3, r0
; }
 801d090: 4618         	mov	r0, r3
 801d092: 3710         	adds	r7, #0x10
 801d094: 46bd         	mov	sp, r7
 801d096: bd80         	pop	{r7, pc}

0801d098 <z_impl_can_get_timing_min>:
; {
 801d098: b480         	push	{r7}
 801d09a: b085         	sub	sp, #0x14
 801d09c: af00         	add	r7, sp, #0x0
 801d09e: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 801d0a0: 687b         	ldr	r3, [r7, #0x4]
 801d0a2: 689b         	ldr	r3, [r3, #0x8]
 801d0a4: 60fb         	str	r3, [r7, #0xc]
; 	return &api->timing_min;
 801d0a6: 68fb         	ldr	r3, [r7, #0xc]
 801d0a8: 3330         	adds	r3, #0x30
; }
 801d0aa: 4618         	mov	r0, r3
 801d0ac: 3714         	adds	r7, #0x14
 801d0ae: 46bd         	mov	sp, r7
 801d0b0: f85d 7b04    	ldr	r7, [sp], #4
 801d0b4: 4770         	bx	lr

0801d0b6 <z_impl_can_get_timing_max>:
; {
 801d0b6: b480         	push	{r7}
 801d0b8: b085         	sub	sp, #0x14
 801d0ba: af00         	add	r7, sp, #0x0
 801d0bc: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 801d0be: 687b         	ldr	r3, [r7, #0x4]
 801d0c0: 689b         	ldr	r3, [r3, #0x8]
 801d0c2: 60fb         	str	r3, [r7, #0xc]
; 	return &api->timing_max;
 801d0c4: 68fb         	ldr	r3, [r7, #0xc]
 801d0c6: 333a         	adds	r3, #0x3a
; }
 801d0c8: 4618         	mov	r0, r3
 801d0ca: 3714         	adds	r7, #0x14
 801d0cc: 46bd         	mov	sp, r7
 801d0ce: f85d 7b04    	ldr	r7, [sp], #4
 801d0d2: 4770         	bx	lr

0801d0d4 <can_get_core_clock>:
; {
 801d0d4: b580         	push	{r7, lr}
 801d0d6: b082         	sub	sp, #0x8
 801d0d8: af00         	add	r7, sp, #0x0
 801d0da: 6078         	str	r0, [r7, #0x4]
 801d0dc: 6039         	str	r1, [r7]
; 	return z_impl_can_get_core_clock(dev, rate);
 801d0de: 6839         	ldr	r1, [r7]
 801d0e0: 6878         	ldr	r0, [r7, #0x4]
 801d0e2: f7ff ffc7    	bl	0x801d074 <z_impl_can_get_core_clock> @ imm = #-0x72
 801d0e6: 4603         	mov	r3, r0
; }
 801d0e8: 4618         	mov	r0, r3
 801d0ea: 3708         	adds	r7, #0x8
 801d0ec: 46bd         	mov	sp, r7
 801d0ee: bd80         	pop	{r7, pc}

0801d0f0 <can_get_timing_min>:
; {
 801d0f0: b580         	push	{r7, lr}
 801d0f2: b082         	sub	sp, #0x8
 801d0f4: af00         	add	r7, sp, #0x0
 801d0f6: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_get_timing_min(dev);
 801d0f8: 6878         	ldr	r0, [r7, #0x4]
 801d0fa: f7ff ffcd    	bl	0x801d098 <z_impl_can_get_timing_min> @ imm = #-0x66
 801d0fe: 4603         	mov	r3, r0
; }
 801d100: 4618         	mov	r0, r3
 801d102: 3708         	adds	r7, #0x8
 801d104: 46bd         	mov	sp, r7
 801d106: bd80         	pop	{r7, pc}

0801d108 <can_get_timing_max>:
; {
 801d108: b580         	push	{r7, lr}
 801d10a: b082         	sub	sp, #0x8
 801d10c: af00         	add	r7, sp, #0x0
 801d10e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_get_timing_max(dev);
 801d110: 6878         	ldr	r0, [r7, #0x4]
 801d112: f7ff ffd0    	bl	0x801d0b6 <z_impl_can_get_timing_max> @ imm = #-0x60
 801d116: 4603         	mov	r3, r0
; }
 801d118: 4618         	mov	r0, r3
 801d11a: 3708         	adds	r7, #0x8
 801d11c: 46bd         	mov	sp, r7
 801d11e: bd80         	pop	{r7, pc}

0801d120 <z_log_msg_runtime_create>:
; {
 801d120: b580         	push	{r7, lr}
 801d122: b08a         	sub	sp, #0x28
 801d124: af04         	add	r7, sp, #0x10
 801d126: 60b9         	str	r1, [r7, #0x8]
 801d128: 607b         	str	r3, [r7, #0x4]
 801d12a: 4603         	mov	r3, r0
 801d12c: 73fb         	strb	r3, [r7, #0xf]
 801d12e: 4613         	mov	r3, r2
 801d130: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801d132: f107 032c    	add.w	r3, r7, #0x2c
 801d136: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801d138: 7bba         	ldrb	r2, [r7, #0xe]
 801d13a: 7bf8         	ldrb	r0, [r7, #0xf]
 801d13c: 697b         	ldr	r3, [r7, #0x14]
 801d13e: 9303         	str	r3, [sp, #0xc]
 801d140: 6abb         	ldr	r3, [r7, #0x28]
 801d142: 9302         	str	r3, [sp, #0x8]
 801d144: 6a7b         	ldr	r3, [r7, #0x24]
 801d146: 9301         	str	r3, [sp, #0x4]
 801d148: 6a3b         	ldr	r3, [r7, #0x20]
 801d14a: 9300         	str	r3, [sp]
 801d14c: 687b         	ldr	r3, [r7, #0x4]
 801d14e: 68b9         	ldr	r1, [r7, #0x8]
 801d150: f7e7 fcf8    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x18610
; }
 801d154: bf00         	nop
 801d156: 3718         	adds	r7, #0x18
 801d158: 46bd         	mov	sp, r7
 801d15a: bd80         	pop	{r7, pc}

0801d15c <can_tx_default_cb>:
; {
 801d15c: b580         	push	{r7, lr}
 801d15e: b086         	sub	sp, #0x18
 801d160: af00         	add	r7, sp, #0x0
 801d162: 60f8         	str	r0, [r7, #0xc]
 801d164: 60b9         	str	r1, [r7, #0x8]
 801d166: 607a         	str	r2, [r7, #0x4]
; 	struct can_tx_default_cb_ctx *ctx = user_data;
 801d168: 687b         	ldr	r3, [r7, #0x4]
 801d16a: 617b         	str	r3, [r7, #0x14]
; 	ctx->status = error;
 801d16c: 697b         	ldr	r3, [r7, #0x14]
 801d16e: 68ba         	ldr	r2, [r7, #0x8]
 801d170: 611a         	str	r2, [r3, #0x10]
; 	k_sem_give(&ctx->done);
 801d172: 697b         	ldr	r3, [r7, #0x14]
 801d174: 4618         	mov	r0, r3
 801d176: f7ff ff72    	bl	0x801d05e <k_sem_give>  @ imm = #-0x11c
; }
 801d17a: bf00         	nop
 801d17c: 3718         	adds	r7, #0x18
 801d17e: 46bd         	mov	sp, r7
 801d180: bd80         	pop	{r7, pc}

0801d182 <check_timing_in_range>:
; {
 801d182: b480         	push	{r7}
 801d184: b085         	sub	sp, #0x14
 801d186: af00         	add	r7, sp, #0x0
 801d188: 60f8         	str	r0, [r7, #0xc]
 801d18a: 60b9         	str	r1, [r7, #0x8]
 801d18c: 607a         	str	r2, [r7, #0x4]
; 	if (!IN_RANGE(timing->sjw, min->sjw, max->sjw) ||
 801d18e: 68fb         	ldr	r3, [r7, #0xc]
 801d190: 881a         	ldrh	r2, [r3]
 801d192: 68bb         	ldr	r3, [r7, #0x8]
 801d194: 881b         	ldrh	r3, [r3]
 801d196: 429a         	cmp	r2, r3
 801d198: d335         	blo	0x801d206 <check_timing_in_range+0x84> @ imm = #0x6a
 801d19a: 68fb         	ldr	r3, [r7, #0xc]
 801d19c: 881a         	ldrh	r2, [r3]
 801d19e: 687b         	ldr	r3, [r7, #0x4]
 801d1a0: 881b         	ldrh	r3, [r3]
 801d1a2: 429a         	cmp	r2, r3
 801d1a4: d82f         	bhi	0x801d206 <check_timing_in_range+0x84> @ imm = #0x5e
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 801d1a6: 68fb         	ldr	r3, [r7, #0xc]
 801d1a8: 885a         	ldrh	r2, [r3, #0x2]
 801d1aa: 68bb         	ldr	r3, [r7, #0x8]
 801d1ac: 885b         	ldrh	r3, [r3, #0x2]
; 	if (!IN_RANGE(timing->sjw, min->sjw, max->sjw) ||
 801d1ae: 429a         	cmp	r2, r3
 801d1b0: d329         	blo	0x801d206 <check_timing_in_range+0x84> @ imm = #0x52
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 801d1b2: 68fb         	ldr	r3, [r7, #0xc]
 801d1b4: 885a         	ldrh	r2, [r3, #0x2]
 801d1b6: 687b         	ldr	r3, [r7, #0x4]
 801d1b8: 885b         	ldrh	r3, [r3, #0x2]
 801d1ba: 429a         	cmp	r2, r3
 801d1bc: d823         	bhi	0x801d206 <check_timing_in_range+0x84> @ imm = #0x46
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 801d1be: 68fb         	ldr	r3, [r7, #0xc]
 801d1c0: 889a         	ldrh	r2, [r3, #0x4]
 801d1c2: 68bb         	ldr	r3, [r7, #0x8]
 801d1c4: 889b         	ldrh	r3, [r3, #0x4]
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 801d1c6: 429a         	cmp	r2, r3
 801d1c8: d31d         	blo	0x801d206 <check_timing_in_range+0x84> @ imm = #0x3a
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 801d1ca: 68fb         	ldr	r3, [r7, #0xc]
 801d1cc: 889a         	ldrh	r2, [r3, #0x4]
 801d1ce: 687b         	ldr	r3, [r7, #0x4]
 801d1d0: 889b         	ldrh	r3, [r3, #0x4]
 801d1d2: 429a         	cmp	r2, r3
 801d1d4: d817         	bhi	0x801d206 <check_timing_in_range+0x84> @ imm = #0x2e
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 801d1d6: 68fb         	ldr	r3, [r7, #0xc]
 801d1d8: 88da         	ldrh	r2, [r3, #0x6]
 801d1da: 68bb         	ldr	r3, [r7, #0x8]
 801d1dc: 88db         	ldrh	r3, [r3, #0x6]
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 801d1de: 429a         	cmp	r2, r3
 801d1e0: d311         	blo	0x801d206 <check_timing_in_range+0x84> @ imm = #0x22
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 801d1e2: 68fb         	ldr	r3, [r7, #0xc]
 801d1e4: 88da         	ldrh	r2, [r3, #0x6]
 801d1e6: 687b         	ldr	r3, [r7, #0x4]
 801d1e8: 88db         	ldrh	r3, [r3, #0x6]
 801d1ea: 429a         	cmp	r2, r3
 801d1ec: d80b         	bhi	0x801d206 <check_timing_in_range+0x84> @ imm = #0x16
; 	    !IN_RANGE(timing->prescaler, min->prescaler, max->prescaler)) {
 801d1ee: 68fb         	ldr	r3, [r7, #0xc]
 801d1f0: 891a         	ldrh	r2, [r3, #0x8]
 801d1f2: 68bb         	ldr	r3, [r7, #0x8]
 801d1f4: 891b         	ldrh	r3, [r3, #0x8]
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 801d1f6: 429a         	cmp	r2, r3
 801d1f8: d305         	blo	0x801d206 <check_timing_in_range+0x84> @ imm = #0xa
; 	    !IN_RANGE(timing->prescaler, min->prescaler, max->prescaler)) {
 801d1fa: 68fb         	ldr	r3, [r7, #0xc]
 801d1fc: 891a         	ldrh	r2, [r3, #0x8]
 801d1fe: 687b         	ldr	r3, [r7, #0x4]
 801d200: 891b         	ldrh	r3, [r3, #0x8]
 801d202: 429a         	cmp	r2, r3
 801d204: d902         	bls	0x801d20c <check_timing_in_range+0x8a> @ imm = #0x4
; 		return -ENOTSUP;
 801d206: f06f 0385    	mvn	r3, #0x85
 801d20a: e00f         	b	0x801d22c <check_timing_in_range+0xaa> @ imm = #0x1e
; 	if ((timing->sjw > timing->phase_seg1) || (timing->sjw > timing->phase_seg2)) {
 801d20c: 68fb         	ldr	r3, [r7, #0xc]
 801d20e: 881a         	ldrh	r2, [r3]
 801d210: 68fb         	ldr	r3, [r7, #0xc]
 801d212: 889b         	ldrh	r3, [r3, #0x4]
 801d214: 429a         	cmp	r2, r3
 801d216: d805         	bhi	0x801d224 <check_timing_in_range+0xa2> @ imm = #0xa
 801d218: 68fb         	ldr	r3, [r7, #0xc]
 801d21a: 881a         	ldrh	r2, [r3]
 801d21c: 68fb         	ldr	r3, [r7, #0xc]
 801d21e: 88db         	ldrh	r3, [r3, #0x6]
 801d220: 429a         	cmp	r2, r3
 801d222: d902         	bls	0x801d22a <check_timing_in_range+0xa8> @ imm = #0x4
; 		return -ENOTSUP;
 801d224: f06f 0385    	mvn	r3, #0x85
 801d228: e000         	b	0x801d22c <check_timing_in_range+0xaa> @ imm = #0x0
; 	return 0;
 801d22a: 2300         	movs	r3, #0x0
; }
 801d22c: 4618         	mov	r0, r3
 801d22e: 3714         	adds	r7, #0x14
 801d230: 46bd         	mov	sp, r7
 801d232: f85d 7b04    	ldr	r7, [sp], #4
 801d236: 4770         	bx	lr

0801d238 <z_impl_can_set_timing>:
; {
 801d238: b580         	push	{r7, lr}
 801d23a: b086         	sub	sp, #0x18
 801d23c: af00         	add	r7, sp, #0x0
 801d23e: 6078         	str	r0, [r7, #0x4]
 801d240: 6039         	str	r1, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 801d242: 687b         	ldr	r3, [r7, #0x4]
 801d244: 689b         	ldr	r3, [r3, #0x8]
 801d246: 617b         	str	r3, [r7, #0x14]
; 	const struct can_timing *min = can_get_timing_min(dev);
 801d248: 6878         	ldr	r0, [r7, #0x4]
 801d24a: f7ff ff51    	bl	0x801d0f0 <can_get_timing_min> @ imm = #-0x15e
 801d24e: 6138         	str	r0, [r7, #0x10]
; 	const struct can_timing *max = can_get_timing_max(dev);
 801d250: 6878         	ldr	r0, [r7, #0x4]
 801d252: f7ff ff59    	bl	0x801d108 <can_get_timing_max> @ imm = #-0x14e
 801d256: 60f8         	str	r0, [r7, #0xc]
; 	err = check_timing_in_range(timing, min, max);
 801d258: 68fa         	ldr	r2, [r7, #0xc]
 801d25a: 6939         	ldr	r1, [r7, #0x10]
 801d25c: 6838         	ldr	r0, [r7]
 801d25e: f7ff ff90    	bl	0x801d182 <check_timing_in_range> @ imm = #-0xe0
 801d262: 60b8         	str	r0, [r7, #0x8]
; 	if (err != 0) {
 801d264: 68bb         	ldr	r3, [r7, #0x8]
 801d266: 2b00         	cmp	r3, #0x0
 801d268: d001         	beq	0x801d26e <z_impl_can_set_timing+0x36> @ imm = #0x2
; 		return err;
 801d26a: 68bb         	ldr	r3, [r7, #0x8]
 801d26c: e005         	b	0x801d27a <z_impl_can_set_timing+0x42> @ imm = #0xa
; 	return api->set_timing(dev, timing);
 801d26e: 697b         	ldr	r3, [r7, #0x14]
 801d270: 691b         	ldr	r3, [r3, #0x10]
 801d272: 6839         	ldr	r1, [r7]
 801d274: 6878         	ldr	r0, [r7, #0x4]
 801d276: 4798         	blx	r3
 801d278: 4603         	mov	r3, r0
; }
 801d27a: 4618         	mov	r0, r3
 801d27c: 3718         	adds	r7, #0x18
 801d27e: 46bd         	mov	sp, r7
 801d280: bd80         	pop	{r7, pc}

0801d282 <device_is_ready>:
; {
 801d282: b580         	push	{r7, lr}
 801d284: b082         	sub	sp, #0x8
 801d286: af00         	add	r7, sp, #0x0
 801d288: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801d28a: 6878         	ldr	r0, [r7, #0x4]
 801d28c: f007 f949    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x7292
 801d290: 4603         	mov	r3, r0
; }
 801d292: 4618         	mov	r0, r3
 801d294: 3708         	adds	r7, #0x8
 801d296: 46bd         	mov	sp, r7
 801d298: bd80         	pop	{r7, pc}

0801d29a <arch_k_cycle_get_32>:
; {
 801d29a: b580         	push	{r7, lr}
 801d29c: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 801d29e: f7f2 f907    	bl	0x800f4b0 <sys_clock_cycle_get_32> @ imm = #-0xddf2
 801d2a2: 4603         	mov	r3, r0
; }
 801d2a4: 4618         	mov	r0, r3
 801d2a6: bd80         	pop	{r7, pc}

0801d2a8 <k_cycle_get_32>:
; {
 801d2a8: b580         	push	{r7, lr}
 801d2aa: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 801d2ac: f7ff fff5    	bl	0x801d29a <arch_k_cycle_get_32> @ imm = #-0x16
 801d2b0: 4603         	mov	r3, r0
; }
 801d2b2: 4618         	mov	r0, r3
 801d2b4: bd80         	pop	{r7, pc}

0801d2b6 <k_mutex_init>:
; {
 801d2b6: b580         	push	{r7, lr}
 801d2b8: b082         	sub	sp, #0x8
 801d2ba: af00         	add	r7, sp, #0x0
 801d2bc: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_init(mutex);
 801d2be: 6878         	ldr	r0, [r7, #0x4]
 801d2c0: f007 ff53    	bl	0x802516a <z_impl_k_mutex_init> @ imm = #0x7ea6
 801d2c4: 4603         	mov	r3, r0
; }
 801d2c6: 4618         	mov	r0, r3
 801d2c8: 3708         	adds	r7, #0x8
 801d2ca: 46bd         	mov	sp, r7
 801d2cc: bd80         	pop	{r7, pc}

0801d2ce <k_mutex_lock>:
; {
 801d2ce: b580         	push	{r7, lr}
 801d2d0: b084         	sub	sp, #0x10
 801d2d2: af00         	add	r7, sp, #0x0
 801d2d4: 60f8         	str	r0, [r7, #0xc]
 801d2d6: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_mutex_lock(mutex, timeout);
 801d2da: e9d7 2300    	ldrd	r2, r3, [r7]
 801d2de: 68f8         	ldr	r0, [r7, #0xc]
 801d2e0: f7f6 fae4    	bl	0x80138ac <z_impl_k_mutex_lock> @ imm = #-0x9a38
 801d2e4: 4603         	mov	r3, r0
; }
 801d2e6: 4618         	mov	r0, r3
 801d2e8: 3710         	adds	r7, #0x10
 801d2ea: 46bd         	mov	sp, r7
 801d2ec: bd80         	pop	{r7, pc}

0801d2ee <k_mutex_unlock>:
; {
 801d2ee: b580         	push	{r7, lr}
 801d2f0: b082         	sub	sp, #0x8
 801d2f2: af00         	add	r7, sp, #0x0
 801d2f4: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_unlock(mutex);
 801d2f6: 6878         	ldr	r0, [r7, #0x4]
 801d2f8: f7f6 fd22    	bl	0x8013d40 <z_impl_k_mutex_unlock> @ imm = #-0x95bc
 801d2fc: 4603         	mov	r3, r0
; }
 801d2fe: 4618         	mov	r0, r3
 801d300: 3708         	adds	r7, #0x8
 801d302: 46bd         	mov	sp, r7
 801d304: bd80         	pop	{r7, pc}

0801d306 <k_sem_init>:
; {
 801d306: b580         	push	{r7, lr}
 801d308: b084         	sub	sp, #0x10
 801d30a: af00         	add	r7, sp, #0x0
 801d30c: 60f8         	str	r0, [r7, #0xc]
 801d30e: 60b9         	str	r1, [r7, #0x8]
 801d310: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 801d312: 687a         	ldr	r2, [r7, #0x4]
 801d314: 68b9         	ldr	r1, [r7, #0x8]
 801d316: 68f8         	ldr	r0, [r7, #0xc]
 801d318: f008 fac1    	bl	0x802589e <z_impl_k_sem_init> @ imm = #0x8582
 801d31c: 4603         	mov	r3, r0
; }
 801d31e: 4618         	mov	r0, r3
 801d320: 3710         	adds	r7, #0x10
 801d322: 46bd         	mov	sp, r7
 801d324: bd80         	pop	{r7, pc}

0801d326 <k_sem_take>:
; {
 801d326: b580         	push	{r7, lr}
 801d328: b084         	sub	sp, #0x10
 801d32a: af00         	add	r7, sp, #0x0
 801d32c: 60f8         	str	r0, [r7, #0xc]
 801d32e: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 801d332: e9d7 2300    	ldrd	r2, r3, [r7]
 801d336: 68f8         	ldr	r0, [r7, #0xc]
 801d338: f7f6 ff10    	bl	0x801415c <z_impl_k_sem_take> @ imm = #-0x91e0
 801d33c: 4603         	mov	r3, r0
; }
 801d33e: 4618         	mov	r0, r3
 801d340: 3710         	adds	r7, #0x10
 801d342: 46bd         	mov	sp, r7
 801d344: bd80         	pop	{r7, pc}

0801d346 <k_sem_give>:
; {
 801d346: b580         	push	{r7, lr}
 801d348: b082         	sub	sp, #0x8
 801d34a: af00         	add	r7, sp, #0x0
 801d34c: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801d34e: 6878         	ldr	r0, [r7, #0x4]
 801d350: f7f6 fe76    	bl	0x8014040 <z_impl_k_sem_give> @ imm = #-0x9314
; }
 801d354: bf00         	nop
 801d356: 3708         	adds	r7, #0x8
 801d358: 46bd         	mov	sp, r7
 801d35a: bd80         	pop	{r7, pc}

0801d35c <can_calc_timing>:
; {
 801d35c: b580         	push	{r7, lr}
 801d35e: b084         	sub	sp, #0x10
 801d360: af00         	add	r7, sp, #0x0
 801d362: 60f8         	str	r0, [r7, #0xc]
 801d364: 60b9         	str	r1, [r7, #0x8]
 801d366: 607a         	str	r2, [r7, #0x4]
 801d368: 807b         	strh	r3, [r7, #0x2]
; 	return z_impl_can_calc_timing(dev, res, bitrate, sample_pnt);
 801d36a: 887b         	ldrh	r3, [r7, #0x2]
 801d36c: 687a         	ldr	r2, [r7, #0x4]
 801d36e: 68b9         	ldr	r1, [r7, #0x8]
 801d370: 68f8         	ldr	r0, [r7, #0xc]
 801d372: f7ea fc81    	bl	0x8007c78 <z_impl_can_calc_timing> @ imm = #-0x156fe
 801d376: 4603         	mov	r3, r0
; }
 801d378: 4618         	mov	r0, r3
 801d37a: 3710         	adds	r7, #0x10
 801d37c: 46bd         	mov	sp, r7
 801d37e: bd80         	pop	{r7, pc}

0801d380 <can_set_timing>:
; {
 801d380: b580         	push	{r7, lr}
 801d382: b082         	sub	sp, #0x8
 801d384: af00         	add	r7, sp, #0x0
 801d386: 6078         	str	r0, [r7, #0x4]
 801d388: 6039         	str	r1, [r7]
; 	return z_impl_can_set_timing(dev, timing);
 801d38a: 6839         	ldr	r1, [r7]
 801d38c: 6878         	ldr	r0, [r7, #0x4]
 801d38e: f7ff ff53    	bl	0x801d238 <z_impl_can_set_timing> @ imm = #-0x15a
 801d392: 4603         	mov	r3, r0
; }
 801d394: 4618         	mov	r0, r3
 801d396: 3708         	adds	r7, #0x8
 801d398: 46bd         	mov	sp, r7
 801d39a: bd80         	pop	{r7, pc}

0801d39c <can_transceiver_enable>:
; {
 801d39c: b580         	push	{r7, lr}
 801d39e: b082         	sub	sp, #0x8
 801d3a0: af00         	add	r7, sp, #0x0
 801d3a2: 6078         	str	r0, [r7, #0x4]
 801d3a4: 6039         	str	r1, [r7]
; 	return DEVICE_API_GET(can_transceiver, dev)->enable(dev, mode);
 801d3a6: 687b         	ldr	r3, [r7, #0x4]
 801d3a8: 689b         	ldr	r3, [r3, #0x8]
 801d3aa: 681b         	ldr	r3, [r3]
 801d3ac: 6839         	ldr	r1, [r7]
 801d3ae: 6878         	ldr	r0, [r7, #0x4]
 801d3b0: 4798         	blx	r3
 801d3b2: 4603         	mov	r3, r0
; }
 801d3b4: 4618         	mov	r0, r3
 801d3b6: 3708         	adds	r7, #0x8
 801d3b8: 46bd         	mov	sp, r7
 801d3ba: bd80         	pop	{r7, pc}

0801d3bc <can_transceiver_disable>:
; {
 801d3bc: b580         	push	{r7, lr}
 801d3be: b082         	sub	sp, #0x8
 801d3c0: af00         	add	r7, sp, #0x0
 801d3c2: 6078         	str	r0, [r7, #0x4]
; 	return DEVICE_API_GET(can_transceiver, dev)->disable(dev);
 801d3c4: 687b         	ldr	r3, [r7, #0x4]
 801d3c6: 689b         	ldr	r3, [r3, #0x8]
 801d3c8: 685b         	ldr	r3, [r3, #0x4]
 801d3ca: 6878         	ldr	r0, [r7, #0x4]
 801d3cc: 4798         	blx	r3
 801d3ce: 4603         	mov	r3, r0
; }
 801d3d0: 4618         	mov	r0, r3
 801d3d2: 3708         	adds	r7, #0x8
 801d3d4: 46bd         	mov	sp, r7
 801d3d6: bd80         	pop	{r7, pc}

0801d3d8 <clock_control_on>:
; {
 801d3d8: b580         	push	{r7, lr}
 801d3da: b084         	sub	sp, #0x10
 801d3dc: af00         	add	r7, sp, #0x0
 801d3de: 6078         	str	r0, [r7, #0x4]
 801d3e0: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801d3e2: 687b         	ldr	r3, [r7, #0x4]
 801d3e4: 689b         	ldr	r3, [r3, #0x8]
 801d3e6: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801d3e8: 68fb         	ldr	r3, [r7, #0xc]
 801d3ea: 681b         	ldr	r3, [r3]
 801d3ec: 6839         	ldr	r1, [r7]
 801d3ee: 6878         	ldr	r0, [r7, #0x4]
 801d3f0: 4798         	blx	r3
 801d3f2: 4603         	mov	r3, r0
; }
 801d3f4: 4618         	mov	r0, r3
 801d3f6: 3710         	adds	r7, #0x10
 801d3f8: 46bd         	mov	sp, r7
 801d3fa: bd80         	pop	{r7, pc}

0801d3fc <clock_control_get_rate>:
; {
 801d3fc: b580         	push	{r7, lr}
 801d3fe: b086         	sub	sp, #0x18
 801d400: af00         	add	r7, sp, #0x0
 801d402: 60f8         	str	r0, [r7, #0xc]
 801d404: 60b9         	str	r1, [r7, #0x8]
 801d406: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 801d408: 68fb         	ldr	r3, [r7, #0xc]
 801d40a: 689b         	ldr	r3, [r3, #0x8]
 801d40c: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 801d40e: 697b         	ldr	r3, [r7, #0x14]
 801d410: 68db         	ldr	r3, [r3, #0xc]
 801d412: 2b00         	cmp	r3, #0x0
 801d414: d102         	bne	0x801d41c <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 801d416: f06f 0357    	mvn	r3, #0x57
 801d41a: e006         	b	0x801d42a <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 801d41c: 697b         	ldr	r3, [r7, #0x14]
 801d41e: 68db         	ldr	r3, [r3, #0xc]
 801d420: 687a         	ldr	r2, [r7, #0x4]
 801d422: 68b9         	ldr	r1, [r7, #0x8]
 801d424: 68f8         	ldr	r0, [r7, #0xc]
 801d426: 4798         	blx	r3
 801d428: 4603         	mov	r3, r0
; }
 801d42a: 4618         	mov	r0, r3
 801d42c: 3718         	adds	r7, #0x18
 801d42e: 46bd         	mov	sp, r7
 801d430: bd80         	pop	{r7, pc}

0801d432 <pinctrl_apply_state_direct>:
; {
 801d432: b580         	push	{r7, lr}
 801d434: b084         	sub	sp, #0x10
 801d436: af00         	add	r7, sp, #0x0
 801d438: 6078         	str	r0, [r7, #0x4]
 801d43a: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 801d43c: 2300         	movs	r3, #0x0
 801d43e: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 801d440: 683b         	ldr	r3, [r7]
 801d442: 6818         	ldr	r0, [r3]
 801d444: 683b         	ldr	r3, [r7]
 801d446: 791b         	ldrb	r3, [r3, #0x4]
 801d448: 68fa         	ldr	r2, [r7, #0xc]
 801d44a: 4619         	mov	r1, r3
 801d44c: f002 fcaf    	bl	0x801fdae <pinctrl_configure_pins> @ imm = #0x295e
 801d450: 4603         	mov	r3, r0
; }
 801d452: 4618         	mov	r0, r3
 801d454: 3710         	adds	r7, #0x10
 801d456: 46bd         	mov	sp, r7
 801d458: bd80         	pop	{r7, pc}

0801d45a <pinctrl_apply_state>:
; {
 801d45a: b580         	push	{r7, lr}
 801d45c: b084         	sub	sp, #0x10
 801d45e: af00         	add	r7, sp, #0x0
 801d460: 6078         	str	r0, [r7, #0x4]
 801d462: 460b         	mov	r3, r1
 801d464: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 801d466: f107 0208    	add.w	r2, r7, #0x8
 801d46a: 78fb         	ldrb	r3, [r7, #0x3]
 801d46c: 4619         	mov	r1, r3
 801d46e: 6878         	ldr	r0, [r7, #0x4]
 801d470: f002 fc65    	bl	0x801fd3e <pinctrl_lookup_state> @ imm = #0x28ca
 801d474: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 801d476: 68fb         	ldr	r3, [r7, #0xc]
 801d478: 2b00         	cmp	r3, #0x0
 801d47a: da01         	bge	0x801d480 <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 801d47c: 68fb         	ldr	r3, [r7, #0xc]
 801d47e: e005         	b	0x801d48c <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 801d480: 68bb         	ldr	r3, [r7, #0x8]
 801d482: 4619         	mov	r1, r3
 801d484: 6878         	ldr	r0, [r7, #0x4]
 801d486: f7ff ffd4    	bl	0x801d432 <pinctrl_apply_state_direct> @ imm = #-0x58
 801d48a: 4603         	mov	r3, r0
; }
 801d48c: 4618         	mov	r0, r3
 801d48e: 3710         	adds	r7, #0x10
 801d490: 46bd         	mov	sp, r7
 801d492: bd80         	pop	{r7, pc}

0801d494 <z_log_msg_runtime_create>:
; {
 801d494: b580         	push	{r7, lr}
 801d496: b08a         	sub	sp, #0x28
 801d498: af04         	add	r7, sp, #0x10
 801d49a: 60b9         	str	r1, [r7, #0x8]
 801d49c: 607b         	str	r3, [r7, #0x4]
 801d49e: 4603         	mov	r3, r0
 801d4a0: 73fb         	strb	r3, [r7, #0xf]
 801d4a2: 4613         	mov	r3, r2
 801d4a4: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801d4a6: f107 032c    	add.w	r3, r7, #0x2c
 801d4aa: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801d4ac: 7bba         	ldrb	r2, [r7, #0xe]
 801d4ae: 7bf8         	ldrb	r0, [r7, #0xf]
 801d4b0: 697b         	ldr	r3, [r7, #0x14]
 801d4b2: 9303         	str	r3, [sp, #0xc]
 801d4b4: 6abb         	ldr	r3, [r7, #0x28]
 801d4b6: 9302         	str	r3, [sp, #0x8]
 801d4b8: 6a7b         	ldr	r3, [r7, #0x24]
 801d4ba: 9301         	str	r3, [sp, #0x4]
 801d4bc: 6a3b         	ldr	r3, [r7, #0x20]
 801d4be: 9300         	str	r3, [sp]
 801d4c0: 687b         	ldr	r3, [r7, #0x4]
 801d4c2: 68b9         	ldr	r1, [r7, #0x8]
 801d4c4: f7e7 fb3e    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x18984
; }
 801d4c8: bf00         	nop
 801d4ca: 3718         	adds	r7, #0x18
 801d4cc: 46bd         	mov	sp, r7
 801d4ce: bd80         	pop	{r7, pc}

0801d4d0 <can_stm32_signal_tx_complete>:
; {
 801d4d0: b580         	push	{r7, lr}
 801d4d2: b086         	sub	sp, #0x18
 801d4d4: af00         	add	r7, sp, #0x0
 801d4d6: 60f8         	str	r0, [r7, #0xc]
 801d4d8: 60b9         	str	r1, [r7, #0x8]
 801d4da: 607a         	str	r2, [r7, #0x4]
; 	can_tx_callback_t callback = mb->tx_callback;
 801d4dc: 68bb         	ldr	r3, [r7, #0x8]
 801d4de: 681b         	ldr	r3, [r3]
 801d4e0: 617b         	str	r3, [r7, #0x14]
; 	if (callback != NULL) {
 801d4e2: 697b         	ldr	r3, [r7, #0x14]
 801d4e4: 2b00         	cmp	r3, #0x0
 801d4e6: d008         	beq	0x801d4fa <can_stm32_signal_tx_complete+0x2a> @ imm = #0x10
; 		callback(dev, status, mb->callback_arg);
 801d4e8: 68bb         	ldr	r3, [r7, #0x8]
 801d4ea: 685a         	ldr	r2, [r3, #0x4]
 801d4ec: 697b         	ldr	r3, [r7, #0x14]
 801d4ee: 6879         	ldr	r1, [r7, #0x4]
 801d4f0: 68f8         	ldr	r0, [r7, #0xc]
 801d4f2: 4798         	blx	r3
; 		mb->tx_callback = NULL;
 801d4f4: 68bb         	ldr	r3, [r7, #0x8]
 801d4f6: 2200         	movs	r2, #0x0
 801d4f8: 601a         	str	r2, [r3]
; }
 801d4fa: bf00         	nop
 801d4fc: 3718         	adds	r7, #0x18
 801d4fe: 46bd         	mov	sp, r7
 801d500: bd80         	pop	{r7, pc}

0801d502 <can_stm32_rx_fifo_pop>:
; {
 801d502: b580         	push	{r7, lr}
 801d504: b082         	sub	sp, #0x8
 801d506: af00         	add	r7, sp, #0x0
 801d508: 6078         	str	r0, [r7, #0x4]
 801d50a: 6039         	str	r1, [r7]
; 	memset(frame, 0, sizeof(*frame));
 801d50c: 2210         	movs	r2, #0x10
 801d50e: 2100         	movs	r1, #0x0
 801d510: 6838         	ldr	r0, [r7]
 801d512: f009 fff9    	bl	0x8027508 <memset>      @ imm = #0x9ff2
; 	if (mbox->RIR & CAN_RI0R_IDE) {
 801d516: 687b         	ldr	r3, [r7, #0x4]
 801d518: 681b         	ldr	r3, [r3]
 801d51a: f003 0304    	and	r3, r3, #0x4
 801d51e: 2b00         	cmp	r3, #0x0
 801d520: d00c         	beq	0x801d53c <can_stm32_rx_fifo_pop+0x3a> @ imm = #0x18
; 		frame->id = mbox->RIR >> CAN_RI0R_EXID_Pos;
 801d522: 687b         	ldr	r3, [r7, #0x4]
 801d524: 681b         	ldr	r3, [r3]
 801d526: 08da         	lsrs	r2, r3, #0x3
 801d528: 683b         	ldr	r3, [r7]
 801d52a: 601a         	str	r2, [r3]
; 		frame->flags |= CAN_FRAME_IDE;
 801d52c: 683b         	ldr	r3, [r7]
 801d52e: 795b         	ldrb	r3, [r3, #0x5]
 801d530: f043 0301    	orr	r3, r3, #0x1
 801d534: b2da         	uxtb	r2, r3
 801d536: 683b         	ldr	r3, [r7]
 801d538: 715a         	strb	r2, [r3, #0x5]
 801d53a: e004         	b	0x801d546 <can_stm32_rx_fifo_pop+0x44> @ imm = #0x8
; 		frame->id = mbox->RIR >> CAN_RI0R_STID_Pos;
 801d53c: 687b         	ldr	r3, [r7, #0x4]
 801d53e: 681b         	ldr	r3, [r3]
 801d540: 0d5a         	lsrs	r2, r3, #0x15
 801d542: 683b         	ldr	r3, [r7]
 801d544: 601a         	str	r2, [r3]
; 	if ((mbox->RIR & CAN_RI0R_RTR) != 0) {
 801d546: 687b         	ldr	r3, [r7, #0x4]
 801d548: 681b         	ldr	r3, [r3]
 801d54a: f003 0302    	and	r3, r3, #0x2
 801d54e: 2b00         	cmp	r3, #0x0
 801d550: d007         	beq	0x801d562 <can_stm32_rx_fifo_pop+0x60> @ imm = #0xe
; 		frame->flags |= CAN_FRAME_RTR;
 801d552: 683b         	ldr	r3, [r7]
 801d554: 795b         	ldrb	r3, [r3, #0x5]
 801d556: f043 0302    	orr	r3, r3, #0x2
 801d55a: b2da         	uxtb	r2, r3
 801d55c: 683b         	ldr	r3, [r7]
 801d55e: 715a         	strb	r2, [r3, #0x5]
 801d560: e007         	b	0x801d572 <can_stm32_rx_fifo_pop+0x70> @ imm = #0xe
; 		frame->data_32[0] = mbox->RDLR;
 801d562: 687b         	ldr	r3, [r7, #0x4]
 801d564: 689a         	ldr	r2, [r3, #0x8]
 801d566: 683b         	ldr	r3, [r7]
 801d568: 609a         	str	r2, [r3, #0x8]
; 		frame->data_32[1] = mbox->RDHR;
 801d56a: 687b         	ldr	r3, [r7, #0x4]
 801d56c: 68da         	ldr	r2, [r3, #0xc]
 801d56e: 683b         	ldr	r3, [r7]
 801d570: 60da         	str	r2, [r3, #0xc]
; 	frame->dlc = mbox->RDTR & (CAN_RDT0R_DLC >> CAN_RDT0R_DLC_Pos);
 801d572: 687b         	ldr	r3, [r7, #0x4]
 801d574: 685b         	ldr	r3, [r3, #0x4]
 801d576: b2db         	uxtb	r3, r3
 801d578: f003 030f    	and	r3, r3, #0xf
 801d57c: b2da         	uxtb	r2, r3
 801d57e: 683b         	ldr	r3, [r7]
 801d580: 711a         	strb	r2, [r3, #0x4]
; }
 801d582: bf00         	nop
 801d584: 3708         	adds	r7, #0x8
 801d586: 46bd         	mov	sp, r7
 801d588: bd80         	pop	{r7, pc}

0801d58a <can_stm32_get_state>:
; {
 801d58a: b480         	push	{r7}
 801d58c: b089         	sub	sp, #0x24
 801d58e: af00         	add	r7, sp, #0x0
 801d590: 60f8         	str	r0, [r7, #0xc]
 801d592: 60b9         	str	r1, [r7, #0x8]
 801d594: 607a         	str	r2, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 801d596: 68fb         	ldr	r3, [r7, #0xc]
 801d598: 685b         	ldr	r3, [r3, #0x4]
 801d59a: 61fb         	str	r3, [r7, #0x1c]
; 	struct can_stm32_data *data = dev->data;
 801d59c: 68fb         	ldr	r3, [r7, #0xc]
 801d59e: 691b         	ldr	r3, [r3, #0x10]
 801d5a0: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 801d5a2: 69fb         	ldr	r3, [r7, #0x1c]
 801d5a4: 695b         	ldr	r3, [r3, #0x14]
 801d5a6: 617b         	str	r3, [r7, #0x14]
; 	if (state != NULL) {
 801d5a8: 68bb         	ldr	r3, [r7, #0x8]
 801d5aa: 2b00         	cmp	r3, #0x0
 801d5ac: d02b         	beq	0x801d606 <can_stm32_get_state+0x7c> @ imm = #0x56
; 		if (!data->common.started) {
 801d5ae: 69bb         	ldr	r3, [r7, #0x18]
 801d5b0: 791b         	ldrb	r3, [r3, #0x4]
 801d5b2: f083 0301    	eor	r3, r3, #0x1
 801d5b6: b2db         	uxtb	r3, r3
 801d5b8: 2b00         	cmp	r3, #0x0
 801d5ba: d003         	beq	0x801d5c4 <can_stm32_get_state+0x3a> @ imm = #0x6
; 			*state = CAN_STATE_STOPPED;
 801d5bc: 68bb         	ldr	r3, [r7, #0x8]
 801d5be: 2204         	movs	r2, #0x4
 801d5c0: 701a         	strb	r2, [r3]
 801d5c2: e020         	b	0x801d606 <can_stm32_get_state+0x7c> @ imm = #0x40
; 		} else if (can->ESR & CAN_ESR_BOFF) {
 801d5c4: 697b         	ldr	r3, [r7, #0x14]
 801d5c6: 699b         	ldr	r3, [r3, #0x18]
 801d5c8: f003 0304    	and	r3, r3, #0x4
 801d5cc: 2b00         	cmp	r3, #0x0
 801d5ce: d003         	beq	0x801d5d8 <can_stm32_get_state+0x4e> @ imm = #0x6
; 			*state = CAN_STATE_BUS_OFF;
 801d5d0: 68bb         	ldr	r3, [r7, #0x8]
 801d5d2: 2203         	movs	r2, #0x3
 801d5d4: 701a         	strb	r2, [r3]
 801d5d6: e016         	b	0x801d606 <can_stm32_get_state+0x7c> @ imm = #0x2c
; 		} else if (can->ESR & CAN_ESR_EPVF) {
 801d5d8: 697b         	ldr	r3, [r7, #0x14]
 801d5da: 699b         	ldr	r3, [r3, #0x18]
 801d5dc: f003 0302    	and	r3, r3, #0x2
 801d5e0: 2b00         	cmp	r3, #0x0
 801d5e2: d003         	beq	0x801d5ec <can_stm32_get_state+0x62> @ imm = #0x6
; 			*state = CAN_STATE_ERROR_PASSIVE;
 801d5e4: 68bb         	ldr	r3, [r7, #0x8]
 801d5e6: 2202         	movs	r2, #0x2
 801d5e8: 701a         	strb	r2, [r3]
 801d5ea: e00c         	b	0x801d606 <can_stm32_get_state+0x7c> @ imm = #0x18
; 		} else if (can->ESR & CAN_ESR_EWGF) {
 801d5ec: 697b         	ldr	r3, [r7, #0x14]
 801d5ee: 699b         	ldr	r3, [r3, #0x18]
 801d5f0: f003 0301    	and	r3, r3, #0x1
 801d5f4: 2b00         	cmp	r3, #0x0
 801d5f6: d003         	beq	0x801d600 <can_stm32_get_state+0x76> @ imm = #0x6
; 			*state = CAN_STATE_ERROR_WARNING;
 801d5f8: 68bb         	ldr	r3, [r7, #0x8]
 801d5fa: 2201         	movs	r2, #0x1
 801d5fc: 701a         	strb	r2, [r3]
 801d5fe: e002         	b	0x801d606 <can_stm32_get_state+0x7c> @ imm = #0x4
; 			*state = CAN_STATE_ERROR_ACTIVE;
 801d600: 68bb         	ldr	r3, [r7, #0x8]
 801d602: 2200         	movs	r2, #0x0
 801d604: 701a         	strb	r2, [r3]
; 	if (err_cnt != NULL) {
 801d606: 687b         	ldr	r3, [r7, #0x4]
 801d608: 2b00         	cmp	r3, #0x0
 801d60a: d00b         	beq	0x801d624 <can_stm32_get_state+0x9a> @ imm = #0x16
; 		err_cnt->tx_err_cnt = ((can->ESR & CAN_ESR_TEC) >> CAN_ESR_TEC_Pos);
 801d60c: 697b         	ldr	r3, [r7, #0x14]
 801d60e: 699b         	ldr	r3, [r3, #0x18]
 801d610: 0c1b         	lsrs	r3, r3, #0x10
 801d612: b2da         	uxtb	r2, r3
 801d614: 687b         	ldr	r3, [r7, #0x4]
 801d616: 701a         	strb	r2, [r3]
; 		err_cnt->rx_err_cnt = ((can->ESR & CAN_ESR_REC) >> CAN_ESR_REC_Pos);
 801d618: 697b         	ldr	r3, [r7, #0x14]
 801d61a: 699b         	ldr	r3, [r3, #0x18]
 801d61c: 0e1b         	lsrs	r3, r3, #0x18
 801d61e: b2da         	uxtb	r2, r3
 801d620: 687b         	ldr	r3, [r7, #0x4]
 801d622: 705a         	strb	r2, [r3, #0x1]
; 	return 0;
 801d624: 2300         	movs	r3, #0x0
; }
 801d626: 4618         	mov	r0, r3
 801d628: 3724         	adds	r7, #0x24
 801d62a: 46bd         	mov	sp, r7
 801d62c: f85d 7b04    	ldr	r7, [sp], #4
 801d630: 4770         	bx	lr

0801d632 <can_stm32_bus_state_change_isr>:
; {
 801d632: b590         	push	{r4, r7, lr}
 801d634: b089         	sub	sp, #0x24
 801d636: af00         	add	r7, sp, #0x0
 801d638: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 801d63a: 687b         	ldr	r3, [r7, #0x4]
 801d63c: 691b         	ldr	r3, [r3, #0x10]
 801d63e: 61fb         	str	r3, [r7, #0x1c]
; 	const can_state_change_callback_t cb = data->common.state_change_cb;
 801d640: 69fb         	ldr	r3, [r7, #0x1c]
 801d642: 689b         	ldr	r3, [r3, #0x8]
 801d644: 61bb         	str	r3, [r7, #0x18]
; 	void *state_change_cb_data = data->common.state_change_cb_user_data;
 801d646: 69fb         	ldr	r3, [r7, #0x1c]
 801d648: 68db         	ldr	r3, [r3, #0xc]
 801d64a: 617b         	str	r3, [r7, #0x14]
; 	(void)can_stm32_get_state(dev, &state, &err_cnt);
 801d64c: f107 0210    	add.w	r2, r7, #0x10
 801d650: f107 030f    	add.w	r3, r7, #0xf
 801d654: 4619         	mov	r1, r3
 801d656: 6878         	ldr	r0, [r7, #0x4]
 801d658: f7ff ff97    	bl	0x801d58a <can_stm32_get_state> @ imm = #-0xd2
; 	if (state != data->state) {
 801d65c: 69fb         	ldr	r3, [r7, #0x1c]
 801d65e: f893 20f4    	ldrb.w	r2, [r3, #0xf4]
 801d662: 7bfb         	ldrb	r3, [r7, #0xf]
 801d664: 429a         	cmp	r2, r3
 801d666: d00c         	beq	0x801d682 <can_stm32_bus_state_change_isr+0x50> @ imm = #0x18
; 		data->state = state;
 801d668: 7bfa         	ldrb	r2, [r7, #0xf]
 801d66a: 69fb         	ldr	r3, [r7, #0x1c]
 801d66c: f883 20f4    	strb.w	r2, [r3, #0xf4]
; 		if (cb != NULL) {
 801d670: 69bb         	ldr	r3, [r7, #0x18]
 801d672: 2b00         	cmp	r3, #0x0
 801d674: d005         	beq	0x801d682 <can_stm32_bus_state_change_isr+0x50> @ imm = #0xa
; 			cb(dev, state, err_cnt, state_change_cb_data);
 801d676: 7bf9         	ldrb	r1, [r7, #0xf]
 801d678: 69bc         	ldr	r4, [r7, #0x18]
 801d67a: 697b         	ldr	r3, [r7, #0x14]
 801d67c: 693a         	ldr	r2, [r7, #0x10]
 801d67e: 6878         	ldr	r0, [r7, #0x4]
 801d680: 47a0         	blx	r4
; }
 801d682: bf00         	nop
 801d684: 3724         	adds	r7, #0x24
 801d686: 46bd         	mov	sp, r7
 801d688: bd90         	pop	{r4, r7, pc}

0801d68a <can_stm32_tx_isr_handler>:
; {
 801d68a: b580         	push	{r7, lr}
 801d68c: b088         	sub	sp, #0x20
 801d68e: af00         	add	r7, sp, #0x0
 801d690: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 801d692: 687b         	ldr	r3, [r7, #0x4]
 801d694: 691b         	ldr	r3, [r3, #0x10]
 801d696: 61fb         	str	r3, [r7, #0x1c]
; 	const struct can_stm32_config *cfg = dev->config;
 801d698: 687b         	ldr	r3, [r7, #0x4]
 801d69a: 685b         	ldr	r3, [r3, #0x4]
 801d69c: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 801d69e: 69bb         	ldr	r3, [r7, #0x18]
 801d6a0: 695b         	ldr	r3, [r3, #0x14]
 801d6a2: 617b         	str	r3, [r7, #0x14]
; 	bus_off = can->ESR & CAN_ESR_BOFF;
 801d6a4: 697b         	ldr	r3, [r7, #0x14]
 801d6a6: 699b         	ldr	r3, [r3, #0x18]
 801d6a8: f003 0304    	and	r3, r3, #0x4
 801d6ac: 613b         	str	r3, [r7, #0x10]
; 	if ((can->TSR & CAN_TSR_RQCP0) | bus_off) {
 801d6ae: 697b         	ldr	r3, [r7, #0x14]
 801d6b0: 689b         	ldr	r3, [r3, #0x8]
 801d6b2: f003 0201    	and	r2, r3, #0x1
 801d6b6: 693b         	ldr	r3, [r7, #0x10]
 801d6b8: 4313         	orrs	r3, r2
 801d6ba: 2b00         	cmp	r3, #0x0
 801d6bc: d02f         	beq	0x801d71e <can_stm32_tx_isr_handler+0x94> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK0   ? 0
 801d6be: 697b         	ldr	r3, [r7, #0x14]
 801d6c0: 689b         	ldr	r3, [r3, #0x8]
 801d6c2: f003 0302    	and	r3, r3, #0x2
; 			 : can->TSR & CAN_TSR_TERR0 ? -EIO
 801d6c6: 2b00         	cmp	r3, #0x0
 801d6c8: d11a         	bne	0x801d700 <can_stm32_tx_isr_handler+0x76> @ imm = #0x34
 801d6ca: 697b         	ldr	r3, [r7, #0x14]
 801d6cc: 689b         	ldr	r3, [r3, #0x8]
 801d6ce: f003 0308    	and	r3, r3, #0x8
; 			 : can->TSR & CAN_TSR_ALST0 ? -EBUSY
 801d6d2: 2b00         	cmp	r3, #0x0
 801d6d4: d111         	bne	0x801d6fa <can_stm32_tx_isr_handler+0x70> @ imm = #0x22
 801d6d6: 697b         	ldr	r3, [r7, #0x14]
 801d6d8: 689b         	ldr	r3, [r3, #0x8]
 801d6da: f003 0304    	and	r3, r3, #0x4
; 			 : bus_off                  ? -ENETUNREACH
 801d6de: 2b00         	cmp	r3, #0x0
 801d6e0: d108         	bne	0x801d6f4 <can_stm32_tx_isr_handler+0x6a> @ imm = #0x10
; 						    : -EIO;
 801d6e2: 693b         	ldr	r3, [r7, #0x10]
 801d6e4: 2b00         	cmp	r3, #0x0
 801d6e6: d002         	beq	0x801d6ee <can_stm32_tx_isr_handler+0x64> @ imm = #0x4
 801d6e8: f06f 0371    	mvn	r3, #0x71
 801d6ec: e009         	b	0x801d702 <can_stm32_tx_isr_handler+0x78> @ imm = #0x12
 801d6ee: f06f 0304    	mvn	r3, #0x4
 801d6f2: e006         	b	0x801d702 <can_stm32_tx_isr_handler+0x78> @ imm = #0xc
; 			 : bus_off                  ? -ENETUNREACH
 801d6f4: f06f 030f    	mvn	r3, #0xf
 801d6f8: e003         	b	0x801d702 <can_stm32_tx_isr_handler+0x78> @ imm = #0x6
; 			 : can->TSR & CAN_TSR_ALST0 ? -EBUSY
 801d6fa: f06f 0304    	mvn	r3, #0x4
 801d6fe: e000         	b	0x801d702 <can_stm32_tx_isr_handler+0x78> @ imm = #0x0
; 			 : can->TSR & CAN_TSR_TERR0 ? -EIO
 801d700: 2300         	movs	r3, #0x0
; 		status = can->TSR & CAN_TSR_TXOK0   ? 0
 801d702: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP0;
 801d704: 697b         	ldr	r3, [r7, #0x14]
 801d706: 689b         	ldr	r3, [r3, #0x8]
 801d708: f043 0201    	orr	r2, r3, #0x1
 801d70c: 697b         	ldr	r3, [r7, #0x14]
 801d70e: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb0, status);
 801d710: 69fb         	ldr	r3, [r7, #0x1c]
 801d712: 3334         	adds	r3, #0x34
 801d714: 68fa         	ldr	r2, [r7, #0xc]
 801d716: 4619         	mov	r1, r3
 801d718: 6878         	ldr	r0, [r7, #0x4]
 801d71a: f7ff fed9    	bl	0x801d4d0 <can_stm32_signal_tx_complete> @ imm = #-0x24e
; 	if ((can->TSR & CAN_TSR_RQCP1) | bus_off) {
 801d71e: 697b         	ldr	r3, [r7, #0x14]
 801d720: 689b         	ldr	r3, [r3, #0x8]
 801d722: f403 7280    	and	r2, r3, #0x100
 801d726: 693b         	ldr	r3, [r7, #0x10]
 801d728: 4313         	orrs	r3, r2
 801d72a: 2b00         	cmp	r3, #0x0
 801d72c: d02f         	beq	0x801d78e <can_stm32_tx_isr_handler+0x104> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK1   ? 0
 801d72e: 697b         	ldr	r3, [r7, #0x14]
 801d730: 689b         	ldr	r3, [r3, #0x8]
 801d732: f403 7300    	and	r3, r3, #0x200
; 			 : can->TSR & CAN_TSR_TERR1 ? -EIO
 801d736: 2b00         	cmp	r3, #0x0
 801d738: d11a         	bne	0x801d770 <can_stm32_tx_isr_handler+0xe6> @ imm = #0x34
 801d73a: 697b         	ldr	r3, [r7, #0x14]
 801d73c: 689b         	ldr	r3, [r3, #0x8]
 801d73e: f403 6300    	and	r3, r3, #0x800
; 			 : can->TSR & CAN_TSR_ALST1 ? -EBUSY
 801d742: 2b00         	cmp	r3, #0x0
 801d744: d111         	bne	0x801d76a <can_stm32_tx_isr_handler+0xe0> @ imm = #0x22
 801d746: 697b         	ldr	r3, [r7, #0x14]
 801d748: 689b         	ldr	r3, [r3, #0x8]
 801d74a: f403 6380    	and	r3, r3, #0x400
; 			 : bus_off                  ? -ENETUNREACH
 801d74e: 2b00         	cmp	r3, #0x0
 801d750: d108         	bne	0x801d764 <can_stm32_tx_isr_handler+0xda> @ imm = #0x10
; 						    : -EIO;
 801d752: 693b         	ldr	r3, [r7, #0x10]
 801d754: 2b00         	cmp	r3, #0x0
 801d756: d002         	beq	0x801d75e <can_stm32_tx_isr_handler+0xd4> @ imm = #0x4
 801d758: f06f 0371    	mvn	r3, #0x71
 801d75c: e009         	b	0x801d772 <can_stm32_tx_isr_handler+0xe8> @ imm = #0x12
 801d75e: f06f 0304    	mvn	r3, #0x4
 801d762: e006         	b	0x801d772 <can_stm32_tx_isr_handler+0xe8> @ imm = #0xc
; 			 : bus_off                  ? -ENETUNREACH
 801d764: f06f 030f    	mvn	r3, #0xf
 801d768: e003         	b	0x801d772 <can_stm32_tx_isr_handler+0xe8> @ imm = #0x6
; 			 : can->TSR & CAN_TSR_ALST1 ? -EBUSY
 801d76a: f06f 0304    	mvn	r3, #0x4
 801d76e: e000         	b	0x801d772 <can_stm32_tx_isr_handler+0xe8> @ imm = #0x0
; 			 : can->TSR & CAN_TSR_TERR1 ? -EIO
 801d770: 2300         	movs	r3, #0x0
; 		status = can->TSR & CAN_TSR_TXOK1   ? 0
 801d772: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP1;
 801d774: 697b         	ldr	r3, [r7, #0x14]
 801d776: 689b         	ldr	r3, [r3, #0x8]
 801d778: f443 7280    	orr	r2, r3, #0x100
 801d77c: 697b         	ldr	r3, [r7, #0x14]
 801d77e: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb1, status);
 801d780: 69fb         	ldr	r3, [r7, #0x1c]
 801d782: 333c         	adds	r3, #0x3c
 801d784: 68fa         	ldr	r2, [r7, #0xc]
 801d786: 4619         	mov	r1, r3
 801d788: 6878         	ldr	r0, [r7, #0x4]
 801d78a: f7ff fea1    	bl	0x801d4d0 <can_stm32_signal_tx_complete> @ imm = #-0x2be
; 	if ((can->TSR & CAN_TSR_RQCP2) | bus_off) {
 801d78e: 697b         	ldr	r3, [r7, #0x14]
 801d790: 689b         	ldr	r3, [r3, #0x8]
 801d792: f403 3280    	and	r2, r3, #0x10000
 801d796: 693b         	ldr	r3, [r7, #0x10]
 801d798: 4313         	orrs	r3, r2
 801d79a: 2b00         	cmp	r3, #0x0
 801d79c: d02f         	beq	0x801d7fe <can_stm32_tx_isr_handler+0x174> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK2   ? 0
 801d79e: 697b         	ldr	r3, [r7, #0x14]
 801d7a0: 689b         	ldr	r3, [r3, #0x8]
 801d7a2: f403 3300    	and	r3, r3, #0x20000
; 			 : can->TSR & CAN_TSR_TERR2 ? -EIO
 801d7a6: 2b00         	cmp	r3, #0x0
 801d7a8: d11a         	bne	0x801d7e0 <can_stm32_tx_isr_handler+0x156> @ imm = #0x34
 801d7aa: 697b         	ldr	r3, [r7, #0x14]
 801d7ac: 689b         	ldr	r3, [r3, #0x8]
 801d7ae: f403 2300    	and	r3, r3, #0x80000
; 			 : can->TSR & CAN_TSR_ALST2 ? -EBUSY
 801d7b2: 2b00         	cmp	r3, #0x0
 801d7b4: d111         	bne	0x801d7da <can_stm32_tx_isr_handler+0x150> @ imm = #0x22
 801d7b6: 697b         	ldr	r3, [r7, #0x14]
 801d7b8: 689b         	ldr	r3, [r3, #0x8]
 801d7ba: f403 2380    	and	r3, r3, #0x40000
; 			 : bus_off                  ? -ENETUNREACH
 801d7be: 2b00         	cmp	r3, #0x0
 801d7c0: d108         	bne	0x801d7d4 <can_stm32_tx_isr_handler+0x14a> @ imm = #0x10
; 						    : -EIO;
 801d7c2: 693b         	ldr	r3, [r7, #0x10]
 801d7c4: 2b00         	cmp	r3, #0x0
 801d7c6: d002         	beq	0x801d7ce <can_stm32_tx_isr_handler+0x144> @ imm = #0x4
 801d7c8: f06f 0371    	mvn	r3, #0x71
 801d7cc: e009         	b	0x801d7e2 <can_stm32_tx_isr_handler+0x158> @ imm = #0x12
 801d7ce: f06f 0304    	mvn	r3, #0x4
 801d7d2: e006         	b	0x801d7e2 <can_stm32_tx_isr_handler+0x158> @ imm = #0xc
; 			 : bus_off                  ? -ENETUNREACH
 801d7d4: f06f 030f    	mvn	r3, #0xf
 801d7d8: e003         	b	0x801d7e2 <can_stm32_tx_isr_handler+0x158> @ imm = #0x6
; 			 : can->TSR & CAN_TSR_ALST2 ? -EBUSY
 801d7da: f06f 0304    	mvn	r3, #0x4
 801d7de: e000         	b	0x801d7e2 <can_stm32_tx_isr_handler+0x158> @ imm = #0x0
; 			 : can->TSR & CAN_TSR_TERR2 ? -EIO
 801d7e0: 2300         	movs	r3, #0x0
; 		status = can->TSR & CAN_TSR_TXOK2   ? 0
 801d7e2: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP2;
 801d7e4: 697b         	ldr	r3, [r7, #0x14]
 801d7e6: 689b         	ldr	r3, [r3, #0x8]
 801d7e8: f443 3280    	orr	r2, r3, #0x10000
 801d7ec: 697b         	ldr	r3, [r7, #0x14]
 801d7ee: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb2, status);
 801d7f0: 69fb         	ldr	r3, [r7, #0x1c]
 801d7f2: 3344         	adds	r3, #0x44
 801d7f4: 68fa         	ldr	r2, [r7, #0xc]
 801d7f6: 4619         	mov	r1, r3
 801d7f8: 6878         	ldr	r0, [r7, #0x4]
 801d7fa: f7ff fe69    	bl	0x801d4d0 <can_stm32_signal_tx_complete> @ imm = #-0x32e
; 	if (can->TSR & CAN_TSR_TME) {
 801d7fe: 697b         	ldr	r3, [r7, #0x14]
 801d800: 689b         	ldr	r3, [r3, #0x8]
 801d802: f003 53e0    	and	r3, r3, #0x1c000000
 801d806: 2b00         	cmp	r3, #0x0
 801d808: d004         	beq	0x801d814 <can_stm32_tx_isr_handler+0x18a> @ imm = #0x8
; 		k_sem_give(&data->tx_int_sem);
 801d80a: 69fb         	ldr	r3, [r7, #0x1c]
 801d80c: 3324         	adds	r3, #0x24
 801d80e: 4618         	mov	r0, r3
 801d810: f7ff fd99    	bl	0x801d346 <k_sem_give>  @ imm = #-0x4ce
; }
 801d814: bf00         	nop
 801d816: 3720         	adds	r7, #0x20
 801d818: 46bd         	mov	sp, r7
 801d81a: bd80         	pop	{r7, pc}

0801d81c <can_stm32_rx_isr>:
; {
 801d81c: b580         	push	{r7, lr}
 801d81e: b082         	sub	sp, #0x8
 801d820: af00         	add	r7, sp, #0x0
 801d822: 6078         	str	r0, [r7, #0x4]
; 	can_stm32_rx_isr_handler(dev);
 801d824: 6878         	ldr	r0, [r7, #0x4]
 801d826: f7ea fa4f    	bl	0x8007cc8 <can_stm32_rx_isr_handler> @ imm = #-0x15b62
; }
 801d82a: bf00         	nop
 801d82c: 3708         	adds	r7, #0x8
 801d82e: 46bd         	mov	sp, r7
 801d830: bd80         	pop	{r7, pc}

0801d832 <can_stm32_tx_isr>:
; {
 801d832: b580         	push	{r7, lr}
 801d834: b082         	sub	sp, #0x8
 801d836: af00         	add	r7, sp, #0x0
 801d838: 6078         	str	r0, [r7, #0x4]
; 	can_stm32_tx_isr_handler(dev);
 801d83a: 6878         	ldr	r0, [r7, #0x4]
 801d83c: f7ff ff25    	bl	0x801d68a <can_stm32_tx_isr_handler> @ imm = #-0x1b6
; }
 801d840: bf00         	nop
 801d842: 3708         	adds	r7, #0x8
 801d844: 46bd         	mov	sp, r7
 801d846: bd80         	pop	{r7, pc}

0801d848 <can_stm32_state_change_isr>:
; {
 801d848: b580         	push	{r7, lr}
 801d84a: b084         	sub	sp, #0x10
 801d84c: af00         	add	r7, sp, #0x0
 801d84e: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 801d850: 687b         	ldr	r3, [r7, #0x4]
 801d852: 685b         	ldr	r3, [r3, #0x4]
 801d854: 60fb         	str	r3, [r7, #0xc]
; 	CAN_TypeDef *can = cfg->can;
 801d856: 68fb         	ldr	r3, [r7, #0xc]
 801d858: 695b         	ldr	r3, [r3, #0x14]
 801d85a: 60bb         	str	r3, [r7, #0x8]
; 	if (can->MSR & CAN_MSR_ERRI) {
 801d85c: 68bb         	ldr	r3, [r7, #0x8]
 801d85e: 685b         	ldr	r3, [r3, #0x4]
 801d860: f003 0304    	and	r3, r3, #0x4
 801d864: 2b00         	cmp	r3, #0x0
 801d866: d00b         	beq	0x801d880 <can_stm32_state_change_isr+0x38> @ imm = #0x16
; 		can_stm32_tx_isr_handler(dev);
 801d868: 6878         	ldr	r0, [r7, #0x4]
 801d86a: f7ff ff0e    	bl	0x801d68a <can_stm32_tx_isr_handler> @ imm = #-0x1e4
; 		can_stm32_bus_state_change_isr(dev);
 801d86e: 6878         	ldr	r0, [r7, #0x4]
 801d870: f7ff fedf    	bl	0x801d632 <can_stm32_bus_state_change_isr> @ imm = #-0x242
; 		can->MSR |= CAN_MSR_ERRI;
 801d874: 68bb         	ldr	r3, [r7, #0x8]
 801d876: 685b         	ldr	r3, [r3, #0x4]
 801d878: f043 0204    	orr	r2, r3, #0x4
 801d87c: 68bb         	ldr	r3, [r7, #0x8]
 801d87e: 605a         	str	r2, [r3, #0x4]
; }
 801d880: bf00         	nop
 801d882: 3710         	adds	r7, #0x10
 801d884: 46bd         	mov	sp, r7
 801d886: bd80         	pop	{r7, pc}

0801d888 <can_stm32_get_capabilities>:
; {
 801d888: b480         	push	{r7}
 801d88a: b083         	sub	sp, #0xc
 801d88c: af00         	add	r7, sp, #0x0
 801d88e: 6078         	str	r0, [r7, #0x4]
 801d890: 6039         	str	r1, [r7]
; 	*cap = CAN_MODE_NORMAL | CAN_MODE_LOOPBACK | CAN_MODE_LISTENONLY | CAN_MODE_ONE_SHOT;
 801d892: 683b         	ldr	r3, [r7]
 801d894: 220b         	movs	r2, #0xb
 801d896: 601a         	str	r2, [r3]
; 	return 0;
 801d898: 2300         	movs	r3, #0x0
; }
 801d89a: 4618         	mov	r0, r3
 801d89c: 370c         	adds	r7, #0xc
 801d89e: 46bd         	mov	sp, r7
 801d8a0: f85d 7b04    	ldr	r7, [sp], #4
 801d8a4: 4770         	bx	lr

0801d8a6 <can_stm32_get_max_filters>:
; {
 801d8a6: b480         	push	{r7}
 801d8a8: b083         	sub	sp, #0xc
 801d8aa: af00         	add	r7, sp, #0x0
 801d8ac: 6078         	str	r0, [r7, #0x4]
 801d8ae: 460b         	mov	r3, r1
 801d8b0: 70fb         	strb	r3, [r7, #0x3]
; 	if (ide) {
 801d8b2: 78fb         	ldrb	r3, [r7, #0x3]
 801d8b4: 2b00         	cmp	r3, #0x0
 801d8b6: d001         	beq	0x801d8bc <can_stm32_get_max_filters+0x16> @ imm = #0x2
; 		return CONFIG_CAN_MAX_EXT_ID_FILTER;
 801d8b8: 2307         	movs	r3, #0x7
 801d8ba: e000         	b	0x801d8be <can_stm32_get_max_filters+0x18> @ imm = #0x0
; 		return CONFIG_CAN_MAX_STD_ID_FILTER;
 801d8bc: 230e         	movs	r3, #0xe
; }
 801d8be: 4618         	mov	r0, r3
 801d8c0: 370c         	adds	r7, #0xc
 801d8c2: 46bd         	mov	sp, r7
 801d8c4: f85d 7b04    	ldr	r7, [sp], #4
 801d8c8: 4770         	bx	lr

0801d8ca <can_stm32_set_state_change_callback>:
; {
 801d8ca: b480         	push	{r7}
 801d8cc: b089         	sub	sp, #0x24
 801d8ce: af00         	add	r7, sp, #0x0
 801d8d0: 60f8         	str	r0, [r7, #0xc]
 801d8d2: 60b9         	str	r1, [r7, #0x8]
 801d8d4: 607a         	str	r2, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 801d8d6: 68fb         	ldr	r3, [r7, #0xc]
 801d8d8: 691b         	ldr	r3, [r3, #0x10]
 801d8da: 61fb         	str	r3, [r7, #0x1c]
; 	const struct can_stm32_config *cfg = dev->config;
 801d8dc: 68fb         	ldr	r3, [r7, #0xc]
 801d8de: 685b         	ldr	r3, [r3, #0x4]
 801d8e0: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 801d8e2: 69bb         	ldr	r3, [r7, #0x18]
 801d8e4: 695b         	ldr	r3, [r3, #0x14]
 801d8e6: 617b         	str	r3, [r7, #0x14]
; 	data->common.state_change_cb = cb;
 801d8e8: 69fb         	ldr	r3, [r7, #0x1c]
 801d8ea: 68ba         	ldr	r2, [r7, #0x8]
 801d8ec: 609a         	str	r2, [r3, #0x8]
; 	data->common.state_change_cb_user_data = user_data;
 801d8ee: 69fb         	ldr	r3, [r7, #0x1c]
 801d8f0: 687a         	ldr	r2, [r7, #0x4]
 801d8f2: 60da         	str	r2, [r3, #0xc]
; 	if (cb == NULL) {
 801d8f4: 68bb         	ldr	r3, [r7, #0x8]
 801d8f6: 2b00         	cmp	r3, #0x0
 801d8f8: d106         	bne	0x801d908 <can_stm32_set_state_change_callback+0x3e> @ imm = #0xc
; 		can->IER &= ~(CAN_IER_BOFIE | CAN_IER_EPVIE | CAN_IER_EWGIE);
 801d8fa: 697b         	ldr	r3, [r7, #0x14]
 801d8fc: 695b         	ldr	r3, [r3, #0x14]
 801d8fe: f423 62e0    	bic	r2, r3, #0x700
 801d902: 697b         	ldr	r3, [r7, #0x14]
 801d904: 615a         	str	r2, [r3, #0x14]
; }
 801d906: e005         	b	0x801d914 <can_stm32_set_state_change_callback+0x4a> @ imm = #0xa
; 		can->IER |= CAN_IER_BOFIE | CAN_IER_EPVIE | CAN_IER_EWGIE;
 801d908: 697b         	ldr	r3, [r7, #0x14]
 801d90a: 695b         	ldr	r3, [r3, #0x14]
 801d90c: f443 62e0    	orr	r2, r3, #0x700
 801d910: 697b         	ldr	r3, [r7, #0x14]
 801d912: 615a         	str	r2, [r3, #0x14]
; }
 801d914: bf00         	nop
 801d916: 3724         	adds	r7, #0x24
 801d918: 46bd         	mov	sp, r7
 801d91a: f85d 7b04    	ldr	r7, [sp], #4
 801d91e: 4770         	bx	lr

0801d920 <can_stm32_set_filter_bank>:
; {
 801d920: b480         	push	{r7}
 801d922: b085         	sub	sp, #0x14
 801d924: af00         	add	r7, sp, #0x0
 801d926: 60f8         	str	r0, [r7, #0xc]
 801d928: 60b9         	str	r1, [r7, #0x8]
 801d92a: 603b         	str	r3, [r7]
 801d92c: 4613         	mov	r3, r2
 801d92e: 71fb         	strb	r3, [r7, #0x7]
; 	if (ide) {
 801d930: 79fb         	ldrb	r3, [r7, #0x7]
 801d932: 2b00         	cmp	r3, #0x0
 801d934: d006         	beq	0x801d944 <can_stm32_set_filter_bank+0x24> @ imm = #0xc
; 		filter_reg->FR1 = id;
 801d936: 68bb         	ldr	r3, [r7, #0x8]
 801d938: 683a         	ldr	r2, [r7]
 801d93a: 601a         	str	r2, [r3]
; 		filter_reg->FR2 = mask;
 801d93c: 68bb         	ldr	r3, [r7, #0x8]
 801d93e: 69ba         	ldr	r2, [r7, #0x18]
 801d940: 605a         	str	r2, [r3, #0x4]
; }
 801d942: e012         	b	0x801d96a <can_stm32_set_filter_bank+0x4a> @ imm = #0x24
; 		if ((filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER) % 2 == 0) {
 801d944: 68fb         	ldr	r3, [r7, #0xc]
 801d946: 3b07         	subs	r3, #0x7
 801d948: f003 0301    	and	r3, r3, #0x1
 801d94c: 2b00         	cmp	r3, #0x0
 801d94e: d106         	bne	0x801d95e <can_stm32_set_filter_bank+0x3e> @ imm = #0xc
; 			filter_reg->FR1 = id | (mask << 16);
 801d950: 69bb         	ldr	r3, [r7, #0x18]
 801d952: 041a         	lsls	r2, r3, #0x10
 801d954: 683b         	ldr	r3, [r7]
 801d956: 431a         	orrs	r2, r3
 801d958: 68bb         	ldr	r3, [r7, #0x8]
 801d95a: 601a         	str	r2, [r3]
; }
 801d95c: e005         	b	0x801d96a <can_stm32_set_filter_bank+0x4a> @ imm = #0xa
; 			filter_reg->FR2 = id | (mask << 16);
 801d95e: 69bb         	ldr	r3, [r7, #0x18]
 801d960: 041a         	lsls	r2, r3, #0x10
 801d962: 683b         	ldr	r3, [r7]
 801d964: 431a         	orrs	r2, r3
 801d966: 68bb         	ldr	r3, [r7, #0x8]
 801d968: 605a         	str	r2, [r3, #0x4]
; }
 801d96a: bf00         	nop
 801d96c: 3714         	adds	r7, #0x14
 801d96e: 46bd         	mov	sp, r7
 801d970: f85d 7b04    	ldr	r7, [sp], #4
 801d974: 4770         	bx	lr

0801d976 <can_stm32_filter_to_std_mask>:
; {
 801d976: b480         	push	{r7}
 801d978: b085         	sub	sp, #0x14
 801d97a: af00         	add	r7, sp, #0x0
 801d97c: 6078         	str	r0, [r7, #0x4]
; 	uint32_t rtr_mask = !IS_ENABLED(CONFIG_CAN_ACCEPT_RTR);
 801d97e: 2301         	movs	r3, #0x1
 801d980: 60fb         	str	r3, [r7, #0xc]
; 	return (filter->mask << CAN_STM32_FIRX_STD_ID_POS) |
 801d982: 687b         	ldr	r3, [r7, #0x4]
 801d984: 685b         	ldr	r3, [r3, #0x4]
 801d986: 015a         	lsls	r2, r3, #0x5
; 	       (rtr_mask << CAN_STM32_FIRX_STD_RTR_POS) | (1U << CAN_STM32_FIRX_STD_IDE_POS);
 801d988: 68fb         	ldr	r3, [r7, #0xc]
 801d98a: 011b         	lsls	r3, r3, #0x4
; 	return (filter->mask << CAN_STM32_FIRX_STD_ID_POS) |
 801d98c: 4313         	orrs	r3, r2
; 	       (rtr_mask << CAN_STM32_FIRX_STD_RTR_POS) | (1U << CAN_STM32_FIRX_STD_IDE_POS);
 801d98e: f043 0308    	orr	r3, r3, #0x8
; }
 801d992: 4618         	mov	r0, r3
 801d994: 3714         	adds	r7, #0x14
 801d996: 46bd         	mov	sp, r7
 801d998: f85d 7b04    	ldr	r7, [sp], #4
 801d99c: 4770         	bx	lr

0801d99e <can_stm32_filter_to_ext_mask>:
; {
 801d99e: b480         	push	{r7}
 801d9a0: b085         	sub	sp, #0x14
 801d9a2: af00         	add	r7, sp, #0x0
 801d9a4: 6078         	str	r0, [r7, #0x4]
; 	uint32_t rtr_mask = !IS_ENABLED(CONFIG_CAN_ACCEPT_RTR);
 801d9a6: 2301         	movs	r3, #0x1
 801d9a8: 60fb         	str	r3, [r7, #0xc]
; 	return (filter->mask << CAN_STM32_FIRX_EXT_EXT_ID_POS) |
 801d9aa: 687b         	ldr	r3, [r7, #0x4]
 801d9ac: 685b         	ldr	r3, [r3, #0x4]
 801d9ae: 00da         	lsls	r2, r3, #0x3
; 	       (rtr_mask << CAN_STM32_FIRX_EXT_RTR_POS) | (1U << CAN_STM32_FIRX_EXT_IDE_POS);
 801d9b0: 68fb         	ldr	r3, [r7, #0xc]
 801d9b2: 005b         	lsls	r3, r3, #0x1
; 	return (filter->mask << CAN_STM32_FIRX_EXT_EXT_ID_POS) |
 801d9b4: 4313         	orrs	r3, r2
; 	       (rtr_mask << CAN_STM32_FIRX_EXT_RTR_POS) | (1U << CAN_STM32_FIRX_EXT_IDE_POS);
 801d9b6: f043 0304    	orr	r3, r3, #0x4
; }
 801d9ba: 4618         	mov	r0, r3
 801d9bc: 3714         	adds	r7, #0x14
 801d9be: 46bd         	mov	sp, r7
 801d9c0: f85d 7b04    	ldr	r7, [sp], #4
 801d9c4: 4770         	bx	lr

0801d9c6 <can_stm32_filter_to_std_id>:
; {
 801d9c6: b480         	push	{r7}
 801d9c8: b083         	sub	sp, #0xc
 801d9ca: af00         	add	r7, sp, #0x0
 801d9cc: 6078         	str	r0, [r7, #0x4]
; 	return (filter->id << CAN_STM32_FIRX_STD_ID_POS);
 801d9ce: 687b         	ldr	r3, [r7, #0x4]
 801d9d0: 681b         	ldr	r3, [r3]
 801d9d2: 015b         	lsls	r3, r3, #0x5
; }
 801d9d4: 4618         	mov	r0, r3
 801d9d6: 370c         	adds	r7, #0xc
 801d9d8: 46bd         	mov	sp, r7
 801d9da: f85d 7b04    	ldr	r7, [sp], #4
 801d9de: 4770         	bx	lr

0801d9e0 <can_stm32_filter_to_ext_id>:
; {
 801d9e0: b480         	push	{r7}
 801d9e2: b083         	sub	sp, #0xc
 801d9e4: af00         	add	r7, sp, #0x0
 801d9e6: 6078         	str	r0, [r7, #0x4]
; 	return (filter->id << CAN_STM32_FIRX_EXT_EXT_ID_POS) | (1U << CAN_STM32_FIRX_EXT_IDE_POS);
 801d9e8: 687b         	ldr	r3, [r7, #0x4]
 801d9ea: 681b         	ldr	r3, [r3]
 801d9ec: 00db         	lsls	r3, r3, #0x3
 801d9ee: f043 0304    	orr	r3, r3, #0x4
; }
 801d9f2: 4618         	mov	r0, r3
 801d9f4: 370c         	adds	r7, #0xc
 801d9f6: 46bd         	mov	sp, r7
 801d9f8: f85d 7b04    	ldr	r7, [sp], #4
 801d9fc: 4770         	bx	lr

0801d9fe <config_can_0_irq>:
; DT_INST_FOREACH_STATUS_OKAY(CAN_STM32_INST)
 801d9fe: b580         	push	{r7, lr}
 801da00: b082         	sub	sp, #0x8
 801da02: af00         	add	r7, sp, #0x0
 801da04: 6078         	str	r0, [r7, #0x4]
 801da06: 2200         	movs	r2, #0x0
 801da08: 2100         	movs	r1, #0x0
 801da0a: 2014         	movs	r0, #0x14
 801da0c: f7fe fcdc    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1648
 801da10: 2014         	movs	r0, #0x14
 801da12: f7fe fccc    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x1668
 801da16: 2200         	movs	r2, #0x0
 801da18: 2100         	movs	r1, #0x0
 801da1a: 2013         	movs	r0, #0x13
 801da1c: f7fe fcd4    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1658
 801da20: 2013         	movs	r0, #0x13
 801da22: f7fe fcc4    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x1678
 801da26: 2200         	movs	r2, #0x0
 801da28: 2100         	movs	r1, #0x0
 801da2a: 2016         	movs	r0, #0x16
 801da2c: f7fe fccc    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1668
 801da30: 2016         	movs	r0, #0x16
 801da32: f7fe fcbc    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x1688
 801da36: 687b         	ldr	r3, [r7, #0x4]
 801da38: 695b         	ldr	r3, [r3, #0x14]
 801da3a: f443 4304    	orr	r3, r3, #0x8400
 801da3e: f043 0313    	orr	r3, r3, #0x13
 801da42: 687a         	ldr	r2, [r7, #0x4]
 801da44: 6153         	str	r3, [r2, #0x14]
 801da46: 3708         	adds	r7, #0x8
 801da48: 46bd         	mov	sp, r7
 801da4a: bd80         	pop	{r7, pc}

0801da4c <config_can_1_irq>:
 801da4c: b580         	push	{r7, lr}
 801da4e: b082         	sub	sp, #0x8
 801da50: af00         	add	r7, sp, #0x0
 801da52: 6078         	str	r0, [r7, #0x4]
 801da54: 2200         	movs	r2, #0x0
 801da56: 2100         	movs	r1, #0x0
 801da58: 2040         	movs	r0, #0x40
 801da5a: f7fe fcb5    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1696
 801da5e: 2040         	movs	r0, #0x40
 801da60: f7fe fca5    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x16b6
 801da64: 2200         	movs	r2, #0x0
 801da66: 2100         	movs	r1, #0x0
 801da68: 203f         	movs	r0, #0x3f
 801da6a: f7fe fcad    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x16a6
 801da6e: 203f         	movs	r0, #0x3f
 801da70: f7fe fc9d    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x16c6
 801da74: 2200         	movs	r2, #0x0
 801da76: 2100         	movs	r1, #0x0
 801da78: 2042         	movs	r0, #0x42
 801da7a: f7fe fca5    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x16b6
 801da7e: 2042         	movs	r0, #0x42
 801da80: f7fe fc95    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x16d6
 801da84: 687b         	ldr	r3, [r7, #0x4]
 801da86: 695b         	ldr	r3, [r3, #0x14]
 801da88: f443 4304    	orr	r3, r3, #0x8400
 801da8c: f043 0313    	orr	r3, r3, #0x13
 801da90: 687a         	ldr	r2, [r7, #0x4]
 801da92: 6153         	str	r3, [r2, #0x14]
 801da94: 3708         	adds	r7, #0x8
 801da96: 46bd         	mov	sp, r7
 801da98: bd80         	pop	{r7, pc}

0801da9a <stm32_clock_control_mco_init>:
; {
 801da9a: b480         	push	{r7}
 801da9c: af00         	add	r7, sp, #0x0
; }
 801da9e: bf00         	nop
 801daa0: 46bd         	mov	sp, r7
 801daa2: f85d 7b04    	ldr	r7, [sp], #4
 801daa6: 4770         	bx	lr

0801daa8 <get_pll_div_frequency>:
; {
 801daa8: b480         	push	{r7}
 801daaa: b085         	sub	sp, #0x14
 801daac: af00         	add	r7, sp, #0x0
 801daae: 60f8         	str	r0, [r7, #0xc]
 801dab0: 60b9         	str	r1, [r7, #0x8]
 801dab2: 607a         	str	r2, [r7, #0x4]
 801dab4: 603b         	str	r3, [r7]
; 	return pllsrc_freq / pllm_div * plln_mul / pllout_div;
 801dab6: 68bb         	ldr	r3, [r7, #0x8]
 801dab8: 68fa         	ldr	r2, [r7, #0xc]
 801daba: fbb2 f3f3    	udiv	r3, r2, r3
 801dabe: 687a         	ldr	r2, [r7, #0x4]
 801dac0: fb03 f202    	mul	r2, r3, r2
 801dac4: 683b         	ldr	r3, [r7]
 801dac6: fbb2 f3f3    	udiv	r3, r2, r3
; }
 801daca: 4618         	mov	r0, r3
 801dacc: 3714         	adds	r7, #0x14
 801dace: 46bd         	mov	sp, r7
 801dad0: f85d 7b04    	ldr	r7, [sp], #4
 801dad4: 4770         	bx	lr

0801dad6 <get_bus_clock>:
; {
 801dad6: b480         	push	{r7}
 801dad8: b083         	sub	sp, #0xc
 801dada: af00         	add	r7, sp, #0x0
 801dadc: 6078         	str	r0, [r7, #0x4]
 801dade: 6039         	str	r1, [r7]
; 	return clock / prescaler;
 801dae0: 687a         	ldr	r2, [r7, #0x4]
 801dae2: 683b         	ldr	r3, [r7]
 801dae4: fbb2 f3f3    	udiv	r3, r2, r3
; }
 801dae8: 4618         	mov	r0, r3
 801daea: 370c         	adds	r7, #0xc
 801daec: 46bd         	mov	sp, r7
 801daee: f85d 7b04    	ldr	r7, [sp], #4
 801daf2: 4770         	bx	lr

0801daf4 <stm32_clock_control_on>:
; {
 801daf4: b480         	push	{r7}
 801daf6: b089         	sub	sp, #0x24
 801daf8: af00         	add	r7, sp, #0x0
 801dafa: 6078         	str	r0, [r7, #0x4]
 801dafc: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 801dafe: 683b         	ldr	r3, [r7]
 801db00: 61fb         	str	r3, [r7, #0x1c]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 801db02: 69fb         	ldr	r3, [r7, #0x1c]
 801db04: 681b         	ldr	r3, [r3]
 801db06: 2b2f         	cmp	r3, #0x2f
 801db08: d905         	bls	0x801db16 <stm32_clock_control_on+0x22> @ imm = #0xa
 801db0a: 69fb         	ldr	r3, [r7, #0x1c]
 801db0c: 681b         	ldr	r3, [r3]
 801db0e: 2ba8         	cmp	r3, #0xa8
 801db10: d801         	bhi	0x801db16 <stm32_clock_control_on+0x22> @ imm = #0x2
 801db12: 2301         	movs	r3, #0x1
 801db14: e000         	b	0x801db18 <stm32_clock_control_on+0x24> @ imm = #0x0
 801db16: 2300         	movs	r3, #0x0
 801db18: 2b00         	cmp	r3, #0x0
 801db1a: d102         	bne	0x801db22 <stm32_clock_control_on+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 801db1c: f06f 0385    	mvn	r3, #0x85
 801db20: e01e         	b	0x801db60 <stm32_clock_control_on+0x6c> @ imm = #0x3c
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 801db22: 69fb         	ldr	r3, [r7, #0x1c]
 801db24: 681b         	ldr	r3, [r3]
 801db26: f103 4380    	add.w	r3, r3, #0x40000000
 801db2a: f503 330e    	add.w	r3, r3, #0x23800
 801db2e: 69fa         	ldr	r2, [r7, #0x1c]
 801db30: 6852         	ldr	r2, [r2, #0x4]
 801db32: 617b         	str	r3, [r7, #0x14]
 801db34: 613a         	str	r2, [r7, #0x10]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801db36: 697b         	ldr	r3, [r7, #0x14]
 801db38: 681b         	ldr	r3, [r3]
 801db3a: 60fb         	str	r3, [r7, #0xc]
; 	*(volatile uint32_t *)addr = temp | mask;
 801db3c: 697b         	ldr	r3, [r7, #0x14]
 801db3e: 6939         	ldr	r1, [r7, #0x10]
 801db40: 68fa         	ldr	r2, [r7, #0xc]
 801db42: 430a         	orrs	r2, r1
 801db44: 601a         	str	r2, [r3]
; }
 801db46: bf00         	nop
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 801db48: 69fb         	ldr	r3, [r7, #0x1c]
 801db4a: 681b         	ldr	r3, [r3]
 801db4c: f103 4380    	add.w	r3, r3, #0x40000000
 801db50: f503 330e    	add.w	r3, r3, #0x23800
 801db54: 61bb         	str	r3, [r7, #0x18]
; 	return *(volatile uint32_t *)addr;
 801db56: 69bb         	ldr	r3, [r7, #0x18]
 801db58: 681b         	ldr	r3, [r3]
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 801db5a: 60bb         	str	r3, [r7, #0x8]
; 	UNUSED(temp);
 801db5c: 68bb         	ldr	r3, [r7, #0x8]
; 	return 0;
 801db5e: 2300         	movs	r3, #0x0
; }
 801db60: 4618         	mov	r0, r3
 801db62: 3724         	adds	r7, #0x24
 801db64: 46bd         	mov	sp, r7
 801db66: f85d 7b04    	ldr	r7, [sp], #4
 801db6a: 4770         	bx	lr

0801db6c <stm32_clock_control_off>:
; {
 801db6c: b480         	push	{r7}
 801db6e: b087         	sub	sp, #0x1c
 801db70: af00         	add	r7, sp, #0x0
 801db72: 6078         	str	r0, [r7, #0x4]
 801db74: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 801db76: 683b         	ldr	r3, [r7]
 801db78: 617b         	str	r3, [r7, #0x14]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 801db7a: 697b         	ldr	r3, [r7, #0x14]
 801db7c: 681b         	ldr	r3, [r3]
 801db7e: 2b2f         	cmp	r3, #0x2f
 801db80: d905         	bls	0x801db8e <stm32_clock_control_off+0x22> @ imm = #0xa
 801db82: 697b         	ldr	r3, [r7, #0x14]
 801db84: 681b         	ldr	r3, [r3]
 801db86: 2ba8         	cmp	r3, #0xa8
 801db88: d801         	bhi	0x801db8e <stm32_clock_control_off+0x22> @ imm = #0x2
 801db8a: 2301         	movs	r3, #0x1
 801db8c: e000         	b	0x801db90 <stm32_clock_control_off+0x24> @ imm = #0x0
 801db8e: 2300         	movs	r3, #0x0
 801db90: 2b00         	cmp	r3, #0x0
 801db92: d102         	bne	0x801db9a <stm32_clock_control_off+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 801db94: f06f 0385    	mvn	r3, #0x85
 801db98: e014         	b	0x801dbc4 <stm32_clock_control_off+0x58> @ imm = #0x28
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 801db9a: 697b         	ldr	r3, [r7, #0x14]
 801db9c: 681b         	ldr	r3, [r3]
 801db9e: f103 4380    	add.w	r3, r3, #0x40000000
 801dba2: f503 330e    	add.w	r3, r3, #0x23800
 801dba6: 697a         	ldr	r2, [r7, #0x14]
 801dba8: 6852         	ldr	r2, [r2, #0x4]
 801dbaa: 613b         	str	r3, [r7, #0x10]
 801dbac: 60fa         	str	r2, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801dbae: 693b         	ldr	r3, [r7, #0x10]
 801dbb0: 681b         	ldr	r3, [r3]
 801dbb2: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 801dbb4: 68fb         	ldr	r3, [r7, #0xc]
 801dbb6: 43d9         	mvns	r1, r3
 801dbb8: 693b         	ldr	r3, [r7, #0x10]
 801dbba: 68ba         	ldr	r2, [r7, #0x8]
 801dbbc: 400a         	ands	r2, r1
 801dbbe: 601a         	str	r2, [r3]
; }
 801dbc0: bf00         	nop
; 	return 0;
 801dbc2: 2300         	movs	r3, #0x0
; }
 801dbc4: 4618         	mov	r0, r3
 801dbc6: 371c         	adds	r7, #0x1c
 801dbc8: 46bd         	mov	sp, r7
 801dbca: f85d 7b04    	ldr	r7, [sp], #4
 801dbce: 4770         	bx	lr

0801dbd0 <stm32_clock_control_configure>:
; {
 801dbd0: b580         	push	{r7, lr}
 801dbd2: b08c         	sub	sp, #0x30
 801dbd4: af00         	add	r7, sp, #0x0
 801dbd6: 60f8         	str	r0, [r7, #0xc]
 801dbd8: 60b9         	str	r1, [r7, #0x8]
 801dbda: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 801dbdc: 68bb         	ldr	r3, [r7, #0x8]
 801dbde: 62fb         	str	r3, [r7, #0x2c]
; 	err = enabled_clock(pclken->bus);
 801dbe0: 6afb         	ldr	r3, [r7, #0x2c]
 801dbe2: 681b         	ldr	r3, [r3]
 801dbe4: 4618         	mov	r0, r3
 801dbe6: f7eb fbc9    	bl	0x800937c <enabled_clock> @ imm = #-0x1486e
 801dbea: 62b8         	str	r0, [r7, #0x28]
; 	if (err < 0) {
 801dbec: 6abb         	ldr	r3, [r7, #0x28]
 801dbee: 2b00         	cmp	r3, #0x0
 801dbf0: da01         	bge	0x801dbf6 <stm32_clock_control_configure+0x26> @ imm = #0x2
; 		return err;
 801dbf2: 6abb         	ldr	r3, [r7, #0x28]
 801dbf4: e043         	b	0x801dc7e <stm32_clock_control_configure+0xae> @ imm = #0x86
; 	if (pclken->enr == NO_SEL) {
 801dbf6: 6afb         	ldr	r3, [r7, #0x2c]
 801dbf8: 685b         	ldr	r3, [r3, #0x4]
 801dbfa: 2bff         	cmp	r3, #0xff
 801dbfc: d101         	bne	0x801dc02 <stm32_clock_control_configure+0x32> @ imm = #0x2
; 		return 0;
 801dbfe: 2300         	movs	r3, #0x0
 801dc00: e03d         	b	0x801dc7e <stm32_clock_control_configure+0xae> @ imm = #0x7a
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 801dc02: 6afb         	ldr	r3, [r7, #0x2c]
 801dc04: 685b         	ldr	r3, [r3, #0x4]
 801dc06: b2db         	uxtb	r3, r3
 801dc08: f103 4380    	add.w	r3, r3, #0x40000000
 801dc0c: f503 330e    	add.w	r3, r3, #0x23800
; 		       STM32_CLOCK_MASK_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 801dc10: 6afa         	ldr	r2, [r7, #0x2c]
 801dc12: 6852         	ldr	r2, [r2, #0x4]
 801dc14: 0b52         	lsrs	r2, r2, #0xd
 801dc16: f002 0107    	and	r1, r2, #0x7
 801dc1a: 6afa         	ldr	r2, [r7, #0x2c]
 801dc1c: 6852         	ldr	r2, [r2, #0x4]
 801dc1e: 0a12         	lsrs	r2, r2, #0x8
 801dc20: f002 021f    	and	r2, r2, #0x1f
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 801dc24: fa01 f202    	lsl.w	r2, r1, r2
 801dc28: 61bb         	str	r3, [r7, #0x18]
 801dc2a: 617a         	str	r2, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801dc2c: 69bb         	ldr	r3, [r7, #0x18]
 801dc2e: 681b         	ldr	r3, [r3]
 801dc30: 613b         	str	r3, [r7, #0x10]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 801dc32: 697b         	ldr	r3, [r7, #0x14]
 801dc34: 43d9         	mvns	r1, r3
 801dc36: 69bb         	ldr	r3, [r7, #0x18]
 801dc38: 693a         	ldr	r2, [r7, #0x10]
 801dc3a: 400a         	ands	r2, r1
 801dc3c: 601a         	str	r2, [r3]
; }
 801dc3e: bf00         	nop
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 801dc40: 6afb         	ldr	r3, [r7, #0x2c]
 801dc42: 685b         	ldr	r3, [r3, #0x4]
 801dc44: b2db         	uxtb	r3, r3
 801dc46: f103 4380    	add.w	r3, r3, #0x40000000
 801dc4a: f503 330e    	add.w	r3, r3, #0x23800
; 		     STM32_CLOCK_VAL_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 801dc4e: 6afa         	ldr	r2, [r7, #0x2c]
 801dc50: 6852         	ldr	r2, [r2, #0x4]
 801dc52: 0c12         	lsrs	r2, r2, #0x10
 801dc54: f002 0107    	and	r1, r2, #0x7
 801dc58: 6afa         	ldr	r2, [r7, #0x2c]
 801dc5a: 6852         	ldr	r2, [r2, #0x4]
 801dc5c: 0a12         	lsrs	r2, r2, #0x8
 801dc5e: f002 021f    	and	r2, r2, #0x1f
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 801dc62: fa01 f202    	lsl.w	r2, r1, r2
 801dc66: 627b         	str	r3, [r7, #0x24]
 801dc68: 623a         	str	r2, [r7, #0x20]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801dc6a: 6a7b         	ldr	r3, [r7, #0x24]
 801dc6c: 681b         	ldr	r3, [r3]
 801dc6e: 61fb         	str	r3, [r7, #0x1c]
; 	*(volatile uint32_t *)addr = temp | mask;
 801dc70: 6a7b         	ldr	r3, [r7, #0x24]
 801dc72: 6a39         	ldr	r1, [r7, #0x20]
 801dc74: 69fa         	ldr	r2, [r7, #0x1c]
 801dc76: 430a         	orrs	r2, r1
 801dc78: 601a         	str	r2, [r3]
; }
 801dc7a: bf00         	nop
; 	return 0;
 801dc7c: 2300         	movs	r3, #0x0
; }
 801dc7e: 4618         	mov	r0, r3
 801dc80: 3730         	adds	r7, #0x30
 801dc82: 46bd         	mov	sp, r7
 801dc84: bd80         	pop	{r7, pc}

0801dc86 <stm32_clock_control_get_status>:
; {
 801dc86: b580         	push	{r7, lr}
 801dc88: b084         	sub	sp, #0x10
 801dc8a: af00         	add	r7, sp, #0x0
 801dc8c: 6078         	str	r0, [r7, #0x4]
 801dc8e: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)sub_system;
 801dc90: 683b         	ldr	r3, [r7]
 801dc92: 60fb         	str	r3, [r7, #0xc]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == true) {
 801dc94: 68fb         	ldr	r3, [r7, #0xc]
 801dc96: 681b         	ldr	r3, [r3]
 801dc98: 2b2f         	cmp	r3, #0x2f
 801dc9a: d905         	bls	0x801dca8 <stm32_clock_control_get_status+0x22> @ imm = #0xa
 801dc9c: 68fb         	ldr	r3, [r7, #0xc]
 801dc9e: 681b         	ldr	r3, [r3]
 801dca0: 2ba8         	cmp	r3, #0xa8
 801dca2: d801         	bhi	0x801dca8 <stm32_clock_control_get_status+0x22> @ imm = #0x2
 801dca4: 2301         	movs	r3, #0x1
 801dca6: e000         	b	0x801dcaa <stm32_clock_control_get_status+0x24> @ imm = #0x0
 801dca8: 2300         	movs	r3, #0x0
 801dcaa: 2b01         	cmp	r3, #0x1
 801dcac: d113         	bne	0x801dcd6 <stm32_clock_control_get_status+0x50> @ imm = #0x26
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 801dcae: 68fb         	ldr	r3, [r7, #0xc]
 801dcb0: 681b         	ldr	r3, [r3]
 801dcb2: f103 4380    	add.w	r3, r3, #0x40000000
 801dcb6: f503 330e    	add.w	r3, r3, #0x23800
 801dcba: 60bb         	str	r3, [r7, #0x8]
; 	return *(volatile uint32_t *)addr;
 801dcbc: 68bb         	ldr	r3, [r7, #0x8]
 801dcbe: 681a         	ldr	r2, [r3]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 801dcc0: 68fb         	ldr	r3, [r7, #0xc]
 801dcc2: 685b         	ldr	r3, [r3, #0x4]
 801dcc4: 401a         	ands	r2, r3
; 		    == pclken->enr) {
 801dcc6: 68fb         	ldr	r3, [r7, #0xc]
 801dcc8: 685b         	ldr	r3, [r3, #0x4]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 801dcca: 429a         	cmp	r2, r3
 801dccc: d101         	bne	0x801dcd2 <stm32_clock_control_get_status+0x4c> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 801dcce: 2302         	movs	r3, #0x2
 801dcd0: e00c         	b	0x801dcec <stm32_clock_control_get_status+0x66> @ imm = #0x18
; 			return CLOCK_CONTROL_STATUS_OFF;
 801dcd2: 2301         	movs	r3, #0x1
 801dcd4: e00a         	b	0x801dcec <stm32_clock_control_get_status+0x66> @ imm = #0x14
; 		if (enabled_clock(pclken->bus) == 0) {
 801dcd6: 68fb         	ldr	r3, [r7, #0xc]
 801dcd8: 681b         	ldr	r3, [r3]
 801dcda: 4618         	mov	r0, r3
 801dcdc: f7eb fb4e    	bl	0x800937c <enabled_clock> @ imm = #-0x14964
 801dce0: 4603         	mov	r3, r0
 801dce2: 2b00         	cmp	r3, #0x0
 801dce4: d101         	bne	0x801dcea <stm32_clock_control_get_status+0x64> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 801dce6: 2302         	movs	r3, #0x2
 801dce8: e000         	b	0x801dcec <stm32_clock_control_get_status+0x66> @ imm = #0x0
; 			return CLOCK_CONTROL_STATUS_OFF;
 801dcea: 2301         	movs	r3, #0x1
; }
 801dcec: 4618         	mov	r0, r3
 801dcee: 3710         	adds	r7, #0x10
 801dcf0: 46bd         	mov	sp, r7
 801dcf2: bd80         	pop	{r7, pc}

0801dcf4 <stm32_clock_switch_to_hsi>:
; {
 801dcf4: b580         	push	{r7, lr}
 801dcf6: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_HSI_IsReady() != 1) {
 801dcf8: f7eb fa6c    	bl	0x80091d4 <LL_RCC_HSI_IsReady> @ imm = #-0x14b28
 801dcfc: 4603         	mov	r3, r0
 801dcfe: 2b01         	cmp	r3, #0x1
 801dd00: d007         	beq	0x801dd12 <stm32_clock_switch_to_hsi+0x1e> @ imm = #0xe
; 		LL_RCC_HSI_Enable();
 801dd02: f7eb fa57    	bl	0x80091b4 <LL_RCC_HSI_Enable> @ imm = #-0x14b52
; 		while (LL_RCC_HSI_IsReady() != 1) {
 801dd06: bf00         	nop
 801dd08: f7eb fa64    	bl	0x80091d4 <LL_RCC_HSI_IsReady> @ imm = #-0x14b38
 801dd0c: 4603         	mov	r3, r0
 801dd0e: 2b01         	cmp	r3, #0x1
 801dd10: d1fa         	bne	0x801dd08 <stm32_clock_switch_to_hsi+0x14> @ imm = #-0xc
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);
 801dd12: 2000         	movs	r0, #0x0
 801dd14: f7eb fa92    	bl	0x800923c <LL_RCC_SetSysClkSource> @ imm = #-0x14adc
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI) {
 801dd18: bf00         	nop
 801dd1a: f7eb faa3    	bl	0x8009264 <LL_RCC_GetSysClkSource> @ imm = #-0x14aba
 801dd1e: 4603         	mov	r3, r0
 801dd20: 2b00         	cmp	r3, #0x0
 801dd22: d1fa         	bne	0x801dd1a <stm32_clock_switch_to_hsi+0x26> @ imm = #-0xc
; }
 801dd24: bf00         	nop
 801dd26: bf00         	nop
 801dd28: bd80         	pop	{r7, pc}

0801dd2a <set_up_fixed_clock_sources>:
; {
 801dd2a: b580         	push	{r7, lr}
 801dd2c: af00         	add	r7, sp, #0x0
; 			LL_RCC_HSE_DisableBypass();
 801dd2e: f7eb fa0d    	bl	0x800914c <LL_RCC_HSE_DisableBypass> @ imm = #-0x14be6
; 		LL_RCC_HSE_Enable();
 801dd32: f7eb fa1b    	bl	0x800916c <LL_RCC_HSE_Enable> @ imm = #-0x14bca
; 		while (LL_RCC_HSE_IsReady() != 1) {
 801dd36: bf00         	nop
 801dd38: f7eb fa28    	bl	0x800918c <LL_RCC_HSE_IsReady> @ imm = #-0x14bb0
 801dd3c: 4603         	mov	r3, r0
 801dd3e: 2b01         	cmp	r3, #0x1
 801dd40: d1fa         	bne	0x801dd38 <set_up_fixed_clock_sources+0xe> @ imm = #-0xc
; 		LL_RCC_LSI_Enable();
 801dd42: f7eb fa59    	bl	0x80091f8 <LL_RCC_LSI_Enable> @ imm = #-0x14b4e
; 		while (LL_RCC_LSI_IsReady() != 1) {
 801dd46: bf00         	nop
 801dd48: f7eb fa66    	bl	0x8009218 <LL_RCC_LSI_IsReady> @ imm = #-0x14b34
 801dd4c: 4603         	mov	r3, r0
 801dd4e: 2b01         	cmp	r3, #0x1
 801dd50: d1fa         	bne	0x801dd48 <set_up_fixed_clock_sources+0x1e> @ imm = #-0xc
; }
 801dd52: bf00         	nop
 801dd54: bf00         	nop
 801dd56: bd80         	pop	{r7, pc}

0801dd58 <config_regulator_voltage>:
; void __weak config_regulator_voltage(uint32_t hclk_freq) {}
 801dd58: b480         	push	{r7}
 801dd5a: b083         	sub	sp, #0xc
 801dd5c: af00         	add	r7, sp, #0x0
 801dd5e: 6078         	str	r0, [r7, #0x4]
 801dd60: bf00         	nop
 801dd62: 370c         	adds	r7, #0xc
 801dd64: 46bd         	mov	sp, r7
 801dd66: f85d 7b04    	ldr	r7, [sp], #4
 801dd6a: 4770         	bx	lr

0801dd6c <get_pll_source>:
; {
 801dd6c: b480         	push	{r7}
 801dd6e: af00         	add	r7, sp, #0x0
; 		return LL_RCC_PLLSOURCE_HSE;
 801dd70: f44f 0380    	mov.w	r3, #0x400000
; }
 801dd74: 4618         	mov	r0, r3
 801dd76: 46bd         	mov	sp, r7
 801dd78: f85d 7b04    	ldr	r7, [sp], #4
 801dd7c: 4770         	bx	lr

0801dd7e <config_pll_sysclock>:
; {
 801dd7e: b580         	push	{r7, lr}
 801dd80: af00         	add	r7, sp, #0x0
; 	LL_RCC_PLL_ConfigDomain_SYS(get_pll_source(),
 801dd82: f7ff fff3    	bl	0x801dd6c <get_pll_source> @ imm = #-0x1a
 801dd86: 2300         	movs	r3, #0x0
 801dd88: 22a8         	movs	r2, #0xa8
 801dd8a: 2106         	movs	r1, #0x6
 801dd8c: f7eb fcc8    	bl	0x8009720 <LL_RCC_PLL_ConfigDomain_SYS> @ imm = #-0x14670
; }
 801dd90: bf00         	nop
 801dd92: bd80         	pop	{r7, pc}

0801dd94 <config_enable_default_clocks>:
; {
 801dd94: b580         	push	{r7, lr}
 801dd96: af00         	add	r7, sp, #0x0
; 	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
 801dd98: f04f 5080    	mov.w	r0, #0x10000000
 801dd9c: f7eb fca8    	bl	0x80096f0 <LL_APB1_GRP1_EnableClock> @ imm = #-0x146b0
; }
 801dda0: bf00         	nop
 801dda2: bd80         	pop	{r7, pc}

0801dda4 <device_is_ready>:
; {
 801dda4: b580         	push	{r7, lr}
 801dda6: b082         	sub	sp, #0x8
 801dda8: af00         	add	r7, sp, #0x0
 801ddaa: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801ddac: 6878         	ldr	r0, [r7, #0x4]
 801ddae: f006 fbb8    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x6770
 801ddb2: 4603         	mov	r3, r0
; }
 801ddb4: 4618         	mov	r0, r3
 801ddb6: 3708         	adds	r7, #0x8
 801ddb8: 46bd         	mov	sp, r7
 801ddba: bd80         	pop	{r7, pc}

0801ddbc <z_impl_uart_poll_out>:
; {
 801ddbc: b580         	push	{r7, lr}
 801ddbe: b084         	sub	sp, #0x10
 801ddc0: af00         	add	r7, sp, #0x0
 801ddc2: 6078         	str	r0, [r7, #0x4]
 801ddc4: 460b         	mov	r3, r1
 801ddc6: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 801ddc8: 687b         	ldr	r3, [r7, #0x4]
 801ddca: 689b         	ldr	r3, [r3, #0x8]
 801ddcc: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 801ddce: 68fb         	ldr	r3, [r7, #0xc]
 801ddd0: 69db         	ldr	r3, [r3, #0x1c]
 801ddd2: 78fa         	ldrb	r2, [r7, #0x3]
 801ddd4: 4611         	mov	r1, r2
 801ddd6: 6878         	ldr	r0, [r7, #0x4]
 801ddd8: 4798         	blx	r3
; }
 801ddda: bf00         	nop
 801dddc: 3710         	adds	r7, #0x10
 801ddde: 46bd         	mov	sp, r7
 801dde0: bd80         	pop	{r7, pc}

0801dde2 <uart_poll_out>:
; {
 801dde2: b580         	push	{r7, lr}
 801dde4: b082         	sub	sp, #0x8
 801dde6: af00         	add	r7, sp, #0x0
 801dde8: 6078         	str	r0, [r7, #0x4]
 801ddea: 460b         	mov	r3, r1
 801ddec: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 801ddee: 78fb         	ldrb	r3, [r7, #0x3]
 801ddf0: 4619         	mov	r1, r3
 801ddf2: 6878         	ldr	r0, [r7, #0x4]
 801ddf4: f7ff ffe2    	bl	0x801ddbc <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 801ddf8: bf00         	nop
 801ddfa: 3708         	adds	r7, #0x8
 801ddfc: 46bd         	mov	sp, r7
 801ddfe: bd80         	pop	{r7, pc}

0801de00 <pm_device_runtime_get>:
; {
 801de00: b480         	push	{r7}
 801de02: b083         	sub	sp, #0xc
 801de04: af00         	add	r7, sp, #0x0
 801de06: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801de08: 2300         	movs	r3, #0x0
; }
 801de0a: 4618         	mov	r0, r3
 801de0c: 370c         	adds	r7, #0xc
 801de0e: 46bd         	mov	sp, r7
 801de10: f85d 7b04    	ldr	r7, [sp], #4
 801de14: 4770         	bx	lr

0801de16 <pm_device_runtime_put_async>:
; {
 801de16: b480         	push	{r7}
 801de18: b085         	sub	sp, #0x14
 801de1a: af00         	add	r7, sp, #0x0
 801de1c: 60f8         	str	r0, [r7, #0xc]
 801de1e: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 801de22: 2300         	movs	r3, #0x0
; }
 801de24: 4618         	mov	r0, r3
 801de26: 3714         	adds	r7, #0x14
 801de28: 46bd         	mov	sp, r7
 801de2a: f85d 7b04    	ldr	r7, [sp], #4
 801de2e: 4770         	bx	lr

0801de30 <device_is_ready>:
; {
 801de30: b580         	push	{r7, lr}
 801de32: b082         	sub	sp, #0x8
 801de34: af00         	add	r7, sp, #0x0
 801de36: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801de38: 6878         	ldr	r0, [r7, #0x4]
 801de3a: f006 fb72    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x66e4
 801de3e: 4603         	mov	r3, r0
; }
 801de40: 4618         	mov	r0, r3
 801de42: 3708         	adds	r7, #0x8
 801de44: 46bd         	mov	sp, r7
 801de46: bd80         	pop	{r7, pc}

0801de48 <k_sleep>:
; {
 801de48: b580         	push	{r7, lr}
 801de4a: b082         	sub	sp, #0x8
 801de4c: af00         	add	r7, sp, #0x0
 801de4e: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 801de52: e9d7 0100    	ldrd	r0, r1, [r7]
 801de56: f7f8 fa4b    	bl	0x80162f0 <z_impl_k_sleep> @ imm = #-0x7b6a
 801de5a: 4603         	mov	r3, r0
; }
 801de5c: 4618         	mov	r0, r3
 801de5e: 3708         	adds	r7, #0x8
 801de60: 46bd         	mov	sp, r7
 801de62: bd80         	pop	{r7, pc}

0801de64 <clock_control_on>:
; {
 801de64: b580         	push	{r7, lr}
 801de66: b084         	sub	sp, #0x10
 801de68: af00         	add	r7, sp, #0x0
 801de6a: 6078         	str	r0, [r7, #0x4]
 801de6c: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801de6e: 687b         	ldr	r3, [r7, #0x4]
 801de70: 689b         	ldr	r3, [r3, #0x8]
 801de72: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801de74: 68fb         	ldr	r3, [r7, #0xc]
 801de76: 681b         	ldr	r3, [r3]
 801de78: 6839         	ldr	r1, [r7]
 801de7a: 6878         	ldr	r0, [r7, #0x4]
 801de7c: 4798         	blx	r3
 801de7e: 4603         	mov	r3, r0
; }
 801de80: 4618         	mov	r0, r3
 801de82: 3710         	adds	r7, #0x10
 801de84: 46bd         	mov	sp, r7
 801de86: bd80         	pop	{r7, pc}

0801de88 <z_log_msg_runtime_create>:
; {
 801de88: b580         	push	{r7, lr}
 801de8a: b08a         	sub	sp, #0x28
 801de8c: af04         	add	r7, sp, #0x10
 801de8e: 60b9         	str	r1, [r7, #0x8]
 801de90: 607b         	str	r3, [r7, #0x4]
 801de92: 4603         	mov	r3, r0
 801de94: 73fb         	strb	r3, [r7, #0xf]
 801de96: 4613         	mov	r3, r2
 801de98: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801de9a: f107 032c    	add.w	r3, r7, #0x2c
 801de9e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801dea0: 7bba         	ldrb	r2, [r7, #0xe]
 801dea2: 7bf8         	ldrb	r0, [r7, #0xf]
 801dea4: 697b         	ldr	r3, [r7, #0x14]
 801dea6: 9303         	str	r3, [sp, #0xc]
 801dea8: 6abb         	ldr	r3, [r7, #0x28]
 801deaa: 9302         	str	r3, [sp, #0x8]
 801deac: 6a7b         	ldr	r3, [r7, #0x24]
 801deae: 9301         	str	r3, [sp, #0x4]
 801deb0: 6a3b         	ldr	r3, [r7, #0x20]
 801deb2: 9300         	str	r3, [sp]
 801deb4: 687b         	ldr	r3, [r7, #0x4]
 801deb6: 68b9         	ldr	r1, [r7, #0x8]
 801deb8: f7e6 fe44    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x19378
; }
 801debc: bf00         	nop
 801debe: 3718         	adds	r7, #0x18
 801dec0: 46bd         	mov	sp, r7
 801dec2: bd80         	pop	{r7, pc}

0801dec4 <dma_stm32_dump_stream_irq>:
; {
 801dec4: b580         	push	{r7, lr}
 801dec6: b084         	sub	sp, #0x10
 801dec8: af00         	add	r7, sp, #0x0
 801deca: 6078         	str	r0, [r7, #0x4]
 801decc: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801dece: 687b         	ldr	r3, [r7, #0x4]
 801ded0: 685b         	ldr	r3, [r3, #0x4]
 801ded2: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801ded4: 68fb         	ldr	r3, [r7, #0xc]
 801ded6: 691b         	ldr	r3, [r3, #0x10]
 801ded8: 60bb         	str	r3, [r7, #0x8]
; 	stm32_dma_dump_stream_irq(dma, id);
 801deda: 6839         	ldr	r1, [r7]
 801dedc: 68b8         	ldr	r0, [r7, #0x8]
 801dede: f7ec fe81    	bl	0x800abe4 <stm32_dma_dump_stream_irq> @ imm = #-0x132fe
; }
 801dee2: bf00         	nop
 801dee4: 3710         	adds	r7, #0x10
 801dee6: 46bd         	mov	sp, r7
 801dee8: bd80         	pop	{r7, pc}

0801deea <dma_stm32_clear_stream_irq>:
; {
 801deea: b580         	push	{r7, lr}
 801deec: b084         	sub	sp, #0x10
 801deee: af00         	add	r7, sp, #0x0
 801def0: 6078         	str	r0, [r7, #0x4]
 801def2: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801def4: 687b         	ldr	r3, [r7, #0x4]
 801def6: 685b         	ldr	r3, [r3, #0x4]
 801def8: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801defa: 68fb         	ldr	r3, [r7, #0xc]
 801defc: 691b         	ldr	r3, [r3, #0x10]
 801defe: 60bb         	str	r3, [r7, #0x8]
; 	dma_stm32_clear_tc(dma, id);
 801df00: 6839         	ldr	r1, [r7]
 801df02: 68b8         	ldr	r0, [r7, #0x8]
 801df04: f7ec fdae    	bl	0x800aa64 <dma_stm32_clear_tc> @ imm = #-0x134a4
; 	dma_stm32_clear_ht(dma, id);
 801df08: 6839         	ldr	r1, [r7]
 801df0a: 68b8         	ldr	r0, [r7, #0x8]
 801df0c: f7ec fd98    	bl	0x800aa40 <dma_stm32_clear_ht> @ imm = #-0x134d0
; 	stm32_dma_clear_stream_irq(dma, id);
 801df10: 6839         	ldr	r1, [r7]
 801df12: 68b8         	ldr	r0, [r7, #0x8]
 801df14: f001 f843    	bl	0x801ef9e <stm32_dma_clear_stream_irq> @ imm = #0x1086
; }
 801df18: bf00         	nop
 801df1a: 3710         	adds	r7, #0x10
 801df1c: 46bd         	mov	sp, r7
 801df1e: bd80         	pop	{r7, pc}

0801df20 <dma_stm32_disable_stream>:
; {
 801df20: b580         	push	{r7, lr}
 801df22: b084         	sub	sp, #0x10
 801df24: af00         	add	r7, sp, #0x0
 801df26: 6078         	str	r0, [r7, #0x4]
 801df28: 6039         	str	r1, [r7]
; 	int count = 0;
 801df2a: 2300         	movs	r3, #0x0
 801df2c: 60fb         	str	r3, [r7, #0xc]
; 		if (stm32_dma_disable_stream(dma, id) == 0) {
 801df2e: 6839         	ldr	r1, [r7]
 801df30: 6878         	ldr	r0, [r7, #0x4]
 801df32: f001 f871    	bl	0x801f018 <stm32_dma_disable_stream> @ imm = #0x10e2
 801df36: 4603         	mov	r3, r0
 801df38: 2b00         	cmp	r3, #0x0
 801df3a: d101         	bne	0x801df40 <dma_stm32_disable_stream+0x20> @ imm = #0x2
; 			return 0;
 801df3c: 2100         	movs	r1, #0x0
 801df3e: e012         	b	0x801df66 <dma_stm32_disable_stream+0x46> @ imm = #0x24
; 		if (count++ > (5 * 1000)) {
 801df40: 68fb         	ldr	r3, [r7, #0xc]
 801df42: 1c5a         	adds	r2, r3, #0x1
 801df44: 60fa         	str	r2, [r7, #0xc]
 801df46: f241 3288    	movw	r2, #0x1388
 801df4a: 4293         	cmp	r3, r2
 801df4c: dd02         	ble	0x801df54 <dma_stm32_disable_stream+0x34> @ imm = #0x4
; 			return -EBUSY;
 801df4e: f06f 010f    	mvn	r1, #0xf
 801df52: e008         	b	0x801df66 <dma_stm32_disable_stream+0x46> @ imm = #0x10
; 		k_sleep(K_MSEC(1));
 801df54: f04f 020a    	mov.w	r2, #0xa
 801df58: f04f 0300    	mov.w	r3, #0x0
 801df5c: 4610         	mov	r0, r2
 801df5e: 4619         	mov	r1, r3
 801df60: f7ff ff72    	bl	0x801de48 <k_sleep>     @ imm = #-0x11c
; 	for (;;) {
 801df64: e7e3         	b	0x801df2e <dma_stm32_disable_stream+0xe> @ imm = #-0x3a
; }
 801df66: 460b         	mov	r3, r1
 801df68: 4618         	mov	r0, r3
 801df6a: 3710         	adds	r7, #0x10
 801df6c: 46bd         	mov	sp, r7
 801df6e: bd80         	pop	{r7, pc}

0801df70 <dma_stm32_reload>:
; {
 801df70: b580         	push	{r7, lr}
 801df72: b088         	sub	sp, #0x20
 801df74: af00         	add	r7, sp, #0x0
 801df76: 60f8         	str	r0, [r7, #0xc]
 801df78: 60b9         	str	r1, [r7, #0x8]
 801df7a: 607a         	str	r2, [r7, #0x4]
 801df7c: 603b         	str	r3, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801df7e: 68fb         	ldr	r3, [r7, #0xc]
 801df80: 685b         	ldr	r3, [r3, #0x4]
 801df82: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801df84: 69fb         	ldr	r3, [r7, #0x1c]
 801df86: 691b         	ldr	r3, [r3, #0x10]
 801df88: 61bb         	str	r3, [r7, #0x18]
; 	if (id >= config->max_streams) {
 801df8a: 69fb         	ldr	r3, [r7, #0x1c]
 801df8c: 695b         	ldr	r3, [r3, #0x14]
 801df8e: 68ba         	ldr	r2, [r7, #0x8]
 801df90: 429a         	cmp	r2, r3
 801df92: d302         	blo	0x801df9a <dma_stm32_reload+0x2a> @ imm = #0x4
; 		return -EINVAL;
 801df94: f06f 0315    	mvn	r3, #0x15
 801df98: e06c         	b	0x801e074 <dma_stm32_reload+0x104> @ imm = #0xd8
; 	stream = &config->streams[id];
 801df9a: 69fb         	ldr	r3, [r7, #0x1c]
 801df9c: 6999         	ldr	r1, [r3, #0x18]
 801df9e: 68ba         	ldr	r2, [r7, #0x8]
 801dfa0: 4613         	mov	r3, r2
 801dfa2: 00db         	lsls	r3, r3, #0x3
 801dfa4: 1a9b         	subs	r3, r3, r2
 801dfa6: 009b         	lsls	r3, r3, #0x2
 801dfa8: 440b         	add	r3, r1
 801dfaa: 617b         	str	r3, [r7, #0x14]
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 801dfac: 68b9         	ldr	r1, [r7, #0x8]
 801dfae: 69b8         	ldr	r0, [r7, #0x18]
 801dfb0: f7ff ffb6    	bl	0x801df20 <dma_stm32_disable_stream> @ imm = #-0x94
 801dfb4: 4603         	mov	r3, r0
 801dfb6: 2b00         	cmp	r3, #0x0
 801dfb8: d002         	beq	0x801dfc0 <dma_stm32_reload+0x50> @ imm = #0x4
; 		return -EBUSY;
 801dfba: f06f 030f    	mvn	r3, #0xf
 801dfbe: e059         	b	0x801e074 <dma_stm32_reload+0x104> @ imm = #0xb2
; 	switch (stream->direction) {
 801dfc0: 697b         	ldr	r3, [r7, #0x14]
 801dfc2: 681b         	ldr	r3, [r3]
 801dfc4: 2b02         	cmp	r3, #0x2
 801dfc6: d018         	beq	0x801dffa <dma_stm32_reload+0x8a> @ imm = #0x30
 801dfc8: 2b02         	cmp	r3, #0x2
 801dfca: d829         	bhi	0x801e020 <dma_stm32_reload+0xb0> @ imm = #0x52
 801dfcc: 2b00         	cmp	r3, #0x0
 801dfce: d014         	beq	0x801dffa <dma_stm32_reload+0x8a> @ imm = #0x28
 801dfd0: 2b01         	cmp	r3, #0x1
 801dfd2: d125         	bne	0x801e020 <dma_stm32_reload+0xb0> @ imm = #0x4a
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), src);
 801dfd4: 68b8         	ldr	r0, [r7, #0x8]
 801dfd6: f7ec fd13    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x135da
 801dfda: 4603         	mov	r3, r0
 801dfdc: 687a         	ldr	r2, [r7, #0x4]
 801dfde: 4619         	mov	r1, r3
 801dfe0: 69b8         	ldr	r0, [r7, #0x18]
 801dfe2: f7eb fc95    	bl	0x8009910 <LL_DMA_SetMemoryAddress> @ imm = #-0x146d6
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), dst);
 801dfe6: 68b8         	ldr	r0, [r7, #0x8]
 801dfe8: f7ec fd0a    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x135ec
 801dfec: 4603         	mov	r3, r0
 801dfee: 683a         	ldr	r2, [r7]
 801dff0: 4619         	mov	r1, r3
 801dff2: 69b8         	ldr	r0, [r7, #0x18]
 801dff4: f7eb fca4    	bl	0x8009940 <LL_DMA_SetPeriphAddress> @ imm = #-0x146b8
; 		break;
 801dff8: e015         	b	0x801e026 <dma_stm32_reload+0xb6> @ imm = #0x2a
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), src);
 801dffa: 68b8         	ldr	r0, [r7, #0x8]
 801dffc: f7ec fd00    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x13600
 801e000: 4603         	mov	r3, r0
 801e002: 687a         	ldr	r2, [r7, #0x4]
 801e004: 4619         	mov	r1, r3
 801e006: 69b8         	ldr	r0, [r7, #0x18]
 801e008: f7eb fc9a    	bl	0x8009940 <LL_DMA_SetPeriphAddress> @ imm = #-0x146cc
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), dst);
 801e00c: 68b8         	ldr	r0, [r7, #0x8]
 801e00e: f7ec fcf7    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x13612
 801e012: 4603         	mov	r3, r0
 801e014: 683a         	ldr	r2, [r7]
 801e016: 4619         	mov	r1, r3
 801e018: 69b8         	ldr	r0, [r7, #0x18]
 801e01a: f7eb fc79    	bl	0x8009910 <LL_DMA_SetMemoryAddress> @ imm = #-0x1470e
; 		break;
 801e01e: e002         	b	0x801e026 <dma_stm32_reload+0xb6> @ imm = #0x4
; 		return -EINVAL;
 801e020: f06f 0315    	mvn	r3, #0x15
 801e024: e026         	b	0x801e074 <dma_stm32_reload+0x104> @ imm = #0x4c
; 	if (stream->source_periph) {
 801e026: 697b         	ldr	r3, [r7, #0x14]
 801e028: 791b         	ldrb	r3, [r3, #0x4]
 801e02a: 2b00         	cmp	r3, #0x0
 801e02c: d00d         	beq	0x801e04a <dma_stm32_reload+0xda> @ imm = #0x1a
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 801e02e: 68b8         	ldr	r0, [r7, #0x8]
 801e030: f7ec fce6    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x13634
 801e034: 4601         	mov	r1, r0
; 				     size / stream->src_size);
 801e036: 697b         	ldr	r3, [r7, #0x14]
 801e038: 689b         	ldr	r3, [r3, #0x8]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 801e03a: 6aba         	ldr	r2, [r7, #0x28]
 801e03c: fbb2 f3f3    	udiv	r3, r2, r3
 801e040: 461a         	mov	r2, r3
 801e042: 69b8         	ldr	r0, [r7, #0x18]
 801e044: f7eb fbea    	bl	0x800981c <LL_DMA_SetDataLength> @ imm = #-0x1482c
 801e048: e00c         	b	0x801e064 <dma_stm32_reload+0xf4> @ imm = #0x18
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 801e04a: 68b8         	ldr	r0, [r7, #0x8]
 801e04c: f7ec fcd8    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x13650
 801e050: 4601         	mov	r1, r0
; 				     size / stream->dst_size);
 801e052: 697b         	ldr	r3, [r7, #0x14]
 801e054: 68db         	ldr	r3, [r3, #0xc]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 801e056: 6aba         	ldr	r2, [r7, #0x28]
 801e058: fbb2 f3f3    	udiv	r3, r2, r3
 801e05c: 461a         	mov	r2, r3
 801e05e: 69b8         	ldr	r0, [r7, #0x18]
 801e060: f7eb fbdc    	bl	0x800981c <LL_DMA_SetDataLength> @ imm = #-0x14848
; 	stream->busy = true;
 801e064: 697b         	ldr	r3, [r7, #0x14]
 801e066: 2201         	movs	r2, #0x1
 801e068: 719a         	strb	r2, [r3, #0x6]
; 	stm32_dma_enable_stream(dma, id);
 801e06a: 68b9         	ldr	r1, [r7, #0x8]
 801e06c: 69b8         	ldr	r0, [r7, #0x18]
 801e06e: f000 ffab    	bl	0x801efc8 <stm32_dma_enable_stream> @ imm = #0xf56
; 	return 0;
 801e072: 2300         	movs	r3, #0x0
; }
 801e074: 4618         	mov	r0, r3
 801e076: 3720         	adds	r7, #0x20
 801e078: 46bd         	mov	sp, r7
 801e07a: bd80         	pop	{r7, pc}

0801e07c <dma_stm32_start>:
; {
 801e07c: b580         	push	{r7, lr}
 801e07e: b086         	sub	sp, #0x18
 801e080: af00         	add	r7, sp, #0x0
 801e082: 6078         	str	r0, [r7, #0x4]
 801e084: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801e086: 687b         	ldr	r3, [r7, #0x4]
 801e088: 685b         	ldr	r3, [r3, #0x4]
 801e08a: 617b         	str	r3, [r7, #0x14]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801e08c: 697b         	ldr	r3, [r7, #0x14]
 801e08e: 691b         	ldr	r3, [r3, #0x10]
 801e090: 613b         	str	r3, [r7, #0x10]
; 	if (id >= config->max_streams) {
 801e092: 697b         	ldr	r3, [r7, #0x14]
 801e094: 695b         	ldr	r3, [r3, #0x14]
 801e096: 683a         	ldr	r2, [r7]
 801e098: 429a         	cmp	r2, r3
 801e09a: d302         	blo	0x801e0a2 <dma_stm32_start+0x26> @ imm = #0x4
; 		return -EINVAL;
 801e09c: f06f 0315    	mvn	r3, #0x15
 801e0a0: e01d         	b	0x801e0de <dma_stm32_start+0x62> @ imm = #0x3a
; 	if (stm32_dma_is_enabled_stream(dma, id)) {
 801e0a2: 6839         	ldr	r1, [r7]
 801e0a4: 6938         	ldr	r0, [r7, #0x10]
 801e0a6: f000 ffa0    	bl	0x801efea <stm32_dma_is_enabled_stream> @ imm = #0xf40
 801e0aa: 4603         	mov	r3, r0
 801e0ac: 2b00         	cmp	r3, #0x0
 801e0ae: d001         	beq	0x801e0b4 <dma_stm32_start+0x38> @ imm = #0x2
; 		return 0;
 801e0b0: 2300         	movs	r3, #0x0
 801e0b2: e014         	b	0x801e0de <dma_stm32_start+0x62> @ imm = #0x28
; 	stream = &config->streams[id];
 801e0b4: 697b         	ldr	r3, [r7, #0x14]
 801e0b6: 6999         	ldr	r1, [r3, #0x18]
 801e0b8: 683a         	ldr	r2, [r7]
 801e0ba: 4613         	mov	r3, r2
 801e0bc: 00db         	lsls	r3, r3, #0x3
 801e0be: 1a9b         	subs	r3, r3, r2
 801e0c0: 009b         	lsls	r3, r3, #0x2
 801e0c2: 440b         	add	r3, r1
 801e0c4: 60fb         	str	r3, [r7, #0xc]
; 	stream->busy = true;
 801e0c6: 68fb         	ldr	r3, [r7, #0xc]
 801e0c8: 2201         	movs	r2, #0x1
 801e0ca: 719a         	strb	r2, [r3, #0x6]
; 	dma_stm32_clear_stream_irq(dev, id);
 801e0cc: 6839         	ldr	r1, [r7]
 801e0ce: 6878         	ldr	r0, [r7, #0x4]
 801e0d0: f7ff ff0b    	bl	0x801deea <dma_stm32_clear_stream_irq> @ imm = #-0x1ea
; 	stm32_dma_enable_stream(dma, id);
 801e0d4: 6839         	ldr	r1, [r7]
 801e0d6: 6938         	ldr	r0, [r7, #0x10]
 801e0d8: f000 ff76    	bl	0x801efc8 <stm32_dma_enable_stream> @ imm = #0xeec
; 	return 0;
 801e0dc: 2300         	movs	r3, #0x0
; }
 801e0de: 4618         	mov	r0, r3
 801e0e0: 3718         	adds	r7, #0x18
 801e0e2: 46bd         	mov	sp, r7
 801e0e4: bd80         	pop	{r7, pc}

0801e0e6 <dma_stm32_stop>:
; {
 801e0e6: b580         	push	{r7, lr}
 801e0e8: b086         	sub	sp, #0x18
 801e0ea: af00         	add	r7, sp, #0x0
 801e0ec: 6078         	str	r0, [r7, #0x4]
 801e0ee: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801e0f0: 687b         	ldr	r3, [r7, #0x4]
 801e0f2: 685b         	ldr	r3, [r3, #0x4]
 801e0f4: 617b         	str	r3, [r7, #0x14]
; 	struct dma_stm32_stream *stream = &config->streams[id - STM32_DMA_STREAM_OFFSET];
 801e0f6: 697b         	ldr	r3, [r7, #0x14]
 801e0f8: 6999         	ldr	r1, [r3, #0x18]
 801e0fa: 683a         	ldr	r2, [r7]
 801e0fc: 4613         	mov	r3, r2
 801e0fe: 00db         	lsls	r3, r3, #0x3
 801e100: 1a9b         	subs	r3, r3, r2
 801e102: 009b         	lsls	r3, r3, #0x2
 801e104: 440b         	add	r3, r1
 801e106: 613b         	str	r3, [r7, #0x10]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801e108: 697b         	ldr	r3, [r7, #0x14]
 801e10a: 691b         	ldr	r3, [r3, #0x10]
 801e10c: 60fb         	str	r3, [r7, #0xc]
; 	if (id >= config->max_streams) {
 801e10e: 697b         	ldr	r3, [r7, #0x14]
 801e110: 695b         	ldr	r3, [r3, #0x14]
 801e112: 683a         	ldr	r2, [r7]
 801e114: 429a         	cmp	r2, r3
 801e116: d302         	blo	0x801e11e <dma_stm32_stop+0x38> @ imm = #0x4
; 		return -EINVAL;
 801e118: f06f 0315    	mvn	r3, #0x15
 801e11c: e02c         	b	0x801e178 <dma_stm32_stop+0x92> @ imm = #0x58
; 	if (stream->hal_override) {
 801e11e: 693b         	ldr	r3, [r7, #0x10]
 801e120: 795b         	ldrb	r3, [r3, #0x5]
 801e122: 2b00         	cmp	r3, #0x0
 801e124: d004         	beq	0x801e130 <dma_stm32_stop+0x4a> @ imm = #0x8
; 		stream->busy = false;
 801e126: 693b         	ldr	r3, [r7, #0x10]
 801e128: 2200         	movs	r2, #0x0
 801e12a: 719a         	strb	r2, [r3, #0x6]
; 		return 0;
 801e12c: 2300         	movs	r3, #0x0
 801e12e: e023         	b	0x801e178 <dma_stm32_stop+0x92> @ imm = #0x46
; 	if (!stm32_dma_is_enabled_stream(dma, id)) {
 801e130: 6839         	ldr	r1, [r7]
 801e132: 68f8         	ldr	r0, [r7, #0xc]
 801e134: f000 ff59    	bl	0x801efea <stm32_dma_is_enabled_stream> @ imm = #0xeb2
 801e138: 4603         	mov	r3, r0
 801e13a: f083 0301    	eor	r3, r3, #0x1
 801e13e: b2db         	uxtb	r3, r3
 801e140: 2b00         	cmp	r3, #0x0
 801e142: d001         	beq	0x801e148 <dma_stm32_stop+0x62> @ imm = #0x2
; 		return 0;
 801e144: 2300         	movs	r3, #0x0
 801e146: e017         	b	0x801e178 <dma_stm32_stop+0x92> @ imm = #0x2e
; 	LL_DMA_DisableIT_TC(dma, dma_stm32_id_to_stream(id));
 801e148: 6838         	ldr	r0, [r7]
 801e14a: f7ec fc59    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x1374e
 801e14e: 4603         	mov	r3, r0
 801e150: 4619         	mov	r1, r3
 801e152: 68f8         	ldr	r0, [r7, #0xc]
 801e154: f7eb fc6c    	bl	0x8009a30 <LL_DMA_DisableIT_TC> @ imm = #-0x14728
; 	stm32_dma_disable_fifo_irq(dma, id);
 801e158: 6839         	ldr	r1, [r7]
 801e15a: 68f8         	ldr	r0, [r7, #0xc]
 801e15c: f000 ff7a    	bl	0x801f054 <stm32_dma_disable_fifo_irq> @ imm = #0xef4
; 	dma_stm32_clear_stream_irq(dev, id);
 801e160: 6839         	ldr	r1, [r7]
 801e162: 6878         	ldr	r0, [r7, #0x4]
 801e164: f7ff fec1    	bl	0x801deea <dma_stm32_clear_stream_irq> @ imm = #-0x27e
; 	dma_stm32_disable_stream(dma, id);
 801e168: 6839         	ldr	r1, [r7]
 801e16a: 68f8         	ldr	r0, [r7, #0xc]
 801e16c: f7ff fed8    	bl	0x801df20 <dma_stm32_disable_stream> @ imm = #-0x250
; 	stream->busy = false;
 801e170: 693b         	ldr	r3, [r7, #0x10]
 801e172: 2200         	movs	r2, #0x0
 801e174: 719a         	strb	r2, [r3, #0x6]
; 	return 0;
 801e176: 2300         	movs	r3, #0x0
; }
 801e178: 4618         	mov	r0, r3
 801e17a: 3718         	adds	r7, #0x18
 801e17c: 46bd         	mov	sp, r7
 801e17e: bd80         	pop	{r7, pc}

0801e180 <dma_stm32_get_status>:
; {
 801e180: b580         	push	{r7, lr}
 801e182: b088         	sub	sp, #0x20
 801e184: af00         	add	r7, sp, #0x0
 801e186: 60f8         	str	r0, [r7, #0xc]
 801e188: 60b9         	str	r1, [r7, #0x8]
 801e18a: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 801e18c: 68fb         	ldr	r3, [r7, #0xc]
 801e18e: 685b         	ldr	r3, [r3, #0x4]
 801e190: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801e192: 69fb         	ldr	r3, [r7, #0x1c]
 801e194: 691b         	ldr	r3, [r3, #0x10]
 801e196: 61bb         	str	r3, [r7, #0x18]
; 	if (id >= config->max_streams) {
 801e198: 69fb         	ldr	r3, [r7, #0x1c]
 801e19a: 695b         	ldr	r3, [r3, #0x14]
 801e19c: 68ba         	ldr	r2, [r7, #0x8]
 801e19e: 429a         	cmp	r2, r3
 801e1a0: d302         	blo	0x801e1a8 <dma_stm32_get_status+0x28> @ imm = #0x4
; 		return -EINVAL;
 801e1a2: f06f 0315    	mvn	r3, #0x15
 801e1a6: e01e         	b	0x801e1e6 <dma_stm32_get_status+0x66> @ imm = #0x3c
; 	stream = &config->streams[id];
 801e1a8: 69fb         	ldr	r3, [r7, #0x1c]
 801e1aa: 6999         	ldr	r1, [r3, #0x18]
 801e1ac: 68ba         	ldr	r2, [r7, #0x8]
 801e1ae: 4613         	mov	r3, r2
 801e1b0: 00db         	lsls	r3, r3, #0x3
 801e1b2: 1a9b         	subs	r3, r3, r2
 801e1b4: 009b         	lsls	r3, r3, #0x2
 801e1b6: 440b         	add	r3, r1
 801e1b8: 617b         	str	r3, [r7, #0x14]
; 	stat->pending_length = LL_DMA_GetDataLength(dma, dma_stm32_id_to_stream(id));
 801e1ba: 68b8         	ldr	r0, [r7, #0x8]
 801e1bc: f7ec fc20    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x137c0
 801e1c0: 4603         	mov	r3, r0
 801e1c2: 4619         	mov	r1, r3
 801e1c4: 69b8         	ldr	r0, [r7, #0x18]
 801e1c6: f7eb fb4d    	bl	0x8009864 <LL_DMA_GetDataLength> @ imm = #-0x14966
 801e1ca: 4602         	mov	r2, r0
 801e1cc: 687b         	ldr	r3, [r7, #0x4]
 801e1ce: 605a         	str	r2, [r3, #0x4]
; 	stat->dir = stream->direction;
 801e1d0: 697b         	ldr	r3, [r7, #0x14]
 801e1d2: 681b         	ldr	r3, [r3]
 801e1d4: b2da         	uxtb	r2, r3
 801e1d6: 687b         	ldr	r3, [r7, #0x4]
 801e1d8: 705a         	strb	r2, [r3, #0x1]
; 	stat->busy = stream->busy;
 801e1da: 697b         	ldr	r3, [r7, #0x14]
 801e1dc: 799b         	ldrb	r3, [r3, #0x6]
 801e1de: b2da         	uxtb	r2, r3
 801e1e0: 687b         	ldr	r3, [r7, #0x4]
 801e1e2: 701a         	strb	r2, [r3]
; 	return 0;
 801e1e4: 2300         	movs	r3, #0x0
; }
 801e1e6: 4618         	mov	r0, r3
 801e1e8: 3720         	adds	r7, #0x20
 801e1ea: 46bd         	mov	sp, r7
 801e1ec: bd80         	pop	{r7, pc}

0801e1ee <dma_stm32_irq_0_0>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 0);
 801e1ee: b580         	push	{r7, lr}
 801e1f0: b082         	sub	sp, #0x8
 801e1f2: af00         	add	r7, sp, #0x0
 801e1f4: 6078         	str	r0, [r7, #0x4]
 801e1f6: 2100         	movs	r1, #0x0
 801e1f8: 6878         	ldr	r0, [r7, #0x4]
 801e1fa: f7eb fc59    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x1474e
 801e1fe: 3708         	adds	r7, #0x8
 801e200: 46bd         	mov	sp, r7
 801e202: bd80         	pop	{r7, pc}

0801e204 <dma_stm32_irq_0_1>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 1);
 801e204: b580         	push	{r7, lr}
 801e206: b082         	sub	sp, #0x8
 801e208: af00         	add	r7, sp, #0x0
 801e20a: 6078         	str	r0, [r7, #0x4]
 801e20c: 2101         	movs	r1, #0x1
 801e20e: 6878         	ldr	r0, [r7, #0x4]
 801e210: f7eb fc4e    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x14764
 801e214: 3708         	adds	r7, #0x8
 801e216: 46bd         	mov	sp, r7
 801e218: bd80         	pop	{r7, pc}

0801e21a <dma_stm32_irq_0_2>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 2);
 801e21a: b580         	push	{r7, lr}
 801e21c: b082         	sub	sp, #0x8
 801e21e: af00         	add	r7, sp, #0x0
 801e220: 6078         	str	r0, [r7, #0x4]
 801e222: 2102         	movs	r1, #0x2
 801e224: 6878         	ldr	r0, [r7, #0x4]
 801e226: f7eb fc43    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x1477a
 801e22a: 3708         	adds	r7, #0x8
 801e22c: 46bd         	mov	sp, r7
 801e22e: bd80         	pop	{r7, pc}

0801e230 <dma_stm32_irq_0_3>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 3);
 801e230: b580         	push	{r7, lr}
 801e232: b082         	sub	sp, #0x8
 801e234: af00         	add	r7, sp, #0x0
 801e236: 6078         	str	r0, [r7, #0x4]
 801e238: 2103         	movs	r1, #0x3
 801e23a: 6878         	ldr	r0, [r7, #0x4]
 801e23c: f7eb fc38    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x14790
 801e240: 3708         	adds	r7, #0x8
 801e242: 46bd         	mov	sp, r7
 801e244: bd80         	pop	{r7, pc}

0801e246 <dma_stm32_irq_0_4>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 4);
 801e246: b580         	push	{r7, lr}
 801e248: b082         	sub	sp, #0x8
 801e24a: af00         	add	r7, sp, #0x0
 801e24c: 6078         	str	r0, [r7, #0x4]
 801e24e: 2104         	movs	r1, #0x4
 801e250: 6878         	ldr	r0, [r7, #0x4]
 801e252: f7eb fc2d    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x147a6
 801e256: 3708         	adds	r7, #0x8
 801e258: 46bd         	mov	sp, r7
 801e25a: bd80         	pop	{r7, pc}

0801e25c <dma_stm32_irq_0_5>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 5);
 801e25c: b580         	push	{r7, lr}
 801e25e: b082         	sub	sp, #0x8
 801e260: af00         	add	r7, sp, #0x0
 801e262: 6078         	str	r0, [r7, #0x4]
 801e264: 2105         	movs	r1, #0x5
 801e266: 6878         	ldr	r0, [r7, #0x4]
 801e268: f7eb fc22    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x147bc
 801e26c: 3708         	adds	r7, #0x8
 801e26e: 46bd         	mov	sp, r7
 801e270: bd80         	pop	{r7, pc}

0801e272 <dma_stm32_irq_0_6>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 6);
 801e272: b580         	push	{r7, lr}
 801e274: b082         	sub	sp, #0x8
 801e276: af00         	add	r7, sp, #0x0
 801e278: 6078         	str	r0, [r7, #0x4]
 801e27a: 2106         	movs	r1, #0x6
 801e27c: 6878         	ldr	r0, [r7, #0x4]
 801e27e: f7eb fc17    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x147d2
 801e282: 3708         	adds	r7, #0x8
 801e284: 46bd         	mov	sp, r7
 801e286: bd80         	pop	{r7, pc}

0801e288 <dma_stm32_irq_0_7>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 7);
 801e288: b580         	push	{r7, lr}
 801e28a: b082         	sub	sp, #0x8
 801e28c: af00         	add	r7, sp, #0x0
 801e28e: 6078         	str	r0, [r7, #0x4]
 801e290: 2107         	movs	r1, #0x7
 801e292: 6878         	ldr	r0, [r7, #0x4]
 801e294: f7eb fc0c    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x147e8
 801e298: 3708         	adds	r7, #0x8
 801e29a: 46bd         	mov	sp, r7
 801e29c: bd80         	pop	{r7, pc}

0801e29e <dma_stm32_config_irq_0>:
; {
 801e29e: b580         	push	{r7, lr}
 801e2a0: b082         	sub	sp, #0x8
 801e2a2: af00         	add	r7, sp, #0x0
 801e2a4: 6078         	str	r0, [r7, #0x4]
; 	LISTIFY(
 801e2a6: 2200         	movs	r2, #0x0
 801e2a8: 2100         	movs	r1, #0x0
 801e2aa: 200b         	movs	r0, #0xb
 801e2ac: f7fe f88c    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1ee8
 801e2b0: 200b         	movs	r0, #0xb
 801e2b2: f7fe f87c    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x1f08
 801e2b6: 2200         	movs	r2, #0x0
 801e2b8: 2100         	movs	r1, #0x0
 801e2ba: 200c         	movs	r0, #0xc
 801e2bc: f7fe f884    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1ef8
 801e2c0: 200c         	movs	r0, #0xc
 801e2c2: f7fe f874    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x1f18
 801e2c6: 2200         	movs	r2, #0x0
 801e2c8: 2100         	movs	r1, #0x0
 801e2ca: 200d         	movs	r0, #0xd
 801e2cc: f7fe f87c    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1f08
 801e2d0: 200d         	movs	r0, #0xd
 801e2d2: f7fe f86c    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x1f28
 801e2d6: 2200         	movs	r2, #0x0
 801e2d8: 2100         	movs	r1, #0x0
 801e2da: 200e         	movs	r0, #0xe
 801e2dc: f7fe f874    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1f18
 801e2e0: 200e         	movs	r0, #0xe
 801e2e2: f7fe f864    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x1f38
 801e2e6: 2200         	movs	r2, #0x0
 801e2e8: 2100         	movs	r1, #0x0
 801e2ea: 200f         	movs	r0, #0xf
 801e2ec: f7fe f86c    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1f28
 801e2f0: 200f         	movs	r0, #0xf
 801e2f2: f7fe f85c    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x1f48
 801e2f6: 2200         	movs	r2, #0x0
 801e2f8: 2100         	movs	r1, #0x0
 801e2fa: 2010         	movs	r0, #0x10
 801e2fc: f7fe f864    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1f38
 801e300: 2010         	movs	r0, #0x10
 801e302: f7fe f854    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x1f58
 801e306: 2200         	movs	r2, #0x0
 801e308: 2100         	movs	r1, #0x0
 801e30a: 2011         	movs	r0, #0x11
 801e30c: f7fe f85c    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1f48
 801e310: 2011         	movs	r0, #0x11
 801e312: f7fe f84c    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x1f68
 801e316: 2200         	movs	r2, #0x0
 801e318: 2100         	movs	r1, #0x0
 801e31a: 202f         	movs	r0, #0x2f
 801e31c: f7fe f854    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x1f58
 801e320: 202f         	movs	r0, #0x2f
 801e322: f7fe f844    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x1f78
; }
 801e326: bf00         	nop
 801e328: 3708         	adds	r7, #0x8
 801e32a: 46bd         	mov	sp, r7
 801e32c: bd80         	pop	{r7, pc}

0801e32e <dma_stm32_irq_1_0>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 0);
 801e32e: b580         	push	{r7, lr}
 801e330: b082         	sub	sp, #0x8
 801e332: af00         	add	r7, sp, #0x0
 801e334: 6078         	str	r0, [r7, #0x4]
 801e336: 2100         	movs	r1, #0x0
 801e338: 6878         	ldr	r0, [r7, #0x4]
 801e33a: f7eb fbb9    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x1488e
 801e33e: 3708         	adds	r7, #0x8
 801e340: 46bd         	mov	sp, r7
 801e342: bd80         	pop	{r7, pc}

0801e344 <dma_stm32_irq_1_1>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 1);
 801e344: b580         	push	{r7, lr}
 801e346: b082         	sub	sp, #0x8
 801e348: af00         	add	r7, sp, #0x0
 801e34a: 6078         	str	r0, [r7, #0x4]
 801e34c: 2101         	movs	r1, #0x1
 801e34e: 6878         	ldr	r0, [r7, #0x4]
 801e350: f7eb fbae    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x148a4
 801e354: 3708         	adds	r7, #0x8
 801e356: 46bd         	mov	sp, r7
 801e358: bd80         	pop	{r7, pc}

0801e35a <dma_stm32_irq_1_2>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 2);
 801e35a: b580         	push	{r7, lr}
 801e35c: b082         	sub	sp, #0x8
 801e35e: af00         	add	r7, sp, #0x0
 801e360: 6078         	str	r0, [r7, #0x4]
 801e362: 2102         	movs	r1, #0x2
 801e364: 6878         	ldr	r0, [r7, #0x4]
 801e366: f7eb fba3    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x148ba
 801e36a: 3708         	adds	r7, #0x8
 801e36c: 46bd         	mov	sp, r7
 801e36e: bd80         	pop	{r7, pc}

0801e370 <dma_stm32_irq_1_3>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 3);
 801e370: b580         	push	{r7, lr}
 801e372: b082         	sub	sp, #0x8
 801e374: af00         	add	r7, sp, #0x0
 801e376: 6078         	str	r0, [r7, #0x4]
 801e378: 2103         	movs	r1, #0x3
 801e37a: 6878         	ldr	r0, [r7, #0x4]
 801e37c: f7eb fb98    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x148d0
 801e380: 3708         	adds	r7, #0x8
 801e382: 46bd         	mov	sp, r7
 801e384: bd80         	pop	{r7, pc}

0801e386 <dma_stm32_irq_1_4>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 4);
 801e386: b580         	push	{r7, lr}
 801e388: b082         	sub	sp, #0x8
 801e38a: af00         	add	r7, sp, #0x0
 801e38c: 6078         	str	r0, [r7, #0x4]
 801e38e: 2104         	movs	r1, #0x4
 801e390: 6878         	ldr	r0, [r7, #0x4]
 801e392: f7eb fb8d    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x148e6
 801e396: 3708         	adds	r7, #0x8
 801e398: 46bd         	mov	sp, r7
 801e39a: bd80         	pop	{r7, pc}

0801e39c <dma_stm32_irq_1_5>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 5);
 801e39c: b580         	push	{r7, lr}
 801e39e: b082         	sub	sp, #0x8
 801e3a0: af00         	add	r7, sp, #0x0
 801e3a2: 6078         	str	r0, [r7, #0x4]
 801e3a4: 2105         	movs	r1, #0x5
 801e3a6: 6878         	ldr	r0, [r7, #0x4]
 801e3a8: f7eb fb82    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x148fc
 801e3ac: 3708         	adds	r7, #0x8
 801e3ae: 46bd         	mov	sp, r7
 801e3b0: bd80         	pop	{r7, pc}

0801e3b2 <dma_stm32_irq_1_6>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 6);
 801e3b2: b580         	push	{r7, lr}
 801e3b4: b082         	sub	sp, #0x8
 801e3b6: af00         	add	r7, sp, #0x0
 801e3b8: 6078         	str	r0, [r7, #0x4]
 801e3ba: 2106         	movs	r1, #0x6
 801e3bc: 6878         	ldr	r0, [r7, #0x4]
 801e3be: f7eb fb77    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x14912
 801e3c2: 3708         	adds	r7, #0x8
 801e3c4: 46bd         	mov	sp, r7
 801e3c6: bd80         	pop	{r7, pc}

0801e3c8 <dma_stm32_irq_1_7>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 7);
 801e3c8: b580         	push	{r7, lr}
 801e3ca: b082         	sub	sp, #0x8
 801e3cc: af00         	add	r7, sp, #0x0
 801e3ce: 6078         	str	r0, [r7, #0x4]
 801e3d0: 2107         	movs	r1, #0x7
 801e3d2: 6878         	ldr	r0, [r7, #0x4]
 801e3d4: f7eb fb6c    	bl	0x8009ab0 <dma_stm32_irq_handler> @ imm = #-0x14928
 801e3d8: 3708         	adds	r7, #0x8
 801e3da: 46bd         	mov	sp, r7
 801e3dc: bd80         	pop	{r7, pc}

0801e3de <dma_stm32_config_irq_1>:
; {
 801e3de: b580         	push	{r7, lr}
 801e3e0: b082         	sub	sp, #0x8
 801e3e2: af00         	add	r7, sp, #0x0
 801e3e4: 6078         	str	r0, [r7, #0x4]
; 	LISTIFY(
 801e3e6: 2200         	movs	r2, #0x0
 801e3e8: 2100         	movs	r1, #0x0
 801e3ea: 2038         	movs	r0, #0x38
 801e3ec: f7fd ffec    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x2028
 801e3f0: 2038         	movs	r0, #0x38
 801e3f2: f7fd ffdc    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x2048
 801e3f6: 2200         	movs	r2, #0x0
 801e3f8: 2100         	movs	r1, #0x0
 801e3fa: 2039         	movs	r0, #0x39
 801e3fc: f7fd ffe4    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x2038
 801e400: 2039         	movs	r0, #0x39
 801e402: f7fd ffd4    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x2058
 801e406: 2200         	movs	r2, #0x0
 801e408: 2100         	movs	r1, #0x0
 801e40a: 203a         	movs	r0, #0x3a
 801e40c: f7fd ffdc    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x2048
 801e410: 203a         	movs	r0, #0x3a
 801e412: f7fd ffcc    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x2068
 801e416: 2200         	movs	r2, #0x0
 801e418: 2100         	movs	r1, #0x0
 801e41a: 203b         	movs	r0, #0x3b
 801e41c: f7fd ffd4    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x2058
 801e420: 203b         	movs	r0, #0x3b
 801e422: f7fd ffc4    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x2078
 801e426: 2200         	movs	r2, #0x0
 801e428: 2100         	movs	r1, #0x0
 801e42a: 203c         	movs	r0, #0x3c
 801e42c: f7fd ffcc    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x2068
 801e430: 203c         	movs	r0, #0x3c
 801e432: f7fd ffbc    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x2088
 801e436: 2200         	movs	r2, #0x0
 801e438: 2100         	movs	r1, #0x0
 801e43a: 2044         	movs	r0, #0x44
 801e43c: f7fd ffc4    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x2078
 801e440: 2044         	movs	r0, #0x44
 801e442: f7fd ffb4    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x2098
 801e446: 2200         	movs	r2, #0x0
 801e448: 2100         	movs	r1, #0x0
 801e44a: 2045         	movs	r0, #0x45
 801e44c: f7fd ffbc    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x2088
 801e450: 2045         	movs	r0, #0x45
 801e452: f7fd ffac    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x20a8
 801e456: 2200         	movs	r2, #0x0
 801e458: 2100         	movs	r1, #0x0
 801e45a: 2046         	movs	r0, #0x46
 801e45c: f7fd ffb4    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x2098
 801e460: 2046         	movs	r0, #0x46
 801e462: f7fd ffa4    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x20b8
; }
 801e466: bf00         	nop
 801e468: 3708         	adds	r7, #0x8
 801e46a: 46bd         	mov	sp, r7
 801e46c: bd80         	pop	{r7, pc}

0801e46e <LL_DMA_IsActiveFlag_HT0>:
; {
 801e46e: b480         	push	{r7}
 801e470: b083         	sub	sp, #0xc
 801e472: af00         	add	r7, sp, #0x0
 801e474: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF0)==(DMA_LISR_HTIF0));
 801e476: 687b         	ldr	r3, [r7, #0x4]
 801e478: 681b         	ldr	r3, [r3]
 801e47a: f003 0310    	and	r3, r3, #0x10
 801e47e: 2b10         	cmp	r3, #0x10
 801e480: bf0c         	ite	eq
 801e482: 2301         	moveq	r3, #0x1
 801e484: 2300         	movne	r3, #0x0
 801e486: b2db         	uxtb	r3, r3
; }
 801e488: 4618         	mov	r0, r3
 801e48a: 370c         	adds	r7, #0xc
 801e48c: 46bd         	mov	sp, r7
 801e48e: f85d 7b04    	ldr	r7, [sp], #4
 801e492: 4770         	bx	lr

0801e494 <LL_DMA_IsActiveFlag_HT1>:
; {
 801e494: b480         	push	{r7}
 801e496: b083         	sub	sp, #0xc
 801e498: af00         	add	r7, sp, #0x0
 801e49a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF1)==(DMA_LISR_HTIF1));
 801e49c: 687b         	ldr	r3, [r7, #0x4]
 801e49e: 681b         	ldr	r3, [r3]
 801e4a0: f403 6380    	and	r3, r3, #0x400
 801e4a4: f5b3 6f80    	cmp.w	r3, #0x400
 801e4a8: bf0c         	ite	eq
 801e4aa: 2301         	moveq	r3, #0x1
 801e4ac: 2300         	movne	r3, #0x0
 801e4ae: b2db         	uxtb	r3, r3
; }
 801e4b0: 4618         	mov	r0, r3
 801e4b2: 370c         	adds	r7, #0xc
 801e4b4: 46bd         	mov	sp, r7
 801e4b6: f85d 7b04    	ldr	r7, [sp], #4
 801e4ba: 4770         	bx	lr

0801e4bc <LL_DMA_IsActiveFlag_HT2>:
; {
 801e4bc: b480         	push	{r7}
 801e4be: b083         	sub	sp, #0xc
 801e4c0: af00         	add	r7, sp, #0x0
 801e4c2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF2)==(DMA_LISR_HTIF2));
 801e4c4: 687b         	ldr	r3, [r7, #0x4]
 801e4c6: 681b         	ldr	r3, [r3]
 801e4c8: f403 1380    	and	r3, r3, #0x100000
 801e4cc: f5b3 1f80    	cmp.w	r3, #0x100000
 801e4d0: bf0c         	ite	eq
 801e4d2: 2301         	moveq	r3, #0x1
 801e4d4: 2300         	movne	r3, #0x0
 801e4d6: b2db         	uxtb	r3, r3
; }
 801e4d8: 4618         	mov	r0, r3
 801e4da: 370c         	adds	r7, #0xc
 801e4dc: 46bd         	mov	sp, r7
 801e4de: f85d 7b04    	ldr	r7, [sp], #4
 801e4e2: 4770         	bx	lr

0801e4e4 <LL_DMA_IsActiveFlag_HT3>:
; {
 801e4e4: b480         	push	{r7}
 801e4e6: b083         	sub	sp, #0xc
 801e4e8: af00         	add	r7, sp, #0x0
 801e4ea: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF3)==(DMA_LISR_HTIF3));
 801e4ec: 687b         	ldr	r3, [r7, #0x4]
 801e4ee: 681b         	ldr	r3, [r3]
 801e4f0: f003 6380    	and	r3, r3, #0x4000000
 801e4f4: f1b3 6f80    	cmp.w	r3, #0x4000000
 801e4f8: bf0c         	ite	eq
 801e4fa: 2301         	moveq	r3, #0x1
 801e4fc: 2300         	movne	r3, #0x0
 801e4fe: b2db         	uxtb	r3, r3
; }
 801e500: 4618         	mov	r0, r3
 801e502: 370c         	adds	r7, #0xc
 801e504: 46bd         	mov	sp, r7
 801e506: f85d 7b04    	ldr	r7, [sp], #4
 801e50a: 4770         	bx	lr

0801e50c <LL_DMA_IsActiveFlag_HT4>:
; {
 801e50c: b480         	push	{r7}
 801e50e: b083         	sub	sp, #0xc
 801e510: af00         	add	r7, sp, #0x0
 801e512: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF4)==(DMA_HISR_HTIF4));
 801e514: 687b         	ldr	r3, [r7, #0x4]
 801e516: 685b         	ldr	r3, [r3, #0x4]
 801e518: f003 0310    	and	r3, r3, #0x10
 801e51c: 2b10         	cmp	r3, #0x10
 801e51e: bf0c         	ite	eq
 801e520: 2301         	moveq	r3, #0x1
 801e522: 2300         	movne	r3, #0x0
 801e524: b2db         	uxtb	r3, r3
; }
 801e526: 4618         	mov	r0, r3
 801e528: 370c         	adds	r7, #0xc
 801e52a: 46bd         	mov	sp, r7
 801e52c: f85d 7b04    	ldr	r7, [sp], #4
 801e530: 4770         	bx	lr

0801e532 <LL_DMA_IsActiveFlag_HT5>:
; {
 801e532: b480         	push	{r7}
 801e534: b083         	sub	sp, #0xc
 801e536: af00         	add	r7, sp, #0x0
 801e538: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF5)==(DMA_HISR_HTIF5));
 801e53a: 687b         	ldr	r3, [r7, #0x4]
 801e53c: 685b         	ldr	r3, [r3, #0x4]
 801e53e: f403 6380    	and	r3, r3, #0x400
 801e542: f5b3 6f80    	cmp.w	r3, #0x400
 801e546: bf0c         	ite	eq
 801e548: 2301         	moveq	r3, #0x1
 801e54a: 2300         	movne	r3, #0x0
 801e54c: b2db         	uxtb	r3, r3
; }
 801e54e: 4618         	mov	r0, r3
 801e550: 370c         	adds	r7, #0xc
 801e552: 46bd         	mov	sp, r7
 801e554: f85d 7b04    	ldr	r7, [sp], #4
 801e558: 4770         	bx	lr

0801e55a <LL_DMA_IsActiveFlag_HT6>:
; {
 801e55a: b480         	push	{r7}
 801e55c: b083         	sub	sp, #0xc
 801e55e: af00         	add	r7, sp, #0x0
 801e560: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF6)==(DMA_HISR_HTIF6));
 801e562: 687b         	ldr	r3, [r7, #0x4]
 801e564: 685b         	ldr	r3, [r3, #0x4]
 801e566: f403 1380    	and	r3, r3, #0x100000
 801e56a: f5b3 1f80    	cmp.w	r3, #0x100000
 801e56e: bf0c         	ite	eq
 801e570: 2301         	moveq	r3, #0x1
 801e572: 2300         	movne	r3, #0x0
 801e574: b2db         	uxtb	r3, r3
; }
 801e576: 4618         	mov	r0, r3
 801e578: 370c         	adds	r7, #0xc
 801e57a: 46bd         	mov	sp, r7
 801e57c: f85d 7b04    	ldr	r7, [sp], #4
 801e580: 4770         	bx	lr

0801e582 <LL_DMA_IsActiveFlag_HT7>:
; {
 801e582: b480         	push	{r7}
 801e584: b083         	sub	sp, #0xc
 801e586: af00         	add	r7, sp, #0x0
 801e588: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF7)==(DMA_HISR_HTIF7));
 801e58a: 687b         	ldr	r3, [r7, #0x4]
 801e58c: 685b         	ldr	r3, [r3, #0x4]
 801e58e: f003 6380    	and	r3, r3, #0x4000000
 801e592: f1b3 6f80    	cmp.w	r3, #0x4000000
 801e596: bf0c         	ite	eq
 801e598: 2301         	moveq	r3, #0x1
 801e59a: 2300         	movne	r3, #0x0
 801e59c: b2db         	uxtb	r3, r3
; }
 801e59e: 4618         	mov	r0, r3
 801e5a0: 370c         	adds	r7, #0xc
 801e5a2: 46bd         	mov	sp, r7
 801e5a4: f85d 7b04    	ldr	r7, [sp], #4
 801e5a8: 4770         	bx	lr

0801e5aa <LL_DMA_IsActiveFlag_TC0>:
; {
 801e5aa: b480         	push	{r7}
 801e5ac: b083         	sub	sp, #0xc
 801e5ae: af00         	add	r7, sp, #0x0
 801e5b0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF0)==(DMA_LISR_TCIF0));
 801e5b2: 687b         	ldr	r3, [r7, #0x4]
 801e5b4: 681b         	ldr	r3, [r3]
 801e5b6: f003 0320    	and	r3, r3, #0x20
 801e5ba: 2b20         	cmp	r3, #0x20
 801e5bc: bf0c         	ite	eq
 801e5be: 2301         	moveq	r3, #0x1
 801e5c0: 2300         	movne	r3, #0x0
 801e5c2: b2db         	uxtb	r3, r3
; }
 801e5c4: 4618         	mov	r0, r3
 801e5c6: 370c         	adds	r7, #0xc
 801e5c8: 46bd         	mov	sp, r7
 801e5ca: f85d 7b04    	ldr	r7, [sp], #4
 801e5ce: 4770         	bx	lr

0801e5d0 <LL_DMA_IsActiveFlag_TC1>:
; {
 801e5d0: b480         	push	{r7}
 801e5d2: b083         	sub	sp, #0xc
 801e5d4: af00         	add	r7, sp, #0x0
 801e5d6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF1)==(DMA_LISR_TCIF1));
 801e5d8: 687b         	ldr	r3, [r7, #0x4]
 801e5da: 681b         	ldr	r3, [r3]
 801e5dc: f403 6300    	and	r3, r3, #0x800
 801e5e0: f5b3 6f00    	cmp.w	r3, #0x800
 801e5e4: bf0c         	ite	eq
 801e5e6: 2301         	moveq	r3, #0x1
 801e5e8: 2300         	movne	r3, #0x0
 801e5ea: b2db         	uxtb	r3, r3
; }
 801e5ec: 4618         	mov	r0, r3
 801e5ee: 370c         	adds	r7, #0xc
 801e5f0: 46bd         	mov	sp, r7
 801e5f2: f85d 7b04    	ldr	r7, [sp], #4
 801e5f6: 4770         	bx	lr

0801e5f8 <LL_DMA_IsActiveFlag_TC2>:
; {
 801e5f8: b480         	push	{r7}
 801e5fa: b083         	sub	sp, #0xc
 801e5fc: af00         	add	r7, sp, #0x0
 801e5fe: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF2)==(DMA_LISR_TCIF2));
 801e600: 687b         	ldr	r3, [r7, #0x4]
 801e602: 681b         	ldr	r3, [r3]
 801e604: f403 1300    	and	r3, r3, #0x200000
 801e608: f5b3 1f00    	cmp.w	r3, #0x200000
 801e60c: bf0c         	ite	eq
 801e60e: 2301         	moveq	r3, #0x1
 801e610: 2300         	movne	r3, #0x0
 801e612: b2db         	uxtb	r3, r3
; }
 801e614: 4618         	mov	r0, r3
 801e616: 370c         	adds	r7, #0xc
 801e618: 46bd         	mov	sp, r7
 801e61a: f85d 7b04    	ldr	r7, [sp], #4
 801e61e: 4770         	bx	lr

0801e620 <LL_DMA_IsActiveFlag_TC3>:
; {
 801e620: b480         	push	{r7}
 801e622: b083         	sub	sp, #0xc
 801e624: af00         	add	r7, sp, #0x0
 801e626: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF3)==(DMA_LISR_TCIF3));
 801e628: 687b         	ldr	r3, [r7, #0x4]
 801e62a: 681b         	ldr	r3, [r3]
 801e62c: f003 6300    	and	r3, r3, #0x8000000
 801e630: f1b3 6f00    	cmp.w	r3, #0x8000000
 801e634: bf0c         	ite	eq
 801e636: 2301         	moveq	r3, #0x1
 801e638: 2300         	movne	r3, #0x0
 801e63a: b2db         	uxtb	r3, r3
; }
 801e63c: 4618         	mov	r0, r3
 801e63e: 370c         	adds	r7, #0xc
 801e640: 46bd         	mov	sp, r7
 801e642: f85d 7b04    	ldr	r7, [sp], #4
 801e646: 4770         	bx	lr

0801e648 <LL_DMA_IsActiveFlag_TC4>:
; {
 801e648: b480         	push	{r7}
 801e64a: b083         	sub	sp, #0xc
 801e64c: af00         	add	r7, sp, #0x0
 801e64e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF4)==(DMA_HISR_TCIF4));
 801e650: 687b         	ldr	r3, [r7, #0x4]
 801e652: 685b         	ldr	r3, [r3, #0x4]
 801e654: f003 0320    	and	r3, r3, #0x20
 801e658: 2b20         	cmp	r3, #0x20
 801e65a: bf0c         	ite	eq
 801e65c: 2301         	moveq	r3, #0x1
 801e65e: 2300         	movne	r3, #0x0
 801e660: b2db         	uxtb	r3, r3
; }
 801e662: 4618         	mov	r0, r3
 801e664: 370c         	adds	r7, #0xc
 801e666: 46bd         	mov	sp, r7
 801e668: f85d 7b04    	ldr	r7, [sp], #4
 801e66c: 4770         	bx	lr

0801e66e <LL_DMA_IsActiveFlag_TC5>:
; {
 801e66e: b480         	push	{r7}
 801e670: b083         	sub	sp, #0xc
 801e672: af00         	add	r7, sp, #0x0
 801e674: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF5)==(DMA_HISR_TCIF5));
 801e676: 687b         	ldr	r3, [r7, #0x4]
 801e678: 685b         	ldr	r3, [r3, #0x4]
 801e67a: f403 6300    	and	r3, r3, #0x800
 801e67e: f5b3 6f00    	cmp.w	r3, #0x800
 801e682: bf0c         	ite	eq
 801e684: 2301         	moveq	r3, #0x1
 801e686: 2300         	movne	r3, #0x0
 801e688: b2db         	uxtb	r3, r3
; }
 801e68a: 4618         	mov	r0, r3
 801e68c: 370c         	adds	r7, #0xc
 801e68e: 46bd         	mov	sp, r7
 801e690: f85d 7b04    	ldr	r7, [sp], #4
 801e694: 4770         	bx	lr

0801e696 <LL_DMA_IsActiveFlag_TC6>:
; {
 801e696: b480         	push	{r7}
 801e698: b083         	sub	sp, #0xc
 801e69a: af00         	add	r7, sp, #0x0
 801e69c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF6)==(DMA_HISR_TCIF6));
 801e69e: 687b         	ldr	r3, [r7, #0x4]
 801e6a0: 685b         	ldr	r3, [r3, #0x4]
 801e6a2: f403 1300    	and	r3, r3, #0x200000
 801e6a6: f5b3 1f00    	cmp.w	r3, #0x200000
 801e6aa: bf0c         	ite	eq
 801e6ac: 2301         	moveq	r3, #0x1
 801e6ae: 2300         	movne	r3, #0x0
 801e6b0: b2db         	uxtb	r3, r3
; }
 801e6b2: 4618         	mov	r0, r3
 801e6b4: 370c         	adds	r7, #0xc
 801e6b6: 46bd         	mov	sp, r7
 801e6b8: f85d 7b04    	ldr	r7, [sp], #4
 801e6bc: 4770         	bx	lr

0801e6be <LL_DMA_IsActiveFlag_TC7>:
; {
 801e6be: b480         	push	{r7}
 801e6c0: b083         	sub	sp, #0xc
 801e6c2: af00         	add	r7, sp, #0x0
 801e6c4: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF7)==(DMA_HISR_TCIF7));
 801e6c6: 687b         	ldr	r3, [r7, #0x4]
 801e6c8: 685b         	ldr	r3, [r3, #0x4]
 801e6ca: f003 6300    	and	r3, r3, #0x8000000
 801e6ce: f1b3 6f00    	cmp.w	r3, #0x8000000
 801e6d2: bf0c         	ite	eq
 801e6d4: 2301         	moveq	r3, #0x1
 801e6d6: 2300         	movne	r3, #0x0
 801e6d8: b2db         	uxtb	r3, r3
; }
 801e6da: 4618         	mov	r0, r3
 801e6dc: 370c         	adds	r7, #0xc
 801e6de: 46bd         	mov	sp, r7
 801e6e0: f85d 7b04    	ldr	r7, [sp], #4
 801e6e4: 4770         	bx	lr

0801e6e6 <LL_DMA_IsActiveFlag_TE0>:
; {
 801e6e6: b480         	push	{r7}
 801e6e8: b083         	sub	sp, #0xc
 801e6ea: af00         	add	r7, sp, #0x0
 801e6ec: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF0)==(DMA_LISR_TEIF0));
 801e6ee: 687b         	ldr	r3, [r7, #0x4]
 801e6f0: 681b         	ldr	r3, [r3]
 801e6f2: f003 0308    	and	r3, r3, #0x8
 801e6f6: 2b08         	cmp	r3, #0x8
 801e6f8: bf0c         	ite	eq
 801e6fa: 2301         	moveq	r3, #0x1
 801e6fc: 2300         	movne	r3, #0x0
 801e6fe: b2db         	uxtb	r3, r3
; }
 801e700: 4618         	mov	r0, r3
 801e702: 370c         	adds	r7, #0xc
 801e704: 46bd         	mov	sp, r7
 801e706: f85d 7b04    	ldr	r7, [sp], #4
 801e70a: 4770         	bx	lr

0801e70c <LL_DMA_IsActiveFlag_TE1>:
; {
 801e70c: b480         	push	{r7}
 801e70e: b083         	sub	sp, #0xc
 801e710: af00         	add	r7, sp, #0x0
 801e712: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF1)==(DMA_LISR_TEIF1));
 801e714: 687b         	ldr	r3, [r7, #0x4]
 801e716: 681b         	ldr	r3, [r3]
 801e718: f403 7300    	and	r3, r3, #0x200
 801e71c: f5b3 7f00    	cmp.w	r3, #0x200
 801e720: bf0c         	ite	eq
 801e722: 2301         	moveq	r3, #0x1
 801e724: 2300         	movne	r3, #0x0
 801e726: b2db         	uxtb	r3, r3
; }
 801e728: 4618         	mov	r0, r3
 801e72a: 370c         	adds	r7, #0xc
 801e72c: 46bd         	mov	sp, r7
 801e72e: f85d 7b04    	ldr	r7, [sp], #4
 801e732: 4770         	bx	lr

0801e734 <LL_DMA_IsActiveFlag_TE2>:
; {
 801e734: b480         	push	{r7}
 801e736: b083         	sub	sp, #0xc
 801e738: af00         	add	r7, sp, #0x0
 801e73a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF2)==(DMA_LISR_TEIF2));
 801e73c: 687b         	ldr	r3, [r7, #0x4]
 801e73e: 681b         	ldr	r3, [r3]
 801e740: f403 2300    	and	r3, r3, #0x80000
 801e744: f5b3 2f00    	cmp.w	r3, #0x80000
 801e748: bf0c         	ite	eq
 801e74a: 2301         	moveq	r3, #0x1
 801e74c: 2300         	movne	r3, #0x0
 801e74e: b2db         	uxtb	r3, r3
; }
 801e750: 4618         	mov	r0, r3
 801e752: 370c         	adds	r7, #0xc
 801e754: 46bd         	mov	sp, r7
 801e756: f85d 7b04    	ldr	r7, [sp], #4
 801e75a: 4770         	bx	lr

0801e75c <LL_DMA_IsActiveFlag_TE3>:
; {
 801e75c: b480         	push	{r7}
 801e75e: b083         	sub	sp, #0xc
 801e760: af00         	add	r7, sp, #0x0
 801e762: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF3)==(DMA_LISR_TEIF3));
 801e764: 687b         	ldr	r3, [r7, #0x4]
 801e766: 681b         	ldr	r3, [r3]
 801e768: f003 7300    	and	r3, r3, #0x2000000
 801e76c: f1b3 7f00    	cmp.w	r3, #0x2000000
 801e770: bf0c         	ite	eq
 801e772: 2301         	moveq	r3, #0x1
 801e774: 2300         	movne	r3, #0x0
 801e776: b2db         	uxtb	r3, r3
; }
 801e778: 4618         	mov	r0, r3
 801e77a: 370c         	adds	r7, #0xc
 801e77c: 46bd         	mov	sp, r7
 801e77e: f85d 7b04    	ldr	r7, [sp], #4
 801e782: 4770         	bx	lr

0801e784 <LL_DMA_IsActiveFlag_TE4>:
; {
 801e784: b480         	push	{r7}
 801e786: b083         	sub	sp, #0xc
 801e788: af00         	add	r7, sp, #0x0
 801e78a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF4)==(DMA_HISR_TEIF4));
 801e78c: 687b         	ldr	r3, [r7, #0x4]
 801e78e: 685b         	ldr	r3, [r3, #0x4]
 801e790: f003 0308    	and	r3, r3, #0x8
 801e794: 2b08         	cmp	r3, #0x8
 801e796: bf0c         	ite	eq
 801e798: 2301         	moveq	r3, #0x1
 801e79a: 2300         	movne	r3, #0x0
 801e79c: b2db         	uxtb	r3, r3
; }
 801e79e: 4618         	mov	r0, r3
 801e7a0: 370c         	adds	r7, #0xc
 801e7a2: 46bd         	mov	sp, r7
 801e7a4: f85d 7b04    	ldr	r7, [sp], #4
 801e7a8: 4770         	bx	lr

0801e7aa <LL_DMA_IsActiveFlag_TE5>:
; {
 801e7aa: b480         	push	{r7}
 801e7ac: b083         	sub	sp, #0xc
 801e7ae: af00         	add	r7, sp, #0x0
 801e7b0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF5)==(DMA_HISR_TEIF5));
 801e7b2: 687b         	ldr	r3, [r7, #0x4]
 801e7b4: 685b         	ldr	r3, [r3, #0x4]
 801e7b6: f403 7300    	and	r3, r3, #0x200
 801e7ba: f5b3 7f00    	cmp.w	r3, #0x200
 801e7be: bf0c         	ite	eq
 801e7c0: 2301         	moveq	r3, #0x1
 801e7c2: 2300         	movne	r3, #0x0
 801e7c4: b2db         	uxtb	r3, r3
; }
 801e7c6: 4618         	mov	r0, r3
 801e7c8: 370c         	adds	r7, #0xc
 801e7ca: 46bd         	mov	sp, r7
 801e7cc: f85d 7b04    	ldr	r7, [sp], #4
 801e7d0: 4770         	bx	lr

0801e7d2 <LL_DMA_IsActiveFlag_TE6>:
; {
 801e7d2: b480         	push	{r7}
 801e7d4: b083         	sub	sp, #0xc
 801e7d6: af00         	add	r7, sp, #0x0
 801e7d8: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF6)==(DMA_HISR_TEIF6));
 801e7da: 687b         	ldr	r3, [r7, #0x4]
 801e7dc: 685b         	ldr	r3, [r3, #0x4]
 801e7de: f403 2300    	and	r3, r3, #0x80000
 801e7e2: f5b3 2f00    	cmp.w	r3, #0x80000
 801e7e6: bf0c         	ite	eq
 801e7e8: 2301         	moveq	r3, #0x1
 801e7ea: 2300         	movne	r3, #0x0
 801e7ec: b2db         	uxtb	r3, r3
; }
 801e7ee: 4618         	mov	r0, r3
 801e7f0: 370c         	adds	r7, #0xc
 801e7f2: 46bd         	mov	sp, r7
 801e7f4: f85d 7b04    	ldr	r7, [sp], #4
 801e7f8: 4770         	bx	lr

0801e7fa <LL_DMA_IsActiveFlag_TE7>:
; {
 801e7fa: b480         	push	{r7}
 801e7fc: b083         	sub	sp, #0xc
 801e7fe: af00         	add	r7, sp, #0x0
 801e800: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF7)==(DMA_HISR_TEIF7));
 801e802: 687b         	ldr	r3, [r7, #0x4]
 801e804: 685b         	ldr	r3, [r3, #0x4]
 801e806: f003 7300    	and	r3, r3, #0x2000000
 801e80a: f1b3 7f00    	cmp.w	r3, #0x2000000
 801e80e: bf0c         	ite	eq
 801e810: 2301         	moveq	r3, #0x1
 801e812: 2300         	movne	r3, #0x0
 801e814: b2db         	uxtb	r3, r3
; }
 801e816: 4618         	mov	r0, r3
 801e818: 370c         	adds	r7, #0xc
 801e81a: 46bd         	mov	sp, r7
 801e81c: f85d 7b04    	ldr	r7, [sp], #4
 801e820: 4770         	bx	lr

0801e822 <LL_DMA_IsActiveFlag_DME0>:
; {
 801e822: b480         	push	{r7}
 801e824: b083         	sub	sp, #0xc
 801e826: af00         	add	r7, sp, #0x0
 801e828: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF0)==(DMA_LISR_DMEIF0));
 801e82a: 687b         	ldr	r3, [r7, #0x4]
 801e82c: 681b         	ldr	r3, [r3]
 801e82e: f003 0304    	and	r3, r3, #0x4
 801e832: 2b04         	cmp	r3, #0x4
 801e834: bf0c         	ite	eq
 801e836: 2301         	moveq	r3, #0x1
 801e838: 2300         	movne	r3, #0x0
 801e83a: b2db         	uxtb	r3, r3
; }
 801e83c: 4618         	mov	r0, r3
 801e83e: 370c         	adds	r7, #0xc
 801e840: 46bd         	mov	sp, r7
 801e842: f85d 7b04    	ldr	r7, [sp], #4
 801e846: 4770         	bx	lr

0801e848 <LL_DMA_IsActiveFlag_DME1>:
; {
 801e848: b480         	push	{r7}
 801e84a: b083         	sub	sp, #0xc
 801e84c: af00         	add	r7, sp, #0x0
 801e84e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF1)==(DMA_LISR_DMEIF1));
 801e850: 687b         	ldr	r3, [r7, #0x4]
 801e852: 681b         	ldr	r3, [r3]
 801e854: f403 7380    	and	r3, r3, #0x100
 801e858: f5b3 7f80    	cmp.w	r3, #0x100
 801e85c: bf0c         	ite	eq
 801e85e: 2301         	moveq	r3, #0x1
 801e860: 2300         	movne	r3, #0x0
 801e862: b2db         	uxtb	r3, r3
; }
 801e864: 4618         	mov	r0, r3
 801e866: 370c         	adds	r7, #0xc
 801e868: 46bd         	mov	sp, r7
 801e86a: f85d 7b04    	ldr	r7, [sp], #4
 801e86e: 4770         	bx	lr

0801e870 <LL_DMA_IsActiveFlag_DME2>:
; {
 801e870: b480         	push	{r7}
 801e872: b083         	sub	sp, #0xc
 801e874: af00         	add	r7, sp, #0x0
 801e876: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF2)==(DMA_LISR_DMEIF2));
 801e878: 687b         	ldr	r3, [r7, #0x4]
 801e87a: 681b         	ldr	r3, [r3]
 801e87c: f403 2380    	and	r3, r3, #0x40000
 801e880: f5b3 2f80    	cmp.w	r3, #0x40000
 801e884: bf0c         	ite	eq
 801e886: 2301         	moveq	r3, #0x1
 801e888: 2300         	movne	r3, #0x0
 801e88a: b2db         	uxtb	r3, r3
; }
 801e88c: 4618         	mov	r0, r3
 801e88e: 370c         	adds	r7, #0xc
 801e890: 46bd         	mov	sp, r7
 801e892: f85d 7b04    	ldr	r7, [sp], #4
 801e896: 4770         	bx	lr

0801e898 <LL_DMA_IsActiveFlag_DME3>:
; {
 801e898: b480         	push	{r7}
 801e89a: b083         	sub	sp, #0xc
 801e89c: af00         	add	r7, sp, #0x0
 801e89e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF3)==(DMA_LISR_DMEIF3));
 801e8a0: 687b         	ldr	r3, [r7, #0x4]
 801e8a2: 681b         	ldr	r3, [r3]
 801e8a4: f003 7380    	and	r3, r3, #0x1000000
 801e8a8: f1b3 7f80    	cmp.w	r3, #0x1000000
 801e8ac: bf0c         	ite	eq
 801e8ae: 2301         	moveq	r3, #0x1
 801e8b0: 2300         	movne	r3, #0x0
 801e8b2: b2db         	uxtb	r3, r3
; }
 801e8b4: 4618         	mov	r0, r3
 801e8b6: 370c         	adds	r7, #0xc
 801e8b8: 46bd         	mov	sp, r7
 801e8ba: f85d 7b04    	ldr	r7, [sp], #4
 801e8be: 4770         	bx	lr

0801e8c0 <LL_DMA_IsActiveFlag_DME4>:
; {
 801e8c0: b480         	push	{r7}
 801e8c2: b083         	sub	sp, #0xc
 801e8c4: af00         	add	r7, sp, #0x0
 801e8c6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF4)==(DMA_HISR_DMEIF4));
 801e8c8: 687b         	ldr	r3, [r7, #0x4]
 801e8ca: 685b         	ldr	r3, [r3, #0x4]
 801e8cc: f003 0304    	and	r3, r3, #0x4
 801e8d0: 2b04         	cmp	r3, #0x4
 801e8d2: bf0c         	ite	eq
 801e8d4: 2301         	moveq	r3, #0x1
 801e8d6: 2300         	movne	r3, #0x0
 801e8d8: b2db         	uxtb	r3, r3
; }
 801e8da: 4618         	mov	r0, r3
 801e8dc: 370c         	adds	r7, #0xc
 801e8de: 46bd         	mov	sp, r7
 801e8e0: f85d 7b04    	ldr	r7, [sp], #4
 801e8e4: 4770         	bx	lr

0801e8e6 <LL_DMA_IsActiveFlag_DME5>:
; {
 801e8e6: b480         	push	{r7}
 801e8e8: b083         	sub	sp, #0xc
 801e8ea: af00         	add	r7, sp, #0x0
 801e8ec: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF5)==(DMA_HISR_DMEIF5));
 801e8ee: 687b         	ldr	r3, [r7, #0x4]
 801e8f0: 685b         	ldr	r3, [r3, #0x4]
 801e8f2: f403 7380    	and	r3, r3, #0x100
 801e8f6: f5b3 7f80    	cmp.w	r3, #0x100
 801e8fa: bf0c         	ite	eq
 801e8fc: 2301         	moveq	r3, #0x1
 801e8fe: 2300         	movne	r3, #0x0
 801e900: b2db         	uxtb	r3, r3
; }
 801e902: 4618         	mov	r0, r3
 801e904: 370c         	adds	r7, #0xc
 801e906: 46bd         	mov	sp, r7
 801e908: f85d 7b04    	ldr	r7, [sp], #4
 801e90c: 4770         	bx	lr

0801e90e <LL_DMA_IsActiveFlag_DME6>:
; {
 801e90e: b480         	push	{r7}
 801e910: b083         	sub	sp, #0xc
 801e912: af00         	add	r7, sp, #0x0
 801e914: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF6)==(DMA_HISR_DMEIF6));
 801e916: 687b         	ldr	r3, [r7, #0x4]
 801e918: 685b         	ldr	r3, [r3, #0x4]
 801e91a: f403 2380    	and	r3, r3, #0x40000
 801e91e: f5b3 2f80    	cmp.w	r3, #0x40000
 801e922: bf0c         	ite	eq
 801e924: 2301         	moveq	r3, #0x1
 801e926: 2300         	movne	r3, #0x0
 801e928: b2db         	uxtb	r3, r3
; }
 801e92a: 4618         	mov	r0, r3
 801e92c: 370c         	adds	r7, #0xc
 801e92e: 46bd         	mov	sp, r7
 801e930: f85d 7b04    	ldr	r7, [sp], #4
 801e934: 4770         	bx	lr

0801e936 <LL_DMA_IsActiveFlag_DME7>:
; {
 801e936: b480         	push	{r7}
 801e938: b083         	sub	sp, #0xc
 801e93a: af00         	add	r7, sp, #0x0
 801e93c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF7)==(DMA_HISR_DMEIF7));
 801e93e: 687b         	ldr	r3, [r7, #0x4]
 801e940: 685b         	ldr	r3, [r3, #0x4]
 801e942: f003 7380    	and	r3, r3, #0x1000000
 801e946: f1b3 7f80    	cmp.w	r3, #0x1000000
 801e94a: bf0c         	ite	eq
 801e94c: 2301         	moveq	r3, #0x1
 801e94e: 2300         	movne	r3, #0x0
 801e950: b2db         	uxtb	r3, r3
; }
 801e952: 4618         	mov	r0, r3
 801e954: 370c         	adds	r7, #0xc
 801e956: 46bd         	mov	sp, r7
 801e958: f85d 7b04    	ldr	r7, [sp], #4
 801e95c: 4770         	bx	lr

0801e95e <LL_DMA_IsActiveFlag_FE0>:
; {
 801e95e: b480         	push	{r7}
 801e960: b083         	sub	sp, #0xc
 801e962: af00         	add	r7, sp, #0x0
 801e964: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF0)==(DMA_LISR_FEIF0));
 801e966: 687b         	ldr	r3, [r7, #0x4]
 801e968: 681b         	ldr	r3, [r3]
 801e96a: f003 0301    	and	r3, r3, #0x1
 801e96e: 2b01         	cmp	r3, #0x1
 801e970: bf0c         	ite	eq
 801e972: 2301         	moveq	r3, #0x1
 801e974: 2300         	movne	r3, #0x0
 801e976: b2db         	uxtb	r3, r3
; }
 801e978: 4618         	mov	r0, r3
 801e97a: 370c         	adds	r7, #0xc
 801e97c: 46bd         	mov	sp, r7
 801e97e: f85d 7b04    	ldr	r7, [sp], #4
 801e982: 4770         	bx	lr

0801e984 <LL_DMA_IsActiveFlag_FE1>:
; {
 801e984: b480         	push	{r7}
 801e986: b083         	sub	sp, #0xc
 801e988: af00         	add	r7, sp, #0x0
 801e98a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF1)==(DMA_LISR_FEIF1));
 801e98c: 687b         	ldr	r3, [r7, #0x4]
 801e98e: 681b         	ldr	r3, [r3]
 801e990: f003 0340    	and	r3, r3, #0x40
 801e994: 2b40         	cmp	r3, #0x40
 801e996: bf0c         	ite	eq
 801e998: 2301         	moveq	r3, #0x1
 801e99a: 2300         	movne	r3, #0x0
 801e99c: b2db         	uxtb	r3, r3
; }
 801e99e: 4618         	mov	r0, r3
 801e9a0: 370c         	adds	r7, #0xc
 801e9a2: 46bd         	mov	sp, r7
 801e9a4: f85d 7b04    	ldr	r7, [sp], #4
 801e9a8: 4770         	bx	lr

0801e9aa <LL_DMA_IsActiveFlag_FE2>:
; {
 801e9aa: b480         	push	{r7}
 801e9ac: b083         	sub	sp, #0xc
 801e9ae: af00         	add	r7, sp, #0x0
 801e9b0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF2)==(DMA_LISR_FEIF2));
 801e9b2: 687b         	ldr	r3, [r7, #0x4]
 801e9b4: 681b         	ldr	r3, [r3]
 801e9b6: f403 3380    	and	r3, r3, #0x10000
 801e9ba: f5b3 3f80    	cmp.w	r3, #0x10000
 801e9be: bf0c         	ite	eq
 801e9c0: 2301         	moveq	r3, #0x1
 801e9c2: 2300         	movne	r3, #0x0
 801e9c4: b2db         	uxtb	r3, r3
; }
 801e9c6: 4618         	mov	r0, r3
 801e9c8: 370c         	adds	r7, #0xc
 801e9ca: 46bd         	mov	sp, r7
 801e9cc: f85d 7b04    	ldr	r7, [sp], #4
 801e9d0: 4770         	bx	lr

0801e9d2 <LL_DMA_IsActiveFlag_FE3>:
; {
 801e9d2: b480         	push	{r7}
 801e9d4: b083         	sub	sp, #0xc
 801e9d6: af00         	add	r7, sp, #0x0
 801e9d8: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF3)==(DMA_LISR_FEIF3));
 801e9da: 687b         	ldr	r3, [r7, #0x4]
 801e9dc: 681b         	ldr	r3, [r3]
 801e9de: f403 0380    	and	r3, r3, #0x400000
 801e9e2: f5b3 0f80    	cmp.w	r3, #0x400000
 801e9e6: bf0c         	ite	eq
 801e9e8: 2301         	moveq	r3, #0x1
 801e9ea: 2300         	movne	r3, #0x0
 801e9ec: b2db         	uxtb	r3, r3
; }
 801e9ee: 4618         	mov	r0, r3
 801e9f0: 370c         	adds	r7, #0xc
 801e9f2: 46bd         	mov	sp, r7
 801e9f4: f85d 7b04    	ldr	r7, [sp], #4
 801e9f8: 4770         	bx	lr

0801e9fa <LL_DMA_IsActiveFlag_FE4>:
; {
 801e9fa: b480         	push	{r7}
 801e9fc: b083         	sub	sp, #0xc
 801e9fe: af00         	add	r7, sp, #0x0
 801ea00: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF4)==(DMA_HISR_FEIF4));
 801ea02: 687b         	ldr	r3, [r7, #0x4]
 801ea04: 685b         	ldr	r3, [r3, #0x4]
 801ea06: f003 0301    	and	r3, r3, #0x1
 801ea0a: 2b01         	cmp	r3, #0x1
 801ea0c: bf0c         	ite	eq
 801ea0e: 2301         	moveq	r3, #0x1
 801ea10: 2300         	movne	r3, #0x0
 801ea12: b2db         	uxtb	r3, r3
; }
 801ea14: 4618         	mov	r0, r3
 801ea16: 370c         	adds	r7, #0xc
 801ea18: 46bd         	mov	sp, r7
 801ea1a: f85d 7b04    	ldr	r7, [sp], #4
 801ea1e: 4770         	bx	lr

0801ea20 <LL_DMA_IsActiveFlag_FE5>:
; {
 801ea20: b480         	push	{r7}
 801ea22: b083         	sub	sp, #0xc
 801ea24: af00         	add	r7, sp, #0x0
 801ea26: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF5)==(DMA_HISR_FEIF5));
 801ea28: 687b         	ldr	r3, [r7, #0x4]
 801ea2a: 685b         	ldr	r3, [r3, #0x4]
 801ea2c: f003 0340    	and	r3, r3, #0x40
 801ea30: 2b40         	cmp	r3, #0x40
 801ea32: bf0c         	ite	eq
 801ea34: 2301         	moveq	r3, #0x1
 801ea36: 2300         	movne	r3, #0x0
 801ea38: b2db         	uxtb	r3, r3
; }
 801ea3a: 4618         	mov	r0, r3
 801ea3c: 370c         	adds	r7, #0xc
 801ea3e: 46bd         	mov	sp, r7
 801ea40: f85d 7b04    	ldr	r7, [sp], #4
 801ea44: 4770         	bx	lr

0801ea46 <LL_DMA_IsActiveFlag_FE6>:
; {
 801ea46: b480         	push	{r7}
 801ea48: b083         	sub	sp, #0xc
 801ea4a: af00         	add	r7, sp, #0x0
 801ea4c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF6)==(DMA_HISR_FEIF6));
 801ea4e: 687b         	ldr	r3, [r7, #0x4]
 801ea50: 685b         	ldr	r3, [r3, #0x4]
 801ea52: f403 3380    	and	r3, r3, #0x10000
 801ea56: f5b3 3f80    	cmp.w	r3, #0x10000
 801ea5a: bf0c         	ite	eq
 801ea5c: 2301         	moveq	r3, #0x1
 801ea5e: 2300         	movne	r3, #0x0
 801ea60: b2db         	uxtb	r3, r3
; }
 801ea62: 4618         	mov	r0, r3
 801ea64: 370c         	adds	r7, #0xc
 801ea66: 46bd         	mov	sp, r7
 801ea68: f85d 7b04    	ldr	r7, [sp], #4
 801ea6c: 4770         	bx	lr

0801ea6e <LL_DMA_IsActiveFlag_FE7>:
; {
 801ea6e: b480         	push	{r7}
 801ea70: b083         	sub	sp, #0xc
 801ea72: af00         	add	r7, sp, #0x0
 801ea74: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF7)==(DMA_HISR_FEIF7));
 801ea76: 687b         	ldr	r3, [r7, #0x4]
 801ea78: 685b         	ldr	r3, [r3, #0x4]
 801ea7a: f403 0380    	and	r3, r3, #0x400000
 801ea7e: f5b3 0f80    	cmp.w	r3, #0x400000
 801ea82: bf0c         	ite	eq
 801ea84: 2301         	moveq	r3, #0x1
 801ea86: 2300         	movne	r3, #0x0
 801ea88: b2db         	uxtb	r3, r3
; }
 801ea8a: 4618         	mov	r0, r3
 801ea8c: 370c         	adds	r7, #0xc
 801ea8e: 46bd         	mov	sp, r7
 801ea90: f85d 7b04    	ldr	r7, [sp], #4
 801ea94: 4770         	bx	lr

0801ea96 <LL_DMA_ClearFlag_HT0>:
; {
 801ea96: b480         	push	{r7}
 801ea98: b083         	sub	sp, #0xc
 801ea9a: af00         	add	r7, sp, #0x0
 801ea9c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF0);
 801ea9e: 687b         	ldr	r3, [r7, #0x4]
 801eaa0: 2210         	movs	r2, #0x10
 801eaa2: 609a         	str	r2, [r3, #0x8]
; }
 801eaa4: bf00         	nop
 801eaa6: 370c         	adds	r7, #0xc
 801eaa8: 46bd         	mov	sp, r7
 801eaaa: f85d 7b04    	ldr	r7, [sp], #4
 801eaae: 4770         	bx	lr

0801eab0 <LL_DMA_ClearFlag_HT1>:
; {
 801eab0: b480         	push	{r7}
 801eab2: b083         	sub	sp, #0xc
 801eab4: af00         	add	r7, sp, #0x0
 801eab6: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF1);
 801eab8: 687b         	ldr	r3, [r7, #0x4]
 801eaba: f44f 6280    	mov.w	r2, #0x400
 801eabe: 609a         	str	r2, [r3, #0x8]
; }
 801eac0: bf00         	nop
 801eac2: 370c         	adds	r7, #0xc
 801eac4: 46bd         	mov	sp, r7
 801eac6: f85d 7b04    	ldr	r7, [sp], #4
 801eaca: 4770         	bx	lr

0801eacc <LL_DMA_ClearFlag_HT2>:
; {
 801eacc: b480         	push	{r7}
 801eace: b083         	sub	sp, #0xc
 801ead0: af00         	add	r7, sp, #0x0
 801ead2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF2);
 801ead4: 687b         	ldr	r3, [r7, #0x4]
 801ead6: f44f 1280    	mov.w	r2, #0x100000
 801eada: 609a         	str	r2, [r3, #0x8]
; }
 801eadc: bf00         	nop
 801eade: 370c         	adds	r7, #0xc
 801eae0: 46bd         	mov	sp, r7
 801eae2: f85d 7b04    	ldr	r7, [sp], #4
 801eae6: 4770         	bx	lr

0801eae8 <LL_DMA_ClearFlag_HT3>:
; {
 801eae8: b480         	push	{r7}
 801eaea: b083         	sub	sp, #0xc
 801eaec: af00         	add	r7, sp, #0x0
 801eaee: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF3);
 801eaf0: 687b         	ldr	r3, [r7, #0x4]
 801eaf2: f04f 6280    	mov.w	r2, #0x4000000
 801eaf6: 609a         	str	r2, [r3, #0x8]
; }
 801eaf8: bf00         	nop
 801eafa: 370c         	adds	r7, #0xc
 801eafc: 46bd         	mov	sp, r7
 801eafe: f85d 7b04    	ldr	r7, [sp], #4
 801eb02: 4770         	bx	lr

0801eb04 <LL_DMA_ClearFlag_HT4>:
; {
 801eb04: b480         	push	{r7}
 801eb06: b083         	sub	sp, #0xc
 801eb08: af00         	add	r7, sp, #0x0
 801eb0a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF4);
 801eb0c: 687b         	ldr	r3, [r7, #0x4]
 801eb0e: 2210         	movs	r2, #0x10
 801eb10: 60da         	str	r2, [r3, #0xc]
; }
 801eb12: bf00         	nop
 801eb14: 370c         	adds	r7, #0xc
 801eb16: 46bd         	mov	sp, r7
 801eb18: f85d 7b04    	ldr	r7, [sp], #4
 801eb1c: 4770         	bx	lr

0801eb1e <LL_DMA_ClearFlag_HT5>:
; {
 801eb1e: b480         	push	{r7}
 801eb20: b083         	sub	sp, #0xc
 801eb22: af00         	add	r7, sp, #0x0
 801eb24: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF5);
 801eb26: 687b         	ldr	r3, [r7, #0x4]
 801eb28: f44f 6280    	mov.w	r2, #0x400
 801eb2c: 60da         	str	r2, [r3, #0xc]
; }
 801eb2e: bf00         	nop
 801eb30: 370c         	adds	r7, #0xc
 801eb32: 46bd         	mov	sp, r7
 801eb34: f85d 7b04    	ldr	r7, [sp], #4
 801eb38: 4770         	bx	lr

0801eb3a <LL_DMA_ClearFlag_HT6>:
; {
 801eb3a: b480         	push	{r7}
 801eb3c: b083         	sub	sp, #0xc
 801eb3e: af00         	add	r7, sp, #0x0
 801eb40: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF6);
 801eb42: 687b         	ldr	r3, [r7, #0x4]
 801eb44: f44f 1280    	mov.w	r2, #0x100000
 801eb48: 60da         	str	r2, [r3, #0xc]
; }
 801eb4a: bf00         	nop
 801eb4c: 370c         	adds	r7, #0xc
 801eb4e: 46bd         	mov	sp, r7
 801eb50: f85d 7b04    	ldr	r7, [sp], #4
 801eb54: 4770         	bx	lr

0801eb56 <LL_DMA_ClearFlag_HT7>:
; {
 801eb56: b480         	push	{r7}
 801eb58: b083         	sub	sp, #0xc
 801eb5a: af00         	add	r7, sp, #0x0
 801eb5c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF7);
 801eb5e: 687b         	ldr	r3, [r7, #0x4]
 801eb60: f04f 6280    	mov.w	r2, #0x4000000
 801eb64: 60da         	str	r2, [r3, #0xc]
; }
 801eb66: bf00         	nop
 801eb68: 370c         	adds	r7, #0xc
 801eb6a: 46bd         	mov	sp, r7
 801eb6c: f85d 7b04    	ldr	r7, [sp], #4
 801eb70: 4770         	bx	lr

0801eb72 <LL_DMA_ClearFlag_TC0>:
; {
 801eb72: b480         	push	{r7}
 801eb74: b083         	sub	sp, #0xc
 801eb76: af00         	add	r7, sp, #0x0
 801eb78: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF0);
 801eb7a: 687b         	ldr	r3, [r7, #0x4]
 801eb7c: 2220         	movs	r2, #0x20
 801eb7e: 609a         	str	r2, [r3, #0x8]
; }
 801eb80: bf00         	nop
 801eb82: 370c         	adds	r7, #0xc
 801eb84: 46bd         	mov	sp, r7
 801eb86: f85d 7b04    	ldr	r7, [sp], #4
 801eb8a: 4770         	bx	lr

0801eb8c <LL_DMA_ClearFlag_TC1>:
; {
 801eb8c: b480         	push	{r7}
 801eb8e: b083         	sub	sp, #0xc
 801eb90: af00         	add	r7, sp, #0x0
 801eb92: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF1);
 801eb94: 687b         	ldr	r3, [r7, #0x4]
 801eb96: f44f 6200    	mov.w	r2, #0x800
 801eb9a: 609a         	str	r2, [r3, #0x8]
; }
 801eb9c: bf00         	nop
 801eb9e: 370c         	adds	r7, #0xc
 801eba0: 46bd         	mov	sp, r7
 801eba2: f85d 7b04    	ldr	r7, [sp], #4
 801eba6: 4770         	bx	lr

0801eba8 <LL_DMA_ClearFlag_TC2>:
; {
 801eba8: b480         	push	{r7}
 801ebaa: b083         	sub	sp, #0xc
 801ebac: af00         	add	r7, sp, #0x0
 801ebae: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF2);
 801ebb0: 687b         	ldr	r3, [r7, #0x4]
 801ebb2: f44f 1200    	mov.w	r2, #0x200000
 801ebb6: 609a         	str	r2, [r3, #0x8]
; }
 801ebb8: bf00         	nop
 801ebba: 370c         	adds	r7, #0xc
 801ebbc: 46bd         	mov	sp, r7
 801ebbe: f85d 7b04    	ldr	r7, [sp], #4
 801ebc2: 4770         	bx	lr

0801ebc4 <LL_DMA_ClearFlag_TC3>:
; {
 801ebc4: b480         	push	{r7}
 801ebc6: b083         	sub	sp, #0xc
 801ebc8: af00         	add	r7, sp, #0x0
 801ebca: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF3);
 801ebcc: 687b         	ldr	r3, [r7, #0x4]
 801ebce: f04f 6200    	mov.w	r2, #0x8000000
 801ebd2: 609a         	str	r2, [r3, #0x8]
; }
 801ebd4: bf00         	nop
 801ebd6: 370c         	adds	r7, #0xc
 801ebd8: 46bd         	mov	sp, r7
 801ebda: f85d 7b04    	ldr	r7, [sp], #4
 801ebde: 4770         	bx	lr

0801ebe0 <LL_DMA_ClearFlag_TC4>:
; {
 801ebe0: b480         	push	{r7}
 801ebe2: b083         	sub	sp, #0xc
 801ebe4: af00         	add	r7, sp, #0x0
 801ebe6: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF4);
 801ebe8: 687b         	ldr	r3, [r7, #0x4]
 801ebea: 2220         	movs	r2, #0x20
 801ebec: 60da         	str	r2, [r3, #0xc]
; }
 801ebee: bf00         	nop
 801ebf0: 370c         	adds	r7, #0xc
 801ebf2: 46bd         	mov	sp, r7
 801ebf4: f85d 7b04    	ldr	r7, [sp], #4
 801ebf8: 4770         	bx	lr

0801ebfa <LL_DMA_ClearFlag_TC5>:
; {
 801ebfa: b480         	push	{r7}
 801ebfc: b083         	sub	sp, #0xc
 801ebfe: af00         	add	r7, sp, #0x0
 801ec00: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF5);
 801ec02: 687b         	ldr	r3, [r7, #0x4]
 801ec04: f44f 6200    	mov.w	r2, #0x800
 801ec08: 60da         	str	r2, [r3, #0xc]
; }
 801ec0a: bf00         	nop
 801ec0c: 370c         	adds	r7, #0xc
 801ec0e: 46bd         	mov	sp, r7
 801ec10: f85d 7b04    	ldr	r7, [sp], #4
 801ec14: 4770         	bx	lr

0801ec16 <LL_DMA_ClearFlag_TC6>:
; {
 801ec16: b480         	push	{r7}
 801ec18: b083         	sub	sp, #0xc
 801ec1a: af00         	add	r7, sp, #0x0
 801ec1c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF6);
 801ec1e: 687b         	ldr	r3, [r7, #0x4]
 801ec20: f44f 1200    	mov.w	r2, #0x200000
 801ec24: 60da         	str	r2, [r3, #0xc]
; }
 801ec26: bf00         	nop
 801ec28: 370c         	adds	r7, #0xc
 801ec2a: 46bd         	mov	sp, r7
 801ec2c: f85d 7b04    	ldr	r7, [sp], #4
 801ec30: 4770         	bx	lr

0801ec32 <LL_DMA_ClearFlag_TC7>:
; {
 801ec32: b480         	push	{r7}
 801ec34: b083         	sub	sp, #0xc
 801ec36: af00         	add	r7, sp, #0x0
 801ec38: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF7);
 801ec3a: 687b         	ldr	r3, [r7, #0x4]
 801ec3c: f04f 6200    	mov.w	r2, #0x8000000
 801ec40: 60da         	str	r2, [r3, #0xc]
; }
 801ec42: bf00         	nop
 801ec44: 370c         	adds	r7, #0xc
 801ec46: 46bd         	mov	sp, r7
 801ec48: f85d 7b04    	ldr	r7, [sp], #4
 801ec4c: 4770         	bx	lr

0801ec4e <LL_DMA_ClearFlag_TE0>:
; {
 801ec4e: b480         	push	{r7}
 801ec50: b083         	sub	sp, #0xc
 801ec52: af00         	add	r7, sp, #0x0
 801ec54: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF0);
 801ec56: 687b         	ldr	r3, [r7, #0x4]
 801ec58: 2208         	movs	r2, #0x8
 801ec5a: 609a         	str	r2, [r3, #0x8]
; }
 801ec5c: bf00         	nop
 801ec5e: 370c         	adds	r7, #0xc
 801ec60: 46bd         	mov	sp, r7
 801ec62: f85d 7b04    	ldr	r7, [sp], #4
 801ec66: 4770         	bx	lr

0801ec68 <LL_DMA_ClearFlag_TE1>:
; {
 801ec68: b480         	push	{r7}
 801ec6a: b083         	sub	sp, #0xc
 801ec6c: af00         	add	r7, sp, #0x0
 801ec6e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF1);
 801ec70: 687b         	ldr	r3, [r7, #0x4]
 801ec72: f44f 7200    	mov.w	r2, #0x200
 801ec76: 609a         	str	r2, [r3, #0x8]
; }
 801ec78: bf00         	nop
 801ec7a: 370c         	adds	r7, #0xc
 801ec7c: 46bd         	mov	sp, r7
 801ec7e: f85d 7b04    	ldr	r7, [sp], #4
 801ec82: 4770         	bx	lr

0801ec84 <LL_DMA_ClearFlag_TE2>:
; {
 801ec84: b480         	push	{r7}
 801ec86: b083         	sub	sp, #0xc
 801ec88: af00         	add	r7, sp, #0x0
 801ec8a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF2);
 801ec8c: 687b         	ldr	r3, [r7, #0x4]
 801ec8e: f44f 2200    	mov.w	r2, #0x80000
 801ec92: 609a         	str	r2, [r3, #0x8]
; }
 801ec94: bf00         	nop
 801ec96: 370c         	adds	r7, #0xc
 801ec98: 46bd         	mov	sp, r7
 801ec9a: f85d 7b04    	ldr	r7, [sp], #4
 801ec9e: 4770         	bx	lr

0801eca0 <LL_DMA_ClearFlag_TE3>:
; {
 801eca0: b480         	push	{r7}
 801eca2: b083         	sub	sp, #0xc
 801eca4: af00         	add	r7, sp, #0x0
 801eca6: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF3);
 801eca8: 687b         	ldr	r3, [r7, #0x4]
 801ecaa: f04f 7200    	mov.w	r2, #0x2000000
 801ecae: 609a         	str	r2, [r3, #0x8]
; }
 801ecb0: bf00         	nop
 801ecb2: 370c         	adds	r7, #0xc
 801ecb4: 46bd         	mov	sp, r7
 801ecb6: f85d 7b04    	ldr	r7, [sp], #4
 801ecba: 4770         	bx	lr

0801ecbc <LL_DMA_ClearFlag_TE4>:
; {
 801ecbc: b480         	push	{r7}
 801ecbe: b083         	sub	sp, #0xc
 801ecc0: af00         	add	r7, sp, #0x0
 801ecc2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF4);
 801ecc4: 687b         	ldr	r3, [r7, #0x4]
 801ecc6: 2208         	movs	r2, #0x8
 801ecc8: 60da         	str	r2, [r3, #0xc]
; }
 801ecca: bf00         	nop
 801eccc: 370c         	adds	r7, #0xc
 801ecce: 46bd         	mov	sp, r7
 801ecd0: f85d 7b04    	ldr	r7, [sp], #4
 801ecd4: 4770         	bx	lr

0801ecd6 <LL_DMA_ClearFlag_TE5>:
; {
 801ecd6: b480         	push	{r7}
 801ecd8: b083         	sub	sp, #0xc
 801ecda: af00         	add	r7, sp, #0x0
 801ecdc: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF5);
 801ecde: 687b         	ldr	r3, [r7, #0x4]
 801ece0: f44f 7200    	mov.w	r2, #0x200
 801ece4: 60da         	str	r2, [r3, #0xc]
; }
 801ece6: bf00         	nop
 801ece8: 370c         	adds	r7, #0xc
 801ecea: 46bd         	mov	sp, r7
 801ecec: f85d 7b04    	ldr	r7, [sp], #4
 801ecf0: 4770         	bx	lr

0801ecf2 <LL_DMA_ClearFlag_TE6>:
; {
 801ecf2: b480         	push	{r7}
 801ecf4: b083         	sub	sp, #0xc
 801ecf6: af00         	add	r7, sp, #0x0
 801ecf8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF6);
 801ecfa: 687b         	ldr	r3, [r7, #0x4]
 801ecfc: f44f 2200    	mov.w	r2, #0x80000
 801ed00: 60da         	str	r2, [r3, #0xc]
; }
 801ed02: bf00         	nop
 801ed04: 370c         	adds	r7, #0xc
 801ed06: 46bd         	mov	sp, r7
 801ed08: f85d 7b04    	ldr	r7, [sp], #4
 801ed0c: 4770         	bx	lr

0801ed0e <LL_DMA_ClearFlag_TE7>:
; {
 801ed0e: b480         	push	{r7}
 801ed10: b083         	sub	sp, #0xc
 801ed12: af00         	add	r7, sp, #0x0
 801ed14: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF7);
 801ed16: 687b         	ldr	r3, [r7, #0x4]
 801ed18: f04f 7200    	mov.w	r2, #0x2000000
 801ed1c: 60da         	str	r2, [r3, #0xc]
; }
 801ed1e: bf00         	nop
 801ed20: 370c         	adds	r7, #0xc
 801ed22: 46bd         	mov	sp, r7
 801ed24: f85d 7b04    	ldr	r7, [sp], #4
 801ed28: 4770         	bx	lr

0801ed2a <LL_DMA_ClearFlag_DME0>:
; {
 801ed2a: b480         	push	{r7}
 801ed2c: b083         	sub	sp, #0xc
 801ed2e: af00         	add	r7, sp, #0x0
 801ed30: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF0);
 801ed32: 687b         	ldr	r3, [r7, #0x4]
 801ed34: 2204         	movs	r2, #0x4
 801ed36: 609a         	str	r2, [r3, #0x8]
; }
 801ed38: bf00         	nop
 801ed3a: 370c         	adds	r7, #0xc
 801ed3c: 46bd         	mov	sp, r7
 801ed3e: f85d 7b04    	ldr	r7, [sp], #4
 801ed42: 4770         	bx	lr

0801ed44 <LL_DMA_ClearFlag_DME1>:
; {
 801ed44: b480         	push	{r7}
 801ed46: b083         	sub	sp, #0xc
 801ed48: af00         	add	r7, sp, #0x0
 801ed4a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF1);
 801ed4c: 687b         	ldr	r3, [r7, #0x4]
 801ed4e: f44f 7280    	mov.w	r2, #0x100
 801ed52: 609a         	str	r2, [r3, #0x8]
; }
 801ed54: bf00         	nop
 801ed56: 370c         	adds	r7, #0xc
 801ed58: 46bd         	mov	sp, r7
 801ed5a: f85d 7b04    	ldr	r7, [sp], #4
 801ed5e: 4770         	bx	lr

0801ed60 <LL_DMA_ClearFlag_DME2>:
; {
 801ed60: b480         	push	{r7}
 801ed62: b083         	sub	sp, #0xc
 801ed64: af00         	add	r7, sp, #0x0
 801ed66: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF2);
 801ed68: 687b         	ldr	r3, [r7, #0x4]
 801ed6a: f44f 2280    	mov.w	r2, #0x40000
 801ed6e: 609a         	str	r2, [r3, #0x8]
; }
 801ed70: bf00         	nop
 801ed72: 370c         	adds	r7, #0xc
 801ed74: 46bd         	mov	sp, r7
 801ed76: f85d 7b04    	ldr	r7, [sp], #4
 801ed7a: 4770         	bx	lr

0801ed7c <LL_DMA_ClearFlag_DME3>:
; {
 801ed7c: b480         	push	{r7}
 801ed7e: b083         	sub	sp, #0xc
 801ed80: af00         	add	r7, sp, #0x0
 801ed82: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF3);
 801ed84: 687b         	ldr	r3, [r7, #0x4]
 801ed86: f04f 7280    	mov.w	r2, #0x1000000
 801ed8a: 609a         	str	r2, [r3, #0x8]
; }
 801ed8c: bf00         	nop
 801ed8e: 370c         	adds	r7, #0xc
 801ed90: 46bd         	mov	sp, r7
 801ed92: f85d 7b04    	ldr	r7, [sp], #4
 801ed96: 4770         	bx	lr

0801ed98 <LL_DMA_ClearFlag_DME4>:
; {
 801ed98: b480         	push	{r7}
 801ed9a: b083         	sub	sp, #0xc
 801ed9c: af00         	add	r7, sp, #0x0
 801ed9e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF4);
 801eda0: 687b         	ldr	r3, [r7, #0x4]
 801eda2: 2204         	movs	r2, #0x4
 801eda4: 60da         	str	r2, [r3, #0xc]
; }
 801eda6: bf00         	nop
 801eda8: 370c         	adds	r7, #0xc
 801edaa: 46bd         	mov	sp, r7
 801edac: f85d 7b04    	ldr	r7, [sp], #4
 801edb0: 4770         	bx	lr

0801edb2 <LL_DMA_ClearFlag_DME5>:
; {
 801edb2: b480         	push	{r7}
 801edb4: b083         	sub	sp, #0xc
 801edb6: af00         	add	r7, sp, #0x0
 801edb8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF5);
 801edba: 687b         	ldr	r3, [r7, #0x4]
 801edbc: f44f 7280    	mov.w	r2, #0x100
 801edc0: 60da         	str	r2, [r3, #0xc]
; }
 801edc2: bf00         	nop
 801edc4: 370c         	adds	r7, #0xc
 801edc6: 46bd         	mov	sp, r7
 801edc8: f85d 7b04    	ldr	r7, [sp], #4
 801edcc: 4770         	bx	lr

0801edce <LL_DMA_ClearFlag_DME6>:
; {
 801edce: b480         	push	{r7}
 801edd0: b083         	sub	sp, #0xc
 801edd2: af00         	add	r7, sp, #0x0
 801edd4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF6);
 801edd6: 687b         	ldr	r3, [r7, #0x4]
 801edd8: f44f 2280    	mov.w	r2, #0x40000
 801eddc: 60da         	str	r2, [r3, #0xc]
; }
 801edde: bf00         	nop
 801ede0: 370c         	adds	r7, #0xc
 801ede2: 46bd         	mov	sp, r7
 801ede4: f85d 7b04    	ldr	r7, [sp], #4
 801ede8: 4770         	bx	lr

0801edea <LL_DMA_ClearFlag_DME7>:
; {
 801edea: b480         	push	{r7}
 801edec: b083         	sub	sp, #0xc
 801edee: af00         	add	r7, sp, #0x0
 801edf0: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF7);
 801edf2: 687b         	ldr	r3, [r7, #0x4]
 801edf4: f04f 7280    	mov.w	r2, #0x1000000
 801edf8: 60da         	str	r2, [r3, #0xc]
; }
 801edfa: bf00         	nop
 801edfc: 370c         	adds	r7, #0xc
 801edfe: 46bd         	mov	sp, r7
 801ee00: f85d 7b04    	ldr	r7, [sp], #4
 801ee04: 4770         	bx	lr

0801ee06 <LL_DMA_ClearFlag_FE0>:
; {
 801ee06: b480         	push	{r7}
 801ee08: b083         	sub	sp, #0xc
 801ee0a: af00         	add	r7, sp, #0x0
 801ee0c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF0);
 801ee0e: 687b         	ldr	r3, [r7, #0x4]
 801ee10: 2201         	movs	r2, #0x1
 801ee12: 609a         	str	r2, [r3, #0x8]
; }
 801ee14: bf00         	nop
 801ee16: 370c         	adds	r7, #0xc
 801ee18: 46bd         	mov	sp, r7
 801ee1a: f85d 7b04    	ldr	r7, [sp], #4
 801ee1e: 4770         	bx	lr

0801ee20 <LL_DMA_ClearFlag_FE1>:
; {
 801ee20: b480         	push	{r7}
 801ee22: b083         	sub	sp, #0xc
 801ee24: af00         	add	r7, sp, #0x0
 801ee26: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF1);
 801ee28: 687b         	ldr	r3, [r7, #0x4]
 801ee2a: 2240         	movs	r2, #0x40
 801ee2c: 609a         	str	r2, [r3, #0x8]
; }
 801ee2e: bf00         	nop
 801ee30: 370c         	adds	r7, #0xc
 801ee32: 46bd         	mov	sp, r7
 801ee34: f85d 7b04    	ldr	r7, [sp], #4
 801ee38: 4770         	bx	lr

0801ee3a <LL_DMA_ClearFlag_FE2>:
; {
 801ee3a: b480         	push	{r7}
 801ee3c: b083         	sub	sp, #0xc
 801ee3e: af00         	add	r7, sp, #0x0
 801ee40: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF2);
 801ee42: 687b         	ldr	r3, [r7, #0x4]
 801ee44: f44f 3280    	mov.w	r2, #0x10000
 801ee48: 609a         	str	r2, [r3, #0x8]
; }
 801ee4a: bf00         	nop
 801ee4c: 370c         	adds	r7, #0xc
 801ee4e: 46bd         	mov	sp, r7
 801ee50: f85d 7b04    	ldr	r7, [sp], #4
 801ee54: 4770         	bx	lr

0801ee56 <LL_DMA_ClearFlag_FE3>:
; {
 801ee56: b480         	push	{r7}
 801ee58: b083         	sub	sp, #0xc
 801ee5a: af00         	add	r7, sp, #0x0
 801ee5c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF3);
 801ee5e: 687b         	ldr	r3, [r7, #0x4]
 801ee60: f44f 0280    	mov.w	r2, #0x400000
 801ee64: 609a         	str	r2, [r3, #0x8]
; }
 801ee66: bf00         	nop
 801ee68: 370c         	adds	r7, #0xc
 801ee6a: 46bd         	mov	sp, r7
 801ee6c: f85d 7b04    	ldr	r7, [sp], #4
 801ee70: 4770         	bx	lr

0801ee72 <LL_DMA_ClearFlag_FE4>:
; {
 801ee72: b480         	push	{r7}
 801ee74: b083         	sub	sp, #0xc
 801ee76: af00         	add	r7, sp, #0x0
 801ee78: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF4);
 801ee7a: 687b         	ldr	r3, [r7, #0x4]
 801ee7c: 2201         	movs	r2, #0x1
 801ee7e: 60da         	str	r2, [r3, #0xc]
; }
 801ee80: bf00         	nop
 801ee82: 370c         	adds	r7, #0xc
 801ee84: 46bd         	mov	sp, r7
 801ee86: f85d 7b04    	ldr	r7, [sp], #4
 801ee8a: 4770         	bx	lr

0801ee8c <LL_DMA_ClearFlag_FE5>:
; {
 801ee8c: b480         	push	{r7}
 801ee8e: b083         	sub	sp, #0xc
 801ee90: af00         	add	r7, sp, #0x0
 801ee92: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF5);
 801ee94: 687b         	ldr	r3, [r7, #0x4]
 801ee96: 2240         	movs	r2, #0x40
 801ee98: 60da         	str	r2, [r3, #0xc]
; }
 801ee9a: bf00         	nop
 801ee9c: 370c         	adds	r7, #0xc
 801ee9e: 46bd         	mov	sp, r7
 801eea0: f85d 7b04    	ldr	r7, [sp], #4
 801eea4: 4770         	bx	lr

0801eea6 <LL_DMA_ClearFlag_FE6>:
; {
 801eea6: b480         	push	{r7}
 801eea8: b083         	sub	sp, #0xc
 801eeaa: af00         	add	r7, sp, #0x0
 801eeac: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF6);
 801eeae: 687b         	ldr	r3, [r7, #0x4]
 801eeb0: f44f 3280    	mov.w	r2, #0x10000
 801eeb4: 60da         	str	r2, [r3, #0xc]
; }
 801eeb6: bf00         	nop
 801eeb8: 370c         	adds	r7, #0xc
 801eeba: 46bd         	mov	sp, r7
 801eebc: f85d 7b04    	ldr	r7, [sp], #4
 801eec0: 4770         	bx	lr

0801eec2 <LL_DMA_ClearFlag_FE7>:
; {
 801eec2: b480         	push	{r7}
 801eec4: b083         	sub	sp, #0xc
 801eec6: af00         	add	r7, sp, #0x0
 801eec8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF7);
 801eeca: 687b         	ldr	r3, [r7, #0x4]
 801eecc: f44f 0280    	mov.w	r2, #0x400000
 801eed0: 60da         	str	r2, [r3, #0xc]
; }
 801eed2: bf00         	nop
 801eed4: 370c         	adds	r7, #0xc
 801eed6: 46bd         	mov	sp, r7
 801eed8: f85d 7b04    	ldr	r7, [sp], #4
 801eedc: 4770         	bx	lr

0801eede <z_log_msg_runtime_create>:
; {
 801eede: b580         	push	{r7, lr}
 801eee0: b08a         	sub	sp, #0x28
 801eee2: af04         	add	r7, sp, #0x10
 801eee4: 60b9         	str	r1, [r7, #0x8]
 801eee6: 607b         	str	r3, [r7, #0x4]
 801eee8: 4603         	mov	r3, r0
 801eeea: 73fb         	strb	r3, [r7, #0xf]
 801eeec: 4613         	mov	r3, r2
 801eeee: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801eef0: f107 032c    	add.w	r3, r7, #0x2c
 801eef4: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801eef6: 7bba         	ldrb	r2, [r7, #0xe]
 801eef8: 7bf8         	ldrb	r0, [r7, #0xf]
 801eefa: 697b         	ldr	r3, [r7, #0x14]
 801eefc: 9303         	str	r3, [sp, #0xc]
 801eefe: 6abb         	ldr	r3, [r7, #0x28]
 801ef00: 9302         	str	r3, [sp, #0x8]
 801ef02: 6a7b         	ldr	r3, [r7, #0x24]
 801ef04: 9301         	str	r3, [sp, #0x4]
 801ef06: 6a3b         	ldr	r3, [r7, #0x20]
 801ef08: 9300         	str	r3, [sp]
 801ef0a: 687b         	ldr	r3, [r7, #0x4]
 801ef0c: 68b9         	ldr	r1, [r7, #0x8]
 801ef0e: f7e5 fe19    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x1a3ce
; }
 801ef12: bf00         	nop
 801ef14: 3718         	adds	r7, #0x18
 801ef16: 46bd         	mov	sp, r7
 801ef18: bd80         	pop	{r7, pc}

0801ef1a <stm32_dma_is_tc_irq_active>:
; {
 801ef1a: b580         	push	{r7, lr}
 801ef1c: b082         	sub	sp, #0x8
 801ef1e: af00         	add	r7, sp, #0x0
 801ef20: 6078         	str	r0, [r7, #0x4]
 801ef22: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 801ef24: 6838         	ldr	r0, [r7]
 801ef26: f7eb fd6b    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x1452a
 801ef2a: 4603         	mov	r3, r0
 801ef2c: 4619         	mov	r1, r3
 801ef2e: 6878         	ldr	r0, [r7, #0x4]
 801ef30: f7eb fd2e    	bl	0x800a990 <LL_DMA_IsEnabledIT_TC> @ imm = #-0x145a4
 801ef34: 4603         	mov	r3, r0
 801ef36: 2b00         	cmp	r3, #0x0
 801ef38: d008         	beq	0x801ef4c <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_tc_active(dma, id);
 801ef3a: 6839         	ldr	r1, [r7]
 801ef3c: 6878         	ldr	r0, [r7, #0x4]
 801ef3e: f7eb fdbb    	bl	0x800aab8 <dma_stm32_is_tc_active> @ imm = #-0x1448a
 801ef42: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 801ef44: 2b00         	cmp	r3, #0x0
 801ef46: d001         	beq	0x801ef4c <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x2
 801ef48: 2301         	movs	r3, #0x1
 801ef4a: e000         	b	0x801ef4e <stm32_dma_is_tc_irq_active+0x34> @ imm = #0x0
 801ef4c: 2300         	movs	r3, #0x0
 801ef4e: f003 0301    	and	r3, r3, #0x1
 801ef52: b2db         	uxtb	r3, r3
; }
 801ef54: 4618         	mov	r0, r3
 801ef56: 3708         	adds	r7, #0x8
 801ef58: 46bd         	mov	sp, r7
 801ef5a: bd80         	pop	{r7, pc}

0801ef5c <stm32_dma_is_ht_irq_active>:
; {
 801ef5c: b580         	push	{r7, lr}
 801ef5e: b082         	sub	sp, #0x8
 801ef60: af00         	add	r7, sp, #0x0
 801ef62: 6078         	str	r0, [r7, #0x4]
 801ef64: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 801ef66: 6838         	ldr	r0, [r7]
 801ef68: f7eb fd4a    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x1456c
 801ef6c: 4603         	mov	r3, r0
 801ef6e: 4619         	mov	r1, r3
 801ef70: 6878         	ldr	r0, [r7, #0x4]
 801ef72: f7eb fcf1    	bl	0x800a958 <LL_DMA_IsEnabledIT_HT> @ imm = #-0x1461e
 801ef76: 4603         	mov	r3, r0
 801ef78: 2b00         	cmp	r3, #0x0
 801ef7a: d008         	beq	0x801ef8e <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_ht_active(dma, id);
 801ef7c: 6839         	ldr	r1, [r7]
 801ef7e: 6878         	ldr	r0, [r7, #0x4]
 801ef80: f7eb fd82    	bl	0x800aa88 <dma_stm32_is_ht_active> @ imm = #-0x144fc
 801ef84: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 801ef86: 2b00         	cmp	r3, #0x0
 801ef88: d001         	beq	0x801ef8e <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x2
 801ef8a: 2301         	movs	r3, #0x1
 801ef8c: e000         	b	0x801ef90 <stm32_dma_is_ht_irq_active+0x34> @ imm = #0x0
 801ef8e: 2300         	movs	r3, #0x0
 801ef90: f003 0301    	and	r3, r3, #0x1
 801ef94: b2db         	uxtb	r3, r3
; }
 801ef96: 4618         	mov	r0, r3
 801ef98: 3708         	adds	r7, #0x8
 801ef9a: 46bd         	mov	sp, r7
 801ef9c: bd80         	pop	{r7, pc}

0801ef9e <stm32_dma_clear_stream_irq>:
; {
 801ef9e: b580         	push	{r7, lr}
 801efa0: b082         	sub	sp, #0x8
 801efa2: af00         	add	r7, sp, #0x0
 801efa4: 6078         	str	r0, [r7, #0x4]
 801efa6: 6039         	str	r1, [r7]
; 	dma_stm32_clear_te(dma, id);
 801efa8: 6839         	ldr	r1, [r7]
 801efaa: 6878         	ldr	r0, [r7, #0x4]
 801efac: f7eb fd9c    	bl	0x800aae8 <dma_stm32_clear_te> @ imm = #-0x144c8
; 	dma_stm32_clear_dme(dma, id);
 801efb0: 6839         	ldr	r1, [r7]
 801efb2: 6878         	ldr	r0, [r7, #0x4]
 801efb4: f7eb fdaa    	bl	0x800ab0c <dma_stm32_clear_dme> @ imm = #-0x144ac
; 	dma_stm32_clear_fe(dma, id);
 801efb8: 6839         	ldr	r1, [r7]
 801efba: 6878         	ldr	r0, [r7, #0x4]
 801efbc: f7eb fdb8    	bl	0x800ab30 <dma_stm32_clear_fe> @ imm = #-0x14490
; }
 801efc0: bf00         	nop
 801efc2: 3708         	adds	r7, #0x8
 801efc4: 46bd         	mov	sp, r7
 801efc6: bd80         	pop	{r7, pc}

0801efc8 <stm32_dma_enable_stream>:
; {
 801efc8: b580         	push	{r7, lr}
 801efca: b082         	sub	sp, #0x8
 801efcc: af00         	add	r7, sp, #0x0
 801efce: 6078         	str	r0, [r7, #0x4]
 801efd0: 6039         	str	r1, [r7]
; 	LL_DMA_EnableStream(dma, dma_stm32_id_to_stream(id));
 801efd2: 6838         	ldr	r0, [r7]
 801efd4: f7eb fd14    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x145d8
 801efd8: 4603         	mov	r3, r0
 801efda: 4619         	mov	r1, r3
 801efdc: 6878         	ldr	r0, [r7, #0x4]
 801efde: f7eb fc3f    	bl	0x800a860 <LL_DMA_EnableStream> @ imm = #-0x14782
; }
 801efe2: bf00         	nop
 801efe4: 3708         	adds	r7, #0x8
 801efe6: 46bd         	mov	sp, r7
 801efe8: bd80         	pop	{r7, pc}

0801efea <stm32_dma_is_enabled_stream>:
; {
 801efea: b580         	push	{r7, lr}
 801efec: b082         	sub	sp, #0x8
 801efee: af00         	add	r7, sp, #0x0
 801eff0: 6078         	str	r0, [r7, #0x4]
 801eff2: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledStream(dma, dma_stm32_id_to_stream(id)) == 1) {
 801eff4: 6838         	ldr	r0, [r7]
 801eff6: f7eb fd03    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x145fa
 801effa: 4603         	mov	r3, r0
 801effc: 4619         	mov	r1, r3
 801effe: 6878         	ldr	r0, [r7, #0x4]
 801f000: f7eb fc6e    	bl	0x800a8e0 <LL_DMA_IsEnabledStream> @ imm = #-0x14724
 801f004: 4603         	mov	r3, r0
 801f006: 2b01         	cmp	r3, #0x1
 801f008: d101         	bne	0x801f00e <stm32_dma_is_enabled_stream+0x24> @ imm = #0x2
; 		return true;
 801f00a: 2301         	movs	r3, #0x1
 801f00c: e000         	b	0x801f010 <stm32_dma_is_enabled_stream+0x26> @ imm = #0x0
; 	return false;
 801f00e: 2300         	movs	r3, #0x0
; }
 801f010: 4618         	mov	r0, r3
 801f012: 3708         	adds	r7, #0x8
 801f014: 46bd         	mov	sp, r7
 801f016: bd80         	pop	{r7, pc}

0801f018 <stm32_dma_disable_stream>:
; {
 801f018: b580         	push	{r7, lr}
 801f01a: b082         	sub	sp, #0x8
 801f01c: af00         	add	r7, sp, #0x0
 801f01e: 6078         	str	r0, [r7, #0x4]
 801f020: 6039         	str	r1, [r7]
; 	LL_DMA_DisableStream(dma, dma_stm32_id_to_stream(id));
 801f022: 6838         	ldr	r0, [r7]
 801f024: f7eb fcec    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x14628
 801f028: 4603         	mov	r3, r0
 801f02a: 4619         	mov	r1, r3
 801f02c: 6878         	ldr	r0, [r7, #0x4]
 801f02e: f7eb fc37    	bl	0x800a8a0 <LL_DMA_DisableStream> @ imm = #-0x14792
; 	while (stm32_dma_is_enabled_stream(dma, id)) {
 801f032: bf00         	nop
 801f034: 6839         	ldr	r1, [r7]
 801f036: 6878         	ldr	r0, [r7, #0x4]
 801f038: f7ff ffd7    	bl	0x801efea <stm32_dma_is_enabled_stream> @ imm = #-0x52
 801f03c: 4603         	mov	r3, r0
 801f03e: 2b00         	cmp	r3, #0x0
 801f040: d1f8         	bne	0x801f034 <stm32_dma_disable_stream+0x1c> @ imm = #-0x10
; 	dma_stm32_clear_tc(dma, id);
 801f042: 6839         	ldr	r1, [r7]
 801f044: 6878         	ldr	r0, [r7, #0x4]
 801f046: f7eb fd0d    	bl	0x800aa64 <dma_stm32_clear_tc> @ imm = #-0x145e6
; 	return 0;
 801f04a: 2300         	movs	r3, #0x0
; }
 801f04c: 4618         	mov	r0, r3
 801f04e: 3708         	adds	r7, #0x8
 801f050: 46bd         	mov	sp, r7
 801f052: bd80         	pop	{r7, pc}

0801f054 <stm32_dma_disable_fifo_irq>:
; {
 801f054: b580         	push	{r7, lr}
 801f056: b082         	sub	sp, #0x8
 801f058: af00         	add	r7, sp, #0x0
 801f05a: 6078         	str	r0, [r7, #0x4]
 801f05c: 6039         	str	r1, [r7]
; 	LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 801f05e: 6838         	ldr	r0, [r7]
 801f060: f7eb fcce    	bl	0x800aa00 <dma_stm32_id_to_stream> @ imm = #-0x14664
 801f064: 4603         	mov	r3, r0
 801f066: 4619         	mov	r1, r3
 801f068: 6878         	ldr	r0, [r7, #0x4]
 801f06a: f7eb fc55    	bl	0x800a918 <LL_DMA_DisableIT_FE> @ imm = #-0x14756
; }
 801f06e: bf00         	nop
 801f070: 3708         	adds	r7, #0x8
 801f072: 46bd         	mov	sp, r7
 801f074: bd80         	pop	{r7, pc}

0801f076 <stm32_dma_check_fifo_mburst>:
; {
 801f076: b480         	push	{r7}
 801f078: b087         	sub	sp, #0x1c
 801f07a: af00         	add	r7, sp, #0x0
 801f07c: 6078         	str	r0, [r7, #0x4]
; 	uint32_t msize = DMAx->MemoryOrM2MDstDataSize;
 801f07e: 687b         	ldr	r3, [r7, #0x4]
 801f080: 69db         	ldr	r3, [r3, #0x1c]
 801f082: 617b         	str	r3, [r7, #0x14]
; 	uint32_t fifo_level = DMAx->FIFOThreshold;
 801f084: 687b         	ldr	r3, [r7, #0x4]
 801f086: 6b1b         	ldr	r3, [r3, #0x30]
 801f088: 613b         	str	r3, [r7, #0x10]
; 	uint32_t mburst = DMAx->MemBurst;
 801f08a: 687b         	ldr	r3, [r7, #0x4]
 801f08c: 6b5b         	ldr	r3, [r3, #0x34]
 801f08e: 60fb         	str	r3, [r7, #0xc]
; 	switch (msize) {
 801f090: 697b         	ldr	r3, [r7, #0x14]
 801f092: f5b3 4f80    	cmp.w	r3, #0x4000
 801f096: d049         	beq	0x801f12c <stm32_dma_check_fifo_mburst+0xb6> @ imm = #0x92
 801f098: 697b         	ldr	r3, [r7, #0x14]
 801f09a: f5b3 4f80    	cmp.w	r3, #0x4000
 801f09e: d84f         	bhi	0x801f140 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x9e
 801f0a0: 697b         	ldr	r3, [r7, #0x14]
 801f0a2: 2b00         	cmp	r3, #0x0
 801f0a4: d004         	beq	0x801f0b0 <stm32_dma_check_fifo_mburst+0x3a> @ imm = #0x8
 801f0a6: 697b         	ldr	r3, [r7, #0x14]
 801f0a8: f5b3 5f00    	cmp.w	r3, #0x2000
 801f0ac: d024         	beq	0x801f0f8 <stm32_dma_check_fifo_mburst+0x82> @ imm = #0x48
 801f0ae: e047         	b	0x801f140 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x8e
 801f0b0: 68fb         	ldr	r3, [r7, #0xc]
 801f0b2: f1b3 7fc0    	cmp.w	r3, #0x1800000
 801f0b6: d016         	beq	0x801f0e6 <stm32_dma_check_fifo_mburst+0x70> @ imm = #0x2c
 801f0b8: 68fb         	ldr	r3, [r7, #0xc]
 801f0ba: f1b3 7fc0    	cmp.w	r3, #0x1800000
 801f0be: d83e         	bhi	0x801f13e <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x7c
 801f0c0: 68fb         	ldr	r3, [r7, #0xc]
 801f0c2: f5b3 0f00    	cmp.w	r3, #0x800000
 801f0c6: d004         	beq	0x801f0d2 <stm32_dma_check_fifo_mburst+0x5c> @ imm = #0x8
 801f0c8: 68fb         	ldr	r3, [r7, #0xc]
 801f0ca: f1b3 7f80    	cmp.w	r3, #0x1000000
 801f0ce: d002         	beq	0x801f0d6 <stm32_dma_check_fifo_mburst+0x60> @ imm = #0x4
; 		break;
 801f0d0: e035         	b	0x801f13e <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x6a
; 			return true;
 801f0d2: 2301         	movs	r3, #0x1
 801f0d4: e035         	b	0x801f142 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x6a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 801f0d6: 693b         	ldr	r3, [r7, #0x10]
 801f0d8: 2b01         	cmp	r3, #0x1
 801f0da: d002         	beq	0x801f0e2 <stm32_dma_check_fifo_mburst+0x6c> @ imm = #0x4
 801f0dc: 693b         	ldr	r3, [r7, #0x10]
 801f0de: 2b03         	cmp	r3, #0x3
 801f0e0: d106         	bne	0x801f0f0 <stm32_dma_check_fifo_mburst+0x7a> @ imm = #0xc
; 				return true;
 801f0e2: 2301         	movs	r3, #0x1
 801f0e4: e02d         	b	0x801f142 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x5a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 801f0e6: 693b         	ldr	r3, [r7, #0x10]
 801f0e8: 2b03         	cmp	r3, #0x3
 801f0ea: d103         	bne	0x801f0f4 <stm32_dma_check_fifo_mburst+0x7e> @ imm = #0x6
; 				return true;
 801f0ec: 2301         	movs	r3, #0x1
 801f0ee: e028         	b	0x801f142 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x50
; 			break;
 801f0f0: bf00         	nop
 801f0f2: e024         	b	0x801f13e <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x48
; 			break;
 801f0f4: bf00         	nop
; 		break;
 801f0f6: e022         	b	0x801f13e <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x44
 801f0f8: 68fb         	ldr	r3, [r7, #0xc]
 801f0fa: f5b3 0f00    	cmp.w	r3, #0x800000
 801f0fe: d004         	beq	0x801f10a <stm32_dma_check_fifo_mburst+0x94> @ imm = #0x8
 801f100: 68fb         	ldr	r3, [r7, #0xc]
 801f102: f1b3 7f80    	cmp.w	r3, #0x1000000
 801f106: d008         	beq	0x801f11a <stm32_dma_check_fifo_mburst+0xa4> @ imm = #0x10
; 		break;
 801f108: e01a         	b	0x801f140 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x34
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 801f10a: 693b         	ldr	r3, [r7, #0x10]
 801f10c: 2b01         	cmp	r3, #0x1
 801f10e: d002         	beq	0x801f116 <stm32_dma_check_fifo_mburst+0xa0> @ imm = #0x4
 801f110: 693b         	ldr	r3, [r7, #0x10]
 801f112: 2b03         	cmp	r3, #0x3
 801f114: d106         	bne	0x801f124 <stm32_dma_check_fifo_mburst+0xae> @ imm = #0xc
; 				return true;
 801f116: 2301         	movs	r3, #0x1
 801f118: e013         	b	0x801f142 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x26
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 801f11a: 693b         	ldr	r3, [r7, #0x10]
 801f11c: 2b03         	cmp	r3, #0x3
 801f11e: d103         	bne	0x801f128 <stm32_dma_check_fifo_mburst+0xb2> @ imm = #0x6
; 				return true;
 801f120: 2301         	movs	r3, #0x1
 801f122: e00e         	b	0x801f142 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x1c
; 			break;
 801f124: bf00         	nop
 801f126: e00b         	b	0x801f140 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x16
; 			break;
 801f128: bf00         	nop
; 		break;
 801f12a: e009         	b	0x801f140 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x12
; 		if (mburst == LL_DMA_MBURST_INC4 &&
 801f12c: 68fb         	ldr	r3, [r7, #0xc]
 801f12e: f5b3 0f00    	cmp.w	r3, #0x800000
 801f132: d105         	bne	0x801f140 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0xa
 801f134: 693b         	ldr	r3, [r7, #0x10]
 801f136: 2b03         	cmp	r3, #0x3
 801f138: d102         	bne	0x801f140 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x4
; 			return true;
 801f13a: 2301         	movs	r3, #0x1
 801f13c: e001         	b	0x801f142 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x2
; 		break;
 801f13e: bf00         	nop
; 	return false;
 801f140: 2300         	movs	r3, #0x0
; }
 801f142: 4618         	mov	r0, r3
 801f144: 371c         	adds	r7, #0x1c
 801f146: 46bd         	mov	sp, r7
 801f148: f85d 7b04    	ldr	r7, [sp], #4
 801f14c: 4770         	bx	lr

0801f14e <z_snode_next_peek>:
; {
 801f14e: b480         	push	{r7}
 801f150: b083         	sub	sp, #0xc
 801f152: af00         	add	r7, sp, #0x0
 801f154: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 801f156: 687b         	ldr	r3, [r7, #0x4]
 801f158: 681b         	ldr	r3, [r3]
; }
 801f15a: 4618         	mov	r0, r3
 801f15c: 370c         	adds	r7, #0xc
 801f15e: 46bd         	mov	sp, r7
 801f160: f85d 7b04    	ldr	r7, [sp], #4
 801f164: 4770         	bx	lr

0801f166 <z_snode_next_set>:
; {
 801f166: b480         	push	{r7}
 801f168: b083         	sub	sp, #0xc
 801f16a: af00         	add	r7, sp, #0x0
 801f16c: 6078         	str	r0, [r7, #0x4]
 801f16e: 6039         	str	r1, [r7]
; 	parent->next = child;
 801f170: 687b         	ldr	r3, [r7, #0x4]
 801f172: 683a         	ldr	r2, [r7]
 801f174: 601a         	str	r2, [r3]
; }
 801f176: bf00         	nop
 801f178: 370c         	adds	r7, #0xc
 801f17a: 46bd         	mov	sp, r7
 801f17c: f85d 7b04    	ldr	r7, [sp], #4
 801f180: 4770         	bx	lr

0801f182 <z_slist_head_set>:
; {
 801f182: b480         	push	{r7}
 801f184: b083         	sub	sp, #0xc
 801f186: af00         	add	r7, sp, #0x0
 801f188: 6078         	str	r0, [r7, #0x4]
 801f18a: 6039         	str	r1, [r7]
; 	list->head = node;
 801f18c: 687b         	ldr	r3, [r7, #0x4]
 801f18e: 683a         	ldr	r2, [r7]
 801f190: 601a         	str	r2, [r3]
; }
 801f192: bf00         	nop
 801f194: 370c         	adds	r7, #0xc
 801f196: 46bd         	mov	sp, r7
 801f198: f85d 7b04    	ldr	r7, [sp], #4
 801f19c: 4770         	bx	lr

0801f19e <z_slist_tail_set>:
; {
 801f19e: b480         	push	{r7}
 801f1a0: b083         	sub	sp, #0xc
 801f1a2: af00         	add	r7, sp, #0x0
 801f1a4: 6078         	str	r0, [r7, #0x4]
 801f1a6: 6039         	str	r1, [r7]
; 	list->tail = node;
 801f1a8: 687b         	ldr	r3, [r7, #0x4]
 801f1aa: 683a         	ldr	r2, [r7]
 801f1ac: 605a         	str	r2, [r3, #0x4]
; }
 801f1ae: bf00         	nop
 801f1b0: 370c         	adds	r7, #0xc
 801f1b2: 46bd         	mov	sp, r7
 801f1b4: f85d 7b04    	ldr	r7, [sp], #4
 801f1b8: 4770         	bx	lr

0801f1ba <sys_slist_peek_head>:
; {
 801f1ba: b480         	push	{r7}
 801f1bc: b083         	sub	sp, #0xc
 801f1be: af00         	add	r7, sp, #0x0
 801f1c0: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 801f1c2: 687b         	ldr	r3, [r7, #0x4]
 801f1c4: 681b         	ldr	r3, [r3]
; }
 801f1c6: 4618         	mov	r0, r3
 801f1c8: 370c         	adds	r7, #0xc
 801f1ca: 46bd         	mov	sp, r7
 801f1cc: f85d 7b04    	ldr	r7, [sp], #4
 801f1d0: 4770         	bx	lr

0801f1d2 <sys_slist_peek_tail>:
; {
 801f1d2: b480         	push	{r7}
 801f1d4: b083         	sub	sp, #0xc
 801f1d6: af00         	add	r7, sp, #0x0
 801f1d8: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 801f1da: 687b         	ldr	r3, [r7, #0x4]
 801f1dc: 685b         	ldr	r3, [r3, #0x4]
; }
 801f1de: 4618         	mov	r0, r3
 801f1e0: 370c         	adds	r7, #0xc
 801f1e2: 46bd         	mov	sp, r7
 801f1e4: f85d 7b04    	ldr	r7, [sp], #4
 801f1e8: 4770         	bx	lr

0801f1ea <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 801f1ea: b580         	push	{r7, lr}
 801f1ec: b082         	sub	sp, #0x8
 801f1ee: af00         	add	r7, sp, #0x0
 801f1f0: 6078         	str	r0, [r7, #0x4]
 801f1f2: 6878         	ldr	r0, [r7, #0x4]
 801f1f4: f7ff ffe1    	bl	0x801f1ba <sys_slist_peek_head> @ imm = #-0x3e
 801f1f8: 4603         	mov	r3, r0
 801f1fa: 2b00         	cmp	r3, #0x0
 801f1fc: bf0c         	ite	eq
 801f1fe: 2301         	moveq	r3, #0x1
 801f200: 2300         	movne	r3, #0x0
 801f202: b2db         	uxtb	r3, r3
 801f204: 4618         	mov	r0, r3
 801f206: 3708         	adds	r7, #0x8
 801f208: 46bd         	mov	sp, r7
 801f20a: bd80         	pop	{r7, pc}

0801f20c <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 801f20c: b580         	push	{r7, lr}
 801f20e: b082         	sub	sp, #0x8
 801f210: af00         	add	r7, sp, #0x0
 801f212: 6078         	str	r0, [r7, #0x4]
 801f214: 6878         	ldr	r0, [r7, #0x4]
 801f216: f7ff ff9a    	bl	0x801f14e <z_snode_next_peek> @ imm = #-0xcc
 801f21a: 4603         	mov	r3, r0
 801f21c: 4618         	mov	r0, r3
 801f21e: 3708         	adds	r7, #0x8
 801f220: 46bd         	mov	sp, r7
 801f222: bd80         	pop	{r7, pc}

0801f224 <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801f224: b580         	push	{r7, lr}
 801f226: b082         	sub	sp, #0x8
 801f228: af00         	add	r7, sp, #0x0
 801f22a: 6078         	str	r0, [r7, #0x4]
 801f22c: 687b         	ldr	r3, [r7, #0x4]
 801f22e: 2b00         	cmp	r3, #0x0
 801f230: d004         	beq	0x801f23c <sys_slist_peek_next+0x18> @ imm = #0x8
 801f232: 6878         	ldr	r0, [r7, #0x4]
 801f234: f7ff ffea    	bl	0x801f20c <sys_slist_peek_next_no_check> @ imm = #-0x2c
 801f238: 4603         	mov	r3, r0
 801f23a: e000         	b	0x801f23e <sys_slist_peek_next+0x1a> @ imm = #0x0
 801f23c: 2300         	movs	r3, #0x0
 801f23e: 4618         	mov	r0, r3
 801f240: 3708         	adds	r7, #0x8
 801f242: 46bd         	mov	sp, r7
 801f244: bd80         	pop	{r7, pc}

0801f246 <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 801f246: b580         	push	{r7, lr}
 801f248: b082         	sub	sp, #0x8
 801f24a: af00         	add	r7, sp, #0x0
 801f24c: 6078         	str	r0, [r7, #0x4]
 801f24e: 6039         	str	r1, [r7]
 801f250: 6878         	ldr	r0, [r7, #0x4]
 801f252: f7ff ffb2    	bl	0x801f1ba <sys_slist_peek_head> @ imm = #-0x9c
 801f256: 4603         	mov	r3, r0
 801f258: 4619         	mov	r1, r3
 801f25a: 6838         	ldr	r0, [r7]
 801f25c: f7ff ff83    	bl	0x801f166 <z_snode_next_set> @ imm = #-0xfa
 801f260: 6839         	ldr	r1, [r7]
 801f262: 6878         	ldr	r0, [r7, #0x4]
 801f264: f7ff ff8d    	bl	0x801f182 <z_slist_head_set> @ imm = #-0xe6
 801f268: 6878         	ldr	r0, [r7, #0x4]
 801f26a: f7ff ffb2    	bl	0x801f1d2 <sys_slist_peek_tail> @ imm = #-0x9c
 801f26e: 4603         	mov	r3, r0
 801f270: 2b00         	cmp	r3, #0x0
 801f272: d107         	bne	0x801f284 <sys_slist_prepend+0x3e> @ imm = #0xe
 801f274: 6878         	ldr	r0, [r7, #0x4]
 801f276: f7ff ffa0    	bl	0x801f1ba <sys_slist_peek_head> @ imm = #-0xc0
 801f27a: 4603         	mov	r3, r0
 801f27c: 4619         	mov	r1, r3
 801f27e: 6878         	ldr	r0, [r7, #0x4]
 801f280: f7ff ff8d    	bl	0x801f19e <z_slist_tail_set> @ imm = #-0xe6
 801f284: 3708         	adds	r7, #0x8
 801f286: 46bd         	mov	sp, r7
 801f288: bd80         	pop	{r7, pc}

0801f28a <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 801f28a: b580         	push	{r7, lr}
 801f28c: b084         	sub	sp, #0x10
 801f28e: af00         	add	r7, sp, #0x0
 801f290: 60f8         	str	r0, [r7, #0xc]
 801f292: 60b9         	str	r1, [r7, #0x8]
 801f294: 607a         	str	r2, [r7, #0x4]
 801f296: 68bb         	ldr	r3, [r7, #0x8]
 801f298: 2b00         	cmp	r3, #0x0
 801f29a: d117         	bne	0x801f2cc <sys_slist_remove+0x42> @ imm = #0x2e
 801f29c: 6878         	ldr	r0, [r7, #0x4]
 801f29e: f7ff ff56    	bl	0x801f14e <z_snode_next_peek> @ imm = #-0x154
 801f2a2: 4603         	mov	r3, r0
 801f2a4: 4619         	mov	r1, r3
 801f2a6: 68f8         	ldr	r0, [r7, #0xc]
 801f2a8: f7ff ff6b    	bl	0x801f182 <z_slist_head_set> @ imm = #-0x12a
 801f2ac: 68f8         	ldr	r0, [r7, #0xc]
 801f2ae: f7ff ff90    	bl	0x801f1d2 <sys_slist_peek_tail> @ imm = #-0xe0
 801f2b2: 4602         	mov	r2, r0
 801f2b4: 687b         	ldr	r3, [r7, #0x4]
 801f2b6: 4293         	cmp	r3, r2
 801f2b8: d11b         	bne	0x801f2f2 <sys_slist_remove+0x68> @ imm = #0x36
 801f2ba: 68f8         	ldr	r0, [r7, #0xc]
 801f2bc: f7ff ff7d    	bl	0x801f1ba <sys_slist_peek_head> @ imm = #-0x106
 801f2c0: 4603         	mov	r3, r0
 801f2c2: 4619         	mov	r1, r3
 801f2c4: 68f8         	ldr	r0, [r7, #0xc]
 801f2c6: f7ff ff6a    	bl	0x801f19e <z_slist_tail_set> @ imm = #-0x12c
 801f2ca: e012         	b	0x801f2f2 <sys_slist_remove+0x68> @ imm = #0x24
 801f2cc: 6878         	ldr	r0, [r7, #0x4]
 801f2ce: f7ff ff3e    	bl	0x801f14e <z_snode_next_peek> @ imm = #-0x184
 801f2d2: 4603         	mov	r3, r0
 801f2d4: 4619         	mov	r1, r3
 801f2d6: 68b8         	ldr	r0, [r7, #0x8]
 801f2d8: f7ff ff45    	bl	0x801f166 <z_snode_next_set> @ imm = #-0x176
 801f2dc: 68f8         	ldr	r0, [r7, #0xc]
 801f2de: f7ff ff78    	bl	0x801f1d2 <sys_slist_peek_tail> @ imm = #-0x110
 801f2e2: 4602         	mov	r2, r0
 801f2e4: 687b         	ldr	r3, [r7, #0x4]
 801f2e6: 4293         	cmp	r3, r2
 801f2e8: d103         	bne	0x801f2f2 <sys_slist_remove+0x68> @ imm = #0x6
 801f2ea: 68b9         	ldr	r1, [r7, #0x8]
 801f2ec: 68f8         	ldr	r0, [r7, #0xc]
 801f2ee: f7ff ff56    	bl	0x801f19e <z_slist_tail_set> @ imm = #-0x154
 801f2f2: 2100         	movs	r1, #0x0
 801f2f4: 6878         	ldr	r0, [r7, #0x4]
 801f2f6: f7ff ff36    	bl	0x801f166 <z_snode_next_set> @ imm = #-0x194
 801f2fa: 3710         	adds	r7, #0x10
 801f2fc: 46bd         	mov	sp, r7
 801f2fe: bd80         	pop	{r7, pc}

0801f300 <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 801f300: b580         	push	{r7, lr}
 801f302: b084         	sub	sp, #0x10
 801f304: af00         	add	r7, sp, #0x0
 801f306: 6078         	str	r0, [r7, #0x4]
 801f308: 6039         	str	r1, [r7]
 801f30a: 2300         	movs	r3, #0x0
 801f30c: 60fb         	str	r3, [r7, #0xc]
 801f30e: 6878         	ldr	r0, [r7, #0x4]
 801f310: f7ff ff53    	bl	0x801f1ba <sys_slist_peek_head> @ imm = #-0x15a
 801f314: 60b8         	str	r0, [r7, #0x8]
 801f316: e010         	b	0x801f33a <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 801f318: 68ba         	ldr	r2, [r7, #0x8]
 801f31a: 683b         	ldr	r3, [r7]
 801f31c: 429a         	cmp	r2, r3
 801f31e: d106         	bne	0x801f32e <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 801f320: 683a         	ldr	r2, [r7]
 801f322: 68f9         	ldr	r1, [r7, #0xc]
 801f324: 6878         	ldr	r0, [r7, #0x4]
 801f326: f7ff ffb0    	bl	0x801f28a <sys_slist_remove> @ imm = #-0xa0
 801f32a: 2301         	movs	r3, #0x1
 801f32c: e009         	b	0x801f342 <sys_slist_find_and_remove+0x42> @ imm = #0x12
 801f32e: 68bb         	ldr	r3, [r7, #0x8]
 801f330: 60fb         	str	r3, [r7, #0xc]
 801f332: 68b8         	ldr	r0, [r7, #0x8]
 801f334: f7ff ff76    	bl	0x801f224 <sys_slist_peek_next> @ imm = #-0x114
 801f338: 60b8         	str	r0, [r7, #0x8]
 801f33a: 68bb         	ldr	r3, [r7, #0x8]
 801f33c: 2b00         	cmp	r3, #0x0
 801f33e: d1eb         	bne	0x801f318 <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 801f340: 2300         	movs	r3, #0x0
 801f342: 4618         	mov	r0, r3
 801f344: 3710         	adds	r7, #0x10
 801f346: 46bd         	mov	sp, r7
 801f348: bd80         	pop	{r7, pc}

0801f34a <device_is_ready>:
; {
 801f34a: b580         	push	{r7, lr}
 801f34c: b082         	sub	sp, #0x8
 801f34e: af00         	add	r7, sp, #0x0
 801f350: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801f352: 6878         	ldr	r0, [r7, #0x4]
 801f354: f005 f8e5    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x51ca
 801f358: 4603         	mov	r3, r0
; }
 801f35a: 4618         	mov	r0, r3
 801f35c: 3708         	adds	r7, #0x8
 801f35e: 46bd         	mov	sp, r7
 801f360: bd80         	pop	{r7, pc}

0801f362 <LL_GPIO_SetPinMode>:
; {
 801f362: b480         	push	{r7}
 801f364: b08b         	sub	sp, #0x2c
 801f366: af00         	add	r7, sp, #0x0
 801f368: 60f8         	str	r0, [r7, #0xc]
 801f36a: 60b9         	str	r1, [r7, #0x8]
 801f36c: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 801f36e: 68fb         	ldr	r3, [r7, #0xc]
 801f370: 681a         	ldr	r2, [r3]
 801f372: 68bb         	ldr	r3, [r7, #0x8]
 801f374: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801f376: 697b         	ldr	r3, [r7, #0x14]
 801f378: fa93 f3a3    	rbit	r3, r3
 801f37c: 613b         	str	r3, [r7, #0x10]
;   return result;
 801f37e: 693b         	ldr	r3, [r7, #0x10]
 801f380: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 801f382: 69bb         	ldr	r3, [r7, #0x18]
 801f384: 2b00         	cmp	r3, #0x0
 801f386: d101         	bne	0x801f38c <LL_GPIO_SetPinMode+0x2a> @ imm = #0x2
;     return 32U;
 801f388: 2320         	movs	r3, #0x20
 801f38a: e003         	b	0x801f394 <LL_GPIO_SetPinMode+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 801f38c: 69bb         	ldr	r3, [r7, #0x18]
 801f38e: fab3 f383    	clz	r3, r3
 801f392: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 801f394: 005b         	lsls	r3, r3, #0x1
 801f396: 2103         	movs	r1, #0x3
 801f398: fa01 f303    	lsl.w	r3, r1, r3
 801f39c: 43db         	mvns	r3, r3
 801f39e: 401a         	ands	r2, r3
 801f3a0: 68bb         	ldr	r3, [r7, #0x8]
 801f3a2: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801f3a4: 6a3b         	ldr	r3, [r7, #0x20]
 801f3a6: fa93 f3a3    	rbit	r3, r3
 801f3aa: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 801f3ac: 69fb         	ldr	r3, [r7, #0x1c]
 801f3ae: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801f3b0: 6a7b         	ldr	r3, [r7, #0x24]
 801f3b2: 2b00         	cmp	r3, #0x0
 801f3b4: d101         	bne	0x801f3ba <LL_GPIO_SetPinMode+0x58> @ imm = #0x2
;     return 32U;
 801f3b6: 2320         	movs	r3, #0x20
 801f3b8: e003         	b	0x801f3c2 <LL_GPIO_SetPinMode+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 801f3ba: 6a7b         	ldr	r3, [r7, #0x24]
 801f3bc: fab3 f383    	clz	r3, r3
 801f3c0: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 801f3c2: 005b         	lsls	r3, r3, #0x1
 801f3c4: 6879         	ldr	r1, [r7, #0x4]
 801f3c6: fa01 f303    	lsl.w	r3, r1, r3
 801f3ca: 431a         	orrs	r2, r3
 801f3cc: 68fb         	ldr	r3, [r7, #0xc]
 801f3ce: 601a         	str	r2, [r3]
; }
 801f3d0: bf00         	nop
 801f3d2: 372c         	adds	r7, #0x2c
 801f3d4: 46bd         	mov	sp, r7
 801f3d6: f85d 7b04    	ldr	r7, [sp], #4
 801f3da: 4770         	bx	lr

0801f3dc <LL_GPIO_SetPinOutputType>:
; {
 801f3dc: b480         	push	{r7}
 801f3de: b085         	sub	sp, #0x14
 801f3e0: af00         	add	r7, sp, #0x0
 801f3e2: 60f8         	str	r0, [r7, #0xc]
 801f3e4: 60b9         	str	r1, [r7, #0x8]
 801f3e6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 801f3e8: 68fb         	ldr	r3, [r7, #0xc]
 801f3ea: 685a         	ldr	r2, [r3, #0x4]
 801f3ec: 68bb         	ldr	r3, [r7, #0x8]
 801f3ee: 43db         	mvns	r3, r3
 801f3f0: 401a         	ands	r2, r3
 801f3f2: 68bb         	ldr	r3, [r7, #0x8]
 801f3f4: 6879         	ldr	r1, [r7, #0x4]
 801f3f6: fb01 f303    	mul	r3, r1, r3
 801f3fa: 431a         	orrs	r2, r3
 801f3fc: 68fb         	ldr	r3, [r7, #0xc]
 801f3fe: 605a         	str	r2, [r3, #0x4]
; }
 801f400: bf00         	nop
 801f402: 3714         	adds	r7, #0x14
 801f404: 46bd         	mov	sp, r7
 801f406: f85d 7b04    	ldr	r7, [sp], #4
 801f40a: 4770         	bx	lr

0801f40c <LL_GPIO_SetPinSpeed>:
; {
 801f40c: b480         	push	{r7}
 801f40e: b08b         	sub	sp, #0x2c
 801f410: af00         	add	r7, sp, #0x0
 801f412: 60f8         	str	r0, [r7, #0xc]
 801f414: 60b9         	str	r1, [r7, #0x8]
 801f416: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 801f418: 68fb         	ldr	r3, [r7, #0xc]
 801f41a: 689a         	ldr	r2, [r3, #0x8]
 801f41c: 68bb         	ldr	r3, [r7, #0x8]
 801f41e: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801f420: 697b         	ldr	r3, [r7, #0x14]
 801f422: fa93 f3a3    	rbit	r3, r3
 801f426: 613b         	str	r3, [r7, #0x10]
;   return result;
 801f428: 693b         	ldr	r3, [r7, #0x10]
 801f42a: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 801f42c: 69bb         	ldr	r3, [r7, #0x18]
 801f42e: 2b00         	cmp	r3, #0x0
 801f430: d101         	bne	0x801f436 <LL_GPIO_SetPinSpeed+0x2a> @ imm = #0x2
;     return 32U;
 801f432: 2320         	movs	r3, #0x20
 801f434: e003         	b	0x801f43e <LL_GPIO_SetPinSpeed+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 801f436: 69bb         	ldr	r3, [r7, #0x18]
 801f438: fab3 f383    	clz	r3, r3
 801f43c: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 801f43e: 005b         	lsls	r3, r3, #0x1
 801f440: 2103         	movs	r1, #0x3
 801f442: fa01 f303    	lsl.w	r3, r1, r3
 801f446: 43db         	mvns	r3, r3
 801f448: 401a         	ands	r2, r3
 801f44a: 68bb         	ldr	r3, [r7, #0x8]
 801f44c: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801f44e: 6a3b         	ldr	r3, [r7, #0x20]
 801f450: fa93 f3a3    	rbit	r3, r3
 801f454: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 801f456: 69fb         	ldr	r3, [r7, #0x1c]
 801f458: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801f45a: 6a7b         	ldr	r3, [r7, #0x24]
 801f45c: 2b00         	cmp	r3, #0x0
 801f45e: d101         	bne	0x801f464 <LL_GPIO_SetPinSpeed+0x58> @ imm = #0x2
;     return 32U;
 801f460: 2320         	movs	r3, #0x20
 801f462: e003         	b	0x801f46c <LL_GPIO_SetPinSpeed+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 801f464: 6a7b         	ldr	r3, [r7, #0x24]
 801f466: fab3 f383    	clz	r3, r3
 801f46a: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 801f46c: 005b         	lsls	r3, r3, #0x1
 801f46e: 6879         	ldr	r1, [r7, #0x4]
 801f470: fa01 f303    	lsl.w	r3, r1, r3
 801f474: 431a         	orrs	r2, r3
 801f476: 68fb         	ldr	r3, [r7, #0xc]
 801f478: 609a         	str	r2, [r3, #0x8]
; }
 801f47a: bf00         	nop
 801f47c: 372c         	adds	r7, #0x2c
 801f47e: 46bd         	mov	sp, r7
 801f480: f85d 7b04    	ldr	r7, [sp], #4
 801f484: 4770         	bx	lr

0801f486 <LL_GPIO_SetPinPull>:
; {
 801f486: b480         	push	{r7}
 801f488: b08b         	sub	sp, #0x2c
 801f48a: af00         	add	r7, sp, #0x0
 801f48c: 60f8         	str	r0, [r7, #0xc]
 801f48e: 60b9         	str	r1, [r7, #0x8]
 801f490: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 801f492: 68fb         	ldr	r3, [r7, #0xc]
 801f494: 68da         	ldr	r2, [r3, #0xc]
 801f496: 68bb         	ldr	r3, [r7, #0x8]
 801f498: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801f49a: 697b         	ldr	r3, [r7, #0x14]
 801f49c: fa93 f3a3    	rbit	r3, r3
 801f4a0: 613b         	str	r3, [r7, #0x10]
;   return result;
 801f4a2: 693b         	ldr	r3, [r7, #0x10]
 801f4a4: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 801f4a6: 69bb         	ldr	r3, [r7, #0x18]
 801f4a8: 2b00         	cmp	r3, #0x0
 801f4aa: d101         	bne	0x801f4b0 <LL_GPIO_SetPinPull+0x2a> @ imm = #0x2
;     return 32U;
 801f4ac: 2320         	movs	r3, #0x20
 801f4ae: e003         	b	0x801f4b8 <LL_GPIO_SetPinPull+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 801f4b0: 69bb         	ldr	r3, [r7, #0x18]
 801f4b2: fab3 f383    	clz	r3, r3
 801f4b6: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 801f4b8: 005b         	lsls	r3, r3, #0x1
 801f4ba: 2103         	movs	r1, #0x3
 801f4bc: fa01 f303    	lsl.w	r3, r1, r3
 801f4c0: 43db         	mvns	r3, r3
 801f4c2: 401a         	ands	r2, r3
 801f4c4: 68bb         	ldr	r3, [r7, #0x8]
 801f4c6: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801f4c8: 6a3b         	ldr	r3, [r7, #0x20]
 801f4ca: fa93 f3a3    	rbit	r3, r3
 801f4ce: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 801f4d0: 69fb         	ldr	r3, [r7, #0x1c]
 801f4d2: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801f4d4: 6a7b         	ldr	r3, [r7, #0x24]
 801f4d6: 2b00         	cmp	r3, #0x0
 801f4d8: d101         	bne	0x801f4de <LL_GPIO_SetPinPull+0x58> @ imm = #0x2
;     return 32U;
 801f4da: 2320         	movs	r3, #0x20
 801f4dc: e003         	b	0x801f4e6 <LL_GPIO_SetPinPull+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 801f4de: 6a7b         	ldr	r3, [r7, #0x24]
 801f4e0: fab3 f383    	clz	r3, r3
 801f4e4: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 801f4e6: 005b         	lsls	r3, r3, #0x1
 801f4e8: 6879         	ldr	r1, [r7, #0x4]
 801f4ea: fa01 f303    	lsl.w	r3, r1, r3
 801f4ee: 431a         	orrs	r2, r3
 801f4f0: 68fb         	ldr	r3, [r7, #0xc]
 801f4f2: 60da         	str	r2, [r3, #0xc]
; }
 801f4f4: bf00         	nop
 801f4f6: 372c         	adds	r7, #0x2c
 801f4f8: 46bd         	mov	sp, r7
 801f4fa: f85d 7b04    	ldr	r7, [sp], #4
 801f4fe: 4770         	bx	lr

0801f500 <LL_GPIO_SetAFPin_0_7>:
; {
 801f500: b480         	push	{r7}
 801f502: b08b         	sub	sp, #0x2c
 801f504: af00         	add	r7, sp, #0x0
 801f506: 60f8         	str	r0, [r7, #0xc]
 801f508: 60b9         	str	r1, [r7, #0x8]
 801f50a: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 801f50c: 68fb         	ldr	r3, [r7, #0xc]
 801f50e: 6a1a         	ldr	r2, [r3, #0x20]
 801f510: 68bb         	ldr	r3, [r7, #0x8]
 801f512: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801f514: 697b         	ldr	r3, [r7, #0x14]
 801f516: fa93 f3a3    	rbit	r3, r3
 801f51a: 613b         	str	r3, [r7, #0x10]
;   return result;
 801f51c: 693b         	ldr	r3, [r7, #0x10]
 801f51e: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 801f520: 69bb         	ldr	r3, [r7, #0x18]
 801f522: 2b00         	cmp	r3, #0x0
 801f524: d101         	bne	0x801f52a <LL_GPIO_SetAFPin_0_7+0x2a> @ imm = #0x2
;     return 32U;
 801f526: 2320         	movs	r3, #0x20
 801f528: e003         	b	0x801f532 <LL_GPIO_SetAFPin_0_7+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 801f52a: 69bb         	ldr	r3, [r7, #0x18]
 801f52c: fab3 f383    	clz	r3, r3
 801f530: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 801f532: 009b         	lsls	r3, r3, #0x2
 801f534: 210f         	movs	r1, #0xf
 801f536: fa01 f303    	lsl.w	r3, r1, r3
 801f53a: 43db         	mvns	r3, r3
 801f53c: 401a         	ands	r2, r3
 801f53e: 68bb         	ldr	r3, [r7, #0x8]
 801f540: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801f542: 6a3b         	ldr	r3, [r7, #0x20]
 801f544: fa93 f3a3    	rbit	r3, r3
 801f548: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 801f54a: 69fb         	ldr	r3, [r7, #0x1c]
 801f54c: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801f54e: 6a7b         	ldr	r3, [r7, #0x24]
 801f550: 2b00         	cmp	r3, #0x0
 801f552: d101         	bne	0x801f558 <LL_GPIO_SetAFPin_0_7+0x58> @ imm = #0x2
;     return 32U;
 801f554: 2320         	movs	r3, #0x20
 801f556: e003         	b	0x801f560 <LL_GPIO_SetAFPin_0_7+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 801f558: 6a7b         	ldr	r3, [r7, #0x24]
 801f55a: fab3 f383    	clz	r3, r3
 801f55e: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 801f560: 009b         	lsls	r3, r3, #0x2
 801f562: 6879         	ldr	r1, [r7, #0x4]
 801f564: fa01 f303    	lsl.w	r3, r1, r3
 801f568: 431a         	orrs	r2, r3
 801f56a: 68fb         	ldr	r3, [r7, #0xc]
 801f56c: 621a         	str	r2, [r3, #0x20]
; }
 801f56e: bf00         	nop
 801f570: 372c         	adds	r7, #0x2c
 801f572: 46bd         	mov	sp, r7
 801f574: f85d 7b04    	ldr	r7, [sp], #4
 801f578: 4770         	bx	lr

0801f57a <LL_GPIO_SetAFPin_8_15>:
; {
 801f57a: b480         	push	{r7}
 801f57c: b08b         	sub	sp, #0x2c
 801f57e: af00         	add	r7, sp, #0x0
 801f580: 60f8         	str	r0, [r7, #0xc]
 801f582: 60b9         	str	r1, [r7, #0x8]
 801f584: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 801f586: 68fb         	ldr	r3, [r7, #0xc]
 801f588: 6a5a         	ldr	r2, [r3, #0x24]
 801f58a: 68bb         	ldr	r3, [r7, #0x8]
 801f58c: 0a1b         	lsrs	r3, r3, #0x8
 801f58e: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801f590: 697b         	ldr	r3, [r7, #0x14]
 801f592: fa93 f3a3    	rbit	r3, r3
 801f596: 613b         	str	r3, [r7, #0x10]
;   return result;
 801f598: 693b         	ldr	r3, [r7, #0x10]
 801f59a: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 801f59c: 69bb         	ldr	r3, [r7, #0x18]
 801f59e: 2b00         	cmp	r3, #0x0
 801f5a0: d101         	bne	0x801f5a6 <LL_GPIO_SetAFPin_8_15+0x2c> @ imm = #0x2
;     return 32U;
 801f5a2: 2320         	movs	r3, #0x20
 801f5a4: e003         	b	0x801f5ae <LL_GPIO_SetAFPin_8_15+0x34> @ imm = #0x6
;   return __builtin_clz(value);
 801f5a6: 69bb         	ldr	r3, [r7, #0x18]
 801f5a8: fab3 f383    	clz	r3, r3
 801f5ac: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 801f5ae: 009b         	lsls	r3, r3, #0x2
 801f5b0: 210f         	movs	r1, #0xf
 801f5b2: fa01 f303    	lsl.w	r3, r1, r3
 801f5b6: 43db         	mvns	r3, r3
 801f5b8: 401a         	ands	r2, r3
 801f5ba: 68bb         	ldr	r3, [r7, #0x8]
 801f5bc: 0a1b         	lsrs	r3, r3, #0x8
 801f5be: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801f5c0: 6a3b         	ldr	r3, [r7, #0x20]
 801f5c2: fa93 f3a3    	rbit	r3, r3
 801f5c6: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 801f5c8: 69fb         	ldr	r3, [r7, #0x1c]
 801f5ca: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801f5cc: 6a7b         	ldr	r3, [r7, #0x24]
 801f5ce: 2b00         	cmp	r3, #0x0
 801f5d0: d101         	bne	0x801f5d6 <LL_GPIO_SetAFPin_8_15+0x5c> @ imm = #0x2
;     return 32U;
 801f5d2: 2320         	movs	r3, #0x20
 801f5d4: e003         	b	0x801f5de <LL_GPIO_SetAFPin_8_15+0x64> @ imm = #0x6
;   return __builtin_clz(value);
 801f5d6: 6a7b         	ldr	r3, [r7, #0x24]
 801f5d8: fab3 f383    	clz	r3, r3
 801f5dc: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 801f5de: 009b         	lsls	r3, r3, #0x2
 801f5e0: 6879         	ldr	r1, [r7, #0x4]
 801f5e2: fa01 f303    	lsl.w	r3, r1, r3
 801f5e6: 431a         	orrs	r2, r3
 801f5e8: 68fb         	ldr	r3, [r7, #0xc]
 801f5ea: 625a         	str	r2, [r3, #0x24]
; }
 801f5ec: bf00         	nop
 801f5ee: 372c         	adds	r7, #0x2c
 801f5f0: 46bd         	mov	sp, r7
 801f5f2: f85d 7b04    	ldr	r7, [sp], #4
 801f5f6: 4770         	bx	lr

0801f5f8 <LL_GPIO_ReadInputPort>:
; {
 801f5f8: b480         	push	{r7}
 801f5fa: b083         	sub	sp, #0xc
 801f5fc: af00         	add	r7, sp, #0x0
 801f5fe: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->IDR));
 801f600: 687b         	ldr	r3, [r7, #0x4]
 801f602: 691b         	ldr	r3, [r3, #0x10]
; }
 801f604: 4618         	mov	r0, r3
 801f606: 370c         	adds	r7, #0xc
 801f608: 46bd         	mov	sp, r7
 801f60a: f85d 7b04    	ldr	r7, [sp], #4
 801f60e: 4770         	bx	lr

0801f610 <LL_GPIO_WriteOutputPort>:
; {
 801f610: b480         	push	{r7}
 801f612: b083         	sub	sp, #0xc
 801f614: af00         	add	r7, sp, #0x0
 801f616: 6078         	str	r0, [r7, #0x4]
 801f618: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->ODR, PortValue);
 801f61a: 687b         	ldr	r3, [r7, #0x4]
 801f61c: 683a         	ldr	r2, [r7]
 801f61e: 615a         	str	r2, [r3, #0x14]
; }
 801f620: bf00         	nop
 801f622: 370c         	adds	r7, #0xc
 801f624: 46bd         	mov	sp, r7
 801f626: f85d 7b04    	ldr	r7, [sp], #4
 801f62a: 4770         	bx	lr

0801f62c <LL_GPIO_ReadOutputPort>:
; {
 801f62c: b480         	push	{r7}
 801f62e: b083         	sub	sp, #0xc
 801f630: af00         	add	r7, sp, #0x0
 801f632: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->ODR));
 801f634: 687b         	ldr	r3, [r7, #0x4]
 801f636: 695b         	ldr	r3, [r3, #0x14]
; }
 801f638: 4618         	mov	r0, r3
 801f63a: 370c         	adds	r7, #0xc
 801f63c: 46bd         	mov	sp, r7
 801f63e: f85d 7b04    	ldr	r7, [sp], #4
 801f642: 4770         	bx	lr

0801f644 <LL_GPIO_ResetOutputPin>:
; {
 801f644: b480         	push	{r7}
 801f646: b083         	sub	sp, #0xc
 801f648: af00         	add	r7, sp, #0x0
 801f64a: 6078         	str	r0, [r7, #0x4]
 801f64c: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->BSRR, (PinMask << 16));
 801f64e: 683b         	ldr	r3, [r7]
 801f650: 041a         	lsls	r2, r3, #0x10
 801f652: 687b         	ldr	r3, [r7, #0x4]
 801f654: 619a         	str	r2, [r3, #0x18]
; }
 801f656: bf00         	nop
 801f658: 370c         	adds	r7, #0xc
 801f65a: 46bd         	mov	sp, r7
 801f65c: f85d 7b04    	ldr	r7, [sp], #4
 801f660: 4770         	bx	lr

0801f662 <clock_control_on>:
; {
 801f662: b580         	push	{r7, lr}
 801f664: b084         	sub	sp, #0x10
 801f666: af00         	add	r7, sp, #0x0
 801f668: 6078         	str	r0, [r7, #0x4]
 801f66a: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801f66c: 687b         	ldr	r3, [r7, #0x4]
 801f66e: 689b         	ldr	r3, [r3, #0x8]
 801f670: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801f672: 68fb         	ldr	r3, [r7, #0xc]
 801f674: 681b         	ldr	r3, [r3]
 801f676: 6839         	ldr	r1, [r7]
 801f678: 6878         	ldr	r0, [r7, #0x4]
 801f67a: 4798         	blx	r3
 801f67c: 4603         	mov	r3, r0
; }
 801f67e: 4618         	mov	r0, r3
 801f680: 3710         	adds	r7, #0x10
 801f682: 46bd         	mov	sp, r7
 801f684: bd80         	pop	{r7, pc}

0801f686 <clock_control_off>:
; {
 801f686: b580         	push	{r7, lr}
 801f688: b084         	sub	sp, #0x10
 801f68a: af00         	add	r7, sp, #0x0
 801f68c: 6078         	str	r0, [r7, #0x4]
 801f68e: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801f690: 687b         	ldr	r3, [r7, #0x4]
 801f692: 689b         	ldr	r3, [r3, #0x8]
 801f694: 60fb         	str	r3, [r7, #0xc]
; 	return api->off(dev, sys);
 801f696: 68fb         	ldr	r3, [r7, #0xc]
 801f698: 685b         	ldr	r3, [r3, #0x4]
 801f69a: 6839         	ldr	r1, [r7]
 801f69c: 6878         	ldr	r0, [r7, #0x4]
 801f69e: 4798         	blx	r3
 801f6a0: 4603         	mov	r3, r0
; }
 801f6a2: 4618         	mov	r0, r3
 801f6a4: 3710         	adds	r7, #0x10
 801f6a6: 46bd         	mov	sp, r7
 801f6a8: bd80         	pop	{r7, pc}

0801f6aa <pm_device_runtime_enable>:
; {
 801f6aa: b480         	push	{r7}
 801f6ac: b083         	sub	sp, #0xc
 801f6ae: af00         	add	r7, sp, #0x0
 801f6b0: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801f6b2: 2300         	movs	r3, #0x0
; }
 801f6b4: 4618         	mov	r0, r3
 801f6b6: 370c         	adds	r7, #0xc
 801f6b8: 46bd         	mov	sp, r7
 801f6ba: f85d 7b04    	ldr	r7, [sp], #4
 801f6be: 4770         	bx	lr

0801f6c0 <pm_device_runtime_get>:
; {
 801f6c0: b480         	push	{r7}
 801f6c2: b083         	sub	sp, #0xc
 801f6c4: af00         	add	r7, sp, #0x0
 801f6c6: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801f6c8: 2300         	movs	r3, #0x0
; }
 801f6ca: 4618         	mov	r0, r3
 801f6cc: 370c         	adds	r7, #0xc
 801f6ce: 46bd         	mov	sp, r7
 801f6d0: f85d 7b04    	ldr	r7, [sp], #4
 801f6d4: 4770         	bx	lr

0801f6d6 <pm_device_runtime_put>:
; {
 801f6d6: b480         	push	{r7}
 801f6d8: b083         	sub	sp, #0xc
 801f6da: af00         	add	r7, sp, #0x0
 801f6dc: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801f6de: 2300         	movs	r3, #0x0
; }
 801f6e0: 4618         	mov	r0, r3
 801f6e2: 370c         	adds	r7, #0xc
 801f6e4: 46bd         	mov	sp, r7
 801f6e6: f85d 7b04    	ldr	r7, [sp], #4
 801f6ea: 4770         	bx	lr

0801f6ec <z_stm32_hsem_lock>:
; {
 801f6ec: b480         	push	{r7}
 801f6ee: b083         	sub	sp, #0xc
 801f6f0: af00         	add	r7, sp, #0x0
 801f6f2: 6078         	str	r0, [r7, #0x4]
 801f6f4: 6039         	str	r1, [r7]
; }
 801f6f6: bf00         	nop
 801f6f8: 370c         	adds	r7, #0xc
 801f6fa: 46bd         	mov	sp, r7
 801f6fc: f85d 7b04    	ldr	r7, [sp], #4
 801f700: 4770         	bx	lr

0801f702 <z_stm32_hsem_unlock>:
; {
 801f702: b480         	push	{r7}
 801f704: b083         	sub	sp, #0xc
 801f706: af00         	add	r7, sp, #0x0
 801f708: 6078         	str	r0, [r7, #0x4]
; }
 801f70a: bf00         	nop
 801f70c: 370c         	adds	r7, #0xc
 801f70e: 46bd         	mov	sp, r7
 801f710: f85d 7b04    	ldr	r7, [sp], #4
 801f714: 4770         	bx	lr

0801f716 <gpio_manage_callback>:
; {
 801f716: b580         	push	{r7, lr}
 801f718: b084         	sub	sp, #0x10
 801f71a: af00         	add	r7, sp, #0x0
 801f71c: 60f8         	str	r0, [r7, #0xc]
 801f71e: 60b9         	str	r1, [r7, #0x8]
 801f720: 4613         	mov	r3, r2
 801f722: 71fb         	strb	r3, [r7, #0x7]
; 	if (!sys_slist_is_empty(callbacks)) {
 801f724: 68f8         	ldr	r0, [r7, #0xc]
 801f726: f7ff fd60    	bl	0x801f1ea <sys_slist_is_empty> @ imm = #-0x540
 801f72a: 4603         	mov	r3, r0
 801f72c: f083 0301    	eor	r3, r3, #0x1
 801f730: b2db         	uxtb	r3, r3
 801f732: 2b00         	cmp	r3, #0x0
 801f734: d013         	beq	0x801f75e <gpio_manage_callback+0x48> @ imm = #0x26
; 		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
 801f736: 68bb         	ldr	r3, [r7, #0x8]
 801f738: 4619         	mov	r1, r3
 801f73a: 68f8         	ldr	r0, [r7, #0xc]
 801f73c: f7ff fde0    	bl	0x801f300 <sys_slist_find_and_remove> @ imm = #-0x440
 801f740: 4603         	mov	r3, r0
 801f742: f083 0301    	eor	r3, r3, #0x1
 801f746: b2db         	uxtb	r3, r3
 801f748: 2b00         	cmp	r3, #0x0
 801f74a: d011         	beq	0x801f770 <gpio_manage_callback+0x5a> @ imm = #0x22
; 			if (!set) {
 801f74c: 79fb         	ldrb	r3, [r7, #0x7]
 801f74e: f083 0301    	eor	r3, r3, #0x1
 801f752: b2db         	uxtb	r3, r3
 801f754: 2b00         	cmp	r3, #0x0
 801f756: d00b         	beq	0x801f770 <gpio_manage_callback+0x5a> @ imm = #0x16
; 				return -EINVAL;
 801f758: f06f 0315    	mvn	r3, #0x15
 801f75c: e011         	b	0x801f782 <gpio_manage_callback+0x6c> @ imm = #0x22
; 	} else if (!set) {
 801f75e: 79fb         	ldrb	r3, [r7, #0x7]
 801f760: f083 0301    	eor	r3, r3, #0x1
 801f764: b2db         	uxtb	r3, r3
 801f766: 2b00         	cmp	r3, #0x0
 801f768: d002         	beq	0x801f770 <gpio_manage_callback+0x5a> @ imm = #0x4
; 		return -EINVAL;
 801f76a: f06f 0315    	mvn	r3, #0x15
 801f76e: e008         	b	0x801f782 <gpio_manage_callback+0x6c> @ imm = #0x10
; 	if (set) {
 801f770: 79fb         	ldrb	r3, [r7, #0x7]
 801f772: 2b00         	cmp	r3, #0x0
 801f774: d004         	beq	0x801f780 <gpio_manage_callback+0x6a> @ imm = #0x8
; 		sys_slist_prepend(callbacks, &callback->node);
 801f776: 68bb         	ldr	r3, [r7, #0x8]
 801f778: 4619         	mov	r1, r3
 801f77a: 68f8         	ldr	r0, [r7, #0xc]
 801f77c: f7ff fd63    	bl	0x801f246 <sys_slist_prepend> @ imm = #-0x53a
; 	return 0;
 801f780: 2300         	movs	r3, #0x0
; }
 801f782: 4618         	mov	r0, r3
 801f784: 3710         	adds	r7, #0x10
 801f786: 46bd         	mov	sp, r7
 801f788: bd80         	pop	{r7, pc}

0801f78a <gpio_fire_callbacks>:
; {
 801f78a: b580         	push	{r7, lr}
 801f78c: b086         	sub	sp, #0x18
 801f78e: af00         	add	r7, sp, #0x0
 801f790: 60f8         	str	r0, [r7, #0xc]
 801f792: 60b9         	str	r1, [r7, #0x8]
 801f794: 607a         	str	r2, [r7, #0x4]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 801f796: 68f8         	ldr	r0, [r7, #0xc]
 801f798: f7ff fd0f    	bl	0x801f1ba <sys_slist_peek_head> @ imm = #-0x5e2
 801f79c: 4603         	mov	r3, r0
 801f79e: 2b00         	cmp	r3, #0x0
 801f7a0: d004         	beq	0x801f7ac <gpio_fire_callbacks+0x22> @ imm = #0x8
 801f7a2: 68f8         	ldr	r0, [r7, #0xc]
 801f7a4: f7ff fd09    	bl	0x801f1ba <sys_slist_peek_head> @ imm = #-0x5ee
 801f7a8: 4603         	mov	r3, r0
 801f7aa: e000         	b	0x801f7ae <gpio_fire_callbacks+0x24> @ imm = #0x0
 801f7ac: 2300         	movs	r3, #0x0
 801f7ae: 617b         	str	r3, [r7, #0x14]
 801f7b0: 697b         	ldr	r3, [r7, #0x14]
 801f7b2: 2b00         	cmp	r3, #0x0
 801f7b4: d00e         	beq	0x801f7d4 <gpio_fire_callbacks+0x4a> @ imm = #0x1c
 801f7b6: 697b         	ldr	r3, [r7, #0x14]
 801f7b8: 4618         	mov	r0, r3
 801f7ba: f7ff fd33    	bl	0x801f224 <sys_slist_peek_next> @ imm = #-0x59a
 801f7be: 4603         	mov	r3, r0
 801f7c0: 2b00         	cmp	r3, #0x0
 801f7c2: d005         	beq	0x801f7d0 <gpio_fire_callbacks+0x46> @ imm = #0xa
 801f7c4: 697b         	ldr	r3, [r7, #0x14]
 801f7c6: 4618         	mov	r0, r3
 801f7c8: f7ff fd2c    	bl	0x801f224 <sys_slist_peek_next> @ imm = #-0x5a8
 801f7cc: 4603         	mov	r3, r0
 801f7ce: e002         	b	0x801f7d6 <gpio_fire_callbacks+0x4c> @ imm = #0x4
 801f7d0: 2300         	movs	r3, #0x0
 801f7d2: e000         	b	0x801f7d6 <gpio_fire_callbacks+0x4c> @ imm = #0x0
 801f7d4: 2300         	movs	r3, #0x0
 801f7d6: 613b         	str	r3, [r7, #0x10]
 801f7d8: e024         	b	0x801f824 <gpio_fire_callbacks+0x9a> @ imm = #0x48
; 		if (cb->pin_mask & pins) {
 801f7da: 697b         	ldr	r3, [r7, #0x14]
 801f7dc: 689a         	ldr	r2, [r3, #0x8]
 801f7de: 687b         	ldr	r3, [r7, #0x4]
 801f7e0: 4013         	ands	r3, r2
 801f7e2: 2b00         	cmp	r3, #0x0
 801f7e4: d008         	beq	0x801f7f8 <gpio_fire_callbacks+0x6e> @ imm = #0x10
; 			cb->handler(port, cb, cb->pin_mask & pins);
 801f7e6: 697b         	ldr	r3, [r7, #0x14]
 801f7e8: 685b         	ldr	r3, [r3, #0x4]
 801f7ea: 697a         	ldr	r2, [r7, #0x14]
 801f7ec: 6891         	ldr	r1, [r2, #0x8]
 801f7ee: 687a         	ldr	r2, [r7, #0x4]
 801f7f0: 400a         	ands	r2, r1
 801f7f2: 6979         	ldr	r1, [r7, #0x14]
 801f7f4: 68b8         	ldr	r0, [r7, #0x8]
 801f7f6: 4798         	blx	r3
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 801f7f8: 693b         	ldr	r3, [r7, #0x10]
 801f7fa: 617b         	str	r3, [r7, #0x14]
 801f7fc: 697b         	ldr	r3, [r7, #0x14]
 801f7fe: 2b00         	cmp	r3, #0x0
 801f800: d00e         	beq	0x801f820 <gpio_fire_callbacks+0x96> @ imm = #0x1c
 801f802: 697b         	ldr	r3, [r7, #0x14]
 801f804: 4618         	mov	r0, r3
 801f806: f7ff fd0d    	bl	0x801f224 <sys_slist_peek_next> @ imm = #-0x5e6
 801f80a: 4603         	mov	r3, r0
 801f80c: 2b00         	cmp	r3, #0x0
 801f80e: d005         	beq	0x801f81c <gpio_fire_callbacks+0x92> @ imm = #0xa
 801f810: 697b         	ldr	r3, [r7, #0x14]
 801f812: 4618         	mov	r0, r3
 801f814: f7ff fd06    	bl	0x801f224 <sys_slist_peek_next> @ imm = #-0x5f4
 801f818: 4603         	mov	r3, r0
 801f81a: e002         	b	0x801f822 <gpio_fire_callbacks+0x98> @ imm = #0x4
 801f81c: 2300         	movs	r3, #0x0
 801f81e: e000         	b	0x801f822 <gpio_fire_callbacks+0x98> @ imm = #0x0
 801f820: 2300         	movs	r3, #0x0
 801f822: 613b         	str	r3, [r7, #0x10]
 801f824: 697b         	ldr	r3, [r7, #0x14]
 801f826: 2b00         	cmp	r3, #0x0
 801f828: d1d7         	bne	0x801f7da <gpio_fire_callbacks+0x50> @ imm = #-0x52
; }
 801f82a: bf00         	nop
 801f82c: bf00         	nop
 801f82e: 3718         	adds	r7, #0x18
 801f830: 46bd         	mov	sp, r7
 801f832: bd80         	pop	{r7, pc}

0801f834 <gpio_stm32_isr>:
; {
 801f834: b580         	push	{r7, lr}
 801f836: b084         	sub	sp, #0x10
 801f838: af00         	add	r7, sp, #0x0
 801f83a: 6078         	str	r0, [r7, #0x4]
 801f83c: 6039         	str	r1, [r7]
; 	struct gpio_stm32_data *data = arg;
 801f83e: 683b         	ldr	r3, [r7]
 801f840: 60fb         	str	r3, [r7, #0xc]
; 	gpio_fire_callbacks(&data->cb, data->dev, pin);
 801f842: 68fb         	ldr	r3, [r7, #0xc]
 801f844: f103 0008    	add.w	r0, r3, #0x8
 801f848: 68fb         	ldr	r3, [r7, #0xc]
 801f84a: 685b         	ldr	r3, [r3, #0x4]
 801f84c: 687a         	ldr	r2, [r7, #0x4]
 801f84e: 4619         	mov	r1, r3
 801f850: f7ff ff9b    	bl	0x801f78a <gpio_fire_callbacks> @ imm = #-0xca
; }
 801f854: bf00         	nop
 801f856: 3710         	adds	r7, #0x10
 801f858: 46bd         	mov	sp, r7
 801f85a: bd80         	pop	{r7, pc}

0801f85c <gpio_stm32_flags_to_conf>:
; {
 801f85c: b480         	push	{r7}
 801f85e: b083         	sub	sp, #0xc
 801f860: af00         	add	r7, sp, #0x0
 801f862: 6078         	str	r0, [r7, #0x4]
 801f864: 6039         	str	r1, [r7]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 801f866: 687b         	ldr	r3, [r7, #0x4]
 801f868: f403 3300    	and	r3, r3, #0x20000
 801f86c: 2b00         	cmp	r3, #0x0
 801f86e: d032         	beq	0x801f8d6 <gpio_stm32_flags_to_conf+0x7a> @ imm = #0x64
; 		*pincfg = STM32_PINCFG_MODE_OUTPUT;
 801f870: 683b         	ldr	r3, [r7]
 801f872: 2210         	movs	r2, #0x10
 801f874: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_SINGLE_ENDED) != 0) {
 801f876: 687b         	ldr	r3, [r7, #0x4]
 801f878: f003 0302    	and	r3, r3, #0x2
 801f87c: 2b00         	cmp	r3, #0x0
 801f87e: d00e         	beq	0x801f89e <gpio_stm32_flags_to_conf+0x42> @ imm = #0x1c
; 			if (flags & GPIO_LINE_OPEN_DRAIN) {
 801f880: 687b         	ldr	r3, [r7, #0x4]
 801f882: f003 0304    	and	r3, r3, #0x4
 801f886: 2b00         	cmp	r3, #0x0
 801f888: d006         	beq	0x801f898 <gpio_stm32_flags_to_conf+0x3c> @ imm = #0xc
; 				*pincfg |= STM32_PINCFG_OPEN_DRAIN;
 801f88a: 683b         	ldr	r3, [r7]
 801f88c: 681b         	ldr	r3, [r3]
 801f88e: f043 0240    	orr	r2, r3, #0x40
 801f892: 683b         	ldr	r3, [r7]
 801f894: 601a         	str	r2, [r3]
 801f896: e006         	b	0x801f8a6 <gpio_stm32_flags_to_conf+0x4a> @ imm = #0xc
; 				return -ENOTSUP;
 801f898: f06f 0385    	mvn	r3, #0x85
 801f89c: e044         	b	0x801f928 <gpio_stm32_flags_to_conf+0xcc> @ imm = #0x88
; 			*pincfg |= STM32_PINCFG_PUSH_PULL;
 801f89e: 683b         	ldr	r3, [r7]
 801f8a0: 681a         	ldr	r2, [r3]
 801f8a2: 683b         	ldr	r3, [r7]
 801f8a4: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 801f8a6: 687b         	ldr	r3, [r7, #0x4]
 801f8a8: f003 0310    	and	r3, r3, #0x10
 801f8ac: 2b00         	cmp	r3, #0x0
 801f8ae: d006         	beq	0x801f8be <gpio_stm32_flags_to_conf+0x62> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 801f8b0: 683b         	ldr	r3, [r7]
 801f8b2: 681b         	ldr	r3, [r3]
 801f8b4: f443 7200    	orr	r2, r3, #0x200
 801f8b8: 683b         	ldr	r3, [r7]
 801f8ba: 601a         	str	r2, [r3]
 801f8bc: e033         	b	0x801f926 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x66
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 801f8be: 687b         	ldr	r3, [r7, #0x4]
 801f8c0: f003 0320    	and	r3, r3, #0x20
 801f8c4: 2b00         	cmp	r3, #0x0
 801f8c6: d02e         	beq	0x801f926 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x5c
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 801f8c8: 683b         	ldr	r3, [r7]
 801f8ca: 681b         	ldr	r3, [r3]
 801f8cc: f443 6280    	orr	r2, r3, #0x400
 801f8d0: 683b         	ldr	r3, [r7]
 801f8d2: 601a         	str	r2, [r3]
 801f8d4: e027         	b	0x801f926 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4e
; 	} else if  ((flags & GPIO_INPUT) != 0) {
 801f8d6: 687b         	ldr	r3, [r7, #0x4]
 801f8d8: f403 3380    	and	r3, r3, #0x10000
 801f8dc: 2b00         	cmp	r3, #0x0
 801f8de: d01f         	beq	0x801f920 <gpio_stm32_flags_to_conf+0xc4> @ imm = #0x3e
; 		*pincfg = STM32_PINCFG_MODE_INPUT;
 801f8e0: 683b         	ldr	r3, [r7]
 801f8e2: 2200         	movs	r2, #0x0
 801f8e4: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 801f8e6: 687b         	ldr	r3, [r7, #0x4]
 801f8e8: f003 0310    	and	r3, r3, #0x10
 801f8ec: 2b00         	cmp	r3, #0x0
 801f8ee: d006         	beq	0x801f8fe <gpio_stm32_flags_to_conf+0xa2> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 801f8f0: 683b         	ldr	r3, [r7]
 801f8f2: 681b         	ldr	r3, [r3]
 801f8f4: f443 7200    	orr	r2, r3, #0x200
 801f8f8: 683b         	ldr	r3, [r7]
 801f8fa: 601a         	str	r2, [r3]
 801f8fc: e013         	b	0x801f926 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x26
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 801f8fe: 687b         	ldr	r3, [r7, #0x4]
 801f900: f003 0320    	and	r3, r3, #0x20
 801f904: 2b00         	cmp	r3, #0x0
 801f906: d006         	beq	0x801f916 <gpio_stm32_flags_to_conf+0xba> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 801f908: 683b         	ldr	r3, [r7]
 801f90a: 681b         	ldr	r3, [r3]
 801f90c: f443 6280    	orr	r2, r3, #0x400
 801f910: 683b         	ldr	r3, [r7]
 801f912: 601a         	str	r2, [r3]
 801f914: e007         	b	0x801f926 <gpio_stm32_flags_to_conf+0xca> @ imm = #0xe
; 			*pincfg |= STM32_PINCFG_FLOATING;
 801f916: 683b         	ldr	r3, [r7]
 801f918: 681a         	ldr	r2, [r3]
 801f91a: 683b         	ldr	r3, [r7]
 801f91c: 601a         	str	r2, [r3]
 801f91e: e002         	b	0x801f926 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4
; 		*pincfg = STM32_PINCFG_MODE_ANALOG;
 801f920: 683b         	ldr	r3, [r7]
 801f922: 2230         	movs	r2, #0x30
 801f924: 601a         	str	r2, [r3]
; 	return 0;
 801f926: 2300         	movs	r3, #0x0
; }
 801f928: 4618         	mov	r0, r3
 801f92a: 370c         	adds	r7, #0xc
 801f92c: 46bd         	mov	sp, r7
 801f92e: f85d 7b04    	ldr	r7, [sp], #4
 801f932: 4770         	bx	lr

0801f934 <stm32_pinval_get>:
; {
 801f934: b480         	push	{r7}
 801f936: b085         	sub	sp, #0x14
 801f938: af00         	add	r7, sp, #0x0
 801f93a: 4603         	mov	r3, r0
 801f93c: 71fb         	strb	r3, [r7, #0x7]
; 	pinval = 1 << pin;
 801f93e: 79fb         	ldrb	r3, [r7, #0x7]
 801f940: 2201         	movs	r2, #0x1
 801f942: fa02 f303    	lsl.w	r3, r2, r3
 801f946: 60fb         	str	r3, [r7, #0xc]
; 	return pinval;
 801f948: 68fb         	ldr	r3, [r7, #0xc]
; }
 801f94a: 4618         	mov	r0, r3
 801f94c: 3714         	adds	r7, #0x14
 801f94e: 46bd         	mov	sp, r7
 801f950: f85d 7b04    	ldr	r7, [sp], #4
 801f954: 4770         	bx	lr

0801f956 <ll_gpio_set_pin_pull>:
; {
 801f956: b580         	push	{r7, lr}
 801f958: b084         	sub	sp, #0x10
 801f95a: af00         	add	r7, sp, #0x0
 801f95c: 60f8         	str	r0, [r7, #0xc]
 801f95e: 60b9         	str	r1, [r7, #0x8]
 801f960: 607a         	str	r2, [r7, #0x4]
; 	LL_GPIO_SetPinPull(GPIOx, Pin, Pull);
 801f962: 687a         	ldr	r2, [r7, #0x4]
 801f964: 68b9         	ldr	r1, [r7, #0x8]
 801f966: 68f8         	ldr	r0, [r7, #0xc]
 801f968: f7ff fd8d    	bl	0x801f486 <LL_GPIO_SetPinPull> @ imm = #-0x4e6
; }
 801f96c: bf00         	nop
 801f96e: 3710         	adds	r7, #0x10
 801f970: 46bd         	mov	sp, r7
 801f972: bd80         	pop	{r7, pc}

0801f974 <gpio_stm32_disable_pin_irqs>:
; {
 801f974: b580         	push	{r7, lr}
 801f976: b084         	sub	sp, #0x10
 801f978: af00         	add	r7, sp, #0x0
 801f97a: 6078         	str	r0, [r7, #0x4]
 801f97c: 460b         	mov	r3, r1
 801f97e: 70fb         	strb	r3, [r7, #0x3]
; 	if (port != stm32_exti_get_line_src_port(pin)) {
 801f980: 78fb         	ldrb	r3, [r7, #0x3]
 801f982: 4618         	mov	r0, r3
 801f984: f7fd fb38    	bl	0x801cff8 <stm32_exti_get_line_src_port> @ imm = #-0x2990
 801f988: 4602         	mov	r2, r0
 801f98a: 687b         	ldr	r3, [r7, #0x4]
 801f98c: 4293         	cmp	r3, r2
 801f98e: d110         	bne	0x801f9b2 <gpio_stm32_disable_pin_irqs+0x3e> @ imm = #0x20
; 	stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(port, pin);
 801f990: 78fb         	ldrb	r3, [r7, #0x3]
 801f992: 4619         	mov	r1, r3
 801f994: 6878         	ldr	r0, [r7, #0x4]
 801f996: f7fd fafa    	bl	0x801cf8e <stm32_gpio_intc_get_pin_irq_line> @ imm = #-0x2a0c
 801f99a: 60f8         	str	r0, [r7, #0xc]
; 	stm32_gpio_intc_disable_line(irq_line);
 801f99c: 68f8         	ldr	r0, [r7, #0xc]
 801f99e: f7fd fb05    	bl	0x801cfac <stm32_gpio_intc_disable_line> @ imm = #-0x29f6
; 	stm32_gpio_intc_remove_irq_callback(irq_line);
 801f9a2: 68f8         	ldr	r0, [r7, #0xc]
 801f9a4: f7e7 fe46    	bl	0x8007634 <stm32_gpio_intc_remove_irq_callback> @ imm = #-0x18374
; 	stm32_gpio_intc_select_line_trigger(irq_line, STM32_GPIO_IRQ_TRIG_NONE);
 801f9a8: 2100         	movs	r1, #0x0
 801f9aa: 68f8         	ldr	r0, [r7, #0xc]
 801f9ac: f7e7 fdca    	bl	0x8007544 <stm32_gpio_intc_select_line_trigger> @ imm = #-0x1846c
 801f9b0: e000         	b	0x801f9b4 <gpio_stm32_disable_pin_irqs+0x40> @ imm = #0x0
; 		return;
 801f9b2: bf00         	nop
; }
 801f9b4: 3710         	adds	r7, #0x10
 801f9b6: 46bd         	mov	sp, r7
 801f9b8: bd80         	pop	{r7, pc}

0801f9ba <gpio_stm32_configure_raw>:
; {
 801f9ba: b580         	push	{r7, lr}
 801f9bc: b08c         	sub	sp, #0x30
 801f9be: af00         	add	r7, sp, #0x0
 801f9c0: 60f8         	str	r0, [r7, #0xc]
 801f9c2: 607a         	str	r2, [r7, #0x4]
 801f9c4: 603b         	str	r3, [r7]
 801f9c6: 460b         	mov	r3, r1
 801f9c8: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 801f9ca: 68fb         	ldr	r3, [r7, #0xc]
 801f9cc: 685b         	ldr	r3, [r3, #0x4]
 801f9ce: 62fb         	str	r3, [r7, #0x2c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 801f9d0: 6afb         	ldr	r3, [r7, #0x2c]
 801f9d2: 685b         	ldr	r3, [r3, #0x4]
 801f9d4: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pin_ll = stm32_pinval_get(pin);
 801f9d6: 7afb         	ldrb	r3, [r7, #0xb]
 801f9d8: 4618         	mov	r0, r3
 801f9da: f7ff ffab    	bl	0x801f934 <stm32_pinval_get> @ imm = #-0xaa
 801f9de: 6278         	str	r0, [r7, #0x24]
; 	mode = conf & (STM32_MODER_MASK << STM32_MODER_SHIFT);
 801f9e0: 687b         	ldr	r3, [r7, #0x4]
 801f9e2: f003 0330    	and	r3, r3, #0x30
 801f9e6: 623b         	str	r3, [r7, #0x20]
; 	otype = conf & (STM32_OTYPER_MASK << STM32_OTYPER_SHIFT);
 801f9e8: 687b         	ldr	r3, [r7, #0x4]
 801f9ea: f003 0340    	and	r3, r3, #0x40
 801f9ee: 61fb         	str	r3, [r7, #0x1c]
; 	ospeed = conf & (STM32_OSPEEDR_MASK << STM32_OSPEEDR_SHIFT);
 801f9f0: 687b         	ldr	r3, [r7, #0x4]
 801f9f2: f403 73c0    	and	r3, r3, #0x180
 801f9f6: 61bb         	str	r3, [r7, #0x18]
; 	pupd = conf & (STM32_PUPDR_MASK << STM32_PUPDR_SHIFT);
 801f9f8: 687b         	ldr	r3, [r7, #0x4]
 801f9fa: f403 63c0    	and	r3, r3, #0x600
 801f9fe: 617b         	str	r3, [r7, #0x14]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 801fa00: f44f 1180    	mov.w	r1, #0x100000
 801fa04: 2000         	movs	r0, #0x0
 801fa06: f7ff fe71    	bl	0x801f6ec <z_stm32_hsem_lock> @ imm = #-0x31e
; 	LL_GPIO_SetPinOutputType(gpio, pin_ll, otype >> STM32_OTYPER_SHIFT);
 801fa0a: 69fb         	ldr	r3, [r7, #0x1c]
 801fa0c: 099b         	lsrs	r3, r3, #0x6
 801fa0e: 461a         	mov	r2, r3
 801fa10: 6a79         	ldr	r1, [r7, #0x24]
 801fa12: 6ab8         	ldr	r0, [r7, #0x28]
 801fa14: f7ff fce2    	bl	0x801f3dc <LL_GPIO_SetPinOutputType> @ imm = #-0x63c
; 	LL_GPIO_SetPinSpeed(gpio, pin_ll, ospeed >> STM32_OSPEEDR_SHIFT);
 801fa18: 69bb         	ldr	r3, [r7, #0x18]
 801fa1a: 09db         	lsrs	r3, r3, #0x7
 801fa1c: 461a         	mov	r2, r3
 801fa1e: 6a79         	ldr	r1, [r7, #0x24]
 801fa20: 6ab8         	ldr	r0, [r7, #0x28]
 801fa22: f7ff fcf3    	bl	0x801f40c <LL_GPIO_SetPinSpeed> @ imm = #-0x61a
; 	ll_gpio_set_pin_pull(gpio, pin_ll, pupd >> STM32_PUPDR_SHIFT);
 801fa26: 697b         	ldr	r3, [r7, #0x14]
 801fa28: 0a5b         	lsrs	r3, r3, #0x9
 801fa2a: 461a         	mov	r2, r3
 801fa2c: 6a79         	ldr	r1, [r7, #0x24]
 801fa2e: 6ab8         	ldr	r0, [r7, #0x28]
 801fa30: f7ff ff91    	bl	0x801f956 <ll_gpio_set_pin_pull> @ imm = #-0xde
; 	if (mode == STM32_MODER_ALT_MODE) {
 801fa34: 6a3b         	ldr	r3, [r7, #0x20]
 801fa36: 2b20         	cmp	r3, #0x20
 801fa38: d10d         	bne	0x801fa56 <gpio_stm32_configure_raw+0x9c> @ imm = #0x1a
; 		if (pin < 8) {
 801fa3a: 7afb         	ldrb	r3, [r7, #0xb]
 801fa3c: 2b07         	cmp	r3, #0x7
 801fa3e: d805         	bhi	0x801fa4c <gpio_stm32_configure_raw+0x92> @ imm = #0xa
; 			LL_GPIO_SetAFPin_0_7(gpio, pin_ll, func);
 801fa40: 683a         	ldr	r2, [r7]
 801fa42: 6a79         	ldr	r1, [r7, #0x24]
 801fa44: 6ab8         	ldr	r0, [r7, #0x28]
 801fa46: f7ff fd5b    	bl	0x801f500 <LL_GPIO_SetAFPin_0_7> @ imm = #-0x54a
 801fa4a: e004         	b	0x801fa56 <gpio_stm32_configure_raw+0x9c> @ imm = #0x8
; 			LL_GPIO_SetAFPin_8_15(gpio, pin_ll, func);
 801fa4c: 683a         	ldr	r2, [r7]
 801fa4e: 6a79         	ldr	r1, [r7, #0x24]
 801fa50: 6ab8         	ldr	r0, [r7, #0x28]
 801fa52: f7ff fd92    	bl	0x801f57a <LL_GPIO_SetAFPin_8_15> @ imm = #-0x4dc
; 	LL_GPIO_SetPinMode(gpio, pin_ll, mode >> STM32_MODER_SHIFT);
 801fa56: 6a3b         	ldr	r3, [r7, #0x20]
 801fa58: 091b         	lsrs	r3, r3, #0x4
 801fa5a: 461a         	mov	r2, r3
 801fa5c: 6a79         	ldr	r1, [r7, #0x24]
 801fa5e: 6ab8         	ldr	r0, [r7, #0x28]
 801fa60: f7ff fc7f    	bl	0x801f362 <LL_GPIO_SetPinMode> @ imm = #-0x702
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 801fa64: 2000         	movs	r0, #0x0
 801fa66: f7ff fe4c    	bl	0x801f702 <z_stm32_hsem_unlock> @ imm = #-0x368
; }
 801fa6a: bf00         	nop
 801fa6c: 3730         	adds	r7, #0x30
 801fa6e: 46bd         	mov	sp, r7
 801fa70: bd80         	pop	{r7, pc}

0801fa72 <gpio_stm32_port_get_raw>:
; {
 801fa72: b580         	push	{r7, lr}
 801fa74: b084         	sub	sp, #0x10
 801fa76: af00         	add	r7, sp, #0x0
 801fa78: 6078         	str	r0, [r7, #0x4]
 801fa7a: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 801fa7c: 687b         	ldr	r3, [r7, #0x4]
 801fa7e: 685b         	ldr	r3, [r3, #0x4]
 801fa80: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 801fa82: 68fb         	ldr	r3, [r7, #0xc]
 801fa84: 685b         	ldr	r3, [r3, #0x4]
 801fa86: 60bb         	str	r3, [r7, #0x8]
; 	*value = LL_GPIO_ReadInputPort(gpio);
 801fa88: 68b8         	ldr	r0, [r7, #0x8]
 801fa8a: f7ff fdb5    	bl	0x801f5f8 <LL_GPIO_ReadInputPort> @ imm = #-0x496
 801fa8e: 4602         	mov	r2, r0
 801fa90: 683b         	ldr	r3, [r7]
 801fa92: 601a         	str	r2, [r3]
; 	return 0;
 801fa94: 2300         	movs	r3, #0x0
; }
 801fa96: 4618         	mov	r0, r3
 801fa98: 3710         	adds	r7, #0x10
 801fa9a: 46bd         	mov	sp, r7
 801fa9c: bd80         	pop	{r7, pc}

0801fa9e <gpio_stm32_port_set_masked_raw>:
; {
 801fa9e: b580         	push	{r7, lr}
 801faa0: b088         	sub	sp, #0x20
 801faa2: af00         	add	r7, sp, #0x0
 801faa4: 60f8         	str	r0, [r7, #0xc]
 801faa6: 60b9         	str	r1, [r7, #0x8]
 801faa8: 607a         	str	r2, [r7, #0x4]
; 	const struct gpio_stm32_config *cfg = dev->config;
 801faaa: 68fb         	ldr	r3, [r7, #0xc]
 801faac: 685b         	ldr	r3, [r3, #0x4]
 801faae: 61fb         	str	r3, [r7, #0x1c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 801fab0: 69fb         	ldr	r3, [r7, #0x1c]
 801fab2: 685b         	ldr	r3, [r3, #0x4]
 801fab4: 61bb         	str	r3, [r7, #0x18]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 801fab6: f44f 1180    	mov.w	r1, #0x100000
 801faba: 2000         	movs	r0, #0x0
 801fabc: f7ff fe16    	bl	0x801f6ec <z_stm32_hsem_lock> @ imm = #-0x3d4
; 	port_value = LL_GPIO_ReadOutputPort(gpio);
 801fac0: 69b8         	ldr	r0, [r7, #0x18]
 801fac2: f7ff fdb3    	bl	0x801f62c <LL_GPIO_ReadOutputPort> @ imm = #-0x49a
 801fac6: 6178         	str	r0, [r7, #0x14]
; 	LL_GPIO_WriteOutputPort(gpio, (port_value & ~mask) | (mask & value));
 801fac8: 68bb         	ldr	r3, [r7, #0x8]
 801faca: 43da         	mvns	r2, r3
 801facc: 697b         	ldr	r3, [r7, #0x14]
 801face: 401a         	ands	r2, r3
 801fad0: 68b9         	ldr	r1, [r7, #0x8]
 801fad2: 687b         	ldr	r3, [r7, #0x4]
 801fad4: 400b         	ands	r3, r1
 801fad6: 4313         	orrs	r3, r2
 801fad8: 4619         	mov	r1, r3
 801fada: 69b8         	ldr	r0, [r7, #0x18]
 801fadc: f7ff fd98    	bl	0x801f610 <LL_GPIO_WriteOutputPort> @ imm = #-0x4d0
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 801fae0: 2000         	movs	r0, #0x0
 801fae2: f7ff fe0e    	bl	0x801f702 <z_stm32_hsem_unlock> @ imm = #-0x3e4
; 	return 0;
 801fae6: 2300         	movs	r3, #0x0
; }
 801fae8: 4618         	mov	r0, r3
 801faea: 3720         	adds	r7, #0x20
 801faec: 46bd         	mov	sp, r7
 801faee: bd80         	pop	{r7, pc}

0801faf0 <gpio_stm32_port_set_bits_raw>:
; {
 801faf0: b480         	push	{r7}
 801faf2: b085         	sub	sp, #0x14
 801faf4: af00         	add	r7, sp, #0x0
 801faf6: 6078         	str	r0, [r7, #0x4]
 801faf8: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 801fafa: 687b         	ldr	r3, [r7, #0x4]
 801fafc: 685b         	ldr	r3, [r3, #0x4]
 801fafe: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 801fb00: 68fb         	ldr	r3, [r7, #0xc]
 801fb02: 685b         	ldr	r3, [r3, #0x4]
 801fb04: 60bb         	str	r3, [r7, #0x8]
; 	WRITE_REG(gpio->BSRR, pins);
 801fb06: 68bb         	ldr	r3, [r7, #0x8]
 801fb08: 683a         	ldr	r2, [r7]
 801fb0a: 619a         	str	r2, [r3, #0x18]
; 	return 0;
 801fb0c: 2300         	movs	r3, #0x0
; }
 801fb0e: 4618         	mov	r0, r3
 801fb10: 3714         	adds	r7, #0x14
 801fb12: 46bd         	mov	sp, r7
 801fb14: f85d 7b04    	ldr	r7, [sp], #4
 801fb18: 4770         	bx	lr

0801fb1a <gpio_stm32_port_clear_bits_raw>:
; {
 801fb1a: b580         	push	{r7, lr}
 801fb1c: b084         	sub	sp, #0x10
 801fb1e: af00         	add	r7, sp, #0x0
 801fb20: 6078         	str	r0, [r7, #0x4]
 801fb22: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 801fb24: 687b         	ldr	r3, [r7, #0x4]
 801fb26: 685b         	ldr	r3, [r3, #0x4]
 801fb28: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 801fb2a: 68fb         	ldr	r3, [r7, #0xc]
 801fb2c: 685b         	ldr	r3, [r3, #0x4]
 801fb2e: 60bb         	str	r3, [r7, #0x8]
; 	LL_GPIO_ResetOutputPin(gpio, pins);
 801fb30: 6839         	ldr	r1, [r7]
 801fb32: 68b8         	ldr	r0, [r7, #0x8]
 801fb34: f7ff fd86    	bl	0x801f644 <LL_GPIO_ResetOutputPin> @ imm = #-0x4f4
; 	return 0;
 801fb38: 2300         	movs	r3, #0x0
; }
 801fb3a: 4618         	mov	r0, r3
 801fb3c: 3710         	adds	r7, #0x10
 801fb3e: 46bd         	mov	sp, r7
 801fb40: bd80         	pop	{r7, pc}

0801fb42 <gpio_stm32_port_toggle_bits>:
; {
 801fb42: b580         	push	{r7, lr}
 801fb44: b084         	sub	sp, #0x10
 801fb46: af00         	add	r7, sp, #0x0
 801fb48: 6078         	str	r0, [r7, #0x4]
 801fb4a: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 801fb4c: 687b         	ldr	r3, [r7, #0x4]
 801fb4e: 685b         	ldr	r3, [r3, #0x4]
 801fb50: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 801fb52: 68fb         	ldr	r3, [r7, #0xc]
 801fb54: 685b         	ldr	r3, [r3, #0x4]
 801fb56: 60bb         	str	r3, [r7, #0x8]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 801fb58: f44f 1180    	mov.w	r1, #0x100000
 801fb5c: 2000         	movs	r0, #0x0
 801fb5e: f7ff fdc5    	bl	0x801f6ec <z_stm32_hsem_lock> @ imm = #-0x476
; 	WRITE_REG(gpio->ODR, READ_REG(gpio->ODR) ^ pins);
 801fb62: 68bb         	ldr	r3, [r7, #0x8]
 801fb64: 695a         	ldr	r2, [r3, #0x14]
 801fb66: 683b         	ldr	r3, [r7]
 801fb68: 405a         	eors	r2, r3
 801fb6a: 68bb         	ldr	r3, [r7, #0x8]
 801fb6c: 615a         	str	r2, [r3, #0x14]
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 801fb6e: 2000         	movs	r0, #0x0
 801fb70: f7ff fdc7    	bl	0x801f702 <z_stm32_hsem_unlock> @ imm = #-0x472
; 	return 0;
 801fb74: 2300         	movs	r3, #0x0
; }
 801fb76: 4618         	mov	r0, r3
 801fb78: 3710         	adds	r7, #0x10
 801fb7a: 46bd         	mov	sp, r7
 801fb7c: bd80         	pop	{r7, pc}

0801fb7e <gpio_stm32_configure>:
; {
 801fb7e: b580         	push	{r7, lr}
 801fb80: b086         	sub	sp, #0x18
 801fb82: af00         	add	r7, sp, #0x0
 801fb84: 60f8         	str	r0, [r7, #0xc]
 801fb86: 607a         	str	r2, [r7, #0x4]
 801fb88: 603b         	str	r3, [r7]
 801fb8a: 460b         	mov	r3, r1
 801fb8c: 72fb         	strb	r3, [r7, #0xb]
; 	ret = pm_device_runtime_get(dev);
 801fb8e: 68f8         	ldr	r0, [r7, #0xc]
 801fb90: f7ff fd96    	bl	0x801f6c0 <pm_device_runtime_get> @ imm = #-0x4d4
 801fb94: 6178         	str	r0, [r7, #0x14]
; 	if (ret < 0) {
 801fb96: 697b         	ldr	r3, [r7, #0x14]
 801fb98: 2b00         	cmp	r3, #0x0
 801fb9a: da01         	bge	0x801fba0 <gpio_stm32_configure+0x22> @ imm = #0x2
; 		return ret;
 801fb9c: 697b         	ldr	r3, [r7, #0x14]
 801fb9e: e028         	b	0x801fbf2 <gpio_stm32_configure+0x74> @ imm = #0x50
; 	gpio_stm32_configure_raw(dev, pin, conf, func);
 801fba0: 7af9         	ldrb	r1, [r7, #0xb]
 801fba2: 683b         	ldr	r3, [r7]
 801fba4: 687a         	ldr	r2, [r7, #0x4]
 801fba6: 68f8         	ldr	r0, [r7, #0xc]
 801fba8: f7ff ff07    	bl	0x801f9ba <gpio_stm32_configure_raw> @ imm = #-0x1f2
; 	if (func == IS_GPIO_OUT) {
 801fbac: 683b         	ldr	r3, [r7]
 801fbae: 2b11         	cmp	r3, #0x11
 801fbb0: d11b         	bne	0x801fbea <gpio_stm32_configure+0x6c> @ imm = #0x36
; 		uint32_t gpio_out = conf & (STM32_ODR_MASK << STM32_ODR_SHIFT);
 801fbb2: 687b         	ldr	r3, [r7, #0x4]
 801fbb4: f403 6300    	and	r3, r3, #0x800
 801fbb8: 613b         	str	r3, [r7, #0x10]
; 		if (gpio_out == STM32_ODR_1) {
 801fbba: 693b         	ldr	r3, [r7, #0x10]
 801fbbc: f5b3 6f00    	cmp.w	r3, #0x800
 801fbc0: d108         	bne	0x801fbd4 <gpio_stm32_configure+0x56> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 801fbc2: 7afb         	ldrb	r3, [r7, #0xb]
 801fbc4: 2201         	movs	r2, #0x1
 801fbc6: fa02 f303    	lsl.w	r3, r2, r3
 801fbca: 4619         	mov	r1, r3
 801fbcc: 68f8         	ldr	r0, [r7, #0xc]
 801fbce: f7ff ff8f    	bl	0x801faf0 <gpio_stm32_port_set_bits_raw> @ imm = #-0xe2
 801fbd2: e00a         	b	0x801fbea <gpio_stm32_configure+0x6c> @ imm = #0x14
; 		} else if (gpio_out == STM32_ODR_0) {
 801fbd4: 693b         	ldr	r3, [r7, #0x10]
 801fbd6: 2b00         	cmp	r3, #0x0
 801fbd8: d107         	bne	0x801fbea <gpio_stm32_configure+0x6c> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 801fbda: 7afb         	ldrb	r3, [r7, #0xb]
 801fbdc: 2201         	movs	r2, #0x1
 801fbde: fa02 f303    	lsl.w	r3, r2, r3
 801fbe2: 4619         	mov	r1, r3
 801fbe4: 68f8         	ldr	r0, [r7, #0xc]
 801fbe6: f7ff ff98    	bl	0x801fb1a <gpio_stm32_port_clear_bits_raw> @ imm = #-0xd0
; 	return pm_device_runtime_put(dev);
 801fbea: 68f8         	ldr	r0, [r7, #0xc]
 801fbec: f7ff fd73    	bl	0x801f6d6 <pm_device_runtime_put> @ imm = #-0x51a
 801fbf0: 4603         	mov	r3, r0
; }
 801fbf2: 4618         	mov	r0, r3
 801fbf4: 3718         	adds	r7, #0x18
 801fbf6: 46bd         	mov	sp, r7
 801fbf8: bd80         	pop	{r7, pc}

0801fbfa <gpio_stm32_config>:
; {
 801fbfa: b580         	push	{r7, lr}
 801fbfc: b088         	sub	sp, #0x20
 801fbfe: af00         	add	r7, sp, #0x0
 801fc00: 60f8         	str	r0, [r7, #0xc]
 801fc02: 460b         	mov	r3, r1
 801fc04: 607a         	str	r2, [r7, #0x4]
 801fc06: 72fb         	strb	r3, [r7, #0xb]
; 	struct gpio_stm32_data *data = dev->data;
 801fc08: 68fb         	ldr	r3, [r7, #0xc]
 801fc0a: 691b         	ldr	r3, [r3, #0x10]
 801fc0c: 61fb         	str	r3, [r7, #0x1c]
; 	err = gpio_stm32_flags_to_conf(flags, &pincfg);
 801fc0e: f107 0314    	add.w	r3, r7, #0x14
 801fc12: 4619         	mov	r1, r3
 801fc14: 6878         	ldr	r0, [r7, #0x4]
 801fc16: f7ff fe21    	bl	0x801f85c <gpio_stm32_flags_to_conf> @ imm = #-0x3be
 801fc1a: 61b8         	str	r0, [r7, #0x18]
; 	if (err != 0) {
 801fc1c: 69bb         	ldr	r3, [r7, #0x18]
 801fc1e: 2b00         	cmp	r3, #0x0
 801fc20: d001         	beq	0x801fc26 <gpio_stm32_config+0x2c> @ imm = #0x2
; 		return err;
 801fc22: 69bb         	ldr	r3, [r7, #0x18]
 801fc24: e071         	b	0x801fd0a <gpio_stm32_config+0x110> @ imm = #0xe2
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 801fc26: 687b         	ldr	r3, [r7, #0x4]
 801fc28: f403 3300    	and	r3, r3, #0x20000
 801fc2c: 2b00         	cmp	r3, #0x0
 801fc2e: d104         	bne	0x801fc3a <gpio_stm32_config+0x40> @ imm = #0x8
 801fc30: 687b         	ldr	r3, [r7, #0x4]
 801fc32: f403 3380    	and	r3, r3, #0x10000
 801fc36: 2b00         	cmp	r3, #0x0
 801fc38: d01a         	beq	0x801fc70 <gpio_stm32_config+0x76> @ imm = #0x34
; 	    !(data->pin_has_clock_enabled & BIT(pin))) {
 801fc3a: 69fb         	ldr	r3, [r7, #0x1c]
 801fc3c: 691a         	ldr	r2, [r3, #0x10]
 801fc3e: 7afb         	ldrb	r3, [r7, #0xb]
 801fc40: fa22 f303    	lsr.w	r3, r2, r3
 801fc44: f003 0301    	and	r3, r3, #0x1
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 801fc48: 2b00         	cmp	r3, #0x0
 801fc4a: d111         	bne	0x801fc70 <gpio_stm32_config+0x76> @ imm = #0x22
; 		err = pm_device_runtime_get(dev);
 801fc4c: 68f8         	ldr	r0, [r7, #0xc]
 801fc4e: f7ff fd37    	bl	0x801f6c0 <pm_device_runtime_get> @ imm = #-0x592
 801fc52: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 801fc54: 69bb         	ldr	r3, [r7, #0x18]
 801fc56: 2b00         	cmp	r3, #0x0
 801fc58: da01         	bge	0x801fc5e <gpio_stm32_config+0x64> @ imm = #0x2
; 			return err;
 801fc5a: 69bb         	ldr	r3, [r7, #0x18]
 801fc5c: e055         	b	0x801fd0a <gpio_stm32_config+0x110> @ imm = #0xaa
; 		data->pin_has_clock_enabled |= BIT(pin);
 801fc5e: 69fb         	ldr	r3, [r7, #0x1c]
 801fc60: 691a         	ldr	r2, [r3, #0x10]
 801fc62: 7afb         	ldrb	r3, [r7, #0xb]
 801fc64: 2101         	movs	r1, #0x1
 801fc66: fa01 f303    	lsl.w	r3, r1, r3
 801fc6a: 431a         	orrs	r2, r3
 801fc6c: 69fb         	ldr	r3, [r7, #0x1c]
 801fc6e: 611a         	str	r2, [r3, #0x10]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 801fc70: 687b         	ldr	r3, [r7, #0x4]
 801fc72: f403 3300    	and	r3, r3, #0x20000
 801fc76: 2b00         	cmp	r3, #0x0
 801fc78: d01a         	beq	0x801fcb0 <gpio_stm32_config+0xb6> @ imm = #0x34
; 		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 801fc7a: 687b         	ldr	r3, [r7, #0x4]
 801fc7c: f403 2300    	and	r3, r3, #0x80000
 801fc80: 2b00         	cmp	r3, #0x0
 801fc82: d008         	beq	0x801fc96 <gpio_stm32_config+0x9c> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 801fc84: 7afb         	ldrb	r3, [r7, #0xb]
 801fc86: 2201         	movs	r2, #0x1
 801fc88: fa02 f303    	lsl.w	r3, r2, r3
 801fc8c: 4619         	mov	r1, r3
 801fc8e: 68f8         	ldr	r0, [r7, #0xc]
 801fc90: f7ff ff2e    	bl	0x801faf0 <gpio_stm32_port_set_bits_raw> @ imm = #-0x1a4
 801fc94: e00c         	b	0x801fcb0 <gpio_stm32_config+0xb6> @ imm = #0x18
; 		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
 801fc96: 687b         	ldr	r3, [r7, #0x4]
 801fc98: f403 2380    	and	r3, r3, #0x40000
 801fc9c: 2b00         	cmp	r3, #0x0
 801fc9e: d007         	beq	0x801fcb0 <gpio_stm32_config+0xb6> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 801fca0: 7afb         	ldrb	r3, [r7, #0xb]
 801fca2: 2201         	movs	r2, #0x1
 801fca4: fa02 f303    	lsl.w	r3, r2, r3
 801fca8: 4619         	mov	r1, r3
 801fcaa: 68f8         	ldr	r0, [r7, #0xc]
 801fcac: f7ff ff35    	bl	0x801fb1a <gpio_stm32_port_clear_bits_raw> @ imm = #-0x196
; 	gpio_stm32_configure_raw(dev, pin, pincfg, 0);
 801fcb0: 697a         	ldr	r2, [r7, #0x14]
 801fcb2: 7af9         	ldrb	r1, [r7, #0xb]
 801fcb4: 2300         	movs	r3, #0x0
 801fcb6: 68f8         	ldr	r0, [r7, #0xc]
 801fcb8: f7ff fe7f    	bl	0x801f9ba <gpio_stm32_configure_raw> @ imm = #-0x302
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 801fcbc: 687b         	ldr	r3, [r7, #0x4]
 801fcbe: f403 3300    	and	r3, r3, #0x20000
 801fcc2: 2b00         	cmp	r3, #0x0
 801fcc4: d120         	bne	0x801fd08 <gpio_stm32_config+0x10e> @ imm = #0x40
 801fcc6: 687b         	ldr	r3, [r7, #0x4]
 801fcc8: f403 3380    	and	r3, r3, #0x10000
 801fccc: 2b00         	cmp	r3, #0x0
 801fcce: d11b         	bne	0x801fd08 <gpio_stm32_config+0x10e> @ imm = #0x36
; 	    (data->pin_has_clock_enabled & BIT(pin))) {
 801fcd0: 69fb         	ldr	r3, [r7, #0x1c]
 801fcd2: 691a         	ldr	r2, [r3, #0x10]
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 801fcd4: 7afb         	ldrb	r3, [r7, #0xb]
 801fcd6: fa22 f303    	lsr.w	r3, r2, r3
 801fcda: f003 0301    	and	r3, r3, #0x1
 801fcde: 2b00         	cmp	r3, #0x0
 801fce0: d012         	beq	0x801fd08 <gpio_stm32_config+0x10e> @ imm = #0x24
; 		err = pm_device_runtime_put(dev);
 801fce2: 68f8         	ldr	r0, [r7, #0xc]
 801fce4: f7ff fcf7    	bl	0x801f6d6 <pm_device_runtime_put> @ imm = #-0x612
 801fce8: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 801fcea: 69bb         	ldr	r3, [r7, #0x18]
 801fcec: 2b00         	cmp	r3, #0x0
 801fcee: da01         	bge	0x801fcf4 <gpio_stm32_config+0xfa> @ imm = #0x2
; 			return err;
 801fcf0: 69bb         	ldr	r3, [r7, #0x18]
 801fcf2: e00a         	b	0x801fd0a <gpio_stm32_config+0x110> @ imm = #0x14
; 		data->pin_has_clock_enabled &= ~BIT(pin);
 801fcf4: 69fb         	ldr	r3, [r7, #0x1c]
 801fcf6: 691a         	ldr	r2, [r3, #0x10]
 801fcf8: 7afb         	ldrb	r3, [r7, #0xb]
 801fcfa: 2101         	movs	r1, #0x1
 801fcfc: fa01 f303    	lsl.w	r3, r1, r3
 801fd00: 43db         	mvns	r3, r3
 801fd02: 401a         	ands	r2, r3
 801fd04: 69fb         	ldr	r3, [r7, #0x1c]
 801fd06: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 801fd08: 2300         	movs	r3, #0x0
; }
 801fd0a: 4618         	mov	r0, r3
 801fd0c: 3720         	adds	r7, #0x20
 801fd0e: 46bd         	mov	sp, r7
 801fd10: bd80         	pop	{r7, pc}

0801fd12 <gpio_stm32_manage_callback>:
; {
 801fd12: b580         	push	{r7, lr}
 801fd14: b086         	sub	sp, #0x18
 801fd16: af00         	add	r7, sp, #0x0
 801fd18: 60f8         	str	r0, [r7, #0xc]
 801fd1a: 60b9         	str	r1, [r7, #0x8]
 801fd1c: 4613         	mov	r3, r2
 801fd1e: 71fb         	strb	r3, [r7, #0x7]
; 	struct gpio_stm32_data *data = dev->data;
 801fd20: 68fb         	ldr	r3, [r7, #0xc]
 801fd22: 691b         	ldr	r3, [r3, #0x10]
 801fd24: 617b         	str	r3, [r7, #0x14]
; 	return gpio_manage_callback(&data->cb, callback, set);
 801fd26: 697b         	ldr	r3, [r7, #0x14]
 801fd28: 3308         	adds	r3, #0x8
 801fd2a: 79fa         	ldrb	r2, [r7, #0x7]
 801fd2c: 68b9         	ldr	r1, [r7, #0x8]
 801fd2e: 4618         	mov	r0, r3
 801fd30: f7ff fcf1    	bl	0x801f716 <gpio_manage_callback> @ imm = #-0x61e
 801fd34: 4603         	mov	r3, r0
; }
 801fd36: 4618         	mov	r0, r3
 801fd38: 3718         	adds	r7, #0x18
 801fd3a: 46bd         	mov	sp, r7
 801fd3c: bd80         	pop	{r7, pc}

0801fd3e <pinctrl_lookup_state>:
; {
 801fd3e: b480         	push	{r7}
 801fd40: b085         	sub	sp, #0x14
 801fd42: af00         	add	r7, sp, #0x0
 801fd44: 60f8         	str	r0, [r7, #0xc]
 801fd46: 460b         	mov	r3, r1
 801fd48: 607a         	str	r2, [r7, #0x4]
 801fd4a: 72fb         	strb	r3, [r7, #0xb]
; 	*state = &config->states[0];
 801fd4c: 68fb         	ldr	r3, [r7, #0xc]
 801fd4e: 681a         	ldr	r2, [r3]
 801fd50: 687b         	ldr	r3, [r7, #0x4]
 801fd52: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 801fd54: e00d         	b	0x801fd72 <pinctrl_lookup_state+0x34> @ imm = #0x1a
; 		if (id == (*state)->id) {
 801fd56: 687b         	ldr	r3, [r7, #0x4]
 801fd58: 681b         	ldr	r3, [r3]
 801fd5a: 795b         	ldrb	r3, [r3, #0x5]
 801fd5c: 7afa         	ldrb	r2, [r7, #0xb]
 801fd5e: 429a         	cmp	r2, r3
 801fd60: d101         	bne	0x801fd66 <pinctrl_lookup_state+0x28> @ imm = #0x2
; 			return 0;
 801fd62: 2300         	movs	r3, #0x0
 801fd64: e011         	b	0x801fd8a <pinctrl_lookup_state+0x4c> @ imm = #0x22
; 		(*state)++;
 801fd66: 687b         	ldr	r3, [r7, #0x4]
 801fd68: 681b         	ldr	r3, [r3]
 801fd6a: f103 0208    	add.w	r2, r3, #0x8
 801fd6e: 687b         	ldr	r3, [r7, #0x4]
 801fd70: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 801fd72: 687b         	ldr	r3, [r7, #0x4]
 801fd74: 681a         	ldr	r2, [r3]
 801fd76: 68fb         	ldr	r3, [r7, #0xc]
 801fd78: 6819         	ldr	r1, [r3]
 801fd7a: 68fb         	ldr	r3, [r7, #0xc]
 801fd7c: 791b         	ldrb	r3, [r3, #0x4]
 801fd7e: 00db         	lsls	r3, r3, #0x3
 801fd80: 440b         	add	r3, r1
 801fd82: 429a         	cmp	r2, r3
 801fd84: d3e7         	blo	0x801fd56 <pinctrl_lookup_state+0x18> @ imm = #-0x32
; 	return -ENOENT;
 801fd86: f06f 0301    	mvn	r3, #0x1
; }
 801fd8a: 4618         	mov	r0, r3
 801fd8c: 3714         	adds	r7, #0x14
 801fd8e: 46bd         	mov	sp, r7
 801fd90: f85d 7b04    	ldr	r7, [sp], #4
 801fd94: 4770         	bx	lr

0801fd96 <device_is_ready>:
; {
 801fd96: b580         	push	{r7, lr}
 801fd98: b082         	sub	sp, #0x8
 801fd9a: af00         	add	r7, sp, #0x0
 801fd9c: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801fd9e: 6878         	ldr	r0, [r7, #0x4]
 801fda0: f004 fbbf    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x477e
 801fda4: 4603         	mov	r3, r0
; }
 801fda6: 4618         	mov	r0, r3
 801fda8: 3708         	adds	r7, #0x8
 801fdaa: 46bd         	mov	sp, r7
 801fdac: bd80         	pop	{r7, pc}

0801fdae <pinctrl_configure_pins>:
; {
 801fdae: b580         	push	{r7, lr}
 801fdb0: b08a         	sub	sp, #0x28
 801fdb2: af00         	add	r7, sp, #0x0
 801fdb4: 60f8         	str	r0, [r7, #0xc]
 801fdb6: 460b         	mov	r3, r1
 801fdb8: 607a         	str	r2, [r7, #0x4]
 801fdba: 72fb         	strb	r3, [r7, #0xb]
; 	uint32_t pin_cgf = 0;
 801fdbc: 2300         	movs	r3, #0x0
 801fdbe: 627b         	str	r3, [r7, #0x24]
; 	int ret = 0;
 801fdc0: 2300         	movs	r3, #0x0
 801fdc2: 61fb         	str	r3, [r7, #0x1c]
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 801fdc4: 2300         	movs	r3, #0x0
 801fdc6: f887 3023    	strb.w	r3, [r7, #0x23]
 801fdca: e047         	b	0x801fe5c <pinctrl_configure_pins+0xae> @ imm = #0x8e
; 		mux = pins[i].pinmux;
 801fdcc: f897 3023    	ldrb.w	r3, [r7, #0x23]
 801fdd0: 00db         	lsls	r3, r3, #0x3
 801fdd2: 68fa         	ldr	r2, [r7, #0xc]
 801fdd4: 4413         	add	r3, r2
 801fdd6: 681b         	ldr	r3, [r3]
 801fdd8: 61bb         	str	r3, [r7, #0x18]
; 		if (STM32_DT_PINMUX_FUNC(mux) < STM32_ANALOG) {
 801fdda: 69bb         	ldr	r3, [r7, #0x18]
 801fddc: f003 0310    	and	r3, r3, #0x10
 801fde0: 2b00         	cmp	r3, #0x0
 801fde2: d109         	bne	0x801fdf8 <pinctrl_configure_pins+0x4a> @ imm = #0x12
; 			pin_cgf = pins[i].pincfg | STM32_MODER_ALT_MODE;
 801fde4: f897 3023    	ldrb.w	r3, [r7, #0x23]
 801fde8: 00db         	lsls	r3, r3, #0x3
 801fdea: 68fa         	ldr	r2, [r7, #0xc]
 801fdec: 4413         	add	r3, r2
 801fdee: 685b         	ldr	r3, [r3, #0x4]
 801fdf0: f043 0320    	orr	r3, r3, #0x20
 801fdf4: 627b         	str	r3, [r7, #0x24]
 801fdf6: e013         	b	0x801fe20 <pinctrl_configure_pins+0x72> @ imm = #0x26
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_ANALOG) {
 801fdf8: 69bb         	ldr	r3, [r7, #0x18]
 801fdfa: f003 031f    	and	r3, r3, #0x1f
 801fdfe: 2b10         	cmp	r3, #0x10
 801fe00: d102         	bne	0x801fe08 <pinctrl_configure_pins+0x5a> @ imm = #0x4
; 			pin_cgf = STM32_MODER_ANALOG_MODE;
 801fe02: 2330         	movs	r3, #0x30
 801fe04: 627b         	str	r3, [r7, #0x24]
 801fe06: e00b         	b	0x801fe20 <pinctrl_configure_pins+0x72> @ imm = #0x16
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_GPIO) {
 801fe08: 69bb         	ldr	r3, [r7, #0x18]
 801fe0a: f003 031f    	and	r3, r3, #0x1f
 801fe0e: 2b11         	cmp	r3, #0x11
 801fe10: d106         	bne	0x801fe20 <pinctrl_configure_pins+0x72> @ imm = #0xc
; 			pin_cgf = pins[i].pincfg;
 801fe12: f897 3023    	ldrb.w	r3, [r7, #0x23]
 801fe16: 00db         	lsls	r3, r3, #0x3
 801fe18: 68fa         	ldr	r2, [r7, #0xc]
 801fe1a: 4413         	add	r3, r2
 801fe1c: 685b         	ldr	r3, [r3, #0x4]
 801fe1e: 627b         	str	r3, [r7, #0x24]
; 		pin = STM32PIN(STM32_DT_PINMUX_PORT(mux),
 801fe20: 69bb         	ldr	r3, [r7, #0x18]
 801fe22: 0a5b         	lsrs	r3, r3, #0x9
 801fe24: 011b         	lsls	r3, r3, #0x4
 801fe26: f403 72f8    	and	r2, r3, #0x1f0
 801fe2a: 69bb         	ldr	r3, [r7, #0x18]
 801fe2c: 095b         	lsrs	r3, r3, #0x5
 801fe2e: f003 030f    	and	r3, r3, #0xf
 801fe32: 4313         	orrs	r3, r2
 801fe34: 617b         	str	r3, [r7, #0x14]
; 		ret = stm32_pin_configure(pin, pin_cgf, STM32_DT_PINMUX_FUNC(mux));
 801fe36: 69bb         	ldr	r3, [r7, #0x18]
 801fe38: f003 031f    	and	r3, r3, #0x1f
 801fe3c: 461a         	mov	r2, r3
 801fe3e: 6a79         	ldr	r1, [r7, #0x24]
 801fe40: 6978         	ldr	r0, [r7, #0x14]
 801fe42: f7eb f92b    	bl	0x800b09c <stm32_pin_configure> @ imm = #-0x14daa
 801fe46: 61f8         	str	r0, [r7, #0x1c]
; 		if (ret < 0) {
 801fe48: 69fb         	ldr	r3, [r7, #0x1c]
 801fe4a: 2b00         	cmp	r3, #0x0
 801fe4c: da01         	bge	0x801fe52 <pinctrl_configure_pins+0xa4> @ imm = #0x2
; 			return ret;
 801fe4e: 69fb         	ldr	r3, [r7, #0x1c]
 801fe50: e00a         	b	0x801fe68 <pinctrl_configure_pins+0xba> @ imm = #0x14
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 801fe52: f897 3023    	ldrb.w	r3, [r7, #0x23]
 801fe56: 3301         	adds	r3, #0x1
 801fe58: f887 3023    	strb.w	r3, [r7, #0x23]
 801fe5c: f897 2023    	ldrb.w	r2, [r7, #0x23]
 801fe60: 7afb         	ldrb	r3, [r7, #0xb]
 801fe62: 429a         	cmp	r2, r3
 801fe64: d3b2         	blo	0x801fdcc <pinctrl_configure_pins+0x1e> @ imm = #-0x9c
; 	return 0;
 801fe66: 2300         	movs	r3, #0x0
; }
 801fe68: 4618         	mov	r0, r3
 801fe6a: 3728         	adds	r7, #0x28
 801fe6c: 46bd         	mov	sp, r7
 801fe6e: bd80         	pop	{r7, pc}

0801fe70 <reset_stm32_status>:
; {
 801fe70: b480         	push	{r7}
 801fe72: b089         	sub	sp, #0x24
 801fe74: af00         	add	r7, sp, #0x0
 801fe76: 60f8         	str	r0, [r7, #0xc]
 801fe78: 60b9         	str	r1, [r7, #0x8]
 801fe7a: 607a         	str	r2, [r7, #0x4]
; 	const struct reset_stm32_config *config = dev->config;
 801fe7c: 68fb         	ldr	r3, [r7, #0xc]
 801fe7e: 685b         	ldr	r3, [r3, #0x4]
 801fe80: 61fb         	str	r3, [r7, #0x1c]
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 801fe82: 69fb         	ldr	r3, [r7, #0x1c]
 801fe84: 681a         	ldr	r2, [r3]
 801fe86: 68bb         	ldr	r3, [r7, #0x8]
 801fe88: 095b         	lsrs	r3, r3, #0x5
 801fe8a: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 801fe8e: 441a         	add	r2, r3
 801fe90: 68bb         	ldr	r3, [r7, #0x8]
 801fe92: f003 031f    	and	r3, r3, #0x1f
 801fe96: 61ba         	str	r2, [r7, #0x18]
 801fe98: 617b         	str	r3, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801fe9a: 69bb         	ldr	r3, [r7, #0x18]
 801fe9c: 681b         	ldr	r3, [r3]
 801fe9e: 613b         	str	r3, [r7, #0x10]
; 	return temp & (1 << bit);
 801fea0: 2201         	movs	r2, #0x1
 801fea2: 697b         	ldr	r3, [r7, #0x14]
 801fea4: fa02 f303    	lsl.w	r3, r2, r3
 801fea8: 461a         	mov	r2, r3
 801feaa: 693b         	ldr	r3, [r7, #0x10]
 801feac: 4013         	ands	r3, r2
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 801feae: 2b00         	cmp	r3, #0x0
 801feb0: bf14         	ite	ne
 801feb2: 2301         	movne	r3, #0x1
 801feb4: 2300         	moveq	r3, #0x0
 801feb6: b2db         	uxtb	r3, r3
 801feb8: 461a         	mov	r2, r3
 801feba: 687b         	ldr	r3, [r7, #0x4]
 801febc: 701a         	strb	r2, [r3]
; 	return 0;
 801febe: 2300         	movs	r3, #0x0
; }
 801fec0: 4618         	mov	r0, r3
 801fec2: 3724         	adds	r7, #0x24
 801fec4: 46bd         	mov	sp, r7
 801fec6: f85d 7b04    	ldr	r7, [sp], #4
 801feca: 4770         	bx	lr

0801fecc <reset_stm32_line_assert>:
; {
 801fecc: b480         	push	{r7}
 801fece: b087         	sub	sp, #0x1c
 801fed0: af00         	add	r7, sp, #0x0
 801fed2: 6078         	str	r0, [r7, #0x4]
 801fed4: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 801fed6: 687b         	ldr	r3, [r7, #0x4]
 801fed8: 685b         	ldr	r3, [r3, #0x4]
 801feda: 617b         	str	r3, [r7, #0x14]
; 	sys_set_bit(config->base + STM32_RESET_SET_OFFSET(id),
 801fedc: 697b         	ldr	r3, [r7, #0x14]
 801fede: 681a         	ldr	r2, [r3]
 801fee0: 683b         	ldr	r3, [r7]
 801fee2: 095b         	lsrs	r3, r3, #0x5
 801fee4: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 801fee8: 441a         	add	r2, r3
 801feea: 683b         	ldr	r3, [r7]
 801feec: f003 031f    	and	r3, r3, #0x1f
 801fef0: 613a         	str	r2, [r7, #0x10]
 801fef2: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801fef4: 693b         	ldr	r3, [r7, #0x10]
 801fef6: 681b         	ldr	r3, [r3]
 801fef8: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp | (1 << bit);
 801fefa: 2201         	movs	r2, #0x1
 801fefc: 68fb         	ldr	r3, [r7, #0xc]
 801fefe: fa02 f303    	lsl.w	r3, r2, r3
 801ff02: 4619         	mov	r1, r3
 801ff04: 693b         	ldr	r3, [r7, #0x10]
 801ff06: 68ba         	ldr	r2, [r7, #0x8]
 801ff08: 430a         	orrs	r2, r1
 801ff0a: 601a         	str	r2, [r3]
; }
 801ff0c: bf00         	nop
; 	return 0;
 801ff0e: 2300         	movs	r3, #0x0
; }
 801ff10: 4618         	mov	r0, r3
 801ff12: 371c         	adds	r7, #0x1c
 801ff14: 46bd         	mov	sp, r7
 801ff16: f85d 7b04    	ldr	r7, [sp], #4
 801ff1a: 4770         	bx	lr

0801ff1c <reset_stm32_line_deassert>:
; {
 801ff1c: b480         	push	{r7}
 801ff1e: b087         	sub	sp, #0x1c
 801ff20: af00         	add	r7, sp, #0x0
 801ff22: 6078         	str	r0, [r7, #0x4]
 801ff24: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 801ff26: 687b         	ldr	r3, [r7, #0x4]
 801ff28: 685b         	ldr	r3, [r3, #0x4]
 801ff2a: 617b         	str	r3, [r7, #0x14]
; 	sys_clear_bit(config->base + STM32_RESET_SET_OFFSET(id),
 801ff2c: 697b         	ldr	r3, [r7, #0x14]
 801ff2e: 681a         	ldr	r2, [r3]
 801ff30: 683b         	ldr	r3, [r7]
 801ff32: 095b         	lsrs	r3, r3, #0x5
 801ff34: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 801ff38: 441a         	add	r2, r3
 801ff3a: 683b         	ldr	r3, [r7]
 801ff3c: f003 031f    	and	r3, r3, #0x1f
 801ff40: 613a         	str	r2, [r7, #0x10]
 801ff42: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801ff44: 693b         	ldr	r3, [r7, #0x10]
 801ff46: 681b         	ldr	r3, [r3]
 801ff48: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~(1 << bit);
 801ff4a: 2201         	movs	r2, #0x1
 801ff4c: 68fb         	ldr	r3, [r7, #0xc]
 801ff4e: fa02 f303    	lsl.w	r3, r2, r3
 801ff52: 43db         	mvns	r3, r3
 801ff54: 4619         	mov	r1, r3
 801ff56: 693b         	ldr	r3, [r7, #0x10]
 801ff58: 68ba         	ldr	r2, [r7, #0x8]
 801ff5a: 400a         	ands	r2, r1
 801ff5c: 601a         	str	r2, [r3]
; }
 801ff5e: bf00         	nop
; 	return 0;
 801ff60: 2300         	movs	r3, #0x0
; }
 801ff62: 4618         	mov	r0, r3
 801ff64: 371c         	adds	r7, #0x1c
 801ff66: 46bd         	mov	sp, r7
 801ff68: f85d 7b04    	ldr	r7, [sp], #4
 801ff6c: 4770         	bx	lr

0801ff6e <reset_stm32_line_toggle>:
; {
 801ff6e: b580         	push	{r7, lr}
 801ff70: b082         	sub	sp, #0x8
 801ff72: af00         	add	r7, sp, #0x0
 801ff74: 6078         	str	r0, [r7, #0x4]
 801ff76: 6039         	str	r1, [r7]
; 	reset_stm32_line_assert(dev, id);
 801ff78: 6839         	ldr	r1, [r7]
 801ff7a: 6878         	ldr	r0, [r7, #0x4]
 801ff7c: f7ff ffa6    	bl	0x801fecc <reset_stm32_line_assert> @ imm = #-0xb4
; 	reset_stm32_line_deassert(dev, id);
 801ff80: 6839         	ldr	r1, [r7]
 801ff82: 6878         	ldr	r0, [r7, #0x4]
 801ff84: f7ff ffca    	bl	0x801ff1c <reset_stm32_line_deassert> @ imm = #-0x6c
; 	return 0;
 801ff88: 2300         	movs	r3, #0x0
; }
 801ff8a: 4618         	mov	r0, r3
 801ff8c: 3708         	adds	r7, #0x8
 801ff8e: 46bd         	mov	sp, r7
 801ff90: bd80         	pop	{r7, pc}

0801ff92 <device_is_ready>:
; {
 801ff92: b580         	push	{r7, lr}
 801ff94: b082         	sub	sp, #0x8
 801ff96: af00         	add	r7, sp, #0x0
 801ff98: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801ff9a: 6878         	ldr	r0, [r7, #0x4]
 801ff9c: f004 fac1    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x4582
 801ffa0: 4603         	mov	r3, r0
; }
 801ffa2: 4618         	mov	r0, r3
 801ffa4: 3708         	adds	r7, #0x8
 801ffa6: 46bd         	mov	sp, r7
 801ffa8: bd80         	pop	{r7, pc}

0801ffaa <k_msleep>:
; {
 801ffaa: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801ffae: b082         	sub	sp, #0x8
 801ffb0: af00         	add	r7, sp, #0x0
 801ffb2: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 801ffb4: 6879         	ldr	r1, [r7, #0x4]
 801ffb6: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 801ffba: 17c8         	asrs	r0, r1, #0x1f
 801ffbc: 4688         	mov	r8, r1
 801ffbe: 4681         	mov	r9, r0
 801ffc0: 4640         	mov	r0, r8
 801ffc2: 4649         	mov	r1, r9
 801ffc4: f04f 0400    	mov.w	r4, #0x0
 801ffc8: f04f 0500    	mov.w	r5, #0x0
 801ffcc: 008d         	lsls	r5, r1, #0x2
 801ffce: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 801ffd2: 0084         	lsls	r4, r0, #0x2
 801ffd4: 4620         	mov	r0, r4
 801ffd6: 4629         	mov	r1, r5
 801ffd8: eb10 0208    	adds.w	r2, r0, r8
 801ffdc: eb41 0309    	adc.w	r3, r1, r9
 801ffe0: eb12 0a02    	adds.w	r10, r2, r2
 801ffe4: eb43 0b03    	adc.w	r11, r3, r3
 801ffe8: 4652         	mov	r2, r10
 801ffea: 465b         	mov	r3, r11
 801ffec: 4610         	mov	r0, r2
 801ffee: 4619         	mov	r1, r3
 801fff0: f000 f807    	bl	0x8020002 <k_sleep>     @ imm = #0xe
 801fff4: 4601         	mov	r1, r0
 801fff6: 460b         	mov	r3, r1
; }
 801fff8: 4618         	mov	r0, r3
 801fffa: 3708         	adds	r7, #0x8
 801fffc: 46bd         	mov	sp, r7
 801fffe: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08020002 <k_sleep>:
; {
 8020002: b580         	push	{r7, lr}
 8020004: b082         	sub	sp, #0x8
 8020006: af00         	add	r7, sp, #0x0
 8020008: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 802000c: e9d7 0100    	ldrd	r0, r1, [r7]
 8020010: f7f6 f96e    	bl	0x80162f0 <z_impl_k_sleep> @ imm = #-0x9d24
 8020014: 4603         	mov	r3, r0
; }
 8020016: 4618         	mov	r0, r3
 8020018: 3708         	adds	r7, #0x8
 802001a: 46bd         	mov	sp, r7
 802001c: bd80         	pop	{r7, pc}

0802001e <k_usleep>:
; {
 802001e: b580         	push	{r7, lr}
 8020020: b082         	sub	sp, #0x8
 8020022: af00         	add	r7, sp, #0x0
 8020024: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_usleep(us);
 8020026: 6878         	ldr	r0, [r7, #0x4]
 8020028: f006 fe23    	bl	0x8026c72 <z_impl_k_usleep> @ imm = #0x6c46
 802002c: 4603         	mov	r3, r0
; }
 802002e: 4618         	mov	r0, r3
 8020030: 3708         	adds	r7, #0x8
 8020032: 46bd         	mov	sp, r7
 8020034: bd80         	pop	{r7, pc}

08020036 <pm_device_busy_set>:
; {
 8020036: b480         	push	{r7}
 8020038: b083         	sub	sp, #0xc
 802003a: af00         	add	r7, sp, #0x0
 802003c: 6078         	str	r0, [r7, #0x4]
; }
 802003e: bf00         	nop
 8020040: 370c         	adds	r7, #0xc
 8020042: 46bd         	mov	sp, r7
 8020044: f85d 7b04    	ldr	r7, [sp], #4
 8020048: 4770         	bx	lr

0802004a <pm_device_busy_clear>:
; {
 802004a: b480         	push	{r7}
 802004c: b083         	sub	sp, #0xc
 802004e: af00         	add	r7, sp, #0x0
 8020050: 6078         	str	r0, [r7, #0x4]
; }
 8020052: bf00         	nop
 8020054: 370c         	adds	r7, #0xc
 8020056: 46bd         	mov	sp, r7
 8020058: f85d 7b04    	ldr	r7, [sp], #4
 802005c: 4770         	bx	lr

0802005e <z_log_msg_runtime_create>:
; {
 802005e: b580         	push	{r7, lr}
 8020060: b08a         	sub	sp, #0x28
 8020062: af04         	add	r7, sp, #0x10
 8020064: 60b9         	str	r1, [r7, #0x8]
 8020066: 607b         	str	r3, [r7, #0x4]
 8020068: 4603         	mov	r3, r0
 802006a: 73fb         	strb	r3, [r7, #0xf]
 802006c: 4613         	mov	r3, r2
 802006e: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8020070: f107 032c    	add.w	r3, r7, #0x2c
 8020074: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8020076: 7bba         	ldrb	r2, [r7, #0xe]
 8020078: 7bf8         	ldrb	r0, [r7, #0xf]
 802007a: 697b         	ldr	r3, [r7, #0x14]
 802007c: 9303         	str	r3, [sp, #0xc]
 802007e: 6abb         	ldr	r3, [r7, #0x28]
 8020080: 9302         	str	r3, [sp, #0x8]
 8020082: 6a7b         	ldr	r3, [r7, #0x24]
 8020084: 9301         	str	r3, [sp, #0x4]
 8020086: 6a3b         	ldr	r3, [r7, #0x20]
 8020088: 9300         	str	r3, [sp]
 802008a: 687b         	ldr	r3, [r7, #0x4]
 802008c: 68b9         	ldr	r1, [r7, #0x8]
 802008e: f7e4 fd59    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x1b54e
; }
 8020092: bf00         	nop
 8020094: 3718         	adds	r7, #0x18
 8020096: 46bd         	mov	sp, r7
 8020098: bd80         	pop	{r7, pc}

0802009a <gpio_is_ready_dt>:
; {
 802009a: b580         	push	{r7, lr}
 802009c: b082         	sub	sp, #0x8
 802009e: af00         	add	r7, sp, #0x0
 80200a0: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 80200a2: 687b         	ldr	r3, [r7, #0x4]
 80200a4: 681b         	ldr	r3, [r3]
 80200a6: 4618         	mov	r0, r3
 80200a8: f7ff ff73    	bl	0x801ff92 <device_is_ready> @ imm = #-0x11a
 80200ac: 4603         	mov	r3, r0
; }
 80200ae: 4618         	mov	r0, r3
 80200b0: 3708         	adds	r7, #0x8
 80200b2: 46bd         	mov	sp, r7
 80200b4: bd80         	pop	{r7, pc}

080200b6 <spi_cs_is_gpio>:
; {
 80200b6: b480         	push	{r7}
 80200b8: b083         	sub	sp, #0xc
 80200ba: af00         	add	r7, sp, #0x0
 80200bc: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 80200be: 687b         	ldr	r3, [r7, #0x4]
 80200c0: 689b         	ldr	r3, [r3, #0x8]
 80200c2: 2b00         	cmp	r3, #0x0
 80200c4: bf14         	ite	ne
 80200c6: 2301         	movne	r3, #0x1
 80200c8: 2300         	moveq	r3, #0x0
 80200ca: b2db         	uxtb	r3, r3
; }
 80200cc: 4618         	mov	r0, r3
 80200ce: 370c         	adds	r7, #0xc
 80200d0: 46bd         	mov	sp, r7
 80200d2: f85d 7b04    	ldr	r7, [sp], #4
 80200d6: 4770         	bx	lr

080200d8 <spi_cs_is_gpio_dt>:
; {
 80200d8: b580         	push	{r7, lr}
 80200da: b082         	sub	sp, #0x8
 80200dc: af00         	add	r7, sp, #0x0
 80200de: 6078         	str	r0, [r7, #0x4]
; 	return spi_cs_is_gpio(&spec->config);
 80200e0: 687b         	ldr	r3, [r7, #0x4]
 80200e2: 3304         	adds	r3, #0x4
 80200e4: 4618         	mov	r0, r3
 80200e6: f7ff ffe6    	bl	0x80200b6 <spi_cs_is_gpio> @ imm = #-0x34
 80200ea: 4603         	mov	r3, r0
; }
 80200ec: 4618         	mov	r0, r3
 80200ee: 3708         	adds	r7, #0x8
 80200f0: 46bd         	mov	sp, r7
 80200f2: bd80         	pop	{r7, pc}

080200f4 <spi_is_ready_dt>:
; {
 80200f4: b580         	push	{r7, lr}
 80200f6: b082         	sub	sp, #0x8
 80200f8: af00         	add	r7, sp, #0x0
 80200fa: 6078         	str	r0, [r7, #0x4]
; 	if (!device_is_ready(spec->bus)) {
 80200fc: 687b         	ldr	r3, [r7, #0x4]
 80200fe: 681b         	ldr	r3, [r3]
 8020100: 4618         	mov	r0, r3
 8020102: f7ff ff46    	bl	0x801ff92 <device_is_ready> @ imm = #-0x174
 8020106: 4603         	mov	r3, r0
 8020108: f083 0301    	eor	r3, r3, #0x1
 802010c: b2db         	uxtb	r3, r3
 802010e: 2b00         	cmp	r3, #0x0
 8020110: d001         	beq	0x8020116 <spi_is_ready_dt+0x22> @ imm = #0x2
; 		return false;
 8020112: 2300         	movs	r3, #0x0
 8020114: e013         	b	0x802013e <spi_is_ready_dt+0x4a> @ imm = #0x26
; 	if (spi_cs_is_gpio_dt(spec) &&
 8020116: 6878         	ldr	r0, [r7, #0x4]
 8020118: f7ff ffde    	bl	0x80200d8 <spi_cs_is_gpio_dt> @ imm = #-0x44
 802011c: 4603         	mov	r3, r0
 802011e: 2b00         	cmp	r3, #0x0
 8020120: d00c         	beq	0x802013c <spi_is_ready_dt+0x48> @ imm = #0x18
; 	    !gpio_is_ready_dt(&spec->config.cs.gpio)) {
 8020122: 687b         	ldr	r3, [r7, #0x4]
 8020124: 330c         	adds	r3, #0xc
 8020126: 4618         	mov	r0, r3
 8020128: f7ff ffb7    	bl	0x802009a <gpio_is_ready_dt> @ imm = #-0x92
 802012c: 4603         	mov	r3, r0
 802012e: f083 0301    	eor	r3, r3, #0x1
 8020132: b2db         	uxtb	r3, r3
; 	if (spi_cs_is_gpio_dt(spec) &&
 8020134: 2b00         	cmp	r3, #0x0
 8020136: d001         	beq	0x802013c <spi_is_ready_dt+0x48> @ imm = #0x2
; 		return false;
 8020138: 2300         	movs	r3, #0x0
 802013a: e000         	b	0x802013e <spi_is_ready_dt+0x4a> @ imm = #0x0
; 	return true;
 802013c: 2301         	movs	r3, #0x1
; }
 802013e: 4618         	mov	r0, r3
 8020140: 3708         	adds	r7, #0x8
 8020142: 46bd         	mov	sp, r7
 8020144: bd80         	pop	{r7, pc}

08020146 <z_impl_spi_transceive>:
; {
 8020146: b590         	push	{r4, r7, lr}
 8020148: b087         	sub	sp, #0x1c
 802014a: af00         	add	r7, sp, #0x0
 802014c: 60f8         	str	r0, [r7, #0xc]
 802014e: 60b9         	str	r1, [r7, #0x8]
 8020150: 607a         	str	r2, [r7, #0x4]
 8020152: 603b         	str	r3, [r7]
; 	const struct spi_driver_api *api =
 8020154: 68fb         	ldr	r3, [r7, #0xc]
 8020156: 689b         	ldr	r3, [r3, #0x8]
 8020158: 617b         	str	r3, [r7, #0x14]
; 	ret = api->transceive(dev, config, tx_bufs, rx_bufs);
 802015a: 697b         	ldr	r3, [r7, #0x14]
 802015c: 681c         	ldr	r4, [r3]
 802015e: 683b         	ldr	r3, [r7]
 8020160: 687a         	ldr	r2, [r7, #0x4]
 8020162: 68b9         	ldr	r1, [r7, #0x8]
 8020164: 68f8         	ldr	r0, [r7, #0xc]
 8020166: 47a0         	blx	r4
 8020168: 6138         	str	r0, [r7, #0x10]
; 	return ret;
 802016a: 693b         	ldr	r3, [r7, #0x10]
; }
 802016c: 4618         	mov	r0, r3
 802016e: 371c         	adds	r7, #0x1c
 8020170: 46bd         	mov	sp, r7
 8020172: bd90         	pop	{r4, r7, pc}

08020174 <spi_transceive_dt>:
; {
 8020174: b580         	push	{r7, lr}
 8020176: b084         	sub	sp, #0x10
 8020178: af00         	add	r7, sp, #0x0
 802017a: 60f8         	str	r0, [r7, #0xc]
 802017c: 60b9         	str	r1, [r7, #0x8]
 802017e: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(spec->bus, &spec->config, tx_bufs, rx_bufs);
 8020180: 68fb         	ldr	r3, [r7, #0xc]
 8020182: 6818         	ldr	r0, [r3]
 8020184: 68fb         	ldr	r3, [r7, #0xc]
 8020186: 1d19         	adds	r1, r3, #0x4
 8020188: 687b         	ldr	r3, [r7, #0x4]
 802018a: 68ba         	ldr	r2, [r7, #0x8]
 802018c: f000 f828    	bl	0x80201e0 <spi_transceive> @ imm = #0x50
 8020190: 4603         	mov	r3, r0
; }
 8020192: 4618         	mov	r0, r3
 8020194: 3710         	adds	r7, #0x10
 8020196: 46bd         	mov	sp, r7
 8020198: bd80         	pop	{r7, pc}

0802019a <spi_write>:
; {
 802019a: b580         	push	{r7, lr}
 802019c: b084         	sub	sp, #0x10
 802019e: af00         	add	r7, sp, #0x0
 80201a0: 60f8         	str	r0, [r7, #0xc]
 80201a2: 60b9         	str	r1, [r7, #0x8]
 80201a4: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(dev, config, tx_bufs, NULL);
 80201a6: 2300         	movs	r3, #0x0
 80201a8: 687a         	ldr	r2, [r7, #0x4]
 80201aa: 68b9         	ldr	r1, [r7, #0x8]
 80201ac: 68f8         	ldr	r0, [r7, #0xc]
 80201ae: f000 f817    	bl	0x80201e0 <spi_transceive> @ imm = #0x2e
 80201b2: 4603         	mov	r3, r0
; }
 80201b4: 4618         	mov	r0, r3
 80201b6: 3710         	adds	r7, #0x10
 80201b8: 46bd         	mov	sp, r7
 80201ba: bd80         	pop	{r7, pc}

080201bc <spi_write_dt>:
; {
 80201bc: b580         	push	{r7, lr}
 80201be: b082         	sub	sp, #0x8
 80201c0: af00         	add	r7, sp, #0x0
 80201c2: 6078         	str	r0, [r7, #0x4]
 80201c4: 6039         	str	r1, [r7]
; 	return spi_write(spec->bus, &spec->config, tx_bufs);
 80201c6: 687b         	ldr	r3, [r7, #0x4]
 80201c8: 6818         	ldr	r0, [r3]
 80201ca: 687b         	ldr	r3, [r7, #0x4]
 80201cc: 3304         	adds	r3, #0x4
 80201ce: 683a         	ldr	r2, [r7]
 80201d0: 4619         	mov	r1, r3
 80201d2: f7ff ffe2    	bl	0x802019a <spi_write>   @ imm = #-0x3c
 80201d6: 4603         	mov	r3, r0
; }
 80201d8: 4618         	mov	r0, r3
 80201da: 3708         	adds	r7, #0x8
 80201dc: 46bd         	mov	sp, r7
 80201de: bd80         	pop	{r7, pc}

080201e0 <spi_transceive>:
; {
 80201e0: b580         	push	{r7, lr}
 80201e2: b084         	sub	sp, #0x10
 80201e4: af00         	add	r7, sp, #0x0
 80201e6: 60f8         	str	r0, [r7, #0xc]
 80201e8: 60b9         	str	r1, [r7, #0x8]
 80201ea: 607a         	str	r2, [r7, #0x4]
 80201ec: 603b         	str	r3, [r7]
; 	return z_impl_spi_transceive(dev, config, tx_bufs, rx_bufs);
 80201ee: 683b         	ldr	r3, [r7]
 80201f0: 687a         	ldr	r2, [r7, #0x4]
 80201f2: 68b9         	ldr	r1, [r7, #0x8]
 80201f4: 68f8         	ldr	r0, [r7, #0xc]
 80201f6: f7ff ffa6    	bl	0x8020146 <z_impl_spi_transceive> @ imm = #-0xb4
 80201fa: 4603         	mov	r3, r0
; }
 80201fc: 4618         	mov	r0, r3
 80201fe: 3710         	adds	r7, #0x10
 8020200: 46bd         	mov	sp, r7
 8020202: bd80         	pop	{r7, pc}

08020204 <bmi08x_accel_transceive_spi>:
; {
 8020204: b580         	push	{r7, lr}
 8020206: b092         	sub	sp, #0x48
 8020208: af00         	add	r7, sp, #0x0
 802020a: 60f8         	str	r0, [r7, #0xc]
 802020c: 607b         	str	r3, [r7, #0x4]
 802020e: 460b         	mov	r3, r1
 8020210: 72fb         	strb	r3, [r7, #0xb]
 8020212: 4613         	mov	r3, r2
 8020214: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_accel_config *bmi08x = dev->config;
 8020216: 68fb         	ldr	r3, [r7, #0xc]
 8020218: 685b         	ldr	r3, [r3, #0x4]
 802021a: 647b         	str	r3, [r7, #0x44]
; 	const struct spi_buf tx_buf[2] = {{.buf = &reg, .len = 1}, {.buf = data, .len = length}};
 802021c: f107 030b    	add.w	r3, r7, #0xb
 8020220: 637b         	str	r3, [r7, #0x34]
 8020222: 2301         	movs	r3, #0x1
 8020224: 63bb         	str	r3, [r7, #0x38]
 8020226: 687b         	ldr	r3, [r7, #0x4]
 8020228: 63fb         	str	r3, [r7, #0x3c]
 802022a: 6d3b         	ldr	r3, [r7, #0x50]
 802022c: 643b         	str	r3, [r7, #0x40]
; 	const struct spi_buf_set tx = {.buffers = tx_buf, .count = write ? 2 : 1};
 802022e: f107 0334    	add.w	r3, r7, #0x34
 8020232: 62fb         	str	r3, [r7, #0x2c]
 8020234: 7abb         	ldrb	r3, [r7, #0xa]
 8020236: 2b00         	cmp	r3, #0x0
 8020238: d001         	beq	0x802023e <bmi08x_accel_transceive_spi+0x3a> @ imm = #0x2
 802023a: 2302         	movs	r3, #0x2
 802023c: e000         	b	0x8020240 <bmi08x_accel_transceive_spi+0x3c> @ imm = #0x0
 802023e: 2301         	movs	r3, #0x1
 8020240: 633b         	str	r3, [r7, #0x30]
; 	if (!write) {
 8020242: 7abb         	ldrb	r3, [r7, #0xa]
 8020244: f083 0301    	eor	r3, r3, #0x1
 8020248: b2db         	uxtb	r3, r3
 802024a: 2b00         	cmp	r3, #0x0
 802024c: d017         	beq	0x802027e <bmi08x_accel_transceive_spi+0x7a> @ imm = #0x2e
; 		const struct spi_buf rx_buf[2] = {{.buf = &dummy, .len = 2},
 802024e: f107 032a    	add.w	r3, r7, #0x2a
 8020252: 61bb         	str	r3, [r7, #0x18]
 8020254: 2302         	movs	r3, #0x2
 8020256: 61fb         	str	r3, [r7, #0x1c]
 8020258: 687b         	ldr	r3, [r7, #0x4]
 802025a: 623b         	str	r3, [r7, #0x20]
 802025c: 6d3b         	ldr	r3, [r7, #0x50]
 802025e: 627b         	str	r3, [r7, #0x24]
; 		const struct spi_buf_set rx = {.buffers = rx_buf, .count = 2};
 8020260: f107 0318    	add.w	r3, r7, #0x18
 8020264: 613b         	str	r3, [r7, #0x10]
 8020266: 2302         	movs	r3, #0x2
 8020268: 617b         	str	r3, [r7, #0x14]
; 		return spi_transceive_dt(&bmi08x->bus.spi, &tx, &rx);
 802026a: 6c7b         	ldr	r3, [r7, #0x44]
 802026c: f107 0210    	add.w	r2, r7, #0x10
 8020270: f107 012c    	add.w	r1, r7, #0x2c
 8020274: 4618         	mov	r0, r3
 8020276: f7ff ff7d    	bl	0x8020174 <spi_transceive_dt> @ imm = #-0x106
 802027a: 4603         	mov	r3, r0
 802027c: e007         	b	0x802028e <bmi08x_accel_transceive_spi+0x8a> @ imm = #0xe
; 	return spi_write_dt(&bmi08x->bus.spi, &tx);
 802027e: 6c7b         	ldr	r3, [r7, #0x44]
 8020280: f107 022c    	add.w	r2, r7, #0x2c
 8020284: 4611         	mov	r1, r2
 8020286: 4618         	mov	r0, r3
 8020288: f7ff ff98    	bl	0x80201bc <spi_write_dt> @ imm = #-0xd0
 802028c: 4603         	mov	r3, r0
; }
 802028e: 4618         	mov	r0, r3
 8020290: 3748         	adds	r7, #0x48
 8020292: 46bd         	mov	sp, r7
 8020294: bd80         	pop	{r7, pc}

08020296 <bmi08x_bus_check_spi>:
; {
 8020296: b580         	push	{r7, lr}
 8020298: b082         	sub	sp, #0x8
 802029a: af00         	add	r7, sp, #0x0
 802029c: 6078         	str	r0, [r7, #0x4]
; 	return spi_is_ready_dt(&bus->spi) ? 0 : -ENODEV;
 802029e: 687b         	ldr	r3, [r7, #0x4]
 80202a0: 4618         	mov	r0, r3
 80202a2: f7ff ff27    	bl	0x80200f4 <spi_is_ready_dt> @ imm = #-0x1b2
 80202a6: 4603         	mov	r3, r0
 80202a8: 2b00         	cmp	r3, #0x0
 80202aa: d001         	beq	0x80202b0 <bmi08x_bus_check_spi+0x1a> @ imm = #0x2
 80202ac: 2300         	movs	r3, #0x0
 80202ae: e001         	b	0x80202b4 <bmi08x_bus_check_spi+0x1e> @ imm = #0x2
 80202b0: f06f 0312    	mvn	r3, #0x12
; }
 80202b4: 4618         	mov	r0, r3
 80202b6: 3708         	adds	r7, #0x8
 80202b8: 46bd         	mov	sp, r7
 80202ba: bd80         	pop	{r7, pc}

080202bc <bmi08x_bus_check>:
; {
 80202bc: b580         	push	{r7, lr}
 80202be: b084         	sub	sp, #0x10
 80202c0: af00         	add	r7, sp, #0x0
 80202c2: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 80202c4: 687b         	ldr	r3, [r7, #0x4]
 80202c6: 685b         	ldr	r3, [r3, #0x4]
 80202c8: 60fb         	str	r3, [r7, #0xc]
; 	return config->api->check(&config->bus);
 80202ca: 68fb         	ldr	r3, [r7, #0xc]
 80202cc: 699b         	ldr	r3, [r3, #0x18]
 80202ce: 681b         	ldr	r3, [r3]
 80202d0: 68fa         	ldr	r2, [r7, #0xc]
 80202d2: 4610         	mov	r0, r2
 80202d4: 4798         	blx	r3
 80202d6: 4603         	mov	r3, r0
; }
 80202d8: 4618         	mov	r0, r3
 80202da: 3710         	adds	r7, #0x10
 80202dc: 46bd         	mov	sp, r7
 80202de: bd80         	pop	{r7, pc}

080202e0 <bmi08x_bus_init>:
; {
 80202e0: b580         	push	{r7, lr}
 80202e2: b084         	sub	sp, #0x10
 80202e4: af00         	add	r7, sp, #0x0
 80202e6: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 80202e8: 687b         	ldr	r3, [r7, #0x4]
 80202ea: 685b         	ldr	r3, [r3, #0x4]
 80202ec: 60fb         	str	r3, [r7, #0xc]
; 	if (config->api->bus_init) {
 80202ee: 68fb         	ldr	r3, [r7, #0xc]
 80202f0: 699b         	ldr	r3, [r3, #0x18]
 80202f2: 685b         	ldr	r3, [r3, #0x4]
 80202f4: 2b00         	cmp	r3, #0x0
 80202f6: d006         	beq	0x8020306 <bmi08x_bus_init+0x26> @ imm = #0xc
; 		return config->api->bus_init(dev);
 80202f8: 68fb         	ldr	r3, [r7, #0xc]
 80202fa: 699b         	ldr	r3, [r3, #0x18]
 80202fc: 685b         	ldr	r3, [r3, #0x4]
 80202fe: 6878         	ldr	r0, [r7, #0x4]
 8020300: 4798         	blx	r3
 8020302: 4603         	mov	r3, r0
 8020304: e000         	b	0x8020308 <bmi08x_bus_init+0x28> @ imm = #0x0
; 	return 0;
 8020306: 2300         	movs	r3, #0x0
; }
 8020308: 4618         	mov	r0, r3
 802030a: 3710         	adds	r7, #0x10
 802030c: 46bd         	mov	sp, r7
 802030e: bd80         	pop	{r7, pc}

08020310 <bmi08x_accel_transceive>:
; {
 8020310: b590         	push	{r4, r7, lr}
 8020312: b089         	sub	sp, #0x24
 8020314: af02         	add	r7, sp, #0x8
 8020316: 60f8         	str	r0, [r7, #0xc]
 8020318: 607b         	str	r3, [r7, #0x4]
 802031a: 460b         	mov	r3, r1
 802031c: 72fb         	strb	r3, [r7, #0xb]
 802031e: 4613         	mov	r3, r2
 8020320: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_accel_config *config = dev->config;
 8020322: 68fb         	ldr	r3, [r7, #0xc]
 8020324: 685b         	ldr	r3, [r3, #0x4]
 8020326: 617b         	str	r3, [r7, #0x14]
; 	return config->api->transceive(dev, reg, write, data, length);
 8020328: 697b         	ldr	r3, [r7, #0x14]
 802032a: 699b         	ldr	r3, [r3, #0x18]
 802032c: 689c         	ldr	r4, [r3, #0x8]
 802032e: 7aba         	ldrb	r2, [r7, #0xa]
 8020330: 7af9         	ldrb	r1, [r7, #0xb]
 8020332: 6abb         	ldr	r3, [r7, #0x28]
 8020334: 9300         	str	r3, [sp]
 8020336: 687b         	ldr	r3, [r7, #0x4]
 8020338: 68f8         	ldr	r0, [r7, #0xc]
 802033a: 47a0         	blx	r4
 802033c: 4603         	mov	r3, r0
; }
 802033e: 4618         	mov	r0, r3
 8020340: 371c         	adds	r7, #0x1c
 8020342: 46bd         	mov	sp, r7
 8020344: bd90         	pop	{r4, r7, pc}

08020346 <bmi08x_accel_read>:
; {
 8020346: b580         	push	{r7, lr}
 8020348: b086         	sub	sp, #0x18
 802034a: af02         	add	r7, sp, #0x8
 802034c: 60f8         	str	r0, [r7, #0xc]
 802034e: 607a         	str	r2, [r7, #0x4]
 8020350: 461a         	mov	r2, r3
 8020352: 460b         	mov	r3, r1
 8020354: 72fb         	strb	r3, [r7, #0xb]
 8020356: 4613         	mov	r3, r2
 8020358: 72bb         	strb	r3, [r7, #0xa]
; 	return bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, data, len);
 802035a: 7afb         	ldrb	r3, [r7, #0xb]
 802035c: f063 037f    	orn	r3, r3, #0x7f
 8020360: b2d9         	uxtb	r1, r3
 8020362: 7abb         	ldrb	r3, [r7, #0xa]
 8020364: 9300         	str	r3, [sp]
 8020366: 687b         	ldr	r3, [r7, #0x4]
 8020368: 2200         	movs	r2, #0x0
 802036a: 68f8         	ldr	r0, [r7, #0xc]
 802036c: f7ff ffd0    	bl	0x8020310 <bmi08x_accel_transceive> @ imm = #-0x60
 8020370: 4603         	mov	r3, r0
; }
 8020372: 4618         	mov	r0, r3
 8020374: 3710         	adds	r7, #0x10
 8020376: 46bd         	mov	sp, r7
 8020378: bd80         	pop	{r7, pc}

0802037a <bmi08x_accel_byte_read>:
; {
 802037a: b580         	push	{r7, lr}
 802037c: b086         	sub	sp, #0x18
 802037e: af02         	add	r7, sp, #0x8
 8020380: 60f8         	str	r0, [r7, #0xc]
 8020382: 460b         	mov	r3, r1
 8020384: 607a         	str	r2, [r7, #0x4]
 8020386: 72fb         	strb	r3, [r7, #0xb]
; 	return bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, byte, 1);
 8020388: 7afb         	ldrb	r3, [r7, #0xb]
 802038a: f063 037f    	orn	r3, r3, #0x7f
 802038e: b2d9         	uxtb	r1, r3
 8020390: 2301         	movs	r3, #0x1
 8020392: 9300         	str	r3, [sp]
 8020394: 687b         	ldr	r3, [r7, #0x4]
 8020396: 2200         	movs	r2, #0x0
 8020398: 68f8         	ldr	r0, [r7, #0xc]
 802039a: f7ff ffb9    	bl	0x8020310 <bmi08x_accel_transceive> @ imm = #-0x8e
 802039e: 4603         	mov	r3, r0
; }
 80203a0: 4618         	mov	r0, r3
 80203a2: 3710         	adds	r7, #0x10
 80203a4: 46bd         	mov	sp, r7
 80203a6: bd80         	pop	{r7, pc}

080203a8 <bmi08x_accel_word_read>:
; {
 80203a8: b580         	push	{r7, lr}
 80203aa: b088         	sub	sp, #0x20
 80203ac: af02         	add	r7, sp, #0x8
 80203ae: 60f8         	str	r0, [r7, #0xc]
 80203b0: 460b         	mov	r3, r1
 80203b2: 607a         	str	r2, [r7, #0x4]
 80203b4: 72fb         	strb	r3, [r7, #0xb]
; 	ret = bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, word, 2);
 80203b6: 7afb         	ldrb	r3, [r7, #0xb]
 80203b8: f063 037f    	orn	r3, r3, #0x7f
 80203bc: b2d9         	uxtb	r1, r3
 80203be: 2302         	movs	r3, #0x2
 80203c0: 9300         	str	r3, [sp]
 80203c2: 687b         	ldr	r3, [r7, #0x4]
 80203c4: 2200         	movs	r2, #0x0
 80203c6: 68f8         	ldr	r0, [r7, #0xc]
 80203c8: f7ff ffa2    	bl	0x8020310 <bmi08x_accel_transceive> @ imm = #-0xbc
 80203cc: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 80203ce: 697b         	ldr	r3, [r7, #0x14]
 80203d0: 2b00         	cmp	r3, #0x0
 80203d2: d001         	beq	0x80203d8 <bmi08x_accel_word_read+0x30> @ imm = #0x2
; 		return ret;
 80203d4: 697b         	ldr	r3, [r7, #0x14]
 80203d6: e004         	b	0x80203e2 <bmi08x_accel_word_read+0x3a> @ imm = #0x8
; 	*word = sys_le16_to_cpu(*word);
 80203d8: 687b         	ldr	r3, [r7, #0x4]
 80203da: 881a         	ldrh	r2, [r3]
 80203dc: 687b         	ldr	r3, [r7, #0x4]
 80203de: 801a         	strh	r2, [r3]
; 	return ret;
 80203e0: 697b         	ldr	r3, [r7, #0x14]
; }
 80203e2: 4618         	mov	r0, r3
 80203e4: 3718         	adds	r7, #0x18
 80203e6: 46bd         	mov	sp, r7
 80203e8: bd80         	pop	{r7, pc}

080203ea <bmi08x_accel_byte_write>:
; {
 80203ea: b580         	push	{r7, lr}
 80203ec: b084         	sub	sp, #0x10
 80203ee: af02         	add	r7, sp, #0x8
 80203f0: 6078         	str	r0, [r7, #0x4]
 80203f2: 460b         	mov	r3, r1
 80203f4: 70fb         	strb	r3, [r7, #0x3]
 80203f6: 4613         	mov	r3, r2
 80203f8: 70bb         	strb	r3, [r7, #0x2]
; 	return bmi08x_accel_transceive(dev, reg_addr & 0x7F, true, &byte, 1);
 80203fa: 78fb         	ldrb	r3, [r7, #0x3]
 80203fc: f003 037f    	and	r3, r3, #0x7f
 8020400: b2d9         	uxtb	r1, r3
 8020402: 1cbb         	adds	r3, r7, #0x2
 8020404: 2201         	movs	r2, #0x1
 8020406: 9200         	str	r2, [sp]
 8020408: 2201         	movs	r2, #0x1
 802040a: 6878         	ldr	r0, [r7, #0x4]
 802040c: f7ff ff80    	bl	0x8020310 <bmi08x_accel_transceive> @ imm = #-0x100
 8020410: 4603         	mov	r3, r0
; }
 8020412: 4618         	mov	r0, r3
 8020414: 3708         	adds	r7, #0x8
 8020416: 46bd         	mov	sp, r7
 8020418: bd80         	pop	{r7, pc}

0802041a <bmi08x_accel_reg_field_update>:
; {
 802041a: b580         	push	{r7, lr}
 802041c: b084         	sub	sp, #0x10
 802041e: af00         	add	r7, sp, #0x0
 8020420: 6078         	str	r0, [r7, #0x4]
 8020422: 4608         	mov	r0, r1
 8020424: 4611         	mov	r1, r2
 8020426: 461a         	mov	r2, r3
 8020428: 4603         	mov	r3, r0
 802042a: 70fb         	strb	r3, [r7, #0x3]
 802042c: 460b         	mov	r3, r1
 802042e: 70bb         	strb	r3, [r7, #0x2]
 8020430: 4613         	mov	r3, r2
 8020432: 707b         	strb	r3, [r7, #0x1]
; 	ret = bmi08x_accel_byte_read(dev, reg_addr, &old_val);
 8020434: f107 020b    	add.w	r2, r7, #0xb
 8020438: 78fb         	ldrb	r3, [r7, #0x3]
 802043a: 4619         	mov	r1, r3
 802043c: 6878         	ldr	r0, [r7, #0x4]
 802043e: f7ff ff9c    	bl	0x802037a <bmi08x_accel_byte_read> @ imm = #-0xc8
 8020442: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8020444: 68fb         	ldr	r3, [r7, #0xc]
 8020446: 2b00         	cmp	r3, #0x0
 8020448: da01         	bge	0x802044e <bmi08x_accel_reg_field_update+0x34> @ imm = #0x2
; 		return ret;
 802044a: 68fb         	ldr	r3, [r7, #0xc]
 802044c: e019         	b	0x8020482 <bmi08x_accel_reg_field_update+0x68> @ imm = #0x32
; 	return bmi08x_accel_byte_write(dev, reg_addr, (old_val & ~mask) | ((val << pos) & mask));
 802044e: f997 3001    	ldrsb.w	r3, [r7, #0x1]
 8020452: 43db         	mvns	r3, r3
 8020454: b25a         	sxtb	r2, r3
 8020456: 7afb         	ldrb	r3, [r7, #0xb]
 8020458: b25b         	sxtb	r3, r3
 802045a: 4013         	ands	r3, r2
 802045c: b25a         	sxtb	r2, r3
 802045e: 7e39         	ldrb	r1, [r7, #0x18]
 8020460: 78bb         	ldrb	r3, [r7, #0x2]
 8020462: fa01 f303    	lsl.w	r3, r1, r3
 8020466: b259         	sxtb	r1, r3
 8020468: f997 3001    	ldrsb.w	r3, [r7, #0x1]
 802046c: 400b         	ands	r3, r1
 802046e: b25b         	sxtb	r3, r3
 8020470: 4313         	orrs	r3, r2
 8020472: b25b         	sxtb	r3, r3
 8020474: b2da         	uxtb	r2, r3
 8020476: 78fb         	ldrb	r3, [r7, #0x3]
 8020478: 4619         	mov	r1, r3
 802047a: 6878         	ldr	r0, [r7, #0x4]
 802047c: f7ff ffb5    	bl	0x80203ea <bmi08x_accel_byte_write> @ imm = #-0x96
 8020480: 4603         	mov	r3, r0
; }
 8020482: 4618         	mov	r0, r3
 8020484: 3710         	adds	r7, #0x10
 8020486: 46bd         	mov	sp, r7
 8020488: bd80         	pop	{r7, pc}

0802048a <bmi08x_acc_odr_set>:
; {
 802048a: b580         	push	{r7, lr}
 802048c: b086         	sub	sp, #0x18
 802048e: af02         	add	r7, sp, #0x8
 8020490: 6078         	str	r0, [r7, #0x4]
 8020492: 460b         	mov	r3, r1
 8020494: 807b         	strh	r3, [r7, #0x2]
 8020496: 4613         	mov	r3, r2
 8020498: 803b         	strh	r3, [r7]
; 	int odr = bmi08x_freq_to_odr_val(freq_int, freq_milli);
 802049a: 883a         	ldrh	r2, [r7]
 802049c: 887b         	ldrh	r3, [r7, #0x2]
 802049e: 4611         	mov	r1, r2
 80204a0: 4618         	mov	r0, r3
 80204a2: f7eb fe73    	bl	0x800c18c <bmi08x_freq_to_odr_val> @ imm = #-0x1431a
 80204a6: 60f8         	str	r0, [r7, #0xc]
; 	if (odr < BMI08X_ACCEL_ODR_12_5_HZ) {
 80204a8: 68fb         	ldr	r3, [r7, #0xc]
 80204aa: 2b04         	cmp	r3, #0x4
 80204ac: dc01         	bgt	0x80204b2 <bmi08x_acc_odr_set+0x28> @ imm = #0x2
; 		return odr;
 80204ae: 68fb         	ldr	r3, [r7, #0xc]
 80204b0: e009         	b	0x80204c6 <bmi08x_acc_odr_set+0x3c> @ imm = #0x12
; 	return bmi08x_accel_reg_field_update(dev, BMI08X_REG_ACCEL_CONF, 0, BMI08X_ACCEL_ODR_MASK,
 80204b2: 68fb         	ldr	r3, [r7, #0xc]
 80204b4: b2db         	uxtb	r3, r3
 80204b6: 9300         	str	r3, [sp]
 80204b8: 230f         	movs	r3, #0xf
 80204ba: 2200         	movs	r2, #0x0
 80204bc: 2140         	movs	r1, #0x40
 80204be: 6878         	ldr	r0, [r7, #0x4]
 80204c0: f7ff ffab    	bl	0x802041a <bmi08x_accel_reg_field_update> @ imm = #-0xaa
 80204c4: 4603         	mov	r3, r0
; }
 80204c6: 4618         	mov	r0, r3
 80204c8: 3710         	adds	r7, #0x10
 80204ca: 46bd         	mov	sp, r7
 80204cc: bd80         	pop	{r7, pc}

080204ce <bmi08x_channel_convert>:
; {
 80204ce: b580         	push	{r7, lr}
 80204d0: b086         	sub	sp, #0x18
 80204d2: af00         	add	r7, sp, #0x0
 80204d4: 60ba         	str	r2, [r7, #0x8]
 80204d6: 607b         	str	r3, [r7, #0x4]
 80204d8: 4603         	mov	r3, r0
 80204da: 81fb         	strh	r3, [r7, #0xe]
 80204dc: 460b         	mov	r3, r1
 80204de: 81bb         	strh	r3, [r7, #0xc]
; 	switch (chan) {
 80204e0: 89fb         	ldrh	r3, [r7, #0xe]
 80204e2: 2b02         	cmp	r3, #0x2
 80204e4: d010         	beq	0x8020508 <bmi08x_channel_convert+0x3a> @ imm = #0x20
 80204e6: 2b02         	cmp	r3, #0x2
 80204e8: dc13         	bgt	0x8020512 <bmi08x_channel_convert+0x44> @ imm = #0x26
 80204ea: 2b00         	cmp	r3, #0x0
 80204ec: d002         	beq	0x80204f4 <bmi08x_channel_convert+0x26> @ imm = #0x4
 80204ee: 2b01         	cmp	r3, #0x1
 80204f0: d005         	beq	0x80204fe <bmi08x_channel_convert+0x30> @ imm = #0xa
 80204f2: e00e         	b	0x8020512 <bmi08x_channel_convert+0x44> @ imm = #0x1c
; 		ofs_start = ofs_stop = 0U;
 80204f4: 2300         	movs	r3, #0x0
 80204f6: 74bb         	strb	r3, [r7, #0x12]
 80204f8: 7cbb         	ldrb	r3, [r7, #0x12]
 80204fa: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 80204fc: e00e         	b	0x802051c <bmi08x_channel_convert+0x4e> @ imm = #0x1c
; 		ofs_start = ofs_stop = 1U;
 80204fe: 2301         	movs	r3, #0x1
 8020500: 74bb         	strb	r3, [r7, #0x12]
 8020502: 7cbb         	ldrb	r3, [r7, #0x12]
 8020504: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 8020506: e009         	b	0x802051c <bmi08x_channel_convert+0x4e> @ imm = #0x12
; 		ofs_start = ofs_stop = 2U;
 8020508: 2302         	movs	r3, #0x2
 802050a: 74bb         	strb	r3, [r7, #0x12]
 802050c: 7cbb         	ldrb	r3, [r7, #0x12]
 802050e: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 8020510: e004         	b	0x802051c <bmi08x_channel_convert+0x4e> @ imm = #0x8
; 		ofs_start = 0U;
 8020512: 2300         	movs	r3, #0x0
 8020514: 74fb         	strb	r3, [r7, #0x13]
; 		ofs_stop = 2U;
 8020516: 2302         	movs	r3, #0x2
 8020518: 74bb         	strb	r3, [r7, #0x12]
; 		break;
 802051a: bf00         	nop
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 802051c: 7cfb         	ldrb	r3, [r7, #0x13]
 802051e: 617b         	str	r3, [r7, #0x14]
 8020520: e010         	b	0x8020544 <bmi08x_channel_convert+0x76> @ imm = #0x20
; 		bmi08x_to_fixed_point(raw_xyz[i], scale, val);
 8020522: 697b         	ldr	r3, [r7, #0x14]
 8020524: 005b         	lsls	r3, r3, #0x1
 8020526: 68ba         	ldr	r2, [r7, #0x8]
 8020528: 4413         	add	r3, r2
 802052a: 881b         	ldrh	r3, [r3]
 802052c: b21b         	sxth	r3, r3
 802052e: 89b9         	ldrh	r1, [r7, #0xc]
 8020530: 687a         	ldr	r2, [r7, #0x4]
 8020532: 4618         	mov	r0, r3
 8020534: f7ea ff86    	bl	0x800b444 <bmi08x_to_fixed_point> @ imm = #-0x150f4
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 8020538: 697b         	ldr	r3, [r7, #0x14]
 802053a: 3301         	adds	r3, #0x1
 802053c: 617b         	str	r3, [r7, #0x14]
 802053e: 687b         	ldr	r3, [r7, #0x4]
 8020540: 3308         	adds	r3, #0x8
 8020542: 607b         	str	r3, [r7, #0x4]
 8020544: 7cbb         	ldrb	r3, [r7, #0x12]
 8020546: 697a         	ldr	r2, [r7, #0x14]
 8020548: 429a         	cmp	r2, r3
 802054a: ddea         	ble	0x8020522 <bmi08x_channel_convert+0x54> @ imm = #-0x2c
; }
 802054c: bf00         	nop
 802054e: bf00         	nop
 8020550: 3718         	adds	r7, #0x18
 8020552: 46bd         	mov	sp, r7
 8020554: bd80         	pop	{r7, pc}

08020556 <bmi08x_acc_channel_get>:
; {
 8020556: b580         	push	{r7, lr}
 8020558: b086         	sub	sp, #0x18
 802055a: af00         	add	r7, sp, #0x0
 802055c: 60f8         	str	r0, [r7, #0xc]
 802055e: 460b         	mov	r3, r1
 8020560: 607a         	str	r2, [r7, #0x4]
 8020562: 817b         	strh	r3, [r7, #0xa]
; 	struct bmi08x_accel_data *data = dev->data;
 8020564: 68fb         	ldr	r3, [r7, #0xc]
 8020566: 691b         	ldr	r3, [r3, #0x10]
 8020568: 617b         	str	r3, [r7, #0x14]
; 	bmi08x_channel_convert(chan, data->scale, data->acc_sample, val);
 802056a: 697b         	ldr	r3, [r7, #0x14]
 802056c: 8a59         	ldrh	r1, [r3, #0x12]
 802056e: 697b         	ldr	r3, [r7, #0x14]
 8020570: f103 020c    	add.w	r2, r3, #0xc
 8020574: 8978         	ldrh	r0, [r7, #0xa]
 8020576: 687b         	ldr	r3, [r7, #0x4]
 8020578: f7ff ffa9    	bl	0x80204ce <bmi08x_channel_convert> @ imm = #-0xae
; }
 802057c: bf00         	nop
 802057e: 3718         	adds	r7, #0x18
 8020580: 46bd         	mov	sp, r7
 8020582: bd80         	pop	{r7, pc}

08020584 <device_is_ready>:
; {
 8020584: b580         	push	{r7, lr}
 8020586: b082         	sub	sp, #0x8
 8020588: af00         	add	r7, sp, #0x0
 802058a: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 802058c: 6878         	ldr	r0, [r7, #0x4]
 802058e: f003 ffc8    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x3f90
 8020592: 4603         	mov	r3, r0
; }
 8020594: 4618         	mov	r0, r3
 8020596: 3708         	adds	r7, #0x8
 8020598: 46bd         	mov	sp, r7
 802059a: bd80         	pop	{r7, pc}

0802059c <k_msleep>:
; {
 802059c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 80205a0: b082         	sub	sp, #0x8
 80205a2: af00         	add	r7, sp, #0x0
 80205a4: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 80205a6: 6879         	ldr	r1, [r7, #0x4]
 80205a8: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 80205ac: 17c8         	asrs	r0, r1, #0x1f
 80205ae: 4688         	mov	r8, r1
 80205b0: 4681         	mov	r9, r0
 80205b2: 4640         	mov	r0, r8
 80205b4: 4649         	mov	r1, r9
 80205b6: f04f 0400    	mov.w	r4, #0x0
 80205ba: f04f 0500    	mov.w	r5, #0x0
 80205be: 008d         	lsls	r5, r1, #0x2
 80205c0: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 80205c4: 0084         	lsls	r4, r0, #0x2
 80205c6: 4620         	mov	r0, r4
 80205c8: 4629         	mov	r1, r5
 80205ca: eb10 0208    	adds.w	r2, r0, r8
 80205ce: eb41 0309    	adc.w	r3, r1, r9
 80205d2: eb12 0a02    	adds.w	r10, r2, r2
 80205d6: eb43 0b03    	adc.w	r11, r3, r3
 80205da: 4652         	mov	r2, r10
 80205dc: 465b         	mov	r3, r11
 80205de: 4610         	mov	r0, r2
 80205e0: 4619         	mov	r1, r3
 80205e2: f000 f807    	bl	0x80205f4 <k_sleep>     @ imm = #0xe
 80205e6: 4601         	mov	r1, r0
 80205e8: 460b         	mov	r3, r1
; }
 80205ea: 4618         	mov	r0, r3
 80205ec: 3708         	adds	r7, #0x8
 80205ee: 46bd         	mov	sp, r7
 80205f0: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080205f4 <k_sleep>:
; {
 80205f4: b580         	push	{r7, lr}
 80205f6: b082         	sub	sp, #0x8
 80205f8: af00         	add	r7, sp, #0x0
 80205fa: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 80205fe: e9d7 0100    	ldrd	r0, r1, [r7]
 8020602: f7f5 fe75    	bl	0x80162f0 <z_impl_k_sleep> @ imm = #-0xa316
 8020606: 4603         	mov	r3, r0
; }
 8020608: 4618         	mov	r0, r3
 802060a: 3708         	adds	r7, #0x8
 802060c: 46bd         	mov	sp, r7
 802060e: bd80         	pop	{r7, pc}

08020610 <z_log_msg_runtime_create>:
; {
 8020610: b580         	push	{r7, lr}
 8020612: b08a         	sub	sp, #0x28
 8020614: af04         	add	r7, sp, #0x10
 8020616: 60b9         	str	r1, [r7, #0x8]
 8020618: 607b         	str	r3, [r7, #0x4]
 802061a: 4603         	mov	r3, r0
 802061c: 73fb         	strb	r3, [r7, #0xf]
 802061e: 4613         	mov	r3, r2
 8020620: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8020622: f107 032c    	add.w	r3, r7, #0x2c
 8020626: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8020628: 7bba         	ldrb	r2, [r7, #0xe]
 802062a: 7bf8         	ldrb	r0, [r7, #0xf]
 802062c: 697b         	ldr	r3, [r7, #0x14]
 802062e: 9303         	str	r3, [sp, #0xc]
 8020630: 6abb         	ldr	r3, [r7, #0x28]
 8020632: 9302         	str	r3, [sp, #0x8]
 8020634: 6a7b         	ldr	r3, [r7, #0x24]
 8020636: 9301         	str	r3, [sp, #0x4]
 8020638: 6a3b         	ldr	r3, [r7, #0x20]
 802063a: 9300         	str	r3, [sp]
 802063c: 687b         	ldr	r3, [r7, #0x4]
 802063e: 68b9         	ldr	r1, [r7, #0x8]
 8020640: f7e4 fa80    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x1bb00
; }
 8020644: bf00         	nop
 8020646: 3718         	adds	r7, #0x18
 8020648: 46bd         	mov	sp, r7
 802064a: bd80         	pop	{r7, pc}

0802064c <gpio_is_ready_dt>:
; {
 802064c: b580         	push	{r7, lr}
 802064e: b082         	sub	sp, #0x8
 8020650: af00         	add	r7, sp, #0x0
 8020652: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 8020654: 687b         	ldr	r3, [r7, #0x4]
 8020656: 681b         	ldr	r3, [r3]
 8020658: 4618         	mov	r0, r3
 802065a: f7ff ff93    	bl	0x8020584 <device_is_ready> @ imm = #-0xda
 802065e: 4603         	mov	r3, r0
; }
 8020660: 4618         	mov	r0, r3
 8020662: 3708         	adds	r7, #0x8
 8020664: 46bd         	mov	sp, r7
 8020666: bd80         	pop	{r7, pc}

08020668 <spi_cs_is_gpio>:
; {
 8020668: b480         	push	{r7}
 802066a: b083         	sub	sp, #0xc
 802066c: af00         	add	r7, sp, #0x0
 802066e: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 8020670: 687b         	ldr	r3, [r7, #0x4]
 8020672: 689b         	ldr	r3, [r3, #0x8]
 8020674: 2b00         	cmp	r3, #0x0
 8020676: bf14         	ite	ne
 8020678: 2301         	movne	r3, #0x1
 802067a: 2300         	moveq	r3, #0x0
 802067c: b2db         	uxtb	r3, r3
; }
 802067e: 4618         	mov	r0, r3
 8020680: 370c         	adds	r7, #0xc
 8020682: 46bd         	mov	sp, r7
 8020684: f85d 7b04    	ldr	r7, [sp], #4
 8020688: 4770         	bx	lr

0802068a <spi_cs_is_gpio_dt>:
; {
 802068a: b580         	push	{r7, lr}
 802068c: b082         	sub	sp, #0x8
 802068e: af00         	add	r7, sp, #0x0
 8020690: 6078         	str	r0, [r7, #0x4]
; 	return spi_cs_is_gpio(&spec->config);
 8020692: 687b         	ldr	r3, [r7, #0x4]
 8020694: 3304         	adds	r3, #0x4
 8020696: 4618         	mov	r0, r3
 8020698: f7ff ffe6    	bl	0x8020668 <spi_cs_is_gpio> @ imm = #-0x34
 802069c: 4603         	mov	r3, r0
; }
 802069e: 4618         	mov	r0, r3
 80206a0: 3708         	adds	r7, #0x8
 80206a2: 46bd         	mov	sp, r7
 80206a4: bd80         	pop	{r7, pc}

080206a6 <spi_is_ready_dt>:
; {
 80206a6: b580         	push	{r7, lr}
 80206a8: b082         	sub	sp, #0x8
 80206aa: af00         	add	r7, sp, #0x0
 80206ac: 6078         	str	r0, [r7, #0x4]
; 	if (!device_is_ready(spec->bus)) {
 80206ae: 687b         	ldr	r3, [r7, #0x4]
 80206b0: 681b         	ldr	r3, [r3]
 80206b2: 4618         	mov	r0, r3
 80206b4: f7ff ff66    	bl	0x8020584 <device_is_ready> @ imm = #-0x134
 80206b8: 4603         	mov	r3, r0
 80206ba: f083 0301    	eor	r3, r3, #0x1
 80206be: b2db         	uxtb	r3, r3
 80206c0: 2b00         	cmp	r3, #0x0
 80206c2: d001         	beq	0x80206c8 <spi_is_ready_dt+0x22> @ imm = #0x2
; 		return false;
 80206c4: 2300         	movs	r3, #0x0
 80206c6: e013         	b	0x80206f0 <spi_is_ready_dt+0x4a> @ imm = #0x26
; 	if (spi_cs_is_gpio_dt(spec) &&
 80206c8: 6878         	ldr	r0, [r7, #0x4]
 80206ca: f7ff ffde    	bl	0x802068a <spi_cs_is_gpio_dt> @ imm = #-0x44
 80206ce: 4603         	mov	r3, r0
 80206d0: 2b00         	cmp	r3, #0x0
 80206d2: d00c         	beq	0x80206ee <spi_is_ready_dt+0x48> @ imm = #0x18
; 	    !gpio_is_ready_dt(&spec->config.cs.gpio)) {
 80206d4: 687b         	ldr	r3, [r7, #0x4]
 80206d6: 330c         	adds	r3, #0xc
 80206d8: 4618         	mov	r0, r3
 80206da: f7ff ffb7    	bl	0x802064c <gpio_is_ready_dt> @ imm = #-0x92
 80206de: 4603         	mov	r3, r0
 80206e0: f083 0301    	eor	r3, r3, #0x1
 80206e4: b2db         	uxtb	r3, r3
; 	if (spi_cs_is_gpio_dt(spec) &&
 80206e6: 2b00         	cmp	r3, #0x0
 80206e8: d001         	beq	0x80206ee <spi_is_ready_dt+0x48> @ imm = #0x2
; 		return false;
 80206ea: 2300         	movs	r3, #0x0
 80206ec: e000         	b	0x80206f0 <spi_is_ready_dt+0x4a> @ imm = #0x0
; 	return true;
 80206ee: 2301         	movs	r3, #0x1
; }
 80206f0: 4618         	mov	r0, r3
 80206f2: 3708         	adds	r7, #0x8
 80206f4: 46bd         	mov	sp, r7
 80206f6: bd80         	pop	{r7, pc}

080206f8 <z_impl_spi_transceive>:
; {
 80206f8: b590         	push	{r4, r7, lr}
 80206fa: b087         	sub	sp, #0x1c
 80206fc: af00         	add	r7, sp, #0x0
 80206fe: 60f8         	str	r0, [r7, #0xc]
 8020700: 60b9         	str	r1, [r7, #0x8]
 8020702: 607a         	str	r2, [r7, #0x4]
 8020704: 603b         	str	r3, [r7]
; 	const struct spi_driver_api *api =
 8020706: 68fb         	ldr	r3, [r7, #0xc]
 8020708: 689b         	ldr	r3, [r3, #0x8]
 802070a: 617b         	str	r3, [r7, #0x14]
; 	ret = api->transceive(dev, config, tx_bufs, rx_bufs);
 802070c: 697b         	ldr	r3, [r7, #0x14]
 802070e: 681c         	ldr	r4, [r3]
 8020710: 683b         	ldr	r3, [r7]
 8020712: 687a         	ldr	r2, [r7, #0x4]
 8020714: 68b9         	ldr	r1, [r7, #0x8]
 8020716: 68f8         	ldr	r0, [r7, #0xc]
 8020718: 47a0         	blx	r4
 802071a: 6138         	str	r0, [r7, #0x10]
; 	return ret;
 802071c: 693b         	ldr	r3, [r7, #0x10]
; }
 802071e: 4618         	mov	r0, r3
 8020720: 371c         	adds	r7, #0x1c
 8020722: 46bd         	mov	sp, r7
 8020724: bd90         	pop	{r4, r7, pc}

08020726 <spi_transceive_dt>:
; {
 8020726: b580         	push	{r7, lr}
 8020728: b084         	sub	sp, #0x10
 802072a: af00         	add	r7, sp, #0x0
 802072c: 60f8         	str	r0, [r7, #0xc]
 802072e: 60b9         	str	r1, [r7, #0x8]
 8020730: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(spec->bus, &spec->config, tx_bufs, rx_bufs);
 8020732: 68fb         	ldr	r3, [r7, #0xc]
 8020734: 6818         	ldr	r0, [r3]
 8020736: 68fb         	ldr	r3, [r7, #0xc]
 8020738: 1d19         	adds	r1, r3, #0x4
 802073a: 687b         	ldr	r3, [r7, #0x4]
 802073c: 68ba         	ldr	r2, [r7, #0x8]
 802073e: f000 f828    	bl	0x8020792 <spi_transceive> @ imm = #0x50
 8020742: 4603         	mov	r3, r0
; }
 8020744: 4618         	mov	r0, r3
 8020746: 3710         	adds	r7, #0x10
 8020748: 46bd         	mov	sp, r7
 802074a: bd80         	pop	{r7, pc}

0802074c <spi_write>:
; {
 802074c: b580         	push	{r7, lr}
 802074e: b084         	sub	sp, #0x10
 8020750: af00         	add	r7, sp, #0x0
 8020752: 60f8         	str	r0, [r7, #0xc]
 8020754: 60b9         	str	r1, [r7, #0x8]
 8020756: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(dev, config, tx_bufs, NULL);
 8020758: 2300         	movs	r3, #0x0
 802075a: 687a         	ldr	r2, [r7, #0x4]
 802075c: 68b9         	ldr	r1, [r7, #0x8]
 802075e: 68f8         	ldr	r0, [r7, #0xc]
 8020760: f000 f817    	bl	0x8020792 <spi_transceive> @ imm = #0x2e
 8020764: 4603         	mov	r3, r0
; }
 8020766: 4618         	mov	r0, r3
 8020768: 3710         	adds	r7, #0x10
 802076a: 46bd         	mov	sp, r7
 802076c: bd80         	pop	{r7, pc}

0802076e <spi_write_dt>:
; {
 802076e: b580         	push	{r7, lr}
 8020770: b082         	sub	sp, #0x8
 8020772: af00         	add	r7, sp, #0x0
 8020774: 6078         	str	r0, [r7, #0x4]
 8020776: 6039         	str	r1, [r7]
; 	return spi_write(spec->bus, &spec->config, tx_bufs);
 8020778: 687b         	ldr	r3, [r7, #0x4]
 802077a: 6818         	ldr	r0, [r3]
 802077c: 687b         	ldr	r3, [r7, #0x4]
 802077e: 3304         	adds	r3, #0x4
 8020780: 683a         	ldr	r2, [r7]
 8020782: 4619         	mov	r1, r3
 8020784: f7ff ffe2    	bl	0x802074c <spi_write>   @ imm = #-0x3c
 8020788: 4603         	mov	r3, r0
; }
 802078a: 4618         	mov	r0, r3
 802078c: 3708         	adds	r7, #0x8
 802078e: 46bd         	mov	sp, r7
 8020790: bd80         	pop	{r7, pc}

08020792 <spi_transceive>:
; {
 8020792: b580         	push	{r7, lr}
 8020794: b084         	sub	sp, #0x10
 8020796: af00         	add	r7, sp, #0x0
 8020798: 60f8         	str	r0, [r7, #0xc]
 802079a: 60b9         	str	r1, [r7, #0x8]
 802079c: 607a         	str	r2, [r7, #0x4]
 802079e: 603b         	str	r3, [r7]
; 	return z_impl_spi_transceive(dev, config, tx_bufs, rx_bufs);
 80207a0: 683b         	ldr	r3, [r7]
 80207a2: 687a         	ldr	r2, [r7, #0x4]
 80207a4: 68b9         	ldr	r1, [r7, #0x8]
 80207a6: 68f8         	ldr	r0, [r7, #0xc]
 80207a8: f7ff ffa6    	bl	0x80206f8 <z_impl_spi_transceive> @ imm = #-0xb4
 80207ac: 4603         	mov	r3, r0
; }
 80207ae: 4618         	mov	r0, r3
 80207b0: 3710         	adds	r7, #0x10
 80207b2: 46bd         	mov	sp, r7
 80207b4: bd80         	pop	{r7, pc}

080207b6 <bmi08x_gyro_transceive_spi>:
; {
 80207b6: b580         	push	{r7, lr}
 80207b8: b092         	sub	sp, #0x48
 80207ba: af00         	add	r7, sp, #0x0
 80207bc: 60f8         	str	r0, [r7, #0xc]
 80207be: 607b         	str	r3, [r7, #0x4]
 80207c0: 460b         	mov	r3, r1
 80207c2: 72fb         	strb	r3, [r7, #0xb]
 80207c4: 4613         	mov	r3, r2
 80207c6: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_gyro_config *bmi08x = dev->config;
 80207c8: 68fb         	ldr	r3, [r7, #0xc]
 80207ca: 685b         	ldr	r3, [r3, #0x4]
 80207cc: 647b         	str	r3, [r7, #0x44]
; 	const struct spi_buf tx_buf[2] = {{.buf = &reg, .len = 1}, {.buf = data, .len = length}};
 80207ce: f107 030b    	add.w	r3, r7, #0xb
 80207d2: 637b         	str	r3, [r7, #0x34]
 80207d4: 2301         	movs	r3, #0x1
 80207d6: 63bb         	str	r3, [r7, #0x38]
 80207d8: 687b         	ldr	r3, [r7, #0x4]
 80207da: 63fb         	str	r3, [r7, #0x3c]
 80207dc: 6d3b         	ldr	r3, [r7, #0x50]
 80207de: 643b         	str	r3, [r7, #0x40]
; 	const struct spi_buf_set tx = {.buffers = tx_buf, .count = write ? 2 : 1};
 80207e0: f107 0334    	add.w	r3, r7, #0x34
 80207e4: 62fb         	str	r3, [r7, #0x2c]
 80207e6: 7abb         	ldrb	r3, [r7, #0xa]
 80207e8: 2b00         	cmp	r3, #0x0
 80207ea: d001         	beq	0x80207f0 <bmi08x_gyro_transceive_spi+0x3a> @ imm = #0x2
 80207ec: 2302         	movs	r3, #0x2
 80207ee: e000         	b	0x80207f2 <bmi08x_gyro_transceive_spi+0x3c> @ imm = #0x0
 80207f0: 2301         	movs	r3, #0x1
 80207f2: 633b         	str	r3, [r7, #0x30]
; 	if (!write) {
 80207f4: 7abb         	ldrb	r3, [r7, #0xa]
 80207f6: f083 0301    	eor	r3, r3, #0x1
 80207fa: b2db         	uxtb	r3, r3
 80207fc: 2b00         	cmp	r3, #0x0
 80207fe: d017         	beq	0x8020830 <bmi08x_gyro_transceive_spi+0x7a> @ imm = #0x2e
; 		const struct spi_buf rx_buf[2] = {{.buf = &dummy, .len = 1},
 8020800: f107 032a    	add.w	r3, r7, #0x2a
 8020804: 61bb         	str	r3, [r7, #0x18]
 8020806: 2301         	movs	r3, #0x1
 8020808: 61fb         	str	r3, [r7, #0x1c]
 802080a: 687b         	ldr	r3, [r7, #0x4]
 802080c: 623b         	str	r3, [r7, #0x20]
 802080e: 6d3b         	ldr	r3, [r7, #0x50]
 8020810: 627b         	str	r3, [r7, #0x24]
; 		const struct spi_buf_set rx = {.buffers = rx_buf, .count = 2};
 8020812: f107 0318    	add.w	r3, r7, #0x18
 8020816: 613b         	str	r3, [r7, #0x10]
 8020818: 2302         	movs	r3, #0x2
 802081a: 617b         	str	r3, [r7, #0x14]
; 		return spi_transceive_dt(&bmi08x->bus.spi, &tx, &rx);
 802081c: 6c7b         	ldr	r3, [r7, #0x44]
 802081e: f107 0210    	add.w	r2, r7, #0x10
 8020822: f107 012c    	add.w	r1, r7, #0x2c
 8020826: 4618         	mov	r0, r3
 8020828: f7ff ff7d    	bl	0x8020726 <spi_transceive_dt> @ imm = #-0x106
 802082c: 4603         	mov	r3, r0
 802082e: e007         	b	0x8020840 <bmi08x_gyro_transceive_spi+0x8a> @ imm = #0xe
; 	return spi_write_dt(&bmi08x->bus.spi, &tx);
 8020830: 6c7b         	ldr	r3, [r7, #0x44]
 8020832: f107 022c    	add.w	r2, r7, #0x2c
 8020836: 4611         	mov	r1, r2
 8020838: 4618         	mov	r0, r3
 802083a: f7ff ff98    	bl	0x802076e <spi_write_dt> @ imm = #-0xd0
 802083e: 4603         	mov	r3, r0
; }
 8020840: 4618         	mov	r0, r3
 8020842: 3748         	adds	r7, #0x48
 8020844: 46bd         	mov	sp, r7
 8020846: bd80         	pop	{r7, pc}

08020848 <bmi08x_bus_check_spi>:
; {
 8020848: b580         	push	{r7, lr}
 802084a: b082         	sub	sp, #0x8
 802084c: af00         	add	r7, sp, #0x0
 802084e: 6078         	str	r0, [r7, #0x4]
; 	return spi_is_ready_dt(&bus->spi) ? 0 : -ENODEV;
 8020850: 687b         	ldr	r3, [r7, #0x4]
 8020852: 4618         	mov	r0, r3
 8020854: f7ff ff27    	bl	0x80206a6 <spi_is_ready_dt> @ imm = #-0x1b2
 8020858: 4603         	mov	r3, r0
 802085a: 2b00         	cmp	r3, #0x0
 802085c: d001         	beq	0x8020862 <bmi08x_bus_check_spi+0x1a> @ imm = #0x2
 802085e: 2300         	movs	r3, #0x0
 8020860: e001         	b	0x8020866 <bmi08x_bus_check_spi+0x1e> @ imm = #0x2
 8020862: f06f 0312    	mvn	r3, #0x12
; }
 8020866: 4618         	mov	r0, r3
 8020868: 3708         	adds	r7, #0x8
 802086a: 46bd         	mov	sp, r7
 802086c: bd80         	pop	{r7, pc}

0802086e <bmi08x_bus_check>:
; {
 802086e: b580         	push	{r7, lr}
 8020870: b084         	sub	sp, #0x10
 8020872: af00         	add	r7, sp, #0x0
 8020874: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_gyro_config *config = dev->config;
 8020876: 687b         	ldr	r3, [r7, #0x4]
 8020878: 685b         	ldr	r3, [r3, #0x4]
 802087a: 60fb         	str	r3, [r7, #0xc]
; 	return config->api->check(&config->bus);
 802087c: 68fb         	ldr	r3, [r7, #0xc]
 802087e: 699b         	ldr	r3, [r3, #0x18]
 8020880: 681b         	ldr	r3, [r3]
 8020882: 68fa         	ldr	r2, [r7, #0xc]
 8020884: 4610         	mov	r0, r2
 8020886: 4798         	blx	r3
 8020888: 4603         	mov	r3, r0
; }
 802088a: 4618         	mov	r0, r3
 802088c: 3710         	adds	r7, #0x10
 802088e: 46bd         	mov	sp, r7
 8020890: bd80         	pop	{r7, pc}

08020892 <bmi08x_gyro_transceive>:
; {
 8020892: b590         	push	{r4, r7, lr}
 8020894: b089         	sub	sp, #0x24
 8020896: af02         	add	r7, sp, #0x8
 8020898: 60f8         	str	r0, [r7, #0xc]
 802089a: 607b         	str	r3, [r7, #0x4]
 802089c: 460b         	mov	r3, r1
 802089e: 72fb         	strb	r3, [r7, #0xb]
 80208a0: 4613         	mov	r3, r2
 80208a2: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_gyro_config *cfg = dev->config;
 80208a4: 68fb         	ldr	r3, [r7, #0xc]
 80208a6: 685b         	ldr	r3, [r3, #0x4]
 80208a8: 617b         	str	r3, [r7, #0x14]
; 	return cfg->api->transceive(dev, reg, write, data, length);
 80208aa: 697b         	ldr	r3, [r7, #0x14]
 80208ac: 699b         	ldr	r3, [r3, #0x18]
 80208ae: 685c         	ldr	r4, [r3, #0x4]
 80208b0: 7aba         	ldrb	r2, [r7, #0xa]
 80208b2: 7af9         	ldrb	r1, [r7, #0xb]
 80208b4: 6abb         	ldr	r3, [r7, #0x28]
 80208b6: 9300         	str	r3, [sp]
 80208b8: 687b         	ldr	r3, [r7, #0x4]
 80208ba: 68f8         	ldr	r0, [r7, #0xc]
 80208bc: 47a0         	blx	r4
 80208be: 4603         	mov	r3, r0
; }
 80208c0: 4618         	mov	r0, r3
 80208c2: 371c         	adds	r7, #0x1c
 80208c4: 46bd         	mov	sp, r7
 80208c6: bd90         	pop	{r4, r7, pc}

080208c8 <bmi08x_gyro_read>:
; {
 80208c8: b580         	push	{r7, lr}
 80208ca: b086         	sub	sp, #0x18
 80208cc: af02         	add	r7, sp, #0x8
 80208ce: 60f8         	str	r0, [r7, #0xc]
 80208d0: 607a         	str	r2, [r7, #0x4]
 80208d2: 461a         	mov	r2, r3
 80208d4: 460b         	mov	r3, r1
 80208d6: 72fb         	strb	r3, [r7, #0xb]
 80208d8: 4613         	mov	r3, r2
 80208da: 72bb         	strb	r3, [r7, #0xa]
; 	return bmi08x_gyro_transceive(dev, reg_addr | BIT(7), false, data, len);
 80208dc: 7afb         	ldrb	r3, [r7, #0xb]
 80208de: f063 037f    	orn	r3, r3, #0x7f
 80208e2: b2d9         	uxtb	r1, r3
 80208e4: 7abb         	ldrb	r3, [r7, #0xa]
 80208e6: 9300         	str	r3, [sp]
 80208e8: 687b         	ldr	r3, [r7, #0x4]
 80208ea: 2200         	movs	r2, #0x0
 80208ec: 68f8         	ldr	r0, [r7, #0xc]
 80208ee: f7ff ffd0    	bl	0x8020892 <bmi08x_gyro_transceive> @ imm = #-0x60
 80208f2: 4603         	mov	r3, r0
; }
 80208f4: 4618         	mov	r0, r3
 80208f6: 3710         	adds	r7, #0x10
 80208f8: 46bd         	mov	sp, r7
 80208fa: bd80         	pop	{r7, pc}

080208fc <bmi08x_gyro_byte_read>:
; {
 80208fc: b580         	push	{r7, lr}
 80208fe: b086         	sub	sp, #0x18
 8020900: af02         	add	r7, sp, #0x8
 8020902: 60f8         	str	r0, [r7, #0xc]
 8020904: 460b         	mov	r3, r1
 8020906: 607a         	str	r2, [r7, #0x4]
 8020908: 72fb         	strb	r3, [r7, #0xb]
; 	return bmi08x_gyro_transceive(dev, reg_addr | BIT(7), false, byte, 1);
 802090a: 7afb         	ldrb	r3, [r7, #0xb]
 802090c: f063 037f    	orn	r3, r3, #0x7f
 8020910: b2d9         	uxtb	r1, r3
 8020912: 2301         	movs	r3, #0x1
 8020914: 9300         	str	r3, [sp]
 8020916: 687b         	ldr	r3, [r7, #0x4]
 8020918: 2200         	movs	r2, #0x0
 802091a: 68f8         	ldr	r0, [r7, #0xc]
 802091c: f7ff ffb9    	bl	0x8020892 <bmi08x_gyro_transceive> @ imm = #-0x8e
 8020920: 4603         	mov	r3, r0
; }
 8020922: 4618         	mov	r0, r3
 8020924: 3710         	adds	r7, #0x10
 8020926: 46bd         	mov	sp, r7
 8020928: bd80         	pop	{r7, pc}

0802092a <bmi08x_gyro_byte_write>:
; {
 802092a: b580         	push	{r7, lr}
 802092c: b084         	sub	sp, #0x10
 802092e: af02         	add	r7, sp, #0x8
 8020930: 6078         	str	r0, [r7, #0x4]
 8020932: 460b         	mov	r3, r1
 8020934: 70fb         	strb	r3, [r7, #0x3]
 8020936: 4613         	mov	r3, r2
 8020938: 70bb         	strb	r3, [r7, #0x2]
; 	return bmi08x_gyro_transceive(dev, reg_addr & 0x7F, true, &byte, 1);
 802093a: 78fb         	ldrb	r3, [r7, #0x3]
 802093c: f003 037f    	and	r3, r3, #0x7f
 8020940: b2d9         	uxtb	r1, r3
 8020942: 1cbb         	adds	r3, r7, #0x2
 8020944: 2201         	movs	r2, #0x1
 8020946: 9200         	str	r2, [sp]
 8020948: 2201         	movs	r2, #0x1
 802094a: 6878         	ldr	r0, [r7, #0x4]
 802094c: f7ff ffa1    	bl	0x8020892 <bmi08x_gyro_transceive> @ imm = #-0xbe
 8020950: 4603         	mov	r3, r0
; }
 8020952: 4618         	mov	r0, r3
 8020954: 3708         	adds	r7, #0x8
 8020956: 46bd         	mov	sp, r7
 8020958: bd80         	pop	{r7, pc}

0802095a <bmi08x_gyr_odr_set>:
; {
 802095a: b580         	push	{r7, lr}
 802095c: b084         	sub	sp, #0x10
 802095e: af00         	add	r7, sp, #0x0
 8020960: 6078         	str	r0, [r7, #0x4]
 8020962: 460b         	mov	r3, r1
 8020964: 807b         	strh	r3, [r7, #0x2]
 8020966: 4613         	mov	r3, r2
 8020968: 803b         	strh	r3, [r7]
; 	int odr = bmi08x_freq_to_odr_val(freq_int, freq_milli);
 802096a: 883a         	ldrh	r2, [r7]
 802096c: 887b         	ldrh	r3, [r7, #0x2]
 802096e: 4611         	mov	r1, r2
 8020970: 4618         	mov	r0, r3
 8020972: f7eb fc0b    	bl	0x800c18c <bmi08x_freq_to_odr_val> @ imm = #-0x147ea
 8020976: 60f8         	str	r0, [r7, #0xc]
; 	if (odr < 0) {
 8020978: 68fb         	ldr	r3, [r7, #0xc]
 802097a: 2b00         	cmp	r3, #0x0
 802097c: da01         	bge	0x8020982 <bmi08x_gyr_odr_set+0x28> @ imm = #0x2
; 		return odr;
 802097e: 68fb         	ldr	r3, [r7, #0xc]
 8020980: e010         	b	0x80209a4 <bmi08x_gyr_odr_set+0x4a> @ imm = #0x20
; 	if (odr < BMI08X_GYRO_BW_532_ODR_2000_HZ || odr > BMI08X_GYRO_BW_32_ODR_100_HZ) {
 8020982: 68fb         	ldr	r3, [r7, #0xc]
 8020984: 2b00         	cmp	r3, #0x0
 8020986: db02         	blt	0x802098e <bmi08x_gyr_odr_set+0x34> @ imm = #0x4
 8020988: 68fb         	ldr	r3, [r7, #0xc]
 802098a: 2b07         	cmp	r3, #0x7
 802098c: dd02         	ble	0x8020994 <bmi08x_gyr_odr_set+0x3a> @ imm = #0x4
; 		return -ENOTSUP;
 802098e: f06f 0385    	mvn	r3, #0x85
 8020992: e007         	b	0x80209a4 <bmi08x_gyr_odr_set+0x4a> @ imm = #0xe
; 	return bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_BANDWIDTH, (uint8_t)odr);
 8020994: 68fb         	ldr	r3, [r7, #0xc]
 8020996: b2db         	uxtb	r3, r3
 8020998: 461a         	mov	r2, r3
 802099a: 2110         	movs	r1, #0x10
 802099c: 6878         	ldr	r0, [r7, #0x4]
 802099e: f7ff ffc4    	bl	0x802092a <bmi08x_gyro_byte_write> @ imm = #-0x78
 80209a2: 4603         	mov	r3, r0
; }
 80209a4: 4618         	mov	r0, r3
 80209a6: 3710         	adds	r7, #0x10
 80209a8: 46bd         	mov	sp, r7
 80209aa: bd80         	pop	{r7, pc}

080209ac <bmi08x_channel_convert>:
; {
 80209ac: b580         	push	{r7, lr}
 80209ae: b086         	sub	sp, #0x18
 80209b0: af00         	add	r7, sp, #0x0
 80209b2: 60ba         	str	r2, [r7, #0x8]
 80209b4: 607b         	str	r3, [r7, #0x4]
 80209b6: 4603         	mov	r3, r0
 80209b8: 81fb         	strh	r3, [r7, #0xe]
 80209ba: 460b         	mov	r3, r1
 80209bc: 81bb         	strh	r3, [r7, #0xc]
; 	switch (chan) {
 80209be: 89fb         	ldrh	r3, [r7, #0xe]
 80209c0: 2b06         	cmp	r3, #0x6
 80209c2: d010         	beq	0x80209e6 <bmi08x_channel_convert+0x3a> @ imm = #0x20
 80209c4: 2b06         	cmp	r3, #0x6
 80209c6: dc13         	bgt	0x80209f0 <bmi08x_channel_convert+0x44> @ imm = #0x26
 80209c8: 2b04         	cmp	r3, #0x4
 80209ca: d002         	beq	0x80209d2 <bmi08x_channel_convert+0x26> @ imm = #0x4
 80209cc: 2b05         	cmp	r3, #0x5
 80209ce: d005         	beq	0x80209dc <bmi08x_channel_convert+0x30> @ imm = #0xa
 80209d0: e00e         	b	0x80209f0 <bmi08x_channel_convert+0x44> @ imm = #0x1c
; 		ofs_start = ofs_stop = 0U;
 80209d2: 2300         	movs	r3, #0x0
 80209d4: 74bb         	strb	r3, [r7, #0x12]
 80209d6: 7cbb         	ldrb	r3, [r7, #0x12]
 80209d8: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 80209da: e00e         	b	0x80209fa <bmi08x_channel_convert+0x4e> @ imm = #0x1c
; 		ofs_start = ofs_stop = 1U;
 80209dc: 2301         	movs	r3, #0x1
 80209de: 74bb         	strb	r3, [r7, #0x12]
 80209e0: 7cbb         	ldrb	r3, [r7, #0x12]
 80209e2: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 80209e4: e009         	b	0x80209fa <bmi08x_channel_convert+0x4e> @ imm = #0x12
; 		ofs_start = ofs_stop = 2U;
 80209e6: 2302         	movs	r3, #0x2
 80209e8: 74bb         	strb	r3, [r7, #0x12]
 80209ea: 7cbb         	ldrb	r3, [r7, #0x12]
 80209ec: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 80209ee: e004         	b	0x80209fa <bmi08x_channel_convert+0x4e> @ imm = #0x8
; 		ofs_start = 0U;
 80209f0: 2300         	movs	r3, #0x0
 80209f2: 74fb         	strb	r3, [r7, #0x13]
; 		ofs_stop = 2U;
 80209f4: 2302         	movs	r3, #0x2
 80209f6: 74bb         	strb	r3, [r7, #0x12]
; 		break;
 80209f8: bf00         	nop
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 80209fa: 7cfb         	ldrb	r3, [r7, #0x13]
 80209fc: 617b         	str	r3, [r7, #0x14]
 80209fe: e010         	b	0x8020a22 <bmi08x_channel_convert+0x76> @ imm = #0x20
; 		bmi08x_to_fixed_point(raw_xyz[i], scale, val);
 8020a00: 697b         	ldr	r3, [r7, #0x14]
 8020a02: 005b         	lsls	r3, r3, #0x1
 8020a04: 68ba         	ldr	r2, [r7, #0x8]
 8020a06: 4413         	add	r3, r2
 8020a08: 881b         	ldrh	r3, [r3]
 8020a0a: b21b         	sxth	r3, r3
 8020a0c: 89b9         	ldrh	r1, [r7, #0xc]
 8020a0e: 687a         	ldr	r2, [r7, #0x4]
 8020a10: 4618         	mov	r0, r3
 8020a12: f7eb f99f    	bl	0x800bd54 <bmi08x_to_fixed_point> @ imm = #-0x14cc2
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 8020a16: 697b         	ldr	r3, [r7, #0x14]
 8020a18: 3301         	adds	r3, #0x1
 8020a1a: 617b         	str	r3, [r7, #0x14]
 8020a1c: 687b         	ldr	r3, [r7, #0x4]
 8020a1e: 3308         	adds	r3, #0x8
 8020a20: 607b         	str	r3, [r7, #0x4]
 8020a22: 7cbb         	ldrb	r3, [r7, #0x12]
 8020a24: 697a         	ldr	r2, [r7, #0x14]
 8020a26: 429a         	cmp	r2, r3
 8020a28: ddea         	ble	0x8020a00 <bmi08x_channel_convert+0x54> @ imm = #-0x2c
; }
 8020a2a: bf00         	nop
 8020a2c: bf00         	nop
 8020a2e: 3718         	adds	r7, #0x18
 8020a30: 46bd         	mov	sp, r7
 8020a32: bd80         	pop	{r7, pc}

08020a34 <bmi08x_gyr_channel_get>:
; {
 8020a34: b580         	push	{r7, lr}
 8020a36: b086         	sub	sp, #0x18
 8020a38: af00         	add	r7, sp, #0x0
 8020a3a: 60f8         	str	r0, [r7, #0xc]
 8020a3c: 460b         	mov	r3, r1
 8020a3e: 607a         	str	r2, [r7, #0x4]
 8020a40: 817b         	strh	r3, [r7, #0xa]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 8020a42: 68fb         	ldr	r3, [r7, #0xc]
 8020a44: 691b         	ldr	r3, [r3, #0x10]
 8020a46: 617b         	str	r3, [r7, #0x14]
; 	bmi08x_channel_convert(chan, bmi08x->scale, bmi08x->gyr_sample, val);
 8020a48: 697b         	ldr	r3, [r7, #0x14]
 8020a4a: 8a59         	ldrh	r1, [r3, #0x12]
 8020a4c: 697b         	ldr	r3, [r7, #0x14]
 8020a4e: f103 020c    	add.w	r2, r3, #0xc
 8020a52: 8978         	ldrh	r0, [r7, #0xa]
 8020a54: 687b         	ldr	r3, [r7, #0x4]
 8020a56: f7ff ffa9    	bl	0x80209ac <bmi08x_channel_convert> @ imm = #-0xae
; }
 8020a5a: bf00         	nop
 8020a5c: 3718         	adds	r7, #0x18
 8020a5e: 46bd         	mov	sp, r7
 8020a60: bd80         	pop	{r7, pc}

08020a62 <bmi08x_range_to_reg_val>:
; {
 8020a62: b480         	push	{r7}
 8020a64: b085         	sub	sp, #0x14
 8020a66: af00         	add	r7, sp, #0x0
 8020a68: 4603         	mov	r3, r0
 8020a6a: 6039         	str	r1, [r7]
 8020a6c: 80fb         	strh	r3, [r7, #0x6]
 8020a6e: 4613         	mov	r3, r2
 8020a70: 80bb         	strh	r3, [r7, #0x4]
; 	for (i = 0; i < range_map_size; i++) {
 8020a72: 2300         	movs	r3, #0x0
 8020a74: 60fb         	str	r3, [r7, #0xc]
 8020a76: e010         	b	0x8020a9a <bmi08x_range_to_reg_val+0x38> @ imm = #0x20
; 		if (range <= range_map[i].range) {
 8020a78: 68fb         	ldr	r3, [r7, #0xc]
 8020a7a: 009b         	lsls	r3, r3, #0x2
 8020a7c: 683a         	ldr	r2, [r7]
 8020a7e: 4413         	add	r3, r2
 8020a80: 881b         	ldrh	r3, [r3]
 8020a82: 88fa         	ldrh	r2, [r7, #0x6]
 8020a84: 429a         	cmp	r2, r3
 8020a86: d805         	bhi	0x8020a94 <bmi08x_range_to_reg_val+0x32> @ imm = #0xa
; 			return range_map[i].reg_val;
 8020a88: 68fb         	ldr	r3, [r7, #0xc]
 8020a8a: 009b         	lsls	r3, r3, #0x2
 8020a8c: 683a         	ldr	r2, [r7]
 8020a8e: 4413         	add	r3, r2
 8020a90: 789b         	ldrb	r3, [r3, #0x2]
 8020a92: e008         	b	0x8020aa6 <bmi08x_range_to_reg_val+0x44> @ imm = #0x10
; 	for (i = 0; i < range_map_size; i++) {
 8020a94: 68fb         	ldr	r3, [r7, #0xc]
 8020a96: 3301         	adds	r3, #0x1
 8020a98: 60fb         	str	r3, [r7, #0xc]
 8020a9a: 88bb         	ldrh	r3, [r7, #0x4]
 8020a9c: 68fa         	ldr	r2, [r7, #0xc]
 8020a9e: 429a         	cmp	r2, r3
 8020aa0: dbea         	blt	0x8020a78 <bmi08x_range_to_reg_val+0x16> @ imm = #-0x2c
; 	return -EINVAL;
 8020aa2: f06f 0315    	mvn	r3, #0x15
; }
 8020aa6: 4618         	mov	r0, r3
 8020aa8: 3714         	adds	r7, #0x14
 8020aaa: 46bd         	mov	sp, r7
 8020aac: f85d 7b04    	ldr	r7, [sp], #4
 8020ab0: 4770         	bx	lr

08020ab2 <device_is_ready>:
; {
 8020ab2: b580         	push	{r7, lr}
 8020ab4: b082         	sub	sp, #0x8
 8020ab6: af00         	add	r7, sp, #0x0
 8020ab8: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8020aba: 6878         	ldr	r0, [r7, #0x4]
 8020abc: f003 fd31    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x3a62
 8020ac0: 4603         	mov	r3, r0
; }
 8020ac2: 4618         	mov	r0, r3
 8020ac4: 3708         	adds	r7, #0x8
 8020ac6: 46bd         	mov	sp, r7
 8020ac8: bd80         	pop	{r7, pc}

08020aca <gpio_is_ready_dt>:
; {
 8020aca: b580         	push	{r7, lr}
 8020acc: b082         	sub	sp, #0x8
 8020ace: af00         	add	r7, sp, #0x0
 8020ad0: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 8020ad2: 687b         	ldr	r3, [r7, #0x4]
 8020ad4: 681b         	ldr	r3, [r3]
 8020ad6: 4618         	mov	r0, r3
 8020ad8: f7ff ffeb    	bl	0x8020ab2 <device_is_ready> @ imm = #-0x2a
 8020adc: 4603         	mov	r3, r0
; }
 8020ade: 4618         	mov	r0, r3
 8020ae0: 3708         	adds	r7, #0x8
 8020ae2: 46bd         	mov	sp, r7
 8020ae4: bd80         	pop	{r7, pc}

08020ae6 <gpio_pin_interrupt_configure_dt>:
; {
 8020ae6: b580         	push	{r7, lr}
 8020ae8: b082         	sub	sp, #0x8
 8020aea: af00         	add	r7, sp, #0x0
 8020aec: 6078         	str	r0, [r7, #0x4]
 8020aee: 6039         	str	r1, [r7]
; 	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
 8020af0: 687b         	ldr	r3, [r7, #0x4]
 8020af2: 6818         	ldr	r0, [r3]
 8020af4: 687b         	ldr	r3, [r7, #0x4]
 8020af6: 791b         	ldrb	r3, [r3, #0x4]
 8020af8: 683a         	ldr	r2, [r7]
 8020afa: 4619         	mov	r1, r3
 8020afc: f000 f892    	bl	0x8020c24 <gpio_pin_interrupt_configure> @ imm = #0x124
 8020b00: 4603         	mov	r3, r0
; }
 8020b02: 4618         	mov	r0, r3
 8020b04: 3708         	adds	r7, #0x8
 8020b06: 46bd         	mov	sp, r7
 8020b08: bd80         	pop	{r7, pc}

08020b0a <z_impl_gpio_pin_configure>:
; {
 8020b0a: b580         	push	{r7, lr}
 8020b0c: b088         	sub	sp, #0x20
 8020b0e: af00         	add	r7, sp, #0x0
 8020b10: 60f8         	str	r0, [r7, #0xc]
 8020b12: 460b         	mov	r3, r1
 8020b14: 607a         	str	r2, [r7, #0x4]
 8020b16: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 8020b18: 68fb         	ldr	r3, [r7, #0xc]
 8020b1a: 689b         	ldr	r3, [r3, #0x8]
 8020b1c: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 8020b1e: 68fb         	ldr	r3, [r7, #0xc]
 8020b20: 685b         	ldr	r3, [r3, #0x4]
 8020b22: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 8020b24: 68fb         	ldr	r3, [r7, #0xc]
 8020b26: 691b         	ldr	r3, [r3, #0x10]
 8020b28: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 8020b2a: 687b         	ldr	r3, [r7, #0x4]
 8020b2c: f403 1380    	and	r3, r3, #0x100000
 8020b30: 2b00         	cmp	r3, #0x0
 8020b32: d00d         	beq	0x8020b50 <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 8020b34: 687b         	ldr	r3, [r7, #0x4]
 8020b36: f403 2340    	and	r3, r3, #0xc0000
 8020b3a: 2b00         	cmp	r3, #0x0
 8020b3c: d008         	beq	0x8020b50 <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 8020b3e: 687b         	ldr	r3, [r7, #0x4]
 8020b40: f003 0301    	and	r3, r3, #0x1
 8020b44: 2b00         	cmp	r3, #0x0
 8020b46: d003         	beq	0x8020b50 <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 8020b48: 687b         	ldr	r3, [r7, #0x4]
 8020b4a: f483 2340    	eor	r3, r3, #0xc0000
 8020b4e: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 8020b50: 687b         	ldr	r3, [r7, #0x4]
 8020b52: f423 1380    	bic	r3, r3, #0x100000
 8020b56: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 8020b58: 687b         	ldr	r3, [r7, #0x4]
 8020b5a: f003 0301    	and	r3, r3, #0x1
 8020b5e: 2b00         	cmp	r3, #0x0
 8020b60: d009         	beq	0x8020b76 <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 8020b62: 697b         	ldr	r3, [r7, #0x14]
 8020b64: 681a         	ldr	r2, [r3]
 8020b66: 7afb         	ldrb	r3, [r7, #0xb]
 8020b68: 2101         	movs	r1, #0x1
 8020b6a: fa01 f303    	lsl.w	r3, r1, r3
 8020b6e: 431a         	orrs	r2, r3
 8020b70: 697b         	ldr	r3, [r7, #0x14]
 8020b72: 601a         	str	r2, [r3]
 8020b74: e009         	b	0x8020b8a <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 8020b76: 697b         	ldr	r3, [r7, #0x14]
 8020b78: 681a         	ldr	r2, [r3]
 8020b7a: 7afb         	ldrb	r3, [r7, #0xb]
 8020b7c: 2101         	movs	r1, #0x1
 8020b7e: fa01 f303    	lsl.w	r3, r1, r3
 8020b82: 43db         	mvns	r3, r3
 8020b84: 401a         	ands	r2, r3
 8020b86: 697b         	ldr	r3, [r7, #0x14]
 8020b88: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 8020b8a: 69fb         	ldr	r3, [r7, #0x1c]
 8020b8c: 681b         	ldr	r3, [r3]
 8020b8e: 7af9         	ldrb	r1, [r7, #0xb]
 8020b90: 687a         	ldr	r2, [r7, #0x4]
 8020b92: 68f8         	ldr	r0, [r7, #0xc]
 8020b94: 4798         	blx	r3
 8020b96: 4603         	mov	r3, r0
; }
 8020b98: 4618         	mov	r0, r3
 8020b9a: 3720         	adds	r7, #0x20
 8020b9c: 46bd         	mov	sp, r7
 8020b9e: bd80         	pop	{r7, pc}

08020ba0 <gpio_pin_configure_dt>:
; {
 8020ba0: b580         	push	{r7, lr}
 8020ba2: b082         	sub	sp, #0x8
 8020ba4: af00         	add	r7, sp, #0x0
 8020ba6: 6078         	str	r0, [r7, #0x4]
 8020ba8: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 8020baa: 687b         	ldr	r3, [r7, #0x4]
 8020bac: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 8020bae: 687b         	ldr	r3, [r7, #0x4]
 8020bb0: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 8020bb2: 687b         	ldr	r3, [r7, #0x4]
 8020bb4: 88db         	ldrh	r3, [r3, #0x6]
 8020bb6: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 8020bb8: 683b         	ldr	r3, [r7]
 8020bba: 4313         	orrs	r3, r2
 8020bbc: 461a         	mov	r2, r3
 8020bbe: f000 f843    	bl	0x8020c48 <gpio_pin_configure> @ imm = #0x86
 8020bc2: 4603         	mov	r3, r0
; }
 8020bc4: 4618         	mov	r0, r3
 8020bc6: 3708         	adds	r7, #0x8
 8020bc8: 46bd         	mov	sp, r7
 8020bca: bd80         	pop	{r7, pc}

08020bcc <gpio_init_callback>:
; {
 8020bcc: b480         	push	{r7}
 8020bce: b085         	sub	sp, #0x14
 8020bd0: af00         	add	r7, sp, #0x0
 8020bd2: 60f8         	str	r0, [r7, #0xc]
 8020bd4: 60b9         	str	r1, [r7, #0x8]
 8020bd6: 607a         	str	r2, [r7, #0x4]
; 	callback->handler = handler;
 8020bd8: 68fb         	ldr	r3, [r7, #0xc]
 8020bda: 68ba         	ldr	r2, [r7, #0x8]
 8020bdc: 605a         	str	r2, [r3, #0x4]
; 	callback->pin_mask = pin_mask;
 8020bde: 68fb         	ldr	r3, [r7, #0xc]
 8020be0: 687a         	ldr	r2, [r7, #0x4]
 8020be2: 609a         	str	r2, [r3, #0x8]
; }
 8020be4: bf00         	nop
 8020be6: 3714         	adds	r7, #0x14
 8020be8: 46bd         	mov	sp, r7
 8020bea: f85d 7b04    	ldr	r7, [sp], #4
 8020bee: 4770         	bx	lr

08020bf0 <gpio_add_callback>:
; {
 8020bf0: b580         	push	{r7, lr}
 8020bf2: b084         	sub	sp, #0x10
 8020bf4: af00         	add	r7, sp, #0x0
 8020bf6: 6078         	str	r0, [r7, #0x4]
 8020bf8: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 8020bfa: 687b         	ldr	r3, [r7, #0x4]
 8020bfc: 689b         	ldr	r3, [r3, #0x8]
 8020bfe: 60fb         	str	r3, [r7, #0xc]
; 	if (api->manage_callback == NULL) {
 8020c00: 68fb         	ldr	r3, [r7, #0xc]
 8020c02: 69db         	ldr	r3, [r3, #0x1c]
 8020c04: 2b00         	cmp	r3, #0x0
 8020c06: d102         	bne	0x8020c0e <gpio_add_callback+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 8020c08: f06f 0357    	mvn	r3, #0x57
 8020c0c: e006         	b	0x8020c1c <gpio_add_callback+0x2c> @ imm = #0xc
; 	return api->manage_callback(port, callback, true);
 8020c0e: 68fb         	ldr	r3, [r7, #0xc]
 8020c10: 69db         	ldr	r3, [r3, #0x1c]
 8020c12: 2201         	movs	r2, #0x1
 8020c14: 6839         	ldr	r1, [r7]
 8020c16: 6878         	ldr	r0, [r7, #0x4]
 8020c18: 4798         	blx	r3
 8020c1a: 4603         	mov	r3, r0
; }
 8020c1c: 4618         	mov	r0, r3
 8020c1e: 3710         	adds	r7, #0x10
 8020c20: 46bd         	mov	sp, r7
 8020c22: bd80         	pop	{r7, pc}

08020c24 <gpio_pin_interrupt_configure>:
; {
 8020c24: b580         	push	{r7, lr}
 8020c26: b084         	sub	sp, #0x10
 8020c28: af00         	add	r7, sp, #0x0
 8020c2a: 60f8         	str	r0, [r7, #0xc]
 8020c2c: 460b         	mov	r3, r1
 8020c2e: 607a         	str	r2, [r7, #0x4]
 8020c30: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_interrupt_configure(port, pin, flags);
 8020c32: 7afb         	ldrb	r3, [r7, #0xb]
 8020c34: 687a         	ldr	r2, [r7, #0x4]
 8020c36: 4619         	mov	r1, r3
 8020c38: 68f8         	ldr	r0, [r7, #0xc]
 8020c3a: f7eb fae3    	bl	0x800c204 <z_impl_gpio_pin_interrupt_configure> @ imm = #-0x14a3a
 8020c3e: 4603         	mov	r3, r0
; }
 8020c40: 4618         	mov	r0, r3
 8020c42: 3710         	adds	r7, #0x10
 8020c44: 46bd         	mov	sp, r7
 8020c46: bd80         	pop	{r7, pc}

08020c48 <gpio_pin_configure>:
; {
 8020c48: b580         	push	{r7, lr}
 8020c4a: b084         	sub	sp, #0x10
 8020c4c: af00         	add	r7, sp, #0x0
 8020c4e: 60f8         	str	r0, [r7, #0xc]
 8020c50: 460b         	mov	r3, r1
 8020c52: 607a         	str	r2, [r7, #0x4]
 8020c54: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 8020c56: 7afb         	ldrb	r3, [r7, #0xb]
 8020c58: 687a         	ldr	r2, [r7, #0x4]
 8020c5a: 4619         	mov	r1, r3
 8020c5c: 68f8         	ldr	r0, [r7, #0xc]
 8020c5e: f7ff ff54    	bl	0x8020b0a <z_impl_gpio_pin_configure> @ imm = #-0x158
 8020c62: 4603         	mov	r3, r0
; }
 8020c64: 4618         	mov	r0, r3
 8020c66: 3710         	adds	r7, #0x10
 8020c68: 46bd         	mov	sp, r7
 8020c6a: bd80         	pop	{r7, pc}

08020c6c <k_thread_create>:
; {
 8020c6c: b580         	push	{r7, lr}
 8020c6e: b08c         	sub	sp, #0x30
 8020c70: af08         	add	r7, sp, #0x20
 8020c72: 60f8         	str	r0, [r7, #0xc]
 8020c74: 60b9         	str	r1, [r7, #0x8]
 8020c76: 607a         	str	r2, [r7, #0x4]
 8020c78: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 8020c7a: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8020c7e: e9cd 2306    	strd	r2, r3, [sp, #24]
 8020c82: 6abb         	ldr	r3, [r7, #0x28]
 8020c84: 9304         	str	r3, [sp, #0x10]
 8020c86: 6a7b         	ldr	r3, [r7, #0x24]
 8020c88: 9303         	str	r3, [sp, #0xc]
 8020c8a: 6a3b         	ldr	r3, [r7, #0x20]
 8020c8c: 9302         	str	r3, [sp, #0x8]
 8020c8e: 69fb         	ldr	r3, [r7, #0x1c]
 8020c90: 9301         	str	r3, [sp, #0x4]
 8020c92: 69bb         	ldr	r3, [r7, #0x18]
 8020c94: 9300         	str	r3, [sp]
 8020c96: 683b         	ldr	r3, [r7]
 8020c98: 687a         	ldr	r2, [r7, #0x4]
 8020c9a: 68b9         	ldr	r1, [r7, #0x8]
 8020c9c: 68f8         	ldr	r0, [r7, #0xc]
 8020c9e: f005 fac8    	bl	0x8026232 <z_impl_k_thread_create> @ imm = #0x5590
 8020ca2: 4603         	mov	r3, r0
; }
 8020ca4: 4618         	mov	r0, r3
 8020ca6: 3710         	adds	r7, #0x10
 8020ca8: 46bd         	mov	sp, r7
 8020caa: bd80         	pop	{r7, pc}

08020cac <k_thread_name_set>:
; {
 8020cac: b580         	push	{r7, lr}
 8020cae: b082         	sub	sp, #0x8
 8020cb0: af00         	add	r7, sp, #0x0
 8020cb2: 6078         	str	r0, [r7, #0x4]
 8020cb4: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 8020cb6: 6839         	ldr	r1, [r7]
 8020cb8: 6878         	ldr	r0, [r7, #0x4]
 8020cba: f7f3 feb7    	bl	0x8014a2c <z_impl_k_thread_name_set> @ imm = #-0xc292
 8020cbe: 4603         	mov	r3, r0
; }
 8020cc0: 4618         	mov	r0, r3
 8020cc2: 3708         	adds	r7, #0x8
 8020cc4: 46bd         	mov	sp, r7
 8020cc6: bd80         	pop	{r7, pc}

08020cc8 <k_sem_init>:
; {
 8020cc8: b580         	push	{r7, lr}
 8020cca: b084         	sub	sp, #0x10
 8020ccc: af00         	add	r7, sp, #0x0
 8020cce: 60f8         	str	r0, [r7, #0xc]
 8020cd0: 60b9         	str	r1, [r7, #0x8]
 8020cd2: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 8020cd4: 687a         	ldr	r2, [r7, #0x4]
 8020cd6: 68b9         	ldr	r1, [r7, #0x8]
 8020cd8: 68f8         	ldr	r0, [r7, #0xc]
 8020cda: f004 fde0    	bl	0x802589e <z_impl_k_sem_init> @ imm = #0x4bc0
 8020cde: 4603         	mov	r3, r0
; }
 8020ce0: 4618         	mov	r0, r3
 8020ce2: 3710         	adds	r7, #0x10
 8020ce4: 46bd         	mov	sp, r7
 8020ce6: bd80         	pop	{r7, pc}

08020ce8 <k_sem_take>:
; {
 8020ce8: b580         	push	{r7, lr}
 8020cea: b084         	sub	sp, #0x10
 8020cec: af00         	add	r7, sp, #0x0
 8020cee: 60f8         	str	r0, [r7, #0xc]
 8020cf0: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8020cf4: e9d7 2300    	ldrd	r2, r3, [r7]
 8020cf8: 68f8         	ldr	r0, [r7, #0xc]
 8020cfa: f7f3 fa2f    	bl	0x801415c <z_impl_k_sem_take> @ imm = #-0xcba2
 8020cfe: 4603         	mov	r3, r0
; }
 8020d00: 4618         	mov	r0, r3
 8020d02: 3710         	adds	r7, #0x10
 8020d04: 46bd         	mov	sp, r7
 8020d06: bd80         	pop	{r7, pc}

08020d08 <k_sem_give>:
; {
 8020d08: b580         	push	{r7, lr}
 8020d0a: b082         	sub	sp, #0x8
 8020d0c: af00         	add	r7, sp, #0x0
 8020d0e: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8020d10: 6878         	ldr	r0, [r7, #0x4]
 8020d12: f7f3 f995    	bl	0x8014040 <z_impl_k_sem_give> @ imm = #-0xccd6
; }
 8020d16: bf00         	nop
 8020d18: 3708         	adds	r7, #0x8
 8020d1a: 46bd         	mov	sp, r7
 8020d1c: bd80         	pop	{r7, pc}

08020d1e <z_log_msg_runtime_create>:
; {
 8020d1e: b580         	push	{r7, lr}
 8020d20: b08a         	sub	sp, #0x28
 8020d22: af04         	add	r7, sp, #0x10
 8020d24: 60b9         	str	r1, [r7, #0x8]
 8020d26: 607b         	str	r3, [r7, #0x4]
 8020d28: 4603         	mov	r3, r0
 8020d2a: 73fb         	strb	r3, [r7, #0xf]
 8020d2c: 4613         	mov	r3, r2
 8020d2e: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8020d30: f107 032c    	add.w	r3, r7, #0x2c
 8020d34: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8020d36: 7bba         	ldrb	r2, [r7, #0xe]
 8020d38: 7bf8         	ldrb	r0, [r7, #0xf]
 8020d3a: 697b         	ldr	r3, [r7, #0x14]
 8020d3c: 9303         	str	r3, [sp, #0xc]
 8020d3e: 6abb         	ldr	r3, [r7, #0x28]
 8020d40: 9302         	str	r3, [sp, #0x8]
 8020d42: 6a7b         	ldr	r3, [r7, #0x24]
 8020d44: 9301         	str	r3, [sp, #0x4]
 8020d46: 6a3b         	ldr	r3, [r7, #0x20]
 8020d48: 9300         	str	r3, [sp]
 8020d4a: 687b         	ldr	r3, [r7, #0x4]
 8020d4c: 68b9         	ldr	r1, [r7, #0x8]
 8020d4e: f7e3 fef9    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x1c20e
; }
 8020d52: bf00         	nop
 8020d54: 3718         	adds	r7, #0x18
 8020d56: 46bd         	mov	sp, r7
 8020d58: bd80         	pop	{r7, pc}

08020d5a <bmi08x_handle_drdy_acc>:
; {
 8020d5a: b580         	push	{r7, lr}
 8020d5c: b084         	sub	sp, #0x10
 8020d5e: af00         	add	r7, sp, #0x0
 8020d60: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 8020d62: 687b         	ldr	r3, [r7, #0x4]
 8020d64: 691b         	ldr	r3, [r3, #0x10]
 8020d66: 60fb         	str	r3, [r7, #0xc]
; 	if (data->handler_drdy_acc) {
 8020d68: 68fb         	ldr	r3, [r7, #0xc]
 8020d6a: f8d3 3940    	ldr.w	r3, [r3, #0x940]
 8020d6e: 2b00         	cmp	r3, #0x0
 8020d70: d008         	beq	0x8020d84 <bmi08x_handle_drdy_acc+0x2a> @ imm = #0x10
; 		data->handler_drdy_acc(dev, data->drdy_trig_acc);
 8020d72: 68fb         	ldr	r3, [r7, #0xc]
 8020d74: f8d3 3940    	ldr.w	r3, [r3, #0x940]
 8020d78: 68fa         	ldr	r2, [r7, #0xc]
 8020d7a: f8d2 2944    	ldr.w	r2, [r2, #0x944]
 8020d7e: 4611         	mov	r1, r2
 8020d80: 6878         	ldr	r0, [r7, #0x4]
 8020d82: 4798         	blx	r3
; }
 8020d84: bf00         	nop
 8020d86: 3710         	adds	r7, #0x10
 8020d88: 46bd         	mov	sp, r7
 8020d8a: bd80         	pop	{r7, pc}

08020d8c <bmi08x_handle_interrupts_acc>:
; {
 8020d8c: b580         	push	{r7, lr}
 8020d8e: b084         	sub	sp, #0x10
 8020d90: af00         	add	r7, sp, #0x0
 8020d92: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = (const struct device *)arg;
 8020d94: 687b         	ldr	r3, [r7, #0x4]
 8020d96: 60fb         	str	r3, [r7, #0xc]
; 	bmi08x_handle_drdy_acc(dev);
 8020d98: 68f8         	ldr	r0, [r7, #0xc]
 8020d9a: f7ff ffde    	bl	0x8020d5a <bmi08x_handle_drdy_acc> @ imm = #-0x44
; }
 8020d9e: bf00         	nop
 8020da0: 3710         	adds	r7, #0x10
 8020da2: 46bd         	mov	sp, r7
 8020da4: bd80         	pop	{r7, pc}

08020da6 <bmi08x_acc_gpio_callback>:
; {
 8020da6: b580         	push	{r7, lr}
 8020da8: b086         	sub	sp, #0x18
 8020daa: af00         	add	r7, sp, #0x0
 8020dac: 60f8         	str	r0, [r7, #0xc]
 8020dae: 60b9         	str	r1, [r7, #0x8]
 8020db0: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_accel_data *data = CONTAINER_OF(cb, struct bmi08x_accel_data, gpio_cb);
 8020db2: 68bb         	ldr	r3, [r7, #0x8]
 8020db4: 617b         	str	r3, [r7, #0x14]
; 	k_sem_give(&data->sem);
 8020db6: 697b         	ldr	r3, [r7, #0x14]
 8020db8: f503 6313    	add.w	r3, r3, #0x930
 8020dbc: 4618         	mov	r0, r3
 8020dbe: f7ff ffa3    	bl	0x8020d08 <k_sem_give>  @ imm = #-0xba
; }
 8020dc2: bf00         	nop
 8020dc4: 3718         	adds	r7, #0x18
 8020dc6: 46bd         	mov	sp, r7
 8020dc8: bd80         	pop	{r7, pc}

08020dca <bmi08x_trigger_set_acc>:
; {
 8020dca: b480         	push	{r7}
 8020dcc: b087         	sub	sp, #0x1c
 8020dce: af00         	add	r7, sp, #0x0
 8020dd0: 60f8         	str	r0, [r7, #0xc]
 8020dd2: 60b9         	str	r1, [r7, #0x8]
 8020dd4: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 8020dd6: 68fb         	ldr	r3, [r7, #0xc]
 8020dd8: 691b         	ldr	r3, [r3, #0x10]
 8020dda: 617b         	str	r3, [r7, #0x14]
; 	if ((trig->chan == SENSOR_CHAN_ACCEL_XYZ) && (trig->type == SENSOR_TRIG_DATA_READY)) {
 8020ddc: 68bb         	ldr	r3, [r7, #0x8]
 8020dde: 885b         	ldrh	r3, [r3, #0x2]
 8020de0: 2b03         	cmp	r3, #0x3
 8020de2: d10d         	bne	0x8020e00 <bmi08x_trigger_set_acc+0x36> @ imm = #0x1a
 8020de4: 68bb         	ldr	r3, [r7, #0x8]
 8020de6: 881b         	ldrh	r3, [r3]
 8020de8: 2b01         	cmp	r3, #0x1
 8020dea: d109         	bne	0x8020e00 <bmi08x_trigger_set_acc+0x36> @ imm = #0x12
; 		data->drdy_trig_acc = trig;
 8020dec: 697b         	ldr	r3, [r7, #0x14]
 8020dee: 68ba         	ldr	r2, [r7, #0x8]
 8020df0: f8c3 2944    	str.w	r2, [r3, #0x944]
; 		data->handler_drdy_acc = handler;
 8020df4: 697b         	ldr	r3, [r7, #0x14]
 8020df6: 687a         	ldr	r2, [r7, #0x4]
 8020df8: f8c3 2940    	str.w	r2, [r3, #0x940]
; 		return 0;
 8020dfc: 2300         	movs	r3, #0x0
 8020dfe: e001         	b	0x8020e04 <bmi08x_trigger_set_acc+0x3a> @ imm = #0x2
; 	return -ENOTSUP;
 8020e00: f06f 0385    	mvn	r3, #0x85
; }
 8020e04: 4618         	mov	r0, r3
 8020e06: 371c         	adds	r7, #0x1c
 8020e08: 46bd         	mov	sp, r7
 8020e0a: f85d 7b04    	ldr	r7, [sp], #4
 8020e0e: 4770         	bx	lr

08020e10 <device_is_ready>:
; {
 8020e10: b580         	push	{r7, lr}
 8020e12: b082         	sub	sp, #0x8
 8020e14: af00         	add	r7, sp, #0x0
 8020e16: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8020e18: 6878         	ldr	r0, [r7, #0x4]
 8020e1a: f003 fb82    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x3704
 8020e1e: 4603         	mov	r3, r0
; }
 8020e20: 4618         	mov	r0, r3
 8020e22: 3708         	adds	r7, #0x8
 8020e24: 46bd         	mov	sp, r7
 8020e26: bd80         	pop	{r7, pc}

08020e28 <gpio_is_ready_dt>:
; {
 8020e28: b580         	push	{r7, lr}
 8020e2a: b082         	sub	sp, #0x8
 8020e2c: af00         	add	r7, sp, #0x0
 8020e2e: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 8020e30: 687b         	ldr	r3, [r7, #0x4]
 8020e32: 681b         	ldr	r3, [r3]
 8020e34: 4618         	mov	r0, r3
 8020e36: f7ff ffeb    	bl	0x8020e10 <device_is_ready> @ imm = #-0x2a
 8020e3a: 4603         	mov	r3, r0
; }
 8020e3c: 4618         	mov	r0, r3
 8020e3e: 3708         	adds	r7, #0x8
 8020e40: 46bd         	mov	sp, r7
 8020e42: bd80         	pop	{r7, pc}

08020e44 <gpio_pin_interrupt_configure_dt>:
; {
 8020e44: b580         	push	{r7, lr}
 8020e46: b082         	sub	sp, #0x8
 8020e48: af00         	add	r7, sp, #0x0
 8020e4a: 6078         	str	r0, [r7, #0x4]
 8020e4c: 6039         	str	r1, [r7]
; 	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
 8020e4e: 687b         	ldr	r3, [r7, #0x4]
 8020e50: 6818         	ldr	r0, [r3]
 8020e52: 687b         	ldr	r3, [r7, #0x4]
 8020e54: 791b         	ldrb	r3, [r3, #0x4]
 8020e56: 683a         	ldr	r2, [r7]
 8020e58: 4619         	mov	r1, r3
 8020e5a: f000 f892    	bl	0x8020f82 <gpio_pin_interrupt_configure> @ imm = #0x124
 8020e5e: 4603         	mov	r3, r0
; }
 8020e60: 4618         	mov	r0, r3
 8020e62: 3708         	adds	r7, #0x8
 8020e64: 46bd         	mov	sp, r7
 8020e66: bd80         	pop	{r7, pc}

08020e68 <z_impl_gpio_pin_configure>:
; {
 8020e68: b580         	push	{r7, lr}
 8020e6a: b088         	sub	sp, #0x20
 8020e6c: af00         	add	r7, sp, #0x0
 8020e6e: 60f8         	str	r0, [r7, #0xc]
 8020e70: 460b         	mov	r3, r1
 8020e72: 607a         	str	r2, [r7, #0x4]
 8020e74: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 8020e76: 68fb         	ldr	r3, [r7, #0xc]
 8020e78: 689b         	ldr	r3, [r3, #0x8]
 8020e7a: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 8020e7c: 68fb         	ldr	r3, [r7, #0xc]
 8020e7e: 685b         	ldr	r3, [r3, #0x4]
 8020e80: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 8020e82: 68fb         	ldr	r3, [r7, #0xc]
 8020e84: 691b         	ldr	r3, [r3, #0x10]
 8020e86: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 8020e88: 687b         	ldr	r3, [r7, #0x4]
 8020e8a: f403 1380    	and	r3, r3, #0x100000
 8020e8e: 2b00         	cmp	r3, #0x0
 8020e90: d00d         	beq	0x8020eae <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 8020e92: 687b         	ldr	r3, [r7, #0x4]
 8020e94: f403 2340    	and	r3, r3, #0xc0000
 8020e98: 2b00         	cmp	r3, #0x0
 8020e9a: d008         	beq	0x8020eae <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 8020e9c: 687b         	ldr	r3, [r7, #0x4]
 8020e9e: f003 0301    	and	r3, r3, #0x1
 8020ea2: 2b00         	cmp	r3, #0x0
 8020ea4: d003         	beq	0x8020eae <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 8020ea6: 687b         	ldr	r3, [r7, #0x4]
 8020ea8: f483 2340    	eor	r3, r3, #0xc0000
 8020eac: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 8020eae: 687b         	ldr	r3, [r7, #0x4]
 8020eb0: f423 1380    	bic	r3, r3, #0x100000
 8020eb4: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 8020eb6: 687b         	ldr	r3, [r7, #0x4]
 8020eb8: f003 0301    	and	r3, r3, #0x1
 8020ebc: 2b00         	cmp	r3, #0x0
 8020ebe: d009         	beq	0x8020ed4 <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 8020ec0: 697b         	ldr	r3, [r7, #0x14]
 8020ec2: 681a         	ldr	r2, [r3]
 8020ec4: 7afb         	ldrb	r3, [r7, #0xb]
 8020ec6: 2101         	movs	r1, #0x1
 8020ec8: fa01 f303    	lsl.w	r3, r1, r3
 8020ecc: 431a         	orrs	r2, r3
 8020ece: 697b         	ldr	r3, [r7, #0x14]
 8020ed0: 601a         	str	r2, [r3]
 8020ed2: e009         	b	0x8020ee8 <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 8020ed4: 697b         	ldr	r3, [r7, #0x14]
 8020ed6: 681a         	ldr	r2, [r3]
 8020ed8: 7afb         	ldrb	r3, [r7, #0xb]
 8020eda: 2101         	movs	r1, #0x1
 8020edc: fa01 f303    	lsl.w	r3, r1, r3
 8020ee0: 43db         	mvns	r3, r3
 8020ee2: 401a         	ands	r2, r3
 8020ee4: 697b         	ldr	r3, [r7, #0x14]
 8020ee6: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 8020ee8: 69fb         	ldr	r3, [r7, #0x1c]
 8020eea: 681b         	ldr	r3, [r3]
 8020eec: 7af9         	ldrb	r1, [r7, #0xb]
 8020eee: 687a         	ldr	r2, [r7, #0x4]
 8020ef0: 68f8         	ldr	r0, [r7, #0xc]
 8020ef2: 4798         	blx	r3
 8020ef4: 4603         	mov	r3, r0
; }
 8020ef6: 4618         	mov	r0, r3
 8020ef8: 3720         	adds	r7, #0x20
 8020efa: 46bd         	mov	sp, r7
 8020efc: bd80         	pop	{r7, pc}

08020efe <gpio_pin_configure_dt>:
; {
 8020efe: b580         	push	{r7, lr}
 8020f00: b082         	sub	sp, #0x8
 8020f02: af00         	add	r7, sp, #0x0
 8020f04: 6078         	str	r0, [r7, #0x4]
 8020f06: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 8020f08: 687b         	ldr	r3, [r7, #0x4]
 8020f0a: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 8020f0c: 687b         	ldr	r3, [r7, #0x4]
 8020f0e: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 8020f10: 687b         	ldr	r3, [r7, #0x4]
 8020f12: 88db         	ldrh	r3, [r3, #0x6]
 8020f14: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 8020f16: 683b         	ldr	r3, [r7]
 8020f18: 4313         	orrs	r3, r2
 8020f1a: 461a         	mov	r2, r3
 8020f1c: f000 f843    	bl	0x8020fa6 <gpio_pin_configure> @ imm = #0x86
 8020f20: 4603         	mov	r3, r0
; }
 8020f22: 4618         	mov	r0, r3
 8020f24: 3708         	adds	r7, #0x8
 8020f26: 46bd         	mov	sp, r7
 8020f28: bd80         	pop	{r7, pc}

08020f2a <gpio_init_callback>:
; {
 8020f2a: b480         	push	{r7}
 8020f2c: b085         	sub	sp, #0x14
 8020f2e: af00         	add	r7, sp, #0x0
 8020f30: 60f8         	str	r0, [r7, #0xc]
 8020f32: 60b9         	str	r1, [r7, #0x8]
 8020f34: 607a         	str	r2, [r7, #0x4]
; 	callback->handler = handler;
 8020f36: 68fb         	ldr	r3, [r7, #0xc]
 8020f38: 68ba         	ldr	r2, [r7, #0x8]
 8020f3a: 605a         	str	r2, [r3, #0x4]
; 	callback->pin_mask = pin_mask;
 8020f3c: 68fb         	ldr	r3, [r7, #0xc]
 8020f3e: 687a         	ldr	r2, [r7, #0x4]
 8020f40: 609a         	str	r2, [r3, #0x8]
; }
 8020f42: bf00         	nop
 8020f44: 3714         	adds	r7, #0x14
 8020f46: 46bd         	mov	sp, r7
 8020f48: f85d 7b04    	ldr	r7, [sp], #4
 8020f4c: 4770         	bx	lr

08020f4e <gpio_add_callback>:
; {
 8020f4e: b580         	push	{r7, lr}
 8020f50: b084         	sub	sp, #0x10
 8020f52: af00         	add	r7, sp, #0x0
 8020f54: 6078         	str	r0, [r7, #0x4]
 8020f56: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 8020f58: 687b         	ldr	r3, [r7, #0x4]
 8020f5a: 689b         	ldr	r3, [r3, #0x8]
 8020f5c: 60fb         	str	r3, [r7, #0xc]
; 	if (api->manage_callback == NULL) {
 8020f5e: 68fb         	ldr	r3, [r7, #0xc]
 8020f60: 69db         	ldr	r3, [r3, #0x1c]
 8020f62: 2b00         	cmp	r3, #0x0
 8020f64: d102         	bne	0x8020f6c <gpio_add_callback+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 8020f66: f06f 0357    	mvn	r3, #0x57
 8020f6a: e006         	b	0x8020f7a <gpio_add_callback+0x2c> @ imm = #0xc
; 	return api->manage_callback(port, callback, true);
 8020f6c: 68fb         	ldr	r3, [r7, #0xc]
 8020f6e: 69db         	ldr	r3, [r3, #0x1c]
 8020f70: 2201         	movs	r2, #0x1
 8020f72: 6839         	ldr	r1, [r7]
 8020f74: 6878         	ldr	r0, [r7, #0x4]
 8020f76: 4798         	blx	r3
 8020f78: 4603         	mov	r3, r0
; }
 8020f7a: 4618         	mov	r0, r3
 8020f7c: 3710         	adds	r7, #0x10
 8020f7e: 46bd         	mov	sp, r7
 8020f80: bd80         	pop	{r7, pc}

08020f82 <gpio_pin_interrupt_configure>:
; {
 8020f82: b580         	push	{r7, lr}
 8020f84: b084         	sub	sp, #0x10
 8020f86: af00         	add	r7, sp, #0x0
 8020f88: 60f8         	str	r0, [r7, #0xc]
 8020f8a: 460b         	mov	r3, r1
 8020f8c: 607a         	str	r2, [r7, #0x4]
 8020f8e: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_interrupt_configure(port, pin, flags);
 8020f90: 7afb         	ldrb	r3, [r7, #0xb]
 8020f92: 687a         	ldr	r2, [r7, #0x4]
 8020f94: 4619         	mov	r1, r3
 8020f96: 68f8         	ldr	r0, [r7, #0xc]
 8020f98: f7eb facc    	bl	0x800c534 <z_impl_gpio_pin_interrupt_configure> @ imm = #-0x14a68
 8020f9c: 4603         	mov	r3, r0
; }
 8020f9e: 4618         	mov	r0, r3
 8020fa0: 3710         	adds	r7, #0x10
 8020fa2: 46bd         	mov	sp, r7
 8020fa4: bd80         	pop	{r7, pc}

08020fa6 <gpio_pin_configure>:
; {
 8020fa6: b580         	push	{r7, lr}
 8020fa8: b084         	sub	sp, #0x10
 8020faa: af00         	add	r7, sp, #0x0
 8020fac: 60f8         	str	r0, [r7, #0xc]
 8020fae: 460b         	mov	r3, r1
 8020fb0: 607a         	str	r2, [r7, #0x4]
 8020fb2: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 8020fb4: 7afb         	ldrb	r3, [r7, #0xb]
 8020fb6: 687a         	ldr	r2, [r7, #0x4]
 8020fb8: 4619         	mov	r1, r3
 8020fba: 68f8         	ldr	r0, [r7, #0xc]
 8020fbc: f7ff ff54    	bl	0x8020e68 <z_impl_gpio_pin_configure> @ imm = #-0x158
 8020fc0: 4603         	mov	r3, r0
; }
 8020fc2: 4618         	mov	r0, r3
 8020fc4: 3710         	adds	r7, #0x10
 8020fc6: 46bd         	mov	sp, r7
 8020fc8: bd80         	pop	{r7, pc}

08020fca <k_thread_create>:
; {
 8020fca: b580         	push	{r7, lr}
 8020fcc: b08c         	sub	sp, #0x30
 8020fce: af08         	add	r7, sp, #0x20
 8020fd0: 60f8         	str	r0, [r7, #0xc]
 8020fd2: 60b9         	str	r1, [r7, #0x8]
 8020fd4: 607a         	str	r2, [r7, #0x4]
 8020fd6: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 8020fd8: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8020fdc: e9cd 2306    	strd	r2, r3, [sp, #24]
 8020fe0: 6abb         	ldr	r3, [r7, #0x28]
 8020fe2: 9304         	str	r3, [sp, #0x10]
 8020fe4: 6a7b         	ldr	r3, [r7, #0x24]
 8020fe6: 9303         	str	r3, [sp, #0xc]
 8020fe8: 6a3b         	ldr	r3, [r7, #0x20]
 8020fea: 9302         	str	r3, [sp, #0x8]
 8020fec: 69fb         	ldr	r3, [r7, #0x1c]
 8020fee: 9301         	str	r3, [sp, #0x4]
 8020ff0: 69bb         	ldr	r3, [r7, #0x18]
 8020ff2: 9300         	str	r3, [sp]
 8020ff4: 683b         	ldr	r3, [r7]
 8020ff6: 687a         	ldr	r2, [r7, #0x4]
 8020ff8: 68b9         	ldr	r1, [r7, #0x8]
 8020ffa: 68f8         	ldr	r0, [r7, #0xc]
 8020ffc: f005 f919    	bl	0x8026232 <z_impl_k_thread_create> @ imm = #0x5232
 8021000: 4603         	mov	r3, r0
; }
 8021002: 4618         	mov	r0, r3
 8021004: 3710         	adds	r7, #0x10
 8021006: 46bd         	mov	sp, r7
 8021008: bd80         	pop	{r7, pc}

0802100a <k_thread_name_set>:
; {
 802100a: b580         	push	{r7, lr}
 802100c: b082         	sub	sp, #0x8
 802100e: af00         	add	r7, sp, #0x0
 8021010: 6078         	str	r0, [r7, #0x4]
 8021012: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 8021014: 6839         	ldr	r1, [r7]
 8021016: 6878         	ldr	r0, [r7, #0x4]
 8021018: f7f3 fd08    	bl	0x8014a2c <z_impl_k_thread_name_set> @ imm = #-0xc5f0
 802101c: 4603         	mov	r3, r0
; }
 802101e: 4618         	mov	r0, r3
 8021020: 3708         	adds	r7, #0x8
 8021022: 46bd         	mov	sp, r7
 8021024: bd80         	pop	{r7, pc}

08021026 <k_sem_init>:
; {
 8021026: b580         	push	{r7, lr}
 8021028: b084         	sub	sp, #0x10
 802102a: af00         	add	r7, sp, #0x0
 802102c: 60f8         	str	r0, [r7, #0xc]
 802102e: 60b9         	str	r1, [r7, #0x8]
 8021030: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 8021032: 687a         	ldr	r2, [r7, #0x4]
 8021034: 68b9         	ldr	r1, [r7, #0x8]
 8021036: 68f8         	ldr	r0, [r7, #0xc]
 8021038: f004 fc31    	bl	0x802589e <z_impl_k_sem_init> @ imm = #0x4862
 802103c: 4603         	mov	r3, r0
; }
 802103e: 4618         	mov	r0, r3
 8021040: 3710         	adds	r7, #0x10
 8021042: 46bd         	mov	sp, r7
 8021044: bd80         	pop	{r7, pc}

08021046 <k_sem_take>:
; {
 8021046: b580         	push	{r7, lr}
 8021048: b084         	sub	sp, #0x10
 802104a: af00         	add	r7, sp, #0x0
 802104c: 60f8         	str	r0, [r7, #0xc]
 802104e: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8021052: e9d7 2300    	ldrd	r2, r3, [r7]
 8021056: 68f8         	ldr	r0, [r7, #0xc]
 8021058: f7f3 f880    	bl	0x801415c <z_impl_k_sem_take> @ imm = #-0xcf00
 802105c: 4603         	mov	r3, r0
; }
 802105e: 4618         	mov	r0, r3
 8021060: 3710         	adds	r7, #0x10
 8021062: 46bd         	mov	sp, r7
 8021064: bd80         	pop	{r7, pc}

08021066 <k_sem_give>:
; {
 8021066: b580         	push	{r7, lr}
 8021068: b082         	sub	sp, #0x8
 802106a: af00         	add	r7, sp, #0x0
 802106c: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 802106e: 6878         	ldr	r0, [r7, #0x4]
 8021070: f7f2 ffe6    	bl	0x8014040 <z_impl_k_sem_give> @ imm = #-0xd034
; }
 8021074: bf00         	nop
 8021076: 3708         	adds	r7, #0x8
 8021078: 46bd         	mov	sp, r7
 802107a: bd80         	pop	{r7, pc}

0802107c <z_log_msg_runtime_create>:
; {
 802107c: b580         	push	{r7, lr}
 802107e: b08a         	sub	sp, #0x28
 8021080: af04         	add	r7, sp, #0x10
 8021082: 60b9         	str	r1, [r7, #0x8]
 8021084: 607b         	str	r3, [r7, #0x4]
 8021086: 4603         	mov	r3, r0
 8021088: 73fb         	strb	r3, [r7, #0xf]
 802108a: 4613         	mov	r3, r2
 802108c: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 802108e: f107 032c    	add.w	r3, r7, #0x2c
 8021092: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8021094: 7bba         	ldrb	r2, [r7, #0xe]
 8021096: 7bf8         	ldrb	r0, [r7, #0xf]
 8021098: 697b         	ldr	r3, [r7, #0x14]
 802109a: 9303         	str	r3, [sp, #0xc]
 802109c: 6abb         	ldr	r3, [r7, #0x28]
 802109e: 9302         	str	r3, [sp, #0x8]
 80210a0: 6a7b         	ldr	r3, [r7, #0x24]
 80210a2: 9301         	str	r3, [sp, #0x4]
 80210a4: 6a3b         	ldr	r3, [r7, #0x20]
 80210a6: 9300         	str	r3, [sp]
 80210a8: 687b         	ldr	r3, [r7, #0x4]
 80210aa: 68b9         	ldr	r1, [r7, #0x8]
 80210ac: f7e3 fd4a    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x1c56c
; }
 80210b0: bf00         	nop
 80210b2: 3718         	adds	r7, #0x18
 80210b4: 46bd         	mov	sp, r7
 80210b6: bd80         	pop	{r7, pc}

080210b8 <bmi08x_handle_drdy_gyr>:
; {
 80210b8: b580         	push	{r7, lr}
 80210ba: b084         	sub	sp, #0x10
 80210bc: af00         	add	r7, sp, #0x0
 80210be: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 80210c0: 687b         	ldr	r3, [r7, #0x4]
 80210c2: 691b         	ldr	r3, [r3, #0x10]
 80210c4: 60fb         	str	r3, [r7, #0xc]
; 	if (data->handler_drdy_gyr) {
 80210c6: 68fb         	ldr	r3, [r7, #0xc]
 80210c8: f8d3 3940    	ldr.w	r3, [r3, #0x940]
 80210cc: 2b00         	cmp	r3, #0x0
 80210ce: d008         	beq	0x80210e2 <bmi08x_handle_drdy_gyr+0x2a> @ imm = #0x10
; 		data->handler_drdy_gyr(dev, data->drdy_trig_gyr);
 80210d0: 68fb         	ldr	r3, [r7, #0xc]
 80210d2: f8d3 3940    	ldr.w	r3, [r3, #0x940]
 80210d6: 68fa         	ldr	r2, [r7, #0xc]
 80210d8: f8d2 2944    	ldr.w	r2, [r2, #0x944]
 80210dc: 4611         	mov	r1, r2
 80210de: 6878         	ldr	r0, [r7, #0x4]
 80210e0: 4798         	blx	r3
; }
 80210e2: bf00         	nop
 80210e4: 3710         	adds	r7, #0x10
 80210e6: 46bd         	mov	sp, r7
 80210e8: bd80         	pop	{r7, pc}

080210ea <bmi08x_handle_interrupts_gyr>:
; {
 80210ea: b580         	push	{r7, lr}
 80210ec: b084         	sub	sp, #0x10
 80210ee: af00         	add	r7, sp, #0x0
 80210f0: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = (const struct device *)arg;
 80210f2: 687b         	ldr	r3, [r7, #0x4]
 80210f4: 60fb         	str	r3, [r7, #0xc]
; 	bmi08x_handle_drdy_gyr(dev);
 80210f6: 68f8         	ldr	r0, [r7, #0xc]
 80210f8: f7ff ffde    	bl	0x80210b8 <bmi08x_handle_drdy_gyr> @ imm = #-0x44
; }
 80210fc: bf00         	nop
 80210fe: 3710         	adds	r7, #0x10
 8021100: 46bd         	mov	sp, r7
 8021102: bd80         	pop	{r7, pc}

08021104 <bmi08x_gyr_gpio_callback>:
; {
 8021104: b580         	push	{r7, lr}
 8021106: b086         	sub	sp, #0x18
 8021108: af00         	add	r7, sp, #0x0
 802110a: 60f8         	str	r0, [r7, #0xc]
 802110c: 60b9         	str	r1, [r7, #0x8]
 802110e: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = CONTAINER_OF(cb, struct bmi08x_gyro_data, gpio_cb);
 8021110: 68bb         	ldr	r3, [r7, #0x8]
 8021112: 617b         	str	r3, [r7, #0x14]
; 	k_sem_give(&data->sem);
 8021114: 697b         	ldr	r3, [r7, #0x14]
 8021116: f503 6313    	add.w	r3, r3, #0x930
 802111a: 4618         	mov	r0, r3
 802111c: f7ff ffa3    	bl	0x8021066 <k_sem_give>  @ imm = #-0xba
; }
 8021120: bf00         	nop
 8021122: 3718         	adds	r7, #0x18
 8021124: 46bd         	mov	sp, r7
 8021126: bd80         	pop	{r7, pc}

08021128 <bmi08x_trigger_set_gyr>:
; {
 8021128: b480         	push	{r7}
 802112a: b087         	sub	sp, #0x1c
 802112c: af00         	add	r7, sp, #0x0
 802112e: 60f8         	str	r0, [r7, #0xc]
 8021130: 60b9         	str	r1, [r7, #0x8]
 8021132: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 8021134: 68fb         	ldr	r3, [r7, #0xc]
 8021136: 691b         	ldr	r3, [r3, #0x10]
 8021138: 617b         	str	r3, [r7, #0x14]
; 	if ((trig->chan == SENSOR_CHAN_GYRO_XYZ) && (trig->type == SENSOR_TRIG_DATA_READY)) {
 802113a: 68bb         	ldr	r3, [r7, #0x8]
 802113c: 885b         	ldrh	r3, [r3, #0x2]
 802113e: 2b07         	cmp	r3, #0x7
 8021140: d10d         	bne	0x802115e <bmi08x_trigger_set_gyr+0x36> @ imm = #0x1a
 8021142: 68bb         	ldr	r3, [r7, #0x8]
 8021144: 881b         	ldrh	r3, [r3]
 8021146: 2b01         	cmp	r3, #0x1
 8021148: d109         	bne	0x802115e <bmi08x_trigger_set_gyr+0x36> @ imm = #0x12
; 		data->drdy_trig_gyr = trig;
 802114a: 697b         	ldr	r3, [r7, #0x14]
 802114c: 68ba         	ldr	r2, [r7, #0x8]
 802114e: f8c3 2944    	str.w	r2, [r3, #0x944]
; 		data->handler_drdy_gyr = handler;
 8021152: 697b         	ldr	r3, [r7, #0x14]
 8021154: 687a         	ldr	r2, [r7, #0x4]
 8021156: f8c3 2940    	str.w	r2, [r3, #0x940]
; 		return 0;
 802115a: 2300         	movs	r3, #0x0
 802115c: e001         	b	0x8021162 <bmi08x_trigger_set_gyr+0x3a> @ imm = #0x2
; 	return -ENOTSUP;
 802115e: f06f 0385    	mvn	r3, #0x85
; }
 8021162: 4618         	mov	r0, r3
 8021164: 371c         	adds	r7, #0x1c
 8021166: 46bd         	mov	sp, r7
 8021168: f85d 7b04    	ldr	r7, [sp], #4
 802116c: 4770         	bx	lr

0802116e <device_is_ready>:
; {
 802116e: b580         	push	{r7, lr}
 8021170: b082         	sub	sp, #0x8
 8021172: af00         	add	r7, sp, #0x0
 8021174: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8021176: 6878         	ldr	r0, [r7, #0x4]
 8021178: f003 f9d3    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x33a6
 802117c: 4603         	mov	r3, r0
; }
 802117e: 4618         	mov	r0, r3
 8021180: 3708         	adds	r7, #0x8
 8021182: 46bd         	mov	sp, r7
 8021184: bd80         	pop	{r7, pc}

08021186 <k_work_delayable_from_work>:
; {
 8021186: b480         	push	{r7}
 8021188: b083         	sub	sp, #0xc
 802118a: af00         	add	r7, sp, #0x0
 802118c: 6078         	str	r0, [r7, #0x4]
; 	return CONTAINER_OF(work, struct k_work_delayable, work);
 802118e: 687b         	ldr	r3, [r7, #0x4]
; }
 8021190: 4618         	mov	r0, r3
 8021192: 370c         	adds	r7, #0xc
 8021194: 46bd         	mov	sp, r7
 8021196: f85d 7b04    	ldr	r7, [sp], #4
 802119a: 4770         	bx	lr

0802119c <clock_control_on>:
; {
 802119c: b580         	push	{r7, lr}
 802119e: b084         	sub	sp, #0x10
 80211a0: af00         	add	r7, sp, #0x0
 80211a2: 6078         	str	r0, [r7, #0x4]
 80211a4: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 80211a6: 687b         	ldr	r3, [r7, #0x4]
 80211a8: 689b         	ldr	r3, [r3, #0x8]
 80211aa: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 80211ac: 68fb         	ldr	r3, [r7, #0xc]
 80211ae: 681b         	ldr	r3, [r3]
 80211b0: 6839         	ldr	r1, [r7]
 80211b2: 6878         	ldr	r0, [r7, #0x4]
 80211b4: 4798         	blx	r3
 80211b6: 4603         	mov	r3, r0
; }
 80211b8: 4618         	mov	r0, r3
 80211ba: 3710         	adds	r7, #0x10
 80211bc: 46bd         	mov	sp, r7
 80211be: bd80         	pop	{r7, pc}

080211c0 <clock_control_get_rate>:
; {
 80211c0: b580         	push	{r7, lr}
 80211c2: b086         	sub	sp, #0x18
 80211c4: af00         	add	r7, sp, #0x0
 80211c6: 60f8         	str	r0, [r7, #0xc]
 80211c8: 60b9         	str	r1, [r7, #0x8]
 80211ca: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 80211cc: 68fb         	ldr	r3, [r7, #0xc]
 80211ce: 689b         	ldr	r3, [r3, #0x8]
 80211d0: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 80211d2: 697b         	ldr	r3, [r7, #0x14]
 80211d4: 68db         	ldr	r3, [r3, #0xc]
 80211d6: 2b00         	cmp	r3, #0x0
 80211d8: d102         	bne	0x80211e0 <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 80211da: f06f 0357    	mvn	r3, #0x57
 80211de: e006         	b	0x80211ee <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 80211e0: 697b         	ldr	r3, [r7, #0x14]
 80211e2: 68db         	ldr	r3, [r3, #0xc]
 80211e4: 687a         	ldr	r2, [r7, #0x4]
 80211e6: 68b9         	ldr	r1, [r7, #0x8]
 80211e8: 68f8         	ldr	r0, [r7, #0xc]
 80211ea: 4798         	blx	r3
 80211ec: 4603         	mov	r3, r0
; }
 80211ee: 4618         	mov	r0, r3
 80211f0: 3718         	adds	r7, #0x18
 80211f2: 46bd         	mov	sp, r7
 80211f4: bd80         	pop	{r7, pc}

080211f6 <dma_config>:
; {
 80211f6: b580         	push	{r7, lr}
 80211f8: b086         	sub	sp, #0x18
 80211fa: af00         	add	r7, sp, #0x0
 80211fc: 60f8         	str	r0, [r7, #0xc]
 80211fe: 60b9         	str	r1, [r7, #0x8]
 8021200: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 8021202: 68fb         	ldr	r3, [r7, #0xc]
 8021204: 689b         	ldr	r3, [r3, #0x8]
 8021206: 617b         	str	r3, [r7, #0x14]
; 	return api->config(dev, channel, config);
 8021208: 697b         	ldr	r3, [r7, #0x14]
 802120a: 681b         	ldr	r3, [r3]
 802120c: 687a         	ldr	r2, [r7, #0x4]
 802120e: 68b9         	ldr	r1, [r7, #0x8]
 8021210: 68f8         	ldr	r0, [r7, #0xc]
 8021212: 4798         	blx	r3
 8021214: 4603         	mov	r3, r0
; }
 8021216: 4618         	mov	r0, r3
 8021218: 3718         	adds	r7, #0x18
 802121a: 46bd         	mov	sp, r7
 802121c: bd80         	pop	{r7, pc}

0802121e <dma_reload>:
; {
 802121e: b590         	push	{r4, r7, lr}
 8021220: b089         	sub	sp, #0x24
 8021222: af02         	add	r7, sp, #0x8
 8021224: 60f8         	str	r0, [r7, #0xc]
 8021226: 60b9         	str	r1, [r7, #0x8]
 8021228: 607a         	str	r2, [r7, #0x4]
 802122a: 603b         	str	r3, [r7]
; 	const struct dma_driver_api *api =
 802122c: 68fb         	ldr	r3, [r7, #0xc]
 802122e: 689b         	ldr	r3, [r3, #0x8]
 8021230: 617b         	str	r3, [r7, #0x14]
; 	if (api->reload) {
 8021232: 697b         	ldr	r3, [r7, #0x14]
 8021234: 685b         	ldr	r3, [r3, #0x4]
 8021236: 2b00         	cmp	r3, #0x0
 8021238: d00a         	beq	0x8021250 <dma_reload+0x32> @ imm = #0x14
; 		return api->reload(dev, channel, src, dst, size);
 802123a: 697b         	ldr	r3, [r7, #0x14]
 802123c: 685c         	ldr	r4, [r3, #0x4]
 802123e: 6abb         	ldr	r3, [r7, #0x28]
 8021240: 9300         	str	r3, [sp]
 8021242: 683b         	ldr	r3, [r7]
 8021244: 687a         	ldr	r2, [r7, #0x4]
 8021246: 68b9         	ldr	r1, [r7, #0x8]
 8021248: 68f8         	ldr	r0, [r7, #0xc]
 802124a: 47a0         	blx	r4
 802124c: 4603         	mov	r3, r0
 802124e: e001         	b	0x8021254 <dma_reload+0x36> @ imm = #0x2
; 	return -ENOSYS;
 8021250: f06f 0357    	mvn	r3, #0x57
; }
 8021254: 4618         	mov	r0, r3
 8021256: 371c         	adds	r7, #0x1c
 8021258: 46bd         	mov	sp, r7
 802125a: bd90         	pop	{r4, r7, pc}

0802125c <z_impl_dma_start>:
; {
 802125c: b580         	push	{r7, lr}
 802125e: b084         	sub	sp, #0x10
 8021260: af00         	add	r7, sp, #0x0
 8021262: 6078         	str	r0, [r7, #0x4]
 8021264: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 8021266: 687b         	ldr	r3, [r7, #0x4]
 8021268: 689b         	ldr	r3, [r3, #0x8]
 802126a: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev, channel);
 802126c: 68fb         	ldr	r3, [r7, #0xc]
 802126e: 689b         	ldr	r3, [r3, #0x8]
 8021270: 6839         	ldr	r1, [r7]
 8021272: 6878         	ldr	r0, [r7, #0x4]
 8021274: 4798         	blx	r3
 8021276: 4603         	mov	r3, r0
; }
 8021278: 4618         	mov	r0, r3
 802127a: 3710         	adds	r7, #0x10
 802127c: 46bd         	mov	sp, r7
 802127e: bd80         	pop	{r7, pc}

08021280 <z_impl_dma_stop>:
; {
 8021280: b580         	push	{r7, lr}
 8021282: b084         	sub	sp, #0x10
 8021284: af00         	add	r7, sp, #0x0
 8021286: 6078         	str	r0, [r7, #0x4]
 8021288: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 802128a: 687b         	ldr	r3, [r7, #0x4]
 802128c: 689b         	ldr	r3, [r3, #0x8]
 802128e: 60fb         	str	r3, [r7, #0xc]
; 	return api->stop(dev, channel);
 8021290: 68fb         	ldr	r3, [r7, #0xc]
 8021292: 68db         	ldr	r3, [r3, #0xc]
 8021294: 6839         	ldr	r1, [r7]
 8021296: 6878         	ldr	r0, [r7, #0x4]
 8021298: 4798         	blx	r3
 802129a: 4603         	mov	r3, r0
; }
 802129c: 4618         	mov	r0, r3
 802129e: 3710         	adds	r7, #0x10
 80212a0: 46bd         	mov	sp, r7
 80212a2: bd80         	pop	{r7, pc}

080212a4 <dma_get_status>:
; {
 80212a4: b580         	push	{r7, lr}
 80212a6: b086         	sub	sp, #0x18
 80212a8: af00         	add	r7, sp, #0x0
 80212aa: 60f8         	str	r0, [r7, #0xc]
 80212ac: 60b9         	str	r1, [r7, #0x8]
 80212ae: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 80212b0: 68fb         	ldr	r3, [r7, #0xc]
 80212b2: 689b         	ldr	r3, [r3, #0x8]
 80212b4: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_status) {
 80212b6: 697b         	ldr	r3, [r7, #0x14]
 80212b8: 699b         	ldr	r3, [r3, #0x18]
 80212ba: 2b00         	cmp	r3, #0x0
 80212bc: d007         	beq	0x80212ce <dma_get_status+0x2a> @ imm = #0xe
; 		return api->get_status(dev, channel, stat);
 80212be: 697b         	ldr	r3, [r7, #0x14]
 80212c0: 699b         	ldr	r3, [r3, #0x18]
 80212c2: 687a         	ldr	r2, [r7, #0x4]
 80212c4: 68b9         	ldr	r1, [r7, #0x8]
 80212c6: 68f8         	ldr	r0, [r7, #0xc]
 80212c8: 4798         	blx	r3
 80212ca: 4603         	mov	r3, r0
 80212cc: e001         	b	0x80212d2 <dma_get_status+0x2e> @ imm = #0x2
; 	return -ENOSYS;
 80212ce: f06f 0357    	mvn	r3, #0x57
; }
 80212d2: 4618         	mov	r0, r3
 80212d4: 3718         	adds	r7, #0x18
 80212d6: 46bd         	mov	sp, r7
 80212d8: bd80         	pop	{r7, pc}

080212da <dma_start>:
; {
 80212da: b580         	push	{r7, lr}
 80212dc: b082         	sub	sp, #0x8
 80212de: af00         	add	r7, sp, #0x0
 80212e0: 6078         	str	r0, [r7, #0x4]
 80212e2: 6039         	str	r1, [r7]
; 	return z_impl_dma_start(dev, channel);
 80212e4: 6839         	ldr	r1, [r7]
 80212e6: 6878         	ldr	r0, [r7, #0x4]
 80212e8: f7ff ffb8    	bl	0x802125c <z_impl_dma_start> @ imm = #-0x90
 80212ec: 4603         	mov	r3, r0
; }
 80212ee: 4618         	mov	r0, r3
 80212f0: 3708         	adds	r7, #0x8
 80212f2: 46bd         	mov	sp, r7
 80212f4: bd80         	pop	{r7, pc}

080212f6 <dma_stop>:
; {
 80212f6: b580         	push	{r7, lr}
 80212f8: b082         	sub	sp, #0x8
 80212fa: af00         	add	r7, sp, #0x0
 80212fc: 6078         	str	r0, [r7, #0x4]
 80212fe: 6039         	str	r1, [r7]
; 	return z_impl_dma_stop(dev, channel);
 8021300: 6839         	ldr	r1, [r7]
 8021302: 6878         	ldr	r0, [r7, #0x4]
 8021304: f7ff ffbc    	bl	0x8021280 <z_impl_dma_stop> @ imm = #-0x88
 8021308: 4603         	mov	r3, r0
; }
 802130a: 4618         	mov	r0, r3
 802130c: 3708         	adds	r7, #0x8
 802130e: 46bd         	mov	sp, r7
 8021310: bd80         	pop	{r7, pc}

08021312 <pinctrl_apply_state_direct>:
; {
 8021312: b580         	push	{r7, lr}
 8021314: b084         	sub	sp, #0x10
 8021316: af00         	add	r7, sp, #0x0
 8021318: 6078         	str	r0, [r7, #0x4]
 802131a: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 802131c: 2300         	movs	r3, #0x0
 802131e: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 8021320: 683b         	ldr	r3, [r7]
 8021322: 6818         	ldr	r0, [r3]
 8021324: 683b         	ldr	r3, [r7]
 8021326: 791b         	ldrb	r3, [r3, #0x4]
 8021328: 68fa         	ldr	r2, [r7, #0xc]
 802132a: 4619         	mov	r1, r3
 802132c: f7fe fd3f    	bl	0x801fdae <pinctrl_configure_pins> @ imm = #-0x1582
 8021330: 4603         	mov	r3, r0
; }
 8021332: 4618         	mov	r0, r3
 8021334: 3710         	adds	r7, #0x10
 8021336: 46bd         	mov	sp, r7
 8021338: bd80         	pop	{r7, pc}

0802133a <pinctrl_apply_state>:
; {
 802133a: b580         	push	{r7, lr}
 802133c: b084         	sub	sp, #0x10
 802133e: af00         	add	r7, sp, #0x0
 8021340: 6078         	str	r0, [r7, #0x4]
 8021342: 460b         	mov	r3, r1
 8021344: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 8021346: f107 0208    	add.w	r2, r7, #0x8
 802134a: 78fb         	ldrb	r3, [r7, #0x3]
 802134c: 4619         	mov	r1, r3
 802134e: 6878         	ldr	r0, [r7, #0x4]
 8021350: f7fe fcf5    	bl	0x801fd3e <pinctrl_lookup_state> @ imm = #-0x1616
 8021354: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8021356: 68fb         	ldr	r3, [r7, #0xc]
 8021358: 2b00         	cmp	r3, #0x0
 802135a: da01         	bge	0x8021360 <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 802135c: 68fb         	ldr	r3, [r7, #0xc]
 802135e: e005         	b	0x802136c <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 8021360: 68bb         	ldr	r3, [r7, #0x8]
 8021362: 4619         	mov	r1, r3
 8021364: 6878         	ldr	r0, [r7, #0x4]
 8021366: f7ff ffd4    	bl	0x8021312 <pinctrl_apply_state_direct> @ imm = #-0x58
 802136a: 4603         	mov	r3, r0
; }
 802136c: 4618         	mov	r0, r3
 802136e: 3710         	adds	r7, #0x10
 8021370: 46bd         	mov	sp, r7
 8021372: bd80         	pop	{r7, pc}

08021374 <z_impl_reset_line_toggle>:
; {
 8021374: b580         	push	{r7, lr}
 8021376: b084         	sub	sp, #0x10
 8021378: af00         	add	r7, sp, #0x0
 802137a: 6078         	str	r0, [r7, #0x4]
 802137c: 6039         	str	r1, [r7]
; 	const struct reset_driver_api *api = (const struct reset_driver_api *)dev->api;
 802137e: 687b         	ldr	r3, [r7, #0x4]
 8021380: 689b         	ldr	r3, [r3, #0x8]
 8021382: 60fb         	str	r3, [r7, #0xc]
; 	if (api->line_toggle == NULL) {
 8021384: 68fb         	ldr	r3, [r7, #0xc]
 8021386: 68db         	ldr	r3, [r3, #0xc]
 8021388: 2b00         	cmp	r3, #0x0
 802138a: d102         	bne	0x8021392 <z_impl_reset_line_toggle+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 802138c: f06f 0357    	mvn	r3, #0x57
 8021390: e005         	b	0x802139e <z_impl_reset_line_toggle+0x2a> @ imm = #0xa
; 	return api->line_toggle(dev, id);
 8021392: 68fb         	ldr	r3, [r7, #0xc]
 8021394: 68db         	ldr	r3, [r3, #0xc]
 8021396: 6839         	ldr	r1, [r7]
 8021398: 6878         	ldr	r0, [r7, #0x4]
 802139a: 4798         	blx	r3
 802139c: 4603         	mov	r3, r0
; }
 802139e: 4618         	mov	r0, r3
 80213a0: 3710         	adds	r7, #0x10
 80213a2: 46bd         	mov	sp, r7
 80213a4: bd80         	pop	{r7, pc}

080213a6 <reset_line_toggle_dt>:
; {
 80213a6: b580         	push	{r7, lr}
 80213a8: b082         	sub	sp, #0x8
 80213aa: af00         	add	r7, sp, #0x0
 80213ac: 6078         	str	r0, [r7, #0x4]
; 	return reset_line_toggle(spec->dev, spec->id);
 80213ae: 687b         	ldr	r3, [r7, #0x4]
 80213b0: 681a         	ldr	r2, [r3]
 80213b2: 687b         	ldr	r3, [r7, #0x4]
 80213b4: 685b         	ldr	r3, [r3, #0x4]
 80213b6: 4619         	mov	r1, r3
 80213b8: 4610         	mov	r0, r2
 80213ba: f000 f805    	bl	0x80213c8 <reset_line_toggle> @ imm = #0xa
 80213be: 4603         	mov	r3, r0
; }
 80213c0: 4618         	mov	r0, r3
 80213c2: 3708         	adds	r7, #0x8
 80213c4: 46bd         	mov	sp, r7
 80213c6: bd80         	pop	{r7, pc}

080213c8 <reset_line_toggle>:
; {
 80213c8: b580         	push	{r7, lr}
 80213ca: b082         	sub	sp, #0x8
 80213cc: af00         	add	r7, sp, #0x0
 80213ce: 6078         	str	r0, [r7, #0x4]
 80213d0: 6039         	str	r1, [r7]
; 	return z_impl_reset_line_toggle(dev, id);
 80213d2: 6839         	ldr	r1, [r7]
 80213d4: 6878         	ldr	r0, [r7, #0x4]
 80213d6: f7ff ffcd    	bl	0x8021374 <z_impl_reset_line_toggle> @ imm = #-0x66
 80213da: 4603         	mov	r3, r0
; }
 80213dc: 4618         	mov	r0, r3
 80213de: 3708         	adds	r7, #0x8
 80213e0: 46bd         	mov	sp, r7
 80213e2: bd80         	pop	{r7, pc}

080213e4 <LL_USART_Enable>:
; {
 80213e4: b480         	push	{r7}
 80213e6: b083         	sub	sp, #0xc
 80213e8: af00         	add	r7, sp, #0x0
 80213ea: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR1, USART_CR1_UE);
 80213ec: 687b         	ldr	r3, [r7, #0x4]
 80213ee: 68db         	ldr	r3, [r3, #0xc]
 80213f0: f443 5200    	orr	r2, r3, #0x2000
 80213f4: 687b         	ldr	r3, [r7, #0x4]
 80213f6: 60da         	str	r2, [r3, #0xc]
; }
 80213f8: bf00         	nop
 80213fa: 370c         	adds	r7, #0xc
 80213fc: 46bd         	mov	sp, r7
 80213fe: f85d 7b04    	ldr	r7, [sp], #4
 8021402: 4770         	bx	lr

08021404 <LL_USART_Disable>:
; {
 8021404: b480         	push	{r7}
 8021406: b083         	sub	sp, #0xc
 8021408: af00         	add	r7, sp, #0x0
 802140a: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
 802140c: 687b         	ldr	r3, [r7, #0x4]
 802140e: 68db         	ldr	r3, [r3, #0xc]
 8021410: f423 5200    	bic	r2, r3, #0x2000
 8021414: 687b         	ldr	r3, [r7, #0x4]
 8021416: 60da         	str	r2, [r3, #0xc]
; }
 8021418: bf00         	nop
 802141a: 370c         	adds	r7, #0xc
 802141c: 46bd         	mov	sp, r7
 802141e: f85d 7b04    	ldr	r7, [sp], #4
 8021422: 4770         	bx	lr

08021424 <LL_USART_SetTransferDirection>:
; {
 8021424: b480         	push	{r7}
 8021426: b089         	sub	sp, #0x24
 8021428: af00         	add	r7, sp, #0x0
 802142a: 6078         	str	r0, [r7, #0x4]
 802142c: 6039         	str	r1, [r7]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 802142e: 687b         	ldr	r3, [r7, #0x4]
 8021430: 330c         	adds	r3, #0xc
 8021432: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8021434: 68fb         	ldr	r3, [r7, #0xc]
 8021436: e853 3f00    	ldrex	r3, [r3]
 802143a: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 802143c: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 802143e: f023 030c    	bic	r3, r3, #0xc
 8021442: 683a         	ldr	r2, [r7]
 8021444: 4313         	orrs	r3, r2
 8021446: 61fb         	str	r3, [r7, #0x1c]
 8021448: 687b         	ldr	r3, [r7, #0x4]
 802144a: 330c         	adds	r3, #0xc
 802144c: 69fa         	ldr	r2, [r7, #0x1c]
 802144e: 61ba         	str	r2, [r7, #0x18]
 8021450: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021452: 6979         	ldr	r1, [r7, #0x14]
 8021454: 69ba         	ldr	r2, [r7, #0x18]
 8021456: e841 2300    	strex	r3, r2, [r1]
 802145a: 613b         	str	r3, [r7, #0x10]
;    return(result);
 802145c: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 802145e: 2b00         	cmp	r3, #0x0
 8021460: d1e5         	bne	0x802142e <LL_USART_SetTransferDirection+0xa> @ imm = #-0x36
; }
 8021462: bf00         	nop
 8021464: bf00         	nop
 8021466: 3724         	adds	r7, #0x24
 8021468: 46bd         	mov	sp, r7
 802146a: f85d 7b04    	ldr	r7, [sp], #4
 802146e: 4770         	bx	lr

08021470 <LL_USART_SetParity>:
; {
 8021470: b480         	push	{r7}
 8021472: b083         	sub	sp, #0xc
 8021474: af00         	add	r7, sp, #0x0
 8021476: 6078         	str	r0, [r7, #0x4]
 8021478: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
 802147a: 687b         	ldr	r3, [r7, #0x4]
 802147c: 68db         	ldr	r3, [r3, #0xc]
 802147e: f423 62c0    	bic	r2, r3, #0x600
 8021482: 683b         	ldr	r3, [r7]
 8021484: 431a         	orrs	r2, r3
 8021486: 687b         	ldr	r3, [r7, #0x4]
 8021488: 60da         	str	r2, [r3, #0xc]
; }
 802148a: bf00         	nop
 802148c: 370c         	adds	r7, #0xc
 802148e: 46bd         	mov	sp, r7
 8021490: f85d 7b04    	ldr	r7, [sp], #4
 8021494: 4770         	bx	lr

08021496 <LL_USART_GetParity>:
; {
 8021496: b480         	push	{r7}
 8021498: b083         	sub	sp, #0xc
 802149a: af00         	add	r7, sp, #0x0
 802149c: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
 802149e: 687b         	ldr	r3, [r7, #0x4]
 80214a0: 68db         	ldr	r3, [r3, #0xc]
 80214a2: f403 63c0    	and	r3, r3, #0x600
; }
 80214a6: 4618         	mov	r0, r3
 80214a8: 370c         	adds	r7, #0xc
 80214aa: 46bd         	mov	sp, r7
 80214ac: f85d 7b04    	ldr	r7, [sp], #4
 80214b0: 4770         	bx	lr

080214b2 <LL_USART_SetDataWidth>:
; {
 80214b2: b480         	push	{r7}
 80214b4: b083         	sub	sp, #0xc
 80214b6: af00         	add	r7, sp, #0x0
 80214b8: 6078         	str	r0, [r7, #0x4]
 80214ba: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
 80214bc: 687b         	ldr	r3, [r7, #0x4]
 80214be: 68db         	ldr	r3, [r3, #0xc]
 80214c0: f423 5280    	bic	r2, r3, #0x1000
 80214c4: 683b         	ldr	r3, [r7]
 80214c6: 431a         	orrs	r2, r3
 80214c8: 687b         	ldr	r3, [r7, #0x4]
 80214ca: 60da         	str	r2, [r3, #0xc]
; }
 80214cc: bf00         	nop
 80214ce: 370c         	adds	r7, #0xc
 80214d0: 46bd         	mov	sp, r7
 80214d2: f85d 7b04    	ldr	r7, [sp], #4
 80214d6: 4770         	bx	lr

080214d8 <LL_USART_GetDataWidth>:
; {
 80214d8: b480         	push	{r7}
 80214da: b083         	sub	sp, #0xc
 80214dc: af00         	add	r7, sp, #0x0
 80214de: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
 80214e0: 687b         	ldr	r3, [r7, #0x4]
 80214e2: 68db         	ldr	r3, [r3, #0xc]
 80214e4: f403 5380    	and	r3, r3, #0x1000
; }
 80214e8: 4618         	mov	r0, r3
 80214ea: 370c         	adds	r7, #0xc
 80214ec: 46bd         	mov	sp, r7
 80214ee: f85d 7b04    	ldr	r7, [sp], #4
 80214f2: 4770         	bx	lr

080214f4 <LL_USART_SetOverSampling>:
; {
 80214f4: b480         	push	{r7}
 80214f6: b083         	sub	sp, #0xc
 80214f8: af00         	add	r7, sp, #0x0
 80214fa: 6078         	str	r0, [r7, #0x4]
 80214fc: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
 80214fe: 687b         	ldr	r3, [r7, #0x4]
 8021500: 68db         	ldr	r3, [r3, #0xc]
 8021502: f423 4200    	bic	r2, r3, #0x8000
 8021506: 683b         	ldr	r3, [r7]
 8021508: 431a         	orrs	r2, r3
 802150a: 687b         	ldr	r3, [r7, #0x4]
 802150c: 60da         	str	r2, [r3, #0xc]
; }
 802150e: bf00         	nop
 8021510: 370c         	adds	r7, #0xc
 8021512: 46bd         	mov	sp, r7
 8021514: f85d 7b04    	ldr	r7, [sp], #4
 8021518: 4770         	bx	lr

0802151a <LL_USART_SetStopBitsLength>:
; {
 802151a: b480         	push	{r7}
 802151c: b083         	sub	sp, #0xc
 802151e: af00         	add	r7, sp, #0x0
 8021520: 6078         	str	r0, [r7, #0x4]
 8021522: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8021524: 687b         	ldr	r3, [r7, #0x4]
 8021526: 691b         	ldr	r3, [r3, #0x10]
 8021528: f423 5240    	bic	r2, r3, #0x3000
 802152c: 683b         	ldr	r3, [r7]
 802152e: 431a         	orrs	r2, r3
 8021530: 687b         	ldr	r3, [r7, #0x4]
 8021532: 611a         	str	r2, [r3, #0x10]
; }
 8021534: bf00         	nop
 8021536: 370c         	adds	r7, #0xc
 8021538: 46bd         	mov	sp, r7
 802153a: f85d 7b04    	ldr	r7, [sp], #4
 802153e: 4770         	bx	lr

08021540 <LL_USART_GetStopBitsLength>:
; {
 8021540: b480         	push	{r7}
 8021542: b083         	sub	sp, #0xc
 8021544: af00         	add	r7, sp, #0x0
 8021546: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
 8021548: 687b         	ldr	r3, [r7, #0x4]
 802154a: 691b         	ldr	r3, [r3, #0x10]
 802154c: f403 5340    	and	r3, r3, #0x3000
; }
 8021550: 4618         	mov	r0, r3
 8021552: 370c         	adds	r7, #0xc
 8021554: 46bd         	mov	sp, r7
 8021556: f85d 7b04    	ldr	r7, [sp], #4
 802155a: 4770         	bx	lr

0802155c <LL_USART_ConfigCharacter>:
; {
 802155c: b480         	push	{r7}
 802155e: b085         	sub	sp, #0x14
 8021560: af00         	add	r7, sp, #0x0
 8021562: 60f8         	str	r0, [r7, #0xc]
 8021564: 60b9         	str	r1, [r7, #0x8]
 8021566: 607a         	str	r2, [r7, #0x4]
 8021568: 603b         	str	r3, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
 802156a: 68fb         	ldr	r3, [r7, #0xc]
 802156c: 68db         	ldr	r3, [r3, #0xc]
 802156e: f423 52b0    	bic	r2, r3, #0x1600
 8021572: 6879         	ldr	r1, [r7, #0x4]
 8021574: 68bb         	ldr	r3, [r7, #0x8]
 8021576: 430b         	orrs	r3, r1
 8021578: 431a         	orrs	r2, r3
 802157a: 68fb         	ldr	r3, [r7, #0xc]
 802157c: 60da         	str	r2, [r3, #0xc]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 802157e: 68fb         	ldr	r3, [r7, #0xc]
 8021580: 691b         	ldr	r3, [r3, #0x10]
 8021582: f423 5240    	bic	r2, r3, #0x3000
 8021586: 683b         	ldr	r3, [r7]
 8021588: 431a         	orrs	r2, r3
 802158a: 68fb         	ldr	r3, [r7, #0xc]
 802158c: 611a         	str	r2, [r3, #0x10]
; }
 802158e: bf00         	nop
 8021590: 3714         	adds	r7, #0x14
 8021592: 46bd         	mov	sp, r7
 8021594: f85d 7b04    	ldr	r7, [sp], #4
 8021598: 4770         	bx	lr

0802159a <LL_USART_SetHWFlowCtrl>:
; {
 802159a: b480         	push	{r7}
 802159c: b083         	sub	sp, #0xc
 802159e: af00         	add	r7, sp, #0x0
 80215a0: 6078         	str	r0, [r7, #0x4]
 80215a2: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 80215a4: 687b         	ldr	r3, [r7, #0x4]
 80215a6: 695b         	ldr	r3, [r3, #0x14]
 80215a8: f423 7240    	bic	r2, r3, #0x300
 80215ac: 683b         	ldr	r3, [r7]
 80215ae: 431a         	orrs	r2, r3
 80215b0: 687b         	ldr	r3, [r7, #0x4]
 80215b2: 615a         	str	r2, [r3, #0x14]
; }
 80215b4: bf00         	nop
 80215b6: 370c         	adds	r7, #0xc
 80215b8: 46bd         	mov	sp, r7
 80215ba: f85d 7b04    	ldr	r7, [sp], #4
 80215be: 4770         	bx	lr

080215c0 <LL_USART_GetHWFlowCtrl>:
; {
 80215c0: b480         	push	{r7}
 80215c2: b083         	sub	sp, #0xc
 80215c4: af00         	add	r7, sp, #0x0
 80215c6: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
 80215c8: 687b         	ldr	r3, [r7, #0x4]
 80215ca: 695b         	ldr	r3, [r3, #0x14]
 80215cc: f403 7340    	and	r3, r3, #0x300
; }
 80215d0: 4618         	mov	r0, r3
 80215d2: 370c         	adds	r7, #0xc
 80215d4: 46bd         	mov	sp, r7
 80215d6: f85d 7b04    	ldr	r7, [sp], #4
 80215da: 4770         	bx	lr

080215dc <LL_USART_EnableHalfDuplex>:
; {
 80215dc: b480         	push	{r7}
 80215de: b083         	sub	sp, #0xc
 80215e0: af00         	add	r7, sp, #0x0
 80215e2: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
 80215e4: 687b         	ldr	r3, [r7, #0x4]
 80215e6: 695b         	ldr	r3, [r3, #0x14]
 80215e8: f043 0208    	orr	r2, r3, #0x8
 80215ec: 687b         	ldr	r3, [r7, #0x4]
 80215ee: 615a         	str	r2, [r3, #0x14]
; }
 80215f0: bf00         	nop
 80215f2: 370c         	adds	r7, #0xc
 80215f4: 46bd         	mov	sp, r7
 80215f6: f85d 7b04    	ldr	r7, [sp], #4
 80215fa: 4770         	bx	lr

080215fc <LL_USART_IsActiveFlag_PE>:
; {
 80215fc: b480         	push	{r7}
 80215fe: b083         	sub	sp, #0xc
 8021600: af00         	add	r7, sp, #0x0
 8021602: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_PE) == (USART_SR_PE));
 8021604: 687b         	ldr	r3, [r7, #0x4]
 8021606: 681b         	ldr	r3, [r3]
 8021608: f003 0301    	and	r3, r3, #0x1
 802160c: 2b01         	cmp	r3, #0x1
 802160e: bf0c         	ite	eq
 8021610: 2301         	moveq	r3, #0x1
 8021612: 2300         	movne	r3, #0x0
 8021614: b2db         	uxtb	r3, r3
; }
 8021616: 4618         	mov	r0, r3
 8021618: 370c         	adds	r7, #0xc
 802161a: 46bd         	mov	sp, r7
 802161c: f85d 7b04    	ldr	r7, [sp], #4
 8021620: 4770         	bx	lr

08021622 <LL_USART_IsActiveFlag_FE>:
; {
 8021622: b480         	push	{r7}
 8021624: b083         	sub	sp, #0xc
 8021626: af00         	add	r7, sp, #0x0
 8021628: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_FE) == (USART_SR_FE));
 802162a: 687b         	ldr	r3, [r7, #0x4]
 802162c: 681b         	ldr	r3, [r3]
 802162e: f003 0302    	and	r3, r3, #0x2
 8021632: 2b02         	cmp	r3, #0x2
 8021634: bf0c         	ite	eq
 8021636: 2301         	moveq	r3, #0x1
 8021638: 2300         	movne	r3, #0x0
 802163a: b2db         	uxtb	r3, r3
; }
 802163c: 4618         	mov	r0, r3
 802163e: 370c         	adds	r7, #0xc
 8021640: 46bd         	mov	sp, r7
 8021642: f85d 7b04    	ldr	r7, [sp], #4
 8021646: 4770         	bx	lr

08021648 <LL_USART_IsActiveFlag_NE>:
; {
 8021648: b480         	push	{r7}
 802164a: b083         	sub	sp, #0xc
 802164c: af00         	add	r7, sp, #0x0
 802164e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_NE) == (USART_SR_NE));
 8021650: 687b         	ldr	r3, [r7, #0x4]
 8021652: 681b         	ldr	r3, [r3]
 8021654: f003 0304    	and	r3, r3, #0x4
 8021658: 2b04         	cmp	r3, #0x4
 802165a: bf0c         	ite	eq
 802165c: 2301         	moveq	r3, #0x1
 802165e: 2300         	movne	r3, #0x0
 8021660: b2db         	uxtb	r3, r3
; }
 8021662: 4618         	mov	r0, r3
 8021664: 370c         	adds	r7, #0xc
 8021666: 46bd         	mov	sp, r7
 8021668: f85d 7b04    	ldr	r7, [sp], #4
 802166c: 4770         	bx	lr

0802166e <LL_USART_IsActiveFlag_ORE>:
; {
 802166e: b480         	push	{r7}
 8021670: b083         	sub	sp, #0xc
 8021672: af00         	add	r7, sp, #0x0
 8021674: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_ORE) == (USART_SR_ORE));
 8021676: 687b         	ldr	r3, [r7, #0x4]
 8021678: 681b         	ldr	r3, [r3]
 802167a: f003 0308    	and	r3, r3, #0x8
 802167e: 2b08         	cmp	r3, #0x8
 8021680: bf0c         	ite	eq
 8021682: 2301         	moveq	r3, #0x1
 8021684: 2300         	movne	r3, #0x0
 8021686: b2db         	uxtb	r3, r3
; }
 8021688: 4618         	mov	r0, r3
 802168a: 370c         	adds	r7, #0xc
 802168c: 46bd         	mov	sp, r7
 802168e: f85d 7b04    	ldr	r7, [sp], #4
 8021692: 4770         	bx	lr

08021694 <LL_USART_IsActiveFlag_IDLE>:
; {
 8021694: b480         	push	{r7}
 8021696: b083         	sub	sp, #0xc
 8021698: af00         	add	r7, sp, #0x0
 802169a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_IDLE) == (USART_SR_IDLE));
 802169c: 687b         	ldr	r3, [r7, #0x4]
 802169e: 681b         	ldr	r3, [r3]
 80216a0: f003 0310    	and	r3, r3, #0x10
 80216a4: 2b10         	cmp	r3, #0x10
 80216a6: bf0c         	ite	eq
 80216a8: 2301         	moveq	r3, #0x1
 80216aa: 2300         	movne	r3, #0x0
 80216ac: b2db         	uxtb	r3, r3
; }
 80216ae: 4618         	mov	r0, r3
 80216b0: 370c         	adds	r7, #0xc
 80216b2: 46bd         	mov	sp, r7
 80216b4: f85d 7b04    	ldr	r7, [sp], #4
 80216b8: 4770         	bx	lr

080216ba <LL_USART_IsActiveFlag_RXNE>:
; {
 80216ba: b480         	push	{r7}
 80216bc: b083         	sub	sp, #0xc
 80216be: af00         	add	r7, sp, #0x0
 80216c0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
 80216c2: 687b         	ldr	r3, [r7, #0x4]
 80216c4: 681b         	ldr	r3, [r3]
 80216c6: f003 0320    	and	r3, r3, #0x20
 80216ca: 2b20         	cmp	r3, #0x20
 80216cc: bf0c         	ite	eq
 80216ce: 2301         	moveq	r3, #0x1
 80216d0: 2300         	movne	r3, #0x0
 80216d2: b2db         	uxtb	r3, r3
; }
 80216d4: 4618         	mov	r0, r3
 80216d6: 370c         	adds	r7, #0xc
 80216d8: 46bd         	mov	sp, r7
 80216da: f85d 7b04    	ldr	r7, [sp], #4
 80216de: 4770         	bx	lr

080216e0 <LL_USART_IsActiveFlag_TC>:
; {
 80216e0: b480         	push	{r7}
 80216e2: b083         	sub	sp, #0xc
 80216e4: af00         	add	r7, sp, #0x0
 80216e6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_TC) == (USART_SR_TC));
 80216e8: 687b         	ldr	r3, [r7, #0x4]
 80216ea: 681b         	ldr	r3, [r3]
 80216ec: f003 0340    	and	r3, r3, #0x40
 80216f0: 2b40         	cmp	r3, #0x40
 80216f2: bf0c         	ite	eq
 80216f4: 2301         	moveq	r3, #0x1
 80216f6: 2300         	movne	r3, #0x0
 80216f8: b2db         	uxtb	r3, r3
; }
 80216fa: 4618         	mov	r0, r3
 80216fc: 370c         	adds	r7, #0xc
 80216fe: 46bd         	mov	sp, r7
 8021700: f85d 7b04    	ldr	r7, [sp], #4
 8021704: 4770         	bx	lr

08021706 <LL_USART_IsActiveFlag_TXE>:
; {
 8021706: b480         	push	{r7}
 8021708: b083         	sub	sp, #0xc
 802170a: af00         	add	r7, sp, #0x0
 802170c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_TXE) == (USART_SR_TXE));
 802170e: 687b         	ldr	r3, [r7, #0x4]
 8021710: 681b         	ldr	r3, [r3]
 8021712: f003 0380    	and	r3, r3, #0x80
 8021716: 2b80         	cmp	r3, #0x80
 8021718: bf0c         	ite	eq
 802171a: 2301         	moveq	r3, #0x1
 802171c: 2300         	movne	r3, #0x0
 802171e: b2db         	uxtb	r3, r3
; }
 8021720: 4618         	mov	r0, r3
 8021722: 370c         	adds	r7, #0xc
 8021724: 46bd         	mov	sp, r7
 8021726: f85d 7b04    	ldr	r7, [sp], #4
 802172a: 4770         	bx	lr

0802172c <LL_USART_IsActiveFlag_LBD>:
; {
 802172c: b480         	push	{r7}
 802172e: b083         	sub	sp, #0xc
 8021730: af00         	add	r7, sp, #0x0
 8021732: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_LBD) == (USART_SR_LBD));
 8021734: 687b         	ldr	r3, [r7, #0x4]
 8021736: 681b         	ldr	r3, [r3]
 8021738: f403 7380    	and	r3, r3, #0x100
 802173c: f5b3 7f80    	cmp.w	r3, #0x100
 8021740: bf0c         	ite	eq
 8021742: 2301         	moveq	r3, #0x1
 8021744: 2300         	movne	r3, #0x0
 8021746: b2db         	uxtb	r3, r3
; }
 8021748: 4618         	mov	r0, r3
 802174a: 370c         	adds	r7, #0xc
 802174c: 46bd         	mov	sp, r7
 802174e: f85d 7b04    	ldr	r7, [sp], #4
 8021752: 4770         	bx	lr

08021754 <LL_USART_ClearFlag_PE>:
; {
 8021754: b480         	push	{r7}
 8021756: b085         	sub	sp, #0x14
 8021758: af00         	add	r7, sp, #0x0
 802175a: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 802175c: 687b         	ldr	r3, [r7, #0x4]
 802175e: 681b         	ldr	r3, [r3]
 8021760: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8021762: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 8021764: 687b         	ldr	r3, [r7, #0x4]
 8021766: 685b         	ldr	r3, [r3, #0x4]
 8021768: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 802176a: 68fb         	ldr	r3, [r7, #0xc]
; }
 802176c: bf00         	nop
 802176e: 3714         	adds	r7, #0x14
 8021770: 46bd         	mov	sp, r7
 8021772: f85d 7b04    	ldr	r7, [sp], #4
 8021776: 4770         	bx	lr

08021778 <LL_USART_ClearFlag_FE>:
; {
 8021778: b480         	push	{r7}
 802177a: b085         	sub	sp, #0x14
 802177c: af00         	add	r7, sp, #0x0
 802177e: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8021780: 687b         	ldr	r3, [r7, #0x4]
 8021782: 681b         	ldr	r3, [r3]
 8021784: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8021786: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 8021788: 687b         	ldr	r3, [r7, #0x4]
 802178a: 685b         	ldr	r3, [r3, #0x4]
 802178c: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 802178e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8021790: bf00         	nop
 8021792: 3714         	adds	r7, #0x14
 8021794: 46bd         	mov	sp, r7
 8021796: f85d 7b04    	ldr	r7, [sp], #4
 802179a: 4770         	bx	lr

0802179c <LL_USART_ClearFlag_NE>:
; {
 802179c: b480         	push	{r7}
 802179e: b085         	sub	sp, #0x14
 80217a0: af00         	add	r7, sp, #0x0
 80217a2: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 80217a4: 687b         	ldr	r3, [r7, #0x4]
 80217a6: 681b         	ldr	r3, [r3]
 80217a8: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80217aa: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 80217ac: 687b         	ldr	r3, [r7, #0x4]
 80217ae: 685b         	ldr	r3, [r3, #0x4]
 80217b0: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80217b2: 68fb         	ldr	r3, [r7, #0xc]
; }
 80217b4: bf00         	nop
 80217b6: 3714         	adds	r7, #0x14
 80217b8: 46bd         	mov	sp, r7
 80217ba: f85d 7b04    	ldr	r7, [sp], #4
 80217be: 4770         	bx	lr

080217c0 <LL_USART_ClearFlag_ORE>:
; {
 80217c0: b480         	push	{r7}
 80217c2: b085         	sub	sp, #0x14
 80217c4: af00         	add	r7, sp, #0x0
 80217c6: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 80217c8: 687b         	ldr	r3, [r7, #0x4]
 80217ca: 681b         	ldr	r3, [r3]
 80217cc: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80217ce: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 80217d0: 687b         	ldr	r3, [r7, #0x4]
 80217d2: 685b         	ldr	r3, [r3, #0x4]
 80217d4: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80217d6: 68fb         	ldr	r3, [r7, #0xc]
; }
 80217d8: bf00         	nop
 80217da: 3714         	adds	r7, #0x14
 80217dc: 46bd         	mov	sp, r7
 80217de: f85d 7b04    	ldr	r7, [sp], #4
 80217e2: 4770         	bx	lr

080217e4 <LL_USART_ClearFlag_IDLE>:
; {
 80217e4: b480         	push	{r7}
 80217e6: b085         	sub	sp, #0x14
 80217e8: af00         	add	r7, sp, #0x0
 80217ea: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 80217ec: 687b         	ldr	r3, [r7, #0x4]
 80217ee: 681b         	ldr	r3, [r3]
 80217f0: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80217f2: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 80217f4: 687b         	ldr	r3, [r7, #0x4]
 80217f6: 685b         	ldr	r3, [r3, #0x4]
 80217f8: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80217fa: 68fb         	ldr	r3, [r7, #0xc]
; }
 80217fc: bf00         	nop
 80217fe: 3714         	adds	r7, #0x14
 8021800: 46bd         	mov	sp, r7
 8021802: f85d 7b04    	ldr	r7, [sp], #4
 8021806: 4770         	bx	lr

08021808 <LL_USART_ClearFlag_TC>:
; {
 8021808: b480         	push	{r7}
 802180a: b083         	sub	sp, #0xc
 802180c: af00         	add	r7, sp, #0x0
 802180e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_TC));
 8021810: 687b         	ldr	r3, [r7, #0x4]
 8021812: f06f 0240    	mvn	r2, #0x40
 8021816: 601a         	str	r2, [r3]
; }
 8021818: bf00         	nop
 802181a: 370c         	adds	r7, #0xc
 802181c: 46bd         	mov	sp, r7
 802181e: f85d 7b04    	ldr	r7, [sp], #4
 8021822: 4770         	bx	lr

08021824 <LL_USART_ClearFlag_RXNE>:
; {
 8021824: b480         	push	{r7}
 8021826: b083         	sub	sp, #0xc
 8021828: af00         	add	r7, sp, #0x0
 802182a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_RXNE));
 802182c: 687b         	ldr	r3, [r7, #0x4]
 802182e: f06f 0220    	mvn	r2, #0x20
 8021832: 601a         	str	r2, [r3]
; }
 8021834: bf00         	nop
 8021836: 370c         	adds	r7, #0xc
 8021838: 46bd         	mov	sp, r7
 802183a: f85d 7b04    	ldr	r7, [sp], #4
 802183e: 4770         	bx	lr

08021840 <LL_USART_ClearFlag_LBD>:
; {
 8021840: b480         	push	{r7}
 8021842: b083         	sub	sp, #0xc
 8021844: af00         	add	r7, sp, #0x0
 8021846: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_LBD));
 8021848: 687b         	ldr	r3, [r7, #0x4]
 802184a: f46f 7280    	mvn	r2, #0x100
 802184e: 601a         	str	r2, [r3]
; }
 8021850: bf00         	nop
 8021852: 370c         	adds	r7, #0xc
 8021854: 46bd         	mov	sp, r7
 8021856: f85d 7b04    	ldr	r7, [sp], #4
 802185a: 4770         	bx	lr

0802185c <LL_USART_EnableIT_IDLE>:
; {
 802185c: b480         	push	{r7}
 802185e: b089         	sub	sp, #0x24
 8021860: af00         	add	r7, sp, #0x0
 8021862: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8021864: 687b         	ldr	r3, [r7, #0x4]
 8021866: 330c         	adds	r3, #0xc
 8021868: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802186a: 68fb         	ldr	r3, [r7, #0xc]
 802186c: e853 3f00    	ldrex	r3, [r3]
 8021870: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8021872: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8021874: f043 0310    	orr	r3, r3, #0x10
 8021878: 61fb         	str	r3, [r7, #0x1c]
 802187a: 687b         	ldr	r3, [r7, #0x4]
 802187c: 330c         	adds	r3, #0xc
 802187e: 69fa         	ldr	r2, [r7, #0x1c]
 8021880: 61ba         	str	r2, [r7, #0x18]
 8021882: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021884: 6979         	ldr	r1, [r7, #0x14]
 8021886: 69ba         	ldr	r2, [r7, #0x18]
 8021888: e841 2300    	strex	r3, r2, [r1]
 802188c: 613b         	str	r3, [r7, #0x10]
;    return(result);
 802188e: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8021890: 2b00         	cmp	r3, #0x0
 8021892: d1e7         	bne	0x8021864 <LL_USART_EnableIT_IDLE+0x8> @ imm = #-0x32
; }
 8021894: bf00         	nop
 8021896: bf00         	nop
 8021898: 3724         	adds	r7, #0x24
 802189a: 46bd         	mov	sp, r7
 802189c: f85d 7b04    	ldr	r7, [sp], #4
 80218a0: 4770         	bx	lr

080218a2 <LL_USART_EnableIT_RXNE>:
; {
 80218a2: b480         	push	{r7}
 80218a4: b089         	sub	sp, #0x24
 80218a6: af00         	add	r7, sp, #0x0
 80218a8: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 80218aa: 687b         	ldr	r3, [r7, #0x4]
 80218ac: 330c         	adds	r3, #0xc
 80218ae: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80218b0: 68fb         	ldr	r3, [r7, #0xc]
 80218b2: e853 3f00    	ldrex	r3, [r3]
 80218b6: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80218b8: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 80218ba: f043 0320    	orr	r3, r3, #0x20
 80218be: 61fb         	str	r3, [r7, #0x1c]
 80218c0: 687b         	ldr	r3, [r7, #0x4]
 80218c2: 330c         	adds	r3, #0xc
 80218c4: 69fa         	ldr	r2, [r7, #0x1c]
 80218c6: 61ba         	str	r2, [r7, #0x18]
 80218c8: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80218ca: 6979         	ldr	r1, [r7, #0x14]
 80218cc: 69ba         	ldr	r2, [r7, #0x18]
 80218ce: e841 2300    	strex	r3, r2, [r1]
 80218d2: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80218d4: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 80218d6: 2b00         	cmp	r3, #0x0
 80218d8: d1e7         	bne	0x80218aa <LL_USART_EnableIT_RXNE+0x8> @ imm = #-0x32
; }
 80218da: bf00         	nop
 80218dc: bf00         	nop
 80218de: 3724         	adds	r7, #0x24
 80218e0: 46bd         	mov	sp, r7
 80218e2: f85d 7b04    	ldr	r7, [sp], #4
 80218e6: 4770         	bx	lr

080218e8 <LL_USART_EnableIT_TC>:
; {
 80218e8: b480         	push	{r7}
 80218ea: b089         	sub	sp, #0x24
 80218ec: af00         	add	r7, sp, #0x0
 80218ee: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 80218f0: 687b         	ldr	r3, [r7, #0x4]
 80218f2: 330c         	adds	r3, #0xc
 80218f4: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80218f6: 68fb         	ldr	r3, [r7, #0xc]
 80218f8: e853 3f00    	ldrex	r3, [r3]
 80218fc: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80218fe: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 8021900: f043 0340    	orr	r3, r3, #0x40
 8021904: 61fb         	str	r3, [r7, #0x1c]
 8021906: 687b         	ldr	r3, [r7, #0x4]
 8021908: 330c         	adds	r3, #0xc
 802190a: 69fa         	ldr	r2, [r7, #0x1c]
 802190c: 61ba         	str	r2, [r7, #0x18]
 802190e: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021910: 6979         	ldr	r1, [r7, #0x14]
 8021912: 69ba         	ldr	r2, [r7, #0x18]
 8021914: e841 2300    	strex	r3, r2, [r1]
 8021918: 613b         	str	r3, [r7, #0x10]
;    return(result);
 802191a: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 802191c: 2b00         	cmp	r3, #0x0
 802191e: d1e7         	bne	0x80218f0 <LL_USART_EnableIT_TC+0x8> @ imm = #-0x32
; }
 8021920: bf00         	nop
 8021922: bf00         	nop
 8021924: 3724         	adds	r7, #0x24
 8021926: 46bd         	mov	sp, r7
 8021928: f85d 7b04    	ldr	r7, [sp], #4
 802192c: 4770         	bx	lr

0802192e <LL_USART_EnableIT_PE>:
; {
 802192e: b480         	push	{r7}
 8021930: b089         	sub	sp, #0x24
 8021932: af00         	add	r7, sp, #0x0
 8021934: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 8021936: 687b         	ldr	r3, [r7, #0x4]
 8021938: 330c         	adds	r3, #0xc
 802193a: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 802193c: 68fb         	ldr	r3, [r7, #0xc]
 802193e: e853 3f00    	ldrex	r3, [r3]
 8021942: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8021944: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 8021946: f443 7380    	orr	r3, r3, #0x100
 802194a: 61fb         	str	r3, [r7, #0x1c]
 802194c: 687b         	ldr	r3, [r7, #0x4]
 802194e: 330c         	adds	r3, #0xc
 8021950: 69fa         	ldr	r2, [r7, #0x1c]
 8021952: 61ba         	str	r2, [r7, #0x18]
 8021954: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021956: 6979         	ldr	r1, [r7, #0x14]
 8021958: 69ba         	ldr	r2, [r7, #0x18]
 802195a: e841 2300    	strex	r3, r2, [r1]
 802195e: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8021960: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 8021962: 2b00         	cmp	r3, #0x0
 8021964: d1e7         	bne	0x8021936 <LL_USART_EnableIT_PE+0x8> @ imm = #-0x32
; }
 8021966: bf00         	nop
 8021968: bf00         	nop
 802196a: 3724         	adds	r7, #0x24
 802196c: 46bd         	mov	sp, r7
 802196e: f85d 7b04    	ldr	r7, [sp], #4
 8021972: 4770         	bx	lr

08021974 <LL_USART_EnableIT_LBD>:
; {
 8021974: b480         	push	{r7}
 8021976: b083         	sub	sp, #0xc
 8021978: af00         	add	r7, sp, #0x0
 802197a: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
 802197c: 687b         	ldr	r3, [r7, #0x4]
 802197e: 691b         	ldr	r3, [r3, #0x10]
 8021980: f043 0240    	orr	r2, r3, #0x40
 8021984: 687b         	ldr	r3, [r7, #0x4]
 8021986: 611a         	str	r2, [r3, #0x10]
; }
 8021988: bf00         	nop
 802198a: 370c         	adds	r7, #0xc
 802198c: 46bd         	mov	sp, r7
 802198e: f85d 7b04    	ldr	r7, [sp], #4
 8021992: 4770         	bx	lr

08021994 <LL_USART_EnableIT_ERROR>:
; {
 8021994: b480         	push	{r7}
 8021996: b089         	sub	sp, #0x24
 8021998: af00         	add	r7, sp, #0x0
 802199a: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 802199c: 687b         	ldr	r3, [r7, #0x4]
 802199e: 3314         	adds	r3, #0x14
 80219a0: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80219a2: 68fb         	ldr	r3, [r7, #0xc]
 80219a4: e853 3f00    	ldrex	r3, [r3]
 80219a8: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80219aa: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 80219ac: f043 0301    	orr	r3, r3, #0x1
 80219b0: 61fb         	str	r3, [r7, #0x1c]
 80219b2: 687b         	ldr	r3, [r7, #0x4]
 80219b4: 3314         	adds	r3, #0x14
 80219b6: 69fa         	ldr	r2, [r7, #0x1c]
 80219b8: 61ba         	str	r2, [r7, #0x18]
 80219ba: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80219bc: 6979         	ldr	r1, [r7, #0x14]
 80219be: 69ba         	ldr	r2, [r7, #0x18]
 80219c0: e841 2300    	strex	r3, r2, [r1]
 80219c4: 613b         	str	r3, [r7, #0x10]
;    return(result);
 80219c6: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 80219c8: 2b00         	cmp	r3, #0x0
 80219ca: d1e7         	bne	0x802199c <LL_USART_EnableIT_ERROR+0x8> @ imm = #-0x32
; }
 80219cc: bf00         	nop
 80219ce: bf00         	nop
 80219d0: 3724         	adds	r7, #0x24
 80219d2: 46bd         	mov	sp, r7
 80219d4: f85d 7b04    	ldr	r7, [sp], #4
 80219d8: 4770         	bx	lr

080219da <LL_USART_DisableIT_IDLE>:
; {
 80219da: b480         	push	{r7}
 80219dc: b089         	sub	sp, #0x24
 80219de: af00         	add	r7, sp, #0x0
 80219e0: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 80219e2: 687b         	ldr	r3, [r7, #0x4]
 80219e4: 330c         	adds	r3, #0xc
 80219e6: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80219e8: 68fb         	ldr	r3, [r7, #0xc]
 80219ea: e853 3f00    	ldrex	r3, [r3]
 80219ee: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 80219f0: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 80219f2: f023 0310    	bic	r3, r3, #0x10
 80219f6: 61fb         	str	r3, [r7, #0x1c]
 80219f8: 687b         	ldr	r3, [r7, #0x4]
 80219fa: 330c         	adds	r3, #0xc
 80219fc: 69fa         	ldr	r2, [r7, #0x1c]
 80219fe: 61ba         	str	r2, [r7, #0x18]
 8021a00: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021a02: 6979         	ldr	r1, [r7, #0x14]
 8021a04: 69ba         	ldr	r2, [r7, #0x18]
 8021a06: e841 2300    	strex	r3, r2, [r1]
 8021a0a: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8021a0c: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 8021a0e: 2b00         	cmp	r3, #0x0
 8021a10: d1e7         	bne	0x80219e2 <LL_USART_DisableIT_IDLE+0x8> @ imm = #-0x32
; }
 8021a12: bf00         	nop
 8021a14: bf00         	nop
 8021a16: 3724         	adds	r7, #0x24
 8021a18: 46bd         	mov	sp, r7
 8021a1a: f85d 7b04    	ldr	r7, [sp], #4
 8021a1e: 4770         	bx	lr

08021a20 <LL_USART_DisableIT_RXNE>:
; {
 8021a20: b480         	push	{r7}
 8021a22: b089         	sub	sp, #0x24
 8021a24: af00         	add	r7, sp, #0x0
 8021a26: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8021a28: 687b         	ldr	r3, [r7, #0x4]
 8021a2a: 330c         	adds	r3, #0xc
 8021a2c: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8021a2e: 68fb         	ldr	r3, [r7, #0xc]
 8021a30: e853 3f00    	ldrex	r3, [r3]
 8021a34: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8021a36: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8021a38: f023 0320    	bic	r3, r3, #0x20
 8021a3c: 61fb         	str	r3, [r7, #0x1c]
 8021a3e: 687b         	ldr	r3, [r7, #0x4]
 8021a40: 330c         	adds	r3, #0xc
 8021a42: 69fa         	ldr	r2, [r7, #0x1c]
 8021a44: 61ba         	str	r2, [r7, #0x18]
 8021a46: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021a48: 6979         	ldr	r1, [r7, #0x14]
 8021a4a: 69ba         	ldr	r2, [r7, #0x18]
 8021a4c: e841 2300    	strex	r3, r2, [r1]
 8021a50: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8021a52: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8021a54: 2b00         	cmp	r3, #0x0
 8021a56: d1e7         	bne	0x8021a28 <LL_USART_DisableIT_RXNE+0x8> @ imm = #-0x32
; }
 8021a58: bf00         	nop
 8021a5a: bf00         	nop
 8021a5c: 3724         	adds	r7, #0x24
 8021a5e: 46bd         	mov	sp, r7
 8021a60: f85d 7b04    	ldr	r7, [sp], #4
 8021a64: 4770         	bx	lr

08021a66 <LL_USART_DisableIT_TC>:
; {
 8021a66: b480         	push	{r7}
 8021a68: b089         	sub	sp, #0x24
 8021a6a: af00         	add	r7, sp, #0x0
 8021a6c: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8021a6e: 687b         	ldr	r3, [r7, #0x4]
 8021a70: 330c         	adds	r3, #0xc
 8021a72: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8021a74: 68fb         	ldr	r3, [r7, #0xc]
 8021a76: e853 3f00    	ldrex	r3, [r3]
 8021a7a: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8021a7c: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8021a7e: f023 0340    	bic	r3, r3, #0x40
 8021a82: 61fb         	str	r3, [r7, #0x1c]
 8021a84: 687b         	ldr	r3, [r7, #0x4]
 8021a86: 330c         	adds	r3, #0xc
 8021a88: 69fa         	ldr	r2, [r7, #0x1c]
 8021a8a: 61ba         	str	r2, [r7, #0x18]
 8021a8c: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021a8e: 6979         	ldr	r1, [r7, #0x14]
 8021a90: 69ba         	ldr	r2, [r7, #0x18]
 8021a92: e841 2300    	strex	r3, r2, [r1]
 8021a96: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8021a98: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 8021a9a: 2b00         	cmp	r3, #0x0
 8021a9c: d1e7         	bne	0x8021a6e <LL_USART_DisableIT_TC+0x8> @ imm = #-0x32
; }
 8021a9e: bf00         	nop
 8021aa0: bf00         	nop
 8021aa2: 3724         	adds	r7, #0x24
 8021aa4: 46bd         	mov	sp, r7
 8021aa6: f85d 7b04    	ldr	r7, [sp], #4
 8021aaa: 4770         	bx	lr

08021aac <LL_USART_DisableIT_PE>:
; {
 8021aac: b480         	push	{r7}
 8021aae: b089         	sub	sp, #0x24
 8021ab0: af00         	add	r7, sp, #0x0
 8021ab2: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 8021ab4: 687b         	ldr	r3, [r7, #0x4]
 8021ab6: 330c         	adds	r3, #0xc
 8021ab8: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8021aba: 68fb         	ldr	r3, [r7, #0xc]
 8021abc: e853 3f00    	ldrex	r3, [r3]
 8021ac0: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8021ac2: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 8021ac4: f423 7380    	bic	r3, r3, #0x100
 8021ac8: 61fb         	str	r3, [r7, #0x1c]
 8021aca: 687b         	ldr	r3, [r7, #0x4]
 8021acc: 330c         	adds	r3, #0xc
 8021ace: 69fa         	ldr	r2, [r7, #0x1c]
 8021ad0: 61ba         	str	r2, [r7, #0x18]
 8021ad2: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021ad4: 6979         	ldr	r1, [r7, #0x14]
 8021ad6: 69ba         	ldr	r2, [r7, #0x18]
 8021ad8: e841 2300    	strex	r3, r2, [r1]
 8021adc: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8021ade: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 8021ae0: 2b00         	cmp	r3, #0x0
 8021ae2: d1e7         	bne	0x8021ab4 <LL_USART_DisableIT_PE+0x8> @ imm = #-0x32
; }
 8021ae4: bf00         	nop
 8021ae6: bf00         	nop
 8021ae8: 3724         	adds	r7, #0x24
 8021aea: 46bd         	mov	sp, r7
 8021aec: f85d 7b04    	ldr	r7, [sp], #4
 8021af0: 4770         	bx	lr

08021af2 <LL_USART_DisableIT_LBD>:
; {
 8021af2: b480         	push	{r7}
 8021af4: b083         	sub	sp, #0xc
 8021af6: af00         	add	r7, sp, #0x0
 8021af8: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR2, USART_CR2_LBDIE);
 8021afa: 687b         	ldr	r3, [r7, #0x4]
 8021afc: 691b         	ldr	r3, [r3, #0x10]
 8021afe: f023 0240    	bic	r2, r3, #0x40
 8021b02: 687b         	ldr	r3, [r7, #0x4]
 8021b04: 611a         	str	r2, [r3, #0x10]
; }
 8021b06: bf00         	nop
 8021b08: 370c         	adds	r7, #0xc
 8021b0a: 46bd         	mov	sp, r7
 8021b0c: f85d 7b04    	ldr	r7, [sp], #4
 8021b10: 4770         	bx	lr

08021b12 <LL_USART_DisableIT_ERROR>:
; {
 8021b12: b480         	push	{r7}
 8021b14: b089         	sub	sp, #0x24
 8021b16: af00         	add	r7, sp, #0x0
 8021b18: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8021b1a: 687b         	ldr	r3, [r7, #0x4]
 8021b1c: 3314         	adds	r3, #0x14
 8021b1e: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8021b20: 68fb         	ldr	r3, [r7, #0xc]
 8021b22: e853 3f00    	ldrex	r3, [r3]
 8021b26: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8021b28: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8021b2a: f023 0301    	bic	r3, r3, #0x1
 8021b2e: 61fb         	str	r3, [r7, #0x1c]
 8021b30: 687b         	ldr	r3, [r7, #0x4]
 8021b32: 3314         	adds	r3, #0x14
 8021b34: 69fa         	ldr	r2, [r7, #0x1c]
 8021b36: 61ba         	str	r2, [r7, #0x18]
 8021b38: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021b3a: 6979         	ldr	r1, [r7, #0x14]
 8021b3c: 69ba         	ldr	r2, [r7, #0x18]
 8021b3e: e841 2300    	strex	r3, r2, [r1]
 8021b42: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8021b44: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 8021b46: 2b00         	cmp	r3, #0x0
 8021b48: d1e7         	bne	0x8021b1a <LL_USART_DisableIT_ERROR+0x8> @ imm = #-0x32
; }
 8021b4a: bf00         	nop
 8021b4c: bf00         	nop
 8021b4e: 3724         	adds	r7, #0x24
 8021b50: 46bd         	mov	sp, r7
 8021b52: f85d 7b04    	ldr	r7, [sp], #4
 8021b56: 4770         	bx	lr

08021b58 <LL_USART_IsEnabledIT_IDLE>:
; {
 8021b58: b480         	push	{r7}
 8021b5a: b083         	sub	sp, #0xc
 8021b5c: af00         	add	r7, sp, #0x0
 8021b5e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE));
 8021b60: 687b         	ldr	r3, [r7, #0x4]
 8021b62: 68db         	ldr	r3, [r3, #0xc]
 8021b64: f003 0310    	and	r3, r3, #0x10
 8021b68: 2b10         	cmp	r3, #0x10
 8021b6a: bf0c         	ite	eq
 8021b6c: 2301         	moveq	r3, #0x1
 8021b6e: 2300         	movne	r3, #0x0
 8021b70: b2db         	uxtb	r3, r3
; }
 8021b72: 4618         	mov	r0, r3
 8021b74: 370c         	adds	r7, #0xc
 8021b76: 46bd         	mov	sp, r7
 8021b78: f85d 7b04    	ldr	r7, [sp], #4
 8021b7c: 4770         	bx	lr

08021b7e <LL_USART_IsEnabledIT_RXNE>:
; {
 8021b7e: b480         	push	{r7}
 8021b80: b083         	sub	sp, #0xc
 8021b82: af00         	add	r7, sp, #0x0
 8021b84: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE));
 8021b86: 687b         	ldr	r3, [r7, #0x4]
 8021b88: 68db         	ldr	r3, [r3, #0xc]
 8021b8a: f003 0320    	and	r3, r3, #0x20
 8021b8e: 2b20         	cmp	r3, #0x20
 8021b90: bf0c         	ite	eq
 8021b92: 2301         	moveq	r3, #0x1
 8021b94: 2300         	movne	r3, #0x0
 8021b96: b2db         	uxtb	r3, r3
; }
 8021b98: 4618         	mov	r0, r3
 8021b9a: 370c         	adds	r7, #0xc
 8021b9c: 46bd         	mov	sp, r7
 8021b9e: f85d 7b04    	ldr	r7, [sp], #4
 8021ba2: 4770         	bx	lr

08021ba4 <LL_USART_IsEnabledIT_TC>:
; {
 8021ba4: b480         	push	{r7}
 8021ba6: b083         	sub	sp, #0xc
 8021ba8: af00         	add	r7, sp, #0x0
 8021baa: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_TCIE) == (USART_CR1_TCIE));
 8021bac: 687b         	ldr	r3, [r7, #0x4]
 8021bae: 68db         	ldr	r3, [r3, #0xc]
 8021bb0: f003 0340    	and	r3, r3, #0x40
 8021bb4: 2b40         	cmp	r3, #0x40
 8021bb6: bf0c         	ite	eq
 8021bb8: 2301         	moveq	r3, #0x1
 8021bba: 2300         	movne	r3, #0x0
 8021bbc: b2db         	uxtb	r3, r3
; }
 8021bbe: 4618         	mov	r0, r3
 8021bc0: 370c         	adds	r7, #0xc
 8021bc2: 46bd         	mov	sp, r7
 8021bc4: f85d 7b04    	ldr	r7, [sp], #4
 8021bc8: 4770         	bx	lr

08021bca <LL_USART_EnableDMAReq_RX>:
; {
 8021bca: b480         	push	{r7}
 8021bcc: b089         	sub	sp, #0x24
 8021bce: af00         	add	r7, sp, #0x0
 8021bd0: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8021bd2: 687b         	ldr	r3, [r7, #0x4]
 8021bd4: 3314         	adds	r3, #0x14
 8021bd6: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8021bd8: 68fb         	ldr	r3, [r7, #0xc]
 8021bda: e853 3f00    	ldrex	r3, [r3]
 8021bde: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8021be0: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8021be2: f043 0340    	orr	r3, r3, #0x40
 8021be6: 61fb         	str	r3, [r7, #0x1c]
 8021be8: 687b         	ldr	r3, [r7, #0x4]
 8021bea: 3314         	adds	r3, #0x14
 8021bec: 69fa         	ldr	r2, [r7, #0x1c]
 8021bee: 61ba         	str	r2, [r7, #0x18]
 8021bf0: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021bf2: 6979         	ldr	r1, [r7, #0x14]
 8021bf4: 69ba         	ldr	r2, [r7, #0x18]
 8021bf6: e841 2300    	strex	r3, r2, [r1]
 8021bfa: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8021bfc: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 8021bfe: 2b00         	cmp	r3, #0x0
 8021c00: d1e7         	bne	0x8021bd2 <LL_USART_EnableDMAReq_RX+0x8> @ imm = #-0x32
; }
 8021c02: bf00         	nop
 8021c04: bf00         	nop
 8021c06: 3724         	adds	r7, #0x24
 8021c08: 46bd         	mov	sp, r7
 8021c0a: f85d 7b04    	ldr	r7, [sp], #4
 8021c0e: 4770         	bx	lr

08021c10 <LL_USART_EnableDMAReq_TX>:
; {
 8021c10: b480         	push	{r7}
 8021c12: b089         	sub	sp, #0x24
 8021c14: af00         	add	r7, sp, #0x0
 8021c16: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 8021c18: 687b         	ldr	r3, [r7, #0x4]
 8021c1a: 3314         	adds	r3, #0x14
 8021c1c: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8021c1e: 68fb         	ldr	r3, [r7, #0xc]
 8021c20: e853 3f00    	ldrex	r3, [r3]
 8021c24: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8021c26: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 8021c28: f043 0380    	orr	r3, r3, #0x80
 8021c2c: 61fb         	str	r3, [r7, #0x1c]
 8021c2e: 687b         	ldr	r3, [r7, #0x4]
 8021c30: 3314         	adds	r3, #0x14
 8021c32: 69fa         	ldr	r2, [r7, #0x1c]
 8021c34: 61ba         	str	r2, [r7, #0x18]
 8021c36: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021c38: 6979         	ldr	r1, [r7, #0x14]
 8021c3a: 69ba         	ldr	r2, [r7, #0x18]
 8021c3c: e841 2300    	strex	r3, r2, [r1]
 8021c40: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8021c42: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 8021c44: 2b00         	cmp	r3, #0x0
 8021c46: d1e7         	bne	0x8021c18 <LL_USART_EnableDMAReq_TX+0x8> @ imm = #-0x32
; }
 8021c48: bf00         	nop
 8021c4a: bf00         	nop
 8021c4c: 3724         	adds	r7, #0x24
 8021c4e: 46bd         	mov	sp, r7
 8021c50: f85d 7b04    	ldr	r7, [sp], #4
 8021c54: 4770         	bx	lr

08021c56 <LL_USART_DisableDMAReq_TX>:
; {
 8021c56: b480         	push	{r7}
 8021c58: b089         	sub	sp, #0x24
 8021c5a: af00         	add	r7, sp, #0x0
 8021c5c: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 8021c5e: 687b         	ldr	r3, [r7, #0x4]
 8021c60: 3314         	adds	r3, #0x14
 8021c62: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8021c64: 68fb         	ldr	r3, [r7, #0xc]
 8021c66: e853 3f00    	ldrex	r3, [r3]
 8021c6a: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8021c6c: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 8021c6e: f023 0380    	bic	r3, r3, #0x80
 8021c72: 61fb         	str	r3, [r7, #0x1c]
 8021c74: 687b         	ldr	r3, [r7, #0x4]
 8021c76: 3314         	adds	r3, #0x14
 8021c78: 69fa         	ldr	r2, [r7, #0x1c]
 8021c7a: 61ba         	str	r2, [r7, #0x18]
 8021c7c: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8021c7e: 6979         	ldr	r1, [r7, #0x14]
 8021c80: 69ba         	ldr	r2, [r7, #0x18]
 8021c82: e841 2300    	strex	r3, r2, [r1]
 8021c86: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8021c88: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 8021c8a: 2b00         	cmp	r3, #0x0
 8021c8c: d1e7         	bne	0x8021c5e <LL_USART_DisableDMAReq_TX+0x8> @ imm = #-0x32
; }
 8021c8e: bf00         	nop
 8021c90: bf00         	nop
 8021c92: 3724         	adds	r7, #0x24
 8021c94: 46bd         	mov	sp, r7
 8021c96: f85d 7b04    	ldr	r7, [sp], #4
 8021c9a: 4770         	bx	lr

08021c9c <LL_USART_DMA_GetRegAddr>:
; {
 8021c9c: b480         	push	{r7}
 8021c9e: b083         	sub	sp, #0xc
 8021ca0: af00         	add	r7, sp, #0x0
 8021ca2: 6078         	str	r0, [r7, #0x4]
;   return ((uint32_t) &(USARTx->DR));
 8021ca4: 687b         	ldr	r3, [r7, #0x4]
 8021ca6: 3304         	adds	r3, #0x4
; }
 8021ca8: 4618         	mov	r0, r3
 8021caa: 370c         	adds	r7, #0xc
 8021cac: 46bd         	mov	sp, r7
 8021cae: f85d 7b04    	ldr	r7, [sp], #4
 8021cb2: 4770         	bx	lr

08021cb4 <LL_USART_ReceiveData8>:
; {
 8021cb4: b480         	push	{r7}
 8021cb6: b083         	sub	sp, #0xc
 8021cb8: af00         	add	r7, sp, #0x0
 8021cba: 6078         	str	r0, [r7, #0x4]
;   return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
 8021cbc: 687b         	ldr	r3, [r7, #0x4]
 8021cbe: 685b         	ldr	r3, [r3, #0x4]
 8021cc0: b2db         	uxtb	r3, r3
; }
 8021cc2: 4618         	mov	r0, r3
 8021cc4: 370c         	adds	r7, #0xc
 8021cc6: 46bd         	mov	sp, r7
 8021cc8: f85d 7b04    	ldr	r7, [sp], #4
 8021ccc: 4770         	bx	lr

08021cce <LL_USART_TransmitData8>:
; {
 8021cce: b480         	push	{r7}
 8021cd0: b083         	sub	sp, #0xc
 8021cd2: af00         	add	r7, sp, #0x0
 8021cd4: 6078         	str	r0, [r7, #0x4]
 8021cd6: 460b         	mov	r3, r1
 8021cd8: 70fb         	strb	r3, [r7, #0x3]
;   USARTx->DR = Value;
 8021cda: 78fa         	ldrb	r2, [r7, #0x3]
 8021cdc: 687b         	ldr	r3, [r7, #0x4]
 8021cde: 605a         	str	r2, [r3, #0x4]
; }
 8021ce0: bf00         	nop
 8021ce2: 370c         	adds	r7, #0xc
 8021ce4: 46bd         	mov	sp, r7
 8021ce6: f85d 7b04    	ldr	r7, [sp], #4
 8021cea: 4770         	bx	lr

08021cec <z_log_msg_runtime_create>:
; {
 8021cec: b580         	push	{r7, lr}
 8021cee: b08a         	sub	sp, #0x28
 8021cf0: af04         	add	r7, sp, #0x10
 8021cf2: 60b9         	str	r1, [r7, #0x8]
 8021cf4: 607b         	str	r3, [r7, #0x4]
 8021cf6: 4603         	mov	r3, r0
 8021cf8: 73fb         	strb	r3, [r7, #0xf]
 8021cfa: 4613         	mov	r3, r2
 8021cfc: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8021cfe: f107 032c    	add.w	r3, r7, #0x2c
 8021d02: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8021d04: 7bba         	ldrb	r2, [r7, #0xe]
 8021d06: 7bf8         	ldrb	r0, [r7, #0xf]
 8021d08: 697b         	ldr	r3, [r7, #0x14]
 8021d0a: 9303         	str	r3, [sp, #0xc]
 8021d0c: 6abb         	ldr	r3, [r7, #0x28]
 8021d0e: 9302         	str	r3, [sp, #0x8]
 8021d10: 6a7b         	ldr	r3, [r7, #0x24]
 8021d12: 9301         	str	r3, [sp, #0x4]
 8021d14: 6a3b         	ldr	r3, [r7, #0x20]
 8021d16: 9300         	str	r3, [sp]
 8021d18: 687b         	ldr	r3, [r7, #0x4]
 8021d1a: 68b9         	ldr	r1, [r7, #0x8]
 8021d1c: f7e2 ff12    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x1d1dc
; }
 8021d20: bf00         	nop
 8021d22: 3718         	adds	r7, #0x18
 8021d24: 46bd         	mov	sp, r7
 8021d26: bd80         	pop	{r7, pc}

08021d28 <uart_stm32_set_parity>:
; {
 8021d28: b580         	push	{r7, lr}
 8021d2a: b084         	sub	sp, #0x10
 8021d2c: af00         	add	r7, sp, #0x0
 8021d2e: 6078         	str	r0, [r7, #0x4]
 8021d30: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8021d32: 687b         	ldr	r3, [r7, #0x4]
 8021d34: 685b         	ldr	r3, [r3, #0x4]
 8021d36: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetParity(config->usart, parity);
 8021d38: 68fb         	ldr	r3, [r7, #0xc]
 8021d3a: 681b         	ldr	r3, [r3]
 8021d3c: 6839         	ldr	r1, [r7]
 8021d3e: 4618         	mov	r0, r3
 8021d40: f7ff fb96    	bl	0x8021470 <LL_USART_SetParity> @ imm = #-0x8d4
; }
 8021d44: bf00         	nop
 8021d46: 3710         	adds	r7, #0x10
 8021d48: 46bd         	mov	sp, r7
 8021d4a: bd80         	pop	{r7, pc}

08021d4c <uart_stm32_get_parity>:
; {
 8021d4c: b580         	push	{r7, lr}
 8021d4e: b084         	sub	sp, #0x10
 8021d50: af00         	add	r7, sp, #0x0
 8021d52: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8021d54: 687b         	ldr	r3, [r7, #0x4]
 8021d56: 685b         	ldr	r3, [r3, #0x4]
 8021d58: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetParity(config->usart);
 8021d5a: 68fb         	ldr	r3, [r7, #0xc]
 8021d5c: 681b         	ldr	r3, [r3]
 8021d5e: 4618         	mov	r0, r3
 8021d60: f7ff fb99    	bl	0x8021496 <LL_USART_GetParity> @ imm = #-0x8ce
 8021d64: 4603         	mov	r3, r0
; }
 8021d66: 4618         	mov	r0, r3
 8021d68: 3710         	adds	r7, #0x10
 8021d6a: 46bd         	mov	sp, r7
 8021d6c: bd80         	pop	{r7, pc}

08021d6e <uart_stm32_set_stopbits>:
; {
 8021d6e: b580         	push	{r7, lr}
 8021d70: b084         	sub	sp, #0x10
 8021d72: af00         	add	r7, sp, #0x0
 8021d74: 6078         	str	r0, [r7, #0x4]
 8021d76: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8021d78: 687b         	ldr	r3, [r7, #0x4]
 8021d7a: 685b         	ldr	r3, [r3, #0x4]
 8021d7c: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetStopBitsLength(config->usart, stopbits);
 8021d7e: 68fb         	ldr	r3, [r7, #0xc]
 8021d80: 681b         	ldr	r3, [r3]
 8021d82: 6839         	ldr	r1, [r7]
 8021d84: 4618         	mov	r0, r3
 8021d86: f7ff fbc8    	bl	0x802151a <LL_USART_SetStopBitsLength> @ imm = #-0x870
; }
 8021d8a: bf00         	nop
 8021d8c: 3710         	adds	r7, #0x10
 8021d8e: 46bd         	mov	sp, r7
 8021d90: bd80         	pop	{r7, pc}

08021d92 <uart_stm32_get_stopbits>:
; {
 8021d92: b580         	push	{r7, lr}
 8021d94: b084         	sub	sp, #0x10
 8021d96: af00         	add	r7, sp, #0x0
 8021d98: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8021d9a: 687b         	ldr	r3, [r7, #0x4]
 8021d9c: 685b         	ldr	r3, [r3, #0x4]
 8021d9e: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetStopBitsLength(config->usart);
 8021da0: 68fb         	ldr	r3, [r7, #0xc]
 8021da2: 681b         	ldr	r3, [r3]
 8021da4: 4618         	mov	r0, r3
 8021da6: f7ff fbcb    	bl	0x8021540 <LL_USART_GetStopBitsLength> @ imm = #-0x86a
 8021daa: 4603         	mov	r3, r0
; }
 8021dac: 4618         	mov	r0, r3
 8021dae: 3710         	adds	r7, #0x10
 8021db0: 46bd         	mov	sp, r7
 8021db2: bd80         	pop	{r7, pc}

08021db4 <uart_stm32_set_databits>:
; {
 8021db4: b580         	push	{r7, lr}
 8021db6: b084         	sub	sp, #0x10
 8021db8: af00         	add	r7, sp, #0x0
 8021dba: 6078         	str	r0, [r7, #0x4]
 8021dbc: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8021dbe: 687b         	ldr	r3, [r7, #0x4]
 8021dc0: 685b         	ldr	r3, [r3, #0x4]
 8021dc2: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetDataWidth(config->usart, databits);
 8021dc4: 68fb         	ldr	r3, [r7, #0xc]
 8021dc6: 681b         	ldr	r3, [r3]
 8021dc8: 6839         	ldr	r1, [r7]
 8021dca: 4618         	mov	r0, r3
 8021dcc: f7ff fb71    	bl	0x80214b2 <LL_USART_SetDataWidth> @ imm = #-0x91e
; }
 8021dd0: bf00         	nop
 8021dd2: 3710         	adds	r7, #0x10
 8021dd4: 46bd         	mov	sp, r7
 8021dd6: bd80         	pop	{r7, pc}

08021dd8 <uart_stm32_get_databits>:
; {
 8021dd8: b580         	push	{r7, lr}
 8021dda: b084         	sub	sp, #0x10
 8021ddc: af00         	add	r7, sp, #0x0
 8021dde: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8021de0: 687b         	ldr	r3, [r7, #0x4]
 8021de2: 685b         	ldr	r3, [r3, #0x4]
 8021de4: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetDataWidth(config->usart);
 8021de6: 68fb         	ldr	r3, [r7, #0xc]
 8021de8: 681b         	ldr	r3, [r3]
 8021dea: 4618         	mov	r0, r3
 8021dec: f7ff fb74    	bl	0x80214d8 <LL_USART_GetDataWidth> @ imm = #-0x918
 8021df0: 4603         	mov	r3, r0
; }
 8021df2: 4618         	mov	r0, r3
 8021df4: 3710         	adds	r7, #0x10
 8021df6: 46bd         	mov	sp, r7
 8021df8: bd80         	pop	{r7, pc}

08021dfa <uart_stm32_set_hwctrl>:
; {
 8021dfa: b580         	push	{r7, lr}
 8021dfc: b084         	sub	sp, #0x10
 8021dfe: af00         	add	r7, sp, #0x0
 8021e00: 6078         	str	r0, [r7, #0x4]
 8021e02: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8021e04: 687b         	ldr	r3, [r7, #0x4]
 8021e06: 685b         	ldr	r3, [r3, #0x4]
 8021e08: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetHWFlowCtrl(config->usart, hwctrl);
 8021e0a: 68fb         	ldr	r3, [r7, #0xc]
 8021e0c: 681b         	ldr	r3, [r3]
 8021e0e: 6839         	ldr	r1, [r7]
 8021e10: 4618         	mov	r0, r3
 8021e12: f7ff fbc2    	bl	0x802159a <LL_USART_SetHWFlowCtrl> @ imm = #-0x87c
; }
 8021e16: bf00         	nop
 8021e18: 3710         	adds	r7, #0x10
 8021e1a: 46bd         	mov	sp, r7
 8021e1c: bd80         	pop	{r7, pc}

08021e1e <uart_stm32_get_hwctrl>:
; {
 8021e1e: b580         	push	{r7, lr}
 8021e20: b084         	sub	sp, #0x10
 8021e22: af00         	add	r7, sp, #0x0
 8021e24: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8021e26: 687b         	ldr	r3, [r7, #0x4]
 8021e28: 685b         	ldr	r3, [r3, #0x4]
 8021e2a: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetHWFlowCtrl(config->usart);
 8021e2c: 68fb         	ldr	r3, [r7, #0xc]
 8021e2e: 681b         	ldr	r3, [r3]
 8021e30: 4618         	mov	r0, r3
 8021e32: f7ff fbc5    	bl	0x80215c0 <LL_USART_GetHWFlowCtrl> @ imm = #-0x876
 8021e36: 4603         	mov	r3, r0
; }
 8021e38: 4618         	mov	r0, r3
 8021e3a: 3710         	adds	r7, #0x10
 8021e3c: 46bd         	mov	sp, r7
 8021e3e: bd80         	pop	{r7, pc}

08021e40 <uart_stm32_cfg2ll_parity>:
; {
 8021e40: b480         	push	{r7}
 8021e42: b083         	sub	sp, #0xc
 8021e44: af00         	add	r7, sp, #0x0
 8021e46: 4603         	mov	r3, r0
 8021e48: 71fb         	strb	r3, [r7, #0x7]
; 	switch (parity) {
 8021e4a: 79fb         	ldrb	r3, [r7, #0x7]
 8021e4c: 2b01         	cmp	r3, #0x1
 8021e4e: d002         	beq	0x8021e56 <uart_stm32_cfg2ll_parity+0x16> @ imm = #0x4
 8021e50: 2b02         	cmp	r3, #0x2
 8021e52: d003         	beq	0x8021e5c <uart_stm32_cfg2ll_parity+0x1c> @ imm = #0x6
 8021e54: e005         	b	0x8021e62 <uart_stm32_cfg2ll_parity+0x22> @ imm = #0xa
; 		return LL_USART_PARITY_ODD;
 8021e56: f44f 63c0    	mov.w	r3, #0x600
 8021e5a: e003         	b	0x8021e64 <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x6
; 		return LL_USART_PARITY_EVEN;
 8021e5c: f44f 6380    	mov.w	r3, #0x400
 8021e60: e000         	b	0x8021e64 <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x0
; 		return LL_USART_PARITY_NONE;
 8021e62: 2300         	movs	r3, #0x0
; }
 8021e64: 4618         	mov	r0, r3
 8021e66: 370c         	adds	r7, #0xc
 8021e68: 46bd         	mov	sp, r7
 8021e6a: f85d 7b04    	ldr	r7, [sp], #4
 8021e6e: 4770         	bx	lr

08021e70 <uart_stm32_ll2cfg_parity>:
; {
 8021e70: b480         	push	{r7}
 8021e72: b083         	sub	sp, #0xc
 8021e74: af00         	add	r7, sp, #0x0
 8021e76: 6078         	str	r0, [r7, #0x4]
; 	switch (parity) {
 8021e78: 687b         	ldr	r3, [r7, #0x4]
 8021e7a: f5b3 6f80    	cmp.w	r3, #0x400
 8021e7e: d005         	beq	0x8021e8c <uart_stm32_ll2cfg_parity+0x1c> @ imm = #0xa
 8021e80: 687b         	ldr	r3, [r7, #0x4]
 8021e82: f5b3 6fc0    	cmp.w	r3, #0x600
 8021e86: d103         	bne	0x8021e90 <uart_stm32_ll2cfg_parity+0x20> @ imm = #0x6
; 		return UART_CFG_PARITY_ODD;
 8021e88: 2301         	movs	r3, #0x1
 8021e8a: e002         	b	0x8021e92 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x4
; 		return UART_CFG_PARITY_EVEN;
 8021e8c: 2302         	movs	r3, #0x2
 8021e8e: e000         	b	0x8021e92 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x0
; 		return UART_CFG_PARITY_NONE;
 8021e90: 2300         	movs	r3, #0x0
; }
 8021e92: 4618         	mov	r0, r3
 8021e94: 370c         	adds	r7, #0xc
 8021e96: 46bd         	mov	sp, r7
 8021e98: f85d 7b04    	ldr	r7, [sp], #4
 8021e9c: 4770         	bx	lr

08021e9e <uart_stm32_cfg2ll_stopbits>:
; {
 8021e9e: b480         	push	{r7}
 8021ea0: b083         	sub	sp, #0xc
 8021ea2: af00         	add	r7, sp, #0x0
 8021ea4: 6078         	str	r0, [r7, #0x4]
 8021ea6: 460b         	mov	r3, r1
 8021ea8: 70fb         	strb	r3, [r7, #0x3]
; 	switch (sb) {
 8021eaa: 78fb         	ldrb	r3, [r7, #0x3]
 8021eac: 2b02         	cmp	r3, #0x2
 8021eae: d00b         	beq	0x8021ec8 <uart_stm32_cfg2ll_stopbits+0x2a> @ imm = #0x16
 8021eb0: 2b02         	cmp	r3, #0x2
 8021eb2: dc0c         	bgt	0x8021ece <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0x18
 8021eb4: 2b00         	cmp	r3, #0x0
 8021eb6: d002         	beq	0x8021ebe <uart_stm32_cfg2ll_stopbits+0x20> @ imm = #0x4
 8021eb8: 2b01         	cmp	r3, #0x1
 8021eba: d003         	beq	0x8021ec4 <uart_stm32_cfg2ll_stopbits+0x26> @ imm = #0x6
 8021ebc: e007         	b	0x8021ece <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0xe
; 		return LL_USART_STOPBITS_0_5;
 8021ebe: f44f 5380    	mov.w	r3, #0x1000
 8021ec2: e006         	b	0x8021ed2 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0xc
; 		return LL_USART_STOPBITS_1;
 8021ec4: 2300         	movs	r3, #0x0
 8021ec6: e004         	b	0x8021ed2 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x8
; 		return LL_USART_STOPBITS_1_5;
 8021ec8: f44f 5340    	mov.w	r3, #0x3000
 8021ecc: e001         	b	0x8021ed2 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x2
; 		return LL_USART_STOPBITS_2;
 8021ece: f44f 5300    	mov.w	r3, #0x2000
; }
 8021ed2: 4618         	mov	r0, r3
 8021ed4: 370c         	adds	r7, #0xc
 8021ed6: 46bd         	mov	sp, r7
 8021ed8: f85d 7b04    	ldr	r7, [sp], #4
 8021edc: 4770         	bx	lr

08021ede <uart_stm32_ll2cfg_stopbits>:
; {
 8021ede: b480         	push	{r7}
 8021ee0: b083         	sub	sp, #0xc
 8021ee2: af00         	add	r7, sp, #0x0
 8021ee4: 6078         	str	r0, [r7, #0x4]
; 	switch (sb) {
 8021ee6: 687b         	ldr	r3, [r7, #0x4]
 8021ee8: f5b3 5f40    	cmp.w	r3, #0x3000
 8021eec: d00e         	beq	0x8021f0c <uart_stm32_ll2cfg_stopbits+0x2e> @ imm = #0x1c
 8021eee: 687b         	ldr	r3, [r7, #0x4]
 8021ef0: f5b3 5f40    	cmp.w	r3, #0x3000
 8021ef4: d80c         	bhi	0x8021f10 <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0x18
 8021ef6: 687b         	ldr	r3, [r7, #0x4]
 8021ef8: 2b00         	cmp	r3, #0x0
 8021efa: d005         	beq	0x8021f08 <uart_stm32_ll2cfg_stopbits+0x2a> @ imm = #0xa
 8021efc: 687b         	ldr	r3, [r7, #0x4]
 8021efe: f5b3 5f80    	cmp.w	r3, #0x1000
 8021f02: d105         	bne	0x8021f10 <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0xa
; 		return UART_CFG_STOP_BITS_0_5;
 8021f04: 2300         	movs	r3, #0x0
 8021f06: e004         	b	0x8021f12 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x8
; 		return UART_CFG_STOP_BITS_1;
 8021f08: 2301         	movs	r3, #0x1
 8021f0a: e002         	b	0x8021f12 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x4
; 		return UART_CFG_STOP_BITS_1_5;
 8021f0c: 2302         	movs	r3, #0x2
 8021f0e: e000         	b	0x8021f12 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x0
; 		return UART_CFG_STOP_BITS_2;
 8021f10: 2303         	movs	r3, #0x3
; }
 8021f12: 4618         	mov	r0, r3
 8021f14: 370c         	adds	r7, #0xc
 8021f16: 46bd         	mov	sp, r7
 8021f18: f85d 7b04    	ldr	r7, [sp], #4
 8021f1c: 4770         	bx	lr

08021f1e <uart_stm32_cfg2ll_databits>:
; {
 8021f1e: b480         	push	{r7}
 8021f20: b083         	sub	sp, #0xc
 8021f22: af00         	add	r7, sp, #0x0
 8021f24: 4603         	mov	r3, r0
 8021f26: 460a         	mov	r2, r1
 8021f28: 71fb         	strb	r3, [r7, #0x7]
 8021f2a: 4613         	mov	r3, r2
 8021f2c: 71bb         	strb	r3, [r7, #0x6]
; 	switch (db) {
 8021f2e: 79fb         	ldrb	r3, [r7, #0x7]
 8021f30: 2b04         	cmp	r3, #0x4
 8021f32: d102         	bne	0x8021f3a <uart_stm32_cfg2ll_databits+0x1c> @ imm = #0x4
; 		return LL_USART_DATAWIDTH_9B;
 8021f34: f44f 5380    	mov.w	r3, #0x1000
 8021f38: e006         	b	0x8021f48 <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0xc
; 		if (p == UART_CFG_PARITY_NONE) {
 8021f3a: 79bb         	ldrb	r3, [r7, #0x6]
 8021f3c: 2b00         	cmp	r3, #0x0
 8021f3e: d101         	bne	0x8021f44 <uart_stm32_cfg2ll_databits+0x26> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_8B;
 8021f40: 2300         	movs	r3, #0x0
 8021f42: e001         	b	0x8021f48 <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_9B;
 8021f44: f44f 5380    	mov.w	r3, #0x1000
; }
 8021f48: 4618         	mov	r0, r3
 8021f4a: 370c         	adds	r7, #0xc
 8021f4c: 46bd         	mov	sp, r7
 8021f4e: f85d 7b04    	ldr	r7, [sp], #4
 8021f52: 4770         	bx	lr

08021f54 <uart_stm32_ll2cfg_databits>:
; {
 8021f54: b480         	push	{r7}
 8021f56: b083         	sub	sp, #0xc
 8021f58: af00         	add	r7, sp, #0x0
 8021f5a: 6078         	str	r0, [r7, #0x4]
 8021f5c: 6039         	str	r1, [r7]
; 	switch (db) {
 8021f5e: 687b         	ldr	r3, [r7, #0x4]
 8021f60: f5b3 5f80    	cmp.w	r3, #0x1000
 8021f64: d106         	bne	0x8021f74 <uart_stm32_ll2cfg_databits+0x20> @ imm = #0xc
; 		if (p == LL_USART_PARITY_NONE) {
 8021f66: 683b         	ldr	r3, [r7]
 8021f68: 2b00         	cmp	r3, #0x0
 8021f6a: d101         	bne	0x8021f70 <uart_stm32_ll2cfg_databits+0x1c> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_9;
 8021f6c: 2304         	movs	r3, #0x4
 8021f6e: e007         	b	0x8021f80 <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xe
; 			return UART_CFG_DATA_BITS_8;
 8021f70: 2303         	movs	r3, #0x3
 8021f72: e005         	b	0x8021f80 <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xa
; 		if (p == LL_USART_PARITY_NONE) {
 8021f74: 683b         	ldr	r3, [r7]
 8021f76: 2b00         	cmp	r3, #0x0
 8021f78: d101         	bne	0x8021f7e <uart_stm32_ll2cfg_databits+0x2a> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_8;
 8021f7a: 2303         	movs	r3, #0x3
 8021f7c: e000         	b	0x8021f80 <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0x0
; 			return UART_CFG_DATA_BITS_7;
 8021f7e: 2302         	movs	r3, #0x2
; }
 8021f80: 4618         	mov	r0, r3
 8021f82: 370c         	adds	r7, #0xc
 8021f84: 46bd         	mov	sp, r7
 8021f86: f85d 7b04    	ldr	r7, [sp], #4
 8021f8a: 4770         	bx	lr

08021f8c <uart_stm32_cfg2ll_hwctrl>:
; {
 8021f8c: b480         	push	{r7}
 8021f8e: b083         	sub	sp, #0xc
 8021f90: af00         	add	r7, sp, #0x0
 8021f92: 4603         	mov	r3, r0
 8021f94: 71fb         	strb	r3, [r7, #0x7]
; 	if (fc == UART_CFG_FLOW_CTRL_RTS_CTS) {
 8021f96: 79fb         	ldrb	r3, [r7, #0x7]
 8021f98: 2b01         	cmp	r3, #0x1
 8021f9a: d102         	bne	0x8021fa2 <uart_stm32_cfg2ll_hwctrl+0x16> @ imm = #0x4
; 		return LL_USART_HWCONTROL_RTS_CTS;
 8021f9c: f44f 7340    	mov.w	r3, #0x300
 8021fa0: e005         	b	0x8021fae <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0xa
; 	} else if (fc == UART_CFG_FLOW_CTRL_RS485) {
 8021fa2: 79fb         	ldrb	r3, [r7, #0x7]
 8021fa4: 2b03         	cmp	r3, #0x3
 8021fa6: d101         	bne	0x8021fac <uart_stm32_cfg2ll_hwctrl+0x20> @ imm = #0x2
; 		return LL_USART_HWCONTROL_NONE;
 8021fa8: 2300         	movs	r3, #0x0
 8021faa: e000         	b	0x8021fae <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0x0
; 	return LL_USART_HWCONTROL_NONE;
 8021fac: 2300         	movs	r3, #0x0
; }
 8021fae: 4618         	mov	r0, r3
 8021fb0: 370c         	adds	r7, #0xc
 8021fb2: 46bd         	mov	sp, r7
 8021fb4: f85d 7b04    	ldr	r7, [sp], #4
 8021fb8: 4770         	bx	lr

08021fba <uart_stm32_ll2cfg_hwctrl>:
; {
 8021fba: b480         	push	{r7}
 8021fbc: b083         	sub	sp, #0xc
 8021fbe: af00         	add	r7, sp, #0x0
 8021fc0: 6078         	str	r0, [r7, #0x4]
; 	if (fc == LL_USART_HWCONTROL_RTS_CTS) {
 8021fc2: 687b         	ldr	r3, [r7, #0x4]
 8021fc4: f5b3 7f40    	cmp.w	r3, #0x300
 8021fc8: d101         	bne	0x8021fce <uart_stm32_ll2cfg_hwctrl+0x14> @ imm = #0x2
; 		return UART_CFG_FLOW_CTRL_RTS_CTS;
 8021fca: 2301         	movs	r3, #0x1
 8021fcc: e000         	b	0x8021fd0 <uart_stm32_ll2cfg_hwctrl+0x16> @ imm = #0x0
; 	return UART_CFG_FLOW_CTRL_NONE;
 8021fce: 2300         	movs	r3, #0x0
; }
 8021fd0: 4618         	mov	r0, r3
 8021fd2: 370c         	adds	r7, #0xc
 8021fd4: 46bd         	mov	sp, r7
 8021fd6: f85d 7b04    	ldr	r7, [sp], #4
 8021fda: 4770         	bx	lr

08021fdc <uart_stm32_parameters_set>:
; {
 8021fdc: b580         	push	{r7, lr}
 8021fde: b08a         	sub	sp, #0x28
 8021fe0: af00         	add	r7, sp, #0x0
 8021fe2: 6078         	str	r0, [r7, #0x4]
 8021fe4: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8021fe6: 687b         	ldr	r3, [r7, #0x4]
 8021fe8: 685b         	ldr	r3, [r3, #0x4]
 8021fea: 627b         	str	r3, [r7, #0x24]
; 	struct uart_stm32_data *data = dev->data;
 8021fec: 687b         	ldr	r3, [r7, #0x4]
 8021fee: 691b         	ldr	r3, [r3, #0x10]
 8021ff0: 623b         	str	r3, [r7, #0x20]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 8021ff2: 6a3b         	ldr	r3, [r7, #0x20]
 8021ff4: 685b         	ldr	r3, [r3, #0x4]
 8021ff6: 61fb         	str	r3, [r7, #0x1c]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 8021ff8: 683b         	ldr	r3, [r7]
 8021ffa: 791b         	ldrb	r3, [r3, #0x4]
 8021ffc: 4618         	mov	r0, r3
 8021ffe: f7ff ff1f    	bl	0x8021e40 <uart_stm32_cfg2ll_parity> @ imm = #-0x1c2
 8022002: 61b8         	str	r0, [r7, #0x18]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 8022004: 683b         	ldr	r3, [r7]
 8022006: 795b         	ldrb	r3, [r3, #0x5]
 8022008: 4619         	mov	r1, r3
 802200a: 6a78         	ldr	r0, [r7, #0x24]
 802200c: f7ff ff47    	bl	0x8021e9e <uart_stm32_cfg2ll_stopbits> @ imm = #-0x172
 8022010: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 8022012: 683b         	ldr	r3, [r7]
 8022014: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 8022016: 683b         	ldr	r3, [r7]
 8022018: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 802201a: 4619         	mov	r1, r3
 802201c: 4610         	mov	r0, r2
 802201e: f7ff ff7e    	bl	0x8021f1e <uart_stm32_cfg2ll_databits> @ imm = #-0x104
 8022022: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t flowctrl = uart_stm32_cfg2ll_hwctrl(cfg->flow_ctrl);
 8022024: 683b         	ldr	r3, [r7]
 8022026: 79db         	ldrb	r3, [r3, #0x7]
 8022028: 4618         	mov	r0, r3
 802202a: f7ff ffaf    	bl	0x8021f8c <uart_stm32_cfg2ll_hwctrl> @ imm = #-0xa2
 802202e: 60f8         	str	r0, [r7, #0xc]
; 	if (cfg == uart_cfg) {
 8022030: 683a         	ldr	r2, [r7]
 8022032: 69fb         	ldr	r3, [r7, #0x1c]
 8022034: 429a         	cmp	r2, r3
 8022036: d111         	bne	0x802205c <uart_stm32_parameters_set+0x80> @ imm = #0x22
; 		LL_USART_ConfigCharacter(config->usart,
 8022038: 6a7b         	ldr	r3, [r7, #0x24]
 802203a: 6818         	ldr	r0, [r3]
 802203c: 697b         	ldr	r3, [r7, #0x14]
 802203e: 69ba         	ldr	r2, [r7, #0x18]
 8022040: 6939         	ldr	r1, [r7, #0x10]
 8022042: f7ff fa8b    	bl	0x802155c <LL_USART_ConfigCharacter> @ imm = #-0xaea
; 		uart_stm32_set_hwctrl(dev, flowctrl);
 8022046: 68f9         	ldr	r1, [r7, #0xc]
 8022048: 6878         	ldr	r0, [r7, #0x4]
 802204a: f7ff fed6    	bl	0x8021dfa <uart_stm32_set_hwctrl> @ imm = #-0x254
; 		uart_stm32_set_baudrate(dev, cfg->baudrate);
 802204e: 683b         	ldr	r3, [r7]
 8022050: 681b         	ldr	r3, [r3]
 8022052: 4619         	mov	r1, r3
 8022054: 6878         	ldr	r0, [r7, #0x4]
 8022056: f7ea fda3    	bl	0x800cba0 <uart_stm32_set_baudrate> @ imm = #-0x154ba
; }
 802205a: e03b         	b	0x80220d4 <uart_stm32_parameters_set+0xf8> @ imm = #0x76
; 		if (parity != uart_stm32_get_parity(dev)) {
 802205c: 6878         	ldr	r0, [r7, #0x4]
 802205e: f7ff fe75    	bl	0x8021d4c <uart_stm32_get_parity> @ imm = #-0x316
 8022062: 4602         	mov	r2, r0
 8022064: 69bb         	ldr	r3, [r7, #0x18]
 8022066: 4293         	cmp	r3, r2
 8022068: d003         	beq	0x8022072 <uart_stm32_parameters_set+0x96> @ imm = #0x6
; 			uart_stm32_set_parity(dev, parity);
 802206a: 69b9         	ldr	r1, [r7, #0x18]
 802206c: 6878         	ldr	r0, [r7, #0x4]
 802206e: f7ff fe5b    	bl	0x8021d28 <uart_stm32_set_parity> @ imm = #-0x34a
; 		if (stopbits != uart_stm32_get_stopbits(dev)) {
 8022072: 6878         	ldr	r0, [r7, #0x4]
 8022074: f7ff fe8d    	bl	0x8021d92 <uart_stm32_get_stopbits> @ imm = #-0x2e6
 8022078: 4602         	mov	r2, r0
 802207a: 697b         	ldr	r3, [r7, #0x14]
 802207c: 4293         	cmp	r3, r2
 802207e: d003         	beq	0x8022088 <uart_stm32_parameters_set+0xac> @ imm = #0x6
; 			uart_stm32_set_stopbits(dev, stopbits);
 8022080: 6979         	ldr	r1, [r7, #0x14]
 8022082: 6878         	ldr	r0, [r7, #0x4]
 8022084: f7ff fe73    	bl	0x8021d6e <uart_stm32_set_stopbits> @ imm = #-0x31a
; 		if (databits != uart_stm32_get_databits(dev)) {
 8022088: 6878         	ldr	r0, [r7, #0x4]
 802208a: f7ff fea5    	bl	0x8021dd8 <uart_stm32_get_databits> @ imm = #-0x2b6
 802208e: 4602         	mov	r2, r0
 8022090: 693b         	ldr	r3, [r7, #0x10]
 8022092: 4293         	cmp	r3, r2
 8022094: d003         	beq	0x802209e <uart_stm32_parameters_set+0xc2> @ imm = #0x6
; 			uart_stm32_set_databits(dev, databits);
 8022096: 6939         	ldr	r1, [r7, #0x10]
 8022098: 6878         	ldr	r0, [r7, #0x4]
 802209a: f7ff fe8b    	bl	0x8021db4 <uart_stm32_set_databits> @ imm = #-0x2ea
; 		if (flowctrl != uart_stm32_get_hwctrl(dev)) {
 802209e: 6878         	ldr	r0, [r7, #0x4]
 80220a0: f7ff febd    	bl	0x8021e1e <uart_stm32_get_hwctrl> @ imm = #-0x286
 80220a4: 4602         	mov	r2, r0
 80220a6: 68fb         	ldr	r3, [r7, #0xc]
 80220a8: 4293         	cmp	r3, r2
 80220aa: d003         	beq	0x80220b4 <uart_stm32_parameters_set+0xd8> @ imm = #0x6
; 			uart_stm32_set_hwctrl(dev, flowctrl);
 80220ac: 68f9         	ldr	r1, [r7, #0xc]
 80220ae: 6878         	ldr	r0, [r7, #0x4]
 80220b0: f7ff fea3    	bl	0x8021dfa <uart_stm32_set_hwctrl> @ imm = #-0x2ba
; 		if (cfg->baudrate != uart_cfg->baudrate) {
 80220b4: 683b         	ldr	r3, [r7]
 80220b6: 681a         	ldr	r2, [r3]
 80220b8: 69fb         	ldr	r3, [r7, #0x1c]
 80220ba: 681b         	ldr	r3, [r3]
 80220bc: 429a         	cmp	r2, r3
 80220be: d009         	beq	0x80220d4 <uart_stm32_parameters_set+0xf8> @ imm = #0x12
; 			uart_stm32_set_baudrate(dev, cfg->baudrate);
 80220c0: 683b         	ldr	r3, [r7]
 80220c2: 681b         	ldr	r3, [r3]
 80220c4: 4619         	mov	r1, r3
 80220c6: 6878         	ldr	r0, [r7, #0x4]
 80220c8: f7ea fd6a    	bl	0x800cba0 <uart_stm32_set_baudrate> @ imm = #-0x1552c
; 			uart_cfg->baudrate = cfg->baudrate;
 80220cc: 683b         	ldr	r3, [r7]
 80220ce: 681a         	ldr	r2, [r3]
 80220d0: 69fb         	ldr	r3, [r7, #0x1c]
 80220d2: 601a         	str	r2, [r3]
; }
 80220d4: bf00         	nop
 80220d6: 3728         	adds	r7, #0x28
 80220d8: 46bd         	mov	sp, r7
 80220da: bd80         	pop	{r7, pc}

080220dc <uart_stm32_config_get>:
; {
 80220dc: b590         	push	{r4, r7, lr}
 80220de: b085         	sub	sp, #0x14
 80220e0: af00         	add	r7, sp, #0x0
 80220e2: 6078         	str	r0, [r7, #0x4]
 80220e4: 6039         	str	r1, [r7]
; 	struct uart_stm32_data *data = dev->data;
 80220e6: 687b         	ldr	r3, [r7, #0x4]
 80220e8: 691b         	ldr	r3, [r3, #0x10]
 80220ea: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 80220ec: 68fb         	ldr	r3, [r7, #0xc]
 80220ee: 685b         	ldr	r3, [r3, #0x4]
 80220f0: 60bb         	str	r3, [r7, #0x8]
; 	cfg->baudrate = uart_cfg->baudrate;
 80220f2: 68bb         	ldr	r3, [r7, #0x8]
 80220f4: 681a         	ldr	r2, [r3]
 80220f6: 683b         	ldr	r3, [r7]
 80220f8: 601a         	str	r2, [r3]
; 	cfg->parity = uart_stm32_ll2cfg_parity(uart_stm32_get_parity(dev));
 80220fa: 6878         	ldr	r0, [r7, #0x4]
 80220fc: f7ff fe26    	bl	0x8021d4c <uart_stm32_get_parity> @ imm = #-0x3b4
 8022100: 4603         	mov	r3, r0
 8022102: 4618         	mov	r0, r3
 8022104: f7ff feb4    	bl	0x8021e70 <uart_stm32_ll2cfg_parity> @ imm = #-0x298
 8022108: 4603         	mov	r3, r0
 802210a: 461a         	mov	r2, r3
 802210c: 683b         	ldr	r3, [r7]
 802210e: 711a         	strb	r2, [r3, #0x4]
; 	cfg->stop_bits = uart_stm32_ll2cfg_stopbits(
 8022110: 6878         	ldr	r0, [r7, #0x4]
 8022112: f7ff fe3e    	bl	0x8021d92 <uart_stm32_get_stopbits> @ imm = #-0x384
 8022116: 4603         	mov	r3, r0
 8022118: 4618         	mov	r0, r3
 802211a: f7ff fee0    	bl	0x8021ede <uart_stm32_ll2cfg_stopbits> @ imm = #-0x240
 802211e: 4603         	mov	r3, r0
 8022120: 461a         	mov	r2, r3
 8022122: 683b         	ldr	r3, [r7]
 8022124: 715a         	strb	r2, [r3, #0x5]
; 	cfg->data_bits = uart_stm32_ll2cfg_databits(
 8022126: 6878         	ldr	r0, [r7, #0x4]
 8022128: f7ff fe56    	bl	0x8021dd8 <uart_stm32_get_databits> @ imm = #-0x354
 802212c: 4604         	mov	r4, r0
 802212e: 6878         	ldr	r0, [r7, #0x4]
 8022130: f7ff fe0c    	bl	0x8021d4c <uart_stm32_get_parity> @ imm = #-0x3e8
 8022134: 4603         	mov	r3, r0
 8022136: 4619         	mov	r1, r3
 8022138: 4620         	mov	r0, r4
 802213a: f7ff ff0b    	bl	0x8021f54 <uart_stm32_ll2cfg_databits> @ imm = #-0x1ea
 802213e: 4603         	mov	r3, r0
 8022140: 461a         	mov	r2, r3
 8022142: 683b         	ldr	r3, [r7]
 8022144: 719a         	strb	r2, [r3, #0x6]
; 	cfg->flow_ctrl = uart_stm32_ll2cfg_hwctrl(
 8022146: 6878         	ldr	r0, [r7, #0x4]
 8022148: f7ff fe69    	bl	0x8021e1e <uart_stm32_get_hwctrl> @ imm = #-0x32e
 802214c: 4603         	mov	r3, r0
 802214e: 4618         	mov	r0, r3
 8022150: f7ff ff33    	bl	0x8021fba <uart_stm32_ll2cfg_hwctrl> @ imm = #-0x19a
 8022154: 4603         	mov	r3, r0
 8022156: 461a         	mov	r2, r3
 8022158: 683b         	ldr	r3, [r7]
 802215a: 71da         	strb	r2, [r3, #0x7]
; 	return 0;
 802215c: 2300         	movs	r3, #0x0
; }
 802215e: 4618         	mov	r0, r3
 8022160: 3714         	adds	r7, #0x14
 8022162: 46bd         	mov	sp, r7
 8022164: bd90         	pop	{r4, r7, pc}

08022166 <uart_stm32_poll_in_visitor>:
; {
 8022166: b580         	push	{r7, lr}
 8022168: b086         	sub	sp, #0x18
 802216a: af00         	add	r7, sp, #0x0
 802216c: 60f8         	str	r0, [r7, #0xc]
 802216e: 60b9         	str	r1, [r7, #0x8]
 8022170: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8022172: 68fb         	ldr	r3, [r7, #0xc]
 8022174: 685b         	ldr	r3, [r3, #0x4]
 8022176: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 8022178: 697b         	ldr	r3, [r7, #0x14]
 802217a: 681b         	ldr	r3, [r3]
 802217c: 613b         	str	r3, [r7, #0x10]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 802217e: 6938         	ldr	r0, [r7, #0x10]
 8022180: f7ff fa75    	bl	0x802166e <LL_USART_IsActiveFlag_ORE> @ imm = #-0xb16
 8022184: 4603         	mov	r3, r0
 8022186: 2b00         	cmp	r3, #0x0
 8022188: d002         	beq	0x8022190 <uart_stm32_poll_in_visitor+0x2a> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 802218a: 6938         	ldr	r0, [r7, #0x10]
 802218c: f7ff fb18    	bl	0x80217c0 <LL_USART_ClearFlag_ORE> @ imm = #-0x9d0
; 	if (!LL_USART_IsActiveFlag_RXNE(usart)) {
 8022190: 6938         	ldr	r0, [r7, #0x10]
 8022192: f7ff fa92    	bl	0x80216ba <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xadc
 8022196: 4603         	mov	r3, r0
 8022198: 2b00         	cmp	r3, #0x0
 802219a: d102         	bne	0x80221a2 <uart_stm32_poll_in_visitor+0x3c> @ imm = #0x4
; 		return -1;
 802219c: f04f 33ff    	mov.w	r3, #0xffffffff
 80221a0: e004         	b	0x80221ac <uart_stm32_poll_in_visitor+0x46> @ imm = #0x8
; 	get_fn(usart, in);
 80221a2: 687b         	ldr	r3, [r7, #0x4]
 80221a4: 68b9         	ldr	r1, [r7, #0x8]
 80221a6: 6938         	ldr	r0, [r7, #0x10]
 80221a8: 4798         	blx	r3
; 	return 0;
 80221aa: 2300         	movs	r3, #0x0
; }
 80221ac: 4618         	mov	r0, r3
 80221ae: 3718         	adds	r7, #0x18
 80221b0: 46bd         	mov	sp, r7
 80221b2: bd80         	pop	{r7, pc}

080221b4 <uart_stm32_poll_out_visitor>:
; {
 80221b4: b580         	push	{r7, lr}
 80221b6: b08e         	sub	sp, #0x38
 80221b8: af00         	add	r7, sp, #0x0
 80221ba: 60f8         	str	r0, [r7, #0xc]
 80221bc: 460b         	mov	r3, r1
 80221be: 607a         	str	r2, [r7, #0x4]
 80221c0: 817b         	strh	r3, [r7, #0xa]
; 	const struct uart_stm32_config *config = dev->config;
 80221c2: 68fb         	ldr	r3, [r7, #0xc]
 80221c4: 685b         	ldr	r3, [r3, #0x4]
 80221c6: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 80221c8: 6b7b         	ldr	r3, [r7, #0x34]
 80221ca: 681b         	ldr	r3, [r3]
 80221cc: 633b         	str	r3, [r7, #0x30]
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 80221ce: 6b38         	ldr	r0, [r7, #0x30]
 80221d0: f7ff fa99    	bl	0x8021706 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xace
 80221d4: 4603         	mov	r3, r0
 80221d6: 2b00         	cmp	r3, #0x0
 80221d8: d0f9         	beq	0x80221ce <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0xe
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80221da: f3ef 8311    	mrs	r3, basepri
 80221de: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 80221e0: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 80221e2: 627b         	str	r3, [r7, #0x24]
 80221e4: 2310         	movs	r3, #0x10
 80221e6: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80221e8: 6a3b         	ldr	r3, [r7, #0x20]
 80221ea: f383 8812    	msr	basepri_max, r3
; }
 80221ee: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80221f0: f3bf 8f6f    	isb	sy
; }
 80221f4: bf00         	nop
; 	return key;
 80221f6: 6a7b         	ldr	r3, [r7, #0x24]
; 			key = irq_lock();
 80221f8: 62fb         	str	r3, [r7, #0x2c]
; 			if (LL_USART_IsActiveFlag_TXE(usart)) {
 80221fa: 6b38         	ldr	r0, [r7, #0x30]
 80221fc: f7ff fa83    	bl	0x8021706 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xafa
 8022200: 4603         	mov	r3, r0
 8022202: 2b00         	cmp	r3, #0x0
 8022204: d10c         	bne	0x8022220 <uart_stm32_poll_out_visitor+0x6c> @ imm = #0x18
 8022206: 6afb         	ldr	r3, [r7, #0x2c]
 8022208: 61fb         	str	r3, [r7, #0x1c]
 802220a: 69fb         	ldr	r3, [r7, #0x1c]
 802220c: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 802220e: 69bb         	ldr	r3, [r7, #0x18]
 8022210: f383 8811    	msr	basepri, r3
; }
 8022214: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8022216: f3bf 8f6f    	isb	sy
; }
 802221a: bf00         	nop
; }
 802221c: bf00         	nop
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 802221e: e7d6         	b	0x80221ce <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0x54
; 				break;
 8022220: bf00         	nop
; 	set_fn(usart, out);
 8022222: 897a         	ldrh	r2, [r7, #0xa]
 8022224: 687b         	ldr	r3, [r7, #0x4]
 8022226: 4611         	mov	r1, r2
 8022228: 6b38         	ldr	r0, [r7, #0x30]
 802222a: 4798         	blx	r3
 802222c: 6afb         	ldr	r3, [r7, #0x2c]
 802222e: 617b         	str	r3, [r7, #0x14]
 8022230: 697b         	ldr	r3, [r7, #0x14]
 8022232: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8022234: 693b         	ldr	r3, [r7, #0x10]
 8022236: f383 8811    	msr	basepri, r3
; }
 802223a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 802223c: f3bf 8f6f    	isb	sy
; }
 8022240: bf00         	nop
; }
 8022242: bf00         	nop
; }
 8022244: bf00         	nop
 8022246: 3738         	adds	r7, #0x38
 8022248: 46bd         	mov	sp, r7
 802224a: bd80         	pop	{r7, pc}

0802224c <poll_in_u8>:
; {
 802224c: b580         	push	{r7, lr}
 802224e: b082         	sub	sp, #0x8
 8022250: af00         	add	r7, sp, #0x0
 8022252: 6078         	str	r0, [r7, #0x4]
 8022254: 6039         	str	r1, [r7]
; 	*((unsigned char *)in) = (unsigned char)LL_USART_ReceiveData8(usart);
 8022256: 6878         	ldr	r0, [r7, #0x4]
 8022258: f7ff fd2c    	bl	0x8021cb4 <LL_USART_ReceiveData8> @ imm = #-0x5a8
 802225c: 4603         	mov	r3, r0
 802225e: 461a         	mov	r2, r3
 8022260: 683b         	ldr	r3, [r7]
 8022262: 701a         	strb	r2, [r3]
; }
 8022264: bf00         	nop
 8022266: 3708         	adds	r7, #0x8
 8022268: 46bd         	mov	sp, r7
 802226a: bd80         	pop	{r7, pc}

0802226c <poll_out_u8>:
; {
 802226c: b580         	push	{r7, lr}
 802226e: b082         	sub	sp, #0x8
 8022270: af00         	add	r7, sp, #0x0
 8022272: 6078         	str	r0, [r7, #0x4]
 8022274: 460b         	mov	r3, r1
 8022276: 807b         	strh	r3, [r7, #0x2]
; 	LL_USART_TransmitData8(usart, (uint8_t)out);
 8022278: 887b         	ldrh	r3, [r7, #0x2]
 802227a: b2db         	uxtb	r3, r3
 802227c: 4619         	mov	r1, r3
 802227e: 6878         	ldr	r0, [r7, #0x4]
 8022280: f7ff fd25    	bl	0x8021cce <LL_USART_TransmitData8> @ imm = #-0x5b6
; }
 8022284: bf00         	nop
 8022286: 3708         	adds	r7, #0x8
 8022288: 46bd         	mov	sp, r7
 802228a: bd80         	pop	{r7, pc}

0802228c <uart_stm32_err_check>:
; {
 802228c: b580         	push	{r7, lr}
 802228e: b086         	sub	sp, #0x18
 8022290: af00         	add	r7, sp, #0x0
 8022292: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8022294: 687b         	ldr	r3, [r7, #0x4]
 8022296: 685b         	ldr	r3, [r3, #0x4]
 8022298: 613b         	str	r3, [r7, #0x10]
; 	USART_TypeDef *usart = config->usart;
 802229a: 693b         	ldr	r3, [r7, #0x10]
 802229c: 681b         	ldr	r3, [r3]
 802229e: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t err = 0U;
 80222a0: 2300         	movs	r3, #0x0
 80222a2: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 80222a4: 68f8         	ldr	r0, [r7, #0xc]
 80222a6: f7ff f9e2    	bl	0x802166e <LL_USART_IsActiveFlag_ORE> @ imm = #-0xc3c
 80222aa: 4603         	mov	r3, r0
 80222ac: 2b00         	cmp	r3, #0x0
 80222ae: d003         	beq	0x80222b8 <uart_stm32_err_check+0x2c> @ imm = #0x6
; 		err |= UART_ERROR_OVERRUN;
 80222b0: 697b         	ldr	r3, [r7, #0x14]
 80222b2: f043 0301    	orr	r3, r3, #0x1
 80222b6: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_PE(usart)) {
 80222b8: 68f8         	ldr	r0, [r7, #0xc]
 80222ba: f7ff f99f    	bl	0x80215fc <LL_USART_IsActiveFlag_PE> @ imm = #-0xcc2
 80222be: 4603         	mov	r3, r0
 80222c0: 2b00         	cmp	r3, #0x0
 80222c2: d003         	beq	0x80222cc <uart_stm32_err_check+0x40> @ imm = #0x6
; 		err |= UART_ERROR_PARITY;
 80222c4: 697b         	ldr	r3, [r7, #0x14]
 80222c6: f043 0302    	orr	r3, r3, #0x2
 80222ca: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_FE(usart)) {
 80222cc: 68f8         	ldr	r0, [r7, #0xc]
 80222ce: f7ff f9a8    	bl	0x8021622 <LL_USART_IsActiveFlag_FE> @ imm = #-0xcb0
 80222d2: 4603         	mov	r3, r0
 80222d4: 2b00         	cmp	r3, #0x0
 80222d6: d003         	beq	0x80222e0 <uart_stm32_err_check+0x54> @ imm = #0x6
; 		err |= UART_ERROR_FRAMING;
 80222d8: 697b         	ldr	r3, [r7, #0x14]
 80222da: f043 0304    	orr	r3, r3, #0x4
 80222de: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_NE(usart)) {
 80222e0: 68f8         	ldr	r0, [r7, #0xc]
 80222e2: f7ff f9b1    	bl	0x8021648 <LL_USART_IsActiveFlag_NE> @ imm = #-0xc9e
 80222e6: 4603         	mov	r3, r0
 80222e8: 2b00         	cmp	r3, #0x0
 80222ea: d003         	beq	0x80222f4 <uart_stm32_err_check+0x68> @ imm = #0x6
; 		err |= UART_ERROR_NOISE;
 80222ec: 697b         	ldr	r3, [r7, #0x14]
 80222ee: f043 0320    	orr	r3, r3, #0x20
 80222f2: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_LBD(usart)) {
 80222f4: 68f8         	ldr	r0, [r7, #0xc]
 80222f6: f7ff fa19    	bl	0x802172c <LL_USART_IsActiveFlag_LBD> @ imm = #-0xbce
 80222fa: 4603         	mov	r3, r0
 80222fc: 2b00         	cmp	r3, #0x0
 80222fe: d003         	beq	0x8022308 <uart_stm32_err_check+0x7c> @ imm = #0x6
; 		err |= UART_BREAK;
 8022300: 697b         	ldr	r3, [r7, #0x14]
 8022302: f043 0308    	orr	r3, r3, #0x8
 8022306: 617b         	str	r3, [r7, #0x14]
; 	if (err & UART_BREAK) {
 8022308: 697b         	ldr	r3, [r7, #0x14]
 802230a: f003 0308    	and	r3, r3, #0x8
 802230e: 2b00         	cmp	r3, #0x0
 8022310: d002         	beq	0x8022318 <uart_stm32_err_check+0x8c> @ imm = #0x4
; 		LL_USART_ClearFlag_LBD(usart);
 8022312: 68f8         	ldr	r0, [r7, #0xc]
 8022314: f7ff fa94    	bl	0x8021840 <LL_USART_ClearFlag_LBD> @ imm = #-0xad8
; 	if (err & UART_ERROR_OVERRUN) {
 8022318: 697b         	ldr	r3, [r7, #0x14]
 802231a: f003 0301    	and	r3, r3, #0x1
 802231e: 2b00         	cmp	r3, #0x0
 8022320: d002         	beq	0x8022328 <uart_stm32_err_check+0x9c> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 8022322: 68f8         	ldr	r0, [r7, #0xc]
 8022324: f7ff fa4c    	bl	0x80217c0 <LL_USART_ClearFlag_ORE> @ imm = #-0xb68
; 	if (err & UART_ERROR_PARITY) {
 8022328: 697b         	ldr	r3, [r7, #0x14]
 802232a: f003 0302    	and	r3, r3, #0x2
 802232e: 2b00         	cmp	r3, #0x0
 8022330: d002         	beq	0x8022338 <uart_stm32_err_check+0xac> @ imm = #0x4
; 		LL_USART_ClearFlag_PE(usart);
 8022332: 68f8         	ldr	r0, [r7, #0xc]
 8022334: f7ff fa0e    	bl	0x8021754 <LL_USART_ClearFlag_PE> @ imm = #-0xbe4
; 	if (err & UART_ERROR_FRAMING) {
 8022338: 697b         	ldr	r3, [r7, #0x14]
 802233a: f003 0304    	and	r3, r3, #0x4
 802233e: 2b00         	cmp	r3, #0x0
 8022340: d002         	beq	0x8022348 <uart_stm32_err_check+0xbc> @ imm = #0x4
; 		LL_USART_ClearFlag_FE(usart);
 8022342: 68f8         	ldr	r0, [r7, #0xc]
 8022344: f7ff fa18    	bl	0x8021778 <LL_USART_ClearFlag_FE> @ imm = #-0xbd0
; 	if (err & UART_ERROR_NOISE) {
 8022348: 697b         	ldr	r3, [r7, #0x14]
 802234a: f003 0320    	and	r3, r3, #0x20
 802234e: 2b00         	cmp	r3, #0x0
 8022350: d002         	beq	0x8022358 <uart_stm32_err_check+0xcc> @ imm = #0x4
; 		LL_USART_ClearFlag_NE(usart);
 8022352: 68f8         	ldr	r0, [r7, #0xc]
 8022354: f7ff fa22    	bl	0x802179c <LL_USART_ClearFlag_NE> @ imm = #-0xbbc
; 	return err;
 8022358: 697b         	ldr	r3, [r7, #0x14]
; }
 802235a: 4618         	mov	r0, r3
 802235c: 3718         	adds	r7, #0x18
 802235e: 46bd         	mov	sp, r7
 8022360: bd80         	pop	{r7, pc}

08022362 <uart_stm32_fifo_fill_visitor>:
; {
 8022362: b580         	push	{r7, lr}
 8022364: b08e         	sub	sp, #0x38
 8022366: af00         	add	r7, sp, #0x0
 8022368: 60f8         	str	r0, [r7, #0xc]
 802236a: 60b9         	str	r1, [r7, #0x8]
 802236c: 607a         	str	r2, [r7, #0x4]
 802236e: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8022370: 68fb         	ldr	r3, [r7, #0xc]
 8022372: 685b         	ldr	r3, [r3, #0x4]
 8022374: 633b         	str	r3, [r7, #0x30]
; 	USART_TypeDef *usart = config->usart;
 8022376: 6b3b         	ldr	r3, [r7, #0x30]
 8022378: 681b         	ldr	r3, [r3]
 802237a: 62fb         	str	r3, [r7, #0x2c]
; 	int num_tx = 0U;
 802237c: 2300         	movs	r3, #0x0
 802237e: 637b         	str	r3, [r7, #0x34]
; 	if (!LL_USART_IsActiveFlag_TXE(usart)) {
 8022380: 6af8         	ldr	r0, [r7, #0x2c]
 8022382: f7ff f9c0    	bl	0x8021706 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xc80
 8022386: 4603         	mov	r3, r0
 8022388: 2b00         	cmp	r3, #0x0
 802238a: d101         	bne	0x8022390 <uart_stm32_fifo_fill_visitor+0x2e> @ imm = #0x2
; 		return num_tx;
 802238c: 6b7b         	ldr	r3, [r7, #0x34]
 802238e: e030         	b	0x80223f2 <uart_stm32_fifo_fill_visitor+0x90> @ imm = #0x60
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8022390: f3ef 8311    	mrs	r3, basepri
 8022394: 627b         	str	r3, [r7, #0x24]
;   return(result);
 8022396: 6a7b         	ldr	r3, [r7, #0x24]
; 	key = __get_BASEPRI();
 8022398: 623b         	str	r3, [r7, #0x20]
 802239a: 2310         	movs	r3, #0x10
 802239c: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 802239e: 69fb         	ldr	r3, [r7, #0x1c]
 80223a0: f383 8812    	msr	basepri_max, r3
; }
 80223a4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80223a6: f3bf 8f6f    	isb	sy
; }
 80223aa: bf00         	nop
; 	return key;
 80223ac: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = irq_lock();
 80223ae: 62bb         	str	r3, [r7, #0x28]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 80223b0: e007         	b	0x80223c2 <uart_stm32_fifo_fill_visitor+0x60> @ imm = #0xe
; 		fill_fn(usart, tx_data, num_tx);
 80223b2: 683b         	ldr	r3, [r7]
 80223b4: 6b7a         	ldr	r2, [r7, #0x34]
 80223b6: 68b9         	ldr	r1, [r7, #0x8]
 80223b8: 6af8         	ldr	r0, [r7, #0x2c]
 80223ba: 4798         	blx	r3
; 		num_tx++;
 80223bc: 6b7b         	ldr	r3, [r7, #0x34]
 80223be: 3301         	adds	r3, #0x1
 80223c0: 637b         	str	r3, [r7, #0x34]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 80223c2: 687a         	ldr	r2, [r7, #0x4]
 80223c4: 6b7b         	ldr	r3, [r7, #0x34]
 80223c6: 1ad3         	subs	r3, r2, r3
 80223c8: 2b00         	cmp	r3, #0x0
 80223ca: dd05         	ble	0x80223d8 <uart_stm32_fifo_fill_visitor+0x76> @ imm = #0xa
 80223cc: 6af8         	ldr	r0, [r7, #0x2c]
 80223ce: f7ff f99a    	bl	0x8021706 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xccc
 80223d2: 4603         	mov	r3, r0
 80223d4: 2b00         	cmp	r3, #0x0
 80223d6: d1ec         	bne	0x80223b2 <uart_stm32_fifo_fill_visitor+0x50> @ imm = #-0x28
 80223d8: 6abb         	ldr	r3, [r7, #0x28]
 80223da: 61bb         	str	r3, [r7, #0x18]
 80223dc: 69bb         	ldr	r3, [r7, #0x18]
 80223de: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80223e0: 697b         	ldr	r3, [r7, #0x14]
 80223e2: f383 8811    	msr	basepri, r3
; }
 80223e6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80223e8: f3bf 8f6f    	isb	sy
; }
 80223ec: bf00         	nop
; }
 80223ee: bf00         	nop
; 	return num_tx;
 80223f0: 6b7b         	ldr	r3, [r7, #0x34]
; }
 80223f2: 4618         	mov	r0, r3
 80223f4: 3738         	adds	r7, #0x38
 80223f6: 46bd         	mov	sp, r7
 80223f8: bd80         	pop	{r7, pc}

080223fa <fifo_fill_with_u8>:
; {
 80223fa: b580         	push	{r7, lr}
 80223fc: b086         	sub	sp, #0x18
 80223fe: af00         	add	r7, sp, #0x0
 8022400: 60f8         	str	r0, [r7, #0xc]
 8022402: 60b9         	str	r1, [r7, #0x8]
 8022404: 607a         	str	r2, [r7, #0x4]
; 	const uint8_t *data = (const uint8_t *)tx_data;
 8022406: 68bb         	ldr	r3, [r7, #0x8]
 8022408: 617b         	str	r3, [r7, #0x14]
; 	LL_USART_TransmitData8(usart, data[offset]);
 802240a: 687b         	ldr	r3, [r7, #0x4]
 802240c: 697a         	ldr	r2, [r7, #0x14]
 802240e: 4413         	add	r3, r2
 8022410: 781b         	ldrb	r3, [r3]
 8022412: 4619         	mov	r1, r3
 8022414: 68f8         	ldr	r0, [r7, #0xc]
 8022416: f7ff fc5a    	bl	0x8021cce <LL_USART_TransmitData8> @ imm = #-0x74c
; }
 802241a: bf00         	nop
 802241c: 3718         	adds	r7, #0x18
 802241e: 46bd         	mov	sp, r7
 8022420: bd80         	pop	{r7, pc}

08022422 <uart_stm32_fifo_read_visitor>:
; {
 8022422: b580         	push	{r7, lr}
 8022424: b088         	sub	sp, #0x20
 8022426: af00         	add	r7, sp, #0x0
 8022428: 60f8         	str	r0, [r7, #0xc]
 802242a: 60b9         	str	r1, [r7, #0x8]
 802242c: 607a         	str	r2, [r7, #0x4]
 802242e: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8022430: 68fb         	ldr	r3, [r7, #0xc]
 8022432: 685b         	ldr	r3, [r3, #0x4]
 8022434: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 8022436: 69bb         	ldr	r3, [r7, #0x18]
 8022438: 681b         	ldr	r3, [r3]
 802243a: 617b         	str	r3, [r7, #0x14]
; 	int num_rx = 0U;
 802243c: 2300         	movs	r3, #0x0
 802243e: 61fb         	str	r3, [r7, #0x1c]
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 8022440: e010         	b	0x8022464 <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x20
; 		read_fn(usart, rx_data, num_rx);
 8022442: 683b         	ldr	r3, [r7]
 8022444: 69fa         	ldr	r2, [r7, #0x1c]
 8022446: 68b9         	ldr	r1, [r7, #0x8]
 8022448: 6978         	ldr	r0, [r7, #0x14]
 802244a: 4798         	blx	r3
; 		num_rx++;
 802244c: 69fb         	ldr	r3, [r7, #0x1c]
 802244e: 3301         	adds	r3, #0x1
 8022450: 61fb         	str	r3, [r7, #0x1c]
; 		if (LL_USART_IsActiveFlag_ORE(usart)) {
 8022452: 6978         	ldr	r0, [r7, #0x14]
 8022454: f7ff f90b    	bl	0x802166e <LL_USART_IsActiveFlag_ORE> @ imm = #-0xdea
 8022458: 4603         	mov	r3, r0
 802245a: 2b00         	cmp	r3, #0x0
 802245c: d002         	beq	0x8022464 <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x4
; 			LL_USART_ClearFlag_ORE(usart);
 802245e: 6978         	ldr	r0, [r7, #0x14]
 8022460: f7ff f9ae    	bl	0x80217c0 <LL_USART_ClearFlag_ORE> @ imm = #-0xca4
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 8022464: 687a         	ldr	r2, [r7, #0x4]
 8022466: 69fb         	ldr	r3, [r7, #0x1c]
 8022468: 1ad3         	subs	r3, r2, r3
 802246a: 2b00         	cmp	r3, #0x0
 802246c: dd05         	ble	0x802247a <uart_stm32_fifo_read_visitor+0x58> @ imm = #0xa
 802246e: 6978         	ldr	r0, [r7, #0x14]
 8022470: f7ff f923    	bl	0x80216ba <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xdba
 8022474: 4603         	mov	r3, r0
 8022476: 2b00         	cmp	r3, #0x0
 8022478: d1e3         	bne	0x8022442 <uart_stm32_fifo_read_visitor+0x20> @ imm = #-0x3a
; 	return num_rx;
 802247a: 69fb         	ldr	r3, [r7, #0x1c]
; }
 802247c: 4618         	mov	r0, r3
 802247e: 3720         	adds	r7, #0x20
 8022480: 46bd         	mov	sp, r7
 8022482: bd80         	pop	{r7, pc}

08022484 <fifo_read_with_u8>:
; {
 8022484: b590         	push	{r4, r7, lr}
 8022486: b087         	sub	sp, #0x1c
 8022488: af00         	add	r7, sp, #0x0
 802248a: 60f8         	str	r0, [r7, #0xc]
 802248c: 60b9         	str	r1, [r7, #0x8]
 802248e: 607a         	str	r2, [r7, #0x4]
; 	uint8_t *data = (uint8_t *)rx_data;
 8022490: 68bb         	ldr	r3, [r7, #0x8]
 8022492: 617b         	str	r3, [r7, #0x14]
; 	data[offset] = LL_USART_ReceiveData8(usart);
 8022494: 687b         	ldr	r3, [r7, #0x4]
 8022496: 697a         	ldr	r2, [r7, #0x14]
 8022498: 18d4         	adds	r4, r2, r3
 802249a: 68f8         	ldr	r0, [r7, #0xc]
 802249c: f7ff fc0a    	bl	0x8021cb4 <LL_USART_ReceiveData8> @ imm = #-0x7ec
 80224a0: 4603         	mov	r3, r0
 80224a2: 7023         	strb	r3, [r4]
; }
 80224a4: bf00         	nop
 80224a6: 371c         	adds	r7, #0x1c
 80224a8: 46bd         	mov	sp, r7
 80224aa: bd90         	pop	{r4, r7, pc}

080224ac <uart_stm32_irq_tx_enable>:
; {
 80224ac: b580         	push	{r7, lr}
 80224ae: b084         	sub	sp, #0x10
 80224b0: af00         	add	r7, sp, #0x0
 80224b2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80224b4: 687b         	ldr	r3, [r7, #0x4]
 80224b6: 685b         	ldr	r3, [r3, #0x4]
 80224b8: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_TC(config->usart);
 80224ba: 68fb         	ldr	r3, [r7, #0xc]
 80224bc: 681b         	ldr	r3, [r3]
 80224be: 4618         	mov	r0, r3
 80224c0: f7ff fa12    	bl	0x80218e8 <LL_USART_EnableIT_TC> @ imm = #-0xbdc
; }
 80224c4: bf00         	nop
 80224c6: 3710         	adds	r7, #0x10
 80224c8: 46bd         	mov	sp, r7
 80224ca: bd80         	pop	{r7, pc}

080224cc <uart_stm32_irq_tx_disable>:
; {
 80224cc: b580         	push	{r7, lr}
 80224ce: b084         	sub	sp, #0x10
 80224d0: af00         	add	r7, sp, #0x0
 80224d2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80224d4: 687b         	ldr	r3, [r7, #0x4]
 80224d6: 685b         	ldr	r3, [r3, #0x4]
 80224d8: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_TC(config->usart);
 80224da: 68fb         	ldr	r3, [r7, #0xc]
 80224dc: 681b         	ldr	r3, [r3]
 80224de: 4618         	mov	r0, r3
 80224e0: f7ff fac1    	bl	0x8021a66 <LL_USART_DisableIT_TC> @ imm = #-0xa7e
; }
 80224e4: bf00         	nop
 80224e6: 3710         	adds	r7, #0x10
 80224e8: 46bd         	mov	sp, r7
 80224ea: bd80         	pop	{r7, pc}

080224ec <uart_stm32_irq_tx_ready>:
; {
 80224ec: b580         	push	{r7, lr}
 80224ee: b084         	sub	sp, #0x10
 80224f0: af00         	add	r7, sp, #0x0
 80224f2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80224f4: 687b         	ldr	r3, [r7, #0x4]
 80224f6: 685b         	ldr	r3, [r3, #0x4]
 80224f8: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 80224fa: 68fb         	ldr	r3, [r7, #0xc]
 80224fc: 681b         	ldr	r3, [r3]
 80224fe: 4618         	mov	r0, r3
 8022500: f7ff f901    	bl	0x8021706 <LL_USART_IsActiveFlag_TXE> @ imm = #-0xdfe
 8022504: 4603         	mov	r3, r0
 8022506: 2b00         	cmp	r3, #0x0
 8022508: d009         	beq	0x802251e <uart_stm32_irq_tx_ready+0x32> @ imm = #0x12
; 		LL_USART_IsEnabledIT_TC(config->usart);
 802250a: 68fb         	ldr	r3, [r7, #0xc]
 802250c: 681b         	ldr	r3, [r3]
 802250e: 4618         	mov	r0, r3
 8022510: f7ff fb48    	bl	0x8021ba4 <LL_USART_IsEnabledIT_TC> @ imm = #-0x970
 8022514: 4603         	mov	r3, r0
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 8022516: 2b00         	cmp	r3, #0x0
 8022518: d001         	beq	0x802251e <uart_stm32_irq_tx_ready+0x32> @ imm = #0x2
 802251a: 2301         	movs	r3, #0x1
 802251c: e000         	b	0x8022520 <uart_stm32_irq_tx_ready+0x34> @ imm = #0x0
 802251e: 2300         	movs	r3, #0x0
; }
 8022520: 4618         	mov	r0, r3
 8022522: 3710         	adds	r7, #0x10
 8022524: 46bd         	mov	sp, r7
 8022526: bd80         	pop	{r7, pc}

08022528 <uart_stm32_irq_tx_complete>:
; {
 8022528: b580         	push	{r7, lr}
 802252a: b084         	sub	sp, #0x10
 802252c: af00         	add	r7, sp, #0x0
 802252e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8022530: 687b         	ldr	r3, [r7, #0x4]
 8022532: 685b         	ldr	r3, [r3, #0x4]
 8022534: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TC(config->usart);
 8022536: 68fb         	ldr	r3, [r7, #0xc]
 8022538: 681b         	ldr	r3, [r3]
 802253a: 4618         	mov	r0, r3
 802253c: f7ff f8d0    	bl	0x80216e0 <LL_USART_IsActiveFlag_TC> @ imm = #-0xe60
 8022540: 4603         	mov	r3, r0
; }
 8022542: 4618         	mov	r0, r3
 8022544: 3710         	adds	r7, #0x10
 8022546: 46bd         	mov	sp, r7
 8022548: bd80         	pop	{r7, pc}

0802254a <uart_stm32_irq_rx_enable>:
; {
 802254a: b580         	push	{r7, lr}
 802254c: b084         	sub	sp, #0x10
 802254e: af00         	add	r7, sp, #0x0
 8022550: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8022552: 687b         	ldr	r3, [r7, #0x4]
 8022554: 685b         	ldr	r3, [r3, #0x4]
 8022556: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_RXNE(config->usart);
 8022558: 68fb         	ldr	r3, [r7, #0xc]
 802255a: 681b         	ldr	r3, [r3]
 802255c: 4618         	mov	r0, r3
 802255e: f7ff f9a0    	bl	0x80218a2 <LL_USART_EnableIT_RXNE> @ imm = #-0xcc0
; }
 8022562: bf00         	nop
 8022564: 3710         	adds	r7, #0x10
 8022566: 46bd         	mov	sp, r7
 8022568: bd80         	pop	{r7, pc}

0802256a <uart_stm32_irq_rx_disable>:
; {
 802256a: b580         	push	{r7, lr}
 802256c: b084         	sub	sp, #0x10
 802256e: af00         	add	r7, sp, #0x0
 8022570: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8022572: 687b         	ldr	r3, [r7, #0x4]
 8022574: 685b         	ldr	r3, [r3, #0x4]
 8022576: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_RXNE(config->usart);
 8022578: 68fb         	ldr	r3, [r7, #0xc]
 802257a: 681b         	ldr	r3, [r3]
 802257c: 4618         	mov	r0, r3
 802257e: f7ff fa4f    	bl	0x8021a20 <LL_USART_DisableIT_RXNE> @ imm = #-0xb62
; }
 8022582: bf00         	nop
 8022584: 3710         	adds	r7, #0x10
 8022586: 46bd         	mov	sp, r7
 8022588: bd80         	pop	{r7, pc}

0802258a <uart_stm32_irq_rx_ready>:
; {
 802258a: b580         	push	{r7, lr}
 802258c: b084         	sub	sp, #0x10
 802258e: af00         	add	r7, sp, #0x0
 8022590: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8022592: 687b         	ldr	r3, [r7, #0x4]
 8022594: 685b         	ldr	r3, [r3, #0x4]
 8022596: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_RXNE(config->usart);
 8022598: 68fb         	ldr	r3, [r7, #0xc]
 802259a: 681b         	ldr	r3, [r3]
 802259c: 4618         	mov	r0, r3
 802259e: f7ff f88c    	bl	0x80216ba <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xee8
 80225a2: 4603         	mov	r3, r0
; }
 80225a4: 4618         	mov	r0, r3
 80225a6: 3710         	adds	r7, #0x10
 80225a8: 46bd         	mov	sp, r7
 80225aa: bd80         	pop	{r7, pc}

080225ac <uart_stm32_irq_is_pending>:
; {
 80225ac: b580         	push	{r7, lr}
 80225ae: b084         	sub	sp, #0x10
 80225b0: af00         	add	r7, sp, #0x0
 80225b2: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80225b4: 687b         	ldr	r3, [r7, #0x4]
 80225b6: 685b         	ldr	r3, [r3, #0x4]
 80225b8: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 80225ba: 68fb         	ldr	r3, [r7, #0xc]
 80225bc: 681b         	ldr	r3, [r3]
 80225be: 60bb         	str	r3, [r7, #0x8]
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 80225c0: 68b8         	ldr	r0, [r7, #0x8]
 80225c2: f7ff f87a    	bl	0x80216ba <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xf0c
 80225c6: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 80225c8: 2b00         	cmp	r3, #0x0
 80225ca: d005         	beq	0x80225d8 <uart_stm32_irq_is_pending+0x2c> @ imm = #0xa
 80225cc: 68b8         	ldr	r0, [r7, #0x8]
 80225ce: f7ff fad6    	bl	0x8021b7e <LL_USART_IsEnabledIT_RXNE> @ imm = #-0xa54
 80225d2: 4603         	mov	r3, r0
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 80225d4: 2b00         	cmp	r3, #0x0
 80225d6: d10b         	bne	0x80225f0 <uart_stm32_irq_is_pending+0x44> @ imm = #0x16
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 80225d8: 68b8         	ldr	r0, [r7, #0x8]
 80225da: f7ff f881    	bl	0x80216e0 <LL_USART_IsActiveFlag_TC> @ imm = #-0xefe
 80225de: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 80225e0: 2b00         	cmp	r3, #0x0
 80225e2: d007         	beq	0x80225f4 <uart_stm32_irq_is_pending+0x48> @ imm = #0xe
; 		 LL_USART_IsEnabledIT_TC(usart)));
 80225e4: 68b8         	ldr	r0, [r7, #0x8]
 80225e6: f7ff fadd    	bl	0x8021ba4 <LL_USART_IsEnabledIT_TC> @ imm = #-0xa46
 80225ea: 4603         	mov	r3, r0
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 80225ec: 2b00         	cmp	r3, #0x0
 80225ee: d001         	beq	0x80225f4 <uart_stm32_irq_is_pending+0x48> @ imm = #0x2
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 80225f0: 2301         	movs	r3, #0x1
 80225f2: e000         	b	0x80225f6 <uart_stm32_irq_is_pending+0x4a> @ imm = #0x0
 80225f4: 2300         	movs	r3, #0x0
; }
 80225f6: 4618         	mov	r0, r3
 80225f8: 3710         	adds	r7, #0x10
 80225fa: 46bd         	mov	sp, r7
 80225fc: bd80         	pop	{r7, pc}

080225fe <uart_stm32_irq_update>:
; {
 80225fe: b480         	push	{r7}
 8022600: b083         	sub	sp, #0xc
 8022602: af00         	add	r7, sp, #0x0
 8022604: 6078         	str	r0, [r7, #0x4]
; 	return 1;
 8022606: 2301         	movs	r3, #0x1
; }
 8022608: 4618         	mov	r0, r3
 802260a: 370c         	adds	r7, #0xc
 802260c: 46bd         	mov	sp, r7
 802260e: f85d 7b04    	ldr	r7, [sp], #4
 8022612: 4770         	bx	lr

08022614 <uart_stm32_irq_callback_set>:
; {
 8022614: b480         	push	{r7}
 8022616: b087         	sub	sp, #0x1c
 8022618: af00         	add	r7, sp, #0x0
 802261a: 60f8         	str	r0, [r7, #0xc]
 802261c: 60b9         	str	r1, [r7, #0x8]
 802261e: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 8022620: 68fb         	ldr	r3, [r7, #0xc]
 8022622: 691b         	ldr	r3, [r3, #0x10]
 8022624: 617b         	str	r3, [r7, #0x14]
; 	data->user_cb = cb;
 8022626: 697b         	ldr	r3, [r7, #0x14]
 8022628: 68ba         	ldr	r2, [r7, #0x8]
 802262a: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = cb_data;
 802262c: 697b         	ldr	r3, [r7, #0x14]
 802262e: 687a         	ldr	r2, [r7, #0x4]
 8022630: 60da         	str	r2, [r3, #0xc]
; 	data->async_cb = NULL;
 8022632: 697b         	ldr	r3, [r7, #0x14]
 8022634: 2200         	movs	r2, #0x0
 8022636: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = NULL;
 8022638: 697b         	ldr	r3, [r7, #0x14]
 802263a: 2200         	movs	r2, #0x0
 802263c: 619a         	str	r2, [r3, #0x18]
; }
 802263e: bf00         	nop
 8022640: 371c         	adds	r7, #0x1c
 8022642: 46bd         	mov	sp, r7
 8022644: f85d 7b04    	ldr	r7, [sp], #4
 8022648: 4770         	bx	lr

0802264a <async_user_callback>:
; {
 802264a: b580         	push	{r7, lr}
 802264c: b082         	sub	sp, #0x8
 802264e: af00         	add	r7, sp, #0x0
 8022650: 6078         	str	r0, [r7, #0x4]
 8022652: 6039         	str	r1, [r7]
; 	if (data->async_cb) {
 8022654: 687b         	ldr	r3, [r7, #0x4]
 8022656: 695b         	ldr	r3, [r3, #0x14]
 8022658: 2b00         	cmp	r3, #0x0
 802265a: d007         	beq	0x802266c <async_user_callback+0x22> @ imm = #0xe
; 		data->async_cb(data->uart_dev, event, data->async_user_data);
 802265c: 687b         	ldr	r3, [r7, #0x4]
 802265e: 695b         	ldr	r3, [r3, #0x14]
 8022660: 687a         	ldr	r2, [r7, #0x4]
 8022662: 6910         	ldr	r0, [r2, #0x10]
 8022664: 687a         	ldr	r2, [r7, #0x4]
 8022666: 6992         	ldr	r2, [r2, #0x18]
 8022668: 6839         	ldr	r1, [r7]
 802266a: 4798         	blx	r3
; }
 802266c: bf00         	nop
 802266e: 3708         	adds	r7, #0x8
 8022670: 46bd         	mov	sp, r7
 8022672: bd80         	pop	{r7, pc}

08022674 <async_evt_rx_buf_request>:
; {
 8022674: b580         	push	{r7, lr}
 8022676: b088         	sub	sp, #0x20
 8022678: af00         	add	r7, sp, #0x0
 802267a: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 802267c: f107 030c    	add.w	r3, r7, #0xc
 8022680: 2200         	movs	r2, #0x0
 8022682: 601a         	str	r2, [r3]
 8022684: 605a         	str	r2, [r3, #0x4]
 8022686: 609a         	str	r2, [r3, #0x8]
 8022688: 60da         	str	r2, [r3, #0xc]
 802268a: 611a         	str	r2, [r3, #0x10]
 802268c: 2303         	movs	r3, #0x3
 802268e: 733b         	strb	r3, [r7, #0xc]
; 	async_user_callback(data, &evt);
 8022690: f107 030c    	add.w	r3, r7, #0xc
 8022694: 4619         	mov	r1, r3
 8022696: 6878         	ldr	r0, [r7, #0x4]
 8022698: f7ff ffd7    	bl	0x802264a <async_user_callback> @ imm = #-0x52
; }
 802269c: bf00         	nop
 802269e: 3720         	adds	r7, #0x20
 80226a0: 46bd         	mov	sp, r7
 80226a2: bd80         	pop	{r7, pc}

080226a4 <async_evt_rx_buf_release>:
; {
 80226a4: b580         	push	{r7, lr}
 80226a6: b088         	sub	sp, #0x20
 80226a8: af00         	add	r7, sp, #0x0
 80226aa: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 80226ac: f107 030c    	add.w	r3, r7, #0xc
 80226b0: 2200         	movs	r2, #0x0
 80226b2: 601a         	str	r2, [r3]
 80226b4: 605a         	str	r2, [r3, #0x4]
 80226b6: 609a         	str	r2, [r3, #0x8]
 80226b8: 60da         	str	r2, [r3, #0xc]
 80226ba: 611a         	str	r2, [r3, #0x10]
 80226bc: 2304         	movs	r3, #0x4
 80226be: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx_buf.buf = data->dma_rx.buffer,
 80226c0: 687b         	ldr	r3, [r7, #0x4]
 80226c2: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event evt = {
 80226c4: 613b         	str	r3, [r7, #0x10]
; 	async_user_callback(data, &evt);
 80226c6: f107 030c    	add.w	r3, r7, #0xc
 80226ca: 4619         	mov	r1, r3
 80226cc: 6878         	ldr	r0, [r7, #0x4]
 80226ce: f7ff ffbc    	bl	0x802264a <async_user_callback> @ imm = #-0x88
; }
 80226d2: bf00         	nop
 80226d4: 3720         	adds	r7, #0x20
 80226d6: 46bd         	mov	sp, r7
 80226d8: bd80         	pop	{r7, pc}

080226da <uart_stm32_dma_rx_flush>:
; {
 80226da: b580         	push	{r7, lr}
 80226dc: b08c         	sub	sp, #0x30
 80226de: af00         	add	r7, sp, #0x0
 80226e0: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 80226e2: 687b         	ldr	r3, [r7, #0x4]
 80226e4: 691b         	ldr	r3, [r3, #0x10]
 80226e6: 62fb         	str	r3, [r7, #0x2c]
; 	if (dma_get_status(data->dma_rx.dma_dev,
 80226e8: 6afb         	ldr	r3, [r7, #0x2c]
 80226ea: 6a18         	ldr	r0, [r3, #0x20]
 80226ec: 6afb         	ldr	r3, [r7, #0x2c]
 80226ee: 6a5b         	ldr	r3, [r3, #0x24]
 80226f0: f107 0208    	add.w	r2, r7, #0x8
 80226f4: 4619         	mov	r1, r3
 80226f6: f7fe fdd5    	bl	0x80212a4 <dma_get_status> @ imm = #-0x1456
 80226fa: 4603         	mov	r3, r0
 80226fc: 2b00         	cmp	r3, #0x0
 80226fe: d10f         	bne	0x8022720 <uart_stm32_dma_rx_flush+0x46> @ imm = #0x1e
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 8022700: 6afb         	ldr	r3, [r7, #0x2c]
 8022702: 6f1a         	ldr	r2, [r3, #0x70]
; 					stat.pending_length;
 8022704: 68fb         	ldr	r3, [r7, #0xc]
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 8022706: 1ad3         	subs	r3, r2, r3
 8022708: 62bb         	str	r3, [r7, #0x28]
; 		if (rx_rcv_len > data->dma_rx.offset) {
 802270a: 6afb         	ldr	r3, [r7, #0x2c]
 802270c: 6f5b         	ldr	r3, [r3, #0x74]
 802270e: 6aba         	ldr	r2, [r7, #0x28]
 8022710: 429a         	cmp	r2, r3
 8022712: d905         	bls	0x8022720 <uart_stm32_dma_rx_flush+0x46> @ imm = #0xa
; 			data->dma_rx.counter = rx_rcv_len;
 8022714: 6afb         	ldr	r3, [r7, #0x2c]
 8022716: 6aba         	ldr	r2, [r7, #0x28]
 8022718: 679a         	str	r2, [r3, #0x78]
; 			async_evt_rx_rdy(data);
 802271a: 6af8         	ldr	r0, [r7, #0x2c]
 802271c: f7ea fc12    	bl	0x800cf44 <async_evt_rx_rdy> @ imm = #-0x157dc
; }
 8022720: bf00         	nop
 8022722: 3730         	adds	r7, #0x30
 8022724: 46bd         	mov	sp, r7
 8022726: bd80         	pop	{r7, pc}

08022728 <uart_stm32_async_callback_set>:
; {
 8022728: b480         	push	{r7}
 802272a: b087         	sub	sp, #0x1c
 802272c: af00         	add	r7, sp, #0x0
 802272e: 60f8         	str	r0, [r7, #0xc]
 8022730: 60b9         	str	r1, [r7, #0x8]
 8022732: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 8022734: 68fb         	ldr	r3, [r7, #0xc]
 8022736: 691b         	ldr	r3, [r3, #0x10]
 8022738: 617b         	str	r3, [r7, #0x14]
; 	data->async_cb = callback;
 802273a: 697b         	ldr	r3, [r7, #0x14]
 802273c: 68ba         	ldr	r2, [r7, #0x8]
 802273e: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = user_data;
 8022740: 697b         	ldr	r3, [r7, #0x14]
 8022742: 687a         	ldr	r2, [r7, #0x4]
 8022744: 619a         	str	r2, [r3, #0x18]
; 	data->user_cb = NULL;
 8022746: 697b         	ldr	r3, [r7, #0x14]
 8022748: 2200         	movs	r2, #0x0
 802274a: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = NULL;
 802274c: 697b         	ldr	r3, [r7, #0x14]
 802274e: 2200         	movs	r2, #0x0
 8022750: 60da         	str	r2, [r3, #0xc]
; 	return 0;
 8022752: 2300         	movs	r3, #0x0
; }
 8022754: 4618         	mov	r0, r3
 8022756: 371c         	adds	r7, #0x1c
 8022758: 46bd         	mov	sp, r7
 802275a: f85d 7b04    	ldr	r7, [sp], #4
 802275e: 4770         	bx	lr

08022760 <uart_stm32_dma_tx_enable>:
; {
 8022760: b580         	push	{r7, lr}
 8022762: b084         	sub	sp, #0x10
 8022764: af00         	add	r7, sp, #0x0
 8022766: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8022768: 687b         	ldr	r3, [r7, #0x4]
 802276a: 685b         	ldr	r3, [r3, #0x4]
 802276c: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableDMAReq_TX(config->usart);
 802276e: 68fb         	ldr	r3, [r7, #0xc]
 8022770: 681b         	ldr	r3, [r3]
 8022772: 4618         	mov	r0, r3
 8022774: f7ff fa4c    	bl	0x8021c10 <LL_USART_EnableDMAReq_TX> @ imm = #-0xb68
; }
 8022778: bf00         	nop
 802277a: 3710         	adds	r7, #0x10
 802277c: 46bd         	mov	sp, r7
 802277e: bd80         	pop	{r7, pc}

08022780 <uart_stm32_dma_tx_disable>:
; {
 8022780: b580         	push	{r7, lr}
 8022782: b084         	sub	sp, #0x10
 8022784: af00         	add	r7, sp, #0x0
 8022786: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8022788: 687b         	ldr	r3, [r7, #0x4]
 802278a: 685b         	ldr	r3, [r3, #0x4]
 802278c: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableDMAReq_TX(config->usart);
 802278e: 68fb         	ldr	r3, [r7, #0xc]
 8022790: 681b         	ldr	r3, [r3]
 8022792: 4618         	mov	r0, r3
 8022794: f7ff fa5f    	bl	0x8021c56 <LL_USART_DisableDMAReq_TX> @ imm = #-0xb42
; }
 8022798: bf00         	nop
 802279a: 3710         	adds	r7, #0x10
 802279c: 46bd         	mov	sp, r7
 802279e: bd80         	pop	{r7, pc}

080227a0 <uart_stm32_dma_rx_enable>:
; {
 80227a0: b580         	push	{r7, lr}
 80227a2: b084         	sub	sp, #0x10
 80227a4: af00         	add	r7, sp, #0x0
 80227a6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80227a8: 687b         	ldr	r3, [r7, #0x4]
 80227aa: 685b         	ldr	r3, [r3, #0x4]
 80227ac: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_stm32_data *data = dev->data;
 80227ae: 687b         	ldr	r3, [r7, #0x4]
 80227b0: 691b         	ldr	r3, [r3, #0x10]
 80227b2: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableDMAReq_RX(config->usart);
 80227b4: 68fb         	ldr	r3, [r7, #0xc]
 80227b6: 681b         	ldr	r3, [r3]
 80227b8: 4618         	mov	r0, r3
 80227ba: f7ff fa06    	bl	0x8021bca <LL_USART_EnableDMAReq_RX> @ imm = #-0xbf4
; 	data->dma_rx.enabled = true;
 80227be: 68bb         	ldr	r3, [r7, #0x8]
 80227c0: 2201         	movs	r2, #0x1
 80227c2: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 80227c6: bf00         	nop
 80227c8: 3710         	adds	r7, #0x10
 80227ca: 46bd         	mov	sp, r7
 80227cc: bd80         	pop	{r7, pc}

080227ce <uart_stm32_dma_rx_disable>:
; {
 80227ce: b480         	push	{r7}
 80227d0: b085         	sub	sp, #0x14
 80227d2: af00         	add	r7, sp, #0x0
 80227d4: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 80227d6: 687b         	ldr	r3, [r7, #0x4]
 80227d8: 691b         	ldr	r3, [r3, #0x10]
 80227da: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.enabled = false;
 80227dc: 68fb         	ldr	r3, [r7, #0xc]
 80227de: 2200         	movs	r2, #0x0
 80227e0: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 80227e4: bf00         	nop
 80227e6: 3714         	adds	r7, #0x14
 80227e8: 46bd         	mov	sp, r7
 80227ea: f85d 7b04    	ldr	r7, [sp], #4
 80227ee: 4770         	bx	lr

080227f0 <uart_stm32_dma_tx_cb>:
; {
 80227f0: b580         	push	{r7, lr}
 80227f2: b094         	sub	sp, #0x50
 80227f4: af00         	add	r7, sp, #0x0
 80227f6: 60f8         	str	r0, [r7, #0xc]
 80227f8: 60b9         	str	r1, [r7, #0x8]
 80227fa: 607a         	str	r2, [r7, #0x4]
 80227fc: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 80227fe: 68bb         	ldr	r3, [r7, #0x8]
 8022800: 64fb         	str	r3, [r7, #0x4c]
; 	struct uart_stm32_data *data = uart_dev->data;
 8022802: 6cfb         	ldr	r3, [r7, #0x4c]
 8022804: 691b         	ldr	r3, [r3, #0x10]
 8022806: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8022808: f3ef 8311    	mrs	r3, basepri
 802280c: 643b         	str	r3, [r7, #0x40]
;   return(result);
 802280e: 6c3b         	ldr	r3, [r7, #0x40]
; 	key = __get_BASEPRI();
 8022810: 63fb         	str	r3, [r7, #0x3c]
 8022812: 2310         	movs	r3, #0x10
 8022814: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8022816: 6bbb         	ldr	r3, [r7, #0x38]
 8022818: f383 8812    	msr	basepri_max, r3
; }
 802281c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 802281e: f3bf 8f6f    	isb	sy
; }
 8022822: bf00         	nop
; 	return key;
 8022824: 6bfb         	ldr	r3, [r7, #0x3c]
; 	unsigned int key = irq_lock();
 8022826: 647b         	str	r3, [r7, #0x44]
; 	uart_stm32_dma_tx_disable(uart_dev);
 8022828: 6cf8         	ldr	r0, [r7, #0x4c]
 802282a: f7ff ffa9    	bl	0x8022780 <uart_stm32_dma_tx_disable> @ imm = #-0xae
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 802282e: 6cbb         	ldr	r3, [r7, #0x48]
 8022830: f503 738c    	add.w	r3, r3, #0x118
 8022834: 4618         	mov	r0, r3
 8022836: f7f2 f8ab    	bl	0x8014990 <k_work_cancel_delayable> @ imm = #-0xdeaa
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 802283a: 6cbb         	ldr	r3, [r7, #0x48]
 802283c: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 8022840: 6cbb         	ldr	r3, [r7, #0x48]
 8022842: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 8022846: f107 0210    	add.w	r2, r7, #0x10
 802284a: 4619         	mov	r1, r3
 802284c: f7fe fd2a    	bl	0x80212a4 <dma_get_status> @ imm = #-0x15ac
 8022850: 4603         	mov	r3, r0
 8022852: 2b00         	cmp	r3, #0x0
 8022854: d107         	bne	0x8022866 <uart_stm32_dma_tx_cb+0x76> @ imm = #0xe
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 8022856: 6cbb         	ldr	r3, [r7, #0x48]
 8022858: f8d3 2108    	ldr.w	r2, [r3, #0x108]
; 					stat.pending_length;
 802285c: 697b         	ldr	r3, [r7, #0x14]
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 802285e: 1ad2         	subs	r2, r2, r3
 8022860: 6cbb         	ldr	r3, [r7, #0x48]
 8022862: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	data->dma_tx.buffer_length = 0;
 8022866: 6cbb         	ldr	r3, [r7, #0x48]
 8022868: 2200         	movs	r2, #0x0
 802286a: f8c3 2108    	str.w	r2, [r3, #0x108]
 802286e: 6c7b         	ldr	r3, [r7, #0x44]
 8022870: 637b         	str	r3, [r7, #0x34]
 8022872: 6b7b         	ldr	r3, [r7, #0x34]
 8022874: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8022876: 6b3b         	ldr	r3, [r7, #0x30]
 8022878: f383 8811    	msr	basepri, r3
; }
 802287c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 802287e: f3bf 8f6f    	isb	sy
; }
 8022882: bf00         	nop
; }
 8022884: bf00         	nop
; }
 8022886: bf00         	nop
 8022888: 3750         	adds	r7, #0x50
 802288a: 46bd         	mov	sp, r7
 802288c: bd80         	pop	{r7, pc}

0802288e <uart_stm32_dma_rx_cb>:
; {
 802288e: b580         	push	{r7, lr}
 8022890: b086         	sub	sp, #0x18
 8022892: af00         	add	r7, sp, #0x0
 8022894: 60f8         	str	r0, [r7, #0xc]
 8022896: 60b9         	str	r1, [r7, #0x8]
 8022898: 607a         	str	r2, [r7, #0x4]
 802289a: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 802289c: 68bb         	ldr	r3, [r7, #0x8]
 802289e: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = uart_dev->data;
 80228a0: 697b         	ldr	r3, [r7, #0x14]
 80228a2: 691b         	ldr	r3, [r3, #0x10]
 80228a4: 613b         	str	r3, [r7, #0x10]
; 	if (status < 0) {
 80228a6: 683b         	ldr	r3, [r7]
 80228a8: 2b00         	cmp	r3, #0x0
 80228aa: da04         	bge	0x80228b6 <uart_stm32_dma_rx_cb+0x28> @ imm = #0x8
; 		async_evt_rx_err(data, status);
 80228ac: 6839         	ldr	r1, [r7]
 80228ae: 6938         	ldr	r0, [r7, #0x10]
 80228b0: f7ea fb9e    	bl	0x800cff0 <async_evt_rx_err> @ imm = #-0x158c4
; 		return;
 80228b4: e021         	b	0x80228fa <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x42
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 80228b6: 693b         	ldr	r3, [r7, #0x10]
 80228b8: 3380         	adds	r3, #0x80
 80228ba: 4618         	mov	r0, r3
 80228bc: f7f2 f868    	bl	0x8014990 <k_work_cancel_delayable> @ imm = #-0xdf30
; 	data->dma_rx.counter = data->dma_rx.buffer_length;
 80228c0: 693b         	ldr	r3, [r7, #0x10]
 80228c2: 6f1a         	ldr	r2, [r3, #0x70]
 80228c4: 693b         	ldr	r3, [r7, #0x10]
 80228c6: 679a         	str	r2, [r3, #0x78]
; 	async_evt_rx_rdy(data);
 80228c8: 6938         	ldr	r0, [r7, #0x10]
 80228ca: f7ea fb3b    	bl	0x800cf44 <async_evt_rx_rdy> @ imm = #-0x1598a
; 	if (data->rx_next_buffer != NULL) {
 80228ce: 693b         	ldr	r3, [r7, #0x10]
 80228d0: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 80228d4: 2b00         	cmp	r3, #0x0
 80228d6: d006         	beq	0x80228e6 <uart_stm32_dma_rx_cb+0x58> @ imm = #0xc
; 		async_evt_rx_buf_release(data);
 80228d8: 6938         	ldr	r0, [r7, #0x10]
 80228da: f7ff fee3    	bl	0x80226a4 <async_evt_rx_buf_release> @ imm = #-0x23a
; 		uart_stm32_dma_replace_buffer(uart_dev);
 80228de: 6978         	ldr	r0, [r7, #0x14]
 80228e0: f7ea fdce    	bl	0x800d480 <uart_stm32_dma_replace_buffer> @ imm = #-0x15464
 80228e4: e009         	b	0x80228fa <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x12
; 		k_work_reschedule(&data->dma_rx.timeout_work, K_TICKS(1));
 80228e6: 693b         	ldr	r3, [r7, #0x10]
 80228e8: f103 0180    	add.w	r1, r3, #0x80
 80228ec: f04f 0201    	mov.w	r2, #0x1
 80228f0: f04f 0300    	mov.w	r3, #0x0
 80228f4: 4608         	mov	r0, r1
 80228f6: f7f2 f837    	bl	0x8014968 <k_work_reschedule> @ imm = #-0xdf92
; }
 80228fa: 3718         	adds	r7, #0x18
 80228fc: 46bd         	mov	sp, r7
 80228fe: bd80         	pop	{r7, pc}

08022900 <uart_stm32_async_tx_abort>:
; {
 8022900: b580         	push	{r7, lr}
 8022902: b08c         	sub	sp, #0x30
 8022904: af00         	add	r7, sp, #0x0
 8022906: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 8022908: 687b         	ldr	r3, [r7, #0x4]
 802290a: 691b         	ldr	r3, [r3, #0x10]
 802290c: 62fb         	str	r3, [r7, #0x2c]
; 	size_t tx_buffer_length = data->dma_tx.buffer_length;
 802290e: 6afb         	ldr	r3, [r7, #0x2c]
 8022910: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 8022914: 62bb         	str	r3, [r7, #0x28]
; 	if (tx_buffer_length == 0) {
 8022916: 6abb         	ldr	r3, [r7, #0x28]
 8022918: 2b00         	cmp	r3, #0x0
 802291a: d102         	bne	0x8022922 <uart_stm32_async_tx_abort+0x22> @ imm = #0x4
; 		return -EFAULT;
 802291c: f06f 030d    	mvn	r3, #0xd
 8022920: e027         	b	0x8022972 <uart_stm32_async_tx_abort+0x72> @ imm = #0x4e
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 8022922: 6afb         	ldr	r3, [r7, #0x2c]
 8022924: f503 738c    	add.w	r3, r3, #0x118
 8022928: 4618         	mov	r0, r3
 802292a: f7f2 f831    	bl	0x8014990 <k_work_cancel_delayable> @ imm = #-0xdf9e
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 802292e: 6afb         	ldr	r3, [r7, #0x2c]
 8022930: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 8022934: 6afb         	ldr	r3, [r7, #0x2c]
 8022936: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 802293a: f107 0208    	add.w	r2, r7, #0x8
 802293e: 4619         	mov	r1, r3
 8022940: f7fe fcb0    	bl	0x80212a4 <dma_get_status> @ imm = #-0x16a0
 8022944: 4603         	mov	r3, r0
 8022946: 2b00         	cmp	r3, #0x0
 8022948: d105         	bne	0x8022956 <uart_stm32_async_tx_abort+0x56> @ imm = #0xa
; 		data->dma_tx.counter = tx_buffer_length - stat.pending_length;
 802294a: 68fb         	ldr	r3, [r7, #0xc]
 802294c: 6aba         	ldr	r2, [r7, #0x28]
 802294e: 1ad2         	subs	r2, r2, r3
 8022950: 6afb         	ldr	r3, [r7, #0x2c]
 8022952: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	dma_stop(data->dma_tx.dma_dev, data->dma_tx.dma_channel);
 8022956: 6afb         	ldr	r3, [r7, #0x2c]
 8022958: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 802295c: 6afb         	ldr	r3, [r7, #0x2c]
 802295e: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 8022962: 4619         	mov	r1, r3
 8022964: 4610         	mov	r0, r2
 8022966: f7fe fcc6    	bl	0x80212f6 <dma_stop>    @ imm = #-0x1674
; 	async_evt_tx_abort(data);
 802296a: 6af8         	ldr	r0, [r7, #0x2c]
 802296c: f7ea fbd0    	bl	0x800d110 <async_evt_tx_abort> @ imm = #-0x15860
; 	return 0;
 8022970: 2300         	movs	r3, #0x0
; }
 8022972: 4618         	mov	r0, r3
 8022974: 3730         	adds	r7, #0x30
 8022976: 46bd         	mov	sp, r7
 8022978: bd80         	pop	{r7, pc}

0802297a <uart_stm32_init>:
; {
 802297a: b580         	push	{r7, lr}
 802297c: b084         	sub	sp, #0x10
 802297e: af00         	add	r7, sp, #0x0
 8022980: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8022982: 687b         	ldr	r3, [r7, #0x4]
 8022984: 685b         	ldr	r3, [r3, #0x4]
 8022986: 60fb         	str	r3, [r7, #0xc]
; 	err = uart_stm32_clocks_enable(dev);
 8022988: 6878         	ldr	r0, [r7, #0x4]
 802298a: f7eb f9a3    	bl	0x800dcd4 <uart_stm32_clocks_enable> @ imm = #-0x14cba
 802298e: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 8022990: 68bb         	ldr	r3, [r7, #0x8]
 8022992: 2b00         	cmp	r3, #0x0
 8022994: da01         	bge	0x802299a <uart_stm32_init+0x20> @ imm = #0x2
; 		return err;
 8022996: 68bb         	ldr	r3, [r7, #0x8]
 8022998: e01c         	b	0x80229d4 <uart_stm32_init+0x5a> @ imm = #0x38
; 	err = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
 802299a: 68fb         	ldr	r3, [r7, #0xc]
 802299c: 6a1b         	ldr	r3, [r3, #0x20]
 802299e: 2100         	movs	r1, #0x0
 80229a0: 4618         	mov	r0, r3
 80229a2: f7fe fcca    	bl	0x802133a <pinctrl_apply_state> @ imm = #-0x166c
 80229a6: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 80229a8: 68bb         	ldr	r3, [r7, #0x8]
 80229aa: 2b00         	cmp	r3, #0x0
 80229ac: da01         	bge	0x80229b2 <uart_stm32_init+0x38> @ imm = #0x2
; 		return err;
 80229ae: 68bb         	ldr	r3, [r7, #0x8]
 80229b0: e010         	b	0x80229d4 <uart_stm32_init+0x5a> @ imm = #0x20
; 	err = uart_stm32_registers_configure(dev);
 80229b2: 6878         	ldr	r0, [r7, #0x4]
 80229b4: f7eb f9f6    	bl	0x800dda4 <uart_stm32_registers_configure> @ imm = #-0x14c14
 80229b8: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 80229ba: 68bb         	ldr	r3, [r7, #0x8]
 80229bc: 2b00         	cmp	r3, #0x0
 80229be: da01         	bge	0x80229c4 <uart_stm32_init+0x4a> @ imm = #0x2
; 		return err;
 80229c0: 68bb         	ldr	r3, [r7, #0x8]
 80229c2: e007         	b	0x80229d4 <uart_stm32_init+0x5a> @ imm = #0xe
; 	config->irq_config_func(dev);
 80229c4: 68fb         	ldr	r3, [r7, #0xc]
 80229c6: 6a5b         	ldr	r3, [r3, #0x24]
 80229c8: 6878         	ldr	r0, [r7, #0x4]
 80229ca: 4798         	blx	r3
; 	return uart_stm32_async_init(dev);
 80229cc: 6878         	ldr	r0, [r7, #0x4]
 80229ce: f7eb f877    	bl	0x800dac0 <uart_stm32_async_init> @ imm = #-0x14f12
 80229d2: 4603         	mov	r3, r0
; }
 80229d4: 4618         	mov	r0, r3
 80229d6: 3710         	adds	r7, #0x10
 80229d8: 46bd         	mov	sp, r7
 80229da: bd80         	pop	{r7, pc}

080229dc <uart_stm32_irq_config_func_0>:
; DT_INST_FOREACH_STATUS_OKAY(STM32_UART_INIT)
 80229dc: b580         	push	{r7, lr}
 80229de: b082         	sub	sp, #0x8
 80229e0: af00         	add	r7, sp, #0x0
 80229e2: 6078         	str	r0, [r7, #0x4]
 80229e4: 2200         	movs	r2, #0x0
 80229e6: 2100         	movs	r1, #0x0
 80229e8: 2025         	movs	r0, #0x25
 80229ea: f7f9 fced    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x6626
 80229ee: 2025         	movs	r0, #0x25
 80229f0: f7f9 fcdd    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x6646
 80229f4: 3708         	adds	r7, #0x8
 80229f6: 46bd         	mov	sp, r7
 80229f8: bd80         	pop	{r7, pc}

080229fa <uart_stm32_irq_config_func_1>:
 80229fa: b580         	push	{r7, lr}
 80229fc: b082         	sub	sp, #0x8
 80229fe: af00         	add	r7, sp, #0x0
 8022a00: 6078         	str	r0, [r7, #0x4]
 8022a02: 2200         	movs	r2, #0x0
 8022a04: 2100         	movs	r1, #0x0
 8022a06: 2047         	movs	r0, #0x47
 8022a08: f7f9 fcde    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x6644
 8022a0c: 2047         	movs	r0, #0x47
 8022a0e: f7f9 fcce    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x6664
 8022a12: 3708         	adds	r7, #0x8
 8022a14: 46bd         	mov	sp, r7
 8022a16: bd80         	pop	{r7, pc}

08022a18 <uart_stm32_irq_config_func_2>:
 8022a18: b580         	push	{r7, lr}
 8022a1a: b082         	sub	sp, #0x8
 8022a1c: af00         	add	r7, sp, #0x0
 8022a1e: 6078         	str	r0, [r7, #0x4]
 8022a20: 2200         	movs	r2, #0x0
 8022a22: 2100         	movs	r1, #0x0
 8022a24: 2027         	movs	r0, #0x27
 8022a26: f7f9 fccf    	bl	0x801c3c8 <z_arm_irq_priority_set> @ imm = #-0x6662
 8022a2a: 2027         	movs	r0, #0x27
 8022a2c: f7f9 fcbf    	bl	0x801c3ae <arch_irq_enable> @ imm = #-0x6682
 8022a30: 3708         	adds	r7, #0x8
 8022a32: 46bd         	mov	sp, r7
 8022a34: bd80         	pop	{r7, pc}

08022a36 <device_is_ready>:
; {
 8022a36: b580         	push	{r7, lr}
 8022a38: b082         	sub	sp, #0x8
 8022a3a: af00         	add	r7, sp, #0x0
 8022a3c: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8022a3e: 6878         	ldr	r0, [r7, #0x4]
 8022a40: f001 fd6f    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x1ade
 8022a44: 4603         	mov	r3, r0
; }
 8022a46: 4618         	mov	r0, r3
 8022a48: 3708         	adds	r7, #0x8
 8022a4a: 46bd         	mov	sp, r7
 8022a4c: bd80         	pop	{r7, pc}

08022a4e <z_log_msg_runtime_create>:
; {
 8022a4e: b580         	push	{r7, lr}
 8022a50: b08a         	sub	sp, #0x28
 8022a52: af04         	add	r7, sp, #0x10
 8022a54: 60b9         	str	r1, [r7, #0x8]
 8022a56: 607b         	str	r3, [r7, #0x4]
 8022a58: 4603         	mov	r3, r0
 8022a5a: 73fb         	strb	r3, [r7, #0xf]
 8022a5c: 4613         	mov	r3, r2
 8022a5e: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8022a60: f107 032c    	add.w	r3, r7, #0x2c
 8022a64: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8022a66: 7bba         	ldrb	r2, [r7, #0xe]
 8022a68: 7bf8         	ldrb	r0, [r7, #0xf]
 8022a6a: 697b         	ldr	r3, [r7, #0x14]
 8022a6c: 9303         	str	r3, [sp, #0xc]
 8022a6e: 6abb         	ldr	r3, [r7, #0x28]
 8022a70: 9302         	str	r3, [sp, #0x8]
 8022a72: 6a7b         	ldr	r3, [r7, #0x24]
 8022a74: 9301         	str	r3, [sp, #0x4]
 8022a76: 6a3b         	ldr	r3, [r7, #0x20]
 8022a78: 9300         	str	r3, [sp]
 8022a7a: 687b         	ldr	r3, [r7, #0x4]
 8022a7c: 68b9         	ldr	r1, [r7, #0x8]
 8022a7e: f7e2 f861    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x1df3e
; }
 8022a82: bf00         	nop
 8022a84: 3718         	adds	r7, #0x18
 8022a86: 46bd         	mov	sp, r7
 8022a88: bd80         	pop	{r7, pc}

08022a8a <z_impl_k_sem_count_get>:
; {
 8022a8a: b480         	push	{r7}
 8022a8c: b083         	sub	sp, #0xc
 8022a8e: af00         	add	r7, sp, #0x0
 8022a90: 6078         	str	r0, [r7, #0x4]
; 	return sem->count;
 8022a92: 687b         	ldr	r3, [r7, #0x4]
 8022a94: 689b         	ldr	r3, [r3, #0x8]
; }
 8022a96: 4618         	mov	r0, r3
 8022a98: 370c         	adds	r7, #0xc
 8022a9a: 46bd         	mov	sp, r7
 8022a9c: f85d 7b04    	ldr	r7, [sp], #4
 8022aa0: 4770         	bx	lr

08022aa2 <k_busy_wait>:
; {
 8022aa2: b580         	push	{r7, lr}
 8022aa4: b082         	sub	sp, #0x8
 8022aa6: af00         	add	r7, sp, #0x0
 8022aa8: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_busy_wait(usec_to_wait);
 8022aaa: 6878         	ldr	r0, [r7, #0x4]
 8022aac: f001 fd10    	bl	0x80244d0 <z_impl_k_busy_wait> @ imm = #0x1a20
; }
 8022ab0: bf00         	nop
 8022ab2: 3708         	adds	r7, #0x8
 8022ab4: 46bd         	mov	sp, r7
 8022ab6: bd80         	pop	{r7, pc}

08022ab8 <k_sem_take>:
; {
 8022ab8: b580         	push	{r7, lr}
 8022aba: b084         	sub	sp, #0x10
 8022abc: af00         	add	r7, sp, #0x0
 8022abe: 60f8         	str	r0, [r7, #0xc]
 8022ac0: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 8022ac4: e9d7 2300    	ldrd	r2, r3, [r7]
 8022ac8: 68f8         	ldr	r0, [r7, #0xc]
 8022aca: f7f1 fb47    	bl	0x801415c <z_impl_k_sem_take> @ imm = #-0xe972
 8022ace: 4603         	mov	r3, r0
; }
 8022ad0: 4618         	mov	r0, r3
 8022ad2: 3710         	adds	r7, #0x10
 8022ad4: 46bd         	mov	sp, r7
 8022ad6: bd80         	pop	{r7, pc}

08022ad8 <k_sem_give>:
; {
 8022ad8: b580         	push	{r7, lr}
 8022ada: b082         	sub	sp, #0x8
 8022adc: af00         	add	r7, sp, #0x0
 8022ade: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8022ae0: 6878         	ldr	r0, [r7, #0x4]
 8022ae2: f7f1 faad    	bl	0x8014040 <z_impl_k_sem_give> @ imm = #-0xeaa6
; }
 8022ae6: bf00         	nop
 8022ae8: 3708         	adds	r7, #0x8
 8022aea: 46bd         	mov	sp, r7
 8022aec: bd80         	pop	{r7, pc}

08022aee <k_sem_count_get>:
; {
 8022aee: b580         	push	{r7, lr}
 8022af0: b082         	sub	sp, #0x8
 8022af2: af00         	add	r7, sp, #0x0
 8022af4: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_sem_count_get(sem);
 8022af6: 6878         	ldr	r0, [r7, #0x4]
 8022af8: f7ff ffc7    	bl	0x8022a8a <z_impl_k_sem_count_get> @ imm = #-0x72
 8022afc: 4603         	mov	r3, r0
; }
 8022afe: 4618         	mov	r0, r3
 8022b00: 3708         	adds	r7, #0x8
 8022b02: 46bd         	mov	sp, r7
 8022b04: bd80         	pop	{r7, pc}

08022b06 <LL_SPI_Enable>:
; {
 8022b06: b480         	push	{r7}
 8022b08: b083         	sub	sp, #0xc
 8022b0a: af00         	add	r7, sp, #0x0
 8022b0c: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(SPIx->CR1, SPI_CR1_SPE);
 8022b0e: 687b         	ldr	r3, [r7, #0x4]
 8022b10: 681b         	ldr	r3, [r3]
 8022b12: f043 0240    	orr	r2, r3, #0x40
 8022b16: 687b         	ldr	r3, [r7, #0x4]
 8022b18: 601a         	str	r2, [r3]
; }
 8022b1a: bf00         	nop
 8022b1c: 370c         	adds	r7, #0xc
 8022b1e: 46bd         	mov	sp, r7
 8022b20: f85d 7b04    	ldr	r7, [sp], #4
 8022b24: 4770         	bx	lr

08022b26 <LL_SPI_Disable>:
; {
 8022b26: b480         	push	{r7}
 8022b28: b083         	sub	sp, #0xc
 8022b2a: af00         	add	r7, sp, #0x0
 8022b2c: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 8022b2e: 687b         	ldr	r3, [r7, #0x4]
 8022b30: 681b         	ldr	r3, [r3]
 8022b32: f023 0240    	bic	r2, r3, #0x40
 8022b36: 687b         	ldr	r3, [r7, #0x4]
 8022b38: 601a         	str	r2, [r3]
; }
 8022b3a: bf00         	nop
 8022b3c: 370c         	adds	r7, #0xc
 8022b3e: 46bd         	mov	sp, r7
 8022b40: f85d 7b04    	ldr	r7, [sp], #4
 8022b44: 4770         	bx	lr

08022b46 <LL_SPI_IsEnabled>:
; {
 8022b46: b480         	push	{r7}
 8022b48: b083         	sub	sp, #0xc
 8022b4a: af00         	add	r7, sp, #0x0
 8022b4c: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->CR1, SPI_CR1_SPE) == (SPI_CR1_SPE)) ? 1UL : 0UL);
 8022b4e: 687b         	ldr	r3, [r7, #0x4]
 8022b50: 681b         	ldr	r3, [r3]
 8022b52: f003 0340    	and	r3, r3, #0x40
 8022b56: 2b40         	cmp	r3, #0x40
 8022b58: d101         	bne	0x8022b5e <LL_SPI_IsEnabled+0x18> @ imm = #0x2
 8022b5a: 2301         	movs	r3, #0x1
 8022b5c: e000         	b	0x8022b60 <LL_SPI_IsEnabled+0x1a> @ imm = #0x0
 8022b5e: 2300         	movs	r3, #0x0
; }
 8022b60: 4618         	mov	r0, r3
 8022b62: 370c         	adds	r7, #0xc
 8022b64: 46bd         	mov	sp, r7
 8022b66: f85d 7b04    	ldr	r7, [sp], #4
 8022b6a: 4770         	bx	lr

08022b6c <LL_SPI_SetMode>:
; {
 8022b6c: b480         	push	{r7}
 8022b6e: b083         	sub	sp, #0xc
 8022b70: af00         	add	r7, sp, #0x0
 8022b72: 6078         	str	r0, [r7, #0x4]
 8022b74: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI, Mode);
 8022b76: 687b         	ldr	r3, [r7, #0x4]
 8022b78: 681b         	ldr	r3, [r3]
 8022b7a: f423 7282    	bic	r2, r3, #0x104
 8022b7e: 683b         	ldr	r3, [r7]
 8022b80: 431a         	orrs	r2, r3
 8022b82: 687b         	ldr	r3, [r7, #0x4]
 8022b84: 601a         	str	r2, [r3]
; }
 8022b86: bf00         	nop
 8022b88: 370c         	adds	r7, #0xc
 8022b8a: 46bd         	mov	sp, r7
 8022b8c: f85d 7b04    	ldr	r7, [sp], #4
 8022b90: 4770         	bx	lr

08022b92 <LL_SPI_GetMode>:
; {
 8022b92: b480         	push	{r7}
 8022b94: b083         	sub	sp, #0xc
 8022b96: af00         	add	r7, sp, #0x0
 8022b98: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI));
 8022b9a: 687b         	ldr	r3, [r7, #0x4]
 8022b9c: 681b         	ldr	r3, [r3]
 8022b9e: f403 7382    	and	r3, r3, #0x104
; }
 8022ba2: 4618         	mov	r0, r3
 8022ba4: 370c         	adds	r7, #0xc
 8022ba6: 46bd         	mov	sp, r7
 8022ba8: f85d 7b04    	ldr	r7, [sp], #4
 8022bac: 4770         	bx	lr

08022bae <LL_SPI_SetStandard>:
; {
 8022bae: b480         	push	{r7}
 8022bb0: b083         	sub	sp, #0xc
 8022bb2: af00         	add	r7, sp, #0x0
 8022bb4: 6078         	str	r0, [r7, #0x4]
 8022bb6: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR2, SPI_CR2_FRF, Standard);
 8022bb8: 687b         	ldr	r3, [r7, #0x4]
 8022bba: 685b         	ldr	r3, [r3, #0x4]
 8022bbc: f023 0210    	bic	r2, r3, #0x10
 8022bc0: 683b         	ldr	r3, [r7]
 8022bc2: 431a         	orrs	r2, r3
 8022bc4: 687b         	ldr	r3, [r7, #0x4]
 8022bc6: 605a         	str	r2, [r3, #0x4]
; }
 8022bc8: bf00         	nop
 8022bca: 370c         	adds	r7, #0xc
 8022bcc: 46bd         	mov	sp, r7
 8022bce: f85d 7b04    	ldr	r7, [sp], #4
 8022bd2: 4770         	bx	lr

08022bd4 <LL_SPI_SetClockPhase>:
; {
 8022bd4: b480         	push	{r7}
 8022bd6: b083         	sub	sp, #0xc
 8022bd8: af00         	add	r7, sp, #0x0
 8022bda: 6078         	str	r0, [r7, #0x4]
 8022bdc: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_CPHA, ClockPhase);
 8022bde: 687b         	ldr	r3, [r7, #0x4]
 8022be0: 681b         	ldr	r3, [r3]
 8022be2: f023 0201    	bic	r2, r3, #0x1
 8022be6: 683b         	ldr	r3, [r7]
 8022be8: 431a         	orrs	r2, r3
 8022bea: 687b         	ldr	r3, [r7, #0x4]
 8022bec: 601a         	str	r2, [r3]
; }
 8022bee: bf00         	nop
 8022bf0: 370c         	adds	r7, #0xc
 8022bf2: 46bd         	mov	sp, r7
 8022bf4: f85d 7b04    	ldr	r7, [sp], #4
 8022bf8: 4770         	bx	lr

08022bfa <LL_SPI_SetClockPolarity>:
; {
 8022bfa: b480         	push	{r7}
 8022bfc: b083         	sub	sp, #0xc
 8022bfe: af00         	add	r7, sp, #0x0
 8022c00: 6078         	str	r0, [r7, #0x4]
 8022c02: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_CPOL, ClockPolarity);
 8022c04: 687b         	ldr	r3, [r7, #0x4]
 8022c06: 681b         	ldr	r3, [r3]
 8022c08: f023 0202    	bic	r2, r3, #0x2
 8022c0c: 683b         	ldr	r3, [r7]
 8022c0e: 431a         	orrs	r2, r3
 8022c10: 687b         	ldr	r3, [r7, #0x4]
 8022c12: 601a         	str	r2, [r3]
; }
 8022c14: bf00         	nop
 8022c16: 370c         	adds	r7, #0xc
 8022c18: 46bd         	mov	sp, r7
 8022c1a: f85d 7b04    	ldr	r7, [sp], #4
 8022c1e: 4770         	bx	lr

08022c20 <LL_SPI_SetBaudRatePrescaler>:
; {
 8022c20: b480         	push	{r7}
 8022c22: b083         	sub	sp, #0xc
 8022c24: af00         	add	r7, sp, #0x0
 8022c26: 6078         	str	r0, [r7, #0x4]
 8022c28: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_BR, BaudRate);
 8022c2a: 687b         	ldr	r3, [r7, #0x4]
 8022c2c: 681b         	ldr	r3, [r3]
 8022c2e: f023 0238    	bic	r2, r3, #0x38
 8022c32: 683b         	ldr	r3, [r7]
 8022c34: 431a         	orrs	r2, r3
 8022c36: 687b         	ldr	r3, [r7, #0x4]
 8022c38: 601a         	str	r2, [r3]
; }
 8022c3a: bf00         	nop
 8022c3c: 370c         	adds	r7, #0xc
 8022c3e: 46bd         	mov	sp, r7
 8022c40: f85d 7b04    	ldr	r7, [sp], #4
 8022c44: 4770         	bx	lr

08022c46 <LL_SPI_SetTransferBitOrder>:
; {
 8022c46: b480         	push	{r7}
 8022c48: b083         	sub	sp, #0xc
 8022c4a: af00         	add	r7, sp, #0x0
 8022c4c: 6078         	str	r0, [r7, #0x4]
 8022c4e: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_LSBFIRST, BitOrder);
 8022c50: 687b         	ldr	r3, [r7, #0x4]
 8022c52: 681b         	ldr	r3, [r3]
 8022c54: f023 0280    	bic	r2, r3, #0x80
 8022c58: 683b         	ldr	r3, [r7]
 8022c5a: 431a         	orrs	r2, r3
 8022c5c: 687b         	ldr	r3, [r7, #0x4]
 8022c5e: 601a         	str	r2, [r3]
; }
 8022c60: bf00         	nop
 8022c62: 370c         	adds	r7, #0xc
 8022c64: 46bd         	mov	sp, r7
 8022c66: f85d 7b04    	ldr	r7, [sp], #4
 8022c6a: 4770         	bx	lr

08022c6c <LL_SPI_SetTransferDirection>:
; {
 8022c6c: b480         	push	{r7}
 8022c6e: b083         	sub	sp, #0xc
 8022c70: af00         	add	r7, sp, #0x0
 8022c72: 6078         	str	r0, [r7, #0x4]
 8022c74: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_RXONLY | SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE, TransferDirection);
 8022c76: 687b         	ldr	r3, [r7, #0x4]
 8022c78: 681b         	ldr	r3, [r3]
 8022c7a: f423 4244    	bic	r2, r3, #0xc400
 8022c7e: 683b         	ldr	r3, [r7]
 8022c80: 431a         	orrs	r2, r3
 8022c82: 687b         	ldr	r3, [r7, #0x4]
 8022c84: 601a         	str	r2, [r3]
; }
 8022c86: bf00         	nop
 8022c88: 370c         	adds	r7, #0xc
 8022c8a: 46bd         	mov	sp, r7
 8022c8c: f85d 7b04    	ldr	r7, [sp], #4
 8022c90: 4770         	bx	lr

08022c92 <LL_SPI_SetDataWidth>:
; {
 8022c92: b480         	push	{r7}
 8022c94: b083         	sub	sp, #0xc
 8022c96: af00         	add	r7, sp, #0x0
 8022c98: 6078         	str	r0, [r7, #0x4]
 8022c9a: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_DFF, DataWidth);
 8022c9c: 687b         	ldr	r3, [r7, #0x4]
 8022c9e: 681b         	ldr	r3, [r3]
 8022ca0: f423 6200    	bic	r2, r3, #0x800
 8022ca4: 683b         	ldr	r3, [r7]
 8022ca6: 431a         	orrs	r2, r3
 8022ca8: 687b         	ldr	r3, [r7, #0x4]
 8022caa: 601a         	str	r2, [r3]
; }
 8022cac: bf00         	nop
 8022cae: 370c         	adds	r7, #0xc
 8022cb0: 46bd         	mov	sp, r7
 8022cb2: f85d 7b04    	ldr	r7, [sp], #4
 8022cb6: 4770         	bx	lr

08022cb8 <LL_SPI_DisableCRC>:
; {
 8022cb8: b480         	push	{r7}
 8022cba: b083         	sub	sp, #0xc
 8022cbc: af00         	add	r7, sp, #0x0
 8022cbe: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_CRCEN);
 8022cc0: 687b         	ldr	r3, [r7, #0x4]
 8022cc2: 681b         	ldr	r3, [r3]
 8022cc4: f423 5200    	bic	r2, r3, #0x2000
 8022cc8: 687b         	ldr	r3, [r7, #0x4]
 8022cca: 601a         	str	r2, [r3]
; }
 8022ccc: bf00         	nop
 8022cce: 370c         	adds	r7, #0xc
 8022cd0: 46bd         	mov	sp, r7
 8022cd2: f85d 7b04    	ldr	r7, [sp], #4
 8022cd6: 4770         	bx	lr

08022cd8 <LL_SPI_SetNSSMode>:
; {
 8022cd8: b480         	push	{r7}
 8022cda: b083         	sub	sp, #0xc
 8022cdc: af00         	add	r7, sp, #0x0
 8022cde: 6078         	str	r0, [r7, #0x4]
 8022ce0: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_SSM,  NSS);
 8022ce2: 687b         	ldr	r3, [r7, #0x4]
 8022ce4: 681b         	ldr	r3, [r3]
 8022ce6: f423 7200    	bic	r2, r3, #0x200
 8022cea: 683b         	ldr	r3, [r7]
 8022cec: 431a         	orrs	r2, r3
 8022cee: 687b         	ldr	r3, [r7, #0x4]
 8022cf0: 601a         	str	r2, [r3]
;   MODIFY_REG(SPIx->CR2, SPI_CR2_SSOE, ((uint32_t)(NSS >> 16U)));
 8022cf2: 687b         	ldr	r3, [r7, #0x4]
 8022cf4: 685b         	ldr	r3, [r3, #0x4]
 8022cf6: f023 0204    	bic	r2, r3, #0x4
 8022cfa: 683b         	ldr	r3, [r7]
 8022cfc: 0c1b         	lsrs	r3, r3, #0x10
 8022cfe: 431a         	orrs	r2, r3
 8022d00: 687b         	ldr	r3, [r7, #0x4]
 8022d02: 605a         	str	r2, [r3, #0x4]
; }
 8022d04: bf00         	nop
 8022d06: 370c         	adds	r7, #0xc
 8022d08: 46bd         	mov	sp, r7
 8022d0a: f85d 7b04    	ldr	r7, [sp], #4
 8022d0e: 4770         	bx	lr

08022d10 <LL_SPI_IsActiveFlag_RXNE>:
; {
 8022d10: b480         	push	{r7}
 8022d12: b083         	sub	sp, #0xc
 8022d14: af00         	add	r7, sp, #0x0
 8022d16: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_RXNE) == (SPI_SR_RXNE)) ? 1UL : 0UL);
 8022d18: 687b         	ldr	r3, [r7, #0x4]
 8022d1a: 689b         	ldr	r3, [r3, #0x8]
 8022d1c: f003 0301    	and	r3, r3, #0x1
 8022d20: 2b01         	cmp	r3, #0x1
 8022d22: d101         	bne	0x8022d28 <LL_SPI_IsActiveFlag_RXNE+0x18> @ imm = #0x2
 8022d24: 2301         	movs	r3, #0x1
 8022d26: e000         	b	0x8022d2a <LL_SPI_IsActiveFlag_RXNE+0x1a> @ imm = #0x0
 8022d28: 2300         	movs	r3, #0x0
; }
 8022d2a: 4618         	mov	r0, r3
 8022d2c: 370c         	adds	r7, #0xc
 8022d2e: 46bd         	mov	sp, r7
 8022d30: f85d 7b04    	ldr	r7, [sp], #4
 8022d34: 4770         	bx	lr

08022d36 <LL_SPI_IsActiveFlag_TXE>:
; {
 8022d36: b480         	push	{r7}
 8022d38: b083         	sub	sp, #0xc
 8022d3a: af00         	add	r7, sp, #0x0
 8022d3c: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_TXE) == (SPI_SR_TXE)) ? 1UL : 0UL);
 8022d3e: 687b         	ldr	r3, [r7, #0x4]
 8022d40: 689b         	ldr	r3, [r3, #0x8]
 8022d42: f003 0302    	and	r3, r3, #0x2
 8022d46: 2b02         	cmp	r3, #0x2
 8022d48: d101         	bne	0x8022d4e <LL_SPI_IsActiveFlag_TXE+0x18> @ imm = #0x2
 8022d4a: 2301         	movs	r3, #0x1
 8022d4c: e000         	b	0x8022d50 <LL_SPI_IsActiveFlag_TXE+0x1a> @ imm = #0x0
 8022d4e: 2300         	movs	r3, #0x0
; }
 8022d50: 4618         	mov	r0, r3
 8022d52: 370c         	adds	r7, #0xc
 8022d54: 46bd         	mov	sp, r7
 8022d56: f85d 7b04    	ldr	r7, [sp], #4
 8022d5a: 4770         	bx	lr

08022d5c <LL_SPI_IsActiveFlag_MODF>:
; {
 8022d5c: b480         	push	{r7}
 8022d5e: b083         	sub	sp, #0xc
 8022d60: af00         	add	r7, sp, #0x0
 8022d62: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_MODF) == (SPI_SR_MODF)) ? 1UL : 0UL);
 8022d64: 687b         	ldr	r3, [r7, #0x4]
 8022d66: 689b         	ldr	r3, [r3, #0x8]
 8022d68: f003 0320    	and	r3, r3, #0x20
 8022d6c: 2b20         	cmp	r3, #0x20
 8022d6e: d101         	bne	0x8022d74 <LL_SPI_IsActiveFlag_MODF+0x18> @ imm = #0x2
 8022d70: 2301         	movs	r3, #0x1
 8022d72: e000         	b	0x8022d76 <LL_SPI_IsActiveFlag_MODF+0x1a> @ imm = #0x0
 8022d74: 2300         	movs	r3, #0x0
; }
 8022d76: 4618         	mov	r0, r3
 8022d78: 370c         	adds	r7, #0xc
 8022d7a: 46bd         	mov	sp, r7
 8022d7c: f85d 7b04    	ldr	r7, [sp], #4
 8022d80: 4770         	bx	lr

08022d82 <LL_SPI_IsActiveFlag_OVR>:
; {
 8022d82: b480         	push	{r7}
 8022d84: b083         	sub	sp, #0xc
 8022d86: af00         	add	r7, sp, #0x0
 8022d88: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_OVR) == (SPI_SR_OVR)) ? 1UL : 0UL);
 8022d8a: 687b         	ldr	r3, [r7, #0x4]
 8022d8c: 689b         	ldr	r3, [r3, #0x8]
 8022d8e: f003 0340    	and	r3, r3, #0x40
 8022d92: 2b40         	cmp	r3, #0x40
 8022d94: d101         	bne	0x8022d9a <LL_SPI_IsActiveFlag_OVR+0x18> @ imm = #0x2
 8022d96: 2301         	movs	r3, #0x1
 8022d98: e000         	b	0x8022d9c <LL_SPI_IsActiveFlag_OVR+0x1a> @ imm = #0x0
 8022d9a: 2300         	movs	r3, #0x0
; }
 8022d9c: 4618         	mov	r0, r3
 8022d9e: 370c         	adds	r7, #0xc
 8022da0: 46bd         	mov	sp, r7
 8022da2: f85d 7b04    	ldr	r7, [sp], #4
 8022da6: 4770         	bx	lr

08022da8 <LL_SPI_IsActiveFlag_BSY>:
; {
 8022da8: b480         	push	{r7}
 8022daa: b083         	sub	sp, #0xc
 8022dac: af00         	add	r7, sp, #0x0
 8022dae: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_BSY) == (SPI_SR_BSY)) ? 1UL : 0UL);
 8022db0: 687b         	ldr	r3, [r7, #0x4]
 8022db2: 689b         	ldr	r3, [r3, #0x8]
 8022db4: f003 0380    	and	r3, r3, #0x80
 8022db8: 2b80         	cmp	r3, #0x80
 8022dba: d101         	bne	0x8022dc0 <LL_SPI_IsActiveFlag_BSY+0x18> @ imm = #0x2
 8022dbc: 2301         	movs	r3, #0x1
 8022dbe: e000         	b	0x8022dc2 <LL_SPI_IsActiveFlag_BSY+0x1a> @ imm = #0x0
 8022dc0: 2300         	movs	r3, #0x0
; }
 8022dc2: 4618         	mov	r0, r3
 8022dc4: 370c         	adds	r7, #0xc
 8022dc6: 46bd         	mov	sp, r7
 8022dc8: f85d 7b04    	ldr	r7, [sp], #4
 8022dcc: 4770         	bx	lr

08022dce <LL_SPI_ClearFlag_MODF>:
; {
 8022dce: b480         	push	{r7}
 8022dd0: b085         	sub	sp, #0x14
 8022dd2: af00         	add	r7, sp, #0x0
 8022dd4: 6078         	str	r0, [r7, #0x4]
;   tmpreg_sr = SPIx->SR;
 8022dd6: 687b         	ldr	r3, [r7, #0x4]
 8022dd8: 689b         	ldr	r3, [r3, #0x8]
 8022dda: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg_sr;
 8022ddc: 68fb         	ldr	r3, [r7, #0xc]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 8022dde: 687b         	ldr	r3, [r7, #0x4]
 8022de0: 681b         	ldr	r3, [r3]
 8022de2: f023 0240    	bic	r2, r3, #0x40
 8022de6: 687b         	ldr	r3, [r7, #0x4]
 8022de8: 601a         	str	r2, [r3]
; }
 8022dea: bf00         	nop
 8022dec: 3714         	adds	r7, #0x14
 8022dee: 46bd         	mov	sp, r7
 8022df0: f85d 7b04    	ldr	r7, [sp], #4
 8022df4: 4770         	bx	lr

08022df6 <LL_SPI_ClearFlag_OVR>:
; {
 8022df6: b480         	push	{r7}
 8022df8: b085         	sub	sp, #0x14
 8022dfa: af00         	add	r7, sp, #0x0
 8022dfc: 6078         	str	r0, [r7, #0x4]
;   tmpreg = SPIx->DR;
 8022dfe: 687b         	ldr	r3, [r7, #0x4]
 8022e00: 68db         	ldr	r3, [r3, #0xc]
 8022e02: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8022e04: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = SPIx->SR;
 8022e06: 687b         	ldr	r3, [r7, #0x4]
 8022e08: 689b         	ldr	r3, [r3, #0x8]
 8022e0a: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8022e0c: 68fb         	ldr	r3, [r7, #0xc]
; }
 8022e0e: bf00         	nop
 8022e10: 3714         	adds	r7, #0x14
 8022e12: 46bd         	mov	sp, r7
 8022e14: f85d 7b04    	ldr	r7, [sp], #4
 8022e18: 4770         	bx	lr

08022e1a <LL_SPI_DisableIT_TXE>:
; {
 8022e1a: b480         	push	{r7}
 8022e1c: b083         	sub	sp, #0xc
 8022e1e: af00         	add	r7, sp, #0x0
 8022e20: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR2, SPI_CR2_TXEIE);
 8022e22: 687b         	ldr	r3, [r7, #0x4]
 8022e24: 685b         	ldr	r3, [r3, #0x4]
 8022e26: f023 0280    	bic	r2, r3, #0x80
 8022e2a: 687b         	ldr	r3, [r7, #0x4]
 8022e2c: 605a         	str	r2, [r3, #0x4]
; }
 8022e2e: bf00         	nop
 8022e30: 370c         	adds	r7, #0xc
 8022e32: 46bd         	mov	sp, r7
 8022e34: f85d 7b04    	ldr	r7, [sp], #4
 8022e38: 4770         	bx	lr

08022e3a <LL_SPI_ReceiveData8>:
; {
 8022e3a: b480         	push	{r7}
 8022e3c: b083         	sub	sp, #0xc
 8022e3e: af00         	add	r7, sp, #0x0
 8022e40: 6078         	str	r0, [r7, #0x4]
;   return (*((__IO uint8_t *)&SPIx->DR));
 8022e42: 687b         	ldr	r3, [r7, #0x4]
 8022e44: 330c         	adds	r3, #0xc
 8022e46: 781b         	ldrb	r3, [r3]
 8022e48: b2db         	uxtb	r3, r3
; }
 8022e4a: 4618         	mov	r0, r3
 8022e4c: 370c         	adds	r7, #0xc
 8022e4e: 46bd         	mov	sp, r7
 8022e50: f85d 7b04    	ldr	r7, [sp], #4
 8022e54: 4770         	bx	lr

08022e56 <LL_SPI_ReceiveData16>:
; {
 8022e56: b480         	push	{r7}
 8022e58: b083         	sub	sp, #0xc
 8022e5a: af00         	add	r7, sp, #0x0
 8022e5c: 6078         	str	r0, [r7, #0x4]
;   return (uint16_t)(READ_REG(SPIx->DR));
 8022e5e: 687b         	ldr	r3, [r7, #0x4]
 8022e60: 68db         	ldr	r3, [r3, #0xc]
 8022e62: b29b         	uxth	r3, r3
; }
 8022e64: 4618         	mov	r0, r3
 8022e66: 370c         	adds	r7, #0xc
 8022e68: 46bd         	mov	sp, r7
 8022e6a: f85d 7b04    	ldr	r7, [sp], #4
 8022e6e: 4770         	bx	lr

08022e70 <LL_SPI_TransmitData8>:
; {
 8022e70: b480         	push	{r7}
 8022e72: b085         	sub	sp, #0x14
 8022e74: af00         	add	r7, sp, #0x0
 8022e76: 6078         	str	r0, [r7, #0x4]
 8022e78: 460b         	mov	r3, r1
 8022e7a: 70fb         	strb	r3, [r7, #0x3]
;   __IO uint8_t *spidr = ((__IO uint8_t *)&SPIx->DR);
 8022e7c: 687b         	ldr	r3, [r7, #0x4]
 8022e7e: 330c         	adds	r3, #0xc
 8022e80: 60fb         	str	r3, [r7, #0xc]
;   *spidr = TxData;
 8022e82: 68fb         	ldr	r3, [r7, #0xc]
 8022e84: 78fa         	ldrb	r2, [r7, #0x3]
 8022e86: 701a         	strb	r2, [r3]
; }
 8022e88: bf00         	nop
 8022e8a: 3714         	adds	r7, #0x14
 8022e8c: 46bd         	mov	sp, r7
 8022e8e: f85d 7b04    	ldr	r7, [sp], #4
 8022e92: 4770         	bx	lr

08022e94 <LL_SPI_TransmitData16>:
; {
 8022e94: b480         	push	{r7}
 8022e96: b085         	sub	sp, #0x14
 8022e98: af00         	add	r7, sp, #0x0
 8022e9a: 6078         	str	r0, [r7, #0x4]
 8022e9c: 460b         	mov	r3, r1
 8022e9e: 807b         	strh	r3, [r7, #0x2]
;   __IO uint16_t *spidr = ((__IO uint16_t *)&SPIx->DR);
 8022ea0: 687b         	ldr	r3, [r7, #0x4]
 8022ea2: 330c         	adds	r3, #0xc
 8022ea4: 60fb         	str	r3, [r7, #0xc]
;   *spidr = TxData;
 8022ea6: 68fb         	ldr	r3, [r7, #0xc]
 8022ea8: 887a         	ldrh	r2, [r7, #0x2]
 8022eaa: 801a         	strh	r2, [r3]
; }
 8022eac: bf00         	nop
 8022eae: 3714         	adds	r7, #0x14
 8022eb0: 46bd         	mov	sp, r7
 8022eb2: f85d 7b04    	ldr	r7, [sp], #4
 8022eb6: 4770         	bx	lr

08022eb8 <z_impl_gpio_pin_configure>:
; {
 8022eb8: b580         	push	{r7, lr}
 8022eba: b088         	sub	sp, #0x20
 8022ebc: af00         	add	r7, sp, #0x0
 8022ebe: 60f8         	str	r0, [r7, #0xc]
 8022ec0: 460b         	mov	r3, r1
 8022ec2: 607a         	str	r2, [r7, #0x4]
 8022ec4: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 8022ec6: 68fb         	ldr	r3, [r7, #0xc]
 8022ec8: 689b         	ldr	r3, [r3, #0x8]
 8022eca: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 8022ecc: 68fb         	ldr	r3, [r7, #0xc]
 8022ece: 685b         	ldr	r3, [r3, #0x4]
 8022ed0: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 8022ed2: 68fb         	ldr	r3, [r7, #0xc]
 8022ed4: 691b         	ldr	r3, [r3, #0x10]
 8022ed6: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 8022ed8: 687b         	ldr	r3, [r7, #0x4]
 8022eda: f403 1380    	and	r3, r3, #0x100000
 8022ede: 2b00         	cmp	r3, #0x0
 8022ee0: d00d         	beq	0x8022efe <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 8022ee2: 687b         	ldr	r3, [r7, #0x4]
 8022ee4: f403 2340    	and	r3, r3, #0xc0000
 8022ee8: 2b00         	cmp	r3, #0x0
 8022eea: d008         	beq	0x8022efe <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 8022eec: 687b         	ldr	r3, [r7, #0x4]
 8022eee: f003 0301    	and	r3, r3, #0x1
 8022ef2: 2b00         	cmp	r3, #0x0
 8022ef4: d003         	beq	0x8022efe <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 8022ef6: 687b         	ldr	r3, [r7, #0x4]
 8022ef8: f483 2340    	eor	r3, r3, #0xc0000
 8022efc: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 8022efe: 687b         	ldr	r3, [r7, #0x4]
 8022f00: f423 1380    	bic	r3, r3, #0x100000
 8022f04: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 8022f06: 687b         	ldr	r3, [r7, #0x4]
 8022f08: f003 0301    	and	r3, r3, #0x1
 8022f0c: 2b00         	cmp	r3, #0x0
 8022f0e: d009         	beq	0x8022f24 <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 8022f10: 697b         	ldr	r3, [r7, #0x14]
 8022f12: 681a         	ldr	r2, [r3]
 8022f14: 7afb         	ldrb	r3, [r7, #0xb]
 8022f16: 2101         	movs	r1, #0x1
 8022f18: fa01 f303    	lsl.w	r3, r1, r3
 8022f1c: 431a         	orrs	r2, r3
 8022f1e: 697b         	ldr	r3, [r7, #0x14]
 8022f20: 601a         	str	r2, [r3]
 8022f22: e009         	b	0x8022f38 <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 8022f24: 697b         	ldr	r3, [r7, #0x14]
 8022f26: 681a         	ldr	r2, [r3]
 8022f28: 7afb         	ldrb	r3, [r7, #0xb]
 8022f2a: 2101         	movs	r1, #0x1
 8022f2c: fa01 f303    	lsl.w	r3, r1, r3
 8022f30: 43db         	mvns	r3, r3
 8022f32: 401a         	ands	r2, r3
 8022f34: 697b         	ldr	r3, [r7, #0x14]
 8022f36: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 8022f38: 69fb         	ldr	r3, [r7, #0x1c]
 8022f3a: 681b         	ldr	r3, [r3]
 8022f3c: 7af9         	ldrb	r1, [r7, #0xb]
 8022f3e: 687a         	ldr	r2, [r7, #0x4]
 8022f40: 68f8         	ldr	r0, [r7, #0xc]
 8022f42: 4798         	blx	r3
 8022f44: 4603         	mov	r3, r0
; }
 8022f46: 4618         	mov	r0, r3
 8022f48: 3720         	adds	r7, #0x20
 8022f4a: 46bd         	mov	sp, r7
 8022f4c: bd80         	pop	{r7, pc}

08022f4e <gpio_pin_configure_dt>:
; {
 8022f4e: b580         	push	{r7, lr}
 8022f50: b082         	sub	sp, #0x8
 8022f52: af00         	add	r7, sp, #0x0
 8022f54: 6078         	str	r0, [r7, #0x4]
 8022f56: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 8022f58: 687b         	ldr	r3, [r7, #0x4]
 8022f5a: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 8022f5c: 687b         	ldr	r3, [r7, #0x4]
 8022f5e: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 8022f60: 687b         	ldr	r3, [r7, #0x4]
 8022f62: 88db         	ldrh	r3, [r3, #0x6]
 8022f64: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 8022f66: 683b         	ldr	r3, [r7]
 8022f68: 4313         	orrs	r3, r2
 8022f6a: 461a         	mov	r2, r3
 8022f6c: f000 f888    	bl	0x8023080 <gpio_pin_configure> @ imm = #0x110
 8022f70: 4603         	mov	r3, r0
; }
 8022f72: 4618         	mov	r0, r3
 8022f74: 3708         	adds	r7, #0x8
 8022f76: 46bd         	mov	sp, r7
 8022f78: bd80         	pop	{r7, pc}

08022f7a <z_impl_gpio_port_set_bits_raw>:
; {
 8022f7a: b580         	push	{r7, lr}
 8022f7c: b084         	sub	sp, #0x10
 8022f7e: af00         	add	r7, sp, #0x0
 8022f80: 6078         	str	r0, [r7, #0x4]
 8022f82: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 8022f84: 687b         	ldr	r3, [r7, #0x4]
 8022f86: 689b         	ldr	r3, [r3, #0x8]
 8022f88: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_set_bits_raw(port, pins);
 8022f8a: 68fb         	ldr	r3, [r7, #0xc]
 8022f8c: 68db         	ldr	r3, [r3, #0xc]
 8022f8e: 6839         	ldr	r1, [r7]
 8022f90: 6878         	ldr	r0, [r7, #0x4]
 8022f92: 4798         	blx	r3
 8022f94: 4603         	mov	r3, r0
; }
 8022f96: 4618         	mov	r0, r3
 8022f98: 3710         	adds	r7, #0x10
 8022f9a: 46bd         	mov	sp, r7
 8022f9c: bd80         	pop	{r7, pc}

08022f9e <z_impl_gpio_port_clear_bits_raw>:
; {
 8022f9e: b580         	push	{r7, lr}
 8022fa0: b084         	sub	sp, #0x10
 8022fa2: af00         	add	r7, sp, #0x0
 8022fa4: 6078         	str	r0, [r7, #0x4]
 8022fa6: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 8022fa8: 687b         	ldr	r3, [r7, #0x4]
 8022faa: 689b         	ldr	r3, [r3, #0x8]
 8022fac: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_clear_bits_raw(port, pins);
 8022fae: 68fb         	ldr	r3, [r7, #0xc]
 8022fb0: 691b         	ldr	r3, [r3, #0x10]
 8022fb2: 6839         	ldr	r1, [r7]
 8022fb4: 6878         	ldr	r0, [r7, #0x4]
 8022fb6: 4798         	blx	r3
 8022fb8: 4603         	mov	r3, r0
; }
 8022fba: 4618         	mov	r0, r3
 8022fbc: 3710         	adds	r7, #0x10
 8022fbe: 46bd         	mov	sp, r7
 8022fc0: bd80         	pop	{r7, pc}

08022fc2 <gpio_pin_set_raw>:
; {
 8022fc2: b580         	push	{r7, lr}
 8022fc4: b086         	sub	sp, #0x18
 8022fc6: af00         	add	r7, sp, #0x0
 8022fc8: 60f8         	str	r0, [r7, #0xc]
 8022fca: 460b         	mov	r3, r1
 8022fcc: 607a         	str	r2, [r7, #0x4]
 8022fce: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 8022fd0: 68fb         	ldr	r3, [r7, #0xc]
 8022fd2: 685b         	ldr	r3, [r3, #0x4]
 8022fd4: 613b         	str	r3, [r7, #0x10]
; 	if (value != 0)	{
 8022fd6: 687b         	ldr	r3, [r7, #0x4]
 8022fd8: 2b00         	cmp	r3, #0x0
 8022fda: d009         	beq	0x8022ff0 <gpio_pin_set_raw+0x2e> @ imm = #0x12
; 		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 8022fdc: 7afb         	ldrb	r3, [r7, #0xb]
 8022fde: 2201         	movs	r2, #0x1
 8022fe0: fa02 f303    	lsl.w	r3, r2, r3
 8022fe4: 4619         	mov	r1, r3
 8022fe6: 68f8         	ldr	r0, [r7, #0xc]
 8022fe8: f000 f85c    	bl	0x80230a4 <gpio_port_set_bits_raw> @ imm = #0xb8
 8022fec: 6178         	str	r0, [r7, #0x14]
 8022fee: e008         	b	0x8023002 <gpio_pin_set_raw+0x40> @ imm = #0x10
; 		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 8022ff0: 7afb         	ldrb	r3, [r7, #0xb]
 8022ff2: 2201         	movs	r2, #0x1
 8022ff4: fa02 f303    	lsl.w	r3, r2, r3
 8022ff8: 4619         	mov	r1, r3
 8022ffa: 68f8         	ldr	r0, [r7, #0xc]
 8022ffc: f000 f860    	bl	0x80230c0 <gpio_port_clear_bits_raw> @ imm = #0xc0
 8023000: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 8023002: 697b         	ldr	r3, [r7, #0x14]
; }
 8023004: 4618         	mov	r0, r3
 8023006: 3718         	adds	r7, #0x18
 8023008: 46bd         	mov	sp, r7
 802300a: bd80         	pop	{r7, pc}

0802300c <gpio_pin_set>:
; {
 802300c: b580         	push	{r7, lr}
 802300e: b086         	sub	sp, #0x18
 8023010: af00         	add	r7, sp, #0x0
 8023012: 60f8         	str	r0, [r7, #0xc]
 8023014: 460b         	mov	r3, r1
 8023016: 607a         	str	r2, [r7, #0x4]
 8023018: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 802301a: 68fb         	ldr	r3, [r7, #0xc]
 802301c: 685b         	ldr	r3, [r3, #0x4]
 802301e: 617b         	str	r3, [r7, #0x14]
; 	const struct gpio_driver_data *const data =
 8023020: 68fb         	ldr	r3, [r7, #0xc]
 8023022: 691b         	ldr	r3, [r3, #0x10]
 8023024: 613b         	str	r3, [r7, #0x10]
; 	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
 8023026: 693b         	ldr	r3, [r7, #0x10]
 8023028: 681a         	ldr	r2, [r3]
 802302a: 7afb         	ldrb	r3, [r7, #0xb]
 802302c: 2101         	movs	r1, #0x1
 802302e: fa01 f303    	lsl.w	r3, r1, r3
 8023032: 4013         	ands	r3, r2
 8023034: 2b00         	cmp	r3, #0x0
 8023036: d006         	beq	0x8023046 <gpio_pin_set+0x3a> @ imm = #0xc
; 		value = (value != 0) ? 0 : 1;
 8023038: 687b         	ldr	r3, [r7, #0x4]
 802303a: 2b00         	cmp	r3, #0x0
 802303c: bf0c         	ite	eq
 802303e: 2301         	moveq	r3, #0x1
 8023040: 2300         	movne	r3, #0x0
 8023042: b2db         	uxtb	r3, r3
 8023044: 607b         	str	r3, [r7, #0x4]
; 	return gpio_pin_set_raw(port, pin, value);
 8023046: 7afb         	ldrb	r3, [r7, #0xb]
 8023048: 687a         	ldr	r2, [r7, #0x4]
 802304a: 4619         	mov	r1, r3
 802304c: 68f8         	ldr	r0, [r7, #0xc]
 802304e: f7ff ffb8    	bl	0x8022fc2 <gpio_pin_set_raw> @ imm = #-0x90
 8023052: 4603         	mov	r3, r0
; }
 8023054: 4618         	mov	r0, r3
 8023056: 3718         	adds	r7, #0x18
 8023058: 46bd         	mov	sp, r7
 802305a: bd80         	pop	{r7, pc}

0802305c <gpio_pin_set_dt>:
; {
 802305c: b580         	push	{r7, lr}
 802305e: b082         	sub	sp, #0x8
 8023060: af00         	add	r7, sp, #0x0
 8023062: 6078         	str	r0, [r7, #0x4]
 8023064: 6039         	str	r1, [r7]
; 	return gpio_pin_set(spec->port, spec->pin, value);
 8023066: 687b         	ldr	r3, [r7, #0x4]
 8023068: 6818         	ldr	r0, [r3]
 802306a: 687b         	ldr	r3, [r7, #0x4]
 802306c: 791b         	ldrb	r3, [r3, #0x4]
 802306e: 683a         	ldr	r2, [r7]
 8023070: 4619         	mov	r1, r3
 8023072: f7ff ffcb    	bl	0x802300c <gpio_pin_set> @ imm = #-0x6a
 8023076: 4603         	mov	r3, r0
; }
 8023078: 4618         	mov	r0, r3
 802307a: 3708         	adds	r7, #0x8
 802307c: 46bd         	mov	sp, r7
 802307e: bd80         	pop	{r7, pc}

08023080 <gpio_pin_configure>:
; {
 8023080: b580         	push	{r7, lr}
 8023082: b084         	sub	sp, #0x10
 8023084: af00         	add	r7, sp, #0x0
 8023086: 60f8         	str	r0, [r7, #0xc]
 8023088: 460b         	mov	r3, r1
 802308a: 607a         	str	r2, [r7, #0x4]
 802308c: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 802308e: 7afb         	ldrb	r3, [r7, #0xb]
 8023090: 687a         	ldr	r2, [r7, #0x4]
 8023092: 4619         	mov	r1, r3
 8023094: 68f8         	ldr	r0, [r7, #0xc]
 8023096: f7ff ff0f    	bl	0x8022eb8 <z_impl_gpio_pin_configure> @ imm = #-0x1e2
 802309a: 4603         	mov	r3, r0
; }
 802309c: 4618         	mov	r0, r3
 802309e: 3710         	adds	r7, #0x10
 80230a0: 46bd         	mov	sp, r7
 80230a2: bd80         	pop	{r7, pc}

080230a4 <gpio_port_set_bits_raw>:
; {
 80230a4: b580         	push	{r7, lr}
 80230a6: b082         	sub	sp, #0x8
 80230a8: af00         	add	r7, sp, #0x0
 80230aa: 6078         	str	r0, [r7, #0x4]
 80230ac: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_set_bits_raw(port, pins);
 80230ae: 6839         	ldr	r1, [r7]
 80230b0: 6878         	ldr	r0, [r7, #0x4]
 80230b2: f7ff ff62    	bl	0x8022f7a <z_impl_gpio_port_set_bits_raw> @ imm = #-0x13c
 80230b6: 4603         	mov	r3, r0
; }
 80230b8: 4618         	mov	r0, r3
 80230ba: 3708         	adds	r7, #0x8
 80230bc: 46bd         	mov	sp, r7
 80230be: bd80         	pop	{r7, pc}

080230c0 <gpio_port_clear_bits_raw>:
; {
 80230c0: b580         	push	{r7, lr}
 80230c2: b082         	sub	sp, #0x8
 80230c4: af00         	add	r7, sp, #0x0
 80230c6: 6078         	str	r0, [r7, #0x4]
 80230c8: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_clear_bits_raw(port, pins);
 80230ca: 6839         	ldr	r1, [r7]
 80230cc: 6878         	ldr	r0, [r7, #0x4]
 80230ce: f7ff ff66    	bl	0x8022f9e <z_impl_gpio_port_clear_bits_raw> @ imm = #-0x134
 80230d2: 4603         	mov	r3, r0
; }
 80230d4: 4618         	mov	r0, r3
 80230d6: 3708         	adds	r7, #0x8
 80230d8: 46bd         	mov	sp, r7
 80230da: bd80         	pop	{r7, pc}

080230dc <spi_cs_is_gpio>:
; {
 80230dc: b480         	push	{r7}
 80230de: b083         	sub	sp, #0xc
 80230e0: af00         	add	r7, sp, #0x0
 80230e2: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 80230e4: 687b         	ldr	r3, [r7, #0x4]
 80230e6: 689b         	ldr	r3, [r3, #0x8]
 80230e8: 2b00         	cmp	r3, #0x0
 80230ea: bf14         	ite	ne
 80230ec: 2301         	movne	r3, #0x1
 80230ee: 2300         	moveq	r3, #0x0
 80230f0: b2db         	uxtb	r3, r3
; }
 80230f2: 4618         	mov	r0, r3
 80230f4: 370c         	adds	r7, #0xc
 80230f6: 46bd         	mov	sp, r7
 80230f8: f85d 7b04    	ldr	r7, [sp], #4
 80230fc: 4770         	bx	lr

080230fe <pinctrl_apply_state_direct>:
; {
 80230fe: b580         	push	{r7, lr}
 8023100: b084         	sub	sp, #0x10
 8023102: af00         	add	r7, sp, #0x0
 8023104: 6078         	str	r0, [r7, #0x4]
 8023106: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 8023108: 2300         	movs	r3, #0x0
 802310a: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 802310c: 683b         	ldr	r3, [r7]
 802310e: 6818         	ldr	r0, [r3]
 8023110: 683b         	ldr	r3, [r7]
 8023112: 791b         	ldrb	r3, [r3, #0x4]
 8023114: 68fa         	ldr	r2, [r7, #0xc]
 8023116: 4619         	mov	r1, r3
 8023118: f7fc fe49    	bl	0x801fdae <pinctrl_configure_pins> @ imm = #-0x336e
 802311c: 4603         	mov	r3, r0
; }
 802311e: 4618         	mov	r0, r3
 8023120: 3710         	adds	r7, #0x10
 8023122: 46bd         	mov	sp, r7
 8023124: bd80         	pop	{r7, pc}

08023126 <pinctrl_apply_state>:
; {
 8023126: b580         	push	{r7, lr}
 8023128: b084         	sub	sp, #0x10
 802312a: af00         	add	r7, sp, #0x0
 802312c: 6078         	str	r0, [r7, #0x4]
 802312e: 460b         	mov	r3, r1
 8023130: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 8023132: f107 0208    	add.w	r2, r7, #0x8
 8023136: 78fb         	ldrb	r3, [r7, #0x3]
 8023138: 4619         	mov	r1, r3
 802313a: 6878         	ldr	r0, [r7, #0x4]
 802313c: f7fc fdff    	bl	0x801fd3e <pinctrl_lookup_state> @ imm = #-0x3402
 8023140: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8023142: 68fb         	ldr	r3, [r7, #0xc]
 8023144: 2b00         	cmp	r3, #0x0
 8023146: da01         	bge	0x802314c <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 8023148: 68fb         	ldr	r3, [r7, #0xc]
 802314a: e005         	b	0x8023158 <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 802314c: 68bb         	ldr	r3, [r7, #0x8]
 802314e: 4619         	mov	r1, r3
 8023150: 6878         	ldr	r0, [r7, #0x4]
 8023152: f7ff ffd4    	bl	0x80230fe <pinctrl_apply_state_direct> @ imm = #-0x58
 8023156: 4603         	mov	r3, r0
; }
 8023158: 4618         	mov	r0, r3
 802315a: 3710         	adds	r7, #0x10
 802315c: 46bd         	mov	sp, r7
 802315e: bd80         	pop	{r7, pc}

08023160 <pm_device_runtime_enable>:
; {
 8023160: b480         	push	{r7}
 8023162: b083         	sub	sp, #0xc
 8023164: af00         	add	r7, sp, #0x0
 8023166: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8023168: 2300         	movs	r3, #0x0
; }
 802316a: 4618         	mov	r0, r3
 802316c: 370c         	adds	r7, #0xc
 802316e: 46bd         	mov	sp, r7
 8023170: f85d 7b04    	ldr	r7, [sp], #4
 8023174: 4770         	bx	lr

08023176 <clock_control_on>:
; {
 8023176: b580         	push	{r7, lr}
 8023178: b084         	sub	sp, #0x10
 802317a: af00         	add	r7, sp, #0x0
 802317c: 6078         	str	r0, [r7, #0x4]
 802317e: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8023180: 687b         	ldr	r3, [r7, #0x4]
 8023182: 689b         	ldr	r3, [r3, #0x8]
 8023184: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8023186: 68fb         	ldr	r3, [r7, #0xc]
 8023188: 681b         	ldr	r3, [r3]
 802318a: 6839         	ldr	r1, [r7]
 802318c: 6878         	ldr	r0, [r7, #0x4]
 802318e: 4798         	blx	r3
 8023190: 4603         	mov	r3, r0
; }
 8023192: 4618         	mov	r0, r3
 8023194: 3710         	adds	r7, #0x10
 8023196: 46bd         	mov	sp, r7
 8023198: bd80         	pop	{r7, pc}

0802319a <clock_control_get_rate>:
; {
 802319a: b580         	push	{r7, lr}
 802319c: b086         	sub	sp, #0x18
 802319e: af00         	add	r7, sp, #0x0
 80231a0: 60f8         	str	r0, [r7, #0xc]
 80231a2: 60b9         	str	r1, [r7, #0x8]
 80231a4: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 80231a6: 68fb         	ldr	r3, [r7, #0xc]
 80231a8: 689b         	ldr	r3, [r3, #0x8]
 80231aa: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 80231ac: 697b         	ldr	r3, [r7, #0x14]
 80231ae: 68db         	ldr	r3, [r3, #0xc]
 80231b0: 2b00         	cmp	r3, #0x0
 80231b2: d102         	bne	0x80231ba <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 80231b4: f06f 0357    	mvn	r3, #0x57
 80231b8: e006         	b	0x80231c8 <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 80231ba: 697b         	ldr	r3, [r7, #0x14]
 80231bc: 68db         	ldr	r3, [r3, #0xc]
 80231be: 687a         	ldr	r2, [r7, #0x4]
 80231c0: 68b9         	ldr	r1, [r7, #0x8]
 80231c2: 68f8         	ldr	r0, [r7, #0xc]
 80231c4: 4798         	blx	r3
 80231c6: 4603         	mov	r3, r0
; }
 80231c8: 4618         	mov	r0, r3
 80231ca: 3718         	adds	r7, #0x18
 80231cc: 46bd         	mov	sp, r7
 80231ce: bd80         	pop	{r7, pc}

080231d0 <spi_context_configured>:
; {
 80231d0: b480         	push	{r7}
 80231d2: b083         	sub	sp, #0xc
 80231d4: af00         	add	r7, sp, #0x0
 80231d6: 6078         	str	r0, [r7, #0x4]
 80231d8: 6039         	str	r1, [r7]
; 	return !!(ctx->config == config);
 80231da: 687b         	ldr	r3, [r7, #0x4]
 80231dc: 681b         	ldr	r3, [r3]
 80231de: 683a         	ldr	r2, [r7]
 80231e0: 429a         	cmp	r2, r3
 80231e2: bf0c         	ite	eq
 80231e4: 2301         	moveq	r3, #0x1
 80231e6: 2300         	movne	r3, #0x0
 80231e8: b2db         	uxtb	r3, r3
; }
 80231ea: 4618         	mov	r0, r3
 80231ec: 370c         	adds	r7, #0xc
 80231ee: 46bd         	mov	sp, r7
 80231f0: f85d 7b04    	ldr	r7, [sp], #4
 80231f4: 4770         	bx	lr

080231f6 <spi_context_lock>:
; {
 80231f6: b580         	push	{r7, lr}
 80231f8: b084         	sub	sp, #0x10
 80231fa: af00         	add	r7, sp, #0x0
 80231fc: 60f8         	str	r0, [r7, #0xc]
 80231fe: 607a         	str	r2, [r7, #0x4]
 8023200: 603b         	str	r3, [r7]
 8023202: 460b         	mov	r3, r1
 8023204: 72fb         	strb	r3, [r7, #0xb]
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 8023206: 69bb         	ldr	r3, [r7, #0x18]
 8023208: 889b         	ldrh	r3, [r3, #0x4]
 802320a: f403 5300    	and	r3, r3, #0x2000
 802320e: 2b00         	cmp	r3, #0x0
 8023210: d00d         	beq	0x802322e <spi_context_lock+0x38> @ imm = #0x1a
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 8023212: 68fb         	ldr	r3, [r7, #0xc]
 8023214: 3310         	adds	r3, #0x10
 8023216: 4618         	mov	r0, r3
 8023218: f7ff fc69    	bl	0x8022aee <k_sem_count_get> @ imm = #-0x72e
 802321c: 4603         	mov	r3, r0
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 802321e: 2b00         	cmp	r3, #0x0
 8023220: d105         	bne	0x802322e <spi_context_lock+0x38> @ imm = #0xa
; 		(ctx->owner == spi_cfg)) {
 8023222: 68fb         	ldr	r3, [r7, #0xc]
 8023224: 685b         	ldr	r3, [r3, #0x4]
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 8023226: 69ba         	ldr	r2, [r7, #0x18]
 8023228: 429a         	cmp	r2, r3
 802322a: d100         	bne	0x802322e <spi_context_lock+0x38> @ imm = #0x0
 802322c: e00c         	b	0x8023248 <spi_context_lock+0x52> @ imm = #0x18
; 	k_sem_take(&ctx->lock, K_FOREVER);
 802322e: 68fb         	ldr	r3, [r7, #0xc]
 8023230: f103 0110    	add.w	r1, r3, #0x10
 8023234: f04f 32ff    	mov.w	r2, #0xffffffff
 8023238: f04f 33ff    	mov.w	r3, #0xffffffff
 802323c: 4608         	mov	r0, r1
 802323e: f7ff fc3b    	bl	0x8022ab8 <k_sem_take>  @ imm = #-0x78a
; 	ctx->owner = spi_cfg;
 8023242: 68fb         	ldr	r3, [r7, #0xc]
 8023244: 69ba         	ldr	r2, [r7, #0x18]
 8023246: 605a         	str	r2, [r3, #0x4]
; }
 8023248: 3710         	adds	r7, #0x10
 802324a: 46bd         	mov	sp, r7
 802324c: bd80         	pop	{r7, pc}

0802324e <spi_context_release>:
; {
 802324e: b580         	push	{r7, lr}
 8023250: b082         	sub	sp, #0x8
 8023252: af00         	add	r7, sp, #0x0
 8023254: 6078         	str	r0, [r7, #0x4]
 8023256: 6039         	str	r1, [r7]
; 	if (!(ctx->config->operation & SPI_LOCK_ON)) {
 8023258: 687b         	ldr	r3, [r7, #0x4]
 802325a: 681b         	ldr	r3, [r3]
 802325c: 889b         	ldrh	r3, [r3, #0x4]
 802325e: f403 5300    	and	r3, r3, #0x2000
 8023262: 2b00         	cmp	r3, #0x0
 8023264: d107         	bne	0x8023276 <spi_context_release+0x28> @ imm = #0xe
; 		ctx->owner = NULL;
 8023266: 687b         	ldr	r3, [r7, #0x4]
 8023268: 2200         	movs	r2, #0x0
 802326a: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 802326c: 687b         	ldr	r3, [r7, #0x4]
 802326e: 3310         	adds	r3, #0x10
 8023270: 4618         	mov	r0, r3
 8023272: f7ff fc31    	bl	0x8022ad8 <k_sem_give>  @ imm = #-0x79e
; }
 8023276: bf00         	nop
 8023278: 3708         	adds	r7, #0x8
 802327a: 46bd         	mov	sp, r7
 802327c: bd80         	pop	{r7, pc}

0802327e <_spi_context_cs_control>:
; {
 802327e: b580         	push	{r7, lr}
 8023280: b082         	sub	sp, #0x8
 8023282: af00         	add	r7, sp, #0x0
 8023284: 6078         	str	r0, [r7, #0x4]
 8023286: 460b         	mov	r3, r1
 8023288: 70fb         	strb	r3, [r7, #0x3]
 802328a: 4613         	mov	r3, r2
 802328c: 70bb         	strb	r3, [r7, #0x2]
; 	if (ctx->config && spi_cs_is_gpio(ctx->config)) {
 802328e: 687b         	ldr	r3, [r7, #0x4]
 8023290: 681b         	ldr	r3, [r3]
 8023292: 2b00         	cmp	r3, #0x0
 8023294: d034         	beq	0x8023300 <_spi_context_cs_control+0x82> @ imm = #0x68
 8023296: 687b         	ldr	r3, [r7, #0x4]
 8023298: 681b         	ldr	r3, [r3]
 802329a: 4618         	mov	r0, r3
 802329c: f7ff ff1e    	bl	0x80230dc <spi_cs_is_gpio> @ imm = #-0x1c4
 80232a0: 4603         	mov	r3, r0
 80232a2: 2b00         	cmp	r3, #0x0
 80232a4: d02c         	beq	0x8023300 <_spi_context_cs_control+0x82> @ imm = #0x58
; 		if (on) {
 80232a6: 78fb         	ldrb	r3, [r7, #0x3]
 80232a8: 2b00         	cmp	r3, #0x0
 80232aa: d00d         	beq	0x80232c8 <_spi_context_cs_control+0x4a> @ imm = #0x1a
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 1);
 80232ac: 687b         	ldr	r3, [r7, #0x4]
 80232ae: 681b         	ldr	r3, [r3]
 80232b0: 3308         	adds	r3, #0x8
 80232b2: 2101         	movs	r1, #0x1
 80232b4: 4618         	mov	r0, r3
 80232b6: f7ff fed1    	bl	0x802305c <gpio_pin_set_dt> @ imm = #-0x25e
; 			k_busy_wait(ctx->config->cs.delay);
 80232ba: 687b         	ldr	r3, [r7, #0x4]
 80232bc: 681b         	ldr	r3, [r3]
 80232be: 691b         	ldr	r3, [r3, #0x10]
 80232c0: 4618         	mov	r0, r3
 80232c2: f7ff fbee    	bl	0x8022aa2 <k_busy_wait> @ imm = #-0x824
 80232c6: e01b         	b	0x8023300 <_spi_context_cs_control+0x82> @ imm = #0x36
; 			if (!force_off &&
 80232c8: 78bb         	ldrb	r3, [r7, #0x2]
 80232ca: f083 0301    	eor	r3, r3, #0x1
 80232ce: b2db         	uxtb	r3, r3
 80232d0: 2b00         	cmp	r3, #0x0
 80232d2: d006         	beq	0x80232e2 <_spi_context_cs_control+0x64> @ imm = #0xc
; 			    ctx->config->operation & SPI_HOLD_ON_CS) {
 80232d4: 687b         	ldr	r3, [r7, #0x4]
 80232d6: 681b         	ldr	r3, [r3]
 80232d8: 889b         	ldrh	r3, [r3, #0x4]
 80232da: f403 5380    	and	r3, r3, #0x1000
; 			if (!force_off &&
 80232de: 2b00         	cmp	r3, #0x0
 80232e0: d10d         	bne	0x80232fe <_spi_context_cs_control+0x80> @ imm = #0x1a
; 			k_busy_wait(ctx->config->cs.delay);
 80232e2: 687b         	ldr	r3, [r7, #0x4]
 80232e4: 681b         	ldr	r3, [r3]
 80232e6: 691b         	ldr	r3, [r3, #0x10]
 80232e8: 4618         	mov	r0, r3
 80232ea: f7ff fbda    	bl	0x8022aa2 <k_busy_wait> @ imm = #-0x84c
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 0);
 80232ee: 687b         	ldr	r3, [r7, #0x4]
 80232f0: 681b         	ldr	r3, [r3]
 80232f2: 3308         	adds	r3, #0x8
 80232f4: 2100         	movs	r1, #0x0
 80232f6: 4618         	mov	r0, r3
 80232f8: f7ff feb0    	bl	0x802305c <gpio_pin_set_dt> @ imm = #-0x2a0
 80232fc: e000         	b	0x8023300 <_spi_context_cs_control+0x82> @ imm = #0x0
; 				return;
 80232fe: bf00         	nop
; }
 8023300: 3708         	adds	r7, #0x8
 8023302: 46bd         	mov	sp, r7
 8023304: bd80         	pop	{r7, pc}

08023306 <spi_context_cs_control>:
; {
 8023306: b580         	push	{r7, lr}
 8023308: b082         	sub	sp, #0x8
 802330a: af00         	add	r7, sp, #0x0
 802330c: 6078         	str	r0, [r7, #0x4]
 802330e: 460b         	mov	r3, r1
 8023310: 70fb         	strb	r3, [r7, #0x3]
; 	_spi_context_cs_control(ctx, on, false);
 8023312: 78fb         	ldrb	r3, [r7, #0x3]
 8023314: 2200         	movs	r2, #0x0
 8023316: 4619         	mov	r1, r3
 8023318: 6878         	ldr	r0, [r7, #0x4]
 802331a: f7ff ffb0    	bl	0x802327e <_spi_context_cs_control> @ imm = #-0xa0
; }
 802331e: bf00         	nop
 8023320: 3708         	adds	r7, #0x8
 8023322: 46bd         	mov	sp, r7
 8023324: bd80         	pop	{r7, pc}

08023326 <spi_context_unlock_unconditionally>:
; {
 8023326: b580         	push	{r7, lr}
 8023328: b082         	sub	sp, #0x8
 802332a: af00         	add	r7, sp, #0x0
 802332c: 6078         	str	r0, [r7, #0x4]
; 	_spi_context_cs_control(ctx, false, true);
 802332e: 2201         	movs	r2, #0x1
 8023330: 2100         	movs	r1, #0x0
 8023332: 6878         	ldr	r0, [r7, #0x4]
 8023334: f7ff ffa3    	bl	0x802327e <_spi_context_cs_control> @ imm = #-0xba
; 	if (!k_sem_count_get(&ctx->lock)) {
 8023338: 687b         	ldr	r3, [r7, #0x4]
 802333a: 3310         	adds	r3, #0x10
 802333c: 4618         	mov	r0, r3
 802333e: f7ff fbd6    	bl	0x8022aee <k_sem_count_get> @ imm = #-0x854
 8023342: 4603         	mov	r3, r0
 8023344: 2b00         	cmp	r3, #0x0
 8023346: d107         	bne	0x8023358 <spi_context_unlock_unconditionally+0x32> @ imm = #0xe
; 		ctx->owner = NULL;
 8023348: 687b         	ldr	r3, [r7, #0x4]
 802334a: 2200         	movs	r2, #0x0
 802334c: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 802334e: 687b         	ldr	r3, [r7, #0x4]
 8023350: 3310         	adds	r3, #0x10
 8023352: 4618         	mov	r0, r3
 8023354: f7ff fbc0    	bl	0x8022ad8 <k_sem_give>  @ imm = #-0x880
; }
 8023358: bf00         	nop
 802335a: 3708         	adds	r7, #0x8
 802335c: 46bd         	mov	sp, r7
 802335e: bd80         	pop	{r7, pc}

08023360 <spi_context_get_next_buf>:
; {
 8023360: b480         	push	{r7}
 8023362: b085         	sub	sp, #0x14
 8023364: af00         	add	r7, sp, #0x0
 8023366: 60f8         	str	r0, [r7, #0xc]
 8023368: 60b9         	str	r1, [r7, #0x8]
 802336a: 607a         	str	r2, [r7, #0x4]
 802336c: 70fb         	strb	r3, [r7, #0x3]
; 	while (*count) {
 802336e: e01c         	b	0x80233aa <spi_context_get_next_buf+0x4a> @ imm = #0x38
; 		if (((*current)->len / dfs) != 0) {
 8023370: 68fb         	ldr	r3, [r7, #0xc]
 8023372: 681b         	ldr	r3, [r3]
 8023374: 685a         	ldr	r2, [r3, #0x4]
 8023376: 78fb         	ldrb	r3, [r7, #0x3]
 8023378: 429a         	cmp	r2, r3
 802337a: d30b         	blo	0x8023394 <spi_context_get_next_buf+0x34> @ imm = #0x16
; 			*buf_len = (*current)->len / dfs;
 802337c: 68fb         	ldr	r3, [r7, #0xc]
 802337e: 681b         	ldr	r3, [r3]
 8023380: 685a         	ldr	r2, [r3, #0x4]
 8023382: 78fb         	ldrb	r3, [r7, #0x3]
 8023384: fbb2 f2f3    	udiv	r2, r2, r3
 8023388: 687b         	ldr	r3, [r7, #0x4]
 802338a: 601a         	str	r2, [r3]
; 			return (*current)->buf;
 802338c: 68fb         	ldr	r3, [r7, #0xc]
 802338e: 681b         	ldr	r3, [r3]
 8023390: 681b         	ldr	r3, [r3]
 8023392: e012         	b	0x80233ba <spi_context_get_next_buf+0x5a> @ imm = #0x24
; 		++(*current);
 8023394: 68fb         	ldr	r3, [r7, #0xc]
 8023396: 681b         	ldr	r3, [r3]
 8023398: f103 0208    	add.w	r2, r3, #0x8
 802339c: 68fb         	ldr	r3, [r7, #0xc]
 802339e: 601a         	str	r2, [r3]
; 		--(*count);
 80233a0: 68bb         	ldr	r3, [r7, #0x8]
 80233a2: 681b         	ldr	r3, [r3]
 80233a4: 1e5a         	subs	r2, r3, #0x1
 80233a6: 68bb         	ldr	r3, [r7, #0x8]
 80233a8: 601a         	str	r2, [r3]
; 	while (*count) {
 80233aa: 68bb         	ldr	r3, [r7, #0x8]
 80233ac: 681b         	ldr	r3, [r3]
 80233ae: 2b00         	cmp	r3, #0x0
 80233b0: d1de         	bne	0x8023370 <spi_context_get_next_buf+0x10> @ imm = #-0x44
; 	*buf_len = 0;
 80233b2: 687b         	ldr	r3, [r7, #0x4]
 80233b4: 2200         	movs	r2, #0x0
 80233b6: 601a         	str	r2, [r3]
; 	return NULL;
 80233b8: 2300         	movs	r3, #0x0
; }
 80233ba: 4618         	mov	r0, r3
 80233bc: 3714         	adds	r7, #0x14
 80233be: 46bd         	mov	sp, r7
 80233c0: f85d 7b04    	ldr	r7, [sp], #4
 80233c4: 4770         	bx	lr

080233c6 <ll_func_tx_is_not_full>:
; {
 80233c6: b580         	push	{r7, lr}
 80233c8: b082         	sub	sp, #0x8
 80233ca: af00         	add	r7, sp, #0x0
 80233cc: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_TXE(spi);
 80233ce: 6878         	ldr	r0, [r7, #0x4]
 80233d0: f7ff fcb1    	bl	0x8022d36 <LL_SPI_IsActiveFlag_TXE> @ imm = #-0x69e
 80233d4: 4603         	mov	r3, r0
; }
 80233d6: 4618         	mov	r0, r3
 80233d8: 3708         	adds	r7, #0x8
 80233da: 46bd         	mov	sp, r7
 80233dc: bd80         	pop	{r7, pc}

080233de <ll_func_rx_is_not_empty>:
; {
 80233de: b580         	push	{r7, lr}
 80233e0: b082         	sub	sp, #0x8
 80233e2: af00         	add	r7, sp, #0x0
 80233e4: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_RXNE(spi);
 80233e6: 6878         	ldr	r0, [r7, #0x4]
 80233e8: f7ff fc92    	bl	0x8022d10 <LL_SPI_IsActiveFlag_RXNE> @ imm = #-0x6dc
 80233ec: 4603         	mov	r3, r0
; }
 80233ee: 4618         	mov	r0, r3
 80233f0: 3708         	adds	r7, #0x8
 80233f2: 46bd         	mov	sp, r7
 80233f4: bd80         	pop	{r7, pc}

080233f6 <ll_func_disable_int_tx_empty>:
; {
 80233f6: b580         	push	{r7, lr}
 80233f8: b082         	sub	sp, #0x8
 80233fa: af00         	add	r7, sp, #0x0
 80233fc: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_DisableIT_TXE(spi);
 80233fe: 6878         	ldr	r0, [r7, #0x4]
 8023400: f7ff fd0b    	bl	0x8022e1a <LL_SPI_DisableIT_TXE> @ imm = #-0x5ea
; }
 8023404: bf00         	nop
 8023406: 3708         	adds	r7, #0x8
 8023408: 46bd         	mov	sp, r7
 802340a: bd80         	pop	{r7, pc}

0802340c <ll_func_spi_is_busy>:
; {
 802340c: b580         	push	{r7, lr}
 802340e: b082         	sub	sp, #0x8
 8023410: af00         	add	r7, sp, #0x0
 8023412: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_BSY(spi);
 8023414: 6878         	ldr	r0, [r7, #0x4]
 8023416: f7ff fcc7    	bl	0x8022da8 <LL_SPI_IsActiveFlag_BSY> @ imm = #-0x672
 802341a: 4603         	mov	r3, r0
; }
 802341c: 4618         	mov	r0, r3
 802341e: 3708         	adds	r7, #0x8
 8023420: 46bd         	mov	sp, r7
 8023422: bd80         	pop	{r7, pc}

08023424 <ll_func_disable_spi>:
; {
 8023424: b580         	push	{r7, lr}
 8023426: b082         	sub	sp, #0x8
 8023428: af00         	add	r7, sp, #0x0
 802342a: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_Disable(spi);
 802342c: 6878         	ldr	r0, [r7, #0x4]
 802342e: f7ff fb7a    	bl	0x8022b26 <LL_SPI_Disable> @ imm = #-0x90c
; 	while (LL_SPI_IsEnabled(spi)) {
 8023432: bf00         	nop
 8023434: 6878         	ldr	r0, [r7, #0x4]
 8023436: f7ff fb86    	bl	0x8022b46 <LL_SPI_IsEnabled> @ imm = #-0x8f4
 802343a: 4603         	mov	r3, r0
 802343c: 2b00         	cmp	r3, #0x0
 802343e: d1f9         	bne	0x8023434 <ll_func_disable_spi+0x10> @ imm = #-0xe
; }
 8023440: bf00         	nop
 8023442: bf00         	nop
 8023444: 3708         	adds	r7, #0x8
 8023446: 46bd         	mov	sp, r7
 8023448: bd80         	pop	{r7, pc}

0802344a <spi_stm32_pm_policy_state_lock_get>:
; {
 802344a: b480         	push	{r7}
 802344c: b083         	sub	sp, #0xc
 802344e: af00         	add	r7, sp, #0x0
 8023450: 6078         	str	r0, [r7, #0x4]
; }
 8023452: bf00         	nop
 8023454: 370c         	adds	r7, #0xc
 8023456: 46bd         	mov	sp, r7
 8023458: f85d 7b04    	ldr	r7, [sp], #4
 802345c: 4770         	bx	lr

0802345e <spi_stm32_pm_policy_state_lock_put>:
; {
 802345e: b480         	push	{r7}
 8023460: b083         	sub	sp, #0xc
 8023462: af00         	add	r7, sp, #0x0
 8023464: 6078         	str	r0, [r7, #0x4]
; }
 8023466: bf00         	nop
 8023468: 370c         	adds	r7, #0xc
 802346a: 46bd         	mov	sp, r7
 802346c: f85d 7b04    	ldr	r7, [sp], #4
 8023470: 4770         	bx	lr

08023472 <spi_stm32_transfer_ongoing>:
; {
 8023472: b480         	push	{r7}
 8023474: b085         	sub	sp, #0x14
 8023476: af00         	add	r7, sp, #0x0
 8023478: 6078         	str	r0, [r7, #0x4]
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 802347a: 687b         	ldr	r3, [r7, #0x4]
 802347c: 60fb         	str	r3, [r7, #0xc]
; 	return !!(ctx->tx_len);
 802347e: 68fb         	ldr	r3, [r7, #0xc]
 8023480: 6c9b         	ldr	r3, [r3, #0x48]
 8023482: 2b00         	cmp	r3, #0x0
 8023484: bf14         	ite	ne
 8023486: 2301         	movne	r3, #0x1
 8023488: 2300         	moveq	r3, #0x0
 802348a: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 802348c: 2b00         	cmp	r3, #0x0
 802348e: d10a         	bne	0x80234a6 <spi_stm32_transfer_ongoing+0x34> @ imm = #0x14
 8023490: 687b         	ldr	r3, [r7, #0x4]
 8023492: 60bb         	str	r3, [r7, #0x8]
; 	return !!(ctx->rx_len);
 8023494: 68bb         	ldr	r3, [r7, #0x8]
 8023496: 6d1b         	ldr	r3, [r3, #0x50]
 8023498: 2b00         	cmp	r3, #0x0
 802349a: bf14         	ite	ne
 802349c: 2301         	movne	r3, #0x1
 802349e: 2300         	moveq	r3, #0x0
 80234a0: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 80234a2: 2b00         	cmp	r3, #0x0
 80234a4: d001         	beq	0x80234aa <spi_stm32_transfer_ongoing+0x38> @ imm = #0x2
 80234a6: 2301         	movs	r3, #0x1
 80234a8: e000         	b	0x80234ac <spi_stm32_transfer_ongoing+0x3a> @ imm = #0x0
 80234aa: 2300         	movs	r3, #0x0
 80234ac: f003 0301    	and	r3, r3, #0x1
 80234b0: b2db         	uxtb	r3, r3
; }
 80234b2: 4618         	mov	r0, r3
 80234b4: 3714         	adds	r7, #0x14
 80234b6: 46bd         	mov	sp, r7
 80234b8: f85d 7b04    	ldr	r7, [sp], #4
 80234bc: 4770         	bx	lr

080234be <spi_stm32_shift_fifo>:
; {
 80234be: b580         	push	{r7, lr}
 80234c0: b082         	sub	sp, #0x8
 80234c2: af00         	add	r7, sp, #0x0
 80234c4: 6078         	str	r0, [r7, #0x4]
 80234c6: 6039         	str	r1, [r7]
; 	if (ll_func_rx_is_not_empty(spi)) {
 80234c8: 6878         	ldr	r0, [r7, #0x4]
 80234ca: f7ff ff88    	bl	0x80233de <ll_func_rx_is_not_empty> @ imm = #-0xf0
 80234ce: 4603         	mov	r3, r0
 80234d0: 2b00         	cmp	r3, #0x0
 80234d2: d003         	beq	0x80234dc <spi_stm32_shift_fifo+0x1e> @ imm = #0x6
; 		spi_stm32_read_next_frame(spi, data);
 80234d4: 6839         	ldr	r1, [r7]
 80234d6: 6878         	ldr	r0, [r7, #0x4]
 80234d8: f7ea ff3e    	bl	0x800e358 <spi_stm32_read_next_frame> @ imm = #-0x15184
; 	if (ll_func_tx_is_not_full(spi)) {
 80234dc: 6878         	ldr	r0, [r7, #0x4]
 80234de: f7ff ff72    	bl	0x80233c6 <ll_func_tx_is_not_full> @ imm = #-0x11c
 80234e2: 4603         	mov	r3, r0
 80234e4: 2b00         	cmp	r3, #0x0
 80234e6: d003         	beq	0x80234f0 <spi_stm32_shift_fifo+0x32> @ imm = #0x6
; 		spi_stm32_send_next_frame(spi, data);
 80234e8: 6839         	ldr	r1, [r7]
 80234ea: 6878         	ldr	r0, [r7, #0x4]
 80234ec: f7ea fdc8    	bl	0x800e080 <spi_stm32_send_next_frame> @ imm = #-0x15470
; }
 80234f0: bf00         	nop
 80234f2: 3708         	adds	r7, #0x8
 80234f4: 46bd         	mov	sp, r7
 80234f6: bd80         	pop	{r7, pc}

080234f8 <spi_stm32_shift_m>:
; {
 80234f8: b580         	push	{r7, lr}
 80234fa: b082         	sub	sp, #0x8
 80234fc: af00         	add	r7, sp, #0x0
 80234fe: 6078         	str	r0, [r7, #0x4]
 8023500: 6039         	str	r1, [r7]
; 	if (cfg->fifo_enabled) {
 8023502: 687b         	ldr	r3, [r7, #0x4]
 8023504: 7c1b         	ldrb	r3, [r3, #0x10]
 8023506: 2b00         	cmp	r3, #0x0
 8023508: d006         	beq	0x8023518 <spi_stm32_shift_m+0x20> @ imm = #0xc
; 		spi_stm32_shift_fifo(cfg->spi, data);
 802350a: 687b         	ldr	r3, [r7, #0x4]
 802350c: 681b         	ldr	r3, [r3]
 802350e: 6839         	ldr	r1, [r7]
 8023510: 4618         	mov	r0, r3
 8023512: f7ff ffd4    	bl	0x80234be <spi_stm32_shift_fifo> @ imm = #-0x58
; }
 8023516: e01d         	b	0x8023554 <spi_stm32_shift_m+0x5c> @ imm = #0x3a
; 		while (!ll_func_tx_is_not_full(cfg->spi)) {
 8023518: bf00         	nop
 802351a: 687b         	ldr	r3, [r7, #0x4]
 802351c: 681b         	ldr	r3, [r3]
 802351e: 4618         	mov	r0, r3
 8023520: f7ff ff51    	bl	0x80233c6 <ll_func_tx_is_not_full> @ imm = #-0x15e
 8023524: 4603         	mov	r3, r0
 8023526: 2b00         	cmp	r3, #0x0
 8023528: d0f7         	beq	0x802351a <spi_stm32_shift_m+0x22> @ imm = #-0x12
; 		spi_stm32_send_next_frame(cfg->spi, data);
 802352a: 687b         	ldr	r3, [r7, #0x4]
 802352c: 681b         	ldr	r3, [r3]
 802352e: 6839         	ldr	r1, [r7]
 8023530: 4618         	mov	r0, r3
 8023532: f7ea fda5    	bl	0x800e080 <spi_stm32_send_next_frame> @ imm = #-0x154b6
; 		while (!ll_func_rx_is_not_empty(cfg->spi)) {
 8023536: bf00         	nop
 8023538: 687b         	ldr	r3, [r7, #0x4]
 802353a: 681b         	ldr	r3, [r3]
 802353c: 4618         	mov	r0, r3
 802353e: f7ff ff4e    	bl	0x80233de <ll_func_rx_is_not_empty> @ imm = #-0x164
 8023542: 4603         	mov	r3, r0
 8023544: 2b00         	cmp	r3, #0x0
 8023546: d0f7         	beq	0x8023538 <spi_stm32_shift_m+0x40> @ imm = #-0x12
; 		spi_stm32_read_next_frame(cfg->spi, data);
 8023548: 687b         	ldr	r3, [r7, #0x4]
 802354a: 681b         	ldr	r3, [r3]
 802354c: 6839         	ldr	r1, [r7]
 802354e: 4618         	mov	r0, r3
 8023550: f7ea ff02    	bl	0x800e358 <spi_stm32_read_next_frame> @ imm = #-0x151fc
; }
 8023554: bf00         	nop
 8023556: 3708         	adds	r7, #0x8
 8023558: 46bd         	mov	sp, r7
 802355a: bd80         	pop	{r7, pc}

0802355c <spi_stm32_shift_frames>:
; {
 802355c: b580         	push	{r7, lr}
 802355e: b084         	sub	sp, #0x10
 8023560: af00         	add	r7, sp, #0x0
 8023562: 6078         	str	r0, [r7, #0x4]
 8023564: 6039         	str	r1, [r7]
; 	uint16_t operation = data->ctx.config->operation;
 8023566: 683b         	ldr	r3, [r7]
 8023568: 681b         	ldr	r3, [r3]
 802356a: 889b         	ldrh	r3, [r3, #0x4]
 802356c: 81fb         	strh	r3, [r7, #0xe]
; 	if (SPI_OP_MODE_GET(operation) == SPI_OP_MODE_MASTER) {
 802356e: 89fb         	ldrh	r3, [r7, #0xe]
 8023570: f003 0301    	and	r3, r3, #0x1
 8023574: 2b00         	cmp	r3, #0x0
 8023576: d104         	bne	0x8023582 <spi_stm32_shift_frames+0x26> @ imm = #0x8
; 		spi_stm32_shift_m(cfg, data);
 8023578: 6839         	ldr	r1, [r7]
 802357a: 6878         	ldr	r0, [r7, #0x4]
 802357c: f7ff ffbc    	bl	0x80234f8 <spi_stm32_shift_m> @ imm = #-0x88
 8023580: e005         	b	0x802358e <spi_stm32_shift_frames+0x32> @ imm = #0xa
; 		spi_stm32_shift_s(cfg->spi, data);
 8023582: 687b         	ldr	r3, [r7, #0x4]
 8023584: 681b         	ldr	r3, [r3]
 8023586: 6839         	ldr	r1, [r7]
 8023588: 4618         	mov	r0, r3
 802358a: f7eb f893    	bl	0x800e6b4 <spi_stm32_shift_s> @ imm = #-0x14eda
; 	return spi_stm32_get_err(cfg->spi);
 802358e: 687b         	ldr	r3, [r7, #0x4]
 8023590: 681b         	ldr	r3, [r3]
 8023592: 4618         	mov	r0, r3
 8023594: f7eb f84a    	bl	0x800e62c <spi_stm32_get_err> @ imm = #-0x14f6c
 8023598: 4603         	mov	r3, r0
; }
 802359a: 4618         	mov	r0, r3
 802359c: 3710         	adds	r7, #0x10
 802359e: 46bd         	mov	sp, r7
 80235a0: bd80         	pop	{r7, pc}

080235a2 <spi_stm32_cs_control>:
; {
 80235a2: b580         	push	{r7, lr}
 80235a4: b084         	sub	sp, #0x10
 80235a6: af00         	add	r7, sp, #0x0
 80235a8: 6078         	str	r0, [r7, #0x4]
 80235aa: 460b         	mov	r3, r1
 80235ac: 70fb         	strb	r3, [r7, #0x3]
; 	struct spi_stm32_data *data = dev->data;
 80235ae: 687b         	ldr	r3, [r7, #0x4]
 80235b0: 691b         	ldr	r3, [r3, #0x10]
 80235b2: 60fb         	str	r3, [r7, #0xc]
; 	spi_context_cs_control(&data->ctx, on);
 80235b4: 68fb         	ldr	r3, [r7, #0xc]
 80235b6: 78fa         	ldrb	r2, [r7, #0x3]
 80235b8: 4611         	mov	r1, r2
 80235ba: 4618         	mov	r0, r3
 80235bc: f7ff fea3    	bl	0x8023306 <spi_context_cs_control> @ imm = #-0x2ba
; }
 80235c0: bf00         	nop
 80235c2: 3710         	adds	r7, #0x10
 80235c4: 46bd         	mov	sp, r7
 80235c6: bd80         	pop	{r7, pc}

080235c8 <spi_stm32_complete>:
; {
 80235c8: b580         	push	{r7, lr}
 80235ca: b086         	sub	sp, #0x18
 80235cc: af00         	add	r7, sp, #0x0
 80235ce: 6078         	str	r0, [r7, #0x4]
 80235d0: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 80235d2: 687b         	ldr	r3, [r7, #0x4]
 80235d4: 685b         	ldr	r3, [r3, #0x4]
 80235d6: 617b         	str	r3, [r7, #0x14]
; 	SPI_TypeDef *spi = cfg->spi;
 80235d8: 697b         	ldr	r3, [r7, #0x14]
 80235da: 681b         	ldr	r3, [r3]
 80235dc: 613b         	str	r3, [r7, #0x10]
; 	struct spi_stm32_data *data = dev->data;
 80235de: 687b         	ldr	r3, [r7, #0x4]
 80235e0: 691b         	ldr	r3, [r3, #0x10]
 80235e2: 60fb         	str	r3, [r7, #0xc]
; 	if (LL_SPI_GetMode(spi) == LL_SPI_MODE_MASTER) {
 80235e4: 6938         	ldr	r0, [r7, #0x10]
 80235e6: f7ff fad4    	bl	0x8022b92 <LL_SPI_GetMode> @ imm = #-0xa58
 80235ea: 4603         	mov	r3, r0
 80235ec: f5b3 7f82    	cmp.w	r3, #0x104
 80235f0: d10a         	bne	0x8023608 <spi_stm32_complete+0x40> @ imm = #0x14
; 		while (ll_func_spi_is_busy(spi)) {
 80235f2: bf00         	nop
 80235f4: 6938         	ldr	r0, [r7, #0x10]
 80235f6: f7ff ff09    	bl	0x802340c <ll_func_spi_is_busy> @ imm = #-0x1ee
 80235fa: 4603         	mov	r3, r0
 80235fc: 2b00         	cmp	r3, #0x0
 80235fe: d1f9         	bne	0x80235f4 <spi_stm32_complete+0x2c> @ imm = #-0xe
; 		spi_stm32_cs_control(dev, false);
 8023600: 2100         	movs	r1, #0x0
 8023602: 6878         	ldr	r0, [r7, #0x4]
 8023604: f7ff ffcd    	bl	0x80235a2 <spi_stm32_cs_control> @ imm = #-0x66
; 	if (LL_SPI_IsActiveFlag_MODF(spi)) {
 8023608: 6938         	ldr	r0, [r7, #0x10]
 802360a: f7ff fba7    	bl	0x8022d5c <LL_SPI_IsActiveFlag_MODF> @ imm = #-0x8b2
 802360e: 4603         	mov	r3, r0
 8023610: 2b00         	cmp	r3, #0x0
 8023612: d002         	beq	0x802361a <spi_stm32_complete+0x52> @ imm = #0x4
; 		LL_SPI_ClearFlag_MODF(spi);
 8023614: 6938         	ldr	r0, [r7, #0x10]
 8023616: f7ff fbda    	bl	0x8022dce <LL_SPI_ClearFlag_MODF> @ imm = #-0x84c
; 	if (!(data->ctx.config->operation & SPI_HOLD_ON_CS)) {
 802361a: 68fb         	ldr	r3, [r7, #0xc]
 802361c: 681b         	ldr	r3, [r3]
 802361e: 889b         	ldrh	r3, [r3, #0x4]
 8023620: f403 5380    	and	r3, r3, #0x1000
 8023624: 2b00         	cmp	r3, #0x0
 8023626: d102         	bne	0x802362e <spi_stm32_complete+0x66> @ imm = #0x4
; 		ll_func_disable_spi(spi);
 8023628: 6938         	ldr	r0, [r7, #0x10]
 802362a: f7ff fefb    	bl	0x8023424 <ll_func_disable_spi> @ imm = #-0x20a
; 	spi_stm32_pm_policy_state_lock_put(dev);
 802362e: 6878         	ldr	r0, [r7, #0x4]
 8023630: f7ff ff15    	bl	0x802345e <spi_stm32_pm_policy_state_lock_put> @ imm = #-0x1d6
; }
 8023634: bf00         	nop
 8023636: 3718         	adds	r7, #0x18
 8023638: 46bd         	mov	sp, r7
 802363a: bd80         	pop	{r7, pc}

0802363c <spi_stm32_release>:
; {
 802363c: b580         	push	{r7, lr}
 802363e: b084         	sub	sp, #0x10
 8023640: af00         	add	r7, sp, #0x0
 8023642: 6078         	str	r0, [r7, #0x4]
 8023644: 6039         	str	r1, [r7]
; 	struct spi_stm32_data *data = dev->data;
 8023646: 687b         	ldr	r3, [r7, #0x4]
 8023648: 691b         	ldr	r3, [r3, #0x10]
 802364a: 60fb         	str	r3, [r7, #0xc]
; 	const struct spi_stm32_config *cfg = dev->config;
 802364c: 687b         	ldr	r3, [r7, #0x4]
 802364e: 685b         	ldr	r3, [r3, #0x4]
 8023650: 60bb         	str	r3, [r7, #0x8]
; 	spi_context_unlock_unconditionally(&data->ctx);
 8023652: 68fb         	ldr	r3, [r7, #0xc]
 8023654: 4618         	mov	r0, r3
 8023656: f7ff fe66    	bl	0x8023326 <spi_context_unlock_unconditionally> @ imm = #-0x334
; 	ll_func_disable_spi(cfg->spi);
 802365a: 68bb         	ldr	r3, [r7, #0x8]
 802365c: 681b         	ldr	r3, [r3]
 802365e: 4618         	mov	r0, r3
 8023660: f7ff fee0    	bl	0x8023424 <ll_func_disable_spi> @ imm = #-0x240
; 	return 0;
 8023664: 2300         	movs	r3, #0x0
; }
 8023666: 4618         	mov	r0, r3
 8023668: 3710         	adds	r7, #0x10
 802366a: 46bd         	mov	sp, r7
 802366c: bd80         	pop	{r7, pc}

0802366e <transceive>:
; {
 802366e: b580         	push	{r7, lr}
 8023670: b08a         	sub	sp, #0x28
 8023672: af02         	add	r7, sp, #0x8
 8023674: 60f8         	str	r0, [r7, #0xc]
 8023676: 60b9         	str	r1, [r7, #0x8]
 8023678: 607a         	str	r2, [r7, #0x4]
 802367a: 603b         	str	r3, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 802367c: 68fb         	ldr	r3, [r7, #0xc]
 802367e: 685b         	ldr	r3, [r3, #0x4]
 8023680: 61bb         	str	r3, [r7, #0x18]
; 	struct spi_stm32_data *data = dev->data;
 8023682: 68fb         	ldr	r3, [r7, #0xc]
 8023684: 691b         	ldr	r3, [r3, #0x10]
 8023686: 617b         	str	r3, [r7, #0x14]
; 	SPI_TypeDef *spi = cfg->spi;
 8023688: 69bb         	ldr	r3, [r7, #0x18]
 802368a: 681b         	ldr	r3, [r3]
 802368c: 613b         	str	r3, [r7, #0x10]
; 	if (!tx_bufs && !rx_bufs) {
 802368e: 687b         	ldr	r3, [r7, #0x4]
 8023690: 2b00         	cmp	r3, #0x0
 8023692: d104         	bne	0x802369e <transceive+0x30> @ imm = #0x8
 8023694: 683b         	ldr	r3, [r7]
 8023696: 2b00         	cmp	r3, #0x0
 8023698: d101         	bne	0x802369e <transceive+0x30> @ imm = #0x2
; 		return 0;
 802369a: 2300         	movs	r3, #0x0
 802369c: e04f         	b	0x802373e <transceive+0xd0> @ imm = #0x9e
; 	if (asynchronous) {
 802369e: f897 3028    	ldrb.w	r3, [r7, #0x28]
 80236a2: 2b00         	cmp	r3, #0x0
 80236a4: d002         	beq	0x80236ac <transceive+0x3e> @ imm = #0x4
; 		return -ENOTSUP;
 80236a6: f06f 0385    	mvn	r3, #0x85
 80236aa: e048         	b	0x802373e <transceive+0xd0> @ imm = #0x90
; 	spi_context_lock(&data->ctx, asynchronous, cb, userdata, config);
 80236ac: 6978         	ldr	r0, [r7, #0x14]
 80236ae: f897 1028    	ldrb.w	r1, [r7, #0x28]
 80236b2: 68bb         	ldr	r3, [r7, #0x8]
 80236b4: 9300         	str	r3, [sp]
 80236b6: 6b3b         	ldr	r3, [r7, #0x30]
 80236b8: 6afa         	ldr	r2, [r7, #0x2c]
 80236ba: f7ff fd9c    	bl	0x80231f6 <spi_context_lock> @ imm = #-0x4c8
; 	spi_stm32_pm_policy_state_lock_get(dev);
 80236be: 68f8         	ldr	r0, [r7, #0xc]
 80236c0: f7ff fec3    	bl	0x802344a <spi_stm32_pm_policy_state_lock_get> @ imm = #-0x27a
; 	ret = spi_stm32_configure(dev, config);
 80236c4: 68b9         	ldr	r1, [r7, #0x8]
 80236c6: 68f8         	ldr	r0, [r7, #0xc]
 80236c8: f7eb fab0    	bl	0x800ec2c <spi_stm32_configure> @ imm = #-0x14aa0
 80236cc: 61f8         	str	r0, [r7, #0x1c]
; 	if (ret) {
 80236ce: 69fb         	ldr	r3, [r7, #0x1c]
 80236d0: 2b00         	cmp	r3, #0x0
 80236d2: d12d         	bne	0x8023730 <transceive+0xc2> @ imm = #0x5a
; 	if (SPI_WORD_SIZE_GET(config->operation) == 8) {
 80236d4: 68bb         	ldr	r3, [r7, #0x8]
 80236d6: 889b         	ldrh	r3, [r3, #0x4]
 80236d8: 095b         	lsrs	r3, r3, #0x5
 80236da: f003 033f    	and	r3, r3, #0x3f
 80236de: 2b08         	cmp	r3, #0x8
 80236e0: d106         	bne	0x80236f0 <transceive+0x82> @ imm = #0xc
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 1);
 80236e2: 6978         	ldr	r0, [r7, #0x14]
 80236e4: 2301         	movs	r3, #0x1
 80236e6: 683a         	ldr	r2, [r7]
 80236e8: 6879         	ldr	r1, [r7, #0x4]
 80236ea: f7ea fc0f    	bl	0x800df0c <spi_context_buffers_setup> @ imm = #-0x157e2
 80236ee: e005         	b	0x80236fc <transceive+0x8e> @ imm = #0xa
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 2);
 80236f0: 6978         	ldr	r0, [r7, #0x14]
 80236f2: 2302         	movs	r3, #0x2
 80236f4: 683a         	ldr	r2, [r7]
 80236f6: 6879         	ldr	r1, [r7, #0x4]
 80236f8: f7ea fc08    	bl	0x800df0c <spi_context_buffers_setup> @ imm = #-0x157f0
; 	LL_SPI_Enable(spi);
 80236fc: 6938         	ldr	r0, [r7, #0x10]
 80236fe: f7ff fa02    	bl	0x8022b06 <LL_SPI_Enable> @ imm = #-0xbfc
; 	spi_stm32_cs_control(dev, true);
 8023702: 2101         	movs	r1, #0x1
 8023704: 68f8         	ldr	r0, [r7, #0xc]
 8023706: f7ff ff4c    	bl	0x80235a2 <spi_stm32_cs_control> @ imm = #-0x168
; 		ret = spi_stm32_shift_frames(cfg, data);
 802370a: 6979         	ldr	r1, [r7, #0x14]
 802370c: 69b8         	ldr	r0, [r7, #0x18]
 802370e: f7ff ff25    	bl	0x802355c <spi_stm32_shift_frames> @ imm = #-0x1b6
 8023712: 61f8         	str	r0, [r7, #0x1c]
; 	} while (!ret && spi_stm32_transfer_ongoing(data));
 8023714: 69fb         	ldr	r3, [r7, #0x1c]
 8023716: 2b00         	cmp	r3, #0x0
 8023718: d105         	bne	0x8023726 <transceive+0xb8> @ imm = #0xa
 802371a: 6978         	ldr	r0, [r7, #0x14]
 802371c: f7ff fea9    	bl	0x8023472 <spi_stm32_transfer_ongoing> @ imm = #-0x2ae
 8023720: 4603         	mov	r3, r0
 8023722: 2b00         	cmp	r3, #0x0
 8023724: d1f1         	bne	0x802370a <transceive+0x9c> @ imm = #-0x1e
; 	spi_stm32_complete(dev, ret);
 8023726: 69f9         	ldr	r1, [r7, #0x1c]
 8023728: 68f8         	ldr	r0, [r7, #0xc]
 802372a: f7ff ff4d    	bl	0x80235c8 <spi_stm32_complete> @ imm = #-0x166
 802372e: e000         	b	0x8023732 <transceive+0xc4> @ imm = #0x0
; 		goto end;
 8023730: bf00         	nop
; 	spi_context_release(&data->ctx, ret);
 8023732: 697b         	ldr	r3, [r7, #0x14]
 8023734: 69f9         	ldr	r1, [r7, #0x1c]
 8023736: 4618         	mov	r0, r3
 8023738: f7ff fd89    	bl	0x802324e <spi_context_release> @ imm = #-0x4ee
; 	return ret;
 802373c: 69fb         	ldr	r3, [r7, #0x1c]
; }
 802373e: 4618         	mov	r0, r3
 8023740: 3720         	adds	r7, #0x20
 8023742: 46bd         	mov	sp, r7
 8023744: bd80         	pop	{r7, pc}

08023746 <spi_stm32_transceive>:
; {
 8023746: b580         	push	{r7, lr}
 8023748: b088         	sub	sp, #0x20
 802374a: af04         	add	r7, sp, #0x10
 802374c: 60f8         	str	r0, [r7, #0xc]
 802374e: 60b9         	str	r1, [r7, #0x8]
 8023750: 607a         	str	r2, [r7, #0x4]
 8023752: 603b         	str	r3, [r7]
; 	return transceive(dev, config, tx_bufs, rx_bufs, false, NULL, NULL);
 8023754: 2300         	movs	r3, #0x0
 8023756: 9302         	str	r3, [sp, #0x8]
 8023758: 2300         	movs	r3, #0x0
 802375a: 9301         	str	r3, [sp, #0x4]
 802375c: 2300         	movs	r3, #0x0
 802375e: 9300         	str	r3, [sp]
 8023760: 683b         	ldr	r3, [r7]
 8023762: 687a         	ldr	r2, [r7, #0x4]
 8023764: 68b9         	ldr	r1, [r7, #0x8]
 8023766: 68f8         	ldr	r0, [r7, #0xc]
 8023768: f7ff ff81    	bl	0x802366e <transceive>  @ imm = #-0xfe
 802376c: 4603         	mov	r3, r0
; }
 802376e: 4618         	mov	r0, r3
 8023770: 3710         	adds	r7, #0x10
 8023772: 46bd         	mov	sp, r7
 8023774: bd80         	pop	{r7, pc}

08023776 <spi_stm32_is_subghzspi>:
; {
 8023776: b480         	push	{r7}
 8023778: b083         	sub	sp, #0xc
 802377a: af00         	add	r7, sp, #0x0
 802377c: 6078         	str	r0, [r7, #0x4]
; 	return false;
 802377e: 2300         	movs	r3, #0x0
; }
 8023780: 4618         	mov	r0, r3
 8023782: 370c         	adds	r7, #0xc
 8023784: 46bd         	mov	sp, r7
 8023786: f85d 7b04    	ldr	r7, [sp], #4
 802378a: 4770         	bx	lr

0802378c <device_is_ready>:
; {
 802378c: b580         	push	{r7, lr}
 802378e: b082         	sub	sp, #0x8
 8023790: af00         	add	r7, sp, #0x0
 8023792: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8023794: 6878         	ldr	r0, [r7, #0x4]
 8023796: f000 fec4    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0xd88
 802379a: 4603         	mov	r3, r0
; }
 802379c: 4618         	mov	r0, r3
 802379e: 3708         	adds	r7, #0x8
 80237a0: 46bd         	mov	sp, r7
 80237a2: bd80         	pop	{r7, pc}

080237a4 <pid_reg_input>:
; {
 80237a4: b480         	push	{r7}
 80237a6: b085         	sub	sp, #0x14
 80237a8: af00         	add	r7, sp, #0x0
 80237aa: 60f8         	str	r0, [r7, #0xc]
 80237ac: 60b9         	str	r1, [r7, #0x8]
 80237ae: 607a         	str	r2, [r7, #0x4]
; 	if (data == NULL) {
 80237b0: 68fb         	ldr	r3, [r7, #0xc]
 80237b2: 2b00         	cmp	r3, #0x0
 80237b4: d006         	beq	0x80237c4 <pid_reg_input+0x20> @ imm = #0xc
; 	data->curr = curr;
 80237b6: 68fb         	ldr	r3, [r7, #0xc]
 80237b8: 68ba         	ldr	r2, [r7, #0x8]
 80237ba: 605a         	str	r2, [r3, #0x4]
; 	data->ref = ref;
 80237bc: 68fb         	ldr	r3, [r7, #0xc]
 80237be: 687a         	ldr	r2, [r7, #0x4]
 80237c0: 601a         	str	r2, [r3]
 80237c2: e000         	b	0x80237c6 <pid_reg_input+0x22> @ imm = #0x0
; 		return;
 80237c4: bf00         	nop
; }
 80237c6: 3714         	adds	r7, #0x14
 80237c8: 46bd         	mov	sp, r7
 80237ca: f85d 7b04    	ldr	r7, [sp], #4
 80237ce: 4770         	bx	lr

080237d0 <pid_reg_output>:
; {
 80237d0: b480         	push	{r7}
 80237d2: b083         	sub	sp, #0xc
 80237d4: af00         	add	r7, sp, #0x0
 80237d6: 6078         	str	r0, [r7, #0x4]
 80237d8: 6039         	str	r1, [r7]
; 	if (data == NULL) {
 80237da: 687b         	ldr	r3, [r7, #0x4]
 80237dc: 2b00         	cmp	r3, #0x0
 80237de: d003         	beq	0x80237e8 <pid_reg_output+0x18> @ imm = #0x6
; 	data->output = output;
 80237e0: 687b         	ldr	r3, [r7, #0x4]
 80237e2: 683a         	ldr	r2, [r7]
 80237e4: 629a         	str	r2, [r3, #0x28]
 80237e6: e000         	b	0x80237ea <pid_reg_output+0x1a> @ imm = #0x0
; 		return;
 80237e8: bf00         	nop
; }
 80237ea: 370c         	adds	r7, #0xc
 80237ec: 46bd         	mov	sp, r7
 80237ee: f85d 7b04    	ldr	r7, [sp], #4
 80237f2: 4770         	bx	lr

080237f4 <pid_reg_time>:
; {
 80237f4: b480         	push	{r7}
 80237f6: b085         	sub	sp, #0x14
 80237f8: af00         	add	r7, sp, #0x0
 80237fa: 60f8         	str	r0, [r7, #0xc]
 80237fc: 60b9         	str	r1, [r7, #0x8]
 80237fe: 607a         	str	r2, [r7, #0x4]
; 	if (data == NULL) {
 8023800: 68fb         	ldr	r3, [r7, #0xc]
 8023802: 2b00         	cmp	r3, #0x0
 8023804: d006         	beq	0x8023814 <pid_reg_time+0x20> @ imm = #0xc
; 	data->curr_time = curr_cyc;
 8023806: 68fb         	ldr	r3, [r7, #0xc]
 8023808: 68ba         	ldr	r2, [r7, #0x8]
 802380a: 621a         	str	r2, [r3, #0x20]
; 	data->prev_time = prev_cyc;
 802380c: 68fb         	ldr	r3, [r7, #0xc]
 802380e: 687a         	ldr	r2, [r7, #0x4]
 8023810: 625a         	str	r2, [r3, #0x24]
 8023812: e000         	b	0x8023816 <pid_reg_time+0x22> @ imm = #0x0
; 		return;
 8023814: bf00         	nop
; }
 8023816: 3714         	adds	r7, #0x14
 8023818: 46bd         	mov	sp, r7
 802381a: f85d 7b04    	ldr	r7, [sp], #4
 802381e: 4770         	bx	lr

08023820 <arch_k_cycle_get_32>:
; {
 8023820: b580         	push	{r7, lr}
 8023822: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 8023824: f7eb fe44    	bl	0x800f4b0 <sys_clock_cycle_get_32> @ imm = #-0x14378
 8023828: 4603         	mov	r3, r0
; }
 802382a: 4618         	mov	r0, r3
 802382c: bd80         	pop	{r7, pc}

0802382e <k_cycle_get_32>:
; {
 802382e: b580         	push	{r7, lr}
 8023830: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 8023832: f7ff fff5    	bl	0x8023820 <arch_k_cycle_get_32> @ imm = #-0x16
 8023836: 4603         	mov	r3, r0
; }
 8023838: 4618         	mov	r0, r3
 802383a: bd80         	pop	{r7, pc}

0802383c <k_work_is_pending>:
; {
 802383c: b580         	push	{r7, lr}
 802383e: b082         	sub	sp, #0x8
 8023840: af00         	add	r7, sp, #0x0
 8023842: 6078         	str	r0, [r7, #0x4]
; 	return k_work_busy_get(work) != 0;
 8023844: 6878         	ldr	r0, [r7, #0x4]
 8023846: f7f0 fd7d    	bl	0x8014344 <k_work_busy_get> @ imm = #-0xf506
 802384a: 4603         	mov	r3, r0
 802384c: 2b00         	cmp	r3, #0x0
 802384e: bf14         	ite	ne
 8023850: 2301         	movne	r3, #0x1
 8023852: 2300         	moveq	r3, #0x0
 8023854: b2db         	uxtb	r3, r3
; }
 8023856: 4618         	mov	r0, r3
 8023858: 3708         	adds	r7, #0x8
 802385a: 46bd         	mov	sp, r7
 802385c: bd80         	pop	{r7, pc}

0802385e <k_timer_start>:
; {
 802385e: b580         	push	{r7, lr}
 8023860: b086         	sub	sp, #0x18
 8023862: af02         	add	r7, sp, #0x8
 8023864: 60f8         	str	r0, [r7, #0xc]
 8023866: e9c7 2300    	strd	r2, r3, [r7]
; 	z_impl_k_timer_start(timer, duration, period);
 802386a: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 802386e: e9cd 2300    	strd	r2, r3, [sp]
 8023872: e9d7 2300    	ldrd	r2, r3, [r7]
 8023876: 68f8         	ldr	r0, [r7, #0xc]
 8023878: f7f3 fda4    	bl	0x80173c4 <z_impl_k_timer_start> @ imm = #-0xc4b8
; }
 802387c: bf00         	nop
 802387e: 3710         	adds	r7, #0x10
 8023880: 46bd         	mov	sp, r7
 8023882: bd80         	pop	{r7, pc}

08023884 <k_timer_stop>:
; {
 8023884: b580         	push	{r7, lr}
 8023886: b082         	sub	sp, #0x8
 8023888: af00         	add	r7, sp, #0x0
 802388a: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_timer_stop(timer);
 802388c: 6878         	ldr	r0, [r7, #0x4]
 802388e: f003 fd29    	bl	0x80272e4 <z_impl_k_timer_stop> @ imm = #0x3a52
; }
 8023892: bf00         	nop
 8023894: 3708         	adds	r7, #0x8
 8023896: 46bd         	mov	sp, r7
 8023898: bd80         	pop	{r7, pc}

0802389a <k_sem_init>:
; {
 802389a: b580         	push	{r7, lr}
 802389c: b084         	sub	sp, #0x10
 802389e: af00         	add	r7, sp, #0x0
 80238a0: 60f8         	str	r0, [r7, #0xc]
 80238a2: 60b9         	str	r1, [r7, #0x8]
 80238a4: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 80238a6: 687a         	ldr	r2, [r7, #0x4]
 80238a8: 68b9         	ldr	r1, [r7, #0x8]
 80238aa: 68f8         	ldr	r0, [r7, #0xc]
 80238ac: f001 fff7    	bl	0x802589e <z_impl_k_sem_init> @ imm = #0x1fee
 80238b0: 4603         	mov	r3, r0
; }
 80238b2: 4618         	mov	r0, r3
 80238b4: 3710         	adds	r7, #0x10
 80238b6: 46bd         	mov	sp, r7
 80238b8: bd80         	pop	{r7, pc}

080238ba <k_sem_take>:
; {
 80238ba: b580         	push	{r7, lr}
 80238bc: b084         	sub	sp, #0x10
 80238be: af00         	add	r7, sp, #0x0
 80238c0: 60f8         	str	r0, [r7, #0xc]
 80238c2: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 80238c6: e9d7 2300    	ldrd	r2, r3, [r7]
 80238ca: 68f8         	ldr	r0, [r7, #0xc]
 80238cc: f7f0 fc46    	bl	0x801415c <z_impl_k_sem_take> @ imm = #-0xf774
 80238d0: 4603         	mov	r3, r0
; }
 80238d2: 4618         	mov	r0, r3
 80238d4: 3710         	adds	r7, #0x10
 80238d6: 46bd         	mov	sp, r7
 80238d8: bd80         	pop	{r7, pc}

080238da <k_sem_give>:
; {
 80238da: b580         	push	{r7, lr}
 80238dc: b082         	sub	sp, #0x8
 80238de: af00         	add	r7, sp, #0x0
 80238e0: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 80238e2: 6878         	ldr	r0, [r7, #0x4]
 80238e4: f7f0 fbac    	bl	0x8014040 <z_impl_k_sem_give> @ imm = #-0xf8a8
; }
 80238e8: bf00         	nop
 80238ea: 3708         	adds	r7, #0x8
 80238ec: 46bd         	mov	sp, r7
 80238ee: bd80         	pop	{r7, pc}

080238f0 <z_log_msg_runtime_create>:
; {
 80238f0: b580         	push	{r7, lr}
 80238f2: b08a         	sub	sp, #0x28
 80238f4: af04         	add	r7, sp, #0x10
 80238f6: 60b9         	str	r1, [r7, #0x8]
 80238f8: 607b         	str	r3, [r7, #0x4]
 80238fa: 4603         	mov	r3, r0
 80238fc: 73fb         	strb	r3, [r7, #0xf]
 80238fe: 4613         	mov	r3, r2
 8023900: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8023902: f107 032c    	add.w	r3, r7, #0x2c
 8023906: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8023908: 7bba         	ldrb	r2, [r7, #0xe]
 802390a: 7bf8         	ldrb	r0, [r7, #0xf]
 802390c: 697b         	ldr	r3, [r7, #0x14]
 802390e: 9303         	str	r3, [sp, #0xc]
 8023910: 6abb         	ldr	r3, [r7, #0x28]
 8023912: 9302         	str	r3, [sp, #0x8]
 8023914: 6a7b         	ldr	r3, [r7, #0x24]
 8023916: 9301         	str	r3, [sp, #0x4]
 8023918: 6a3b         	ldr	r3, [r7, #0x20]
 802391a: 9300         	str	r3, [sp]
 802391c: 687b         	ldr	r3, [r7, #0x4]
 802391e: 68b9         	ldr	r1, [r7, #0x8]
 8023920: f7e1 f910    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x1ede0
; }
 8023924: bf00         	nop
 8023926: 3718         	adds	r7, #0x18
 8023928: 46bd         	mov	sp, r7
 802392a: bd80         	pop	{r7, pc}

0802392c <z_impl_can_start>:
; {
 802392c: b580         	push	{r7, lr}
 802392e: b084         	sub	sp, #0x10
 8023930: af00         	add	r7, sp, #0x0
 8023932: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8023934: 687b         	ldr	r3, [r7, #0x4]
 8023936: 689b         	ldr	r3, [r3, #0x8]
 8023938: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev);
 802393a: 68fb         	ldr	r3, [r7, #0xc]
 802393c: 685b         	ldr	r3, [r3, #0x4]
 802393e: 6878         	ldr	r0, [r7, #0x4]
 8023940: 4798         	blx	r3
 8023942: 4603         	mov	r3, r0
; }
 8023944: 4618         	mov	r0, r3
 8023946: 3710         	adds	r7, #0x10
 8023948: 46bd         	mov	sp, r7
 802394a: bd80         	pop	{r7, pc}

0802394c <can_start>:
; {
 802394c: b580         	push	{r7, lr}
 802394e: b082         	sub	sp, #0x8
 8023950: af00         	add	r7, sp, #0x0
 8023952: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_start(dev);
 8023954: 6878         	ldr	r0, [r7, #0x4]
 8023956: f7ff ffe9    	bl	0x802392c <z_impl_can_start> @ imm = #-0x2e
 802395a: 4603         	mov	r3, r0
; }
 802395c: 4618         	mov	r0, r3
 802395e: 3708         	adds	r7, #0x8
 8023960: 46bd         	mov	sp, r7
 8023962: bd80         	pop	{r7, pc}

08023964 <can_send>:
; {
 8023964: b580         	push	{r7, lr}
 8023966: b086         	sub	sp, #0x18
 8023968: af02         	add	r7, sp, #0x8
 802396a: 60f8         	str	r0, [r7, #0xc]
 802396c: 60b9         	str	r1, [r7, #0x8]
 802396e: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_can_send(dev, frame, timeout, callback, user_data);
 8023972: 69fb         	ldr	r3, [r7, #0x1c]
 8023974: 9301         	str	r3, [sp, #0x4]
 8023976: 69bb         	ldr	r3, [r7, #0x18]
 8023978: 9300         	str	r3, [sp]
 802397a: e9d7 2300    	ldrd	r2, r3, [r7]
 802397e: 68b9         	ldr	r1, [r7, #0x8]
 8023980: 68f8         	ldr	r0, [r7, #0xc]
 8023982: f7e3 fe77    	bl	0x8007674 <z_impl_can_send> @ imm = #-0x1c312
 8023986: 4603         	mov	r3, r0
; }
 8023988: 4618         	mov	r0, r3
 802398a: 3710         	adds	r7, #0x10
 802398c: 46bd         	mov	sp, r7
 802398e: bd80         	pop	{r7, pc}

08023990 <frames_id>:
; {
 8023990: b480         	push	{r7}
 8023992: b083         	sub	sp, #0xc
 8023994: af00         	add	r7, sp, #0x0
 8023996: 6078         	str	r0, [r7, #0x4]
; 	if (tx_id == 0x200) {
 8023998: 687b         	ldr	r3, [r7, #0x4]
 802399a: f5b3 7f00    	cmp.w	r3, #0x200
 802399e: d101         	bne	0x80239a4 <frames_id+0x14> @ imm = #0x2
; 		return 0;
 80239a0: 2300         	movs	r3, #0x0
 80239a2: e01c         	b	0x80239de <frames_id+0x4e> @ imm = #0x38
; 	} else if (tx_id == 0x1FF) {
 80239a4: 687b         	ldr	r3, [r7, #0x4]
 80239a6: f240 12ff    	movw	r2, #0x1ff
 80239aa: 4293         	cmp	r3, r2
 80239ac: d101         	bne	0x80239b2 <frames_id+0x22> @ imm = #0x2
; 		return 1;
 80239ae: 2301         	movs	r3, #0x1
 80239b0: e015         	b	0x80239de <frames_id+0x4e> @ imm = #0x2a
; 	} else if (tx_id == 0x1FE) {
 80239b2: 687b         	ldr	r3, [r7, #0x4]
 80239b4: f5b3 7fff    	cmp.w	r3, #0x1fe
 80239b8: d101         	bne	0x80239be <frames_id+0x2e> @ imm = #0x2
; 		return 2;
 80239ba: 2302         	movs	r3, #0x2
 80239bc: e00f         	b	0x80239de <frames_id+0x4e> @ imm = #0x1e
; 	} else if (tx_id == 0x2FE) {
 80239be: 687b         	ldr	r3, [r7, #0x4]
 80239c0: f240 22fe    	movw	r2, #0x2fe
 80239c4: 4293         	cmp	r3, r2
 80239c6: d101         	bne	0x80239cc <frames_id+0x3c> @ imm = #0x2
; 		return 3;
 80239c8: 2303         	movs	r3, #0x3
 80239ca: e008         	b	0x80239de <frames_id+0x4e> @ imm = #0x10
; 	} else if (tx_id == 0x2FF) {
 80239cc: 687b         	ldr	r3, [r7, #0x4]
 80239ce: f240 22ff    	movw	r2, #0x2ff
 80239d2: 4293         	cmp	r3, r2
 80239d4: d101         	bne	0x80239da <frames_id+0x4a> @ imm = #0x2
; 		return 4;
 80239d6: 2304         	movs	r3, #0x4
 80239d8: e001         	b	0x80239de <frames_id+0x4e> @ imm = #0x2
; 	return -1; // Return a default value if no match is found
 80239da: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 80239de: 4618         	mov	r0, r3
 80239e0: 370c         	adds	r7, #0xc
 80239e2: 46bd         	mov	sp, r7
 80239e4: f85d 7b04    	ldr	r7, [sp], #4
 80239e8: 4770         	bx	lr

080239ea <txframe_id>:
; {
 80239ea: b480         	push	{r7}
 80239ec: b083         	sub	sp, #0xc
 80239ee: af00         	add	r7, sp, #0x0
 80239f0: 6078         	str	r0, [r7, #0x4]
; 	if (frames_id == 0) {
 80239f2: 687b         	ldr	r3, [r7, #0x4]
 80239f4: 2b00         	cmp	r3, #0x0
 80239f6: d102         	bne	0x80239fe <txframe_id+0x14> @ imm = #0x4
; 		return 0x200;
 80239f8: f44f 7300    	mov.w	r3, #0x200
 80239fc: e019         	b	0x8023a32 <txframe_id+0x48> @ imm = #0x32
; 	} else if (frames_id == 1) {
 80239fe: 687b         	ldr	r3, [r7, #0x4]
 8023a00: 2b01         	cmp	r3, #0x1
 8023a02: d102         	bne	0x8023a0a <txframe_id+0x20> @ imm = #0x4
; 		return 0x1FF;
 8023a04: f240 13ff    	movw	r3, #0x1ff
 8023a08: e013         	b	0x8023a32 <txframe_id+0x48> @ imm = #0x26
; 	} else if (frames_id == 2) {
 8023a0a: 687b         	ldr	r3, [r7, #0x4]
 8023a0c: 2b02         	cmp	r3, #0x2
 8023a0e: d102         	bne	0x8023a16 <txframe_id+0x2c> @ imm = #0x4
; 		return 0x1FE;
 8023a10: f44f 73ff    	mov.w	r3, #0x1fe
 8023a14: e00d         	b	0x8023a32 <txframe_id+0x48> @ imm = #0x1a
; 	} else if (frames_id == 3) {
 8023a16: 687b         	ldr	r3, [r7, #0x4]
 8023a18: 2b03         	cmp	r3, #0x3
 8023a1a: d102         	bne	0x8023a22 <txframe_id+0x38> @ imm = #0x4
; 		return 0x2FE;
 8023a1c: f240 23fe    	movw	r3, #0x2fe
 8023a20: e007         	b	0x8023a32 <txframe_id+0x48> @ imm = #0xe
; 	} else if (frames_id == 4) {
 8023a22: 687b         	ldr	r3, [r7, #0x4]
 8023a24: 2b04         	cmp	r3, #0x4
 8023a26: d102         	bne	0x8023a2e <txframe_id+0x44> @ imm = #0x4
; 		return 0x2FF;
 8023a28: f240 23ff    	movw	r3, #0x2ff
 8023a2c: e001         	b	0x8023a32 <txframe_id+0x48> @ imm = #0x2
; 	return -1;
 8023a2e: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 8023a32: 4618         	mov	r0, r3
 8023a34: 370c         	adds	r7, #0xc
 8023a36: 46bd         	mov	sp, r7
 8023a38: f85d 7b04    	ldr	r7, [sp], #4
 8023a3c: 4770         	bx	lr

08023a3e <motor_id>:
; {
 8023a3e: b480         	push	{r7}
 8023a40: b085         	sub	sp, #0x14
 8023a42: af00         	add	r7, sp, #0x0
 8023a44: 6078         	str	r0, [r7, #0x4]
; 	const struct dji_motor_config *cfg = dev->config;
 8023a46: 687b         	ldr	r3, [r7, #0x4]
 8023a48: 685b         	ldr	r3, [r3, #0x4]
 8023a4a: 60fb         	str	r3, [r7, #0xc]
; 	return cfg->common.id - 1;
 8023a4c: 68fb         	ldr	r3, [r7, #0xc]
 8023a4e: 791b         	ldrb	r3, [r3, #0x4]
 8023a50: 3b01         	subs	r3, #0x1
 8023a52: b29b         	uxth	r3, r3
; }
 8023a54: 4618         	mov	r0, r3
 8023a56: 3714         	adds	r7, #0x14
 8023a58: 46bd         	mov	sp, r7
 8023a5a: f85d 7b04    	ldr	r7, [sp], #4
 8023a5e: 4770         	bx	lr

08023a60 <dji_speed_limit>:
; {
 8023a60: b480         	push	{r7}
 8023a62: b087         	sub	sp, #0x1c
 8023a64: af00         	add	r7, sp, #0x0
 8023a66: 60f8         	str	r0, [r7, #0xc]
 8023a68: ed87 0a02    	vstr	s0, [r7, #8]
 8023a6c: edc7 0a01    	vstr	s1, [r7, #4]
; 	struct dji_motor_data *data = dev->data;
 8023a70: 68fb         	ldr	r3, [r7, #0xc]
 8023a72: 691b         	ldr	r3, [r3, #0x10]
 8023a74: 617b         	str	r3, [r7, #0x14]
; 	data->common.speed_limit[0] = min_speed;
 8023a76: 697b         	ldr	r3, [r7, #0x14]
 8023a78: 687a         	ldr	r2, [r7, #0x4]
 8023a7a: 615a         	str	r2, [r3, #0x14]
; 	data->common.speed_limit[1] = max_speed;
 8023a7c: 697b         	ldr	r3, [r7, #0x14]
 8023a7e: 68ba         	ldr	r2, [r7, #0x8]
 8023a80: 619a         	str	r2, [r3, #0x18]
; }
 8023a82: bf00         	nop
 8023a84: 371c         	adds	r7, #0x1c
 8023a86: 46bd         	mov	sp, r7
 8023a88: f85d 7b04    	ldr	r7, [sp], #4
 8023a8c: 4770         	bx	lr

08023a8e <dji_torque_limit>:
; {
 8023a8e: b480         	push	{r7}
 8023a90: b087         	sub	sp, #0x1c
 8023a92: af00         	add	r7, sp, #0x0
 8023a94: 60f8         	str	r0, [r7, #0xc]
 8023a96: ed87 0a02    	vstr	s0, [r7, #8]
 8023a9a: edc7 0a01    	vstr	s1, [r7, #4]
; 	struct dji_motor_data *data = dev->data;
 8023a9e: 68fb         	ldr	r3, [r7, #0xc]
 8023aa0: 691b         	ldr	r3, [r3, #0x10]
 8023aa2: 617b         	str	r3, [r7, #0x14]
; 	data->common.torque_limit[0] = min_torque;
 8023aa4: 697b         	ldr	r3, [r7, #0x14]
 8023aa6: 687a         	ldr	r2, [r7, #0x4]
 8023aa8: 61da         	str	r2, [r3, #0x1c]
; 	data->common.torque_limit[1] = max_torque;
 8023aaa: 697b         	ldr	r3, [r7, #0x14]
 8023aac: 68ba         	ldr	r2, [r7, #0x8]
 8023aae: 621a         	str	r2, [r3, #0x20]
; }
 8023ab0: bf00         	nop
 8023ab2: 371c         	adds	r7, #0x1c
 8023ab4: 46bd         	mov	sp, r7
 8023ab6: f85d 7b04    	ldr	r7, [sp], #4
 8023aba: 4770         	bx	lr

08023abc <dji_get_speed>:
; {
 8023abc: b480         	push	{r7}
 8023abe: b085         	sub	sp, #0x14
 8023ac0: af00         	add	r7, sp, #0x0
 8023ac2: 6078         	str	r0, [r7, #0x4]
; 	struct dji_motor_data *data = dev->data;
 8023ac4: 687b         	ldr	r3, [r7, #0x4]
 8023ac6: 691b         	ldr	r3, [r3, #0x10]
 8023ac8: 60fb         	str	r3, [r7, #0xc]
; 	return data->common.rpm;
 8023aca: 68fb         	ldr	r3, [r7, #0xc]
 8023acc: 685b         	ldr	r3, [r3, #0x4]
 8023ace: ee07 3a90    	vmov	s15, r3
; }
 8023ad2: eeb0 0a67    	vmov.f32	s0, s15
 8023ad6: 3714         	adds	r7, #0x14
 8023ad8: 46bd         	mov	sp, r7
 8023ada: f85d 7b04    	ldr	r7, [sp], #4
 8023ade: 4770         	bx	lr

08023ae0 <dji_get_torque>:
; {
 8023ae0: b480         	push	{r7}
 8023ae2: b085         	sub	sp, #0x14
 8023ae4: af00         	add	r7, sp, #0x0
 8023ae6: 6078         	str	r0, [r7, #0x4]
; 	struct dji_motor_data *data = dev->data;
 8023ae8: 687b         	ldr	r3, [r7, #0x4]
 8023aea: 691b         	ldr	r3, [r3, #0x10]
 8023aec: 60fb         	str	r3, [r7, #0xc]
; 	return data->common.torque;
 8023aee: 68fb         	ldr	r3, [r7, #0xc]
 8023af0: 689b         	ldr	r3, [r3, #0x8]
 8023af2: ee07 3a90    	vmov	s15, r3
; }
 8023af6: eeb0 0a67    	vmov.f32	s0, s15
 8023afa: 3714         	adds	r7, #0x14
 8023afc: 46bd         	mov	sp, r7
 8023afe: f85d 7b04    	ldr	r7, [sp], #4
 8023b02: 4770         	bx	lr

08023b04 <can_tx_callback>:
; {
 8023b04: b580         	push	{r7, lr}
 8023b06: b086         	sub	sp, #0x18
 8023b08: af00         	add	r7, sp, #0x0
 8023b0a: 60f8         	str	r0, [r7, #0xc]
 8023b0c: 60b9         	str	r1, [r7, #0x8]
 8023b0e: 607a         	str	r2, [r7, #0x4]
; 	struct k_sem *queue_sem = user_data;
 8023b10: 687b         	ldr	r3, [r7, #0x4]
 8023b12: 617b         	str	r3, [r7, #0x14]
; 	if (!error) {
 8023b14: 68bb         	ldr	r3, [r7, #0x8]
 8023b16: 2b00         	cmp	r3, #0x0
 8023b18: d102         	bne	0x8023b20 <can_tx_callback+0x1c> @ imm = #0x4
; 		k_sem_give(queue_sem);
 8023b1a: 6978         	ldr	r0, [r7, #0x14]
 8023b1c: f7ff fedd    	bl	0x80238da <k_sem_give>  @ imm = #-0x246
; }
 8023b20: bf00         	nop
 8023b22: 3718         	adds	r7, #0x18
 8023b24: 46bd         	mov	sp, r7
 8023b26: bd80         	pop	{r7, pc}

08023b28 <can_pack_add>:
; {
 8023b28: b580         	push	{r7, lr}
 8023b2a: b086         	sub	sp, #0x18
 8023b2c: af00         	add	r7, sp, #0x0
 8023b2e: 60f8         	str	r0, [r7, #0xc]
 8023b30: 60b9         	str	r1, [r7, #0x8]
 8023b32: 4613         	mov	r3, r2
 8023b34: 71fb         	strb	r3, [r7, #0x7]
; 	struct dji_motor_data *data_temp = motor_dev->data;
 8023b36: 68bb         	ldr	r3, [r7, #0x8]
 8023b38: 691b         	ldr	r3, [r3, #0x10]
 8023b3a: 617b         	str	r3, [r7, #0x14]
; 	int16_t value = to16t(data_temp->target_current);
 8023b3c: 697b         	ldr	r3, [r7, #0x14]
 8023b3e: edd3 7a1b    	vldr	s15, [r3, #108]
 8023b42: eeb0 0a67    	vmov.f32	s0, s15
 8023b46: f7eb feb9    	bl	0x800f8bc <to16t>       @ imm = #-0x1428e
 8023b4a: 4603         	mov	r3, r0
 8023b4c: 827b         	strh	r3, [r7, #0x12]
; 	data[num * 2] = HIGH_BYTE(value);
 8023b4e: f9b7 3012    	ldrsh.w	r3, [r7, #0x12]
 8023b52: 121b         	asrs	r3, r3, #0x8
 8023b54: b21a         	sxth	r2, r3
 8023b56: 79fb         	ldrb	r3, [r7, #0x7]
 8023b58: 005b         	lsls	r3, r3, #0x1
 8023b5a: 4619         	mov	r1, r3
 8023b5c: 68fb         	ldr	r3, [r7, #0xc]
 8023b5e: 440b         	add	r3, r1
 8023b60: b2d2         	uxtb	r2, r2
 8023b62: 701a         	strb	r2, [r3]
; 	data[num * 2 + 1] = LOW_BYTE(value);
 8023b64: 79fb         	ldrb	r3, [r7, #0x7]
 8023b66: 005b         	lsls	r3, r3, #0x1
 8023b68: 3301         	adds	r3, #0x1
 8023b6a: 68fa         	ldr	r2, [r7, #0xc]
 8023b6c: 4413         	add	r3, r2
 8023b6e: 8a7a         	ldrh	r2, [r7, #0x12]
 8023b70: b2d2         	uxtb	r2, r2
 8023b72: 701a         	strb	r2, [r3]
; }
 8023b74: bf00         	nop
 8023b76: 3718         	adds	r7, #0x18
 8023b78: 46bd         	mov	sp, r7
 8023b7a: bd80         	pop	{r7, pc}

08023b7c <device_is_ready>:
; {
 8023b7c: b580         	push	{r7, lr}
 8023b7e: b082         	sub	sp, #0x8
 8023b80: af00         	add	r7, sp, #0x0
 8023b82: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8023b84: 6878         	ldr	r0, [r7, #0x4]
 8023b86: f000 fccc    	bl	0x8024522 <z_impl_device_is_ready> @ imm = #0x998
 8023b8a: 4603         	mov	r3, r0
; }
 8023b8c: 4618         	mov	r0, r3
 8023b8e: 3708         	adds	r7, #0x8
 8023b90: 46bd         	mov	sp, r7
 8023b92: bd80         	pop	{r7, pc}

08023b94 <z_impl_uart_configure>:
; {
 8023b94: b580         	push	{r7, lr}
 8023b96: b084         	sub	sp, #0x10
 8023b98: af00         	add	r7, sp, #0x0
 8023b9a: 6078         	str	r0, [r7, #0x4]
 8023b9c: 6039         	str	r1, [r7]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8023b9e: 687b         	ldr	r3, [r7, #0x4]
 8023ba0: 689b         	ldr	r3, [r3, #0x8]
 8023ba2: 60fb         	str	r3, [r7, #0xc]
; 	if (api->configure == NULL) {
 8023ba4: 68fb         	ldr	r3, [r7, #0xc]
 8023ba6: 6a5b         	ldr	r3, [r3, #0x24]
 8023ba8: 2b00         	cmp	r3, #0x0
 8023baa: d102         	bne	0x8023bb2 <z_impl_uart_configure+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 8023bac: f06f 0357    	mvn	r3, #0x57
 8023bb0: e005         	b	0x8023bbe <z_impl_uart_configure+0x2a> @ imm = #0xa
; 	return api->configure(dev, cfg);
 8023bb2: 68fb         	ldr	r3, [r7, #0xc]
 8023bb4: 6a5b         	ldr	r3, [r3, #0x24]
 8023bb6: 6839         	ldr	r1, [r7]
 8023bb8: 6878         	ldr	r0, [r7, #0x4]
 8023bba: 4798         	blx	r3
 8023bbc: 4603         	mov	r3, r0
; }
 8023bbe: 4618         	mov	r0, r3
 8023bc0: 3710         	adds	r7, #0x10
 8023bc2: 46bd         	mov	sp, r7
 8023bc4: bd80         	pop	{r7, pc}

08023bc6 <uart_callback_set>:
; {
 8023bc6: b580         	push	{r7, lr}
 8023bc8: b086         	sub	sp, #0x18
 8023bca: af00         	add	r7, sp, #0x0
 8023bcc: 60f8         	str	r0, [r7, #0xc]
 8023bce: 60b9         	str	r1, [r7, #0x8]
 8023bd0: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8023bd2: 68fb         	ldr	r3, [r7, #0xc]
 8023bd4: 689b         	ldr	r3, [r3, #0x8]
 8023bd6: 617b         	str	r3, [r7, #0x14]
; 	if (api->callback_set == NULL) {
 8023bd8: 697b         	ldr	r3, [r7, #0x14]
 8023bda: 681b         	ldr	r3, [r3]
 8023bdc: 2b00         	cmp	r3, #0x0
 8023bde: d102         	bne	0x8023be6 <uart_callback_set+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8023be0: f06f 0357    	mvn	r3, #0x57
 8023be4: e006         	b	0x8023bf4 <uart_callback_set+0x2e> @ imm = #0xc
; 	return api->callback_set(dev, callback, user_data);
 8023be6: 697b         	ldr	r3, [r7, #0x14]
 8023be8: 681b         	ldr	r3, [r3]
 8023bea: 687a         	ldr	r2, [r7, #0x4]
 8023bec: 68b9         	ldr	r1, [r7, #0x8]
 8023bee: 68f8         	ldr	r0, [r7, #0xc]
 8023bf0: 4798         	blx	r3
 8023bf2: 4603         	mov	r3, r0
; }
 8023bf4: 4618         	mov	r0, r3
 8023bf6: 3718         	adds	r7, #0x18
 8023bf8: 46bd         	mov	sp, r7
 8023bfa: bd80         	pop	{r7, pc}

08023bfc <z_impl_uart_rx_enable>:
; {
 8023bfc: b590         	push	{r4, r7, lr}
 8023bfe: b087         	sub	sp, #0x1c
 8023c00: af00         	add	r7, sp, #0x0
 8023c02: 60f8         	str	r0, [r7, #0xc]
 8023c04: 60b9         	str	r1, [r7, #0x8]
 8023c06: 607a         	str	r2, [r7, #0x4]
 8023c08: 603b         	str	r3, [r7]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8023c0a: 68fb         	ldr	r3, [r7, #0xc]
 8023c0c: 689b         	ldr	r3, [r3, #0x8]
 8023c0e: 617b         	str	r3, [r7, #0x14]
; 	return api->rx_enable(dev, buf, len, timeout);
 8023c10: 697b         	ldr	r3, [r7, #0x14]
 8023c12: 68dc         	ldr	r4, [r3, #0xc]
 8023c14: 683b         	ldr	r3, [r7]
 8023c16: 687a         	ldr	r2, [r7, #0x4]
 8023c18: 68b9         	ldr	r1, [r7, #0x8]
 8023c1a: 68f8         	ldr	r0, [r7, #0xc]
 8023c1c: 47a0         	blx	r4
 8023c1e: 4603         	mov	r3, r0
; }
 8023c20: 4618         	mov	r0, r3
 8023c22: 371c         	adds	r7, #0x1c
 8023c24: 46bd         	mov	sp, r7
 8023c26: bd90         	pop	{r4, r7, pc}

08023c28 <uart_rx_buf_rsp>:
; {
 8023c28: b580         	push	{r7, lr}
 8023c2a: b086         	sub	sp, #0x18
 8023c2c: af00         	add	r7, sp, #0x0
 8023c2e: 60f8         	str	r0, [r7, #0xc]
 8023c30: 60b9         	str	r1, [r7, #0x8]
 8023c32: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8023c34: 68fb         	ldr	r3, [r7, #0xc]
 8023c36: 689b         	ldr	r3, [r3, #0x8]
 8023c38: 617b         	str	r3, [r7, #0x14]
; 	return api->rx_buf_rsp(dev, buf, len);
 8023c3a: 697b         	ldr	r3, [r7, #0x14]
 8023c3c: 691b         	ldr	r3, [r3, #0x10]
 8023c3e: 687a         	ldr	r2, [r7, #0x4]
 8023c40: 68b9         	ldr	r1, [r7, #0x8]
 8023c42: 68f8         	ldr	r0, [r7, #0xc]
 8023c44: 4798         	blx	r3
 8023c46: 4603         	mov	r3, r0
; }
 8023c48: 4618         	mov	r0, r3
 8023c4a: 3718         	adds	r7, #0x18
 8023c4c: 46bd         	mov	sp, r7
 8023c4e: bd80         	pop	{r7, pc}

08023c50 <z_impl_uart_rx_disable>:
; {
 8023c50: b580         	push	{r7, lr}
 8023c52: b084         	sub	sp, #0x10
 8023c54: af00         	add	r7, sp, #0x0
 8023c56: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8023c58: 687b         	ldr	r3, [r7, #0x4]
 8023c5a: 689b         	ldr	r3, [r3, #0x8]
 8023c5c: 60fb         	str	r3, [r7, #0xc]
; 	return api->rx_disable(dev);
 8023c5e: 68fb         	ldr	r3, [r7, #0xc]
 8023c60: 695b         	ldr	r3, [r3, #0x14]
 8023c62: 6878         	ldr	r0, [r7, #0x4]
 8023c64: 4798         	blx	r3
 8023c66: 4603         	mov	r3, r0
; }
 8023c68: 4618         	mov	r0, r3
 8023c6a: 3710         	adds	r7, #0x10
 8023c6c: 46bd         	mov	sp, r7
 8023c6e: bd80         	pop	{r7, pc}

08023c70 <uart_configure>:
; {
 8023c70: b580         	push	{r7, lr}
 8023c72: b082         	sub	sp, #0x8
 8023c74: af00         	add	r7, sp, #0x0
 8023c76: 6078         	str	r0, [r7, #0x4]
 8023c78: 6039         	str	r1, [r7]
; 	return z_impl_uart_configure(dev, cfg);
 8023c7a: 6839         	ldr	r1, [r7]
 8023c7c: 6878         	ldr	r0, [r7, #0x4]
 8023c7e: f7ff ff89    	bl	0x8023b94 <z_impl_uart_configure> @ imm = #-0xee
 8023c82: 4603         	mov	r3, r0
; }
 8023c84: 4618         	mov	r0, r3
 8023c86: 3708         	adds	r7, #0x8
 8023c88: 46bd         	mov	sp, r7
 8023c8a: bd80         	pop	{r7, pc}

08023c8c <uart_rx_enable>:
; {
 8023c8c: b580         	push	{r7, lr}
 8023c8e: b084         	sub	sp, #0x10
 8023c90: af00         	add	r7, sp, #0x0
 8023c92: 60f8         	str	r0, [r7, #0xc]
 8023c94: 60b9         	str	r1, [r7, #0x8]
 8023c96: 607a         	str	r2, [r7, #0x4]
 8023c98: 603b         	str	r3, [r7]
; 	return z_impl_uart_rx_enable(dev, buf, len, timeout);
 8023c9a: 683b         	ldr	r3, [r7]
 8023c9c: 687a         	ldr	r2, [r7, #0x4]
 8023c9e: 68b9         	ldr	r1, [r7, #0x8]
 8023ca0: 68f8         	ldr	r0, [r7, #0xc]
 8023ca2: f7ff ffab    	bl	0x8023bfc <z_impl_uart_rx_enable> @ imm = #-0xaa
 8023ca6: 4603         	mov	r3, r0
; }
 8023ca8: 4618         	mov	r0, r3
 8023caa: 3710         	adds	r7, #0x10
 8023cac: 46bd         	mov	sp, r7
 8023cae: bd80         	pop	{r7, pc}

08023cb0 <uart_rx_disable>:
; {
 8023cb0: b580         	push	{r7, lr}
 8023cb2: b082         	sub	sp, #0x8
 8023cb4: af00         	add	r7, sp, #0x0
 8023cb6: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_uart_rx_disable(dev);
 8023cb8: 6878         	ldr	r0, [r7, #0x4]
 8023cba: f7ff ffc9    	bl	0x8023c50 <z_impl_uart_rx_disable> @ imm = #-0x6e
 8023cbe: 4603         	mov	r3, r0
; }
 8023cc0: 4618         	mov	r0, r3
 8023cc2: 3708         	adds	r7, #0x8
 8023cc4: 46bd         	mov	sp, r7
 8023cc6: bd80         	pop	{r7, pc}

08023cc8 <z_log_msg_runtime_create>:
; {
 8023cc8: b580         	push	{r7, lr}
 8023cca: b08a         	sub	sp, #0x28
 8023ccc: af04         	add	r7, sp, #0x10
 8023cce: 60b9         	str	r1, [r7, #0x8]
 8023cd0: 607b         	str	r3, [r7, #0x4]
 8023cd2: 4603         	mov	r3, r0
 8023cd4: 73fb         	strb	r3, [r7, #0xf]
 8023cd6: 4613         	mov	r3, r2
 8023cd8: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8023cda: f107 032c    	add.w	r3, r7, #0x2c
 8023cde: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8023ce0: 7bba         	ldrb	r2, [r7, #0xe]
 8023ce2: 7bf8         	ldrb	r0, [r7, #0xf]
 8023ce4: 697b         	ldr	r3, [r7, #0x14]
 8023ce6: 9303         	str	r3, [sp, #0xc]
 8023ce8: 6abb         	ldr	r3, [r7, #0x28]
 8023cea: 9302         	str	r3, [sp, #0x8]
 8023cec: 6a7b         	ldr	r3, [r7, #0x24]
 8023cee: 9301         	str	r3, [sp, #0x4]
 8023cf0: 6a3b         	ldr	r3, [r7, #0x20]
 8023cf2: 9300         	str	r3, [sp]
 8023cf4: 687b         	ldr	r3, [r7, #0x4]
 8023cf6: 68b9         	ldr	r1, [r7, #0x8]
 8023cf8: f7e0 ff24    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x1f1b8
; }
 8023cfc: bf00         	nop
 8023cfe: 3718         	adds	r7, #0x18
 8023d00: 46bd         	mov	sp, r7
 8023d02: bd80         	pop	{r7, pc}

08023d04 <sbus_parseframe>:
; { // 检查帧是否为空
 8023d04: b480         	push	{r7}
 8023d06: b085         	sub	sp, #0x14
 8023d08: af00         	add	r7, sp, #0x0
 8023d0a: 6078         	str	r0, [r7, #0x4]
; 	struct sbus_driver_data *data = dev->data;
 8023d0c: 687b         	ldr	r3, [r7, #0x4]
 8023d0e: 691b         	ldr	r3, [r3, #0x10]
 8023d10: 60fb         	str	r3, [r7, #0xc]
; 	data->channels[0] = (data->data[1] >> 0 | (data->data[2] << 8)) & 0x07FF;
 8023d12: 68fb         	ldr	r3, [r7, #0xc]
 8023d14: 785b         	ldrb	r3, [r3, #0x1]
 8023d16: b21a         	sxth	r2, r3
 8023d18: 68fb         	ldr	r3, [r7, #0xc]
 8023d1a: 789b         	ldrb	r3, [r3, #0x2]
 8023d1c: 021b         	lsls	r3, r3, #0x8
 8023d1e: b21b         	sxth	r3, r3
 8023d20: 4313         	orrs	r3, r2
 8023d22: b21b         	sxth	r3, r3
 8023d24: b29b         	uxth	r3, r3
 8023d26: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023d2a: b29a         	uxth	r2, r3
 8023d2c: 68fb         	ldr	r3, [r7, #0xc]
 8023d2e: 835a         	strh	r2, [r3, #0x1a]
; 	data->channels[1] = (data->data[2] >> 3 | (data->data[3] << 5)) & 0x07FF;
 8023d30: 68fb         	ldr	r3, [r7, #0xc]
 8023d32: 789b         	ldrb	r3, [r3, #0x2]
 8023d34: 08db         	lsrs	r3, r3, #0x3
 8023d36: b2db         	uxtb	r3, r3
 8023d38: b21a         	sxth	r2, r3
 8023d3a: 68fb         	ldr	r3, [r7, #0xc]
 8023d3c: 78db         	ldrb	r3, [r3, #0x3]
 8023d3e: 015b         	lsls	r3, r3, #0x5
 8023d40: b21b         	sxth	r3, r3
 8023d42: 4313         	orrs	r3, r2
 8023d44: b21b         	sxth	r3, r3
 8023d46: b29b         	uxth	r3, r3
 8023d48: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023d4c: b29a         	uxth	r2, r3
 8023d4e: 68fb         	ldr	r3, [r7, #0xc]
 8023d50: 839a         	strh	r2, [r3, #0x1c]
; 		(data->data[3] >> 6 | (data->data[4] << 2) | data->data[5] << 10) & 0x07FF;
 8023d52: 68fb         	ldr	r3, [r7, #0xc]
 8023d54: 78db         	ldrb	r3, [r3, #0x3]
 8023d56: 099b         	lsrs	r3, r3, #0x6
 8023d58: b2db         	uxtb	r3, r3
 8023d5a: b21a         	sxth	r2, r3
 8023d5c: 68fb         	ldr	r3, [r7, #0xc]
 8023d5e: 791b         	ldrb	r3, [r3, #0x4]
 8023d60: 009b         	lsls	r3, r3, #0x2
 8023d62: b21b         	sxth	r3, r3
 8023d64: 4313         	orrs	r3, r2
 8023d66: b21a         	sxth	r2, r3
 8023d68: 68fb         	ldr	r3, [r7, #0xc]
 8023d6a: 795b         	ldrb	r3, [r3, #0x5]
 8023d6c: 029b         	lsls	r3, r3, #0xa
 8023d6e: b21b         	sxth	r3, r3
 8023d70: 4313         	orrs	r3, r2
 8023d72: b21b         	sxth	r3, r3
 8023d74: b29b         	uxth	r3, r3
 8023d76: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023d7a: b29a         	uxth	r2, r3
; 	data->channels[2] =
 8023d7c: 68fb         	ldr	r3, [r7, #0xc]
 8023d7e: 83da         	strh	r2, [r3, #0x1e]
; 	data->channels[3] = (data->data[5] >> 1 | (data->data[6] << 7)) & 0x07FF;
 8023d80: 68fb         	ldr	r3, [r7, #0xc]
 8023d82: 795b         	ldrb	r3, [r3, #0x5]
 8023d84: 085b         	lsrs	r3, r3, #0x1
 8023d86: b2db         	uxtb	r3, r3
 8023d88: b21a         	sxth	r2, r3
 8023d8a: 68fb         	ldr	r3, [r7, #0xc]
 8023d8c: 799b         	ldrb	r3, [r3, #0x6]
 8023d8e: 01db         	lsls	r3, r3, #0x7
 8023d90: b21b         	sxth	r3, r3
 8023d92: 4313         	orrs	r3, r2
 8023d94: b21b         	sxth	r3, r3
 8023d96: b29b         	uxth	r3, r3
 8023d98: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023d9c: b29a         	uxth	r2, r3
 8023d9e: 68fb         	ldr	r3, [r7, #0xc]
 8023da0: 841a         	strh	r2, [r3, #0x20]
; 	data->channels[4] = (data->data[6] >> 4 | (data->data[7] << 4)) & 0x07FF;
 8023da2: 68fb         	ldr	r3, [r7, #0xc]
 8023da4: 799b         	ldrb	r3, [r3, #0x6]
 8023da6: 091b         	lsrs	r3, r3, #0x4
 8023da8: b2db         	uxtb	r3, r3
 8023daa: b21a         	sxth	r2, r3
 8023dac: 68fb         	ldr	r3, [r7, #0xc]
 8023dae: 79db         	ldrb	r3, [r3, #0x7]
 8023db0: 011b         	lsls	r3, r3, #0x4
 8023db2: b21b         	sxth	r3, r3
 8023db4: 4313         	orrs	r3, r2
 8023db6: b21b         	sxth	r3, r3
 8023db8: b29b         	uxth	r3, r3
 8023dba: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023dbe: b29a         	uxth	r2, r3
 8023dc0: 68fb         	ldr	r3, [r7, #0xc]
 8023dc2: 845a         	strh	r2, [r3, #0x22]
; 		(data->data[7] >> 7 | (data->data[8] << 1) | data->data[9] << 9) & 0x07FF;
 8023dc4: 68fb         	ldr	r3, [r7, #0xc]
 8023dc6: 79db         	ldrb	r3, [r3, #0x7]
 8023dc8: 09db         	lsrs	r3, r3, #0x7
 8023dca: b2db         	uxtb	r3, r3
 8023dcc: b21a         	sxth	r2, r3
 8023dce: 68fb         	ldr	r3, [r7, #0xc]
 8023dd0: 7a1b         	ldrb	r3, [r3, #0x8]
 8023dd2: 005b         	lsls	r3, r3, #0x1
 8023dd4: b21b         	sxth	r3, r3
 8023dd6: 4313         	orrs	r3, r2
 8023dd8: b21a         	sxth	r2, r3
 8023dda: 68fb         	ldr	r3, [r7, #0xc]
 8023ddc: 7a5b         	ldrb	r3, [r3, #0x9]
 8023dde: 025b         	lsls	r3, r3, #0x9
 8023de0: b21b         	sxth	r3, r3
 8023de2: 4313         	orrs	r3, r2
 8023de4: b21b         	sxth	r3, r3
 8023de6: b29b         	uxth	r3, r3
 8023de8: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023dec: b29a         	uxth	r2, r3
; 	data->channels[5] =
 8023dee: 68fb         	ldr	r3, [r7, #0xc]
 8023df0: 849a         	strh	r2, [r3, #0x24]
; 	data->channels[6] = (data->data[9] >> 2 | (data->data[10] << 6)) & 0x07FF;
 8023df2: 68fb         	ldr	r3, [r7, #0xc]
 8023df4: 7a5b         	ldrb	r3, [r3, #0x9]
 8023df6: 089b         	lsrs	r3, r3, #0x2
 8023df8: b2db         	uxtb	r3, r3
 8023dfa: b21a         	sxth	r2, r3
 8023dfc: 68fb         	ldr	r3, [r7, #0xc]
 8023dfe: 7a9b         	ldrb	r3, [r3, #0xa]
 8023e00: 019b         	lsls	r3, r3, #0x6
 8023e02: b21b         	sxth	r3, r3
 8023e04: 4313         	orrs	r3, r2
 8023e06: b21b         	sxth	r3, r3
 8023e08: b29b         	uxth	r3, r3
 8023e0a: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023e0e: b29a         	uxth	r2, r3
 8023e10: 68fb         	ldr	r3, [r7, #0xc]
 8023e12: 84da         	strh	r2, [r3, #0x26]
; 	data->channels[7] = (data->data[10] >> 5 | (data->data[11] << 3)) & 0x07FF;
 8023e14: 68fb         	ldr	r3, [r7, #0xc]
 8023e16: 7a9b         	ldrb	r3, [r3, #0xa]
 8023e18: 095b         	lsrs	r3, r3, #0x5
 8023e1a: b2db         	uxtb	r3, r3
 8023e1c: b21a         	sxth	r2, r3
 8023e1e: 68fb         	ldr	r3, [r7, #0xc]
 8023e20: 7adb         	ldrb	r3, [r3, #0xb]
 8023e22: 00db         	lsls	r3, r3, #0x3
 8023e24: b21b         	sxth	r3, r3
 8023e26: 4313         	orrs	r3, r2
 8023e28: b21b         	sxth	r3, r3
 8023e2a: b29b         	uxth	r3, r3
 8023e2c: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023e30: b29a         	uxth	r2, r3
 8023e32: 68fb         	ldr	r3, [r7, #0xc]
 8023e34: 851a         	strh	r2, [r3, #0x28]
; 	data->channels[8] = (data->data[12] << 0 | (data->data[13] << 8)) & 0x07FF;
 8023e36: 68fb         	ldr	r3, [r7, #0xc]
 8023e38: 7b1b         	ldrb	r3, [r3, #0xc]
 8023e3a: b21a         	sxth	r2, r3
 8023e3c: 68fb         	ldr	r3, [r7, #0xc]
 8023e3e: 7b5b         	ldrb	r3, [r3, #0xd]
 8023e40: 021b         	lsls	r3, r3, #0x8
 8023e42: b21b         	sxth	r3, r3
 8023e44: 4313         	orrs	r3, r2
 8023e46: b21b         	sxth	r3, r3
 8023e48: b29b         	uxth	r3, r3
 8023e4a: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023e4e: b29a         	uxth	r2, r3
 8023e50: 68fb         	ldr	r3, [r7, #0xc]
 8023e52: 855a         	strh	r2, [r3, #0x2a]
; 	data->channels[9] = (data->data[13] >> 3 | (data->data[14] << 5)) & 0x07FF;
 8023e54: 68fb         	ldr	r3, [r7, #0xc]
 8023e56: 7b5b         	ldrb	r3, [r3, #0xd]
 8023e58: 08db         	lsrs	r3, r3, #0x3
 8023e5a: b2db         	uxtb	r3, r3
 8023e5c: b21a         	sxth	r2, r3
 8023e5e: 68fb         	ldr	r3, [r7, #0xc]
 8023e60: 7b9b         	ldrb	r3, [r3, #0xe]
 8023e62: 015b         	lsls	r3, r3, #0x5
 8023e64: b21b         	sxth	r3, r3
 8023e66: 4313         	orrs	r3, r2
 8023e68: b21b         	sxth	r3, r3
 8023e6a: b29b         	uxth	r3, r3
 8023e6c: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023e70: b29a         	uxth	r2, r3
 8023e72: 68fb         	ldr	r3, [r7, #0xc]
 8023e74: 859a         	strh	r2, [r3, #0x2c]
; 		(data->data[14] >> 6 | (data->data[16] << 2) | data->data[15] << 10) & 0x07FF;
 8023e76: 68fb         	ldr	r3, [r7, #0xc]
 8023e78: 7b9b         	ldrb	r3, [r3, #0xe]
 8023e7a: 099b         	lsrs	r3, r3, #0x6
 8023e7c: b2db         	uxtb	r3, r3
 8023e7e: b21a         	sxth	r2, r3
 8023e80: 68fb         	ldr	r3, [r7, #0xc]
 8023e82: 7c1b         	ldrb	r3, [r3, #0x10]
 8023e84: 009b         	lsls	r3, r3, #0x2
 8023e86: b21b         	sxth	r3, r3
 8023e88: 4313         	orrs	r3, r2
 8023e8a: b21a         	sxth	r2, r3
 8023e8c: 68fb         	ldr	r3, [r7, #0xc]
 8023e8e: 7bdb         	ldrb	r3, [r3, #0xf]
 8023e90: 029b         	lsls	r3, r3, #0xa
 8023e92: b21b         	sxth	r3, r3
 8023e94: 4313         	orrs	r3, r2
 8023e96: b21b         	sxth	r3, r3
 8023e98: b29b         	uxth	r3, r3
 8023e9a: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023e9e: b29a         	uxth	r2, r3
; 	data->channels[10] =
 8023ea0: 68fb         	ldr	r3, [r7, #0xc]
 8023ea2: 85da         	strh	r2, [r3, #0x2e]
; 	data->channels[11] = (data->data[16] >> 1 | (data->data[17] << 7)) & 0x07FF;
 8023ea4: 68fb         	ldr	r3, [r7, #0xc]
 8023ea6: 7c1b         	ldrb	r3, [r3, #0x10]
 8023ea8: 085b         	lsrs	r3, r3, #0x1
 8023eaa: b2db         	uxtb	r3, r3
 8023eac: b21a         	sxth	r2, r3
 8023eae: 68fb         	ldr	r3, [r7, #0xc]
 8023eb0: 7c5b         	ldrb	r3, [r3, #0x11]
 8023eb2: 01db         	lsls	r3, r3, #0x7
 8023eb4: b21b         	sxth	r3, r3
 8023eb6: 4313         	orrs	r3, r2
 8023eb8: b21b         	sxth	r3, r3
 8023eba: b29b         	uxth	r3, r3
 8023ebc: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023ec0: b29a         	uxth	r2, r3
 8023ec2: 68fb         	ldr	r3, [r7, #0xc]
 8023ec4: 861a         	strh	r2, [r3, #0x30]
; 	data->channels[12] = (data->data[17] >> 4 | (data->data[18] << 4)) & 0x07FF;
 8023ec6: 68fb         	ldr	r3, [r7, #0xc]
 8023ec8: 7c5b         	ldrb	r3, [r3, #0x11]
 8023eca: 091b         	lsrs	r3, r3, #0x4
 8023ecc: b2db         	uxtb	r3, r3
 8023ece: b21a         	sxth	r2, r3
 8023ed0: 68fb         	ldr	r3, [r7, #0xc]
 8023ed2: 7c9b         	ldrb	r3, [r3, #0x12]
 8023ed4: 011b         	lsls	r3, r3, #0x4
 8023ed6: b21b         	sxth	r3, r3
 8023ed8: 4313         	orrs	r3, r2
 8023eda: b21b         	sxth	r3, r3
 8023edc: b29b         	uxth	r3, r3
 8023ede: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023ee2: b29a         	uxth	r2, r3
 8023ee4: 68fb         	ldr	r3, [r7, #0xc]
 8023ee6: 865a         	strh	r2, [r3, #0x32]
; 		(data->data[18] >> 7 | (data->data[19] << 1) | data->data[20] << 9) & 0x07FF;
 8023ee8: 68fb         	ldr	r3, [r7, #0xc]
 8023eea: 7c9b         	ldrb	r3, [r3, #0x12]
 8023eec: 09db         	lsrs	r3, r3, #0x7
 8023eee: b2db         	uxtb	r3, r3
 8023ef0: b21a         	sxth	r2, r3
 8023ef2: 68fb         	ldr	r3, [r7, #0xc]
 8023ef4: 7cdb         	ldrb	r3, [r3, #0x13]
 8023ef6: 005b         	lsls	r3, r3, #0x1
 8023ef8: b21b         	sxth	r3, r3
 8023efa: 4313         	orrs	r3, r2
 8023efc: b21a         	sxth	r2, r3
 8023efe: 68fb         	ldr	r3, [r7, #0xc]
 8023f00: 7d1b         	ldrb	r3, [r3, #0x14]
 8023f02: 025b         	lsls	r3, r3, #0x9
 8023f04: b21b         	sxth	r3, r3
 8023f06: 4313         	orrs	r3, r2
 8023f08: b21b         	sxth	r3, r3
 8023f0a: b29b         	uxth	r3, r3
 8023f0c: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023f10: b29a         	uxth	r2, r3
; 	data->channels[13] =
 8023f12: 68fb         	ldr	r3, [r7, #0xc]
 8023f14: 869a         	strh	r2, [r3, #0x34]
; 	data->channels[14] = (data->data[20] >> 2 | (data->data[21] << 6)) & 0x07FF;
 8023f16: 68fb         	ldr	r3, [r7, #0xc]
 8023f18: 7d1b         	ldrb	r3, [r3, #0x14]
 8023f1a: 089b         	lsrs	r3, r3, #0x2
 8023f1c: b2db         	uxtb	r3, r3
 8023f1e: b21a         	sxth	r2, r3
 8023f20: 68fb         	ldr	r3, [r7, #0xc]
 8023f22: 7d5b         	ldrb	r3, [r3, #0x15]
 8023f24: 019b         	lsls	r3, r3, #0x6
 8023f26: b21b         	sxth	r3, r3
 8023f28: 4313         	orrs	r3, r2
 8023f2a: b21b         	sxth	r3, r3
 8023f2c: b29b         	uxth	r3, r3
 8023f2e: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023f32: b29a         	uxth	r2, r3
 8023f34: 68fb         	ldr	r3, [r7, #0xc]
 8023f36: 86da         	strh	r2, [r3, #0x36]
; 	data->channels[15] = (data->data[21] >> 5 | (data->data[22] << 3)) & 0x07FF;
 8023f38: 68fb         	ldr	r3, [r7, #0xc]
 8023f3a: 7d5b         	ldrb	r3, [r3, #0x15]
 8023f3c: 095b         	lsrs	r3, r3, #0x5
 8023f3e: b2db         	uxtb	r3, r3
 8023f40: b21a         	sxth	r2, r3
 8023f42: 68fb         	ldr	r3, [r7, #0xc]
 8023f44: 7d9b         	ldrb	r3, [r3, #0x16]
 8023f46: 00db         	lsls	r3, r3, #0x3
 8023f48: b21b         	sxth	r3, r3
 8023f4a: 4313         	orrs	r3, r2
 8023f4c: b21b         	sxth	r3, r3
 8023f4e: b29b         	uxth	r3, r3
 8023f50: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 8023f54: b29a         	uxth	r2, r3
 8023f56: 68fb         	ldr	r3, [r7, #0xc]
 8023f58: 871a         	strh	r2, [r3, #0x38]
; 	data->frameLost = (data->data[23] & 0x04) >> 2;
 8023f5a: 68fb         	ldr	r3, [r7, #0xc]
 8023f5c: 7ddb         	ldrb	r3, [r3, #0x17]
 8023f5e: 109b         	asrs	r3, r3, #0x2
 8023f60: f003 0301    	and	r3, r3, #0x1
 8023f64: 2b00         	cmp	r3, #0x0
 8023f66: bf14         	ite	ne
 8023f68: 2301         	movne	r3, #0x1
 8023f6a: 2300         	moveq	r3, #0x0
 8023f6c: b2da         	uxtb	r2, r3
 8023f6e: 68fb         	ldr	r3, [r7, #0xc]
 8023f70: f883 203a    	strb.w	r2, [r3, #0x3a]
; 	data->failSafe = (data->data[23] & 0x08) >> 3;
 8023f74: 68fb         	ldr	r3, [r7, #0xc]
 8023f76: 7ddb         	ldrb	r3, [r3, #0x17]
 8023f78: 10db         	asrs	r3, r3, #0x3
 8023f7a: f003 0301    	and	r3, r3, #0x1
 8023f7e: 2b00         	cmp	r3, #0x0
 8023f80: bf14         	ite	ne
 8023f82: 2301         	movne	r3, #0x1
 8023f84: 2300         	moveq	r3, #0x0
 8023f86: b2da         	uxtb	r2, r3
 8023f88: 68fb         	ldr	r3, [r7, #0xc]
 8023f8a: f883 203b    	strb.w	r2, [r3, #0x3b]
; 	data->digitalChannels[0] = (data->data[23] & 0x01);
 8023f8e: 68fb         	ldr	r3, [r7, #0xc]
 8023f90: 7ddb         	ldrb	r3, [r3, #0x17]
 8023f92: f003 0301    	and	r3, r3, #0x1
 8023f96: 2b00         	cmp	r3, #0x0
 8023f98: bf14         	ite	ne
 8023f9a: 2301         	movne	r3, #0x1
 8023f9c: 2300         	moveq	r3, #0x0
 8023f9e: b2da         	uxtb	r2, r3
 8023fa0: 68fb         	ldr	r3, [r7, #0xc]
 8023fa2: f883 203c    	strb.w	r2, [r3, #0x3c]
; 	data->digitalChannels[1] = (data->data[23] & 0x02) >> 1;
 8023fa6: 68fb         	ldr	r3, [r7, #0xc]
 8023fa8: 7ddb         	ldrb	r3, [r3, #0x17]
 8023faa: 105b         	asrs	r3, r3, #0x1
 8023fac: f003 0301    	and	r3, r3, #0x1
 8023fb0: 2b00         	cmp	r3, #0x0
 8023fb2: bf14         	ite	ne
 8023fb4: 2301         	movne	r3, #0x1
 8023fb6: 2300         	moveq	r3, #0x0
 8023fb8: b2da         	uxtb	r2, r3
 8023fba: 68fb         	ldr	r3, [r7, #0xc]
 8023fbc: f883 203d    	strb.w	r2, [r3, #0x3d]
; }
 8023fc0: bf00         	nop
 8023fc2: 3714         	adds	r7, #0x14
 8023fc4: 46bd         	mov	sp, r7
 8023fc6: f85d 7b04    	ldr	r7, [sp], #4
 8023fca: 4770         	bx	lr

08023fcc <find_begin>:
; {
 8023fcc: b480         	push	{r7}
 8023fce: b085         	sub	sp, #0x14
 8023fd0: af00         	add	r7, sp, #0x0
 8023fd2: 6078         	str	r0, [r7, #0x4]
 8023fd4: 460b         	mov	r3, r1
 8023fd6: 807b         	strh	r3, [r7, #0x2]
; 	if (len < 25) {
 8023fd8: 887b         	ldrh	r3, [r7, #0x2]
 8023fda: 2b18         	cmp	r3, #0x18
 8023fdc: d802         	bhi	0x8023fe4 <find_begin+0x18> @ imm = #0x4
; 		return -1;
 8023fde: f04f 33ff    	mov.w	r3, #0xffffffff
 8023fe2: e01e         	b	0x8024022 <find_begin+0x56> @ imm = #0x3c
; 	for (int i = len - 1; i >= 24; i--) {
 8023fe4: 887b         	ldrh	r3, [r7, #0x2]
 8023fe6: 3b01         	subs	r3, #0x1
 8023fe8: 60fb         	str	r3, [r7, #0xc]
 8023fea: e015         	b	0x8024018 <find_begin+0x4c> @ imm = #0x2a
; 		if (data[i - 24] == 0x0F && data[i] == 0x00) {
 8023fec: 68fb         	ldr	r3, [r7, #0xc]
 8023fee: 3b18         	subs	r3, #0x18
 8023ff0: 687a         	ldr	r2, [r7, #0x4]
 8023ff2: 4413         	add	r3, r2
 8023ff4: 781b         	ldrb	r3, [r3]
 8023ff6: 2b0f         	cmp	r3, #0xf
 8023ff8: d10b         	bne	0x8024012 <find_begin+0x46> @ imm = #0x16
 8023ffa: 68fb         	ldr	r3, [r7, #0xc]
 8023ffc: 687a         	ldr	r2, [r7, #0x4]
 8023ffe: 4413         	add	r3, r2
 8024000: 781b         	ldrb	r3, [r3]
 8024002: 2b00         	cmp	r3, #0x0
 8024004: d105         	bne	0x8024012 <find_begin+0x46> @ imm = #0xa
; 			return i - 24;
 8024006: 68fb         	ldr	r3, [r7, #0xc]
 8024008: b29b         	uxth	r3, r3
 802400a: 3b18         	subs	r3, #0x18
 802400c: b29b         	uxth	r3, r3
 802400e: b21b         	sxth	r3, r3
 8024010: e007         	b	0x8024022 <find_begin+0x56> @ imm = #0xe
; 	for (int i = len - 1; i >= 24; i--) {
 8024012: 68fb         	ldr	r3, [r7, #0xc]
 8024014: 3b01         	subs	r3, #0x1
 8024016: 60fb         	str	r3, [r7, #0xc]
 8024018: 68fb         	ldr	r3, [r7, #0xc]
 802401a: 2b17         	cmp	r3, #0x17
 802401c: dce6         	bgt	0x8023fec <find_begin+0x20> @ imm = #-0x34
; 	return -1;
 802401e: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 8024022: 4618         	mov	r0, r3
 8024024: 3714         	adds	r7, #0x14
 8024026: 46bd         	mov	sp, r7
 8024028: f85d 7b04    	ldr	r7, [sp], #4
 802402c: 4770         	bx	lr

0802402e <sbus_getchannel_digital>:
; {
 802402e: b580         	push	{r7, lr}
 8024030: b084         	sub	sp, #0x10
 8024032: af00         	add	r7, sp, #0x0
 8024034: 6078         	str	r0, [r7, #0x4]
 8024036: 460b         	mov	r3, r1
 8024038: 70fb         	strb	r3, [r7, #0x3]
; 	struct sbus_driver_data *data = dev->data;
 802403a: 687b         	ldr	r3, [r7, #0x4]
 802403c: 691b         	ldr	r3, [r3, #0x10]
 802403e: 60fb         	str	r3, [r7, #0xc]
; 	sbus_parseframe(dev);
 8024040: 6878         	ldr	r0, [r7, #0x4]
 8024042: f7ff fe5f    	bl	0x8023d04 <sbus_parseframe> @ imm = #-0x342
; 	return data->channels[channelid];
 8024046: 78fb         	ldrb	r3, [r7, #0x3]
 8024048: 68fa         	ldr	r2, [r7, #0xc]
 802404a: 330c         	adds	r3, #0xc
 802404c: 005b         	lsls	r3, r3, #0x1
 802404e: 4413         	add	r3, r2
 8024050: 885b         	ldrh	r3, [r3, #0x2]
; }
 8024052: 4618         	mov	r0, r3
 8024054: 3710         	adds	r7, #0x10
 8024056: 46bd         	mov	sp, r7
 8024058: bd80         	pop	{r7, pc}

0802405a <arch_k_cycle_get_32>:
; {
 802405a: b580         	push	{r7, lr}
 802405c: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 802405e: f7eb fa27    	bl	0x800f4b0 <sys_clock_cycle_get_32> @ imm = #-0x14bb2
 8024062: 4603         	mov	r3, r0
; }
 8024064: 4618         	mov	r0, r3
 8024066: bd80         	pop	{r7, pc}

08024068 <k_msleep>:
; {
 8024068: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 802406c: b082         	sub	sp, #0x8
 802406e: af00         	add	r7, sp, #0x0
 8024070: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 8024072: 6879         	ldr	r1, [r7, #0x4]
 8024074: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 8024078: 17c8         	asrs	r0, r1, #0x1f
 802407a: 4688         	mov	r8, r1
 802407c: 4681         	mov	r9, r0
 802407e: 4640         	mov	r0, r8
 8024080: 4649         	mov	r1, r9
 8024082: f04f 0400    	mov.w	r4, #0x0
 8024086: f04f 0500    	mov.w	r5, #0x0
 802408a: 008d         	lsls	r5, r1, #0x2
 802408c: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 8024090: 0084         	lsls	r4, r0, #0x2
 8024092: 4620         	mov	r0, r4
 8024094: 4629         	mov	r1, r5
 8024096: eb10 0208    	adds.w	r2, r0, r8
 802409a: eb41 0309    	adc.w	r3, r1, r9
 802409e: eb12 0a02    	adds.w	r10, r2, r2
 80240a2: eb43 0b03    	adc.w	r11, r3, r3
 80240a6: 4652         	mov	r2, r10
 80240a8: 465b         	mov	r3, r11
 80240aa: 4610         	mov	r0, r2
 80240ac: 4619         	mov	r1, r3
 80240ae: f000 f82a    	bl	0x8024106 <k_sleep>     @ imm = #0x54
 80240b2: 4601         	mov	r1, r0
 80240b4: 460b         	mov	r3, r1
; }
 80240b6: 4618         	mov	r0, r3
 80240b8: 3708         	adds	r7, #0x8
 80240ba: 46bd         	mov	sp, r7
 80240bc: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080240c0 <k_uptime_get>:
; {
 80240c0: b580         	push	{r7, lr}
 80240c2: af00         	add	r7, sp, #0x0
; 	return k_ticks_to_ms_floor64(k_uptime_ticks());
 80240c4: f000 f82d    	bl	0x8024122 <k_uptime_ticks> @ imm = #0x5a
 80240c8: 4602         	mov	r2, r0
 80240ca: 460b         	mov	r3, r1
 80240cc: 4610         	mov	r0, r2
 80240ce: 4619         	mov	r1, r3
 80240d0: f04f 020a    	mov.w	r2, #0xa
 80240d4: f04f 0300    	mov.w	r3, #0x0
 80240d8: f7dc fab2    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x23a9c
 80240dc: 4602         	mov	r2, r0
 80240de: 460b         	mov	r3, r1
; }
 80240e0: 4610         	mov	r0, r2
 80240e2: 4619         	mov	r1, r3
 80240e4: bd80         	pop	{r7, pc}

080240e6 <k_uptime_get_32>:
; {
 80240e6: b580         	push	{r7, lr}
 80240e8: af00         	add	r7, sp, #0x0
; 	return (uint32_t)k_uptime_get();
 80240ea: f7ff ffe9    	bl	0x80240c0 <k_uptime_get> @ imm = #-0x2e
 80240ee: 4602         	mov	r2, r0
 80240f0: 460b         	mov	r3, r1
 80240f2: 4613         	mov	r3, r2
; }
 80240f4: 4618         	mov	r0, r3
 80240f6: bd80         	pop	{r7, pc}

080240f8 <k_cycle_get_32>:
; {
 80240f8: b580         	push	{r7, lr}
 80240fa: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 80240fc: f7ff ffad    	bl	0x802405a <arch_k_cycle_get_32> @ imm = #-0xa6
 8024100: 4603         	mov	r3, r0
; }
 8024102: 4618         	mov	r0, r3
 8024104: bd80         	pop	{r7, pc}

08024106 <k_sleep>:
; {
 8024106: b580         	push	{r7, lr}
 8024108: b082         	sub	sp, #0x8
 802410a: af00         	add	r7, sp, #0x0
 802410c: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8024110: e9d7 0100    	ldrd	r0, r1, [r7]
 8024114: f7f2 f8ec    	bl	0x80162f0 <z_impl_k_sleep> @ imm = #-0xde28
 8024118: 4603         	mov	r3, r0
; }
 802411a: 4618         	mov	r0, r3
 802411c: 3708         	adds	r7, #0x8
 802411e: 46bd         	mov	sp, r7
 8024120: bd80         	pop	{r7, pc}

08024122 <k_uptime_ticks>:
; {
 8024122: b580         	push	{r7, lr}
 8024124: af00         	add	r7, sp, #0x0
; 	return z_impl_k_uptime_ticks();
 8024126: f002 ff60    	bl	0x8026fea <z_impl_k_uptime_ticks> @ imm = #0x2ec0
 802412a: 4602         	mov	r2, r0
 802412c: 460b         	mov	r3, r1
; }
 802412e: 4610         	mov	r0, r2
 8024130: 4619         	mov	r1, r3
 8024132: bd80         	pop	{r7, pc}

08024134 <pid_reg_input>:
; {
 8024134: b480         	push	{r7}
 8024136: b085         	sub	sp, #0x14
 8024138: af00         	add	r7, sp, #0x0
 802413a: 60f8         	str	r0, [r7, #0xc]
 802413c: 60b9         	str	r1, [r7, #0x8]
 802413e: 607a         	str	r2, [r7, #0x4]
; 	if (data == NULL) {
 8024140: 68fb         	ldr	r3, [r7, #0xc]
 8024142: 2b00         	cmp	r3, #0x0
 8024144: d006         	beq	0x8024154 <pid_reg_input+0x20> @ imm = #0xc
; 	data->curr = curr;
 8024146: 68fb         	ldr	r3, [r7, #0xc]
 8024148: 68ba         	ldr	r2, [r7, #0x8]
 802414a: 605a         	str	r2, [r3, #0x4]
; 	data->ref = ref;
 802414c: 68fb         	ldr	r3, [r7, #0xc]
 802414e: 687a         	ldr	r2, [r7, #0x4]
 8024150: 601a         	str	r2, [r3]
 8024152: e000         	b	0x8024156 <pid_reg_input+0x22> @ imm = #0x0
; 		return;
 8024154: bf00         	nop
; }
 8024156: 3714         	adds	r7, #0x14
 8024158: 46bd         	mov	sp, r7
 802415a: f85d 7b04    	ldr	r7, [sp], #4
 802415e: 4770         	bx	lr

08024160 <pid_reg_output>:
; {
 8024160: b480         	push	{r7}
 8024162: b083         	sub	sp, #0xc
 8024164: af00         	add	r7, sp, #0x0
 8024166: 6078         	str	r0, [r7, #0x4]
 8024168: 6039         	str	r1, [r7]
; 	if (data == NULL) {
 802416a: 687b         	ldr	r3, [r7, #0x4]
 802416c: 2b00         	cmp	r3, #0x0
 802416e: d003         	beq	0x8024178 <pid_reg_output+0x18> @ imm = #0x6
; 	data->output = output;
 8024170: 687b         	ldr	r3, [r7, #0x4]
 8024172: 683a         	ldr	r2, [r7]
 8024174: 629a         	str	r2, [r3, #0x28]
 8024176: e000         	b	0x802417a <pid_reg_output+0x1a> @ imm = #0x0
; 		return;
 8024178: bf00         	nop
; }
 802417a: 370c         	adds	r7, #0xc
 802417c: 46bd         	mov	sp, r7
 802417e: f85d 7b04    	ldr	r7, [sp], #4
 8024182: 4770         	bx	lr

08024184 <pid_reg_time>:
; {
 8024184: b480         	push	{r7}
 8024186: b085         	sub	sp, #0x14
 8024188: af00         	add	r7, sp, #0x0
 802418a: 60f8         	str	r0, [r7, #0xc]
 802418c: 60b9         	str	r1, [r7, #0x8]
 802418e: 607a         	str	r2, [r7, #0x4]
; 	if (data == NULL) {
 8024190: 68fb         	ldr	r3, [r7, #0xc]
 8024192: 2b00         	cmp	r3, #0x0
 8024194: d006         	beq	0x80241a4 <pid_reg_time+0x20> @ imm = #0xc
; 	data->curr_time = curr_cyc;
 8024196: 68fb         	ldr	r3, [r7, #0xc]
 8024198: 68ba         	ldr	r2, [r7, #0x8]
 802419a: 621a         	str	r2, [r3, #0x20]
; 	data->prev_time = prev_cyc;
 802419c: 68fb         	ldr	r3, [r7, #0xc]
 802419e: 687a         	ldr	r2, [r7, #0x4]
 80241a0: 625a         	str	r2, [r3, #0x24]
 80241a2: e000         	b	0x80241a6 <pid_reg_time+0x22> @ imm = #0x0
; 		return;
 80241a4: bf00         	nop
; }
 80241a6: 3714         	adds	r7, #0x14
 80241a8: 46bd         	mov	sp, r7
 80241aa: f85d 7b04    	ldr	r7, [sp], #4
 80241ae: 4770         	bx	lr

080241b0 <z_impl_motor_set_speed>:
; {
 80241b0: b580         	push	{r7, lr}
 80241b2: b084         	sub	sp, #0x10
 80241b4: af00         	add	r7, sp, #0x0
 80241b6: 6078         	str	r0, [r7, #0x4]
 80241b8: ed87 0a00    	vstr	s0, [r7]
; 	const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 80241bc: 687b         	ldr	r3, [r7, #0x4]
 80241be: 689b         	ldr	r3, [r3, #0x8]
 80241c0: 60fb         	str	r3, [r7, #0xc]
; 	if (api->motor_set_speed == NULL) {
 80241c2: 68fb         	ldr	r3, [r7, #0xc]
 80241c4: 68db         	ldr	r3, [r3, #0xc]
 80241c6: 2b00         	cmp	r3, #0x0
 80241c8: d102         	bne	0x80241d0 <z_impl_motor_set_speed+0x20> @ imm = #0x4
; 		return -ENOSYS;
 80241ca: f06f 0357    	mvn	r3, #0x57
 80241ce: e006         	b	0x80241de <z_impl_motor_set_speed+0x2e> @ imm = #0xc
; 	return api->motor_set_speed(dev, speed_rpm);
 80241d0: 68fb         	ldr	r3, [r7, #0xc]
 80241d2: 68db         	ldr	r3, [r3, #0xc]
 80241d4: ed97 0a00    	vldr	s0, [r7]
 80241d8: 6878         	ldr	r0, [r7, #0x4]
 80241da: 4798         	blx	r3
 80241dc: 4603         	mov	r3, r0
; }
 80241de: 4618         	mov	r0, r3
 80241e0: 3710         	adds	r7, #0x10
 80241e2: 46bd         	mov	sp, r7
 80241e4: bd80         	pop	{r7, pc}

080241e6 <z_impl_motor_set_angle>:
; {
 80241e6: b580         	push	{r7, lr}
 80241e8: b084         	sub	sp, #0x10
 80241ea: af00         	add	r7, sp, #0x0
 80241ec: 6078         	str	r0, [r7, #0x4]
 80241ee: ed87 0a00    	vstr	s0, [r7]
; 	const struct motor_driver_api *api = (const struct motor_driver_api *)dev->api;
 80241f2: 687b         	ldr	r3, [r7, #0x4]
 80241f4: 689b         	ldr	r3, [r3, #0x8]
 80241f6: 60fb         	str	r3, [r7, #0xc]
; 	if (api->motor_set_angle == NULL) {
 80241f8: 68fb         	ldr	r3, [r7, #0xc]
 80241fa: 695b         	ldr	r3, [r3, #0x14]
 80241fc: 2b00         	cmp	r3, #0x0
 80241fe: d102         	bne	0x8024206 <z_impl_motor_set_angle+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8024200: f06f 0357    	mvn	r3, #0x57
 8024204: e006         	b	0x8024214 <z_impl_motor_set_angle+0x2e> @ imm = #0xc
; 	return api->motor_set_angle(dev, angle);
 8024206: 68fb         	ldr	r3, [r7, #0xc]
 8024208: 695b         	ldr	r3, [r3, #0x14]
 802420a: ed97 0a00    	vldr	s0, [r7]
 802420e: 6878         	ldr	r0, [r7, #0x4]
 8024210: 4798         	blx	r3
 8024212: 4603         	mov	r3, r0
; }
 8024214: 4618         	mov	r0, r3
 8024216: 3710         	adds	r7, #0x10
 8024218: 46bd         	mov	sp, r7
 802421a: bd80         	pop	{r7, pc}

0802421c <motor_get_speed>:
; {
 802421c: b580         	push	{r7, lr}
 802421e: b082         	sub	sp, #0x8
 8024220: af00         	add	r7, sp, #0x0
 8024222: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_motor_get_speed(dev);
 8024224: 6878         	ldr	r0, [r7, #0x4]
 8024226: f7ed f99d    	bl	0x8011564 <z_impl_motor_get_speed> @ imm = #-0x12cc6
 802422a: eef0 7a40    	vmov.f32	s15, s0
; }
 802422e: eeb0 0a67    	vmov.f32	s0, s15
 8024232: 3708         	adds	r7, #0x8
 8024234: 46bd         	mov	sp, r7
 8024236: bd80         	pop	{r7, pc}

08024238 <motor_get_angle>:
; {
 8024238: b580         	push	{r7, lr}
 802423a: b082         	sub	sp, #0x8
 802423c: af00         	add	r7, sp, #0x0
 802423e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_motor_get_angle(dev);
 8024240: 6878         	ldr	r0, [r7, #0x4]
 8024242: f7ed f9ab    	bl	0x801159c <z_impl_motor_get_angle> @ imm = #-0x12caa
 8024246: eef0 7a40    	vmov.f32	s15, s0
; }
 802424a: eeb0 0a67    	vmov.f32	s0, s15
 802424e: 3708         	adds	r7, #0x8
 8024250: 46bd         	mov	sp, r7
 8024252: bd80         	pop	{r7, pc}

08024254 <motor_set_speed>:
; {
 8024254: b580         	push	{r7, lr}
 8024256: b082         	sub	sp, #0x8
 8024258: af00         	add	r7, sp, #0x0
 802425a: 6078         	str	r0, [r7, #0x4]
 802425c: ed87 0a00    	vstr	s0, [r7]
; 	return z_impl_motor_set_speed(dev, speed_rpm);
 8024260: ed97 0a00    	vldr	s0, [r7]
 8024264: 6878         	ldr	r0, [r7, #0x4]
 8024266: f7ff ffa3    	bl	0x80241b0 <z_impl_motor_set_speed> @ imm = #-0xba
 802426a: 4603         	mov	r3, r0
; }
 802426c: 4618         	mov	r0, r3
 802426e: 3708         	adds	r7, #0x8
 8024270: 46bd         	mov	sp, r7
 8024272: bd80         	pop	{r7, pc}

08024274 <motor_set_angle>:
; {
 8024274: b580         	push	{r7, lr}
 8024276: b082         	sub	sp, #0x8
 8024278: af00         	add	r7, sp, #0x0
 802427a: 6078         	str	r0, [r7, #0x4]
 802427c: ed87 0a00    	vstr	s0, [r7]
; 	return z_impl_motor_set_angle(dev, angle);
 8024280: ed97 0a00    	vldr	s0, [r7]
 8024284: 6878         	ldr	r0, [r7, #0x4]
 8024286: f7ff ffae    	bl	0x80241e6 <z_impl_motor_set_angle> @ imm = #-0xa4
 802428a: 4603         	mov	r3, r0
; }
 802428c: 4618         	mov	r0, r3
 802428e: 3708         	adds	r7, #0x8
 8024290: 46bd         	mov	sp, r7
 8024292: bd80         	pop	{r7, pc}

08024294 <steerwheel_get_speed>:
; {
 8024294: b580         	push	{r7, lr}
 8024296: b084         	sub	sp, #0x10
 8024298: af00         	add	r7, sp, #0x0
 802429a: 6078         	str	r0, [r7, #0x4]
; 	steerwheel_data_t *data = dev->data;
 802429c: 687b         	ldr	r3, [r7, #0x4]
 802429e: 691b         	ldr	r3, [r3, #0x10]
 80242a0: 60fb         	str	r3, [r7, #0xc]
; 	const steerwheel_cfg_t *cfg = dev->config;
 80242a2: 687b         	ldr	r3, [r7, #0x4]
 80242a4: 685b         	ldr	r3, [r3, #0x4]
 80242a6: 60bb         	str	r3, [r7, #0x8]
; 	data->current_speed = motor_get_speed(cfg->wheel_motor);
 80242a8: 68bb         	ldr	r3, [r7, #0x8]
 80242aa: 699b         	ldr	r3, [r3, #0x18]
 80242ac: 4618         	mov	r0, r3
 80242ae: f7ff ffb5    	bl	0x802421c <motor_get_speed> @ imm = #-0x96
 80242b2: eef0 7a40    	vmov.f32	s15, s0
 80242b6: 68fb         	ldr	r3, [r7, #0xc]
 80242b8: edc3 7a01    	vstr	s15, [r3, #4]
; 	if (data->negative) {
 80242bc: 68fb         	ldr	r3, [r7, #0xc]
 80242be: 7c1b         	ldrb	r3, [r3, #0x10]
 80242c0: 2b00         	cmp	r3, #0x0
 80242c2: d007         	beq	0x80242d4 <steerwheel_get_speed+0x40> @ imm = #0xe
; 		data->current_speed = -data->current_speed;
 80242c4: 68fb         	ldr	r3, [r7, #0xc]
 80242c6: edd3 7a01    	vldr	s15, [r3, #4]
 80242ca: eef1 7a67    	vneg.f32	s15, s15
 80242ce: 68fb         	ldr	r3, [r7, #0xc]
 80242d0: edc3 7a01    	vstr	s15, [r3, #4]
; 	return data->current_speed;
 80242d4: 68fb         	ldr	r3, [r7, #0xc]
 80242d6: 685b         	ldr	r3, [r3, #0x4]
 80242d8: ee07 3a90    	vmov	s15, r3
; }
 80242dc: eeb0 0a67    	vmov.f32	s0, s15
 80242e0: 3710         	adds	r7, #0x10
 80242e2: 46bd         	mov	sp, r7
 80242e4: bd80         	pop	{r7, pc}

080242e6 <swchassis_set_angle>:
; {
 80242e6: b480         	push	{r7}
 80242e8: b085         	sub	sp, #0x14
 80242ea: af00         	add	r7, sp, #0x0
 80242ec: 6078         	str	r0, [r7, #0x4]
 80242ee: ed87 0a00    	vstr	s0, [r7]
; 	chassis_data_t *data = dev->data;
 80242f2: 687b         	ldr	r3, [r7, #0x4]
 80242f4: 691b         	ldr	r3, [r3, #0x10]
 80242f6: 60fb         	str	r3, [r7, #0xc]
; 	data->targetYaw = angle;
 80242f8: 68fb         	ldr	r3, [r7, #0xc]
 80242fa: 683a         	ldr	r2, [r7]
 80242fc: 601a         	str	r2, [r3]
; 	data->angleControl = true;
 80242fe: 68fb         	ldr	r3, [r7, #0xc]
 8024300: 2201         	movs	r2, #0x1
 8024302: f883 2028    	strb.w	r2, [r3, #0x28]
; }
 8024306: bf00         	nop
 8024308: 3714         	adds	r7, #0x14
 802430a: 46bd         	mov	sp, r7
 802430c: f85d 7b04    	ldr	r7, [sp], #4
 8024310: 4770         	bx	lr

08024312 <swchassis_set_speed>:
; {
 8024312: b480         	push	{r7}
 8024314: b087         	sub	sp, #0x1c
 8024316: af00         	add	r7, sp, #0x0
 8024318: 60f8         	str	r0, [r7, #0xc]
 802431a: ed87 0a02    	vstr	s0, [r7, #8]
 802431e: edc7 0a01    	vstr	s1, [r7, #4]
; 	chassis_data_t *data = dev->data;
 8024322: 68fb         	ldr	r3, [r7, #0xc]
 8024324: 691b         	ldr	r3, [r3, #0x10]
 8024326: 617b         	str	r3, [r7, #0x14]
; 	data->targetXSpeed = x_speed;
 8024328: 697b         	ldr	r3, [r7, #0x14]
 802432a: 68ba         	ldr	r2, [r7, #0x8]
 802432c: 611a         	str	r2, [r3, #0x10]
; 	data->targetYSpeed = y_speed;
 802432e: 697b         	ldr	r3, [r7, #0x14]
 8024330: 687a         	ldr	r2, [r7, #0x4]
 8024332: 615a         	str	r2, [r3, #0x14]
; 	data->angleControl = false;
 8024334: 697b         	ldr	r3, [r7, #0x14]
 8024336: 2200         	movs	r2, #0x0
 8024338: f883 2028    	strb.w	r2, [r3, #0x28]
; }
 802433c: bf00         	nop
 802433e: 371c         	adds	r7, #0x1c
 8024340: 46bd         	mov	sp, r7
 8024342: f85d 7b04    	ldr	r7, [sp], #4
 8024346: 4770         	bx	lr

08024348 <swchassis_set_gyro>:
; {
 8024348: b480         	push	{r7}
 802434a: b085         	sub	sp, #0x14
 802434c: af00         	add	r7, sp, #0x0
 802434e: 6078         	str	r0, [r7, #0x4]
 8024350: ed87 0a00    	vstr	s0, [r7]
; 	chassis_data_t *data = dev->data;
 8024354: 687b         	ldr	r3, [r7, #0x4]
 8024356: 691b         	ldr	r3, [r3, #0x10]
 8024358: 60fb         	str	r3, [r7, #0xc]
; 	data->targetGyro = gyro;
 802435a: 68fb         	ldr	r3, [r7, #0xc]
 802435c: 683a         	ldr	r2, [r7]
 802435e: 609a         	str	r2, [r3, #0x8]
; 	data->angleControl = false;
 8024360: 68fb         	ldr	r3, [r7, #0xc]
 8024362: 2200         	movs	r2, #0x0
 8024364: f883 2028    	strb.w	r2, [r3, #0x28]
; }
 8024368: bf00         	nop
 802436a: 3714         	adds	r7, #0x14
 802436c: 46bd         	mov	sp, r7
 802436e: f85d 7b04    	ldr	r7, [sp], #4
 8024372: 4770         	bx	lr

08024374 <swchassis_get_status>:
; {
 8024374: b480         	push	{r7}
 8024376: b085         	sub	sp, #0x14
 8024378: af00         	add	r7, sp, #0x0
 802437a: 6078         	str	r0, [r7, #0x4]
; 	chassis_data_t *data = dev->data;
 802437c: 687b         	ldr	r3, [r7, #0x4]
 802437e: 691b         	ldr	r3, [r3, #0x10]
 8024380: 60fb         	str	r3, [r7, #0xc]
; 	return &data->chassis_status;
 8024382: 68fb         	ldr	r3, [r7, #0xc]
 8024384: 334c         	adds	r3, #0x4c
; }
 8024386: 4618         	mov	r0, r3
 8024388: 3714         	adds	r7, #0x14
 802438a: 46bd         	mov	sp, r7
 802438c: f85d 7b04    	ldr	r7, [sp], #4
 8024390: 4770         	bx	lr

08024392 <LL_DMA_Init>:
; {
 8024392: b580         	push	{r7, lr}
 8024394: b084         	sub	sp, #0x10
 8024396: af00         	add	r7, sp, #0x0
 8024398: 60f8         	str	r0, [r7, #0xc]
 802439a: 60b9         	str	r1, [r7, #0x8]
 802439c: 607a         	str	r2, [r7, #0x4]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 802439e: 687b         	ldr	r3, [r7, #0x4]
 80243a0: 689a         	ldr	r2, [r3, #0x8]
;                         DMA_InitStruct->Mode                    | \
 80243a2: 687b         	ldr	r3, [r7, #0x4]
 80243a4: 68db         	ldr	r3, [r3, #0xc]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 80243a6: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 80243a8: 687b         	ldr	r3, [r7, #0x4]
 80243aa: 691b         	ldr	r3, [r3, #0x10]
;                         DMA_InitStruct->Mode                    | \
 80243ac: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 80243ae: 687b         	ldr	r3, [r7, #0x4]
 80243b0: 695b         	ldr	r3, [r3, #0x14]
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 80243b2: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 80243b4: 687b         	ldr	r3, [r7, #0x4]
 80243b6: 699b         	ldr	r3, [r3, #0x18]
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 80243b8: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstDataSize  | \
 80243ba: 687b         	ldr	r3, [r7, #0x4]
 80243bc: 69db         	ldr	r3, [r3, #0x1c]
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 80243be: 431a         	orrs	r2, r3
;                         DMA_InitStruct->Priority
 80243c0: 687b         	ldr	r3, [r7, #0x4]
 80243c2: 6a9b         	ldr	r3, [r3, #0x28]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 80243c4: 4313         	orrs	r3, r2
 80243c6: 461a         	mov	r2, r3
 80243c8: 68b9         	ldr	r1, [r7, #0x8]
 80243ca: 68f8         	ldr	r0, [r7, #0xc]
 80243cc: f7ee fb00    	bl	0x80129d0 <LL_DMA_ConfigTransfer> @ imm = #-0x11a00
;   if(DMA_InitStruct->FIFOMode != LL_DMA_FIFOMODE_DISABLE)
 80243d0: 687b         	ldr	r3, [r7, #0x4]
 80243d2: 6adb         	ldr	r3, [r3, #0x2c]
 80243d4: 2b00         	cmp	r3, #0x0
 80243d6: d015         	beq	0x8024404 <LL_DMA_Init+0x72> @ imm = #0x2a
;     LL_DMA_ConfigFifo(DMAx, Stream, DMA_InitStruct->FIFOMode, DMA_InitStruct->FIFOThreshold);
 80243d8: 687b         	ldr	r3, [r7, #0x4]
 80243da: 6ada         	ldr	r2, [r3, #0x2c]
 80243dc: 687b         	ldr	r3, [r7, #0x4]
 80243de: 6b1b         	ldr	r3, [r3, #0x30]
 80243e0: 68b9         	ldr	r1, [r7, #0x8]
 80243e2: 68f8         	ldr	r0, [r7, #0xc]
 80243e4: f7ee fbaa    	bl	0x8012b3c <LL_DMA_ConfigFifo> @ imm = #-0x118ac
;     LL_DMA_SetMemoryBurstxfer(DMAx,Stream,DMA_InitStruct->MemBurst);
 80243e8: 687b         	ldr	r3, [r7, #0x4]
 80243ea: 6b5b         	ldr	r3, [r3, #0x34]
 80243ec: 461a         	mov	r2, r3
 80243ee: 68b9         	ldr	r1, [r7, #0x8]
 80243f0: 68f8         	ldr	r0, [r7, #0xc]
 80243f2: f7ee fb5b    	bl	0x8012aac <LL_DMA_SetMemoryBurstxfer> @ imm = #-0x1194a
;     LL_DMA_SetPeriphBurstxfer(DMAx,Stream,DMA_InitStruct->PeriphBurst);
 80243f6: 687b         	ldr	r3, [r7, #0x4]
 80243f8: 6b9b         	ldr	r3, [r3, #0x38]
 80243fa: 461a         	mov	r2, r3
 80243fc: 68b9         	ldr	r1, [r7, #0x8]
 80243fe: 68f8         	ldr	r0, [r7, #0xc]
 8024400: f7ee fb78    	bl	0x8012af4 <LL_DMA_SetPeriphBurstxfer> @ imm = #-0x11910
;   LL_DMA_SetMemoryAddress(DMAx, Stream, DMA_InitStruct->MemoryOrM2MDstAddress);
 8024404: 687b         	ldr	r3, [r7, #0x4]
 8024406: 685b         	ldr	r3, [r3, #0x4]
 8024408: 461a         	mov	r2, r3
 802440a: 68b9         	ldr	r1, [r7, #0x8]
 802440c: 68f8         	ldr	r0, [r7, #0xc]
 802440e: f7ee fbbb    	bl	0x8012b88 <LL_DMA_SetMemoryAddress> @ imm = #-0x1188a
;   LL_DMA_SetPeriphAddress(DMAx, Stream, DMA_InitStruct->PeriphOrM2MSrcAddress);
 8024412: 687b         	ldr	r3, [r7, #0x4]
 8024414: 681b         	ldr	r3, [r3]
 8024416: 461a         	mov	r2, r3
 8024418: 68b9         	ldr	r1, [r7, #0x8]
 802441a: 68f8         	ldr	r0, [r7, #0xc]
 802441c: f7ee fbcc    	bl	0x8012bb8 <LL_DMA_SetPeriphAddress> @ imm = #-0x11868
;   LL_DMA_SetDataLength(DMAx, Stream, DMA_InitStruct->NbData);
 8024420: 687b         	ldr	r3, [r7, #0x4]
 8024422: 6a1b         	ldr	r3, [r3, #0x20]
 8024424: 461a         	mov	r2, r3
 8024426: 68b9         	ldr	r1, [r7, #0x8]
 8024428: 68f8         	ldr	r0, [r7, #0xc]
 802442a: f7ee faf7    	bl	0x8012a1c <LL_DMA_SetDataLength> @ imm = #-0x11a12
;   LL_DMA_SetChannelSelection(DMAx, Stream, DMA_InitStruct->Channel);
 802442e: 687b         	ldr	r3, [r7, #0x4]
 8024430: 6a5b         	ldr	r3, [r3, #0x24]
 8024432: 461a         	mov	r2, r3
 8024434: 68b9         	ldr	r1, [r7, #0x8]
 8024436: 68f8         	ldr	r0, [r7, #0xc]
 8024438: f7ee fb14    	bl	0x8012a64 <LL_DMA_SetChannelSelection> @ imm = #-0x119d8
;   return SUCCESS;
 802443c: 2300         	movs	r3, #0x0
; }
 802443e: 4618         	mov	r0, r3
 8024440: 3710         	adds	r7, #0x10
 8024442: 46bd         	mov	sp, r7
 8024444: bd80         	pop	{r7, pc}

08024446 <LL_DMA_StructInit>:
; {
 8024446: b480         	push	{r7}
 8024448: b083         	sub	sp, #0xc
 802444a: af00         	add	r7, sp, #0x0
 802444c: 6078         	str	r0, [r7, #0x4]
;   DMA_InitStruct->PeriphOrM2MSrcAddress  = 0x00000000U;
 802444e: 687b         	ldr	r3, [r7, #0x4]
 8024450: 2200         	movs	r2, #0x0
 8024452: 601a         	str	r2, [r3]
;   DMA_InitStruct->MemoryOrM2MDstAddress  = 0x00000000U;
 8024454: 687b         	ldr	r3, [r7, #0x4]
 8024456: 2200         	movs	r2, #0x0
 8024458: 605a         	str	r2, [r3, #0x4]
;   DMA_InitStruct->Direction              = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 802445a: 687b         	ldr	r3, [r7, #0x4]
 802445c: 2200         	movs	r2, #0x0
 802445e: 609a         	str	r2, [r3, #0x8]
;   DMA_InitStruct->Mode                   = LL_DMA_MODE_NORMAL;
 8024460: 687b         	ldr	r3, [r7, #0x4]
 8024462: 2200         	movs	r2, #0x0
 8024464: 60da         	str	r2, [r3, #0xc]
;   DMA_InitStruct->PeriphOrM2MSrcIncMode  = LL_DMA_PERIPH_NOINCREMENT;
 8024466: 687b         	ldr	r3, [r7, #0x4]
 8024468: 2200         	movs	r2, #0x0
 802446a: 611a         	str	r2, [r3, #0x10]
;   DMA_InitStruct->MemoryOrM2MDstIncMode  = LL_DMA_MEMORY_NOINCREMENT;
 802446c: 687b         	ldr	r3, [r7, #0x4]
 802446e: 2200         	movs	r2, #0x0
 8024470: 615a         	str	r2, [r3, #0x14]
;   DMA_InitStruct->PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;
 8024472: 687b         	ldr	r3, [r7, #0x4]
 8024474: 2200         	movs	r2, #0x0
 8024476: 619a         	str	r2, [r3, #0x18]
;   DMA_InitStruct->MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;
 8024478: 687b         	ldr	r3, [r7, #0x4]
 802447a: 2200         	movs	r2, #0x0
 802447c: 61da         	str	r2, [r3, #0x1c]
;   DMA_InitStruct->NbData                 = 0x00000000U;
 802447e: 687b         	ldr	r3, [r7, #0x4]
 8024480: 2200         	movs	r2, #0x0
 8024482: 621a         	str	r2, [r3, #0x20]
;   DMA_InitStruct->Channel                = LL_DMA_CHANNEL_0;
 8024484: 687b         	ldr	r3, [r7, #0x4]
 8024486: 2200         	movs	r2, #0x0
 8024488: 625a         	str	r2, [r3, #0x24]
;   DMA_InitStruct->Priority               = LL_DMA_PRIORITY_LOW;
 802448a: 687b         	ldr	r3, [r7, #0x4]
 802448c: 2200         	movs	r2, #0x0
 802448e: 629a         	str	r2, [r3, #0x28]
;   DMA_InitStruct->FIFOMode               = LL_DMA_FIFOMODE_DISABLE;
 8024490: 687b         	ldr	r3, [r7, #0x4]
 8024492: 2200         	movs	r2, #0x0
 8024494: 62da         	str	r2, [r3, #0x2c]
;   DMA_InitStruct->FIFOThreshold          = LL_DMA_FIFOTHRESHOLD_1_4;
 8024496: 687b         	ldr	r3, [r7, #0x4]
 8024498: 2200         	movs	r2, #0x0
 802449a: 631a         	str	r2, [r3, #0x30]
;   DMA_InitStruct->MemBurst               = LL_DMA_MBURST_SINGLE;
 802449c: 687b         	ldr	r3, [r7, #0x4]
 802449e: 2200         	movs	r2, #0x0
 80244a0: 635a         	str	r2, [r3, #0x34]
;   DMA_InitStruct->PeriphBurst            = LL_DMA_PBURST_SINGLE;
 80244a2: 687b         	ldr	r3, [r7, #0x4]
 80244a4: 2200         	movs	r2, #0x0
 80244a6: 639a         	str	r2, [r3, #0x38]
; }
 80244a8: bf00         	nop
 80244aa: 370c         	adds	r7, #0xc
 80244ac: 46bd         	mov	sp, r7
 80244ae: f85d 7b04    	ldr	r7, [sp], #4
 80244b2: 4770         	bx	lr

080244b4 <arch_k_cycle_get_32>:
; {
 80244b4: b580         	push	{r7, lr}
 80244b6: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 80244b8: f7ea fffa    	bl	0x800f4b0 <sys_clock_cycle_get_32> @ imm = #-0x1500c
 80244bc: 4603         	mov	r3, r0
; }
 80244be: 4618         	mov	r0, r3
 80244c0: bd80         	pop	{r7, pc}

080244c2 <k_cycle_get_32>:
; {
 80244c2: b580         	push	{r7, lr}
 80244c4: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 80244c6: f7ff fff5    	bl	0x80244b4 <arch_k_cycle_get_32> @ imm = #-0x16
 80244ca: 4603         	mov	r3, r0
; }
 80244cc: 4618         	mov	r0, r3
 80244ce: bd80         	pop	{r7, pc}

080244d0 <z_impl_k_busy_wait>:
; {
 80244d0: b580         	push	{r7, lr}
 80244d2: b086         	sub	sp, #0x18
 80244d4: af00         	add	r7, sp, #0x0
 80244d6: 6078         	str	r0, [r7, #0x4]
; 	if (usec_to_wait == 0U) {
 80244d8: 687b         	ldr	r3, [r7, #0x4]
 80244da: 2b00         	cmp	r3, #0x0
 80244dc: d011         	beq	0x8024502 <z_impl_k_busy_wait+0x32> @ imm = #0x22
; 	uint32_t start_cycles = k_cycle_get_32();
 80244de: f7ff fff0    	bl	0x80244c2 <k_cycle_get_32> @ imm = #-0x20
 80244e2: 6178         	str	r0, [r7, #0x14]
; 	uint32_t cycles_to_wait = k_us_to_cyc_ceil32(usec_to_wait);
 80244e4: 687b         	ldr	r3, [r7, #0x4]
 80244e6: 22a8         	movs	r2, #0xa8
 80244e8: fb02 f303    	mul	r3, r2, r3
 80244ec: 613b         	str	r3, [r7, #0x10]
; 		uint32_t current_cycles = k_cycle_get_32();
 80244ee: f7ff ffe8    	bl	0x80244c2 <k_cycle_get_32> @ imm = #-0x30
 80244f2: 60f8         	str	r0, [r7, #0xc]
; 		if ((current_cycles - start_cycles) >= cycles_to_wait) {
 80244f4: 68fa         	ldr	r2, [r7, #0xc]
 80244f6: 697b         	ldr	r3, [r7, #0x14]
 80244f8: 1ad3         	subs	r3, r2, r3
 80244fa: 693a         	ldr	r2, [r7, #0x10]
 80244fc: 429a         	cmp	r2, r3
 80244fe: d902         	bls	0x8024506 <z_impl_k_busy_wait+0x36> @ imm = #0x4
; 	for (;;) {
 8024500: e7f5         	b	0x80244ee <z_impl_k_busy_wait+0x1e> @ imm = #-0x16
; 		return;
 8024502: bf00         	nop
 8024504: e000         	b	0x8024508 <z_impl_k_busy_wait+0x38> @ imm = #0x0
; 			break;
 8024506: bf00         	nop
; }
 8024508: 3718         	adds	r7, #0x18
 802450a: 46bd         	mov	sp, r7
 802450c: bd80         	pop	{r7, pc}

0802450e <k_object_init>:
; {
 802450e: b480         	push	{r7}
 8024510: b083         	sub	sp, #0xc
 8024512: af00         	add	r7, sp, #0x0
 8024514: 6078         	str	r0, [r7, #0x4]
; }
 8024516: bf00         	nop
 8024518: 370c         	adds	r7, #0xc
 802451a: 46bd         	mov	sp, r7
 802451c: f85d 7b04    	ldr	r7, [sp], #4
 8024520: 4770         	bx	lr

08024522 <z_impl_device_is_ready>:
; {
 8024522: b480         	push	{r7}
 8024524: b083         	sub	sp, #0xc
 8024526: af00         	add	r7, sp, #0x0
 8024528: 6078         	str	r0, [r7, #0x4]
; 	if (dev == NULL) {
 802452a: 687b         	ldr	r3, [r7, #0x4]
 802452c: 2b00         	cmp	r3, #0x0
 802452e: d101         	bne	0x8024534 <z_impl_device_is_ready+0x12> @ imm = #0x2
; 		return false;
 8024530: 2300         	movs	r3, #0x0
 8024532: e012         	b	0x802455a <z_impl_device_is_ready+0x38> @ imm = #0x24
; 	return dev->state->initialized && (dev->state->init_res == 0U);
 8024534: 687b         	ldr	r3, [r7, #0x4]
 8024536: 68db         	ldr	r3, [r3, #0xc]
 8024538: 785b         	ldrb	r3, [r3, #0x1]
 802453a: f003 0301    	and	r3, r3, #0x1
 802453e: b2db         	uxtb	r3, r3
 8024540: 2b00         	cmp	r3, #0x0
 8024542: d006         	beq	0x8024552 <z_impl_device_is_ready+0x30> @ imm = #0xc
 8024544: 687b         	ldr	r3, [r7, #0x4]
 8024546: 68db         	ldr	r3, [r3, #0xc]
 8024548: 781b         	ldrb	r3, [r3]
 802454a: 2b00         	cmp	r3, #0x0
 802454c: d101         	bne	0x8024552 <z_impl_device_is_ready+0x30> @ imm = #0x2
 802454e: 2301         	movs	r3, #0x1
 8024550: e000         	b	0x8024554 <z_impl_device_is_ready+0x32> @ imm = #0x0
 8024552: 2300         	movs	r3, #0x0
 8024554: f003 0301    	and	r3, r3, #0x1
 8024558: b2db         	uxtb	r3, r3
; }
 802455a: 4618         	mov	r0, r3
 802455c: 370c         	adds	r7, #0xc
 802455e: 46bd         	mov	sp, r7
 8024560: f85d 7b04    	ldr	r7, [sp], #4
 8024564: 4770         	bx	lr

08024566 <k_thread_abort>:
; {
 8024566: b580         	push	{r7, lr}
 8024568: b082         	sub	sp, #0x8
 802456a: af00         	add	r7, sp, #0x0
 802456c: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 802456e: 6878         	ldr	r0, [r7, #0x4]
 8024570: f7e1 ff0e    	bl	0x8006390 <z_impl_k_thread_abort> @ imm = #-0x1e1e4
; }
 8024574: bf00         	nop
 8024576: 3708         	adds	r7, #0x8
 8024578: 46bd         	mov	sp, r7
 802457a: bd80         	pop	{r7, pc}

0802457c <z_log_msg_runtime_create>:
; {
 802457c: b580         	push	{r7, lr}
 802457e: b08a         	sub	sp, #0x28
 8024580: af04         	add	r7, sp, #0x10
 8024582: 60b9         	str	r1, [r7, #0x8]
 8024584: 607b         	str	r3, [r7, #0x4]
 8024586: 4603         	mov	r3, r0
 8024588: 73fb         	strb	r3, [r7, #0xf]
 802458a: 4613         	mov	r3, r2
 802458c: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 802458e: f107 032c    	add.w	r3, r7, #0x2c
 8024592: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8024594: 7bba         	ldrb	r2, [r7, #0xe]
 8024596: 7bf8         	ldrb	r0, [r7, #0xf]
 8024598: 697b         	ldr	r3, [r7, #0x14]
 802459a: 9303         	str	r3, [sp, #0xc]
 802459c: 6abb         	ldr	r3, [r7, #0x28]
 802459e: 9302         	str	r3, [sp, #0x8]
 80245a0: 6a7b         	ldr	r3, [r7, #0x24]
 80245a2: 9301         	str	r3, [sp, #0x4]
 80245a4: 6a3b         	ldr	r3, [r7, #0x20]
 80245a6: 9300         	str	r3, [sp]
 80245a8: 687b         	ldr	r3, [r7, #0x4]
 80245aa: 68b9         	ldr	r1, [r7, #0x8]
 80245ac: f7e0 faca    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x1fa6c
; }
 80245b0: bf00         	nop
 80245b2: 3718         	adds	r7, #0x18
 80245b4: 46bd         	mov	sp, r7
 80245b6: bd80         	pop	{r7, pc}

080245b8 <log_panic>:
; {
 80245b8: b580         	push	{r7, lr}
 80245ba: af00         	add	r7, sp, #0x0
; 	z_impl_log_panic();
 80245bc: f7e0 f948    	bl	0x8004850 <z_impl_log_panic> @ imm = #-0x1fd70
; }
 80245c0: bf00         	nop
 80245c2: bd80         	pop	{r7, pc}

080245c4 <coredump>:
; {
 80245c4: b480         	push	{r7}
 80245c6: b085         	sub	sp, #0x14
 80245c8: af00         	add	r7, sp, #0x0
 80245ca: 60f8         	str	r0, [r7, #0xc]
 80245cc: 60b9         	str	r1, [r7, #0x8]
 80245ce: 607a         	str	r2, [r7, #0x4]
; }
 80245d0: bf00         	nop
 80245d2: 3714         	adds	r7, #0x14
 80245d4: 46bd         	mov	sp, r7
 80245d6: f85d 7b04    	ldr	r7, [sp], #4
 80245da: 4770         	bx	lr

080245dc <arch_system_halt>:
; {
 80245dc: b480         	push	{r7}
 80245de: b087         	sub	sp, #0x1c
 80245e0: af00         	add	r7, sp, #0x0
 80245e2: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80245e4: f3ef 8311    	mrs	r3, basepri
 80245e8: 617b         	str	r3, [r7, #0x14]
;   return(result);
 80245ea: 697b         	ldr	r3, [r7, #0x14]
; 	key = __get_BASEPRI();
 80245ec: 613b         	str	r3, [r7, #0x10]
 80245ee: 2310         	movs	r3, #0x10
 80245f0: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80245f2: 68fb         	ldr	r3, [r7, #0xc]
 80245f4: f383 8812    	msr	basepri_max, r3
; }
 80245f8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80245fa: f3bf 8f6f    	isb	sy
; }
 80245fe: bf00         	nop
; 	for (;;) {
 8024600: bf00         	nop
 8024602: e7fd         	b	0x8024600 <arch_system_halt+0x24> @ imm = #-0x6

08024604 <K_KERNEL_STACK_BUFFER>:
; {
 8024604: b480         	push	{r7}
 8024606: b083         	sub	sp, #0xc
 8024608: af00         	add	r7, sp, #0x0
 802460a: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 802460c: 687b         	ldr	r3, [r7, #0x4]
; }
 802460e: 4618         	mov	r0, r3
 8024610: 370c         	adds	r7, #0xc
 8024612: 46bd         	mov	sp, r7
 8024614: f85d 7b04    	ldr	r7, [sp], #4
 8024618: 4770         	bx	lr

0802461a <k_thread_start>:
; {
 802461a: b580         	push	{r7, lr}
 802461c: b082         	sub	sp, #0x8
 802461e: af00         	add	r7, sp, #0x0
 8024620: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 8024622: 6878         	ldr	r0, [r7, #0x4]
 8024624: f000 f804    	bl	0x8024630 <k_thread_resume> @ imm = #0x8
; }
 8024628: bf00         	nop
 802462a: 3708         	adds	r7, #0x8
 802462c: 46bd         	mov	sp, r7
 802462e: bd80         	pop	{r7, pc}

08024630 <k_thread_resume>:
; {
 8024630: b580         	push	{r7, lr}
 8024632: b082         	sub	sp, #0x8
 8024634: af00         	add	r7, sp, #0x0
 8024636: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 8024638: 6878         	ldr	r0, [r7, #0x4]
 802463a: f7f0 ffa9    	bl	0x8015590 <z_impl_k_thread_resume> @ imm = #-0xf0ae
; }
 802463e: bf00         	nop
 8024640: 3708         	adds	r7, #0x8
 8024642: 46bd         	mov	sp, r7
 8024644: bd80         	pop	{r7, pc}

08024646 <thread_schedule_new>:
; {
 8024646: b580         	push	{r7, lr}
 8024648: b084         	sub	sp, #0x10
 802464a: af00         	add	r7, sp, #0x0
 802464c: 60f8         	str	r0, [r7, #0xc]
 802464e: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 8024652: e9d7 2300    	ldrd	r2, r3, [r7]
 8024656: f04f 0000    	mov.w	r0, #0x0
 802465a: f04f 0100    	mov.w	r1, #0x0
 802465e: 428b         	cmp	r3, r1
 8024660: bf08         	it	eq
 8024662: 4282         	cmpeq	r2, r0
 8024664: d103         	bne	0x802466e <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 8024666: 68f8         	ldr	r0, [r7, #0xc]
 8024668: f7ff ffd7    	bl	0x802461a <k_thread_start> @ imm = #-0x52
 802466c: e004         	b	0x8024678 <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 802466e: e9d7 2300    	ldrd	r2, r3, [r7]
 8024672: 68f8         	ldr	r0, [r7, #0xc]
 8024674: f7ee fcfe    	bl	0x8013074 <z_add_thread_timeout> @ imm = #-0x11604
; }
 8024678: bf00         	nop
 802467a: 3710         	adds	r7, #0x10
 802467c: 46bd         	mov	sp, r7
 802467e: bd80         	pop	{r7, pc}

08024680 <z_mark_thread_as_not_suspended>:
; {
 8024680: b480         	push	{r7}
 8024682: b083         	sub	sp, #0xc
 8024684: af00         	add	r7, sp, #0x0
 8024686: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 8024688: 687b         	ldr	r3, [r7, #0x4]
 802468a: 7b5b         	ldrb	r3, [r3, #0xd]
 802468c: f023 0310    	bic	r3, r3, #0x10
 8024690: b2da         	uxtb	r2, r3
 8024692: 687b         	ldr	r3, [r7, #0x4]
 8024694: 735a         	strb	r2, [r3, #0xd]
; }
 8024696: bf00         	nop
 8024698: 370c         	adds	r7, #0xc
 802469a: 46bd         	mov	sp, r7
 802469c: f85d 7b04    	ldr	r7, [sp], #4
 80246a0: 4770         	bx	lr

080246a2 <z_thread_essential_clear>:
; {
 80246a2: b480         	push	{r7}
 80246a4: b083         	sub	sp, #0xc
 80246a6: af00         	add	r7, sp, #0x0
 80246a8: 6078         	str	r0, [r7, #0x4]
; 	thread->base.user_options &= ~K_ESSENTIAL;
 80246aa: 687b         	ldr	r3, [r7, #0x4]
 80246ac: 7b1b         	ldrb	r3, [r3, #0xc]
 80246ae: f023 0301    	bic	r3, r3, #0x1
 80246b2: b2da         	uxtb	r2, r3
 80246b4: 687b         	ldr	r3, [r7, #0x4]
 80246b6: 731a         	strb	r2, [r3, #0xc]
; }
 80246b8: bf00         	nop
 80246ba: 370c         	adds	r7, #0xc
 80246bc: 46bd         	mov	sp, r7
 80246be: f85d 7b04    	ldr	r7, [sp], #4
 80246c2: 4770         	bx	lr

080246c4 <gcov_static_init>:
; static inline void gcov_static_init(void) { }
 80246c4: b480         	push	{r7}
 80246c6: af00         	add	r7, sp, #0x0
 80246c8: bf00         	nop
 80246ca: 46bd         	mov	sp, r7
 80246cc: f85d 7b04    	ldr	r7, [sp], #4
 80246d0: 4770         	bx	lr

080246d2 <pm_device_runtime_auto_enable>:
; {
 80246d2: b480         	push	{r7}
 80246d4: b083         	sub	sp, #0xc
 80246d6: af00         	add	r7, sp, #0x0
 80246d8: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80246da: 2300         	movs	r3, #0x0
; }
 80246dc: 4618         	mov	r0, r3
 80246de: 370c         	adds	r7, #0xc
 80246e0: 46bd         	mov	sp, r7
 80246e2: f85d 7b04    	ldr	r7, [sp], #4
 80246e6: 4770         	bx	lr

080246e8 <z_early_memset>:
; {
 80246e8: b580         	push	{r7, lr}
 80246ea: b084         	sub	sp, #0x10
 80246ec: af00         	add	r7, sp, #0x0
 80246ee: 60f8         	str	r0, [r7, #0xc]
 80246f0: 60b9         	str	r1, [r7, #0x8]
 80246f2: 607a         	str	r2, [r7, #0x4]
; 	(void) memset(dst, c, n);
 80246f4: 687a         	ldr	r2, [r7, #0x4]
 80246f6: 68b9         	ldr	r1, [r7, #0x8]
 80246f8: 68f8         	ldr	r0, [r7, #0xc]
 80246fa: f002 ff05    	bl	0x8027508 <memset>      @ imm = #0x2e0a
; }
 80246fe: bf00         	nop
 8024700: 3710         	adds	r7, #0x10
 8024702: 46bd         	mov	sp, r7
 8024704: bd80         	pop	{r7, pc}

08024706 <z_early_memcpy>:
; {
 8024706: b580         	push	{r7, lr}
 8024708: b084         	sub	sp, #0x10
 802470a: af00         	add	r7, sp, #0x0
 802470c: 60f8         	str	r0, [r7, #0xc]
 802470e: 60b9         	str	r1, [r7, #0x8]
 8024710: 607a         	str	r2, [r7, #0x4]
; 	(void) memcpy(dst, src, n);
 8024712: 687a         	ldr	r2, [r7, #0x4]
 8024714: 68b9         	ldr	r1, [r7, #0x8]
 8024716: 68f8         	ldr	r0, [r7, #0xc]
 8024718: f002 fee8    	bl	0x80274ec <memcpy>      @ imm = #0x2dd0
; }
 802471c: bf00         	nop
 802471e: 3710         	adds	r7, #0x10
 8024720: 46bd         	mov	sp, r7
 8024722: bd80         	pop	{r7, pc}

08024724 <do_device_init>:
; {
 8024724: b580         	push	{r7, lr}
 8024726: b084         	sub	sp, #0x10
 8024728: af00         	add	r7, sp, #0x0
 802472a: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = entry->dev;
 802472c: 687b         	ldr	r3, [r7, #0x4]
 802472e: 685b         	ldr	r3, [r3, #0x4]
 8024730: 60bb         	str	r3, [r7, #0x8]
; 	int rc = 0;
 8024732: 2300         	movs	r3, #0x0
 8024734: 60fb         	str	r3, [r7, #0xc]
; 	if (entry->init_fn.dev != NULL) {
 8024736: 687b         	ldr	r3, [r7, #0x4]
 8024738: 681b         	ldr	r3, [r3]
 802473a: 2b00         	cmp	r3, #0x0
 802473c: d017         	beq	0x802476e <do_device_init+0x4a> @ imm = #0x2e
; 		rc = entry->init_fn.dev(dev);
 802473e: 687b         	ldr	r3, [r7, #0x4]
 8024740: 681b         	ldr	r3, [r3]
 8024742: 68b8         	ldr	r0, [r7, #0x8]
 8024744: 4798         	blx	r3
 8024746: 60f8         	str	r0, [r7, #0xc]
; 		if (rc != 0) {
 8024748: 68fb         	ldr	r3, [r7, #0xc]
 802474a: 2b00         	cmp	r3, #0x0
 802474c: d00f         	beq	0x802476e <do_device_init+0x4a> @ imm = #0x1e
; 			if (rc < 0) {
 802474e: 68fb         	ldr	r3, [r7, #0xc]
 8024750: 2b00         	cmp	r3, #0x0
 8024752: da02         	bge	0x802475a <do_device_init+0x36> @ imm = #0x4
; 				rc = -rc;
 8024754: 68fb         	ldr	r3, [r7, #0xc]
 8024756: 425b         	rsbs	r3, r3, #0
 8024758: 60fb         	str	r3, [r7, #0xc]
; 			if (rc > UINT8_MAX) {
 802475a: 68fb         	ldr	r3, [r7, #0xc]
 802475c: 2bff         	cmp	r3, #0xff
 802475e: dd01         	ble	0x8024764 <do_device_init+0x40> @ imm = #0x2
; 				rc = UINT8_MAX;
 8024760: 23ff         	movs	r3, #0xff
 8024762: 60fb         	str	r3, [r7, #0xc]
; 			dev->state->init_res = rc;
 8024764: 68bb         	ldr	r3, [r7, #0x8]
 8024766: 68db         	ldr	r3, [r3, #0xc]
 8024768: 68fa         	ldr	r2, [r7, #0xc]
 802476a: b2d2         	uxtb	r2, r2
 802476c: 701a         	strb	r2, [r3]
; 	dev->state->initialized = true;
 802476e: 68bb         	ldr	r3, [r7, #0x8]
 8024770: 68da         	ldr	r2, [r3, #0xc]
 8024772: 7853         	ldrb	r3, [r2, #0x1]
 8024774: f043 0301    	orr	r3, r3, #0x1
 8024778: 7053         	strb	r3, [r2, #0x1]
; 	if (rc == 0) {
 802477a: 68fb         	ldr	r3, [r7, #0xc]
 802477c: 2b00         	cmp	r3, #0x0
 802477e: d102         	bne	0x8024786 <do_device_init+0x62> @ imm = #0x4
; 		(void)pm_device_runtime_auto_enable(dev);
 8024780: 68b8         	ldr	r0, [r7, #0x8]
 8024782: f7ff ffa6    	bl	0x80246d2 <pm_device_runtime_auto_enable> @ imm = #-0xb4
; 	return rc;
 8024786: 68fb         	ldr	r3, [r7, #0xc]
; }
 8024788: 4618         	mov	r0, r3
 802478a: 3710         	adds	r7, #0x10
 802478c: 46bd         	mov	sp, r7
 802478e: bd80         	pop	{r7, pc}

08024790 <z_init_static>:
; {
 8024790: b480         	push	{r7}
 8024792: af00         	add	r7, sp, #0x0
; }
 8024794: bf00         	nop
 8024796: 46bd         	mov	sp, r7
 8024798: f85d 7b04    	ldr	r7, [sp], #4
 802479c: 4770         	bx	lr

0802479e <sys_dlist_init>:
; {
 802479e: b480         	push	{r7}
 80247a0: b083         	sub	sp, #0xc
 80247a2: af00         	add	r7, sp, #0x0
 80247a4: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 80247a6: 687b         	ldr	r3, [r7, #0x4]
 80247a8: 687a         	ldr	r2, [r7, #0x4]
 80247aa: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 80247ac: 687b         	ldr	r3, [r7, #0x4]
 80247ae: 687a         	ldr	r2, [r7, #0x4]
 80247b0: 605a         	str	r2, [r3, #0x4]
; }
 80247b2: bf00         	nop
 80247b4: 370c         	adds	r7, #0xc
 80247b6: 46bd         	mov	sp, r7
 80247b8: f85d 7b04    	ldr	r7, [sp], #4
 80247bc: 4770         	bx	lr

080247be <z_waitq_init>:
; {
 80247be: b580         	push	{r7, lr}
 80247c0: b082         	sub	sp, #0x8
 80247c2: af00         	add	r7, sp, #0x0
 80247c4: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 80247c6: 687b         	ldr	r3, [r7, #0x4]
 80247c8: 4618         	mov	r0, r3
 80247ca: f7ff ffe8    	bl	0x802479e <sys_dlist_init> @ imm = #-0x30
; }
 80247ce: bf00         	nop
 80247d0: 3708         	adds	r7, #0x8
 80247d2: 46bd         	mov	sp, r7
 80247d4: bd80         	pop	{r7, pc}

080247d6 <k_heap_init>:
; {
 80247d6: b580         	push	{r7, lr}
 80247d8: b084         	sub	sp, #0x10
 80247da: af00         	add	r7, sp, #0x0
 80247dc: 60f8         	str	r0, [r7, #0xc]
 80247de: 60b9         	str	r1, [r7, #0x8]
 80247e0: 607a         	str	r2, [r7, #0x4]
; 	z_waitq_init(&heap->wait_q);
 80247e2: 68fb         	ldr	r3, [r7, #0xc]
 80247e4: 330c         	adds	r3, #0xc
 80247e6: 4618         	mov	r0, r3
 80247e8: f7ff ffe9    	bl	0x80247be <z_waitq_init> @ imm = #-0x2e
; 	sys_heap_init(&heap->heap, mem, bytes);
 80247ec: 68fb         	ldr	r3, [r7, #0xc]
 80247ee: 687a         	ldr	r2, [r7, #0x4]
 80247f0: 68b9         	ldr	r1, [r7, #0x8]
 80247f2: 4618         	mov	r0, r3
 80247f4: f7f6 fcc0    	bl	0x801b178 <sys_heap_init> @ imm = #-0x9680
; }
 80247f8: bf00         	nop
 80247fa: 3710         	adds	r7, #0x10
 80247fc: 46bd         	mov	sp, r7
 80247fe: bd80         	pop	{r7, pc}

08024800 <k_heap_aligned_alloc>:
; {
 8024800: b580         	push	{r7, lr}
 8024802: b09e         	sub	sp, #0x78
 8024804: af02         	add	r7, sp, #0x8
 8024806: 60f8         	str	r0, [r7, #0xc]
 8024808: 60b9         	str	r1, [r7, #0x8]
 802480a: 607a         	str	r2, [r7, #0x4]
; 	k_timepoint_t end = sys_timepoint_calc(timeout);
 802480c: f107 0120    	add.w	r1, r7, #0x20
 8024810: e9d7 231e    	ldrd	r2, r3, [r7, #120]
 8024814: 4608         	mov	r0, r1
 8024816: f002 fbf1    	bl	0x8026ffc <sys_timepoint_calc> @ imm = #0x27e2
; 	void *ret = NULL;
 802481a: 2300         	movs	r3, #0x0
 802481c: 66fb         	str	r3, [r7, #0x6c]
; 	k_spinlock_key_t key = k_spin_lock(&heap->lock);
 802481e: 68fb         	ldr	r3, [r7, #0xc]
 8024820: 3314         	adds	r3, #0x14
 8024822: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8024824: f3ef 8311    	mrs	r3, basepri
 8024828: 663b         	str	r3, [r7, #0x60]
;   return(result);
 802482a: 6e3b         	ldr	r3, [r7, #0x60]
; 	key = __get_BASEPRI();
 802482c: 65fb         	str	r3, [r7, #0x5c]
 802482e: 2310         	movs	r3, #0x10
 8024830: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8024832: 6dbb         	ldr	r3, [r7, #0x58]
 8024834: f383 8812    	msr	basepri_max, r3
; }
 8024838: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 802483a: f3bf 8f6f    	isb	sy
; }
 802483e: bf00         	nop
; 	return key;
 8024840: 6dfb         	ldr	r3, [r7, #0x5c]
; 	k.key = arch_irq_lock();
 8024842: 613b         	str	r3, [r7, #0x10]
 8024844: 6e7b         	ldr	r3, [r7, #0x64]
 8024846: 657b         	str	r3, [r7, #0x54]
; }
 8024848: bf00         	nop
 802484a: 6e7b         	ldr	r3, [r7, #0x64]
 802484c: 653b         	str	r3, [r7, #0x50]
; }
 802484e: bf00         	nop
; 	return k;
 8024850: 693b         	ldr	r3, [r7, #0x10]
 8024852: 61fb         	str	r3, [r7, #0x1c]
; 	bool blocked_alloc = false;
 8024854: 2300         	movs	r3, #0x0
 8024856: f887 306b    	strb.w	r3, [r7, #0x6b]
; 	while (ret == NULL) {
 802485a: e04d         	b	0x80248f8 <k_heap_aligned_alloc+0xf8> @ imm = #0x9a
; 		ret = sys_heap_aligned_alloc(&heap->heap, align, bytes);
 802485c: 68fb         	ldr	r3, [r7, #0xc]
 802485e: 687a         	ldr	r2, [r7, #0x4]
 8024860: 68b9         	ldr	r1, [r7, #0x8]
 8024862: 4618         	mov	r0, r3
 8024864: f7f6 fbdf    	bl	0x801b026 <sys_heap_aligned_alloc> @ imm = #-0x9842
 8024868: 66f8         	str	r0, [r7, #0x6c]
; 		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
 802486a: 6efb         	ldr	r3, [r7, #0x6c]
 802486c: 2b00         	cmp	r3, #0x0
 802486e: d146         	bne	0x80248fe <k_heap_aligned_alloc+0xfe> @ imm = #0x8c
; 		    (ret != NULL) || K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 8024870: e9d7 231e    	ldrd	r2, r3, [r7, #120]
 8024874: f04f 0000    	mov.w	r0, #0x0
 8024878: f04f 0100    	mov.w	r1, #0x0
 802487c: 428b         	cmp	r3, r1
 802487e: bf08         	it	eq
 8024880: 4282         	cmpeq	r2, r0
 8024882: d03c         	beq	0x80248fe <k_heap_aligned_alloc+0xfe> @ imm = #0x78
; 		if (!blocked_alloc) {
 8024884: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 8024888: f083 0301    	eor	r3, r3, #0x1
 802488c: b2db         	uxtb	r3, r3
 802488e: 2b00         	cmp	r3, #0x0
 8024890: d100         	bne	0x8024894 <k_heap_aligned_alloc+0x94> @ imm = #0x0
 8024892: e002         	b	0x802489a <k_heap_aligned_alloc+0x9a> @ imm = #0x4
; 			blocked_alloc = true;
 8024894: 2301         	movs	r3, #0x1
 8024896: f887 306b    	strb.w	r3, [r7, #0x6b]
; 		timeout = sys_timepoint_timeout(end);
 802489a: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 802489e: f107 0078    	add.w	r0, r7, #0x78
 80248a2: f002 fc10    	bl	0x80270c6 <sys_timepoint_timeout> @ imm = #0x2820
; 		(void) z_pend_curr(&heap->lock, key, &heap->wait_q, timeout);
 80248a6: 68fb         	ldr	r3, [r7, #0xc]
 80248a8: f103 0014    	add.w	r0, r3, #0x14
 80248ac: 68fb         	ldr	r3, [r7, #0xc]
 80248ae: f103 010c    	add.w	r1, r3, #0xc
 80248b2: e9d7 231e    	ldrd	r2, r3, [r7, #120]
 80248b6: e9cd 2300    	strd	r2, r3, [sp]
 80248ba: 460a         	mov	r2, r1
 80248bc: 69f9         	ldr	r1, [r7, #0x1c]
 80248be: f7f1 f80f    	bl	0x80158e0 <z_pend_curr> @ imm = #-0xefe2
; 		key = k_spin_lock(&heap->lock);
 80248c2: 68fb         	ldr	r3, [r7, #0xc]
 80248c4: 3314         	adds	r3, #0x14
 80248c6: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80248c8: f3ef 8311    	mrs	r3, basepri
 80248cc: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 80248ce: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 80248d0: 647b         	str	r3, [r7, #0x44]
 80248d2: 2310         	movs	r3, #0x10
 80248d4: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80248d6: 6c3b         	ldr	r3, [r7, #0x40]
 80248d8: f383 8812    	msr	basepri_max, r3
; }
 80248dc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80248de: f3bf 8f6f    	isb	sy
; }
 80248e2: bf00         	nop
; 	return key;
 80248e4: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 80248e6: 617b         	str	r3, [r7, #0x14]
 80248e8: 6cfb         	ldr	r3, [r7, #0x4c]
 80248ea: 63fb         	str	r3, [r7, #0x3c]
; }
 80248ec: bf00         	nop
 80248ee: 6cfb         	ldr	r3, [r7, #0x4c]
 80248f0: 63bb         	str	r3, [r7, #0x38]
; }
 80248f2: bf00         	nop
; 	return k;
 80248f4: 697b         	ldr	r3, [r7, #0x14]
 80248f6: 61fb         	str	r3, [r7, #0x1c]
; 	while (ret == NULL) {
 80248f8: 6efb         	ldr	r3, [r7, #0x6c]
 80248fa: 2b00         	cmp	r3, #0x0
 80248fc: d0ae         	beq	0x802485c <k_heap_aligned_alloc+0x5c> @ imm = #-0xa4
; 	k_spin_unlock(&heap->lock, key);
 80248fe: 68fb         	ldr	r3, [r7, #0xc]
 8024900: 3314         	adds	r3, #0x14
 8024902: 637b         	str	r3, [r7, #0x34]
 8024904: 69fb         	ldr	r3, [r7, #0x1c]
 8024906: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8024908: 69bb         	ldr	r3, [r7, #0x18]
 802490a: 633b         	str	r3, [r7, #0x30]
 802490c: 6b3b         	ldr	r3, [r7, #0x30]
 802490e: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8024910: 6afb         	ldr	r3, [r7, #0x2c]
 8024912: f383 8811    	msr	basepri, r3
; }
 8024916: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8024918: f3bf 8f6f    	isb	sy
; }
 802491c: bf00         	nop
; }
 802491e: bf00         	nop
; }
 8024920: bf00         	nop
; 	return ret;
 8024922: 6efb         	ldr	r3, [r7, #0x6c]
; }
 8024924: 4618         	mov	r0, r3
 8024926: 3770         	adds	r7, #0x70
 8024928: 46bd         	mov	sp, r7
 802492a: bd80         	pop	{r7, pc}

0802492c <k_heap_free>:
; {
 802492c: b580         	push	{r7, lr}
 802492e: b08e         	sub	sp, #0x38
 8024930: af00         	add	r7, sp, #0x0
 8024932: 6078         	str	r0, [r7, #0x4]
 8024934: 6039         	str	r1, [r7]
; 	k_spinlock_key_t key = k_spin_lock(&heap->lock);
 8024936: 687b         	ldr	r3, [r7, #0x4]
 8024938: 3314         	adds	r3, #0x14
 802493a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 802493c: f3ef 8311    	mrs	r3, basepri
 8024940: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8024942: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 8024944: 62fb         	str	r3, [r7, #0x2c]
 8024946: 2310         	movs	r3, #0x10
 8024948: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 802494a: 6abb         	ldr	r3, [r7, #0x28]
 802494c: f383 8812    	msr	basepri_max, r3
; }
 8024950: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8024952: f3bf 8f6f    	isb	sy
; }
 8024956: bf00         	nop
; 	return key;
 8024958: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 802495a: 60bb         	str	r3, [r7, #0x8]
 802495c: 6b7b         	ldr	r3, [r7, #0x34]
 802495e: 627b         	str	r3, [r7, #0x24]
; }
 8024960: bf00         	nop
 8024962: 6b7b         	ldr	r3, [r7, #0x34]
 8024964: 623b         	str	r3, [r7, #0x20]
; }
 8024966: bf00         	nop
; 	return k;
 8024968: 68bb         	ldr	r3, [r7, #0x8]
 802496a: 613b         	str	r3, [r7, #0x10]
; 	sys_heap_free(&heap->heap, mem);
 802496c: 687b         	ldr	r3, [r7, #0x4]
 802496e: 6839         	ldr	r1, [r7]
 8024970: 4618         	mov	r0, r3
 8024972: f7f6 fa8f    	bl	0x801ae94 <sys_heap_free> @ imm = #-0x9ae2
; 	if (IS_ENABLED(CONFIG_MULTITHREADING) && (z_unpend_all(&heap->wait_q) != 0)) {
 8024976: 687b         	ldr	r3, [r7, #0x4]
 8024978: 330c         	adds	r3, #0xc
 802497a: 4618         	mov	r0, r3
 802497c: f002 f94b    	bl	0x8026c16 <z_unpend_all> @ imm = #0x2296
 8024980: 4603         	mov	r3, r0
 8024982: 2b00         	cmp	r3, #0x0
 8024984: d006         	beq	0x8024994 <k_heap_free+0x68> @ imm = #0xc
; 		z_reschedule(&heap->lock, key);
 8024986: 687b         	ldr	r3, [r7, #0x4]
 8024988: 3314         	adds	r3, #0x14
 802498a: 6939         	ldr	r1, [r7, #0x10]
 802498c: 4618         	mov	r0, r3
 802498e: f002 f8ed    	bl	0x8026b6c <z_reschedule> @ imm = #0x21da
; }
 8024992: e011         	b	0x80249b8 <k_heap_free+0x8c> @ imm = #0x22
; 		k_spin_unlock(&heap->lock, key);
 8024994: 687b         	ldr	r3, [r7, #0x4]
 8024996: 3314         	adds	r3, #0x14
 8024998: 61fb         	str	r3, [r7, #0x1c]
 802499a: 693b         	ldr	r3, [r7, #0x10]
 802499c: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 802499e: 68fb         	ldr	r3, [r7, #0xc]
 80249a0: 61bb         	str	r3, [r7, #0x18]
 80249a2: 69bb         	ldr	r3, [r7, #0x18]
 80249a4: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80249a6: 697b         	ldr	r3, [r7, #0x14]
 80249a8: f383 8811    	msr	basepri, r3
; }
 80249ac: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80249ae: f3bf 8f6f    	isb	sy
; }
 80249b2: bf00         	nop
; }
 80249b4: bf00         	nop
; }
 80249b6: bf00         	nop
; }
 80249b8: bf00         	nop
 80249ba: 3738         	adds	r7, #0x38
 80249bc: 46bd         	mov	sp, r7
 80249be: bd80         	pop	{r7, pc}

080249c0 <sys_dnode_init>:
; {
 80249c0: b480         	push	{r7}
 80249c2: b083         	sub	sp, #0xc
 80249c4: af00         	add	r7, sp, #0x0
 80249c6: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 80249c8: 687b         	ldr	r3, [r7, #0x4]
 80249ca: 2200         	movs	r2, #0x0
 80249cc: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 80249ce: 687b         	ldr	r3, [r7, #0x4]
 80249d0: 2200         	movs	r2, #0x0
 80249d2: 605a         	str	r2, [r3, #0x4]
; }
 80249d4: bf00         	nop
 80249d6: 370c         	adds	r7, #0xc
 80249d8: 46bd         	mov	sp, r7
 80249da: f85d 7b04    	ldr	r7, [sp], #4
 80249de: 4770         	bx	lr

080249e0 <sys_dlist_is_empty>:
; {
 80249e0: b480         	push	{r7}
 80249e2: b083         	sub	sp, #0xc
 80249e4: af00         	add	r7, sp, #0x0
 80249e6: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 80249e8: 687b         	ldr	r3, [r7, #0x4]
 80249ea: 681b         	ldr	r3, [r3]
 80249ec: 687a         	ldr	r2, [r7, #0x4]
 80249ee: 429a         	cmp	r2, r3
 80249f0: bf0c         	ite	eq
 80249f2: 2301         	moveq	r3, #0x1
 80249f4: 2300         	movne	r3, #0x0
 80249f6: b2db         	uxtb	r3, r3
; }
 80249f8: 4618         	mov	r0, r3
 80249fa: 370c         	adds	r7, #0xc
 80249fc: 46bd         	mov	sp, r7
 80249fe: f85d 7b04    	ldr	r7, [sp], #4
 8024a02: 4770         	bx	lr

08024a04 <sys_dlist_peek_head>:
; {
 8024a04: b580         	push	{r7, lr}
 8024a06: b082         	sub	sp, #0x8
 8024a08: af00         	add	r7, sp, #0x0
 8024a0a: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8024a0c: 6878         	ldr	r0, [r7, #0x4]
 8024a0e: f7ff ffe7    	bl	0x80249e0 <sys_dlist_is_empty> @ imm = #-0x32
 8024a12: 4603         	mov	r3, r0
 8024a14: 2b00         	cmp	r3, #0x0
 8024a16: d102         	bne	0x8024a1e <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8024a18: 687b         	ldr	r3, [r7, #0x4]
 8024a1a: 681b         	ldr	r3, [r3]
 8024a1c: e000         	b	0x8024a20 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8024a1e: 2300         	movs	r3, #0x0
; }
 8024a20: 4618         	mov	r0, r3
 8024a22: 3708         	adds	r7, #0x8
 8024a24: 46bd         	mov	sp, r7
 8024a26: bd80         	pop	{r7, pc}

08024a28 <sys_dlist_remove>:
; {
 8024a28: b580         	push	{r7, lr}
 8024a2a: b084         	sub	sp, #0x10
 8024a2c: af00         	add	r7, sp, #0x0
 8024a2e: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8024a30: 687b         	ldr	r3, [r7, #0x4]
 8024a32: 685b         	ldr	r3, [r3, #0x4]
 8024a34: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8024a36: 687b         	ldr	r3, [r7, #0x4]
 8024a38: 681b         	ldr	r3, [r3]
 8024a3a: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8024a3c: 68fb         	ldr	r3, [r7, #0xc]
 8024a3e: 68ba         	ldr	r2, [r7, #0x8]
 8024a40: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8024a42: 68bb         	ldr	r3, [r7, #0x8]
 8024a44: 68fa         	ldr	r2, [r7, #0xc]
 8024a46: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8024a48: 6878         	ldr	r0, [r7, #0x4]
 8024a4a: f7ff ffb9    	bl	0x80249c0 <sys_dnode_init> @ imm = #-0x8e
; }
 8024a4e: bf00         	nop
 8024a50: 3710         	adds	r7, #0x10
 8024a52: 46bd         	mov	sp, r7
 8024a54: bd80         	pop	{r7, pc}

08024a56 <k_object_init>:
; {
 8024a56: b480         	push	{r7}
 8024a58: b083         	sub	sp, #0xc
 8024a5a: af00         	add	r7, sp, #0x0
 8024a5c: 6078         	str	r0, [r7, #0x4]
; }
 8024a5e: bf00         	nop
 8024a60: 370c         	adds	r7, #0xc
 8024a62: 46bd         	mov	sp, r7
 8024a64: f85d 7b04    	ldr	r7, [sp], #4
 8024a68: 4770         	bx	lr

08024a6a <z_abort_thread_timeout>:
; {
 8024a6a: b580         	push	{r7, lr}
 8024a6c: b082         	sub	sp, #0x8
 8024a6e: af00         	add	r7, sp, #0x0
 8024a70: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8024a72: 687b         	ldr	r3, [r7, #0x4]
 8024a74: 3318         	adds	r3, #0x18
 8024a76: 4618         	mov	r0, r3
 8024a78: f7f2 f9c4    	bl	0x8016e04 <z_abort_timeout> @ imm = #-0xdc78
 8024a7c: 4603         	mov	r3, r0
; }
 8024a7e: 4618         	mov	r0, r3
 8024a80: 3708         	adds	r7, #0x8
 8024a82: 46bd         	mov	sp, r7
 8024a84: bd80         	pop	{r7, pc}

08024a86 <z_mark_thread_as_not_pending>:
; {
 8024a86: b480         	push	{r7}
 8024a88: b083         	sub	sp, #0xc
 8024a8a: af00         	add	r7, sp, #0x0
 8024a8c: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8024a8e: 687b         	ldr	r3, [r7, #0x4]
 8024a90: 7b5b         	ldrb	r3, [r3, #0xd]
 8024a92: f023 0302    	bic	r3, r3, #0x2
 8024a96: b2da         	uxtb	r2, r3
 8024a98: 687b         	ldr	r3, [r7, #0x4]
 8024a9a: 735a         	strb	r2, [r3, #0xd]
; }
 8024a9c: bf00         	nop
 8024a9e: 370c         	adds	r7, #0xc
 8024aa0: 46bd         	mov	sp, r7
 8024aa2: f85d 7b04    	ldr	r7, [sp], #4
 8024aa6: 4770         	bx	lr

08024aa8 <unpend_thread_no_timeout>:
; {
 8024aa8: b580         	push	{r7, lr}
 8024aaa: b086         	sub	sp, #0x18
 8024aac: af00         	add	r7, sp, #0x0
 8024aae: 6078         	str	r0, [r7, #0x4]
 8024ab0: 687b         	ldr	r3, [r7, #0x4]
 8024ab2: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8024ab4: 68fb         	ldr	r3, [r7, #0xc]
 8024ab6: 689b         	ldr	r3, [r3, #0x8]
 8024ab8: 617b         	str	r3, [r7, #0x14]
 8024aba: 687b         	ldr	r3, [r7, #0x4]
 8024abc: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8024abe: 693b         	ldr	r3, [r7, #0x10]
 8024ac0: 4618         	mov	r0, r3
 8024ac2: f7ff ffb1    	bl	0x8024a28 <sys_dlist_remove> @ imm = #-0x9e
; }
 8024ac6: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8024ac8: 6878         	ldr	r0, [r7, #0x4]
 8024aca: f7ff ffdc    	bl	0x8024a86 <z_mark_thread_as_not_pending> @ imm = #-0x48
; 	thread->base.pended_on = NULL;
 8024ace: 687b         	ldr	r3, [r7, #0x4]
 8024ad0: 2200         	movs	r2, #0x0
 8024ad2: 609a         	str	r2, [r3, #0x8]
; }
 8024ad4: bf00         	nop
 8024ad6: 3718         	adds	r7, #0x18
 8024ad8: 46bd         	mov	sp, r7
 8024ada: bd80         	pop	{r7, pc}

08024adc <create_free_list>:
; {
 8024adc: b480         	push	{r7}
 8024ade: b085         	sub	sp, #0x14
 8024ae0: af00         	add	r7, sp, #0x0
 8024ae2: 6078         	str	r0, [r7, #0x4]
; 	CHECKIF(((slab->info.block_size | (uintptr_t)slab->buffer) &
 8024ae4: 687b         	ldr	r3, [r7, #0x4]
 8024ae6: 695b         	ldr	r3, [r3, #0x14]
 8024ae8: 687a         	ldr	r2, [r7, #0x4]
 8024aea: 6892         	ldr	r2, [r2, #0x8]
 8024aec: 4313         	orrs	r3, r2
 8024aee: f003 0303    	and	r3, r3, #0x3
 8024af2: 2b00         	cmp	r3, #0x0
 8024af4: d002         	beq	0x8024afc <create_free_list+0x20> @ imm = #0x4
; 		return -EINVAL;
 8024af6: f06f 0315    	mvn	r3, #0x15
 8024afa: e021         	b	0x8024b40 <create_free_list+0x64> @ imm = #0x42
; 	slab->free_list = NULL;
 8024afc: 687b         	ldr	r3, [r7, #0x4]
 8024afe: 2200         	movs	r2, #0x0
 8024b00: 60da         	str	r2, [r3, #0xc]
; 	p = slab->buffer + slab->info.block_size * (slab->info.num_blocks - 1);
 8024b02: 687b         	ldr	r3, [r7, #0x4]
 8024b04: 689a         	ldr	r2, [r3, #0x8]
 8024b06: 687b         	ldr	r3, [r7, #0x4]
 8024b08: 695b         	ldr	r3, [r3, #0x14]
 8024b0a: 6879         	ldr	r1, [r7, #0x4]
 8024b0c: 6909         	ldr	r1, [r1, #0x10]
 8024b0e: 3901         	subs	r1, #0x1
 8024b10: fb01 f303    	mul	r3, r1, r3
 8024b14: 4413         	add	r3, r2
 8024b16: 60fb         	str	r3, [r7, #0xc]
; 	while (p >= slab->buffer) {
 8024b18: e00c         	b	0x8024b34 <create_free_list+0x58> @ imm = #0x18
; 		*(char **)p = slab->free_list;
 8024b1a: 687b         	ldr	r3, [r7, #0x4]
 8024b1c: 68da         	ldr	r2, [r3, #0xc]
 8024b1e: 68fb         	ldr	r3, [r7, #0xc]
 8024b20: 601a         	str	r2, [r3]
; 		slab->free_list = p;
 8024b22: 687b         	ldr	r3, [r7, #0x4]
 8024b24: 68fa         	ldr	r2, [r7, #0xc]
 8024b26: 60da         	str	r2, [r3, #0xc]
; 		p -= slab->info.block_size;
 8024b28: 687b         	ldr	r3, [r7, #0x4]
 8024b2a: 695b         	ldr	r3, [r3, #0x14]
 8024b2c: 425b         	rsbs	r3, r3, #0
 8024b2e: 68fa         	ldr	r2, [r7, #0xc]
 8024b30: 4413         	add	r3, r2
 8024b32: 60fb         	str	r3, [r7, #0xc]
; 	while (p >= slab->buffer) {
 8024b34: 687b         	ldr	r3, [r7, #0x4]
 8024b36: 689b         	ldr	r3, [r3, #0x8]
 8024b38: 68fa         	ldr	r2, [r7, #0xc]
 8024b3a: 429a         	cmp	r2, r3
 8024b3c: d2ed         	bhs	0x8024b1a <create_free_list+0x3e> @ imm = #-0x26
; 	return 0;
 8024b3e: 2300         	movs	r3, #0x0
; }
 8024b40: 4618         	mov	r0, r3
 8024b42: 3714         	adds	r7, #0x14
 8024b44: 46bd         	mov	sp, r7
 8024b46: f85d 7b04    	ldr	r7, [sp], #4
 8024b4a: 4770         	bx	lr

08024b4c <slab_ptr_is_good>:
; {
 8024b4c: b480         	push	{r7}
 8024b4e: b085         	sub	sp, #0x14
 8024b50: af00         	add	r7, sp, #0x0
 8024b52: 6078         	str	r0, [r7, #0x4]
 8024b54: 6039         	str	r1, [r7]
; 	const char *p = ptr;
 8024b56: 683b         	ldr	r3, [r7]
 8024b58: 60fb         	str	r3, [r7, #0xc]
; 	ptrdiff_t offset = p - slab->buffer;
 8024b5a: 687b         	ldr	r3, [r7, #0x4]
 8024b5c: 689b         	ldr	r3, [r3, #0x8]
 8024b5e: 68fa         	ldr	r2, [r7, #0xc]
 8024b60: 1ad3         	subs	r3, r2, r3
 8024b62: 60bb         	str	r3, [r7, #0x8]
; 	       (offset < (slab->info.block_size * slab->info.num_blocks)) &&
 8024b64: 68bb         	ldr	r3, [r7, #0x8]
 8024b66: 2b00         	cmp	r3, #0x0
 8024b68: db14         	blt	0x8024b94 <slab_ptr_is_good+0x48> @ imm = #0x28
 8024b6a: 687b         	ldr	r3, [r7, #0x4]
 8024b6c: 695b         	ldr	r3, [r3, #0x14]
 8024b6e: 687a         	ldr	r2, [r7, #0x4]
 8024b70: 6912         	ldr	r2, [r2, #0x10]
 8024b72: fb03 f202    	mul	r2, r3, r2
 8024b76: 68bb         	ldr	r3, [r7, #0x8]
; 	return (offset >= 0) &&
 8024b78: 429a         	cmp	r2, r3
 8024b7a: d90b         	bls	0x8024b94 <slab_ptr_is_good+0x48> @ imm = #0x16
; 	       ((offset % slab->info.block_size) == 0);
 8024b7c: 68bb         	ldr	r3, [r7, #0x8]
 8024b7e: 687a         	ldr	r2, [r7, #0x4]
 8024b80: 6952         	ldr	r2, [r2, #0x14]
 8024b82: fbb3 f1f2    	udiv	r1, r3, r2
 8024b86: fb01 f202    	mul	r2, r1, r2
 8024b8a: 1a9b         	subs	r3, r3, r2
; 	       (offset < (slab->info.block_size * slab->info.num_blocks)) &&
 8024b8c: 2b00         	cmp	r3, #0x0
 8024b8e: d101         	bne	0x8024b94 <slab_ptr_is_good+0x48> @ imm = #0x2
 8024b90: 2301         	movs	r3, #0x1
 8024b92: e000         	b	0x8024b96 <slab_ptr_is_good+0x4a> @ imm = #0x0
 8024b94: 2300         	movs	r3, #0x0
 8024b96: f003 0301    	and	r3, r3, #0x1
 8024b9a: b2db         	uxtb	r3, r3
; }
 8024b9c: 4618         	mov	r0, r3
 8024b9e: 3714         	adds	r7, #0x14
 8024ba0: 46bd         	mov	sp, r7
 8024ba2: f85d 7b04    	ldr	r7, [sp], #4
 8024ba6: 4770         	bx	lr

08024ba8 <k_mem_slab_free>:
; {
 8024ba8: b580         	push	{r7, lr}
 8024baa: b09c         	sub	sp, #0x70
 8024bac: af00         	add	r7, sp, #0x0
 8024bae: 6078         	str	r0, [r7, #0x4]
 8024bb0: 6039         	str	r1, [r7]
; 	if (!slab_ptr_is_good(slab, mem)) {
 8024bb2: 6839         	ldr	r1, [r7]
 8024bb4: 6878         	ldr	r0, [r7, #0x4]
 8024bb6: f7ff ffc9    	bl	0x8024b4c <slab_ptr_is_good> @ imm = #-0x6e
 8024bba: 4603         	mov	r3, r0
 8024bbc: f083 0301    	eor	r3, r3, #0x1
 8024bc0: b2db         	uxtb	r3, r3
 8024bc2: 2b00         	cmp	r3, #0x0
 8024bc4: d00f         	beq	0x8024be6 <k_mem_slab_free+0x3e> @ imm = #0x1e
 8024bc6: 2300         	movs	r3, #0x0
 8024bc8: 66bb         	str	r3, [r7, #0x68]
 8024bca: 6ebb         	ldr	r3, [r7, #0x68]
 8024bcc: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8024bce: 6e7b         	ldr	r3, [r7, #0x64]
 8024bd0: f383 8811    	msr	basepri, r3
; }
 8024bd4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8024bd6: f3bf 8f6f    	isb	sy
; }
 8024bda: bf00         	nop
; }
 8024bdc: bf00         	nop
; 		k_panic();
 8024bde: 2304         	movs	r3, #0x4
 8024be0: 4618         	mov	r0, r3
 8024be2: df02         	svc	#0x2
; 		return;
 8024be4: e084         	b	0x8024cf0 <k_mem_slab_free+0x148> @ imm = #0x108
; 	k_spinlock_key_t key = k_spin_lock(&slab->lock);
 8024be6: 687b         	ldr	r3, [r7, #0x4]
 8024be8: 3308         	adds	r3, #0x8
 8024bea: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8024bec: f3ef 8311    	mrs	r3, basepri
 8024bf0: 65fb         	str	r3, [r7, #0x5c]
;   return(result);
 8024bf2: 6dfb         	ldr	r3, [r7, #0x5c]
; 	key = __get_BASEPRI();
 8024bf4: 65bb         	str	r3, [r7, #0x58]
 8024bf6: 2310         	movs	r3, #0x10
 8024bf8: 657b         	str	r3, [r7, #0x54]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8024bfa: 6d7b         	ldr	r3, [r7, #0x54]
 8024bfc: f383 8812    	msr	basepri_max, r3
; }
 8024c00: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8024c02: f3bf 8f6f    	isb	sy
; }
 8024c06: bf00         	nop
; 	return key;
 8024c08: 6dbb         	ldr	r3, [r7, #0x58]
; 	k.key = arch_irq_lock();
 8024c0a: 60fb         	str	r3, [r7, #0xc]
 8024c0c: 6e3b         	ldr	r3, [r7, #0x60]
 8024c0e: 653b         	str	r3, [r7, #0x50]
; }
 8024c10: bf00         	nop
 8024c12: 6e3b         	ldr	r3, [r7, #0x60]
 8024c14: 64fb         	str	r3, [r7, #0x4c]
; }
 8024c16: bf00         	nop
; 	return k;
 8024c18: 68fb         	ldr	r3, [r7, #0xc]
 8024c1a: 617b         	str	r3, [r7, #0x14]
; 	if ((slab->free_list == NULL) && IS_ENABLED(CONFIG_MULTITHREADING)) {
 8024c1c: 687b         	ldr	r3, [r7, #0x4]
 8024c1e: 68db         	ldr	r3, [r3, #0xc]
 8024c20: 2b00         	cmp	r3, #0x0
 8024c22: d147         	bne	0x8024cb4 <k_mem_slab_free+0x10c> @ imm = #0x8e
; 		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
 8024c24: 687b         	ldr	r3, [r7, #0x4]
 8024c26: 64bb         	str	r3, [r7, #0x48]
; 	struct k_thread *thread = NULL;
 8024c28: 2300         	movs	r3, #0x0
 8024c2a: 647b         	str	r3, [r7, #0x44]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8024c2c: 6cbb         	ldr	r3, [r7, #0x48]
 8024c2e: 643b         	str	r3, [r7, #0x40]
; 	struct k_thread *thread = NULL;
 8024c30: 2300         	movs	r3, #0x0
 8024c32: 63fb         	str	r3, [r7, #0x3c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8024c34: 6c38         	ldr	r0, [r7, #0x40]
 8024c36: f7ff fee5    	bl	0x8024a04 <sys_dlist_peek_head> @ imm = #-0x236
 8024c3a: 63b8         	str	r0, [r7, #0x38]
; 	if (n != NULL) {
 8024c3c: 6bbb         	ldr	r3, [r7, #0x38]
 8024c3e: 2b00         	cmp	r3, #0x0
 8024c40: d001         	beq	0x8024c46 <k_mem_slab_free+0x9e> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8024c42: 6bbb         	ldr	r3, [r7, #0x38]
 8024c44: 63fb         	str	r3, [r7, #0x3c]
; 	return thread;
 8024c46: 6bfb         	ldr	r3, [r7, #0x3c]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8024c48: 647b         	str	r3, [r7, #0x44]
; 		if (unlikely(thread != NULL)) {
 8024c4a: 6c7b         	ldr	r3, [r7, #0x44]
 8024c4c: 2b00         	cmp	r3, #0x0
 8024c4e: bf14         	ite	ne
 8024c50: 2301         	movne	r3, #0x1
 8024c52: 2300         	moveq	r3, #0x0
 8024c54: b2db         	uxtb	r3, r3
 8024c56: 2b00         	cmp	r3, #0x0
 8024c58: d005         	beq	0x8024c66 <k_mem_slab_free+0xbe> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 8024c5a: 6c78         	ldr	r0, [r7, #0x44]
 8024c5c: f7ff ff24    	bl	0x8024aa8 <unpend_thread_no_timeout> @ imm = #-0x1b8
; 			(void)z_abort_thread_timeout(thread);
 8024c60: 6c78         	ldr	r0, [r7, #0x44]
 8024c62: f7ff ff02    	bl	0x8024a6a <z_abort_thread_timeout> @ imm = #-0x1fc
; 	return thread;
 8024c66: 6c7b         	ldr	r3, [r7, #0x44]
; 		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
 8024c68: 66fb         	str	r3, [r7, #0x6c]
; 		if (unlikely(pending_thread != NULL)) {
 8024c6a: 6efb         	ldr	r3, [r7, #0x6c]
 8024c6c: 2b00         	cmp	r3, #0x0
 8024c6e: bf14         	ite	ne
 8024c70: 2301         	movne	r3, #0x1
 8024c72: 2300         	moveq	r3, #0x0
 8024c74: b2db         	uxtb	r3, r3
 8024c76: 2b00         	cmp	r3, #0x0
 8024c78: d01c         	beq	0x8024cb4 <k_mem_slab_free+0x10c> @ imm = #0x38
 8024c7a: 6efb         	ldr	r3, [r7, #0x6c]
 8024c7c: 637b         	str	r3, [r7, #0x34]
 8024c7e: 2300         	movs	r3, #0x0
 8024c80: 633b         	str	r3, [r7, #0x30]
 8024c82: 683b         	ldr	r3, [r7]
 8024c84: 62fb         	str	r3, [r7, #0x2c]
 8024c86: 6b7b         	ldr	r3, [r7, #0x34]
 8024c88: 62bb         	str	r3, [r7, #0x28]
 8024c8a: 6b3b         	ldr	r3, [r7, #0x30]
 8024c8c: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 8024c8e: 6abb         	ldr	r3, [r7, #0x28]
 8024c90: 6a7a         	ldr	r2, [r7, #0x24]
 8024c92: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8024c96: bf00         	nop
; 	thread->base.swap_data = data;
 8024c98: 6b7b         	ldr	r3, [r7, #0x34]
 8024c9a: 6afa         	ldr	r2, [r7, #0x2c]
 8024c9c: 615a         	str	r2, [r3, #0x14]
; }
 8024c9e: bf00         	nop
; 			z_ready_thread(pending_thread);
 8024ca0: 6ef8         	ldr	r0, [r7, #0x6c]
 8024ca2: f7f0 fa1b    	bl	0x80150dc <z_ready_thread> @ imm = #-0xfbca
; 			z_reschedule(&slab->lock, key);
 8024ca6: 687b         	ldr	r3, [r7, #0x4]
 8024ca8: 3308         	adds	r3, #0x8
 8024caa: 6979         	ldr	r1, [r7, #0x14]
 8024cac: 4618         	mov	r0, r3
 8024cae: f001 ff5d    	bl	0x8026b6c <z_reschedule> @ imm = #0x1eba
; 			return;
 8024cb2: e01d         	b	0x8024cf0 <k_mem_slab_free+0x148> @ imm = #0x3a
; 	*(char **) mem = slab->free_list;
 8024cb4: 687b         	ldr	r3, [r7, #0x4]
 8024cb6: 68da         	ldr	r2, [r3, #0xc]
 8024cb8: 683b         	ldr	r3, [r7]
 8024cba: 601a         	str	r2, [r3]
; 	slab->free_list = (char *) mem;
 8024cbc: 687b         	ldr	r3, [r7, #0x4]
 8024cbe: 683a         	ldr	r2, [r7]
 8024cc0: 60da         	str	r2, [r3, #0xc]
; 	slab->info.num_used--;
 8024cc2: 687b         	ldr	r3, [r7, #0x4]
 8024cc4: 699b         	ldr	r3, [r3, #0x18]
 8024cc6: 1e5a         	subs	r2, r3, #0x1
 8024cc8: 687b         	ldr	r3, [r7, #0x4]
 8024cca: 619a         	str	r2, [r3, #0x18]
; 	k_spin_unlock(&slab->lock, key);
 8024ccc: 687b         	ldr	r3, [r7, #0x4]
 8024cce: 3308         	adds	r3, #0x8
 8024cd0: 623b         	str	r3, [r7, #0x20]
 8024cd2: 697b         	ldr	r3, [r7, #0x14]
 8024cd4: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8024cd6: 693b         	ldr	r3, [r7, #0x10]
 8024cd8: 61fb         	str	r3, [r7, #0x1c]
 8024cda: 69fb         	ldr	r3, [r7, #0x1c]
 8024cdc: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8024cde: 69bb         	ldr	r3, [r7, #0x18]
 8024ce0: f383 8811    	msr	basepri, r3
; }
 8024ce4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8024ce6: f3bf 8f6f    	isb	sy
; }
 8024cea: bf00         	nop
; }
 8024cec: bf00         	nop
; }
 8024cee: bf00         	nop
; }
 8024cf0: 3770         	adds	r7, #0x70
 8024cf2: 46bd         	mov	sp, r7
 8024cf4: bd80         	pop	{r7, pc}

08024cf6 <k_cpu_idle>:
; {
 8024cf6: b580         	push	{r7, lr}
 8024cf8: af00         	add	r7, sp, #0x0
; 	arch_cpu_idle();
 8024cfa: f7f7 fbce    	bl	0x801c49a <arch_cpu_idle> @ imm = #-0x8864
; }
 8024cfe: bf00         	nop
 8024d00: bd80         	pop	{r7, pc}

08024d02 <idle>:
; {
 8024d02: b580         	push	{r7, lr}
 8024d04: b088         	sub	sp, #0x20
 8024d06: af00         	add	r7, sp, #0x0
 8024d08: 60f8         	str	r0, [r7, #0xc]
 8024d0a: 60b9         	str	r1, [r7, #0x8]
 8024d0c: 607a         	str	r2, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8024d0e: f3ef 8311    	mrs	r3, basepri
 8024d12: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 8024d14: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 8024d16: 61bb         	str	r3, [r7, #0x18]
 8024d18: 2310         	movs	r3, #0x10
 8024d1a: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8024d1c: 697b         	ldr	r3, [r7, #0x14]
 8024d1e: f383 8812    	msr	basepri_max, r3
; }
 8024d22: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8024d24: f3bf 8f6f    	isb	sy
; }
 8024d28: bf00         	nop
; 	return key;
 8024d2a: bf00         	nop
; 		k_cpu_idle();
 8024d2c: f7ff ffe3    	bl	0x8024cf6 <k_cpu_idle>  @ imm = #-0x3a
; 		if (IS_ENABLED(CONFIG_SMP) && !IS_ENABLED(CONFIG_SCHED_IPI_SUPPORTED)) {
 8024d30: e7ed         	b	0x8024d0e <idle+0xc>    @ imm = #-0x26

08024d32 <arch_spin_relax>:
; {
 8024d32: b480         	push	{r7}
 8024d34: af00         	add	r7, sp, #0x0
; 	__asm__ volatile("nop");
 8024d36: bf00         	nop
; }
 8024d38: bf00         	nop
; }
 8024d3a: bf00         	nop
 8024d3c: 46bd         	mov	sp, r7
 8024d3e: f85d 7b04    	ldr	r7, [sp], #4
 8024d42: 4770         	bx	lr

08024d44 <sys_dnode_init>:
; {
 8024d44: b480         	push	{r7}
 8024d46: b083         	sub	sp, #0xc
 8024d48: af00         	add	r7, sp, #0x0
 8024d4a: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8024d4c: 687b         	ldr	r3, [r7, #0x4]
 8024d4e: 2200         	movs	r2, #0x0
 8024d50: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8024d52: 687b         	ldr	r3, [r7, #0x4]
 8024d54: 2200         	movs	r2, #0x0
 8024d56: 605a         	str	r2, [r3, #0x4]
; }
 8024d58: bf00         	nop
 8024d5a: 370c         	adds	r7, #0xc
 8024d5c: 46bd         	mov	sp, r7
 8024d5e: f85d 7b04    	ldr	r7, [sp], #4
 8024d62: 4770         	bx	lr

08024d64 <sys_dlist_is_empty>:
; {
 8024d64: b480         	push	{r7}
 8024d66: b083         	sub	sp, #0xc
 8024d68: af00         	add	r7, sp, #0x0
 8024d6a: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8024d6c: 687b         	ldr	r3, [r7, #0x4]
 8024d6e: 681b         	ldr	r3, [r3]
 8024d70: 687a         	ldr	r2, [r7, #0x4]
 8024d72: 429a         	cmp	r2, r3
 8024d74: bf0c         	ite	eq
 8024d76: 2301         	moveq	r3, #0x1
 8024d78: 2300         	movne	r3, #0x0
 8024d7a: b2db         	uxtb	r3, r3
; }
 8024d7c: 4618         	mov	r0, r3
 8024d7e: 370c         	adds	r7, #0xc
 8024d80: 46bd         	mov	sp, r7
 8024d82: f85d 7b04    	ldr	r7, [sp], #4
 8024d86: 4770         	bx	lr

08024d88 <sys_dlist_peek_head>:
; {
 8024d88: b580         	push	{r7, lr}
 8024d8a: b082         	sub	sp, #0x8
 8024d8c: af00         	add	r7, sp, #0x0
 8024d8e: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8024d90: 6878         	ldr	r0, [r7, #0x4]
 8024d92: f7ff ffe7    	bl	0x8024d64 <sys_dlist_is_empty> @ imm = #-0x32
 8024d96: 4603         	mov	r3, r0
 8024d98: 2b00         	cmp	r3, #0x0
 8024d9a: d102         	bne	0x8024da2 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8024d9c: 687b         	ldr	r3, [r7, #0x4]
 8024d9e: 681b         	ldr	r3, [r3]
 8024da0: e000         	b	0x8024da4 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8024da2: 2300         	movs	r3, #0x0
; }
 8024da4: 4618         	mov	r0, r3
 8024da6: 3708         	adds	r7, #0x8
 8024da8: 46bd         	mov	sp, r7
 8024daa: bd80         	pop	{r7, pc}

08024dac <sys_dlist_remove>:
; {
 8024dac: b580         	push	{r7, lr}
 8024dae: b084         	sub	sp, #0x10
 8024db0: af00         	add	r7, sp, #0x0
 8024db2: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8024db4: 687b         	ldr	r3, [r7, #0x4]
 8024db6: 685b         	ldr	r3, [r3, #0x4]
 8024db8: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8024dba: 687b         	ldr	r3, [r7, #0x4]
 8024dbc: 681b         	ldr	r3, [r3]
 8024dbe: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8024dc0: 68fb         	ldr	r3, [r7, #0xc]
 8024dc2: 68ba         	ldr	r2, [r7, #0x8]
 8024dc4: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8024dc6: 68bb         	ldr	r3, [r7, #0x8]
 8024dc8: 68fa         	ldr	r2, [r7, #0xc]
 8024dca: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8024dcc: 6878         	ldr	r0, [r7, #0x4]
 8024dce: f7ff ffb9    	bl	0x8024d44 <sys_dnode_init> @ imm = #-0x8e
; }
 8024dd2: bf00         	nop
 8024dd4: 3710         	adds	r7, #0x10
 8024dd6: 46bd         	mov	sp, r7
 8024dd8: bd80         	pop	{r7, pc}

08024dda <z_abort_thread_timeout>:
; {
 8024dda: b580         	push	{r7, lr}
 8024ddc: b082         	sub	sp, #0x8
 8024dde: af00         	add	r7, sp, #0x0
 8024de0: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8024de2: 687b         	ldr	r3, [r7, #0x4]
 8024de4: 3318         	adds	r3, #0x18
 8024de6: 4618         	mov	r0, r3
 8024de8: f7f2 f80c    	bl	0x8016e04 <z_abort_timeout> @ imm = #-0xdfe8
 8024dec: 4603         	mov	r3, r0
; }
 8024dee: 4618         	mov	r0, r3
 8024df0: 3708         	adds	r7, #0x8
 8024df2: 46bd         	mov	sp, r7
 8024df4: bd80         	pop	{r7, pc}

08024df6 <z_mark_thread_as_not_pending>:
; {
 8024df6: b480         	push	{r7}
 8024df8: b083         	sub	sp, #0xc
 8024dfa: af00         	add	r7, sp, #0x0
 8024dfc: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8024dfe: 687b         	ldr	r3, [r7, #0x4]
 8024e00: 7b5b         	ldrb	r3, [r3, #0xd]
 8024e02: f023 0302    	bic	r3, r3, #0x2
 8024e06: b2da         	uxtb	r2, r3
 8024e08: 687b         	ldr	r3, [r7, #0x4]
 8024e0a: 735a         	strb	r2, [r3, #0xd]
; }
 8024e0c: bf00         	nop
 8024e0e: 370c         	adds	r7, #0xc
 8024e10: 46bd         	mov	sp, r7
 8024e12: f85d 7b04    	ldr	r7, [sp], #4
 8024e16: 4770         	bx	lr

08024e18 <unpend_thread_no_timeout>:
; {
 8024e18: b580         	push	{r7, lr}
 8024e1a: b086         	sub	sp, #0x18
 8024e1c: af00         	add	r7, sp, #0x0
 8024e1e: 6078         	str	r0, [r7, #0x4]
 8024e20: 687b         	ldr	r3, [r7, #0x4]
 8024e22: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8024e24: 68fb         	ldr	r3, [r7, #0xc]
 8024e26: 689b         	ldr	r3, [r3, #0x8]
 8024e28: 617b         	str	r3, [r7, #0x14]
 8024e2a: 687b         	ldr	r3, [r7, #0x4]
 8024e2c: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8024e2e: 693b         	ldr	r3, [r7, #0x10]
 8024e30: 4618         	mov	r0, r3
 8024e32: f7ff ffbb    	bl	0x8024dac <sys_dlist_remove> @ imm = #-0x8a
; }
 8024e36: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8024e38: 6878         	ldr	r0, [r7, #0x4]
 8024e3a: f7ff ffdc    	bl	0x8024df6 <z_mark_thread_as_not_pending> @ imm = #-0x48
; 	thread->base.pended_on = NULL;
 8024e3e: 687b         	ldr	r3, [r7, #0x4]
 8024e40: 2200         	movs	r2, #0x0
 8024e42: 609a         	str	r2, [r3, #0x8]
; }
 8024e44: bf00         	nop
 8024e46: 3718         	adds	r7, #0x18
 8024e48: 46bd         	mov	sp, r7
 8024e4a: bd80         	pop	{r7, pc}

08024e4c <sys_dlist_init>:
; {
 8024e4c: b480         	push	{r7}
 8024e4e: b083         	sub	sp, #0xc
 8024e50: af00         	add	r7, sp, #0x0
 8024e52: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8024e54: 687b         	ldr	r3, [r7, #0x4]
 8024e56: 687a         	ldr	r2, [r7, #0x4]
 8024e58: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8024e5a: 687b         	ldr	r3, [r7, #0x4]
 8024e5c: 687a         	ldr	r2, [r7, #0x4]
 8024e5e: 605a         	str	r2, [r3, #0x4]
; }
 8024e60: bf00         	nop
 8024e62: 370c         	adds	r7, #0xc
 8024e64: 46bd         	mov	sp, r7
 8024e66: f85d 7b04    	ldr	r7, [sp], #4
 8024e6a: 4770         	bx	lr

08024e6c <sys_dnode_init>:
; {
 8024e6c: b480         	push	{r7}
 8024e6e: b083         	sub	sp, #0xc
 8024e70: af00         	add	r7, sp, #0x0
 8024e72: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8024e74: 687b         	ldr	r3, [r7, #0x4]
 8024e76: 2200         	movs	r2, #0x0
 8024e78: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8024e7a: 687b         	ldr	r3, [r7, #0x4]
 8024e7c: 2200         	movs	r2, #0x0
 8024e7e: 605a         	str	r2, [r3, #0x4]
; }
 8024e80: bf00         	nop
 8024e82: 370c         	adds	r7, #0xc
 8024e84: 46bd         	mov	sp, r7
 8024e86: f85d 7b04    	ldr	r7, [sp], #4
 8024e8a: 4770         	bx	lr

08024e8c <sys_dnode_is_linked>:
; {
 8024e8c: b480         	push	{r7}
 8024e8e: b083         	sub	sp, #0xc
 8024e90: af00         	add	r7, sp, #0x0
 8024e92: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 8024e94: 687b         	ldr	r3, [r7, #0x4]
 8024e96: 681b         	ldr	r3, [r3]
 8024e98: 2b00         	cmp	r3, #0x0
 8024e9a: bf14         	ite	ne
 8024e9c: 2301         	movne	r3, #0x1
 8024e9e: 2300         	moveq	r3, #0x0
 8024ea0: b2db         	uxtb	r3, r3
; }
 8024ea2: 4618         	mov	r0, r3
 8024ea4: 370c         	adds	r7, #0xc
 8024ea6: 46bd         	mov	sp, r7
 8024ea8: f85d 7b04    	ldr	r7, [sp], #4
 8024eac: 4770         	bx	lr

08024eae <sys_dlist_is_empty>:
; {
 8024eae: b480         	push	{r7}
 8024eb0: b083         	sub	sp, #0xc
 8024eb2: af00         	add	r7, sp, #0x0
 8024eb4: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8024eb6: 687b         	ldr	r3, [r7, #0x4]
 8024eb8: 681b         	ldr	r3, [r3]
 8024eba: 687a         	ldr	r2, [r7, #0x4]
 8024ebc: 429a         	cmp	r2, r3
 8024ebe: bf0c         	ite	eq
 8024ec0: 2301         	moveq	r3, #0x1
 8024ec2: 2300         	movne	r3, #0x0
 8024ec4: b2db         	uxtb	r3, r3
; }
 8024ec6: 4618         	mov	r0, r3
 8024ec8: 370c         	adds	r7, #0xc
 8024eca: 46bd         	mov	sp, r7
 8024ecc: f85d 7b04    	ldr	r7, [sp], #4
 8024ed0: 4770         	bx	lr

08024ed2 <sys_dlist_peek_head>:
; {
 8024ed2: b580         	push	{r7, lr}
 8024ed4: b082         	sub	sp, #0x8
 8024ed6: af00         	add	r7, sp, #0x0
 8024ed8: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8024eda: 6878         	ldr	r0, [r7, #0x4]
 8024edc: f7ff ffe7    	bl	0x8024eae <sys_dlist_is_empty> @ imm = #-0x32
 8024ee0: 4603         	mov	r3, r0
 8024ee2: 2b00         	cmp	r3, #0x0
 8024ee4: d102         	bne	0x8024eec <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8024ee6: 687b         	ldr	r3, [r7, #0x4]
 8024ee8: 681b         	ldr	r3, [r3]
 8024eea: e000         	b	0x8024eee <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8024eec: 2300         	movs	r3, #0x0
; }
 8024eee: 4618         	mov	r0, r3
 8024ef0: 3708         	adds	r7, #0x8
 8024ef2: 46bd         	mov	sp, r7
 8024ef4: bd80         	pop	{r7, pc}

08024ef6 <sys_dlist_remove>:
; {
 8024ef6: b580         	push	{r7, lr}
 8024ef8: b084         	sub	sp, #0x10
 8024efa: af00         	add	r7, sp, #0x0
 8024efc: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8024efe: 687b         	ldr	r3, [r7, #0x4]
 8024f00: 685b         	ldr	r3, [r3, #0x4]
 8024f02: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8024f04: 687b         	ldr	r3, [r7, #0x4]
 8024f06: 681b         	ldr	r3, [r3]
 8024f08: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8024f0a: 68fb         	ldr	r3, [r7, #0xc]
 8024f0c: 68ba         	ldr	r2, [r7, #0x8]
 8024f0e: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8024f10: 68bb         	ldr	r3, [r7, #0x8]
 8024f12: 68fa         	ldr	r2, [r7, #0xc]
 8024f14: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8024f16: 6878         	ldr	r0, [r7, #0x4]
 8024f18: f7ff ffa8    	bl	0x8024e6c <sys_dnode_init> @ imm = #-0xb0
; }
 8024f1c: bf00         	nop
 8024f1e: 3710         	adds	r7, #0x10
 8024f20: 46bd         	mov	sp, r7
 8024f22: bd80         	pop	{r7, pc}

08024f24 <k_object_init>:
; {
 8024f24: b480         	push	{r7}
 8024f26: b083         	sub	sp, #0xc
 8024f28: af00         	add	r7, sp, #0x0
 8024f2a: 6078         	str	r0, [r7, #0x4]
; }
 8024f2c: bf00         	nop
 8024f2e: 370c         	adds	r7, #0xc
 8024f30: 46bd         	mov	sp, r7
 8024f32: f85d 7b04    	ldr	r7, [sp], #4
 8024f36: 4770         	bx	lr

08024f38 <z_is_inactive_timeout>:
; {
 8024f38: b580         	push	{r7, lr}
 8024f3a: b082         	sub	sp, #0x8
 8024f3c: af00         	add	r7, sp, #0x0
 8024f3e: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 8024f40: 687b         	ldr	r3, [r7, #0x4]
 8024f42: 4618         	mov	r0, r3
 8024f44: f7ff ffa2    	bl	0x8024e8c <sys_dnode_is_linked> @ imm = #-0xbc
 8024f48: 4603         	mov	r3, r0
 8024f4a: 2b00         	cmp	r3, #0x0
 8024f4c: bf14         	ite	ne
 8024f4e: 2301         	movne	r3, #0x1
 8024f50: 2300         	moveq	r3, #0x0
 8024f52: b2db         	uxtb	r3, r3
 8024f54: f083 0301    	eor	r3, r3, #0x1
 8024f58: b2db         	uxtb	r3, r3
 8024f5a: f003 0301    	and	r3, r3, #0x1
 8024f5e: b2db         	uxtb	r3, r3
; }
 8024f60: 4618         	mov	r0, r3
 8024f62: 3708         	adds	r7, #0x8
 8024f64: 46bd         	mov	sp, r7
 8024f66: bd80         	pop	{r7, pc}

08024f68 <z_abort_thread_timeout>:
; {
 8024f68: b580         	push	{r7, lr}
 8024f6a: b082         	sub	sp, #0x8
 8024f6c: af00         	add	r7, sp, #0x0
 8024f6e: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8024f70: 687b         	ldr	r3, [r7, #0x4]
 8024f72: 3318         	adds	r3, #0x18
 8024f74: 4618         	mov	r0, r3
 8024f76: f7f1 ff45    	bl	0x8016e04 <z_abort_timeout> @ imm = #-0xe176
 8024f7a: 4603         	mov	r3, r0
; }
 8024f7c: 4618         	mov	r0, r3
 8024f7e: 3708         	adds	r7, #0x8
 8024f80: 46bd         	mov	sp, r7
 8024f82: bd80         	pop	{r7, pc}

08024f84 <z_is_thread_prevented_from_running>:
; {
 8024f84: b480         	push	{r7}
 8024f86: b085         	sub	sp, #0x14
 8024f88: af00         	add	r7, sp, #0x0
 8024f8a: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8024f8c: 687b         	ldr	r3, [r7, #0x4]
 8024f8e: 7b5b         	ldrb	r3, [r3, #0xd]
 8024f90: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 8024f92: 7bfb         	ldrb	r3, [r7, #0xf]
 8024f94: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 8024f98: 2b00         	cmp	r3, #0x0
 8024f9a: bf14         	ite	ne
 8024f9c: 2301         	movne	r3, #0x1
 8024f9e: 2300         	moveq	r3, #0x0
 8024fa0: b2db         	uxtb	r3, r3
; }
 8024fa2: 4618         	mov	r0, r3
 8024fa4: 3714         	adds	r7, #0x14
 8024fa6: 46bd         	mov	sp, r7
 8024fa8: f85d 7b04    	ldr	r7, [sp], #4
 8024fac: 4770         	bx	lr

08024fae <z_is_thread_timeout_active>:
; {
 8024fae: b580         	push	{r7, lr}
 8024fb0: b082         	sub	sp, #0x8
 8024fb2: af00         	add	r7, sp, #0x0
 8024fb4: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 8024fb6: 687b         	ldr	r3, [r7, #0x4]
 8024fb8: 3318         	adds	r3, #0x18
 8024fba: 4618         	mov	r0, r3
 8024fbc: f7ff ffbc    	bl	0x8024f38 <z_is_inactive_timeout> @ imm = #-0x88
 8024fc0: 4603         	mov	r3, r0
 8024fc2: 2b00         	cmp	r3, #0x0
 8024fc4: bf14         	ite	ne
 8024fc6: 2301         	movne	r3, #0x1
 8024fc8: 2300         	moveq	r3, #0x0
 8024fca: b2db         	uxtb	r3, r3
 8024fcc: f083 0301    	eor	r3, r3, #0x1
 8024fd0: b2db         	uxtb	r3, r3
 8024fd2: f003 0301    	and	r3, r3, #0x1
 8024fd6: b2db         	uxtb	r3, r3
; }
 8024fd8: 4618         	mov	r0, r3
 8024fda: 3708         	adds	r7, #0x8
 8024fdc: 46bd         	mov	sp, r7
 8024fde: bd80         	pop	{r7, pc}

08024fe0 <z_is_thread_ready>:
; {
 8024fe0: b580         	push	{r7, lr}
 8024fe2: b082         	sub	sp, #0x8
 8024fe4: af00         	add	r7, sp, #0x0
 8024fe6: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 8024fe8: 6878         	ldr	r0, [r7, #0x4]
 8024fea: f7ff ffcb    	bl	0x8024f84 <z_is_thread_prevented_from_running> @ imm = #-0x6a
 8024fee: 4603         	mov	r3, r0
 8024ff0: f083 0301    	eor	r3, r3, #0x1
 8024ff4: b2db         	uxtb	r3, r3
 8024ff6: 2b00         	cmp	r3, #0x0
 8024ff8: d00a         	beq	0x8025010 <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 8024ffa: 6878         	ldr	r0, [r7, #0x4]
 8024ffc: f7ff ffd7    	bl	0x8024fae <z_is_thread_timeout_active> @ imm = #-0x52
 8025000: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 8025002: f083 0301    	eor	r3, r3, #0x1
 8025006: b2db         	uxtb	r3, r3
 8025008: 2b00         	cmp	r3, #0x0
 802500a: d001         	beq	0x8025010 <z_is_thread_ready+0x30> @ imm = #0x2
 802500c: 2301         	movs	r3, #0x1
 802500e: e000         	b	0x8025012 <z_is_thread_ready+0x32> @ imm = #0x0
 8025010: 2300         	movs	r3, #0x0
 8025012: f003 0301    	and	r3, r3, #0x1
 8025016: b2db         	uxtb	r3, r3
; }
 8025018: 4618         	mov	r0, r3
 802501a: 3708         	adds	r7, #0x8
 802501c: 46bd         	mov	sp, r7
 802501e: bd80         	pop	{r7, pc}

08025020 <z_mark_thread_as_not_pending>:
; {
 8025020: b480         	push	{r7}
 8025022: b083         	sub	sp, #0xc
 8025024: af00         	add	r7, sp, #0x0
 8025026: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8025028: 687b         	ldr	r3, [r7, #0x4]
 802502a: 7b5b         	ldrb	r3, [r3, #0xd]
 802502c: f023 0302    	bic	r3, r3, #0x2
 8025030: b2da         	uxtb	r2, r3
 8025032: 687b         	ldr	r3, [r7, #0x4]
 8025034: 735a         	strb	r2, [r3, #0xd]
; }
 8025036: bf00         	nop
 8025038: 370c         	adds	r7, #0xc
 802503a: 46bd         	mov	sp, r7
 802503c: f85d 7b04    	ldr	r7, [sp], #4
 8025040: 4770         	bx	lr

08025042 <z_is_under_prio_ceiling>:
; {
 8025042: b480         	push	{r7}
 8025044: b083         	sub	sp, #0xc
 8025046: af00         	add	r7, sp, #0x0
 8025048: 6078         	str	r0, [r7, #0x4]
; 	return prio >= CONFIG_PRIORITY_CEILING;
 802504a: 687b         	ldr	r3, [r7, #0x4]
 802504c: f113 0f7f    	cmn.w	r3, #0x7f
 8025050: bfac         	ite	ge
 8025052: 2301         	movge	r3, #0x1
 8025054: 2300         	movlt	r3, #0x0
 8025056: b2db         	uxtb	r3, r3
; }
 8025058: 4618         	mov	r0, r3
 802505a: 370c         	adds	r7, #0xc
 802505c: 46bd         	mov	sp, r7
 802505e: f85d 7b04    	ldr	r7, [sp], #4
 8025062: 4770         	bx	lr

08025064 <z_get_new_prio_with_ceiling>:
; {
 8025064: b580         	push	{r7, lr}
 8025066: b082         	sub	sp, #0x8
 8025068: af00         	add	r7, sp, #0x0
 802506a: 6078         	str	r0, [r7, #0x4]
; 	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
 802506c: 6878         	ldr	r0, [r7, #0x4]
 802506e: f7ff ffe8    	bl	0x8025042 <z_is_under_prio_ceiling> @ imm = #-0x30
 8025072: 4603         	mov	r3, r0
 8025074: 2b00         	cmp	r3, #0x0
 8025076: d001         	beq	0x802507c <z_get_new_prio_with_ceiling+0x18> @ imm = #0x2
 8025078: 687b         	ldr	r3, [r7, #0x4]
 802507a: e001         	b	0x8025080 <z_get_new_prio_with_ceiling+0x1c> @ imm = #0x2
 802507c: f06f 037e    	mvn	r3, #0x7e
; }
 8025080: 4618         	mov	r0, r3
 8025082: 3708         	adds	r7, #0x8
 8025084: 46bd         	mov	sp, r7
 8025086: bd80         	pop	{r7, pc}

08025088 <z_is_prio1_higher_than_prio2>:
; {
 8025088: b480         	push	{r7}
 802508a: b083         	sub	sp, #0xc
 802508c: af00         	add	r7, sp, #0x0
 802508e: 6078         	str	r0, [r7, #0x4]
 8025090: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 8025092: 687a         	ldr	r2, [r7, #0x4]
 8025094: 683b         	ldr	r3, [r7]
 8025096: 429a         	cmp	r2, r3
 8025098: bfb4         	ite	lt
 802509a: 2301         	movlt	r3, #0x1
 802509c: 2300         	movge	r3, #0x0
 802509e: b2db         	uxtb	r3, r3
; }
 80250a0: 4618         	mov	r0, r3
 80250a2: 370c         	adds	r7, #0xc
 80250a4: 46bd         	mov	sp, r7
 80250a6: f85d 7b04    	ldr	r7, [sp], #4
 80250aa: 4770         	bx	lr

080250ac <z_is_prio_higher>:
; {
 80250ac: b580         	push	{r7, lr}
 80250ae: b082         	sub	sp, #0x8
 80250b0: af00         	add	r7, sp, #0x0
 80250b2: 6078         	str	r0, [r7, #0x4]
 80250b4: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 80250b6: 6839         	ldr	r1, [r7]
 80250b8: 6878         	ldr	r0, [r7, #0x4]
 80250ba: f7ff ffe5    	bl	0x8025088 <z_is_prio1_higher_than_prio2> @ imm = #-0x36
 80250be: 4603         	mov	r3, r0
; }
 80250c0: 4618         	mov	r0, r3
 80250c2: 3708         	adds	r7, #0x8
 80250c4: 46bd         	mov	sp, r7
 80250c6: bd80         	pop	{r7, pc}

080250c8 <unpend_thread_no_timeout>:
; {
 80250c8: b580         	push	{r7, lr}
 80250ca: b086         	sub	sp, #0x18
 80250cc: af00         	add	r7, sp, #0x0
 80250ce: 6078         	str	r0, [r7, #0x4]
 80250d0: 687b         	ldr	r3, [r7, #0x4]
 80250d2: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 80250d4: 68fb         	ldr	r3, [r7, #0xc]
 80250d6: 689b         	ldr	r3, [r3, #0x8]
 80250d8: 617b         	str	r3, [r7, #0x14]
 80250da: 687b         	ldr	r3, [r7, #0x4]
 80250dc: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 80250de: 693b         	ldr	r3, [r7, #0x10]
 80250e0: 4618         	mov	r0, r3
 80250e2: f7ff ff08    	bl	0x8024ef6 <sys_dlist_remove> @ imm = #-0x1f0
; }
 80250e6: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 80250e8: 6878         	ldr	r0, [r7, #0x4]
 80250ea: f7ff ff99    	bl	0x8025020 <z_mark_thread_as_not_pending> @ imm = #-0xce
; 	thread->base.pended_on = NULL;
 80250ee: 687b         	ldr	r3, [r7, #0x4]
 80250f0: 2200         	movs	r2, #0x0
 80250f2: 609a         	str	r2, [r3, #0x8]
; }
 80250f4: bf00         	nop
 80250f6: 3718         	adds	r7, #0x18
 80250f8: 46bd         	mov	sp, r7
 80250fa: bd80         	pop	{r7, pc}

080250fc <z_waitq_init>:
; {
 80250fc: b580         	push	{r7, lr}
 80250fe: b082         	sub	sp, #0x8
 8025100: af00         	add	r7, sp, #0x0
 8025102: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8025104: 687b         	ldr	r3, [r7, #0x4]
 8025106: 4618         	mov	r0, r3
 8025108: f7ff fea0    	bl	0x8024e4c <sys_dlist_init> @ imm = #-0x2c0
; }
 802510c: bf00         	nop
 802510e: 3708         	adds	r7, #0x8
 8025110: 46bd         	mov	sp, r7
 8025112: bd80         	pop	{r7, pc}

08025114 <z_waitq_head>:
; {
 8025114: b580         	push	{r7, lr}
 8025116: b082         	sub	sp, #0x8
 8025118: af00         	add	r7, sp, #0x0
 802511a: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 802511c: 687b         	ldr	r3, [r7, #0x4]
 802511e: 4618         	mov	r0, r3
 8025120: f7ff fed7    	bl	0x8024ed2 <sys_dlist_peek_head> @ imm = #-0x252
 8025124: 4603         	mov	r3, r0
; }
 8025126: 4618         	mov	r0, r3
 8025128: 3708         	adds	r7, #0x8
 802512a: 46bd         	mov	sp, r7
 802512c: bd80         	pop	{r7, pc}

0802512e <z_log_msg_runtime_create>:
; {
 802512e: b580         	push	{r7, lr}
 8025130: b08a         	sub	sp, #0x28
 8025132: af04         	add	r7, sp, #0x10
 8025134: 60b9         	str	r1, [r7, #0x8]
 8025136: 607b         	str	r3, [r7, #0x4]
 8025138: 4603         	mov	r3, r0
 802513a: 73fb         	strb	r3, [r7, #0xf]
 802513c: 4613         	mov	r3, r2
 802513e: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8025140: f107 032c    	add.w	r3, r7, #0x2c
 8025144: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8025146: 7bba         	ldrb	r2, [r7, #0xe]
 8025148: 7bf8         	ldrb	r0, [r7, #0xf]
 802514a: 697b         	ldr	r3, [r7, #0x14]
 802514c: 9303         	str	r3, [sp, #0xc]
 802514e: 6abb         	ldr	r3, [r7, #0x28]
 8025150: 9302         	str	r3, [sp, #0x8]
 8025152: 6a7b         	ldr	r3, [r7, #0x24]
 8025154: 9301         	str	r3, [sp, #0x4]
 8025156: 6a3b         	ldr	r3, [r7, #0x20]
 8025158: 9300         	str	r3, [sp]
 802515a: 687b         	ldr	r3, [r7, #0x4]
 802515c: 68b9         	ldr	r1, [r7, #0x8]
 802515e: f7df fcf1    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x2061e
; }
 8025162: bf00         	nop
 8025164: 3718         	adds	r7, #0x18
 8025166: 46bd         	mov	sp, r7
 8025168: bd80         	pop	{r7, pc}

0802516a <z_impl_k_mutex_init>:
; {
 802516a: b580         	push	{r7, lr}
 802516c: b082         	sub	sp, #0x8
 802516e: af00         	add	r7, sp, #0x0
 8025170: 6078         	str	r0, [r7, #0x4]
; 	mutex->owner = NULL;
 8025172: 687b         	ldr	r3, [r7, #0x4]
 8025174: 2200         	movs	r2, #0x0
 8025176: 609a         	str	r2, [r3, #0x8]
; 	mutex->lock_count = 0U;
 8025178: 687b         	ldr	r3, [r7, #0x4]
 802517a: 2200         	movs	r2, #0x0
 802517c: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&mutex->wait_q);
 802517e: 687b         	ldr	r3, [r7, #0x4]
 8025180: 4618         	mov	r0, r3
 8025182: f7ff ffbb    	bl	0x80250fc <z_waitq_init> @ imm = #-0x8a
; 	k_object_init(mutex);
 8025186: 6878         	ldr	r0, [r7, #0x4]
 8025188: f7ff fecc    	bl	0x8024f24 <k_object_init> @ imm = #-0x268
; 	return 0;
 802518c: 2300         	movs	r3, #0x0
; }
 802518e: 4618         	mov	r0, r3
 8025190: 3708         	adds	r7, #0x8
 8025192: 46bd         	mov	sp, r7
 8025194: bd80         	pop	{r7, pc}

08025196 <new_prio_for_inheritance>:
; {
 8025196: b580         	push	{r7, lr}
 8025198: b084         	sub	sp, #0x10
 802519a: af00         	add	r7, sp, #0x0
 802519c: 6078         	str	r0, [r7, #0x4]
 802519e: 6039         	str	r1, [r7]
; 	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
 80251a0: 6839         	ldr	r1, [r7]
 80251a2: 6878         	ldr	r0, [r7, #0x4]
 80251a4: f7ff ff82    	bl	0x80250ac <z_is_prio_higher> @ imm = #-0xfc
 80251a8: 4603         	mov	r3, r0
 80251aa: 2b00         	cmp	r3, #0x0
 80251ac: d001         	beq	0x80251b2 <new_prio_for_inheritance+0x1c> @ imm = #0x2
 80251ae: 687b         	ldr	r3, [r7, #0x4]
 80251b0: e000         	b	0x80251b4 <new_prio_for_inheritance+0x1e> @ imm = #0x0
 80251b2: 683b         	ldr	r3, [r7]
 80251b4: 60fb         	str	r3, [r7, #0xc]
; 	new_prio = z_get_new_prio_with_ceiling(new_prio);
 80251b6: 68f8         	ldr	r0, [r7, #0xc]
 80251b8: f7ff ff54    	bl	0x8025064 <z_get_new_prio_with_ceiling> @ imm = #-0x158
 80251bc: 60f8         	str	r0, [r7, #0xc]
; 	return new_prio;
 80251be: 68fb         	ldr	r3, [r7, #0xc]
; }
 80251c0: 4618         	mov	r0, r3
 80251c2: 3710         	adds	r7, #0x10
 80251c4: 46bd         	mov	sp, r7
 80251c6: bd80         	pop	{r7, pc}

080251c8 <sys_dnode_init>:
; {
 80251c8: b480         	push	{r7}
 80251ca: b083         	sub	sp, #0xc
 80251cc: af00         	add	r7, sp, #0x0
 80251ce: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 80251d0: 687b         	ldr	r3, [r7, #0x4]
 80251d2: 2200         	movs	r2, #0x0
 80251d4: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 80251d6: 687b         	ldr	r3, [r7, #0x4]
 80251d8: 2200         	movs	r2, #0x0
 80251da: 605a         	str	r2, [r3, #0x4]
; }
 80251dc: bf00         	nop
 80251de: 370c         	adds	r7, #0xc
 80251e0: 46bd         	mov	sp, r7
 80251e2: f85d 7b04    	ldr	r7, [sp], #4
 80251e6: 4770         	bx	lr

080251e8 <sys_dlist_is_empty>:
; {
 80251e8: b480         	push	{r7}
 80251ea: b083         	sub	sp, #0xc
 80251ec: af00         	add	r7, sp, #0x0
 80251ee: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 80251f0: 687b         	ldr	r3, [r7, #0x4]
 80251f2: 681b         	ldr	r3, [r3]
 80251f4: 687a         	ldr	r2, [r7, #0x4]
 80251f6: 429a         	cmp	r2, r3
 80251f8: bf0c         	ite	eq
 80251fa: 2301         	moveq	r3, #0x1
 80251fc: 2300         	movne	r3, #0x0
 80251fe: b2db         	uxtb	r3, r3
; }
 8025200: 4618         	mov	r0, r3
 8025202: 370c         	adds	r7, #0xc
 8025204: 46bd         	mov	sp, r7
 8025206: f85d 7b04    	ldr	r7, [sp], #4
 802520a: 4770         	bx	lr

0802520c <sys_dlist_peek_head>:
; {
 802520c: b580         	push	{r7, lr}
 802520e: b082         	sub	sp, #0x8
 8025210: af00         	add	r7, sp, #0x0
 8025212: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8025214: 6878         	ldr	r0, [r7, #0x4]
 8025216: f7ff ffe7    	bl	0x80251e8 <sys_dlist_is_empty> @ imm = #-0x32
 802521a: 4603         	mov	r3, r0
 802521c: 2b00         	cmp	r3, #0x0
 802521e: d102         	bne	0x8025226 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8025220: 687b         	ldr	r3, [r7, #0x4]
 8025222: 681b         	ldr	r3, [r3]
 8025224: e000         	b	0x8025228 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8025226: 2300         	movs	r3, #0x0
; }
 8025228: 4618         	mov	r0, r3
 802522a: 3708         	adds	r7, #0x8
 802522c: 46bd         	mov	sp, r7
 802522e: bd80         	pop	{r7, pc}

08025230 <sys_dlist_remove>:
; {
 8025230: b580         	push	{r7, lr}
 8025232: b084         	sub	sp, #0x10
 8025234: af00         	add	r7, sp, #0x0
 8025236: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8025238: 687b         	ldr	r3, [r7, #0x4]
 802523a: 685b         	ldr	r3, [r3, #0x4]
 802523c: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 802523e: 687b         	ldr	r3, [r7, #0x4]
 8025240: 681b         	ldr	r3, [r3]
 8025242: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8025244: 68fb         	ldr	r3, [r7, #0xc]
 8025246: 68ba         	ldr	r2, [r7, #0x8]
 8025248: 601a         	str	r2, [r3]
; 	next->prev = prev;
 802524a: 68bb         	ldr	r3, [r7, #0x8]
 802524c: 68fa         	ldr	r2, [r7, #0xc]
 802524e: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8025250: 6878         	ldr	r0, [r7, #0x4]
 8025252: f7ff ffb9    	bl	0x80251c8 <sys_dnode_init> @ imm = #-0x8e
; }
 8025256: bf00         	nop
 8025258: 3710         	adds	r7, #0x10
 802525a: 46bd         	mov	sp, r7
 802525c: bd80         	pop	{r7, pc}

0802525e <z_sfnode_next_peek>:
; {
 802525e: b480         	push	{r7}
 8025260: b083         	sub	sp, #0xc
 8025262: af00         	add	r7, sp, #0x0
 8025264: 6078         	str	r0, [r7, #0x4]
; 	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 8025266: 687b         	ldr	r3, [r7, #0x4]
 8025268: 681b         	ldr	r3, [r3]
 802526a: f023 0303    	bic	r3, r3, #0x3
; }
 802526e: 4618         	mov	r0, r3
 8025270: 370c         	adds	r7, #0xc
 8025272: 46bd         	mov	sp, r7
 8025274: f85d 7b04    	ldr	r7, [sp], #4
 8025278: 4770         	bx	lr

0802527a <z_sfnode_next_set>:
; {
 802527a: b580         	push	{r7, lr}
 802527c: b084         	sub	sp, #0x10
 802527e: af00         	add	r7, sp, #0x0
 8025280: 6078         	str	r0, [r7, #0x4]
 8025282: 6039         	str	r1, [r7]
; 	uint8_t cur_flags = sys_sfnode_flags_get(parent);
 8025284: 6878         	ldr	r0, [r7, #0x4]
 8025286: f000 f83f    	bl	0x8025308 <sys_sfnode_flags_get> @ imm = #0x7e
 802528a: 4603         	mov	r3, r0
 802528c: 73fb         	strb	r3, [r7, #0xf]
; 	parent->next_and_flags = cur_flags | (uintptr_t)child;
 802528e: 7bfa         	ldrb	r2, [r7, #0xf]
 8025290: 683b         	ldr	r3, [r7]
 8025292: 431a         	orrs	r2, r3
 8025294: 687b         	ldr	r3, [r7, #0x4]
 8025296: 601a         	str	r2, [r3]
; }
 8025298: bf00         	nop
 802529a: 3710         	adds	r7, #0x10
 802529c: 46bd         	mov	sp, r7
 802529e: bd80         	pop	{r7, pc}

080252a0 <z_sflist_head_set>:
; {
 80252a0: b480         	push	{r7}
 80252a2: b083         	sub	sp, #0xc
 80252a4: af00         	add	r7, sp, #0x0
 80252a6: 6078         	str	r0, [r7, #0x4]
 80252a8: 6039         	str	r1, [r7]
; 	list->head = node;
 80252aa: 687b         	ldr	r3, [r7, #0x4]
 80252ac: 683a         	ldr	r2, [r7]
 80252ae: 601a         	str	r2, [r3]
; }
 80252b0: bf00         	nop
 80252b2: 370c         	adds	r7, #0xc
 80252b4: 46bd         	mov	sp, r7
 80252b6: f85d 7b04    	ldr	r7, [sp], #4
 80252ba: 4770         	bx	lr

080252bc <z_sflist_tail_set>:
; {
 80252bc: b480         	push	{r7}
 80252be: b083         	sub	sp, #0xc
 80252c0: af00         	add	r7, sp, #0x0
 80252c2: 6078         	str	r0, [r7, #0x4]
 80252c4: 6039         	str	r1, [r7]
; 	list->tail = node;
 80252c6: 687b         	ldr	r3, [r7, #0x4]
 80252c8: 683a         	ldr	r2, [r7]
 80252ca: 605a         	str	r2, [r3, #0x4]
; }
 80252cc: bf00         	nop
 80252ce: 370c         	adds	r7, #0xc
 80252d0: 46bd         	mov	sp, r7
 80252d2: f85d 7b04    	ldr	r7, [sp], #4
 80252d6: 4770         	bx	lr

080252d8 <sys_sflist_peek_head>:
; {
 80252d8: b480         	push	{r7}
 80252da: b083         	sub	sp, #0xc
 80252dc: af00         	add	r7, sp, #0x0
 80252de: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 80252e0: 687b         	ldr	r3, [r7, #0x4]
 80252e2: 681b         	ldr	r3, [r3]
; }
 80252e4: 4618         	mov	r0, r3
 80252e6: 370c         	adds	r7, #0xc
 80252e8: 46bd         	mov	sp, r7
 80252ea: f85d 7b04    	ldr	r7, [sp], #4
 80252ee: 4770         	bx	lr

080252f0 <sys_sflist_peek_tail>:
; {
 80252f0: b480         	push	{r7}
 80252f2: b083         	sub	sp, #0xc
 80252f4: af00         	add	r7, sp, #0x0
 80252f6: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 80252f8: 687b         	ldr	r3, [r7, #0x4]
 80252fa: 685b         	ldr	r3, [r3, #0x4]
; }
 80252fc: 4618         	mov	r0, r3
 80252fe: 370c         	adds	r7, #0xc
 8025300: 46bd         	mov	sp, r7
 8025302: f85d 7b04    	ldr	r7, [sp], #4
 8025306: 4770         	bx	lr

08025308 <sys_sfnode_flags_get>:
; {
 8025308: b480         	push	{r7}
 802530a: b083         	sub	sp, #0xc
 802530c: af00         	add	r7, sp, #0x0
 802530e: 6078         	str	r0, [r7, #0x4]
; 	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 8025310: 687b         	ldr	r3, [r7, #0x4]
 8025312: 681b         	ldr	r3, [r3]
 8025314: b2db         	uxtb	r3, r3
 8025316: f003 0303    	and	r3, r3, #0x3
 802531a: b2db         	uxtb	r3, r3
; }
 802531c: 4618         	mov	r0, r3
 802531e: 370c         	adds	r7, #0xc
 8025320: 46bd         	mov	sp, r7
 8025322: f85d 7b04    	ldr	r7, [sp], #4
 8025326: 4770         	bx	lr

08025328 <sys_sfnode_init>:
; {
 8025328: b480         	push	{r7}
 802532a: b083         	sub	sp, #0xc
 802532c: af00         	add	r7, sp, #0x0
 802532e: 6078         	str	r0, [r7, #0x4]
 8025330: 460b         	mov	r3, r1
 8025332: 70fb         	strb	r3, [r7, #0x3]
; 	node->next_and_flags = flags;
 8025334: 78fa         	ldrb	r2, [r7, #0x3]
 8025336: 687b         	ldr	r3, [r7, #0x4]
 8025338: 601a         	str	r2, [r3]
; }
 802533a: bf00         	nop
 802533c: 370c         	adds	r7, #0xc
 802533e: 46bd         	mov	sp, r7
 8025340: f85d 7b04    	ldr	r7, [sp], #4
 8025344: 4770         	bx	lr

08025346 <sys_sflist_is_empty>:
; Z_GENLIST_IS_EMPTY(sflist)
 8025346: b580         	push	{r7, lr}
 8025348: b082         	sub	sp, #0x8
 802534a: af00         	add	r7, sp, #0x0
 802534c: 6078         	str	r0, [r7, #0x4]
 802534e: 6878         	ldr	r0, [r7, #0x4]
 8025350: f7ff ffc2    	bl	0x80252d8 <sys_sflist_peek_head> @ imm = #-0x7c
 8025354: 4603         	mov	r3, r0
 8025356: 2b00         	cmp	r3, #0x0
 8025358: bf0c         	ite	eq
 802535a: 2301         	moveq	r3, #0x1
 802535c: 2300         	movne	r3, #0x0
 802535e: b2db         	uxtb	r3, r3
 8025360: 4618         	mov	r0, r3
 8025362: 3708         	adds	r7, #0x8
 8025364: 46bd         	mov	sp, r7
 8025366: bd80         	pop	{r7, pc}

08025368 <sys_sflist_prepend>:
; Z_GENLIST_PREPEND(sflist, sfnode)
 8025368: b580         	push	{r7, lr}
 802536a: b082         	sub	sp, #0x8
 802536c: af00         	add	r7, sp, #0x0
 802536e: 6078         	str	r0, [r7, #0x4]
 8025370: 6039         	str	r1, [r7]
 8025372: 6878         	ldr	r0, [r7, #0x4]
 8025374: f7ff ffb0    	bl	0x80252d8 <sys_sflist_peek_head> @ imm = #-0xa0
 8025378: 4603         	mov	r3, r0
 802537a: 4619         	mov	r1, r3
 802537c: 6838         	ldr	r0, [r7]
 802537e: f7ff ff7c    	bl	0x802527a <z_sfnode_next_set> @ imm = #-0x108
 8025382: 6839         	ldr	r1, [r7]
 8025384: 6878         	ldr	r0, [r7, #0x4]
 8025386: f7ff ff8b    	bl	0x80252a0 <z_sflist_head_set> @ imm = #-0xea
 802538a: 6878         	ldr	r0, [r7, #0x4]
 802538c: f7ff ffb0    	bl	0x80252f0 <sys_sflist_peek_tail> @ imm = #-0xa0
 8025390: 4603         	mov	r3, r0
 8025392: 2b00         	cmp	r3, #0x0
 8025394: d107         	bne	0x80253a6 <sys_sflist_prepend+0x3e> @ imm = #0xe
 8025396: 6878         	ldr	r0, [r7, #0x4]
 8025398: f7ff ff9e    	bl	0x80252d8 <sys_sflist_peek_head> @ imm = #-0xc4
 802539c: 4603         	mov	r3, r0
 802539e: 4619         	mov	r1, r3
 80253a0: 6878         	ldr	r0, [r7, #0x4]
 80253a2: f7ff ff8b    	bl	0x80252bc <z_sflist_tail_set> @ imm = #-0xea
 80253a6: 3708         	adds	r7, #0x8
 80253a8: 46bd         	mov	sp, r7
 80253aa: bd80         	pop	{r7, pc}

080253ac <sys_sflist_append>:
; Z_GENLIST_APPEND(sflist, sfnode)
 80253ac: b580         	push	{r7, lr}
 80253ae: b082         	sub	sp, #0x8
 80253b0: af00         	add	r7, sp, #0x0
 80253b2: 6078         	str	r0, [r7, #0x4]
 80253b4: 6039         	str	r1, [r7]
 80253b6: 2100         	movs	r1, #0x0
 80253b8: 6838         	ldr	r0, [r7]
 80253ba: f7ff ff5e    	bl	0x802527a <z_sfnode_next_set> @ imm = #-0x144
 80253be: 6878         	ldr	r0, [r7, #0x4]
 80253c0: f7ff ff96    	bl	0x80252f0 <sys_sflist_peek_tail> @ imm = #-0xd4
 80253c4: 4603         	mov	r3, r0
 80253c6: 2b00         	cmp	r3, #0x0
 80253c8: d108         	bne	0x80253dc <sys_sflist_append+0x30> @ imm = #0x10
 80253ca: 6839         	ldr	r1, [r7]
 80253cc: 6878         	ldr	r0, [r7, #0x4]
 80253ce: f7ff ff75    	bl	0x80252bc <z_sflist_tail_set> @ imm = #-0x116
 80253d2: 6839         	ldr	r1, [r7]
 80253d4: 6878         	ldr	r0, [r7, #0x4]
 80253d6: f7ff ff63    	bl	0x80252a0 <z_sflist_head_set> @ imm = #-0x13a
 80253da: e00b         	b	0x80253f4 <sys_sflist_append+0x48> @ imm = #0x16
 80253dc: 6878         	ldr	r0, [r7, #0x4]
 80253de: f7ff ff87    	bl	0x80252f0 <sys_sflist_peek_tail> @ imm = #-0xf2
 80253e2: 4603         	mov	r3, r0
 80253e4: 6839         	ldr	r1, [r7]
 80253e6: 4618         	mov	r0, r3
 80253e8: f7ff ff47    	bl	0x802527a <z_sfnode_next_set> @ imm = #-0x172
 80253ec: 6839         	ldr	r1, [r7]
 80253ee: 6878         	ldr	r0, [r7, #0x4]
 80253f0: f7ff ff64    	bl	0x80252bc <z_sflist_tail_set> @ imm = #-0x138
 80253f4: 3708         	adds	r7, #0x8
 80253f6: 46bd         	mov	sp, r7
 80253f8: bd80         	pop	{r7, pc}

080253fa <sys_sflist_insert>:
; Z_GENLIST_INSERT(sflist, sfnode)
 80253fa: b580         	push	{r7, lr}
 80253fc: b084         	sub	sp, #0x10
 80253fe: af00         	add	r7, sp, #0x0
 8025400: 60f8         	str	r0, [r7, #0xc]
 8025402: 60b9         	str	r1, [r7, #0x8]
 8025404: 607a         	str	r2, [r7, #0x4]
 8025406: 68bb         	ldr	r3, [r7, #0x8]
 8025408: 2b00         	cmp	r3, #0x0
 802540a: d104         	bne	0x8025416 <sys_sflist_insert+0x1c> @ imm = #0x8
 802540c: 6879         	ldr	r1, [r7, #0x4]
 802540e: 68f8         	ldr	r0, [r7, #0xc]
 8025410: f7ff ffaa    	bl	0x8025368 <sys_sflist_prepend> @ imm = #-0xac
 8025414: e016         	b	0x8025444 <sys_sflist_insert+0x4a> @ imm = #0x2c
 8025416: 68b8         	ldr	r0, [r7, #0x8]
 8025418: f7ff ff21    	bl	0x802525e <z_sfnode_next_peek> @ imm = #-0x1be
 802541c: 4603         	mov	r3, r0
 802541e: 2b00         	cmp	r3, #0x0
 8025420: d104         	bne	0x802542c <sys_sflist_insert+0x32> @ imm = #0x8
 8025422: 6879         	ldr	r1, [r7, #0x4]
 8025424: 68f8         	ldr	r0, [r7, #0xc]
 8025426: f7ff ffc1    	bl	0x80253ac <sys_sflist_append> @ imm = #-0x7e
 802542a: e00b         	b	0x8025444 <sys_sflist_insert+0x4a> @ imm = #0x16
 802542c: 68b8         	ldr	r0, [r7, #0x8]
 802542e: f7ff ff16    	bl	0x802525e <z_sfnode_next_peek> @ imm = #-0x1d4
 8025432: 4603         	mov	r3, r0
 8025434: 4619         	mov	r1, r3
 8025436: 6878         	ldr	r0, [r7, #0x4]
 8025438: f7ff ff1f    	bl	0x802527a <z_sfnode_next_set> @ imm = #-0x1c2
 802543c: 6879         	ldr	r1, [r7, #0x4]
 802543e: 68b8         	ldr	r0, [r7, #0x8]
 8025440: f7ff ff1b    	bl	0x802527a <z_sfnode_next_set> @ imm = #-0x1ca
 8025444: 3710         	adds	r7, #0x10
 8025446: 46bd         	mov	sp, r7
 8025448: bd80         	pop	{r7, pc}

0802544a <sys_sflist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
 802544a: b580         	push	{r7, lr}
 802544c: b084         	sub	sp, #0x10
 802544e: af00         	add	r7, sp, #0x0
 8025450: 6078         	str	r0, [r7, #0x4]
 8025452: 6878         	ldr	r0, [r7, #0x4]
 8025454: f7ff ff40    	bl	0x80252d8 <sys_sflist_peek_head> @ imm = #-0x180
 8025458: 60f8         	str	r0, [r7, #0xc]
 802545a: 68f8         	ldr	r0, [r7, #0xc]
 802545c: f7ff feff    	bl	0x802525e <z_sfnode_next_peek> @ imm = #-0x202
 8025460: 4603         	mov	r3, r0
 8025462: 4619         	mov	r1, r3
 8025464: 6878         	ldr	r0, [r7, #0x4]
 8025466: f7ff ff1b    	bl	0x80252a0 <z_sflist_head_set> @ imm = #-0x1ca
 802546a: 6878         	ldr	r0, [r7, #0x4]
 802546c: f7ff ff40    	bl	0x80252f0 <sys_sflist_peek_tail> @ imm = #-0x180
 8025470: 4602         	mov	r2, r0
 8025472: 68fb         	ldr	r3, [r7, #0xc]
 8025474: 4293         	cmp	r3, r2
 8025476: d107         	bne	0x8025488 <sys_sflist_get_not_empty+0x3e> @ imm = #0xe
 8025478: 6878         	ldr	r0, [r7, #0x4]
 802547a: f7ff ff2d    	bl	0x80252d8 <sys_sflist_peek_head> @ imm = #-0x1a6
 802547e: 4603         	mov	r3, r0
 8025480: 4619         	mov	r1, r3
 8025482: 6878         	ldr	r0, [r7, #0x4]
 8025484: f7ff ff1a    	bl	0x80252bc <z_sflist_tail_set> @ imm = #-0x1cc
 8025488: 68fb         	ldr	r3, [r7, #0xc]
 802548a: 4618         	mov	r0, r3
 802548c: 3710         	adds	r7, #0x10
 802548e: 46bd         	mov	sp, r7
 8025490: bd80         	pop	{r7, pc}

08025492 <z_abort_thread_timeout>:
; {
 8025492: b580         	push	{r7, lr}
 8025494: b082         	sub	sp, #0x8
 8025496: af00         	add	r7, sp, #0x0
 8025498: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 802549a: 687b         	ldr	r3, [r7, #0x4]
 802549c: 3318         	adds	r3, #0x18
 802549e: 4618         	mov	r0, r3
 80254a0: f7f1 fcb0    	bl	0x8016e04 <z_abort_timeout> @ imm = #-0xe6a0
 80254a4: 4603         	mov	r3, r0
; }
 80254a6: 4618         	mov	r0, r3
 80254a8: 3708         	adds	r7, #0x8
 80254aa: 46bd         	mov	sp, r7
 80254ac: bd80         	pop	{r7, pc}

080254ae <z_thread_malloc>:
; {
 80254ae: b580         	push	{r7, lr}
 80254b0: b082         	sub	sp, #0x8
 80254b2: af00         	add	r7, sp, #0x0
 80254b4: 6078         	str	r0, [r7, #0x4]
; 	return z_thread_aligned_alloc(0, size);
 80254b6: 6879         	ldr	r1, [r7, #0x4]
 80254b8: 2000         	movs	r0, #0x0
 80254ba: f7f2 f977    	bl	0x80177ac <z_thread_aligned_alloc> @ imm = #-0xdd12
 80254be: 4603         	mov	r3, r0
; }
 80254c0: 4618         	mov	r0, r3
 80254c2: 3708         	adds	r7, #0x8
 80254c4: 46bd         	mov	sp, r7
 80254c6: bd80         	pop	{r7, pc}

080254c8 <z_mark_thread_as_not_pending>:
; {
 80254c8: b480         	push	{r7}
 80254ca: b083         	sub	sp, #0xc
 80254cc: af00         	add	r7, sp, #0x0
 80254ce: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 80254d0: 687b         	ldr	r3, [r7, #0x4]
 80254d2: 7b5b         	ldrb	r3, [r3, #0xd]
 80254d4: f023 0302    	bic	r3, r3, #0x2
 80254d8: b2da         	uxtb	r2, r3
 80254da: 687b         	ldr	r3, [r7, #0x4]
 80254dc: 735a         	strb	r2, [r3, #0xd]
; }
 80254de: bf00         	nop
 80254e0: 370c         	adds	r7, #0xc
 80254e2: 46bd         	mov	sp, r7
 80254e4: f85d 7b04    	ldr	r7, [sp], #4
 80254e8: 4770         	bx	lr

080254ea <unpend_thread_no_timeout>:
; {
 80254ea: b580         	push	{r7, lr}
 80254ec: b086         	sub	sp, #0x18
 80254ee: af00         	add	r7, sp, #0x0
 80254f0: 6078         	str	r0, [r7, #0x4]
 80254f2: 687b         	ldr	r3, [r7, #0x4]
 80254f4: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 80254f6: 68fb         	ldr	r3, [r7, #0xc]
 80254f8: 689b         	ldr	r3, [r3, #0x8]
 80254fa: 617b         	str	r3, [r7, #0x14]
 80254fc: 687b         	ldr	r3, [r7, #0x4]
 80254fe: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8025500: 693b         	ldr	r3, [r7, #0x10]
 8025502: 4618         	mov	r0, r3
 8025504: f7ff fe94    	bl	0x8025230 <sys_dlist_remove> @ imm = #-0x2d8
; }
 8025508: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 802550a: 6878         	ldr	r0, [r7, #0x4]
 802550c: f7ff ffdc    	bl	0x80254c8 <z_mark_thread_as_not_pending> @ imm = #-0x48
; 	thread->base.pended_on = NULL;
 8025510: 687b         	ldr	r3, [r7, #0x4]
 8025512: 2200         	movs	r2, #0x0
 8025514: 609a         	str	r2, [r3, #0x8]
; }
 8025516: bf00         	nop
 8025518: 3718         	adds	r7, #0x18
 802551a: 46bd         	mov	sp, r7
 802551c: bd80         	pop	{r7, pc}

0802551e <z_queue_node_peek>:
; {
 802551e: b580         	push	{r7, lr}
 8025520: b084         	sub	sp, #0x10
 8025522: af00         	add	r7, sp, #0x0
 8025524: 6078         	str	r0, [r7, #0x4]
 8025526: 460b         	mov	r3, r1
 8025528: 70fb         	strb	r3, [r7, #0x3]
; 	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
 802552a: 687b         	ldr	r3, [r7, #0x4]
 802552c: 2b00         	cmp	r3, #0x0
 802552e: d011         	beq	0x8025554 <z_queue_node_peek+0x36> @ imm = #0x22
 8025530: 6878         	ldr	r0, [r7, #0x4]
 8025532: f7ff fee9    	bl	0x8025308 <sys_sfnode_flags_get> @ imm = #-0x22e
 8025536: 4603         	mov	r3, r0
 8025538: 2b00         	cmp	r3, #0x0
 802553a: d00b         	beq	0x8025554 <z_queue_node_peek+0x36> @ imm = #0x16
; 		anode = CONTAINER_OF(node, struct alloc_node, node);
 802553c: 687b         	ldr	r3, [r7, #0x4]
 802553e: 60bb         	str	r3, [r7, #0x8]
; 		ret = anode->data;
 8025540: 68bb         	ldr	r3, [r7, #0x8]
 8025542: 685b         	ldr	r3, [r3, #0x4]
 8025544: 60fb         	str	r3, [r7, #0xc]
; 		if (needs_free) {
 8025546: 78fb         	ldrb	r3, [r7, #0x3]
 8025548: 2b00         	cmp	r3, #0x0
 802554a: d006         	beq	0x802555a <z_queue_node_peek+0x3c> @ imm = #0xc
; 			k_free(anode);
 802554c: 68b8         	ldr	r0, [r7, #0x8]
 802554e: f001 ffa7    	bl	0x80274a0 <k_free>      @ imm = #0x1f4e
; 	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
 8025552: e002         	b	0x802555a <z_queue_node_peek+0x3c> @ imm = #0x4
; 		ret = (void *)node;
 8025554: 687b         	ldr	r3, [r7, #0x4]
 8025556: 60fb         	str	r3, [r7, #0xc]
 8025558: e000         	b	0x802555c <z_queue_node_peek+0x3e> @ imm = #0x0
; 	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
 802555a: bf00         	nop
; 	return ret;
 802555c: 68fb         	ldr	r3, [r7, #0xc]
; }
 802555e: 4618         	mov	r0, r3
 8025560: 3710         	adds	r7, #0x10
 8025562: 46bd         	mov	sp, r7
 8025564: bd80         	pop	{r7, pc}

08025566 <prepare_thread_to_run>:
; {
 8025566: b580         	push	{r7, lr}
 8025568: b088         	sub	sp, #0x20
 802556a: af00         	add	r7, sp, #0x0
 802556c: 6078         	str	r0, [r7, #0x4]
 802556e: 6039         	str	r1, [r7]
 8025570: 687b         	ldr	r3, [r7, #0x4]
 8025572: 61fb         	str	r3, [r7, #0x1c]
 8025574: 2300         	movs	r3, #0x0
 8025576: 61bb         	str	r3, [r7, #0x18]
 8025578: 683b         	ldr	r3, [r7]
 802557a: 617b         	str	r3, [r7, #0x14]
 802557c: 69fb         	ldr	r3, [r7, #0x1c]
 802557e: 613b         	str	r3, [r7, #0x10]
 8025580: 69bb         	ldr	r3, [r7, #0x18]
 8025582: 60fb         	str	r3, [r7, #0xc]
; 	thread->arch.swap_return_value = value;
 8025584: 693b         	ldr	r3, [r7, #0x10]
 8025586: 68fa         	ldr	r2, [r7, #0xc]
 8025588: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 802558c: bf00         	nop
; 	thread->base.swap_data = data;
 802558e: 69fb         	ldr	r3, [r7, #0x1c]
 8025590: 697a         	ldr	r2, [r7, #0x14]
 8025592: 615a         	str	r2, [r3, #0x14]
; }
 8025594: bf00         	nop
; 	z_ready_thread(thread);
 8025596: 6878         	ldr	r0, [r7, #0x4]
 8025598: f7ef fda0    	bl	0x80150dc <z_ready_thread> @ imm = #-0x104c0
; }
 802559c: bf00         	nop
 802559e: 3720         	adds	r7, #0x20
 80255a0: 46bd         	mov	sp, r7
 80255a2: bd80         	pop	{r7, pc}

080255a4 <handle_poll_events>:
; {
 80255a4: b480         	push	{r7}
 80255a6: b083         	sub	sp, #0xc
 80255a8: af00         	add	r7, sp, #0x0
 80255aa: 6078         	str	r0, [r7, #0x4]
 80255ac: 6039         	str	r1, [r7]
; }
 80255ae: bf00         	nop
 80255b0: 370c         	adds	r7, #0xc
 80255b2: 46bd         	mov	sp, r7
 80255b4: f85d 7b04    	ldr	r7, [sp], #4
 80255b8: 4770         	bx	lr

080255ba <queue_insert>:
; {
 80255ba: b580         	push	{r7, lr}
 80255bc: b098         	sub	sp, #0x60
 80255be: af00         	add	r7, sp, #0x0
 80255c0: 60f8         	str	r0, [r7, #0xc]
 80255c2: 60b9         	str	r1, [r7, #0x8]
 80255c4: 607a         	str	r2, [r7, #0x4]
 80255c6: 70fb         	strb	r3, [r7, #0x3]
; 	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 80255c8: 68fb         	ldr	r3, [r7, #0xc]
 80255ca: 3308         	adds	r3, #0x8
 80255cc: 657b         	str	r3, [r7, #0x54]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80255ce: f3ef 8311    	mrs	r3, basepri
 80255d2: 653b         	str	r3, [r7, #0x50]
;   return(result);
 80255d4: 6d3b         	ldr	r3, [r7, #0x50]
; 	key = __get_BASEPRI();
 80255d6: 64fb         	str	r3, [r7, #0x4c]
 80255d8: 2310         	movs	r3, #0x10
 80255da: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80255dc: 6cbb         	ldr	r3, [r7, #0x48]
 80255de: f383 8812    	msr	basepri_max, r3
; }
 80255e2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80255e4: f3bf 8f6f    	isb	sy
; }
 80255e8: bf00         	nop
; 	return key;
 80255ea: 6cfb         	ldr	r3, [r7, #0x4c]
; 	k.key = arch_irq_lock();
 80255ec: 61bb         	str	r3, [r7, #0x18]
 80255ee: 6d7b         	ldr	r3, [r7, #0x54]
 80255f0: 647b         	str	r3, [r7, #0x44]
; }
 80255f2: bf00         	nop
 80255f4: 6d7b         	ldr	r3, [r7, #0x54]
 80255f6: 643b         	str	r3, [r7, #0x40]
; }
 80255f8: bf00         	nop
; 	return k;
 80255fa: 69bb         	ldr	r3, [r7, #0x18]
 80255fc: 61fb         	str	r3, [r7, #0x1c]
; 	if (is_append) {
 80255fe: f897 3068    	ldrb.w	r3, [r7, #0x68]
 8025602: 2b00         	cmp	r3, #0x0
 8025604: d004         	beq	0x8025610 <queue_insert+0x56> @ imm = #0x8
; 		prev = sys_sflist_peek_tail(&queue->data_q);
 8025606: 68fb         	ldr	r3, [r7, #0xc]
 8025608: 4618         	mov	r0, r3
 802560a: f7ff fe71    	bl	0x80252f0 <sys_sflist_peek_tail> @ imm = #-0x31e
 802560e: 60b8         	str	r0, [r7, #0x8]
; 	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
 8025610: 68fb         	ldr	r3, [r7, #0xc]
 8025612: 3308         	adds	r3, #0x8
 8025614: 63fb         	str	r3, [r7, #0x3c]
; 	struct k_thread *thread = NULL;
 8025616: 2300         	movs	r3, #0x0
 8025618: 63bb         	str	r3, [r7, #0x38]
; 		thread = _priq_wait_best(&wait_q->waitq);
 802561a: 6bfb         	ldr	r3, [r7, #0x3c]
 802561c: 637b         	str	r3, [r7, #0x34]
; 	struct k_thread *thread = NULL;
 802561e: 2300         	movs	r3, #0x0
 8025620: 633b         	str	r3, [r7, #0x30]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8025622: 6b78         	ldr	r0, [r7, #0x34]
 8025624: f7ff fdf2    	bl	0x802520c <sys_dlist_peek_head> @ imm = #-0x41c
 8025628: 62f8         	str	r0, [r7, #0x2c]
; 	if (n != NULL) {
 802562a: 6afb         	ldr	r3, [r7, #0x2c]
 802562c: 2b00         	cmp	r3, #0x0
 802562e: d001         	beq	0x8025634 <queue_insert+0x7a> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8025630: 6afb         	ldr	r3, [r7, #0x2c]
 8025632: 633b         	str	r3, [r7, #0x30]
; 	return thread;
 8025634: 6b3b         	ldr	r3, [r7, #0x30]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8025636: 63bb         	str	r3, [r7, #0x38]
; 		if (unlikely(thread != NULL)) {
 8025638: 6bbb         	ldr	r3, [r7, #0x38]
 802563a: 2b00         	cmp	r3, #0x0
 802563c: bf14         	ite	ne
 802563e: 2301         	movne	r3, #0x1
 8025640: 2300         	moveq	r3, #0x0
 8025642: b2db         	uxtb	r3, r3
 8025644: 2b00         	cmp	r3, #0x0
 8025646: d005         	beq	0x8025654 <queue_insert+0x9a> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 8025648: 6bb8         	ldr	r0, [r7, #0x38]
 802564a: f7ff ff4e    	bl	0x80254ea <unpend_thread_no_timeout> @ imm = #-0x164
; 			(void)z_abort_thread_timeout(thread);
 802564e: 6bb8         	ldr	r0, [r7, #0x38]
 8025650: f7ff ff1f    	bl	0x8025492 <z_abort_thread_timeout> @ imm = #-0x1c2
; 	return thread;
 8025654: 6bbb         	ldr	r3, [r7, #0x38]
; 	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
 8025656: 65fb         	str	r3, [r7, #0x5c]
; 	if (unlikely(first_pending_thread != NULL)) {
 8025658: 6dfb         	ldr	r3, [r7, #0x5c]
 802565a: 2b00         	cmp	r3, #0x0
 802565c: bf14         	ite	ne
 802565e: 2301         	movne	r3, #0x1
 8025660: 2300         	moveq	r3, #0x0
 8025662: b2db         	uxtb	r3, r3
 8025664: 2b00         	cmp	r3, #0x0
 8025666: d00b         	beq	0x8025680 <queue_insert+0xc6> @ imm = #0x16
; 		prepare_thread_to_run(first_pending_thread, data);
 8025668: 6879         	ldr	r1, [r7, #0x4]
 802566a: 6df8         	ldr	r0, [r7, #0x5c]
 802566c: f7ff ff7b    	bl	0x8025566 <prepare_thread_to_run> @ imm = #-0x10a
; 		z_reschedule(&queue->lock, key);
 8025670: 68fb         	ldr	r3, [r7, #0xc]
 8025672: 3308         	adds	r3, #0x8
 8025674: 69f9         	ldr	r1, [r7, #0x1c]
 8025676: 4618         	mov	r0, r3
 8025678: f001 fa78    	bl	0x8026b6c <z_reschedule> @ imm = #0x14f0
; 		return 0;
 802567c: 2300         	movs	r3, #0x0
 802567e: e03e         	b	0x80256fe <queue_insert+0x144> @ imm = #0x7c
; 	if (alloc) {
 8025680: 78fb         	ldrb	r3, [r7, #0x3]
 8025682: 2b00         	cmp	r3, #0x0
 8025684: d026         	beq	0x80256d4 <queue_insert+0x11a> @ imm = #0x4c
; 		anode = z_thread_malloc(sizeof(*anode));
 8025686: 2008         	movs	r0, #0x8
 8025688: f7ff ff11    	bl	0x80254ae <z_thread_malloc> @ imm = #-0x1de
 802568c: 65b8         	str	r0, [r7, #0x58]
; 		if (anode == NULL) {
 802568e: 6dbb         	ldr	r3, [r7, #0x58]
 8025690: 2b00         	cmp	r3, #0x0
 8025692: d114         	bne	0x80256be <queue_insert+0x104> @ imm = #0x28
; 			k_spin_unlock(&queue->lock, key);
 8025694: 68fb         	ldr	r3, [r7, #0xc]
 8025696: 3308         	adds	r3, #0x8
 8025698: 62bb         	str	r3, [r7, #0x28]
 802569a: 69fb         	ldr	r3, [r7, #0x1c]
 802569c: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 802569e: 697b         	ldr	r3, [r7, #0x14]
 80256a0: 627b         	str	r3, [r7, #0x24]
 80256a2: 6a7b         	ldr	r3, [r7, #0x24]
 80256a4: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80256a6: 6a3b         	ldr	r3, [r7, #0x20]
 80256a8: f383 8811    	msr	basepri, r3
; }
 80256ac: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80256ae: f3bf 8f6f    	isb	sy
; }
 80256b2: bf00         	nop
; }
 80256b4: bf00         	nop
; }
 80256b6: bf00         	nop
; 			return -ENOMEM;
 80256b8: f06f 030b    	mvn	r3, #0xb
 80256bc: e01f         	b	0x80256fe <queue_insert+0x144> @ imm = #0x3e
; 		anode->data = data;
 80256be: 6dbb         	ldr	r3, [r7, #0x58]
 80256c0: 687a         	ldr	r2, [r7, #0x4]
 80256c2: 605a         	str	r2, [r3, #0x4]
; 		sys_sfnode_init(&anode->node, 0x1);
 80256c4: 6dbb         	ldr	r3, [r7, #0x58]
 80256c6: 2101         	movs	r1, #0x1
 80256c8: 4618         	mov	r0, r3
 80256ca: f7ff fe2d    	bl	0x8025328 <sys_sfnode_init> @ imm = #-0x3a6
; 		data = anode;
 80256ce: 6dbb         	ldr	r3, [r7, #0x58]
 80256d0: 607b         	str	r3, [r7, #0x4]
 80256d2: e003         	b	0x80256dc <queue_insert+0x122> @ imm = #0x6
; 		sys_sfnode_init(data, 0x0);
 80256d4: 2100         	movs	r1, #0x0
 80256d6: 6878         	ldr	r0, [r7, #0x4]
 80256d8: f7ff fe26    	bl	0x8025328 <sys_sfnode_init> @ imm = #-0x3b4
; 	sys_sflist_insert(&queue->data_q, prev, data);
 80256dc: 68fb         	ldr	r3, [r7, #0xc]
 80256de: 687a         	ldr	r2, [r7, #0x4]
 80256e0: 68b9         	ldr	r1, [r7, #0x8]
 80256e2: 4618         	mov	r0, r3
 80256e4: f7ff fe89    	bl	0x80253fa <sys_sflist_insert> @ imm = #-0x2ee
; 	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
 80256e8: 2104         	movs	r1, #0x4
 80256ea: 68f8         	ldr	r0, [r7, #0xc]
 80256ec: f7ff ff5a    	bl	0x80255a4 <handle_poll_events> @ imm = #-0x14c
; 	z_reschedule(&queue->lock, key);
 80256f0: 68fb         	ldr	r3, [r7, #0xc]
 80256f2: 3308         	adds	r3, #0x8
 80256f4: 69f9         	ldr	r1, [r7, #0x1c]
 80256f6: 4618         	mov	r0, r3
 80256f8: f001 fa38    	bl	0x8026b6c <z_reschedule> @ imm = #0x1470
; 	return 0;
 80256fc: 2300         	movs	r3, #0x0
; }
 80256fe: 4618         	mov	r0, r3
 8025700: 3760         	adds	r7, #0x60
 8025702: 46bd         	mov	sp, r7
 8025704: bd80         	pop	{r7, pc}

08025706 <k_queue_append>:
; {
 8025706: b580         	push	{r7, lr}
 8025708: b084         	sub	sp, #0x10
 802570a: af02         	add	r7, sp, #0x8
 802570c: 6078         	str	r0, [r7, #0x4]
 802570e: 6039         	str	r1, [r7]
; 	(void)queue_insert(queue, NULL, data, false, true);
 8025710: 2301         	movs	r3, #0x1
 8025712: 9300         	str	r3, [sp]
 8025714: 2300         	movs	r3, #0x0
 8025716: 683a         	ldr	r2, [r7]
 8025718: 2100         	movs	r1, #0x0
 802571a: 6878         	ldr	r0, [r7, #0x4]
 802571c: f7ff ff4d    	bl	0x80255ba <queue_insert> @ imm = #-0x166
; }
 8025720: bf00         	nop
 8025722: 3708         	adds	r7, #0x8
 8025724: 46bd         	mov	sp, r7
 8025726: bd80         	pop	{r7, pc}

08025728 <k_queue_prepend>:
; {
 8025728: b580         	push	{r7, lr}
 802572a: b084         	sub	sp, #0x10
 802572c: af02         	add	r7, sp, #0x8
 802572e: 6078         	str	r0, [r7, #0x4]
 8025730: 6039         	str	r1, [r7]
; 	(void)queue_insert(queue, NULL, data, false, false);
 8025732: 2300         	movs	r3, #0x0
 8025734: 9300         	str	r3, [sp]
 8025736: 2300         	movs	r3, #0x0
 8025738: 683a         	ldr	r2, [r7]
 802573a: 2100         	movs	r1, #0x0
 802573c: 6878         	ldr	r0, [r7, #0x4]
 802573e: f7ff ff3c    	bl	0x80255ba <queue_insert> @ imm = #-0x188
; }
 8025742: bf00         	nop
 8025744: 3708         	adds	r7, #0x8
 8025746: 46bd         	mov	sp, r7
 8025748: bd80         	pop	{r7, pc}

0802574a <sys_dlist_init>:
; {
 802574a: b480         	push	{r7}
 802574c: b083         	sub	sp, #0xc
 802574e: af00         	add	r7, sp, #0x0
 8025750: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8025752: 687b         	ldr	r3, [r7, #0x4]
 8025754: 687a         	ldr	r2, [r7, #0x4]
 8025756: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8025758: 687b         	ldr	r3, [r7, #0x4]
 802575a: 687a         	ldr	r2, [r7, #0x4]
 802575c: 605a         	str	r2, [r3, #0x4]
; }
 802575e: bf00         	nop
 8025760: 370c         	adds	r7, #0xc
 8025762: 46bd         	mov	sp, r7
 8025764: f85d 7b04    	ldr	r7, [sp], #4
 8025768: 4770         	bx	lr

0802576a <sys_dnode_init>:
; {
 802576a: b480         	push	{r7}
 802576c: b083         	sub	sp, #0xc
 802576e: af00         	add	r7, sp, #0x0
 8025770: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8025772: 687b         	ldr	r3, [r7, #0x4]
 8025774: 2200         	movs	r2, #0x0
 8025776: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8025778: 687b         	ldr	r3, [r7, #0x4]
 802577a: 2200         	movs	r2, #0x0
 802577c: 605a         	str	r2, [r3, #0x4]
; }
 802577e: bf00         	nop
 8025780: 370c         	adds	r7, #0xc
 8025782: 46bd         	mov	sp, r7
 8025784: f85d 7b04    	ldr	r7, [sp], #4
 8025788: 4770         	bx	lr

0802578a <sys_dlist_is_empty>:
; {
 802578a: b480         	push	{r7}
 802578c: b083         	sub	sp, #0xc
 802578e: af00         	add	r7, sp, #0x0
 8025790: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8025792: 687b         	ldr	r3, [r7, #0x4]
 8025794: 681b         	ldr	r3, [r3]
 8025796: 687a         	ldr	r2, [r7, #0x4]
 8025798: 429a         	cmp	r2, r3
 802579a: bf0c         	ite	eq
 802579c: 2301         	moveq	r3, #0x1
 802579e: 2300         	movne	r3, #0x0
 80257a0: b2db         	uxtb	r3, r3
; }
 80257a2: 4618         	mov	r0, r3
 80257a4: 370c         	adds	r7, #0xc
 80257a6: 46bd         	mov	sp, r7
 80257a8: f85d 7b04    	ldr	r7, [sp], #4
 80257ac: 4770         	bx	lr

080257ae <sys_dlist_peek_head>:
; {
 80257ae: b580         	push	{r7, lr}
 80257b0: b082         	sub	sp, #0x8
 80257b2: af00         	add	r7, sp, #0x0
 80257b4: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 80257b6: 6878         	ldr	r0, [r7, #0x4]
 80257b8: f7ff ffe7    	bl	0x802578a <sys_dlist_is_empty> @ imm = #-0x32
 80257bc: 4603         	mov	r3, r0
 80257be: 2b00         	cmp	r3, #0x0
 80257c0: d102         	bne	0x80257c8 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 80257c2: 687b         	ldr	r3, [r7, #0x4]
 80257c4: 681b         	ldr	r3, [r3]
 80257c6: e000         	b	0x80257ca <sys_dlist_peek_head+0x1c> @ imm = #0x0
 80257c8: 2300         	movs	r3, #0x0
; }
 80257ca: 4618         	mov	r0, r3
 80257cc: 3708         	adds	r7, #0x8
 80257ce: 46bd         	mov	sp, r7
 80257d0: bd80         	pop	{r7, pc}

080257d2 <sys_dlist_remove>:
; {
 80257d2: b580         	push	{r7, lr}
 80257d4: b084         	sub	sp, #0x10
 80257d6: af00         	add	r7, sp, #0x0
 80257d8: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 80257da: 687b         	ldr	r3, [r7, #0x4]
 80257dc: 685b         	ldr	r3, [r3, #0x4]
 80257de: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 80257e0: 687b         	ldr	r3, [r7, #0x4]
 80257e2: 681b         	ldr	r3, [r3]
 80257e4: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 80257e6: 68fb         	ldr	r3, [r7, #0xc]
 80257e8: 68ba         	ldr	r2, [r7, #0x8]
 80257ea: 601a         	str	r2, [r3]
; 	next->prev = prev;
 80257ec: 68bb         	ldr	r3, [r7, #0x8]
 80257ee: 68fa         	ldr	r2, [r7, #0xc]
 80257f0: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 80257f2: 6878         	ldr	r0, [r7, #0x4]
 80257f4: f7ff ffb9    	bl	0x802576a <sys_dnode_init> @ imm = #-0x8e
; }
 80257f8: bf00         	nop
 80257fa: 3710         	adds	r7, #0x10
 80257fc: 46bd         	mov	sp, r7
 80257fe: bd80         	pop	{r7, pc}

08025800 <k_object_init>:
; {
 8025800: b480         	push	{r7}
 8025802: b083         	sub	sp, #0xc
 8025804: af00         	add	r7, sp, #0x0
 8025806: 6078         	str	r0, [r7, #0x4]
; }
 8025808: bf00         	nop
 802580a: 370c         	adds	r7, #0xc
 802580c: 46bd         	mov	sp, r7
 802580e: f85d 7b04    	ldr	r7, [sp], #4
 8025812: 4770         	bx	lr

08025814 <z_abort_thread_timeout>:
; {
 8025814: b580         	push	{r7, lr}
 8025816: b082         	sub	sp, #0x8
 8025818: af00         	add	r7, sp, #0x0
 802581a: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 802581c: 687b         	ldr	r3, [r7, #0x4]
 802581e: 3318         	adds	r3, #0x18
 8025820: 4618         	mov	r0, r3
 8025822: f7f1 faef    	bl	0x8016e04 <z_abort_timeout> @ imm = #-0xea22
 8025826: 4603         	mov	r3, r0
; }
 8025828: 4618         	mov	r0, r3
 802582a: 3708         	adds	r7, #0x8
 802582c: 46bd         	mov	sp, r7
 802582e: bd80         	pop	{r7, pc}

08025830 <z_waitq_init>:
; {
 8025830: b580         	push	{r7, lr}
 8025832: b082         	sub	sp, #0x8
 8025834: af00         	add	r7, sp, #0x0
 8025836: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8025838: 687b         	ldr	r3, [r7, #0x4]
 802583a: 4618         	mov	r0, r3
 802583c: f7ff ff85    	bl	0x802574a <sys_dlist_init> @ imm = #-0xf6
; }
 8025840: bf00         	nop
 8025842: 3708         	adds	r7, #0x8
 8025844: 46bd         	mov	sp, r7
 8025846: bd80         	pop	{r7, pc}

08025848 <z_mark_thread_as_not_pending>:
; {
 8025848: b480         	push	{r7}
 802584a: b083         	sub	sp, #0xc
 802584c: af00         	add	r7, sp, #0x0
 802584e: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8025850: 687b         	ldr	r3, [r7, #0x4]
 8025852: 7b5b         	ldrb	r3, [r3, #0xd]
 8025854: f023 0302    	bic	r3, r3, #0x2
 8025858: b2da         	uxtb	r2, r3
 802585a: 687b         	ldr	r3, [r7, #0x4]
 802585c: 735a         	strb	r2, [r3, #0xd]
; }
 802585e: bf00         	nop
 8025860: 370c         	adds	r7, #0xc
 8025862: 46bd         	mov	sp, r7
 8025864: f85d 7b04    	ldr	r7, [sp], #4
 8025868: 4770         	bx	lr

0802586a <unpend_thread_no_timeout>:
; {
 802586a: b580         	push	{r7, lr}
 802586c: b086         	sub	sp, #0x18
 802586e: af00         	add	r7, sp, #0x0
 8025870: 6078         	str	r0, [r7, #0x4]
 8025872: 687b         	ldr	r3, [r7, #0x4]
 8025874: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8025876: 68fb         	ldr	r3, [r7, #0xc]
 8025878: 689b         	ldr	r3, [r3, #0x8]
 802587a: 617b         	str	r3, [r7, #0x14]
 802587c: 687b         	ldr	r3, [r7, #0x4]
 802587e: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8025880: 693b         	ldr	r3, [r7, #0x10]
 8025882: 4618         	mov	r0, r3
 8025884: f7ff ffa5    	bl	0x80257d2 <sys_dlist_remove> @ imm = #-0xb6
; }
 8025888: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 802588a: 6878         	ldr	r0, [r7, #0x4]
 802588c: f7ff ffdc    	bl	0x8025848 <z_mark_thread_as_not_pending> @ imm = #-0x48
; 	thread->base.pended_on = NULL;
 8025890: 687b         	ldr	r3, [r7, #0x4]
 8025892: 2200         	movs	r2, #0x0
 8025894: 609a         	str	r2, [r3, #0x8]
; }
 8025896: bf00         	nop
 8025898: 3718         	adds	r7, #0x18
 802589a: 46bd         	mov	sp, r7
 802589c: bd80         	pop	{r7, pc}

0802589e <z_impl_k_sem_init>:
; {
 802589e: b580         	push	{r7, lr}
 80258a0: b084         	sub	sp, #0x10
 80258a2: af00         	add	r7, sp, #0x0
 80258a4: 60f8         	str	r0, [r7, #0xc]
 80258a6: 60b9         	str	r1, [r7, #0x8]
 80258a8: 607a         	str	r2, [r7, #0x4]
; 	CHECKIF(limit == 0U || initial_count > limit) {
 80258aa: 687b         	ldr	r3, [r7, #0x4]
 80258ac: 2b00         	cmp	r3, #0x0
 80258ae: d003         	beq	0x80258b8 <z_impl_k_sem_init+0x1a> @ imm = #0x6
 80258b0: 68ba         	ldr	r2, [r7, #0x8]
 80258b2: 687b         	ldr	r3, [r7, #0x4]
 80258b4: 429a         	cmp	r2, r3
 80258b6: d902         	bls	0x80258be <z_impl_k_sem_init+0x20> @ imm = #0x4
; 		return -EINVAL;
 80258b8: f06f 0315    	mvn	r3, #0x15
 80258bc: e00d         	b	0x80258da <z_impl_k_sem_init+0x3c> @ imm = #0x1a
; 	sem->count = initial_count;
 80258be: 68fb         	ldr	r3, [r7, #0xc]
 80258c0: 68ba         	ldr	r2, [r7, #0x8]
 80258c2: 609a         	str	r2, [r3, #0x8]
; 	sem->limit = limit;
 80258c4: 68fb         	ldr	r3, [r7, #0xc]
 80258c6: 687a         	ldr	r2, [r7, #0x4]
 80258c8: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&sem->wait_q);
 80258ca: 68fb         	ldr	r3, [r7, #0xc]
 80258cc: 4618         	mov	r0, r3
 80258ce: f7ff ffaf    	bl	0x8025830 <z_waitq_init> @ imm = #-0xa2
; 	k_object_init(sem);
 80258d2: 68f8         	ldr	r0, [r7, #0xc]
 80258d4: f7ff ff94    	bl	0x8025800 <k_object_init> @ imm = #-0xd8
; 	return 0;
 80258d8: 2300         	movs	r3, #0x0
; }
 80258da: 4618         	mov	r0, r3
 80258dc: 3710         	adds	r7, #0x10
 80258de: 46bd         	mov	sp, r7
 80258e0: bd80         	pop	{r7, pc}

080258e2 <handle_poll_events>:
; {
 80258e2: b480         	push	{r7}
 80258e4: b083         	sub	sp, #0xc
 80258e6: af00         	add	r7, sp, #0x0
 80258e8: 6078         	str	r0, [r7, #0x4]
; 	return false;
 80258ea: 2300         	movs	r3, #0x0
; }
 80258ec: 4618         	mov	r0, r3
 80258ee: 370c         	adds	r7, #0xc
 80258f0: 46bd         	mov	sp, r7
 80258f2: f85d 7b04    	ldr	r7, [sp], #4
 80258f6: 4770         	bx	lr

080258f8 <sys_dlist_init>:
; {
 80258f8: b480         	push	{r7}
 80258fa: b083         	sub	sp, #0xc
 80258fc: af00         	add	r7, sp, #0x0
 80258fe: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8025900: 687b         	ldr	r3, [r7, #0x4]
 8025902: 687a         	ldr	r2, [r7, #0x4]
 8025904: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8025906: 687b         	ldr	r3, [r7, #0x4]
 8025908: 687a         	ldr	r2, [r7, #0x4]
 802590a: 605a         	str	r2, [r3, #0x4]
; }
 802590c: bf00         	nop
 802590e: 370c         	adds	r7, #0xc
 8025910: 46bd         	mov	sp, r7
 8025912: f85d 7b04    	ldr	r7, [sp], #4
 8025916: 4770         	bx	lr

08025918 <sys_dnode_init>:
; {
 8025918: b480         	push	{r7}
 802591a: b083         	sub	sp, #0xc
 802591c: af00         	add	r7, sp, #0x0
 802591e: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8025920: 687b         	ldr	r3, [r7, #0x4]
 8025922: 2200         	movs	r2, #0x0
 8025924: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8025926: 687b         	ldr	r3, [r7, #0x4]
 8025928: 2200         	movs	r2, #0x0
 802592a: 605a         	str	r2, [r3, #0x4]
; }
 802592c: bf00         	nop
 802592e: 370c         	adds	r7, #0xc
 8025930: 46bd         	mov	sp, r7
 8025932: f85d 7b04    	ldr	r7, [sp], #4
 8025936: 4770         	bx	lr

08025938 <sys_slist_init>:
; {
 8025938: b480         	push	{r7}
 802593a: b083         	sub	sp, #0xc
 802593c: af00         	add	r7, sp, #0x0
 802593e: 6078         	str	r0, [r7, #0x4]
; 	list->head = NULL;
 8025940: 687b         	ldr	r3, [r7, #0x4]
 8025942: 2200         	movs	r2, #0x0
 8025944: 601a         	str	r2, [r3]
; 	list->tail = NULL;
 8025946: 687b         	ldr	r3, [r7, #0x4]
 8025948: 2200         	movs	r2, #0x0
 802594a: 605a         	str	r2, [r3, #0x4]
; }
 802594c: bf00         	nop
 802594e: 370c         	adds	r7, #0xc
 8025950: 46bd         	mov	sp, r7
 8025952: f85d 7b04    	ldr	r7, [sp], #4
 8025956: 4770         	bx	lr

08025958 <z_snode_next_peek>:
; {
 8025958: b480         	push	{r7}
 802595a: b083         	sub	sp, #0xc
 802595c: af00         	add	r7, sp, #0x0
 802595e: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 8025960: 687b         	ldr	r3, [r7, #0x4]
 8025962: 681b         	ldr	r3, [r3]
; }
 8025964: 4618         	mov	r0, r3
 8025966: 370c         	adds	r7, #0xc
 8025968: 46bd         	mov	sp, r7
 802596a: f85d 7b04    	ldr	r7, [sp], #4
 802596e: 4770         	bx	lr

08025970 <z_snode_next_set>:
; {
 8025970: b480         	push	{r7}
 8025972: b083         	sub	sp, #0xc
 8025974: af00         	add	r7, sp, #0x0
 8025976: 6078         	str	r0, [r7, #0x4]
 8025978: 6039         	str	r1, [r7]
; 	parent->next = child;
 802597a: 687b         	ldr	r3, [r7, #0x4]
 802597c: 683a         	ldr	r2, [r7]
 802597e: 601a         	str	r2, [r3]
; }
 8025980: bf00         	nop
 8025982: 370c         	adds	r7, #0xc
 8025984: 46bd         	mov	sp, r7
 8025986: f85d 7b04    	ldr	r7, [sp], #4
 802598a: 4770         	bx	lr

0802598c <z_slist_head_set>:
; {
 802598c: b480         	push	{r7}
 802598e: b083         	sub	sp, #0xc
 8025990: af00         	add	r7, sp, #0x0
 8025992: 6078         	str	r0, [r7, #0x4]
 8025994: 6039         	str	r1, [r7]
; 	list->head = node;
 8025996: 687b         	ldr	r3, [r7, #0x4]
 8025998: 683a         	ldr	r2, [r7]
 802599a: 601a         	str	r2, [r3]
; }
 802599c: bf00         	nop
 802599e: 370c         	adds	r7, #0xc
 80259a0: 46bd         	mov	sp, r7
 80259a2: f85d 7b04    	ldr	r7, [sp], #4
 80259a6: 4770         	bx	lr

080259a8 <z_slist_tail_set>:
; {
 80259a8: b480         	push	{r7}
 80259aa: b083         	sub	sp, #0xc
 80259ac: af00         	add	r7, sp, #0x0
 80259ae: 6078         	str	r0, [r7, #0x4]
 80259b0: 6039         	str	r1, [r7]
; 	list->tail = node;
 80259b2: 687b         	ldr	r3, [r7, #0x4]
 80259b4: 683a         	ldr	r2, [r7]
 80259b6: 605a         	str	r2, [r3, #0x4]
; }
 80259b8: bf00         	nop
 80259ba: 370c         	adds	r7, #0xc
 80259bc: 46bd         	mov	sp, r7
 80259be: f85d 7b04    	ldr	r7, [sp], #4
 80259c2: 4770         	bx	lr

080259c4 <sys_slist_peek_head>:
; {
 80259c4: b480         	push	{r7}
 80259c6: b083         	sub	sp, #0xc
 80259c8: af00         	add	r7, sp, #0x0
 80259ca: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 80259cc: 687b         	ldr	r3, [r7, #0x4]
 80259ce: 681b         	ldr	r3, [r3]
; }
 80259d0: 4618         	mov	r0, r3
 80259d2: 370c         	adds	r7, #0xc
 80259d4: 46bd         	mov	sp, r7
 80259d6: f85d 7b04    	ldr	r7, [sp], #4
 80259da: 4770         	bx	lr

080259dc <sys_slist_peek_tail>:
; {
 80259dc: b480         	push	{r7}
 80259de: b083         	sub	sp, #0xc
 80259e0: af00         	add	r7, sp, #0x0
 80259e2: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 80259e4: 687b         	ldr	r3, [r7, #0x4]
 80259e6: 685b         	ldr	r3, [r3, #0x4]
; }
 80259e8: 4618         	mov	r0, r3
 80259ea: 370c         	adds	r7, #0xc
 80259ec: 46bd         	mov	sp, r7
 80259ee: f85d 7b04    	ldr	r7, [sp], #4
 80259f2: 4770         	bx	lr

080259f4 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 80259f4: b580         	push	{r7, lr}
 80259f6: b082         	sub	sp, #0x8
 80259f8: af00         	add	r7, sp, #0x0
 80259fa: 6078         	str	r0, [r7, #0x4]
 80259fc: 6878         	ldr	r0, [r7, #0x4]
 80259fe: f7ff ffe1    	bl	0x80259c4 <sys_slist_peek_head> @ imm = #-0x3e
 8025a02: 4603         	mov	r3, r0
 8025a04: 2b00         	cmp	r3, #0x0
 8025a06: bf0c         	ite	eq
 8025a08: 2301         	moveq	r3, #0x1
 8025a0a: 2300         	movne	r3, #0x0
 8025a0c: b2db         	uxtb	r3, r3
 8025a0e: 4618         	mov	r0, r3
 8025a10: 3708         	adds	r7, #0x8
 8025a12: 46bd         	mov	sp, r7
 8025a14: bd80         	pop	{r7, pc}

08025a16 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8025a16: b580         	push	{r7, lr}
 8025a18: b082         	sub	sp, #0x8
 8025a1a: af00         	add	r7, sp, #0x0
 8025a1c: 6078         	str	r0, [r7, #0x4]
 8025a1e: 6878         	ldr	r0, [r7, #0x4]
 8025a20: f7ff ff9a    	bl	0x8025958 <z_snode_next_peek> @ imm = #-0xcc
 8025a24: 4603         	mov	r3, r0
 8025a26: 4618         	mov	r0, r3
 8025a28: 3708         	adds	r7, #0x8
 8025a2a: 46bd         	mov	sp, r7
 8025a2c: bd80         	pop	{r7, pc}

08025a2e <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 8025a2e: b580         	push	{r7, lr}
 8025a30: b082         	sub	sp, #0x8
 8025a32: af00         	add	r7, sp, #0x0
 8025a34: 6078         	str	r0, [r7, #0x4]
 8025a36: 687b         	ldr	r3, [r7, #0x4]
 8025a38: 2b00         	cmp	r3, #0x0
 8025a3a: d004         	beq	0x8025a46 <sys_slist_peek_next+0x18> @ imm = #0x8
 8025a3c: 6878         	ldr	r0, [r7, #0x4]
 8025a3e: f7ff ffea    	bl	0x8025a16 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 8025a42: 4603         	mov	r3, r0
 8025a44: e000         	b	0x8025a48 <sys_slist_peek_next+0x1a> @ imm = #0x0
 8025a46: 2300         	movs	r3, #0x0
 8025a48: 4618         	mov	r0, r3
 8025a4a: 3708         	adds	r7, #0x8
 8025a4c: 46bd         	mov	sp, r7
 8025a4e: bd80         	pop	{r7, pc}

08025a50 <sys_slist_append>:
; Z_GENLIST_APPEND(slist, snode)
 8025a50: b580         	push	{r7, lr}
 8025a52: b082         	sub	sp, #0x8
 8025a54: af00         	add	r7, sp, #0x0
 8025a56: 6078         	str	r0, [r7, #0x4]
 8025a58: 6039         	str	r1, [r7]
 8025a5a: 2100         	movs	r1, #0x0
 8025a5c: 6838         	ldr	r0, [r7]
 8025a5e: f7ff ff87    	bl	0x8025970 <z_snode_next_set> @ imm = #-0xf2
 8025a62: 6878         	ldr	r0, [r7, #0x4]
 8025a64: f7ff ffba    	bl	0x80259dc <sys_slist_peek_tail> @ imm = #-0x8c
 8025a68: 4603         	mov	r3, r0
 8025a6a: 2b00         	cmp	r3, #0x0
 8025a6c: d108         	bne	0x8025a80 <sys_slist_append+0x30> @ imm = #0x10
 8025a6e: 6839         	ldr	r1, [r7]
 8025a70: 6878         	ldr	r0, [r7, #0x4]
 8025a72: f7ff ff99    	bl	0x80259a8 <z_slist_tail_set> @ imm = #-0xce
 8025a76: 6839         	ldr	r1, [r7]
 8025a78: 6878         	ldr	r0, [r7, #0x4]
 8025a7a: f7ff ff87    	bl	0x802598c <z_slist_head_set> @ imm = #-0xf2
 8025a7e: e00b         	b	0x8025a98 <sys_slist_append+0x48> @ imm = #0x16
 8025a80: 6878         	ldr	r0, [r7, #0x4]
 8025a82: f7ff ffab    	bl	0x80259dc <sys_slist_peek_tail> @ imm = #-0xaa
 8025a86: 4603         	mov	r3, r0
 8025a88: 6839         	ldr	r1, [r7]
 8025a8a: 4618         	mov	r0, r3
 8025a8c: f7ff ff70    	bl	0x8025970 <z_snode_next_set> @ imm = #-0x120
 8025a90: 6839         	ldr	r1, [r7]
 8025a92: 6878         	ldr	r0, [r7, #0x4]
 8025a94: f7ff ff88    	bl	0x80259a8 <z_slist_tail_set> @ imm = #-0xf0
 8025a98: 3708         	adds	r7, #0x8
 8025a9a: 46bd         	mov	sp, r7
 8025a9c: bd80         	pop	{r7, pc}

08025a9e <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 8025a9e: b580         	push	{r7, lr}
 8025aa0: b084         	sub	sp, #0x10
 8025aa2: af00         	add	r7, sp, #0x0
 8025aa4: 6078         	str	r0, [r7, #0x4]
 8025aa6: 6878         	ldr	r0, [r7, #0x4]
 8025aa8: f7ff ff8c    	bl	0x80259c4 <sys_slist_peek_head> @ imm = #-0xe8
 8025aac: 60f8         	str	r0, [r7, #0xc]
 8025aae: 68f8         	ldr	r0, [r7, #0xc]
 8025ab0: f7ff ff52    	bl	0x8025958 <z_snode_next_peek> @ imm = #-0x15c
 8025ab4: 4603         	mov	r3, r0
 8025ab6: 4619         	mov	r1, r3
 8025ab8: 6878         	ldr	r0, [r7, #0x4]
 8025aba: f7ff ff67    	bl	0x802598c <z_slist_head_set> @ imm = #-0x132
 8025abe: 6878         	ldr	r0, [r7, #0x4]
 8025ac0: f7ff ff8c    	bl	0x80259dc <sys_slist_peek_tail> @ imm = #-0xe8
 8025ac4: 4602         	mov	r2, r0
 8025ac6: 68fb         	ldr	r3, [r7, #0xc]
 8025ac8: 4293         	cmp	r3, r2
 8025aca: d107         	bne	0x8025adc <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 8025acc: 6878         	ldr	r0, [r7, #0x4]
 8025ace: f7ff ff79    	bl	0x80259c4 <sys_slist_peek_head> @ imm = #-0x10e
 8025ad2: 4603         	mov	r3, r0
 8025ad4: 4619         	mov	r1, r3
 8025ad6: 6878         	ldr	r0, [r7, #0x4]
 8025ad8: f7ff ff66    	bl	0x80259a8 <z_slist_tail_set> @ imm = #-0x134
 8025adc: 68fb         	ldr	r3, [r7, #0xc]
 8025ade: 4618         	mov	r0, r3
 8025ae0: 3710         	adds	r7, #0x10
 8025ae2: 46bd         	mov	sp, r7
 8025ae4: bd80         	pop	{r7, pc}

08025ae6 <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 8025ae6: b580         	push	{r7, lr}
 8025ae8: b082         	sub	sp, #0x8
 8025aea: af00         	add	r7, sp, #0x0
 8025aec: 6078         	str	r0, [r7, #0x4]
 8025aee: 6878         	ldr	r0, [r7, #0x4]
 8025af0: f7ff ff80    	bl	0x80259f4 <sys_slist_is_empty> @ imm = #-0x100
 8025af4: 4603         	mov	r3, r0
 8025af6: 2b00         	cmp	r3, #0x0
 8025af8: d104         	bne	0x8025b04 <sys_slist_get+0x1e> @ imm = #0x8
 8025afa: 6878         	ldr	r0, [r7, #0x4]
 8025afc: f7ff ffcf    	bl	0x8025a9e <sys_slist_get_not_empty> @ imm = #-0x62
 8025b00: 4603         	mov	r3, r0
 8025b02: e000         	b	0x8025b06 <sys_slist_get+0x20> @ imm = #0x0
 8025b04: 2300         	movs	r3, #0x0
 8025b06: 4618         	mov	r0, r3
 8025b08: 3708         	adds	r7, #0x8
 8025b0a: 46bd         	mov	sp, r7
 8025b0c: bd80         	pop	{r7, pc}

08025b0e <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 8025b0e: b580         	push	{r7, lr}
 8025b10: b084         	sub	sp, #0x10
 8025b12: af00         	add	r7, sp, #0x0
 8025b14: 60f8         	str	r0, [r7, #0xc]
 8025b16: 60b9         	str	r1, [r7, #0x8]
 8025b18: 607a         	str	r2, [r7, #0x4]
 8025b1a: 68bb         	ldr	r3, [r7, #0x8]
 8025b1c: 2b00         	cmp	r3, #0x0
 8025b1e: d117         	bne	0x8025b50 <sys_slist_remove+0x42> @ imm = #0x2e
 8025b20: 6878         	ldr	r0, [r7, #0x4]
 8025b22: f7ff ff19    	bl	0x8025958 <z_snode_next_peek> @ imm = #-0x1ce
 8025b26: 4603         	mov	r3, r0
 8025b28: 4619         	mov	r1, r3
 8025b2a: 68f8         	ldr	r0, [r7, #0xc]
 8025b2c: f7ff ff2e    	bl	0x802598c <z_slist_head_set> @ imm = #-0x1a4
 8025b30: 68f8         	ldr	r0, [r7, #0xc]
 8025b32: f7ff ff53    	bl	0x80259dc <sys_slist_peek_tail> @ imm = #-0x15a
 8025b36: 4602         	mov	r2, r0
 8025b38: 687b         	ldr	r3, [r7, #0x4]
 8025b3a: 4293         	cmp	r3, r2
 8025b3c: d11b         	bne	0x8025b76 <sys_slist_remove+0x68> @ imm = #0x36
 8025b3e: 68f8         	ldr	r0, [r7, #0xc]
 8025b40: f7ff ff40    	bl	0x80259c4 <sys_slist_peek_head> @ imm = #-0x180
 8025b44: 4603         	mov	r3, r0
 8025b46: 4619         	mov	r1, r3
 8025b48: 68f8         	ldr	r0, [r7, #0xc]
 8025b4a: f7ff ff2d    	bl	0x80259a8 <z_slist_tail_set> @ imm = #-0x1a6
 8025b4e: e012         	b	0x8025b76 <sys_slist_remove+0x68> @ imm = #0x24
 8025b50: 6878         	ldr	r0, [r7, #0x4]
 8025b52: f7ff ff01    	bl	0x8025958 <z_snode_next_peek> @ imm = #-0x1fe
 8025b56: 4603         	mov	r3, r0
 8025b58: 4619         	mov	r1, r3
 8025b5a: 68b8         	ldr	r0, [r7, #0x8]
 8025b5c: f7ff ff08    	bl	0x8025970 <z_snode_next_set> @ imm = #-0x1f0
 8025b60: 68f8         	ldr	r0, [r7, #0xc]
 8025b62: f7ff ff3b    	bl	0x80259dc <sys_slist_peek_tail> @ imm = #-0x18a
 8025b66: 4602         	mov	r2, r0
 8025b68: 687b         	ldr	r3, [r7, #0x4]
 8025b6a: 4293         	cmp	r3, r2
 8025b6c: d103         	bne	0x8025b76 <sys_slist_remove+0x68> @ imm = #0x6
 8025b6e: 68b9         	ldr	r1, [r7, #0x8]
 8025b70: 68f8         	ldr	r0, [r7, #0xc]
 8025b72: f7ff ff19    	bl	0x80259a8 <z_slist_tail_set> @ imm = #-0x1ce
 8025b76: 2100         	movs	r1, #0x0
 8025b78: 6878         	ldr	r0, [r7, #0x4]
 8025b7a: f7ff fef9    	bl	0x8025970 <z_snode_next_set> @ imm = #-0x20e
 8025b7e: 3710         	adds	r7, #0x10
 8025b80: 46bd         	mov	sp, r7
 8025b82: bd80         	pop	{r7, pc}

08025b84 <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8025b84: b580         	push	{r7, lr}
 8025b86: b084         	sub	sp, #0x10
 8025b88: af00         	add	r7, sp, #0x0
 8025b8a: 6078         	str	r0, [r7, #0x4]
 8025b8c: 6039         	str	r1, [r7]
 8025b8e: 2300         	movs	r3, #0x0
 8025b90: 60fb         	str	r3, [r7, #0xc]
 8025b92: 6878         	ldr	r0, [r7, #0x4]
 8025b94: f7ff ff16    	bl	0x80259c4 <sys_slist_peek_head> @ imm = #-0x1d4
 8025b98: 60b8         	str	r0, [r7, #0x8]
 8025b9a: e010         	b	0x8025bbe <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 8025b9c: 68ba         	ldr	r2, [r7, #0x8]
 8025b9e: 683b         	ldr	r3, [r7]
 8025ba0: 429a         	cmp	r2, r3
 8025ba2: d106         	bne	0x8025bb2 <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 8025ba4: 683a         	ldr	r2, [r7]
 8025ba6: 68f9         	ldr	r1, [r7, #0xc]
 8025ba8: 6878         	ldr	r0, [r7, #0x4]
 8025baa: f7ff ffb0    	bl	0x8025b0e <sys_slist_remove> @ imm = #-0xa0
 8025bae: 2301         	movs	r3, #0x1
 8025bb0: e009         	b	0x8025bc6 <sys_slist_find_and_remove+0x42> @ imm = #0x12
 8025bb2: 68bb         	ldr	r3, [r7, #0x8]
 8025bb4: 60fb         	str	r3, [r7, #0xc]
 8025bb6: 68b8         	ldr	r0, [r7, #0x8]
 8025bb8: f7ff ff39    	bl	0x8025a2e <sys_slist_peek_next> @ imm = #-0x18e
 8025bbc: 60b8         	str	r0, [r7, #0x8]
 8025bbe: 68bb         	ldr	r3, [r7, #0x8]
 8025bc0: 2b00         	cmp	r3, #0x0
 8025bc2: d1eb         	bne	0x8025b9c <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 8025bc4: 2300         	movs	r3, #0x0
 8025bc6: 4618         	mov	r0, r3
 8025bc8: 3710         	adds	r7, #0x10
 8025bca: 46bd         	mov	sp, r7
 8025bcc: bd80         	pop	{r7, pc}

08025bce <k_thread_start>:
; {
 8025bce: b580         	push	{r7, lr}
 8025bd0: b082         	sub	sp, #0x8
 8025bd2: af00         	add	r7, sp, #0x0
 8025bd4: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 8025bd6: 6878         	ldr	r0, [r7, #0x4]
 8025bd8: f000 f82a    	bl	0x8025c30 <k_thread_resume> @ imm = #0x54
; }
 8025bdc: bf00         	nop
 8025bde: 3708         	adds	r7, #0x8
 8025be0: 46bd         	mov	sp, r7
 8025be2: bd80         	pop	{r7, pc}

08025be4 <k_thread_create>:
; {
 8025be4: b580         	push	{r7, lr}
 8025be6: b08c         	sub	sp, #0x30
 8025be8: af08         	add	r7, sp, #0x20
 8025bea: 60f8         	str	r0, [r7, #0xc]
 8025bec: 60b9         	str	r1, [r7, #0x8]
 8025bee: 607a         	str	r2, [r7, #0x4]
 8025bf0: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 8025bf2: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8025bf6: e9cd 2306    	strd	r2, r3, [sp, #24]
 8025bfa: 6abb         	ldr	r3, [r7, #0x28]
 8025bfc: 9304         	str	r3, [sp, #0x10]
 8025bfe: 6a7b         	ldr	r3, [r7, #0x24]
 8025c00: 9303         	str	r3, [sp, #0xc]
 8025c02: 6a3b         	ldr	r3, [r7, #0x20]
 8025c04: 9302         	str	r3, [sp, #0x8]
 8025c06: 69fb         	ldr	r3, [r7, #0x1c]
 8025c08: 9301         	str	r3, [sp, #0x4]
 8025c0a: 69bb         	ldr	r3, [r7, #0x18]
 8025c0c: 9300         	str	r3, [sp]
 8025c0e: 683b         	ldr	r3, [r7]
 8025c10: 687a         	ldr	r2, [r7, #0x4]
 8025c12: 68b9         	ldr	r1, [r7, #0x8]
 8025c14: 68f8         	ldr	r0, [r7, #0xc]
 8025c16: f000 fb0c    	bl	0x8026232 <z_impl_k_thread_create> @ imm = #0x618
 8025c1a: 4603         	mov	r3, r0
; }
 8025c1c: 4618         	mov	r0, r3
 8025c1e: 3710         	adds	r7, #0x10
 8025c20: 46bd         	mov	sp, r7
 8025c22: bd80         	pop	{r7, pc}

08025c24 <k_yield>:
; {
 8025c24: b580         	push	{r7, lr}
 8025c26: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 8025c28: f7f0 f994    	bl	0x8015f54 <z_impl_k_yield> @ imm = #-0xfcd8
; }
 8025c2c: bf00         	nop
 8025c2e: bd80         	pop	{r7, pc}

08025c30 <k_thread_resume>:
; {
 8025c30: b580         	push	{r7, lr}
 8025c32: b082         	sub	sp, #0x8
 8025c34: af00         	add	r7, sp, #0x0
 8025c36: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 8025c38: 6878         	ldr	r0, [r7, #0x4]
 8025c3a: f7ef fca9    	bl	0x8015590 <z_impl_k_thread_resume> @ imm = #-0x106ae
; }
 8025c3e: bf00         	nop
 8025c40: 3708         	adds	r7, #0x8
 8025c42: 46bd         	mov	sp, r7
 8025c44: bd80         	pop	{r7, pc}

08025c46 <k_thread_name_set>:
; {
 8025c46: b580         	push	{r7, lr}
 8025c48: b082         	sub	sp, #0x8
 8025c4a: af00         	add	r7, sp, #0x0
 8025c4c: 6078         	str	r0, [r7, #0x4]
 8025c4e: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 8025c50: 6839         	ldr	r1, [r7]
 8025c52: 6878         	ldr	r0, [r7, #0x4]
 8025c54: f7ee feea    	bl	0x8014a2c <z_impl_k_thread_name_set> @ imm = #-0x1122c
 8025c58: 4603         	mov	r3, r0
; }
 8025c5a: 4618         	mov	r0, r3
 8025c5c: 3708         	adds	r7, #0x8
 8025c5e: 46bd         	mov	sp, r7
 8025c60: bd80         	pop	{r7, pc}

08025c62 <k_sem_give>:
; {
 8025c62: b580         	push	{r7, lr}
 8025c64: b082         	sub	sp, #0x8
 8025c66: af00         	add	r7, sp, #0x0
 8025c68: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8025c6a: 6878         	ldr	r0, [r7, #0x4]
 8025c6c: f7ee f9e8    	bl	0x8014040 <z_impl_k_sem_give> @ imm = #-0x11c30
; }
 8025c70: bf00         	nop
 8025c72: 3708         	adds	r7, #0x8
 8025c74: 46bd         	mov	sp, r7
 8025c76: bd80         	pop	{r7, pc}

08025c78 <z_init_timeout>:
; {
 8025c78: b580         	push	{r7, lr}
 8025c7a: b082         	sub	sp, #0x8
 8025c7c: af00         	add	r7, sp, #0x0
 8025c7e: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 8025c80: 687b         	ldr	r3, [r7, #0x4]
 8025c82: 4618         	mov	r0, r3
 8025c84: f7ff fe48    	bl	0x8025918 <sys_dnode_init> @ imm = #-0x370
; }
 8025c88: bf00         	nop
 8025c8a: 3708         	adds	r7, #0x8
 8025c8c: 46bd         	mov	sp, r7
 8025c8e: bd80         	pop	{r7, pc}

08025c90 <z_waitq_init>:
; {
 8025c90: b580         	push	{r7, lr}
 8025c92: b082         	sub	sp, #0x8
 8025c94: af00         	add	r7, sp, #0x0
 8025c96: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8025c98: 687b         	ldr	r3, [r7, #0x4]
 8025c9a: 4618         	mov	r0, r3
 8025c9c: f7ff fe2c    	bl	0x80258f8 <sys_dlist_init> @ imm = #-0x3a8
; }
 8025ca0: bf00         	nop
 8025ca2: 3708         	adds	r7, #0x8
 8025ca4: 46bd         	mov	sp, r7
 8025ca6: bd80         	pop	{r7, pc}

08025ca8 <z_reschedule_unlocked>:
; {
 8025ca8: b580         	push	{r7, lr}
 8025caa: b084         	sub	sp, #0x10
 8025cac: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8025cae: f3ef 8311    	mrs	r3, basepri
 8025cb2: 60fb         	str	r3, [r7, #0xc]
;   return(result);
 8025cb4: 68fb         	ldr	r3, [r7, #0xc]
; 	key = __get_BASEPRI();
 8025cb6: 60bb         	str	r3, [r7, #0x8]
 8025cb8: 2310         	movs	r3, #0x10
 8025cba: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8025cbc: 687b         	ldr	r3, [r7, #0x4]
 8025cbe: f383 8812    	msr	basepri_max, r3
; }
 8025cc2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8025cc4: f3bf 8f6f    	isb	sy
; }
 8025cc8: bf00         	nop
; 	return key;
 8025cca: 68bb         	ldr	r3, [r7, #0x8]
; 	(void) z_reschedule_irqlock(arch_irq_lock());
 8025ccc: 4618         	mov	r0, r3
 8025cce: f000 ff7f    	bl	0x8026bd0 <z_reschedule_irqlock> @ imm = #0xefe
; }
 8025cd2: bf00         	nop
 8025cd4: 3710         	adds	r7, #0x10
 8025cd6: 46bd         	mov	sp, r7
 8025cd8: bd80         	pop	{r7, pc}

08025cda <z_sched_wake_all>:
; {
 8025cda: b580         	push	{r7, lr}
 8025cdc: b086         	sub	sp, #0x18
 8025cde: af00         	add	r7, sp, #0x0
 8025ce0: 60f8         	str	r0, [r7, #0xc]
 8025ce2: 60b9         	str	r1, [r7, #0x8]
 8025ce4: 607a         	str	r2, [r7, #0x4]
; 	bool woken = false;
 8025ce6: 2300         	movs	r3, #0x0
 8025ce8: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 8025cea: e001         	b	0x8025cf0 <z_sched_wake_all+0x16> @ imm = #0x2
; 		woken = true;
 8025cec: 2301         	movs	r3, #0x1
 8025cee: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 8025cf0: 687a         	ldr	r2, [r7, #0x4]
 8025cf2: 68b9         	ldr	r1, [r7, #0x8]
 8025cf4: 68f8         	ldr	r0, [r7, #0xc]
 8025cf6: f7f0 fc9d    	bl	0x8016634 <z_sched_wake> @ imm = #-0xf6c6
 8025cfa: 4603         	mov	r3, r0
 8025cfc: 2b00         	cmp	r3, #0x0
 8025cfe: d1f5         	bne	0x8025cec <z_sched_wake_all+0x12> @ imm = #-0x16
; 	return woken;
 8025d00: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 8025d02: 4618         	mov	r0, r3
 8025d04: 3718         	adds	r7, #0x18
 8025d06: 46bd         	mov	sp, r7
 8025d08: bd80         	pop	{r7, pc}

08025d0a <flag_clear>:
; {
 8025d0a: b480         	push	{r7}
 8025d0c: b083         	sub	sp, #0xc
 8025d0e: af00         	add	r7, sp, #0x0
 8025d10: 6078         	str	r0, [r7, #0x4]
 8025d12: 6039         	str	r1, [r7]
; 	*flagp &= ~BIT(bit);
 8025d14: 687b         	ldr	r3, [r7, #0x4]
 8025d16: 681a         	ldr	r2, [r3]
 8025d18: 2101         	movs	r1, #0x1
 8025d1a: 683b         	ldr	r3, [r7]
 8025d1c: fa01 f303    	lsl.w	r3, r1, r3
 8025d20: 43db         	mvns	r3, r3
 8025d22: 401a         	ands	r2, r3
 8025d24: 687b         	ldr	r3, [r7, #0x4]
 8025d26: 601a         	str	r2, [r3]
; }
 8025d28: bf00         	nop
 8025d2a: 370c         	adds	r7, #0xc
 8025d2c: 46bd         	mov	sp, r7
 8025d2e: f85d 7b04    	ldr	r7, [sp], #4
 8025d32: 4770         	bx	lr

08025d34 <flag_set>:
; {
 8025d34: b480         	push	{r7}
 8025d36: b083         	sub	sp, #0xc
 8025d38: af00         	add	r7, sp, #0x0
 8025d3a: 6078         	str	r0, [r7, #0x4]
 8025d3c: 6039         	str	r1, [r7]
; 	*flagp |= BIT(bit);
 8025d3e: 687b         	ldr	r3, [r7, #0x4]
 8025d40: 681a         	ldr	r2, [r3]
 8025d42: 2101         	movs	r1, #0x1
 8025d44: 683b         	ldr	r3, [r7]
 8025d46: fa01 f303    	lsl.w	r3, r1, r3
 8025d4a: 431a         	orrs	r2, r3
 8025d4c: 687b         	ldr	r3, [r7, #0x4]
 8025d4e: 601a         	str	r2, [r3]
; }
 8025d50: bf00         	nop
 8025d52: 370c         	adds	r7, #0xc
 8025d54: 46bd         	mov	sp, r7
 8025d56: f85d 7b04    	ldr	r7, [sp], #4
 8025d5a: 4770         	bx	lr

08025d5c <flag_test>:
; {
 8025d5c: b480         	push	{r7}
 8025d5e: b083         	sub	sp, #0xc
 8025d60: af00         	add	r7, sp, #0x0
 8025d62: 6078         	str	r0, [r7, #0x4]
 8025d64: 6039         	str	r1, [r7]
; 	return (*flagp & BIT(bit)) != 0U;
 8025d66: 687b         	ldr	r3, [r7, #0x4]
 8025d68: 681a         	ldr	r2, [r3]
 8025d6a: 683b         	ldr	r3, [r7]
 8025d6c: fa22 f303    	lsr.w	r3, r2, r3
 8025d70: f003 0301    	and	r3, r3, #0x1
 8025d74: 2b00         	cmp	r3, #0x0
 8025d76: bf14         	ite	ne
 8025d78: 2301         	movne	r3, #0x1
 8025d7a: 2300         	moveq	r3, #0x0
 8025d7c: b2db         	uxtb	r3, r3
; }
 8025d7e: 4618         	mov	r0, r3
 8025d80: 370c         	adds	r7, #0xc
 8025d82: 46bd         	mov	sp, r7
 8025d84: f85d 7b04    	ldr	r7, [sp], #4
 8025d88: 4770         	bx	lr

08025d8a <flag_test_and_clear>:
; {
 8025d8a: b580         	push	{r7, lr}
 8025d8c: b084         	sub	sp, #0x10
 8025d8e: af00         	add	r7, sp, #0x0
 8025d90: 6078         	str	r0, [r7, #0x4]
 8025d92: 6039         	str	r1, [r7]
; 	bool ret = flag_test(flagp, bit);
 8025d94: 683b         	ldr	r3, [r7]
 8025d96: 4619         	mov	r1, r3
 8025d98: 6878         	ldr	r0, [r7, #0x4]
 8025d9a: f7ff ffdf    	bl	0x8025d5c <flag_test>   @ imm = #-0x42
 8025d9e: 4603         	mov	r3, r0
 8025da0: 73fb         	strb	r3, [r7, #0xf]
; 	flag_clear(flagp, bit);
 8025da2: 683b         	ldr	r3, [r7]
 8025da4: 4619         	mov	r1, r3
 8025da6: 6878         	ldr	r0, [r7, #0x4]
 8025da8: f7ff ffaf    	bl	0x8025d0a <flag_clear>  @ imm = #-0xa2
; 	return ret;
 8025dac: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8025dae: 4618         	mov	r0, r3
 8025db0: 3710         	adds	r7, #0x10
 8025db2: 46bd         	mov	sp, r7
 8025db4: bd80         	pop	{r7, pc}

08025db6 <flags_set>:
; {
 8025db6: b480         	push	{r7}
 8025db8: b083         	sub	sp, #0xc
 8025dba: af00         	add	r7, sp, #0x0
 8025dbc: 6078         	str	r0, [r7, #0x4]
 8025dbe: 6039         	str	r1, [r7]
; 	*flagp = flags;
 8025dc0: 687b         	ldr	r3, [r7, #0x4]
 8025dc2: 683a         	ldr	r2, [r7]
 8025dc4: 601a         	str	r2, [r3]
; }
 8025dc6: bf00         	nop
 8025dc8: 370c         	adds	r7, #0xc
 8025dca: 46bd         	mov	sp, r7
 8025dcc: f85d 7b04    	ldr	r7, [sp], #4
 8025dd0: 4770         	bx	lr

08025dd2 <flags_get>:
; {
 8025dd2: b480         	push	{r7}
 8025dd4: b083         	sub	sp, #0xc
 8025dd6: af00         	add	r7, sp, #0x0
 8025dd8: 6078         	str	r0, [r7, #0x4]
; 	return *flagp;
 8025dda: 687b         	ldr	r3, [r7, #0x4]
 8025ddc: 681b         	ldr	r3, [r3]
; }
 8025dde: 4618         	mov	r0, r3
 8025de0: 370c         	adds	r7, #0xc
 8025de2: 46bd         	mov	sp, r7
 8025de4: f85d 7b04    	ldr	r7, [sp], #4
 8025de8: 4770         	bx	lr

08025dea <finalize_flush_locked>:
; {
 8025dea: b580         	push	{r7, lr}
 8025dec: b084         	sub	sp, #0x10
 8025dee: af00         	add	r7, sp, #0x0
 8025df0: 6078         	str	r0, [r7, #0x4]
; 	struct z_work_flusher *flusher = CONTAINER_OF(work, struct z_work_flusher, work);
 8025df2: 687b         	ldr	r3, [r7, #0x4]
 8025df4: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_FLUSHING_BIT);
 8025df6: 687b         	ldr	r3, [r7, #0x4]
 8025df8: 330c         	adds	r3, #0xc
 8025dfa: 2104         	movs	r1, #0x4
 8025dfc: 4618         	mov	r0, r3
 8025dfe: f7ff ff84    	bl	0x8025d0a <flag_clear>  @ imm = #-0xf8
; 	k_sem_give(&flusher->sem);
 8025e02: 68fb         	ldr	r3, [r7, #0xc]
 8025e04: 3310         	adds	r3, #0x10
 8025e06: 4618         	mov	r0, r3
 8025e08: f7ff ff2b    	bl	0x8025c62 <k_sem_give>  @ imm = #-0x1aa
; };
 8025e0c: bf00         	nop
 8025e0e: 3710         	adds	r7, #0x10
 8025e10: 46bd         	mov	sp, r7
 8025e12: bd80         	pop	{r7, pc}

08025e14 <work_busy_get_locked>:
; {
 8025e14: b580         	push	{r7, lr}
 8025e16: b082         	sub	sp, #0x8
 8025e18: af00         	add	r7, sp, #0x0
 8025e1a: 6078         	str	r0, [r7, #0x4]
; 	return flags_get(&work->flags) & K_WORK_MASK;
 8025e1c: 687b         	ldr	r3, [r7, #0x4]
 8025e1e: 330c         	adds	r3, #0xc
 8025e20: 4618         	mov	r0, r3
 8025e22: f7ff ffd6    	bl	0x8025dd2 <flags_get>   @ imm = #-0x54
 8025e26: 4603         	mov	r3, r0
 8025e28: f003 031f    	and	r3, r3, #0x1f
; }
 8025e2c: 4618         	mov	r0, r3
 8025e2e: 3708         	adds	r7, #0x8
 8025e30: 46bd         	mov	sp, r7
 8025e32: bd80         	pop	{r7, pc}

08025e34 <queue_remove_locked>:
; {
 8025e34: b580         	push	{r7, lr}
 8025e36: b082         	sub	sp, #0x8
 8025e38: af00         	add	r7, sp, #0x0
 8025e3a: 6078         	str	r0, [r7, #0x4]
 8025e3c: 6039         	str	r1, [r7]
; 	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
 8025e3e: 683b         	ldr	r3, [r7]
 8025e40: 330c         	adds	r3, #0xc
 8025e42: 2102         	movs	r1, #0x2
 8025e44: 4618         	mov	r0, r3
 8025e46: f7ff ffa0    	bl	0x8025d8a <flag_test_and_clear> @ imm = #-0xc0
 8025e4a: 4603         	mov	r3, r0
 8025e4c: 2b00         	cmp	r3, #0x0
 8025e4e: d007         	beq	0x8025e60 <queue_remove_locked+0x2c> @ imm = #0xe
; 		(void)sys_slist_find_and_remove(&queue->pending, &work->node);
 8025e50: 687b         	ldr	r3, [r7, #0x4]
 8025e52: f503 738c    	add.w	r3, r3, #0x118
 8025e56: 683a         	ldr	r2, [r7]
 8025e58: 4611         	mov	r1, r2
 8025e5a: 4618         	mov	r0, r3
 8025e5c: f7ff fe92    	bl	0x8025b84 <sys_slist_find_and_remove> @ imm = #-0x2dc
; }
 8025e60: bf00         	nop
 8025e62: 3708         	adds	r7, #0x8
 8025e64: 46bd         	mov	sp, r7
 8025e66: bd80         	pop	{r7, pc}

08025e68 <notify_queue_locked>:
; {
 8025e68: b580         	push	{r7, lr}
 8025e6a: b084         	sub	sp, #0x10
 8025e6c: af00         	add	r7, sp, #0x0
 8025e6e: 6078         	str	r0, [r7, #0x4]
; 	bool rv = false;
 8025e70: 2300         	movs	r3, #0x0
 8025e72: 73fb         	strb	r3, [r7, #0xf]
; 	if (queue != NULL) {
 8025e74: 687b         	ldr	r3, [r7, #0x4]
 8025e76: 2b00         	cmp	r3, #0x0
 8025e78: d009         	beq	0x8025e8e <notify_queue_locked+0x26> @ imm = #0x12
; 		rv = z_sched_wake(&queue->notifyq, 0, NULL);
 8025e7a: 687b         	ldr	r3, [r7, #0x4]
 8025e7c: f503 7390    	add.w	r3, r3, #0x120
 8025e80: 2200         	movs	r2, #0x0
 8025e82: 2100         	movs	r1, #0x0
 8025e84: 4618         	mov	r0, r3
 8025e86: f7f0 fbd5    	bl	0x8016634 <z_sched_wake> @ imm = #-0xf856
 8025e8a: 4603         	mov	r3, r0
 8025e8c: 73fb         	strb	r3, [r7, #0xf]
; 	return rv;
 8025e8e: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8025e90: 4618         	mov	r0, r3
 8025e92: 3710         	adds	r7, #0x10
 8025e94: 46bd         	mov	sp, r7
 8025e96: bd80         	pop	{r7, pc}

08025e98 <submit_to_queue_locked>:
; {
 8025e98: b580         	push	{r7, lr}
 8025e9a: b084         	sub	sp, #0x10
 8025e9c: af00         	add	r7, sp, #0x0
 8025e9e: 6078         	str	r0, [r7, #0x4]
 8025ea0: 6039         	str	r1, [r7]
; 	int ret = 0;
 8025ea2: 2300         	movs	r3, #0x0
 8025ea4: 60fb         	str	r3, [r7, #0xc]
; 	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 8025ea6: 687b         	ldr	r3, [r7, #0x4]
 8025ea8: 330c         	adds	r3, #0xc
 8025eaa: 2101         	movs	r1, #0x1
 8025eac: 4618         	mov	r0, r3
 8025eae: f7ff ff55    	bl	0x8025d5c <flag_test>   @ imm = #-0x156
 8025eb2: 4603         	mov	r3, r0
 8025eb4: 2b00         	cmp	r3, #0x0
 8025eb6: d003         	beq	0x8025ec0 <submit_to_queue_locked+0x28> @ imm = #0x6
; 		ret = -EBUSY;
 8025eb8: f06f 030f    	mvn	r3, #0xf
 8025ebc: 60fb         	str	r3, [r7, #0xc]
 8025ebe: e03b         	b	0x8025f38 <submit_to_queue_locked+0xa0> @ imm = #0x76
; 	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
 8025ec0: 687b         	ldr	r3, [r7, #0x4]
 8025ec2: 330c         	adds	r3, #0xc
 8025ec4: 2102         	movs	r1, #0x2
 8025ec6: 4618         	mov	r0, r3
 8025ec8: f7ff ff48    	bl	0x8025d5c <flag_test>   @ imm = #-0x170
 8025ecc: 4603         	mov	r3, r0
 8025ece: f083 0301    	eor	r3, r3, #0x1
 8025ed2: b2db         	uxtb	r3, r3
 8025ed4: 2b00         	cmp	r3, #0x0
 8025ed6: d02f         	beq	0x8025f38 <submit_to_queue_locked+0xa0> @ imm = #0x5e
; 		ret = 1;
 8025ed8: 2301         	movs	r3, #0x1
 8025eda: 60fb         	str	r3, [r7, #0xc]
; 		if (*queuep == NULL) {
 8025edc: 683b         	ldr	r3, [r7]
 8025ede: 681b         	ldr	r3, [r3]
 8025ee0: 2b00         	cmp	r3, #0x0
 8025ee2: d103         	bne	0x8025eec <submit_to_queue_locked+0x54> @ imm = #0x6
; 			*queuep = work->queue;
 8025ee4: 687b         	ldr	r3, [r7, #0x4]
 8025ee6: 689a         	ldr	r2, [r3, #0x8]
 8025ee8: 683b         	ldr	r3, [r7]
 8025eea: 601a         	str	r2, [r3]
; 		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
 8025eec: 687b         	ldr	r3, [r7, #0x4]
 8025eee: 330c         	adds	r3, #0xc
 8025ef0: 2100         	movs	r1, #0x0
 8025ef2: 4618         	mov	r0, r3
 8025ef4: f7ff ff32    	bl	0x8025d5c <flag_test>   @ imm = #-0x19c
 8025ef8: 4603         	mov	r3, r0
 8025efa: 2b00         	cmp	r3, #0x0
 8025efc: d005         	beq	0x8025f0a <submit_to_queue_locked+0x72> @ imm = #0xa
; 			*queuep = work->queue;
 8025efe: 687b         	ldr	r3, [r7, #0x4]
 8025f00: 689a         	ldr	r2, [r3, #0x8]
 8025f02: 683b         	ldr	r3, [r7]
 8025f04: 601a         	str	r2, [r3]
; 			ret = 2;
 8025f06: 2302         	movs	r3, #0x2
 8025f08: 60fb         	str	r3, [r7, #0xc]
; 		int rc = queue_submit_locked(*queuep, work);
 8025f0a: 683b         	ldr	r3, [r7]
 8025f0c: 681b         	ldr	r3, [r3]
 8025f0e: 6879         	ldr	r1, [r7, #0x4]
 8025f10: 4618         	mov	r0, r3
 8025f12: f7ee fa51    	bl	0x80143b8 <queue_submit_locked> @ imm = #-0x11b5e
 8025f16: 60b8         	str	r0, [r7, #0x8]
; 		if (rc < 0) {
 8025f18: 68bb         	ldr	r3, [r7, #0x8]
 8025f1a: 2b00         	cmp	r3, #0x0
 8025f1c: da02         	bge	0x8025f24 <submit_to_queue_locked+0x8c> @ imm = #0x4
; 			ret = rc;
 8025f1e: 68bb         	ldr	r3, [r7, #0x8]
 8025f20: 60fb         	str	r3, [r7, #0xc]
 8025f22: e009         	b	0x8025f38 <submit_to_queue_locked+0xa0> @ imm = #0x12
; 			flag_set(&work->flags, K_WORK_QUEUED_BIT);
 8025f24: 687b         	ldr	r3, [r7, #0x4]
 8025f26: 330c         	adds	r3, #0xc
 8025f28: 2102         	movs	r1, #0x2
 8025f2a: 4618         	mov	r0, r3
 8025f2c: f7ff ff02    	bl	0x8025d34 <flag_set>    @ imm = #-0x1fc
; 			work->queue = *queuep;
 8025f30: 683b         	ldr	r3, [r7]
 8025f32: 681a         	ldr	r2, [r3]
 8025f34: 687b         	ldr	r3, [r7, #0x4]
 8025f36: 609a         	str	r2, [r3, #0x8]
; 	if (ret <= 0) {
 8025f38: 68fb         	ldr	r3, [r7, #0xc]
 8025f3a: 2b00         	cmp	r3, #0x0
 8025f3c: dc02         	bgt	0x8025f44 <submit_to_queue_locked+0xac> @ imm = #0x4
; 		*queuep = NULL;
 8025f3e: 683b         	ldr	r3, [r7]
 8025f40: 2200         	movs	r2, #0x0
 8025f42: 601a         	str	r2, [r3]
; 	return ret;
 8025f44: 68fb         	ldr	r3, [r7, #0xc]
; }
 8025f46: 4618         	mov	r0, r3
 8025f48: 3710         	adds	r7, #0x10
 8025f4a: 46bd         	mov	sp, r7
 8025f4c: bd80         	pop	{r7, pc}

08025f4e <k_work_submit_to_queue>:
; {
 8025f4e: b580         	push	{r7, lr}
 8025f50: b084         	sub	sp, #0x10
 8025f52: af00         	add	r7, sp, #0x0
 8025f54: 6078         	str	r0, [r7, #0x4]
 8025f56: 6039         	str	r1, [r7]
; 	int ret = z_work_submit_to_queue(queue, work);
 8025f58: 6839         	ldr	r1, [r7]
 8025f5a: 6878         	ldr	r0, [r7, #0x4]
 8025f5c: f7ee faa0    	bl	0x80144a0 <z_work_submit_to_queue> @ imm = #-0x11ac0
 8025f60: 60f8         	str	r0, [r7, #0xc]
; 	if (ret > 0) {
 8025f62: 68fb         	ldr	r3, [r7, #0xc]
 8025f64: 2b00         	cmp	r3, #0x0
 8025f66: dd01         	ble	0x8025f6c <k_work_submit_to_queue+0x1e> @ imm = #0x2
; 		z_reschedule_unlocked();
 8025f68: f7ff fe9e    	bl	0x8025ca8 <z_reschedule_unlocked> @ imm = #-0x2c4
; 	return ret;
 8025f6c: 68fb         	ldr	r3, [r7, #0xc]
; }
 8025f6e: 4618         	mov	r0, r3
 8025f70: 3710         	adds	r7, #0x10
 8025f72: 46bd         	mov	sp, r7
 8025f74: bd80         	pop	{r7, pc}

08025f76 <cancel_async_locked>:
; {
 8025f76: b580         	push	{r7, lr}
 8025f78: b084         	sub	sp, #0x10
 8025f7a: af00         	add	r7, sp, #0x0
 8025f7c: 6078         	str	r0, [r7, #0x4]
; 	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 8025f7e: 687b         	ldr	r3, [r7, #0x4]
 8025f80: 330c         	adds	r3, #0xc
 8025f82: 2101         	movs	r1, #0x1
 8025f84: 4618         	mov	r0, r3
 8025f86: f7ff fee9    	bl	0x8025d5c <flag_test>   @ imm = #-0x22e
 8025f8a: 4603         	mov	r3, r0
 8025f8c: f083 0301    	eor	r3, r3, #0x1
 8025f90: b2db         	uxtb	r3, r3
 8025f92: 2b00         	cmp	r3, #0x0
 8025f94: d005         	beq	0x8025fa2 <cancel_async_locked+0x2c> @ imm = #0xa
; 		queue_remove_locked(work->queue, work);
 8025f96: 687b         	ldr	r3, [r7, #0x4]
 8025f98: 689b         	ldr	r3, [r3, #0x8]
 8025f9a: 6879         	ldr	r1, [r7, #0x4]
 8025f9c: 4618         	mov	r0, r3
 8025f9e: f7ff ff49    	bl	0x8025e34 <queue_remove_locked> @ imm = #-0x16e
; 	int ret = work_busy_get_locked(work);
 8025fa2: 6878         	ldr	r0, [r7, #0x4]
 8025fa4: f7ff ff36    	bl	0x8025e14 <work_busy_get_locked> @ imm = #-0x194
 8025fa8: 60f8         	str	r0, [r7, #0xc]
; 	if (ret != 0) {
 8025faa: 68fb         	ldr	r3, [r7, #0xc]
 8025fac: 2b00         	cmp	r3, #0x0
 8025fae: d009         	beq	0x8025fc4 <cancel_async_locked+0x4e> @ imm = #0x12
; 		flag_set(&work->flags, K_WORK_CANCELING_BIT);
 8025fb0: 687b         	ldr	r3, [r7, #0x4]
 8025fb2: 330c         	adds	r3, #0xc
 8025fb4: 2101         	movs	r1, #0x1
 8025fb6: 4618         	mov	r0, r3
 8025fb8: f7ff febc    	bl	0x8025d34 <flag_set>    @ imm = #-0x288
; 		ret = work_busy_get_locked(work);
 8025fbc: 6878         	ldr	r0, [r7, #0x4]
 8025fbe: f7ff ff29    	bl	0x8025e14 <work_busy_get_locked> @ imm = #-0x1ae
 8025fc2: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 8025fc4: 68fb         	ldr	r3, [r7, #0xc]
; }
 8025fc6: 4618         	mov	r0, r3
 8025fc8: 3710         	adds	r7, #0x10
 8025fca: 46bd         	mov	sp, r7
 8025fcc: bd80         	pop	{r7, pc}

08025fce <k_work_queue_init>:
; {
 8025fce: b580         	push	{r7, lr}
 8025fd0: b0d0         	sub	sp, #0x140
 8025fd2: af00         	add	r7, sp, #0x0
 8025fd4: f507 73a0    	add.w	r3, r7, #0x140
 8025fd8: f5a3 739e    	sub.w	r3, r3, #0x13c
 8025fdc: 6018         	str	r0, [r3]
; 	*queue = (struct k_work_q){
 8025fde: f507 73a0    	add.w	r3, r7, #0x140
 8025fe2: f5a3 739e    	sub.w	r3, r3, #0x13c
 8025fe6: 681b         	ldr	r3, [r3]
 8025fe8: 4618         	mov	r0, r3
 8025fea: f44f 739c    	mov.w	r3, #0x138
 8025fee: 461a         	mov	r2, r3
 8025ff0: 2100         	movs	r1, #0x0
 8025ff2: f001 fa89    	bl	0x8027508 <memset>      @ imm = #0x1512
; }
 8025ff6: bf00         	nop
 8025ff8: f507 77a0    	add.w	r7, r7, #0x140
 8025ffc: 46bd         	mov	sp, r7
 8025ffe: bd80         	pop	{r7, pc}

08026000 <k_work_init_delayable>:
; {
 8026000: b580         	push	{r7, lr}
 8026002: b08e         	sub	sp, #0x38
 8026004: af00         	add	r7, sp, #0x0
 8026006: 6078         	str	r0, [r7, #0x4]
 8026008: 6039         	str	r1, [r7]
; 	*dwork = (struct k_work_delayable){
 802600a: 687b         	ldr	r3, [r7, #0x4]
 802600c: 4618         	mov	r0, r3
 802600e: 2330         	movs	r3, #0x30
 8026010: 461a         	mov	r2, r3
 8026012: 2100         	movs	r1, #0x0
 8026014: f001 fa78    	bl	0x8027508 <memset>      @ imm = #0x14f0
 8026018: 687b         	ldr	r3, [r7, #0x4]
 802601a: 683a         	ldr	r2, [r7]
 802601c: 605a         	str	r2, [r3, #0x4]
 802601e: 687b         	ldr	r3, [r7, #0x4]
 8026020: f44f 7280    	mov.w	r2, #0x100
 8026024: 60da         	str	r2, [r3, #0xc]
; 	z_init_timeout(&dwork->timeout);
 8026026: 687b         	ldr	r3, [r7, #0x4]
 8026028: 3310         	adds	r3, #0x10
 802602a: 4618         	mov	r0, r3
 802602c: f7ff fe24    	bl	0x8025c78 <z_init_timeout> @ imm = #-0x3b8
; }
 8026030: bf00         	nop
 8026032: 3738         	adds	r7, #0x38
 8026034: 46bd         	mov	sp, r7
 8026036: bd80         	pop	{r7, pc}

08026038 <unschedule_locked>:
; {
 8026038: b580         	push	{r7, lr}
 802603a: b084         	sub	sp, #0x10
 802603c: af00         	add	r7, sp, #0x0
 802603e: 6078         	str	r0, [r7, #0x4]
; 	bool ret = false;
 8026040: 2300         	movs	r3, #0x0
 8026042: 73fb         	strb	r3, [r7, #0xf]
; 	struct k_work *work = &dwork->work;
 8026044: 687b         	ldr	r3, [r7, #0x4]
 8026046: 60bb         	str	r3, [r7, #0x8]
; 	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
 8026048: 68bb         	ldr	r3, [r7, #0x8]
 802604a: 330c         	adds	r3, #0xc
 802604c: 2103         	movs	r1, #0x3
 802604e: 4618         	mov	r0, r3
 8026050: f7ff fe9b    	bl	0x8025d8a <flag_test_and_clear> @ imm = #-0x2ca
 8026054: 4603         	mov	r3, r0
 8026056: 2b00         	cmp	r3, #0x0
 8026058: d00a         	beq	0x8026070 <unschedule_locked+0x38> @ imm = #0x14
; 		ret = z_abort_timeout(&dwork->timeout) == 0;
 802605a: 687b         	ldr	r3, [r7, #0x4]
 802605c: 3310         	adds	r3, #0x10
 802605e: 4618         	mov	r0, r3
 8026060: f7f0 fed0    	bl	0x8016e04 <z_abort_timeout> @ imm = #-0xf260
 8026064: 4603         	mov	r3, r0
 8026066: 2b00         	cmp	r3, #0x0
 8026068: bf0c         	ite	eq
 802606a: 2301         	moveq	r3, #0x1
 802606c: 2300         	movne	r3, #0x0
 802606e: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 8026070: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8026072: 4618         	mov	r0, r3
 8026074: 3710         	adds	r7, #0x10
 8026076: 46bd         	mov	sp, r7
 8026078: bd80         	pop	{r7, pc}

0802607a <cancel_delayable_async_locked>:
; {
 802607a: b580         	push	{r7, lr}
 802607c: b082         	sub	sp, #0x8
 802607e: af00         	add	r7, sp, #0x0
 8026080: 6078         	str	r0, [r7, #0x4]
; 	(void)unschedule_locked(dwork);
 8026082: 6878         	ldr	r0, [r7, #0x4]
 8026084: f7ff ffd8    	bl	0x8026038 <unschedule_locked> @ imm = #-0x50
; 	return cancel_async_locked(&dwork->work);
 8026088: 687b         	ldr	r3, [r7, #0x4]
 802608a: 4618         	mov	r0, r3
 802608c: f7ff ff73    	bl	0x8025f76 <cancel_async_locked> @ imm = #-0x11a
 8026090: 4603         	mov	r3, r0
; }
 8026092: 4618         	mov	r0, r3
 8026094: 3708         	adds	r7, #0x8
 8026096: 46bd         	mov	sp, r7
 8026098: bd80         	pop	{r7, pc}

0802609a <sys_dlist_init>:
; {
 802609a: b480         	push	{r7}
 802609c: b083         	sub	sp, #0xc
 802609e: af00         	add	r7, sp, #0x0
 80260a0: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 80260a2: 687b         	ldr	r3, [r7, #0x4]
 80260a4: 687a         	ldr	r2, [r7, #0x4]
 80260a6: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 80260a8: 687b         	ldr	r3, [r7, #0x4]
 80260aa: 687a         	ldr	r2, [r7, #0x4]
 80260ac: 605a         	str	r2, [r3, #0x4]
; }
 80260ae: bf00         	nop
 80260b0: 370c         	adds	r7, #0xc
 80260b2: 46bd         	mov	sp, r7
 80260b4: f85d 7b04    	ldr	r7, [sp], #4
 80260b8: 4770         	bx	lr

080260ba <sys_dnode_init>:
; {
 80260ba: b480         	push	{r7}
 80260bc: b083         	sub	sp, #0xc
 80260be: af00         	add	r7, sp, #0x0
 80260c0: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 80260c2: 687b         	ldr	r3, [r7, #0x4]
 80260c4: 2200         	movs	r2, #0x0
 80260c6: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 80260c8: 687b         	ldr	r3, [r7, #0x4]
 80260ca: 2200         	movs	r2, #0x0
 80260cc: 605a         	str	r2, [r3, #0x4]
; }
 80260ce: bf00         	nop
 80260d0: 370c         	adds	r7, #0xc
 80260d2: 46bd         	mov	sp, r7
 80260d4: f85d 7b04    	ldr	r7, [sp], #4
 80260d8: 4770         	bx	lr

080260da <K_KERNEL_STACK_BUFFER>:
; {
 80260da: b480         	push	{r7}
 80260dc: b083         	sub	sp, #0xc
 80260de: af00         	add	r7, sp, #0x0
 80260e0: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 80260e2: 687b         	ldr	r3, [r7, #0x4]
; }
 80260e4: 4618         	mov	r0, r3
 80260e6: 370c         	adds	r7, #0xc
 80260e8: 46bd         	mov	sp, r7
 80260ea: f85d 7b04    	ldr	r7, [sp], #4
 80260ee: 4770         	bx	lr

080260f0 <k_thread_start>:
; {
 80260f0: b580         	push	{r7, lr}
 80260f2: b082         	sub	sp, #0x8
 80260f4: af00         	add	r7, sp, #0x0
 80260f6: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 80260f8: 6878         	ldr	r0, [r7, #0x4]
 80260fa: f000 f804    	bl	0x8026106 <k_thread_resume> @ imm = #0x8
; }
 80260fe: bf00         	nop
 8026100: 3708         	adds	r7, #0x8
 8026102: 46bd         	mov	sp, r7
 8026104: bd80         	pop	{r7, pc}

08026106 <k_thread_resume>:
; {
 8026106: b580         	push	{r7, lr}
 8026108: b082         	sub	sp, #0x8
 802610a: af00         	add	r7, sp, #0x0
 802610c: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 802610e: 6878         	ldr	r0, [r7, #0x4]
 8026110: f7ef fa3e    	bl	0x8015590 <z_impl_k_thread_resume> @ imm = #-0x10b84
; }
 8026114: bf00         	nop
 8026116: 3708         	adds	r7, #0x8
 8026118: 46bd         	mov	sp, r7
 802611a: bd80         	pop	{r7, pc}

0802611c <z_init_timeout>:
; {
 802611c: b580         	push	{r7, lr}
 802611e: b082         	sub	sp, #0x8
 8026120: af00         	add	r7, sp, #0x0
 8026122: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 8026124: 687b         	ldr	r3, [r7, #0x4]
 8026126: 4618         	mov	r0, r3
 8026128: f7ff ffc7    	bl	0x80260ba <sys_dnode_init> @ imm = #-0x72
; }
 802612c: bf00         	nop
 802612e: 3708         	adds	r7, #0x8
 8026130: 46bd         	mov	sp, r7
 8026132: bd80         	pop	{r7, pc}

08026134 <z_init_thread_timeout>:
; {
 8026134: b580         	push	{r7, lr}
 8026136: b082         	sub	sp, #0x8
 8026138: af00         	add	r7, sp, #0x0
 802613a: 6078         	str	r0, [r7, #0x4]
; 	z_init_timeout(&thread_base->timeout);
 802613c: 687b         	ldr	r3, [r7, #0x4]
 802613e: 3318         	adds	r3, #0x18
 8026140: 4618         	mov	r0, r3
 8026142: f7ff ffeb    	bl	0x802611c <z_init_timeout> @ imm = #-0x2a
; }
 8026146: bf00         	nop
 8026148: 3708         	adds	r7, #0x8
 802614a: 46bd         	mov	sp, r7
 802614c: bd80         	pop	{r7, pc}

0802614e <thread_schedule_new>:
; {
 802614e: b580         	push	{r7, lr}
 8026150: b084         	sub	sp, #0x10
 8026152: af00         	add	r7, sp, #0x0
 8026154: 60f8         	str	r0, [r7, #0xc]
 8026156: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 802615a: e9d7 2300    	ldrd	r2, r3, [r7]
 802615e: f04f 0000    	mov.w	r0, #0x0
 8026162: f04f 0100    	mov.w	r1, #0x0
 8026166: 428b         	cmp	r3, r1
 8026168: bf08         	it	eq
 802616a: 4282         	cmpeq	r2, r0
 802616c: d103         	bne	0x8026176 <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 802616e: 68f8         	ldr	r0, [r7, #0xc]
 8026170: f7ff ffbe    	bl	0x80260f0 <k_thread_start> @ imm = #-0x84
 8026174: e004         	b	0x8026180 <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 8026176: e9d7 2300    	ldrd	r2, r3, [r7]
 802617a: 68f8         	ldr	r0, [r7, #0xc]
 802617c: f7ee fc42    	bl	0x8014a04 <z_add_thread_timeout> @ imm = #-0x1177c
; }
 8026180: bf00         	nop
 8026182: 3710         	adds	r7, #0x10
 8026184: 46bd         	mov	sp, r7
 8026186: bd80         	pop	{r7, pc}

08026188 <z_waitq_init>:
; {
 8026188: b580         	push	{r7, lr}
 802618a: b082         	sub	sp, #0x8
 802618c: af00         	add	r7, sp, #0x0
 802618e: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8026190: 687b         	ldr	r3, [r7, #0x4]
 8026192: 4618         	mov	r0, r3
 8026194: f7ff ff81    	bl	0x802609a <sys_dlist_init> @ imm = #-0xfe
; }
 8026198: bf00         	nop
 802619a: 3708         	adds	r7, #0x8
 802619c: 46bd         	mov	sp, r7
 802619e: bd80         	pop	{r7, pc}

080261a0 <z_log_msg_runtime_create>:
; {
 80261a0: b580         	push	{r7, lr}
 80261a2: b08a         	sub	sp, #0x28
 80261a4: af04         	add	r7, sp, #0x10
 80261a6: 60b9         	str	r1, [r7, #0x8]
 80261a8: 607b         	str	r3, [r7, #0x4]
 80261aa: 4603         	mov	r3, r0
 80261ac: 73fb         	strb	r3, [r7, #0xf]
 80261ae: 4613         	mov	r3, r2
 80261b0: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80261b2: f107 032c    	add.w	r3, r7, #0x2c
 80261b6: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80261b8: 7bba         	ldrb	r2, [r7, #0xe]
 80261ba: 7bf8         	ldrb	r0, [r7, #0xf]
 80261bc: 697b         	ldr	r3, [r7, #0x14]
 80261be: 9303         	str	r3, [sp, #0xc]
 80261c0: 6abb         	ldr	r3, [r7, #0x28]
 80261c2: 9302         	str	r3, [sp, #0x8]
 80261c4: 6a7b         	ldr	r3, [r7, #0x24]
 80261c6: 9301         	str	r3, [sp, #0x4]
 80261c8: 6a3b         	ldr	r3, [r7, #0x20]
 80261ca: 9300         	str	r3, [sp]
 80261cc: 687b         	ldr	r3, [r7, #0x4]
 80261ce: 68b9         	ldr	r1, [r7, #0x8]
 80261d0: f7de fcb8    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x21690
; }
 80261d4: bf00         	nop
 80261d6: 3718         	adds	r7, #0x18
 80261d8: 46bd         	mov	sp, r7
 80261da: bd80         	pop	{r7, pc}

080261dc <k_is_in_isr>:
; {
 80261dc: b480         	push	{r7}
 80261de: b083         	sub	sp, #0xc
 80261e0: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80261e2: f3ef 8305    	mrs	r3, ipsr
 80261e6: 607b         	str	r3, [r7, #0x4]
;   return(result);
 80261e8: 687b         	ldr	r3, [r7, #0x4]
; 	return (__get_IPSR()) ? (true) : (false);
 80261ea: 2b00         	cmp	r3, #0x0
 80261ec: bf14         	ite	ne
 80261ee: 2301         	movne	r3, #0x1
 80261f0: 2300         	moveq	r3, #0x0
 80261f2: b2db         	uxtb	r3, r3
; }
 80261f4: 4618         	mov	r0, r3
 80261f6: 370c         	adds	r7, #0xc
 80261f8: 46bd         	mov	sp, r7
 80261fa: f85d 7b04    	ldr	r7, [sp], #4
 80261fe: 4770         	bx	lr

08026200 <z_impl_k_thread_priority_get>:
; {
 8026200: b480         	push	{r7}
 8026202: b083         	sub	sp, #0xc
 8026204: af00         	add	r7, sp, #0x0
 8026206: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.prio;
 8026208: 687b         	ldr	r3, [r7, #0x4]
 802620a: f993 300e    	ldrsb.w	r3, [r3, #0xe]
; }
 802620e: 4618         	mov	r0, r3
 8026210: 370c         	adds	r7, #0xc
 8026212: 46bd         	mov	sp, r7
 8026214: f85d 7b04    	ldr	r7, [sp], #4
 8026218: 4770         	bx	lr

0802621a <k_thread_name_get>:
; {
 802621a: b480         	push	{r7}
 802621c: b083         	sub	sp, #0xc
 802621e: af00         	add	r7, sp, #0x0
 8026220: 6078         	str	r0, [r7, #0x4]
; 	return (const char *)thread->name;
 8026222: 687b         	ldr	r3, [r7, #0x4]
 8026224: 3394         	adds	r3, #0x94
; }
 8026226: 4618         	mov	r0, r3
 8026228: 370c         	adds	r7, #0xc
 802622a: 46bd         	mov	sp, r7
 802622c: f85d 7b04    	ldr	r7, [sp], #4
 8026230: 4770         	bx	lr

08026232 <z_impl_k_thread_create>:
; {
 8026232: b580         	push	{r7, lr}
 8026234: b08a         	sub	sp, #0x28
 8026236: af06         	add	r7, sp, #0x18
 8026238: 60f8         	str	r0, [r7, #0xc]
 802623a: 60b9         	str	r1, [r7, #0x8]
 802623c: 607a         	str	r2, [r7, #0x4]
 802623e: 603b         	str	r3, [r7]
; 	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 8026240: 2300         	movs	r3, #0x0
 8026242: 9305         	str	r3, [sp, #0x14]
 8026244: 6abb         	ldr	r3, [r7, #0x28]
 8026246: 9304         	str	r3, [sp, #0x10]
 8026248: 6a7b         	ldr	r3, [r7, #0x24]
 802624a: 9303         	str	r3, [sp, #0xc]
 802624c: 6a3b         	ldr	r3, [r7, #0x20]
 802624e: 9302         	str	r3, [sp, #0x8]
 8026250: 69fb         	ldr	r3, [r7, #0x1c]
 8026252: 9301         	str	r3, [sp, #0x4]
 8026254: 69bb         	ldr	r3, [r7, #0x18]
 8026256: 9300         	str	r3, [sp]
 8026258: 683b         	ldr	r3, [r7]
 802625a: 687a         	ldr	r2, [r7, #0x4]
 802625c: 68b9         	ldr	r1, [r7, #0x8]
 802625e: 68f8         	ldr	r0, [r7, #0xc]
 8026260: f7ee fc74    	bl	0x8014b4c <z_setup_new_thread> @ imm = #-0x11718
; 	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
 8026264: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8026268: f04f 30ff    	mov.w	r0, #0xffffffff
 802626c: f04f 31ff    	mov.w	r1, #0xffffffff
 8026270: 428b         	cmp	r3, r1
 8026272: bf08         	it	eq
 8026274: 4282         	cmpeq	r2, r0
 8026276: d004         	beq	0x8026282 <z_impl_k_thread_create+0x50> @ imm = #0x8
; 		thread_schedule_new(new_thread, delay);
 8026278: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 802627c: 68f8         	ldr	r0, [r7, #0xc]
 802627e: f7ff ff66    	bl	0x802614e <thread_schedule_new> @ imm = #-0x134
; 	return new_thread;
 8026282: 68fb         	ldr	r3, [r7, #0xc]
; }
 8026284: 4618         	mov	r0, r3
 8026286: 3710         	adds	r7, #0x10
 8026288: 46bd         	mov	sp, r7
 802628a: bd80         	pop	{r7, pc}

0802628c <z_init_thread_base>:
; {
 802628c: b580         	push	{r7, lr}
 802628e: b084         	sub	sp, #0x10
 8026290: af00         	add	r7, sp, #0x0
 8026292: 60f8         	str	r0, [r7, #0xc]
 8026294: 60b9         	str	r1, [r7, #0x8]
 8026296: 607a         	str	r2, [r7, #0x4]
 8026298: 603b         	str	r3, [r7]
; 	thread_base->pended_on = NULL;
 802629a: 68fb         	ldr	r3, [r7, #0xc]
 802629c: 2200         	movs	r2, #0x0
 802629e: 609a         	str	r2, [r3, #0x8]
; 	thread_base->user_options = (uint8_t)options;
 80262a0: 683b         	ldr	r3, [r7]
 80262a2: b2da         	uxtb	r2, r3
 80262a4: 68fb         	ldr	r3, [r7, #0xc]
 80262a6: 731a         	strb	r2, [r3, #0xc]
; 	thread_base->thread_state = (uint8_t)initial_state;
 80262a8: 687b         	ldr	r3, [r7, #0x4]
 80262aa: b2da         	uxtb	r2, r3
 80262ac: 68fb         	ldr	r3, [r7, #0xc]
 80262ae: 735a         	strb	r2, [r3, #0xd]
; 	thread_base->prio = priority;
 80262b0: 68bb         	ldr	r3, [r7, #0x8]
 80262b2: b25a         	sxtb	r2, r3
 80262b4: 68fb         	ldr	r3, [r7, #0xc]
 80262b6: 739a         	strb	r2, [r3, #0xe]
; 	thread_base->sched_locked = 0U;
 80262b8: 68fb         	ldr	r3, [r7, #0xc]
 80262ba: 2200         	movs	r2, #0x0
 80262bc: 73da         	strb	r2, [r3, #0xf]
; 	z_init_thread_timeout(thread_base);
 80262be: 68f8         	ldr	r0, [r7, #0xc]
 80262c0: f7ff ff38    	bl	0x8026134 <z_init_thread_timeout> @ imm = #-0x190
; }
 80262c4: bf00         	nop
 80262c6: 3710         	adds	r7, #0x10
 80262c8: 46bd         	mov	sp, r7
 80262ca: bd80         	pop	{r7, pc}

080262cc <z_stack_space_get>:
; {
 80262cc: b480         	push	{r7}
 80262ce: b089         	sub	sp, #0x24
 80262d0: af00         	add	r7, sp, #0x0
 80262d2: 60f8         	str	r0, [r7, #0xc]
 80262d4: 60b9         	str	r1, [r7, #0x8]
 80262d6: 607a         	str	r2, [r7, #0x4]
; 	size_t unused = 0;
 80262d8: 2300         	movs	r3, #0x0
 80262da: 61fb         	str	r3, [r7, #0x1c]
; 	const uint8_t *checked_stack = stack_start;
 80262dc: 68fb         	ldr	r3, [r7, #0xc]
 80262de: 617b         	str	r3, [r7, #0x14]
; 	const uint8_t *stack_pointer = (const uint8_t *)&stack_start;
 80262e0: f107 030c    	add.w	r3, r7, #0xc
 80262e4: 613b         	str	r3, [r7, #0x10]
; 	for (size_t i = 0; i < size; i++) {
 80262e6: 2300         	movs	r3, #0x0
 80262e8: 61bb         	str	r3, [r7, #0x18]
 80262ea: e00b         	b	0x8026304 <z_stack_space_get+0x38> @ imm = #0x16
; 		if ((checked_stack[i]) == 0xaaU) {
 80262ec: 697a         	ldr	r2, [r7, #0x14]
 80262ee: 69bb         	ldr	r3, [r7, #0x18]
 80262f0: 4413         	add	r3, r2
 80262f2: 781b         	ldrb	r3, [r3]
 80262f4: 2baa         	cmp	r3, #0xaa
 80262f6: d10a         	bne	0x802630e <z_stack_space_get+0x42> @ imm = #0x14
; 			unused++;
 80262f8: 69fb         	ldr	r3, [r7, #0x1c]
 80262fa: 3301         	adds	r3, #0x1
 80262fc: 61fb         	str	r3, [r7, #0x1c]
; 	for (size_t i = 0; i < size; i++) {
 80262fe: 69bb         	ldr	r3, [r7, #0x18]
 8026300: 3301         	adds	r3, #0x1
 8026302: 61bb         	str	r3, [r7, #0x18]
 8026304: 69ba         	ldr	r2, [r7, #0x18]
 8026306: 68bb         	ldr	r3, [r7, #0x8]
 8026308: 429a         	cmp	r2, r3
 802630a: d3ef         	blo	0x80262ec <z_stack_space_get+0x20> @ imm = #-0x22
 802630c: e000         	b	0x8026310 <z_stack_space_get+0x44> @ imm = #0x0
; 			break;
 802630e: bf00         	nop
; 	*unused_ptr = unused;
 8026310: 687b         	ldr	r3, [r7, #0x4]
 8026312: 69fa         	ldr	r2, [r7, #0x1c]
 8026314: 601a         	str	r2, [r3]
; 	return 0;
 8026316: 2300         	movs	r3, #0x0
; }
 8026318: 4618         	mov	r0, r3
 802631a: 3724         	adds	r7, #0x24
 802631c: 46bd         	mov	sp, r7
 802631e: f85d 7b04    	ldr	r7, [sp], #4
 8026322: 4770         	bx	lr

08026324 <z_impl_k_thread_stack_space_get>:
; {
 8026324: b580         	push	{r7, lr}
 8026326: b082         	sub	sp, #0x8
 8026328: af00         	add	r7, sp, #0x0
 802632a: 6078         	str	r0, [r7, #0x4]
 802632c: 6039         	str	r1, [r7]
; 	return z_stack_space_get((const uint8_t *)thread->stack_info.start,
 802632e: 687b         	ldr	r3, [r7, #0x4]
 8026330: f8d3 30b4    	ldr.w	r3, [r3, #0xb4]
 8026334: 4618         	mov	r0, r3
; 				 thread->stack_info.size, unused_ptr);
 8026336: 687b         	ldr	r3, [r7, #0x4]
 8026338: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
; 	return z_stack_space_get((const uint8_t *)thread->stack_info.start,
 802633c: 683a         	ldr	r2, [r7]
 802633e: 4619         	mov	r1, r3
 8026340: f7ff ffc4    	bl	0x80262cc <z_stack_space_get> @ imm = #-0x78
 8026344: 4603         	mov	r3, r0
; }
 8026346: 4618         	mov	r0, r3
 8026348: 3708         	adds	r7, #0x8
 802634a: 46bd         	mov	sp, r7
 802634c: bd80         	pop	{r7, pc}

0802634e <z_thread_mark_switched_out>:
; {
 802634e: b580         	push	{r7, lr}
 8026350: af00         	add	r7, sp, #0x0
; 	z_sched_usage_stop();
 8026352: f7f1 f8cb    	bl	0x80174ec <z_sched_usage_stop> @ imm = #-0xee6a
; }
 8026356: bf00         	nop
 8026358: bd80         	pop	{r7, pc}

0802635a <k_thread_runtime_stats_get>:
; {
 802635a: b580         	push	{r7, lr}
 802635c: b082         	sub	sp, #0x8
 802635e: af00         	add	r7, sp, #0x0
 8026360: 6078         	str	r0, [r7, #0x4]
 8026362: 6039         	str	r1, [r7]
; 	if ((thread == NULL) || (stats == NULL)) {
 8026364: 687b         	ldr	r3, [r7, #0x4]
 8026366: 2b00         	cmp	r3, #0x0
 8026368: d002         	beq	0x8026370 <k_thread_runtime_stats_get+0x16> @ imm = #0x4
 802636a: 683b         	ldr	r3, [r7]
 802636c: 2b00         	cmp	r3, #0x0
 802636e: d102         	bne	0x8026376 <k_thread_runtime_stats_get+0x1c> @ imm = #0x4
; 		return -EINVAL;
 8026370: f06f 0315    	mvn	r3, #0x15
 8026374: e004         	b	0x8026380 <k_thread_runtime_stats_get+0x26> @ imm = #0x8
; 	z_sched_thread_usage(thread, stats);
 8026376: 6839         	ldr	r1, [r7]
 8026378: 6878         	ldr	r0, [r7, #0x4]
 802637a: f7f1 f98b    	bl	0x8017694 <z_sched_thread_usage> @ imm = #-0xecea
; 	return 0;
 802637e: 2300         	movs	r3, #0x0
; }
 8026380: 4618         	mov	r0, r3
 8026382: 3708         	adds	r7, #0x8
 8026384: 46bd         	mov	sp, r7
 8026386: bd80         	pop	{r7, pc}

08026388 <k_thread_runtime_stats_all_get>:
; {
 8026388: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 802638c: b090         	sub	sp, #0x40
 802638e: af00         	add	r7, sp, #0x0
 8026390: 6078         	str	r0, [r7, #0x4]
; 	if (stats == NULL) {
 8026392: 687b         	ldr	r3, [r7, #0x4]
 8026394: 2b00         	cmp	r3, #0x0
 8026396: d102         	bne	0x802639e <k_thread_runtime_stats_all_get+0x16> @ imm = #0x4
; 		return -EINVAL;
 8026398: f06f 0315    	mvn	r3, #0x15
 802639c: e044         	b	0x8026428 <k_thread_runtime_stats_all_get+0xa0> @ imm = #0x88
; 	*stats = (k_thread_runtime_stats_t) {};
 802639e: 687b         	ldr	r3, [r7, #0x4]
 80263a0: 461a         	mov	r2, r3
 80263a2: 2300         	movs	r3, #0x0
 80263a4: 6013         	str	r3, [r2]
 80263a6: 6053         	str	r3, [r2, #0x4]
 80263a8: 6093         	str	r3, [r2, #0x8]
 80263aa: 60d3         	str	r3, [r2, #0xc]
 80263ac: 6113         	str	r3, [r2, #0x10]
 80263ae: 6153         	str	r3, [r2, #0x14]
; 	return CONFIG_MP_MAX_NUM_CPUS;
 80263b0: 2301         	movs	r3, #0x1
; 	unsigned int num_cpus = arch_num_cpus();
 80263b2: 63bb         	str	r3, [r7, #0x38]
; 	for (uint8_t i = 0; i < num_cpus; i++) {
 80263b4: 2300         	movs	r3, #0x0
 80263b6: f887 303f    	strb.w	r3, [r7, #0x3f]
 80263ba: e02f         	b	0x802641c <k_thread_runtime_stats_all_get+0x94> @ imm = #0x5e
; 		z_sched_cpu_usage(i, &tmp_stats);
 80263bc: f107 0220    	add.w	r2, r7, #0x20
 80263c0: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 80263c4: 4611         	mov	r1, r2
 80263c6: 4618         	mov	r0, r3
 80263c8: f7f1 f8e8    	bl	0x801759c <z_sched_cpu_usage> @ imm = #-0xee30
; 		stats->execution_cycles += tmp_stats.execution_cycles;
 80263cc: 687b         	ldr	r3, [r7, #0x4]
 80263ce: e9d3 0100    	ldrd	r0, r1, [r3]
 80263d2: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 80263d6: 1884         	adds	r4, r0, r2
 80263d8: eb41 0503    	adc.w	r5, r1, r3
 80263dc: 687b         	ldr	r3, [r7, #0x4]
 80263de: e9c3 4500    	strd	r4, r5, [r3]
; 		stats->total_cycles     += tmp_stats.total_cycles;
 80263e2: 687b         	ldr	r3, [r7, #0x4]
 80263e4: e9d3 0102    	ldrd	r0, r1, [r3, #8]
 80263e8: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 80263ec: eb10 0802    	adds.w	r8, r0, r2
 80263f0: eb41 0903    	adc.w	r9, r1, r3
 80263f4: 687b         	ldr	r3, [r7, #0x4]
 80263f6: e9c3 8902    	strd	r8, r9, [r3, #8]
; 		stats->idle_cycles      += tmp_stats.idle_cycles;
 80263fa: 687b         	ldr	r3, [r7, #0x4]
 80263fc: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8026400: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8026404: eb10 0a02    	adds.w	r10, r0, r2
 8026408: eb41 0b03    	adc.w	r11, r1, r3
 802640c: 687b         	ldr	r3, [r7, #0x4]
 802640e: e9c3 ab04    	strd	r10, r11, [r3, #16]
; 	for (uint8_t i = 0; i < num_cpus; i++) {
 8026412: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8026416: 3301         	adds	r3, #0x1
 8026418: f887 303f    	strb.w	r3, [r7, #0x3f]
 802641c: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8026420: 6bba         	ldr	r2, [r7, #0x38]
 8026422: 429a         	cmp	r2, r3
 8026424: d8ca         	bhi	0x80263bc <k_thread_runtime_stats_all_get+0x34> @ imm = #-0x6c
; 	return 0;
 8026426: 2300         	movs	r3, #0x0
; }
 8026428: 4618         	mov	r0, r3
 802642a: 3740         	adds	r7, #0x40
 802642c: 46bd         	mov	sp, r7
 802642e: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08026432 <sys_dlist_init>:
; {
 8026432: b480         	push	{r7}
 8026434: b083         	sub	sp, #0xc
 8026436: af00         	add	r7, sp, #0x0
 8026438: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 802643a: 687b         	ldr	r3, [r7, #0x4]
 802643c: 687a         	ldr	r2, [r7, #0x4]
 802643e: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8026440: 687b         	ldr	r3, [r7, #0x4]
 8026442: 687a         	ldr	r2, [r7, #0x4]
 8026444: 605a         	str	r2, [r3, #0x4]
; }
 8026446: bf00         	nop
 8026448: 370c         	adds	r7, #0xc
 802644a: 46bd         	mov	sp, r7
 802644c: f85d 7b04    	ldr	r7, [sp], #4
 8026450: 4770         	bx	lr

08026452 <sys_dnode_init>:
; {
 8026452: b480         	push	{r7}
 8026454: b083         	sub	sp, #0xc
 8026456: af00         	add	r7, sp, #0x0
 8026458: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 802645a: 687b         	ldr	r3, [r7, #0x4]
 802645c: 2200         	movs	r2, #0x0
 802645e: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8026460: 687b         	ldr	r3, [r7, #0x4]
 8026462: 2200         	movs	r2, #0x0
 8026464: 605a         	str	r2, [r3, #0x4]
; }
 8026466: bf00         	nop
 8026468: 370c         	adds	r7, #0xc
 802646a: 46bd         	mov	sp, r7
 802646c: f85d 7b04    	ldr	r7, [sp], #4
 8026470: 4770         	bx	lr

08026472 <sys_dnode_is_linked>:
; {
 8026472: b480         	push	{r7}
 8026474: b083         	sub	sp, #0xc
 8026476: af00         	add	r7, sp, #0x0
 8026478: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 802647a: 687b         	ldr	r3, [r7, #0x4]
 802647c: 681b         	ldr	r3, [r3]
 802647e: 2b00         	cmp	r3, #0x0
 8026480: bf14         	ite	ne
 8026482: 2301         	movne	r3, #0x1
 8026484: 2300         	moveq	r3, #0x0
 8026486: b2db         	uxtb	r3, r3
; }
 8026488: 4618         	mov	r0, r3
 802648a: 370c         	adds	r7, #0xc
 802648c: 46bd         	mov	sp, r7
 802648e: f85d 7b04    	ldr	r7, [sp], #4
 8026492: 4770         	bx	lr

08026494 <sys_dlist_is_empty>:
; {
 8026494: b480         	push	{r7}
 8026496: b083         	sub	sp, #0xc
 8026498: af00         	add	r7, sp, #0x0
 802649a: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 802649c: 687b         	ldr	r3, [r7, #0x4]
 802649e: 681b         	ldr	r3, [r3]
 80264a0: 687a         	ldr	r2, [r7, #0x4]
 80264a2: 429a         	cmp	r2, r3
 80264a4: bf0c         	ite	eq
 80264a6: 2301         	moveq	r3, #0x1
 80264a8: 2300         	movne	r3, #0x0
 80264aa: b2db         	uxtb	r3, r3
; }
 80264ac: 4618         	mov	r0, r3
 80264ae: 370c         	adds	r7, #0xc
 80264b0: 46bd         	mov	sp, r7
 80264b2: f85d 7b04    	ldr	r7, [sp], #4
 80264b6: 4770         	bx	lr

080264b8 <sys_dlist_peek_head>:
; {
 80264b8: b580         	push	{r7, lr}
 80264ba: b082         	sub	sp, #0x8
 80264bc: af00         	add	r7, sp, #0x0
 80264be: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 80264c0: 6878         	ldr	r0, [r7, #0x4]
 80264c2: f7ff ffe7    	bl	0x8026494 <sys_dlist_is_empty> @ imm = #-0x32
 80264c6: 4603         	mov	r3, r0
 80264c8: 2b00         	cmp	r3, #0x0
 80264ca: d102         	bne	0x80264d2 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 80264cc: 687b         	ldr	r3, [r7, #0x4]
 80264ce: 681b         	ldr	r3, [r3]
 80264d0: e000         	b	0x80264d4 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 80264d2: 2300         	movs	r3, #0x0
; }
 80264d4: 4618         	mov	r0, r3
 80264d6: 3708         	adds	r7, #0x8
 80264d8: 46bd         	mov	sp, r7
 80264da: bd80         	pop	{r7, pc}

080264dc <sys_dlist_peek_next_no_check>:
; {
 80264dc: b480         	push	{r7}
 80264de: b083         	sub	sp, #0xc
 80264e0: af00         	add	r7, sp, #0x0
 80264e2: 6078         	str	r0, [r7, #0x4]
 80264e4: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 80264e6: 687b         	ldr	r3, [r7, #0x4]
 80264e8: 685b         	ldr	r3, [r3, #0x4]
 80264ea: 683a         	ldr	r2, [r7]
 80264ec: 429a         	cmp	r2, r3
 80264ee: d002         	beq	0x80264f6 <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 80264f0: 683b         	ldr	r3, [r7]
 80264f2: 681b         	ldr	r3, [r3]
 80264f4: e000         	b	0x80264f8 <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 80264f6: 2300         	movs	r3, #0x0
; }
 80264f8: 4618         	mov	r0, r3
 80264fa: 370c         	adds	r7, #0xc
 80264fc: 46bd         	mov	sp, r7
 80264fe: f85d 7b04    	ldr	r7, [sp], #4
 8026502: 4770         	bx	lr

08026504 <sys_dlist_peek_next>:
; {
 8026504: b580         	push	{r7, lr}
 8026506: b082         	sub	sp, #0x8
 8026508: af00         	add	r7, sp, #0x0
 802650a: 6078         	str	r0, [r7, #0x4]
 802650c: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 802650e: 683b         	ldr	r3, [r7]
 8026510: 2b00         	cmp	r3, #0x0
 8026512: d005         	beq	0x8026520 <sys_dlist_peek_next+0x1c> @ imm = #0xa
 8026514: 6839         	ldr	r1, [r7]
 8026516: 6878         	ldr	r0, [r7, #0x4]
 8026518: f7ff ffe0    	bl	0x80264dc <sys_dlist_peek_next_no_check> @ imm = #-0x40
 802651c: 4603         	mov	r3, r0
 802651e: e000         	b	0x8026522 <sys_dlist_peek_next+0x1e> @ imm = #0x0
 8026520: 2300         	movs	r3, #0x0
; }
 8026522: 4618         	mov	r0, r3
 8026524: 3708         	adds	r7, #0x8
 8026526: 46bd         	mov	sp, r7
 8026528: bd80         	pop	{r7, pc}

0802652a <sys_dlist_append>:
; {
 802652a: b480         	push	{r7}
 802652c: b085         	sub	sp, #0x14
 802652e: af00         	add	r7, sp, #0x0
 8026530: 6078         	str	r0, [r7, #0x4]
 8026532: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 8026534: 687b         	ldr	r3, [r7, #0x4]
 8026536: 685b         	ldr	r3, [r3, #0x4]
 8026538: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 802653a: 683b         	ldr	r3, [r7]
 802653c: 687a         	ldr	r2, [r7, #0x4]
 802653e: 601a         	str	r2, [r3]
; 	node->prev = tail;
 8026540: 683b         	ldr	r3, [r7]
 8026542: 68fa         	ldr	r2, [r7, #0xc]
 8026544: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 8026546: 68fb         	ldr	r3, [r7, #0xc]
 8026548: 683a         	ldr	r2, [r7]
 802654a: 601a         	str	r2, [r3]
; 	list->tail = node;
 802654c: 687b         	ldr	r3, [r7, #0x4]
 802654e: 683a         	ldr	r2, [r7]
 8026550: 605a         	str	r2, [r3, #0x4]
; }
 8026552: bf00         	nop
 8026554: 3714         	adds	r7, #0x14
 8026556: 46bd         	mov	sp, r7
 8026558: f85d 7b04    	ldr	r7, [sp], #4
 802655c: 4770         	bx	lr

0802655e <sys_dlist_insert>:
; {
 802655e: b480         	push	{r7}
 8026560: b085         	sub	sp, #0x14
 8026562: af00         	add	r7, sp, #0x0
 8026564: 6078         	str	r0, [r7, #0x4]
 8026566: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 8026568: 687b         	ldr	r3, [r7, #0x4]
 802656a: 685b         	ldr	r3, [r3, #0x4]
 802656c: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 802656e: 683b         	ldr	r3, [r7]
 8026570: 68fa         	ldr	r2, [r7, #0xc]
 8026572: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 8026574: 683b         	ldr	r3, [r7]
 8026576: 687a         	ldr	r2, [r7, #0x4]
 8026578: 601a         	str	r2, [r3]
; 	prev->next = node;
 802657a: 68fb         	ldr	r3, [r7, #0xc]
 802657c: 683a         	ldr	r2, [r7]
 802657e: 601a         	str	r2, [r3]
; 	successor->prev = node;
 8026580: 687b         	ldr	r3, [r7, #0x4]
 8026582: 683a         	ldr	r2, [r7]
 8026584: 605a         	str	r2, [r3, #0x4]
; }
 8026586: bf00         	nop
 8026588: 3714         	adds	r7, #0x14
 802658a: 46bd         	mov	sp, r7
 802658c: f85d 7b04    	ldr	r7, [sp], #4
 8026590: 4770         	bx	lr

08026592 <sys_dlist_remove>:
; {
 8026592: b580         	push	{r7, lr}
 8026594: b084         	sub	sp, #0x10
 8026596: af00         	add	r7, sp, #0x0
 8026598: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 802659a: 687b         	ldr	r3, [r7, #0x4]
 802659c: 685b         	ldr	r3, [r3, #0x4]
 802659e: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 80265a0: 687b         	ldr	r3, [r7, #0x4]
 80265a2: 681b         	ldr	r3, [r3]
 80265a4: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 80265a6: 68fb         	ldr	r3, [r7, #0xc]
 80265a8: 68ba         	ldr	r2, [r7, #0x8]
 80265aa: 601a         	str	r2, [r3]
; 	next->prev = prev;
 80265ac: 68bb         	ldr	r3, [r7, #0x8]
 80265ae: 68fa         	ldr	r2, [r7, #0xc]
 80265b0: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 80265b2: 6878         	ldr	r0, [r7, #0x4]
 80265b4: f7ff ff4d    	bl	0x8026452 <sys_dnode_init> @ imm = #-0x166
; }
 80265b8: bf00         	nop
 80265ba: 3710         	adds	r7, #0x10
 80265bc: 46bd         	mov	sp, r7
 80265be: bd80         	pop	{r7, pc}

080265c0 <k_yield>:
; {
 80265c0: b580         	push	{r7, lr}
 80265c2: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 80265c4: f7ef fcc6    	bl	0x8015f54 <z_impl_k_yield> @ imm = #-0x10674
; }
 80265c8: bf00         	nop
 80265ca: bd80         	pop	{r7, pc}

080265cc <k_thread_suspend>:
; {
 80265cc: b580         	push	{r7, lr}
 80265ce: b082         	sub	sp, #0x8
 80265d0: af00         	add	r7, sp, #0x0
 80265d2: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_suspend(thread);
 80265d4: 6878         	ldr	r0, [r7, #0x4]
 80265d6: f7ee feb3    	bl	0x8015340 <z_impl_k_thread_suspend> @ imm = #-0x1129a
; }
 80265da: bf00         	nop
 80265dc: 3708         	adds	r7, #0x8
 80265de: 46bd         	mov	sp, r7
 80265e0: bd80         	pop	{r7, pc}

080265e2 <z_is_inactive_timeout>:
; {
 80265e2: b580         	push	{r7, lr}
 80265e4: b082         	sub	sp, #0x8
 80265e6: af00         	add	r7, sp, #0x0
 80265e8: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 80265ea: 687b         	ldr	r3, [r7, #0x4]
 80265ec: 4618         	mov	r0, r3
 80265ee: f7ff ff40    	bl	0x8026472 <sys_dnode_is_linked> @ imm = #-0x180
 80265f2: 4603         	mov	r3, r0
 80265f4: 2b00         	cmp	r3, #0x0
 80265f6: bf14         	ite	ne
 80265f8: 2301         	movne	r3, #0x1
 80265fa: 2300         	moveq	r3, #0x0
 80265fc: b2db         	uxtb	r3, r3
 80265fe: f083 0301    	eor	r3, r3, #0x1
 8026602: b2db         	uxtb	r3, r3
 8026604: f003 0301    	and	r3, r3, #0x1
 8026608: b2db         	uxtb	r3, r3
; }
 802660a: 4618         	mov	r0, r3
 802660c: 3708         	adds	r7, #0x8
 802660e: 46bd         	mov	sp, r7
 8026610: bd80         	pop	{r7, pc}

08026612 <z_abort_thread_timeout>:
; {
 8026612: b580         	push	{r7, lr}
 8026614: b082         	sub	sp, #0x8
 8026616: af00         	add	r7, sp, #0x0
 8026618: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 802661a: 687b         	ldr	r3, [r7, #0x4]
 802661c: 3318         	adds	r3, #0x18
 802661e: 4618         	mov	r0, r3
 8026620: f7f0 fbf0    	bl	0x8016e04 <z_abort_timeout> @ imm = #-0xf820
 8026624: 4603         	mov	r3, r0
; }
 8026626: 4618         	mov	r0, r3
 8026628: 3708         	adds	r7, #0x8
 802662a: 46bd         	mov	sp, r7
 802662c: bd80         	pop	{r7, pc}

0802662e <thread_is_preemptible>:
; {
 802662e: b480         	push	{r7}
 8026630: b083         	sub	sp, #0xc
 8026632: af00         	add	r7, sp, #0x0
 8026634: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 8026636: 687b         	ldr	r3, [r7, #0x4]
 8026638: 89db         	ldrh	r3, [r3, #0xe]
 802663a: 2b7f         	cmp	r3, #0x7f
 802663c: bf94         	ite	ls
 802663e: 2301         	movls	r3, #0x1
 8026640: 2300         	movhi	r3, #0x0
 8026642: b2db         	uxtb	r3, r3
; }
 8026644: 4618         	mov	r0, r3
 8026646: 370c         	adds	r7, #0xc
 8026648: 46bd         	mov	sp, r7
 802664a: f85d 7b04    	ldr	r7, [sp], #4
 802664e: 4770         	bx	lr

08026650 <thread_is_metairq>:
; {
 8026650: b480         	push	{r7}
 8026652: b083         	sub	sp, #0xc
 8026654: af00         	add	r7, sp, #0x0
 8026656: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8026658: 2300         	movs	r3, #0x0
; }
 802665a: 4618         	mov	r0, r3
 802665c: 370c         	adds	r7, #0xc
 802665e: 46bd         	mov	sp, r7
 8026660: f85d 7b04    	ldr	r7, [sp], #4
 8026664: 4770         	bx	lr

08026666 <z_is_thread_suspended>:
; {
 8026666: b480         	push	{r7}
 8026668: b083         	sub	sp, #0xc
 802666a: af00         	add	r7, sp, #0x0
 802666c: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_SUSPENDED) != 0U;
 802666e: 687b         	ldr	r3, [r7, #0x4]
 8026670: 7b5b         	ldrb	r3, [r3, #0xd]
 8026672: f003 0310    	and	r3, r3, #0x10
 8026676: 2b00         	cmp	r3, #0x0
 8026678: bf14         	ite	ne
 802667a: 2301         	movne	r3, #0x1
 802667c: 2300         	moveq	r3, #0x0
 802667e: b2db         	uxtb	r3, r3
; }
 8026680: 4618         	mov	r0, r3
 8026682: 370c         	adds	r7, #0xc
 8026684: 46bd         	mov	sp, r7
 8026686: f85d 7b04    	ldr	r7, [sp], #4
 802668a: 4770         	bx	lr

0802668c <z_is_thread_prevented_from_running>:
; {
 802668c: b480         	push	{r7}
 802668e: b085         	sub	sp, #0x14
 8026690: af00         	add	r7, sp, #0x0
 8026692: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8026694: 687b         	ldr	r3, [r7, #0x4]
 8026696: 7b5b         	ldrb	r3, [r3, #0xd]
 8026698: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 802669a: 7bfb         	ldrb	r3, [r7, #0xf]
 802669c: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 80266a0: 2b00         	cmp	r3, #0x0
 80266a2: bf14         	ite	ne
 80266a4: 2301         	movne	r3, #0x1
 80266a6: 2300         	moveq	r3, #0x0
 80266a8: b2db         	uxtb	r3, r3
; }
 80266aa: 4618         	mov	r0, r3
 80266ac: 3714         	adds	r7, #0x14
 80266ae: 46bd         	mov	sp, r7
 80266b0: f85d 7b04    	ldr	r7, [sp], #4
 80266b4: 4770         	bx	lr

080266b6 <z_is_thread_timeout_active>:
; {
 80266b6: b580         	push	{r7, lr}
 80266b8: b082         	sub	sp, #0x8
 80266ba: af00         	add	r7, sp, #0x0
 80266bc: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 80266be: 687b         	ldr	r3, [r7, #0x4]
 80266c0: 3318         	adds	r3, #0x18
 80266c2: 4618         	mov	r0, r3
 80266c4: f7ff ff8d    	bl	0x80265e2 <z_is_inactive_timeout> @ imm = #-0xe6
 80266c8: 4603         	mov	r3, r0
 80266ca: 2b00         	cmp	r3, #0x0
 80266cc: bf14         	ite	ne
 80266ce: 2301         	movne	r3, #0x1
 80266d0: 2300         	moveq	r3, #0x0
 80266d2: b2db         	uxtb	r3, r3
 80266d4: f083 0301    	eor	r3, r3, #0x1
 80266d8: b2db         	uxtb	r3, r3
 80266da: f003 0301    	and	r3, r3, #0x1
 80266de: b2db         	uxtb	r3, r3
; }
 80266e0: 4618         	mov	r0, r3
 80266e2: 3708         	adds	r7, #0x8
 80266e4: 46bd         	mov	sp, r7
 80266e6: bd80         	pop	{r7, pc}

080266e8 <z_is_thread_ready>:
; {
 80266e8: b580         	push	{r7, lr}
 80266ea: b082         	sub	sp, #0x8
 80266ec: af00         	add	r7, sp, #0x0
 80266ee: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 80266f0: 6878         	ldr	r0, [r7, #0x4]
 80266f2: f7ff ffcb    	bl	0x802668c <z_is_thread_prevented_from_running> @ imm = #-0x6a
 80266f6: 4603         	mov	r3, r0
 80266f8: f083 0301    	eor	r3, r3, #0x1
 80266fc: b2db         	uxtb	r3, r3
 80266fe: 2b00         	cmp	r3, #0x0
 8026700: d00a         	beq	0x8026718 <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 8026702: 6878         	ldr	r0, [r7, #0x4]
 8026704: f7ff ffd7    	bl	0x80266b6 <z_is_thread_timeout_active> @ imm = #-0x52
 8026708: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 802670a: f083 0301    	eor	r3, r3, #0x1
 802670e: b2db         	uxtb	r3, r3
 8026710: 2b00         	cmp	r3, #0x0
 8026712: d001         	beq	0x8026718 <z_is_thread_ready+0x30> @ imm = #0x2
 8026714: 2301         	movs	r3, #0x1
 8026716: e000         	b	0x802671a <z_is_thread_ready+0x32> @ imm = #0x0
 8026718: 2300         	movs	r3, #0x0
 802671a: f003 0301    	and	r3, r3, #0x1
 802671e: b2db         	uxtb	r3, r3
; }
 8026720: 4618         	mov	r0, r3
 8026722: 3708         	adds	r7, #0x8
 8026724: 46bd         	mov	sp, r7
 8026726: bd80         	pop	{r7, pc}

08026728 <z_is_thread_state_set>:
; {
 8026728: b480         	push	{r7}
 802672a: b083         	sub	sp, #0xc
 802672c: af00         	add	r7, sp, #0x0
 802672e: 6078         	str	r0, [r7, #0x4]
 8026730: 6039         	str	r1, [r7]
; 	return (thread->base.thread_state & state) != 0U;
 8026732: 687b         	ldr	r3, [r7, #0x4]
 8026734: 7b5b         	ldrb	r3, [r3, #0xd]
 8026736: 461a         	mov	r2, r3
 8026738: 683b         	ldr	r3, [r7]
 802673a: 4013         	ands	r3, r2
 802673c: 2b00         	cmp	r3, #0x0
 802673e: bf14         	ite	ne
 8026740: 2301         	movne	r3, #0x1
 8026742: 2300         	moveq	r3, #0x0
 8026744: b2db         	uxtb	r3, r3
; }
 8026746: 4618         	mov	r0, r3
 8026748: 370c         	adds	r7, #0xc
 802674a: 46bd         	mov	sp, r7
 802674c: f85d 7b04    	ldr	r7, [sp], #4
 8026750: 4770         	bx	lr

08026752 <z_is_thread_queued>:
; {
 8026752: b580         	push	{r7, lr}
 8026754: b082         	sub	sp, #0x8
 8026756: af00         	add	r7, sp, #0x0
 8026758: 6078         	str	r0, [r7, #0x4]
; 	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 802675a: 2180         	movs	r1, #0x80
 802675c: 6878         	ldr	r0, [r7, #0x4]
 802675e: f7ff ffe3    	bl	0x8026728 <z_is_thread_state_set> @ imm = #-0x3a
 8026762: 4603         	mov	r3, r0
; }
 8026764: 4618         	mov	r0, r3
 8026766: 3708         	adds	r7, #0x8
 8026768: 46bd         	mov	sp, r7
 802676a: bd80         	pop	{r7, pc}

0802676c <z_mark_thread_as_suspended>:
; {
 802676c: b480         	push	{r7}
 802676e: b083         	sub	sp, #0xc
 8026770: af00         	add	r7, sp, #0x0
 8026772: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_SUSPENDED;
 8026774: 687b         	ldr	r3, [r7, #0x4]
 8026776: 7b5b         	ldrb	r3, [r3, #0xd]
 8026778: f043 0310    	orr	r3, r3, #0x10
 802677c: b2da         	uxtb	r2, r3
 802677e: 687b         	ldr	r3, [r7, #0x4]
 8026780: 735a         	strb	r2, [r3, #0xd]
; }
 8026782: bf00         	nop
 8026784: 370c         	adds	r7, #0xc
 8026786: 46bd         	mov	sp, r7
 8026788: f85d 7b04    	ldr	r7, [sp], #4
 802678c: 4770         	bx	lr

0802678e <z_mark_thread_as_not_suspended>:
; {
 802678e: b480         	push	{r7}
 8026790: b083         	sub	sp, #0xc
 8026792: af00         	add	r7, sp, #0x0
 8026794: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 8026796: 687b         	ldr	r3, [r7, #0x4]
 8026798: 7b5b         	ldrb	r3, [r3, #0xd]
 802679a: f023 0310    	bic	r3, r3, #0x10
 802679e: b2da         	uxtb	r2, r3
 80267a0: 687b         	ldr	r3, [r7, #0x4]
 80267a2: 735a         	strb	r2, [r3, #0xd]
; }
 80267a4: bf00         	nop
 80267a6: 370c         	adds	r7, #0xc
 80267a8: 46bd         	mov	sp, r7
 80267aa: f85d 7b04    	ldr	r7, [sp], #4
 80267ae: 4770         	bx	lr

080267b0 <z_mark_thread_as_pending>:
; {
 80267b0: b480         	push	{r7}
 80267b2: b083         	sub	sp, #0xc
 80267b4: af00         	add	r7, sp, #0x0
 80267b6: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_PENDING;
 80267b8: 687b         	ldr	r3, [r7, #0x4]
 80267ba: 7b5b         	ldrb	r3, [r3, #0xd]
 80267bc: f043 0302    	orr	r3, r3, #0x2
 80267c0: b2da         	uxtb	r2, r3
 80267c2: 687b         	ldr	r3, [r7, #0x4]
 80267c4: 735a         	strb	r2, [r3, #0xd]
; }
 80267c6: bf00         	nop
 80267c8: 370c         	adds	r7, #0xc
 80267ca: 46bd         	mov	sp, r7
 80267cc: f85d 7b04    	ldr	r7, [sp], #4
 80267d0: 4770         	bx	lr

080267d2 <z_mark_thread_as_not_pending>:
; {
 80267d2: b480         	push	{r7}
 80267d4: b083         	sub	sp, #0xc
 80267d6: af00         	add	r7, sp, #0x0
 80267d8: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 80267da: 687b         	ldr	r3, [r7, #0x4]
 80267dc: 7b5b         	ldrb	r3, [r3, #0xd]
 80267de: f023 0302    	bic	r3, r3, #0x2
 80267e2: b2da         	uxtb	r2, r3
 80267e4: 687b         	ldr	r3, [r7, #0x4]
 80267e6: 735a         	strb	r2, [r3, #0xd]
; }
 80267e8: bf00         	nop
 80267ea: 370c         	adds	r7, #0xc
 80267ec: 46bd         	mov	sp, r7
 80267ee: f85d 7b04    	ldr	r7, [sp], #4
 80267f2: 4770         	bx	lr

080267f4 <z_is_thread_essential>:
; {
 80267f4: b480         	push	{r7}
 80267f6: b083         	sub	sp, #0xc
 80267f8: af00         	add	r7, sp, #0x0
 80267fa: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
 80267fc: 687b         	ldr	r3, [r7, #0x4]
 80267fe: 7b1b         	ldrb	r3, [r3, #0xc]
 8026800: f003 0301    	and	r3, r3, #0x1
 8026804: 2b00         	cmp	r3, #0x0
 8026806: bf14         	ite	ne
 8026808: 2301         	movne	r3, #0x1
 802680a: 2300         	moveq	r3, #0x0
 802680c: b2db         	uxtb	r3, r3
; }
 802680e: 4618         	mov	r0, r3
 8026810: 370c         	adds	r7, #0xc
 8026812: 46bd         	mov	sp, r7
 8026814: f85d 7b04    	ldr	r7, [sp], #4
 8026818: 4770         	bx	lr

0802681a <z_reschedule_unlocked>:
; {
 802681a: b580         	push	{r7, lr}
 802681c: b084         	sub	sp, #0x10
 802681e: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8026820: f3ef 8311    	mrs	r3, basepri
 8026824: 60fb         	str	r3, [r7, #0xc]
;   return(result);
 8026826: 68fb         	ldr	r3, [r7, #0xc]
; 	key = __get_BASEPRI();
 8026828: 60bb         	str	r3, [r7, #0x8]
 802682a: 2310         	movs	r3, #0x10
 802682c: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 802682e: 687b         	ldr	r3, [r7, #0x4]
 8026830: f383 8812    	msr	basepri_max, r3
; }
 8026834: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8026836: f3bf 8f6f    	isb	sy
; }
 802683a: bf00         	nop
; 	return key;
 802683c: 68bb         	ldr	r3, [r7, #0x8]
; 	(void) z_reschedule_irqlock(arch_irq_lock());
 802683e: 4618         	mov	r0, r3
 8026840: f000 f9c6    	bl	0x8026bd0 <z_reschedule_irqlock> @ imm = #0x38c
; }
 8026844: bf00         	nop
 8026846: 3710         	adds	r7, #0x10
 8026848: 46bd         	mov	sp, r7
 802684a: bd80         	pop	{r7, pc}

0802684c <unpend_thread_no_timeout>:
; {
 802684c: b580         	push	{r7, lr}
 802684e: b086         	sub	sp, #0x18
 8026850: af00         	add	r7, sp, #0x0
 8026852: 6078         	str	r0, [r7, #0x4]
 8026854: 687b         	ldr	r3, [r7, #0x4]
 8026856: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8026858: 68fb         	ldr	r3, [r7, #0xc]
 802685a: 689b         	ldr	r3, [r3, #0x8]
 802685c: 617b         	str	r3, [r7, #0x14]
 802685e: 687b         	ldr	r3, [r7, #0x4]
 8026860: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8026862: 693b         	ldr	r3, [r7, #0x10]
 8026864: 4618         	mov	r0, r3
 8026866: f7ff fe94    	bl	0x8026592 <sys_dlist_remove> @ imm = #-0x2d8
; }
 802686a: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 802686c: 6878         	ldr	r0, [r7, #0x4]
 802686e: f7ff ffb0    	bl	0x80267d2 <z_mark_thread_as_not_pending> @ imm = #-0xa0
; 	thread->base.pended_on = NULL;
 8026872: 687b         	ldr	r3, [r7, #0x4]
 8026874: 2200         	movs	r2, #0x0
 8026876: 609a         	str	r2, [r3, #0x8]
; }
 8026878: bf00         	nop
 802687a: 3718         	adds	r7, #0x18
 802687c: 46bd         	mov	sp, r7
 802687e: bd80         	pop	{r7, pc}

08026880 <z_waitq_head>:
; {
 8026880: b580         	push	{r7, lr}
 8026882: b082         	sub	sp, #0x8
 8026884: af00         	add	r7, sp, #0x0
 8026886: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 8026888: 687b         	ldr	r3, [r7, #0x4]
 802688a: 4618         	mov	r0, r3
 802688c: f7ff fe14    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #-0x3d8
 8026890: 4603         	mov	r3, r0
; }
 8026892: 4618         	mov	r0, r3
 8026894: 3708         	adds	r7, #0x8
 8026896: 46bd         	mov	sp, r7
 8026898: bd80         	pop	{r7, pc}

0802689a <z_swap_irqlock>:
; {
 802689a: b580         	push	{r7, lr}
 802689c: b084         	sub	sp, #0x10
 802689e: af00         	add	r7, sp, #0x0
 80268a0: 6078         	str	r0, [r7, #0x4]
; 	ret = arch_swap(key);
 80268a2: 6878         	ldr	r0, [r7, #0x4]
 80268a4: f7df fda2    	bl	0x80063ec <arch_swap>   @ imm = #-0x204bc
 80268a8: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 80268aa: 68fb         	ldr	r3, [r7, #0xc]
; }
 80268ac: 4618         	mov	r0, r3
 80268ae: 3710         	adds	r7, #0x10
 80268b0: 46bd         	mov	sp, r7
 80268b2: bd80         	pop	{r7, pc}

080268b4 <z_log_msg_runtime_create>:
; {
 80268b4: b580         	push	{r7, lr}
 80268b6: b08a         	sub	sp, #0x28
 80268b8: af04         	add	r7, sp, #0x10
 80268ba: 60b9         	str	r1, [r7, #0x8]
 80268bc: 607b         	str	r3, [r7, #0x4]
 80268be: 4603         	mov	r3, r0
 80268c0: 73fb         	strb	r3, [r7, #0xf]
 80268c2: 4613         	mov	r3, r2
 80268c4: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80268c6: f107 032c    	add.w	r3, r7, #0x2c
 80268ca: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80268cc: 7bba         	ldrb	r2, [r7, #0xe]
 80268ce: 7bf8         	ldrb	r0, [r7, #0xf]
 80268d0: 697b         	ldr	r3, [r7, #0x14]
 80268d2: 9303         	str	r3, [sp, #0xc]
 80268d4: 6abb         	ldr	r3, [r7, #0x28]
 80268d6: 9302         	str	r3, [sp, #0x8]
 80268d8: 6a7b         	ldr	r3, [r7, #0x24]
 80268da: 9301         	str	r3, [sp, #0x4]
 80268dc: 6a3b         	ldr	r3, [r7, #0x20]
 80268de: 9300         	str	r3, [sp]
 80268e0: 687b         	ldr	r3, [r7, #0x4]
 80268e2: 68b9         	ldr	r1, [r7, #0x8]
 80268e4: f7de f92e    	bl	0x8004b44 <z_log_msg_runtime_vcreate> @ imm = #-0x21da4
; }
 80268e8: bf00         	nop
 80268ea: 3718         	adds	r7, #0x18
 80268ec: 46bd         	mov	sp, r7
 80268ee: bd80         	pop	{r7, pc}

080268f0 <z_sched_prio_cmp>:
; {
 80268f0: b480         	push	{r7}
 80268f2: b085         	sub	sp, #0x14
 80268f4: af00         	add	r7, sp, #0x0
 80268f6: 6078         	str	r0, [r7, #0x4]
 80268f8: 6039         	str	r1, [r7]
; 	int32_t b1 = thread_1->base.prio;
 80268fa: 687b         	ldr	r3, [r7, #0x4]
 80268fc: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8026900: 60fb         	str	r3, [r7, #0xc]
; 	int32_t b2 = thread_2->base.prio;
 8026902: 683b         	ldr	r3, [r7]
 8026904: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8026908: 60bb         	str	r3, [r7, #0x8]
; 	if (b1 != b2) {
 802690a: 68fa         	ldr	r2, [r7, #0xc]
 802690c: 68bb         	ldr	r3, [r7, #0x8]
 802690e: 429a         	cmp	r2, r3
 8026910: d003         	beq	0x802691a <z_sched_prio_cmp+0x2a> @ imm = #0x6
; 		return b2 - b1;
 8026912: 68ba         	ldr	r2, [r7, #0x8]
 8026914: 68fb         	ldr	r3, [r7, #0xc]
 8026916: 1ad3         	subs	r3, r2, r3
 8026918: e000         	b	0x802691c <z_sched_prio_cmp+0x2c> @ imm = #0x0
; 	return 0;
 802691a: 2300         	movs	r3, #0x0
; }
 802691c: 4618         	mov	r0, r3
 802691e: 3714         	adds	r7, #0x14
 8026920: 46bd         	mov	sp, r7
 8026922: f85d 7b04    	ldr	r7, [sp], #4
 8026926: 4770         	bx	lr

08026928 <should_queue_thread>:
; {
 8026928: b480         	push	{r7}
 802692a: b083         	sub	sp, #0xc
 802692c: af00         	add	r7, sp, #0x0
 802692e: 6078         	str	r0, [r7, #0x4]
; 	return !IS_ENABLED(CONFIG_SMP) || (thread != arch_current_thread());
 8026930: 2301         	movs	r3, #0x1
; }
 8026932: 4618         	mov	r0, r3
 8026934: 370c         	adds	r7, #0xc
 8026936: 46bd         	mov	sp, r7
 8026938: f85d 7b04    	ldr	r7, [sp], #4
 802693c: 4770         	bx	lr

0802693e <is_aborting>:
; {
 802693e: b480         	push	{r7}
 8026940: b083         	sub	sp, #0xc
 8026942: af00         	add	r7, sp, #0x0
 8026944: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_ABORTING) != 0U;
 8026946: 687b         	ldr	r3, [r7, #0x4]
 8026948: 7b5b         	ldrb	r3, [r3, #0xd]
 802694a: f003 0320    	and	r3, r3, #0x20
 802694e: 2b00         	cmp	r3, #0x0
 8026950: bf14         	ite	ne
 8026952: 2301         	movne	r3, #0x1
 8026954: 2300         	moveq	r3, #0x0
 8026956: b2db         	uxtb	r3, r3
; }
 8026958: 4618         	mov	r0, r3
 802695a: 370c         	adds	r7, #0xc
 802695c: 46bd         	mov	sp, r7
 802695e: f85d 7b04    	ldr	r7, [sp], #4
 8026962: 4770         	bx	lr

08026964 <is_halting>:
; {
 8026964: b480         	push	{r7}
 8026966: b083         	sub	sp, #0xc
 8026968: af00         	add	r7, sp, #0x0
 802696a: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state &
 802696c: 687b         	ldr	r3, [r7, #0x4]
 802696e: 7b5b         	ldrb	r3, [r3, #0xd]
 8026970: f003 0360    	and	r3, r3, #0x60
; 		(_THREAD_ABORTING | _THREAD_SUSPENDING)) != 0U;
 8026974: 2b00         	cmp	r3, #0x0
 8026976: bf14         	ite	ne
 8026978: 2301         	movne	r3, #0x1
 802697a: 2300         	moveq	r3, #0x0
 802697c: b2db         	uxtb	r3, r3
; }
 802697e: 4618         	mov	r0, r3
 8026980: 370c         	adds	r7, #0xc
 8026982: 46bd         	mov	sp, r7
 8026984: f85d 7b04    	ldr	r7, [sp], #4
 8026988: 4770         	bx	lr

0802698a <clear_halting>:
; {
 802698a: b480         	push	{r7}
 802698c: b083         	sub	sp, #0xc
 802698e: af00         	add	r7, sp, #0x0
 8026990: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("dmb 0xF":::"memory");
 8026992: f3bf 8f5f    	dmb	sy
; }
 8026996: bf00         	nop
; }
 8026998: bf00         	nop
; }
 802699a: bf00         	nop
; 	thread->base.thread_state &= ~(_THREAD_ABORTING | _THREAD_SUSPENDING);
 802699c: 687b         	ldr	r3, [r7, #0x4]
 802699e: 7b5b         	ldrb	r3, [r3, #0xd]
 80269a0: f023 0360    	bic	r3, r3, #0x60
 80269a4: b2da         	uxtb	r2, r3
 80269a6: 687b         	ldr	r3, [r7, #0x4]
 80269a8: 735a         	strb	r2, [r3, #0xd]
; }
 80269aa: bf00         	nop
 80269ac: 370c         	adds	r7, #0xc
 80269ae: 46bd         	mov	sp, r7
 80269b0: f85d 7b04    	ldr	r7, [sp], #4
 80269b4: 4770         	bx	lr

080269b6 <update_metairq_preempt>:
; {
 80269b6: b480         	push	{r7}
 80269b8: b083         	sub	sp, #0xc
 80269ba: af00         	add	r7, sp, #0x0
 80269bc: 6078         	str	r0, [r7, #0x4]
; }
 80269be: bf00         	nop
 80269c0: 370c         	adds	r7, #0xc
 80269c2: 46bd         	mov	sp, r7
 80269c4: f85d 7b04    	ldr	r7, [sp], #4
 80269c8: 4770         	bx	lr

080269ca <thread_active_elsewhere>:
; {
 80269ca: b480         	push	{r7}
 80269cc: b083         	sub	sp, #0xc
 80269ce: af00         	add	r7, sp, #0x0
 80269d0: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 80269d2: 2300         	movs	r3, #0x0
; }
 80269d4: 4618         	mov	r0, r3
 80269d6: 370c         	adds	r7, #0xc
 80269d8: 46bd         	mov	sp, r7
 80269da: f85d 7b04    	ldr	r7, [sp], #4
 80269de: 4770         	bx	lr

080269e0 <add_to_waitq_locked>:
; {
 80269e0: b580         	push	{r7, lr}
 80269e2: b086         	sub	sp, #0x18
 80269e4: af00         	add	r7, sp, #0x0
 80269e6: 6078         	str	r0, [r7, #0x4]
 80269e8: 6039         	str	r1, [r7]
; 	unready_thread(thread);
 80269ea: 6878         	ldr	r0, [r7, #0x4]
 80269ec: f7ee fe18    	bl	0x8015620 <unready_thread> @ imm = #-0x113d0
; 	z_mark_thread_as_pending(thread);
 80269f0: 6878         	ldr	r0, [r7, #0x4]
 80269f2: f7ff fedd    	bl	0x80267b0 <z_mark_thread_as_pending> @ imm = #-0x246
; 	if (wait_q != NULL) {
 80269f6: 683b         	ldr	r3, [r7]
 80269f8: 2b00         	cmp	r3, #0x0
 80269fa: d041         	beq	0x8026a80 <add_to_waitq_locked+0xa0> @ imm = #0x82
; 		thread->base.pended_on = wait_q;
 80269fc: 687b         	ldr	r3, [r7, #0x4]
 80269fe: 683a         	ldr	r2, [r7]
 8026a00: 609a         	str	r2, [r3, #0x8]
; 		_priq_wait_add(&wait_q->waitq, thread);
 8026a02: 683b         	ldr	r3, [r7]
 8026a04: 617b         	str	r3, [r7, #0x14]
 8026a06: 687b         	ldr	r3, [r7, #0x4]
 8026a08: 613b         	str	r3, [r7, #0x10]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8026a0a: 6978         	ldr	r0, [r7, #0x14]
 8026a0c: f7ff fd54    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #-0x558
 8026a10: 4603         	mov	r3, r0
 8026a12: 2b00         	cmp	r3, #0x0
 8026a14: d004         	beq	0x8026a20 <add_to_waitq_locked+0x40> @ imm = #0x8
 8026a16: 6978         	ldr	r0, [r7, #0x14]
 8026a18: f7ff fd4e    	bl	0x80264b8 <sys_dlist_peek_head> @ imm = #-0x564
 8026a1c: 4603         	mov	r3, r0
 8026a1e: e000         	b	0x8026a22 <add_to_waitq_locked+0x42> @ imm = #0x0
 8026a20: 2300         	movs	r3, #0x0
 8026a22: 60fb         	str	r3, [r7, #0xc]
 8026a24: e024         	b	0x8026a70 <add_to_waitq_locked+0x90> @ imm = #0x48
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8026a26: 68f9         	ldr	r1, [r7, #0xc]
 8026a28: 6938         	ldr	r0, [r7, #0x10]
 8026a2a: f7ff ff61    	bl	0x80268f0 <z_sched_prio_cmp> @ imm = #-0x13e
 8026a2e: 4603         	mov	r3, r0
 8026a30: 2b00         	cmp	r3, #0x0
 8026a32: dd07         	ble	0x8026a44 <add_to_waitq_locked+0x64> @ imm = #0xe
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8026a34: 68fb         	ldr	r3, [r7, #0xc]
 8026a36: 693a         	ldr	r2, [r7, #0x10]
 8026a38: 4611         	mov	r1, r2
 8026a3a: 4618         	mov	r0, r3
 8026a3c: f7ff fd8f    	bl	0x802655e <sys_dlist_insert> @ imm = #-0x4e2
; 			return;
 8026a40: bf00         	nop
; }
 8026a42: e01d         	b	0x8026a80 <add_to_waitq_locked+0xa0> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8026a44: 68fb         	ldr	r3, [r7, #0xc]
 8026a46: 2b00         	cmp	r3, #0x0
 8026a48: d010         	beq	0x8026a6c <add_to_waitq_locked+0x8c> @ imm = #0x20
 8026a4a: 68fb         	ldr	r3, [r7, #0xc]
 8026a4c: 4619         	mov	r1, r3
 8026a4e: 6978         	ldr	r0, [r7, #0x14]
 8026a50: f7ff fd58    	bl	0x8026504 <sys_dlist_peek_next> @ imm = #-0x550
 8026a54: 4603         	mov	r3, r0
 8026a56: 2b00         	cmp	r3, #0x0
 8026a58: d006         	beq	0x8026a68 <add_to_waitq_locked+0x88> @ imm = #0xc
 8026a5a: 68fb         	ldr	r3, [r7, #0xc]
 8026a5c: 4619         	mov	r1, r3
 8026a5e: 6978         	ldr	r0, [r7, #0x14]
 8026a60: f7ff fd50    	bl	0x8026504 <sys_dlist_peek_next> @ imm = #-0x560
 8026a64: 4603         	mov	r3, r0
 8026a66: e002         	b	0x8026a6e <add_to_waitq_locked+0x8e> @ imm = #0x4
 8026a68: 2300         	movs	r3, #0x0
 8026a6a: e000         	b	0x8026a6e <add_to_waitq_locked+0x8e> @ imm = #0x0
 8026a6c: 2300         	movs	r3, #0x0
 8026a6e: 60fb         	str	r3, [r7, #0xc]
 8026a70: 68fb         	ldr	r3, [r7, #0xc]
 8026a72: 2b00         	cmp	r3, #0x0
 8026a74: d1d7         	bne	0x8026a26 <add_to_waitq_locked+0x46> @ imm = #-0x52
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8026a76: 693b         	ldr	r3, [r7, #0x10]
 8026a78: 4619         	mov	r1, r3
 8026a7a: 6978         	ldr	r0, [r7, #0x14]
 8026a7c: f7ff fd55    	bl	0x802652a <sys_dlist_append> @ imm = #-0x556
; }
 8026a80: bf00         	nop
 8026a82: 3718         	adds	r7, #0x18
 8026a84: 46bd         	mov	sp, r7
 8026a86: bd80         	pop	{r7, pc}

08026a88 <add_thread_timeout>:
; {
 8026a88: b580         	push	{r7, lr}
 8026a8a: b084         	sub	sp, #0x10
 8026a8c: af00         	add	r7, sp, #0x0
 8026a8e: 60f8         	str	r0, [r7, #0xc]
 8026a90: e9c7 2300    	strd	r2, r3, [r7]
; 	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8026a94: e9d7 2300    	ldrd	r2, r3, [r7]
 8026a98: f04f 30ff    	mov.w	r0, #0xffffffff
 8026a9c: f04f 31ff    	mov.w	r1, #0xffffffff
 8026aa0: 428b         	cmp	r3, r1
 8026aa2: bf08         	it	eq
 8026aa4: 4282         	cmpeq	r2, r0
 8026aa6: d004         	beq	0x8026ab2 <add_thread_timeout+0x2a> @ imm = #0x8
; 		z_add_thread_timeout(thread, timeout);
 8026aa8: e9d7 2300    	ldrd	r2, r3, [r7]
 8026aac: 68f8         	ldr	r0, [r7, #0xc]
 8026aae: f7ee f907    	bl	0x8014cc0 <z_add_thread_timeout> @ imm = #-0x11df2
; }
 8026ab2: bf00         	nop
 8026ab4: 3710         	adds	r7, #0x10
 8026ab6: 46bd         	mov	sp, r7
 8026ab8: bd80         	pop	{r7, pc}

08026aba <pend_locked>:
; {
 8026aba: b580         	push	{r7, lr}
 8026abc: b084         	sub	sp, #0x10
 8026abe: af00         	add	r7, sp, #0x0
 8026ac0: 60f8         	str	r0, [r7, #0xc]
 8026ac2: 60b9         	str	r1, [r7, #0x8]
 8026ac4: e9c7 2300    	strd	r2, r3, [r7]
; 	add_to_waitq_locked(thread, wait_q);
 8026ac8: 68b9         	ldr	r1, [r7, #0x8]
 8026aca: 68f8         	ldr	r0, [r7, #0xc]
 8026acc: f7ff ff88    	bl	0x80269e0 <add_to_waitq_locked> @ imm = #-0xf0
; 	add_thread_timeout(thread, timeout);
 8026ad0: e9d7 2300    	ldrd	r2, r3, [r7]
 8026ad4: 68f8         	ldr	r0, [r7, #0xc]
 8026ad6: f7ff ffd7    	bl	0x8026a88 <add_thread_timeout> @ imm = #-0x52
; }
 8026ada: bf00         	nop
 8026adc: 3710         	adds	r7, #0x10
 8026ade: 46bd         	mov	sp, r7
 8026ae0: bd80         	pop	{r7, pc}

08026ae2 <z_thread_timeout>:
; {
 8026ae2: b580         	push	{r7, lr}
 8026ae4: b084         	sub	sp, #0x10
 8026ae6: af00         	add	r7, sp, #0x0
 8026ae8: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = CONTAINER_OF(timeout,
 8026aea: 687b         	ldr	r3, [r7, #0x4]
 8026aec: 3b18         	subs	r3, #0x18
 8026aee: 60fb         	str	r3, [r7, #0xc]
; 	z_sched_wake_thread(thread, true);
 8026af0: 2101         	movs	r1, #0x1
 8026af2: 68f8         	ldr	r0, [r7, #0xc]
 8026af4: f7ee fe78    	bl	0x80157e8 <z_sched_wake_thread> @ imm = #-0x11310
; }
 8026af8: bf00         	nop
 8026afa: 3710         	adds	r7, #0x10
 8026afc: 46bd         	mov	sp, r7
 8026afe: bd80         	pop	{r7, pc}

08026b00 <z_unpend_thread>:
; {
 8026b00: b580         	push	{r7, lr}
 8026b02: b082         	sub	sp, #0x8
 8026b04: af00         	add	r7, sp, #0x0
 8026b06: 6078         	str	r0, [r7, #0x4]
; 	z_unpend_thread_no_timeout(thread);
 8026b08: 6878         	ldr	r0, [r7, #0x4]
 8026b0a: f7ee fe27    	bl	0x801575c <z_unpend_thread_no_timeout> @ imm = #-0x113b2
; 	(void)z_abort_thread_timeout(thread);
 8026b0e: 6878         	ldr	r0, [r7, #0x4]
 8026b10: f7ff fd7f    	bl	0x8026612 <z_abort_thread_timeout> @ imm = #-0x502
; }
 8026b14: bf00         	nop
 8026b16: 3708         	adds	r7, #0x8
 8026b18: 46bd         	mov	sp, r7
 8026b1a: bd80         	pop	{r7, pc}

08026b1c <resched>:
; {
 8026b1c: b480         	push	{r7}
 8026b1e: b085         	sub	sp, #0x14
 8026b20: af00         	add	r7, sp, #0x0
 8026b22: 6078         	str	r0, [r7, #0x4]
 8026b24: 687b         	ldr	r3, [r7, #0x4]
 8026b26: 60fb         	str	r3, [r7, #0xc]
; 	return key == 0U;
 8026b28: 68fb         	ldr	r3, [r7, #0xc]
 8026b2a: 2b00         	cmp	r3, #0x0
 8026b2c: bf0c         	ite	eq
 8026b2e: 2301         	moveq	r3, #0x1
 8026b30: 2300         	movne	r3, #0x0
 8026b32: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 8026b34: 2b00         	cmp	r3, #0x0
 8026b36: d00f         	beq	0x8026b58 <resched+0x3c> @ imm = #0x1e
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8026b38: f3ef 8305    	mrs	r3, ipsr
 8026b3c: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 8026b3e: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 8026b40: 2b00         	cmp	r3, #0x0
 8026b42: bf14         	ite	ne
 8026b44: 2301         	movne	r3, #0x1
 8026b46: 2300         	moveq	r3, #0x0
 8026b48: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 8026b4a: f083 0301    	eor	r3, r3, #0x1
 8026b4e: b2db         	uxtb	r3, r3
 8026b50: 2b00         	cmp	r3, #0x0
 8026b52: d001         	beq	0x8026b58 <resched+0x3c> @ imm = #0x2
 8026b54: 2301         	movs	r3, #0x1
 8026b56: e000         	b	0x8026b5a <resched+0x3e> @ imm = #0x0
 8026b58: 2300         	movs	r3, #0x0
 8026b5a: f003 0301    	and	r3, r3, #0x1
 8026b5e: b2db         	uxtb	r3, r3
; }
 8026b60: 4618         	mov	r0, r3
 8026b62: 3714         	adds	r7, #0x14
 8026b64: 46bd         	mov	sp, r7
 8026b66: f85d 7b04    	ldr	r7, [sp], #4
 8026b6a: 4770         	bx	lr

08026b6c <z_reschedule>:
; {
 8026b6c: b580         	push	{r7, lr}
 8026b6e: b08a         	sub	sp, #0x28
 8026b70: af00         	add	r7, sp, #0x0
 8026b72: 6078         	str	r0, [r7, #0x4]
 8026b74: 6039         	str	r1, [r7]
; 	if (resched(key.key) && need_swap()) {
 8026b76: 683b         	ldr	r3, [r7]
 8026b78: 4618         	mov	r0, r3
 8026b7a: f7ff ffcf    	bl	0x8026b1c <resched>     @ imm = #-0x62
 8026b7e: 4603         	mov	r3, r0
 8026b80: 2b00         	cmp	r3, #0x0
 8026b82: d010         	beq	0x8026ba6 <z_reschedule+0x3a> @ imm = #0x20
 8026b84: f7ef f888    	bl	0x8015c98 <need_swap>   @ imm = #-0x10ef0
 8026b88: 4603         	mov	r3, r0
 8026b8a: 2b00         	cmp	r3, #0x0
 8026b8c: d00b         	beq	0x8026ba6 <z_reschedule+0x3a> @ imm = #0x16
 8026b8e: 687b         	ldr	r3, [r7, #0x4]
 8026b90: 627b         	str	r3, [r7, #0x24]
 8026b92: 683b         	ldr	r3, [r7]
 8026b94: 60fb         	str	r3, [r7, #0xc]
 8026b96: 6a7b         	ldr	r3, [r7, #0x24]
 8026b98: 623b         	str	r3, [r7, #0x20]
; }
 8026b9a: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8026b9c: 68fb         	ldr	r3, [r7, #0xc]
 8026b9e: 4618         	mov	r0, r3
 8026ba0: f7ff fe7b    	bl	0x802689a <z_swap_irqlock> @ imm = #-0x30a
; 		z_swap(lock, key);
 8026ba4: e010         	b	0x8026bc8 <z_reschedule+0x5c> @ imm = #0x20
 8026ba6: 687b         	ldr	r3, [r7, #0x4]
 8026ba8: 61fb         	str	r3, [r7, #0x1c]
 8026baa: 683b         	ldr	r3, [r7]
 8026bac: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8026bae: 693b         	ldr	r3, [r7, #0x10]
 8026bb0: 61bb         	str	r3, [r7, #0x18]
 8026bb2: 69bb         	ldr	r3, [r7, #0x18]
 8026bb4: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8026bb6: 697b         	ldr	r3, [r7, #0x14]
 8026bb8: f383 8811    	msr	basepri, r3
; }
 8026bbc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8026bbe: f3bf 8f6f    	isb	sy
; }
 8026bc2: bf00         	nop
; }
 8026bc4: bf00         	nop
; }
 8026bc6: bf00         	nop
; }
 8026bc8: bf00         	nop
 8026bca: 3728         	adds	r7, #0x28
 8026bcc: 46bd         	mov	sp, r7
 8026bce: bd80         	pop	{r7, pc}

08026bd0 <z_reschedule_irqlock>:
; {
 8026bd0: b580         	push	{r7, lr}
 8026bd2: b084         	sub	sp, #0x10
 8026bd4: af00         	add	r7, sp, #0x0
 8026bd6: 6078         	str	r0, [r7, #0x4]
; 	if (resched(key) && need_swap()) {
 8026bd8: 6878         	ldr	r0, [r7, #0x4]
 8026bda: f7ff ff9f    	bl	0x8026b1c <resched>     @ imm = #-0xc2
 8026bde: 4603         	mov	r3, r0
 8026be0: 2b00         	cmp	r3, #0x0
 8026be2: d008         	beq	0x8026bf6 <z_reschedule_irqlock+0x26> @ imm = #0x10
 8026be4: f7ef f858    	bl	0x8015c98 <need_swap>   @ imm = #-0x10f50
 8026be8: 4603         	mov	r3, r0
 8026bea: 2b00         	cmp	r3, #0x0
 8026bec: d003         	beq	0x8026bf6 <z_reschedule_irqlock+0x26> @ imm = #0x6
; 		z_swap_irqlock(key);
 8026bee: 6878         	ldr	r0, [r7, #0x4]
 8026bf0: f7ff fe53    	bl	0x802689a <z_swap_irqlock> @ imm = #-0x35a
 8026bf4: e00b         	b	0x8026c0e <z_reschedule_irqlock+0x3e> @ imm = #0x16
 8026bf6: 687b         	ldr	r3, [r7, #0x4]
 8026bf8: 60fb         	str	r3, [r7, #0xc]
 8026bfa: 68fb         	ldr	r3, [r7, #0xc]
 8026bfc: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8026bfe: 68bb         	ldr	r3, [r7, #0x8]
 8026c00: f383 8811    	msr	basepri, r3
; }
 8026c04: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8026c06: f3bf 8f6f    	isb	sy
; }
 8026c0a: bf00         	nop
; }
 8026c0c: bf00         	nop
; }
 8026c0e: bf00         	nop
 8026c10: 3710         	adds	r7, #0x10
 8026c12: 46bd         	mov	sp, r7
 8026c14: bd80         	pop	{r7, pc}

08026c16 <z_unpend_all>:
; {
 8026c16: b580         	push	{r7, lr}
 8026c18: b084         	sub	sp, #0x10
 8026c1a: af00         	add	r7, sp, #0x0
 8026c1c: 6078         	str	r0, [r7, #0x4]
; 	int need_sched = 0;
 8026c1e: 2300         	movs	r3, #0x0
 8026c20: 60fb         	str	r3, [r7, #0xc]
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 8026c22: 6878         	ldr	r0, [r7, #0x4]
 8026c24: f7ff fe2c    	bl	0x8026880 <z_waitq_head> @ imm = #-0x3a8
 8026c28: 60b8         	str	r0, [r7, #0x8]
 8026c2a: e00b         	b	0x8026c44 <z_unpend_all+0x2e> @ imm = #0x16
; 		z_unpend_thread(thread);
 8026c2c: 68b8         	ldr	r0, [r7, #0x8]
 8026c2e: f7ff ff67    	bl	0x8026b00 <z_unpend_thread> @ imm = #-0x132
; 		z_ready_thread(thread);
 8026c32: 68b8         	ldr	r0, [r7, #0x8]
 8026c34: f7ee fa52    	bl	0x80150dc <z_ready_thread> @ imm = #-0x11b5c
; 		need_sched = 1;
 8026c38: 2301         	movs	r3, #0x1
 8026c3a: 60fb         	str	r3, [r7, #0xc]
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 8026c3c: 6878         	ldr	r0, [r7, #0x4]
 8026c3e: f7ff fe1f    	bl	0x8026880 <z_waitq_head> @ imm = #-0x3c2
 8026c42: 60b8         	str	r0, [r7, #0x8]
 8026c44: 68bb         	ldr	r3, [r7, #0x8]
 8026c46: 2b00         	cmp	r3, #0x0
 8026c48: d1f0         	bne	0x8026c2c <z_unpend_all+0x16> @ imm = #-0x20
; 	return need_sched;
 8026c4a: 68fb         	ldr	r3, [r7, #0xc]
; }
 8026c4c: 4618         	mov	r0, r3
 8026c4e: 3710         	adds	r7, #0x10
 8026c50: 46bd         	mov	sp, r7
 8026c52: bd80         	pop	{r7, pc}

08026c54 <init_ready_q>:
; {
 8026c54: b580         	push	{r7, lr}
 8026c56: b084         	sub	sp, #0x10
 8026c58: af00         	add	r7, sp, #0x0
 8026c5a: 6078         	str	r0, [r7, #0x4]
; 	_priq_run_init(&ready_q->runq);
 8026c5c: 687b         	ldr	r3, [r7, #0x4]
 8026c5e: 3304         	adds	r3, #0x4
 8026c60: 60fb         	str	r3, [r7, #0xc]
; 	sys_dlist_init(pq);
 8026c62: 68f8         	ldr	r0, [r7, #0xc]
 8026c64: f7ff fbe5    	bl	0x8026432 <sys_dlist_init> @ imm = #-0x836
; }
 8026c68: bf00         	nop
; }
 8026c6a: bf00         	nop
 8026c6c: 3710         	adds	r7, #0x10
 8026c6e: 46bd         	mov	sp, r7
 8026c70: bd80         	pop	{r7, pc}

08026c72 <z_impl_k_usleep>:
; {
 8026c72: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8026c76: b084         	sub	sp, #0x10
 8026c78: af00         	add	r7, sp, #0x0
 8026c7a: 6078         	str	r0, [r7, #0x4]
; 	ticks = k_us_to_ticks_ceil64(us);
 8026c7c: 6879         	ldr	r1, [r7, #0x4]
 8026c7e: 17c8         	asrs	r0, r1, #0x1f
 8026c80: 460a         	mov	r2, r1
 8026c82: 4603         	mov	r3, r0
 8026c84: f112 0463    	adds.w	r4, r2, #0x63
 8026c88: f143 0500    	adc	r5, r3, #0x0
 8026c8c: f04f 0264    	mov.w	r2, #0x64
 8026c90: f04f 0300    	mov.w	r3, #0x0
 8026c94: 4620         	mov	r0, r4
 8026c96: 4629         	mov	r1, r5
 8026c98: f7d9 fcd2    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x2665c
 8026c9c: 4602         	mov	r2, r0
 8026c9e: 460b         	mov	r3, r1
 8026ca0: 4613         	mov	r3, r2
 8026ca2: 60fb         	str	r3, [r7, #0xc]
; 	ticks = z_tick_sleep(ticks);
 8026ca4: 68fb         	ldr	r3, [r7, #0xc]
 8026ca6: 17da         	asrs	r2, r3, #0x1f
 8026ca8: 4698         	mov	r8, r3
 8026caa: 4691         	mov	r9, r2
 8026cac: 4640         	mov	r0, r8
 8026cae: 4649         	mov	r1, r9
 8026cb0: f7ef fa66    	bl	0x8016180 <z_tick_sleep> @ imm = #-0x10b34
 8026cb4: 60f8         	str	r0, [r7, #0xc]
; 	int32_t ret = k_ticks_to_us_ceil64(ticks);
 8026cb6: 68fb         	ldr	r3, [r7, #0xc]
 8026cb8: 17da         	asrs	r2, r3, #0x1f
 8026cba: 469a         	mov	r10, r3
 8026cbc: 4693         	mov	r11, r2
 8026cbe: 4652         	mov	r2, r10
 8026cc0: 2364         	movs	r3, #0x64
 8026cc2: fb02 f303    	mul	r3, r2, r3
 8026cc6: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8026cc8: 68bb         	ldr	r3, [r7, #0x8]
; }
 8026cca: 4618         	mov	r0, r3
 8026ccc: 3710         	adds	r7, #0x10
 8026cce: 46bd         	mov	sp, r7
 8026cd0: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08026cd4 <unpend_all>:
; {
 8026cd4: b580         	push	{r7, lr}
 8026cd6: b086         	sub	sp, #0x18
 8026cd8: af00         	add	r7, sp, #0x0
 8026cda: 6078         	str	r0, [r7, #0x4]
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 8026cdc: 6878         	ldr	r0, [r7, #0x4]
 8026cde: f7ff fdcf    	bl	0x8026880 <z_waitq_head> @ imm = #-0x462
 8026ce2: 6178         	str	r0, [r7, #0x14]
 8026ce4: e015         	b	0x8026d12 <unpend_all+0x3e> @ imm = #0x2a
; 		unpend_thread_no_timeout(thread);
 8026ce6: 6978         	ldr	r0, [r7, #0x14]
 8026ce8: f7ff fdb0    	bl	0x802684c <unpend_thread_no_timeout> @ imm = #-0x4a0
; 		(void)z_abort_thread_timeout(thread);
 8026cec: 6978         	ldr	r0, [r7, #0x14]
 8026cee: f7ff fc90    	bl	0x8026612 <z_abort_thread_timeout> @ imm = #-0x6e0
 8026cf2: 697b         	ldr	r3, [r7, #0x14]
 8026cf4: 613b         	str	r3, [r7, #0x10]
 8026cf6: 2300         	movs	r3, #0x0
 8026cf8: 60fb         	str	r3, [r7, #0xc]
; 	thread->arch.swap_return_value = value;
 8026cfa: 693b         	ldr	r3, [r7, #0x10]
 8026cfc: 68fa         	ldr	r2, [r7, #0xc]
 8026cfe: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8026d02: bf00         	nop
; 		ready_thread(thread);
 8026d04: 6978         	ldr	r0, [r7, #0x14]
 8026d06: f7ee f915    	bl	0x8014f34 <ready_thread> @ imm = #-0x11dd6
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 8026d0a: 6878         	ldr	r0, [r7, #0x4]
 8026d0c: f7ff fdb8    	bl	0x8026880 <z_waitq_head> @ imm = #-0x490
 8026d10: 6178         	str	r0, [r7, #0x14]
 8026d12: 697b         	ldr	r3, [r7, #0x14]
 8026d14: 2b00         	cmp	r3, #0x0
 8026d16: d1e6         	bne	0x8026ce6 <unpend_all+0x12> @ imm = #-0x34
; }
 8026d18: bf00         	nop
 8026d1a: bf00         	nop
 8026d1c: 3718         	adds	r7, #0x18
 8026d1e: 46bd         	mov	sp, r7
 8026d20: bd80         	pop	{r7, pc}

08026d22 <thread_is_preemptible>:
; {
 8026d22: b480         	push	{r7}
 8026d24: b083         	sub	sp, #0xc
 8026d26: af00         	add	r7, sp, #0x0
 8026d28: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 8026d2a: 687b         	ldr	r3, [r7, #0x4]
 8026d2c: 89db         	ldrh	r3, [r3, #0xe]
 8026d2e: 2b7f         	cmp	r3, #0x7f
 8026d30: bf94         	ite	ls
 8026d32: 2301         	movls	r3, #0x1
 8026d34: 2300         	movhi	r3, #0x0
 8026d36: b2db         	uxtb	r3, r3
; }
 8026d38: 4618         	mov	r0, r3
 8026d3a: 370c         	adds	r7, #0xc
 8026d3c: 46bd         	mov	sp, r7
 8026d3e: f85d 7b04    	ldr	r7, [sp], #4
 8026d42: 4770         	bx	lr

08026d44 <z_is_thread_prevented_from_running>:
; {
 8026d44: b480         	push	{r7}
 8026d46: b085         	sub	sp, #0x14
 8026d48: af00         	add	r7, sp, #0x0
 8026d4a: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8026d4c: 687b         	ldr	r3, [r7, #0x4]
 8026d4e: 7b5b         	ldrb	r3, [r3, #0xd]
 8026d50: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 8026d52: 7bfb         	ldrb	r3, [r7, #0xf]
 8026d54: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 8026d58: 2b00         	cmp	r3, #0x0
 8026d5a: bf14         	ite	ne
 8026d5c: 2301         	movne	r3, #0x1
 8026d5e: 2300         	moveq	r3, #0x0
 8026d60: b2db         	uxtb	r3, r3
; }
 8026d62: 4618         	mov	r0, r3
 8026d64: 3714         	adds	r7, #0x14
 8026d66: 46bd         	mov	sp, r7
 8026d68: f85d 7b04    	ldr	r7, [sp], #4
 8026d6c: 4770         	bx	lr

08026d6e <z_is_prio1_higher_than_prio2>:
; {
 8026d6e: b480         	push	{r7}
 8026d70: b083         	sub	sp, #0xc
 8026d72: af00         	add	r7, sp, #0x0
 8026d74: 6078         	str	r0, [r7, #0x4]
 8026d76: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 8026d78: 687a         	ldr	r2, [r7, #0x4]
 8026d7a: 683b         	ldr	r3, [r7]
 8026d7c: 429a         	cmp	r2, r3
 8026d7e: bfb4         	ite	lt
 8026d80: 2301         	movlt	r3, #0x1
 8026d82: 2300         	movge	r3, #0x0
 8026d84: b2db         	uxtb	r3, r3
; }
 8026d86: 4618         	mov	r0, r3
 8026d88: 370c         	adds	r7, #0xc
 8026d8a: 46bd         	mov	sp, r7
 8026d8c: f85d 7b04    	ldr	r7, [sp], #4
 8026d90: 4770         	bx	lr

08026d92 <z_is_prio_higher>:
; {
 8026d92: b580         	push	{r7, lr}
 8026d94: b082         	sub	sp, #0x8
 8026d96: af00         	add	r7, sp, #0x0
 8026d98: 6078         	str	r0, [r7, #0x4]
 8026d9a: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 8026d9c: 6839         	ldr	r1, [r7]
 8026d9e: 6878         	ldr	r0, [r7, #0x4]
 8026da0: f7ff ffe5    	bl	0x8026d6e <z_is_prio1_higher_than_prio2> @ imm = #-0x36
 8026da4: 4603         	mov	r3, r0
; }
 8026da6: 4618         	mov	r0, r3
 8026da8: 3708         	adds	r7, #0x8
 8026daa: 46bd         	mov	sp, r7
 8026dac: bd80         	pop	{r7, pc}

08026dae <sys_dnode_init>:
; {
 8026dae: b480         	push	{r7}
 8026db0: b083         	sub	sp, #0xc
 8026db2: af00         	add	r7, sp, #0x0
 8026db4: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8026db6: 687b         	ldr	r3, [r7, #0x4]
 8026db8: 2200         	movs	r2, #0x0
 8026dba: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8026dbc: 687b         	ldr	r3, [r7, #0x4]
 8026dbe: 2200         	movs	r2, #0x0
 8026dc0: 605a         	str	r2, [r3, #0x4]
; }
 8026dc2: bf00         	nop
 8026dc4: 370c         	adds	r7, #0xc
 8026dc6: 46bd         	mov	sp, r7
 8026dc8: f85d 7b04    	ldr	r7, [sp], #4
 8026dcc: 4770         	bx	lr

08026dce <sys_dnode_is_linked>:
; {
 8026dce: b480         	push	{r7}
 8026dd0: b083         	sub	sp, #0xc
 8026dd2: af00         	add	r7, sp, #0x0
 8026dd4: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 8026dd6: 687b         	ldr	r3, [r7, #0x4]
 8026dd8: 681b         	ldr	r3, [r3]
 8026dda: 2b00         	cmp	r3, #0x0
 8026ddc: bf14         	ite	ne
 8026dde: 2301         	movne	r3, #0x1
 8026de0: 2300         	moveq	r3, #0x0
 8026de2: b2db         	uxtb	r3, r3
; }
 8026de4: 4618         	mov	r0, r3
 8026de6: 370c         	adds	r7, #0xc
 8026de8: 46bd         	mov	sp, r7
 8026dea: f85d 7b04    	ldr	r7, [sp], #4
 8026dee: 4770         	bx	lr

08026df0 <sys_dlist_is_empty>:
; {
 8026df0: b480         	push	{r7}
 8026df2: b083         	sub	sp, #0xc
 8026df4: af00         	add	r7, sp, #0x0
 8026df6: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8026df8: 687b         	ldr	r3, [r7, #0x4]
 8026dfa: 681b         	ldr	r3, [r3]
 8026dfc: 687a         	ldr	r2, [r7, #0x4]
 8026dfe: 429a         	cmp	r2, r3
 8026e00: bf0c         	ite	eq
 8026e02: 2301         	moveq	r3, #0x1
 8026e04: 2300         	movne	r3, #0x0
 8026e06: b2db         	uxtb	r3, r3
; }
 8026e08: 4618         	mov	r0, r3
 8026e0a: 370c         	adds	r7, #0xc
 8026e0c: 46bd         	mov	sp, r7
 8026e0e: f85d 7b04    	ldr	r7, [sp], #4
 8026e12: 4770         	bx	lr

08026e14 <sys_dlist_peek_head>:
; {
 8026e14: b580         	push	{r7, lr}
 8026e16: b082         	sub	sp, #0x8
 8026e18: af00         	add	r7, sp, #0x0
 8026e1a: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8026e1c: 6878         	ldr	r0, [r7, #0x4]
 8026e1e: f7ff ffe7    	bl	0x8026df0 <sys_dlist_is_empty> @ imm = #-0x32
 8026e22: 4603         	mov	r3, r0
 8026e24: 2b00         	cmp	r3, #0x0
 8026e26: d102         	bne	0x8026e2e <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8026e28: 687b         	ldr	r3, [r7, #0x4]
 8026e2a: 681b         	ldr	r3, [r3]
 8026e2c: e000         	b	0x8026e30 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8026e2e: 2300         	movs	r3, #0x0
; }
 8026e30: 4618         	mov	r0, r3
 8026e32: 3708         	adds	r7, #0x8
 8026e34: 46bd         	mov	sp, r7
 8026e36: bd80         	pop	{r7, pc}

08026e38 <sys_dlist_peek_next_no_check>:
; {
 8026e38: b480         	push	{r7}
 8026e3a: b083         	sub	sp, #0xc
 8026e3c: af00         	add	r7, sp, #0x0
 8026e3e: 6078         	str	r0, [r7, #0x4]
 8026e40: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 8026e42: 687b         	ldr	r3, [r7, #0x4]
 8026e44: 685b         	ldr	r3, [r3, #0x4]
 8026e46: 683a         	ldr	r2, [r7]
 8026e48: 429a         	cmp	r2, r3
 8026e4a: d002         	beq	0x8026e52 <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 8026e4c: 683b         	ldr	r3, [r7]
 8026e4e: 681b         	ldr	r3, [r3]
 8026e50: e000         	b	0x8026e54 <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 8026e52: 2300         	movs	r3, #0x0
; }
 8026e54: 4618         	mov	r0, r3
 8026e56: 370c         	adds	r7, #0xc
 8026e58: 46bd         	mov	sp, r7
 8026e5a: f85d 7b04    	ldr	r7, [sp], #4
 8026e5e: 4770         	bx	lr

08026e60 <sys_dlist_peek_next>:
; {
 8026e60: b580         	push	{r7, lr}
 8026e62: b082         	sub	sp, #0x8
 8026e64: af00         	add	r7, sp, #0x0
 8026e66: 6078         	str	r0, [r7, #0x4]
 8026e68: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 8026e6a: 683b         	ldr	r3, [r7]
 8026e6c: 2b00         	cmp	r3, #0x0
 8026e6e: d005         	beq	0x8026e7c <sys_dlist_peek_next+0x1c> @ imm = #0xa
 8026e70: 6839         	ldr	r1, [r7]
 8026e72: 6878         	ldr	r0, [r7, #0x4]
 8026e74: f7ff ffe0    	bl	0x8026e38 <sys_dlist_peek_next_no_check> @ imm = #-0x40
 8026e78: 4603         	mov	r3, r0
 8026e7a: e000         	b	0x8026e7e <sys_dlist_peek_next+0x1e> @ imm = #0x0
 8026e7c: 2300         	movs	r3, #0x0
; }
 8026e7e: 4618         	mov	r0, r3
 8026e80: 3708         	adds	r7, #0x8
 8026e82: 46bd         	mov	sp, r7
 8026e84: bd80         	pop	{r7, pc}

08026e86 <sys_dlist_append>:
; {
 8026e86: b480         	push	{r7}
 8026e88: b085         	sub	sp, #0x14
 8026e8a: af00         	add	r7, sp, #0x0
 8026e8c: 6078         	str	r0, [r7, #0x4]
 8026e8e: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 8026e90: 687b         	ldr	r3, [r7, #0x4]
 8026e92: 685b         	ldr	r3, [r3, #0x4]
 8026e94: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 8026e96: 683b         	ldr	r3, [r7]
 8026e98: 687a         	ldr	r2, [r7, #0x4]
 8026e9a: 601a         	str	r2, [r3]
; 	node->prev = tail;
 8026e9c: 683b         	ldr	r3, [r7]
 8026e9e: 68fa         	ldr	r2, [r7, #0xc]
 8026ea0: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 8026ea2: 68fb         	ldr	r3, [r7, #0xc]
 8026ea4: 683a         	ldr	r2, [r7]
 8026ea6: 601a         	str	r2, [r3]
; 	list->tail = node;
 8026ea8: 687b         	ldr	r3, [r7, #0x4]
 8026eaa: 683a         	ldr	r2, [r7]
 8026eac: 605a         	str	r2, [r3, #0x4]
; }
 8026eae: bf00         	nop
 8026eb0: 3714         	adds	r7, #0x14
 8026eb2: 46bd         	mov	sp, r7
 8026eb4: f85d 7b04    	ldr	r7, [sp], #4
 8026eb8: 4770         	bx	lr

08026eba <sys_dlist_insert>:
; {
 8026eba: b480         	push	{r7}
 8026ebc: b085         	sub	sp, #0x14
 8026ebe: af00         	add	r7, sp, #0x0
 8026ec0: 6078         	str	r0, [r7, #0x4]
 8026ec2: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 8026ec4: 687b         	ldr	r3, [r7, #0x4]
 8026ec6: 685b         	ldr	r3, [r3, #0x4]
 8026ec8: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 8026eca: 683b         	ldr	r3, [r7]
 8026ecc: 68fa         	ldr	r2, [r7, #0xc]
 8026ece: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 8026ed0: 683b         	ldr	r3, [r7]
 8026ed2: 687a         	ldr	r2, [r7, #0x4]
 8026ed4: 601a         	str	r2, [r3]
; 	prev->next = node;
 8026ed6: 68fb         	ldr	r3, [r7, #0xc]
 8026ed8: 683a         	ldr	r2, [r7]
 8026eda: 601a         	str	r2, [r3]
; 	successor->prev = node;
 8026edc: 687b         	ldr	r3, [r7, #0x4]
 8026ede: 683a         	ldr	r2, [r7]
 8026ee0: 605a         	str	r2, [r3, #0x4]
; }
 8026ee2: bf00         	nop
 8026ee4: 3714         	adds	r7, #0x14
 8026ee6: 46bd         	mov	sp, r7
 8026ee8: f85d 7b04    	ldr	r7, [sp], #4
 8026eec: 4770         	bx	lr

08026eee <sys_dlist_remove>:
; {
 8026eee: b580         	push	{r7, lr}
 8026ef0: b084         	sub	sp, #0x10
 8026ef2: af00         	add	r7, sp, #0x0
 8026ef4: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8026ef6: 687b         	ldr	r3, [r7, #0x4]
 8026ef8: 685b         	ldr	r3, [r3, #0x4]
 8026efa: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8026efc: 687b         	ldr	r3, [r7, #0x4]
 8026efe: 681b         	ldr	r3, [r3]
 8026f00: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8026f02: 68fb         	ldr	r3, [r7, #0xc]
 8026f04: 68ba         	ldr	r2, [r7, #0x8]
 8026f06: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8026f08: 68bb         	ldr	r3, [r7, #0x8]
 8026f0a: 68fa         	ldr	r2, [r7, #0xc]
 8026f0c: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8026f0e: 6878         	ldr	r0, [r7, #0x4]
 8026f10: f7ff ff4d    	bl	0x8026dae <sys_dnode_init> @ imm = #-0x166
; }
 8026f14: bf00         	nop
 8026f16: 3710         	adds	r7, #0x10
 8026f18: 46bd         	mov	sp, r7
 8026f1a: bd80         	pop	{r7, pc}

08026f1c <remove_timeout>:
; {
 8026f1c: b5f0         	push	{r4, r5, r6, r7, lr}
 8026f1e: b083         	sub	sp, #0xc
 8026f20: af00         	add	r7, sp, #0x0
 8026f22: 6078         	str	r0, [r7, #0x4]
; 	if (next(t) != NULL) {
 8026f24: 6878         	ldr	r0, [r7, #0x4]
 8026f26: f7ef fe57    	bl	0x8016bd8 <next>        @ imm = #-0x10352
 8026f2a: 4603         	mov	r3, r0
 8026f2c: 2b00         	cmp	r3, #0x0
 8026f2e: d00d         	beq	0x8026f4c <remove_timeout+0x30> @ imm = #0x1a
; 		next(t)->dticks += t->dticks;
 8026f30: 6878         	ldr	r0, [r7, #0x4]
 8026f32: f7ef fe51    	bl	0x8016bd8 <next>        @ imm = #-0x1035e
 8026f36: 4606         	mov	r6, r0
 8026f38: e9d6 0104    	ldrd	r0, r1, [r6, #16]
 8026f3c: 687b         	ldr	r3, [r7, #0x4]
 8026f3e: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8026f42: 1884         	adds	r4, r0, r2
 8026f44: eb41 0503    	adc.w	r5, r1, r3
 8026f48: e9c6 4504    	strd	r4, r5, [r6, #16]
; 	sys_dlist_remove(&t->node);
 8026f4c: 687b         	ldr	r3, [r7, #0x4]
 8026f4e: 4618         	mov	r0, r3
 8026f50: f7ff ffcd    	bl	0x8026eee <sys_dlist_remove> @ imm = #-0x66
; }
 8026f54: bf00         	nop
 8026f56: 370c         	adds	r7, #0xc
 8026f58: 46bd         	mov	sp, r7
 8026f5a: bdf0         	pop	{r4, r5, r6, r7, pc}

08026f5c <next_timeout>:
; {
 8026f5c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8026f60: b086         	sub	sp, #0x18
 8026f62: af00         	add	r7, sp, #0x0
; 	struct _timeout *to = first();
 8026f64: f7ef fe2a    	bl	0x8016bbc <first>       @ imm = #-0x103ac
 8026f68: 6138         	str	r0, [r7, #0x10]
; 	int32_t ticks_elapsed = elapsed();
 8026f6a: f7ef fe47    	bl	0x8016bfc <elapsed>     @ imm = #-0x10372
 8026f6e: 60f8         	str	r0, [r7, #0xc]
; 	if ((to == NULL) ||
 8026f70: 693b         	ldr	r3, [r7, #0x10]
 8026f72: 2b00         	cmp	r3, #0x0
 8026f74: d00f         	beq	0x8026f96 <next_timeout+0x3a> @ imm = #0x1e
; 	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 8026f76: 693b         	ldr	r3, [r7, #0x10]
 8026f78: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8026f7c: 68f9         	ldr	r1, [r7, #0xc]
 8026f7e: 17c8         	asrs	r0, r1, #0x1f
 8026f80: 468a         	mov	r10, r1
 8026f82: 4683         	mov	r11, r0
 8026f84: ebb2 040a    	subs.w	r4, r2, r10
 8026f88: eb63 050b    	sbc.w	r5, r3, r11
; 	if ((to == NULL) ||
 8026f8c: f1b4 4f00    	cmp.w	r4, #0x80000000
 8026f90: f175 0300    	sbcs	r3, r5, #0x0
 8026f94: db03         	blt	0x8026f9e <next_timeout+0x42> @ imm = #0x6
; 		ret = MAX_WAIT;
 8026f96: f06f 4300    	mvn	r3, #0x80000000
 8026f9a: 617b         	str	r3, [r7, #0x14]
 8026f9c: e016         	b	0x8026fcc <next_timeout+0x70> @ imm = #0x2c
; 		ret = MAX(0, to->dticks - ticks_elapsed);
 8026f9e: 693b         	ldr	r3, [r7, #0x10]
 8026fa0: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8026fa4: 68f9         	ldr	r1, [r7, #0xc]
 8026fa6: 17c8         	asrs	r0, r1, #0x1f
 8026fa8: 4688         	mov	r8, r1
 8026faa: 4681         	mov	r9, r0
 8026fac: ebb2 0108    	subs.w	r1, r2, r8
 8026fb0: 6039         	str	r1, [r7]
 8026fb2: eb63 0309    	sbc.w	r3, r3, r9
 8026fb6: 607b         	str	r3, [r7, #0x4]
 8026fb8: e9d7 2300    	ldrd	r2, r3, [r7]
 8026fbc: 2b00         	cmp	r3, #0x0
 8026fbe: da03         	bge	0x8026fc8 <next_timeout+0x6c> @ imm = #0x6
 8026fc0: f04f 0200    	mov.w	r2, #0x0
 8026fc4: f04f 0300    	mov.w	r3, #0x0
 8026fc8: 4613         	mov	r3, r2
 8026fca: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 8026fcc: 697b         	ldr	r3, [r7, #0x14]
; }
 8026fce: 4618         	mov	r0, r3
 8026fd0: 3718         	adds	r7, #0x18
 8026fd2: 46bd         	mov	sp, r7
 8026fd4: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08026fd8 <sys_clock_tick_get_32>:
; {
 8026fd8: b580         	push	{r7, lr}
 8026fda: af00         	add	r7, sp, #0x0
; 	return (uint32_t)sys_clock_tick_get();
 8026fdc: f7f0 f852    	bl	0x8017084 <sys_clock_tick_get> @ imm = #-0xff5c
 8026fe0: 4602         	mov	r2, r0
 8026fe2: 460b         	mov	r3, r1
 8026fe4: 4613         	mov	r3, r2
; }
 8026fe6: 4618         	mov	r0, r3
 8026fe8: bd80         	pop	{r7, pc}

08026fea <z_impl_k_uptime_ticks>:
; {
 8026fea: b580         	push	{r7, lr}
 8026fec: af00         	add	r7, sp, #0x0
; 	return sys_clock_tick_get();
 8026fee: f7f0 f849    	bl	0x8017084 <sys_clock_tick_get> @ imm = #-0xff6e
 8026ff2: 4602         	mov	r2, r0
 8026ff4: 460b         	mov	r3, r1
; }
 8026ff6: 4610         	mov	r0, r2
 8026ff8: 4619         	mov	r1, r3
 8026ffa: bd80         	pop	{r7, pc}

08026ffc <sys_timepoint_calc>:
; {
 8026ffc: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8027000: b088         	sub	sp, #0x20
 8027002: af00         	add	r7, sp, #0x0
 8027004: 60f8         	str	r0, [r7, #0xc]
 8027006: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 802700a: e9d7 2300    	ldrd	r2, r3, [r7]
 802700e: f04f 30ff    	mov.w	r0, #0xffffffff
 8027012: f04f 31ff    	mov.w	r1, #0xffffffff
 8027016: 428b         	cmp	r3, r1
 8027018: bf08         	it	eq
 802701a: 4282         	cmpeq	r2, r0
 802701c: d106         	bne	0x802702c <sys_timepoint_calc+0x30> @ imm = #0xc
; 		timepoint.tick = UINT64_MAX;
 802701e: f04f 32ff    	mov.w	r2, #0xffffffff
 8027022: f04f 33ff    	mov.w	r3, #0xffffffff
 8027026: e9c7 2304    	strd	r2, r3, [r7, #16]
 802702a: e042         	b	0x80270b2 <sys_timepoint_calc+0xb6> @ imm = #0x84
; 	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 802702c: e9d7 2300    	ldrd	r2, r3, [r7]
 8027030: f04f 0000    	mov.w	r0, #0x0
 8027034: f04f 0100    	mov.w	r1, #0x0
 8027038: 428b         	cmp	r3, r1
 802703a: bf08         	it	eq
 802703c: 4282         	cmpeq	r2, r0
 802703e: d106         	bne	0x802704e <sys_timepoint_calc+0x52> @ imm = #0xc
; 		timepoint.tick = 0;
 8027040: f04f 0200    	mov.w	r2, #0x0
 8027044: f04f 0300    	mov.w	r3, #0x0
 8027048: e9c7 2304    	strd	r2, r3, [r7, #16]
 802704c: e031         	b	0x80270b2 <sys_timepoint_calc+0xb6> @ imm = #0x62
; 		k_ticks_t dt = timeout.ticks;
 802704e: e9d7 2300    	ldrd	r2, r3, [r7]
 8027052: e9c7 2306    	strd	r2, r3, [r7, #24]
; 		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
 8027056: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 802705a: f06f 0001    	mvn	r0, #0x1
 802705e: f04f 31ff    	mov.w	r1, #0xffffffff
 8027062: 1a84         	subs	r4, r0, r2
 8027064: eb61 0503    	sbc.w	r5, r1, r3
 8027068: 2d00         	cmp	r5, #0x0
 802706a: db0e         	blt	0x802708a <sys_timepoint_calc+0x8e> @ imm = #0x1c
; 			timepoint.tick = Z_TICK_ABS(dt);
 802706c: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8027070: f06f 0001    	mvn	r0, #0x1
 8027074: f04f 31ff    	mov.w	r1, #0xffffffff
 8027078: ebb0 0a02    	subs.w	r10, r0, r2
 802707c: eb61 0b03    	sbc.w	r11, r1, r3
 8027080: 4652         	mov	r2, r10
 8027082: 465b         	mov	r3, r11
 8027084: e9c7 2304    	strd	r2, r3, [r7, #16]
 8027088: e013         	b	0x80270b2 <sys_timepoint_calc+0xb6> @ imm = #0x26
; 			timepoint.tick = sys_clock_tick_get() + MAX(1, dt);
 802708a: f7ef fffb    	bl	0x8017084 <sys_clock_tick_get> @ imm = #-0x1000a
 802708e: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8027092: 2a01         	cmp	r2, #0x1
 8027094: f173 0400    	sbcs	r4, r3, #0x0
 8027098: da03         	bge	0x80270a2 <sys_timepoint_calc+0xa6> @ imm = #0x6
 802709a: f04f 0201    	mov.w	r2, #0x1
 802709e: f04f 0300    	mov.w	r3, #0x0
 80270a2: eb10 0802    	adds.w	r8, r0, r2
 80270a6: eb41 0903    	adc.w	r9, r1, r3
 80270aa: 4642         	mov	r2, r8
 80270ac: 464b         	mov	r3, r9
 80270ae: e9c7 2304    	strd	r2, r3, [r7, #16]
; 	return timepoint;
 80270b2: 68f9         	ldr	r1, [r7, #0xc]
 80270b4: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 80270b8: e9c1 2300    	strd	r2, r3, [r1]
; }
 80270bc: 68f8         	ldr	r0, [r7, #0xc]
 80270be: 3720         	adds	r7, #0x20
 80270c0: 46bd         	mov	sp, r7
 80270c2: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080270c6 <sys_timepoint_timeout>:
; {
 80270c6: b5b0         	push	{r4, r5, r7, lr}
 80270c8: b088         	sub	sp, #0x20
 80270ca: af00         	add	r7, sp, #0x0
 80270cc: 60f8         	str	r0, [r7, #0xc]
 80270ce: e9c7 2300    	strd	r2, r3, [r7]
; 	if (timepoint.tick == UINT64_MAX) {
 80270d2: e9d7 2300    	ldrd	r2, r3, [r7]
 80270d6: f1b3 3fff    	cmp.w	r3, #0xffffffff
 80270da: bf08         	it	eq
 80270dc: f1b2 3fff    	cmpeq.w	r2, #0xffffffff
 80270e0: d107         	bne	0x80270f2 <sys_timepoint_timeout+0x2c> @ imm = #0xe
; 		return K_FOREVER;
 80270e2: 68f9         	ldr	r1, [r7, #0xc]
 80270e4: f04f 32ff    	mov.w	r2, #0xffffffff
 80270e8: f04f 33ff    	mov.w	r3, #0xffffffff
 80270ec: e9c1 2300    	strd	r2, r3, [r1]
 80270f0: e02c         	b	0x802714c <sys_timepoint_timeout+0x86> @ imm = #0x58
; 	if (timepoint.tick == 0) {
 80270f2: e9d7 2300    	ldrd	r2, r3, [r7]
 80270f6: 4313         	orrs	r3, r2
 80270f8: d107         	bne	0x802710a <sys_timepoint_timeout+0x44> @ imm = #0xe
; 		return K_NO_WAIT;
 80270fa: 68f9         	ldr	r1, [r7, #0xc]
 80270fc: f04f 0200    	mov.w	r2, #0x0
 8027100: f04f 0300    	mov.w	r3, #0x0
 8027104: e9c1 2300    	strd	r2, r3, [r1]
 8027108: e020         	b	0x802714c <sys_timepoint_timeout+0x86> @ imm = #0x40
; 	now = sys_clock_tick_get();
 802710a: f7ef ffbb    	bl	0x8017084 <sys_clock_tick_get> @ imm = #-0x1008a
 802710e: 4602         	mov	r2, r0
 8027110: 460b         	mov	r3, r1
 8027112: e9c7 2306    	strd	r2, r3, [r7, #24]
; 	remaining = (timepoint.tick > now) ? (timepoint.tick - now) : 0;
 8027116: e9d7 2300    	ldrd	r2, r3, [r7]
 802711a: e9d7 0106    	ldrd	r0, r1, [r7, #24]
 802711e: 4290         	cmp	r0, r2
 8027120: eb71 0303    	sbcs.w	r3, r1, r3
 8027124: d207         	bhs	0x8027136 <sys_timepoint_timeout+0x70> @ imm = #0xe
 8027126: e9d7 0100    	ldrd	r0, r1, [r7]
 802712a: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 802712e: 1a84         	subs	r4, r0, r2
 8027130: eb61 0503    	sbc.w	r5, r1, r3
 8027134: e003         	b	0x802713e <sys_timepoint_timeout+0x78> @ imm = #0x6
 8027136: f04f 0400    	mov.w	r4, #0x0
 802713a: f04f 0500    	mov.w	r5, #0x0
 802713e: e9c7 4504    	strd	r4, r5, [r7, #16]
; 	return K_TICKS(remaining);
 8027142: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8027146: 68f9         	ldr	r1, [r7, #0xc]
 8027148: e9c1 2300    	strd	r2, r3, [r1]
; }
 802714c: 68f8         	ldr	r0, [r7, #0xc]
 802714e: 3720         	adds	r7, #0x20
 8027150: 46bd         	mov	sp, r7
 8027152: bdb0         	pop	{r4, r5, r7, pc}

08027154 <sys_dlist_init>:
; {
 8027154: b480         	push	{r7}
 8027156: b083         	sub	sp, #0xc
 8027158: af00         	add	r7, sp, #0x0
 802715a: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 802715c: 687b         	ldr	r3, [r7, #0x4]
 802715e: 687a         	ldr	r2, [r7, #0x4]
 8027160: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8027162: 687b         	ldr	r3, [r7, #0x4]
 8027164: 687a         	ldr	r2, [r7, #0x4]
 8027166: 605a         	str	r2, [r3, #0x4]
; }
 8027168: bf00         	nop
 802716a: 370c         	adds	r7, #0xc
 802716c: 46bd         	mov	sp, r7
 802716e: f85d 7b04    	ldr	r7, [sp], #4
 8027172: 4770         	bx	lr

08027174 <sys_dnode_init>:
; {
 8027174: b480         	push	{r7}
 8027176: b083         	sub	sp, #0xc
 8027178: af00         	add	r7, sp, #0x0
 802717a: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 802717c: 687b         	ldr	r3, [r7, #0x4]
 802717e: 2200         	movs	r2, #0x0
 8027180: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8027182: 687b         	ldr	r3, [r7, #0x4]
 8027184: 2200         	movs	r2, #0x0
 8027186: 605a         	str	r2, [r3, #0x4]
; }
 8027188: bf00         	nop
 802718a: 370c         	adds	r7, #0xc
 802718c: 46bd         	mov	sp, r7
 802718e: f85d 7b04    	ldr	r7, [sp], #4
 8027192: 4770         	bx	lr

08027194 <sys_dnode_is_linked>:
; {
 8027194: b480         	push	{r7}
 8027196: b083         	sub	sp, #0xc
 8027198: af00         	add	r7, sp, #0x0
 802719a: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 802719c: 687b         	ldr	r3, [r7, #0x4]
 802719e: 681b         	ldr	r3, [r3]
 80271a0: 2b00         	cmp	r3, #0x0
 80271a2: bf14         	ite	ne
 80271a4: 2301         	movne	r3, #0x1
 80271a6: 2300         	moveq	r3, #0x0
 80271a8: b2db         	uxtb	r3, r3
; }
 80271aa: 4618         	mov	r0, r3
 80271ac: 370c         	adds	r7, #0xc
 80271ae: 46bd         	mov	sp, r7
 80271b0: f85d 7b04    	ldr	r7, [sp], #4
 80271b4: 4770         	bx	lr

080271b6 <sys_dlist_is_empty>:
; {
 80271b6: b480         	push	{r7}
 80271b8: b083         	sub	sp, #0xc
 80271ba: af00         	add	r7, sp, #0x0
 80271bc: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 80271be: 687b         	ldr	r3, [r7, #0x4]
 80271c0: 681b         	ldr	r3, [r3]
 80271c2: 687a         	ldr	r2, [r7, #0x4]
 80271c4: 429a         	cmp	r2, r3
 80271c6: bf0c         	ite	eq
 80271c8: 2301         	moveq	r3, #0x1
 80271ca: 2300         	movne	r3, #0x0
 80271cc: b2db         	uxtb	r3, r3
; }
 80271ce: 4618         	mov	r0, r3
 80271d0: 370c         	adds	r7, #0xc
 80271d2: 46bd         	mov	sp, r7
 80271d4: f85d 7b04    	ldr	r7, [sp], #4
 80271d8: 4770         	bx	lr

080271da <sys_dlist_peek_head>:
; {
 80271da: b580         	push	{r7, lr}
 80271dc: b082         	sub	sp, #0x8
 80271de: af00         	add	r7, sp, #0x0
 80271e0: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 80271e2: 6878         	ldr	r0, [r7, #0x4]
 80271e4: f7ff ffe7    	bl	0x80271b6 <sys_dlist_is_empty> @ imm = #-0x32
 80271e8: 4603         	mov	r3, r0
 80271ea: 2b00         	cmp	r3, #0x0
 80271ec: d102         	bne	0x80271f4 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 80271ee: 687b         	ldr	r3, [r7, #0x4]
 80271f0: 681b         	ldr	r3, [r3]
 80271f2: e000         	b	0x80271f6 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 80271f4: 2300         	movs	r3, #0x0
; }
 80271f6: 4618         	mov	r0, r3
 80271f8: 3708         	adds	r7, #0x8
 80271fa: 46bd         	mov	sp, r7
 80271fc: bd80         	pop	{r7, pc}

080271fe <k_object_init>:
; {
 80271fe: b480         	push	{r7}
 8027200: b083         	sub	sp, #0xc
 8027202: af00         	add	r7, sp, #0x0
 8027204: 6078         	str	r0, [r7, #0x4]
; }
 8027206: bf00         	nop
 8027208: 370c         	adds	r7, #0xc
 802720a: 46bd         	mov	sp, r7
 802720c: f85d 7b04    	ldr	r7, [sp], #4
 8027210: 4770         	bx	lr

08027212 <k_uptime_ticks>:
; {
 8027212: b580         	push	{r7, lr}
 8027214: af00         	add	r7, sp, #0x0
; 	return z_impl_k_uptime_ticks();
 8027216: f7ff fee8    	bl	0x8026fea <z_impl_k_uptime_ticks> @ imm = #-0x230
 802721a: 4602         	mov	r2, r0
 802721c: 460b         	mov	r3, r1
; }
 802721e: 4610         	mov	r0, r2
 8027220: 4619         	mov	r1, r3
 8027222: bd80         	pop	{r7, pc}

08027224 <z_init_timeout>:
; {
 8027224: b580         	push	{r7, lr}
 8027226: b082         	sub	sp, #0x8
 8027228: af00         	add	r7, sp, #0x0
 802722a: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 802722c: 687b         	ldr	r3, [r7, #0x4]
 802722e: 4618         	mov	r0, r3
 8027230: f7ff ffa0    	bl	0x8027174 <sys_dnode_init> @ imm = #-0xc0
; }
 8027234: bf00         	nop
 8027236: 3708         	adds	r7, #0x8
 8027238: 46bd         	mov	sp, r7
 802723a: bd80         	pop	{r7, pc}

0802723c <z_reschedule_unlocked>:
; {
 802723c: b580         	push	{r7, lr}
 802723e: b084         	sub	sp, #0x10
 8027240: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8027242: f3ef 8311    	mrs	r3, basepri
 8027246: 60fb         	str	r3, [r7, #0xc]
;   return(result);
 8027248: 68fb         	ldr	r3, [r7, #0xc]
; 	key = __get_BASEPRI();
 802724a: 60bb         	str	r3, [r7, #0x8]
 802724c: 2310         	movs	r3, #0x10
 802724e: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8027250: 687b         	ldr	r3, [r7, #0x4]
 8027252: f383 8812    	msr	basepri_max, r3
; }
 8027256: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8027258: f3bf 8f6f    	isb	sy
; }
 802725c: bf00         	nop
; 	return key;
 802725e: 68bb         	ldr	r3, [r7, #0x8]
; 	(void) z_reschedule_irqlock(arch_irq_lock());
 8027260: 4618         	mov	r0, r3
 8027262: f7ff fcb5    	bl	0x8026bd0 <z_reschedule_irqlock> @ imm = #-0x696
; }
 8027266: bf00         	nop
 8027268: 3710         	adds	r7, #0x10
 802726a: 46bd         	mov	sp, r7
 802726c: bd80         	pop	{r7, pc}

0802726e <z_waitq_init>:
; {
 802726e: b580         	push	{r7, lr}
 8027270: b082         	sub	sp, #0x8
 8027272: af00         	add	r7, sp, #0x0
 8027274: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8027276: 687b         	ldr	r3, [r7, #0x4]
 8027278: 4618         	mov	r0, r3
 802727a: f7ff ff6b    	bl	0x8027154 <sys_dlist_init> @ imm = #-0x12a
; }
 802727e: bf00         	nop
 8027280: 3708         	adds	r7, #0x8
 8027282: 46bd         	mov	sp, r7
 8027284: bd80         	pop	{r7, pc}

08027286 <z_waitq_head>:
; {
 8027286: b580         	push	{r7, lr}
 8027288: b082         	sub	sp, #0x8
 802728a: af00         	add	r7, sp, #0x0
 802728c: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 802728e: 687b         	ldr	r3, [r7, #0x4]
 8027290: 4618         	mov	r0, r3
 8027292: f7ff ffa2    	bl	0x80271da <sys_dlist_peek_head> @ imm = #-0xbc
 8027296: 4603         	mov	r3, r0
; }
 8027298: 4618         	mov	r0, r3
 802729a: 3708         	adds	r7, #0x8
 802729c: 46bd         	mov	sp, r7
 802729e: bd80         	pop	{r7, pc}

080272a0 <k_timer_init>:
; {
 80272a0: b580         	push	{r7, lr}
 80272a2: b084         	sub	sp, #0x10
 80272a4: af00         	add	r7, sp, #0x0
 80272a6: 60f8         	str	r0, [r7, #0xc]
 80272a8: 60b9         	str	r1, [r7, #0x8]
 80272aa: 607a         	str	r2, [r7, #0x4]
; 	timer->expiry_fn = expiry_fn;
 80272ac: 68fb         	ldr	r3, [r7, #0xc]
 80272ae: 68ba         	ldr	r2, [r7, #0x8]
 80272b0: 621a         	str	r2, [r3, #0x20]
; 	timer->stop_fn = stop_fn;
 80272b2: 68fb         	ldr	r3, [r7, #0xc]
 80272b4: 687a         	ldr	r2, [r7, #0x4]
 80272b6: 625a         	str	r2, [r3, #0x24]
; 	timer->status = 0U;
 80272b8: 68fb         	ldr	r3, [r7, #0xc]
 80272ba: 2200         	movs	r2, #0x0
 80272bc: 631a         	str	r2, [r3, #0x30]
; 		z_waitq_init(&timer->wait_q);
 80272be: 68fb         	ldr	r3, [r7, #0xc]
 80272c0: 3318         	adds	r3, #0x18
 80272c2: 4618         	mov	r0, r3
 80272c4: f7ff ffd3    	bl	0x802726e <z_waitq_init> @ imm = #-0x5a
; 	z_init_timeout(&timer->timeout);
 80272c8: 68fb         	ldr	r3, [r7, #0xc]
 80272ca: 4618         	mov	r0, r3
 80272cc: f7ff ffaa    	bl	0x8027224 <z_init_timeout> @ imm = #-0xac
; 	timer->user_data = NULL;
 80272d0: 68fb         	ldr	r3, [r7, #0xc]
 80272d2: 2200         	movs	r2, #0x0
 80272d4: 635a         	str	r2, [r3, #0x34]
; 	k_object_init(timer);
 80272d6: 68f8         	ldr	r0, [r7, #0xc]
 80272d8: f7ff ff91    	bl	0x80271fe <k_object_init> @ imm = #-0xde
; }
 80272dc: bf00         	nop
 80272de: 3710         	adds	r7, #0x10
 80272e0: 46bd         	mov	sp, r7
 80272e2: bd80         	pop	{r7, pc}

080272e4 <z_impl_k_timer_stop>:
; {
 80272e4: b580         	push	{r7, lr}
 80272e6: b084         	sub	sp, #0x10
 80272e8: af00         	add	r7, sp, #0x0
 80272ea: 6078         	str	r0, [r7, #0x4]
; 	bool inactive = (z_abort_timeout(&timer->timeout) != 0);
 80272ec: 687b         	ldr	r3, [r7, #0x4]
 80272ee: 4618         	mov	r0, r3
 80272f0: f7ef fd88    	bl	0x8016e04 <z_abort_timeout> @ imm = #-0x104f0
 80272f4: 4603         	mov	r3, r0
 80272f6: 2b00         	cmp	r3, #0x0
 80272f8: bf14         	ite	ne
 80272fa: 2301         	movne	r3, #0x1
 80272fc: 2300         	moveq	r3, #0x0
 80272fe: 73fb         	strb	r3, [r7, #0xf]
; 	if (inactive) {
 8027300: 7bfb         	ldrb	r3, [r7, #0xf]
 8027302: 2b00         	cmp	r3, #0x0
 8027304: d116         	bne	0x8027334 <z_impl_k_timer_stop+0x50> @ imm = #0x2c
; 	if (timer->stop_fn != NULL) {
 8027306: 687b         	ldr	r3, [r7, #0x4]
 8027308: 6a5b         	ldr	r3, [r3, #0x24]
 802730a: 2b00         	cmp	r3, #0x0
 802730c: d003         	beq	0x8027316 <z_impl_k_timer_stop+0x32> @ imm = #0x6
; 		timer->stop_fn(timer);
 802730e: 687b         	ldr	r3, [r7, #0x4]
 8027310: 6a5b         	ldr	r3, [r3, #0x24]
 8027312: 6878         	ldr	r0, [r7, #0x4]
 8027314: 4798         	blx	r3
; 		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
 8027316: 687b         	ldr	r3, [r7, #0x4]
 8027318: 3318         	adds	r3, #0x18
 802731a: 4618         	mov	r0, r3
 802731c: f7ee fb26    	bl	0x801596c <z_unpend1_no_timeout> @ imm = #-0x119b4
 8027320: 60b8         	str	r0, [r7, #0x8]
; 		if (pending_thread != NULL) {
 8027322: 68bb         	ldr	r3, [r7, #0x8]
 8027324: 2b00         	cmp	r3, #0x0
 8027326: d006         	beq	0x8027336 <z_impl_k_timer_stop+0x52> @ imm = #0xc
; 			z_ready_thread(pending_thread);
 8027328: 68b8         	ldr	r0, [r7, #0x8]
 802732a: f7ed fed7    	bl	0x80150dc <z_ready_thread> @ imm = #-0x12252
; 			z_reschedule_unlocked();
 802732e: f7ff ff85    	bl	0x802723c <z_reschedule_unlocked> @ imm = #-0xf6
 8027332: e000         	b	0x8027336 <z_impl_k_timer_stop+0x52> @ imm = #0x0
; 		return;
 8027334: bf00         	nop
; }
 8027336: 3710         	adds	r7, #0x10
 8027338: 46bd         	mov	sp, r7
 802733a: bd80         	pop	{r7, pc}

0802733c <arch_k_cycle_get_32>:
; {
 802733c: b580         	push	{r7, lr}
 802733e: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 8027340: f7e8 f8b6    	bl	0x800f4b0 <sys_clock_cycle_get_32> @ imm = #-0x17e94
 8027344: 4603         	mov	r3, r0
; }
 8027346: 4618         	mov	r0, r3
 8027348: bd80         	pop	{r7, pc}

0802734a <k_cycle_get_32>:
; {
 802734a: b580         	push	{r7, lr}
 802734c: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 802734e: f7ff fff5    	bl	0x802733c <arch_k_cycle_get_32> @ imm = #-0x16
 8027352: 4603         	mov	r3, r0
; }
 8027354: 4618         	mov	r0, r3
 8027356: bd80         	pop	{r7, pc}

08027358 <usage_now>:
; {
 8027358: b580         	push	{r7, lr}
 802735a: b082         	sub	sp, #0x8
 802735c: af00         	add	r7, sp, #0x0
; 	now = k_cycle_get_32();
 802735e: f7ff fff4    	bl	0x802734a <k_cycle_get_32> @ imm = #-0x18
 8027362: 6078         	str	r0, [r7, #0x4]
; 	return (now == 0) ? 1 : now;
 8027364: 687b         	ldr	r3, [r7, #0x4]
 8027366: 2b00         	cmp	r3, #0x0
 8027368: d001         	beq	0x802736e <usage_now+0x16> @ imm = #0x2
 802736a: 687b         	ldr	r3, [r7, #0x4]
 802736c: e000         	b	0x8027370 <usage_now+0x18> @ imm = #0x0
 802736e: 2301         	movs	r3, #0x1
; }
 8027370: 4618         	mov	r0, r3
 8027372: 3708         	adds	r7, #0x8
 8027374: 46bd         	mov	sp, r7
 8027376: bd80         	pop	{r7, pc}

08027378 <sched_cpu_update_usage>:
; {
 8027378: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 802737c: b083         	sub	sp, #0xc
 802737e: af00         	add	r7, sp, #0x0
 8027380: 6078         	str	r0, [r7, #0x4]
 8027382: 6039         	str	r1, [r7]
; 	if (!cpu->usage->track_usage) {
 8027384: 687b         	ldr	r3, [r7, #0x4]
 8027386: 69db         	ldr	r3, [r3, #0x1c]
 8027388: 7a1b         	ldrb	r3, [r3, #0x8]
 802738a: f083 0301    	eor	r3, r3, #0x1
 802738e: b2db         	uxtb	r3, r3
 8027390: 2b00         	cmp	r3, #0x0
 8027392: d116         	bne	0x80273c2 <sched_cpu_update_usage+0x4a> @ imm = #0x2c
; 	if (cpu->current != cpu->idle_thread) {
 8027394: 687b         	ldr	r3, [r7, #0x4]
 8027396: 689a         	ldr	r2, [r3, #0x8]
 8027398: 687b         	ldr	r3, [r7, #0x4]
 802739a: 68db         	ldr	r3, [r3, #0xc]
 802739c: 429a         	cmp	r2, r3
 802739e: d011         	beq	0x80273c4 <sched_cpu_update_usage+0x4c> @ imm = #0x22
; 		cpu->usage->total += cycles;
 80273a0: 687b         	ldr	r3, [r7, #0x4]
 80273a2: 69db         	ldr	r3, [r3, #0x1c]
 80273a4: e9d3 2300    	ldrd	r2, r3, [r3]
 80273a8: 6839         	ldr	r1, [r7]
 80273aa: 2000         	movs	r0, #0x0
 80273ac: 460c         	mov	r4, r1
 80273ae: 4605         	mov	r5, r0
 80273b0: 6879         	ldr	r1, [r7, #0x4]
 80273b2: 69c9         	ldr	r1, [r1, #0x1c]
 80273b4: eb12 0804    	adds.w	r8, r2, r4
 80273b8: eb43 0905    	adc.w	r9, r3, r5
 80273bc: e9c1 8900    	strd	r8, r9, [r1]
 80273c0: e000         	b	0x80273c4 <sched_cpu_update_usage+0x4c> @ imm = #0x0
; 		return;
 80273c2: bf00         	nop
; }
 80273c4: 370c         	adds	r7, #0xc
 80273c6: 46bd         	mov	sp, r7
 80273c8: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 80273cc: 4770         	bx	lr

080273ce <sched_thread_update_usage>:
; {
 80273ce: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 80273d2: b083         	sub	sp, #0xc
 80273d4: af00         	add	r7, sp, #0x0
 80273d6: 6078         	str	r0, [r7, #0x4]
 80273d8: 6039         	str	r1, [r7]
; 	thread->base.usage.total += cycles;
 80273da: 687b         	ldr	r3, [r7, #0x4]
 80273dc: e9d3 230c    	ldrd	r2, r3, [r3, #48]
 80273e0: 6839         	ldr	r1, [r7]
 80273e2: 2000         	movs	r0, #0x0
 80273e4: 460c         	mov	r4, r1
 80273e6: 4605         	mov	r5, r0
 80273e8: eb12 0804    	adds.w	r8, r2, r4
 80273ec: eb43 0905    	adc.w	r9, r3, r5
 80273f0: 687b         	ldr	r3, [r7, #0x4]
 80273f2: e9c3 890c    	strd	r8, r9, [r3, #48]
; }
 80273f6: bf00         	nop
 80273f8: 370c         	adds	r7, #0xc
 80273fa: 46bd         	mov	sp, r7
 80273fc: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 8027400: 4770         	bx	lr

08027402 <size_add_overflow>:
; {
 8027402: b480         	push	{r7}
 8027404: b085         	sub	sp, #0x14
 8027406: af00         	add	r7, sp, #0x0
 8027408: 60f8         	str	r0, [r7, #0xc]
 802740a: 60b9         	str	r1, [r7, #0x8]
 802740c: 607a         	str	r2, [r7, #0x4]
; 	return __builtin_add_overflow(a, b, result);
 802740e: 2100         	movs	r1, #0x0
 8027410: 68fb         	ldr	r3, [r7, #0xc]
 8027412: 68ba         	ldr	r2, [r7, #0x8]
 8027414: 189b         	adds	r3, r3, r2
 8027416: d300         	blo	0x802741a <size_add_overflow+0x18> @ imm = #0x0
 8027418: 2101         	movs	r1, #0x1
 802741a: 461a         	mov	r2, r3
 802741c: 687b         	ldr	r3, [r7, #0x4]
 802741e: 601a         	str	r2, [r3]
 8027420: 460b         	mov	r3, r1
 8027422: f003 0301    	and	r3, r3, #0x1
 8027426: b2db         	uxtb	r3, r3
; }
 8027428: 4618         	mov	r0, r3
 802742a: 3714         	adds	r7, #0x14
 802742c: 46bd         	mov	sp, r7
 802742e: f85d 7b04    	ldr	r7, [sp], #4
 8027432: 4770         	bx	lr

08027434 <z_heap_aligned_alloc>:
; {
 8027434: b580         	push	{r7, lr}
 8027436: b08a         	sub	sp, #0x28
 8027438: af02         	add	r7, sp, #0x8
 802743a: 60f8         	str	r0, [r7, #0xc]
 802743c: 60b9         	str	r1, [r7, #0x8]
 802743e: 607a         	str	r2, [r7, #0x4]
; 	if (size_add_overflow(size, sizeof(heap_ref), &size)) {
 8027440: 687b         	ldr	r3, [r7, #0x4]
 8027442: 1d3a         	adds	r2, r7, #0x4
 8027444: 2104         	movs	r1, #0x4
 8027446: 4618         	mov	r0, r3
 8027448: f7ff ffdb    	bl	0x8027402 <size_add_overflow> @ imm = #-0x4a
 802744c: 4603         	mov	r3, r0
 802744e: 2b00         	cmp	r3, #0x0
 8027450: d001         	beq	0x8027456 <z_heap_aligned_alloc+0x22> @ imm = #0x2
; 		return NULL;
 8027452: 2300         	movs	r3, #0x0
 8027454: e020         	b	0x8027498 <z_heap_aligned_alloc+0x64> @ imm = #0x40
; 	__align = align | sizeof(heap_ref);
 8027456: 68bb         	ldr	r3, [r7, #0x8]
 8027458: f043 0304    	orr	r3, r3, #0x4
 802745c: 61fb         	str	r3, [r7, #0x1c]
; 	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
 802745e: 687b         	ldr	r3, [r7, #0x4]
 8027460: f04f 0000    	mov.w	r0, #0x0
 8027464: f04f 0100    	mov.w	r1, #0x0
 8027468: e9cd 0100    	strd	r0, r1, [sp]
 802746c: 461a         	mov	r2, r3
 802746e: 69f9         	ldr	r1, [r7, #0x1c]
 8027470: 68f8         	ldr	r0, [r7, #0xc]
 8027472: f7fd f9c5    	bl	0x8024800 <k_heap_aligned_alloc> @ imm = #-0x2c76
 8027476: 61b8         	str	r0, [r7, #0x18]
; 	if (mem == NULL) {
 8027478: 69bb         	ldr	r3, [r7, #0x18]
 802747a: 2b00         	cmp	r3, #0x0
 802747c: d101         	bne	0x8027482 <z_heap_aligned_alloc+0x4e> @ imm = #0x2
; 		return NULL;
 802747e: 2300         	movs	r3, #0x0
 8027480: e00a         	b	0x8027498 <z_heap_aligned_alloc+0x64> @ imm = #0x14
; 	heap_ref = mem;
 8027482: 69bb         	ldr	r3, [r7, #0x18]
 8027484: 617b         	str	r3, [r7, #0x14]
; 	*heap_ref = heap;
 8027486: 697b         	ldr	r3, [r7, #0x14]
 8027488: 68fa         	ldr	r2, [r7, #0xc]
 802748a: 601a         	str	r2, [r3]
; 	mem = ++heap_ref;
 802748c: 697b         	ldr	r3, [r7, #0x14]
 802748e: 3304         	adds	r3, #0x4
 8027490: 617b         	str	r3, [r7, #0x14]
 8027492: 697b         	ldr	r3, [r7, #0x14]
 8027494: 61bb         	str	r3, [r7, #0x18]
; 	return mem;
 8027496: 69bb         	ldr	r3, [r7, #0x18]
; }
 8027498: 4618         	mov	r0, r3
 802749a: 3720         	adds	r7, #0x20
 802749c: 46bd         	mov	sp, r7
 802749e: bd80         	pop	{r7, pc}

080274a0 <k_free>:
; {
 80274a0: b580         	push	{r7, lr}
 80274a2: b084         	sub	sp, #0x10
 80274a4: af00         	add	r7, sp, #0x0
 80274a6: 6078         	str	r0, [r7, #0x4]
; 	if (ptr != NULL) {
 80274a8: 687b         	ldr	r3, [r7, #0x4]
 80274aa: 2b00         	cmp	r3, #0x0
 80274ac: d00c         	beq	0x80274c8 <k_free+0x28> @ imm = #0x18
; 		heap_ref = ptr;
 80274ae: 687b         	ldr	r3, [r7, #0x4]
 80274b0: 60fb         	str	r3, [r7, #0xc]
; 		--heap_ref;
 80274b2: 68fb         	ldr	r3, [r7, #0xc]
 80274b4: 3b04         	subs	r3, #0x4
 80274b6: 60fb         	str	r3, [r7, #0xc]
; 		ptr = heap_ref;
 80274b8: 68fb         	ldr	r3, [r7, #0xc]
 80274ba: 607b         	str	r3, [r7, #0x4]
; 		k_heap_free(*heap_ref, ptr);
 80274bc: 68fb         	ldr	r3, [r7, #0xc]
 80274be: 681b         	ldr	r3, [r3]
 80274c0: 6879         	ldr	r1, [r7, #0x4]
 80274c2: 4618         	mov	r0, r3
 80274c4: f7fd fa32    	bl	0x802492c <k_heap_free> @ imm = #-0x2b9c
; }
 80274c8: bf00         	nop
 80274ca: 3710         	adds	r7, #0x10
 80274cc: 46bd         	mov	sp, r7
 80274ce: bd80         	pop	{r7, pc}

080274d0 <k_malloc>:
; {
 80274d0: b580         	push	{r7, lr}
 80274d2: b084         	sub	sp, #0x10
 80274d4: af00         	add	r7, sp, #0x0
 80274d6: 6078         	str	r0, [r7, #0x4]
; 	void *ret = k_aligned_alloc(sizeof(void *), size);
 80274d8: 6879         	ldr	r1, [r7, #0x4]
 80274da: 2004         	movs	r0, #0x4
 80274dc: f7f0 f944    	bl	0x8017768 <k_aligned_alloc> @ imm = #-0xfd78
 80274e0: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 80274e2: 68fb         	ldr	r3, [r7, #0xc]
; }
 80274e4: 4618         	mov	r0, r3
 80274e6: 3710         	adds	r7, #0x10
 80274e8: 46bd         	mov	sp, r7
 80274ea: bd80         	pop	{r7, pc}

080274ec <memcpy>:
 80274ec: 440a         	add	r2, r1
 80274ee: 4291         	cmp	r1, r2
 80274f0: f100 33ff    	add.w	r3, r0, #0xffffffff
 80274f4: d100         	bne	0x80274f8 <memcpy+0xc>  @ imm = #0x0
 80274f6: 4770         	bx	lr
 80274f8: b510         	push	{r4, lr}
 80274fa: f811 4b01    	ldrb	r4, [r1], #1
 80274fe: f803 4f01    	strb	r4, [r3, #1]!
 8027502: 4291         	cmp	r1, r2
 8027504: d1f9         	bne	0x80274fa <memcpy+0xe>  @ imm = #-0xe
 8027506: bd10         	pop	{r4, pc}

08027508 <memset>:
 8027508: 4402         	add	r2, r0
 802750a: 4603         	mov	r3, r0
 802750c: 4293         	cmp	r3, r2
 802750e: d100         	bne	0x8027512 <memset+0xa>  @ imm = #0x0
 8027510: 4770         	bx	lr
 8027512: f803 1b01    	strb	r1, [r3], #1
 8027516: e7f9         	b	0x802750c <memset+0x4>  @ imm = #-0xe

08027518 <strncpy>:
 8027518: b510         	push	{r4, lr}
 802751a: 3901         	subs	r1, #0x1
 802751c: 4604         	mov	r4, r0
 802751e: b132         	cbz	r2, 0x802752e <strncpy+0x16> @ imm = #0xc
 8027520: f811 3f01    	ldrb	r3, [r1, #1]!
 8027524: f800 3b01    	strb	r3, [r0], #1
 8027528: 3a01         	subs	r2, #0x1
 802752a: 2b00         	cmp	r3, #0x0
 802752c: d1f7         	bne	0x802751e <strncpy+0x6> @ imm = #-0x12
 802752e: 2100         	movs	r1, #0x0
 8027530: f7ff ffea    	bl	0x8027508 <memset>      @ imm = #-0x2c
 8027534: 4620         	mov	r0, r4
 8027536: bd10         	pop	{r4, pc}

08027538 <strnlen>:
 8027538: b510         	push	{r4, lr}
 802753a: 4602         	mov	r2, r0
 802753c: 4401         	add	r1, r0
 802753e: 428a         	cmp	r2, r1
 8027540: 4613         	mov	r3, r2
 8027542: d003         	beq	0x802754c <strnlen+0x14> @ imm = #0x6
 8027544: 781c         	ldrb	r4, [r3]
 8027546: 3201         	adds	r2, #0x1
 8027548: 2c00         	cmp	r4, #0x0
 802754a: d1f8         	bne	0x802753e <strnlen+0x6> @ imm = #-0x10
 802754c: 1a18         	subs	r0, r3, r0
 802754e: bd10         	pop	{r4, pc}

08027550 <__ultoa_invert>:
 8027550: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 8027554: f1c3 0937    	rsb.w	r9, r3, #0x37
 8027558: 4607         	mov	r7, r0
 802755a: 4688         	mov	r8, r1
 802755c: fa5f f989    	uxtb.w	r9, r9
 8027560: f003 051f    	and	r5, r3, #0x1f
 8027564: 4616         	mov	r6, r2
 8027566: f04f 0a00    	mov.w	r10, #0x0
 802756a: 4638         	mov	r0, r7
 802756c: 4641         	mov	r1, r8
 802756e: 462a         	mov	r2, r5
 8027570: 4653         	mov	r3, r10
 8027572: f7d9 f865    	bl	0x8000640 <__aeabi_uldivmod> @ imm = #-0x26f36
 8027576: b2d4         	uxtb	r4, r2
 8027578: 2c09         	cmp	r4, #0x9
 802757a: bf88         	it	hi
 802757c: 444c         	addhi	r4, r9
 802757e: 463a         	mov	r2, r7
 8027580: 4643         	mov	r3, r8
 8027582: bf88         	it	hi
 8027584: b2e4         	uxtbhi	r4, r4
 8027586: 42aa         	cmp	r2, r5
 8027588: f104 0430    	add.w	r4, r4, #0x30
 802758c: eb73 030a    	sbcs.w	r3, r3, r10
 8027590: f806 4b01    	strb	r4, [r6], #1
 8027594: 4607         	mov	r7, r0
 8027596: 4688         	mov	r8, r1
 8027598: d2e7         	bhs	0x802756a <__ultoa_invert+0x1a> @ imm = #-0x32
 802759a: 4630         	mov	r0, r6
 802759c: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}

080275a0 <mulShiftAll64>:
 80275a0: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80275a4: b089         	sub	sp, #0x24
 80275a6: 1806         	adds	r6, r0, r0
 80275a8: 4699         	mov	r9, r3
 80275aa: ab04         	add	r3, sp, #0x10
 80275ac: eb41 0401    	adc.w	r4, r1, r1
 80275b0: 9300         	str	r3, [sp]
 80275b2: 4615         	mov	r5, r2
 80275b4: 4630         	mov	r0, r6
 80275b6: e9d2 2300    	ldrd	r2, r3, [r2]
 80275ba: 4621         	mov	r1, r4
 80275bc: f8dd b04c    	ldr.w	r11, [sp, #0x4c]
 80275c0: f000 f8ab    	bl	0x802771a <__umul128>   @ imm = #0x156
 80275c4: ab06         	add	r3, sp, #0x18
 80275c6: 9300         	str	r3, [sp]
 80275c8: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 80275cc: 4607         	mov	r7, r0
 80275ce: 4688         	mov	r8, r1
 80275d0: 4630         	mov	r0, r6
 80275d2: 4621         	mov	r1, r4
 80275d4: f000 f8a1    	bl	0x802771a <__umul128>   @ imm = #0x142
 80275d8: e9dd 6304    	ldrd	r6, r3, [sp, #16]
 80275dc: 1984         	adds	r4, r0, r6
 80275de: eb51 0603    	adcs.w	r6, r1, r3
 80275e2: 9b06         	ldr	r3, [sp, #0x18]
 80275e4: e9d5 0100    	ldrd	r0, r1, [r5]
 80275e8: f04f 0200    	mov.w	r2, #0x0
 80275ec: bf28         	it	hs
 80275ee: 2201         	movhs	r2, #0x1
 80275f0: 18d2         	adds	r2, r2, r3
 80275f2: 9b07         	ldr	r3, [sp, #0x1c]
 80275f4: f143 0300    	adc	r3, r3, #0x0
 80275f8: 1838         	adds	r0, r7, r0
 80275fa: eb48 0101    	adc.w	r1, r8, r1
 80275fe: 42b8         	cmp	r0, r7
 8027600: eb71 0108    	sbcs.w	r1, r1, r8
 8027604: 68e9         	ldr	r1, [r5, #0xc]
 8027606: 9103         	str	r1, [sp, #0xc]
 8027608: 68a9         	ldr	r1, [r5, #0x8]
 802760a: bf34         	ite	lo
 802760c: 2001         	movlo	r0, #0x1
 802760e: 2000         	movhs	r0, #0x0
 8027610: eb14 0c01    	adds.w	r12, r4, r1
 8027614: 9903         	ldr	r1, [sp, #0xc]
 8027616: eb46 0101    	adc.w	r1, r6, r1
 802761a: eb10 000c    	adds.w	r0, r0, r12
 802761e: f141 0100    	adc	r1, r1, #0x0
 8027622: 42a0         	cmp	r0, r4
 8027624: eb71 0c06    	sbcs.w	r12, r1, r6
 8027628: bf34         	ite	lo
 802762a: f04f 0c01    	movlo.w	r12, #0x1
 802762e: f04f 0c00    	movhs.w	r12, #0x0
 8027632: e9cd 2306    	strd	r2, r3, [sp, #24]
 8027636: f1a9 0a41    	sub.w	r10, r9, #0x41
 802763a: eb1c 0202    	adds.w	r2, r12, r2
 802763e: f143 0300    	adc	r3, r3, #0x0
 8027642: f8cd a000    	str.w	r10, [sp]
 8027646: f000 f883    	bl	0x8027750 <__shiftright128> @ imm = #0x106
 802764a: 9b12         	ldr	r3, [sp, #0x48]
 802764c: e9c3 0100    	strd	r0, r1, [r3]
 8027650: 9b14         	ldr	r3, [sp, #0x50]
 8027652: 2b01         	cmp	r3, #0x1
 8027654: e9dd 2306    	ldrd	r2, r3, [sp, #24]
 8027658: d129         	bne	0x80276ae <mulShiftAll64+0x10e> @ imm = #0x52
 802765a: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 802765e: e9d5 c500    	ldrd	r12, r5, [r5]
 8027662: 1a20         	subs	r0, r4, r0
 8027664: eb66 0101    	sbc.w	r1, r6, r1
 8027668: 4567         	cmp	r7, r12
 802766a: eb78 0505    	sbcs.w	r5, r8, r5
 802766e: bf34         	ite	lo
 8027670: 2501         	movlo	r5, #0x1
 8027672: 2500         	movhs	r5, #0x0
 8027674: 1b40         	subs	r0, r0, r5
 8027676: f161 0100    	sbc	r1, r1, #0x0
 802767a: 4284         	cmp	r4, r0
 802767c: eb76 0501    	sbcs.w	r5, r6, r1
 8027680: bf34         	ite	lo
 8027682: 2501         	movlo	r5, #0x1
 8027684: 2500         	movhs	r5, #0x0
 8027686: 1b52         	subs	r2, r2, r5
 8027688: f8cd a000    	str.w	r10, [sp]
 802768c: f163 0300    	sbc	r3, r3, #0x0
 8027690: f000 f85e    	bl	0x8027750 <__shiftright128> @ imm = #0xbc
 8027694: e9dd 2306    	ldrd	r2, r3, [sp, #24]
 8027698: e9cb 0100    	strd	r0, r1, [r11]
 802769c: f8cd a000    	str.w	r10, [sp]
 80276a0: 4620         	mov	r0, r4
 80276a2: 4631         	mov	r1, r6
 80276a4: f000 f854    	bl	0x8027750 <__shiftright128> @ imm = #0xa8
 80276a8: b009         	add	sp, #0x24
 80276aa: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80276ae: eb17 0e07    	adds.w	lr, r7, r7
 80276b2: eb48 0c08    	adc.w	r12, r8, r8
 80276b6: 1920         	adds	r0, r4, r4
 80276b8: eb46 0106    	adc.w	r1, r6, r6
 80276bc: 45be         	cmp	lr, r7
 80276be: eb7c 0808    	sbcs.w	r8, r12, r8
 80276c2: bf34         	ite	lo
 80276c4: 2701         	movlo	r7, #0x1
 80276c6: 2700         	movhs	r7, #0x0
 80276c8: 19c7         	adds	r7, r0, r7
 80276ca: f141 0800    	adc	r8, r1, #0x0
 80276ce: e9d5 0100    	ldrd	r0, r1, [r5]
 80276d2: 4586         	cmp	lr, r0
 80276d4: eb7c 0c01    	sbcs.w	r12, r12, r1
 80276d8: e9d5 1502    	ldrd	r1, r5, [r5, #8]
 80276dc: bf34         	ite	lo
 80276de: 2001         	movlo	r0, #0x1
 80276e0: 2000         	movhs	r0, #0x0
 80276e2: 1a38         	subs	r0, r7, r0
 80276e4: f168 0c00    	sbc	r12, r8, #0x0
 80276e8: 1a40         	subs	r0, r0, r1
 80276ea: eb6c 0105    	sbc.w	r1, r12, r5
 80276ee: 1892         	adds	r2, r2, r2
 80276f0: 415b         	adcs	r3, r3
 80276f2: 42a7         	cmp	r7, r4
 80276f4: eb78 0506    	sbcs.w	r5, r8, r6
 80276f8: bf34         	ite	lo
 80276fa: 2501         	movlo	r5, #0x1
 80276fc: 2500         	movhs	r5, #0x0
 80276fe: 1952         	adds	r2, r2, r5
 8027700: f143 0300    	adc	r3, r3, #0x0
 8027704: 4287         	cmp	r7, r0
 8027706: eb78 0801    	sbcs.w	r8, r8, r1
 802770a: bf34         	ite	lo
 802770c: 2501         	movlo	r5, #0x1
 802770e: 2500         	movhs	r5, #0x0
 8027710: 1b52         	subs	r2, r2, r5
 8027712: f1a9 0540    	sub.w	r5, r9, #0x40
 8027716: 9500         	str	r5, [sp]
 8027718: e7b8         	b	0x802768c <mulShiftAll64+0xec> @ imm = #-0x90

0802771a <__umul128>:
 802771a: b5f0         	push	{r4, r5, r6, r7, lr}
 802771c: 460f         	mov	r7, r1
 802771e: 4604         	mov	r4, r0
 8027720: fba0 0102    	umull	r0, r1, r0, r2
 8027724: fba7 5202    	umull	r5, r2, r7, r2
 8027728: 1949         	adds	r1, r1, r5
 802772a: fba3 4504    	umull	r4, r5, r3, r4
 802772e: f142 0200    	adc	r2, r2, #0x0
 8027732: fba7 7303    	umull	r7, r3, r7, r3
 8027736: 1861         	adds	r1, r4, r1
 8027738: f145 0400    	adc	r4, r5, #0x0
 802773c: 19d2         	adds	r2, r2, r7
 802773e: 9e05         	ldr	r6, [sp, #0x14]
 8027740: f143 0300    	adc	r3, r3, #0x0
 8027744: 1912         	adds	r2, r2, r4
 8027746: f143 0300    	adc	r3, r3, #0x0
 802774a: e9c6 2300    	strd	r2, r3, [r6]
 802774e: bdf0         	pop	{r4, r5, r6, r7, pc}

08027750 <__shiftright128>:
 8027750: b5f0         	push	{r4, r5, r6, r7, lr}
 8027752: 9c05         	ldr	r4, [sp, #0x14]
 8027754: f1c4 0740    	rsb.w	r7, r4, #0x40
 8027758: f1c4 0620    	rsb.w	r6, r4, #0x20
 802775c: fa02 f606    	lsl.w	r6, r2, r6
 8027760: f1a4 0520    	sub.w	r5, r4, #0x20
 8027764: 40bb         	lsls	r3, r7
 8027766: fa22 f505    	lsr.w	r5, r2, r5
 802776a: 4333         	orrs	r3, r6
 802776c: f1c4 0620    	rsb.w	r6, r4, #0x20
 8027770: 432b         	orrs	r3, r5
 8027772: fa01 f606    	lsl.w	r6, r1, r6
 8027776: f1a4 0520    	sub.w	r5, r4, #0x20
 802777a: 40e0         	lsrs	r0, r4
 802777c: fa21 f505    	lsr.w	r5, r1, r5
 8027780: 4330         	orrs	r0, r6
 8027782: 40ba         	lsls	r2, r7
 8027784: 4328         	orrs	r0, r5
 8027786: 40e1         	lsrs	r1, r4
 8027788: 4310         	orrs	r0, r2
 802778a: 4319         	orrs	r1, r3
 802778c: bdf0         	pop	{r4, r5, r6, r7, pc}

0802778e <__dtox_engine>:
 802778e: e92d 43f0    	push.w	{r4, r5, r6, r7, r8, r9, lr}
 8027792: ec57 6b10    	vmov	r6, r7, d0
 8027796: 463b         	mov	r3, r7
 8027798: 4634         	mov	r4, r6
 802779a: f3c3 550a    	ubfx	r5, r3, #0x14, #0xb
 802779e: f3c3 0313    	ubfx	r3, r3, #0x0, #0x14
 80277a2: 0ffe         	lsrs	r6, r7, #0x1f
 80277a4: ea54 0c03    	orrs.w	r12, r4, r3
 80277a8: 7106         	strb	r6, [r0, #0x4]
 80277aa: f240 77ff    	movw	r7, #0x7ff
 80277ae: d007         	beq	0x80277c0 <__dtox_engine+0x32> @ imm = #0xe
 80277b0: 42bd         	cmp	r5, r7
 80277b2: d10c         	bne	0x80277ce <__dtox_engine+0x40> @ imm = #0x18
 80277b4: f046 0608    	orr	r6, r6, #0x8
 80277b8: 7106         	strb	r6, [r0, #0x4]
 80277ba: 2000         	movs	r0, #0x0
 80277bc: e8bd 83f0    	pop.w	{r4, r5, r6, r7, r8, r9, pc}
 80277c0: 2d00         	cmp	r5, #0x0
 80277c2: d063         	beq	0x802788c <__dtox_engine+0xfe> @ imm = #0xc6
 80277c4: 42bd         	cmp	r5, r7
 80277c6: d15e         	bne	0x8027886 <__dtox_engine+0xf8> @ imm = #0xbc
 80277c8: f046 0604    	orr	r6, r6, #0x4
 80277cc: e7f4         	b	0x80277b8 <__dtox_engine+0x2a> @ imm = #-0x18
 80277ce: 2d00         	cmp	r5, #0x0
 80277d0: d159         	bne	0x8027886 <__dtox_engine+0xf8> @ imm = #0xb2
 80277d2: 2501         	movs	r5, #0x1
 80277d4: f2a5 35ff    	subw	r5, r5, #0x3ff
 80277d8: 2900         	cmp	r1, #0x0
 80277da: 6005         	str	r5, [r0]
 80277dc: db59         	blt	0x8027892 <__dtox_engine+0x104> @ imm = #0xb2
 80277de: 290c         	cmp	r1, #0xc
 80277e0: dc59         	bgt	0x8027896 <__dtox_engine+0x108> @ imm = #0xb2
 80277e2: f1c1 050d    	rsb.w	r5, r1, #0xd
 80277e6: 00ad         	lsls	r5, r5, #0x2
 80277e8: 2601         	movs	r6, #0x1
 80277ea: f105 3eff    	add.w	lr, r5, #0xffffffff
 80277ee: f1a5 0c21    	sub.w	r12, r5, #0x21
 80277f2: f1c5 0721    	rsb.w	r7, r5, #0x21
 80277f6: fa26 f707    	lsr.w	r7, r6, r7
 80277fa: fa06 fc0c    	lsl.w	r12, r6, r12
 80277fe: fa06 f60e    	lsl.w	r6, r6, lr
 8027802: ea4c 0c07    	orr.w	r12, r12, r7
 8027806: 19b7         	adds	r7, r6, r6
 8027808: eb4c 090c    	adc.w	r9, r12, r12
 802780c: f1d7 0800    	rsbs.w	r8, r7, #0x0
 8027810: eb69 0e49    	sbc.w	lr, r9, r9, lsl #1
 8027814: 3f01         	subs	r7, #0x1
 8027816: f149 39ff    	adc	r9, r9, #0xffffffff
 802781a: 4027         	ands	r7, r4
 802781c: ea09 0903    	and.w	r9, r9, r3
 8027820: 42be         	cmp	r6, r7
 8027822: eb7c 0909    	sbcs.w	r9, r12, r9
 8027826: db0f         	blt	0x8027848 <__dtox_engine+0xba> @ imm = #0x1e
 8027828: f1c5 0920    	rsb.w	r9, r5, #0x20
 802782c: f1b5 0720    	subs.w	r7, r5, #0x20
 8027830: fa03 f909    	lsl.w	r9, r3, r9
 8027834: fa24 f505    	lsr.w	r5, r4, r5
 8027838: ea45 0509    	orr.w	r5, r5, r9
 802783c: bf5c         	itt	pl
 802783e: fa43 f707    	asrpl.w	r7, r3, r7
 8027842: 433d         	orrpl	r5, r7
 8027844: 07ed         	lsls	r5, r5, #0x1f
 8027846: d503         	bpl	0x8027850 <__dtox_engine+0xc2> @ imm = #0x6
 8027848: 19a6         	adds	r6, r4, r6
 802784a: 4634         	mov	r4, r6
 802784c: eb43 030c    	adc.w	r3, r3, r12
 8027850: ea04 0408    	and.w	r4, r4, r8
 8027854: ea03 030e    	and.w	r3, r3, lr
 8027858: f100 0512    	add.w	r5, r0, #0x12
 802785c: 260d         	movs	r6, #0xd
 802785e: 4608         	mov	r0, r1
 8027860: f1c2 0227    	rsb.w	r2, r2, #0x27
 8027864: f04f 0e30    	mov.w	lr, #0x30
 8027868: f004 010f    	and	r1, r4, #0xf
 802786c: 0924         	lsrs	r4, r4, #0x4
 802786e: ea44 7403    	orr.w	r4, r4, r3, lsl #28
 8027872: f106 3cff    	add.w	r12, r6, #0xffffffff
 8027876: 111b         	asrs	r3, r3, #0x4
 8027878: 1e6f         	subs	r7, r5, #0x1
 802787a: b9b1         	cbnz	r1, 0x80278aa <__dtox_engine+0x11c> @ imm = #0x2c
 802787c: 42b0         	cmp	r0, r6
 802787e: da0c         	bge	0x802789a <__dtox_engine+0x10c> @ imm = #0x18
 8027880: 4666         	mov	r6, r12
 8027882: 463d         	mov	r5, r7
 8027884: e7f0         	b	0x8027868 <__dtox_engine+0xda> @ imm = #-0x20
 8027886: f443 1380    	orr	r3, r3, #0x100000
 802788a: e7a3         	b	0x80277d4 <__dtox_engine+0x46> @ imm = #-0xba
 802788c: 462c         	mov	r4, r5
 802788e: 462b         	mov	r3, r5
 8027890: e7a2         	b	0x80277d8 <__dtox_engine+0x4a> @ imm = #-0xbc
 8027892: 2100         	movs	r1, #0x0
 8027894: e7e0         	b	0x8027858 <__dtox_engine+0xca> @ imm = #-0x40
 8027896: 210d         	movs	r1, #0xd
 8027898: e7de         	b	0x8027858 <__dtox_engine+0xca> @ imm = #-0x44
 802789a: f885 e000    	strb.w	lr, [r5]
 802789e: f11c 0101    	adds.w	r1, r12, #0x1
 80278a2: 4666         	mov	r6, r12
 80278a4: 463d         	mov	r5, r7
 80278a6: d1df         	bne	0x8027868 <__dtox_engine+0xda> @ imm = #-0x42
 80278a8: e788         	b	0x80277bc <__dtox_engine+0x2e> @ imm = #-0xf0
 80278aa: 2909         	cmp	r1, #0x9
 80278ac: bfc8         	it	gt
 80278ae: 1889         	addgt	r1, r1, r2
 80278b0: 3130         	adds	r1, #0x30
 80278b2: 42b0         	cmp	r0, r6
 80278b4: 7029         	strb	r1, [r5]
 80278b6: bfb8         	it	lt
 80278b8: 4630         	movlt	r0, r6
 80278ba: e7f0         	b	0x802789e <__dtox_engine+0x110> @ imm = #-0x20

080278bc <__file_str_put>:
 80278bc: e9d1 3204    	ldrd	r3, r2, [r1, #16]
 80278c0: 4293         	cmp	r3, r2
 80278c2: bf1e         	ittt	ne
 80278c4: 1c5a         	addne	r2, r3, #0x1
 80278c6: 610a         	strne	r2, [r1, #0x10]
 80278c8: 7018         	strbne	r0, [r3]
 80278ca: 4770         	bx	lr

080278cc <__aeabi_read_tp>:
; 	ldr r0, =z_arm_tls_ptr
 80278cc: 4801         	ldr	r0, [pc, #0x4]          @ 0x80278d4 <__aeabi_read_tp+0x8>
; 	ldr r0, [r0]
 80278ce: 6800         	ldr	r0, [r0]
; 	bx lr
 80278d0: 4770         	bx	lr

080278d2 <$d>:
 80278d2: 00 00        	.short	0x0000

080278d4 <$d>:
 80278d4: 24 2d 00 20  	.word	0x20002d24
