
build/zephyr/zephyr.elf:	file format elf32-littlearm

Disassembly of section rom_start:

08000000 <_vector_start>:
 8000000: 00 41 00 20  	.word	0x20004100
 8000004: 89 6d 00 08  	.word	0x08006d89
 8000008: f1 5f 00 08  	.word	0x08005ff1
 800000c: 75 6d 00 08  	.word	0x08006d75
 8000010: 75 6d 00 08  	.word	0x08006d75
 8000014: 75 6d 00 08  	.word	0x08006d75
 8000018: 75 6d 00 08  	.word	0x08006d75
 800001c: 00 00 00 00  	.word	0x00000000
 8000020: 00 00 00 00  	.word	0x00000000
 8000024: 00 00 00 00  	.word	0x00000000
 8000028: 00 00 00 00  	.word	0x00000000
 800002c: 35 6f 00 08  	.word	0x08006f35
 8000030: 75 6d 00 08  	.word	0x08006d75
 8000034: 00 00 00 00  	.word	0x00000000
 8000038: 89 6e 00 08  	.word	0x08006e89
 800003c: d9 e0 00 08  	.word	0x0800e0d9

08000040 <$d>:
 8000040: 6d 72 00 08  	.word	0x0800726d
 8000044: 6d 72 00 08  	.word	0x0800726d
 8000048: 6d 72 00 08  	.word	0x0800726d
 800004c: 6d 72 00 08  	.word	0x0800726d
 8000050: 6d 72 00 08  	.word	0x0800726d
 8000054: 6d 72 00 08  	.word	0x0800726d
 8000058: 6d 72 00 08  	.word	0x0800726d
 800005c: 6d 72 00 08  	.word	0x0800726d
 8000060: 6d 72 00 08  	.word	0x0800726d
 8000064: 6d 72 00 08  	.word	0x0800726d
 8000068: 6d 72 00 08  	.word	0x0800726d
 800006c: 6d 72 00 08  	.word	0x0800726d
 8000070: 6d 72 00 08  	.word	0x0800726d
 8000074: 6d 72 00 08  	.word	0x0800726d
 8000078: 6d 72 00 08  	.word	0x0800726d
 800007c: 6d 72 00 08  	.word	0x0800726d
 8000080: 6d 72 00 08  	.word	0x0800726d
 8000084: 6d 72 00 08  	.word	0x0800726d
 8000088: 6d 72 00 08  	.word	0x0800726d
 800008c: 6d 72 00 08  	.word	0x0800726d
 8000090: 6d 72 00 08  	.word	0x0800726d
 8000094: 6d 72 00 08  	.word	0x0800726d
 8000098: 6d 72 00 08  	.word	0x0800726d
 800009c: 6d 72 00 08  	.word	0x0800726d
 80000a0: 6d 72 00 08  	.word	0x0800726d
 80000a4: 6d 72 00 08  	.word	0x0800726d
 80000a8: 6d 72 00 08  	.word	0x0800726d
 80000ac: 6d 72 00 08  	.word	0x0800726d
 80000b0: 6d 72 00 08  	.word	0x0800726d
 80000b4: 6d 72 00 08  	.word	0x0800726d
 80000b8: 6d 72 00 08  	.word	0x0800726d
 80000bc: 6d 72 00 08  	.word	0x0800726d
 80000c0: 6d 72 00 08  	.word	0x0800726d
 80000c4: 6d 72 00 08  	.word	0x0800726d
 80000c8: 6d 72 00 08  	.word	0x0800726d
 80000cc: 6d 72 00 08  	.word	0x0800726d
 80000d0: 6d 72 00 08  	.word	0x0800726d
 80000d4: 6d 72 00 08  	.word	0x0800726d
 80000d8: 6d 72 00 08  	.word	0x0800726d
 80000dc: 6d 72 00 08  	.word	0x0800726d
 80000e0: 6d 72 00 08  	.word	0x0800726d
 80000e4: 6d 72 00 08  	.word	0x0800726d
 80000e8: 6d 72 00 08  	.word	0x0800726d
 80000ec: 6d 72 00 08  	.word	0x0800726d
 80000f0: 6d 72 00 08  	.word	0x0800726d
 80000f4: 6d 72 00 08  	.word	0x0800726d
 80000f8: 6d 72 00 08  	.word	0x0800726d
 80000fc: 6d 72 00 08  	.word	0x0800726d
 8000100: 6d 72 00 08  	.word	0x0800726d
 8000104: 6d 72 00 08  	.word	0x0800726d
 8000108: 6d 72 00 08  	.word	0x0800726d
 800010c: 6d 72 00 08  	.word	0x0800726d
 8000110: 6d 72 00 08  	.word	0x0800726d
 8000114: 6d 72 00 08  	.word	0x0800726d
 8000118: 6d 72 00 08  	.word	0x0800726d
 800011c: 6d 72 00 08  	.word	0x0800726d
 8000120: 6d 72 00 08  	.word	0x0800726d
 8000124: 6d 72 00 08  	.word	0x0800726d
 8000128: 6d 72 00 08  	.word	0x0800726d
 800012c: 6d 72 00 08  	.word	0x0800726d
 8000130: 6d 72 00 08  	.word	0x0800726d
 8000134: 6d 72 00 08  	.word	0x0800726d
 8000138: 6d 72 00 08  	.word	0x0800726d
 800013c: 6d 72 00 08  	.word	0x0800726d
 8000140: 6d 72 00 08  	.word	0x0800726d
 8000144: 6d 72 00 08  	.word	0x0800726d
 8000148: 6d 72 00 08  	.word	0x0800726d
 800014c: 6d 72 00 08  	.word	0x0800726d
 8000150: 6d 72 00 08  	.word	0x0800726d
 8000154: 6d 72 00 08  	.word	0x0800726d
 8000158: 6d 72 00 08  	.word	0x0800726d
 800015c: 6d 72 00 08  	.word	0x0800726d
 8000160: 6d 72 00 08  	.word	0x0800726d
 8000164: 6d 72 00 08  	.word	0x0800726d
 8000168: 6d 72 00 08  	.word	0x0800726d
 800016c: 6d 72 00 08  	.word	0x0800726d
 8000170: 6d 72 00 08  	.word	0x0800726d
 8000174: 6d 72 00 08  	.word	0x0800726d
 8000178: 6d 72 00 08  	.word	0x0800726d
 800017c: 6d 72 00 08  	.word	0x0800726d
 8000180: 6d 72 00 08  	.word	0x0800726d
 8000184: 6d 72 00 08  	.word	0x0800726d

Disassembly of section text:

08000188 <__text_region_start>:
 8000188: f081 4100    	eor	r1, r1, #0x80000000
 800018c: e002         	b	0x8000194 <__aeabi_dadd> @ imm = #0x4
 800018e: bf00         	nop

08000190 <__subdf3>:
 8000190: f083 4300    	eor	r3, r3, #0x80000000

08000194 <__aeabi_dadd>:
 8000194: b530         	push	{r4, r5, lr}
 8000196: ea4f 0441    	lsl.w	r4, r1, #0x1
 800019a: ea4f 0543    	lsl.w	r5, r3, #0x1
 800019e: ea94 0f05    	teq.w	r4, r5
 80001a2: bf08         	it	eq
 80001a4: ea90 0f02    	teqeq.w	r0, r2
 80001a8: bf1f         	itttt	ne
 80001aa: ea54 0c00    	orrsne.w	r12, r4, r0
 80001ae: ea55 0c02    	orrsne.w	r12, r5, r2
 80001b2: ea7f 5c64    	mvnsne.w	r12, r4, asr #21
 80001b6: ea7f 5c65    	mvnsne.w	r12, r5, asr #21
 80001ba: f000 80e2    	beq.w	0x8000382 <__aeabi_dadd+0x1ee> @ imm = #0x1c4
 80001be: ea4f 5454    	lsr.w	r4, r4, #0x15
 80001c2: ebd4 5555    	rsbs	r5, r4, r5, lsr #21
 80001c6: bfb8         	it	lt
 80001c8: 426d         	rsblt	r5, r5, #0
 80001ca: dd0c         	ble	0x80001e6 <__aeabi_dadd+0x52> @ imm = #0x18
 80001cc: 442c         	add	r4, r5
 80001ce: ea80 0202    	eor.w	r2, r0, r2
 80001d2: ea81 0303    	eor.w	r3, r1, r3
 80001d6: ea82 0000    	eor.w	r0, r2, r0
 80001da: ea83 0101    	eor.w	r1, r3, r1
 80001de: ea80 0202    	eor.w	r2, r0, r2
 80001e2: ea81 0303    	eor.w	r3, r1, r3
 80001e6: 2d36         	cmp	r5, #0x36
 80001e8: bf88         	it	hi
 80001ea: bd30         	pophi	{r4, r5, pc}
 80001ec: f011 4f00    	tst.w	r1, #0x80000000
 80001f0: ea4f 3101    	lsl.w	r1, r1, #0xc
 80001f4: f44f 1c80    	mov.w	r12, #0x100000
 80001f8: ea4c 3111    	orr.w	r1, r12, r1, lsr #12
 80001fc: d002         	beq	0x8000204 <__aeabi_dadd+0x70> @ imm = #0x4
 80001fe: 4240         	rsbs	r0, r0, #0
 8000200: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000204: f013 4f00    	tst.w	r3, #0x80000000
 8000208: ea4f 3303    	lsl.w	r3, r3, #0xc
 800020c: ea4c 3313    	orr.w	r3, r12, r3, lsr #12
 8000210: d002         	beq	0x8000218 <__aeabi_dadd+0x84> @ imm = #0x4
 8000212: 4252         	rsbs	r2, r2, #0
 8000214: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 8000218: ea94 0f05    	teq.w	r4, r5
 800021c: f000 80a7    	beq.w	0x800036e <__aeabi_dadd+0x1da> @ imm = #0x14e
 8000220: f1a4 0401    	sub.w	r4, r4, #0x1
 8000224: f1d5 0e20    	rsbs.w	lr, r5, #0x20
 8000228: db0d         	blt	0x8000246 <__aeabi_dadd+0xb2> @ imm = #0x1a
 800022a: fa02 fc0e    	lsl.w	r12, r2, lr
 800022e: fa22 f205    	lsr.w	r2, r2, r5
 8000232: 1880         	adds	r0, r0, r2
 8000234: f141 0100    	adc	r1, r1, #0x0
 8000238: fa03 f20e    	lsl.w	r2, r3, lr
 800023c: 1880         	adds	r0, r0, r2
 800023e: fa43 f305    	asr.w	r3, r3, r5
 8000242: 4159         	adcs	r1, r3
 8000244: e00e         	b	0x8000264 <__aeabi_dadd+0xd0> @ imm = #0x1c
 8000246: f1a5 0520    	sub.w	r5, r5, #0x20
 800024a: f10e 0e20    	add.w	lr, lr, #0x20
 800024e: 2a01         	cmp	r2, #0x1
 8000250: fa03 fc0e    	lsl.w	r12, r3, lr
 8000254: bf28         	it	hs
 8000256: f04c 0c02    	orrhs	r12, r12, #0x2
 800025a: fa43 f305    	asr.w	r3, r3, r5
 800025e: 18c0         	adds	r0, r0, r3
 8000260: eb51 71e3    	adcs.w	r1, r1, r3, asr #31
 8000264: f001 4500    	and	r5, r1, #0x80000000
 8000268: d507         	bpl	0x800027a <__aeabi_dadd+0xe6> @ imm = #0xe
 800026a: f04f 0e00    	mov.w	lr, #0x0
 800026e: f1dc 0c00    	rsbs.w	r12, r12, #0x0
 8000272: eb7e 0000    	sbcs.w	r0, lr, r0
 8000276: eb6e 0101    	sbc.w	r1, lr, r1
 800027a: f5b1 1f80    	cmp.w	r1, #0x100000
 800027e: d31b         	blo	0x80002b8 <__aeabi_dadd+0x124> @ imm = #0x36
 8000280: f5b1 1f00    	cmp.w	r1, #0x200000
 8000284: d30c         	blo	0x80002a0 <__aeabi_dadd+0x10c> @ imm = #0x18
 8000286: 0849         	lsrs	r1, r1, #0x1
 8000288: ea5f 0030    	rrxs	r0, r0
 800028c: ea4f 0c3c    	rrx	r12, r12
 8000290: f104 0401    	add.w	r4, r4, #0x1
 8000294: ea4f 5244    	lsl.w	r2, r4, #0x15
 8000298: f512 0f80    	cmn.w	r2, #0x400000
 800029c: f080 809a    	bhs.w	0x80003d4 <__aeabi_dadd+0x240> @ imm = #0x134
 80002a0: f1bc 4f00    	cmp.w	r12, #0x80000000
 80002a4: bf08         	it	eq
 80002a6: ea5f 0c50    	lsrseq.w	r12, r0, #0x1
 80002aa: f150 0000    	adcs	r0, r0, #0x0
 80002ae: eb41 5104    	adc.w	r1, r1, r4, lsl #20
 80002b2: ea41 0105    	orr.w	r1, r1, r5
 80002b6: bd30         	pop	{r4, r5, pc}
 80002b8: ea5f 0c4c    	lsls.w	r12, r12, #0x1
 80002bc: 4140         	adcs	r0, r0
 80002be: eb41 0101    	adc.w	r1, r1, r1
 80002c2: 3c01         	subs	r4, #0x1
 80002c4: bf28         	it	hs
 80002c6: f5b1 1f80    	cmphs.w	r1, #0x100000
 80002ca: d2e9         	bhs	0x80002a0 <__aeabi_dadd+0x10c> @ imm = #-0x2e
 80002cc: f091 0f00    	teq.w	r1, #0x0
 80002d0: bf04         	itt	eq
 80002d2: 4601         	moveq	r1, r0
 80002d4: 2000         	moveq	r0, #0x0
 80002d6: fab1 f381    	clz	r3, r1
 80002da: bf08         	it	eq
 80002dc: 3320         	addeq	r3, #0x20
 80002de: f1a3 030b    	sub.w	r3, r3, #0xb
 80002e2: f1b3 0220    	subs.w	r2, r3, #0x20
 80002e6: da0c         	bge	0x8000302 <__aeabi_dadd+0x16e> @ imm = #0x18
 80002e8: 320c         	adds	r2, #0xc
 80002ea: dd08         	ble	0x80002fe <__aeabi_dadd+0x16a> @ imm = #0x10
 80002ec: f102 0c14    	add.w	r12, r2, #0x14
 80002f0: f1c2 020c    	rsb.w	r2, r2, #0xc
 80002f4: fa01 f00c    	lsl.w	r0, r1, r12
 80002f8: fa21 f102    	lsr.w	r1, r1, r2
 80002fc: e00c         	b	0x8000318 <__aeabi_dadd+0x184> @ imm = #0x18
 80002fe: f102 0214    	add.w	r2, r2, #0x14
 8000302: bfd8         	it	le
 8000304: f1c2 0c20    	rsble.w	r12, r2, #0x20
 8000308: fa01 f102    	lsl.w	r1, r1, r2
 800030c: fa20 fc0c    	lsr.w	r12, r0, r12
 8000310: bfdc         	itt	le
 8000312: ea41 010c    	orrle.w	r1, r1, r12
 8000316: 4090         	lslle	r0, r2
 8000318: 1ae4         	subs	r4, r4, r3
 800031a: bfa2         	ittt	ge
 800031c: eb01 5104    	addge.w	r1, r1, r4, lsl #20
 8000320: 4329         	orrge	r1, r5
 8000322: bd30         	popge	{r4, r5, pc}
 8000324: ea6f 0404    	mvn.w	r4, r4
 8000328: 3c1f         	subs	r4, #0x1f
 800032a: da1c         	bge	0x8000366 <__aeabi_dadd+0x1d2> @ imm = #0x38
 800032c: 340c         	adds	r4, #0xc
 800032e: dc0e         	bgt	0x800034e <__aeabi_dadd+0x1ba> @ imm = #0x1c
 8000330: f104 0414    	add.w	r4, r4, #0x14
 8000334: f1c4 0220    	rsb.w	r2, r4, #0x20
 8000338: fa20 f004    	lsr.w	r0, r0, r4
 800033c: fa01 f302    	lsl.w	r3, r1, r2
 8000340: ea40 0003    	orr.w	r0, r0, r3
 8000344: fa21 f304    	lsr.w	r3, r1, r4
 8000348: ea45 0103    	orr.w	r1, r5, r3
 800034c: bd30         	pop	{r4, r5, pc}
 800034e: f1c4 040c    	rsb.w	r4, r4, #0xc
 8000352: f1c4 0220    	rsb.w	r2, r4, #0x20
 8000356: fa20 f002    	lsr.w	r0, r0, r2
 800035a: fa01 f304    	lsl.w	r3, r1, r4
 800035e: ea40 0003    	orr.w	r0, r0, r3
 8000362: 4629         	mov	r1, r5
 8000364: bd30         	pop	{r4, r5, pc}
 8000366: fa21 f004    	lsr.w	r0, r1, r4
 800036a: 4629         	mov	r1, r5
 800036c: bd30         	pop	{r4, r5, pc}
 800036e: f094 0f00    	teq.w	r4, #0x0
 8000372: f483 1380    	eor	r3, r3, #0x100000
 8000376: bf06         	itte	eq
 8000378: f481 1180    	eoreq	r1, r1, #0x100000
 800037c: 3401         	addeq	r4, #0x1
 800037e: 3d01         	subne	r5, #0x1
 8000380: e74e         	b	0x8000220 <__aeabi_dadd+0x8c> @ imm = #-0x164
 8000382: ea7f 5c64    	mvns.w	r12, r4, asr #21
 8000386: bf18         	it	ne
 8000388: ea7f 5c65    	mvnsne.w	r12, r5, asr #21
 800038c: d029         	beq	0x80003e2 <__aeabi_dadd+0x24e> @ imm = #0x52
 800038e: ea94 0f05    	teq.w	r4, r5
 8000392: bf08         	it	eq
 8000394: ea90 0f02    	teqeq.w	r0, r2
 8000398: d005         	beq	0x80003a6 <__aeabi_dadd+0x212> @ imm = #0xa
 800039a: ea54 0c00    	orrs.w	r12, r4, r0
 800039e: bf04         	itt	eq
 80003a0: 4619         	moveq	r1, r3
 80003a2: 4610         	moveq	r0, r2
 80003a4: bd30         	pop	{r4, r5, pc}
 80003a6: ea91 0f03    	teq.w	r1, r3
 80003aa: bf1e         	ittt	ne
 80003ac: 2100         	movne	r1, #0x0
 80003ae: 2000         	movne	r0, #0x0
 80003b0: bd30         	popne	{r4, r5, pc}
 80003b2: ea5f 5c54    	lsrs.w	r12, r4, #0x15
 80003b6: d105         	bne	0x80003c4 <__aeabi_dadd+0x230> @ imm = #0xa
 80003b8: 0040         	lsls	r0, r0, #0x1
 80003ba: 4149         	adcs	r1, r1
 80003bc: bf28         	it	hs
 80003be: f041 4100    	orrhs	r1, r1, #0x80000000
 80003c2: bd30         	pop	{r4, r5, pc}
 80003c4: f514 0480    	adds.w	r4, r4, #0x400000
 80003c8: bf3c         	itt	lo
 80003ca: f501 1180    	addlo.w	r1, r1, #0x100000
 80003ce: bd30         	poplo	{r4, r5, pc}
 80003d0: f001 4500    	and	r5, r1, #0x80000000
 80003d4: f045 41fe    	orr	r1, r5, #0x7f000000
 80003d8: f441 0170    	orr	r1, r1, #0xf00000
 80003dc: f04f 0000    	mov.w	r0, #0x0
 80003e0: bd30         	pop	{r4, r5, pc}
 80003e2: ea7f 5c64    	mvns.w	r12, r4, asr #21
 80003e6: bf1a         	itte	ne
 80003e8: 4619         	movne	r1, r3
 80003ea: 4610         	movne	r0, r2
 80003ec: ea7f 5c65    	mvnseq.w	r12, r5, asr #21
 80003f0: bf1c         	itt	ne
 80003f2: 460b         	movne	r3, r1
 80003f4: 4602         	movne	r2, r0
 80003f6: ea50 3401    	orrs.w	r4, r0, r1, lsl #12
 80003fa: bf06         	itte	eq
 80003fc: ea52 3503    	orrseq.w	r5, r2, r3, lsl #12
 8000400: ea91 0f03    	teqeq.w	r1, r3
 8000404: f441 2100    	orrne	r1, r1, #0x80000
 8000408: bd30         	pop	{r4, r5, pc}
 800040a: bf00         	nop

0800040c <__floatunsidf>:
 800040c: f090 0f00    	teq.w	r0, #0x0
 8000410: bf04         	itt	eq
 8000412: 2100         	moveq	r1, #0x0
 8000414: 4770         	bxeq	lr
 8000416: b530         	push	{r4, r5, lr}
 8000418: f44f 6480    	mov.w	r4, #0x400
 800041c: f104 0432    	add.w	r4, r4, #0x32
 8000420: f04f 0500    	mov.w	r5, #0x0
 8000424: f04f 0100    	mov.w	r1, #0x0
 8000428: e750         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x160
 800042a: bf00         	nop

0800042c <__floatsidf>:
 800042c: f090 0f00    	teq.w	r0, #0x0
 8000430: bf04         	itt	eq
 8000432: 2100         	moveq	r1, #0x0
 8000434: 4770         	bxeq	lr
 8000436: b530         	push	{r4, r5, lr}
 8000438: f44f 6480    	mov.w	r4, #0x400
 800043c: f104 0432    	add.w	r4, r4, #0x32
 8000440: f010 4500    	ands	r5, r0, #0x80000000
 8000444: bf48         	it	mi
 8000446: 4240         	rsbmi	r0, r0, #0
 8000448: f04f 0100    	mov.w	r1, #0x0
 800044c: e73e         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x184
 800044e: bf00         	nop

08000450 <__extendsfdf2>:
 8000450: 0042         	lsls	r2, r0, #0x1
 8000452: ea4f 01e2    	asr.w	r1, r2, #0x3
 8000456: ea4f 0131    	rrx	r1, r1
 800045a: ea4f 7002    	lsl.w	r0, r2, #0x1c
 800045e: bf1f         	itttt	ne
 8000460: f012 437f    	andsne	r3, r2, #0xff000000
 8000464: f093 4f7f    	teqne.w	r3, #0xff000000
 8000468: f081 5160    	eorne	r1, r1, #0x38000000
 800046c: 4770         	bxne	lr
 800046e: f032 427f    	bics	r2, r2, #0xff000000
 8000472: bf08         	it	eq
 8000474: 4770         	bxeq	lr
 8000476: f093 4f7f    	teq.w	r3, #0xff000000
 800047a: bf04         	itt	eq
 800047c: f441 2100    	orreq	r1, r1, #0x80000
 8000480: 4770         	bxeq	lr
 8000482: b530         	push	{r4, r5, lr}
 8000484: f44f 7460    	mov.w	r4, #0x380
 8000488: f001 4500    	and	r5, r1, #0x80000000
 800048c: f021 4100    	bic	r1, r1, #0x80000000
 8000490: e71c         	b	0x80002cc <__aeabi_dadd+0x138> @ imm = #-0x1c8
 8000492: bf00         	nop

08000494 <__floatundidf>:
 8000494: ea50 0201    	orrs.w	r2, r0, r1
 8000498: bf08         	it	eq
 800049a: 4770         	bxeq	lr
 800049c: b530         	push	{r4, r5, lr}
 800049e: f04f 0500    	mov.w	r5, #0x0
 80004a2: e00a         	b	0x80004ba <__floatdidf+0x16> @ imm = #0x14

080004a4 <__floatdidf>:
 80004a4: ea50 0201    	orrs.w	r2, r0, r1
 80004a8: bf08         	it	eq
 80004aa: 4770         	bxeq	lr
 80004ac: b530         	push	{r4, r5, lr}
 80004ae: f011 4500    	ands	r5, r1, #0x80000000
 80004b2: d502         	bpl	0x80004ba <__floatdidf+0x16> @ imm = #0x4
 80004b4: 4240         	rsbs	r0, r0, #0
 80004b6: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80004ba: f44f 6480    	mov.w	r4, #0x400
 80004be: f104 0432    	add.w	r4, r4, #0x32
 80004c2: ea5f 5c91    	lsrs.w	r12, r1, #0x16
 80004c6: f43f aed8    	beq.w	0x800027a <__aeabi_dadd+0xe6> @ imm = #-0x250
 80004ca: f04f 0203    	mov.w	r2, #0x3
 80004ce: ea5f 0cdc    	lsrs.w	r12, r12, #0x3
 80004d2: bf18         	it	ne
 80004d4: 3203         	addne	r2, #0x3
 80004d6: ea5f 0cdc    	lsrs.w	r12, r12, #0x3
 80004da: bf18         	it	ne
 80004dc: 3203         	addne	r2, #0x3
 80004de: eb02 02dc    	add.w	r2, r2, r12, lsr #3
 80004e2: f1c2 0320    	rsb.w	r3, r2, #0x20
 80004e6: fa00 fc03    	lsl.w	r12, r0, r3
 80004ea: fa20 f002    	lsr.w	r0, r0, r2
 80004ee: fa01 fe03    	lsl.w	lr, r1, r3
 80004f2: ea40 000e    	orr.w	r0, r0, lr
 80004f6: fa21 f102    	lsr.w	r1, r1, r2
 80004fa: 4414         	add	r4, r2
 80004fc: e6bd         	b	0x800027a <__aeabi_dadd+0xe6> @ imm = #-0x286
 80004fe: bf00         	nop

08000500 <__muldf3>:
 8000500: b570         	push	{r4, r5, r6, lr}
 8000502: f04f 0cff    	mov.w	r12, #0xff
 8000506: f44c 6ce0    	orr	r12, r12, #0x700
 800050a: ea1c 5411    	ands.w	r4, r12, r1, lsr #20
 800050e: bf1d         	ittte	ne
 8000510: ea1c 5513    	andsne.w	r5, r12, r3, lsr #20
 8000514: ea94 0f0c    	teqne.w	r4, r12
 8000518: ea95 0f0c    	teqne.w	r5, r12
 800051c: f000 f8de    	bleq	0x80006dc <__muldf3+0x1dc> @ imm = #0x1bc
 8000520: 442c         	add	r4, r5
 8000522: ea81 0603    	eor.w	r6, r1, r3
 8000526: ea21 514c    	bic.w	r1, r1, r12, lsl #21
 800052a: ea23 534c    	bic.w	r3, r3, r12, lsl #21
 800052e: ea50 3501    	orrs.w	r5, r0, r1, lsl #12
 8000532: bf18         	it	ne
 8000534: ea52 3503    	orrsne.w	r5, r2, r3, lsl #12
 8000538: f441 1180    	orr	r1, r1, #0x100000
 800053c: f443 1380    	orr	r3, r3, #0x100000
 8000540: d038         	beq	0x80005b4 <__muldf3+0xb4> @ imm = #0x70
 8000542: fba0 ce02    	umull	r12, lr, r0, r2
 8000546: f04f 0500    	mov.w	r5, #0x0
 800054a: fbe1 e502    	umlal	lr, r5, r1, r2
 800054e: f006 4200    	and	r2, r6, #0x80000000
 8000552: fbe0 e503    	umlal	lr, r5, r0, r3
 8000556: f04f 0600    	mov.w	r6, #0x0
 800055a: fbe1 5603    	umlal	r5, r6, r1, r3
 800055e: f09c 0f00    	teq.w	r12, #0x0
 8000562: bf18         	it	ne
 8000564: f04e 0e01    	orrne	lr, lr, #0x1
 8000568: f1a4 04ff    	sub.w	r4, r4, #0xff
 800056c: f5b6 7f00    	cmp.w	r6, #0x200
 8000570: f564 7440    	sbc	r4, r4, #0x300
 8000574: d204         	bhs	0x8000580 <__muldf3+0x80> @ imm = #0x8
 8000576: ea5f 0e4e    	lsls.w	lr, lr, #0x1
 800057a: 416d         	adcs	r5, r5
 800057c: eb46 0606    	adc.w	r6, r6, r6
 8000580: ea42 21c6    	orr.w	r1, r2, r6, lsl #11
 8000584: ea41 5155    	orr.w	r1, r1, r5, lsr #21
 8000588: ea4f 20c5    	lsl.w	r0, r5, #0xb
 800058c: ea40 505e    	orr.w	r0, r0, lr, lsr #21
 8000590: ea4f 2ece    	lsl.w	lr, lr, #0xb
 8000594: f1b4 0cfd    	subs.w	r12, r4, #0xfd
 8000598: bf88         	it	hi
 800059a: f5bc 6fe0    	cmphi.w	r12, #0x700
 800059e: d81e         	bhi	0x80005de <__muldf3+0xde> @ imm = #0x3c
 80005a0: f1be 4f00    	cmp.w	lr, #0x80000000
 80005a4: bf08         	it	eq
 80005a6: ea5f 0e50    	lsrseq.w	lr, r0, #0x1
 80005aa: f150 0000    	adcs	r0, r0, #0x0
 80005ae: eb41 5104    	adc.w	r1, r1, r4, lsl #20
 80005b2: bd70         	pop	{r4, r5, r6, pc}
 80005b4: f006 4600    	and	r6, r6, #0x80000000
 80005b8: ea46 0101    	orr.w	r1, r6, r1
 80005bc: ea40 0002    	orr.w	r0, r0, r2
 80005c0: ea81 0103    	eor.w	r1, r1, r3
 80005c4: ebb4 045c    	subs.w	r4, r4, r12, lsr #1
 80005c8: bfc2         	ittt	gt
 80005ca: ebd4 050c    	rsbsgt	r5, r4, r12
 80005ce: ea41 5104    	orrgt.w	r1, r1, r4, lsl #20
 80005d2: bd70         	popgt	{r4, r5, r6, pc}
 80005d4: f441 1180    	orr	r1, r1, #0x100000
 80005d8: f04f 0e00    	mov.w	lr, #0x0
 80005dc: 3c01         	subs	r4, #0x1
 80005de: f300 80ab    	bgt.w	0x8000738 <__muldf3+0x238> @ imm = #0x156
 80005e2: f114 0f36    	cmn.w	r4, #0x36
 80005e6: bfde         	ittt	le
 80005e8: 2000         	movle	r0, #0x0
 80005ea: f001 4100    	andle	r1, r1, #0x80000000
 80005ee: bd70         	pople	{r4, r5, r6, pc}
 80005f0: f1c4 0400    	rsb.w	r4, r4, #0x0
 80005f4: 3c20         	subs	r4, #0x20
 80005f6: da35         	bge	0x8000664 <__muldf3+0x164> @ imm = #0x6a
 80005f8: 340c         	adds	r4, #0xc
 80005fa: dc1b         	bgt	0x8000634 <__muldf3+0x134> @ imm = #0x36
 80005fc: f104 0414    	add.w	r4, r4, #0x14
 8000600: f1c4 0520    	rsb.w	r5, r4, #0x20
 8000604: fa00 f305    	lsl.w	r3, r0, r5
 8000608: fa20 f004    	lsr.w	r0, r0, r4
 800060c: fa01 f205    	lsl.w	r2, r1, r5
 8000610: ea40 0002    	orr.w	r0, r0, r2
 8000614: f001 4200    	and	r2, r1, #0x80000000
 8000618: f021 4100    	bic	r1, r1, #0x80000000
 800061c: eb10 70d3    	adds.w	r0, r0, r3, lsr #31
 8000620: fa21 f604    	lsr.w	r6, r1, r4
 8000624: eb42 0106    	adc.w	r1, r2, r6
 8000628: ea5e 0e43    	orrs.w	lr, lr, r3, lsl #1
 800062c: bf08         	it	eq
 800062e: ea20 70d3    	biceq.w	r0, r0, r3, lsr #31
 8000632: bd70         	pop	{r4, r5, r6, pc}
 8000634: f1c4 040c    	rsb.w	r4, r4, #0xc
 8000638: f1c4 0520    	rsb.w	r5, r4, #0x20
 800063c: fa00 f304    	lsl.w	r3, r0, r4
 8000640: fa20 f005    	lsr.w	r0, r0, r5
 8000644: fa01 f204    	lsl.w	r2, r1, r4
 8000648: ea40 0002    	orr.w	r0, r0, r2
 800064c: f001 4100    	and	r1, r1, #0x80000000
 8000650: eb10 70d3    	adds.w	r0, r0, r3, lsr #31
 8000654: f141 0100    	adc	r1, r1, #0x0
 8000658: ea5e 0e43    	orrs.w	lr, lr, r3, lsl #1
 800065c: bf08         	it	eq
 800065e: ea20 70d3    	biceq.w	r0, r0, r3, lsr #31
 8000662: bd70         	pop	{r4, r5, r6, pc}
 8000664: f1c4 0520    	rsb.w	r5, r4, #0x20
 8000668: fa00 f205    	lsl.w	r2, r0, r5
 800066c: ea4e 0e02    	orr.w	lr, lr, r2
 8000670: fa20 f304    	lsr.w	r3, r0, r4
 8000674: fa01 f205    	lsl.w	r2, r1, r5
 8000678: ea43 0302    	orr.w	r3, r3, r2
 800067c: fa21 f004    	lsr.w	r0, r1, r4
 8000680: f001 4100    	and	r1, r1, #0x80000000
 8000684: fa21 f204    	lsr.w	r2, r1, r4
 8000688: ea20 0002    	bic.w	r0, r0, r2
 800068c: eb00 70d3    	add.w	r0, r0, r3, lsr #31
 8000690: ea5e 0e43    	orrs.w	lr, lr, r3, lsl #1
 8000694: bf08         	it	eq
 8000696: ea20 70d3    	biceq.w	r0, r0, r3, lsr #31
 800069a: bd70         	pop	{r4, r5, r6, pc}
 800069c: f094 0f00    	teq.w	r4, #0x0
 80006a0: d10f         	bne	0x80006c2 <__muldf3+0x1c2> @ imm = #0x1e
 80006a2: f001 4600    	and	r6, r1, #0x80000000
 80006a6: 0040         	lsls	r0, r0, #0x1
 80006a8: eb41 0101    	adc.w	r1, r1, r1
 80006ac: f411 1f80    	tst.w	r1, #0x100000
 80006b0: bf08         	it	eq
 80006b2: 3c01         	subeq	r4, #0x1
 80006b4: d0f7         	beq	0x80006a6 <__muldf3+0x1a6> @ imm = #-0x12
 80006b6: ea41 0106    	orr.w	r1, r1, r6
 80006ba: f095 0f00    	teq.w	r5, #0x0
 80006be: bf18         	it	ne
 80006c0: 4770         	bxne	lr
 80006c2: f003 4600    	and	r6, r3, #0x80000000
 80006c6: 0052         	lsls	r2, r2, #0x1
 80006c8: eb43 0303    	adc.w	r3, r3, r3
 80006cc: f413 1f80    	tst.w	r3, #0x100000
 80006d0: bf08         	it	eq
 80006d2: 3d01         	subeq	r5, #0x1
 80006d4: d0f7         	beq	0x80006c6 <__muldf3+0x1c6> @ imm = #-0x12
 80006d6: ea43 0306    	orr.w	r3, r3, r6
 80006da: 4770         	bx	lr
 80006dc: ea94 0f0c    	teq.w	r4, r12
 80006e0: ea0c 5513    	and.w	r5, r12, r3, lsr #20
 80006e4: bf18         	it	ne
 80006e6: ea95 0f0c    	teqne.w	r5, r12
 80006ea: d00c         	beq	0x8000706 <__muldf3+0x206> @ imm = #0x18
 80006ec: ea50 0641    	orrs.w	r6, r0, r1, lsl #1
 80006f0: bf18         	it	ne
 80006f2: ea52 0643    	orrsne.w	r6, r2, r3, lsl #1
 80006f6: d1d1         	bne	0x800069c <__muldf3+0x19c> @ imm = #-0x5e
 80006f8: ea81 0103    	eor.w	r1, r1, r3
 80006fc: f001 4100    	and	r1, r1, #0x80000000
 8000700: f04f 0000    	mov.w	r0, #0x0
 8000704: bd70         	pop	{r4, r5, r6, pc}
 8000706: ea50 0641    	orrs.w	r6, r0, r1, lsl #1
 800070a: bf06         	itte	eq
 800070c: 4610         	moveq	r0, r2
 800070e: 4619         	moveq	r1, r3
 8000710: ea52 0643    	orrsne.w	r6, r2, r3, lsl #1
 8000714: d019         	beq	0x800074a <__muldf3+0x24a> @ imm = #0x32
 8000716: ea94 0f0c    	teq.w	r4, r12
 800071a: d102         	bne	0x8000722 <__muldf3+0x222> @ imm = #0x4
 800071c: ea50 3601    	orrs.w	r6, r0, r1, lsl #12
 8000720: d113         	bne	0x800074a <__muldf3+0x24a> @ imm = #0x26
 8000722: ea95 0f0c    	teq.w	r5, r12
 8000726: d105         	bne	0x8000734 <__muldf3+0x234> @ imm = #0xa
 8000728: ea52 3603    	orrs.w	r6, r2, r3, lsl #12
 800072c: bf1c         	itt	ne
 800072e: 4610         	movne	r0, r2
 8000730: 4619         	movne	r1, r3
 8000732: d10a         	bne	0x800074a <__muldf3+0x24a> @ imm = #0x14
 8000734: ea81 0103    	eor.w	r1, r1, r3
 8000738: f001 4100    	and	r1, r1, #0x80000000
 800073c: f041 41fe    	orr	r1, r1, #0x7f000000
 8000740: f441 0170    	orr	r1, r1, #0xf00000
 8000744: f04f 0000    	mov.w	r0, #0x0
 8000748: bd70         	pop	{r4, r5, r6, pc}
 800074a: f041 41fe    	orr	r1, r1, #0x7f000000
 800074e: f441 0178    	orr	r1, r1, #0xf80000
 8000752: bd70         	pop	{r4, r5, r6, pc}

08000754 <__divdf3>:
 8000754: b570         	push	{r4, r5, r6, lr}
 8000756: f04f 0cff    	mov.w	r12, #0xff
 800075a: f44c 6ce0    	orr	r12, r12, #0x700
 800075e: ea1c 5411    	ands.w	r4, r12, r1, lsr #20
 8000762: bf1d         	ittte	ne
 8000764: ea1c 5513    	andsne.w	r5, r12, r3, lsr #20
 8000768: ea94 0f0c    	teqne.w	r4, r12
 800076c: ea95 0f0c    	teqne.w	r5, r12
 8000770: f000 f8a7    	bleq	0x80008c2 <__divdf3+0x16e> @ imm = #0x14e
 8000774: eba4 0405    	sub.w	r4, r4, r5
 8000778: ea81 0e03    	eor.w	lr, r1, r3
 800077c: ea52 3503    	orrs.w	r5, r2, r3, lsl #12
 8000780: ea4f 3101    	lsl.w	r1, r1, #0xc
 8000784: f000 8088    	beq.w	0x8000898 <__divdf3+0x144> @ imm = #0x110
 8000788: ea4f 3303    	lsl.w	r3, r3, #0xc
 800078c: f04f 5580    	mov.w	r5, #0x10000000
 8000790: ea45 1313    	orr.w	r3, r5, r3, lsr #4
 8000794: ea43 6312    	orr.w	r3, r3, r2, lsr #24
 8000798: ea4f 2202    	lsl.w	r2, r2, #0x8
 800079c: ea45 1511    	orr.w	r5, r5, r1, lsr #4
 80007a0: ea45 6510    	orr.w	r5, r5, r0, lsr #24
 80007a4: ea4f 2600    	lsl.w	r6, r0, #0x8
 80007a8: f00e 4100    	and	r1, lr, #0x80000000
 80007ac: 429d         	cmp	r5, r3
 80007ae: bf08         	it	eq
 80007b0: 4296         	cmpeq	r6, r2
 80007b2: f144 04fd    	adc	r4, r4, #0xfd
 80007b6: f504 7440    	add.w	r4, r4, #0x300
 80007ba: d202         	bhs	0x80007c2 <__divdf3+0x6e> @ imm = #0x4
 80007bc: 085b         	lsrs	r3, r3, #0x1
 80007be: ea4f 0232    	rrx	r2, r2
 80007c2: 1ab6         	subs	r6, r6, r2
 80007c4: eb65 0503    	sbc.w	r5, r5, r3
 80007c8: 085b         	lsrs	r3, r3, #0x1
 80007ca: ea4f 0232    	rrx	r2, r2
 80007ce: f44f 1080    	mov.w	r0, #0x100000
 80007d2: f44f 2c00    	mov.w	r12, #0x80000
 80007d6: ebb6 0e02    	subs.w	lr, r6, r2
 80007da: eb75 0e03    	sbcs.w	lr, r5, r3
 80007de: bf22         	ittt	hs
 80007e0: 1ab6         	subhs	r6, r6, r2
 80007e2: 4675         	movhs	r5, lr
 80007e4: ea40 000c    	orrhs.w	r0, r0, r12
 80007e8: 085b         	lsrs	r3, r3, #0x1
 80007ea: ea4f 0232    	rrx	r2, r2
 80007ee: ebb6 0e02    	subs.w	lr, r6, r2
 80007f2: eb75 0e03    	sbcs.w	lr, r5, r3
 80007f6: bf22         	ittt	hs
 80007f8: 1ab6         	subhs	r6, r6, r2
 80007fa: 4675         	movhs	r5, lr
 80007fc: ea40 005c    	orrhs.w	r0, r0, r12, lsr #1
 8000800: 085b         	lsrs	r3, r3, #0x1
 8000802: ea4f 0232    	rrx	r2, r2
 8000806: ebb6 0e02    	subs.w	lr, r6, r2
 800080a: eb75 0e03    	sbcs.w	lr, r5, r3
 800080e: bf22         	ittt	hs
 8000810: 1ab6         	subhs	r6, r6, r2
 8000812: 4675         	movhs	r5, lr
 8000814: ea40 009c    	orrhs.w	r0, r0, r12, lsr #2
 8000818: 085b         	lsrs	r3, r3, #0x1
 800081a: ea4f 0232    	rrx	r2, r2
 800081e: ebb6 0e02    	subs.w	lr, r6, r2
 8000822: eb75 0e03    	sbcs.w	lr, r5, r3
 8000826: bf22         	ittt	hs
 8000828: 1ab6         	subhs	r6, r6, r2
 800082a: 4675         	movhs	r5, lr
 800082c: ea40 00dc    	orrhs.w	r0, r0, r12, lsr #3
 8000830: ea55 0e06    	orrs.w	lr, r5, r6
 8000834: d018         	beq	0x8000868 <__divdf3+0x114> @ imm = #0x30
 8000836: ea4f 1505    	lsl.w	r5, r5, #0x4
 800083a: ea45 7516    	orr.w	r5, r5, r6, lsr #28
 800083e: ea4f 1606    	lsl.w	r6, r6, #0x4
 8000842: ea4f 03c3    	lsl.w	r3, r3, #0x3
 8000846: ea43 7352    	orr.w	r3, r3, r2, lsr #29
 800084a: ea4f 02c2    	lsl.w	r2, r2, #0x3
 800084e: ea5f 1c1c    	lsrs.w	r12, r12, #0x4
 8000852: d1c0         	bne	0x80007d6 <__divdf3+0x82> @ imm = #-0x80
 8000854: f411 1f80    	tst.w	r1, #0x100000
 8000858: d10b         	bne	0x8000872 <__divdf3+0x11e> @ imm = #0x16
 800085a: ea41 0100    	orr.w	r1, r1, r0
 800085e: f04f 0000    	mov.w	r0, #0x0
 8000862: f04f 4c00    	mov.w	r12, #0x80000000
 8000866: e7b6         	b	0x80007d6 <__divdf3+0x82> @ imm = #-0x94
 8000868: f411 1f80    	tst.w	r1, #0x100000
 800086c: bf04         	itt	eq
 800086e: 4301         	orreq	r1, r0
 8000870: 2000         	moveq	r0, #0x0
 8000872: f1b4 0cfd    	subs.w	r12, r4, #0xfd
 8000876: bf88         	it	hi
 8000878: f5bc 6fe0    	cmphi.w	r12, #0x700
 800087c: f63f aeaf    	bhi.w	0x80005de <__muldf3+0xde> @ imm = #-0x2a2
 8000880: ebb5 0c03    	subs.w	r12, r5, r3
 8000884: bf04         	itt	eq
 8000886: ebb6 0c02    	subseq.w	r12, r6, r2
 800088a: ea5f 0c50    	lsrseq.w	r12, r0, #0x1
 800088e: f150 0000    	adcs	r0, r0, #0x0
 8000892: eb41 5104    	adc.w	r1, r1, r4, lsl #20
 8000896: bd70         	pop	{r4, r5, r6, pc}
 8000898: f00e 4e00    	and	lr, lr, #0x80000000
 800089c: ea4e 3111    	orr.w	r1, lr, r1, lsr #12
 80008a0: eb14 045c    	adds.w	r4, r4, r12, lsr #1
 80008a4: bfc2         	ittt	gt
 80008a6: ebd4 050c    	rsbsgt	r5, r4, r12
 80008aa: ea41 5104    	orrgt.w	r1, r1, r4, lsl #20
 80008ae: bd70         	popgt	{r4, r5, r6, pc}
 80008b0: f441 1180    	orr	r1, r1, #0x100000
 80008b4: f04f 0e00    	mov.w	lr, #0x0
 80008b8: 3c01         	subs	r4, #0x1
 80008ba: e690         	b	0x80005de <__muldf3+0xde> @ imm = #-0x2e0
 80008bc: ea45 0e06    	orr.w	lr, r5, r6
 80008c0: e68d         	b	0x80005de <__muldf3+0xde> @ imm = #-0x2e6
 80008c2: ea0c 5513    	and.w	r5, r12, r3, lsr #20
 80008c6: ea94 0f0c    	teq.w	r4, r12
 80008ca: bf08         	it	eq
 80008cc: ea95 0f0c    	teqeq.w	r5, r12
 80008d0: f43f af3b    	beq.w	0x800074a <__muldf3+0x24a> @ imm = #-0x18a
 80008d4: ea94 0f0c    	teq.w	r4, r12
 80008d8: d10a         	bne	0x80008f0 <__divdf3+0x19c> @ imm = #0x14
 80008da: ea50 3401    	orrs.w	r4, r0, r1, lsl #12
 80008de: f47f af34    	bne.w	0x800074a <__muldf3+0x24a> @ imm = #-0x198
 80008e2: ea95 0f0c    	teq.w	r5, r12
 80008e6: f47f af25    	bne.w	0x8000734 <__muldf3+0x234> @ imm = #-0x1b6
 80008ea: 4610         	mov	r0, r2
 80008ec: 4619         	mov	r1, r3
 80008ee: e72c         	b	0x800074a <__muldf3+0x24a> @ imm = #-0x1a8
 80008f0: ea95 0f0c    	teq.w	r5, r12
 80008f4: d106         	bne	0x8000904 <__divdf3+0x1b0> @ imm = #0xc
 80008f6: ea52 3503    	orrs.w	r5, r2, r3, lsl #12
 80008fa: f43f aefd    	beq.w	0x80006f8 <__muldf3+0x1f8> @ imm = #-0x206
 80008fe: 4610         	mov	r0, r2
 8000900: 4619         	mov	r1, r3
 8000902: e722         	b	0x800074a <__muldf3+0x24a> @ imm = #-0x1bc
 8000904: ea50 0641    	orrs.w	r6, r0, r1, lsl #1
 8000908: bf18         	it	ne
 800090a: ea52 0643    	orrsne.w	r6, r2, r3, lsl #1
 800090e: f47f aec5    	bne.w	0x800069c <__muldf3+0x19c> @ imm = #-0x276
 8000912: ea50 0441    	orrs.w	r4, r0, r1, lsl #1
 8000916: f47f af0d    	bne.w	0x8000734 <__muldf3+0x234> @ imm = #-0x1e6
 800091a: ea52 0543    	orrs.w	r5, r2, r3, lsl #1
 800091e: f47f aeeb    	bne.w	0x80006f8 <__muldf3+0x1f8> @ imm = #-0x22a
 8000922: e712         	b	0x800074a <__muldf3+0x24a> @ imm = #-0x1dc

08000924 <__truncdfsf2>:
 8000924: ea4f 0241    	lsl.w	r2, r1, #0x1
 8000928: f1b2 43e0    	subs.w	r3, r2, #0x70000000
 800092c: bf24         	itt	hs
 800092e: f5b3 1c00    	subshs.w	r12, r3, #0x200000
 8000932: f1dc 5cfe    	rsbshs.w	r12, r12, #0x1fc00000
 8000936: d90d         	bls	0x8000954 <__truncdfsf2+0x30> @ imm = #0x1a
 8000938: f001 4c00    	and	r12, r1, #0x80000000
 800093c: ea4f 02c0    	lsl.w	r2, r0, #0x3
 8000940: ea4c 7050    	orr.w	r0, r12, r0, lsr #29
 8000944: f1b2 4f00    	cmp.w	r2, #0x80000000
 8000948: eb40 0083    	adc.w	r0, r0, r3, lsl #2
 800094c: bf08         	it	eq
 800094e: f020 0001    	biceq	r0, r0, #0x1
 8000952: 4770         	bx	lr
 8000954: f011 4f80    	tst.w	r1, #0x40000000
 8000958: d121         	bne	0x800099e <__truncdfsf2+0x7a> @ imm = #0x42
 800095a: f113 7238    	adds.w	r2, r3, #0x2e00000
 800095e: bfbc         	itt	lt
 8000960: f001 4000    	andlt	r0, r1, #0x80000000
 8000964: 4770         	bxlt	lr
 8000966: f441 1180    	orr	r1, r1, #0x100000
 800096a: ea4f 5252    	lsr.w	r2, r2, #0x15
 800096e: f1c2 0218    	rsb.w	r2, r2, #0x18
 8000972: f1c2 0c20    	rsb.w	r12, r2, #0x20
 8000976: fa10 f30c    	lsls.w	r3, r0, r12
 800097a: fa20 f002    	lsr.w	r0, r0, r2
 800097e: bf18         	it	ne
 8000980: f040 0001    	orrne	r0, r0, #0x1
 8000984: ea4f 23c1    	lsl.w	r3, r1, #0xb
 8000988: ea4f 23d3    	lsr.w	r3, r3, #0xb
 800098c: fa03 fc0c    	lsl.w	r12, r3, r12
 8000990: ea40 000c    	orr.w	r0, r0, r12
 8000994: fa23 f302    	lsr.w	r3, r3, r2
 8000998: ea4f 0343    	lsl.w	r3, r3, #0x1
 800099c: e7cc         	b	0x8000938 <__truncdfsf2+0x14> @ imm = #-0x68
 800099e: ea7f 5362    	mvns.w	r3, r2, asr #21
 80009a2: d107         	bne	0x80009b4 <__truncdfsf2+0x90> @ imm = #0xe
 80009a4: ea50 3301    	orrs.w	r3, r0, r1, lsl #12
 80009a8: bf1e         	ittt	ne
 80009aa: f04f 40fe    	movne.w	r0, #0x7f000000
 80009ae: f440 0040    	orrne	r0, r0, #0xc00000
 80009b2: 4770         	bxne	lr
 80009b4: f001 4000    	and	r0, r1, #0x80000000
 80009b8: f040 40fe    	orr	r0, r0, #0x7f000000
 80009bc: f440 0000    	orr	r0, r0, #0x800000
 80009c0: 4770         	bx	lr
 80009c2: bf00         	nop

080009c4 <__aeabi_ldivmod>:
 80009c4: b97b         	cbnz	r3, 0x80009e6 <__aeabi_ldivmod+0x22> @ imm = #0x1e
 80009c6: b972         	cbnz	r2, 0x80009e6 <__aeabi_ldivmod+0x22> @ imm = #0x1c
 80009c8: 2900         	cmp	r1, #0x0
 80009ca: bfbe         	ittt	lt
 80009cc: 2000         	movlt	r0, #0x0
 80009ce: f04f 4100    	movlt.w	r1, #0x80000000
 80009d2: e006         	blt	0x80009e2 <__aeabi_ldivmod+0x1e> @ imm = #0xc
 80009d4: bf08         	it	eq
 80009d6: 2800         	cmpeq	r0, #0x0
 80009d8: bf1c         	itt	ne
 80009da: f06f 4100    	mvnne	r1, #0x80000000
 80009de: f04f 30ff    	movne.w	r0, #0xffffffff
 80009e2: f000 b857    	b.w	0x8000a94 <__aeabi_ldiv0> @ imm = #0xae
 80009e6: f1ad 0c08    	sub.w	r12, sp, #0x8
 80009ea: e96d ce04    	strd	r12, lr, [sp, #-16]!
 80009ee: 2900         	cmp	r1, #0x0
 80009f0: db09         	blt	0x8000a06 <__aeabi_ldivmod+0x42> @ imm = #0x12
 80009f2: 2b00         	cmp	r3, #0x0
 80009f4: db1a         	blt	0x8000a2c <__aeabi_ldivmod+0x68> @ imm = #0x34
 80009f6: f000 f857    	bl	0x8000aa8 <__udivmoddi4> @ imm = #0xae
 80009fa: f8dd e004    	ldr.w	lr, [sp, #0x4]
 80009fe: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000a02: b004         	add	sp, #0x10
 8000a04: 4770         	bx	lr
 8000a06: 4240         	rsbs	r0, r0, #0
 8000a08: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000a0c: 2b00         	cmp	r3, #0x0
 8000a0e: db1b         	blt	0x8000a48 <__aeabi_ldivmod+0x84> @ imm = #0x36
 8000a10: f000 f84a    	bl	0x8000aa8 <__udivmoddi4> @ imm = #0x94
 8000a14: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000a18: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000a1c: b004         	add	sp, #0x10
 8000a1e: 4240         	rsbs	r0, r0, #0
 8000a20: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000a24: 4252         	rsbs	r2, r2, #0
 8000a26: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 8000a2a: 4770         	bx	lr
 8000a2c: 4252         	rsbs	r2, r2, #0
 8000a2e: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 8000a32: f000 f839    	bl	0x8000aa8 <__udivmoddi4> @ imm = #0x72
 8000a36: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000a3a: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000a3e: b004         	add	sp, #0x10
 8000a40: 4240         	rsbs	r0, r0, #0
 8000a42: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 8000a46: 4770         	bx	lr
 8000a48: 4252         	rsbs	r2, r2, #0
 8000a4a: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 8000a4e: f000 f82b    	bl	0x8000aa8 <__udivmoddi4> @ imm = #0x56
 8000a52: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000a56: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000a5a: b004         	add	sp, #0x10
 8000a5c: 4252         	rsbs	r2, r2, #0
 8000a5e: eb63 0343    	sbc.w	r3, r3, r3, lsl #1
 8000a62: 4770         	bx	lr

08000a64 <__aeabi_uldivmod>:
 8000a64: b953         	cbnz	r3, 0x8000a7c <__aeabi_uldivmod+0x18> @ imm = #0x14
 8000a66: b94a         	cbnz	r2, 0x8000a7c <__aeabi_uldivmod+0x18> @ imm = #0x12
 8000a68: 2900         	cmp	r1, #0x0
 8000a6a: bf08         	it	eq
 8000a6c: 2800         	cmpeq	r0, #0x0
 8000a6e: bf1c         	itt	ne
 8000a70: f04f 31ff    	movne.w	r1, #0xffffffff
 8000a74: f04f 30ff    	movne.w	r0, #0xffffffff
 8000a78: f000 b80c    	b.w	0x8000a94 <__aeabi_ldiv0> @ imm = #0x18
 8000a7c: f1ad 0c08    	sub.w	r12, sp, #0x8
 8000a80: e96d ce04    	strd	r12, lr, [sp, #-16]!
 8000a84: f000 f810    	bl	0x8000aa8 <__udivmoddi4> @ imm = #0x20
 8000a88: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8000a8c: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 8000a90: b004         	add	sp, #0x10
 8000a92: 4770         	bx	lr

08000a94 <__aeabi_ldiv0>:
 8000a94: 4770         	bx	lr
 8000a96: bf00         	nop

08000a98 <strlen>:
 8000a98: 4603         	mov	r3, r0
 8000a9a: f813 2b01    	ldrb	r2, [r3], #1
 8000a9e: 2a00         	cmp	r2, #0x0
 8000aa0: d1fb         	bne	0x8000a9a <strlen+0x2>  @ imm = #-0xa
 8000aa2: 1a18         	subs	r0, r3, r0
 8000aa4: 3801         	subs	r0, #0x1
 8000aa6: 4770         	bx	lr

08000aa8 <__udivmoddi4>:
 8000aa8: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 8000aac: 4686         	mov	lr, r0
 8000aae: 468c         	mov	r12, r1
 8000ab0: 4608         	mov	r0, r1
 8000ab2: 9e08         	ldr	r6, [sp, #0x20]
 8000ab4: 4615         	mov	r5, r2
 8000ab6: 4674         	mov	r4, lr
 8000ab8: 4619         	mov	r1, r3
 8000aba: 2b00         	cmp	r3, #0x0
 8000abc: f040 80c2    	bne.w	0x8000c44 <__udivmoddi4+0x19c> @ imm = #0x184
 8000ac0: 4285         	cmp	r5, r0
 8000ac2: fab2 f282    	clz	r2, r2
 8000ac6: d945         	bls	0x8000b54 <__udivmoddi4+0xac> @ imm = #0x8a
 8000ac8: b14a         	cbz	r2, 0x8000ade <__udivmoddi4+0x36> @ imm = #0x12
 8000aca: f1c2 0320    	rsb.w	r3, r2, #0x20
 8000ace: fa00 fc02    	lsl.w	r12, r0, r2
 8000ad2: fa2e f303    	lsr.w	r3, lr, r3
 8000ad6: 4095         	lsls	r5, r2
 8000ad8: ea43 0c0c    	orr.w	r12, r3, r12
 8000adc: 4094         	lsls	r4, r2
 8000ade: ea4f 4e15    	lsr.w	lr, r5, #0x10
 8000ae2: b2a8         	uxth	r0, r5
 8000ae4: fbbc f8fe    	udiv	r8, r12, lr
 8000ae8: 0c23         	lsrs	r3, r4, #0x10
 8000aea: fb0e cc18    	mls	r12, lr, r8, r12
 8000aee: fb08 f900    	mul	r9, r8, r0
 8000af2: ea43 430c    	orr.w	r3, r3, r12, lsl #16
 8000af6: 4599         	cmp	r9, r3
 8000af8: d928         	bls	0x8000b4c <__udivmoddi4+0xa4> @ imm = #0x50
 8000afa: 18eb         	adds	r3, r5, r3
 8000afc: f108 37ff    	add.w	r7, r8, #0xffffffff
 8000b00: d204         	bhs	0x8000b0c <__udivmoddi4+0x64> @ imm = #0x8
 8000b02: 4599         	cmp	r9, r3
 8000b04: d902         	bls	0x8000b0c <__udivmoddi4+0x64> @ imm = #0x4
 8000b06: f1a8 0702    	sub.w	r7, r8, #0x2
 8000b0a: 442b         	add	r3, r5
 8000b0c: eba3 0309    	sub.w	r3, r3, r9
 8000b10: b2a4         	uxth	r4, r4
 8000b12: fbb3 fcfe    	udiv	r12, r3, lr
 8000b16: fb0e 331c    	mls	r3, lr, r12, r3
 8000b1a: fb0c f000    	mul	r0, r12, r0
 8000b1e: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 8000b22: 42a0         	cmp	r0, r4
 8000b24: d914         	bls	0x8000b50 <__udivmoddi4+0xa8> @ imm = #0x28
 8000b26: 192c         	adds	r4, r5, r4
 8000b28: f10c 33ff    	add.w	r3, r12, #0xffffffff
 8000b2c: d204         	bhs	0x8000b38 <__udivmoddi4+0x90> @ imm = #0x8
 8000b2e: 42a0         	cmp	r0, r4
 8000b30: d902         	bls	0x8000b38 <__udivmoddi4+0x90> @ imm = #0x4
 8000b32: f1ac 0302    	sub.w	r3, r12, #0x2
 8000b36: 442c         	add	r4, r5
 8000b38: 1a24         	subs	r4, r4, r0
 8000b3a: ea43 4007    	orr.w	r0, r3, r7, lsl #16
 8000b3e: b11e         	cbz	r6, 0x8000b48 <__udivmoddi4+0xa0> @ imm = #0x6
 8000b40: 40d4         	lsrs	r4, r2
 8000b42: 2300         	movs	r3, #0x0
 8000b44: 6034         	str	r4, [r6]
 8000b46: 6073         	str	r3, [r6, #0x4]
 8000b48: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}
 8000b4c: 4647         	mov	r7, r8
 8000b4e: e7dd         	b	0x8000b0c <__udivmoddi4+0x64> @ imm = #-0x46
 8000b50: 4663         	mov	r3, r12
 8000b52: e7f1         	b	0x8000b38 <__udivmoddi4+0x90> @ imm = #-0x1e
 8000b54: bb92         	cbnz	r2, 0x8000bbc <__udivmoddi4+0x114> @ imm = #0x64
 8000b56: 1b43         	subs	r3, r0, r5
 8000b58: 2101         	movs	r1, #0x1
 8000b5a: ea4f 4e15    	lsr.w	lr, r5, #0x10
 8000b5e: b2af         	uxth	r7, r5
 8000b60: fbb3 fcfe    	udiv	r12, r3, lr
 8000b64: 0c20         	lsrs	r0, r4, #0x10
 8000b66: fb0e 331c    	mls	r3, lr, r12, r3
 8000b6a: fb0c f807    	mul	r8, r12, r7
 8000b6e: ea40 4303    	orr.w	r3, r0, r3, lsl #16
 8000b72: 4598         	cmp	r8, r3
 8000b74: d962         	bls	0x8000c3c <__udivmoddi4+0x194> @ imm = #0xc4
 8000b76: 18eb         	adds	r3, r5, r3
 8000b78: f10c 30ff    	add.w	r0, r12, #0xffffffff
 8000b7c: d204         	bhs	0x8000b88 <__udivmoddi4+0xe0> @ imm = #0x8
 8000b7e: 4598         	cmp	r8, r3
 8000b80: d902         	bls	0x8000b88 <__udivmoddi4+0xe0> @ imm = #0x4
 8000b82: f1ac 0002    	sub.w	r0, r12, #0x2
 8000b86: 442b         	add	r3, r5
 8000b88: eba3 0308    	sub.w	r3, r3, r8
 8000b8c: b2a4         	uxth	r4, r4
 8000b8e: fbb3 fcfe    	udiv	r12, r3, lr
 8000b92: fb0e 331c    	mls	r3, lr, r12, r3
 8000b96: fb0c f707    	mul	r7, r12, r7
 8000b9a: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 8000b9e: 42a7         	cmp	r7, r4
 8000ba0: d94e         	bls	0x8000c40 <__udivmoddi4+0x198> @ imm = #0x9c
 8000ba2: 192c         	adds	r4, r5, r4
 8000ba4: f10c 33ff    	add.w	r3, r12, #0xffffffff
 8000ba8: d204         	bhs	0x8000bb4 <__udivmoddi4+0x10c> @ imm = #0x8
 8000baa: 42a7         	cmp	r7, r4
 8000bac: d902         	bls	0x8000bb4 <__udivmoddi4+0x10c> @ imm = #0x4
 8000bae: f1ac 0302    	sub.w	r3, r12, #0x2
 8000bb2: 442c         	add	r4, r5
 8000bb4: 1be4         	subs	r4, r4, r7
 8000bb6: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 8000bba: e7c0         	b	0x8000b3e <__udivmoddi4+0x96> @ imm = #-0x80
 8000bbc: f1c2 0320    	rsb.w	r3, r2, #0x20
 8000bc0: fa20 f103    	lsr.w	r1, r0, r3
 8000bc4: 4095         	lsls	r5, r2
 8000bc6: 4090         	lsls	r0, r2
 8000bc8: fa2e f303    	lsr.w	r3, lr, r3
 8000bcc: 4303         	orrs	r3, r0
 8000bce: ea4f 4e15    	lsr.w	lr, r5, #0x10
 8000bd2: b2af         	uxth	r7, r5
 8000bd4: fbb1 fcfe    	udiv	r12, r1, lr
 8000bd8: fb0e 101c    	mls	r0, lr, r12, r1
 8000bdc: 0c19         	lsrs	r1, r3, #0x10
 8000bde: fb0c f807    	mul	r8, r12, r7
 8000be2: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 8000be6: 4588         	cmp	r8, r1
 8000be8: fa04 f402    	lsl.w	r4, r4, r2
 8000bec: d922         	bls	0x8000c34 <__udivmoddi4+0x18c> @ imm = #0x44
 8000bee: 1869         	adds	r1, r5, r1
 8000bf0: f10c 30ff    	add.w	r0, r12, #0xffffffff
 8000bf4: d204         	bhs	0x8000c00 <__udivmoddi4+0x158> @ imm = #0x8
 8000bf6: 4588         	cmp	r8, r1
 8000bf8: d902         	bls	0x8000c00 <__udivmoddi4+0x158> @ imm = #0x4
 8000bfa: f1ac 0002    	sub.w	r0, r12, #0x2
 8000bfe: 4429         	add	r1, r5
 8000c00: eba1 0108    	sub.w	r1, r1, r8
 8000c04: b29b         	uxth	r3, r3
 8000c06: fbb1 fcfe    	udiv	r12, r1, lr
 8000c0a: fb0e 111c    	mls	r1, lr, r12, r1
 8000c0e: fb0c f707    	mul	r7, r12, r7
 8000c12: ea43 4301    	orr.w	r3, r3, r1, lsl #16
 8000c16: 429f         	cmp	r7, r3
 8000c18: d90e         	bls	0x8000c38 <__udivmoddi4+0x190> @ imm = #0x1c
 8000c1a: 18eb         	adds	r3, r5, r3
 8000c1c: f10c 31ff    	add.w	r1, r12, #0xffffffff
 8000c20: d204         	bhs	0x8000c2c <__udivmoddi4+0x184> @ imm = #0x8
 8000c22: 429f         	cmp	r7, r3
 8000c24: d902         	bls	0x8000c2c <__udivmoddi4+0x184> @ imm = #0x4
 8000c26: f1ac 0102    	sub.w	r1, r12, #0x2
 8000c2a: 442b         	add	r3, r5
 8000c2c: 1bdb         	subs	r3, r3, r7
 8000c2e: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 8000c32: e792         	b	0x8000b5a <__udivmoddi4+0xb2> @ imm = #-0xdc
 8000c34: 4660         	mov	r0, r12
 8000c36: e7e3         	b	0x8000c00 <__udivmoddi4+0x158> @ imm = #-0x3a
 8000c38: 4661         	mov	r1, r12
 8000c3a: e7f7         	b	0x8000c2c <__udivmoddi4+0x184> @ imm = #-0x12
 8000c3c: 4660         	mov	r0, r12
 8000c3e: e7a3         	b	0x8000b88 <__udivmoddi4+0xe0> @ imm = #-0xba
 8000c40: 4663         	mov	r3, r12
 8000c42: e7b7         	b	0x8000bb4 <__udivmoddi4+0x10c> @ imm = #-0x92
 8000c44: 4283         	cmp	r3, r0
 8000c46: d906         	bls	0x8000c56 <__udivmoddi4+0x1ae> @ imm = #0xc
 8000c48: b916         	cbnz	r6, 0x8000c50 <__udivmoddi4+0x1a8> @ imm = #0x4
 8000c4a: 2100         	movs	r1, #0x0
 8000c4c: 4608         	mov	r0, r1
 8000c4e: e77b         	b	0x8000b48 <__udivmoddi4+0xa0> @ imm = #-0x10a
 8000c50: e9c6 e000    	strd	lr, r0, [r6]
 8000c54: e7f9         	b	0x8000c4a <__udivmoddi4+0x1a2> @ imm = #-0xe
 8000c56: fab3 f783    	clz	r7, r3
 8000c5a: b98f         	cbnz	r7, 0x8000c80 <__udivmoddi4+0x1d8> @ imm = #0x22
 8000c5c: 4283         	cmp	r3, r0
 8000c5e: d301         	blo	0x8000c64 <__udivmoddi4+0x1bc> @ imm = #0x2
 8000c60: 4572         	cmp	r2, lr
 8000c62: d808         	bhi	0x8000c76 <__udivmoddi4+0x1ce> @ imm = #0x10
 8000c64: ebbe 0402    	subs.w	r4, lr, r2
 8000c68: eb60 0303    	sbc.w	r3, r0, r3
 8000c6c: 2001         	movs	r0, #0x1
 8000c6e: 469c         	mov	r12, r3
 8000c70: b91e         	cbnz	r6, 0x8000c7a <__udivmoddi4+0x1d2> @ imm = #0x6
 8000c72: 2100         	movs	r1, #0x0
 8000c74: e768         	b	0x8000b48 <__udivmoddi4+0xa0> @ imm = #-0x130
 8000c76: 4638         	mov	r0, r7
 8000c78: e7fa         	b	0x8000c70 <__udivmoddi4+0x1c8> @ imm = #-0xc
 8000c7a: e9c6 4c00    	strd	r4, r12, [r6]
 8000c7e: e7f8         	b	0x8000c72 <__udivmoddi4+0x1ca> @ imm = #-0x10
 8000c80: f1c7 0c20    	rsb.w	r12, r7, #0x20
 8000c84: 40bb         	lsls	r3, r7
 8000c86: fa22 f40c    	lsr.w	r4, r2, r12
 8000c8a: 431c         	orrs	r4, r3
 8000c8c: fa2e f10c    	lsr.w	r1, lr, r12
 8000c90: fa20 f30c    	lsr.w	r3, r0, r12
 8000c94: 40b8         	lsls	r0, r7
 8000c96: 4301         	orrs	r1, r0
 8000c98: ea4f 4914    	lsr.w	r9, r4, #0x10
 8000c9c: fa0e f507    	lsl.w	r5, lr, r7
 8000ca0: fbb3 f8f9    	udiv	r8, r3, r9
 8000ca4: fa1f fe84    	uxth.w	lr, r4
 8000ca8: fb09 3018    	mls	r0, r9, r8, r3
 8000cac: 0c0b         	lsrs	r3, r1, #0x10
 8000cae: fb08 fa0e    	mul	r10, r8, lr
 8000cb2: ea43 4300    	orr.w	r3, r3, r0, lsl #16
 8000cb6: 459a         	cmp	r10, r3
 8000cb8: fa02 f207    	lsl.w	r2, r2, r7
 8000cbc: d940         	bls	0x8000d40 <__udivmoddi4+0x298> @ imm = #0x80
 8000cbe: 18e3         	adds	r3, r4, r3
 8000cc0: f108 30ff    	add.w	r0, r8, #0xffffffff
 8000cc4: d204         	bhs	0x8000cd0 <__udivmoddi4+0x228> @ imm = #0x8
 8000cc6: 459a         	cmp	r10, r3
 8000cc8: d902         	bls	0x8000cd0 <__udivmoddi4+0x228> @ imm = #0x4
 8000cca: f1a8 0002    	sub.w	r0, r8, #0x2
 8000cce: 4423         	add	r3, r4
 8000cd0: eba3 030a    	sub.w	r3, r3, r10
 8000cd4: b289         	uxth	r1, r1
 8000cd6: fbb3 f8f9    	udiv	r8, r3, r9
 8000cda: fb09 3318    	mls	r3, r9, r8, r3
 8000cde: fb08 fe0e    	mul	lr, r8, lr
 8000ce2: ea41 4103    	orr.w	r1, r1, r3, lsl #16
 8000ce6: 458e         	cmp	lr, r1
 8000ce8: d92c         	bls	0x8000d44 <__udivmoddi4+0x29c> @ imm = #0x58
 8000cea: 1861         	adds	r1, r4, r1
 8000cec: f108 33ff    	add.w	r3, r8, #0xffffffff
 8000cf0: d204         	bhs	0x8000cfc <__udivmoddi4+0x254> @ imm = #0x8
 8000cf2: 458e         	cmp	lr, r1
 8000cf4: d902         	bls	0x8000cfc <__udivmoddi4+0x254> @ imm = #0x4
 8000cf6: f1a8 0302    	sub.w	r3, r8, #0x2
 8000cfa: 4421         	add	r1, r4
 8000cfc: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 8000d00: fba0 9802    	umull	r9, r8, r0, r2
 8000d04: eba1 010e    	sub.w	r1, r1, lr
 8000d08: 4541         	cmp	r1, r8
 8000d0a: 46ce         	mov	lr, r9
 8000d0c: 4643         	mov	r3, r8
 8000d0e: d302         	blo	0x8000d16 <__udivmoddi4+0x26e> @ imm = #0x4
 8000d10: d106         	bne	0x8000d20 <__udivmoddi4+0x278> @ imm = #0xc
 8000d12: 454d         	cmp	r5, r9
 8000d14: d204         	bhs	0x8000d20 <__udivmoddi4+0x278> @ imm = #0x8
 8000d16: ebb9 0e02    	subs.w	lr, r9, r2
 8000d1a: eb68 0304    	sbc.w	r3, r8, r4
 8000d1e: 3801         	subs	r0, #0x1
 8000d20: 2e00         	cmp	r6, #0x0
 8000d22: d0a6         	beq	0x8000c72 <__udivmoddi4+0x1ca> @ imm = #-0xb4
 8000d24: ebb5 020e    	subs.w	r2, r5, lr
 8000d28: eb61 0103    	sbc.w	r1, r1, r3
 8000d2c: fa01 fc0c    	lsl.w	r12, r1, r12
 8000d30: fa22 f307    	lsr.w	r3, r2, r7
 8000d34: ea4c 0303    	orr.w	r3, r12, r3
 8000d38: 40f9         	lsrs	r1, r7
 8000d3a: e9c6 3100    	strd	r3, r1, [r6]
 8000d3e: e798         	b	0x8000c72 <__udivmoddi4+0x1ca> @ imm = #-0xd0
 8000d40: 4640         	mov	r0, r8
 8000d42: e7c5         	b	0x8000cd0 <__udivmoddi4+0x228> @ imm = #-0x76
 8000d44: 4643         	mov	r3, r8
 8000d46: e7d9         	b	0x8000cfc <__udivmoddi4+0x254> @ imm = #-0x4e

08000d48 <sensor_value_to_double>:
; {
 8000d48: b5b0         	push	{r4, r5, r7, lr}
 8000d4a: b082         	sub	sp, #0x8
 8000d4c: af00         	add	r7, sp, #0x0
 8000d4e: 6078         	str	r0, [r7, #0x4]
; 	return (double)val->val1 + (double)val->val2 / 1000000;
 8000d50: 687b         	ldr	r3, [r7, #0x4]
 8000d52: 681b         	ldr	r3, [r3]
 8000d54: 4618         	mov	r0, r3
 8000d56: f7ff fb69    	bl	0x800042c <__floatsidf> @ imm = #-0x92e
 8000d5a: 4604         	mov	r4, r0
 8000d5c: 460d         	mov	r5, r1
 8000d5e: 687b         	ldr	r3, [r7, #0x4]
 8000d60: 685b         	ldr	r3, [r3, #0x4]
 8000d62: 4618         	mov	r0, r3
 8000d64: f7ff fb62    	bl	0x800042c <__floatsidf> @ imm = #-0x93c
 8000d68: a30b         	adr	r3, #44 <sensor_value_to_double+0x2f>
 8000d6a: e9d3 2300    	ldrd	r2, r3, [r3]
 8000d6e: f7ff fcf1    	bl	0x8000754 <__divdf3>    @ imm = #-0x61e
 8000d72: 4602         	mov	r2, r0
 8000d74: 460b         	mov	r3, r1
 8000d76: 4620         	mov	r0, r4
 8000d78: 4629         	mov	r1, r5
 8000d7a: f7ff fa0b    	bl	0x8000194 <__aeabi_dadd> @ imm = #-0xbea
 8000d7e: 4602         	mov	r2, r0
 8000d80: 460b         	mov	r3, r1
 8000d82: ec43 2b17    	vmov	d7, r2, r3
; }
 8000d86: eeb0 0a47    	vmov.f32	s0, s14
 8000d8a: eef0 0a67    	vmov.f32	s1, s15
 8000d8e: 3708         	adds	r7, #0x8
 8000d90: 46bd         	mov	sp, r7
 8000d92: bdb0         	pop	{r4, r5, r7, pc}
 8000d94: f3af 8000    	nop.w

08000d98 <$d>:
 8000d98: 00 00 00 00  	.word	0x00000000
 8000d9c: 80 84 2e 41  	.word	0x412e8480

08000da0 <pwm_set>:
; {
 8000da0: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8000da4: b090         	sub	sp, #0x40
 8000da6: af02         	add	r7, sp, #0x8
 8000da8: 6178         	str	r0, [r7, #0x14]
 8000daa: 6139         	str	r1, [r7, #0x10]
 8000dac: 60fa         	str	r2, [r7, #0xc]
 8000dae: 60bb         	str	r3, [r7, #0x8]
; 	err = pwm_get_cycles_per_sec(dev, channel, &cycles_per_sec);
 8000db0: f107 0318    	add.w	r3, r7, #0x18
 8000db4: 461a         	mov	r2, r3
 8000db6: 6939         	ldr	r1, [r7, #0x10]
 8000db8: 6978         	ldr	r0, [r7, #0x14]
 8000dba: f014 ff66    	bl	0x8015c8a <pwm_get_cycles_per_sec> @ imm = #0x14ecc
 8000dbe: 6378         	str	r0, [r7, #0x34]
; 	if (err < 0) {
 8000dc0: 6b7b         	ldr	r3, [r7, #0x34]
 8000dc2: 2b00         	cmp	r3, #0x0
 8000dc4: da01         	bge	0x8000dca <pwm_set+0x2a> @ imm = #0x2
; 		return err;
 8000dc6: 6b7b         	ldr	r3, [r7, #0x34]
 8000dc8: e050         	b	0x8000e6c <pwm_set+0xcc> @ imm = #0xa0
; 	period_cycles = (period * cycles_per_sec) / NSEC_PER_SEC;
 8000dca: 68fb         	ldr	r3, [r7, #0xc]
 8000dcc: 2200         	movs	r2, #0x0
 8000dce: 603b         	str	r3, [r7]
 8000dd0: 607a         	str	r2, [r7, #0x4]
 8000dd2: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8000dd6: 6879         	ldr	r1, [r7, #0x4]
 8000dd8: fb02 f001    	mul	r0, r2, r1
 8000ddc: 6839         	ldr	r1, [r7]
 8000dde: fb01 f103    	mul	r1, r1, r3
 8000de2: 4401         	add	r1, r0
 8000de4: 6838         	ldr	r0, [r7]
 8000de6: fba0 8902    	umull	r8, r9, r0, r2
 8000dea: eb01 0309    	add.w	r3, r1, r9
 8000dee: 4699         	mov	r9, r3
 8000df0: a321         	adr	r3, #132 <pwm_set+0x75>
 8000df2: e9d3 2300    	ldrd	r2, r3, [r3]
 8000df6: 4640         	mov	r0, r8
 8000df8: 4649         	mov	r1, r9
 8000dfa: f7ff fe33    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x39a
 8000dfe: 4602         	mov	r2, r0
 8000e00: 460b         	mov	r3, r1
 8000e02: e9c7 230a    	strd	r2, r3, [r7, #40]
; 	if (period_cycles > UINT32_MAX) {
 8000e06: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8000e0a: 2b01         	cmp	r3, #0x1
 8000e0c: d302         	blo	0x8000e14 <pwm_set+0x74> @ imm = #0x4
; 		return -ENOTSUP;
 8000e0e: f06f 0385    	mvn	r3, #0x85
 8000e12: e02b         	b	0x8000e6c <pwm_set+0xcc> @ imm = #0x56
; 	pulse_cycles = (pulse * cycles_per_sec) / NSEC_PER_SEC;
 8000e14: 68bb         	ldr	r3, [r7, #0x8]
 8000e16: 2200         	movs	r2, #0x0
 8000e18: 469a         	mov	r10, r3
 8000e1a: 4693         	mov	r11, r2
 8000e1c: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8000e20: fb02 f00b    	mul	r0, r2, r11
 8000e24: fb0a f103    	mul	r1, r10, r3
 8000e28: 4401         	add	r1, r0
 8000e2a: fbaa 4502    	umull	r4, r5, r10, r2
 8000e2e: 194b         	adds	r3, r1, r5
 8000e30: 461d         	mov	r5, r3
 8000e32: a311         	adr	r3, #68 <pwm_set+0xa7>
 8000e34: e9d3 2300    	ldrd	r2, r3, [r3]
 8000e38: 4620         	mov	r0, r4
 8000e3a: 4629         	mov	r1, r5
 8000e3c: f7ff fe12    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x3dc
 8000e40: 4602         	mov	r2, r0
 8000e42: 460b         	mov	r3, r1
 8000e44: e9c7 2308    	strd	r2, r3, [r7, #32]
; 	if (pulse_cycles > UINT32_MAX) {
 8000e48: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8000e4c: 2b01         	cmp	r3, #0x1
 8000e4e: d302         	blo	0x8000e56 <pwm_set+0xb6> @ imm = #0x4
; 		return -ENOTSUP;
 8000e50: f06f 0385    	mvn	r3, #0x85
 8000e54: e00a         	b	0x8000e6c <pwm_set+0xcc> @ imm = #0x14
; 	return pwm_set_cycles(dev, channel, (uint32_t)period_cycles,
 8000e56: 6aba         	ldr	r2, [r7, #0x28]
 8000e58: 6a39         	ldr	r1, [r7, #0x20]
 8000e5a: f8b7 3058    	ldrh.w	r3, [r7, #0x58]
 8000e5e: 9300         	str	r3, [sp]
 8000e60: 460b         	mov	r3, r1
 8000e62: 6939         	ldr	r1, [r7, #0x10]
 8000e64: 6978         	ldr	r0, [r7, #0x14]
 8000e66: f014 fefc    	bl	0x8015c62 <pwm_set_cycles> @ imm = #0x14df8
 8000e6a: 4603         	mov	r3, r0
; }
 8000e6c: 4618         	mov	r0, r3
 8000e6e: 3738         	adds	r7, #0x38
 8000e70: 46bd         	mov	sp, r7
 8000e72: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 8000e76: bf00         	nop

08000e78 <$d>:
 8000e78: 00 ca 9a 3b  	.word	0x3b9aca00
 8000e7c: 00 00 00 00  	.word	0x00000000

08000e80 <console_feedback>:
; {
 8000e80: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000e84: b0b3         	sub	sp, #0xcc
 8000e86: af10         	add	r7, sp, #0x40
 8000e88: 61f8         	str	r0, [r7, #0x1c]
 8000e8a: 61b9         	str	r1, [r7, #0x18]
 8000e8c: 617a         	str	r2, [r7, #0x14]
; 	int n = 0;
 8000e8e: 2300         	movs	r3, #0x0
 8000e90: 677b         	str	r3, [r7, #0x74]
; 	memset(sum, 0, 6 * sizeof(float));
 8000e92: f107 0320    	add.w	r3, r7, #0x20
 8000e96: 2218         	movs	r2, #0x18
 8000e98: 2100         	movs	r1, #0x0
 8000e9a: 4618         	mov	r0, r3
 8000e9c: f01e ff1c    	bl	0x801fcd8 <memset>      @ imm = #0x1ee38
; 		sensor_sample_fetch(accel_dev);
 8000ea0: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x80010e0 <console_feedback+0x260>
 8000ea2: 681b         	ldr	r3, [r3]
 8000ea4: 4618         	mov	r0, r3
 8000ea6: f014 fbda    	bl	0x801565e <sensor_sample_fetch> @ imm = #0x147b4
; 		sensor_sample_fetch(gyro_dev);
 8000eaa: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x80010e4 <console_feedback+0x264>
 8000eac: 681b         	ldr	r3, [r3]
 8000eae: 4618         	mov	r0, r3
 8000eb0: f014 fbd5    	bl	0x801565e <sensor_sample_fetch> @ imm = #0x147aa
; 		sensor_channel_get(accel_dev, SENSOR_CHAN_ACCEL_XYZ, accel);
 8000eb4: 4b8a         	ldr	r3, [pc, #0x228]        @ 0x80010e0 <console_feedback+0x260>
 8000eb6: 681b         	ldr	r3, [r3]
 8000eb8: f107 0258    	add.w	r2, r7, #0x58
 8000ebc: 2103         	movs	r1, #0x3
 8000ebe: 4618         	mov	r0, r3
 8000ec0: f014 fbd9    	bl	0x8015676 <sensor_channel_get> @ imm = #0x147b2
; 		sensor_channel_get(gyro_dev, SENSOR_CHAN_GYRO_XYZ, gyro);
 8000ec4: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x80010e4 <console_feedback+0x264>
 8000ec6: 681b         	ldr	r3, [r3]
 8000ec8: f107 0240    	add.w	r2, r7, #0x40
 8000ecc: 2107         	movs	r1, #0x7
 8000ece: 4618         	mov	r0, r3
 8000ed0: f014 fbd1    	bl	0x8015676 <sensor_channel_get> @ imm = #0x147a2
; 		sensor_channel_get(accel_dev, SENSOR_CHAN_DIE_TEMP, &temp);
 8000ed4: 4b82         	ldr	r3, [pc, #0x208]        @ 0x80010e0 <console_feedback+0x260>
 8000ed6: 681b         	ldr	r3, [r3]
 8000ed8: f107 0238    	add.w	r2, r7, #0x38
 8000edc: 210c         	movs	r1, #0xc
 8000ede: 4618         	mov	r0, r3
 8000ee0: f014 fbc9    	bl	0x8015676 <sensor_channel_get> @ imm = #0x14792
; 		for (int i = 0; i < 3; i++) {
 8000ee4: 2300         	movs	r3, #0x0
 8000ee6: f8c7 3080    	str.w	r3, [r7, #0x80]
 8000eea: e060         	b	0x8000fae <console_feedback+0x12e> @ imm = #0xc0
; 			sum[i] += sensor_value_to_double(&accel[i]);
 8000eec: f107 0258    	add.w	r2, r7, #0x58
 8000ef0: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000ef4: 00db         	lsls	r3, r3, #0x3
 8000ef6: 4413         	add	r3, r2
 8000ef8: 4618         	mov	r0, r3
 8000efa: f7ff ff25    	bl	0x8000d48 <sensor_value_to_double> @ imm = #-0x1b6
 8000efe: ec55 4b10    	vmov	r4, r5, d0
 8000f02: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000f06: 009b         	lsls	r3, r3, #0x2
 8000f08: 3378         	adds	r3, #0x78
 8000f0a: f107 0210    	add.w	r2, r7, #0x10
 8000f0e: 4413         	add	r3, r2
 8000f10: 3b68         	subs	r3, #0x68
 8000f12: 681b         	ldr	r3, [r3]
 8000f14: 4618         	mov	r0, r3
 8000f16: f7ff fa9b    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xaca
 8000f1a: 4602         	mov	r2, r0
 8000f1c: 460b         	mov	r3, r1
 8000f1e: 4620         	mov	r0, r4
 8000f20: 4629         	mov	r1, r5
 8000f22: f7ff f937    	bl	0x8000194 <__aeabi_dadd> @ imm = #-0xd92
 8000f26: 4602         	mov	r2, r0
 8000f28: 460b         	mov	r3, r1
 8000f2a: 4610         	mov	r0, r2
 8000f2c: 4619         	mov	r1, r3
 8000f2e: f7ff fcf9    	bl	0x8000924 <__truncdfsf2> @ imm = #-0x60e
 8000f32: 4602         	mov	r2, r0
 8000f34: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000f38: 009b         	lsls	r3, r3, #0x2
 8000f3a: 3378         	adds	r3, #0x78
 8000f3c: f107 0110    	add.w	r1, r7, #0x10
 8000f40: 440b         	add	r3, r1
 8000f42: 3b68         	subs	r3, #0x68
 8000f44: 601a         	str	r2, [r3]
; 			sum[i + 3] += sensor_value_to_double(&gyro[i]);
 8000f46: f107 0240    	add.w	r2, r7, #0x40
 8000f4a: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000f4e: 00db         	lsls	r3, r3, #0x3
 8000f50: 4413         	add	r3, r2
 8000f52: 4618         	mov	r0, r3
 8000f54: f7ff fef8    	bl	0x8000d48 <sensor_value_to_double> @ imm = #-0x210
 8000f58: ec55 4b10    	vmov	r4, r5, d0
 8000f5c: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000f60: 3303         	adds	r3, #0x3
 8000f62: 009b         	lsls	r3, r3, #0x2
 8000f64: 3378         	adds	r3, #0x78
 8000f66: f107 0210    	add.w	r2, r7, #0x10
 8000f6a: 4413         	add	r3, r2
 8000f6c: 3b68         	subs	r3, #0x68
 8000f6e: 681b         	ldr	r3, [r3]
 8000f70: 4618         	mov	r0, r3
 8000f72: f7ff fa6d    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xb26
 8000f76: 4602         	mov	r2, r0
 8000f78: 460b         	mov	r3, r1
 8000f7a: 4620         	mov	r0, r4
 8000f7c: 4629         	mov	r1, r5
 8000f7e: f7ff f909    	bl	0x8000194 <__aeabi_dadd> @ imm = #-0xdee
 8000f82: 4602         	mov	r2, r0
 8000f84: 460b         	mov	r3, r1
 8000f86: 4610         	mov	r0, r2
 8000f88: 4619         	mov	r1, r3
 8000f8a: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000f8e: 1cdc         	adds	r4, r3, #0x3
 8000f90: f7ff fcc8    	bl	0x8000924 <__truncdfsf2> @ imm = #-0x670
 8000f94: 4602         	mov	r2, r0
 8000f96: 00a3         	lsls	r3, r4, #0x2
 8000f98: 3378         	adds	r3, #0x78
 8000f9a: f107 0110    	add.w	r1, r7, #0x10
 8000f9e: 440b         	add	r3, r1
 8000fa0: 3b68         	subs	r3, #0x68
 8000fa2: 601a         	str	r2, [r3]
; 		for (int i = 0; i < 3; i++) {
 8000fa4: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000fa8: 3301         	adds	r3, #0x1
 8000faa: f8c7 3080    	str.w	r3, [r7, #0x80]
 8000fae: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000fb2: 2b02         	cmp	r3, #0x2
 8000fb4: dd9a         	ble	0x8000eec <console_feedback+0x6c> @ imm = #-0xcc
; 		LOG_INF("Accel: %.3f %.3f %.3f, Gyro: %.3f %.3f %.3f", sum[0], sum[1], sum[2],
 8000fb6: 2304         	movs	r3, #0x4
 8000fb8: 2b02         	cmp	r3, #0x2
 8000fba: d94d         	bls	0x8001058 <console_feedback+0x1d8> @ imm = #0x9a
 8000fbc: 2301         	movs	r3, #0x1
 8000fbe: f887 307f    	strb.w	r3, [r7, #0x7f]
 8000fc2: f897 307f    	ldrb.w	r3, [r7, #0x7f]
 8000fc6: f083 0301    	eor	r3, r3, #0x1
 8000fca: b2db         	uxtb	r3, r3
 8000fcc: 2b00         	cmp	r3, #0x0
 8000fce: d143         	bne	0x8001058 <console_feedback+0x1d8> @ imm = #0x86
 8000fd0: 4b45         	ldr	r3, [pc, #0x114]        @ 0x80010e8 <console_feedback+0x268>
 8000fd2: 681e         	ldr	r6, [r3]
 8000fd4: 6a3b         	ldr	r3, [r7, #0x20]
 8000fd6: 4618         	mov	r0, r3
 8000fd8: f7ff fa3a    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xb8c
 8000fdc: 4604         	mov	r4, r0
 8000fde: 460d         	mov	r5, r1
 8000fe0: 6a7b         	ldr	r3, [r7, #0x24]
 8000fe2: 4618         	mov	r0, r3
 8000fe4: f7ff fa34    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xb98
 8000fe8: 4680         	mov	r8, r0
 8000fea: 4689         	mov	r9, r1
 8000fec: 6abb         	ldr	r3, [r7, #0x28]
 8000fee: 4618         	mov	r0, r3
 8000ff0: f7ff fa2e    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xba4
 8000ff4: 4682         	mov	r10, r0
 8000ff6: 468b         	mov	r11, r1
 8000ff8: 6afb         	ldr	r3, [r7, #0x2c]
 8000ffa: 4618         	mov	r0, r3
 8000ffc: f7ff fa28    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xbb0
 8001000: e9c7 0102    	strd	r0, r1, [r7, #8]
 8001004: 6b3b         	ldr	r3, [r7, #0x30]
 8001006: 4618         	mov	r0, r3
 8001008: f7ff fa22    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xbbc
 800100c: e9c7 0100    	strd	r0, r1, [r7]
 8001010: 6b7b         	ldr	r3, [r7, #0x34]
 8001012: 4618         	mov	r0, r3
 8001014: f7ff fa1c    	bl	0x8000450 <__extendsfdf2> @ imm = #-0xbc8
 8001018: 4602         	mov	r2, r0
 800101a: 460b         	mov	r3, r1
 800101c: e9cd 230e    	strd	r2, r3, [sp, #56]
 8001020: ed97 7b00    	vldr	d7, [r7]
 8001024: ed8d 7b0c    	vstr	d7, [sp, #48]
 8001028: ed97 7b02    	vldr	d7, [r7, #8]
 800102c: ed8d 7b0a    	vstr	d7, [sp, #40]
 8001030: e9cd ab08    	strd	r10, r11, [sp, #32]
 8001034: e9cd 8906    	strd	r8, r9, [sp, #24]
 8001038: e9cd 4504    	strd	r4, r5, [sp, #16]
 800103c: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x80010ec <console_feedback+0x26c>
 800103e: 9302         	str	r3, [sp, #0x8]
 8001040: 2300         	movs	r3, #0x0
 8001042: 9301         	str	r3, [sp, #0x4]
 8001044: 2300         	movs	r3, #0x0
 8001046: 9300         	str	r3, [sp]
 8001048: 2300         	movs	r3, #0x0
 800104a: 2203         	movs	r2, #0x3
 800104c: 4631         	mov	r1, r6
 800104e: 2000         	movs	r0, #0x0
 8001050: f014 fa2c    	bl	0x80154ac <z_log_msg_runtime_create> @ imm = #0x14458
 8001054: 2300         	movs	r3, #0x0
 8001056: 67bb         	str	r3, [r7, #0x78]
; 		n++;
 8001058: 6f7b         	ldr	r3, [r7, #0x74]
 800105a: 3301         	adds	r3, #0x1
 800105c: 677b         	str	r3, [r7, #0x74]
; 		LOG_INF("i %d. t %.3f sec. temp %.3f deg", n, n * 0.2,
 800105e: 2304         	movs	r3, #0x4
 8001060: 2b02         	cmp	r3, #0x2
 8001062: d935         	bls	0x80010d0 <console_feedback+0x250> @ imm = #0x6a
 8001064: 2301         	movs	r3, #0x1
 8001066: f887 3073    	strb.w	r3, [r7, #0x73]
 800106a: f897 3073    	ldrb.w	r3, [r7, #0x73]
 800106e: f083 0301    	eor	r3, r3, #0x1
 8001072: b2db         	uxtb	r3, r3
 8001074: 2b00         	cmp	r3, #0x0
 8001076: d12b         	bne	0x80010d0 <console_feedback+0x250> @ imm = #0x56
 8001078: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x80010e8 <console_feedback+0x268>
 800107a: 681e         	ldr	r6, [r3]
 800107c: 6f78         	ldr	r0, [r7, #0x74]
 800107e: f7ff f9d5    	bl	0x800042c <__floatsidf> @ imm = #-0xc56
 8001082: a315         	adr	r3, #84 <console_feedback+0x21b>
 8001084: e9d3 2300    	ldrd	r2, r3, [r3]
 8001088: f7ff fa3a    	bl	0x8000500 <__muldf3>    @ imm = #-0xb8c
 800108c: 4602         	mov	r2, r0
 800108e: 460b         	mov	r3, r1
 8001090: 4614         	mov	r4, r2
 8001092: 461d         	mov	r5, r3
 8001094: f107 0338    	add.w	r3, r7, #0x38
 8001098: 4618         	mov	r0, r3
 800109a: f7ff fe55    	bl	0x8000d48 <sensor_value_to_double> @ imm = #-0x356
 800109e: eeb0 7a40    	vmov.f32	s14, s0
 80010a2: eef0 7a60    	vmov.f32	s15, s1
 80010a6: ed8d 7b06    	vstr	d7, [sp, #24]
 80010aa: e9cd 4504    	strd	r4, r5, [sp, #16]
 80010ae: 6f7b         	ldr	r3, [r7, #0x74]
 80010b0: 9303         	str	r3, [sp, #0xc]
 80010b2: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80010f0 <console_feedback+0x270>
 80010b4: 9302         	str	r3, [sp, #0x8]
 80010b6: 2300         	movs	r3, #0x0
 80010b8: 9301         	str	r3, [sp, #0x4]
 80010ba: 2300         	movs	r3, #0x0
 80010bc: 9300         	str	r3, [sp]
 80010be: 2300         	movs	r3, #0x0
 80010c0: 2203         	movs	r2, #0x3
 80010c2: 4631         	mov	r1, r6
 80010c4: 2000         	movs	r0, #0x0
 80010c6: f014 f9f1    	bl	0x80154ac <z_log_msg_runtime_create> @ imm = #0x143e2
 80010ca: 2300         	movs	r3, #0x0
 80010cc: f8c7 3084    	str.w	r3, [r7, #0x84]
; 		k_msleep(200);
 80010d0: 20c8         	movs	r0, #0xc8
 80010d2: f014 fa09    	bl	0x80154e8 <k_msleep>    @ imm = #0x14412
; 		sensor_sample_fetch(accel_dev);
 80010d6: e6e3         	b	0x8000ea0 <console_feedback+0x20> @ imm = #-0x23a

080010d8 <$d>:
 80010d8: 9a 99 99 99  	.word	0x9999999a
 80010dc: 99 99 c9 3f  	.word	0x3fc99999
 80010e0: f0 04 00 20  	.word	0x200004f0
 80010e4: f4 04 00 20  	.word	0x200004f4
 80010e8: e8 04 00 20  	.word	0x200004e8
 80010ec: c0 07 02 08  	.word	0x080207c0
 80010f0: ec 07 02 08  	.word	0x080207ec
 80010f4: 00 00 00 00  	.word	0x00000000

080010f8 <sensor_ms2_to_g>:
; {
 80010f8: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 80010fc: b090         	sub	sp, #0x40
 80010fe: af00         	add	r7, sp, #0x0
 8001100: 6378         	str	r0, [r7, #0x34]
; 	int64_t micro_ms2 = ms2->val1 * 1000000LL + ms2->val2;
 8001102: 6b7b         	ldr	r3, [r7, #0x34]
 8001104: 681b         	ldr	r3, [r3]
 8001106: 17da         	asrs	r2, r3, #0x1f
 8001108: 469a         	mov	r10, r3
 800110a: 4693         	mov	r11, r2
 800110c: 4652         	mov	r2, r10
 800110e: 465b         	mov	r3, r11
 8001110: f04f 0000    	mov.w	r0, #0x0
 8001114: f04f 0100    	mov.w	r1, #0x0
 8001118: 0159         	lsls	r1, r3, #0x5
 800111a: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 800111e: 0150         	lsls	r0, r2, #0x5
 8001120: 4602         	mov	r2, r0
 8001122: 460b         	mov	r3, r1
 8001124: ebb2 040a    	subs.w	r4, r2, r10
 8001128: eb63 050b    	sbc.w	r5, r3, r11
 800112c: f04f 0200    	mov.w	r2, #0x0
 8001130: f04f 0300    	mov.w	r3, #0x0
 8001134: 026b         	lsls	r3, r5, #0x9
 8001136: ea43 53d4    	orr.w	r3, r3, r4, lsr #23
 800113a: 0262         	lsls	r2, r4, #0x9
 800113c: 4614         	mov	r4, r2
 800113e: 461d         	mov	r5, r3
 8001140: eb14 080a    	adds.w	r8, r4, r10
 8001144: eb45 090b    	adc.w	r9, r5, r11
 8001148: f04f 0200    	mov.w	r2, #0x0
 800114c: f04f 0300    	mov.w	r3, #0x0
 8001150: ea4f 1389    	lsl.w	r3, r9, #0x6
 8001154: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 8001158: ea4f 1288    	lsl.w	r2, r8, #0x6
 800115c: ebb2 0108    	subs.w	r1, r2, r8
 8001160: 60b9         	str	r1, [r7, #0x8]
 8001162: eb63 0309    	sbc.w	r3, r3, r9
 8001166: 60fb         	str	r3, [r7, #0xc]
 8001168: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 800116c: 460b         	mov	r3, r1
 800116e: eb13 030a    	adds.w	r3, r3, r10
 8001172: 62bb         	str	r3, [r7, #0x28]
 8001174: 4613         	mov	r3, r2
 8001176: eb43 030b    	adc.w	r3, r3, r11
 800117a: 62fb         	str	r3, [r7, #0x2c]
 800117c: 6b7b         	ldr	r3, [r7, #0x34]
 800117e: 685b         	ldr	r3, [r3, #0x4]
 8001180: 17da         	asrs	r2, r3, #0x1f
 8001182: 623b         	str	r3, [r7, #0x20]
 8001184: 627a         	str	r2, [r7, #0x24]
 8001186: e9d7 450a    	ldrd	r4, r5, [r7, #40]
 800118a: 4623         	mov	r3, r4
 800118c: e9d7 0108    	ldrd	r0, r1, [r7, #32]
 8001190: 4602         	mov	r2, r0
 8001192: 189b         	adds	r3, r3, r2
 8001194: 603b         	str	r3, [r7]
 8001196: 460b         	mov	r3, r1
 8001198: 462a         	mov	r2, r5
 800119a: eb42 0303    	adc.w	r3, r2, r3
 800119e: 607b         	str	r3, [r7, #0x4]
 80011a0: e9d7 3400    	ldrd	r3, r4, [r7]
 80011a4: e9c7 340e    	strd	r3, r4, [r7, #56]
; 	if (micro_ms2 > 0) {
 80011a8: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 80011ac: 2a01         	cmp	r2, #0x1
 80011ae: f173 0300    	sbcs	r3, r3, #0x0
 80011b2: db12         	blt	0x80011da <sensor_ms2_to_g+0xe2> @ imm = #0x24
; 		return (micro_ms2 + SENSOR_G / 2) / SENSOR_G;
 80011b4: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 80011b8: 4915         	ldr	r1, [pc, #0x54]         @ 0x8001210 <sensor_ms2_to_g+0x118>
 80011ba: 1851         	adds	r1, r2, r1
 80011bc: 61b9         	str	r1, [r7, #0x18]
 80011be: f143 0300    	adc	r3, r3, #0x0
 80011c2: 61fb         	str	r3, [r7, #0x1c]
 80011c4: a310         	adr	r3, #64 <sensor_ms2_to_g+0xe0>
 80011c6: e9d3 2300    	ldrd	r2, r3, [r3]
 80011ca: e9d7 0106    	ldrd	r0, r1, [r7, #24]
 80011ce: f7ff fbf9    	bl	0x80009c4 <__aeabi_ldivmod> @ imm = #-0x80e
 80011d2: 4602         	mov	r2, r0
 80011d4: 460b         	mov	r3, r1
 80011d6: 4613         	mov	r3, r2
 80011d8: e011         	b	0x80011fe <sensor_ms2_to_g+0x106> @ imm = #0x22
; 		return (micro_ms2 - SENSOR_G / 2) / SENSOR_G;
 80011da: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 80011de: 490d         	ldr	r1, [pc, #0x34]         @ 0x8001214 <sensor_ms2_to_g+0x11c>
 80011e0: 1851         	adds	r1, r2, r1
 80011e2: 6139         	str	r1, [r7, #0x10]
 80011e4: f143 33ff    	adc	r3, r3, #0xffffffff
 80011e8: 617b         	str	r3, [r7, #0x14]
 80011ea: a307         	adr	r3, #28 <sensor_ms2_to_g+0xfd>
 80011ec: e9d3 2300    	ldrd	r2, r3, [r3]
 80011f0: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 80011f4: f7ff fbe6    	bl	0x80009c4 <__aeabi_ldivmod> @ imm = #-0x834
 80011f8: 4602         	mov	r2, r0
 80011fa: 460b         	mov	r3, r1
 80011fc: 4613         	mov	r3, r2
; }
 80011fe: 4618         	mov	r0, r3
 8001200: 3740         	adds	r7, #0x40
 8001202: 46bd         	mov	sp, r7
 8001204: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08001208 <$d>:
 8001208: 3a a3 95 00  	.word	0x0095a33a
 800120c: 00 00 00 00  	.word	0x00000000
 8001210: 9d d1 4a 00  	.word	0x004ad19d
 8001214: 63 2e b5 ff  	.word	0xffb52e63

08001218 <sensor_rad_to_degrees>:
; {
 8001218: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800121c: b09c         	sub	sp, #0x70
 800121e: af00         	add	r7, sp, #0x0
 8001220: 6678         	str	r0, [r7, #0x64]
; 	int64_t micro_rad_s = rad->val1 * 1000000LL + rad->val2;
 8001222: 6e7b         	ldr	r3, [r7, #0x64]
 8001224: 681b         	ldr	r3, [r3]
 8001226: 17da         	asrs	r2, r3, #0x1f
 8001228: 65bb         	str	r3, [r7, #0x58]
 800122a: 65fa         	str	r2, [r7, #0x5c]
 800122c: e9d7 2316    	ldrd	r2, r3, [r7, #88]
 8001230: f04f 0000    	mov.w	r0, #0x0
 8001234: f04f 0100    	mov.w	r1, #0x0
 8001238: 0159         	lsls	r1, r3, #0x5
 800123a: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 800123e: 0150         	lsls	r0, r2, #0x5
 8001240: 4602         	mov	r2, r0
 8001242: 460b         	mov	r3, r1
 8001244: 6db9         	ldr	r1, [r7, #0x58]
 8001246: 1a54         	subs	r4, r2, r1
 8001248: 6df9         	ldr	r1, [r7, #0x5c]
 800124a: eb63 0501    	sbc.w	r5, r3, r1
 800124e: f04f 0200    	mov.w	r2, #0x0
 8001252: f04f 0300    	mov.w	r3, #0x0
 8001256: 026b         	lsls	r3, r5, #0x9
 8001258: ea43 53d4    	orr.w	r3, r3, r4, lsr #23
 800125c: 0262         	lsls	r2, r4, #0x9
 800125e: 4614         	mov	r4, r2
 8001260: 461d         	mov	r5, r3
 8001262: e9d7 0116    	ldrd	r0, r1, [r7, #88]
 8001266: 4603         	mov	r3, r0
 8001268: eb14 0803    	adds.w	r8, r4, r3
 800126c: e9c7 0116    	strd	r0, r1, [r7, #88]
 8001270: 460b         	mov	r3, r1
 8001272: eb45 0903    	adc.w	r9, r5, r3
 8001276: f04f 0200    	mov.w	r2, #0x0
 800127a: f04f 0300    	mov.w	r3, #0x0
 800127e: ea4f 1389    	lsl.w	r3, r9, #0x6
 8001282: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 8001286: ea4f 1288    	lsl.w	r2, r8, #0x6
 800128a: ebb2 0108    	subs.w	r1, r2, r8
 800128e: 6339         	str	r1, [r7, #0x30]
 8001290: eb63 0309    	sbc.w	r3, r3, r9
 8001294: 637b         	str	r3, [r7, #0x34]
 8001296: e9d7 450c    	ldrd	r4, r5, [r7, #48]
 800129a: 4623         	mov	r3, r4
 800129c: e9d7 0116    	ldrd	r0, r1, [r7, #88]
 80012a0: 4602         	mov	r2, r0
 80012a2: 189b         	adds	r3, r3, r2
 80012a4: 653b         	str	r3, [r7, #0x50]
 80012a6: 460b         	mov	r3, r1
 80012a8: 462a         	mov	r2, r5
 80012aa: eb42 0303    	adc.w	r3, r2, r3
 80012ae: 657b         	str	r3, [r7, #0x54]
 80012b0: 6e7b         	ldr	r3, [r7, #0x64]
 80012b2: 685b         	ldr	r3, [r3, #0x4]
 80012b4: 17da         	asrs	r2, r3, #0x1f
 80012b6: 64bb         	str	r3, [r7, #0x48]
 80012b8: 64fa         	str	r2, [r7, #0x4c]
 80012ba: e9d7 4514    	ldrd	r4, r5, [r7, #80]
 80012be: 4623         	mov	r3, r4
 80012c0: e9d7 0112    	ldrd	r0, r1, [r7, #72]
 80012c4: 4602         	mov	r2, r0
 80012c6: 189b         	adds	r3, r3, r2
 80012c8: 62bb         	str	r3, [r7, #0x28]
 80012ca: 460b         	mov	r3, r1
 80012cc: 462a         	mov	r2, r5
 80012ce: eb42 0303    	adc.w	r3, r2, r3
 80012d2: 62fb         	str	r3, [r7, #0x2c]
 80012d4: e9d7 340a    	ldrd	r3, r4, [r7, #40]
 80012d8: e9c7 341a    	strd	r3, r4, [r7, #104]
; 	if (micro_rad_s > 0) {
 80012dc: e9d7 231a    	ldrd	r2, r3, [r7, #104]
 80012e0: 2a01         	cmp	r2, #0x1
 80012e2: f173 0300    	sbcs	r3, r3, #0x0
 80012e6: db3f         	blt	0x8001368 <sensor_rad_to_degrees+0x150> @ imm = #0x7e
; 		return (micro_rad_s * 180LL + SENSOR_PI / 2) / SENSOR_PI;
 80012e8: e9d7 011a    	ldrd	r0, r1, [r7, #104]
 80012ec: 4602         	mov	r2, r0
 80012ee: 460b         	mov	r3, r1
 80012f0: 1894         	adds	r4, r2, r2
 80012f2: 623c         	str	r4, [r7, #0x20]
 80012f4: 415b         	adcs	r3, r3
 80012f6: 627b         	str	r3, [r7, #0x24]
 80012f8: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 80012fc: 1814         	adds	r4, r2, r0
 80012fe: 61bc         	str	r4, [r7, #0x18]
 8001300: 414b         	adcs	r3, r1
 8001302: 61fb         	str	r3, [r7, #0x1c]
 8001304: f04f 0200    	mov.w	r2, #0x0
 8001308: f04f 0300    	mov.w	r3, #0x0
 800130c: e9d7 4506    	ldrd	r4, r5, [r7, #24]
 8001310: 4629         	mov	r1, r5
 8001312: 010b         	lsls	r3, r1, #0x4
 8001314: 4621         	mov	r1, r4
 8001316: ea43 7311    	orr.w	r3, r3, r1, lsr #28
 800131a: 4621         	mov	r1, r4
 800131c: 010a         	lsls	r2, r1, #0x4
 800131e: 4621         	mov	r1, r4
 8001320: 1a51         	subs	r1, r2, r1
 8001322: 6139         	str	r1, [r7, #0x10]
 8001324: 4629         	mov	r1, r5
 8001326: eb63 0301    	sbc.w	r3, r3, r1
 800132a: 617b         	str	r3, [r7, #0x14]
 800132c: f04f 0200    	mov.w	r2, #0x0
 8001330: f04f 0300    	mov.w	r3, #0x0
 8001334: e9d7 4504    	ldrd	r4, r5, [r7, #16]
 8001338: 4629         	mov	r1, r5
 800133a: 008b         	lsls	r3, r1, #0x2
 800133c: 4621         	mov	r1, r4
 800133e: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 8001342: 4621         	mov	r1, r4
 8001344: 008a         	lsls	r2, r1, #0x2
 8001346: 492a         	ldr	r1, [pc, #0xa8]         @ 0x80013f0 <sensor_rad_to_degrees+0x1d8>
 8001348: 1851         	adds	r1, r2, r1
 800134a: 6439         	str	r1, [r7, #0x40]
 800134c: f143 0300    	adc	r3, r3, #0x0
 8001350: 647b         	str	r3, [r7, #0x44]
 8001352: a325         	adr	r3, #148 <sensor_rad_to_degrees+0x163>
 8001354: e9d3 2300    	ldrd	r2, r3, [r3]
 8001358: e9d7 0110    	ldrd	r0, r1, [r7, #64]
 800135c: f7ff fb32    	bl	0x80009c4 <__aeabi_ldivmod> @ imm = #-0x99c
 8001360: 4602         	mov	r2, r0
 8001362: 460b         	mov	r3, r1
 8001364: 4613         	mov	r3, r2
 8001366: e03a         	b	0x80013de <sensor_rad_to_degrees+0x1c6> @ imm = #0x74
; 		return (micro_rad_s * 180LL - SENSOR_PI / 2) / SENSOR_PI;
 8001368: e9d7 011a    	ldrd	r0, r1, [r7, #104]
 800136c: 4602         	mov	r2, r0
 800136e: 460b         	mov	r3, r1
 8001370: 1894         	adds	r4, r2, r2
 8001372: 60bc         	str	r4, [r7, #0x8]
 8001374: 415b         	adcs	r3, r3
 8001376: 60fb         	str	r3, [r7, #0xc]
 8001378: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800137c: eb12 0a00    	adds.w	r10, r2, r0
 8001380: eb43 0b01    	adc.w	r11, r3, r1
 8001384: f04f 0200    	mov.w	r2, #0x0
 8001388: f04f 0300    	mov.w	r3, #0x0
 800138c: ea4f 130b    	lsl.w	r3, r11, #0x4
 8001390: ea43 731a    	orr.w	r3, r3, r10, lsr #28
 8001394: ea4f 120a    	lsl.w	r2, r10, #0x4
 8001398: ebb2 010a    	subs.w	r1, r2, r10
 800139c: 6039         	str	r1, [r7]
 800139e: eb63 030b    	sbc.w	r3, r3, r11
 80013a2: 607b         	str	r3, [r7, #0x4]
 80013a4: f04f 0200    	mov.w	r2, #0x0
 80013a8: f04f 0300    	mov.w	r3, #0x0
 80013ac: e9d7 4500    	ldrd	r4, r5, [r7]
 80013b0: 4629         	mov	r1, r5
 80013b2: 008b         	lsls	r3, r1, #0x2
 80013b4: 4621         	mov	r1, r4
 80013b6: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 80013ba: 4621         	mov	r1, r4
 80013bc: 008a         	lsls	r2, r1, #0x2
 80013be: 490d         	ldr	r1, [pc, #0x34]         @ 0x80013f4 <sensor_rad_to_degrees+0x1dc>
 80013c0: 1851         	adds	r1, r2, r1
 80013c2: 63b9         	str	r1, [r7, #0x38]
 80013c4: f143 33ff    	adc	r3, r3, #0xffffffff
 80013c8: 63fb         	str	r3, [r7, #0x3c]
 80013ca: a307         	adr	r3, #28 <sensor_rad_to_degrees+0x1bd>
 80013cc: e9d3 2300    	ldrd	r2, r3, [r3]
 80013d0: e9d7 010e    	ldrd	r0, r1, [r7, #56]
 80013d4: f7ff faf6    	bl	0x80009c4 <__aeabi_ldivmod> @ imm = #-0xa14
 80013d8: 4602         	mov	r2, r0
 80013da: 460b         	mov	r3, r1
 80013dc: 4613         	mov	r3, r2
; }
 80013de: 4618         	mov	r0, r3
 80013e0: 3770         	adds	r7, #0x70
 80013e2: 46bd         	mov	sp, r7
 80013e4: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080013e8 <$d>:
 80013e8: d8 ef 2f 00  	.word	0x002fefd8
 80013ec: 00 00 00 00  	.word	0x00000000
 80013f0: ec f7 17 00  	.word	0x0017f7ec
 80013f4: 14 08 e8 ff  	.word	0xffe80814

080013f8 <k_current_get>:
; {
 80013f8: b580         	push	{r7, lr}
 80013fa: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 80013fc: f01e fe46    	bl	0x802008c <__aeabi_read_tp> @ imm = #0x1ec8c
 8001400: 4603         	mov	r3, r0
 8001402: 4a02         	ldr	r2, [pc, #0x8]          @ 0x800140c <k_current_get+0x14>
 8001404: 589b         	ldr	r3, [r3, r2]
; }
 8001406: 4618         	mov	r0, r3
 8001408: bd80         	pop	{r7, pc}
 800140a: bf00         	nop

0800140c <$d>:
 800140c: 08 00 00 00  	.word	0x00000008

08001410 <sensor_value_to_float>:
; {
 8001410: b480         	push	{r7}
 8001412: b083         	sub	sp, #0xc
 8001414: af00         	add	r7, sp, #0x0
 8001416: 6078         	str	r0, [r7, #0x4]
; 	return (float)val->val1 + (float)val->val2 / 1000000;
 8001418: 687b         	ldr	r3, [r7, #0x4]
 800141a: 681b         	ldr	r3, [r3]
 800141c: ee07 3a90    	vmov	s15, r3
 8001420: eeb8 7ae7    	vcvt.f32.s32	s14, s15
 8001424: 687b         	ldr	r3, [r7, #0x4]
 8001426: 685b         	ldr	r3, [r3, #0x4]
 8001428: ee07 3a90    	vmov	s15, r3
 800142c: eef8 6ae7    	vcvt.f32.s32	s13, s15
 8001430: ed9f 6a06    	vldr	s12, [pc, #24]          @ 0x800144c <sensor_value_to_float+0x3c>
 8001434: eec6 7a86    	vdiv.f32	s15, s13, s12
 8001438: ee77 7a27    	vadd.f32	s15, s14, s15
; }
 800143c: eeb0 0a67    	vmov.f32	s0, s15
 8001440: 370c         	adds	r7, #0xc
 8001442: 46bd         	mov	sp, r7
 8001444: f85d 7b04    	ldr	r7, [sp], #4
 8001448: 4770         	bx	lr
 800144a: bf00         	nop

0800144c <$d>:
 800144c: 00 24 74 49  	.word	0x49742400

08001450 <jf_send_float>:
; {
 8001450: b580         	push	{r7, lr}
 8001452: b084         	sub	sp, #0x10
 8001454: af00         	add	r7, sp, #0x0
 8001456: 6078         	str	r0, [r7, #0x4]
; 	const struct device *uart_dev = data->uart_dev;
 8001458: 687b         	ldr	r3, [r7, #0x4]
 800145a: 681b         	ldr	r3, [r3]
 800145c: 60bb         	str	r3, [r7, #0x8]
; 	for (int i = 0; i < data->channel; i++) {
 800145e: 2300         	movs	r3, #0x0
 8001460: 60fb         	str	r3, [r7, #0xc]
 8001462: e01a         	b	0x800149a <jf_send_float+0x4a> @ imm = #0x34
; 		if (data->fdata[i] == *(float *)tail) {
 8001464: 687a         	ldr	r2, [r7, #0x4]
 8001466: 68fb         	ldr	r3, [r7, #0xc]
 8001468: 3318         	adds	r3, #0x18
 800146a: 009b         	lsls	r3, r3, #0x2
 800146c: 4413         	add	r3, r2
 800146e: 3304         	adds	r3, #0x4
 8001470: ed93 7a00    	vldr	s14, [r3]
 8001474: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8001504 <jf_send_float+0xb4>
 8001476: edd3 7a00    	vldr	s15, [r3]
 800147a: eeb4 7a67    	vcmp.f32	s14, s15
 800147e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8001482: d107         	bne	0x8001494 <jf_send_float+0x44> @ imm = #0xe
; 			data->fdata[i] = 1e+6;
 8001484: 687a         	ldr	r2, [r7, #0x4]
 8001486: 68fb         	ldr	r3, [r7, #0xc]
 8001488: 3318         	adds	r3, #0x18
 800148a: 009b         	lsls	r3, r3, #0x2
 800148c: 4413         	add	r3, r2
 800148e: 3304         	adds	r3, #0x4
 8001490: 4a1d         	ldr	r2, [pc, #0x74]         @ 0x8001508 <jf_send_float+0xb8>
 8001492: 601a         	str	r2, [r3]
; 	for (int i = 0; i < data->channel; i++) {
 8001494: 68fb         	ldr	r3, [r7, #0xc]
 8001496: 3301         	adds	r3, #0x1
 8001498: 60fb         	str	r3, [r7, #0xc]
 800149a: 687b         	ldr	r3, [r7, #0x4]
 800149c: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80014a0: 68fa         	ldr	r2, [r7, #0xc]
 80014a2: 429a         	cmp	r2, r3
 80014a4: dbde         	blt	0x8001464 <jf_send_float+0x14> @ imm = #-0x44
; 	if (data->fdata[data->channel] != *(float *)tail) {
 80014a6: 687b         	ldr	r3, [r7, #0x4]
 80014a8: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80014ac: 687a         	ldr	r2, [r7, #0x4]
 80014ae: 3318         	adds	r3, #0x18
 80014b0: 009b         	lsls	r3, r3, #0x2
 80014b2: 4413         	add	r3, r2
 80014b4: 3304         	adds	r3, #0x4
 80014b6: ed93 7a00    	vldr	s14, [r3]
 80014ba: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8001504 <jf_send_float+0xb4>
 80014bc: edd3 7a00    	vldr	s15, [r3]
 80014c0: eeb4 7a67    	vcmp.f32	s14, s15
 80014c4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80014c8: d00a         	beq	0x80014e0 <jf_send_float+0x90> @ imm = #0x14
; 		memcpy(&(data->fdata[data->channel]), tail, 4 * sizeof(uint8_t));
 80014ca: 687b         	ldr	r3, [r7, #0x4]
 80014cc: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80014d0: 3318         	adds	r3, #0x18
 80014d2: 009b         	lsls	r3, r3, #0x2
 80014d4: 687a         	ldr	r2, [r7, #0x4]
 80014d6: 4413         	add	r3, r2
 80014d8: 3304         	adds	r3, #0x4
 80014da: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8001504 <jf_send_float+0xb4>
 80014dc: 6810         	ldr	r0, [r2]
 80014de: 6018         	str	r0, [r3]
; 	uart_tx(uart_dev, (const uint8_t *)data->fdata, data->channel * 4 + 4, SYS_FOREVER_US);
 80014e0: 687b         	ldr	r3, [r7, #0x4]
 80014e2: f103 0164    	add.w	r1, r3, #0x64
 80014e6: 687b         	ldr	r3, [r7, #0x4]
 80014e8: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80014ec: 3301         	adds	r3, #0x1
 80014ee: 009b         	lsls	r3, r3, #0x2
 80014f0: 461a         	mov	r2, r3
 80014f2: f04f 33ff    	mov.w	r3, #0xffffffff
 80014f6: 68b8         	ldr	r0, [r7, #0x8]
 80014f8: f014 f8e5    	bl	0x80156c6 <uart_tx>     @ imm = #0x141ca
; }
 80014fc: bf00         	nop
 80014fe: 3710         	adds	r7, #0x10
 8001500: 46bd         	mov	sp, r7
 8001502: bd80         	pop	{r7, pc}

08001504 <$d>:
 8001504: 50 25 02 08  	.word	0x08022550
 8001508: 00 24 74 49  	.word	0x49742400

0800150c <jf_feedback>:
; {
 800150c: b580         	push	{r7, lr}
 800150e: b088         	sub	sp, #0x20
 8001510: af00         	add	r7, sp, #0x0
 8001512: 60f8         	str	r0, [r7, #0xc]
 8001514: 60b9         	str	r1, [r7, #0x8]
 8001516: 607a         	str	r2, [r7, #0x4]
; 	int delay = (int)arg1;
 8001518: 68fb         	ldr	r3, [r7, #0xc]
 800151a: 61bb         	str	r3, [r7, #0x18]
; 	struct JFData *data = (struct JFData *)arg2;
 800151c: 68bb         	ldr	r3, [r7, #0x8]
 800151e: 617b         	str	r3, [r7, #0x14]
; 		k_msleep(delay);
 8001520: 69b8         	ldr	r0, [r7, #0x18]
 8001522: f013 ffe1    	bl	0x80154e8 <k_msleep>    @ imm = #0x13fc2
; 		if (data->channel == 0) {
 8001526: 697b         	ldr	r3, [r7, #0x14]
 8001528: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 800152c: 2b00         	cmp	r3, #0x0
 800152e: f000 8082    	beq.w	0x8001636 <jf_feedback+0x12a> @ imm = #0x104
; 		for (int i = 0; i < data->channel; i++) {
 8001532: 2300         	movs	r3, #0x0
 8001534: 61fb         	str	r3, [r7, #0x1c]
 8001536: e074         	b	0x8001622 <jf_feedback+0x116> @ imm = #0xe8
; 			switch (data->types[i]) {
 8001538: 697a         	ldr	r2, [r7, #0x14]
 800153a: 69fb         	ldr	r3, [r7, #0x1c]
 800153c: 4413         	add	r3, r2
 800153e: 33c4         	adds	r3, #0xc4
 8001540: 781b         	ldrb	r3, [r3]
 8001542: 2b04         	cmp	r3, #0x4
 8001544: d869         	bhi	0x800161a <jf_feedback+0x10e> @ imm = #0xd2
 8001546: a201         	adr	r2, #4 <jf_feedback+0x3f>
 8001548: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800154c <$d>:
 800154c: 61 15 00 08  	.word	0x08001561
 8001550: 87 15 00 08  	.word	0x08001587
 8001554: a3 15 00 08  	.word	0x080015a3
 8001558: cb 15 00 08  	.word	0x080015cb
 800155c: f3 15 00 08  	.word	0x080015f3

08001560 <$t>:
; 				data->fdata[i] = *(int *)data->data_ptr[i];
 8001560: 697a         	ldr	r2, [r7, #0x14]
 8001562: 69fb         	ldr	r3, [r7, #0x1c]
 8001564: 009b         	lsls	r3, r3, #0x2
 8001566: 4413         	add	r3, r2
 8001568: 685b         	ldr	r3, [r3, #0x4]
 800156a: 681b         	ldr	r3, [r3]
 800156c: ee07 3a90    	vmov	s15, r3
 8001570: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8001574: 697a         	ldr	r2, [r7, #0x14]
 8001576: 69fb         	ldr	r3, [r7, #0x1c]
 8001578: 3318         	adds	r3, #0x18
 800157a: 009b         	lsls	r3, r3, #0x2
 800157c: 4413         	add	r3, r2
 800157e: 3304         	adds	r3, #0x4
 8001580: edc3 7a00    	vstr	s15, [r3]
; 				break;
 8001584: e04a         	b	0x800161c <jf_feedback+0x110> @ imm = #0x94
; 				data->fdata[i] = *(float *)data->data_ptr[i];
 8001586: 697a         	ldr	r2, [r7, #0x14]
 8001588: 69fb         	ldr	r3, [r7, #0x1c]
 800158a: 009b         	lsls	r3, r3, #0x2
 800158c: 4413         	add	r3, r2
 800158e: 685b         	ldr	r3, [r3, #0x4]
 8001590: 681a         	ldr	r2, [r3]
 8001592: 6979         	ldr	r1, [r7, #0x14]
 8001594: 69fb         	ldr	r3, [r7, #0x1c]
 8001596: 3318         	adds	r3, #0x18
 8001598: 009b         	lsls	r3, r3, #0x2
 800159a: 440b         	add	r3, r1
 800159c: 3304         	adds	r3, #0x4
 800159e: 601a         	str	r2, [r3]
; 				break;
 80015a0: e03c         	b	0x800161c <jf_feedback+0x110> @ imm = #0x78
; 				data->fdata[i] = *(double *)data->data_ptr[i];
 80015a2: 697a         	ldr	r2, [r7, #0x14]
 80015a4: 69fb         	ldr	r3, [r7, #0x1c]
 80015a6: 009b         	lsls	r3, r3, #0x2
 80015a8: 4413         	add	r3, r2
 80015aa: 685b         	ldr	r3, [r3, #0x4]
 80015ac: e9d3 2300    	ldrd	r2, r3, [r3]
 80015b0: 4610         	mov	r0, r2
 80015b2: 4619         	mov	r1, r3
 80015b4: f7ff f9b6    	bl	0x8000924 <__truncdfsf2> @ imm = #-0xc94
 80015b8: 4601         	mov	r1, r0
 80015ba: 697a         	ldr	r2, [r7, #0x14]
 80015bc: 69fb         	ldr	r3, [r7, #0x1c]
 80015be: 3318         	adds	r3, #0x18
 80015c0: 009b         	lsls	r3, r3, #0x2
 80015c2: 4413         	add	r3, r2
 80015c4: 3304         	adds	r3, #0x4
 80015c6: 6019         	str	r1, [r3]
; 				break;
 80015c8: e028         	b	0x800161c <jf_feedback+0x110> @ imm = #0x50
; 				data->fdata[i] = *(int8_t *)data->data_ptr[i];
 80015ca: 697a         	ldr	r2, [r7, #0x14]
 80015cc: 69fb         	ldr	r3, [r7, #0x1c]
 80015ce: 009b         	lsls	r3, r3, #0x2
 80015d0: 4413         	add	r3, r2
 80015d2: 685b         	ldr	r3, [r3, #0x4]
 80015d4: f993 3000    	ldrsb.w	r3, [r3]
 80015d8: ee07 3a90    	vmov	s15, r3
 80015dc: eef8 7ae7    	vcvt.f32.s32	s15, s15
 80015e0: 697a         	ldr	r2, [r7, #0x14]
 80015e2: 69fb         	ldr	r3, [r7, #0x1c]
 80015e4: 3318         	adds	r3, #0x18
 80015e6: 009b         	lsls	r3, r3, #0x2
 80015e8: 4413         	add	r3, r2
 80015ea: 3304         	adds	r3, #0x4
 80015ec: edc3 7a00    	vstr	s15, [r3]
; 				break;
 80015f0: e014         	b	0x800161c <jf_feedback+0x110> @ imm = #0x28
; 				data->fdata[i] = *(int16_t *)data->data_ptr[i];
 80015f2: 697a         	ldr	r2, [r7, #0x14]
 80015f4: 69fb         	ldr	r3, [r7, #0x1c]
 80015f6: 009b         	lsls	r3, r3, #0x2
 80015f8: 4413         	add	r3, r2
 80015fa: 685b         	ldr	r3, [r3, #0x4]
 80015fc: f9b3 3000    	ldrsh.w	r3, [r3]
 8001600: ee07 3a90    	vmov	s15, r3
 8001604: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8001608: 697a         	ldr	r2, [r7, #0x14]
 800160a: 69fb         	ldr	r3, [r7, #0x1c]
 800160c: 3318         	adds	r3, #0x18
 800160e: 009b         	lsls	r3, r3, #0x2
 8001610: 4413         	add	r3, r2
 8001612: 3304         	adds	r3, #0x4
 8001614: edc3 7a00    	vstr	s15, [r3]
; 				break;
 8001618: e000         	b	0x800161c <jf_feedback+0x110> @ imm = #0x0
; 				break;
 800161a: bf00         	nop
; 		for (int i = 0; i < data->channel; i++) {
 800161c: 69fb         	ldr	r3, [r7, #0x1c]
 800161e: 3301         	adds	r3, #0x1
 8001620: 61fb         	str	r3, [r7, #0x1c]
 8001622: 697b         	ldr	r3, [r7, #0x14]
 8001624: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8001628: 69fa         	ldr	r2, [r7, #0x1c]
 800162a: 429a         	cmp	r2, r3
 800162c: db84         	blt	0x8001538 <jf_feedback+0x2c> @ imm = #-0xf8
; 		jf_send_float(data);
 800162e: 6978         	ldr	r0, [r7, #0x14]
 8001630: f7ff ff0e    	bl	0x8001450 <jf_send_float> @ imm = #-0x1e4
 8001634: e774         	b	0x8001520 <jf_feedback+0x14> @ imm = #-0x118
; 			continue;
 8001636: bf00         	nop
; 		k_msleep(delay);
 8001638: e772         	b	0x8001520 <jf_feedback+0x14> @ imm = #-0x11c
 800163a: bf00         	nop

0800163c <jf_channel_add>:
; {
 800163c: b480         	push	{r7}
 800163e: b085         	sub	sp, #0x14
 8001640: af00         	add	r7, sp, #0x0
 8001642: 60f8         	str	r0, [r7, #0xc]
 8001644: 60b9         	str	r1, [r7, #0x8]
 8001646: 4613         	mov	r3, r2
 8001648: 71fb         	strb	r3, [r7, #0x7]
; 	if (data->channel < 24) {
 800164a: 68fb         	ldr	r3, [r7, #0xc]
 800164c: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8001650: 2b17         	cmp	r3, #0x17
 8001652: dc21         	bgt	0x8001698 <jf_channel_add+0x5c> @ imm = #0x42
; 		if (type == RAW) {
 8001654: 79fb         	ldrb	r3, [r7, #0x7]
 8001656: 2b08         	cmp	r3, #0x8
 8001658: d10b         	bne	0x8001672 <jf_channel_add+0x36> @ imm = #0x16
; 			data->fdata[data->channel] = *(float *)value;
 800165a: 68fb         	ldr	r3, [r7, #0xc]
 800165c: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8001660: 68ba         	ldr	r2, [r7, #0x8]
 8001662: 6812         	ldr	r2, [r2]
 8001664: 68f9         	ldr	r1, [r7, #0xc]
 8001666: 3318         	adds	r3, #0x18
 8001668: 009b         	lsls	r3, r3, #0x2
 800166a: 440b         	add	r3, r1
 800166c: 3304         	adds	r3, #0x4
 800166e: 601a         	str	r2, [r3]
 8001670: e012         	b	0x8001698 <jf_channel_add+0x5c> @ imm = #0x24
; 			data->fdata[data->channel] = *(float *)value;
 8001672: 68fb         	ldr	r3, [r7, #0xc]
 8001674: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8001678: 68ba         	ldr	r2, [r7, #0x8]
 800167a: 6812         	ldr	r2, [r2]
 800167c: 68f9         	ldr	r1, [r7, #0xc]
 800167e: 3318         	adds	r3, #0x18
 8001680: 009b         	lsls	r3, r3, #0x2
 8001682: 440b         	add	r3, r1
 8001684: 3304         	adds	r3, #0x4
 8001686: 601a         	str	r2, [r3]
; 			data->data_ptr[data->channel] = value;
 8001688: 68fb         	ldr	r3, [r7, #0xc]
 800168a: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 800168e: 68fa         	ldr	r2, [r7, #0xc]
 8001690: 009b         	lsls	r3, r3, #0x2
 8001692: 4413         	add	r3, r2
 8001694: 68ba         	ldr	r2, [r7, #0x8]
 8001696: 605a         	str	r2, [r3, #0x4]
; 	data->types[data->channel] = type;
 8001698: 68fb         	ldr	r3, [r7, #0xc]
 800169a: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 800169e: 68fa         	ldr	r2, [r7, #0xc]
 80016a0: 4413         	add	r3, r2
 80016a2: 79fa         	ldrb	r2, [r7, #0x7]
 80016a4: f883 20c4    	strb.w	r2, [r3, #0xc4]
; 	data->channel++;
 80016a8: 68fb         	ldr	r3, [r7, #0xc]
 80016aa: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80016ae: 1c5a         	adds	r2, r3, #0x1
 80016b0: 68fb         	ldr	r3, [r7, #0xc]
 80016b2: f8c3 20dc    	str.w	r2, [r3, #0xdc]
; 	data->types[data->channel] = RAW;
 80016b6: 68fb         	ldr	r3, [r7, #0xc]
 80016b8: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80016bc: 68fa         	ldr	r2, [r7, #0xc]
 80016be: 4413         	add	r3, r2
 80016c0: 2208         	movs	r2, #0x8
 80016c2: f883 20c4    	strb.w	r2, [r3, #0xc4]
; 	memcpy(&(data->fdata[data->channel]), tail, 4 * sizeof(uint8_t));
 80016c6: 68fb         	ldr	r3, [r7, #0xc]
 80016c8: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 80016cc: 3318         	adds	r3, #0x18
 80016ce: 009b         	lsls	r3, r3, #0x2
 80016d0: 68fa         	ldr	r2, [r7, #0xc]
 80016d2: 4413         	add	r3, r2
 80016d4: 3304         	adds	r3, #0x4
 80016d6: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80016e8 <jf_channel_add+0xac>
 80016d8: 6810         	ldr	r0, [r2]
 80016da: 6018         	str	r0, [r3]
; }
 80016dc: bf00         	nop
 80016de: 3714         	adds	r7, #0x14
 80016e0: 46bd         	mov	sp, r7
 80016e2: f85d 7b04    	ldr	r7, [sp], #4
 80016e6: 4770         	bx	lr

080016e8 <$d>:
 80016e8: 50 25 02 08  	.word	0x08022550

080016ec <jf_send_init>:
; {
 80016ec: b580         	push	{r7, lr}
 80016ee: b08a         	sub	sp, #0x28
 80016f0: af08         	add	r7, sp, #0x20
 80016f2: 6078         	str	r0, [r7, #0x4]
 80016f4: 6039         	str	r1, [r7]
; 	aresPlotData.channel = 0;
 80016f6: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800177c <jf_send_init+0x90>
 80016f8: 2200         	movs	r2, #0x0
 80016fa: f8c3 20dc    	str.w	r2, [r3, #0xdc]
; 	if (!device_is_ready(uart_dev)) {
 80016fe: 6878         	ldr	r0, [r7, #0x4]
 8001700: f013 fec1    	bl	0x8015486 <device_is_ready> @ imm = #0x13d82
 8001704: 4603         	mov	r3, r0
 8001706: f083 0301    	eor	r3, r3, #0x1
 800170a: b2db         	uxtb	r3, r3
 800170c: 2b00         	cmp	r3, #0x0
 800170e: d001         	beq	0x8001714 <jf_send_init+0x28> @ imm = #0x2
; 		return NULL;
 8001710: 2100         	movs	r1, #0x0
 8001712: e02e         	b	0x8001772 <jf_send_init+0x86> @ imm = #0x5c
; 	aresPlotData.uart_dev = (struct device *)uart_dev;
 8001714: 4a19         	ldr	r2, [pc, #0x64]         @ 0x800177c <jf_send_init+0x90>
 8001716: 687b         	ldr	r3, [r7, #0x4]
 8001718: 6013         	str	r3, [r2]
; 	memcpy(&(aresPlotData.fdata[aresPlotData.channel]), tail, 4 * sizeof(uint8_t));
 800171a: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800177c <jf_send_init+0x90>
 800171c: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8001720: 3318         	adds	r3, #0x18
 8001722: 009b         	lsls	r3, r3, #0x2
 8001724: 4a15         	ldr	r2, [pc, #0x54]         @ 0x800177c <jf_send_init+0x90>
 8001726: 4413         	add	r3, r2
 8001728: 3304         	adds	r3, #0x4
 800172a: 4a15         	ldr	r2, [pc, #0x54]         @ 0x8001780 <jf_send_init+0x94>
 800172c: 6810         	ldr	r0, [r2]
 800172e: 6018         	str	r0, [r3]
; 	aresPlotData.types[aresPlotData.channel] = RAW;
 8001730: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800177c <jf_send_init+0x90>
 8001732: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8001736: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800177c <jf_send_init+0x90>
 8001738: 4413         	add	r3, r2
 800173a: 2208         	movs	r2, #0x8
 800173c: f883 20c4    	strb.w	r2, [r3, #0xc4]
; 	k_thread_create(&jf_thread_data, jf_stack_area, K_THREAD_STACK_SIZEOF(jf_stack_area),
 8001740: 6839         	ldr	r1, [r7]
; 			jf_feedback, (void *)delay, &aresPlotData, NULL, -1, 0, K_NO_WAIT);
 8001742: f04f 0200    	mov.w	r2, #0x0
 8001746: f04f 0300    	mov.w	r3, #0x0
; 	k_thread_create(&jf_thread_data, jf_stack_area, K_THREAD_STACK_SIZEOF(jf_stack_area),
 800174a: e9cd 2306    	strd	r2, r3, [sp, #24]
 800174e: 2300         	movs	r3, #0x0
 8001750: 9304         	str	r3, [sp, #0x10]
 8001752: f04f 33ff    	mov.w	r3, #0xffffffff
 8001756: 9303         	str	r3, [sp, #0xc]
 8001758: 2300         	movs	r3, #0x0
 800175a: 9302         	str	r3, [sp, #0x8]
 800175c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800177c <jf_send_init+0x90>
 800175e: 9301         	str	r3, [sp, #0x4]
 8001760: 9100         	str	r1, [sp]
 8001762: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8001784 <jf_send_init+0x98>
 8001764: f44f 7240    	mov.w	r2, #0x300
 8001768: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8001788 <jf_send_init+0x9c>
 800176a: 4808         	ldr	r0, [pc, #0x20]         @ 0x800178c <jf_send_init+0xa0>
 800176c: f013 feef    	bl	0x801554e <k_thread_create> @ imm = #0x13dde
; 	return &aresPlotData;
 8001770: 4902         	ldr	r1, [pc, #0x8]          @ 0x800177c <jf_send_init+0x90>
; }
 8001772: 460b         	mov	r3, r1
 8001774: 4618         	mov	r0, r3
 8001776: 3708         	adds	r7, #0x8
 8001778: 46bd         	mov	sp, r7
 800177a: bd80         	pop	{r7, pc}

0800177c <$d>:
 800177c: 30 22 00 20  	.word	0x20002230
 8001780: 50 25 02 08  	.word	0x08022550
 8001784: 0d 15 00 08  	.word	0x0800150d
 8001788: 00 28 00 20  	.word	0x20002800
 800178c: 88 06 00 20  	.word	0x20000688

08001790 <Kalman_Filter_Init>:
; {
 8001790: b580         	push	{r7, lr}
 8001792: b082         	sub	sp, #0x8
 8001794: af00         	add	r7, sp, #0x0
 8001796: 6078         	str	r0, [r7, #0x4]
 8001798: 4608         	mov	r0, r1
 800179a: 4611         	mov	r1, r2
 800179c: 461a         	mov	r2, r3
 800179e: 4603         	mov	r3, r0
 80017a0: 70fb         	strb	r3, [r7, #0x3]
 80017a2: 460b         	mov	r3, r1
 80017a4: 70bb         	strb	r3, [r7, #0x2]
 80017a6: 4613         	mov	r3, r2
 80017a8: 707b         	strb	r3, [r7, #0x1]
; 	sizeof_float = sizeof(float);
 80017aa: 4bba         	ldr	r3, [pc, #0x2e8]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 80017ac: 2204         	movs	r2, #0x4
 80017ae: 801a         	strh	r2, [r3]
; 	sizeof_double = sizeof(double);
 80017b0: 4bb9         	ldr	r3, [pc, #0x2e4]        @ 0x8001a98 <Kalman_Filter_Init+0x308>
 80017b2: 2208         	movs	r2, #0x8
 80017b4: 801a         	strh	r2, [r3]
; 	kf->xhatSize = xhatSize;
 80017b6: 687b         	ldr	r3, [r7, #0x4]
 80017b8: 78fa         	ldrb	r2, [r7, #0x3]
 80017ba: 731a         	strb	r2, [r3, #0xc]
; 	kf->uSize = uSize;
 80017bc: 687b         	ldr	r3, [r7, #0x4]
 80017be: 78ba         	ldrb	r2, [r7, #0x2]
 80017c0: 735a         	strb	r2, [r3, #0xd]
; 	kf->zSize = zSize;
 80017c2: 687b         	ldr	r3, [r7, #0x4]
 80017c4: 787a         	ldrb	r2, [r7, #0x1]
 80017c6: 739a         	strb	r2, [r3, #0xe]
; 	kf->MeasurementValidNum = 0;
 80017c8: 687b         	ldr	r3, [r7, #0x4]
 80017ca: 2200         	movs	r2, #0x0
 80017cc: 741a         	strb	r2, [r3, #0x10]
; 	kf->MeasurementMap = (uint8_t *)user_malloc(sizeof(uint8_t) * zSize);
 80017ce: 787b         	ldrb	r3, [r7, #0x1]
 80017d0: 4618         	mov	r0, r3
 80017d2: f005 fdd3    	bl	0x800737c <malloc>      @ imm = #0x5ba6
 80017d6: 4603         	mov	r3, r0
 80017d8: 461a         	mov	r2, r3
 80017da: 687b         	ldr	r3, [r7, #0x4]
 80017dc: 615a         	str	r2, [r3, #0x14]
; 	memset(kf->MeasurementMap, 0, sizeof(uint8_t) * zSize);
 80017de: 687b         	ldr	r3, [r7, #0x4]
 80017e0: 695b         	ldr	r3, [r3, #0x14]
 80017e2: 787a         	ldrb	r2, [r7, #0x1]
 80017e4: 2100         	movs	r1, #0x0
 80017e6: 4618         	mov	r0, r3
 80017e8: f01e fa76    	bl	0x801fcd8 <memset>      @ imm = #0x1e4ec
; 	kf->MeasurementDegree = (float *)user_malloc(sizeof_float * zSize);
 80017ec: 4ba9         	ldr	r3, [pc, #0x2a4]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 80017ee: 881b         	ldrh	r3, [r3]
 80017f0: 461a         	mov	r2, r3
 80017f2: 787b         	ldrb	r3, [r7, #0x1]
 80017f4: fb02 f303    	mul	r3, r2, r3
 80017f8: 4618         	mov	r0, r3
 80017fa: f005 fdbf    	bl	0x800737c <malloc>      @ imm = #0x5b7e
 80017fe: 4603         	mov	r3, r0
 8001800: 461a         	mov	r2, r3
 8001802: 687b         	ldr	r3, [r7, #0x4]
 8001804: 619a         	str	r2, [r3, #0x18]
; 	memset(kf->MeasurementDegree, 0, sizeof_float * zSize);
 8001806: 687b         	ldr	r3, [r7, #0x4]
 8001808: 6998         	ldr	r0, [r3, #0x18]
 800180a: 4ba2         	ldr	r3, [pc, #0x288]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 800180c: 881b         	ldrh	r3, [r3]
 800180e: 461a         	mov	r2, r3
 8001810: 787b         	ldrb	r3, [r7, #0x1]
 8001812: fb02 f303    	mul	r3, r2, r3
 8001816: 461a         	mov	r2, r3
 8001818: 2100         	movs	r1, #0x0
 800181a: f01e fa5d    	bl	0x801fcd8 <memset>      @ imm = #0x1e4ba
; 	kf->MatR_DiagonalElements = (float *)user_malloc(sizeof_float * zSize);
 800181e: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 8001820: 881b         	ldrh	r3, [r3]
 8001822: 461a         	mov	r2, r3
 8001824: 787b         	ldrb	r3, [r7, #0x1]
 8001826: fb02 f303    	mul	r3, r2, r3
 800182a: 4618         	mov	r0, r3
 800182c: f005 fda6    	bl	0x800737c <malloc>      @ imm = #0x5b4c
 8001830: 4603         	mov	r3, r0
 8001832: 461a         	mov	r2, r3
 8001834: 687b         	ldr	r3, [r7, #0x4]
 8001836: 61da         	str	r2, [r3, #0x1c]
; 	memset(kf->MatR_DiagonalElements, 0, sizeof_float * zSize);
 8001838: 687b         	ldr	r3, [r7, #0x4]
 800183a: 69d8         	ldr	r0, [r3, #0x1c]
 800183c: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 800183e: 881b         	ldrh	r3, [r3]
 8001840: 461a         	mov	r2, r3
 8001842: 787b         	ldrb	r3, [r7, #0x1]
 8001844: fb02 f303    	mul	r3, r2, r3
 8001848: 461a         	mov	r2, r3
 800184a: 2100         	movs	r1, #0x0
 800184c: f01e fa44    	bl	0x801fcd8 <memset>      @ imm = #0x1e488
; 	kf->StateMinVariance = (float *)user_malloc(sizeof_float * xhatSize);
 8001850: 4b90         	ldr	r3, [pc, #0x240]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 8001852: 881b         	ldrh	r3, [r3]
 8001854: 461a         	mov	r2, r3
 8001856: 78fb         	ldrb	r3, [r7, #0x3]
 8001858: fb02 f303    	mul	r3, r2, r3
 800185c: 4618         	mov	r0, r3
 800185e: f005 fd8d    	bl	0x800737c <malloc>      @ imm = #0x5b1a
 8001862: 4603         	mov	r3, r0
 8001864: 461a         	mov	r2, r3
 8001866: 687b         	ldr	r3, [r7, #0x4]
 8001868: 621a         	str	r2, [r3, #0x20]
; 	memset(kf->StateMinVariance, 0, sizeof_float * xhatSize);
 800186a: 687b         	ldr	r3, [r7, #0x4]
 800186c: 6a18         	ldr	r0, [r3, #0x20]
 800186e: 4b89         	ldr	r3, [pc, #0x224]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 8001870: 881b         	ldrh	r3, [r3]
 8001872: 461a         	mov	r2, r3
 8001874: 78fb         	ldrb	r3, [r7, #0x3]
 8001876: fb02 f303    	mul	r3, r2, r3
 800187a: 461a         	mov	r2, r3
 800187c: 2100         	movs	r1, #0x0
 800187e: f01e fa2b    	bl	0x801fcd8 <memset>      @ imm = #0x1e456
; 	kf->temp = (uint8_t *)user_malloc(sizeof(uint8_t) * zSize);
 8001882: 787b         	ldrb	r3, [r7, #0x1]
 8001884: 4618         	mov	r0, r3
 8001886: f005 fd79    	bl	0x800737c <malloc>      @ imm = #0x5af2
 800188a: 4603         	mov	r3, r0
 800188c: 461a         	mov	r2, r3
 800188e: 687b         	ldr	r3, [r7, #0x4]
 8001890: 625a         	str	r2, [r3, #0x24]
; 	memset(kf->temp, 0, sizeof(uint8_t) * zSize);
 8001892: 687b         	ldr	r3, [r7, #0x4]
 8001894: 6a5b         	ldr	r3, [r3, #0x24]
 8001896: 787a         	ldrb	r2, [r7, #0x1]
 8001898: 2100         	movs	r1, #0x0
 800189a: 4618         	mov	r0, r3
 800189c: f01e fa1c    	bl	0x801fcd8 <memset>      @ imm = #0x1e438
; 	kf->FilteredValue = (float *)user_malloc(sizeof_float * xhatSize);
 80018a0: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 80018a2: 881b         	ldrh	r3, [r3]
 80018a4: 461a         	mov	r2, r3
 80018a6: 78fb         	ldrb	r3, [r7, #0x3]
 80018a8: fb02 f303    	mul	r3, r2, r3
 80018ac: 4618         	mov	r0, r3
 80018ae: f005 fd65    	bl	0x800737c <malloc>      @ imm = #0x5aca
 80018b2: 4603         	mov	r3, r0
 80018b4: 461a         	mov	r2, r3
 80018b6: 687b         	ldr	r3, [r7, #0x4]
 80018b8: 601a         	str	r2, [r3]
; 	memset(kf->FilteredValue, 0, sizeof_float * xhatSize);
 80018ba: 687b         	ldr	r3, [r7, #0x4]
 80018bc: 6818         	ldr	r0, [r3]
 80018be: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 80018c0: 881b         	ldrh	r3, [r3]
 80018c2: 461a         	mov	r2, r3
 80018c4: 78fb         	ldrb	r3, [r7, #0x3]
 80018c6: fb02 f303    	mul	r3, r2, r3
 80018ca: 461a         	mov	r2, r3
 80018cc: 2100         	movs	r1, #0x0
 80018ce: f01e fa03    	bl	0x801fcd8 <memset>      @ imm = #0x1e406
; 	kf->MeasuredVector = (float *)user_malloc(sizeof_float * zSize);
 80018d2: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 80018d4: 881b         	ldrh	r3, [r3]
 80018d6: 461a         	mov	r2, r3
 80018d8: 787b         	ldrb	r3, [r7, #0x1]
 80018da: fb02 f303    	mul	r3, r2, r3
 80018de: 4618         	mov	r0, r3
 80018e0: f005 fd4c    	bl	0x800737c <malloc>      @ imm = #0x5a98
 80018e4: 4603         	mov	r3, r0
 80018e6: 461a         	mov	r2, r3
 80018e8: 687b         	ldr	r3, [r7, #0x4]
 80018ea: 605a         	str	r2, [r3, #0x4]
; 	memset(kf->MeasuredVector, 0, sizeof_float * zSize);
 80018ec: 687b         	ldr	r3, [r7, #0x4]
 80018ee: 6858         	ldr	r0, [r3, #0x4]
 80018f0: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 80018f2: 881b         	ldrh	r3, [r3]
 80018f4: 461a         	mov	r2, r3
 80018f6: 787b         	ldrb	r3, [r7, #0x1]
 80018f8: fb02 f303    	mul	r3, r2, r3
 80018fc: 461a         	mov	r2, r3
 80018fe: 2100         	movs	r1, #0x0
 8001900: f01e f9ea    	bl	0x801fcd8 <memset>      @ imm = #0x1e3d4
; 	kf->ControlVector = (float *)user_malloc(sizeof_float * uSize);
 8001904: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 8001906: 881b         	ldrh	r3, [r3]
 8001908: 461a         	mov	r2, r3
 800190a: 78bb         	ldrb	r3, [r7, #0x2]
 800190c: fb02 f303    	mul	r3, r2, r3
 8001910: 4618         	mov	r0, r3
 8001912: f005 fd33    	bl	0x800737c <malloc>      @ imm = #0x5a66
 8001916: 4603         	mov	r3, r0
 8001918: 461a         	mov	r2, r3
 800191a: 687b         	ldr	r3, [r7, #0x4]
 800191c: 609a         	str	r2, [r3, #0x8]
; 	memset(kf->ControlVector, 0, sizeof_float * uSize);
 800191e: 687b         	ldr	r3, [r7, #0x4]
 8001920: 6898         	ldr	r0, [r3, #0x8]
 8001922: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 8001924: 881b         	ldrh	r3, [r3]
 8001926: 461a         	mov	r2, r3
 8001928: 78bb         	ldrb	r3, [r7, #0x2]
 800192a: fb02 f303    	mul	r3, r2, r3
 800192e: 461a         	mov	r2, r3
 8001930: 2100         	movs	r1, #0x0
 8001932: f01e f9d1    	bl	0x801fcd8 <memset>      @ imm = #0x1e3a2
; 	kf->xhat_data = (float *)user_malloc(sizeof_float * xhatSize);
 8001936: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 8001938: 881b         	ldrh	r3, [r3]
 800193a: 461a         	mov	r2, r3
 800193c: 78fb         	ldrb	r3, [r7, #0x3]
 800193e: fb02 f303    	mul	r3, r2, r3
 8001942: 4618         	mov	r0, r3
 8001944: f005 fd1a    	bl	0x800737c <malloc>      @ imm = #0x5a34
 8001948: 4603         	mov	r3, r0
 800194a: 461a         	mov	r2, r3
 800194c: 687b         	ldr	r3, [r7, #0x4]
 800194e: f8c3 20e8    	str.w	r2, [r3, #0xe8]
; 	memset(kf->xhat_data, 0, sizeof_float * xhatSize);
 8001952: 687b         	ldr	r3, [r7, #0x4]
 8001954: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 8001958: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 800195a: 881b         	ldrh	r3, [r3]
 800195c: 461a         	mov	r2, r3
 800195e: 78fb         	ldrb	r3, [r7, #0x3]
 8001960: fb02 f303    	mul	r3, r2, r3
 8001964: 461a         	mov	r2, r3
 8001966: 2100         	movs	r1, #0x0
 8001968: f01e f9b6    	bl	0x801fcd8 <memset>      @ imm = #0x1e36c
; 	Matrix_Init(&kf->xhat, kf->xhatSize, 1, (float *)kf->xhat_data);
 800196c: 687b         	ldr	r3, [r7, #0x4]
 800196e: f103 0030    	add.w	r0, r3, #0x30
 8001972: 687b         	ldr	r3, [r7, #0x4]
 8001974: 7b1b         	ldrb	r3, [r3, #0xc]
 8001976: 4619         	mov	r1, r3
 8001978: 687b         	ldr	r3, [r7, #0x4]
 800197a: f8d3 30e8    	ldr.w	r3, [r3, #0xe8]
 800197e: 2201         	movs	r2, #0x1
 8001980: f00c fdd4    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xcba8
; 	kf->xhatminus_data = (float *)user_malloc(sizeof_float * xhatSize);
 8001984: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8001a94 <Kalman_Filter_Init+0x304>
 8001986: 881b         	ldrh	r3, [r3]
 8001988: 461a         	mov	r2, r3
 800198a: 78fb         	ldrb	r3, [r7, #0x3]
 800198c: fb02 f303    	mul	r3, r2, r3
 8001990: 4618         	mov	r0, r3
 8001992: f005 fcf3    	bl	0x800737c <malloc>      @ imm = #0x59e6
 8001996: 4603         	mov	r3, r0
 8001998: 461a         	mov	r2, r3
 800199a: 687b         	ldr	r3, [r7, #0x4]
 800199c: f8c3 20ec    	str.w	r2, [r3, #0xec]
; 	memset(kf->xhatminus_data, 0, sizeof_float * xhatSize);
 80019a0: 687b         	ldr	r3, [r7, #0x4]
 80019a2: f8d3 00ec    	ldr.w	r0, [r3, #0xec]
 80019a6: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8001a94 <Kalman_Filter_Init+0x304>
 80019a8: 881b         	ldrh	r3, [r3]
 80019aa: 461a         	mov	r2, r3
 80019ac: 78fb         	ldrb	r3, [r7, #0x3]
 80019ae: fb02 f303    	mul	r3, r2, r3
 80019b2: 461a         	mov	r2, r3
 80019b4: 2100         	movs	r1, #0x0
 80019b6: f01e f98f    	bl	0x801fcd8 <memset>      @ imm = #0x1e31e
; 	Matrix_Init(&kf->xhatminus, kf->xhatSize, 1, (float *)kf->xhatminus_data);
 80019ba: 687b         	ldr	r3, [r7, #0x4]
 80019bc: f103 0038    	add.w	r0, r3, #0x38
 80019c0: 687b         	ldr	r3, [r7, #0x4]
 80019c2: 7b1b         	ldrb	r3, [r3, #0xc]
 80019c4: 4619         	mov	r1, r3
 80019c6: 687b         	ldr	r3, [r7, #0x4]
 80019c8: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 80019cc: 2201         	movs	r2, #0x1
 80019ce: f00c fdad    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xcb5a
; 	if (uSize != 0) {
 80019d2: 78bb         	ldrb	r3, [r7, #0x2]
 80019d4: 2b00         	cmp	r3, #0x0
 80019d6: d026         	beq	0x8001a26 <Kalman_Filter_Init+0x296> @ imm = #0x4c
; 		kf->u_data = (float *)user_malloc(sizeof_float * uSize);
 80019d8: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8001a94 <Kalman_Filter_Init+0x304>
 80019da: 881b         	ldrh	r3, [r3]
 80019dc: 461a         	mov	r2, r3
 80019de: 78bb         	ldrb	r3, [r7, #0x2]
 80019e0: fb02 f303    	mul	r3, r2, r3
 80019e4: 4618         	mov	r0, r3
 80019e6: f005 fcc9    	bl	0x800737c <malloc>      @ imm = #0x5992
 80019ea: 4603         	mov	r3, r0
 80019ec: 461a         	mov	r2, r3
 80019ee: 687b         	ldr	r3, [r7, #0x4]
 80019f0: f8c3 20f0    	str.w	r2, [r3, #0xf0]
; 		memset(kf->u_data, 0, sizeof_float * uSize);
 80019f4: 687b         	ldr	r3, [r7, #0x4]
 80019f6: f8d3 00f0    	ldr.w	r0, [r3, #0xf0]
 80019fa: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8001a94 <Kalman_Filter_Init+0x304>
 80019fc: 881b         	ldrh	r3, [r3]
 80019fe: 461a         	mov	r2, r3
 8001a00: 78bb         	ldrb	r3, [r7, #0x2]
 8001a02: fb02 f303    	mul	r3, r2, r3
 8001a06: 461a         	mov	r2, r3
 8001a08: 2100         	movs	r1, #0x0
 8001a0a: f01e f965    	bl	0x801fcd8 <memset>      @ imm = #0x1e2ca
; 		Matrix_Init(&kf->u, kf->uSize, 1, (float *)kf->u_data);
 8001a0e: 687b         	ldr	r3, [r7, #0x4]
 8001a10: f103 0040    	add.w	r0, r3, #0x40
 8001a14: 687b         	ldr	r3, [r7, #0x4]
 8001a16: 7b5b         	ldrb	r3, [r3, #0xd]
 8001a18: 4619         	mov	r1, r3
 8001a1a: 687b         	ldr	r3, [r7, #0x4]
 8001a1c: f8d3 30f0    	ldr.w	r3, [r3, #0xf0]
 8001a20: 2201         	movs	r2, #0x1
 8001a22: f00c fd83    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xcb06
; 	kf->z_data = (float *)user_malloc(sizeof_float * zSize);
 8001a26: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8001a94 <Kalman_Filter_Init+0x304>
 8001a28: 881b         	ldrh	r3, [r3]
 8001a2a: 461a         	mov	r2, r3
 8001a2c: 787b         	ldrb	r3, [r7, #0x1]
 8001a2e: fb02 f303    	mul	r3, r2, r3
 8001a32: 4618         	mov	r0, r3
 8001a34: f005 fca2    	bl	0x800737c <malloc>      @ imm = #0x5944
 8001a38: 4603         	mov	r3, r0
 8001a3a: 461a         	mov	r2, r3
 8001a3c: 687b         	ldr	r3, [r7, #0x4]
 8001a3e: f8c3 20f4    	str.w	r2, [r3, #0xf4]
; 	memset(kf->z_data, 0, sizeof_float * zSize);
 8001a42: 687b         	ldr	r3, [r7, #0x4]
 8001a44: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 8001a48: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8001a94 <Kalman_Filter_Init+0x304>
 8001a4a: 881b         	ldrh	r3, [r3]
 8001a4c: 461a         	mov	r2, r3
 8001a4e: 787b         	ldrb	r3, [r7, #0x1]
 8001a50: fb02 f303    	mul	r3, r2, r3
 8001a54: 461a         	mov	r2, r3
 8001a56: 2100         	movs	r1, #0x0
 8001a58: f01e f93e    	bl	0x801fcd8 <memset>      @ imm = #0x1e27c
; 	Matrix_Init(&kf->z, kf->zSize, 1, (float *)kf->z_data);
 8001a5c: 687b         	ldr	r3, [r7, #0x4]
 8001a5e: f103 0048    	add.w	r0, r3, #0x48
 8001a62: 687b         	ldr	r3, [r7, #0x4]
 8001a64: 7b9b         	ldrb	r3, [r3, #0xe]
 8001a66: 4619         	mov	r1, r3
 8001a68: 687b         	ldr	r3, [r7, #0x4]
 8001a6a: f8d3 30f4    	ldr.w	r3, [r3, #0xf4]
 8001a6e: 2201         	movs	r2, #0x1
 8001a70: f00c fd5c    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xcab8
; 	kf->P_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001a74: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8001a94 <Kalman_Filter_Init+0x304>
 8001a76: 881b         	ldrh	r3, [r3]
 8001a78: 461a         	mov	r2, r3
 8001a7a: 78fb         	ldrb	r3, [r7, #0x3]
 8001a7c: fb02 f303    	mul	r3, r2, r3
 8001a80: 78fa         	ldrb	r2, [r7, #0x3]
 8001a82: fb02 f303    	mul	r3, r2, r3
 8001a86: 4618         	mov	r0, r3
 8001a88: f005 fc78    	bl	0x800737c <malloc>      @ imm = #0x58f0
 8001a8c: 4603         	mov	r3, r0
 8001a8e: 461a         	mov	r2, r3
 8001a90: 687b         	ldr	r3, [r7, #0x4]
 8001a92: e003         	b	0x8001a9c <Kalman_Filter_Init+0x30c> @ imm = #0x6

08001a94 <$d>:
 8001a94: f4 27 00 20  	.word	0x200027f4
 8001a98: f6 27 00 20  	.word	0x200027f6

08001a9c <$t>:
 8001a9c: f8c3 20f8    	str.w	r2, [r3, #0xf8]
; 	memset(kf->P_data, 0, sizeof_float * xhatSize * xhatSize);
 8001aa0: 687b         	ldr	r3, [r7, #0x4]
 8001aa2: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 8001aa6: 4bbd         	ldr	r3, [pc, #0x2f4]        @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001aa8: 881b         	ldrh	r3, [r3]
 8001aaa: 461a         	mov	r2, r3
 8001aac: 78fb         	ldrb	r3, [r7, #0x3]
 8001aae: fb02 f303    	mul	r3, r2, r3
 8001ab2: 78fa         	ldrb	r2, [r7, #0x3]
 8001ab4: fb02 f303    	mul	r3, r2, r3
 8001ab8: 461a         	mov	r2, r3
 8001aba: 2100         	movs	r1, #0x0
 8001abc: f01e f90c    	bl	0x801fcd8 <memset>      @ imm = #0x1e218
; 	Matrix_Init(&kf->P, kf->xhatSize, kf->xhatSize, (float *)kf->P_data);
 8001ac0: 687b         	ldr	r3, [r7, #0x4]
 8001ac2: f103 0050    	add.w	r0, r3, #0x50
 8001ac6: 687b         	ldr	r3, [r7, #0x4]
 8001ac8: 7b1b         	ldrb	r3, [r3, #0xc]
 8001aca: 4619         	mov	r1, r3
 8001acc: 687b         	ldr	r3, [r7, #0x4]
 8001ace: 7b1b         	ldrb	r3, [r3, #0xc]
 8001ad0: 461a         	mov	r2, r3
 8001ad2: 687b         	ldr	r3, [r7, #0x4]
 8001ad4: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8001ad8: f00c fd28    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xca50
; 	kf->Pminus_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001adc: 4baf         	ldr	r3, [pc, #0x2bc]        @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001ade: 881b         	ldrh	r3, [r3]
 8001ae0: 461a         	mov	r2, r3
 8001ae2: 78fb         	ldrb	r3, [r7, #0x3]
 8001ae4: fb02 f303    	mul	r3, r2, r3
 8001ae8: 78fa         	ldrb	r2, [r7, #0x3]
 8001aea: fb02 f303    	mul	r3, r2, r3
 8001aee: 4618         	mov	r0, r3
 8001af0: f005 fc44    	bl	0x800737c <malloc>      @ imm = #0x5888
 8001af4: 4603         	mov	r3, r0
 8001af6: 461a         	mov	r2, r3
 8001af8: 687b         	ldr	r3, [r7, #0x4]
 8001afa: f8c3 20fc    	str.w	r2, [r3, #0xfc]
; 	memset(kf->Pminus_data, 0, sizeof_float * xhatSize * xhatSize);
 8001afe: 687b         	ldr	r3, [r7, #0x4]
 8001b00: f8d3 00fc    	ldr.w	r0, [r3, #0xfc]
 8001b04: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001b06: 881b         	ldrh	r3, [r3]
 8001b08: 461a         	mov	r2, r3
 8001b0a: 78fb         	ldrb	r3, [r7, #0x3]
 8001b0c: fb02 f303    	mul	r3, r2, r3
 8001b10: 78fa         	ldrb	r2, [r7, #0x3]
 8001b12: fb02 f303    	mul	r3, r2, r3
 8001b16: 461a         	mov	r2, r3
 8001b18: 2100         	movs	r1, #0x0
 8001b1a: f01e f8dd    	bl	0x801fcd8 <memset>      @ imm = #0x1e1ba
; 	Matrix_Init(&kf->Pminus, kf->xhatSize, kf->xhatSize, (float *)kf->Pminus_data);
 8001b1e: 687b         	ldr	r3, [r7, #0x4]
 8001b20: f103 0058    	add.w	r0, r3, #0x58
 8001b24: 687b         	ldr	r3, [r7, #0x4]
 8001b26: 7b1b         	ldrb	r3, [r3, #0xc]
 8001b28: 4619         	mov	r1, r3
 8001b2a: 687b         	ldr	r3, [r7, #0x4]
 8001b2c: 7b1b         	ldrb	r3, [r3, #0xc]
 8001b2e: 461a         	mov	r2, r3
 8001b30: 687b         	ldr	r3, [r7, #0x4]
 8001b32: f8d3 30fc    	ldr.w	r3, [r3, #0xfc]
 8001b36: f00c fcf9    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc9f2
; 	kf->F_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001b3a: 4b98         	ldr	r3, [pc, #0x260]        @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001b3c: 881b         	ldrh	r3, [r3]
 8001b3e: 461a         	mov	r2, r3
 8001b40: 78fb         	ldrb	r3, [r7, #0x3]
 8001b42: fb02 f303    	mul	r3, r2, r3
 8001b46: 78fa         	ldrb	r2, [r7, #0x3]
 8001b48: fb02 f303    	mul	r3, r2, r3
 8001b4c: 4618         	mov	r0, r3
 8001b4e: f005 fc15    	bl	0x800737c <malloc>      @ imm = #0x582a
 8001b52: 4603         	mov	r3, r0
 8001b54: 461a         	mov	r2, r3
 8001b56: 687b         	ldr	r3, [r7, #0x4]
 8001b58: f8c3 2100    	str.w	r2, [r3, #0x100]
; 	kf->FT_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001b5c: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001b5e: 881b         	ldrh	r3, [r3]
 8001b60: 461a         	mov	r2, r3
 8001b62: 78fb         	ldrb	r3, [r7, #0x3]
 8001b64: fb02 f303    	mul	r3, r2, r3
 8001b68: 78fa         	ldrb	r2, [r7, #0x3]
 8001b6a: fb02 f303    	mul	r3, r2, r3
 8001b6e: 4618         	mov	r0, r3
 8001b70: f005 fc04    	bl	0x800737c <malloc>      @ imm = #0x5808
 8001b74: 4603         	mov	r3, r0
 8001b76: 461a         	mov	r2, r3
 8001b78: 687b         	ldr	r3, [r7, #0x4]
 8001b7a: f8c3 2104    	str.w	r2, [r3, #0x104]
; 	memset(kf->F_data, 0, sizeof_float * xhatSize * xhatSize);
 8001b7e: 687b         	ldr	r3, [r7, #0x4]
 8001b80: f8d3 0100    	ldr.w	r0, [r3, #0x100]
 8001b84: 4b85         	ldr	r3, [pc, #0x214]        @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001b86: 881b         	ldrh	r3, [r3]
 8001b88: 461a         	mov	r2, r3
 8001b8a: 78fb         	ldrb	r3, [r7, #0x3]
 8001b8c: fb02 f303    	mul	r3, r2, r3
 8001b90: 78fa         	ldrb	r2, [r7, #0x3]
 8001b92: fb02 f303    	mul	r3, r2, r3
 8001b96: 461a         	mov	r2, r3
 8001b98: 2100         	movs	r1, #0x0
 8001b9a: f01e f89d    	bl	0x801fcd8 <memset>      @ imm = #0x1e13a
; 	memset(kf->FT_data, 0, sizeof_float * xhatSize * xhatSize);
 8001b9e: 687b         	ldr	r3, [r7, #0x4]
 8001ba0: f8d3 0104    	ldr.w	r0, [r3, #0x104]
 8001ba4: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001ba6: 881b         	ldrh	r3, [r3]
 8001ba8: 461a         	mov	r2, r3
 8001baa: 78fb         	ldrb	r3, [r7, #0x3]
 8001bac: fb02 f303    	mul	r3, r2, r3
 8001bb0: 78fa         	ldrb	r2, [r7, #0x3]
 8001bb2: fb02 f303    	mul	r3, r2, r3
 8001bb6: 461a         	mov	r2, r3
 8001bb8: 2100         	movs	r1, #0x0
 8001bba: f01e f88d    	bl	0x801fcd8 <memset>      @ imm = #0x1e11a
; 	Matrix_Init(&kf->F, kf->xhatSize, kf->xhatSize, (float *)kf->F_data);
 8001bbe: 687b         	ldr	r3, [r7, #0x4]
 8001bc0: f103 0060    	add.w	r0, r3, #0x60
 8001bc4: 687b         	ldr	r3, [r7, #0x4]
 8001bc6: 7b1b         	ldrb	r3, [r3, #0xc]
 8001bc8: 4619         	mov	r1, r3
 8001bca: 687b         	ldr	r3, [r7, #0x4]
 8001bcc: 7b1b         	ldrb	r3, [r3, #0xc]
 8001bce: 461a         	mov	r2, r3
 8001bd0: 687b         	ldr	r3, [r7, #0x4]
 8001bd2: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8001bd6: f00c fca9    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc952
; 	Matrix_Init(&kf->FT, kf->xhatSize, kf->xhatSize, (float *)kf->FT_data);
 8001bda: 687b         	ldr	r3, [r7, #0x4]
 8001bdc: f103 0068    	add.w	r0, r3, #0x68
 8001be0: 687b         	ldr	r3, [r7, #0x4]
 8001be2: 7b1b         	ldrb	r3, [r3, #0xc]
 8001be4: 4619         	mov	r1, r3
 8001be6: 687b         	ldr	r3, [r7, #0x4]
 8001be8: 7b1b         	ldrb	r3, [r3, #0xc]
 8001bea: 461a         	mov	r2, r3
 8001bec: 687b         	ldr	r3, [r7, #0x4]
 8001bee: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8001bf2: f00c fc9b    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc936
; 	if (uSize != 0) {
 8001bf6: 78bb         	ldrb	r3, [r7, #0x2]
 8001bf8: 2b00         	cmp	r3, #0x0
 8001bfa: d02e         	beq	0x8001c5a <Kalman_Filter_Init+0x4ca> @ imm = #0x5c
; 		kf->B_data = (float *)user_malloc(sizeof_float * xhatSize * uSize);
 8001bfc: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001bfe: 881b         	ldrh	r3, [r3]
 8001c00: 461a         	mov	r2, r3
 8001c02: 78fb         	ldrb	r3, [r7, #0x3]
 8001c04: fb02 f303    	mul	r3, r2, r3
 8001c08: 78ba         	ldrb	r2, [r7, #0x2]
 8001c0a: fb02 f303    	mul	r3, r2, r3
 8001c0e: 4618         	mov	r0, r3
 8001c10: f005 fbb4    	bl	0x800737c <malloc>      @ imm = #0x5768
 8001c14: 4603         	mov	r3, r0
 8001c16: 461a         	mov	r2, r3
 8001c18: 687b         	ldr	r3, [r7, #0x4]
 8001c1a: f8c3 2108    	str.w	r2, [r3, #0x108]
; 		memset(kf->B_data, 0, sizeof_float * xhatSize * uSize);
 8001c1e: 687b         	ldr	r3, [r7, #0x4]
 8001c20: f8d3 0108    	ldr.w	r0, [r3, #0x108]
 8001c24: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001c26: 881b         	ldrh	r3, [r3]
 8001c28: 461a         	mov	r2, r3
 8001c2a: 78fb         	ldrb	r3, [r7, #0x3]
 8001c2c: fb02 f303    	mul	r3, r2, r3
 8001c30: 78ba         	ldrb	r2, [r7, #0x2]
 8001c32: fb02 f303    	mul	r3, r2, r3
 8001c36: 461a         	mov	r2, r3
 8001c38: 2100         	movs	r1, #0x0
 8001c3a: f01e f84d    	bl	0x801fcd8 <memset>      @ imm = #0x1e09a
; 		Matrix_Init(&kf->B, kf->xhatSize, kf->uSize, (float *)kf->B_data);
 8001c3e: 687b         	ldr	r3, [r7, #0x4]
 8001c40: f103 0070    	add.w	r0, r3, #0x70
 8001c44: 687b         	ldr	r3, [r7, #0x4]
 8001c46: 7b1b         	ldrb	r3, [r3, #0xc]
 8001c48: 4619         	mov	r1, r3
 8001c4a: 687b         	ldr	r3, [r7, #0x4]
 8001c4c: 7b5b         	ldrb	r3, [r3, #0xd]
 8001c4e: 461a         	mov	r2, r3
 8001c50: 687b         	ldr	r3, [r7, #0x4]
 8001c52: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 8001c56: f00c fc69    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc8d2
; 	kf->H_data = (float *)user_malloc(sizeof_float * zSize * xhatSize);
 8001c5a: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001c5c: 881b         	ldrh	r3, [r3]
 8001c5e: 461a         	mov	r2, r3
 8001c60: 787b         	ldrb	r3, [r7, #0x1]
 8001c62: fb02 f303    	mul	r3, r2, r3
 8001c66: 78fa         	ldrb	r2, [r7, #0x3]
 8001c68: fb02 f303    	mul	r3, r2, r3
 8001c6c: 4618         	mov	r0, r3
 8001c6e: f005 fb85    	bl	0x800737c <malloc>      @ imm = #0x570a
 8001c72: 4603         	mov	r3, r0
 8001c74: 461a         	mov	r2, r3
 8001c76: 687b         	ldr	r3, [r7, #0x4]
 8001c78: f8c3 210c    	str.w	r2, [r3, #0x10c]
; 	kf->HT_data = (float *)user_malloc(sizeof_float * xhatSize * zSize);
 8001c7c: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001c7e: 881b         	ldrh	r3, [r3]
 8001c80: 461a         	mov	r2, r3
 8001c82: 78fb         	ldrb	r3, [r7, #0x3]
 8001c84: fb02 f303    	mul	r3, r2, r3
 8001c88: 787a         	ldrb	r2, [r7, #0x1]
 8001c8a: fb02 f303    	mul	r3, r2, r3
 8001c8e: 4618         	mov	r0, r3
 8001c90: f005 fb74    	bl	0x800737c <malloc>      @ imm = #0x56e8
 8001c94: 4603         	mov	r3, r0
 8001c96: 461a         	mov	r2, r3
 8001c98: 687b         	ldr	r3, [r7, #0x4]
 8001c9a: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	memset(kf->H_data, 0, sizeof_float * zSize * xhatSize);
 8001c9e: 687b         	ldr	r3, [r7, #0x4]
 8001ca0: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 8001ca4: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001ca6: 881b         	ldrh	r3, [r3]
 8001ca8: 461a         	mov	r2, r3
 8001caa: 787b         	ldrb	r3, [r7, #0x1]
 8001cac: fb02 f303    	mul	r3, r2, r3
 8001cb0: 78fa         	ldrb	r2, [r7, #0x3]
 8001cb2: fb02 f303    	mul	r3, r2, r3
 8001cb6: 461a         	mov	r2, r3
 8001cb8: 2100         	movs	r1, #0x0
 8001cba: f01e f80d    	bl	0x801fcd8 <memset>      @ imm = #0x1e01a
; 	memset(kf->HT_data, 0, sizeof_float * xhatSize * zSize);
 8001cbe: 687b         	ldr	r3, [r7, #0x4]
 8001cc0: f8d3 0110    	ldr.w	r0, [r3, #0x110]
 8001cc4: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001cc6: 881b         	ldrh	r3, [r3]
 8001cc8: 461a         	mov	r2, r3
 8001cca: 78fb         	ldrb	r3, [r7, #0x3]
 8001ccc: fb02 f303    	mul	r3, r2, r3
 8001cd0: 787a         	ldrb	r2, [r7, #0x1]
 8001cd2: fb02 f303    	mul	r3, r2, r3
 8001cd6: 461a         	mov	r2, r3
 8001cd8: 2100         	movs	r1, #0x0
 8001cda: f01d fffd    	bl	0x801fcd8 <memset>      @ imm = #0x1dffa
; 	Matrix_Init(&kf->H, kf->zSize, kf->xhatSize, (float *)kf->H_data);
 8001cde: 687b         	ldr	r3, [r7, #0x4]
 8001ce0: f103 0078    	add.w	r0, r3, #0x78
 8001ce4: 687b         	ldr	r3, [r7, #0x4]
 8001ce6: 7b9b         	ldrb	r3, [r3, #0xe]
 8001ce8: 4619         	mov	r1, r3
 8001cea: 687b         	ldr	r3, [r7, #0x4]
 8001cec: 7b1b         	ldrb	r3, [r3, #0xc]
 8001cee: 461a         	mov	r2, r3
 8001cf0: 687b         	ldr	r3, [r7, #0x4]
 8001cf2: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8001cf6: f00c fc19    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc832
; 	Matrix_Init(&kf->HT, kf->xhatSize, kf->zSize, (float *)kf->HT_data);
 8001cfa: 687b         	ldr	r3, [r7, #0x4]
 8001cfc: f103 0080    	add.w	r0, r3, #0x80
 8001d00: 687b         	ldr	r3, [r7, #0x4]
 8001d02: 7b1b         	ldrb	r3, [r3, #0xc]
 8001d04: 4619         	mov	r1, r3
 8001d06: 687b         	ldr	r3, [r7, #0x4]
 8001d08: 7b9b         	ldrb	r3, [r3, #0xe]
 8001d0a: 461a         	mov	r2, r3
 8001d0c: 687b         	ldr	r3, [r7, #0x4]
 8001d0e: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 8001d12: f00c fc0b    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc816
; 	kf->Q_data = (float *)user_malloc(sizeof_float * xhatSize * xhatSize);
 8001d16: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001d18: 881b         	ldrh	r3, [r3]
 8001d1a: 461a         	mov	r2, r3
 8001d1c: 78fb         	ldrb	r3, [r7, #0x3]
 8001d1e: fb02 f303    	mul	r3, r2, r3
 8001d22: 78fa         	ldrb	r2, [r7, #0x3]
 8001d24: fb02 f303    	mul	r3, r2, r3
 8001d28: 4618         	mov	r0, r3
 8001d2a: f005 fb27    	bl	0x800737c <malloc>      @ imm = #0x564e
 8001d2e: 4603         	mov	r3, r0
 8001d30: 461a         	mov	r2, r3
 8001d32: 687b         	ldr	r3, [r7, #0x4]
 8001d34: f8c3 2114    	str.w	r2, [r3, #0x114]
; 	memset(kf->Q_data, 0, sizeof_float * xhatSize * xhatSize);
 8001d38: 687b         	ldr	r3, [r7, #0x4]
 8001d3a: f8d3 0114    	ldr.w	r0, [r3, #0x114]
 8001d3e: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001d40: 881b         	ldrh	r3, [r3]
 8001d42: 461a         	mov	r2, r3
 8001d44: 78fb         	ldrb	r3, [r7, #0x3]
 8001d46: fb02 f303    	mul	r3, r2, r3
 8001d4a: 78fa         	ldrb	r2, [r7, #0x3]
 8001d4c: fb02 f303    	mul	r3, r2, r3
 8001d50: 461a         	mov	r2, r3
 8001d52: 2100         	movs	r1, #0x0
 8001d54: f01d ffc0    	bl	0x801fcd8 <memset>      @ imm = #0x1df80
; 	Matrix_Init(&kf->Q, kf->xhatSize, kf->xhatSize, (float *)kf->Q_data);
 8001d58: 687b         	ldr	r3, [r7, #0x4]
 8001d5a: f103 0088    	add.w	r0, r3, #0x88
 8001d5e: 687b         	ldr	r3, [r7, #0x4]
 8001d60: 7b1b         	ldrb	r3, [r3, #0xc]
 8001d62: 4619         	mov	r1, r3
 8001d64: 687b         	ldr	r3, [r7, #0x4]
 8001d66: 7b1b         	ldrb	r3, [r3, #0xc]
 8001d68: 461a         	mov	r2, r3
 8001d6a: 687b         	ldr	r3, [r7, #0x4]
 8001d6c: f8d3 3114    	ldr.w	r3, [r3, #0x114]
 8001d70: f00c fbdc    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc7b8
; 	kf->R_data = (float *)user_malloc(sizeof_float * zSize * zSize);
 8001d74: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8001d9c <Kalman_Filter_Init+0x60c>
 8001d76: 881b         	ldrh	r3, [r3]
 8001d78: 461a         	mov	r2, r3
 8001d7a: 787b         	ldrb	r3, [r7, #0x1]
 8001d7c: fb02 f303    	mul	r3, r2, r3
 8001d80: 787a         	ldrb	r2, [r7, #0x1]
 8001d82: fb02 f303    	mul	r3, r2, r3
 8001d86: 4618         	mov	r0, r3
 8001d88: f005 faf8    	bl	0x800737c <malloc>      @ imm = #0x55f0
 8001d8c: 4603         	mov	r3, r0
 8001d8e: 461a         	mov	r2, r3
 8001d90: 687b         	ldr	r3, [r7, #0x4]
 8001d92: f8c3 2118    	str.w	r2, [r3, #0x118]
; 	memset(kf->R_data, 0, sizeof_float * zSize * zSize);
 8001d96: 687b         	ldr	r3, [r7, #0x4]
 8001d98: e002         	b	0x8001da0 <Kalman_Filter_Init+0x610> @ imm = #0x4
 8001d9a: bf00         	nop

08001d9c <$d>:
 8001d9c: f4 27 00 20  	.word	0x200027f4

08001da0 <$t>:
 8001da0: f8d3 0118    	ldr.w	r0, [r3, #0x118]
 8001da4: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x8001f9c <Kalman_Filter_Init+0x80c>
 8001da6: 881b         	ldrh	r3, [r3]
 8001da8: 461a         	mov	r2, r3
 8001daa: 787b         	ldrb	r3, [r7, #0x1]
 8001dac: fb02 f303    	mul	r3, r2, r3
 8001db0: 787a         	ldrb	r2, [r7, #0x1]
 8001db2: fb02 f303    	mul	r3, r2, r3
 8001db6: 461a         	mov	r2, r3
 8001db8: 2100         	movs	r1, #0x0
 8001dba: f01d ff8d    	bl	0x801fcd8 <memset>      @ imm = #0x1df1a
; 	Matrix_Init(&kf->R, kf->zSize, kf->zSize, (float *)kf->R_data);
 8001dbe: 687b         	ldr	r3, [r7, #0x4]
 8001dc0: f103 0090    	add.w	r0, r3, #0x90
 8001dc4: 687b         	ldr	r3, [r7, #0x4]
 8001dc6: 7b9b         	ldrb	r3, [r3, #0xe]
 8001dc8: 4619         	mov	r1, r3
 8001dca: 687b         	ldr	r3, [r7, #0x4]
 8001dcc: 7b9b         	ldrb	r3, [r3, #0xe]
 8001dce: 461a         	mov	r2, r3
 8001dd0: 687b         	ldr	r3, [r7, #0x4]
 8001dd2: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8001dd6: f00c fba9    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc752
; 	kf->K_data = (float *)user_malloc(sizeof_float * xhatSize * zSize);
 8001dda: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x8001f9c <Kalman_Filter_Init+0x80c>
 8001ddc: 881b         	ldrh	r3, [r3]
 8001dde: 461a         	mov	r2, r3
 8001de0: 78fb         	ldrb	r3, [r7, #0x3]
 8001de2: fb02 f303    	mul	r3, r2, r3
 8001de6: 787a         	ldrb	r2, [r7, #0x1]
 8001de8: fb02 f303    	mul	r3, r2, r3
 8001dec: 4618         	mov	r0, r3
 8001dee: f005 fac5    	bl	0x800737c <malloc>      @ imm = #0x558a
 8001df2: 4603         	mov	r3, r0
 8001df4: 461a         	mov	r2, r3
 8001df6: 687b         	ldr	r3, [r7, #0x4]
 8001df8: f8c3 211c    	str.w	r2, [r3, #0x11c]
; 	memset(kf->K_data, 0, sizeof_float * xhatSize * zSize);
 8001dfc: 687b         	ldr	r3, [r7, #0x4]
 8001dfe: f8d3 011c    	ldr.w	r0, [r3, #0x11c]
 8001e02: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8001f9c <Kalman_Filter_Init+0x80c>
 8001e04: 881b         	ldrh	r3, [r3]
 8001e06: 461a         	mov	r2, r3
 8001e08: 78fb         	ldrb	r3, [r7, #0x3]
 8001e0a: fb02 f303    	mul	r3, r2, r3
 8001e0e: 787a         	ldrb	r2, [r7, #0x1]
 8001e10: fb02 f303    	mul	r3, r2, r3
 8001e14: 461a         	mov	r2, r3
 8001e16: 2100         	movs	r1, #0x0
 8001e18: f01d ff5e    	bl	0x801fcd8 <memset>      @ imm = #0x1debc
; 	Matrix_Init(&kf->K, kf->xhatSize, kf->zSize, (float *)kf->K_data);
 8001e1c: 687b         	ldr	r3, [r7, #0x4]
 8001e1e: f103 0098    	add.w	r0, r3, #0x98
 8001e22: 687b         	ldr	r3, [r7, #0x4]
 8001e24: 7b1b         	ldrb	r3, [r3, #0xc]
 8001e26: 4619         	mov	r1, r3
 8001e28: 687b         	ldr	r3, [r7, #0x4]
 8001e2a: 7b9b         	ldrb	r3, [r3, #0xe]
 8001e2c: 461a         	mov	r2, r3
 8001e2e: 687b         	ldr	r3, [r7, #0x4]
 8001e30: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8001e34: f00c fb7a    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc6f4
; 	kf->S_data = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 8001e38: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8001f9c <Kalman_Filter_Init+0x80c>
 8001e3a: 881b         	ldrh	r3, [r3]
 8001e3c: 461a         	mov	r2, r3
 8001e3e: 687b         	ldr	r3, [r7, #0x4]
 8001e40: 7b1b         	ldrb	r3, [r3, #0xc]
 8001e42: fb02 f303    	mul	r3, r2, r3
 8001e46: 687a         	ldr	r2, [r7, #0x4]
 8001e48: 7b12         	ldrb	r2, [r2, #0xc]
 8001e4a: fb02 f303    	mul	r3, r2, r3
 8001e4e: 4618         	mov	r0, r3
 8001e50: f005 fa94    	bl	0x800737c <malloc>      @ imm = #0x5528
 8001e54: 4603         	mov	r3, r0
 8001e56: 461a         	mov	r2, r3
 8001e58: 687b         	ldr	r3, [r7, #0x4]
 8001e5a: f8c3 2120    	str.w	r2, [r3, #0x120]
; 	kf->temp_matrix_data = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 8001e5e: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8001f9c <Kalman_Filter_Init+0x80c>
 8001e60: 881b         	ldrh	r3, [r3]
 8001e62: 461a         	mov	r2, r3
 8001e64: 687b         	ldr	r3, [r7, #0x4]
 8001e66: 7b1b         	ldrb	r3, [r3, #0xc]
 8001e68: fb02 f303    	mul	r3, r2, r3
 8001e6c: 687a         	ldr	r2, [r7, #0x4]
 8001e6e: 7b12         	ldrb	r2, [r2, #0xc]
 8001e70: fb02 f303    	mul	r3, r2, r3
 8001e74: 4618         	mov	r0, r3
 8001e76: f005 fa81    	bl	0x800737c <malloc>      @ imm = #0x5502
 8001e7a: 4603         	mov	r3, r0
 8001e7c: 461a         	mov	r2, r3
 8001e7e: 687b         	ldr	r3, [r7, #0x4]
 8001e80: f8c3 2124    	str.w	r2, [r3, #0x124]
; 	kf->temp_matrix_data1 = (float *)user_malloc(sizeof_float * kf->xhatSize * kf->xhatSize);
 8001e84: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8001f9c <Kalman_Filter_Init+0x80c>
 8001e86: 881b         	ldrh	r3, [r3]
 8001e88: 461a         	mov	r2, r3
 8001e8a: 687b         	ldr	r3, [r7, #0x4]
 8001e8c: 7b1b         	ldrb	r3, [r3, #0xc]
 8001e8e: fb02 f303    	mul	r3, r2, r3
 8001e92: 687a         	ldr	r2, [r7, #0x4]
 8001e94: 7b12         	ldrb	r2, [r2, #0xc]
 8001e96: fb02 f303    	mul	r3, r2, r3
 8001e9a: 4618         	mov	r0, r3
 8001e9c: f005 fa6e    	bl	0x800737c <malloc>      @ imm = #0x54dc
 8001ea0: 4603         	mov	r3, r0
 8001ea2: 461a         	mov	r2, r3
 8001ea4: 687b         	ldr	r3, [r7, #0x4]
 8001ea6: f8c3 2128    	str.w	r2, [r3, #0x128]
; 	kf->temp_vector_data = (float *)user_malloc(sizeof_float * kf->xhatSize);
 8001eaa: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8001f9c <Kalman_Filter_Init+0x80c>
 8001eac: 881b         	ldrh	r3, [r3]
 8001eae: 461a         	mov	r2, r3
 8001eb0: 687b         	ldr	r3, [r7, #0x4]
 8001eb2: 7b1b         	ldrb	r3, [r3, #0xc]
 8001eb4: fb02 f303    	mul	r3, r2, r3
 8001eb8: 4618         	mov	r0, r3
 8001eba: f005 fa5f    	bl	0x800737c <malloc>      @ imm = #0x54be
 8001ebe: 4603         	mov	r3, r0
 8001ec0: 461a         	mov	r2, r3
 8001ec2: 687b         	ldr	r3, [r7, #0x4]
 8001ec4: f8c3 212c    	str.w	r2, [r3, #0x12c]
; 	kf->temp_vector_data1 = (float *)user_malloc(sizeof_float * kf->xhatSize);
 8001ec8: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8001f9c <Kalman_Filter_Init+0x80c>
 8001eca: 881b         	ldrh	r3, [r3]
 8001ecc: 461a         	mov	r2, r3
 8001ece: 687b         	ldr	r3, [r7, #0x4]
 8001ed0: 7b1b         	ldrb	r3, [r3, #0xc]
 8001ed2: fb02 f303    	mul	r3, r2, r3
 8001ed6: 4618         	mov	r0, r3
 8001ed8: f005 fa50    	bl	0x800737c <malloc>      @ imm = #0x54a0
 8001edc: 4603         	mov	r3, r0
 8001ede: 461a         	mov	r2, r3
 8001ee0: 687b         	ldr	r3, [r7, #0x4]
 8001ee2: f8c3 2130    	str.w	r2, [r3, #0x130]
; 	Matrix_Init(&kf->S, kf->xhatSize, kf->xhatSize, (float *)kf->S_data);
 8001ee6: 687b         	ldr	r3, [r7, #0x4]
 8001ee8: f103 00a0    	add.w	r0, r3, #0xa0
 8001eec: 687b         	ldr	r3, [r7, #0x4]
 8001eee: 7b1b         	ldrb	r3, [r3, #0xc]
 8001ef0: 4619         	mov	r1, r3
 8001ef2: 687b         	ldr	r3, [r7, #0x4]
 8001ef4: 7b1b         	ldrb	r3, [r3, #0xc]
 8001ef6: 461a         	mov	r2, r3
 8001ef8: 687b         	ldr	r3, [r7, #0x4]
 8001efa: f8d3 3120    	ldr.w	r3, [r3, #0x120]
 8001efe: f00c fb15    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc62a
; 	Matrix_Init(&kf->temp_matrix, kf->xhatSize, kf->xhatSize, (float *)kf->temp_matrix_data);
 8001f02: 687b         	ldr	r3, [r7, #0x4]
 8001f04: f103 00a8    	add.w	r0, r3, #0xa8
 8001f08: 687b         	ldr	r3, [r7, #0x4]
 8001f0a: 7b1b         	ldrb	r3, [r3, #0xc]
 8001f0c: 4619         	mov	r1, r3
 8001f0e: 687b         	ldr	r3, [r7, #0x4]
 8001f10: 7b1b         	ldrb	r3, [r3, #0xc]
 8001f12: 461a         	mov	r2, r3
 8001f14: 687b         	ldr	r3, [r7, #0x4]
 8001f16: f8d3 3124    	ldr.w	r3, [r3, #0x124]
 8001f1a: f00c fb07    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc60e
; 	Matrix_Init(&kf->temp_matrix1, kf->xhatSize, kf->xhatSize, (float *)kf->temp_matrix_data1);
 8001f1e: 687b         	ldr	r3, [r7, #0x4]
 8001f20: f103 00b0    	add.w	r0, r3, #0xb0
 8001f24: 687b         	ldr	r3, [r7, #0x4]
 8001f26: 7b1b         	ldrb	r3, [r3, #0xc]
 8001f28: 4619         	mov	r1, r3
 8001f2a: 687b         	ldr	r3, [r7, #0x4]
 8001f2c: 7b1b         	ldrb	r3, [r3, #0xc]
 8001f2e: 461a         	mov	r2, r3
 8001f30: 687b         	ldr	r3, [r7, #0x4]
 8001f32: f8d3 3128    	ldr.w	r3, [r3, #0x128]
 8001f36: f00c faf9    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc5f2
; 	Matrix_Init(&kf->temp_vector, kf->xhatSize, 1, (float *)kf->temp_vector_data);
 8001f3a: 687b         	ldr	r3, [r7, #0x4]
 8001f3c: f103 00b8    	add.w	r0, r3, #0xb8
 8001f40: 687b         	ldr	r3, [r7, #0x4]
 8001f42: 7b1b         	ldrb	r3, [r3, #0xc]
 8001f44: 4619         	mov	r1, r3
 8001f46: 687b         	ldr	r3, [r7, #0x4]
 8001f48: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 8001f4c: 2201         	movs	r2, #0x1
 8001f4e: f00c faed    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc5da
; 	Matrix_Init(&kf->temp_vector1, kf->xhatSize, 1, (float *)kf->temp_vector_data1);
 8001f52: 687b         	ldr	r3, [r7, #0x4]
 8001f54: f103 00c0    	add.w	r0, r3, #0xc0
 8001f58: 687b         	ldr	r3, [r7, #0x4]
 8001f5a: 7b1b         	ldrb	r3, [r3, #0xc]
 8001f5c: 4619         	mov	r1, r3
 8001f5e: 687b         	ldr	r3, [r7, #0x4]
 8001f60: f8d3 3130    	ldr.w	r3, [r3, #0x130]
 8001f64: 2201         	movs	r2, #0x1
 8001f66: f00c fae1    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xc5c2
; 	kf->SkipEq1 = 0;
 8001f6a: 687b         	ldr	r3, [r7, #0x4]
 8001f6c: 2200         	movs	r2, #0x0
 8001f6e: f883 2028    	strb.w	r2, [r3, #0x28]
; 	kf->SkipEq2 = 0;
 8001f72: 687b         	ldr	r3, [r7, #0x4]
 8001f74: 2200         	movs	r2, #0x0
 8001f76: f883 2029    	strb.w	r2, [r3, #0x29]
; 	kf->SkipEq3 = 0;
 8001f7a: 687b         	ldr	r3, [r7, #0x4]
 8001f7c: 2200         	movs	r2, #0x0
 8001f7e: f883 202a    	strb.w	r2, [r3, #0x2a]
; 	kf->SkipEq4 = 0;
 8001f82: 687b         	ldr	r3, [r7, #0x4]
 8001f84: 2200         	movs	r2, #0x0
 8001f86: f883 202b    	strb.w	r2, [r3, #0x2b]
; 	kf->SkipEq5 = 0;
 8001f8a: 687b         	ldr	r3, [r7, #0x4]
 8001f8c: 2200         	movs	r2, #0x0
 8001f8e: f883 202c    	strb.w	r2, [r3, #0x2c]
; }
 8001f92: bf00         	nop
 8001f94: 3708         	adds	r7, #0x8
 8001f96: 46bd         	mov	sp, r7
 8001f98: bd80         	pop	{r7, pc}
 8001f9a: bf00         	nop

08001f9c <$d>:
 8001f9c: f4 27 00 20  	.word	0x200027f4

08001fa0 <Kalman_Filter_Measure>:
; {
 8001fa0: b580         	push	{r7, lr}
 8001fa2: b082         	sub	sp, #0x8
 8001fa4: af00         	add	r7, sp, #0x0
 8001fa6: 6078         	str	r0, [r7, #0x4]
; 	if (kf->UseAutoAdjustment != 0) {
 8001fa8: 687b         	ldr	r3, [r7, #0x4]
 8001faa: 7bdb         	ldrb	r3, [r3, #0xf]
 8001fac: 2b00         	cmp	r3, #0x0
 8001fae: d003         	beq	0x8001fb8 <Kalman_Filter_Measure+0x18> @ imm = #0x6
; 		H_K_R_Adjustment(kf);
 8001fb0: 6878         	ldr	r0, [r7, #0x4]
 8001fb2: f000 f975    	bl	0x80022a0 <H_K_R_Adjustment> @ imm = #0x2ea
 8001fb6: e01b         	b	0x8001ff0 <Kalman_Filter_Measure+0x50> @ imm = #0x36
; 		memcpy(kf->z_data, kf->MeasuredVector, sizeof_float * kf->zSize);
 8001fb8: 687b         	ldr	r3, [r7, #0x4]
 8001fba: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 8001fbe: 687b         	ldr	r3, [r7, #0x4]
 8001fc0: 6859         	ldr	r1, [r3, #0x4]
 8001fc2: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8002018 <Kalman_Filter_Measure+0x78>
 8001fc4: 881b         	ldrh	r3, [r3]
 8001fc6: 461a         	mov	r2, r3
 8001fc8: 687b         	ldr	r3, [r7, #0x4]
 8001fca: 7b9b         	ldrb	r3, [r3, #0xe]
 8001fcc: fb02 f303    	mul	r3, r2, r3
 8001fd0: 461a         	mov	r2, r3
 8001fd2: f01d fe73    	bl	0x801fcbc <memcpy>      @ imm = #0x1dce6
; 		memset(kf->MeasuredVector, 0, sizeof_float * kf->zSize);
 8001fd6: 687b         	ldr	r3, [r7, #0x4]
 8001fd8: 6858         	ldr	r0, [r3, #0x4]
 8001fda: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8002018 <Kalman_Filter_Measure+0x78>
 8001fdc: 881b         	ldrh	r3, [r3]
 8001fde: 461a         	mov	r2, r3
 8001fe0: 687b         	ldr	r3, [r7, #0x4]
 8001fe2: 7b9b         	ldrb	r3, [r3, #0xe]
 8001fe4: fb02 f303    	mul	r3, r2, r3
 8001fe8: 461a         	mov	r2, r3
 8001fea: 2100         	movs	r1, #0x0
 8001fec: f01d fe74    	bl	0x801fcd8 <memset>      @ imm = #0x1dce8
; 	memcpy(kf->u_data, kf->ControlVector, sizeof_float * kf->uSize);
 8001ff0: 687b         	ldr	r3, [r7, #0x4]
 8001ff2: f8d3 00f0    	ldr.w	r0, [r3, #0xf0]
 8001ff6: 687b         	ldr	r3, [r7, #0x4]
 8001ff8: 6899         	ldr	r1, [r3, #0x8]
 8001ffa: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8002018 <Kalman_Filter_Measure+0x78>
 8001ffc: 881b         	ldrh	r3, [r3]
 8001ffe: 461a         	mov	r2, r3
 8002000: 687b         	ldr	r3, [r7, #0x4]
 8002002: 7b5b         	ldrb	r3, [r3, #0xd]
 8002004: fb02 f303    	mul	r3, r2, r3
 8002008: 461a         	mov	r2, r3
 800200a: f01d fe57    	bl	0x801fcbc <memcpy>      @ imm = #0x1dcae
; }
 800200e: bf00         	nop
 8002010: 3708         	adds	r7, #0x8
 8002012: 46bd         	mov	sp, r7
 8002014: bd80         	pop	{r7, pc}
 8002016: bf00         	nop

08002018 <$d>:
 8002018: f4 27 00 20  	.word	0x200027f4

0800201c <Kalman_Filter_Update>:
; {
 800201c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8002020: b08a         	sub	sp, #0x28
 8002022: af00         	add	r7, sp, #0x0
 8002024: 6178         	str	r0, [r7, #0x14]
; 	QEKF_INS_t *QEKF_INS = CONTAINER_OF(kf, QEKF_INS_t, IMU_QuaternionEKF);
 8002026: 697b         	ldr	r3, [r7, #0x14]
 8002028: 3b04         	subs	r3, #0x4
 800202a: 623b         	str	r3, [r7, #0x20]
; 	Kalman_Filter_Measure(kf);
 800202c: 6978         	ldr	r0, [r7, #0x14]
 800202e: f7ff ffb7    	bl	0x8001fa0 <Kalman_Filter_Measure> @ imm = #-0x92
; 	if (kf->User_Func0_f != NULL) {
 8002032: 697b         	ldr	r3, [r7, #0x14]
 8002034: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
 8002038: 2b00         	cmp	r3, #0x0
 800203a: d004         	beq	0x8002046 <Kalman_Filter_Update+0x2a> @ imm = #0x8
; 		kf->User_Func0_f(kf);
 800203c: 697b         	ldr	r3, [r7, #0x14]
 800203e: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
 8002042: 6978         	ldr	r0, [r7, #0x14]
 8002044: 4798         	blx	r3
; 	Kalman_Filter_xhatMinusUpdate(kf);
 8002046: 6978         	ldr	r0, [r7, #0x14]
 8002048: f013 fb4f    	bl	0x80156ea <Kalman_Filter_xhatMinusUpdate> @ imm = #0x1369e
; 	if (kf->User_Func1_f != NULL) {
 800204c: 697b         	ldr	r3, [r7, #0x14]
 800204e: f8d3 30d0    	ldr.w	r3, [r3, #0xd0]
 8002052: 2b00         	cmp	r3, #0x0
 8002054: d004         	beq	0x8002060 <Kalman_Filter_Update+0x44> @ imm = #0x8
; 		kf->User_Func1_f(kf);
 8002056: 697b         	ldr	r3, [r7, #0x14]
 8002058: f8d3 30d0    	ldr.w	r3, [r3, #0xd0]
 800205c: 6978         	ldr	r0, [r7, #0x14]
 800205e: 4798         	blx	r3
; 	Kalman_Filter_PminusUpdate(kf);
 8002060: 6978         	ldr	r0, [r7, #0x14]
 8002062: f013 fba8    	bl	0x80157b6 <Kalman_Filter_PminusUpdate> @ imm = #0x13750
; 	if (kf->User_Func2_f != NULL) {
 8002066: 697b         	ldr	r3, [r7, #0x14]
 8002068: f8d3 30d4    	ldr.w	r3, [r3, #0xd4]
 800206c: 2b00         	cmp	r3, #0x0
 800206e: d004         	beq	0x800207a <Kalman_Filter_Update+0x5e> @ imm = #0x8
; 		kf->User_Func2_f(kf);
 8002070: 697b         	ldr	r3, [r7, #0x14]
 8002072: f8d3 30d4    	ldr.w	r3, [r3, #0xd4]
 8002076: 6978         	ldr	r0, [r7, #0x14]
 8002078: 4798         	blx	r3
; 	if (kf->MeasurementValidNum != 0 || kf->UseAutoAdjustment == 0) {
 800207a: 697b         	ldr	r3, [r7, #0x14]
 800207c: 7c1b         	ldrb	r3, [r3, #0x10]
 800207e: 2b00         	cmp	r3, #0x0
 8002080: d103         	bne	0x800208a <Kalman_Filter_Update+0x6e> @ imm = #0x6
 8002082: 697b         	ldr	r3, [r7, #0x14]
 8002084: 7bdb         	ldrb	r3, [r3, #0xf]
 8002086: 2b00         	cmp	r3, #0x0
 8002088: d176         	bne	0x8002178 <Kalman_Filter_Update+0x15c> @ imm = #0xec
; 		Kalman_Filter_SetK(kf);
 800208a: 6978         	ldr	r0, [r7, #0x14]
 800208c: f013 fbea    	bl	0x8015864 <Kalman_Filter_SetK> @ imm = #0x137d4
; 		int start_us = k_cyc_to_us_near32(k_cycle_get_32());
 8002090: f013 fa56    	bl	0x8015540 <k_cycle_get_32> @ imm = #0x134ac
 8002094: 4603         	mov	r3, r0
 8002096: f113 0f55    	cmn.w	r3, #0x55
 800209a: d809         	bhi	0x80020b0 <Kalman_Filter_Update+0x94> @ imm = #0x12
 800209c: f013 fa50    	bl	0x8015540 <k_cycle_get_32> @ imm = #0x134a0
 80020a0: 4603         	mov	r3, r0
 80020a2: 3354         	adds	r3, #0x54
 80020a4: 08db         	lsrs	r3, r3, #0x3
 80020a6: 4a7c         	ldr	r2, [pc, #0x1f0]        @ 0x8002298 <Kalman_Filter_Update+0x27c>
 80020a8: fba2 2303    	umull	r2, r3, r2, r3
 80020ac: 085b         	lsrs	r3, r3, #0x1
 80020ae: e016         	b	0x80020de <Kalman_Filter_Update+0xc2> @ imm = #0x2c
 80020b0: f013 fa46    	bl	0x8015540 <k_cycle_get_32> @ imm = #0x1348c
 80020b4: 4603         	mov	r3, r0
 80020b6: 2200         	movs	r2, #0x0
 80020b8: 4698         	mov	r8, r3
 80020ba: 4691         	mov	r9, r2
 80020bc: f118 0354    	adds.w	r3, r8, #0x54
 80020c0: 60bb         	str	r3, [r7, #0x8]
 80020c2: f149 0300    	adc	r3, r9, #0x0
 80020c6: 60fb         	str	r3, [r7, #0xc]
 80020c8: f04f 02a8    	mov.w	r2, #0xa8
 80020cc: f04f 0300    	mov.w	r3, #0x0
 80020d0: e9d7 0102    	ldrd	r0, r1, [r7, #8]
 80020d4: f7fe fcc6    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x1674
 80020d8: 4602         	mov	r2, r0
 80020da: 460b         	mov	r3, r1
 80020dc: 4613         	mov	r3, r2
 80020de: 61fb         	str	r3, [r7, #0x1c]
; 		if (kf->User_Func3_f != NULL) {
 80020e0: 697b         	ldr	r3, [r7, #0x14]
 80020e2: f8d3 30d8    	ldr.w	r3, [r3, #0xd8]
 80020e6: 2b00         	cmp	r3, #0x0
 80020e8: d004         	beq	0x80020f4 <Kalman_Filter_Update+0xd8> @ imm = #0x8
; 			kf->User_Func3_f(kf);
 80020ea: 697b         	ldr	r3, [r7, #0x14]
 80020ec: f8d3 30d8    	ldr.w	r3, [r3, #0xd8]
 80020f0: 6978         	ldr	r0, [r7, #0x14]
 80020f2: 4798         	blx	r3
; 		int end_us = k_cyc_to_us_near32(k_cycle_get_32());
 80020f4: f013 fa24    	bl	0x8015540 <k_cycle_get_32> @ imm = #0x13448
 80020f8: 4603         	mov	r3, r0
 80020fa: f113 0f55    	cmn.w	r3, #0x55
 80020fe: d809         	bhi	0x8002114 <Kalman_Filter_Update+0xf8> @ imm = #0x12
 8002100: f013 fa1e    	bl	0x8015540 <k_cycle_get_32> @ imm = #0x1343c
 8002104: 4603         	mov	r3, r0
 8002106: 3354         	adds	r3, #0x54
 8002108: 08db         	lsrs	r3, r3, #0x3
 800210a: 4a63         	ldr	r2, [pc, #0x18c]        @ 0x8002298 <Kalman_Filter_Update+0x27c>
 800210c: fba2 2303    	umull	r2, r3, r2, r3
 8002110: 085b         	lsrs	r3, r3, #0x1
 8002112: e014         	b	0x800213e <Kalman_Filter_Update+0x122> @ imm = #0x28
 8002114: f013 fa14    	bl	0x8015540 <k_cycle_get_32> @ imm = #0x13428
 8002118: 4603         	mov	r3, r0
 800211a: 2200         	movs	r2, #0x0
 800211c: 461c         	mov	r4, r3
 800211e: 4615         	mov	r5, r2
 8002120: f114 0a54    	adds.w	r10, r4, #0x54
 8002124: f145 0b00    	adc	r11, r5, #0x0
 8002128: f04f 02a8    	mov.w	r2, #0xa8
 800212c: f04f 0300    	mov.w	r3, #0x0
 8002130: 4650         	mov	r0, r10
 8002132: 4659         	mov	r1, r11
 8002134: f7fe fc96    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x16d4
 8002138: 4602         	mov	r2, r0
 800213a: 460b         	mov	r3, r1
 800213c: 4613         	mov	r3, r2
 800213e: 61bb         	str	r3, [r7, #0x18]
; 		QEKF_INS->UpdateTime = end_us - start_us;
 8002140: 69ba         	ldr	r2, [r7, #0x18]
 8002142: 69fb         	ldr	r3, [r7, #0x1c]
 8002144: 1ad3         	subs	r3, r2, r3
 8002146: 17da         	asrs	r2, r3, #0x1f
 8002148: 603b         	str	r3, [r7]
 800214a: 607a         	str	r2, [r7, #0x4]
 800214c: 6a3b         	ldr	r3, [r7, #0x20]
 800214e: e9d7 1200    	ldrd	r1, r2, [r7]
 8002152: e9c3 1278    	strd	r1, r2, [r3, #480]
; 		Kalman_Filter_xhatUpdate(kf);
 8002156: 6978         	ldr	r0, [r7, #0x14]
 8002158: f013 fc2e    	bl	0x80159b8 <Kalman_Filter_xhatUpdate> @ imm = #0x1385c
; 		if (kf->User_Func4_f != NULL) {
 800215c: 697b         	ldr	r3, [r7, #0x14]
 800215e: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 8002162: 2b00         	cmp	r3, #0x0
 8002164: d004         	beq	0x8002170 <Kalman_Filter_Update+0x154> @ imm = #0x8
; 			kf->User_Func4_f(kf);
 8002166: 697b         	ldr	r3, [r7, #0x14]
 8002168: f8d3 30dc    	ldr.w	r3, [r3, #0xdc]
 800216c: 6978         	ldr	r0, [r7, #0x14]
 800216e: 4798         	blx	r3
; 		Kalman_Filter_P_Update(kf);
 8002170: 6978         	ldr	r0, [r7, #0x14]
 8002172: f013 fc8c    	bl	0x8015a8e <Kalman_Filter_P_Update> @ imm = #0x13918
; 	if (kf->MeasurementValidNum != 0 || kf->UseAutoAdjustment == 0) {
 8002176: e023         	b	0x80021c0 <Kalman_Filter_Update+0x1a4> @ imm = #0x46
; 		memcpy(kf->xhat_data, kf->xhatminus_data, sizeof_float * kf->xhatSize);
 8002178: 697b         	ldr	r3, [r7, #0x14]
 800217a: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 800217e: 697b         	ldr	r3, [r7, #0x14]
 8002180: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 8002184: 4b45         	ldr	r3, [pc, #0x114]        @ 0x800229c <Kalman_Filter_Update+0x280>
 8002186: 881b         	ldrh	r3, [r3]
 8002188: 461a         	mov	r2, r3
 800218a: 697b         	ldr	r3, [r7, #0x14]
 800218c: 7b1b         	ldrb	r3, [r3, #0xc]
 800218e: fb02 f303    	mul	r3, r2, r3
 8002192: 461a         	mov	r2, r3
 8002194: f01d fd92    	bl	0x801fcbc <memcpy>      @ imm = #0x1db24
; 		memcpy(kf->P_data, kf->Pminus_data, sizeof_float * kf->xhatSize * kf->xhatSize);
 8002198: 697b         	ldr	r3, [r7, #0x14]
 800219a: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 800219e: 697b         	ldr	r3, [r7, #0x14]
 80021a0: f8d3 10fc    	ldr.w	r1, [r3, #0xfc]
 80021a4: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x800229c <Kalman_Filter_Update+0x280>
 80021a6: 881b         	ldrh	r3, [r3]
 80021a8: 461a         	mov	r2, r3
 80021aa: 697b         	ldr	r3, [r7, #0x14]
 80021ac: 7b1b         	ldrb	r3, [r3, #0xc]
 80021ae: fb02 f303    	mul	r3, r2, r3
 80021b2: 697a         	ldr	r2, [r7, #0x14]
 80021b4: 7b12         	ldrb	r2, [r2, #0xc]
 80021b6: fb02 f303    	mul	r3, r2, r3
 80021ba: 461a         	mov	r2, r3
 80021bc: f01d fd7e    	bl	0x801fcbc <memcpy>      @ imm = #0x1dafc
; 	if (kf->User_Func5_f != NULL) {
 80021c0: 697b         	ldr	r3, [r7, #0x14]
 80021c2: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 80021c6: 2b00         	cmp	r3, #0x0
 80021c8: d004         	beq	0x80021d4 <Kalman_Filter_Update+0x1b8> @ imm = #0x8
; 		kf->User_Func5_f(kf);
 80021ca: 697b         	ldr	r3, [r7, #0x14]
 80021cc: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 80021d0: 6978         	ldr	r0, [r7, #0x14]
 80021d2: 4798         	blx	r3
; 	for (uint8_t i = 0; i < kf->xhatSize; ++i) {
 80021d4: 2300         	movs	r3, #0x0
 80021d6: f887 3027    	strb.w	r3, [r7, #0x27]
 80021da: e037         	b	0x800224c <Kalman_Filter_Update+0x230> @ imm = #0x6e
; 		if (kf->P_data[i * kf->xhatSize + i] < kf->StateMinVariance[i]) {
 80021dc: 697b         	ldr	r3, [r7, #0x14]
 80021de: f8d3 20f8    	ldr.w	r2, [r3, #0xf8]
 80021e2: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80021e6: 6979         	ldr	r1, [r7, #0x14]
 80021e8: 7b09         	ldrb	r1, [r1, #0xc]
 80021ea: fb03 f101    	mul	r1, r3, r1
 80021ee: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80021f2: 440b         	add	r3, r1
 80021f4: 009b         	lsls	r3, r3, #0x2
 80021f6: 4413         	add	r3, r2
 80021f8: ed93 7a00    	vldr	s14, [r3]
 80021fc: 697b         	ldr	r3, [r7, #0x14]
 80021fe: 6a1a         	ldr	r2, [r3, #0x20]
 8002200: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8002204: 009b         	lsls	r3, r3, #0x2
 8002206: 4413         	add	r3, r2
 8002208: edd3 7a00    	vldr	s15, [r3]
 800220c: eeb4 7ae7    	vcmpe.f32	s14, s15
 8002210: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002214: d515         	bpl	0x8002242 <Kalman_Filter_Update+0x226> @ imm = #0x2a
; 			kf->P_data[i * kf->xhatSize + i] = kf->StateMinVariance[i];
 8002216: 697b         	ldr	r3, [r7, #0x14]
 8002218: 6a1a         	ldr	r2, [r3, #0x20]
 800221a: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800221e: 009b         	lsls	r3, r3, #0x2
 8002220: 441a         	add	r2, r3
 8002222: 697b         	ldr	r3, [r7, #0x14]
 8002224: f8d3 10f8    	ldr.w	r1, [r3, #0xf8]
 8002228: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800222c: 6978         	ldr	r0, [r7, #0x14]
 800222e: 7b00         	ldrb	r0, [r0, #0xc]
 8002230: fb03 f000    	mul	r0, r3, r0
 8002234: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8002238: 4403         	add	r3, r0
 800223a: 009b         	lsls	r3, r3, #0x2
 800223c: 440b         	add	r3, r1
 800223e: 6812         	ldr	r2, [r2]
 8002240: 601a         	str	r2, [r3]
; 	for (uint8_t i = 0; i < kf->xhatSize; ++i) {
 8002242: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8002246: 3301         	adds	r3, #0x1
 8002248: f887 3027    	strb.w	r3, [r7, #0x27]
 800224c: 697b         	ldr	r3, [r7, #0x14]
 800224e: 7b1b         	ldrb	r3, [r3, #0xc]
 8002250: f897 2027    	ldrb.w	r2, [r7, #0x27]
 8002254: 429a         	cmp	r2, r3
 8002256: d3c1         	blo	0x80021dc <Kalman_Filter_Update+0x1c0> @ imm = #-0x7e
; 	memcpy(kf->FilteredValue, kf->xhat_data, sizeof_float * kf->xhatSize);
 8002258: 697b         	ldr	r3, [r7, #0x14]
 800225a: 6818         	ldr	r0, [r3]
 800225c: 697b         	ldr	r3, [r7, #0x14]
 800225e: f8d3 10e8    	ldr.w	r1, [r3, #0xe8]
 8002262: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800229c <Kalman_Filter_Update+0x280>
 8002264: 881b         	ldrh	r3, [r3]
 8002266: 461a         	mov	r2, r3
 8002268: 697b         	ldr	r3, [r7, #0x14]
 800226a: 7b1b         	ldrb	r3, [r3, #0xc]
 800226c: fb02 f303    	mul	r3, r2, r3
 8002270: 461a         	mov	r2, r3
 8002272: f01d fd23    	bl	0x801fcbc <memcpy>      @ imm = #0x1da46
; 	if (kf->User_Func6_f != NULL) {
 8002276: 697b         	ldr	r3, [r7, #0x14]
 8002278: f8d3 30e4    	ldr.w	r3, [r3, #0xe4]
 800227c: 2b00         	cmp	r3, #0x0
 800227e: d004         	beq	0x800228a <Kalman_Filter_Update+0x26e> @ imm = #0x8
; 		kf->User_Func6_f(kf);
 8002280: 697b         	ldr	r3, [r7, #0x14]
 8002282: f8d3 30e4    	ldr.w	r3, [r3, #0xe4]
 8002286: 6978         	ldr	r0, [r7, #0x14]
 8002288: 4798         	blx	r3
; 	return kf->FilteredValue;
 800228a: 697b         	ldr	r3, [r7, #0x14]
 800228c: 681b         	ldr	r3, [r3]
; }
 800228e: 4618         	mov	r0, r3
 8002290: 3728         	adds	r7, #0x28
 8002292: 46bd         	mov	sp, r7
 8002294: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08002298 <$d>:
 8002298: 19 86 61 18  	.word	0x18618619
 800229c: f4 27 00 20  	.word	0x200027f4

080022a0 <H_K_R_Adjustment>:
; {
 80022a0: b590         	push	{r4, r7, lr}
 80022a2: b085         	sub	sp, #0x14
 80022a4: af00         	add	r7, sp, #0x0
 80022a6: 6078         	str	r0, [r7, #0x4]
; 	kf->MeasurementValidNum = 0;
 80022a8: 687b         	ldr	r3, [r7, #0x4]
 80022aa: 2200         	movs	r2, #0x0
 80022ac: 741a         	strb	r2, [r3, #0x10]
; 	memcpy(kf->z_data, kf->MeasuredVector, sizeof_float * kf->zSize);
 80022ae: 687b         	ldr	r3, [r7, #0x4]
 80022b0: f8d3 00f4    	ldr.w	r0, [r3, #0xf4]
 80022b4: 687b         	ldr	r3, [r7, #0x4]
 80022b6: 6859         	ldr	r1, [r3, #0x4]
 80022b8: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8002488 <H_K_R_Adjustment+0x1e8>
 80022ba: 881b         	ldrh	r3, [r3]
 80022bc: 461a         	mov	r2, r3
 80022be: 687b         	ldr	r3, [r7, #0x4]
 80022c0: 7b9b         	ldrb	r3, [r3, #0xe]
 80022c2: fb02 f303    	mul	r3, r2, r3
 80022c6: 461a         	mov	r2, r3
 80022c8: f01d fcf8    	bl	0x801fcbc <memcpy>      @ imm = #0x1d9f0
; 	memset(kf->MeasuredVector, 0, sizeof_float * kf->zSize);
 80022cc: 687b         	ldr	r3, [r7, #0x4]
 80022ce: 6858         	ldr	r0, [r3, #0x4]
 80022d0: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x8002488 <H_K_R_Adjustment+0x1e8>
 80022d2: 881b         	ldrh	r3, [r3]
 80022d4: 461a         	mov	r2, r3
 80022d6: 687b         	ldr	r3, [r7, #0x4]
 80022d8: 7b9b         	ldrb	r3, [r3, #0xe]
 80022da: fb02 f303    	mul	r3, r2, r3
 80022de: 461a         	mov	r2, r3
 80022e0: 2100         	movs	r1, #0x0
 80022e2: f01d fcf9    	bl	0x801fcd8 <memset>      @ imm = #0x1d9f2
; 	memset(kf->R_data, 0, sizeof_float * kf->zSize * kf->zSize);
 80022e6: 687b         	ldr	r3, [r7, #0x4]
 80022e8: f8d3 0118    	ldr.w	r0, [r3, #0x118]
 80022ec: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8002488 <H_K_R_Adjustment+0x1e8>
 80022ee: 881b         	ldrh	r3, [r3]
 80022f0: 461a         	mov	r2, r3
 80022f2: 687b         	ldr	r3, [r7, #0x4]
 80022f4: 7b9b         	ldrb	r3, [r3, #0xe]
 80022f6: fb02 f303    	mul	r3, r2, r3
 80022fa: 687a         	ldr	r2, [r7, #0x4]
 80022fc: 7b92         	ldrb	r2, [r2, #0xe]
 80022fe: fb02 f303    	mul	r3, r2, r3
 8002302: 461a         	mov	r2, r3
 8002304: 2100         	movs	r1, #0x0
 8002306: f01d fce7    	bl	0x801fcd8 <memset>      @ imm = #0x1d9ce
; 	memset(kf->H_data, 0, sizeof_float * kf->xhatSize * kf->zSize);
 800230a: 687b         	ldr	r3, [r7, #0x4]
 800230c: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 8002310: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8002488 <H_K_R_Adjustment+0x1e8>
 8002312: 881b         	ldrh	r3, [r3]
 8002314: 461a         	mov	r2, r3
 8002316: 687b         	ldr	r3, [r7, #0x4]
 8002318: 7b1b         	ldrb	r3, [r3, #0xc]
 800231a: fb02 f303    	mul	r3, r2, r3
 800231e: 687a         	ldr	r2, [r7, #0x4]
 8002320: 7b92         	ldrb	r2, [r2, #0xe]
 8002322: fb02 f303    	mul	r3, r2, r3
 8002326: 461a         	mov	r2, r3
 8002328: 2100         	movs	r1, #0x0
 800232a: f01d fcd5    	bl	0x801fcd8 <memset>      @ imm = #0x1d9aa
; 	for (uint8_t i = 0; i < kf->zSize; ++i) {
 800232e: 2300         	movs	r3, #0x0
 8002330: 73fb         	strb	r3, [r7, #0xf]
 8002332: e047         	b	0x80023c4 <H_K_R_Adjustment+0x124> @ imm = #0x8e
; 		if (kf->z_data[i] != 0) {
 8002334: 687b         	ldr	r3, [r7, #0x4]
 8002336: f8d3 20f4    	ldr.w	r2, [r3, #0xf4]
 800233a: 7bfb         	ldrb	r3, [r7, #0xf]
 800233c: 009b         	lsls	r3, r3, #0x2
 800233e: 4413         	add	r3, r2
 8002340: edd3 7a00    	vldr	s15, [r3]
 8002344: eef5 7a40    	vcmp.f32	s15, #0
 8002348: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800234c: d037         	beq	0x80023be <H_K_R_Adjustment+0x11e> @ imm = #0x6e
; 			kf->z_data[kf->MeasurementValidNum] = kf->z_data[i];
 800234e: 687b         	ldr	r3, [r7, #0x4]
 8002350: f8d3 20f4    	ldr.w	r2, [r3, #0xf4]
 8002354: 7bfb         	ldrb	r3, [r7, #0xf]
 8002356: 009b         	lsls	r3, r3, #0x2
 8002358: 441a         	add	r2, r3
 800235a: 687b         	ldr	r3, [r7, #0x4]
 800235c: f8d3 10f4    	ldr.w	r1, [r3, #0xf4]
 8002360: 687b         	ldr	r3, [r7, #0x4]
 8002362: 7c1b         	ldrb	r3, [r3, #0x10]
 8002364: 009b         	lsls	r3, r3, #0x2
 8002366: 440b         	add	r3, r1
 8002368: 6812         	ldr	r2, [r2]
 800236a: 601a         	str	r2, [r3]
; 			kf->temp[kf->MeasurementValidNum] = i;
 800236c: 687b         	ldr	r3, [r7, #0x4]
 800236e: 6a5b         	ldr	r3, [r3, #0x24]
 8002370: 687a         	ldr	r2, [r7, #0x4]
 8002372: 7c12         	ldrb	r2, [r2, #0x10]
 8002374: 4413         	add	r3, r2
 8002376: 7bfa         	ldrb	r2, [r7, #0xf]
 8002378: 701a         	strb	r2, [r3]
; 				   1] = kf->MeasurementDegree[i];
 800237a: 687b         	ldr	r3, [r7, #0x4]
 800237c: 699a         	ldr	r2, [r3, #0x18]
 800237e: 7bfb         	ldrb	r3, [r7, #0xf]
 8002380: 009b         	lsls	r3, r3, #0x2
 8002382: 441a         	add	r2, r3
; 			kf->H_data[kf->xhatSize * kf->MeasurementValidNum + kf->MeasurementMap[i] -
 8002384: 687b         	ldr	r3, [r7, #0x4]
 8002386: f8d3 110c    	ldr.w	r1, [r3, #0x10c]
 800238a: 687b         	ldr	r3, [r7, #0x4]
 800238c: 7b1b         	ldrb	r3, [r3, #0xc]
 800238e: 4618         	mov	r0, r3
 8002390: 687b         	ldr	r3, [r7, #0x4]
 8002392: 7c1b         	ldrb	r3, [r3, #0x10]
 8002394: fb00 f303    	mul	r3, r0, r3
 8002398: 6878         	ldr	r0, [r7, #0x4]
 800239a: 6944         	ldr	r4, [r0, #0x14]
 800239c: 7bf8         	ldrb	r0, [r7, #0xf]
 800239e: 4420         	add	r0, r4
 80023a0: 7800         	ldrb	r0, [r0]
 80023a2: 4403         	add	r3, r0
 80023a4: f103 4380    	add.w	r3, r3, #0x40000000
 80023a8: 3b01         	subs	r3, #0x1
 80023aa: 009b         	lsls	r3, r3, #0x2
 80023ac: 440b         	add	r3, r1
; 				   1] = kf->MeasurementDegree[i];
 80023ae: 6812         	ldr	r2, [r2]
 80023b0: 601a         	str	r2, [r3]
; 			kf->MeasurementValidNum++;
 80023b2: 687b         	ldr	r3, [r7, #0x4]
 80023b4: 7c1b         	ldrb	r3, [r3, #0x10]
 80023b6: 3301         	adds	r3, #0x1
 80023b8: b2da         	uxtb	r2, r3
 80023ba: 687b         	ldr	r3, [r7, #0x4]
 80023bc: 741a         	strb	r2, [r3, #0x10]
; 	for (uint8_t i = 0; i < kf->zSize; ++i) {
 80023be: 7bfb         	ldrb	r3, [r7, #0xf]
 80023c0: 3301         	adds	r3, #0x1
 80023c2: 73fb         	strb	r3, [r7, #0xf]
 80023c4: 687b         	ldr	r3, [r7, #0x4]
 80023c6: 7b9b         	ldrb	r3, [r3, #0xe]
 80023c8: 7bfa         	ldrb	r2, [r7, #0xf]
 80023ca: 429a         	cmp	r2, r3
 80023cc: d3b2         	blo	0x8002334 <H_K_R_Adjustment+0x94> @ imm = #-0x9c
; 	for (uint8_t i = 0; i < kf->MeasurementValidNum; ++i) {
 80023ce: 2300         	movs	r3, #0x0
 80023d0: 73bb         	strb	r3, [r7, #0xe]
 80023d2: e019         	b	0x8002408 <H_K_R_Adjustment+0x168> @ imm = #0x32
; 			kf->MatR_DiagonalElements[kf->temp[i]];
 80023d4: 687b         	ldr	r3, [r7, #0x4]
 80023d6: 69da         	ldr	r2, [r3, #0x1c]
 80023d8: 687b         	ldr	r3, [r7, #0x4]
 80023da: 6a59         	ldr	r1, [r3, #0x24]
 80023dc: 7bbb         	ldrb	r3, [r7, #0xe]
 80023de: 440b         	add	r3, r1
 80023e0: 781b         	ldrb	r3, [r3]
 80023e2: 009b         	lsls	r3, r3, #0x2
 80023e4: 441a         	add	r2, r3
; 		kf->R_data[i * kf->MeasurementValidNum + i] =
 80023e6: 687b         	ldr	r3, [r7, #0x4]
 80023e8: f8d3 1118    	ldr.w	r1, [r3, #0x118]
 80023ec: 7bbb         	ldrb	r3, [r7, #0xe]
 80023ee: 6878         	ldr	r0, [r7, #0x4]
 80023f0: 7c00         	ldrb	r0, [r0, #0x10]
 80023f2: fb03 f000    	mul	r0, r3, r0
 80023f6: 7bbb         	ldrb	r3, [r7, #0xe]
 80023f8: 4403         	add	r3, r0
 80023fa: 009b         	lsls	r3, r3, #0x2
 80023fc: 440b         	add	r3, r1
; 			kf->MatR_DiagonalElements[kf->temp[i]];
 80023fe: 6812         	ldr	r2, [r2]
; 		kf->R_data[i * kf->MeasurementValidNum + i] =
 8002400: 601a         	str	r2, [r3]
; 	for (uint8_t i = 0; i < kf->MeasurementValidNum; ++i) {
 8002402: 7bbb         	ldrb	r3, [r7, #0xe]
 8002404: 3301         	adds	r3, #0x1
 8002406: 73bb         	strb	r3, [r7, #0xe]
 8002408: 687b         	ldr	r3, [r7, #0x4]
 800240a: 7c1b         	ldrb	r3, [r3, #0x10]
 800240c: 7bba         	ldrb	r2, [r7, #0xe]
 800240e: 429a         	cmp	r2, r3
 8002410: d3e0         	blo	0x80023d4 <H_K_R_Adjustment+0x134> @ imm = #-0x40
; 	kf->H.numRows = kf->MeasurementValidNum;
 8002412: 687b         	ldr	r3, [r7, #0x4]
 8002414: 7c1b         	ldrb	r3, [r3, #0x10]
 8002416: 461a         	mov	r2, r3
 8002418: 687b         	ldr	r3, [r7, #0x4]
 800241a: f8a3 2078    	strh.w	r2, [r3, #0x78]
; 	kf->H.numCols = kf->xhatSize;
 800241e: 687b         	ldr	r3, [r7, #0x4]
 8002420: 7b1b         	ldrb	r3, [r3, #0xc]
 8002422: 461a         	mov	r2, r3
 8002424: 687b         	ldr	r3, [r7, #0x4]
 8002426: f8a3 207a    	strh.w	r2, [r3, #0x7a]
; 	kf->HT.numRows = kf->xhatSize;
 800242a: 687b         	ldr	r3, [r7, #0x4]
 800242c: 7b1b         	ldrb	r3, [r3, #0xc]
 800242e: 461a         	mov	r2, r3
 8002430: 687b         	ldr	r3, [r7, #0x4]
 8002432: f8a3 2080    	strh.w	r2, [r3, #0x80]
; 	kf->HT.numCols = kf->MeasurementValidNum;
 8002436: 687b         	ldr	r3, [r7, #0x4]
 8002438: 7c1b         	ldrb	r3, [r3, #0x10]
 800243a: 461a         	mov	r2, r3
 800243c: 687b         	ldr	r3, [r7, #0x4]
 800243e: f8a3 2082    	strh.w	r2, [r3, #0x82]
; 	kf->R.numRows = kf->MeasurementValidNum;
 8002442: 687b         	ldr	r3, [r7, #0x4]
 8002444: 7c1b         	ldrb	r3, [r3, #0x10]
 8002446: 461a         	mov	r2, r3
 8002448: 687b         	ldr	r3, [r7, #0x4]
 800244a: f8a3 2090    	strh.w	r2, [r3, #0x90]
; 	kf->R.numCols = kf->MeasurementValidNum;
 800244e: 687b         	ldr	r3, [r7, #0x4]
 8002450: 7c1b         	ldrb	r3, [r3, #0x10]
 8002452: 461a         	mov	r2, r3
 8002454: 687b         	ldr	r3, [r7, #0x4]
 8002456: f8a3 2092    	strh.w	r2, [r3, #0x92]
; 	kf->K.numRows = kf->xhatSize;
 800245a: 687b         	ldr	r3, [r7, #0x4]
 800245c: 7b1b         	ldrb	r3, [r3, #0xc]
 800245e: 461a         	mov	r2, r3
 8002460: 687b         	ldr	r3, [r7, #0x4]
 8002462: f8a3 2098    	strh.w	r2, [r3, #0x98]
; 	kf->K.numCols = kf->MeasurementValidNum;
 8002466: 687b         	ldr	r3, [r7, #0x4]
 8002468: 7c1b         	ldrb	r3, [r3, #0x10]
 800246a: 461a         	mov	r2, r3
 800246c: 687b         	ldr	r3, [r7, #0x4]
 800246e: f8a3 209a    	strh.w	r2, [r3, #0x9a]
; 	kf->z.numRows = kf->MeasurementValidNum;
 8002472: 687b         	ldr	r3, [r7, #0x4]
 8002474: 7c1b         	ldrb	r3, [r3, #0x10]
 8002476: 461a         	mov	r2, r3
 8002478: 687b         	ldr	r3, [r7, #0x4]
 800247a: f8a3 2048    	strh.w	r2, [r3, #0x48]
; }
 800247e: bf00         	nop
 8002480: 3714         	adds	r7, #0x14
 8002482: 46bd         	mov	sp, r7
 8002484: bd90         	pop	{r4, r7, pc}
 8002486: bf00         	nop

08002488 <$d>:
 8002488: f4 27 00 20  	.word	0x200027f4

0800248c <IMU_QuaternionEKF_Init>:
; {
 800248c: b580         	push	{r7, lr}
 800248e: b088         	sub	sp, #0x20
 8002490: af00         	add	r7, sp, #0x0
 8002492: 6178         	str	r0, [r7, #0x14]
 8002494: ed87 0a04    	vstr	s0, [r7, #16]
 8002498: edc7 0a03    	vstr	s1, [r7, #12]
 800249c: ed87 1a02    	vstr	s2, [r7, #8]
 80024a0: edc7 1a01    	vstr	s3, [r7, #4]
 80024a4: ed87 2a00    	vstr	s4, [r7]
; 	QEKF_INS.Initialized = 1;
 80024a8: 4b42         	ldr	r3, [pc, #0x108]        @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 80024aa: 2201         	movs	r2, #0x1
 80024ac: 701a         	strb	r2, [r3]
; 	QEKF_INS.Q1 = process_noise1;
 80024ae: 4a41         	ldr	r2, [pc, #0x104]        @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 80024b0: 693b         	ldr	r3, [r7, #0x10]
 80024b2: f8c2 31b0    	str.w	r3, [r2, #0x1b0]
; 	QEKF_INS.Q2 = process_noise2;
 80024b6: 4a3f         	ldr	r2, [pc, #0xfc]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 80024b8: 68fb         	ldr	r3, [r7, #0xc]
 80024ba: f8c2 31b4    	str.w	r3, [r2, #0x1b4]
; 	QEKF_INS.R = measure_noise;
 80024be: 4a3d         	ldr	r2, [pc, #0xf4]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 80024c0: 68bb         	ldr	r3, [r7, #0x8]
 80024c2: f8c2 31b8    	str.w	r3, [r2, #0x1b8]
; 	QEKF_INS.ChiSquareTestThreshold = 1e-8;
 80024c6: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 80024c8: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x80025b8 <IMU_QuaternionEKF_Init+0x12c>
 80024ca: f8c3 21cc    	str.w	r2, [r3, #0x1cc]
; 	QEKF_INS.ConvergeFlag = 0;
 80024ce: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 80024d0: 2200         	movs	r2, #0x0
 80024d2: f883 2138    	strb.w	r2, [r3, #0x138]
; 	QEKF_INS.ErrorCount = 0;
 80024d6: 4937         	ldr	r1, [pc, #0xdc]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 80024d8: f04f 0200    	mov.w	r2, #0x0
 80024dc: f04f 0300    	mov.w	r3, #0x0
 80024e0: e9c1 2350    	strd	r2, r3, [r1, #320]
; 	QEKF_INS.UpdateCount = 0;
 80024e4: 4933         	ldr	r1, [pc, #0xcc]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 80024e6: f04f 0200    	mov.w	r2, #0x0
 80024ea: f04f 0300    	mov.w	r3, #0x0
 80024ee: e9c1 2352    	strd	r2, r3, [r1, #328]
; 	if (lambda > 1) {
 80024f2: edd7 7a01    	vldr	s15, [r7, #4]
 80024f6: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 80024fa: eef4 7ac7    	vcmpe.f32	s15, s14
 80024fe: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002502: dd02         	ble	0x800250a <IMU_QuaternionEKF_Init+0x7e> @ imm = #0x4
; 		lambda = 1;
 8002504: f04f 537e    	mov.w	r3, #0x3f800000
 8002508: 607b         	str	r3, [r7, #0x4]
; 	QEKF_INS.lambda = lambda;
 800250a: 4a2a         	ldr	r2, [pc, #0xa8]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 800250c: 687b         	ldr	r3, [r7, #0x4]
 800250e: f8c2 31d0    	str.w	r3, [r2, #0x1d0]
; 	QEKF_INS.accLPFcoef = lpf;
 8002512: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 8002514: 683b         	ldr	r3, [r7]
 8002516: f8c2 3190    	str.w	r3, [r2, #0x190]
; 	Kalman_Filter_Init(&QEKF_INS.IMU_QuaternionEKF, 6, 0, 3);
 800251a: 2303         	movs	r3, #0x3
 800251c: 2200         	movs	r2, #0x0
 800251e: 2106         	movs	r1, #0x6
 8002520: 4826         	ldr	r0, [pc, #0x98]         @ 0x80025bc <IMU_QuaternionEKF_Init+0x130>
 8002522: f7ff f935    	bl	0x8001790 <Kalman_Filter_Init> @ imm = #-0xd96
; 	Matrix_Init(&QEKF_INS.ChiSquare, 1, 1, (float *)QEKF_INS.ChiSquare_Data);
 8002526: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80025c0 <IMU_QuaternionEKF_Init+0x134>
 8002528: 2201         	movs	r2, #0x1
 800252a: 2101         	movs	r1, #0x1
 800252c: 4825         	ldr	r0, [pc, #0x94]         @ 0x80025c4 <IMU_QuaternionEKF_Init+0x138>
 800252e: f00b fffd    	bl	0x800e52c <arm_mat_init_f32> @ imm = #0xbffa
; 	for (int i = 0; i < 4; i++) {
 8002532: 2300         	movs	r3, #0x0
 8002534: 61fb         	str	r3, [r7, #0x1c]
 8002536: e00e         	b	0x8002556 <IMU_QuaternionEKF_Init+0xca> @ imm = #0x1c
; 		QEKF_INS.IMU_QuaternionEKF.xhat_data[i] = init_quaternion[i];
 8002538: 69fb         	ldr	r3, [r7, #0x1c]
 800253a: 009b         	lsls	r3, r3, #0x2
 800253c: 697a         	ldr	r2, [r7, #0x14]
 800253e: 441a         	add	r2, r3
 8002540: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 8002542: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 8002546: 69fb         	ldr	r3, [r7, #0x1c]
 8002548: 009b         	lsls	r3, r3, #0x2
 800254a: 440b         	add	r3, r1
 800254c: 6812         	ldr	r2, [r2]
 800254e: 601a         	str	r2, [r3]
; 	for (int i = 0; i < 4; i++) {
 8002550: 69fb         	ldr	r3, [r7, #0x1c]
 8002552: 3301         	adds	r3, #0x1
 8002554: 61fb         	str	r3, [r7, #0x1c]
 8002556: 69fb         	ldr	r3, [r7, #0x1c]
 8002558: 2b03         	cmp	r3, #0x3
 800255a: dded         	ble	0x8002538 <IMU_QuaternionEKF_Init+0xac> @ imm = #-0x26
; 	QEKF_INS.IMU_QuaternionEKF.User_Func0_f = IMU_QuaternionEKF_Observe;
 800255c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 800255e: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x80025c8 <IMU_QuaternionEKF_Init+0x13c>
 8002560: f8c3 20d0    	str.w	r2, [r3, #0xd0]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func1_f = IMU_QuaternionEKF_F_Linearization_P_Fading;
 8002564: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 8002566: 4a19         	ldr	r2, [pc, #0x64]         @ 0x80025cc <IMU_QuaternionEKF_Init+0x140>
 8002568: f8c3 20d4    	str.w	r2, [r3, #0xd4]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func2_f = IMU_QuaternionEKF_SetH;
 800256c: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 800256e: 4a18         	ldr	r2, [pc, #0x60]         @ 0x80025d0 <IMU_QuaternionEKF_Init+0x144>
 8002570: f8c3 20d8    	str.w	r2, [r3, #0xd8]
; 	QEKF_INS.IMU_QuaternionEKF.User_Func3_f = IMU_QuaternionEKF_xhatUpdate;
 8002574: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 8002576: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x80025d4 <IMU_QuaternionEKF_Init+0x148>
 8002578: f8c3 20dc    	str.w	r2, [r3, #0xdc]
; 	QEKF_INS.IMU_QuaternionEKF.SkipEq3 = TRUE;
 800257c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 800257e: 2201         	movs	r2, #0x1
 8002580: f883 202e    	strb.w	r2, [r3, #0x2e]
; 	QEKF_INS.IMU_QuaternionEKF.SkipEq4 = TRUE;
 8002584: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 8002586: 2201         	movs	r2, #0x1
 8002588: f883 202f    	strb.w	r2, [r3, #0x2f]
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.F_data, IMU_QuaternionEKF_F, sizeof(IMU_QuaternionEKF_F));
 800258c: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 800258e: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8002592: 2290         	movs	r2, #0x90
 8002594: 4910         	ldr	r1, [pc, #0x40]         @ 0x80025d8 <IMU_QuaternionEKF_Init+0x14c>
 8002596: 4618         	mov	r0, r3
 8002598: f01d fb90    	bl	0x801fcbc <memcpy>      @ imm = #0x1d720
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.P_data, IMU_QuaternionEKF_P, sizeof(IMU_QuaternionEKF_P));
 800259c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80025b4 <IMU_QuaternionEKF_Init+0x128>
 800259e: f8d3 30fc    	ldr.w	r3, [r3, #0xfc]
 80025a2: 2290         	movs	r2, #0x90
 80025a4: 490d         	ldr	r1, [pc, #0x34]         @ 0x80025dc <IMU_QuaternionEKF_Init+0x150>
 80025a6: 4618         	mov	r0, r3
 80025a8: f01d fb88    	bl	0x801fcbc <memcpy>      @ imm = #0x1d710
; }
 80025ac: bf00         	nop
 80025ae: 3720         	adds	r7, #0x20
 80025b0: 46bd         	mov	sp, r7
 80025b2: bd80         	pop	{r7, pc}

080025b4 <$d>:
 80025b4: a0 07 00 20  	.word	0x200007a0
 80025b8: 77 cc 2b 32  	.word	0x322bcc77
 80025bc: a4 07 00 20  	.word	0x200007a4
 80025c0: 68 09 00 20  	.word	0x20000968
 80025c4: 60 09 00 20  	.word	0x20000960
 80025c8: e9 37 00 08  	.word	0x080037e9
 80025cc: 21 2d 00 08  	.word	0x08002d21
 80025d0: dd 2f 00 08  	.word	0x08002fdd
 80025d4: 41 31 00 08  	.word	0x08003141
 80025d8: 54 25 02 08  	.word	0x08022554
 80025dc: 08 04 00 20  	.word	0x20000408

080025e0 <IMU_QuaternionEKF_Update>:
; {
 80025e0: b5b0         	push	{r4, r5, r7, lr}
 80025e2: b08a         	sub	sp, #0x28
 80025e4: af00         	add	r7, sp, #0x0
 80025e6: ed87 0a07    	vstr	s0, [r7, #28]
 80025ea: edc7 0a06    	vstr	s1, [r7, #24]
 80025ee: ed87 1a05    	vstr	s2, [r7, #20]
 80025f2: edc7 1a04    	vstr	s3, [r7, #16]
 80025f6: ed87 2a03    	vstr	s4, [r7, #12]
 80025fa: edc7 2a02    	vstr	s5, [r7, #8]
 80025fe: ed87 3a01    	vstr	s6, [r7, #4]
 8002602: edc7 3a00    	vstr	s7, [r7]
; 	QEKF_INS.dt = gyro_dt;
 8002606: 4ab5         	ldr	r2, [pc, #0x2d4]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002608: 683b         	ldr	r3, [r7]
 800260a: f8c2 31bc    	str.w	r3, [r2, #0x1bc]
; 	QEKF_INS.Gyro[0] = gx - QEKF_INS.GyroBias[0];
 800260e: 4bb3         	ldr	r3, [pc, #0x2cc]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002610: edd3 7a58    	vldr	s15, [r3, #352]
 8002614: ed97 7a07    	vldr	s14, [r7, #28]
 8002618: ee77 7a67    	vsub.f32	s15, s14, s15
 800261c: 4baf         	ldr	r3, [pc, #0x2bc]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 800261e: edc3 7a5b    	vstr	s15, [r3, #364]
; 	QEKF_INS.Gyro[1] = gy - QEKF_INS.GyroBias[1];
 8002622: 4bae         	ldr	r3, [pc, #0x2b8]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002624: edd3 7a59    	vldr	s15, [r3, #356]
 8002628: ed97 7a06    	vldr	s14, [r7, #24]
 800262c: ee77 7a67    	vsub.f32	s15, s14, s15
 8002630: 4baa         	ldr	r3, [pc, #0x2a8]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002632: edc3 7a5c    	vstr	s15, [r3, #368]
; 	QEKF_INS.Gyro[2] = gz - QEKF_INS.GyroBias[2];
 8002636: 4ba9         	ldr	r3, [pc, #0x2a4]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002638: edd3 7a5a    	vldr	s15, [r3, #360]
 800263c: ed97 7a05    	vldr	s14, [r7, #20]
 8002640: ee77 7a67    	vsub.f32	s15, s14, s15
 8002644: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002646: edc3 7a5d    	vstr	s15, [r3, #372]
; 	halfgxdt = 0.5f * QEKF_INS.Gyro[0] * gyro_dt;
 800264a: 4ba4         	ldr	r3, [pc, #0x290]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 800264c: edd3 7a5b    	vldr	s15, [r3, #364]
 8002650: eeb6 7a00    	vmov.f32	s14, #5.000000e-01
 8002654: ee27 7a87    	vmul.f32	s14, s15, s14
 8002658: edd7 7a00    	vldr	s15, [r7]
 800265c: ee67 7a27    	vmul.f32	s15, s14, s15
 8002660: 4b9f         	ldr	r3, [pc, #0x27c]        @ 0x80028e0 <IMU_QuaternionEKF_Update+0x300>
 8002662: edc3 7a00    	vstr	s15, [r3]
; 	halfgydt = 0.5f * QEKF_INS.Gyro[1] * gyro_dt;
 8002666: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002668: edd3 7a5c    	vldr	s15, [r3, #368]
 800266c: eeb6 7a00    	vmov.f32	s14, #5.000000e-01
 8002670: ee27 7a87    	vmul.f32	s14, s15, s14
 8002674: edd7 7a00    	vldr	s15, [r7]
 8002678: ee67 7a27    	vmul.f32	s15, s14, s15
 800267c: 4b99         	ldr	r3, [pc, #0x264]        @ 0x80028e4 <IMU_QuaternionEKF_Update+0x304>
 800267e: edc3 7a00    	vstr	s15, [r3]
; 	halfgzdt = 0.5f * QEKF_INS.Gyro[2] * gyro_dt;
 8002682: 4b96         	ldr	r3, [pc, #0x258]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002684: edd3 7a5d    	vldr	s15, [r3, #372]
 8002688: eeb6 7a00    	vmov.f32	s14, #5.000000e-01
 800268c: ee27 7a87    	vmul.f32	s14, s15, s14
 8002690: edd7 7a00    	vldr	s15, [r7]
 8002694: ee67 7a27    	vmul.f32	s15, s14, s15
 8002698: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x80028e8 <IMU_QuaternionEKF_Update+0x308>
 800269a: edc3 7a00    	vstr	s15, [r3]
; 	memcpy(QEKF_INS.IMU_QuaternionEKF.F_data, IMU_QuaternionEKF_F, sizeof(IMU_QuaternionEKF_F));
 800269e: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80026a0: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 80026a4: 2290         	movs	r2, #0x90
 80026a6: 4991         	ldr	r1, [pc, #0x244]        @ 0x80028ec <IMU_QuaternionEKF_Update+0x30c>
 80026a8: 4618         	mov	r0, r3
 80026aa: f01d fb07    	bl	0x801fcbc <memcpy>      @ imm = #0x1d60e
; 	QEKF_INS.IMU_QuaternionEKF.F_data[1] = -halfgxdt;
 80026ae: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x80028e0 <IMU_QuaternionEKF_Update+0x300>
 80026b0: edd3 7a00    	vldr	s15, [r3]
 80026b4: 4b89         	ldr	r3, [pc, #0x224]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80026b6: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 80026ba: 3304         	adds	r3, #0x4
 80026bc: eef1 7a67    	vneg.f32	s15, s15
 80026c0: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[2] = -halfgydt;
 80026c4: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x80028e4 <IMU_QuaternionEKF_Update+0x304>
 80026c6: edd3 7a00    	vldr	s15, [r3]
 80026ca: 4b84         	ldr	r3, [pc, #0x210]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80026cc: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 80026d0: 3308         	adds	r3, #0x8
 80026d2: eef1 7a67    	vneg.f32	s15, s15
 80026d6: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[3] = -halfgzdt;
 80026da: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x80028e8 <IMU_QuaternionEKF_Update+0x308>
 80026dc: edd3 7a00    	vldr	s15, [r3]
 80026e0: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80026e2: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 80026e6: 330c         	adds	r3, #0xc
 80026e8: eef1 7a67    	vneg.f32	s15, s15
 80026ec: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[6] = halfgxdt;
 80026f0: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80026f2: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 80026f6: 3318         	adds	r3, #0x18
 80026f8: 4a79         	ldr	r2, [pc, #0x1e4]        @ 0x80028e0 <IMU_QuaternionEKF_Update+0x300>
 80026fa: 6812         	ldr	r2, [r2]
 80026fc: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[8] = halfgzdt;
 80026fe: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002700: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8002704: 3320         	adds	r3, #0x20
 8002706: 4a78         	ldr	r2, [pc, #0x1e0]        @ 0x80028e8 <IMU_QuaternionEKF_Update+0x308>
 8002708: 6812         	ldr	r2, [r2]
 800270a: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[9] = -halfgydt;
 800270c: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x80028e4 <IMU_QuaternionEKF_Update+0x304>
 800270e: edd3 7a00    	vldr	s15, [r3]
 8002712: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002714: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8002718: 3324         	adds	r3, #0x24
 800271a: eef1 7a67    	vneg.f32	s15, s15
 800271e: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[12] = halfgydt;
 8002722: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002724: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8002728: 3330         	adds	r3, #0x30
 800272a: 4a6e         	ldr	r2, [pc, #0x1b8]        @ 0x80028e4 <IMU_QuaternionEKF_Update+0x304>
 800272c: 6812         	ldr	r2, [r2]
 800272e: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[13] = -halfgzdt;
 8002730: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x80028e8 <IMU_QuaternionEKF_Update+0x308>
 8002732: edd3 7a00    	vldr	s15, [r3]
 8002736: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002738: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 800273c: 3334         	adds	r3, #0x34
 800273e: eef1 7a67    	vneg.f32	s15, s15
 8002742: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[15] = halfgxdt;
 8002746: 4b65         	ldr	r3, [pc, #0x194]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002748: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 800274c: 333c         	adds	r3, #0x3c
 800274e: 4a64         	ldr	r2, [pc, #0x190]        @ 0x80028e0 <IMU_QuaternionEKF_Update+0x300>
 8002750: 6812         	ldr	r2, [r2]
 8002752: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[18] = halfgzdt;
 8002754: 4b61         	ldr	r3, [pc, #0x184]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002756: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 800275a: 3348         	adds	r3, #0x48
 800275c: 4a62         	ldr	r2, [pc, #0x188]        @ 0x80028e8 <IMU_QuaternionEKF_Update+0x308>
 800275e: 6812         	ldr	r2, [r2]
 8002760: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[19] = halfgydt;
 8002762: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002764: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 8002768: 334c         	adds	r3, #0x4c
 800276a: 4a5e         	ldr	r2, [pc, #0x178]        @ 0x80028e4 <IMU_QuaternionEKF_Update+0x304>
 800276c: 6812         	ldr	r2, [r2]
 800276e: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.F_data[20] = -halfgxdt;
 8002770: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x80028e0 <IMU_QuaternionEKF_Update+0x300>
 8002772: edd3 7a00    	vldr	s15, [r3]
 8002776: 4b59         	ldr	r3, [pc, #0x164]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002778: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 800277c: 3350         	adds	r3, #0x50
 800277e: eef1 7a67    	vneg.f32	s15, s15
 8002782: edc3 7a00    	vstr	s15, [r3]
; 	if (QEKF_INS.UpdateCount == 0) // 如果是第一次进入,需要初始化低通滤波
 8002786: 4b55         	ldr	r3, [pc, #0x154]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002788: e9d3 2352    	ldrd	r2, r3, [r3, #328]
 800278c: 4313         	orrs	r3, r2
 800278e: d10b         	bne	0x80027a8 <IMU_QuaternionEKF_Update+0x1c8> @ imm = #0x16
; 		QEKF_INS.Accel[0] = ax;
 8002790: 4a52         	ldr	r2, [pc, #0x148]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002792: 693b         	ldr	r3, [r7, #0x10]
 8002794: f8c2 3178    	str.w	r3, [r2, #0x178]
; 		QEKF_INS.Accel[1] = ay;
 8002798: 4a50         	ldr	r2, [pc, #0x140]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 800279a: 68fb         	ldr	r3, [r7, #0xc]
 800279c: f8c2 317c    	str.w	r3, [r2, #0x17c]
; 		QEKF_INS.Accel[2] = az;
 80027a0: 4a4e         	ldr	r2, [pc, #0x138]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80027a2: 68bb         	ldr	r3, [r7, #0x8]
 80027a4: f8c2 3180    	str.w	r3, [r2, #0x180]
; 		QEKF_INS.Accel[0] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 80027a8: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80027aa: ed93 7a5e    	vldr	s14, [r3, #376]
 80027ae: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80027b0: edd3 7a64    	vldr	s15, [r3, #400]
 80027b4: ee67 6a27    	vmul.f32	s13, s14, s15
 80027b8: 4b48         	ldr	r3, [pc, #0x120]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80027ba: ed93 7a64    	vldr	s14, [r3, #400]
 80027be: edd7 7a01    	vldr	s15, [r7, #4]
 80027c2: ee77 7a27    	vadd.f32	s15, s14, s15
 80027c6: ee86 7aa7    	vdiv.f32	s14, s13, s15
; 		ax * accel_dt / (accel_dt + QEKF_INS.accLPFcoef);
 80027ca: edd7 6a04    	vldr	s13, [r7, #16]
 80027ce: edd7 7a01    	vldr	s15, [r7, #4]
 80027d2: ee26 6aa7    	vmul.f32	s12, s13, s15
 80027d6: 4b41         	ldr	r3, [pc, #0x104]        @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80027d8: edd3 6a64    	vldr	s13, [r3, #400]
 80027dc: edd7 7a01    	vldr	s15, [r7, #4]
 80027e0: ee76 6aa7    	vadd.f32	s13, s13, s15
 80027e4: eec6 7a26    	vdiv.f32	s15, s12, s13
; 		QEKF_INS.Accel[0] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 80027e8: ee77 7a27    	vadd.f32	s15, s14, s15
; 	QEKF_INS.Accel[0] =
 80027ec: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80027ee: edc3 7a5e    	vstr	s15, [r3, #376]
; 		QEKF_INS.Accel[1] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 80027f2: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80027f4: ed93 7a5f    	vldr	s14, [r3, #380]
 80027f8: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80027fa: edd3 7a64    	vldr	s15, [r3, #400]
 80027fe: ee67 6a27    	vmul.f32	s13, s14, s15
 8002802: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002804: ed93 7a64    	vldr	s14, [r3, #400]
 8002808: edd7 7a01    	vldr	s15, [r7, #4]
 800280c: ee77 7a27    	vadd.f32	s15, s14, s15
 8002810: ee86 7aa7    	vdiv.f32	s14, s13, s15
; 		ay * accel_dt / (QEKF_INS.dt + QEKF_INS.accLPFcoef);
 8002814: edd7 6a03    	vldr	s13, [r7, #12]
 8002818: edd7 7a01    	vldr	s15, [r7, #4]
 800281c: ee26 6aa7    	vmul.f32	s12, s13, s15
 8002820: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002822: edd3 6a6f    	vldr	s13, [r3, #444]
 8002826: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002828: edd3 7a64    	vldr	s15, [r3, #400]
 800282c: ee76 6aa7    	vadd.f32	s13, s13, s15
 8002830: eec6 7a26    	vdiv.f32	s15, s12, s13
; 		QEKF_INS.Accel[1] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 8002834: ee77 7a27    	vadd.f32	s15, s14, s15
; 	QEKF_INS.Accel[1] =
 8002838: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 800283a: edc3 7a5f    	vstr	s15, [r3, #380]
; 		QEKF_INS.Accel[2] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 800283e: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002840: ed93 7a60    	vldr	s14, [r3, #384]
 8002844: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002846: edd3 7a64    	vldr	s15, [r3, #400]
 800284a: ee67 6a27    	vmul.f32	s13, s14, s15
 800284e: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002850: ed93 7a64    	vldr	s14, [r3, #400]
 8002854: edd7 7a01    	vldr	s15, [r7, #4]
 8002858: ee77 7a27    	vadd.f32	s15, s14, s15
 800285c: ee86 7aa7    	vdiv.f32	s14, s13, s15
; 		az * accel_dt / (accel_dt + QEKF_INS.accLPFcoef);
 8002860: edd7 6a02    	vldr	s13, [r7, #8]
 8002864: edd7 7a01    	vldr	s15, [r7, #4]
 8002868: ee26 6aa7    	vmul.f32	s12, s13, s15
 800286c: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 800286e: edd3 6a64    	vldr	s13, [r3, #400]
 8002872: edd7 7a01    	vldr	s15, [r7, #4]
 8002876: ee76 6aa7    	vadd.f32	s13, s13, s15
 800287a: eec6 7a26    	vdiv.f32	s15, s12, s13
; 		QEKF_INS.Accel[2] * QEKF_INS.accLPFcoef / (accel_dt + QEKF_INS.accLPFcoef) +
 800287e: ee77 7a27    	vadd.f32	s15, s14, s15
; 	QEKF_INS.Accel[2] =
 8002882: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002884: edc3 7a60    	vstr	s15, [r3, #384]
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 8002888: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 800288a: ed93 7a5e    	vldr	s14, [r3, #376]
 800288e: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 8002890: edd3 7a5e    	vldr	s15, [r3, #376]
 8002894: ee27 7a27    	vmul.f32	s14, s14, s15
; 			       QEKF_INS.Accel[1] * QEKF_INS.Accel[1] +
 8002898: 4b10         	ldr	r3, [pc, #0x40]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 800289a: edd3 6a5f    	vldr	s13, [r3, #380]
 800289e: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80028a0: edd3 7a5f    	vldr	s15, [r3, #380]
 80028a4: ee66 7aa7    	vmul.f32	s15, s13, s15
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 80028a8: ee37 7a27    	vadd.f32	s14, s14, s15
; 			       QEKF_INS.Accel[2] * QEKF_INS.Accel[2]);
 80028ac: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80028ae: edd3 6a60    	vldr	s13, [r3, #384]
 80028b2: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80028dc <IMU_QuaternionEKF_Update+0x2fc>
 80028b4: edd3 7a60    	vldr	s15, [r3, #384]
 80028b8: ee66 7aa7    	vmul.f32	s15, s13, s15
; 	accelInvNorm = invSqrt(QEKF_INS.Accel[0] * QEKF_INS.Accel[0] +
 80028bc: ee77 7a27    	vadd.f32	s15, s14, s15
 80028c0: eeb0 0a67    	vmov.f32	s0, s15
 80028c4: f000 ffb6    	bl	0x8003834 <invSqrt>     @ imm = #0xf6c
 80028c8: eef0 7a40    	vmov.f32	s15, s0
 80028cc: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80028f0 <IMU_QuaternionEKF_Update+0x310>
 80028ce: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 3; ++i) {
 80028d2: 2300         	movs	r3, #0x0
 80028d4: f887 3027    	strb.w	r3, [r7, #0x27]
 80028d8: e026         	b	0x8002928 <IMU_QuaternionEKF_Update+0x348> @ imm = #0x4c
 80028da: bf00         	nop

080028dc <$d>:
 80028dc: a0 07 00 20  	.word	0x200007a0
 80028e0: 0c 24 00 20  	.word	0x2000240c
 80028e4: 10 24 00 20  	.word	0x20002410
 80028e8: 14 24 00 20  	.word	0x20002414
 80028ec: 54 25 02 08  	.word	0x08022554
 80028f0: 18 24 00 20  	.word	0x20002418

080028f4 <$t>:
; 			QEKF_INS.Accel[i] * accelInvNorm; // 用加速度向量更新量测值
 80028f4: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80028f8: 4a38         	ldr	r2, [pc, #0xe0]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 80028fa: 335e         	adds	r3, #0x5e
 80028fc: 009b         	lsls	r3, r3, #0x2
 80028fe: 4413         	add	r3, r2
 8002900: ed93 7a00    	vldr	s14, [r3]
 8002904: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80029e0 <IMU_QuaternionEKF_Update+0x400>
 8002906: edd3 7a00    	vldr	s15, [r3]
; 		QEKF_INS.IMU_QuaternionEKF.MeasuredVector[i] =
 800290a: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 800290c: 689a         	ldr	r2, [r3, #0x8]
 800290e: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8002912: 009b         	lsls	r3, r3, #0x2
 8002914: 4413         	add	r3, r2
; 			QEKF_INS.Accel[i] * accelInvNorm; // 用加速度向量更新量测值
 8002916: ee67 7a27    	vmul.f32	s15, s14, s15
; 		QEKF_INS.IMU_QuaternionEKF.MeasuredVector[i] =
 800291a: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 3; ++i) {
 800291e: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8002922: 3301         	adds	r3, #0x1
 8002924: f887 3027    	strb.w	r3, [r7, #0x27]
 8002928: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800292c: 2b02         	cmp	r3, #0x2
 800292e: d9e1         	bls	0x80028f4 <IMU_QuaternionEKF_Update+0x314> @ imm = #-0x3e
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 8002930: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 8002932: ed93 7a5b    	vldr	s14, [r3, #364]
 8002936: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 8002938: edd3 7a5b    	vldr	s15, [r3, #364]
 800293c: ee27 7a27    	vmul.f32	s14, s14, s15
; 					    QEKF_INS.Gyro[1] * QEKF_INS.Gyro[1] +
 8002940: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 8002942: edd3 6a5c    	vldr	s13, [r3, #368]
 8002946: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 8002948: edd3 7a5c    	vldr	s15, [r3, #368]
 800294c: ee66 7aa7    	vmul.f32	s15, s13, s15
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 8002950: ee37 7a27    	vadd.f32	s14, s14, s15
; 					    QEKF_INS.Gyro[2] * QEKF_INS.Gyro[2]);
 8002954: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 8002956: edd3 6a5d    	vldr	s13, [r3, #372]
 800295a: 4b20         	ldr	r3, [pc, #0x80]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 800295c: edd3 7a5d    	vldr	s15, [r3, #372]
 8002960: ee66 7aa7    	vmul.f32	s15, s13, s15
; 	QEKF_INS.gyro_norm = 1.0f / invSqrt(QEKF_INS.Gyro[0] * QEKF_INS.Gyro[0] +
 8002964: ee77 7a27    	vadd.f32	s15, s14, s15
 8002968: eeb0 0a67    	vmov.f32	s0, s15
 800296c: f000 ff62    	bl	0x8003834 <invSqrt>     @ imm = #0xec4
 8002970: eeb0 7a40    	vmov.f32	s14, s0
 8002974: eef7 6a00    	vmov.f32	s13, #1.000000e+00
 8002978: eec6 7a87    	vdiv.f32	s15, s13, s14
 800297c: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 800297e: edc3 7a65    	vstr	s15, [r3, #404]
; 	QEKF_INS.accl_norm = 1.0f / accelInvNorm;
 8002982: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80029e0 <IMU_QuaternionEKF_Update+0x400>
 8002984: ed93 7a00    	vldr	s14, [r3]
 8002988: eef7 6a00    	vmov.f32	s13, #1.000000e+00
 800298c: eec6 7a87    	vdiv.f32	s15, s13, s14
 8002990: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 8002992: edc3 7a66    	vstr	s15, [r3, #408]
; 	if (QEKF_INS.gyro_norm < 0.3f && QEKF_INS.accl_norm > 9.8f - 0.5f &&
 8002996: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 8002998: edd3 7a65    	vldr	s15, [r3, #404]
 800299c: ed9f 7a11    	vldr	s14, [pc, #68]          @ 0x80029e4 <IMU_QuaternionEKF_Update+0x404>
 80029a0: eef4 7ac7    	vcmpe.f32	s15, s14
 80029a4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80029a8: d522         	bpl	0x80029f0 <IMU_QuaternionEKF_Update+0x410> @ imm = #0x44
 80029aa: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 80029ac: edd3 7a66    	vldr	s15, [r3, #408]
 80029b0: ed9f 7a0d    	vldr	s14, [pc, #52]          @ 0x80029e8 <IMU_QuaternionEKF_Update+0x408>
 80029b4: eef4 7ac7    	vcmpe.f32	s15, s14
 80029b8: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80029bc: dd18         	ble	0x80029f0 <IMU_QuaternionEKF_Update+0x410> @ imm = #0x30
; 	    QEKF_INS.accl_norm < 9.8f + 0.5f) {
 80029be: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 80029c0: edd3 7a66    	vldr	s15, [r3, #408]
; 	if (QEKF_INS.gyro_norm < 0.3f && QEKF_INS.accl_norm > 9.8f - 0.5f &&
 80029c4: ed9f 7a09    	vldr	s14, [pc, #36]          @ 0x80029ec <IMU_QuaternionEKF_Update+0x40c>
 80029c8: eef4 7ac7    	vcmpe.f32	s15, s14
 80029cc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80029d0: d50e         	bpl	0x80029f0 <IMU_QuaternionEKF_Update+0x410> @ imm = #0x1c
; 		QEKF_INS.StableFlag = 1;
 80029d2: 4b02         	ldr	r3, [pc, #0x8]          @ 0x80029dc <IMU_QuaternionEKF_Update+0x3fc>
 80029d4: 2201         	movs	r2, #0x1
 80029d6: f883 2139    	strb.w	r2, [r3, #0x139]
 80029da: e00d         	b	0x80029f8 <IMU_QuaternionEKF_Update+0x418> @ imm = #0x1a

080029dc <$d>:
 80029dc: a0 07 00 20  	.word	0x200007a0
 80029e0: 18 24 00 20  	.word	0x20002418
 80029e4: 9a 99 99 3e  	.word	0x3e99999a
 80029e8: cd cc 14 41  	.word	0x4114cccd
 80029ec: cd cc 24 41  	.word	0x4124cccd

080029f0 <$t>:
; 		QEKF_INS.StableFlag = 0;
 80029f0: 4bc5         	ldr	r3, [pc, #0x314]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 80029f2: 2200         	movs	r2, #0x0
 80029f4: f883 2139    	strb.w	r2, [r3, #0x139]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[0] = QEKF_INS.Q1 * QEKF_INS.dt;
 80029f8: 4bc3         	ldr	r3, [pc, #0x30c]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 80029fa: ed93 7a6c    	vldr	s14, [r3, #432]
 80029fe: 4bc2         	ldr	r3, [pc, #0x308]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a00: edd3 7a6f    	vldr	s15, [r3, #444]
 8002a04: 4bc0         	ldr	r3, [pc, #0x300]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a06: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8002a0a: ee67 7a27    	vmul.f32	s15, s14, s15
 8002a0e: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[7] = QEKF_INS.Q1 * QEKF_INS.dt;
 8002a12: 4bbd         	ldr	r3, [pc, #0x2f4]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a14: ed93 7a6c    	vldr	s14, [r3, #432]
 8002a18: 4bbb         	ldr	r3, [pc, #0x2ec]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a1a: edd3 7a6f    	vldr	s15, [r3, #444]
 8002a1e: 4bba         	ldr	r3, [pc, #0x2e8]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a20: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8002a24: 331c         	adds	r3, #0x1c
 8002a26: ee67 7a27    	vmul.f32	s15, s14, s15
 8002a2a: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[14] = QEKF_INS.Q1 * QEKF_INS.dt;
 8002a2e: 4bb6         	ldr	r3, [pc, #0x2d8]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a30: ed93 7a6c    	vldr	s14, [r3, #432]
 8002a34: 4bb4         	ldr	r3, [pc, #0x2d0]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a36: edd3 7a6f    	vldr	s15, [r3, #444]
 8002a3a: 4bb3         	ldr	r3, [pc, #0x2cc]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a3c: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8002a40: 3338         	adds	r3, #0x38
 8002a42: ee67 7a27    	vmul.f32	s15, s14, s15
 8002a46: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[21] = QEKF_INS.Q1 * QEKF_INS.dt;
 8002a4a: 4baf         	ldr	r3, [pc, #0x2bc]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a4c: ed93 7a6c    	vldr	s14, [r3, #432]
 8002a50: 4bad         	ldr	r3, [pc, #0x2b4]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a52: edd3 7a6f    	vldr	s15, [r3, #444]
 8002a56: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a58: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8002a5c: 3354         	adds	r3, #0x54
 8002a5e: ee67 7a27    	vmul.f32	s15, s14, s15
 8002a62: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[28] = QEKF_INS.Q2 * QEKF_INS.dt;
 8002a66: 4ba8         	ldr	r3, [pc, #0x2a0]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a68: ed93 7a6d    	vldr	s14, [r3, #436]
 8002a6c: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a6e: edd3 7a6f    	vldr	s15, [r3, #444]
 8002a72: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a74: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8002a78: 3370         	adds	r3, #0x70
 8002a7a: ee67 7a27    	vmul.f32	s15, s14, s15
 8002a7e: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.Q_data[35] = QEKF_INS.Q2 * QEKF_INS.dt;
 8002a82: 4ba1         	ldr	r3, [pc, #0x284]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a84: ed93 7a6d    	vldr	s14, [r3, #436]
 8002a88: 4b9f         	ldr	r3, [pc, #0x27c]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a8a: edd3 7a6f    	vldr	s15, [r3, #444]
 8002a8e: 4b9e         	ldr	r3, [pc, #0x278]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002a90: f8d3 3118    	ldr.w	r3, [r3, #0x118]
 8002a94: 338c         	adds	r3, #0x8c
 8002a96: ee67 7a27    	vmul.f32	s15, s14, s15
 8002a9a: edc3 7a00    	vstr	s15, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.R_data[0] = QEKF_INS.R;
 8002a9e: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002aa0: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8002aa4: 4a98         	ldr	r2, [pc, #0x260]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002aa6: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 8002aaa: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.R_data[4] = QEKF_INS.R;
 8002aac: 4b96         	ldr	r3, [pc, #0x258]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002aae: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8002ab2: 3310         	adds	r3, #0x10
 8002ab4: 4a94         	ldr	r2, [pc, #0x250]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002ab6: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 8002aba: 601a         	str	r2, [r3]
; 	QEKF_INS.IMU_QuaternionEKF.R_data[8] = QEKF_INS.R;
 8002abc: 4b92         	ldr	r3, [pc, #0x248]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002abe: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8002ac2: 3320         	adds	r3, #0x20
 8002ac4: 4a90         	ldr	r2, [pc, #0x240]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002ac6: f8d2 21b8    	ldr.w	r2, [r2, #0x1b8]
 8002aca: 601a         	str	r2, [r3]
; 	Kalman_Filter_Update(&QEKF_INS.IMU_QuaternionEKF);
 8002acc: 488f         	ldr	r0, [pc, #0x23c]        @ 0x8002d0c <IMU_QuaternionEKF_Update+0x72c>
 8002ace: f7ff faa5    	bl	0x800201c <Kalman_Filter_Update> @ imm = #-0xab6
; 	QEKF_INS.q[0] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[0];
 8002ad2: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002ad4: 685b         	ldr	r3, [r3, #0x4]
 8002ad6: 681b         	ldr	r3, [r3]
 8002ad8: 4a8b         	ldr	r2, [pc, #0x22c]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002ada: f8c2 3150    	str.w	r3, [r2, #0x150]
; 	QEKF_INS.q[1] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[1];
 8002ade: 4b8a         	ldr	r3, [pc, #0x228]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002ae0: 685b         	ldr	r3, [r3, #0x4]
 8002ae2: 685b         	ldr	r3, [r3, #0x4]
 8002ae4: 4a88         	ldr	r2, [pc, #0x220]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002ae6: f8c2 3154    	str.w	r3, [r2, #0x154]
; 	QEKF_INS.q[2] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[2];
 8002aea: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002aec: 685b         	ldr	r3, [r3, #0x4]
 8002aee: 689b         	ldr	r3, [r3, #0x8]
 8002af0: 4a85         	ldr	r2, [pc, #0x214]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002af2: f8c2 3158    	str.w	r3, [r2, #0x158]
; 	QEKF_INS.q[3] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[3];
 8002af6: 4b84         	ldr	r3, [pc, #0x210]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002af8: 685b         	ldr	r3, [r3, #0x4]
 8002afa: 68db         	ldr	r3, [r3, #0xc]
 8002afc: 4a82         	ldr	r2, [pc, #0x208]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002afe: f8c2 315c    	str.w	r3, [r2, #0x15c]
; 	QEKF_INS.GyroBias[0] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[4];
 8002b02: 4b81         	ldr	r3, [pc, #0x204]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b04: 685b         	ldr	r3, [r3, #0x4]
 8002b06: 691b         	ldr	r3, [r3, #0x10]
 8002b08: 4a7f         	ldr	r2, [pc, #0x1fc]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b0a: f8c2 3160    	str.w	r3, [r2, #0x160]
; 	QEKF_INS.GyroBias[1] = QEKF_INS.IMU_QuaternionEKF.FilteredValue[5];
 8002b0e: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b10: 685b         	ldr	r3, [r3, #0x4]
 8002b12: 695b         	ldr	r3, [r3, #0x14]
 8002b14: 4a7c         	ldr	r2, [pc, #0x1f0]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b16: f8c2 3164    	str.w	r3, [r2, #0x164]
; 	QEKF_INS.GyroBias[2] = 0; // 大部分时候z轴通天,无法观测yaw的漂移
 8002b1a: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b1c: f04f 0200    	mov.w	r2, #0x0
 8002b20: f8c3 2168    	str.w	r2, [r3, #0x168]
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[3] + QEKF_INS.q[1] * QEKF_INS.q[2]),
 8002b24: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b26: ed93 7a54    	vldr	s14, [r3, #336]
 8002b2a: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b2c: edd3 7a57    	vldr	s15, [r3, #348]
 8002b30: ee27 7a27    	vmul.f32	s14, s14, s15
 8002b34: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b36: edd3 6a55    	vldr	s13, [r3, #340]
 8002b3a: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b3c: edd3 7a56    	vldr	s15, [r3, #344]
 8002b40: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002b44: ee77 7a27    	vadd.f32	s15, s14, s15
 8002b48: ee37 6aa7    	vadd.f32	s12, s15, s15
; 		       2.0f * (QEKF_INS.q[0] * QEKF_INS.q[0] + QEKF_INS.q[1] * QEKF_INS.q[1]) -
 8002b4c: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b4e: ed93 7a54    	vldr	s14, [r3, #336]
 8002b52: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b54: edd3 7a54    	vldr	s15, [r3, #336]
 8002b58: ee27 7a27    	vmul.f32	s14, s14, s15
 8002b5c: 4b6a         	ldr	r3, [pc, #0x1a8]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b5e: edd3 6a55    	vldr	s13, [r3, #340]
 8002b62: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b64: edd3 7a55    	vldr	s15, [r3, #340]
 8002b68: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002b6c: ee77 7a27    	vadd.f32	s15, s14, s15
 8002b70: ee77 7aa7    	vadd.f32	s15, s15, s15
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[3] + QEKF_INS.q[1] * QEKF_INS.q[2]),
 8002b74: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 8002b78: ee77 7ac7    	vsub.f32	s15, s15, s14
 8002b7c: eef0 0a67    	vmov.f32	s1, s15
 8002b80: eeb0 0a46    	vmov.f32	s0, s12
 8002b84: f011 fd36    	bl	0x80145f4 <atan2f>      @ imm = #0x11a6c
 8002b88: eef0 7a40    	vmov.f32	s15, s0
; 			       1.0f) *
 8002b8c: ed9f 7a60    	vldr	s14, [pc, #384]         @ 0x8002d10 <IMU_QuaternionEKF_Update+0x730>
 8002b90: ee67 7a87    	vmul.f32	s15, s15, s14
; 	QEKF_INS.Yaw =
 8002b94: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b96: edc3 7a6a    	vstr	s15, [r3, #424]
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[1] + QEKF_INS.q[2] * QEKF_INS.q[3]),
 8002b9a: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002b9c: ed93 7a54    	vldr	s14, [r3, #336]
 8002ba0: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002ba2: edd3 7a55    	vldr	s15, [r3, #340]
 8002ba6: ee27 7a27    	vmul.f32	s14, s14, s15
 8002baa: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002bac: edd3 6a56    	vldr	s13, [r3, #344]
 8002bb0: 4b55         	ldr	r3, [pc, #0x154]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002bb2: edd3 7a57    	vldr	s15, [r3, #348]
 8002bb6: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002bba: ee77 7a27    	vadd.f32	s15, s14, s15
 8002bbe: ee37 6aa7    	vadd.f32	s12, s15, s15
; 		       2.0f * (QEKF_INS.q[0] * QEKF_INS.q[0] + QEKF_INS.q[3] * QEKF_INS.q[3]) -
 8002bc2: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002bc4: ed93 7a54    	vldr	s14, [r3, #336]
 8002bc8: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002bca: edd3 7a54    	vldr	s15, [r3, #336]
 8002bce: ee27 7a27    	vmul.f32	s14, s14, s15
 8002bd2: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002bd4: edd3 6a57    	vldr	s13, [r3, #348]
 8002bd8: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002bda: edd3 7a57    	vldr	s15, [r3, #348]
 8002bde: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002be2: ee77 7a27    	vadd.f32	s15, s14, s15
 8002be6: ee77 7aa7    	vadd.f32	s15, s15, s15
; 		atan2f(2.0f * (QEKF_INS.q[0] * QEKF_INS.q[1] + QEKF_INS.q[2] * QEKF_INS.q[3]),
 8002bea: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 8002bee: ee77 7ac7    	vsub.f32	s15, s15, s14
 8002bf2: eef0 0a67    	vmov.f32	s1, s15
 8002bf6: eeb0 0a46    	vmov.f32	s0, s12
 8002bfa: f011 fcfb    	bl	0x80145f4 <atan2f>      @ imm = #0x119f6
 8002bfe: eef0 7a40    	vmov.f32	s15, s0
; 			       1.0f) *
 8002c02: ed9f 7a43    	vldr	s14, [pc, #268]         @ 0x8002d10 <IMU_QuaternionEKF_Update+0x730>
 8002c06: ee67 7a87    	vmul.f32	s15, s15, s14
; 	QEKF_INS.Pitch =
 8002c0a: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c0c: edc3 7a69    	vstr	s15, [r3, #420]
; 		asinf(-2.0f * (QEKF_INS.q[1] * QEKF_INS.q[3] - QEKF_INS.q[0] * QEKF_INS.q[2])) *
 8002c10: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c12: ed93 7a55    	vldr	s14, [r3, #340]
 8002c16: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c18: edd3 7a57    	vldr	s15, [r3, #348]
 8002c1c: ee27 7a27    	vmul.f32	s14, s14, s15
 8002c20: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c22: edd3 6a54    	vldr	s13, [r3, #336]
 8002c26: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c28: edd3 7a56    	vldr	s15, [r3, #344]
 8002c2c: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002c30: ee77 7a67    	vsub.f32	s15, s14, s15
 8002c34: eeb8 7a00    	vmov.f32	s14, #-2.000000e+00
 8002c38: ee67 7a87    	vmul.f32	s15, s15, s14
 8002c3c: eeb0 0a67    	vmov.f32	s0, s15
 8002c40: f011 fbf6    	bl	0x8014430 <asinf>       @ imm = #0x117ec
 8002c44: eef0 7a40    	vmov.f32	s15, s0
 8002c48: ed9f 7a31    	vldr	s14, [pc, #196]         @ 0x8002d10 <IMU_QuaternionEKF_Update+0x730>
 8002c4c: ee67 7a87    	vmul.f32	s15, s15, s14
; 	QEKF_INS.Roll =
 8002c50: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c52: edc3 7a68    	vstr	s15, [r3, #416]
; 	if (QEKF_INS.Yaw - QEKF_INS.YawAngleLast > 180.0f) {
 8002c56: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c58: ed93 7a6a    	vldr	s14, [r3, #424]
 8002c5c: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c5e: edd3 7a76    	vldr	s15, [r3, #472]
 8002c62: ee77 7a67    	vsub.f32	s15, s14, s15
 8002c66: ed9f 7a2b    	vldr	s14, [pc, #172]         @ 0x8002d14 <IMU_QuaternionEKF_Update+0x734>
 8002c6a: eef4 7ac7    	vcmpe.f32	s15, s14
 8002c6e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002c72: dd0a         	ble	0x8002c8a <IMU_QuaternionEKF_Update+0x6aa> @ imm = #0x14
; 		QEKF_INS.YawRoundCount--;
 8002c74: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c76: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 8002c7a: b29b         	uxth	r3, r3
 8002c7c: 3b01         	subs	r3, #0x1
 8002c7e: b29b         	uxth	r3, r3
 8002c80: b21a         	sxth	r2, r3
 8002c82: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c84: f8a3 21d4    	strh.w	r2, [r3, #0x1d4]
 8002c88: e018         	b	0x8002cbc <IMU_QuaternionEKF_Update+0x6dc> @ imm = #0x30
; 	} else if (QEKF_INS.Yaw - QEKF_INS.YawAngleLast < -180.0f) {
 8002c8a: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c8c: ed93 7a6a    	vldr	s14, [r3, #424]
 8002c90: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002c92: edd3 7a76    	vldr	s15, [r3, #472]
 8002c96: ee77 7a67    	vsub.f32	s15, s14, s15
 8002c9a: ed9f 7a1f    	vldr	s14, [pc, #124]         @ 0x8002d18 <IMU_QuaternionEKF_Update+0x738>
 8002c9e: eef4 7ac7    	vcmpe.f32	s15, s14
 8002ca2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002ca6: d509         	bpl	0x8002cbc <IMU_QuaternionEKF_Update+0x6dc> @ imm = #0x12
; 		QEKF_INS.YawRoundCount++;
 8002ca8: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002caa: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 8002cae: b29b         	uxth	r3, r3
 8002cb0: 3301         	adds	r3, #0x1
 8002cb2: b29b         	uxth	r3, r3
 8002cb4: b21a         	sxth	r2, r3
 8002cb6: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002cb8: f8a3 21d4    	strh.w	r2, [r3, #0x1d4]
; 	QEKF_INS.YawTotalAngle = 360.0f * QEKF_INS.YawRoundCount + QEKF_INS.Yaw;
 8002cbc: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002cbe: f9b3 31d4    	ldrsh.w	r3, [r3, #0x1d4]
 8002cc2: ee07 3a90    	vmov	s15, r3
 8002cc6: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8002cca: ed9f 7a14    	vldr	s14, [pc, #80]          @ 0x8002d1c <IMU_QuaternionEKF_Update+0x73c>
 8002cce: ee27 7a87    	vmul.f32	s14, s15, s14
 8002cd2: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002cd4: edd3 7a6a    	vldr	s15, [r3, #424]
 8002cd8: ee77 7a27    	vadd.f32	s15, s14, s15
 8002cdc: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002cde: edc3 7a6b    	vstr	s15, [r3, #428]
; 	QEKF_INS.YawAngleLast = QEKF_INS.Yaw;
 8002ce2: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002ce4: f8d3 31a8    	ldr.w	r3, [r3, #0x1a8]
 8002ce8: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002cea: f8c2 31d8    	str.w	r3, [r2, #0x1d8]
; 	QEKF_INS.UpdateCount++; // 初始化低通滤波用,计数测试用
 8002cee: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002cf0: e9d3 2352    	ldrd	r2, r3, [r3, #328]
 8002cf4: 1c54         	adds	r4, r2, #0x1
 8002cf6: f143 0500    	adc	r5, r3, #0x0
 8002cfa: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8002d08 <IMU_QuaternionEKF_Update+0x728>
 8002cfc: e9c3 4552    	strd	r4, r5, [r3, #328]
; }
 8002d00: bf00         	nop
 8002d02: 3728         	adds	r7, #0x28
 8002d04: 46bd         	mov	sp, r7
 8002d06: bdb0         	pop	{r4, r5, r7, pc}

08002d08 <$d>:
 8002d08: a0 07 00 20  	.word	0x200007a0
 8002d0c: a4 07 00 20  	.word	0x200007a4
 8002d10: e1 2e 65 42  	.word	0x42652ee1
 8002d14: 00 00 34 43  	.word	0x43340000
 8002d18: 00 00 34 c3  	.word	0xc3340000
 8002d1c: 00 00 b4 43  	.word	0x43b40000

08002d20 <IMU_QuaternionEKF_F_Linearization_P_Fading>:
; {
 8002d20: b580         	push	{r7, lr}
 8002d22: b084         	sub	sp, #0x10
 8002d24: af00         	add	r7, sp, #0x0
 8002d26: 6078         	str	r0, [r7, #0x4]
; 	q0 = kf->xhatminus_data[0];
 8002d28: 687b         	ldr	r3, [r7, #0x4]
 8002d2a: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002d2e: 681b         	ldr	r3, [r3]
 8002d30: 4aa2         	ldr	r2, [pc, #0x288]        @ 0x8002fbc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 8002d32: 6013         	str	r3, [r2]
; 	q1 = kf->xhatminus_data[1];
 8002d34: 687b         	ldr	r3, [r7, #0x4]
 8002d36: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002d3a: 685b         	ldr	r3, [r3, #0x4]
 8002d3c: 4aa0         	ldr	r2, [pc, #0x280]        @ 0x8002fc0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 8002d3e: 6013         	str	r3, [r2]
; 	q2 = kf->xhatminus_data[2];
 8002d40: 687b         	ldr	r3, [r7, #0x4]
 8002d42: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002d46: 689b         	ldr	r3, [r3, #0x8]
 8002d48: 4a9e         	ldr	r2, [pc, #0x278]        @ 0x8002fc4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 8002d4a: 6013         	str	r3, [r2]
; 	q3 = kf->xhatminus_data[3];
 8002d4c: 687b         	ldr	r3, [r7, #0x4]
 8002d4e: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002d52: 68db         	ldr	r3, [r3, #0xc]
 8002d54: 4a9c         	ldr	r2, [pc, #0x270]        @ 0x8002fc8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 8002d56: 6013         	str	r3, [r2]
; 	qInvNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
 8002d58: 4b98         	ldr	r3, [pc, #0x260]        @ 0x8002fbc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 8002d5a: ed93 7a00    	vldr	s14, [r3]
 8002d5e: 4b97         	ldr	r3, [pc, #0x25c]        @ 0x8002fbc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 8002d60: edd3 7a00    	vldr	s15, [r3]
 8002d64: ee27 7a27    	vmul.f32	s14, s14, s15
 8002d68: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8002fc0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 8002d6a: edd3 6a00    	vldr	s13, [r3]
 8002d6e: 4b94         	ldr	r3, [pc, #0x250]        @ 0x8002fc0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 8002d70: edd3 7a00    	vldr	s15, [r3]
 8002d74: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002d78: ee37 7a27    	vadd.f32	s14, s14, s15
 8002d7c: 4b91         	ldr	r3, [pc, #0x244]        @ 0x8002fc4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 8002d7e: edd3 6a00    	vldr	s13, [r3]
 8002d82: 4b90         	ldr	r3, [pc, #0x240]        @ 0x8002fc4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 8002d84: edd3 7a00    	vldr	s15, [r3]
 8002d88: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002d8c: ee37 7a27    	vadd.f32	s14, s14, s15
 8002d90: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8002fc8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 8002d92: edd3 6a00    	vldr	s13, [r3]
 8002d96: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x8002fc8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 8002d98: edd3 7a00    	vldr	s15, [r3]
 8002d9c: ee66 7aa7    	vmul.f32	s15, s13, s15
 8002da0: ee77 7a27    	vadd.f32	s15, s14, s15
 8002da4: eeb0 0a67    	vmov.f32	s0, s15
 8002da8: f000 fd44    	bl	0x8003834 <invSqrt>     @ imm = #0xa88
 8002dac: eef0 7a40    	vmov.f32	s15, s0
 8002db0: 4b86         	ldr	r3, [pc, #0x218]        @ 0x8002fcc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2ac>
 8002db2: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 4; ++i) {
 8002db6: 2300         	movs	r3, #0x0
 8002db8: 73fb         	strb	r3, [r7, #0xf]
 8002dba: e017         	b	0x8002dec <IMU_QuaternionEKF_F_Linearization_P_Fading+0xcc> @ imm = #0x2e
; 		kf->xhatminus_data[i] *= qInvNorm;
 8002dbc: 687b         	ldr	r3, [r7, #0x4]
 8002dbe: f8d3 20ec    	ldr.w	r2, [r3, #0xec]
 8002dc2: 7bfb         	ldrb	r3, [r7, #0xf]
 8002dc4: 009b         	lsls	r3, r3, #0x2
 8002dc6: 4413         	add	r3, r2
 8002dc8: ed93 7a00    	vldr	s14, [r3]
 8002dcc: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x8002fcc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2ac>
 8002dce: edd3 7a00    	vldr	s15, [r3]
 8002dd2: 687b         	ldr	r3, [r7, #0x4]
 8002dd4: f8d3 20ec    	ldr.w	r2, [r3, #0xec]
 8002dd8: 7bfb         	ldrb	r3, [r7, #0xf]
 8002dda: 009b         	lsls	r3, r3, #0x2
 8002ddc: 4413         	add	r3, r2
 8002dde: ee67 7a27    	vmul.f32	s15, s14, s15
 8002de2: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 4; ++i) {
 8002de6: 7bfb         	ldrb	r3, [r7, #0xf]
 8002de8: 3301         	adds	r3, #0x1
 8002dea: 73fb         	strb	r3, [r7, #0xf]
 8002dec: 7bfb         	ldrb	r3, [r7, #0xf]
 8002dee: 2b03         	cmp	r3, #0x3
 8002df0: d9e4         	bls	0x8002dbc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x9c> @ imm = #-0x38
; 	kf->F_data[4] = q1 * QEKF_INS.dt / 2;
 8002df2: 4b77         	ldr	r3, [pc, #0x1dc]        @ 0x8002fd0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002df4: ed93 7a6f    	vldr	s14, [r3, #444]
 8002df8: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8002fc0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 8002dfa: edd3 7a00    	vldr	s15, [r3]
 8002dfe: ee27 7a27    	vmul.f32	s14, s14, s15
 8002e02: 687b         	ldr	r3, [r7, #0x4]
 8002e04: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002e08: 3310         	adds	r3, #0x10
 8002e0a: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8002e0e: eec7 7a26    	vdiv.f32	s15, s14, s13
 8002e12: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[5] = q2 * QEKF_INS.dt / 2;
 8002e16: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8002fd0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002e18: ed93 7a6f    	vldr	s14, [r3, #444]
 8002e1c: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8002fc4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 8002e1e: edd3 7a00    	vldr	s15, [r3]
 8002e22: ee27 7a27    	vmul.f32	s14, s14, s15
 8002e26: 687b         	ldr	r3, [r7, #0x4]
 8002e28: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002e2c: 3314         	adds	r3, #0x14
 8002e2e: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8002e32: eec7 7a26    	vdiv.f32	s15, s14, s13
 8002e36: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[10] = -q0 * QEKF_INS.dt / 2;
 8002e3a: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8002fbc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 8002e3c: edd3 7a00    	vldr	s15, [r3]
 8002e40: eeb1 7a67    	vneg.f32	s14, s15
 8002e44: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8002fd0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002e46: edd3 7a6f    	vldr	s15, [r3, #444]
 8002e4a: ee27 7a27    	vmul.f32	s14, s14, s15
 8002e4e: 687b         	ldr	r3, [r7, #0x4]
 8002e50: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002e54: 3328         	adds	r3, #0x28
 8002e56: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8002e5a: eec7 7a26    	vdiv.f32	s15, s14, s13
 8002e5e: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[11] = q3 * QEKF_INS.dt / 2;
 8002e62: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8002fd0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002e64: ed93 7a6f    	vldr	s14, [r3, #444]
 8002e68: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8002fc8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 8002e6a: edd3 7a00    	vldr	s15, [r3]
 8002e6e: ee27 7a27    	vmul.f32	s14, s14, s15
 8002e72: 687b         	ldr	r3, [r7, #0x4]
 8002e74: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002e78: 332c         	adds	r3, #0x2c
 8002e7a: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8002e7e: eec7 7a26    	vdiv.f32	s15, s14, s13
 8002e82: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[16] = -q3 * QEKF_INS.dt / 2;
 8002e86: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8002fc8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a8>
 8002e88: edd3 7a00    	vldr	s15, [r3]
 8002e8c: eeb1 7a67    	vneg.f32	s14, s15
 8002e90: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8002fd0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002e92: edd3 7a6f    	vldr	s15, [r3, #444]
 8002e96: ee27 7a27    	vmul.f32	s14, s14, s15
 8002e9a: 687b         	ldr	r3, [r7, #0x4]
 8002e9c: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002ea0: 3340         	adds	r3, #0x40
 8002ea2: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8002ea6: eec7 7a26    	vdiv.f32	s15, s14, s13
 8002eaa: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[17] = -q0 * QEKF_INS.dt / 2;
 8002eae: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8002fbc <IMU_QuaternionEKF_F_Linearization_P_Fading+0x29c>
 8002eb0: edd3 7a00    	vldr	s15, [r3]
 8002eb4: eeb1 7a67    	vneg.f32	s14, s15
 8002eb8: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8002fd0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002eba: edd3 7a6f    	vldr	s15, [r3, #444]
 8002ebe: ee27 7a27    	vmul.f32	s14, s14, s15
 8002ec2: 687b         	ldr	r3, [r7, #0x4]
 8002ec4: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002ec8: 3344         	adds	r3, #0x44
 8002eca: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8002ece: eec7 7a26    	vdiv.f32	s15, s14, s13
 8002ed2: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[22] = q2 * QEKF_INS.dt / 2;
 8002ed6: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8002fd0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002ed8: ed93 7a6f    	vldr	s14, [r3, #444]
 8002edc: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8002fc4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a4>
 8002ede: edd3 7a00    	vldr	s15, [r3]
 8002ee2: ee27 7a27    	vmul.f32	s14, s14, s15
 8002ee6: 687b         	ldr	r3, [r7, #0x4]
 8002ee8: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002eec: 3358         	adds	r3, #0x58
 8002eee: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8002ef2: eec7 7a26    	vdiv.f32	s15, s14, s13
 8002ef6: edc3 7a00    	vstr	s15, [r3]
; 	kf->F_data[23] = -q1 * QEKF_INS.dt / 2;
 8002efa: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8002fc0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2a0>
 8002efc: edd3 7a00    	vldr	s15, [r3]
 8002f00: eeb1 7a67    	vneg.f32	s14, s15
 8002f04: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8002fd0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002f06: edd3 7a6f    	vldr	s15, [r3, #444]
 8002f0a: ee27 7a27    	vmul.f32	s14, s14, s15
 8002f0e: 687b         	ldr	r3, [r7, #0x4]
 8002f10: f8d3 3100    	ldr.w	r3, [r3, #0x100]
 8002f14: 335c         	adds	r3, #0x5c
 8002f16: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8002f1a: eec7 7a26    	vdiv.f32	s15, s14, s13
 8002f1e: edc3 7a00    	vstr	s15, [r3]
; 	kf->P_data[28] /= QEKF_INS.lambda;
 8002f22: 687b         	ldr	r3, [r7, #0x4]
 8002f24: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002f28: 3370         	adds	r3, #0x70
 8002f2a: edd3 6a00    	vldr	s13, [r3]
 8002f2e: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8002fd0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002f30: ed93 7a74    	vldr	s14, [r3, #464]
 8002f34: 687b         	ldr	r3, [r7, #0x4]
 8002f36: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002f3a: 3370         	adds	r3, #0x70
 8002f3c: eec6 7a87    	vdiv.f32	s15, s13, s14
 8002f40: edc3 7a00    	vstr	s15, [r3]
; 	kf->P_data[35] /= QEKF_INS.lambda;
 8002f44: 687b         	ldr	r3, [r7, #0x4]
 8002f46: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002f4a: 338c         	adds	r3, #0x8c
 8002f4c: edd3 6a00    	vldr	s13, [r3]
 8002f50: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8002fd0 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b0>
 8002f52: ed93 7a74    	vldr	s14, [r3, #464]
 8002f56: 687b         	ldr	r3, [r7, #0x4]
 8002f58: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002f5c: 338c         	adds	r3, #0x8c
 8002f5e: eec6 7a87    	vdiv.f32	s15, s13, s14
 8002f62: edc3 7a00    	vstr	s15, [r3]
; 	if (kf->P_data[28] > 10000) {
 8002f66: 687b         	ldr	r3, [r7, #0x4]
 8002f68: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002f6c: 3370         	adds	r3, #0x70
 8002f6e: edd3 7a00    	vldr	s15, [r3]
 8002f72: ed9f 7a18    	vldr	s14, [pc, #96]          @ 0x8002fd4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b4>
 8002f76: eef4 7ac7    	vcmpe.f32	s15, s14
 8002f7a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002f7e: dd05         	ble	0x8002f8c <IMU_QuaternionEKF_F_Linearization_P_Fading+0x26c> @ imm = #0xa
; 		kf->P_data[28] = 10000;
 8002f80: 687b         	ldr	r3, [r7, #0x4]
 8002f82: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002f86: 3370         	adds	r3, #0x70
 8002f88: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8002fd8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b8>
 8002f8a: 601a         	str	r2, [r3]
; 	if (kf->P_data[35] > 10000) {
 8002f8c: 687b         	ldr	r3, [r7, #0x4]
 8002f8e: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002f92: 338c         	adds	r3, #0x8c
 8002f94: edd3 7a00    	vldr	s15, [r3]
 8002f98: ed9f 7a0e    	vldr	s14, [pc, #56]          @ 0x8002fd4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b4>
 8002f9c: eef4 7ac7    	vcmpe.f32	s15, s14
 8002fa0: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8002fa4: dc00         	bgt	0x8002fa8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x288> @ imm = #0x0
; }
 8002fa6: e005         	b	0x8002fb4 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x294> @ imm = #0xa
; 		kf->P_data[35] = 10000;
 8002fa8: 687b         	ldr	r3, [r7, #0x4]
 8002faa: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 8002fae: 338c         	adds	r3, #0x8c
 8002fb0: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8002fd8 <IMU_QuaternionEKF_F_Linearization_P_Fading+0x2b8>
 8002fb2: 601a         	str	r2, [r3]
; }
 8002fb4: bf00         	nop
 8002fb6: 3710         	adds	r7, #0x10
 8002fb8: 46bd         	mov	sp, r7
 8002fba: bd80         	pop	{r7, pc}

08002fbc <$d>:
 8002fbc: 1c 24 00 20  	.word	0x2000241c
 8002fc0: 20 24 00 20  	.word	0x20002420
 8002fc4: 24 24 00 20  	.word	0x20002424
 8002fc8: 28 24 00 20  	.word	0x20002428
 8002fcc: 2c 24 00 20  	.word	0x2000242c
 8002fd0: a0 07 00 20  	.word	0x200007a0
 8002fd4: 00 40 1c 46  	.word	0x461c4000
 8002fd8: 00 40 1c 46  	.word	0x461c4000

08002fdc <IMU_QuaternionEKF_SetH>:
; {
 8002fdc: b580         	push	{r7, lr}
 8002fde: b082         	sub	sp, #0x8
 8002fe0: af00         	add	r7, sp, #0x0
 8002fe2: 6078         	str	r0, [r7, #0x4]
; 	doubleq0 = 2 * kf->xhatminus_data[0];
 8002fe4: 687b         	ldr	r3, [r7, #0x4]
 8002fe6: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002fea: edd3 7a00    	vldr	s15, [r3]
 8002fee: ee77 7aa7    	vadd.f32	s15, s15, s15
 8002ff2: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x800312c <IMU_QuaternionEKF_SetH+0x150>
 8002ff4: edc3 7a00    	vstr	s15, [r3]
; 	doubleq1 = 2 * kf->xhatminus_data[1];
 8002ff8: 687b         	ldr	r3, [r7, #0x4]
 8002ffa: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8002ffe: 3304         	adds	r3, #0x4
 8003000: edd3 7a00    	vldr	s15, [r3]
 8003004: ee77 7aa7    	vadd.f32	s15, s15, s15
 8003008: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8003130 <IMU_QuaternionEKF_SetH+0x154>
 800300a: edc3 7a00    	vstr	s15, [r3]
; 	doubleq2 = 2 * kf->xhatminus_data[2];
 800300e: 687b         	ldr	r3, [r7, #0x4]
 8003010: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8003014: 3308         	adds	r3, #0x8
 8003016: edd3 7a00    	vldr	s15, [r3]
 800301a: ee77 7aa7    	vadd.f32	s15, s15, s15
 800301e: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8003134 <IMU_QuaternionEKF_SetH+0x158>
 8003020: edc3 7a00    	vstr	s15, [r3]
; 	doubleq3 = 2 * kf->xhatminus_data[3];
 8003024: 687b         	ldr	r3, [r7, #0x4]
 8003026: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800302a: 330c         	adds	r3, #0xc
 800302c: edd3 7a00    	vldr	s15, [r3]
 8003030: ee77 7aa7    	vadd.f32	s15, s15, s15
 8003034: 4b40         	ldr	r3, [pc, #0x100]        @ 0x8003138 <IMU_QuaternionEKF_SetH+0x15c>
 8003036: edc3 7a00    	vstr	s15, [r3]
; 	memset(kf->H_data, 0, sizeof_float * kf->zSize * kf->xhatSize);
 800303a: 687b         	ldr	r3, [r7, #0x4]
 800303c: f8d3 010c    	ldr.w	r0, [r3, #0x10c]
 8003040: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800313c <IMU_QuaternionEKF_SetH+0x160>
 8003042: 881b         	ldrh	r3, [r3]
 8003044: 461a         	mov	r2, r3
 8003046: 687b         	ldr	r3, [r7, #0x4]
 8003048: 7b9b         	ldrb	r3, [r3, #0xe]
 800304a: fb02 f303    	mul	r3, r2, r3
 800304e: 687a         	ldr	r2, [r7, #0x4]
 8003050: 7b12         	ldrb	r2, [r2, #0xc]
 8003052: fb02 f303    	mul	r3, r2, r3
 8003056: 461a         	mov	r2, r3
 8003058: 2100         	movs	r1, #0x0
 800305a: f01c fe3d    	bl	0x801fcd8 <memset>      @ imm = #0x1cc7a
; 	kf->H_data[0] = -doubleq2;
 800305e: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8003134 <IMU_QuaternionEKF_SetH+0x158>
 8003060: edd3 7a00    	vldr	s15, [r3]
 8003064: 687b         	ldr	r3, [r7, #0x4]
 8003066: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800306a: eef1 7a67    	vneg.f32	s15, s15
 800306e: edc3 7a00    	vstr	s15, [r3]
; 	kf->H_data[1] = doubleq3;
 8003072: 687b         	ldr	r3, [r7, #0x4]
 8003074: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8003078: 3304         	adds	r3, #0x4
 800307a: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x8003138 <IMU_QuaternionEKF_SetH+0x15c>
 800307c: 6812         	ldr	r2, [r2]
 800307e: 601a         	str	r2, [r3]
; 	kf->H_data[2] = -doubleq0;
 8003080: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800312c <IMU_QuaternionEKF_SetH+0x150>
 8003082: edd3 7a00    	vldr	s15, [r3]
 8003086: 687b         	ldr	r3, [r7, #0x4]
 8003088: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800308c: 3308         	adds	r3, #0x8
 800308e: eef1 7a67    	vneg.f32	s15, s15
 8003092: edc3 7a00    	vstr	s15, [r3]
; 	kf->H_data[3] = doubleq1;
 8003096: 687b         	ldr	r3, [r7, #0x4]
 8003098: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800309c: 330c         	adds	r3, #0xc
 800309e: 4a24         	ldr	r2, [pc, #0x90]         @ 0x8003130 <IMU_QuaternionEKF_SetH+0x154>
 80030a0: 6812         	ldr	r2, [r2]
 80030a2: 601a         	str	r2, [r3]
; 	kf->H_data[6] = doubleq1;
 80030a4: 687b         	ldr	r3, [r7, #0x4]
 80030a6: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80030aa: 3318         	adds	r3, #0x18
 80030ac: 4a20         	ldr	r2, [pc, #0x80]         @ 0x8003130 <IMU_QuaternionEKF_SetH+0x154>
 80030ae: 6812         	ldr	r2, [r2]
 80030b0: 601a         	str	r2, [r3]
; 	kf->H_data[7] = doubleq0;
 80030b2: 687b         	ldr	r3, [r7, #0x4]
 80030b4: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80030b8: 331c         	adds	r3, #0x1c
 80030ba: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x800312c <IMU_QuaternionEKF_SetH+0x150>
 80030bc: 6812         	ldr	r2, [r2]
 80030be: 601a         	str	r2, [r3]
; 	kf->H_data[8] = doubleq3;
 80030c0: 687b         	ldr	r3, [r7, #0x4]
 80030c2: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80030c6: 3320         	adds	r3, #0x20
 80030c8: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8003138 <IMU_QuaternionEKF_SetH+0x15c>
 80030ca: 6812         	ldr	r2, [r2]
 80030cc: 601a         	str	r2, [r3]
; 	kf->H_data[9] = doubleq2;
 80030ce: 687b         	ldr	r3, [r7, #0x4]
 80030d0: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80030d4: 3324         	adds	r3, #0x24
 80030d6: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8003134 <IMU_QuaternionEKF_SetH+0x158>
 80030d8: 6812         	ldr	r2, [r2]
 80030da: 601a         	str	r2, [r3]
; 	kf->H_data[12] = doubleq0;
 80030dc: 687b         	ldr	r3, [r7, #0x4]
 80030de: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80030e2: 3330         	adds	r3, #0x30
 80030e4: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800312c <IMU_QuaternionEKF_SetH+0x150>
 80030e6: 6812         	ldr	r2, [r2]
 80030e8: 601a         	str	r2, [r3]
; 	kf->H_data[13] = -doubleq1;
 80030ea: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8003130 <IMU_QuaternionEKF_SetH+0x154>
 80030ec: edd3 7a00    	vldr	s15, [r3]
 80030f0: 687b         	ldr	r3, [r7, #0x4]
 80030f2: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 80030f6: 3334         	adds	r3, #0x34
 80030f8: eef1 7a67    	vneg.f32	s15, s15
 80030fc: edc3 7a00    	vstr	s15, [r3]
; 	kf->H_data[14] = -doubleq2;
 8003100: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8003134 <IMU_QuaternionEKF_SetH+0x158>
 8003102: edd3 7a00    	vldr	s15, [r3]
 8003106: 687b         	ldr	r3, [r7, #0x4]
 8003108: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800310c: 3338         	adds	r3, #0x38
 800310e: eef1 7a67    	vneg.f32	s15, s15
 8003112: edc3 7a00    	vstr	s15, [r3]
; 	kf->H_data[15] = doubleq3;
 8003116: 687b         	ldr	r3, [r7, #0x4]
 8003118: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 800311c: 333c         	adds	r3, #0x3c
 800311e: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8003138 <IMU_QuaternionEKF_SetH+0x15c>
 8003120: 6812         	ldr	r2, [r2]
 8003122: 601a         	str	r2, [r3]
; }
 8003124: bf00         	nop
 8003126: 3708         	adds	r7, #0x8
 8003128: 46bd         	mov	sp, r7
 800312a: bd80         	pop	{r7, pc}

0800312c <$d>:
 800312c: 30 24 00 20  	.word	0x20002430
 8003130: 34 24 00 20  	.word	0x20002434
 8003134: 38 24 00 20  	.word	0x20002438
 8003138: 3c 24 00 20  	.word	0x2000243c
 800313c: f4 27 00 20  	.word	0x200027f4

08003140 <IMU_QuaternionEKF_xhatUpdate>:
; {
 8003140: b5f0         	push	{r4, r5, r6, r7, lr}
 8003142: b087         	sub	sp, #0x1c
 8003144: af00         	add	r7, sp, #0x0
 8003146: 6078         	str	r0, [r7, #0x4]
; 	kf->MatStatus = Matrix_Transpose(&kf->H, &kf->HT); // z|x => x|z
 8003148: 687b         	ldr	r3, [r7, #0x4]
 800314a: f103 0278    	add.w	r2, r3, #0x78
 800314e: 687b         	ldr	r3, [r7, #0x4]
 8003150: 3380         	adds	r3, #0x80
 8003152: 4619         	mov	r1, r3
 8003154: 4610         	mov	r0, r2
 8003156: f00b fbdf    	bl	0x800e918 <arm_mat_trans_f32> @ imm = #0xb7be
 800315a: 4603         	mov	r3, r0
 800315c: 461a         	mov	r2, r3
 800315e: 687b         	ldr	r3, [r7, #0x4]
 8003160: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix.numRows = kf->H.numRows;
 8003164: 687b         	ldr	r3, [r7, #0x4]
 8003166: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 800316a: 687b         	ldr	r3, [r7, #0x4]
 800316c: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = kf->Pminus.numCols;
 8003170: 687b         	ldr	r3, [r7, #0x4]
 8003172: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 8003176: 687b         	ldr	r3, [r7, #0x4]
 8003178: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		Matrix_Multiply(&kf->H, &kf->Pminus, &kf->temp_matrix); // temp_matrix = H·P'(k)
 800317c: 687b         	ldr	r3, [r7, #0x4]
 800317e: f103 0078    	add.w	r0, r3, #0x78
 8003182: 687b         	ldr	r3, [r7, #0x4]
 8003184: f103 0158    	add.w	r1, r3, #0x58
 8003188: 687b         	ldr	r3, [r7, #0x4]
 800318a: 33a8         	adds	r3, #0xa8
 800318c: 461a         	mov	r2, r3
 800318e: f00b fb53    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #0xb6a6
 8003192: 4603         	mov	r3, r0
 8003194: 461a         	mov	r2, r3
; 	kf->MatStatus =
 8003196: 687b         	ldr	r3, [r7, #0x4]
 8003198: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 800319c: 687b         	ldr	r3, [r7, #0x4]
 800319e: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 80031a2: 687b         	ldr	r3, [r7, #0x4]
 80031a4: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 	kf->temp_matrix1.numCols = kf->HT.numCols;
 80031a8: 687b         	ldr	r3, [r7, #0x4]
 80031aa: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 80031ae: 687b         	ldr	r3, [r7, #0x4]
 80031b0: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->HT,
 80031b4: 687b         	ldr	r3, [r7, #0x4]
 80031b6: f103 00a8    	add.w	r0, r3, #0xa8
 80031ba: 687b         	ldr	r3, [r7, #0x4]
 80031bc: f103 0180    	add.w	r1, r3, #0x80
 80031c0: 687b         	ldr	r3, [r7, #0x4]
 80031c2: 33b0         	adds	r3, #0xb0
 80031c4: 461a         	mov	r2, r3
 80031c6: f00b fb37    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #0xb66e
 80031ca: 4603         	mov	r3, r0
 80031cc: 461a         	mov	r2, r3
 80031ce: 687b         	ldr	r3, [r7, #0x4]
 80031d0: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->S.numRows = kf->R.numRows;
 80031d4: 687b         	ldr	r3, [r7, #0x4]
 80031d6: f8b3 2090    	ldrh.w	r2, [r3, #0x90]
 80031da: 687b         	ldr	r3, [r7, #0x4]
 80031dc: f8a3 20a0    	strh.w	r2, [r3, #0xa0]
; 	kf->S.numCols = kf->R.numCols;
 80031e0: 687b         	ldr	r3, [r7, #0x4]
 80031e2: f8b3 2092    	ldrh.w	r2, [r3, #0x92]
 80031e6: 687b         	ldr	r3, [r7, #0x4]
 80031e8: f8a3 20a2    	strh.w	r2, [r3, #0xa2]
; 	kf->MatStatus = Matrix_Add(&kf->temp_matrix1, &kf->R, &kf->S); // S = H P'(k) HT + R
 80031ec: 687b         	ldr	r3, [r7, #0x4]
 80031ee: f103 00b0    	add.w	r0, r3, #0xb0
 80031f2: 687b         	ldr	r3, [r7, #0x4]
 80031f4: f103 0190    	add.w	r1, r3, #0x90
 80031f8: 687b         	ldr	r3, [r7, #0x4]
 80031fa: 33a0         	adds	r3, #0xa0
 80031fc: 461a         	mov	r2, r3
 80031fe: f00b f97f    	bl	0x800e500 <arm_mat_add_f32> @ imm = #0xb2fe
 8003202: 4603         	mov	r3, r0
 8003204: 461a         	mov	r2, r3
 8003206: 687b         	ldr	r3, [r7, #0x4]
 8003208: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		Matrix_Inverse(&kf->S, &kf->temp_matrix1); // temp_matrix1 = inv(H·P'(k)·HT + R)
 800320c: 687b         	ldr	r3, [r7, #0x4]
 800320e: f103 02a0    	add.w	r2, r3, #0xa0
 8003212: 687b         	ldr	r3, [r7, #0x4]
 8003214: 33b0         	adds	r3, #0xb0
 8003216: 4619         	mov	r1, r3
 8003218: 4610         	mov	r0, r2
 800321a: f00b f98b    	bl	0x800e534 <arm_mat_inverse_f32> @ imm = #0xb316
 800321e: 4603         	mov	r3, r0
 8003220: 461a         	mov	r2, r3
; 	kf->MatStatus =
 8003222: 687b         	ldr	r3, [r7, #0x4]
 8003224: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	q0 = kf->xhatminus_data[0];
 8003228: 687b         	ldr	r3, [r7, #0x4]
 800322a: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800322e: 681b         	ldr	r3, [r3]
 8003230: 4ab8         	ldr	r2, [pc, #0x2e0]        @ 0x8003514 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 8003232: 6013         	str	r3, [r2]
; 	q1 = kf->xhatminus_data[1];
 8003234: 687b         	ldr	r3, [r7, #0x4]
 8003236: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 800323a: 685b         	ldr	r3, [r3, #0x4]
 800323c: 4ab6         	ldr	r2, [pc, #0x2d8]        @ 0x8003518 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 800323e: 6013         	str	r3, [r2]
; 	q2 = kf->xhatminus_data[2];
 8003240: 687b         	ldr	r3, [r7, #0x4]
 8003242: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8003246: 689b         	ldr	r3, [r3, #0x8]
 8003248: 4ab4         	ldr	r2, [pc, #0x2d0]        @ 0x800351c <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 800324a: 6013         	str	r3, [r2]
; 	q3 = kf->xhatminus_data[3];
 800324c: 687b         	ldr	r3, [r7, #0x4]
 800324e: f8d3 30ec    	ldr.w	r3, [r3, #0xec]
 8003252: 68db         	ldr	r3, [r3, #0xc]
 8003254: 4ab2         	ldr	r2, [pc, #0x2c8]        @ 0x8003520 <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 8003256: 6013         	str	r3, [r2]
; 	kf->temp_vector.numRows = kf->H.numRows;
 8003258: 687b         	ldr	r3, [r7, #0x4]
 800325a: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 800325e: 687b         	ldr	r3, [r7, #0x4]
 8003260: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = 1;
 8003264: 687b         	ldr	r3, [r7, #0x4]
 8003266: 2201         	movs	r2, #0x1
 8003268: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->temp_vector_data[0] = 2 * (q1 * q3 - q0 * q2);
 800326c: 4baa         	ldr	r3, [pc, #0x2a8]        @ 0x8003518 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 800326e: ed93 7a00    	vldr	s14, [r3]
 8003272: 4bab         	ldr	r3, [pc, #0x2ac]        @ 0x8003520 <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 8003274: edd3 7a00    	vldr	s15, [r3]
 8003278: ee27 7a27    	vmul.f32	s14, s14, s15
 800327c: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8003514 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 800327e: edd3 6a00    	vldr	s13, [r3]
 8003282: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x800351c <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 8003284: edd3 7a00    	vldr	s15, [r3]
 8003288: ee66 7aa7    	vmul.f32	s15, s13, s15
 800328c: ee77 7a67    	vsub.f32	s15, s14, s15
 8003290: 687b         	ldr	r3, [r7, #0x4]
 8003292: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 8003296: ee77 7aa7    	vadd.f32	s15, s15, s15
 800329a: edc3 7a00    	vstr	s15, [r3]
; 	kf->temp_vector_data[1] = 2 * (q0 * q1 + q2 * q3);
 800329e: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x8003514 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 80032a0: ed93 7a00    	vldr	s14, [r3]
 80032a4: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8003518 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 80032a6: edd3 7a00    	vldr	s15, [r3]
 80032aa: ee27 7a27    	vmul.f32	s14, s14, s15
 80032ae: 4b9b         	ldr	r3, [pc, #0x26c]        @ 0x800351c <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 80032b0: edd3 6a00    	vldr	s13, [r3]
 80032b4: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x8003520 <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 80032b6: edd3 7a00    	vldr	s15, [r3]
 80032ba: ee66 7aa7    	vmul.f32	s15, s13, s15
 80032be: ee77 7a27    	vadd.f32	s15, s14, s15
 80032c2: 687b         	ldr	r3, [r7, #0x4]
 80032c4: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 80032c8: 3304         	adds	r3, #0x4
 80032ca: ee77 7aa7    	vadd.f32	s15, s15, s15
 80032ce: edc3 7a00    	vstr	s15, [r3]
; 		q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3; // temp_vector = h(xhat'(k))
 80032d2: 4b90         	ldr	r3, [pc, #0x240]        @ 0x8003514 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 80032d4: ed93 7a00    	vldr	s14, [r3]
 80032d8: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8003514 <IMU_QuaternionEKF_xhatUpdate+0x3d4>
 80032da: edd3 7a00    	vldr	s15, [r3]
 80032de: ee27 7a27    	vmul.f32	s14, s14, s15
 80032e2: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8003518 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 80032e4: edd3 6a00    	vldr	s13, [r3]
 80032e8: 4b8b         	ldr	r3, [pc, #0x22c]        @ 0x8003518 <IMU_QuaternionEKF_xhatUpdate+0x3d8>
 80032ea: edd3 7a00    	vldr	s15, [r3]
 80032ee: ee66 7aa7    	vmul.f32	s15, s13, s15
 80032f2: ee37 7a67    	vsub.f32	s14, s14, s15
 80032f6: 4b89         	ldr	r3, [pc, #0x224]        @ 0x800351c <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 80032f8: edd3 6a00    	vldr	s13, [r3]
 80032fc: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x800351c <IMU_QuaternionEKF_xhatUpdate+0x3dc>
 80032fe: edd3 7a00    	vldr	s15, [r3]
 8003302: ee66 7aa7    	vmul.f32	s15, s13, s15
 8003306: ee37 7a67    	vsub.f32	s14, s14, s15
 800330a: 4b85         	ldr	r3, [pc, #0x214]        @ 0x8003520 <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 800330c: edd3 6a00    	vldr	s13, [r3]
 8003310: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x8003520 <IMU_QuaternionEKF_xhatUpdate+0x3e0>
 8003312: edd3 7a00    	vldr	s15, [r3]
 8003316: ee66 7aa7    	vmul.f32	s15, s13, s15
; 	kf->temp_vector_data[2] =
 800331a: 687b         	ldr	r3, [r7, #0x4]
 800331c: f8d3 312c    	ldr.w	r3, [r3, #0x12c]
 8003320: 3308         	adds	r3, #0x8
; 		q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3; // temp_vector = h(xhat'(k))
 8003322: ee77 7a27    	vadd.f32	s15, s14, s15
; 	kf->temp_vector_data[2] =
 8003326: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 3; ++i) {
 800332a: 2300         	movs	r3, #0x0
 800332c: 75fb         	strb	r3, [r7, #0x17]
 800332e: e021         	b	0x8003374 <IMU_QuaternionEKF_xhatUpdate+0x234> @ imm = #0x42
; 		QEKF_INS.OrientationCosine[i] = acosf(fabsf(kf->temp_vector_data[i]));
 8003330: 687b         	ldr	r3, [r7, #0x4]
 8003332: f8d3 212c    	ldr.w	r2, [r3, #0x12c]
 8003336: 7dfb         	ldrb	r3, [r7, #0x17]
 8003338: 009b         	lsls	r3, r3, #0x2
 800333a: 4413         	add	r3, r2
 800333c: 681b         	ldr	r3, [r3]
 800333e: 60fb         	str	r3, [r7, #0xc]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 8003340: edd7 7a03    	vldr	s15, [r7, #12]
 8003344: eef0 7ae7    	vabs.f32	s15, s15
 8003348: edc7 7a02    	vstr	s15, [r7, #8]
;     return result;
 800334c: edd7 7a02    	vldr	s15, [r7, #8]
; 		QEKF_INS.OrientationCosine[i] = acosf(fabsf(kf->temp_vector_data[i]));
 8003350: 7dfe         	ldrb	r6, [r7, #0x17]
 8003352: eeb0 0a67    	vmov.f32	s0, s15
 8003356: f010 ff7d    	bl	0x8014254 <acosf>       @ imm = #0x10efa
 800335a: eef0 7a40    	vmov.f32	s15, s0
 800335e: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8003360: f106 0360    	add.w	r3, r6, #0x60
 8003364: 009b         	lsls	r3, r3, #0x2
 8003366: 4413         	add	r3, r2
 8003368: 3304         	adds	r3, #0x4
 800336a: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 3; ++i) {
 800336e: 7dfb         	ldrb	r3, [r7, #0x17]
 8003370: 3301         	adds	r3, #0x1
 8003372: 75fb         	strb	r3, [r7, #0x17]
 8003374: 7dfb         	ldrb	r3, [r7, #0x17]
 8003376: 2b02         	cmp	r3, #0x2
 8003378: d9da         	bls	0x8003330 <IMU_QuaternionEKF_xhatUpdate+0x1f0> @ imm = #-0x4c
; 	kf->temp_vector1.numRows = kf->z.numRows;
 800337a: 687b         	ldr	r3, [r7, #0x4]
 800337c: f8b3 2048    	ldrh.w	r2, [r3, #0x48]
 8003380: 687b         	ldr	r3, [r7, #0x4]
 8003382: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 	kf->temp_vector1.numCols = 1;
 8003386: 687b         	ldr	r3, [r7, #0x4]
 8003388: 2201         	movs	r2, #0x1
 800338a: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 	kf->MatStatus = Matrix_Subtract(&kf->z, &kf->temp_vector,
 800338e: 687b         	ldr	r3, [r7, #0x4]
 8003390: f103 0048    	add.w	r0, r3, #0x48
 8003394: 687b         	ldr	r3, [r7, #0x4]
 8003396: f103 01b8    	add.w	r1, r3, #0xb8
 800339a: 687b         	ldr	r3, [r7, #0x4]
 800339c: 33c0         	adds	r3, #0xc0
 800339e: 461a         	mov	r2, r3
 80033a0: f00b faa4    	bl	0x800e8ec <arm_mat_sub_f32> @ imm = #0xb548
 80033a4: 4603         	mov	r3, r0
 80033a6: 461a         	mov	r2, r3
 80033a8: 687b         	ldr	r3, [r7, #0x4]
 80033aa: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_matrix.numRows = kf->temp_vector1.numRows;
 80033ae: 687b         	ldr	r3, [r7, #0x4]
 80033b0: f8b3 20c0    	ldrh.w	r2, [r3, #0xc0]
 80033b4: 687b         	ldr	r3, [r7, #0x4]
 80033b6: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = 1;
 80033ba: 687b         	ldr	r3, [r7, #0x4]
 80033bc: 2201         	movs	r2, #0x1
 80033be: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		&kf->temp_matrix1, &kf->temp_vector1,
 80033c2: 687b         	ldr	r3, [r7, #0x4]
 80033c4: f103 00b0    	add.w	r0, r3, #0xb0
 80033c8: 687b         	ldr	r3, [r7, #0x4]
 80033ca: f103 01c0    	add.w	r1, r3, #0xc0
; 	kf->MatStatus = Matrix_Multiply(
 80033ce: 687b         	ldr	r3, [r7, #0x4]
 80033d0: 33a8         	adds	r3, #0xa8
 80033d2: 461a         	mov	r2, r3
 80033d4: f00b fa30    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #0xb460
 80033d8: 4603         	mov	r3, r0
 80033da: 461a         	mov	r2, r3
 80033dc: 687b         	ldr	r3, [r7, #0x4]
 80033de: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->temp_vector.numRows = 1;
 80033e2: 687b         	ldr	r3, [r7, #0x4]
 80033e4: 2201         	movs	r2, #0x1
 80033e6: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = kf->temp_vector1.numRows;
 80033ea: 687b         	ldr	r3, [r7, #0x4]
 80033ec: f8b3 20c0    	ldrh.w	r2, [r3, #0xc0]
 80033f0: 687b         	ldr	r3, [r7, #0x4]
 80033f2: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->MatStatus = Matrix_Transpose(&kf->temp_vector1,
 80033f6: 687b         	ldr	r3, [r7, #0x4]
 80033f8: f103 02c0    	add.w	r2, r3, #0xc0
 80033fc: 687b         	ldr	r3, [r7, #0x4]
 80033fe: 33b8         	adds	r3, #0xb8
 8003400: 4619         	mov	r1, r3
 8003402: 4610         	mov	r0, r2
 8003404: f00b fa88    	bl	0x800e918 <arm_mat_trans_f32> @ imm = #0xb510
 8003408: 4603         	mov	r3, r0
 800340a: 461a         	mov	r2, r3
 800340c: 687b         	ldr	r3, [r7, #0x4]
 800340e: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_vector, &kf->temp_matrix, &QEKF_INS.ChiSquare);
 8003412: 687b         	ldr	r3, [r7, #0x4]
 8003414: f103 00b8    	add.w	r0, r3, #0xb8
 8003418: 687b         	ldr	r3, [r7, #0x4]
 800341a: 33a8         	adds	r3, #0xa8
 800341c: 4a42         	ldr	r2, [pc, #0x108]        @ 0x8003528 <IMU_QuaternionEKF_xhatUpdate+0x3e8>
 800341e: 4619         	mov	r1, r3
 8003420: f00b fa0a    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #0xb414
 8003424: 4603         	mov	r3, r0
 8003426: 461a         	mov	r2, r3
 8003428: 687b         	ldr	r3, [r7, #0x4]
 800342a: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	if (QEKF_INS.ChiSquare_Data[0] < 0.5f * QEKF_INS.ChiSquareTestThreshold) {
 800342e: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8003430: ed93 7a72    	vldr	s14, [r3, #456]
 8003434: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8003436: edd3 7a73    	vldr	s15, [r3, #460]
 800343a: eef6 6a00    	vmov.f32	s13, #5.000000e-01
 800343e: ee67 7aa6    	vmul.f32	s15, s15, s13
 8003442: eeb4 7ae7    	vcmpe.f32	s14, s15
 8003446: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800344a: d503         	bpl	0x8003454 <IMU_QuaternionEKF_xhatUpdate+0x314> @ imm = #0x6
; 		QEKF_INS.ConvergeFlag = 1;
 800344c: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800344e: 2201         	movs	r2, #0x1
 8003450: f883 2138    	strb.w	r2, [r3, #0x138]
; 	if (QEKF_INS.ChiSquare_Data[0] > QEKF_INS.ChiSquareTestThreshold && QEKF_INS.ConvergeFlag) {
 8003454: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8003456: ed93 7a72    	vldr	s14, [r3, #456]
 800345a: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800345c: edd3 7a73    	vldr	s15, [r3, #460]
 8003460: eeb4 7ae7    	vcmpe.f32	s14, s15
 8003464: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003468: dd62         	ble	0x8003530 <IMU_QuaternionEKF_xhatUpdate+0x3f0> @ imm = #0xc4
 800346a: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800346c: f893 3138    	ldrb.w	r3, [r3, #0x138]
 8003470: 2b00         	cmp	r3, #0x0
 8003472: d05d         	beq	0x8003530 <IMU_QuaternionEKF_xhatUpdate+0x3f0> @ imm = #0xba
; 		if (QEKF_INS.StableFlag) {
 8003474: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8003476: f893 3139    	ldrb.w	r3, [r3, #0x139]
 800347a: 2b00         	cmp	r3, #0x0
 800347c: d009         	beq	0x8003492 <IMU_QuaternionEKF_xhatUpdate+0x352> @ imm = #0x12
; 			QEKF_INS.ErrorCount++; // 载体静止时仍无法通过卡方检验
 800347e: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8003480: e9d3 2350    	ldrd	r2, r3, [r3, #320]
 8003484: 1c54         	adds	r4, r2, #0x1
 8003486: f143 0500    	adc	r5, r3, #0x0
 800348a: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 800348c: e9c3 4550    	strd	r4, r5, [r3, #320]
 8003490: e006         	b	0x80034a0 <IMU_QuaternionEKF_xhatUpdate+0x360> @ imm = #0xc
; 			QEKF_INS.ErrorCount = 0;
 8003492: 4924         	ldr	r1, [pc, #0x90]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 8003494: f04f 0200    	mov.w	r2, #0x0
 8003498: f04f 0300    	mov.w	r3, #0x0
 800349c: e9c1 2350    	strd	r2, r3, [r1, #320]
; 		if (QEKF_INS.ErrorCount > 50) {
 80034a0: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 80034a2: e9d3 2350    	ldrd	r2, r3, [r3, #320]
 80034a6: 2a33         	cmp	r2, #0x33
 80034a8: f173 0300    	sbcs	r3, r3, #0x0
 80034ac: d308         	blo	0x80034c0 <IMU_QuaternionEKF_xhatUpdate+0x380> @ imm = #0x10
; 			QEKF_INS.ConvergeFlag = 0;
 80034ae: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8003524 <IMU_QuaternionEKF_xhatUpdate+0x3e4>
 80034b0: 2200         	movs	r2, #0x0
 80034b2: f883 2138    	strb.w	r2, [r3, #0x138]
; 			kf->SkipEq5 = FALSE; // step-5 is cov mat P updating
 80034b6: 687b         	ldr	r3, [r7, #0x4]
 80034b8: 2200         	movs	r2, #0x0
 80034ba: f883 202c    	strb.w	r2, [r3, #0x2c]
; 		if (QEKF_INS.ErrorCount > 50) {
 80034be: e070         	b	0x80035a2 <IMU_QuaternionEKF_xhatUpdate+0x462> @ imm = #0xe0
; 			memcpy(kf->xhat_data, kf->xhatminus_data, sizeof_float * kf->xhatSize);
 80034c0: 687b         	ldr	r3, [r7, #0x4]
 80034c2: f8d3 00e8    	ldr.w	r0, [r3, #0xe8]
 80034c6: 687b         	ldr	r3, [r7, #0x4]
 80034c8: f8d3 10ec    	ldr.w	r1, [r3, #0xec]
 80034cc: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800352c <IMU_QuaternionEKF_xhatUpdate+0x3ec>
 80034ce: 881b         	ldrh	r3, [r3]
 80034d0: 461a         	mov	r2, r3
 80034d2: 687b         	ldr	r3, [r7, #0x4]
 80034d4: 7b1b         	ldrb	r3, [r3, #0xc]
 80034d6: fb02 f303    	mul	r3, r2, r3
 80034da: 461a         	mov	r2, r3
 80034dc: f01c fbee    	bl	0x801fcbc <memcpy>      @ imm = #0x1c7dc
; 			memcpy(kf->P_data, kf->Pminus_data,
 80034e0: 687b         	ldr	r3, [r7, #0x4]
 80034e2: f8d3 00f8    	ldr.w	r0, [r3, #0xf8]
 80034e6: 687b         	ldr	r3, [r7, #0x4]
 80034e8: f8d3 10fc    	ldr.w	r1, [r3, #0xfc]
; 			       sizeof_float * kf->xhatSize * kf->xhatSize);
 80034ec: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800352c <IMU_QuaternionEKF_xhatUpdate+0x3ec>
 80034ee: 881b         	ldrh	r3, [r3]
 80034f0: 461a         	mov	r2, r3
 80034f2: 687b         	ldr	r3, [r7, #0x4]
 80034f4: 7b1b         	ldrb	r3, [r3, #0xc]
 80034f6: fb02 f303    	mul	r3, r2, r3
 80034fa: 687a         	ldr	r2, [r7, #0x4]
 80034fc: 7b12         	ldrb	r2, [r2, #0xc]
 80034fe: fb02 f303    	mul	r3, r2, r3
; 			memcpy(kf->P_data, kf->Pminus_data,
 8003502: 461a         	mov	r2, r3
 8003504: f01c fbda    	bl	0x801fcbc <memcpy>      @ imm = #0x1c7b4
; 			kf->SkipEq5 = TRUE; // part5 is P updating
 8003508: 687b         	ldr	r3, [r7, #0x4]
 800350a: 2201         	movs	r2, #0x1
 800350c: f883 202c    	strb.w	r2, [r3, #0x2c]
; 			return;
 8003510: e15a         	b	0x80037c8 <IMU_QuaternionEKF_xhatUpdate+0x688> @ imm = #0x2b4
 8003512: bf00         	nop

08003514 <$d>:
 8003514: 40 24 00 20  	.word	0x20002440
 8003518: 44 24 00 20  	.word	0x20002444
 800351c: 48 24 00 20  	.word	0x20002448
 8003520: 4c 24 00 20  	.word	0x2000244c
 8003524: a0 07 00 20  	.word	0x200007a0
 8003528: 60 09 00 20  	.word	0x20000960
 800352c: f4 27 00 20  	.word	0x200027f4

08003530 <$t>:
; 		if (QEKF_INS.ChiSquare_Data[0] > 0.1f * QEKF_INS.ChiSquareTestThreshold &&
 8003530: 4ba7         	ldr	r3, [pc, #0x29c]        @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8003532: ed93 7a72    	vldr	s14, [r3, #456]
 8003536: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8003538: edd3 7a73    	vldr	s15, [r3, #460]
 800353c: eddf 6aa5    	vldr	s13, [pc, #660]         @ 0x80037d4 <IMU_QuaternionEKF_xhatUpdate+0x694>
 8003540: ee67 7aa6    	vmul.f32	s15, s15, s13
 8003544: eeb4 7ae7    	vcmpe.f32	s14, s15
 8003548: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800354c: dd19         	ble	0x8003582 <IMU_QuaternionEKF_xhatUpdate+0x442> @ imm = #0x32
; 		    QEKF_INS.ConvergeFlag) {
 800354e: 4ba0         	ldr	r3, [pc, #0x280]        @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8003550: f893 3138    	ldrb.w	r3, [r3, #0x138]
; 		if (QEKF_INS.ChiSquare_Data[0] > 0.1f * QEKF_INS.ChiSquareTestThreshold &&
 8003554: 2b00         	cmp	r3, #0x0
 8003556: d014         	beq	0x8003582 <IMU_QuaternionEKF_xhatUpdate+0x442> @ imm = #0x28
; 				(QEKF_INS.ChiSquareTestThreshold - QEKF_INS.ChiSquare_Data[0]) /
 8003558: 4b9d         	ldr	r3, [pc, #0x274]        @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 800355a: ed93 7a73    	vldr	s14, [r3, #460]
 800355e: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8003560: edd3 7a72    	vldr	s15, [r3, #456]
 8003564: ee77 6a67    	vsub.f32	s13, s14, s15
; 				(0.9f * QEKF_INS.ChiSquareTestThreshold);
 8003568: 4b99         	ldr	r3, [pc, #0x264]        @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 800356a: edd3 7a73    	vldr	s15, [r3, #460]
 800356e: ed9f 7a9a    	vldr	s14, [pc, #616]         @ 0x80037d8 <IMU_QuaternionEKF_xhatUpdate+0x698>
 8003572: ee27 7a87    	vmul.f32	s14, s15, s14
; 				(QEKF_INS.ChiSquareTestThreshold - QEKF_INS.ChiSquare_Data[0]) /
 8003576: eec6 7a87    	vdiv.f32	s15, s13, s14
; 			QEKF_INS.AdaptiveGainScale =
 800357a: 4b95         	ldr	r3, [pc, #0x254]        @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 800357c: edc3 7a67    	vstr	s15, [r3, #412]
 8003580: e004         	b	0x800358c <IMU_QuaternionEKF_xhatUpdate+0x44c> @ imm = #0x8
; 			QEKF_INS.AdaptiveGainScale = 1;
 8003582: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8003584: f04f 527e    	mov.w	r2, #0x3f800000
 8003588: f8c3 219c    	str.w	r2, [r3, #0x19c]
; 		QEKF_INS.ErrorCount = 0;
 800358c: 4990         	ldr	r1, [pc, #0x240]        @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 800358e: f04f 0200    	mov.w	r2, #0x0
 8003592: f04f 0300    	mov.w	r3, #0x0
 8003596: e9c1 2350    	strd	r2, r3, [r1, #320]
; 		kf->SkipEq5 = FALSE;
 800359a: 687b         	ldr	r3, [r7, #0x4]
 800359c: 2200         	movs	r2, #0x0
 800359e: f883 202c    	strb.w	r2, [r3, #0x2c]
; 	kf->temp_matrix.numRows = kf->Pminus.numRows;
 80035a2: 687b         	ldr	r3, [r7, #0x4]
 80035a4: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 80035a8: 687b         	ldr	r3, [r7, #0x4]
 80035aa: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 	kf->temp_matrix.numCols = kf->HT.numCols;
 80035ae: 687b         	ldr	r3, [r7, #0x4]
 80035b0: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 80035b4: 687b         	ldr	r3, [r7, #0x4]
 80035b6: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		Matrix_Multiply(&kf->Pminus, &kf->HT, &kf->temp_matrix); // temp_matrix = P'(k)·HT
 80035ba: 687b         	ldr	r3, [r7, #0x4]
 80035bc: f103 0058    	add.w	r0, r3, #0x58
 80035c0: 687b         	ldr	r3, [r7, #0x4]
 80035c2: f103 0180    	add.w	r1, r3, #0x80
 80035c6: 687b         	ldr	r3, [r7, #0x4]
 80035c8: 33a8         	adds	r3, #0xa8
 80035ca: 461a         	mov	r2, r3
 80035cc: f00b f934    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #0xb268
 80035d0: 4603         	mov	r3, r0
 80035d2: 461a         	mov	r2, r3
; 	kf->MatStatus =
 80035d4: 687b         	ldr	r3, [r7, #0x4]
 80035d6: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->temp_matrix1, &kf->K);
 80035da: 687b         	ldr	r3, [r7, #0x4]
 80035dc: f103 00a8    	add.w	r0, r3, #0xa8
 80035e0: 687b         	ldr	r3, [r7, #0x4]
 80035e2: f103 01b0    	add.w	r1, r3, #0xb0
 80035e6: 687b         	ldr	r3, [r7, #0x4]
 80035e8: 3398         	adds	r3, #0x98
 80035ea: 461a         	mov	r2, r3
 80035ec: f00b f924    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #0xb248
 80035f0: 4603         	mov	r3, r0
 80035f2: 461a         	mov	r2, r3
 80035f4: 687b         	ldr	r3, [r7, #0x4]
 80035f6: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	for (uint8_t i = 0; i < kf->K.numRows * kf->K.numCols; ++i) {
 80035fa: 2300         	movs	r3, #0x0
 80035fc: 75bb         	strb	r3, [r7, #0x16]
 80035fe: e017         	b	0x8003630 <IMU_QuaternionEKF_xhatUpdate+0x4f0> @ imm = #0x2e
; 		kf->K_data[i] *= QEKF_INS.AdaptiveGainScale;
 8003600: 687b         	ldr	r3, [r7, #0x4]
 8003602: f8d3 211c    	ldr.w	r2, [r3, #0x11c]
 8003606: 7dbb         	ldrb	r3, [r7, #0x16]
 8003608: 009b         	lsls	r3, r3, #0x2
 800360a: 4413         	add	r3, r2
 800360c: ed93 7a00    	vldr	s14, [r3]
 8003610: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8003612: edd3 7a67    	vldr	s15, [r3, #412]
 8003616: 687b         	ldr	r3, [r7, #0x4]
 8003618: f8d3 211c    	ldr.w	r2, [r3, #0x11c]
 800361c: 7dbb         	ldrb	r3, [r7, #0x16]
 800361e: 009b         	lsls	r3, r3, #0x2
 8003620: 4413         	add	r3, r2
 8003622: ee67 7a27    	vmul.f32	s15, s14, s15
 8003626: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < kf->K.numRows * kf->K.numCols; ++i) {
 800362a: 7dbb         	ldrb	r3, [r7, #0x16]
 800362c: 3301         	adds	r3, #0x1
 800362e: 75bb         	strb	r3, [r7, #0x16]
 8003630: 7dba         	ldrb	r2, [r7, #0x16]
 8003632: 687b         	ldr	r3, [r7, #0x4]
 8003634: f8b3 3098    	ldrh.w	r3, [r3, #0x98]
 8003638: 4619         	mov	r1, r3
 800363a: 687b         	ldr	r3, [r7, #0x4]
 800363c: f8b3 309a    	ldrh.w	r3, [r3, #0x9a]
 8003640: fb01 f303    	mul	r3, r1, r3
 8003644: 429a         	cmp	r2, r3
 8003646: dbdb         	blt	0x8003600 <IMU_QuaternionEKF_xhatUpdate+0x4c0> @ imm = #-0x4a
; 	for (uint8_t i = 4; i < 6; ++i) {
 8003648: 2304         	movs	r3, #0x4
 800364a: 757b         	strb	r3, [r7, #0x15]
 800364c: e034         	b	0x80036b8 <IMU_QuaternionEKF_xhatUpdate+0x578> @ imm = #0x68
; 		for (uint8_t j = 0; j < 3; ++j) {
 800364e: 2300         	movs	r3, #0x0
 8003650: 753b         	strb	r3, [r7, #0x14]
 8003652: e02b         	b	0x80036ac <IMU_QuaternionEKF_xhatUpdate+0x56c> @ imm = #0x56
; 			kf->K_data[i * 3 + j] *=
 8003654: 687b         	ldr	r3, [r7, #0x4]
 8003656: f8d3 111c    	ldr.w	r1, [r3, #0x11c]
 800365a: 7d7a         	ldrb	r2, [r7, #0x15]
 800365c: 4613         	mov	r3, r2
 800365e: 005b         	lsls	r3, r3, #0x1
 8003660: 441a         	add	r2, r3
 8003662: 7d3b         	ldrb	r3, [r7, #0x14]
 8003664: 4413         	add	r3, r2
 8003666: 009b         	lsls	r3, r3, #0x2
 8003668: 440b         	add	r3, r1
 800366a: ed93 7a00    	vldr	s14, [r3]
; 				QEKF_INS.OrientationCosine[i - 4] / 1.5707963f; // 1 rad
 800366e: 7d7b         	ldrb	r3, [r7, #0x15]
 8003670: 3b04         	subs	r3, #0x4
 8003672: 4a57         	ldr	r2, [pc, #0x15c]        @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8003674: 3360         	adds	r3, #0x60
 8003676: 009b         	lsls	r3, r3, #0x2
 8003678: 4413         	add	r3, r2
 800367a: 3304         	adds	r3, #0x4
 800367c: edd3 6a00    	vldr	s13, [r3]
 8003680: ed9f 6a56    	vldr	s12, [pc, #344]         @ 0x80037dc <IMU_QuaternionEKF_xhatUpdate+0x69c>
 8003684: eec6 7a86    	vdiv.f32	s15, s13, s12
; 			kf->K_data[i * 3 + j] *=
 8003688: 687b         	ldr	r3, [r7, #0x4]
 800368a: f8d3 111c    	ldr.w	r1, [r3, #0x11c]
 800368e: 7d7a         	ldrb	r2, [r7, #0x15]
 8003690: 4613         	mov	r3, r2
 8003692: 005b         	lsls	r3, r3, #0x1
 8003694: 441a         	add	r2, r3
 8003696: 7d3b         	ldrb	r3, [r7, #0x14]
 8003698: 4413         	add	r3, r2
 800369a: 009b         	lsls	r3, r3, #0x2
 800369c: 440b         	add	r3, r1
 800369e: ee67 7a27    	vmul.f32	s15, s14, s15
 80036a2: edc3 7a00    	vstr	s15, [r3]
; 		for (uint8_t j = 0; j < 3; ++j) {
 80036a6: 7d3b         	ldrb	r3, [r7, #0x14]
 80036a8: 3301         	adds	r3, #0x1
 80036aa: 753b         	strb	r3, [r7, #0x14]
 80036ac: 7d3b         	ldrb	r3, [r7, #0x14]
 80036ae: 2b02         	cmp	r3, #0x2
 80036b0: d9d0         	bls	0x8003654 <IMU_QuaternionEKF_xhatUpdate+0x514> @ imm = #-0x60
; 	for (uint8_t i = 4; i < 6; ++i) {
 80036b2: 7d7b         	ldrb	r3, [r7, #0x15]
 80036b4: 3301         	adds	r3, #0x1
 80036b6: 757b         	strb	r3, [r7, #0x15]
 80036b8: 7d7b         	ldrb	r3, [r7, #0x15]
 80036ba: 2b05         	cmp	r3, #0x5
 80036bc: d9c7         	bls	0x800364e <IMU_QuaternionEKF_xhatUpdate+0x50e> @ imm = #-0x72
; 	kf->temp_vector.numRows = kf->K.numRows;
 80036be: 687b         	ldr	r3, [r7, #0x4]
 80036c0: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 80036c4: 687b         	ldr	r3, [r7, #0x4]
 80036c6: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 	kf->temp_vector.numCols = 1;
 80036ca: 687b         	ldr	r3, [r7, #0x4]
 80036cc: 2201         	movs	r2, #0x1
 80036ce: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 	kf->MatStatus = Matrix_Multiply(&kf->K, &kf->temp_vector1,
 80036d2: 687b         	ldr	r3, [r7, #0x4]
 80036d4: f103 0098    	add.w	r0, r3, #0x98
 80036d8: 687b         	ldr	r3, [r7, #0x4]
 80036da: f103 01c0    	add.w	r1, r3, #0xc0
 80036de: 687b         	ldr	r3, [r7, #0x4]
 80036e0: 33b8         	adds	r3, #0xb8
 80036e2: 461a         	mov	r2, r3
 80036e4: f00b f8a8    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #0xb150
 80036e8: 4603         	mov	r3, r0
 80036ea: 461a         	mov	r2, r3
 80036ec: 687b         	ldr	r3, [r7, #0x4]
 80036ee: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 	if (QEKF_INS.ConvergeFlag) {
 80036f2: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 80036f4: f893 3138    	ldrb.w	r3, [r3, #0x138]
 80036f8: 2b00         	cmp	r3, #0x0
 80036fa: d04e         	beq	0x800379a <IMU_QuaternionEKF_xhatUpdate+0x65a> @ imm = #0x9c
; 		for (uint8_t i = 4; i < 6; ++i) {
 80036fc: 2304         	movs	r3, #0x4
 80036fe: 74fb         	strb	r3, [r7, #0x13]
 8003700: e048         	b	0x8003794 <IMU_QuaternionEKF_xhatUpdate+0x654> @ imm = #0x90
; 			if (kf->temp_vector.pData[i] > 1e-2f * QEKF_INS.dt) {
 8003702: 687b         	ldr	r3, [r7, #0x4]
 8003704: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8003708: 7cfb         	ldrb	r3, [r7, #0x13]
 800370a: 009b         	lsls	r3, r3, #0x2
 800370c: 4413         	add	r3, r2
 800370e: ed93 7a00    	vldr	s14, [r3]
 8003712: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8003714: edd3 7a6f    	vldr	s15, [r3, #444]
 8003718: eddf 6a31    	vldr	s13, [pc, #196]         @ 0x80037e0 <IMU_QuaternionEKF_xhatUpdate+0x6a0>
 800371c: ee67 7aa6    	vmul.f32	s15, s15, s13
 8003720: eeb4 7ae7    	vcmpe.f32	s14, s15
 8003724: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003728: dd0e         	ble	0x8003748 <IMU_QuaternionEKF_xhatUpdate+0x608> @ imm = #0x1c
; 				kf->temp_vector.pData[i] = 1e-2f * QEKF_INS.dt;
 800372a: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 800372c: edd3 7a6f    	vldr	s15, [r3, #444]
 8003730: 687b         	ldr	r3, [r7, #0x4]
 8003732: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 8003736: 7cfb         	ldrb	r3, [r7, #0x13]
 8003738: 009b         	lsls	r3, r3, #0x2
 800373a: 4413         	add	r3, r2
 800373c: ed9f 7a28    	vldr	s14, [pc, #160]         @ 0x80037e0 <IMU_QuaternionEKF_xhatUpdate+0x6a0>
 8003740: ee67 7a87    	vmul.f32	s15, s15, s14
 8003744: edc3 7a00    	vstr	s15, [r3]
; 			if (kf->temp_vector.pData[i] < -1e-2f * QEKF_INS.dt) {
 8003748: 687b         	ldr	r3, [r7, #0x4]
 800374a: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 800374e: 7cfb         	ldrb	r3, [r7, #0x13]
 8003750: 009b         	lsls	r3, r3, #0x2
 8003752: 4413         	add	r3, r2
 8003754: ed93 7a00    	vldr	s14, [r3]
 8003758: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 800375a: edd3 7a6f    	vldr	s15, [r3, #444]
 800375e: eddf 6a21    	vldr	s13, [pc, #132]         @ 0x80037e4 <IMU_QuaternionEKF_xhatUpdate+0x6a4>
 8003762: ee67 7aa6    	vmul.f32	s15, s15, s13
 8003766: eeb4 7ae7    	vcmpe.f32	s14, s15
 800376a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800376e: d50e         	bpl	0x800378e <IMU_QuaternionEKF_xhatUpdate+0x64e> @ imm = #0x1c
; 				kf->temp_vector.pData[i] = -1e-2f * QEKF_INS.dt;
 8003770: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80037d0 <IMU_QuaternionEKF_xhatUpdate+0x690>
 8003772: edd3 7a6f    	vldr	s15, [r3, #444]
 8003776: 687b         	ldr	r3, [r7, #0x4]
 8003778: f8d3 20bc    	ldr.w	r2, [r3, #0xbc]
 800377c: 7cfb         	ldrb	r3, [r7, #0x13]
 800377e: 009b         	lsls	r3, r3, #0x2
 8003780: 4413         	add	r3, r2
 8003782: ed9f 7a18    	vldr	s14, [pc, #96]          @ 0x80037e4 <IMU_QuaternionEKF_xhatUpdate+0x6a4>
 8003786: ee67 7a87    	vmul.f32	s15, s15, s14
 800378a: edc3 7a00    	vstr	s15, [r3]
; 		for (uint8_t i = 4; i < 6; ++i) {
 800378e: 7cfb         	ldrb	r3, [r7, #0x13]
 8003790: 3301         	adds	r3, #0x1
 8003792: 74fb         	strb	r3, [r7, #0x13]
 8003794: 7cfb         	ldrb	r3, [r7, #0x13]
 8003796: 2b05         	cmp	r3, #0x5
 8003798: d9b3         	bls	0x8003702 <IMU_QuaternionEKF_xhatUpdate+0x5c2> @ imm = #-0x9a
; 	kf->temp_vector.pData[3] = 0;
 800379a: 687b         	ldr	r3, [r7, #0x4]
 800379c: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 80037a0: 330c         	adds	r3, #0xc
 80037a2: f04f 0200    	mov.w	r2, #0x0
 80037a6: 601a         	str	r2, [r3]
; 	kf->MatStatus = Matrix_Add(&kf->xhatminus, &kf->temp_vector, &kf->xhat);
 80037a8: 687b         	ldr	r3, [r7, #0x4]
 80037aa: f103 0038    	add.w	r0, r3, #0x38
 80037ae: 687b         	ldr	r3, [r7, #0x4]
 80037b0: f103 01b8    	add.w	r1, r3, #0xb8
 80037b4: 687b         	ldr	r3, [r7, #0x4]
 80037b6: 3330         	adds	r3, #0x30
 80037b8: 461a         	mov	r2, r3
 80037ba: f00a fea1    	bl	0x800e500 <arm_mat_add_f32> @ imm = #0xad42
 80037be: 4603         	mov	r3, r0
 80037c0: 461a         	mov	r2, r3
 80037c2: 687b         	ldr	r3, [r7, #0x4]
 80037c4: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 80037c8: 371c         	adds	r7, #0x1c
 80037ca: 46bd         	mov	sp, r7
 80037cc: bdf0         	pop	{r4, r5, r6, r7, pc}
 80037ce: bf00         	nop

080037d0 <$d>:
 80037d0: a0 07 00 20  	.word	0x200007a0
 80037d4: cd cc cc 3d  	.word	0x3dcccccd
 80037d8: 66 66 66 3f  	.word	0x3f666666
 80037dc: da 0f c9 3f  	.word	0x3fc90fda
 80037e0: 0a d7 23 3c  	.word	0x3c23d70a
 80037e4: 0a d7 23 bc  	.word	0xbc23d70a

080037e8 <IMU_QuaternionEKF_Observe>:
; {
 80037e8: b580         	push	{r7, lr}
 80037ea: b082         	sub	sp, #0x8
 80037ec: af00         	add	r7, sp, #0x0
 80037ee: 6078         	str	r0, [r7, #0x4]
; 	memcpy(IMU_QuaternionEKF_P, kf->P_data, sizeof(IMU_QuaternionEKF_P));
 80037f0: 687b         	ldr	r3, [r7, #0x4]
 80037f2: f8d3 30f8    	ldr.w	r3, [r3, #0xf8]
 80037f6: 2290         	movs	r2, #0x90
 80037f8: 4619         	mov	r1, r3
 80037fa: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8003828 <IMU_QuaternionEKF_Observe+0x40>
 80037fc: f01c fa5e    	bl	0x801fcbc <memcpy>      @ imm = #0x1c4bc
; 	memcpy(IMU_QuaternionEKF_K, kf->K_data, sizeof(IMU_QuaternionEKF_K));
 8003800: 687b         	ldr	r3, [r7, #0x4]
 8003802: f8d3 311c    	ldr.w	r3, [r3, #0x11c]
 8003806: 2248         	movs	r2, #0x48
 8003808: 4619         	mov	r1, r3
 800380a: 4808         	ldr	r0, [pc, #0x20]         @ 0x800382c <IMU_QuaternionEKF_Observe+0x44>
 800380c: f01c fa56    	bl	0x801fcbc <memcpy>      @ imm = #0x1c4ac
; 	memcpy(IMU_QuaternionEKF_H, kf->H_data, sizeof(IMU_QuaternionEKF_H));
 8003810: 687b         	ldr	r3, [r7, #0x4]
 8003812: f8d3 310c    	ldr.w	r3, [r3, #0x10c]
 8003816: 2248         	movs	r2, #0x48
 8003818: 4619         	mov	r1, r3
 800381a: 4805         	ldr	r0, [pc, #0x14]         @ 0x8003830 <IMU_QuaternionEKF_Observe+0x48>
 800381c: f01c fa4e    	bl	0x801fcbc <memcpy>      @ imm = #0x1c49c
; }
 8003820: bf00         	nop
 8003822: 3708         	adds	r7, #0x8
 8003824: 46bd         	mov	sp, r7
 8003826: bd80         	pop	{r7, pc}

08003828 <$d>:
 8003828: 08 04 00 20  	.word	0x20000408
 800382c: 10 23 00 20  	.word	0x20002310
 8003830: 58 23 00 20  	.word	0x20002358

08003834 <invSqrt>:
; {
 8003834: b480         	push	{r7}
 8003836: b087         	sub	sp, #0x1c
 8003838: af00         	add	r7, sp, #0x0
 800383a: ed87 0a01    	vstr	s0, [r7, #4]
; 	float halfx = 0.5f * x;
 800383e: edd7 7a01    	vldr	s15, [r7, #4]
 8003842: eeb6 7a00    	vmov.f32	s14, #5.000000e-01
 8003846: ee67 7a87    	vmul.f32	s15, s15, s14
 800384a: edc7 7a05    	vstr	s15, [r7, #20]
; 	float y = x;
 800384e: 687b         	ldr	r3, [r7, #0x4]
 8003850: 613b         	str	r3, [r7, #0x10]
; 	long i = *(long *)&y;
 8003852: f107 0310    	add.w	r3, r7, #0x10
 8003856: 681b         	ldr	r3, [r3]
 8003858: 60fb         	str	r3, [r7, #0xc]
; 	i = 0x5f375a86 - (i >> 1);
 800385a: 68fb         	ldr	r3, [r7, #0xc]
 800385c: 105a         	asrs	r2, r3, #0x1
 800385e: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80038a8 <invSqrt+0x74>
 8003860: 1a9b         	subs	r3, r3, r2
 8003862: 60fb         	str	r3, [r7, #0xc]
; 	y = *(float *)&i;
 8003864: f107 030c    	add.w	r3, r7, #0xc
 8003868: 681b         	ldr	r3, [r3]
 800386a: 613b         	str	r3, [r7, #0x10]
; 	y = y * (1.5f - (halfx * y * y));
 800386c: ed97 7a04    	vldr	s14, [r7, #16]
 8003870: edd7 7a05    	vldr	s15, [r7, #20]
 8003874: ee27 7a27    	vmul.f32	s14, s14, s15
 8003878: edd7 7a04    	vldr	s15, [r7, #16]
 800387c: ee67 7a27    	vmul.f32	s15, s14, s15
 8003880: eeb7 7a08    	vmov.f32	s14, #1.500000e+00
 8003884: ee37 7a67    	vsub.f32	s14, s14, s15
 8003888: edd7 7a04    	vldr	s15, [r7, #16]
 800388c: ee67 7a27    	vmul.f32	s15, s14, s15
 8003890: edc7 7a04    	vstr	s15, [r7, #16]
; 	return y;
 8003894: 693b         	ldr	r3, [r7, #0x10]
 8003896: ee07 3a90    	vmov	s15, r3
; }
 800389a: eeb0 0a67    	vmov.f32	s0, s15
 800389e: 371c         	adds	r7, #0x1c
 80038a0: 46bd         	mov	sp, r7
 80038a2: f85d 7b04    	ldr	r7, [sp], #4
 80038a6: 4770         	bx	lr

080038a8 <$d>:
 80038a8: 86 5a 37 5f  	.word	0x5f375a86

080038ac <float_equal>:
; {
 80038ac: b480         	push	{r7}
 80038ae: b085         	sub	sp, #0x14
 80038b0: af00         	add	r7, sp, #0x0
 80038b2: ed87 0a01    	vstr	s0, [r7, #4]
 80038b6: edc7 0a00    	vstr	s1, [r7]
; 	return fabsf(a - b) < 0.0001f;
 80038ba: ed97 7a01    	vldr	s14, [r7, #4]
 80038be: edd7 7a00    	vldr	s15, [r7]
 80038c2: ee77 7a67    	vsub.f32	s15, s14, s15
 80038c6: edc7 7a03    	vstr	s15, [r7, #12]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 80038ca: edd7 7a03    	vldr	s15, [r7, #12]
 80038ce: eef0 7ae7    	vabs.f32	s15, s15
 80038d2: edc7 7a02    	vstr	s15, [r7, #8]
;     return result;
 80038d6: edd7 7a02    	vldr	s15, [r7, #8]
; 	return fabsf(a - b) < 0.0001f;
 80038da: ed9f 7a08    	vldr	s14, [pc, #32]          @ 0x80038fc <float_equal+0x50>
 80038de: eef4 7ac7    	vcmpe.f32	s15, s14
 80038e2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80038e6: bf4c         	ite	mi
 80038e8: 2301         	movmi	r3, #0x1
 80038ea: 2300         	movpl	r3, #0x0
 80038ec: b2db         	uxtb	r3, r3
; }
 80038ee: 4618         	mov	r0, r3
 80038f0: 3714         	adds	r7, #0x14
 80038f2: 46bd         	mov	sp, r7
 80038f4: f85d 7b04    	ldr	r7, [sp], #4
 80038f8: 4770         	bx	lr
 80038fa: bf00         	nop

080038fc <$d>:
 80038fc: 17 b7 d1 38  	.word	0x38d1b717

08003900 <pid_calc>:
; {
 8003900: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8003904: b096         	sub	sp, #0x58
 8003906: af00         	add	r7, sp, #0x0
 8003908: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = data->pid_dev;
 800390a: 6879         	ldr	r1, [r7, #0x4]
 800390c: 69c9         	ldr	r1, [r1, #0x1c]
 800390e: 6579         	str	r1, [r7, #0x54]
; 	if (dev == NULL) {
 8003910: 6d79         	ldr	r1, [r7, #0x54]
 8003912: 2900         	cmp	r1, #0x0
 8003914: f000 8224    	beq.w	0x8003d60 <pid_calc+0x460> @ imm = #0x448
; 	const struct pid_config *pid_para = dev->config;
 8003918: 6d79         	ldr	r1, [r7, #0x54]
 800391a: 6849         	ldr	r1, [r1, #0x4]
 800391c: 6539         	str	r1, [r7, #0x50]
; 	if (!pid_para->mit) {
 800391e: 6d39         	ldr	r1, [r7, #0x50]
 8003920: 7e09         	ldrb	r1, [r1, #0x18]
 8003922: f081 0101    	eor	r1, r1, #0x1
 8003926: b2c9         	uxtb	r1, r1
 8003928: 2900         	cmp	r1, #0x0
 800392a: f000 8107    	beq.w	0x8003b3c <pid_calc+0x23c> @ imm = #0x20e
; 		if (data->curr == NULL) {
 800392e: 687b         	ldr	r3, [r7, #0x4]
 8003930: 685b         	ldr	r3, [r3, #0x4]
 8003932: 2b00         	cmp	r3, #0x0
 8003934: f000 8216    	beq.w	0x8003d64 <pid_calc+0x464> @ imm = #0x42c
; 		float kp = pid_para->k_p;
 8003938: 6d3b         	ldr	r3, [r7, #0x50]
 800393a: 681b         	ldr	r3, [r3]
 800393c: 63bb         	str	r3, [r7, #0x38]
; 		float ki = pid_para->k_i;
 800393e: 6d3b         	ldr	r3, [r7, #0x50]
 8003940: 685b         	ldr	r3, [r3, #0x4]
 8003942: 637b         	str	r3, [r7, #0x34]
; 		float kd = pid_para->k_d;
 8003944: 6d3b         	ldr	r3, [r7, #0x50]
 8003946: 689b         	ldr	r3, [r3, #0x8]
 8003948: 633b         	str	r3, [r7, #0x30]
; 		float err = *(data->ref) - *(data->curr);
 800394a: 687b         	ldr	r3, [r7, #0x4]
 800394c: 681b         	ldr	r3, [r3]
 800394e: ed93 7a00    	vldr	s14, [r3]
 8003952: 687b         	ldr	r3, [r7, #0x4]
 8003954: 685b         	ldr	r3, [r3, #0x4]
 8003956: edd3 7a00    	vldr	s15, [r3]
 800395a: ee77 7a67    	vsub.f32	s15, s14, s15
 800395e: edc7 7a0b    	vstr	s15, [r7, #44]
; 		float deltaT = k_cyc_to_us_near32(*(data->curr_time) - *(data->prev_time));
 8003962: 687b         	ldr	r3, [r7, #0x4]
 8003964: 6a1b         	ldr	r3, [r3, #0x20]
 8003966: 681a         	ldr	r2, [r3]
 8003968: 687b         	ldr	r3, [r7, #0x4]
 800396a: 6a5b         	ldr	r3, [r3, #0x24]
 800396c: 681b         	ldr	r3, [r3]
 800396e: 1ad3         	subs	r3, r2, r3
 8003970: 2b00         	cmp	r3, #0x0
 8003972: db11         	blt	0x8003998 <pid_calc+0x98> @ imm = #0x22
 8003974: 687b         	ldr	r3, [r7, #0x4]
 8003976: 6a1b         	ldr	r3, [r3, #0x20]
 8003978: 681a         	ldr	r2, [r3]
 800397a: 687b         	ldr	r3, [r7, #0x4]
 800397c: 6a5b         	ldr	r3, [r3, #0x24]
 800397e: 681b         	ldr	r3, [r3]
 8003980: 1ad3         	subs	r3, r2, r3
 8003982: 3354         	adds	r3, #0x54
 8003984: 08db         	lsrs	r3, r3, #0x3
 8003986: 4ab9         	ldr	r2, [pc, #0x2e4]        @ 0x8003c6c <pid_calc+0x36c>
 8003988: fba2 2303    	umull	r2, r3, r2, r3
 800398c: 085b         	lsrs	r3, r3, #0x1
 800398e: ee07 3a90    	vmov	s15, r3
 8003992: eef8 7a67    	vcvt.f32.u32	s15, s15
 8003996: e01b         	b	0x80039d0 <pid_calc+0xd0> @ imm = #0x36
 8003998: 687b         	ldr	r3, [r7, #0x4]
 800399a: 6a1b         	ldr	r3, [r3, #0x20]
 800399c: 681a         	ldr	r2, [r3]
 800399e: 687b         	ldr	r3, [r7, #0x4]
 80039a0: 6a5b         	ldr	r3, [r3, #0x24]
 80039a2: 681b         	ldr	r3, [r3]
 80039a4: 1ad3         	subs	r3, r2, r3
 80039a6: 17da         	asrs	r2, r3, #0x1f
 80039a8: 461c         	mov	r4, r3
 80039aa: 4615         	mov	r5, r2
 80039ac: f114 0a54    	adds.w	r10, r4, #0x54
 80039b0: f145 0b00    	adc	r11, r5, #0x0
 80039b4: f04f 02a8    	mov.w	r2, #0xa8
 80039b8: f04f 0300    	mov.w	r3, #0x0
 80039bc: 4650         	mov	r0, r10
 80039be: 4659         	mov	r1, r11
 80039c0: f7fd f850    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x2f60
 80039c4: 4602         	mov	r2, r0
 80039c6: 460b         	mov	r3, r1
 80039c8: ee07 2a90    	vmov	s15, r2
 80039cc: eef8 7a67    	vcvt.f32.u32	s15, s15
 80039d0: edc7 7a0a    	vstr	s15, [r7, #40]
; 		if (!float_equal(ki, 0)) {
 80039d4: eddf 0aa6    	vldr	s1, [pc, #664]          @ 0x8003c70 <pid_calc+0x370>
 80039d8: ed97 0a0d    	vldr	s0, [r7, #52]
 80039dc: f7ff ff66    	bl	0x80038ac <float_equal> @ imm = #-0x134
 80039e0: 4603         	mov	r3, r0
 80039e2: f083 0301    	eor	r3, r3, #0x1
 80039e6: b2db         	uxtb	r3, r3
 80039e8: 2b00         	cmp	r3, #0x0
 80039ea: d040         	beq	0x8003a6e <pid_calc+0x16e> @ imm = #0x80
; 			data->err_integral += (err * deltaT) / ki;
 80039ec: 687b         	ldr	r3, [r7, #0x4]
 80039ee: ed93 7a04    	vldr	s14, [r3, #16]
 80039f2: edd7 6a0b    	vldr	s13, [r7, #44]
 80039f6: edd7 7a0a    	vldr	s15, [r7, #40]
 80039fa: ee26 6aa7    	vmul.f32	s12, s13, s15
 80039fe: edd7 6a0d    	vldr	s13, [r7, #52]
 8003a02: eec6 7a26    	vdiv.f32	s15, s12, s13
 8003a06: ee77 7a27    	vadd.f32	s15, s14, s15
 8003a0a: 687b         	ldr	r3, [r7, #0x4]
 8003a0c: edc3 7a04    	vstr	s15, [r3, #16]
; 			if (pid_para->integral_limit != 0) {
 8003a10: 6d3b         	ldr	r3, [r7, #0x50]
 8003a12: edd3 7a03    	vldr	s15, [r3, #12]
 8003a16: eef5 7a40    	vcmp.f32	s15, #0
 8003a1a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003a1e: d026         	beq	0x8003a6e <pid_calc+0x16e> @ imm = #0x4c
; 				if (fabsf(data->err_integral) > pid_para->integral_limit) {
 8003a20: 687b         	ldr	r3, [r7, #0x4]
 8003a22: 691b         	ldr	r3, [r3, #0x10]
 8003a24: 627b         	str	r3, [r7, #0x24]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 8003a26: edd7 7a09    	vldr	s15, [r7, #36]
 8003a2a: eef0 7ae7    	vabs.f32	s15, s15
 8003a2e: edc7 7a08    	vstr	s15, [r7, #32]
;     return result;
 8003a32: ed97 7a08    	vldr	s14, [r7, #32]
; 				if (fabsf(data->err_integral) > pid_para->integral_limit) {
 8003a36: 6d3b         	ldr	r3, [r7, #0x50]
 8003a38: edd3 7a03    	vldr	s15, [r3, #12]
 8003a3c: eeb4 7ae7    	vcmpe.f32	s14, s15
 8003a40: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003a44: dd13         	ble	0x8003a6e <pid_calc+0x16e> @ imm = #0x26
; 					data->err_integral = data->err_integral > 0
 8003a46: 687b         	ldr	r3, [r7, #0x4]
 8003a48: edd3 7a04    	vldr	s15, [r3, #16]
; 								     : -pid_para->integral_limit;
 8003a4c: eef5 7ac0    	vcmpe.f32	s15, #0
 8003a50: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003a54: dd03         	ble	0x8003a5e <pid_calc+0x15e> @ imm = #0x6
 8003a56: 6d3b         	ldr	r3, [r7, #0x50]
 8003a58: edd3 7a03    	vldr	s15, [r3, #12]
 8003a5c: e004         	b	0x8003a68 <pid_calc+0x168> @ imm = #0x8
 8003a5e: 6d3b         	ldr	r3, [r7, #0x50]
 8003a60: edd3 7a03    	vldr	s15, [r3, #12]
 8003a64: eef1 7a67    	vneg.f32	s15, s15
; 					data->err_integral = data->err_integral > 0
 8003a68: 687b         	ldr	r3, [r7, #0x4]
 8003a6a: edc3 7a04    	vstr	s15, [r3, #16]
; 		if (!float_equal(kd, 0)) {
 8003a6e: eddf 0a80    	vldr	s1, [pc, #512]          @ 0x8003c70 <pid_calc+0x370>
 8003a72: ed97 0a0c    	vldr	s0, [r7, #48]
 8003a76: f7ff ff19    	bl	0x80038ac <float_equal> @ imm = #-0x1ce
 8003a7a: 4603         	mov	r3, r0
 8003a7c: f083 0301    	eor	r3, r3, #0x1
 8003a80: b2db         	uxtb	r3, r3
 8003a82: 2b00         	cmp	r3, #0x0
 8003a84: d00c         	beq	0x8003aa0 <pid_calc+0x1a0> @ imm = #0x18
; 			data->err_derivate = kd * err / deltaT;
 8003a86: ed97 7a0c    	vldr	s14, [r7, #48]
 8003a8a: edd7 7a0b    	vldr	s15, [r7, #44]
 8003a8e: ee67 6a27    	vmul.f32	s13, s14, s15
 8003a92: ed97 7a0a    	vldr	s14, [r7, #40]
 8003a96: eec6 7a87    	vdiv.f32	s15, s13, s14
 8003a9a: 687b         	ldr	r3, [r7, #0x4]
 8003a9c: edc3 7a05    	vstr	s15, [r3, #20]
; 		*(data->output) = kp * (err + data->err_integral + data->err_derivate) +
 8003aa0: 687b         	ldr	r3, [r7, #0x4]
 8003aa2: ed93 7a04    	vldr	s14, [r3, #16]
 8003aa6: edd7 7a0b    	vldr	s15, [r7, #44]
 8003aaa: ee37 7a27    	vadd.f32	s14, s14, s15
 8003aae: 687b         	ldr	r3, [r7, #0x4]
 8003ab0: edd3 7a05    	vldr	s15, [r3, #20]
 8003ab4: ee37 7a27    	vadd.f32	s14, s14, s15
 8003ab8: edd7 7a0e    	vldr	s15, [r7, #56]
 8003abc: ee27 7a27    	vmul.f32	s14, s14, s15
; 				  pid_para->output_offset;
 8003ac0: 6d3b         	ldr	r3, [r7, #0x50]
 8003ac2: edd3 7a05    	vldr	s15, [r3, #20]
; 		*(data->output) = kp * (err + data->err_integral + data->err_derivate) +
 8003ac6: 687b         	ldr	r3, [r7, #0x4]
 8003ac8: 6a9b         	ldr	r3, [r3, #0x28]
 8003aca: ee77 7a27    	vadd.f32	s15, s14, s15
 8003ace: edc3 7a00    	vstr	s15, [r3]
; 		if (pid_para->output_limit != 0 &&
 8003ad2: 6d3b         	ldr	r3, [r7, #0x50]
 8003ad4: edd3 7a04    	vldr	s15, [r3, #16]
 8003ad8: eef5 7a40    	vcmp.f32	s15, #0
 8003adc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003ae0: f000 8142    	beq.w	0x8003d68 <pid_calc+0x468> @ imm = #0x284
; 		    fabsf(*(data->output)) > pid_para->output_limit) {
 8003ae4: 687b         	ldr	r3, [r7, #0x4]
 8003ae6: 6a9b         	ldr	r3, [r3, #0x28]
 8003ae8: 681b         	ldr	r3, [r3]
 8003aea: 61fb         	str	r3, [r7, #0x1c]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 8003aec: edd7 7a07    	vldr	s15, [r7, #28]
 8003af0: eef0 7ae7    	vabs.f32	s15, s15
 8003af4: edc7 7a06    	vstr	s15, [r7, #24]
;     return result;
 8003af8: ed97 7a06    	vldr	s14, [r7, #24]
; 		    fabsf(*(data->output)) > pid_para->output_limit) {
 8003afc: 6d3b         	ldr	r3, [r7, #0x50]
 8003afe: edd3 7a04    	vldr	s15, [r3, #16]
; 		if (pid_para->output_limit != 0 &&
 8003b02: eeb4 7ae7    	vcmpe.f32	s14, s15
 8003b06: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003b0a: dc00         	bgt	0x8003b0e <pid_calc+0x20e> @ imm = #0x0
; 		return;
 8003b0c: e12c         	b	0x8003d68 <pid_calc+0x468> @ imm = #0x258
; 			*(data->output) = *(data->output) > 0 ? pid_para->output_limit
 8003b0e: 687b         	ldr	r3, [r7, #0x4]
 8003b10: 6a9b         	ldr	r3, [r3, #0x28]
 8003b12: edd3 7a00    	vldr	s15, [r3]
; 							      : -pid_para->output_limit;
 8003b16: eef5 7ac0    	vcmpe.f32	s15, #0
 8003b1a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003b1e: dd03         	ble	0x8003b28 <pid_calc+0x228> @ imm = #0x6
 8003b20: 6d3b         	ldr	r3, [r7, #0x50]
 8003b22: edd3 7a04    	vldr	s15, [r3, #16]
 8003b26: e004         	b	0x8003b32 <pid_calc+0x232> @ imm = #0x8
 8003b28: 6d3b         	ldr	r3, [r7, #0x50]
 8003b2a: edd3 7a04    	vldr	s15, [r3, #16]
 8003b2e: eef1 7a67    	vneg.f32	s15, s15
; 			*(data->output) = *(data->output) > 0 ? pid_para->output_limit
 8003b32: 687b         	ldr	r3, [r7, #0x4]
 8003b34: 6a9b         	ldr	r3, [r3, #0x28]
 8003b36: edc3 7a00    	vstr	s15, [r3]
; 		return;
 8003b3a: e115         	b	0x8003d68 <pid_calc+0x468> @ imm = #0x22a
; 		if (data->curr == NULL) {
 8003b3c: 6879         	ldr	r1, [r7, #0x4]
 8003b3e: 6849         	ldr	r1, [r1, #0x4]
 8003b40: 2900         	cmp	r1, #0x0
 8003b42: f000 8113    	beq.w	0x8003d6c <pid_calc+0x46c> @ imm = #0x226
; 		float kp = pid_para->k_p;
 8003b46: 6d39         	ldr	r1, [r7, #0x50]
 8003b48: 6809         	ldr	r1, [r1]
 8003b4a: 64f9         	str	r1, [r7, #0x4c]
; 		float ki = pid_para->k_i;
 8003b4c: 6d39         	ldr	r1, [r7, #0x50]
 8003b4e: 6849         	ldr	r1, [r1, #0x4]
 8003b50: 64b9         	str	r1, [r7, #0x48]
; 		float kd = pid_para->k_d;
 8003b52: 6d39         	ldr	r1, [r7, #0x50]
 8003b54: 6889         	ldr	r1, [r1, #0x8]
 8003b56: 6479         	str	r1, [r7, #0x44]
; 		float err = *(data->ref) - *(data->curr);
 8003b58: 6879         	ldr	r1, [r7, #0x4]
 8003b5a: 6809         	ldr	r1, [r1]
 8003b5c: ed91 7a00    	vldr	s14, [r1]
 8003b60: 6879         	ldr	r1, [r7, #0x4]
 8003b62: 6849         	ldr	r1, [r1, #0x4]
 8003b64: edd1 7a00    	vldr	s15, [r1]
 8003b68: ee77 7a67    	vsub.f32	s15, s14, s15
 8003b6c: edc7 7a10    	vstr	s15, [r7, #64]
; 		float deltaT = k_cyc_to_us_near32(*(data->curr_time) - *(data->prev_time));
 8003b70: 6879         	ldr	r1, [r7, #0x4]
 8003b72: 6a09         	ldr	r1, [r1, #0x20]
 8003b74: 6808         	ldr	r0, [r1]
 8003b76: 6879         	ldr	r1, [r7, #0x4]
 8003b78: 6a49         	ldr	r1, [r1, #0x24]
 8003b7a: 6809         	ldr	r1, [r1]
 8003b7c: 1a41         	subs	r1, r0, r1
 8003b7e: 2900         	cmp	r1, #0x0
 8003b80: db11         	blt	0x8003ba6 <pid_calc+0x2a6> @ imm = #0x22
 8003b82: 687b         	ldr	r3, [r7, #0x4]
 8003b84: 6a1b         	ldr	r3, [r3, #0x20]
 8003b86: 681a         	ldr	r2, [r3]
 8003b88: 687b         	ldr	r3, [r7, #0x4]
 8003b8a: 6a5b         	ldr	r3, [r3, #0x24]
 8003b8c: 681b         	ldr	r3, [r3]
 8003b8e: 1ad3         	subs	r3, r2, r3
 8003b90: 3354         	adds	r3, #0x54
 8003b92: 08db         	lsrs	r3, r3, #0x3
 8003b94: 4a35         	ldr	r2, [pc, #0xd4]         @ 0x8003c6c <pid_calc+0x36c>
 8003b96: fba2 2303    	umull	r2, r3, r2, r3
 8003b9a: 085b         	lsrs	r3, r3, #0x1
 8003b9c: ee07 3a90    	vmov	s15, r3
 8003ba0: eef8 7a67    	vcvt.f32.u32	s15, s15
 8003ba4: e01b         	b	0x8003bde <pid_calc+0x2de> @ imm = #0x36
 8003ba6: 6879         	ldr	r1, [r7, #0x4]
 8003ba8: 6a09         	ldr	r1, [r1, #0x20]
 8003baa: 6808         	ldr	r0, [r1]
 8003bac: 6879         	ldr	r1, [r7, #0x4]
 8003bae: 6a49         	ldr	r1, [r1, #0x24]
 8003bb0: 6809         	ldr	r1, [r1]
 8003bb2: 1a41         	subs	r1, r0, r1
 8003bb4: 17c8         	asrs	r0, r1, #0x1f
 8003bb6: 460a         	mov	r2, r1
 8003bb8: 4603         	mov	r3, r0
 8003bba: f112 0854    	adds.w	r8, r2, #0x54
 8003bbe: f143 0900    	adc	r9, r3, #0x0
 8003bc2: f04f 02a8    	mov.w	r2, #0xa8
 8003bc6: f04f 0300    	mov.w	r3, #0x0
 8003bca: 4640         	mov	r0, r8
 8003bcc: 4649         	mov	r1, r9
 8003bce: f7fc ff49    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x316e
 8003bd2: 4602         	mov	r2, r0
 8003bd4: 460b         	mov	r3, r1
 8003bd6: ee07 2a90    	vmov	s15, r2
 8003bda: eef8 7a67    	vcvt.f32.u32	s15, s15
 8003bde: edc7 7a0f    	vstr	s15, [r7, #60]
; 		if (!float_equal(ki, 0)) {
 8003be2: eddf 0a23    	vldr	s1, [pc, #140]          @ 0x8003c70 <pid_calc+0x370>
 8003be6: ed97 0a12    	vldr	s0, [r7, #72]
 8003bea: f7ff fe5f    	bl	0x80038ac <float_equal> @ imm = #-0x342
 8003bee: 4603         	mov	r3, r0
 8003bf0: f083 0301    	eor	r3, r3, #0x1
 8003bf4: b2db         	uxtb	r3, r3
 8003bf6: 2b00         	cmp	r3, #0x0
 8003bf8: d044         	beq	0x8003c84 <pid_calc+0x384> @ imm = #0x88
; 			data->err_integral += (err * deltaT) / ki;
 8003bfa: 687b         	ldr	r3, [r7, #0x4]
 8003bfc: ed93 7a04    	vldr	s14, [r3, #16]
 8003c00: edd7 6a10    	vldr	s13, [r7, #64]
 8003c04: edd7 7a0f    	vldr	s15, [r7, #60]
 8003c08: ee26 6aa7    	vmul.f32	s12, s13, s15
 8003c0c: edd7 6a12    	vldr	s13, [r7, #72]
 8003c10: eec6 7a26    	vdiv.f32	s15, s12, s13
 8003c14: ee77 7a27    	vadd.f32	s15, s14, s15
 8003c18: 687b         	ldr	r3, [r7, #0x4]
 8003c1a: edc3 7a04    	vstr	s15, [r3, #16]
; 			if (pid_para->integral_limit != 0) {
 8003c1e: 6d3b         	ldr	r3, [r7, #0x50]
 8003c20: edd3 7a03    	vldr	s15, [r3, #12]
 8003c24: eef5 7a40    	vcmp.f32	s15, #0
 8003c28: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003c2c: d02a         	beq	0x8003c84 <pid_calc+0x384> @ imm = #0x54
; 				if (fabsf(data->err_integral) > pid_para->integral_limit) {
 8003c2e: 687b         	ldr	r3, [r7, #0x4]
 8003c30: 691b         	ldr	r3, [r3, #0x10]
 8003c32: 617b         	str	r3, [r7, #0x14]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 8003c34: edd7 7a05    	vldr	s15, [r7, #20]
 8003c38: eef0 7ae7    	vabs.f32	s15, s15
 8003c3c: edc7 7a04    	vstr	s15, [r7, #16]
;     return result;
 8003c40: ed97 7a04    	vldr	s14, [r7, #16]
; 				if (fabsf(data->err_integral) > pid_para->integral_limit) {
 8003c44: 6d3b         	ldr	r3, [r7, #0x50]
 8003c46: edd3 7a03    	vldr	s15, [r3, #12]
 8003c4a: eeb4 7ae7    	vcmpe.f32	s14, s15
 8003c4e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003c52: dd17         	ble	0x8003c84 <pid_calc+0x384> @ imm = #0x2e
; 					data->err_integral = data->err_integral > 0
 8003c54: 687b         	ldr	r3, [r7, #0x4]
 8003c56: edd3 7a04    	vldr	s15, [r3, #16]
; 								     : -pid_para->integral_limit;
 8003c5a: eef5 7ac0    	vcmpe.f32	s15, #0
 8003c5e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003c62: dd07         	ble	0x8003c74 <pid_calc+0x374> @ imm = #0xe
 8003c64: 6d3b         	ldr	r3, [r7, #0x50]
 8003c66: edd3 7a03    	vldr	s15, [r3, #12]
 8003c6a: e008         	b	0x8003c7e <pid_calc+0x37e> @ imm = #0x10

08003c6c <$d>:
 8003c6c: 19 86 61 18  	.word	0x18618619
 8003c70: 00 00 00 00  	.word	0x00000000

08003c74 <$t>:
 8003c74: 6d3b         	ldr	r3, [r7, #0x50]
 8003c76: edd3 7a03    	vldr	s15, [r3, #12]
 8003c7a: eef1 7a67    	vneg.f32	s15, s15
; 					data->err_integral = data->err_integral > 0
 8003c7e: 687b         	ldr	r3, [r7, #0x4]
 8003c80: edc3 7a04    	vstr	s15, [r3, #16]
; 		if (!float_equal(kd, 0)) {
 8003c84: ed5f 0a06    	vldr	s1, [pc, #-24]          @ 0x8003c70 <pid_calc+0x370>
 8003c88: ed97 0a11    	vldr	s0, [r7, #68]
 8003c8c: f7ff fe0e    	bl	0x80038ac <float_equal> @ imm = #-0x3e4
 8003c90: 4603         	mov	r3, r0
 8003c92: f083 0301    	eor	r3, r3, #0x1
 8003c96: b2db         	uxtb	r3, r3
 8003c98: 2b00         	cmp	r3, #0x0
 8003c9a: d014         	beq	0x8003cc6 <pid_calc+0x3c6> @ imm = #0x28
; 				kd * (*(data->detri_ref) - *(data->detri_curr)) / deltaT;
 8003c9c: 687b         	ldr	r3, [r7, #0x4]
 8003c9e: 689b         	ldr	r3, [r3, #0x8]
 8003ca0: ed93 7a00    	vldr	s14, [r3]
 8003ca4: 687b         	ldr	r3, [r7, #0x4]
 8003ca6: 68db         	ldr	r3, [r3, #0xc]
 8003ca8: edd3 7a00    	vldr	s15, [r3]
 8003cac: ee37 7a67    	vsub.f32	s14, s14, s15
 8003cb0: edd7 7a11    	vldr	s15, [r7, #68]
 8003cb4: ee67 6a27    	vmul.f32	s13, s14, s15
 8003cb8: ed97 7a0f    	vldr	s14, [r7, #60]
 8003cbc: eec6 7a87    	vdiv.f32	s15, s13, s14
; 			data->err_derivate =
 8003cc0: 687b         	ldr	r3, [r7, #0x4]
 8003cc2: edc3 7a05    	vstr	s15, [r3, #20]
; 		*(data->output) = kp * (err + data->err_integral + data->err_derivate) +
 8003cc6: 687b         	ldr	r3, [r7, #0x4]
 8003cc8: ed93 7a04    	vldr	s14, [r3, #16]
 8003ccc: edd7 7a10    	vldr	s15, [r7, #64]
 8003cd0: ee37 7a27    	vadd.f32	s14, s14, s15
 8003cd4: 687b         	ldr	r3, [r7, #0x4]
 8003cd6: edd3 7a05    	vldr	s15, [r3, #20]
 8003cda: ee37 7a27    	vadd.f32	s14, s14, s15
 8003cde: edd7 7a13    	vldr	s15, [r7, #76]
 8003ce2: ee27 7a27    	vmul.f32	s14, s14, s15
; 				  pid_para->output_offset;
 8003ce6: 6d3b         	ldr	r3, [r7, #0x50]
 8003ce8: edd3 7a05    	vldr	s15, [r3, #20]
; 		*(data->output) = kp * (err + data->err_integral + data->err_derivate) +
 8003cec: 687b         	ldr	r3, [r7, #0x4]
 8003cee: 6a9b         	ldr	r3, [r3, #0x28]
 8003cf0: ee77 7a27    	vadd.f32	s15, s14, s15
 8003cf4: edc3 7a00    	vstr	s15, [r3]
; 		if (pid_para->output_limit != 0 &&
 8003cf8: 6d3b         	ldr	r3, [r7, #0x50]
 8003cfa: edd3 7a04    	vldr	s15, [r3, #16]
 8003cfe: eef5 7a40    	vcmp.f32	s15, #0
 8003d02: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003d06: d033         	beq	0x8003d70 <pid_calc+0x470> @ imm = #0x66
; 		    fabsf(*(data->output)) > pid_para->output_limit) {
 8003d08: 687b         	ldr	r3, [r7, #0x4]
 8003d0a: 6a9b         	ldr	r3, [r3, #0x28]
 8003d0c: 681b         	ldr	r3, [r3]
 8003d0e: 60fb         	str	r3, [r7, #0xc]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 8003d10: edd7 7a03    	vldr	s15, [r7, #12]
 8003d14: eef0 7ae7    	vabs.f32	s15, s15
 8003d18: edc7 7a02    	vstr	s15, [r7, #8]
;     return result;
 8003d1c: ed97 7a02    	vldr	s14, [r7, #8]
; 		    fabsf(*(data->output)) > pid_para->output_limit) {
 8003d20: 6d3b         	ldr	r3, [r7, #0x50]
 8003d22: edd3 7a04    	vldr	s15, [r3, #16]
; 		if (pid_para->output_limit != 0 &&
 8003d26: eeb4 7ae7    	vcmpe.f32	s14, s15
 8003d2a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003d2e: dc00         	bgt	0x8003d32 <pid_calc+0x432> @ imm = #0x0
; 		return;
 8003d30: e01e         	b	0x8003d70 <pid_calc+0x470> @ imm = #0x3c
; 			*(data->output) = *(data->output) > 0 ? pid_para->output_limit
 8003d32: 687b         	ldr	r3, [r7, #0x4]
 8003d34: 6a9b         	ldr	r3, [r3, #0x28]
 8003d36: edd3 7a00    	vldr	s15, [r3]
; 							      : -pid_para->output_limit;
 8003d3a: eef5 7ac0    	vcmpe.f32	s15, #0
 8003d3e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003d42: dd03         	ble	0x8003d4c <pid_calc+0x44c> @ imm = #0x6
 8003d44: 6d3b         	ldr	r3, [r7, #0x50]
 8003d46: edd3 7a04    	vldr	s15, [r3, #16]
 8003d4a: e004         	b	0x8003d56 <pid_calc+0x456> @ imm = #0x8
 8003d4c: 6d3b         	ldr	r3, [r7, #0x50]
 8003d4e: edd3 7a04    	vldr	s15, [r3, #16]
 8003d52: eef1 7a67    	vneg.f32	s15, s15
; 			*(data->output) = *(data->output) > 0 ? pid_para->output_limit
 8003d56: 687b         	ldr	r3, [r7, #0x4]
 8003d58: 6a9b         	ldr	r3, [r3, #0x28]
 8003d5a: edc3 7a00    	vstr	s15, [r3]
; 		return;
 8003d5e: e007         	b	0x8003d70 <pid_calc+0x470> @ imm = #0xe
; 		return;
 8003d60: bf00         	nop
 8003d62: e006         	b	0x8003d72 <pid_calc+0x472> @ imm = #0xc
; 			return;
 8003d64: bf00         	nop
 8003d66: e004         	b	0x8003d72 <pid_calc+0x472> @ imm = #0x8
; 		return;
 8003d68: bf00         	nop
 8003d6a: e002         	b	0x8003d72 <pid_calc+0x472> @ imm = #0x4
; 			return;
 8003d6c: bf00         	nop
 8003d6e: e000         	b	0x8003d72 <pid_calc+0x472> @ imm = #0x0
; 		return;
 8003d70: bf00         	nop
; }
 8003d72: 3758         	adds	r7, #0x58
 8003d74: 46bd         	mov	sp, r7
 8003d76: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 8003d7a: bf00         	nop

08003d7c <Sqrt>:
; {
 8003d7c: b480         	push	{r7}
 8003d7e: b087         	sub	sp, #0x1c
 8003d80: af00         	add	r7, sp, #0x0
 8003d82: ed87 0a01    	vstr	s0, [r7, #4]
; 	if (x <= 0) {
 8003d86: edd7 7a01    	vldr	s15, [r7, #4]
 8003d8a: eef5 7ac0    	vcmpe.f32	s15, #0
 8003d8e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003d92: d802         	bhi	0x8003d9a <Sqrt+0x1e>   @ imm = #0x4
; 		return 0;
 8003d94: f04f 0300    	mov.w	r3, #0x0
 8003d98: e03c         	b	0x8003e14 <Sqrt+0x98>   @ imm = #0x78
; 	y = x / 2;
 8003d9a: ed97 7a01    	vldr	s14, [r7, #4]
 8003d9e: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8003da2: eec7 7a26    	vdiv.f32	s15, s14, s13
 8003da6: edc7 7a05    	vstr	s15, [r7, #20]
; 	maxError = x * 0.001f;
 8003daa: edd7 7a01    	vldr	s15, [r7, #4]
 8003dae: ed9f 7a1e    	vldr	s14, [pc, #120]         @ 0x8003e28 <Sqrt+0xac>
 8003db2: ee67 7a87    	vmul.f32	s15, s15, s14
 8003db6: edc7 7a04    	vstr	s15, [r7, #16]
; 		delta = (y * y) - x;
 8003dba: edd7 7a05    	vldr	s15, [r7, #20]
 8003dbe: ee27 7aa7    	vmul.f32	s14, s15, s15
 8003dc2: edd7 7a01    	vldr	s15, [r7, #4]
 8003dc6: ee77 7a67    	vsub.f32	s15, s14, s15
 8003dca: edc7 7a03    	vstr	s15, [r7, #12]
; 		y -= delta / (2 * y);
 8003dce: edd7 7a05    	vldr	s15, [r7, #20]
 8003dd2: ee37 7aa7    	vadd.f32	s14, s15, s15
 8003dd6: edd7 6a03    	vldr	s13, [r7, #12]
 8003dda: eec6 7a87    	vdiv.f32	s15, s13, s14
 8003dde: ed97 7a05    	vldr	s14, [r7, #20]
 8003de2: ee77 7a67    	vsub.f32	s15, s14, s15
 8003de6: edc7 7a05    	vstr	s15, [r7, #20]
; 	} while (delta > maxError || delta < -maxError);
 8003dea: ed97 7a03    	vldr	s14, [r7, #12]
 8003dee: edd7 7a04    	vldr	s15, [r7, #16]
 8003df2: eeb4 7ae7    	vcmpe.f32	s14, s15
 8003df6: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003dfa: dcde         	bgt	0x8003dba <Sqrt+0x3e>   @ imm = #-0x44
 8003dfc: edd7 7a04    	vldr	s15, [r7, #16]
 8003e00: eef1 7a67    	vneg.f32	s15, s15
 8003e04: ed97 7a03    	vldr	s14, [r7, #12]
 8003e08: eeb4 7ae7    	vcmpe.f32	s14, s15
 8003e0c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8003e10: d4d3         	bmi	0x8003dba <Sqrt+0x3e>   @ imm = #-0x5a
; 	return y;
 8003e12: 697b         	ldr	r3, [r7, #0x14]
; }
 8003e14: ee07 3a90    	vmov	s15, r3
 8003e18: eeb0 0a67    	vmov.f32	s0, s15
 8003e1c: 371c         	adds	r7, #0x1c
 8003e1e: 46bd         	mov	sp, r7
 8003e20: f85d 7b04    	ldr	r7, [sp], #4
 8003e24: 4770         	bx	lr
 8003e26: bf00         	nop

08003e28 <$d>:
 8003e28: 6f 12 83 3a  	.word	0x3a83126f

08003e2c <IMU_Sensor_handle_update>:
; {
 8003e2c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8003e30: b088         	sub	sp, #0x20
 8003e32: af00         	add	r7, sp, #0x0
 8003e34: 6078         	str	r0, [r7, #0x4]
; 	if (data->flag != 0b11) {
 8003e36: 6879         	ldr	r1, [r7, #0x4]
 8003e38: f891 1024    	ldrb.w	r1, [r1, #0x24]
 8003e3c: 2903         	cmp	r1, #0x3
 8003e3e: f040 80fb    	bne.w	0x8004038 <IMU_Sensor_handle_update+0x20c> @ imm = #0x1f6
; 	data->flag = 0;
 8003e42: 6879         	ldr	r1, [r7, #0x4]
 8003e44: 2000         	movs	r0, #0x0
 8003e46: f881 0024    	strb.w	r0, [r1, #0x24]
; 	count++;
 8003e4a: 497e         	ldr	r1, [pc, #0x1f8]        @ 0x8004044 <IMU_Sensor_handle_update+0x218>
 8003e4c: 6809         	ldr	r1, [r1]
 8003e4e: 3101         	adds	r1, #0x1
 8003e50: 487c         	ldr	r0, [pc, #0x1f0]        @ 0x8004044 <IMU_Sensor_handle_update+0x218>
 8003e52: 6001         	str	r1, [r0]
; 		k_cyc_to_us_near32(data->accel_curr_cyc - data->accel_prev_cyc) * 0.000001f;
 8003e54: 6879         	ldr	r1, [r7, #0x4]
 8003e56: 6b88         	ldr	r0, [r1, #0x38]
 8003e58: 6879         	ldr	r1, [r7, #0x4]
 8003e5a: 6ac9         	ldr	r1, [r1, #0x2c]
 8003e5c: 1a41         	subs	r1, r0, r1
 8003e5e: 2900         	cmp	r1, #0x0
 8003e60: db0f         	blt	0x8003e82 <IMU_Sensor_handle_update+0x56> @ imm = #0x1e
 8003e62: 687b         	ldr	r3, [r7, #0x4]
 8003e64: 6b9a         	ldr	r2, [r3, #0x38]
 8003e66: 687b         	ldr	r3, [r7, #0x4]
 8003e68: 6adb         	ldr	r3, [r3, #0x2c]
 8003e6a: 1ad3         	subs	r3, r2, r3
 8003e6c: 3354         	adds	r3, #0x54
 8003e6e: 08db         	lsrs	r3, r3, #0x3
 8003e70: 4a75         	ldr	r2, [pc, #0x1d4]        @ 0x8004048 <IMU_Sensor_handle_update+0x21c>
 8003e72: fba2 2303    	umull	r2, r3, r2, r3
 8003e76: 085b         	lsrs	r3, r3, #0x1
 8003e78: ee07 3a90    	vmov	s15, r3
 8003e7c: eef8 7a67    	vcvt.f32.u32	s15, s15
 8003e80: e019         	b	0x8003eb6 <IMU_Sensor_handle_update+0x8a> @ imm = #0x32
 8003e82: 6879         	ldr	r1, [r7, #0x4]
 8003e84: 6b88         	ldr	r0, [r1, #0x38]
 8003e86: 6879         	ldr	r1, [r7, #0x4]
 8003e88: 6ac9         	ldr	r1, [r1, #0x2c]
 8003e8a: 1a41         	subs	r1, r0, r1
 8003e8c: 17c8         	asrs	r0, r1, #0x1f
 8003e8e: 460a         	mov	r2, r1
 8003e90: 4603         	mov	r3, r0
 8003e92: f112 0a54    	adds.w	r10, r2, #0x54
 8003e96: f143 0b00    	adc	r11, r3, #0x0
 8003e9a: f04f 02a8    	mov.w	r2, #0xa8
 8003e9e: f04f 0300    	mov.w	r3, #0x0
 8003ea2: 4650         	mov	r0, r10
 8003ea4: 4659         	mov	r1, r11
 8003ea6: f7fc fddd    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x3446
 8003eaa: 4602         	mov	r2, r0
 8003eac: 460b         	mov	r3, r1
 8003eae: ee07 2a90    	vmov	s15, r2
 8003eb2: eef8 7a67    	vcvt.f32.u32	s15, s15
; 	float accel_dt =
 8003eb6: ed9f 7a65    	vldr	s14, [pc, #404]         @ 0x800404c <IMU_Sensor_handle_update+0x220>
 8003eba: ee67 7a87    	vmul.f32	s15, s15, s14
 8003ebe: edc7 7a07    	vstr	s15, [r7, #28]
; 	float gyro_dt = k_cyc_to_us_near32(data->gyro_curr_cyc - data->gyro_prev_cyc) * 0.000001f;
 8003ec2: 687b         	ldr	r3, [r7, #0x4]
 8003ec4: 6b5a         	ldr	r2, [r3, #0x34]
 8003ec6: 687b         	ldr	r3, [r7, #0x4]
 8003ec8: 6a9b         	ldr	r3, [r3, #0x28]
 8003eca: 1ad3         	subs	r3, r2, r3
 8003ecc: 2b00         	cmp	r3, #0x0
 8003ece: db0f         	blt	0x8003ef0 <IMU_Sensor_handle_update+0xc4> @ imm = #0x1e
 8003ed0: 687b         	ldr	r3, [r7, #0x4]
 8003ed2: 6b5a         	ldr	r2, [r3, #0x34]
 8003ed4: 687b         	ldr	r3, [r7, #0x4]
 8003ed6: 6a9b         	ldr	r3, [r3, #0x28]
 8003ed8: 1ad3         	subs	r3, r2, r3
 8003eda: 3354         	adds	r3, #0x54
 8003edc: 08db         	lsrs	r3, r3, #0x3
 8003ede: 4a5a         	ldr	r2, [pc, #0x168]        @ 0x8004048 <IMU_Sensor_handle_update+0x21c>
 8003ee0: fba2 2303    	umull	r2, r3, r2, r3
 8003ee4: 085b         	lsrs	r3, r3, #0x1
 8003ee6: ee07 3a90    	vmov	s15, r3
 8003eea: eef8 7a67    	vcvt.f32.u32	s15, s15
 8003eee: e019         	b	0x8003f24 <IMU_Sensor_handle_update+0xf8> @ imm = #0x32
 8003ef0: 687b         	ldr	r3, [r7, #0x4]
 8003ef2: 6b5a         	ldr	r2, [r3, #0x34]
 8003ef4: 687b         	ldr	r3, [r7, #0x4]
 8003ef6: 6a9b         	ldr	r3, [r3, #0x28]
 8003ef8: 1ad3         	subs	r3, r2, r3
 8003efa: 17da         	asrs	r2, r3, #0x1f
 8003efc: 461c         	mov	r4, r3
 8003efe: 4615         	mov	r5, r2
 8003f00: f114 0854    	adds.w	r8, r4, #0x54
 8003f04: f145 0900    	adc	r9, r5, #0x0
 8003f08: f04f 02a8    	mov.w	r2, #0xa8
 8003f0c: f04f 0300    	mov.w	r3, #0x0
 8003f10: 4640         	mov	r0, r8
 8003f12: 4649         	mov	r1, r9
 8003f14: f7fc fda6    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x34b4
 8003f18: 4602         	mov	r2, r0
 8003f1a: 460b         	mov	r3, r1
 8003f1c: ee07 2a90    	vmov	s15, r2
 8003f20: eef8 7a67    	vcvt.f32.u32	s15, s15
 8003f24: ed9f 7a49    	vldr	s14, [pc, #292]         @ 0x800404c <IMU_Sensor_handle_update+0x220>
 8003f28: ee67 7a87    	vmul.f32	s15, s15, s14
 8003f2c: edc7 7a06    	vstr	s15, [r7, #24]
; 	IMU_QuaternionEKF_Update(INS.Gyro[X], INS.Gyro[Y], INS.Gyro[Z], INS.Accel[X], INS.Accel[Y],
 8003f30: 2300         	movs	r3, #0x0
 8003f32: 4a47         	ldr	r2, [pc, #0x11c]        @ 0x8004050 <IMU_Sensor_handle_update+0x224>
 8003f34: 009b         	lsls	r3, r3, #0x2
 8003f36: 4413         	add	r3, r2
 8003f38: edd3 7a00    	vldr	s15, [r3]
 8003f3c: 2301         	movs	r3, #0x1
 8003f3e: 4a44         	ldr	r2, [pc, #0x110]        @ 0x8004050 <IMU_Sensor_handle_update+0x224>
 8003f40: 009b         	lsls	r3, r3, #0x2
 8003f42: 4413         	add	r3, r2
 8003f44: ed93 7a00    	vldr	s14, [r3]
 8003f48: 2302         	movs	r3, #0x2
 8003f4a: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8004050 <IMU_Sensor_handle_update+0x224>
 8003f4c: 009b         	lsls	r3, r3, #0x2
 8003f4e: 4413         	add	r3, r2
 8003f50: edd3 6a00    	vldr	s13, [r3]
 8003f54: 2300         	movs	r3, #0x0
 8003f56: 4a3e         	ldr	r2, [pc, #0xf8]         @ 0x8004050 <IMU_Sensor_handle_update+0x224>
 8003f58: 3302         	adds	r3, #0x2
 8003f5a: 009b         	lsls	r3, r3, #0x2
 8003f5c: 4413         	add	r3, r2
 8003f5e: 3304         	adds	r3, #0x4
 8003f60: ed93 6a00    	vldr	s12, [r3]
 8003f64: 2301         	movs	r3, #0x1
 8003f66: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x8004050 <IMU_Sensor_handle_update+0x224>
 8003f68: 3302         	adds	r3, #0x2
 8003f6a: 009b         	lsls	r3, r3, #0x2
 8003f6c: 4413         	add	r3, r2
 8003f6e: 3304         	adds	r3, #0x4
 8003f70: edd3 5a00    	vldr	s11, [r3]
 8003f74: 2302         	movs	r3, #0x2
 8003f76: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x8004050 <IMU_Sensor_handle_update+0x224>
 8003f78: 3302         	adds	r3, #0x2
 8003f7a: 009b         	lsls	r3, r3, #0x2
 8003f7c: 4413         	add	r3, r2
 8003f7e: 3304         	adds	r3, #0x4
 8003f80: ed93 5a00    	vldr	s10, [r3]
 8003f84: edd7 3a06    	vldr	s7, [r7, #24]
 8003f88: ed97 3a07    	vldr	s6, [r7, #28]
 8003f8c: eef0 2a45    	vmov.f32	s5, s10
 8003f90: eeb0 2a65    	vmov.f32	s4, s11
 8003f94: eef0 1a46    	vmov.f32	s3, s12
 8003f98: eeb0 1a66    	vmov.f32	s2, s13
 8003f9c: eef0 0a47    	vmov.f32	s1, s14
 8003fa0: eeb0 0a67    	vmov.f32	s0, s15
 8003fa4: f7fe fb1c    	bl	0x80025e0 <IMU_QuaternionEKF_Update> @ imm = #-0x19c8
; 	data->gyro_prev_cyc = data->gyro_curr_cyc;
 8003fa8: 687b         	ldr	r3, [r7, #0x4]
 8003faa: 6b5a         	ldr	r2, [r3, #0x34]
 8003fac: 687b         	ldr	r3, [r7, #0x4]
 8003fae: 629a         	str	r2, [r3, #0x28]
; 	data->accel_prev_cyc = data->accel_curr_cyc;
 8003fb0: 687b         	ldr	r3, [r7, #0x4]
 8003fb2: 6b9a         	ldr	r2, [r3, #0x38]
 8003fb4: 687b         	ldr	r3, [r7, #0x4]
 8003fb6: 62da         	str	r2, [r3, #0x2c]
; 	if (count % 50 == 0) {
 8003fb8: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8004044 <IMU_Sensor_handle_update+0x218>
 8003fba: 681a         	ldr	r2, [r3]
 8003fbc: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8004054 <IMU_Sensor_handle_update+0x228>
 8003fbe: fb83 1302    	smull	r1, r3, r3, r2
 8003fc2: 1119         	asrs	r1, r3, #0x4
 8003fc4: 17d3         	asrs	r3, r2, #0x1f
 8003fc6: 1acb         	subs	r3, r1, r3
 8003fc8: 2132         	movs	r1, #0x32
 8003fca: fb01 f303    	mul	r3, r1, r3
 8003fce: 1ad3         	subs	r3, r2, r3
 8003fd0: 2b00         	cmp	r3, #0x0
 8003fd2: d128         	bne	0x8004026 <IMU_Sensor_handle_update+0x1fa> @ imm = #0x50
; 		sensor_channel_get(INS.accel_dev, SENSOR_CHAN_DIE_TEMP, &temp);
 8003fd4: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8004050 <IMU_Sensor_handle_update+0x224>
 8003fd6: 6c1b         	ldr	r3, [r3, #0x40]
 8003fd8: f107 020c    	add.w	r2, r7, #0xc
 8003fdc: 210c         	movs	r1, #0xc
 8003fde: 4618         	mov	r0, r3
 8003fe0: f011 fb49    	bl	0x8015676 <sensor_channel_get> @ imm = #0x11692
; 		current_temp = sensor_value_to_double(&temp);
 8003fe4: f107 030c    	add.w	r3, r7, #0xc
 8003fe8: 4618         	mov	r0, r3
 8003fea: f7fc fead    	bl	0x8000d48 <sensor_value_to_double> @ imm = #-0x32a6
 8003fee: ec53 2b10    	vmov	r2, r3, d0
 8003ff2: 4610         	mov	r0, r2
 8003ff4: 4619         	mov	r1, r3
 8003ff6: f7fc fc95    	bl	0x8000924 <__truncdfsf2> @ imm = #-0x36d6
 8003ffa: 4603         	mov	r3, r0
 8003ffc: 4a16         	ldr	r2, [pc, #0x58]         @ 0x8004058 <IMU_Sensor_handle_update+0x22c>
 8003ffe: 6013         	str	r3, [r2]
; 		pid_calc(temp_pwm_pid);
 8004000: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800405c <IMU_Sensor_handle_update+0x230>
 8004002: 681b         	ldr	r3, [r3]
 8004004: 4618         	mov	r0, r3
 8004006: f7ff fc7b    	bl	0x8003900 <pid_calc>    @ imm = #-0x70a
; 					   ((int)temp_pwm_output < 0) ? 0 : (int)temp_pwm_output);
 800400a: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8004060 <IMU_Sensor_handle_update+0x234>
 800400c: edd3 7a00    	vldr	s15, [r3]
 8004010: eefd 7ae7    	vcvt.s32.f32	s15, s15
 8004014: ee17 3a90    	vmov	r3, s15
 8004018: ea23 73e3    	bic.w	r3, r3, r3, asr #31
; 		int ret = pwm_set_pulse_dt(&pwm,
 800401c: 4619         	mov	r1, r3
 800401e: 4811         	ldr	r0, [pc, #0x44]         @ 0x8004064 <IMU_Sensor_handle_update+0x238>
 8004020: f011 fdfb    	bl	0x8015c1a <pwm_set_pulse_dt> @ imm = #0x11bf6
 8004024: 6178         	str	r0, [r7, #0x14]
; 	if (data->update_cb != NULL) {
 8004026: 687b         	ldr	r3, [r7, #0x4]
 8004028: 6bdb         	ldr	r3, [r3, #0x3c]
 800402a: 2b00         	cmp	r3, #0x0
 800402c: d005         	beq	0x800403a <IMU_Sensor_handle_update+0x20e> @ imm = #0xa
; 		data->update_cb(&QEKF_INS);
 800402e: 687b         	ldr	r3, [r7, #0x4]
 8004030: 6bdb         	ldr	r3, [r3, #0x3c]
 8004032: 480d         	ldr	r0, [pc, #0x34]         @ 0x8004068 <IMU_Sensor_handle_update+0x23c>
 8004034: 4798         	blx	r3
 8004036: e000         	b	0x800403a <IMU_Sensor_handle_update+0x20e> @ imm = #0x0
; 		return;
 8004038: bf00         	nop
; }
 800403a: 3720         	adds	r7, #0x20
 800403c: 46bd         	mov	sp, r7
 800403e: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 8004042: bf00         	nop

08004044 <$d>:
 8004044: 08 24 00 20  	.word	0x20002408
 8004048: 19 86 61 18  	.word	0x18618619
 800404c: bd 37 86 35  	.word	0x358637bd
 8004050: bc 23 00 20  	.word	0x200023bc
 8004054: 1f 85 eb 51  	.word	0x51eb851f
 8004058: a4 04 00 20  	.word	0x200004a4
 800405c: d4 04 00 20  	.word	0x200004d4
 8004060: 04 24 00 20  	.word	0x20002404
 8004064: e4 25 02 08  	.word	0x080225e4
 8004068: a0 07 00 20  	.word	0x200007a0

0800406c <InitQuaternion>:
; {
 800406c: b580         	push	{r7, lr}
 800406e: ed2d 8b02    	vpush	{d8}
 8004072: b096         	sub	sp, #0x58
 8004074: af00         	add	r7, sp, #0x0
 8004076: 60f8         	str	r0, [r7, #0xc]
 8004078: 60b9         	str	r1, [r7, #0x8]
 800407a: 607a         	str	r2, [r7, #0x4]
; 	float acc_init[3] = {0};
 800407c: f107 0344    	add.w	r3, r7, #0x44
 8004080: 2200         	movs	r2, #0x0
 8004082: 601a         	str	r2, [r3]
 8004084: 605a         	str	r2, [r3, #0x4]
 8004086: 609a         	str	r2, [r3, #0x8]
; 	float gravity_norm[3] = {0, 0, 1}; // 导航系重力加速度矢量,归一化后为(0,0,1)
 8004088: f04f 0300    	mov.w	r3, #0x0
 800408c: 63bb         	str	r3, [r7, #0x38]
 800408e: f04f 0300    	mov.w	r3, #0x0
 8004092: 63fb         	str	r3, [r7, #0x3c]
 8004094: f04f 537e    	mov.w	r3, #0x3f800000
 8004098: 643b         	str	r3, [r7, #0x40]
; 	float axis_rot[3] = {0};           // 旋转轴
 800409a: f107 032c    	add.w	r3, r7, #0x2c
 800409e: 2200         	movs	r2, #0x0
 80040a0: 601a         	str	r2, [r3]
 80040a2: 605a         	str	r2, [r3, #0x4]
 80040a4: 609a         	str	r2, [r3, #0x8]
; 	for (uint8_t i = 0; i < 100; ++i) {
 80040a6: 2300         	movs	r3, #0x0
 80040a8: f887 3057    	strb.w	r3, [r7, #0x57]
 80040ac: e05f         	b	0x800416e <InitQuaternion+0x102> @ imm = #0xbe
; 		sensor_sample_fetch(dev);
 80040ae: 68f8         	ldr	r0, [r7, #0xc]
 80040b0: f011 fad5    	bl	0x801565e <sensor_sample_fetch> @ imm = #0x115aa
; 		sensor_channel_get(dev, SENSOR_CHAN_ACCEL_XYZ, accel_data);
 80040b4: f107 0314    	add.w	r3, r7, #0x14
 80040b8: 461a         	mov	r2, r3
 80040ba: 2103         	movs	r1, #0x3
 80040bc: 68f8         	ldr	r0, [r7, #0xc]
 80040be: f011 fada    	bl	0x8015676 <sensor_channel_get> @ imm = #0x115b4
; 		acc_init[X] += sensor_value_to_float(&accel_data[X]);
 80040c2: 2300         	movs	r3, #0x0
 80040c4: f107 0214    	add.w	r2, r7, #0x14
 80040c8: 00db         	lsls	r3, r3, #0x3
 80040ca: 4413         	add	r3, r2
 80040cc: 4618         	mov	r0, r3
 80040ce: f7fd f99f    	bl	0x8001410 <sensor_value_to_float> @ imm = #-0x2cc2
 80040d2: eeb0 7a40    	vmov.f32	s14, s0
 80040d6: 2300         	movs	r3, #0x0
 80040d8: 009b         	lsls	r3, r3, #0x2
 80040da: 3358         	adds	r3, #0x58
 80040dc: 443b         	add	r3, r7
 80040de: 3b14         	subs	r3, #0x14
 80040e0: edd3 7a00    	vldr	s15, [r3]
 80040e4: 2300         	movs	r3, #0x0
 80040e6: ee77 7a27    	vadd.f32	s15, s14, s15
 80040ea: 009b         	lsls	r3, r3, #0x2
 80040ec: 3358         	adds	r3, #0x58
 80040ee: 443b         	add	r3, r7
 80040f0: 3b14         	subs	r3, #0x14
 80040f2: edc3 7a00    	vstr	s15, [r3]
; 		acc_init[Y] += sensor_value_to_float(&accel_data[Y]);
 80040f6: 2301         	movs	r3, #0x1
 80040f8: f107 0214    	add.w	r2, r7, #0x14
 80040fc: 00db         	lsls	r3, r3, #0x3
 80040fe: 4413         	add	r3, r2
 8004100: 4618         	mov	r0, r3
 8004102: f7fd f985    	bl	0x8001410 <sensor_value_to_float> @ imm = #-0x2cf6
 8004106: eeb0 7a40    	vmov.f32	s14, s0
 800410a: 2301         	movs	r3, #0x1
 800410c: 009b         	lsls	r3, r3, #0x2
 800410e: 3358         	adds	r3, #0x58
 8004110: 443b         	add	r3, r7
 8004112: 3b14         	subs	r3, #0x14
 8004114: edd3 7a00    	vldr	s15, [r3]
 8004118: 2301         	movs	r3, #0x1
 800411a: ee77 7a27    	vadd.f32	s15, s14, s15
 800411e: 009b         	lsls	r3, r3, #0x2
 8004120: 3358         	adds	r3, #0x58
 8004122: 443b         	add	r3, r7
 8004124: 3b14         	subs	r3, #0x14
 8004126: edc3 7a00    	vstr	s15, [r3]
; 		acc_init[Z] += sensor_value_to_float(&accel_data[Z]);
 800412a: 2302         	movs	r3, #0x2
 800412c: f107 0214    	add.w	r2, r7, #0x14
 8004130: 00db         	lsls	r3, r3, #0x3
 8004132: 4413         	add	r3, r2
 8004134: 4618         	mov	r0, r3
 8004136: f7fd f96b    	bl	0x8001410 <sensor_value_to_float> @ imm = #-0x2d2a
 800413a: eeb0 7a40    	vmov.f32	s14, s0
 800413e: 2302         	movs	r3, #0x2
 8004140: 009b         	lsls	r3, r3, #0x2
 8004142: 3358         	adds	r3, #0x58
 8004144: 443b         	add	r3, r7
 8004146: 3b14         	subs	r3, #0x14
 8004148: edd3 7a00    	vldr	s15, [r3]
 800414c: 2302         	movs	r3, #0x2
 800414e: ee77 7a27    	vadd.f32	s15, s14, s15
 8004152: 009b         	lsls	r3, r3, #0x2
 8004154: 3358         	adds	r3, #0x58
 8004156: 443b         	add	r3, r7
 8004158: 3b14         	subs	r3, #0x14
 800415a: edc3 7a00    	vstr	s15, [r3]
; 		k_msleep(1);
 800415e: 2001         	movs	r0, #0x1
 8004160: f011 f9c2    	bl	0x80154e8 <k_msleep>    @ imm = #0x11384
; 	for (uint8_t i = 0; i < 100; ++i) {
 8004164: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8004168: 3301         	adds	r3, #0x1
 800416a: f887 3057    	strb.w	r3, [r7, #0x57]
 800416e: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8004172: 2b63         	cmp	r3, #0x63
 8004174: d99b         	bls	0x80040ae <InitQuaternion+0x42> @ imm = #-0xca
; 	for (uint8_t i = 0; i < 3; ++i) {
 8004176: 2300         	movs	r3, #0x0
 8004178: f887 3056    	strb.w	r3, [r7, #0x56]
 800417c: e018         	b	0x80041b0 <InitQuaternion+0x144> @ imm = #0x30
; 		acc_init[i] /= 100;
 800417e: f897 3056    	ldrb.w	r3, [r7, #0x56]
 8004182: 009b         	lsls	r3, r3, #0x2
 8004184: 3358         	adds	r3, #0x58
 8004186: 443b         	add	r3, r7
 8004188: 3b14         	subs	r3, #0x14
 800418a: ed93 7a00    	vldr	s14, [r3]
 800418e: f897 3056    	ldrb.w	r3, [r7, #0x56]
 8004192: eddf 6a4c    	vldr	s13, [pc, #304]         @ 0x80042c4 <InitQuaternion+0x258>
 8004196: eec7 7a26    	vdiv.f32	s15, s14, s13
 800419a: 009b         	lsls	r3, r3, #0x2
 800419c: 3358         	adds	r3, #0x58
 800419e: 443b         	add	r3, r7
 80041a0: 3b14         	subs	r3, #0x14
 80041a2: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 3; ++i) {
 80041a6: f897 3056    	ldrb.w	r3, [r7, #0x56]
 80041aa: 3301         	adds	r3, #0x1
 80041ac: f887 3056    	strb.w	r3, [r7, #0x56]
 80041b0: f897 3056    	ldrb.w	r3, [r7, #0x56]
 80041b4: 2b02         	cmp	r3, #0x2
 80041b6: d9e2         	bls	0x800417e <InitQuaternion+0x112> @ imm = #-0x3c
; 	accel[X] = acc_init[X];
 80041b8: 2100         	movs	r1, #0x0
 80041ba: 2300         	movs	r3, #0x0
 80041bc: 009b         	lsls	r3, r3, #0x2
 80041be: 687a         	ldr	r2, [r7, #0x4]
 80041c0: 4413         	add	r3, r2
 80041c2: 008a         	lsls	r2, r1, #0x2
 80041c4: 3258         	adds	r2, #0x58
 80041c6: 443a         	add	r2, r7
 80041c8: 3a14         	subs	r2, #0x14
 80041ca: 6812         	ldr	r2, [r2]
 80041cc: 601a         	str	r2, [r3]
; 	accel[Y] = acc_init[Y];
 80041ce: 2101         	movs	r1, #0x1
 80041d0: 2301         	movs	r3, #0x1
 80041d2: 009b         	lsls	r3, r3, #0x2
 80041d4: 687a         	ldr	r2, [r7, #0x4]
 80041d6: 4413         	add	r3, r2
 80041d8: 008a         	lsls	r2, r1, #0x2
 80041da: 3258         	adds	r2, #0x58
 80041dc: 443a         	add	r2, r7
 80041de: 3a14         	subs	r2, #0x14
 80041e0: 6812         	ldr	r2, [r2]
 80041e2: 601a         	str	r2, [r3]
; 	accel[Z] = acc_init[Z];
 80041e4: 2102         	movs	r1, #0x2
 80041e6: 2302         	movs	r3, #0x2
 80041e8: 009b         	lsls	r3, r3, #0x2
 80041ea: 687a         	ldr	r2, [r7, #0x4]
 80041ec: 4413         	add	r3, r2
 80041ee: 008a         	lsls	r2, r1, #0x2
 80041f0: 3258         	adds	r2, #0x58
 80041f2: 443a         	add	r2, r7
 80041f4: 3a14         	subs	r2, #0x14
 80041f6: 6812         	ldr	r2, [r2]
 80041f8: 601a         	str	r2, [r3]
; 	Norm3d(acc_init);
 80041fa: f107 0344    	add.w	r3, r7, #0x44
 80041fe: 4618         	mov	r0, r3
 8004200: f011 fd53    	bl	0x8015caa <Norm3d>      @ imm = #0x11aa6
; 	float angle = acosf(Dot3d(acc_init, gravity_norm));
 8004204: f107 0238    	add.w	r2, r7, #0x38
 8004208: f107 0344    	add.w	r3, r7, #0x44
 800420c: 4611         	mov	r1, r2
 800420e: 4618         	mov	r0, r3
 8004210: f011 fdf1    	bl	0x8015df6 <Dot3d>       @ imm = #0x11be2
 8004214: eef0 7a40    	vmov.f32	s15, s0
 8004218: eeb0 0a67    	vmov.f32	s0, s15
 800421c: f010 f81a    	bl	0x8014254 <acosf>       @ imm = #0x10034
 8004220: ed87 0a14    	vstr	s0, [r7, #80]
; 	Cross3d(acc_init, gravity_norm, axis_rot);
 8004224: f107 022c    	add.w	r2, r7, #0x2c
 8004228: f107 0138    	add.w	r1, r7, #0x38
 800422c: f107 0344    	add.w	r3, r7, #0x44
 8004230: 4618         	mov	r0, r3
 8004232: f011 fd8b    	bl	0x8015d4c <Cross3d>     @ imm = #0x11b16
; 	Norm3d(axis_rot);
 8004236: f107 032c    	add.w	r3, r7, #0x2c
 800423a: 4618         	mov	r0, r3
 800423c: f011 fd35    	bl	0x8015caa <Norm3d>      @ imm = #0x11a6a
; 	init_q4[0] = cosf(angle / 2.0f);
 8004240: edd7 7a14    	vldr	s15, [r7, #80]
 8004244: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 8004248: ee87 7aa6    	vdiv.f32	s14, s15, s13
 800424c: eeb0 0a47    	vmov.f32	s0, s14
 8004250: f010 fa90    	bl	0x8014774 <cosf>        @ imm = #0x10520
 8004254: eef0 7a40    	vmov.f32	s15, s0
 8004258: 68bb         	ldr	r3, [r7, #0x8]
 800425a: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 2; ++i) {
 800425e: 2300         	movs	r3, #0x0
 8004260: f887 3055    	strb.w	r3, [r7, #0x55]
 8004264: e022         	b	0x80042ac <InitQuaternion+0x240> @ imm = #0x44
; 			axis_rot[i] * sinf(angle / 2.0f); // 轴角公式,第三轴为0(没有z轴分量)
 8004266: f897 3055    	ldrb.w	r3, [r7, #0x55]
 800426a: 009b         	lsls	r3, r3, #0x2
 800426c: 3358         	adds	r3, #0x58
 800426e: 443b         	add	r3, r7
 8004270: 3b2c         	subs	r3, #0x2c
 8004272: ed93 8a00    	vldr	s16, [r3]
 8004276: edd7 7a14    	vldr	s15, [r7, #80]
 800427a: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 800427e: ee87 7aa6    	vdiv.f32	s14, s15, s13
 8004282: eeb0 0a47    	vmov.f32	s0, s14
 8004286: f010 fbe7    	bl	0x8014a58 <sinf>        @ imm = #0x107ce
 800428a: eef0 7a40    	vmov.f32	s15, s0
; 		init_q4[i + 1] =
 800428e: f897 3055    	ldrb.w	r3, [r7, #0x55]
 8004292: 3301         	adds	r3, #0x1
 8004294: 009b         	lsls	r3, r3, #0x2
 8004296: 68ba         	ldr	r2, [r7, #0x8]
 8004298: 4413         	add	r3, r2
; 			axis_rot[i] * sinf(angle / 2.0f); // 轴角公式,第三轴为0(没有z轴分量)
 800429a: ee68 7a27    	vmul.f32	s15, s16, s15
; 		init_q4[i + 1] =
 800429e: edc3 7a00    	vstr	s15, [r3]
; 	for (uint8_t i = 0; i < 2; ++i) {
 80042a2: f897 3055    	ldrb.w	r3, [r7, #0x55]
 80042a6: 3301         	adds	r3, #0x1
 80042a8: f887 3055    	strb.w	r3, [r7, #0x55]
 80042ac: f897 3055    	ldrb.w	r3, [r7, #0x55]
 80042b0: 2b01         	cmp	r3, #0x1
 80042b2: d9d8         	bls	0x8004266 <InitQuaternion+0x1fa> @ imm = #-0x50
; }
 80042b4: bf00         	nop
 80042b6: bf00         	nop
 80042b8: 3758         	adds	r7, #0x58
 80042ba: 46bd         	mov	sp, r7
 80042bc: ecbd 8b02    	vpop	{d8}
 80042c0: bd80         	pop	{r7, pc}
 80042c2: bf00         	nop

080042c4 <$d>:
 80042c4: 00 00 c8 42  	.word	0x42c80000

080042c8 <IMU_Sensor_trig_handler>:
; {
 80042c8: b590         	push	{r4, r7, lr}
 80042ca: b097         	sub	sp, #0x5c
 80042cc: af00         	add	r7, sp, #0x0
 80042ce: 6078         	str	r0, [r7, #0x4]
 80042d0: 6039         	str	r1, [r7]
; 	if (trigger->type != SENSOR_TRIG_DATA_READY) {
 80042d2: 683b         	ldr	r3, [r7]
 80042d4: 881b         	ldrh	r3, [r3]
 80042d6: 2b01         	cmp	r3, #0x1
 80042d8: f040 80ab    	bne.w	0x8004432 <IMU_Sensor_trig_handler+0x16a> @ imm = #0x156
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80042dc: f3ef 8311    	mrs	r3, basepri
 80042e0: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 80042e2: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 80042e4: 64bb         	str	r3, [r7, #0x48]
 80042e6: 2310         	movs	r3, #0x10
 80042e8: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80042ea: 6c7b         	ldr	r3, [r7, #0x44]
 80042ec: f383 8812    	msr	basepri_max, r3
; }
 80042f0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80042f2: f3bf 8f6f    	isb	sy
; }
 80042f6: bf00         	nop
; 	return key;
 80042f8: 6cbb         	ldr	r3, [r7, #0x48]
; 	unsigned int key = arch_irq_lock();
 80042fa: 657b         	str	r3, [r7, #0x54]
; 	int current_cyc = k_cycle_get_32();
 80042fc: f011 f920    	bl	0x8015540 <k_cycle_get_32> @ imm = #0x11240
 8004300: 4603         	mov	r3, r0
 8004302: 653b         	str	r3, [r7, #0x50]
; 	sensor_sample_fetch(dev);
 8004304: 6878         	ldr	r0, [r7, #0x4]
 8004306: f011 f9aa    	bl	0x801565e <sensor_sample_fetch> @ imm = #0x11354
; 	if (trigger->chan == SENSOR_CHAN_ACCEL_XYZ) {
 800430a: 683b         	ldr	r3, [r7]
 800430c: 885b         	ldrh	r3, [r3, #0x2]
 800430e: 2b03         	cmp	r3, #0x3
 8004310: d149         	bne	0x80043a6 <IMU_Sensor_trig_handler+0xde> @ imm = #0x92
; 		sensor_channel_get(dev, SENSOR_CHAN_ACCEL_XYZ, accel_data);
 8004312: f107 0324    	add.w	r3, r7, #0x24
 8004316: 461a         	mov	r2, r3
 8004318: 2103         	movs	r1, #0x3
 800431a: 6878         	ldr	r0, [r7, #0x4]
 800431c: f011 f9ab    	bl	0x8015676 <sensor_channel_get> @ imm = #0x11356
; 		INS.flag |= 1;
 8004320: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 8004322: f893 3024    	ldrb.w	r3, [r3, #0x24]
 8004326: f043 0301    	orr	r3, r3, #0x1
 800432a: b2da         	uxtb	r2, r3
 800432c: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 800432e: f883 2024    	strb.w	r2, [r3, #0x24]
; 		INS.accel_curr_cyc = current_cyc;
 8004332: 4a42         	ldr	r2, [pc, #0x108]        @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 8004334: 6d3b         	ldr	r3, [r7, #0x50]
 8004336: 6393         	str	r3, [r2, #0x38]
; 		INS.Accel[X] = sensor_value_to_float(&accel_data[X]);
 8004338: 2300         	movs	r3, #0x0
 800433a: f107 0224    	add.w	r2, r7, #0x24
 800433e: 00db         	lsls	r3, r3, #0x3
 8004340: 4413         	add	r3, r2
 8004342: 2400         	movs	r4, #0x0
 8004344: 4618         	mov	r0, r3
 8004346: f7fd f863    	bl	0x8001410 <sensor_value_to_float> @ imm = #-0x2f3a
 800434a: eef0 7a40    	vmov.f32	s15, s0
 800434e: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 8004350: 1ca3         	adds	r3, r4, #0x2
 8004352: 009b         	lsls	r3, r3, #0x2
 8004354: 4413         	add	r3, r2
 8004356: 3304         	adds	r3, #0x4
 8004358: edc3 7a00    	vstr	s15, [r3]
; 		INS.Accel[Y] = sensor_value_to_float(&accel_data[Y]);
 800435c: 2301         	movs	r3, #0x1
 800435e: f107 0224    	add.w	r2, r7, #0x24
 8004362: 00db         	lsls	r3, r3, #0x3
 8004364: 4413         	add	r3, r2
 8004366: 2401         	movs	r4, #0x1
 8004368: 4618         	mov	r0, r3
 800436a: f7fd f851    	bl	0x8001410 <sensor_value_to_float> @ imm = #-0x2f5e
 800436e: eef0 7a40    	vmov.f32	s15, s0
 8004372: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 8004374: 1ca3         	adds	r3, r4, #0x2
 8004376: 009b         	lsls	r3, r3, #0x2
 8004378: 4413         	add	r3, r2
 800437a: 3304         	adds	r3, #0x4
 800437c: edc3 7a00    	vstr	s15, [r3]
; 		INS.Accel[Z] = sensor_value_to_float(&accel_data[Z]);
 8004380: 2302         	movs	r3, #0x2
 8004382: f107 0224    	add.w	r2, r7, #0x24
 8004386: 00db         	lsls	r3, r3, #0x3
 8004388: 4413         	add	r3, r2
 800438a: 2402         	movs	r4, #0x2
 800438c: 4618         	mov	r0, r3
 800438e: f7fd f83f    	bl	0x8001410 <sensor_value_to_float> @ imm = #-0x2f82
 8004392: eef0 7a40    	vmov.f32	s15, s0
 8004396: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 8004398: 1ca3         	adds	r3, r4, #0x2
 800439a: 009b         	lsls	r3, r3, #0x2
 800439c: 4413         	add	r3, r2
 800439e: 3304         	adds	r3, #0x4
 80043a0: edc3 7a00    	vstr	s15, [r3]
 80043a4: e036         	b	0x8004414 <IMU_Sensor_trig_handler+0x14c> @ imm = #0x6c
; 	} else if (trigger->chan == SENSOR_CHAN_GYRO_XYZ) {
 80043a6: 683b         	ldr	r3, [r7]
 80043a8: 885b         	ldrh	r3, [r3, #0x2]
 80043aa: 2b07         	cmp	r3, #0x7
 80043ac: d132         	bne	0x8004414 <IMU_Sensor_trig_handler+0x14c> @ imm = #0x64
; 		sensor_channel_get(dev, SENSOR_CHAN_GYRO_XYZ, gyro_data);
 80043ae: f107 030c    	add.w	r3, r7, #0xc
 80043b2: 461a         	mov	r2, r3
 80043b4: 2107         	movs	r1, #0x7
 80043b6: 6878         	ldr	r0, [r7, #0x4]
 80043b8: f011 f95d    	bl	0x8015676 <sensor_channel_get> @ imm = #0x112ba
; 		INS.flag |= 2;
 80043bc: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 80043be: f893 3024    	ldrb.w	r3, [r3, #0x24]
 80043c2: f043 0302    	orr	r3, r3, #0x2
 80043c6: b2da         	uxtb	r2, r3
 80043c8: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 80043ca: f883 2024    	strb.w	r2, [r3, #0x24]
; 		INS.gyro_curr_cyc = current_cyc;
 80043ce: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 80043d0: 6d3b         	ldr	r3, [r7, #0x50]
 80043d2: 6353         	str	r3, [r2, #0x34]
; 		INS.Gyro[0] = sensor_value_to_float(&gyro_data[0]);
 80043d4: f107 030c    	add.w	r3, r7, #0xc
 80043d8: 4618         	mov	r0, r3
 80043da: f7fd f819    	bl	0x8001410 <sensor_value_to_float> @ imm = #-0x2fce
 80043de: eef0 7a40    	vmov.f32	s15, s0
 80043e2: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 80043e4: edc3 7a00    	vstr	s15, [r3]
; 		INS.Gyro[1] = sensor_value_to_float(&gyro_data[1]);
 80043e8: f107 030c    	add.w	r3, r7, #0xc
 80043ec: 3308         	adds	r3, #0x8
 80043ee: 4618         	mov	r0, r3
 80043f0: f7fd f80e    	bl	0x8001410 <sensor_value_to_float> @ imm = #-0x2fe4
 80043f4: eef0 7a40    	vmov.f32	s15, s0
 80043f8: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 80043fa: edc3 7a01    	vstr	s15, [r3, #4]
; 		INS.Gyro[2] = sensor_value_to_float(&gyro_data[2]);
 80043fe: f107 030c    	add.w	r3, r7, #0xc
 8004402: 3310         	adds	r3, #0x10
 8004404: 4618         	mov	r0, r3
 8004406: f7fd f803    	bl	0x8001410 <sensor_value_to_float> @ imm = #-0x2ffa
 800440a: eef0 7a40    	vmov.f32	s15, s0
 800440e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 8004410: edc3 7a02    	vstr	s15, [r3, #8]
; 	IMU_Sensor_handle_update(&INS);
 8004414: 4809         	ldr	r0, [pc, #0x24]         @ 0x800443c <IMU_Sensor_trig_handler+0x174>
 8004416: f7ff fd09    	bl	0x8003e2c <IMU_Sensor_handle_update> @ imm = #-0x5ee
 800441a: 6d7b         	ldr	r3, [r7, #0x54]
 800441c: 643b         	str	r3, [r7, #0x40]
 800441e: 6c3b         	ldr	r3, [r7, #0x40]
 8004420: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004422: 6bfb         	ldr	r3, [r7, #0x3c]
 8004424: f383 8811    	msr	basepri, r3
; }
 8004428: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800442a: f3bf 8f6f    	isb	sy
; }
 800442e: bf00         	nop
; }
 8004430: e000         	b	0x8004434 <IMU_Sensor_trig_handler+0x16c> @ imm = #0x0
; 		return;
 8004432: bf00         	nop
; }
 8004434: 375c         	adds	r7, #0x5c
 8004436: 46bd         	mov	sp, r7
 8004438: bd90         	pop	{r4, r7, pc}
 800443a: bf00         	nop

0800443c <$d>:
 800443c: bc 23 00 20  	.word	0x200023bc

08004440 <IMU_Initializer>:
; {
 8004440: b580         	push	{r7, lr}
 8004442: b08a         	sub	sp, #0x28
 8004444: af00         	add	r7, sp, #0x0
 8004446: 60f8         	str	r0, [r7, #0xc]
 8004448: 60b9         	str	r1, [r7, #0x8]
 800444a: 607a         	str	r2, [r7, #0x4]
; 	k_thread_name_set(k_current_get(), "IMU_initialize_thread");
 800444c: f7fc ffd4    	bl	0x80013f8 <k_current_get> @ imm = #-0x3058
 8004450: 4603         	mov	r3, r0
 8004452: 4969         	ldr	r1, [pc, #0x1a4]        @ 0x80045f8 <IMU_Initializer+0x1b8>
 8004454: 4618         	mov	r0, r3
 8004456: f011 f8b3    	bl	0x80155c0 <k_thread_name_set> @ imm = #0x11166
; 	int current_cyc = k_cycle_get_32();
 800445a: f011 f871    	bl	0x8015540 <k_cycle_get_32> @ imm = #0x110e2
 800445e: 4603         	mov	r3, r0
 8004460: 627b         	str	r3, [r7, #0x24]
; 	INS.gyro_prev_cyc = current_cyc;
 8004462: 4a66         	ldr	r2, [pc, #0x198]        @ 0x80045fc <IMU_Initializer+0x1bc>
 8004464: 6a7b         	ldr	r3, [r7, #0x24]
 8004466: 6293         	str	r3, [r2, #0x28]
; 	INS.accel_prev_cyc = current_cyc;
 8004468: 4a64         	ldr	r2, [pc, #0x190]        @ 0x80045fc <IMU_Initializer+0x1bc>
 800446a: 6a7b         	ldr	r3, [r7, #0x24]
 800446c: 62d3         	str	r3, [r2, #0x2c]
; 	INS.flag = 0;
 800446e: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x80045fc <IMU_Initializer+0x1bc>
 8004470: 2200         	movs	r2, #0x0
 8004472: f883 2024    	strb.w	r2, [r3, #0x24]
; 	pid_reg_input(temp_pwm_pid, &current_temp, &target_temp);
 8004476: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8004600 <IMU_Initializer+0x1c0>
 8004478: 681b         	ldr	r3, [r3]
 800447a: 4a62         	ldr	r2, [pc, #0x188]        @ 0x8004604 <IMU_Initializer+0x1c4>
 800447c: 4962         	ldr	r1, [pc, #0x188]        @ 0x8004608 <IMU_Initializer+0x1c8>
 800447e: 4618         	mov	r0, r3
 8004480: f011 fb5a    	bl	0x8015b38 <pid_reg_input> @ imm = #0x116b4
; 	pid_reg_output(temp_pwm_pid, &temp_pwm_output);
 8004484: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x8004600 <IMU_Initializer+0x1c0>
 8004486: 681b         	ldr	r3, [r3]
 8004488: 4960         	ldr	r1, [pc, #0x180]        @ 0x800460c <IMU_Initializer+0x1cc>
 800448a: 4618         	mov	r0, r3
 800448c: f011 fb6a    	bl	0x8015b64 <pid_reg_output> @ imm = #0x116d4
; 	pid_reg_time(temp_pwm_pid, &INS.accel_curr_cyc, &INS.accel_prev_cyc);
 8004490: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8004600 <IMU_Initializer+0x1c0>
 8004492: 681b         	ldr	r3, [r3]
 8004494: 4a5e         	ldr	r2, [pc, #0x178]        @ 0x8004610 <IMU_Initializer+0x1d0>
 8004496: 495f         	ldr	r1, [pc, #0x17c]        @ 0x8004614 <IMU_Initializer+0x1d4>
 8004498: 4618         	mov	r0, r3
 800449a: f011 fb75    	bl	0x8015b88 <pid_reg_time> @ imm = #0x116ea
; 	if (!pwm_is_ready_dt(&pwm)) {
 800449e: 485e         	ldr	r0, [pc, #0x178]        @ 0x8004618 <IMU_Initializer+0x1d8>
 80044a0: f011 fbd1    	bl	0x8015c46 <pwm_is_ready_dt> @ imm = #0x117a2
 80044a4: 4603         	mov	r3, r0
 80044a6: f083 0301    	eor	r3, r3, #0x1
 80044aa: b2db         	uxtb	r3, r3
 80044ac: 2b00         	cmp	r3, #0x0
 80044ae: d006         	beq	0x80044be <IMU_Initializer+0x7e> @ imm = #0xc
; 		printk("Error: PWM device %s is not ready\n", pwm.dev->name);
 80044b0: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800461c <IMU_Initializer+0x1dc>
 80044b2: 681b         	ldr	r3, [r3]
 80044b4: 4619         	mov	r1, r3
 80044b6: 485a         	ldr	r0, [pc, #0x168]        @ 0x8004620 <IMU_Initializer+0x1e0>
 80044b8: f012 fa0a    	bl	0x80168d0 <printk>      @ imm = #0x12414
; 		goto init;
 80044bc: e061         	b	0x8004582 <IMU_Initializer+0x142> @ imm = #0xc2
; 		sensor_sample_fetch(INS.accel_dev);
 80044be: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x80045fc <IMU_Initializer+0x1bc>
 80044c0: 6c1b         	ldr	r3, [r3, #0x40]
 80044c2: 4618         	mov	r0, r3
 80044c4: f011 f8cb    	bl	0x801565e <sensor_sample_fetch> @ imm = #0x11196
; 		current_cyc = k_cycle_get_32();
 80044c8: f011 f83a    	bl	0x8015540 <k_cycle_get_32> @ imm = #0x11074
 80044cc: 4603         	mov	r3, r0
 80044ce: 627b         	str	r3, [r7, #0x24]
; 		INS.gyro_prev_cyc = INS.gyro_curr_cyc;
 80044d0: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x80045fc <IMU_Initializer+0x1bc>
 80044d2: 6b5b         	ldr	r3, [r3, #0x34]
 80044d4: 4a49         	ldr	r2, [pc, #0x124]        @ 0x80045fc <IMU_Initializer+0x1bc>
 80044d6: 6293         	str	r3, [r2, #0x28]
; 		INS.accel_prev_cyc = INS.accel_curr_cyc;
 80044d8: 4b48         	ldr	r3, [pc, #0x120]        @ 0x80045fc <IMU_Initializer+0x1bc>
 80044da: 6b9b         	ldr	r3, [r3, #0x38]
 80044dc: 4a47         	ldr	r2, [pc, #0x11c]        @ 0x80045fc <IMU_Initializer+0x1bc>
 80044de: 62d3         	str	r3, [r2, #0x2c]
; 		INS.accel_curr_cyc = current_cyc;
 80044e0: 4a46         	ldr	r2, [pc, #0x118]        @ 0x80045fc <IMU_Initializer+0x1bc>
 80044e2: 6a7b         	ldr	r3, [r7, #0x24]
 80044e4: 6393         	str	r3, [r2, #0x38]
; 		INS.gyro_curr_cyc = current_cyc;
 80044e6: 4a45         	ldr	r2, [pc, #0x114]        @ 0x80045fc <IMU_Initializer+0x1bc>
 80044e8: 6a7b         	ldr	r3, [r7, #0x24]
 80044ea: 6353         	str	r3, [r2, #0x34]
; 		sensor_channel_get(INS.accel_dev, SENSOR_CHAN_DIE_TEMP, &temp);
 80044ec: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x80045fc <IMU_Initializer+0x1bc>
 80044ee: 6c1b         	ldr	r3, [r3, #0x40]
 80044f0: f107 0214    	add.w	r2, r7, #0x14
 80044f4: 210c         	movs	r1, #0xc
 80044f6: 4618         	mov	r0, r3
 80044f8: f011 f8bd    	bl	0x8015676 <sensor_channel_get> @ imm = #0x1117a
; 		current_temp = sensor_value_to_double(&temp);
 80044fc: f107 0314    	add.w	r3, r7, #0x14
 8004500: 4618         	mov	r0, r3
 8004502: f7fc fc21    	bl	0x8000d48 <sensor_value_to_double> @ imm = #-0x37be
 8004506: ec53 2b10    	vmov	r2, r3, d0
 800450a: 4610         	mov	r0, r2
 800450c: 4619         	mov	r1, r3
 800450e: f7fc fa09    	bl	0x8000924 <__truncdfsf2> @ imm = #-0x3bee
 8004512: 4603         	mov	r3, r0
 8004514: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x8004608 <IMU_Initializer+0x1c8>
 8004516: 6013         	str	r3, [r2]
; 		if (fabsf(current_temp - target_temp) < 1.0f) {
 8004518: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8004608 <IMU_Initializer+0x1c8>
 800451a: ed93 7a00    	vldr	s14, [r3]
 800451e: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8004604 <IMU_Initializer+0x1c4>
 8004520: edd3 7a00    	vldr	s15, [r3]
 8004524: ee77 7a67    	vsub.f32	s15, s14, s15
 8004528: edc7 7a08    	vstr	s15, [r7, #32]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 800452c: edd7 7a08    	vldr	s15, [r7, #32]
 8004530: eef0 7ae7    	vabs.f32	s15, s15
 8004534: edc7 7a07    	vstr	s15, [r7, #28]
;     return result;
 8004538: edd7 7a07    	vldr	s15, [r7, #28]
; 		if (fabsf(current_temp - target_temp) < 1.0f) {
 800453c: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 8004540: eef4 7ac7    	vcmpe.f32	s15, s14
 8004544: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8004548: d41a         	bmi	0x8004580 <IMU_Initializer+0x140> @ imm = #0x34
; 		pid_calc(temp_pwm_pid);
 800454a: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8004600 <IMU_Initializer+0x1c0>
 800454c: 681b         	ldr	r3, [r3]
 800454e: 4618         	mov	r0, r3
 8004550: f7ff f9d6    	bl	0x8003900 <pid_calc>    @ imm = #-0xc54
; 		pwm_set_pulse_dt(&pwm, ((int)temp_pwm_output < 0) ? 0 : (int)temp_pwm_output);
 8004554: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x800460c <IMU_Initializer+0x1cc>
 8004556: edd3 7a00    	vldr	s15, [r3]
 800455a: eefd 7ae7    	vcvt.s32.f32	s15, s15
 800455e: ee17 3a90    	vmov	r3, s15
 8004562: ea23 73e3    	bic.w	r3, r3, r3, asr #31
 8004566: 4619         	mov	r1, r3
 8004568: 482b         	ldr	r0, [pc, #0xac]         @ 0x8004618 <IMU_Initializer+0x1d8>
 800456a: f011 fb56    	bl	0x8015c1a <pwm_set_pulse_dt> @ imm = #0x116ac
; 		count++;
 800456e: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8004624 <IMU_Initializer+0x1e4>
 8004570: 681b         	ldr	r3, [r3]
 8004572: 3301         	adds	r3, #0x1
 8004574: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8004624 <IMU_Initializer+0x1e4>
 8004576: 6013         	str	r3, [r2]
; 		k_msleep(50);
 8004578: 2032         	movs	r0, #0x32
 800457a: f010 ffb5    	bl	0x80154e8 <k_msleep>    @ imm = #0x10f6a
; 		sensor_sample_fetch(INS.accel_dev);
 800457e: e79e         	b	0x80044be <IMU_Initializer+0x7e> @ imm = #-0xc4
; 			break;
 8004580: bf00         	nop
; 	InitQuaternion(INS.accel_dev, init_quaternion, INS.lpf_Accel);
 8004582: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80045fc <IMU_Initializer+0x1bc>
 8004584: 6c1b         	ldr	r3, [r3, #0x40]
 8004586: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8004628 <IMU_Initializer+0x1e8>
 8004588: 4928         	ldr	r1, [pc, #0xa0]         @ 0x800462c <IMU_Initializer+0x1ec>
 800458a: 4618         	mov	r0, r3
 800458c: f7ff fd6e    	bl	0x800406c <InitQuaternion> @ imm = #-0x524
; 	IMU_QuaternionEKF_Init(init_quaternion, 10, 0.001, 100000, 1, 0.95);
 8004590: ed9f 2a27    	vldr	s4, [pc, #156]          @ 0x8004630 <IMU_Initializer+0x1f0>
 8004594: eef7 1a00    	vmov.f32	s3, #1.000000e+00
 8004598: ed9f 1a26    	vldr	s2, [pc, #152]          @ 0x8004634 <IMU_Initializer+0x1f4>
 800459c: eddf 0a26    	vldr	s1, [pc, #152]          @ 0x8004638 <IMU_Initializer+0x1f8>
 80045a0: eeb2 0a04    	vmov.f32	s0, #1.000000e+01
 80045a4: 4821         	ldr	r0, [pc, #0x84]         @ 0x800462c <IMU_Initializer+0x1ec>
 80045a6: f7fd ff71    	bl	0x800248c <IMU_QuaternionEKF_Init> @ imm = #-0x211e
; 	current_cyc = k_cycle_get_32();
 80045aa: f010 ffc9    	bl	0x8015540 <k_cycle_get_32> @ imm = #0x10f92
 80045ae: 4603         	mov	r3, r0
 80045b0: 627b         	str	r3, [r7, #0x24]
; 	INS.gyro_prev_cyc = current_cyc;
 80045b2: 4a12         	ldr	r2, [pc, #0x48]         @ 0x80045fc <IMU_Initializer+0x1bc>
 80045b4: 6a7b         	ldr	r3, [r7, #0x24]
 80045b6: 6293         	str	r3, [r2, #0x28]
; 	INS.accel_prev_cyc = current_cyc;
 80045b8: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80045fc <IMU_Initializer+0x1bc>
 80045ba: 6a7b         	ldr	r3, [r7, #0x24]
 80045bc: 62d3         	str	r3, [r2, #0x2c]
; 	INS.flag = 0;
 80045be: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80045fc <IMU_Initializer+0x1bc>
 80045c0: 2200         	movs	r2, #0x0
 80045c2: f883 2024    	strb.w	r2, [r3, #0x24]
; 	sensor_trigger_set(INS.accel_dev, &accel_trig, IMU_Sensor_trig_handler);
 80045c6: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80045fc <IMU_Initializer+0x1bc>
 80045c8: 6c1b         	ldr	r3, [r3, #0x40]
 80045ca: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x800463c <IMU_Initializer+0x1fc>
 80045cc: 491c         	ldr	r1, [pc, #0x70]         @ 0x8004640 <IMU_Initializer+0x200>
 80045ce: 4618         	mov	r0, r3
 80045d0: f011 f804    	bl	0x80155dc <sensor_trigger_set> @ imm = #0x11008
; 	sensor_trigger_set(INS.gyro_dev, &gyro_trig, IMU_Sensor_trig_handler);
 80045d4: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80045fc <IMU_Initializer+0x1bc>
 80045d6: 6c5b         	ldr	r3, [r3, #0x44]
 80045d8: 4a18         	ldr	r2, [pc, #0x60]         @ 0x800463c <IMU_Initializer+0x1fc>
 80045da: 491a         	ldr	r1, [pc, #0x68]         @ 0x8004644 <IMU_Initializer+0x204>
 80045dc: 4618         	mov	r0, r3
 80045de: f010 fffd    	bl	0x80155dc <sensor_trigger_set> @ imm = #0x10ffa
; 	k_thread_abort(k_current_get());
 80045e2: f7fc ff09    	bl	0x80013f8 <k_current_get> @ imm = #-0x31ee
 80045e6: 4603         	mov	r3, r0
 80045e8: 4618         	mov	r0, r3
 80045ea: f010 ffde    	bl	0x80155aa <k_thread_abort> @ imm = #0x10fbc
; 	return;
 80045ee: bf00         	nop
; }
 80045f0: 3728         	adds	r7, #0x28
 80045f2: 46bd         	mov	sp, r7
 80045f4: bd80         	pop	{r7, pc}
 80045f6: bf00         	nop

080045f8 <$d>:
 80045f8: 48 07 02 08  	.word	0x08020748
 80045fc: bc 23 00 20  	.word	0x200023bc
 8004600: d4 04 00 20  	.word	0x200004d4
 8004604: a0 04 00 20  	.word	0x200004a0
 8004608: a4 04 00 20  	.word	0x200004a4
 800460c: 04 24 00 20  	.word	0x20002404
 8004610: e8 23 00 20  	.word	0x200023e8
 8004614: f4 23 00 20  	.word	0x200023f4
 8004618: e4 25 02 08  	.word	0x080225e4
 800461c: d4 02 02 08  	.word	0x080202d4
 8004620: 60 07 02 08  	.word	0x08020760
 8004624: 08 24 00 20  	.word	0x20002408
 8004628: d4 23 00 20  	.word	0x200023d4
 800462c: d8 04 00 20  	.word	0x200004d8
 8004630: 33 33 73 3f  	.word	0x3f733333
 8004634: 00 50 c3 47  	.word	0x47c35000
 8004638: 6f 12 83 3a  	.word	0x3a83126f
 800463c: c9 42 00 08  	.word	0x080042c9
 8004640: 98 04 00 20  	.word	0x20000498
 8004644: 9c 04 00 20  	.word	0x2000049c

08004648 <IMU_Sensor_trig_init>:
; {
 8004648: b580         	push	{r7, lr}
 800464a: b0d0         	sub	sp, #0x140
 800464c: af08         	add	r7, sp, #0x20
 800464e: f507 7390    	add.w	r3, r7, #0x120
 8004652: f5a3 738e    	sub.w	r3, r3, #0x11c
 8004656: 6018         	str	r0, [r3]
 8004658: f507 7390    	add.w	r3, r7, #0x120
 800465c: f5a3 7390    	sub.w	r3, r3, #0x120
 8004660: 6019         	str	r1, [r3]
; 	IMU_Param.scale[X] = 1;
 8004662: 2300         	movs	r3, #0x0
 8004664: 4a2a         	ldr	r2, [pc, #0xa8]         @ 0x8004710 <IMU_Sensor_trig_init+0xc8>
 8004666: 009b         	lsls	r3, r3, #0x2
 8004668: 4413         	add	r3, r2
 800466a: 3304         	adds	r3, #0x4
 800466c: f04f 527e    	mov.w	r2, #0x3f800000
 8004670: 601a         	str	r2, [r3]
; 	IMU_Param.scale[Y] = 1;
 8004672: 2301         	movs	r3, #0x1
 8004674: 4a26         	ldr	r2, [pc, #0x98]         @ 0x8004710 <IMU_Sensor_trig_init+0xc8>
 8004676: 009b         	lsls	r3, r3, #0x2
 8004678: 4413         	add	r3, r2
 800467a: 3304         	adds	r3, #0x4
 800467c: f04f 527e    	mov.w	r2, #0x3f800000
 8004680: 601a         	str	r2, [r3]
; 	IMU_Param.scale[Z] = 1;
 8004682: 2302         	movs	r3, #0x2
 8004684: 4a22         	ldr	r2, [pc, #0x88]         @ 0x8004710 <IMU_Sensor_trig_init+0xc8>
 8004686: 009b         	lsls	r3, r3, #0x2
 8004688: 4413         	add	r3, r2
 800468a: 3304         	adds	r3, #0x4
 800468c: f04f 527e    	mov.w	r2, #0x3f800000
 8004690: 601a         	str	r2, [r3]
; 	IMU_Param.Yaw = 0;
 8004692: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8004710 <IMU_Sensor_trig_init+0xc8>
 8004694: f04f 0200    	mov.w	r2, #0x0
 8004698: 611a         	str	r2, [r3, #0x10]
; 	IMU_Param.Pitch = 0;
 800469a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8004710 <IMU_Sensor_trig_init+0xc8>
 800469c: f04f 0200    	mov.w	r2, #0x0
 80046a0: 615a         	str	r2, [r3, #0x14]
; 	IMU_Param.Roll = 0;
 80046a2: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8004710 <IMU_Sensor_trig_init+0xc8>
 80046a4: f04f 0200    	mov.w	r2, #0x0
 80046a8: 619a         	str	r2, [r3, #0x18]
; 	IMU_Param.flag = 1;
 80046aa: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8004710 <IMU_Sensor_trig_init+0xc8>
 80046ac: 2201         	movs	r2, #0x1
 80046ae: 701a         	strb	r2, [r3]
; 	INS.accel_dev = accel_dev;
 80046b0: 4a18         	ldr	r2, [pc, #0x60]         @ 0x8004714 <IMU_Sensor_trig_init+0xcc>
 80046b2: f507 7390    	add.w	r3, r7, #0x120
 80046b6: f5a3 738e    	sub.w	r3, r3, #0x11c
 80046ba: 681b         	ldr	r3, [r3]
 80046bc: 6413         	str	r3, [r2, #0x40]
; 	INS.gyro_dev = gyro_dev;
 80046be: 4a15         	ldr	r2, [pc, #0x54]         @ 0x8004714 <IMU_Sensor_trig_init+0xcc>
 80046c0: f507 7390    	add.w	r3, r7, #0x120
 80046c4: f5a3 7390    	sub.w	r3, r3, #0x120
 80046c8: 681b         	ldr	r3, [r3]
 80046ca: 6453         	str	r3, [r2, #0x44]
; 	pwm_set_pulse_dt(&pwm, 20000000);
 80046cc: 4912         	ldr	r1, [pc, #0x48]         @ 0x8004718 <IMU_Sensor_trig_init+0xd0>
 80046ce: 4813         	ldr	r0, [pc, #0x4c]         @ 0x800471c <IMU_Sensor_trig_init+0xd4>
 80046d0: f011 faa3    	bl	0x8015c1a <pwm_set_pulse_dt> @ imm = #0x11546
; 			NULL, -1, 0, K_NO_WAIT);
 80046d4: f04f 0200    	mov.w	r2, #0x0
 80046d8: f04f 0300    	mov.w	r3, #0x0
; 	k_thread_create(&initialize_thread, initialize_stack_area,
 80046dc: f107 0008    	add.w	r0, r7, #0x8
 80046e0: e9cd 2306    	strd	r2, r3, [sp, #24]
 80046e4: 2300         	movs	r3, #0x0
 80046e6: 9304         	str	r3, [sp, #0x10]
 80046e8: f04f 33ff    	mov.w	r3, #0xffffffff
 80046ec: 9303         	str	r3, [sp, #0xc]
 80046ee: 2300         	movs	r3, #0x0
 80046f0: 9302         	str	r3, [sp, #0x8]
 80046f2: 2300         	movs	r3, #0x0
 80046f4: 9301         	str	r3, [sp, #0x4]
 80046f6: 2300         	movs	r3, #0x0
 80046f8: 9300         	str	r3, [sp]
 80046fa: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8004720 <IMU_Sensor_trig_init+0xd8>
 80046fc: f44f 62c0    	mov.w	r2, #0x600
 8004700: 4908         	ldr	r1, [pc, #0x20]         @ 0x8004724 <IMU_Sensor_trig_init+0xdc>
 8004702: f010 ff24    	bl	0x801554e <k_thread_create> @ imm = #0x10e48
; }
 8004706: bf00         	nop
 8004708: f507 7790    	add.w	r7, r7, #0x120
 800470c: 46bd         	mov	sp, r7
 800470e: bd80         	pop	{r7, pc}

08004710 <$d>:
 8004710: a0 23 00 20  	.word	0x200023a0
 8004714: bc 23 00 20  	.word	0x200023bc
 8004718: 00 2d 31 01  	.word	0x01312d00
 800471c: e4 25 02 08  	.word	0x080225e4
 8004720: 41 44 00 08  	.word	0x08004441
 8004724: 00 2b 00 20  	.word	0x20002b00

08004728 <board_init>:
; {
 8004728: b580         	push	{r7, lr}
 800472a: af00         	add	r7, sp, #0x0
; 	printk("Board init done.\n");
 800472c: 4802         	ldr	r0, [pc, #0x8]          @ 0x8004738 <board_init+0x10>
 800472e: f012 f8cf    	bl	0x80168d0 <printk>      @ imm = #0x1219e
; }
 8004732: bf00         	nop
 8004734: bd80         	pop	{r7, pc}
 8004736: bf00         	nop

08004738 <$d>:
 8004738: a4 07 02 08  	.word	0x080207a4

0800473c <main>:
; {
 800473c: b580         	push	{r7, lr}
 800473e: b08a         	sub	sp, #0x28
 8004740: af08         	add	r7, sp, #0x20
; 	board_init();
 8004742: f7ff fff1    	bl	0x8004728 <board_init>  @ imm = #-0x1e
; 	struct JFData *data = jf_send_init(uart_dev, 25);
 8004746: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80047e0 <main+0xa4>
 8004748: 681b         	ldr	r3, [r3]
 800474a: 2119         	movs	r1, #0x19
 800474c: 4618         	mov	r0, r3
 800474e: f7fc ffcd    	bl	0x80016ec <jf_send_init> @ imm = #-0x3066
 8004752: 6038         	str	r0, [r7]
; 	jf_channel_add(data, &QEKF_INS.q[0], PTR_FLOAT);
 8004754: 2201         	movs	r2, #0x1
 8004756: 4923         	ldr	r1, [pc, #0x8c]         @ 0x80047e4 <main+0xa8>
 8004758: 6838         	ldr	r0, [r7]
 800475a: f7fc ff6f    	bl	0x800163c <jf_channel_add> @ imm = #-0x3122
; 	jf_channel_add(data, &QEKF_INS.q[1], PTR_FLOAT);
 800475e: 2201         	movs	r2, #0x1
 8004760: 4921         	ldr	r1, [pc, #0x84]         @ 0x80047e8 <main+0xac>
 8004762: 6838         	ldr	r0, [r7]
 8004764: f7fc ff6a    	bl	0x800163c <jf_channel_add> @ imm = #-0x312c
; 	jf_channel_add(data, &QEKF_INS.q[2], PTR_FLOAT);
 8004768: 2201         	movs	r2, #0x1
 800476a: 4920         	ldr	r1, [pc, #0x80]         @ 0x80047ec <main+0xb0>
 800476c: 6838         	ldr	r0, [r7]
 800476e: f7fc ff65    	bl	0x800163c <jf_channel_add> @ imm = #-0x3136
; 	jf_channel_add(data, &QEKF_INS.q[3], PTR_FLOAT);
 8004772: 2201         	movs	r2, #0x1
 8004774: 491e         	ldr	r1, [pc, #0x78]         @ 0x80047f0 <main+0xb4>
 8004776: 6838         	ldr	r0, [r7]
 8004778: f7fc ff60    	bl	0x800163c <jf_channel_add> @ imm = #-0x3140
; 			NULL, 0, 0, K_NO_WAIT);
 800477c: f04f 0200    	mov.w	r2, #0x0
 8004780: f04f 0300    	mov.w	r3, #0x0
; 	k_thread_create(&feedback_thread_data, feedback_stack_area,
 8004784: e9cd 2306    	strd	r2, r3, [sp, #24]
 8004788: 2300         	movs	r3, #0x0
 800478a: 9304         	str	r3, [sp, #0x10]
 800478c: 2300         	movs	r3, #0x0
 800478e: 9303         	str	r3, [sp, #0xc]
 8004790: 2300         	movs	r3, #0x0
 8004792: 9302         	str	r3, [sp, #0x8]
 8004794: 2300         	movs	r3, #0x0
 8004796: 9301         	str	r3, [sp, #0x4]
 8004798: 2300         	movs	r3, #0x0
 800479a: 9300         	str	r3, [sp]
 800479c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80047f4 <main+0xb8>
 800479e: f44f 6200    	mov.w	r2, #0x800
 80047a2: 4915         	ldr	r1, [pc, #0x54]         @ 0x80047f8 <main+0xbc>
 80047a4: 4815         	ldr	r0, [pc, #0x54]         @ 0x80047fc <main+0xc0>
 80047a6: f010 fed2    	bl	0x801554e <k_thread_create> @ imm = #0x10da4
; 	k_sleep(K_MSEC(50));
 80047aa: f44f 72fa    	mov.w	r2, #0x1f4
 80047ae: f04f 0300    	mov.w	r3, #0x0
 80047b2: 4610         	mov	r0, r2
 80047b4: 4619         	mov	r1, r3
 80047b6: f010 feea    	bl	0x801558e <k_sleep>     @ imm = #0x10dd4
; 	IMU_Sensor_trig_init(accel_dev, gyro_dev);
 80047ba: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8004800 <main+0xc4>
 80047bc: 681b         	ldr	r3, [r3]
 80047be: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8004804 <main+0xc8>
 80047c0: 6812         	ldr	r2, [r2]
 80047c2: 4611         	mov	r1, r2
 80047c4: 4618         	mov	r0, r3
 80047c6: f7ff ff3f    	bl	0x8004648 <IMU_Sensor_trig_init> @ imm = #-0x182
; 	int t = 0;
 80047ca: 2300         	movs	r3, #0x0
 80047cc: 607b         	str	r3, [r7, #0x4]
; 		k_msleep(25);
 80047ce: 2019         	movs	r0, #0x19
 80047d0: f010 fe8a    	bl	0x80154e8 <k_msleep>    @ imm = #0x10d14
; 		t += 50;
 80047d4: 687b         	ldr	r3, [r7, #0x4]
 80047d6: 3332         	adds	r3, #0x32
 80047d8: 607b         	str	r3, [r7, #0x4]
; 		k_msleep(25);
 80047da: bf00         	nop
 80047dc: e7f7         	b	0x80047ce <main+0x92>   @ imm = #-0x12
 80047de: bf00         	nop

080047e0 <$d>:
 80047e0: ec 04 00 20  	.word	0x200004ec
 80047e4: f0 08 00 20  	.word	0x200008f0
 80047e8: f4 08 00 20  	.word	0x200008f4
 80047ec: f8 08 00 20  	.word	0x200008f8
 80047f0: fc 08 00 20  	.word	0x200008fc
 80047f4: 81 0e 00 08  	.word	0x08000e81
 80047f8: 00 31 00 20  	.word	0x20003100
 80047fc: 88 09 00 20  	.word	0x20000988
 8004800: f0 04 00 20  	.word	0x200004f0
 8004804: f4 04 00 20  	.word	0x200004f4

08004808 <linker_is_in_rodata>:
; {
 8004808: b480         	push	{r7}
 800480a: b083         	sub	sp, #0xc
 800480c: af00         	add	r7, sp, #0x0
 800480e: 6078         	str	r0, [r7, #0x4]
; 	return (((const char *)addr >= (const char *)RO_START) &&
 8004810: 687b         	ldr	r3, [r7, #0x4]
 8004812: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8004838 <linker_is_in_rodata+0x30>
 8004814: 4293         	cmp	r3, r2
 8004816: d305         	blo	0x8004824 <linker_is_in_rodata+0x1c> @ imm = #0xa
 8004818: 687b         	ldr	r3, [r7, #0x4]
 800481a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800483c <linker_is_in_rodata+0x34>
 800481c: 4293         	cmp	r3, r2
 800481e: d201         	bhs	0x8004824 <linker_is_in_rodata+0x1c> @ imm = #0x2
 8004820: 2301         	movs	r3, #0x1
 8004822: e000         	b	0x8004826 <linker_is_in_rodata+0x1e> @ imm = #0x0
 8004824: 2300         	movs	r3, #0x0
 8004826: f003 0301    	and	r3, r3, #0x1
 800482a: b2db         	uxtb	r3, r3
; }
 800482c: 4618         	mov	r0, r3
 800482e: 370c         	adds	r7, #0xc
 8004830: 46bd         	mov	sp, r7
 8004832: f85d 7b04    	ldr	r7, [sp], #4
 8004836: 4770         	bx	lr

08004838 <$d>:
 8004838: a0 00 02 08  	.word	0x080200a0
 800483c: b8 34 02 08  	.word	0x080234b8

08004840 <cbvprintf_package>:
; {
 8004840: b580         	push	{r7, lr}
 8004842: b0a4         	sub	sp, #0x90
 8004844: af00         	add	r7, sp, #0x0
 8004846: 60f8         	str	r0, [r7, #0xc]
 8004848: 60b9         	str	r1, [r7, #0x8]
 800484a: 607a         	str	r2, [r7, #0x4]
 800484c: 603b         	str	r3, [r7]
; 	uint8_t *buf0 = packaged;  /* buffer start (may be NULL) */
 800484e: 68fb         	ldr	r3, [r7, #0xc]
 8004850: 65fb         	str	r3, [r7, #0x5c]
; 	uintptr_t buf = (uintptr_t)buf0; /* current buffer position */
 8004852: 6dfb         	ldr	r3, [r7, #0x5c]
 8004854: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
 8004858: 2300         	movs	r3, #0x0
 800485a: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	unsigned int s_rw_cnt = 0; /* number of rw strings */
 800485e: 2300         	movs	r3, #0x0
 8004860: 67fb         	str	r3, [r7, #0x7c]
; 	unsigned int s_ro_cnt = 0; /* number of ro strings */
 8004862: 2300         	movs	r3, #0x0
 8004864: 67bb         	str	r3, [r7, #0x78]
; 	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
 8004866: f04f 33ff    	mov.w	r3, #0xffffffff
 800486a: 677b         	str	r3, [r7, #0x74]
; 	bool parsing = false;
 800486c: 2300         	movs	r3, #0x0
 800486e: f887 306b    	strb.w	r3, [r7, #0x6b]
; 	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
 8004872: 687b         	ldr	r3, [r7, #0x4]
 8004874: f003 0304    	and	r3, r3, #0x4
 8004878: 2b00         	cmp	r3, #0x0
 800487a: bf14         	ite	ne
 800487c: 2301         	movne	r3, #0x1
 800487e: 2300         	moveq	r3, #0x0
 8004880: f887 305b    	strb.w	r3, [r7, #0x5b]
; 	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 8004884: 687b         	ldr	r3, [r7, #0x4]
 8004886: 08db         	lsrs	r3, r3, #0x3
 8004888: f003 0307    	and	r3, r3, #0x7
 800488c: 3301         	adds	r3, #0x1
 800488e: 667b         	str	r3, [r7, #0x64]
; 	bool is_str_arg = false;
 8004890: 2300         	movs	r3, #0x0
 8004892: f887 3063    	strb.w	r3, [r7, #0x63]
; 	union cbprintf_package_hdr *pkg_hdr = packaged;
 8004896: 68fb         	ldr	r3, [r7, #0xc]
 8004898: 657b         	str	r3, [r7, #0x54]
; 	if ((uintptr_t)packaged % sizeof(void *)) {
 800489a: 68fb         	ldr	r3, [r7, #0xc]
 800489c: f003 0303    	and	r3, r3, #0x3
 80048a0: 2b00         	cmp	r3, #0x0
 80048a2: d002         	beq	0x80048aa <cbvprintf_package+0x6a> @ imm = #0x4
; 		return -EFAULT;
 80048a4: f06f 030d    	mvn	r3, #0xd
 80048a8: e3a2         	b	0x8004ff0 <cbvprintf_package+0x7b0> @ imm = #0x744
; 	buf += sizeof(*pkg_hdr);
 80048aa: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80048ae: 3304         	adds	r3, #0x4
 80048b0: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	if (buf0 == NULL) {
 80048b4: 6dfb         	ldr	r3, [r7, #0x5c]
 80048b6: 2b00         	cmp	r3, #0x0
 80048b8: d10d         	bne	0x80048d6 <cbvprintf_package+0x96> @ imm = #0x1a
; 		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
 80048ba: 68bb         	ldr	r3, [r7, #0x8]
 80048bc: f003 0307    	and	r3, r3, #0x7
 80048c0: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80048c4: 4413         	add	r3, r2
 80048c6: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
 80048ca: 68bb         	ldr	r3, [r7, #0x8]
 80048cc: f003 0307    	and	r3, r3, #0x7
 80048d0: f1c3 0308    	rsb.w	r3, r3, #0x8
 80048d4: 60bb         	str	r3, [r7, #0x8]
; 	if ((buf0 != NULL) && (BUF_OFFSET + sizeof(char *)) > len) {
 80048d6: 6dfb         	ldr	r3, [r7, #0x5c]
 80048d8: 2b00         	cmp	r3, #0x0
 80048da: d00a         	beq	0x80048f2 <cbvprintf_package+0xb2> @ imm = #0x14
 80048dc: 6dfb         	ldr	r3, [r7, #0x5c]
 80048de: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80048e2: 1ad3         	subs	r3, r2, r3
 80048e4: 3304         	adds	r3, #0x4
 80048e6: 68ba         	ldr	r2, [r7, #0x8]
 80048e8: 429a         	cmp	r2, r3
 80048ea: d202         	bhs	0x80048f2 <cbvprintf_package+0xb2> @ imm = #0x4
; 		return -ENOSPC;
 80048ec: f06f 031b    	mvn	r3, #0x1b
 80048f0: e37e         	b	0x8004ff0 <cbvprintf_package+0x7b0> @ imm = #0x6fc
; 	s = fmt;
 80048f2: 683b         	ldr	r3, [r7]
 80048f4: 66fb         	str	r3, [r7, #0x6c]
; 	--fmt;
 80048f6: 683b         	ldr	r3, [r7]
 80048f8: 3b01         	subs	r3, #0x1
 80048fa: 603b         	str	r3, [r7]
; 	align = VA_STACK_ALIGN(char *);
 80048fc: 2304         	movs	r3, #0x4
 80048fe: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	size = sizeof(char *);
 8004902: 2304         	movs	r3, #0x4
 8004904: f8c7 3088    	str.w	r3, [r7, #0x88]
; 	goto process_string;
 8004908: e197         	b	0x8004c3a <cbvprintf_package+0x3fa> @ imm = #0x32e
; 			if (!parsing) {
 800490a: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 800490e: f083 0301    	eor	r3, r3, #0x1
 8004912: b2db         	uxtb	r3, r3
 8004914: 2b00         	cmp	r3, #0x0
 8004916: d011         	beq	0x800493c <cbvprintf_package+0xfc> @ imm = #0x22
; 				if (*fmt == '%') {
 8004918: 683b         	ldr	r3, [r7]
 800491a: 781b         	ldrb	r3, [r3]
 800491c: 2b25         	cmp	r3, #0x25
 800491e: f040 8278    	bne.w	0x8004e12 <cbvprintf_package+0x5d2> @ imm = #0x4f0
; 					parsing = true;
 8004922: 2301         	movs	r3, #0x1
 8004924: f887 306b    	strb.w	r3, [r7, #0x6b]
; 					arg_idx++;
 8004928: 6f7b         	ldr	r3, [r7, #0x74]
 800492a: 3301         	adds	r3, #0x1
 800492c: 677b         	str	r3, [r7, #0x74]
; 					align = VA_STACK_ALIGN(int);
 800492e: 2304         	movs	r3, #0x4
 8004930: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(int);
 8004934: 2304         	movs	r3, #0x4
 8004936: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 800493a: e26a         	b	0x8004e12 <cbvprintf_package+0x5d2> @ imm = #0x4d4
; 			switch (*fmt) {
 800493c: 683b         	ldr	r3, [r7]
 800493e: 781b         	ldrb	r3, [r3]
 8004940: 2b7a         	cmp	r3, #0x7a
 8004942: f300 8149    	bgt.w	0x8004bd8 <cbvprintf_package+0x398> @ imm = #0x292
 8004946: 2b4c         	cmp	r3, #0x4c
 8004948: da11         	bge	0x800496e <cbvprintf_package+0x12e> @ imm = #0x22
 800494a: 2b47         	cmp	r3, #0x47
 800494c: f300 8144    	bgt.w	0x8004bd8 <cbvprintf_package+0x398> @ imm = #0x288
 8004950: 2b2a         	cmp	r3, #0x2a
 8004952: da71         	bge	0x8004a38 <cbvprintf_package+0x1f8> @ imm = #0xe2
 8004954: 2b25         	cmp	r3, #0x25
 8004956: f000 8092    	beq.w	0x8004a7e <cbvprintf_package+0x23e> @ imm = #0x124
 800495a: 2b25         	cmp	r3, #0x25
 800495c: f300 813c    	bgt.w	0x8004bd8 <cbvprintf_package+0x398> @ imm = #0x278
 8004960: 2b20         	cmp	r3, #0x20
 8004962: f000 8258    	beq.w	0x8004e16 <cbvprintf_package+0x5d6> @ imm = #0x4b0
 8004966: 2b23         	cmp	r3, #0x23
 8004968: f000 8255    	beq.w	0x8004e16 <cbvprintf_package+0x5d6> @ imm = #0x4aa
 800496c: e134         	b	0x8004bd8 <cbvprintf_package+0x398> @ imm = #0x268
 800496e: 3b4c         	subs	r3, #0x4c
 8004970: 2b2e         	cmp	r3, #0x2e
 8004972: f200 8131    	bhi.w	0x8004bd8 <cbvprintf_package+0x398> @ imm = #0x262
 8004976: a201         	adr	r2, #4 <cbvprintf_package+0x13b>
 8004978: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800497c <$d>:
 800497c: 17 4e 00 08  	.word	0x08004e17
 8004980: d9 4b 00 08  	.word	0x08004bd9
 8004984: d9 4b 00 08  	.word	0x08004bd9
 8004988: d9 4b 00 08  	.word	0x08004bd9
 800498c: d9 4b 00 08  	.word	0x08004bd9
 8004990: d9 4b 00 08  	.word	0x08004bd9
 8004994: d9 4b 00 08  	.word	0x08004bd9
 8004998: d9 4b 00 08  	.word	0x08004bd9
 800499c: d9 4b 00 08  	.word	0x08004bd9
 80049a0: d9 4b 00 08  	.word	0x08004bd9
 80049a4: d9 4b 00 08  	.word	0x08004bd9
 80049a8: d9 4b 00 08  	.word	0x08004bd9
 80049ac: b7 4a 00 08  	.word	0x08004ab7
 80049b0: d9 4b 00 08  	.word	0x08004bd9
 80049b4: d9 4b 00 08  	.word	0x08004bd9
 80049b8: d9 4b 00 08  	.word	0x08004bd9
 80049bc: d9 4b 00 08  	.word	0x08004bd9
 80049c0: d9 4b 00 08  	.word	0x08004bd9
 80049c4: d9 4b 00 08  	.word	0x08004bd9
 80049c8: d9 4b 00 08  	.word	0x08004bd9
 80049cc: d9 4b 00 08  	.word	0x08004bd9
 80049d0: 07 4b 00 08  	.word	0x08004b07
 80049d4: d9 4b 00 08  	.word	0x08004bd9
 80049d8: b7 4a 00 08  	.word	0x08004ab7
 80049dc: b7 4a 00 08  	.word	0x08004ab7
 80049e0: 07 4b 00 08  	.word	0x08004b07
 80049e4: 07 4b 00 08  	.word	0x08004b07
 80049e8: 07 4b 00 08  	.word	0x08004b07
 80049ec: 17 4e 00 08  	.word	0x08004e17
 80049f0: b7 4a 00 08  	.word	0x08004ab7
 80049f4: 8d 4a 00 08  	.word	0x08004a8d
 80049f8: d9 4b 00 08  	.word	0x08004bd9
 80049fc: 17 4e 00 08  	.word	0x08004e17
 8004a00: d9 4b 00 08  	.word	0x08004bd9
 8004a04: f3 4a 00 08  	.word	0x08004af3
 8004a08: b7 4a 00 08  	.word	0x08004ab7
 8004a0c: f3 4a 00 08  	.word	0x08004af3
 8004a10: d9 4b 00 08  	.word	0x08004bd9
 8004a14: d9 4b 00 08  	.word	0x08004bd9
 8004a18: ed 4a 00 08  	.word	0x08004aed
 8004a1c: a9 4a 00 08  	.word	0x08004aa9
 8004a20: b7 4a 00 08  	.word	0x08004ab7
 8004a24: d9 4b 00 08  	.word	0x08004bd9
 8004a28: d9 4b 00 08  	.word	0x08004bd9
 8004a2c: b7 4a 00 08  	.word	0x08004ab7
 8004a30: d9 4b 00 08  	.word	0x08004bd9
 8004a34: 9b 4a 00 08  	.word	0x08004a9b

08004a38 <$t>:
 8004a38: 3b2a         	subs	r3, #0x2a
 8004a3a: 2201         	movs	r2, #0x1
 8004a3c: fa02 f303    	lsl.w	r3, r2, r3
 8004a40: f64f 72da    	movw	r2, #0xffda
 8004a44: 401a         	ands	r2, r3
 8004a46: 2a00         	cmp	r2, #0x0
 8004a48: bf14         	ite	ne
 8004a4a: 2201         	movne	r2, #0x1
 8004a4c: 2200         	moveq	r2, #0x0
 8004a4e: b2d2         	uxtb	r2, r2
 8004a50: 2a00         	cmp	r2, #0x0
 8004a52: f040 81e0    	bne.w	0x8004e16 <cbvprintf_package+0x5d6> @ imm = #0x3c0
 8004a56: f003 5262    	and	r2, r3, #0x38800000
 8004a5a: 2a00         	cmp	r2, #0x0
 8004a5c: bf14         	ite	ne
 8004a5e: 2201         	movne	r2, #0x1
 8004a60: 2200         	moveq	r2, #0x0
 8004a62: b2d2         	uxtb	r2, r2
 8004a64: 2a00         	cmp	r2, #0x0
 8004a66: d14e         	bne	0x8004b06 <cbvprintf_package+0x2c6> @ imm = #0x9c
 8004a68: f003 0301    	and	r3, r3, #0x1
 8004a6c: 2b00         	cmp	r3, #0x0
 8004a6e: bf14         	ite	ne
 8004a70: 2301         	movne	r3, #0x1
 8004a72: 2300         	moveq	r3, #0x0
 8004a74: b2db         	uxtb	r3, r3
 8004a76: 2b00         	cmp	r3, #0x0
 8004a78: f040 80b2    	bne.w	0x8004be0 <cbvprintf_package+0x3a0> @ imm = #0x164
 8004a7c: e0ac         	b	0x8004bd8 <cbvprintf_package+0x398> @ imm = #0x158
; 				parsing = false;
 8004a7e: 2300         	movs	r3, #0x0
 8004a80: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				arg_idx--;
 8004a84: 6f7b         	ldr	r3, [r7, #0x74]
 8004a86: 3b01         	subs	r3, #0x1
 8004a88: 677b         	str	r3, [r7, #0x74]
; 				continue;
 8004a8a: e1c5         	b	0x8004e18 <cbvprintf_package+0x5d8> @ imm = #0x38a
; 				align = VA_STACK_ALIGN(intmax_t);
 8004a8c: 2308         	movs	r3, #0x8
 8004a8e: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(intmax_t);
 8004a92: 2308         	movs	r3, #0x8
 8004a94: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8004a98: e1be         	b	0x8004e18 <cbvprintf_package+0x5d8> @ imm = #0x37c
; 				align = VA_STACK_ALIGN(size_t);
 8004a9a: 2304         	movs	r3, #0x4
 8004a9c: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(size_t);
 8004aa0: 2304         	movs	r3, #0x4
 8004aa2: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8004aa6: e1b7         	b	0x8004e18 <cbvprintf_package+0x5d8> @ imm = #0x36e
; 				align = VA_STACK_ALIGN(ptrdiff_t);
 8004aa8: 2304         	movs	r3, #0x4
 8004aaa: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(ptrdiff_t);
 8004aae: 2304         	movs	r3, #0x4
 8004ab0: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8004ab4: e1b0         	b	0x8004e18 <cbvprintf_package+0x5d8> @ imm = #0x360
; 				if (fmt[-1] == 'l') {
 8004ab6: 683b         	ldr	r3, [r7]
 8004ab8: 3b01         	subs	r3, #0x1
 8004aba: 781b         	ldrb	r3, [r3]
 8004abc: 2b6c         	cmp	r3, #0x6c
 8004abe: d111         	bne	0x8004ae4 <cbvprintf_package+0x2a4> @ imm = #0x22
; 					if (fmt[-2] == 'l') {
 8004ac0: 683b         	ldr	r3, [r7]
 8004ac2: 3b02         	subs	r3, #0x2
 8004ac4: 781b         	ldrb	r3, [r3]
 8004ac6: 2b6c         	cmp	r3, #0x6c
 8004ac8: d106         	bne	0x8004ad8 <cbvprintf_package+0x298> @ imm = #0xc
; 						align = VA_STACK_ALIGN(long long);
 8004aca: 2308         	movs	r3, #0x8
 8004acc: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long long);
 8004ad0: 2308         	movs	r3, #0x8
 8004ad2: f8c7 3088    	str.w	r3, [r7, #0x88]
 8004ad6: e005         	b	0x8004ae4 <cbvprintf_package+0x2a4> @ imm = #0xa
; 						align = VA_STACK_ALIGN(long);
 8004ad8: 2304         	movs	r3, #0x4
 8004ada: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long);
 8004ade: 2304         	movs	r3, #0x4
 8004ae0: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 8004ae4: 2300         	movs	r3, #0x0
 8004ae6: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 8004aea: e07a         	b	0x8004be2 <cbvprintf_package+0x3a2> @ imm = #0xf4
; 				is_str_arg = true;
 8004aec: 2301         	movs	r3, #0x1
 8004aee: f887 3063    	strb.w	r3, [r7, #0x63]
; 				align = VA_STACK_ALIGN(void *);
 8004af2: 2304         	movs	r3, #0x4
 8004af4: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(void *);
 8004af8: 2304         	movs	r3, #0x4
 8004afa: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 8004afe: 2300         	movs	r3, #0x0
 8004b00: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 8004b04: e06d         	b	0x8004be2 <cbvprintf_package+0x3a2> @ imm = #0xda
; 				if (fmt[-1] == 'L') {
 8004b06: 683b         	ldr	r3, [r7]
 8004b08: 3b01         	subs	r3, #0x1
 8004b0a: 781b         	ldrb	r3, [r3]
 8004b0c: 2b4c         	cmp	r3, #0x4c
 8004b0e: d113         	bne	0x8004b38 <cbvprintf_package+0x2f8> @ imm = #0x26
; 					v.ld = va_arg(ap, long double);
 8004b10: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8004b14: 3307         	adds	r3, #0x7
 8004b16: f023 0307    	bic	r3, r3, #0x7
 8004b1a: f103 0208    	add.w	r2, r3, #0x8
 8004b1e: f8c7 2098    	str.w	r2, [r7, #0x98]
 8004b22: e9d3 2300    	ldrd	r2, r3, [r3]
 8004b26: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(long double);
 8004b2a: 2308         	movs	r3, #0x8
 8004b2c: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(long double);
 8004b30: 2308         	movs	r3, #0x8
 8004b32: f8c7 3088    	str.w	r3, [r7, #0x88]
 8004b36: e012         	b	0x8004b5e <cbvprintf_package+0x31e> @ imm = #0x24
; 					v.d = va_arg(ap, double);
 8004b38: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8004b3c: 3307         	adds	r3, #0x7
 8004b3e: f023 0307    	bic	r3, r3, #0x7
 8004b42: f103 0208    	add.w	r2, r3, #0x8
 8004b46: f8c7 2098    	str.w	r2, [r7, #0x98]
 8004b4a: e9d3 2300    	ldrd	r2, r3, [r3]
 8004b4e: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(double);
 8004b52: 2308         	movs	r3, #0x8
 8004b54: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(double);
 8004b58: 2308         	movs	r3, #0x8
 8004b5a: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				buf = ROUND_UP(buf, align);
 8004b5e: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8004b62: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004b66: 4413         	add	r3, r2
 8004b68: 1e5a         	subs	r2, r3, #0x1
 8004b6a: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8004b6e: fbb2 f2f3    	udiv	r2, r2, r3
 8004b72: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8004b76: fb02 f303    	mul	r3, r2, r3
 8004b7a: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				if (buf0 != NULL) {
 8004b7e: 6dfb         	ldr	r3, [r7, #0x5c]
 8004b80: 2b00         	cmp	r3, #0x0
 8004b82: d01e         	beq	0x8004bc2 <cbvprintf_package+0x382> @ imm = #0x3c
; 					if (BUF_OFFSET + size > len) {
 8004b84: 6dfb         	ldr	r3, [r7, #0x5c]
 8004b86: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004b8a: 1ad2         	subs	r2, r2, r3
 8004b8c: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8004b90: 4413         	add	r3, r2
 8004b92: 68ba         	ldr	r2, [r7, #0x8]
 8004b94: 429a         	cmp	r2, r3
 8004b96: d202         	bhs	0x8004b9e <cbvprintf_package+0x35e> @ imm = #0x4
; 						return -ENOSPC;
 8004b98: f06f 031b    	mvn	r3, #0x1b
 8004b9c: e228         	b	0x8004ff0 <cbvprintf_package+0x7b0> @ imm = #0x450
; 					} else if (fmt[-1] == 'L') {
 8004b9e: 683b         	ldr	r3, [r7]
 8004ba0: 3b01         	subs	r3, #0x1
 8004ba2: 781b         	ldrb	r3, [r3]
 8004ba4: 2b4c         	cmp	r3, #0x4c
 8004ba6: d106         	bne	0x8004bb6 <cbvprintf_package+0x376> @ imm = #0xc
; 						*(long double *)buf = v.ld;
 8004ba8: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8004bac: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8004bb0: e9c1 2300    	strd	r2, r3, [r1]
 8004bb4: e005         	b	0x8004bc2 <cbvprintf_package+0x382> @ imm = #0xa
; 						*(double *)buf = v.d;
 8004bb6: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8004bba: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8004bbe: e9c1 2300    	strd	r2, r3, [r1]
; 				buf += size;
 8004bc2: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004bc6: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8004bca: 4413         	add	r3, r2
 8004bcc: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				parsing = false;
 8004bd0: 2300         	movs	r3, #0x0
 8004bd2: f887 306b    	strb.w	r3, [r7, #0x6b]
 8004bd6: e11f         	b	0x8004e18 <cbvprintf_package+0x5d8> @ imm = #0x23e
; 				parsing = false;
 8004bd8: 2300         	movs	r3, #0x0
 8004bda: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				continue;
 8004bde: e11b         	b	0x8004e18 <cbvprintf_package+0x5d8> @ imm = #0x236
; 				break;
 8004be0: bf00         	nop
; 		buf = ROUND_UP(buf, align);
 8004be2: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8004be6: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004bea: 4413         	add	r3, r2
 8004bec: 1e5a         	subs	r2, r3, #0x1
 8004bee: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8004bf2: fbb2 f2f3    	udiv	r2, r2, r3
 8004bf6: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8004bfa: fb02 f303    	mul	r3, r2, r3
 8004bfe: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		if ((buf0 != NULL) && (BUF_OFFSET + size) > len) {
 8004c02: 6dfb         	ldr	r3, [r7, #0x5c]
 8004c04: 2b00         	cmp	r3, #0x0
 8004c06: d00c         	beq	0x8004c22 <cbvprintf_package+0x3e2> @ imm = #0x18
 8004c08: 6dfb         	ldr	r3, [r7, #0x5c]
 8004c0a: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004c0e: 1ad2         	subs	r2, r2, r3
 8004c10: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8004c14: 4413         	add	r3, r2
 8004c16: 68ba         	ldr	r2, [r7, #0x8]
 8004c18: 429a         	cmp	r2, r3
 8004c1a: d202         	bhs	0x8004c22 <cbvprintf_package+0x3e2> @ imm = #0x4
; 			return -ENOSPC;
 8004c1c: f06f 031b    	mvn	r3, #0x1b
 8004c20: e1e6         	b	0x8004ff0 <cbvprintf_package+0x7b0> @ imm = #0x3cc
; 		if (is_str_arg) {
 8004c22: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8004c26: 2b00         	cmp	r3, #0x0
 8004c28: f000 80a0    	beq.w	0x8004d6c <cbvprintf_package+0x52c> @ imm = #0x140
; 			s = va_arg(ap, char *);
 8004c2c: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8004c30: 1d1a         	adds	r2, r3, #0x4
 8004c32: f8c7 2098    	str.w	r2, [r7, #0x98]
 8004c36: 681b         	ldr	r3, [r3]
 8004c38: 66fb         	str	r3, [r7, #0x6c]
; 			if (buf0 != NULL) {
 8004c3a: 6dfb         	ldr	r3, [r7, #0x5c]
 8004c3c: 2b00         	cmp	r3, #0x0
 8004c3e: d003         	beq	0x8004c48 <cbvprintf_package+0x408> @ imm = #0x6
; 				*(const char **)buf = s;
 8004c40: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004c44: 6efa         	ldr	r2, [r7, #0x6c]
 8004c46: 601a         	str	r2, [r3]
; 			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 8004c48: 6e7b         	ldr	r3, [r7, #0x64]
 8004c4a: 1e5a         	subs	r2, r3, #0x1
 8004c4c: 667a         	str	r2, [r7, #0x64]
 8004c4e: 2b00         	cmp	r3, #0x0
 8004c50: dc05         	bgt	0x8004c5e <cbvprintf_package+0x41e> @ imm = #0xa
 8004c52: 6ef8         	ldr	r0, [r7, #0x6c]
 8004c54: f011 fdab    	bl	0x80167ae <ptr_in_rodata> @ imm = #0x11b56
 8004c58: 4603         	mov	r3, r0
 8004c5a: 2b00         	cmp	r3, #0x0
 8004c5c: d001         	beq	0x8004c62 <cbvprintf_package+0x422> @ imm = #0x2
 8004c5e: 2301         	movs	r3, #0x1
 8004c60: e000         	b	0x8004c64 <cbvprintf_package+0x424> @ imm = #0x0
 8004c62: 2300         	movs	r3, #0x0
 8004c64: f887 3053    	strb.w	r3, [r7, #0x53]
; 			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);
 8004c68: 687b         	ldr	r3, [r7, #0x4]
 8004c6a: f003 0302    	and	r3, r3, #0x2
 8004c6e: 2b00         	cmp	r3, #0x0
 8004c70: bf14         	ite	ne
 8004c72: 2301         	movne	r3, #0x1
 8004c74: 2300         	moveq	r3, #0x0
 8004c76: f887 3052    	strb.w	r3, [r7, #0x52]
; 			if (is_ro && !do_ro) {
 8004c7a: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8004c7e: 2b00         	cmp	r3, #0x0
 8004c80: d006         	beq	0x8004c90 <cbvprintf_package+0x450> @ imm = #0xc
 8004c82: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8004c86: f083 0301    	eor	r3, r3, #0x1
 8004c8a: b2db         	uxtb	r3, r3
 8004c8c: 2b00         	cmp	r3, #0x0
 8004c8e: d164         	bne	0x8004d5a <cbvprintf_package+0x51a> @ imm = #0xc8
; 				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 8004c90: 6dfb         	ldr	r3, [r7, #0x5c]
 8004c92: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004c96: 1ad3         	subs	r3, r2, r3
 8004c98: 089b         	lsrs	r3, r3, #0x2
 8004c9a: 64fb         	str	r3, [r7, #0x4c]
; 				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 8004c9c: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8004ca0: 2b00         	cmp	r3, #0x0
 8004ca2: d005         	beq	0x8004cb0 <cbvprintf_package+0x470> @ imm = #0xa
 8004ca4: 6cfb         	ldr	r3, [r7, #0x4c]
 8004ca6: 2b7f         	cmp	r3, #0x7f
 8004ca8: d902         	bls	0x8004cb0 <cbvprintf_package+0x470> @ imm = #0x4
; 					return -EINVAL;
 8004caa: f06f 0315    	mvn	r3, #0x15
 8004cae: e19f         	b	0x8004ff0 <cbvprintf_package+0x7b0> @ imm = #0x33e
; 				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
 8004cb0: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004cb4: 2b0f         	cmp	r3, #0xf
 8004cb6: d902         	bls	0x8004cbe <cbvprintf_package+0x47e> @ imm = #0x4
; 					return -EINVAL;
 8004cb8: f06f 0315    	mvn	r3, #0x15
 8004cbc: e198         	b	0x8004ff0 <cbvprintf_package+0x7b0> @ imm = #0x330
; 				if (buf0 != NULL) {
 8004cbe: 6dfb         	ldr	r3, [r7, #0x5c]
 8004cc0: 2b00         	cmp	r3, #0x0
 8004cc2: d02d         	beq	0x8004d20 <cbvprintf_package+0x4e0> @ imm = #0x5a
; 					str_ptr_pos[s_idx] = s_ptr_idx;
 8004cc4: 6cfb         	ldr	r3, [r7, #0x4c]
 8004cc6: b2d9         	uxtb	r1, r3
 8004cc8: f107 0230    	add.w	r2, r7, #0x30
 8004ccc: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004cd0: 4413         	add	r3, r2
 8004cd2: 460a         	mov	r2, r1
 8004cd4: 701a         	strb	r2, [r3]
; 					str_ptr_arg[s_idx] = arg_idx;
 8004cd6: 6f7b         	ldr	r3, [r7, #0x74]
 8004cd8: b2d9         	uxtb	r1, r3
 8004cda: f107 0220    	add.w	r2, r7, #0x20
 8004cde: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004ce2: 4413         	add	r3, r2
 8004ce4: 460a         	mov	r2, r1
 8004ce6: 701a         	strb	r2, [r3]
; 					if (is_ro) {
 8004ce8: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8004cec: 2b00         	cmp	r3, #0x0
 8004cee: d013         	beq	0x8004d18 <cbvprintf_package+0x4d8> @ imm = #0x26
; 						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
 8004cf0: f107 0230    	add.w	r2, r7, #0x30
 8004cf4: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004cf8: 4413         	add	r3, r2
 8004cfa: 781b         	ldrb	r3, [r3]
 8004cfc: f063 037f    	orn	r3, r3, #0x7f
 8004d00: b2d9         	uxtb	r1, r3
 8004d02: f107 0230    	add.w	r2, r7, #0x30
 8004d06: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004d0a: 4413         	add	r3, r2
 8004d0c: 460a         	mov	r2, r1
 8004d0e: 701a         	strb	r2, [r3]
; 						s_ro_cnt++;
 8004d10: 6fbb         	ldr	r3, [r7, #0x78]
 8004d12: 3301         	adds	r3, #0x1
 8004d14: 67bb         	str	r3, [r7, #0x78]
 8004d16: e01b         	b	0x8004d50 <cbvprintf_package+0x510> @ imm = #0x36
; 						s_rw_cnt++;
 8004d18: 6ffb         	ldr	r3, [r7, #0x7c]
 8004d1a: 3301         	adds	r3, #0x1
 8004d1c: 67fb         	str	r3, [r7, #0x7c]
 8004d1e: e017         	b	0x8004d50 <cbvprintf_package+0x510> @ imm = #0x2e
; 				} else if (is_ro) {
 8004d20: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8004d24: 2b00         	cmp	r3, #0x0
 8004d26: d003         	beq	0x8004d30 <cbvprintf_package+0x4f0> @ imm = #0x6
; 					len += 1;
 8004d28: 68bb         	ldr	r3, [r7, #0x8]
 8004d2a: 3301         	adds	r3, #0x1
 8004d2c: 60bb         	str	r3, [r7, #0x8]
 8004d2e: e00f         	b	0x8004d50 <cbvprintf_package+0x510> @ imm = #0x1e
; 				} else if (rws_pos_en) {
 8004d30: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8004d34: 2b00         	cmp	r3, #0x0
 8004d36: d003         	beq	0x8004d40 <cbvprintf_package+0x500> @ imm = #0x6
; 					len += 2;
 8004d38: 68bb         	ldr	r3, [r7, #0x8]
 8004d3a: 3302         	adds	r3, #0x2
 8004d3c: 60bb         	str	r3, [r7, #0x8]
 8004d3e: e007         	b	0x8004d50 <cbvprintf_package+0x510> @ imm = #0xe
; 					len += strlen(s) + 1 + 1;
 8004d40: 6ef8         	ldr	r0, [r7, #0x6c]
 8004d42: f7fb fea9    	bl	0x8000a98 <strlen>      @ imm = #-0x42ae
 8004d46: 4602         	mov	r2, r0
 8004d48: 68bb         	ldr	r3, [r7, #0x8]
 8004d4a: 4413         	add	r3, r2
 8004d4c: 3302         	adds	r3, #0x2
 8004d4e: 60bb         	str	r3, [r7, #0x8]
; 				s_idx++;
 8004d50: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004d54: 3301         	adds	r3, #0x1
 8004d56: f8c7 3080    	str.w	r3, [r7, #0x80]
; 			buf += sizeof(char *);
 8004d5a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004d5e: 3304         	adds	r3, #0x4
 8004d60: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			is_str_arg = false;
 8004d64: 2300         	movs	r3, #0x0
 8004d66: f887 3063    	strb.w	r3, [r7, #0x63]
 8004d6a: e055         	b	0x8004e18 <cbvprintf_package+0x5d8> @ imm = #0xaa
; 		} else if (size == sizeof(int)) {
 8004d6c: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8004d70: 2b04         	cmp	r3, #0x4
 8004d72: d113         	bne	0x8004d9c <cbvprintf_package+0x55c> @ imm = #0x26
; 			int v = va_arg(ap, int);
 8004d74: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8004d78: 1d1a         	adds	r2, r3, #0x4
 8004d7a: f8c7 2098    	str.w	r2, [r7, #0x98]
 8004d7e: 681b         	ldr	r3, [r3]
 8004d80: 647b         	str	r3, [r7, #0x44]
; 			if (buf0 != NULL) {
 8004d82: 6dfb         	ldr	r3, [r7, #0x5c]
 8004d84: 2b00         	cmp	r3, #0x0
 8004d86: d003         	beq	0x8004d90 <cbvprintf_package+0x550> @ imm = #0x6
; 				*(int *)buf = v;
 8004d88: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004d8c: 6c7a         	ldr	r2, [r7, #0x44]
 8004d8e: 601a         	str	r2, [r3]
; 			buf += sizeof(int);
 8004d90: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004d94: 3304         	adds	r3, #0x4
 8004d96: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8004d9a: e03d         	b	0x8004e18 <cbvprintf_package+0x5d8> @ imm = #0x7a
; 		} else if (size == sizeof(long)) {
 8004d9c: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8004da0: 2b04         	cmp	r3, #0x4
 8004da2: d113         	bne	0x8004dcc <cbvprintf_package+0x58c> @ imm = #0x26
; 			long v = va_arg(ap, long);
 8004da4: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8004da8: 1d1a         	adds	r2, r3, #0x4
 8004daa: f8c7 2098    	str.w	r2, [r7, #0x98]
 8004dae: 681b         	ldr	r3, [r3]
 8004db0: 64bb         	str	r3, [r7, #0x48]
; 			if (buf0 != NULL) {
 8004db2: 6dfb         	ldr	r3, [r7, #0x5c]
 8004db4: 2b00         	cmp	r3, #0x0
 8004db6: d003         	beq	0x8004dc0 <cbvprintf_package+0x580> @ imm = #0x6
; 				*(long *)buf = v;
 8004db8: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004dbc: 6cba         	ldr	r2, [r7, #0x48]
 8004dbe: 601a         	str	r2, [r3]
; 			buf += sizeof(long);
 8004dc0: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004dc4: 3304         	adds	r3, #0x4
 8004dc6: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8004dca: e025         	b	0x8004e18 <cbvprintf_package+0x5d8> @ imm = #0x4a
; 		} else if (size == sizeof(long long)) {
 8004dcc: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8004dd0: 2b08         	cmp	r3, #0x8
 8004dd2: d11b         	bne	0x8004e0c <cbvprintf_package+0x5cc> @ imm = #0x36
; 			long long v = va_arg(ap, long long);
 8004dd4: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8004dd8: 3307         	adds	r3, #0x7
 8004dda: f023 0307    	bic	r3, r3, #0x7
 8004dde: f103 0208    	add.w	r2, r3, #0x8
 8004de2: f8c7 2098    	str.w	r2, [r7, #0x98]
 8004de6: e9d3 2300    	ldrd	r2, r3, [r3]
 8004dea: e9c7 2304    	strd	r2, r3, [r7, #16]
; 			if (buf0 != NULL) {
 8004dee: 6dfb         	ldr	r3, [r7, #0x5c]
 8004df0: 2b00         	cmp	r3, #0x0
 8004df2: d005         	beq	0x8004e00 <cbvprintf_package+0x5c0> @ imm = #0xa
; 					*(long long *)buf = v;
 8004df4: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8004df8: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8004dfc: e9c1 2300    	strd	r2, r3, [r1]
; 			buf += sizeof(long long);
 8004e00: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004e04: 3308         	adds	r3, #0x8
 8004e06: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8004e0a: e005         	b	0x8004e18 <cbvprintf_package+0x5d8> @ imm = #0xa
; 			return -EINVAL;
 8004e0c: f06f 0315    	mvn	r3, #0x15
 8004e10: e0ee         	b	0x8004ff0 <cbvprintf_package+0x7b0> @ imm = #0x1dc
; 				continue;
 8004e12: bf00         	nop
 8004e14: e000         	b	0x8004e18 <cbvprintf_package+0x5d8> @ imm = #0x0
; 				continue;
 8004e16: bf00         	nop
; 			if (*++fmt == '\0') {
 8004e18: 683b         	ldr	r3, [r7]
 8004e1a: 3301         	adds	r3, #0x1
 8004e1c: 603b         	str	r3, [r7]
 8004e1e: 683b         	ldr	r3, [r7]
 8004e20: 781b         	ldrb	r3, [r3]
 8004e22: 2b00         	cmp	r3, #0x0
 8004e24: f47f ad71    	bne.w	0x800490a <cbvprintf_package+0xca> @ imm = #-0x51e
; 				break;
 8004e28: bf00         	nop
; 	if ((BUF_OFFSET / sizeof(int)) > 255) {
 8004e2a: 6dfb         	ldr	r3, [r7, #0x5c]
 8004e2c: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004e30: 1ad3         	subs	r3, r2, r3
 8004e32: f5b3 6f80    	cmp.w	r3, #0x400
 8004e36: d302         	blo	0x8004e3e <cbvprintf_package+0x5fe> @ imm = #0x4
; 		return -EINVAL;
 8004e38: f06f 0315    	mvn	r3, #0x15
 8004e3c: e0d8         	b	0x8004ff0 <cbvprintf_package+0x7b0> @ imm = #0x1b0
; 	if (buf0 == NULL) {
 8004e3e: 6dfb         	ldr	r3, [r7, #0x5c]
 8004e40: 2b00         	cmp	r3, #0x0
 8004e42: d107         	bne	0x8004e54 <cbvprintf_package+0x614> @ imm = #0xe
; 		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
 8004e44: 6dfb         	ldr	r3, [r7, #0x5c]
 8004e46: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004e4a: 1ad2         	subs	r2, r2, r3
 8004e4c: 68bb         	ldr	r3, [r7, #0x8]
 8004e4e: 4413         	add	r3, r2
 8004e50: 3b08         	subs	r3, #0x8
 8004e52: e0cd         	b	0x8004ff0 <cbvprintf_package+0x7b0> @ imm = #0x19a
; 	*(char **)buf0 = NULL;
 8004e54: 6dfb         	ldr	r3, [r7, #0x5c]
 8004e56: 2200         	movs	r2, #0x0
 8004e58: 601a         	str	r2, [r3]
; 	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
 8004e5a: 6dfb         	ldr	r3, [r7, #0x5c]
 8004e5c: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004e60: 1ad3         	subs	r3, r2, r3
 8004e62: 089b         	lsrs	r3, r3, #0x2
 8004e64: b2da         	uxtb	r2, r3
 8004e66: 6d7b         	ldr	r3, [r7, #0x54]
 8004e68: 701a         	strb	r2, [r3]
; 	if (rws_pos_en) {
 8004e6a: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8004e6e: 2b00         	cmp	r3, #0x0
 8004e70: d007         	beq	0x8004e82 <cbvprintf_package+0x642> @ imm = #0xe
; 		pkg_hdr->desc.str_cnt = 0;
 8004e72: 6d7b         	ldr	r3, [r7, #0x54]
 8004e74: 2200         	movs	r2, #0x0
 8004e76: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
 8004e78: 6ffb         	ldr	r3, [r7, #0x7c]
 8004e7a: b2da         	uxtb	r2, r3
 8004e7c: 6d7b         	ldr	r3, [r7, #0x54]
 8004e7e: 70da         	strb	r2, [r3, #0x3]
 8004e80: e006         	b	0x8004e90 <cbvprintf_package+0x650> @ imm = #0xc
; 		pkg_hdr->desc.str_cnt = s_rw_cnt;
 8004e82: 6ffb         	ldr	r3, [r7, #0x7c]
 8004e84: b2da         	uxtb	r2, r3
 8004e86: 6d7b         	ldr	r3, [r7, #0x54]
 8004e88: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = 0;
 8004e8a: 6d7b         	ldr	r3, [r7, #0x54]
 8004e8c: 2200         	movs	r2, #0x0
 8004e8e: 70da         	strb	r2, [r3, #0x3]
; 	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
 8004e90: 6fbb         	ldr	r3, [r7, #0x78]
 8004e92: b2da         	uxtb	r2, r3
 8004e94: 6d7b         	ldr	r3, [r7, #0x54]
 8004e96: 709a         	strb	r2, [r3, #0x2]
; 	if (s_ro_cnt != 0U) {
 8004e98: 6fbb         	ldr	r3, [r7, #0x78]
 8004e9a: 2b00         	cmp	r3, #0x0
 8004e9c: d032         	beq	0x8004f04 <cbvprintf_package+0x6c4> @ imm = #0x64
; 		for (i = 0; i < s_idx; i++) {
 8004e9e: 2300         	movs	r3, #0x0
 8004ea0: 673b         	str	r3, [r7, #0x70]
 8004ea2: e02a         	b	0x8004efa <cbvprintf_package+0x6ba> @ imm = #0x54
; 			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
 8004ea4: f107 0230    	add.w	r2, r7, #0x30
 8004ea8: 6f3b         	ldr	r3, [r7, #0x70]
 8004eaa: 4413         	add	r3, r2
 8004eac: 781b         	ldrb	r3, [r3]
 8004eae: b25b         	sxtb	r3, r3
 8004eb0: 2b00         	cmp	r3, #0x0
 8004eb2: da1e         	bge	0x8004ef2 <cbvprintf_package+0x6b2> @ imm = #0x3c
; 			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
 8004eb4: f107 0230    	add.w	r2, r7, #0x30
 8004eb8: 6f3b         	ldr	r3, [r7, #0x70]
 8004eba: 4413         	add	r3, r2
 8004ebc: 781b         	ldrb	r3, [r3]
 8004ebe: f003 037f    	and	r3, r3, #0x7f
 8004ec2: f887 3043    	strb.w	r3, [r7, #0x43]
; 			if ((BUF_OFFSET + 1) > len) {
 8004ec6: 6dfb         	ldr	r3, [r7, #0x5c]
 8004ec8: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004ecc: 1ad3         	subs	r3, r2, r3
 8004ece: 3301         	adds	r3, #0x1
 8004ed0: 68ba         	ldr	r2, [r7, #0x8]
 8004ed2: 429a         	cmp	r2, r3
 8004ed4: d202         	bhs	0x8004edc <cbvprintf_package+0x69c> @ imm = #0x4
; 				return -ENOSPC;
 8004ed6: f06f 031b    	mvn	r3, #0x1b
 8004eda: e089         	b	0x8004ff0 <cbvprintf_package+0x7b0> @ imm = #0x112
; 			*(uint8_t *)buf = pos;
 8004edc: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004ee0: f897 2043    	ldrb.w	r2, [r7, #0x43]
 8004ee4: 701a         	strb	r2, [r3]
; 			++buf;
 8004ee6: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004eea: 3301         	adds	r3, #0x1
 8004eec: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8004ef0: e000         	b	0x8004ef4 <cbvprintf_package+0x6b4> @ imm = #0x0
; 				continue;
 8004ef2: bf00         	nop
; 		for (i = 0; i < s_idx; i++) {
 8004ef4: 6f3b         	ldr	r3, [r7, #0x70]
 8004ef6: 3301         	adds	r3, #0x1
 8004ef8: 673b         	str	r3, [r7, #0x70]
 8004efa: 6f3a         	ldr	r2, [r7, #0x70]
 8004efc: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004f00: 429a         	cmp	r2, r3
 8004f02: d3cf         	blo	0x8004ea4 <cbvprintf_package+0x664> @ imm = #-0x62
; 	for (i = 0; i < s_idx; i++) {
 8004f04: 2300         	movs	r3, #0x0
 8004f06: 673b         	str	r3, [r7, #0x70]
 8004f08: e069         	b	0x8004fde <cbvprintf_package+0x79e> @ imm = #0xd2
; 		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
 8004f0a: 6fbb         	ldr	r3, [r7, #0x78]
 8004f0c: 2b00         	cmp	r3, #0x0
 8004f0e: d007         	beq	0x8004f20 <cbvprintf_package+0x6e0> @ imm = #0xe
 8004f10: f107 0230    	add.w	r2, r7, #0x30
 8004f14: 6f3b         	ldr	r3, [r7, #0x70]
 8004f16: 4413         	add	r3, r2
 8004f18: 781b         	ldrb	r3, [r3]
 8004f1a: b25b         	sxtb	r3, r3
 8004f1c: 2b00         	cmp	r3, #0x0
 8004f1e: db5a         	blt	0x8004fd6 <cbvprintf_package+0x796> @ imm = #0xb4
; 		if (rws_pos_en) {
 8004f20: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8004f24: 2b00         	cmp	r3, #0x0
 8004f26: d010         	beq	0x8004f4a <cbvprintf_package+0x70a> @ imm = #0x20
; 			size = 0;
 8004f28: 2300         	movs	r3, #0x0
 8004f2a: f8c7 3088    	str.w	r3, [r7, #0x88]
; 			*(uint8_t *)buf = str_ptr_arg[i];
 8004f2e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004f32: f107 0120    	add.w	r1, r7, #0x20
 8004f36: 6f3a         	ldr	r2, [r7, #0x70]
 8004f38: 440a         	add	r2, r1
 8004f3a: 7812         	ldrb	r2, [r2]
 8004f3c: 701a         	strb	r2, [r3]
; 			++buf;
 8004f3e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004f42: 3301         	adds	r3, #0x1
 8004f44: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8004f48: e01a         	b	0x8004f80 <cbvprintf_package+0x740> @ imm = #0x34
; 			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
 8004f4a: f107 0230    	add.w	r2, r7, #0x30
 8004f4e: 6f3b         	ldr	r3, [r7, #0x70]
 8004f50: 4413         	add	r3, r2
 8004f52: 781b         	ldrb	r3, [r3]
 8004f54: 009b         	lsls	r3, r3, #0x2
 8004f56: 6dfa         	ldr	r2, [r7, #0x5c]
 8004f58: 4413         	add	r3, r2
 8004f5a: 681b         	ldr	r3, [r3]
 8004f5c: 66fb         	str	r3, [r7, #0x6c]
; 			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
 8004f5e: f107 0230    	add.w	r2, r7, #0x30
 8004f62: 6f3b         	ldr	r3, [r7, #0x70]
 8004f64: 4413         	add	r3, r2
 8004f66: 781b         	ldrb	r3, [r3]
 8004f68: 009b         	lsls	r3, r3, #0x2
 8004f6a: 6dfa         	ldr	r2, [r7, #0x5c]
 8004f6c: 4413         	add	r3, r2
 8004f6e: 2200         	movs	r2, #0x0
 8004f70: 601a         	str	r2, [r3]
; 			size = strlen(s) + 1;
 8004f72: 6ef8         	ldr	r0, [r7, #0x6c]
 8004f74: f7fb fd90    	bl	0x8000a98 <strlen>      @ imm = #-0x44e0
 8004f78: 4603         	mov	r3, r0
 8004f7a: 3301         	adds	r3, #0x1
 8004f7c: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		if ((BUF_OFFSET + 1 + size) > len) {
 8004f80: 6dfb         	ldr	r3, [r7, #0x5c]
 8004f82: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004f86: 1ad2         	subs	r2, r2, r3
 8004f88: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8004f8c: 4413         	add	r3, r2
 8004f8e: 3301         	adds	r3, #0x1
 8004f90: 68ba         	ldr	r2, [r7, #0x8]
 8004f92: 429a         	cmp	r2, r3
 8004f94: d202         	bhs	0x8004f9c <cbvprintf_package+0x75c> @ imm = #0x4
; 			return -ENOSPC;
 8004f96: f06f 031b    	mvn	r3, #0x1b
 8004f9a: e029         	b	0x8004ff0 <cbvprintf_package+0x7b0> @ imm = #0x52
; 		*(uint8_t *)buf = str_ptr_pos[i];
 8004f9c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004fa0: f107 0130    	add.w	r1, r7, #0x30
 8004fa4: 6f3a         	ldr	r2, [r7, #0x70]
 8004fa6: 440a         	add	r2, r1
 8004fa8: 7812         	ldrb	r2, [r2]
 8004faa: 701a         	strb	r2, [r3]
; 		++buf;
 8004fac: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004fb0: 3301         	adds	r3, #0x1
 8004fb2: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		memcpy((void *)buf, (uint8_t *)s, size);
 8004fb6: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8004fba: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 8004fbe: 6ef9         	ldr	r1, [r7, #0x6c]
 8004fc0: 4618         	mov	r0, r3
 8004fc2: f01a fe7b    	bl	0x801fcbc <memcpy>      @ imm = #0x1acf6
; 		buf += size;
 8004fc6: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004fca: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8004fce: 4413         	add	r3, r2
 8004fd0: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8004fd4: e000         	b	0x8004fd8 <cbvprintf_package+0x798> @ imm = #0x0
; 			continue;
 8004fd6: bf00         	nop
; 	for (i = 0; i < s_idx; i++) {
 8004fd8: 6f3b         	ldr	r3, [r7, #0x70]
 8004fda: 3301         	adds	r3, #0x1
 8004fdc: 673b         	str	r3, [r7, #0x70]
 8004fde: 6f3a         	ldr	r2, [r7, #0x70]
 8004fe0: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8004fe4: 429a         	cmp	r2, r3
 8004fe6: d390         	blo	0x8004f0a <cbvprintf_package+0x6ca> @ imm = #-0xe0
; 	return BUF_OFFSET;
 8004fe8: 6dfb         	ldr	r3, [r7, #0x5c]
 8004fea: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8004fee: 1ad3         	subs	r3, r2, r3
; }
 8004ff0: 4618         	mov	r0, r3
 8004ff2: 3790         	adds	r7, #0x90
 8004ff4: 46bd         	mov	sp, r7
 8004ff6: bd80         	pop	{r7, pc}

08004ff8 <__printk_hook_install>:
; {
 8004ff8: b480         	push	{r7}
 8004ffa: b083         	sub	sp, #0xc
 8004ffc: af00         	add	r7, sp, #0x0
 8004ffe: 6078         	str	r0, [r7, #0x4]
; 	_char_out = fn;
 8005000: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8005014 <__printk_hook_install+0x1c>
 8005002: 687b         	ldr	r3, [r7, #0x4]
 8005004: 6013         	str	r3, [r2]
; }
 8005006: bf00         	nop
 8005008: 370c         	adds	r7, #0xc
 800500a: 46bd         	mov	sp, r7
 800500c: f85d 7b04    	ldr	r7, [sp], #4
 8005010: 4770         	bx	lr
 8005012: bf00         	nop

08005014 <$d>:
 8005014: f8 04 00 20  	.word	0x200004f8

08005018 <k_current_get>:
; {
 8005018: b580         	push	{r7, lr}
 800501a: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 800501c: f01b f836    	bl	0x802008c <__aeabi_read_tp> @ imm = #0x1b06c
 8005020: 4603         	mov	r3, r0
 8005022: 4a02         	ldr	r2, [pc, #0x8]          @ 0x800502c <k_current_get+0x14>
 8005024: 589b         	ldr	r3, [r3, r2]
; }
 8005026: 4618         	mov	r0, r3
 8005028: bd80         	pop	{r7, pc}
 800502a: bf00         	nop

0800502c <$d>:
 800502c: 08 00 00 00  	.word	0x00000008

08005030 <z_thread_entry>:
; {
 8005030: b580         	push	{r7, lr}
 8005032: b084         	sub	sp, #0x10
 8005034: af00         	add	r7, sp, #0x0
 8005036: 60f8         	str	r0, [r7, #0xc]
 8005038: 60b9         	str	r1, [r7, #0x8]
 800503a: 607a         	str	r2, [r7, #0x4]
 800503c: 603b         	str	r3, [r7]
; 	z_tls_current = k_sched_current_thread_query();
 800503e: f011 fc59    	bl	0x80168f4 <k_sched_current_thread_query> @ imm = #0x118b2
 8005042: 4602         	mov	r2, r0
 8005044: f01b f822    	bl	0x802008c <__aeabi_read_tp> @ imm = #0x1b044
 8005048: 4603         	mov	r3, r0
 800504a: 4906         	ldr	r1, [pc, #0x18]         @ 0x8005064 <z_thread_entry+0x34>
 800504c: 505a         	str	r2, [r3, r1]
; 	entry(p1, p2, p3);
 800504e: 68fb         	ldr	r3, [r7, #0xc]
 8005050: 683a         	ldr	r2, [r7]
 8005052: 6879         	ldr	r1, [r7, #0x4]
 8005054: 68b8         	ldr	r0, [r7, #0x8]
 8005056: 4798         	blx	r3
; 	k_thread_abort(k_current_get());
 8005058: f7ff ffde    	bl	0x8005018 <k_current_get> @ imm = #-0x44
 800505c: 4603         	mov	r3, r0
 800505e: 4618         	mov	r0, r3
 8005060: f011 fc4f    	bl	0x8016902 <k_thread_abort> @ imm = #0x1189e

08005064 <$d>:
 8005064: 08 00 00 00  	.word	0x00000008

08005068 <LL_DBGMCU_DisableDBGStopMode>:
; {
 8005068: b480         	push	{r7}
 800506a: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 800506c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8005084 <LL_DBGMCU_DisableDBGStopMode+0x1c>
 800506e: 685b         	ldr	r3, [r3, #0x4]
 8005070: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8005084 <LL_DBGMCU_DisableDBGStopMode+0x1c>
 8005072: f023 0302    	bic	r3, r3, #0x2
 8005076: 6053         	str	r3, [r2, #0x4]
; }
 8005078: bf00         	nop
 800507a: 46bd         	mov	sp, r7
 800507c: f85d 7b04    	ldr	r7, [sp], #4
 8005080: 4770         	bx	lr
 8005082: bf00         	nop

08005084 <$d>:
 8005084: 00 20 04 e0  	.word	0xe0042000

08005088 <LL_FLASH_EnablePrefetch>:
; {
 8005088: b480         	push	{r7}
 800508a: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_PRFTEN);
 800508c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80050a4 <LL_FLASH_EnablePrefetch+0x1c>
 800508e: 681b         	ldr	r3, [r3]
 8005090: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80050a4 <LL_FLASH_EnablePrefetch+0x1c>
 8005092: f443 7380    	orr	r3, r3, #0x100
 8005096: 6013         	str	r3, [r2]
; }
 8005098: bf00         	nop
 800509a: 46bd         	mov	sp, r7
 800509c: f85d 7b04    	ldr	r7, [sp], #4
 80050a0: 4770         	bx	lr
 80050a2: bf00         	nop

080050a4 <$d>:
 80050a4: 00 3c 02 40  	.word	0x40023c00

080050a8 <LL_FLASH_EnableInstCache>:
; {
 80050a8: b480         	push	{r7}
 80050aa: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_ICEN);
 80050ac: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80050c4 <LL_FLASH_EnableInstCache+0x1c>
 80050ae: 681b         	ldr	r3, [r3]
 80050b0: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80050c4 <LL_FLASH_EnableInstCache+0x1c>
 80050b2: f443 7300    	orr	r3, r3, #0x200
 80050b6: 6013         	str	r3, [r2]
; }
 80050b8: bf00         	nop
 80050ba: 46bd         	mov	sp, r7
 80050bc: f85d 7b04    	ldr	r7, [sp], #4
 80050c0: 4770         	bx	lr
 80050c2: bf00         	nop

080050c4 <$d>:
 80050c4: 00 3c 02 40  	.word	0x40023c00

080050c8 <LL_FLASH_EnableDataCache>:
; {
 80050c8: b480         	push	{r7}
 80050ca: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_DCEN);
 80050cc: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80050e4 <LL_FLASH_EnableDataCache+0x1c>
 80050ce: 681b         	ldr	r3, [r3]
 80050d0: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80050e4 <LL_FLASH_EnableDataCache+0x1c>
 80050d2: f443 6380    	orr	r3, r3, #0x400
 80050d6: 6013         	str	r3, [r2]
; }
 80050d8: bf00         	nop
 80050da: 46bd         	mov	sp, r7
 80050dc: f85d 7b04    	ldr	r7, [sp], #4
 80050e0: 4770         	bx	lr
 80050e2: bf00         	nop

080050e4 <$d>:
 80050e4: 00 3c 02 40  	.word	0x40023c00

080050e8 <soc_early_init_hook>:
; {
 80050e8: b580         	push	{r7, lr}
 80050ea: af00         	add	r7, sp, #0x0
; 	LL_FLASH_EnablePrefetch();
 80050ec: f7ff ffcc    	bl	0x8005088 <LL_FLASH_EnablePrefetch> @ imm = #-0x68
; 	LL_FLASH_EnableInstCache();
 80050f0: f7ff ffda    	bl	0x80050a8 <LL_FLASH_EnableInstCache> @ imm = #-0x4c
; 	LL_FLASH_EnableDataCache();
 80050f4: f7ff ffe8    	bl	0x80050c8 <LL_FLASH_EnableDataCache> @ imm = #-0x30
; 	SystemCoreClock = 16000000;
 80050f8: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8005104 <soc_early_init_hook+0x1c>
 80050fa: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005108 <soc_early_init_hook+0x20>
 80050fc: 601a         	str	r2, [r3]
; }
 80050fe: bf00         	nop
 8005100: bd80         	pop	{r7, pc}
 8005102: bf00         	nop

08005104 <$d>:
 8005104: ec 05 00 20  	.word	0x200005ec
 8005108: 00 24 f4 00  	.word	0x00f42400

0800510c <log_backend_get>:
; {
 800510c: b480         	push	{r7}
 800510e: b085         	sub	sp, #0x14
 8005110: af00         	add	r7, sp, #0x0
 8005112: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 8005114: 687b         	ldr	r3, [r7, #0x4]
 8005116: 011b         	lsls	r3, r3, #0x4
 8005118: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800512c <log_backend_get+0x20>
 800511a: 4413         	add	r3, r2
 800511c: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 800511e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8005120: 4618         	mov	r0, r3
 8005122: 3714         	adds	r7, #0x14
 8005124: 46bd         	mov	sp, r7
 8005126: f85d 7b04    	ldr	r7, [sp], #4
 800512a: 4770         	bx	lr

0800512c <$d>:
 800512c: 34 07 02 08  	.word	0x08020734

08005130 <log_format_func_t_get>:
; {
 8005130: b480         	push	{r7}
 8005132: b083         	sub	sp, #0xc
 8005134: af00         	add	r7, sp, #0x0
 8005136: 6078         	str	r0, [r7, #0x4]
; 	return format_table[log_type];
 8005138: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800514c <log_format_func_t_get+0x1c>
 800513a: 687b         	ldr	r3, [r7, #0x4]
 800513c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8005140: 4618         	mov	r0, r3
 8005142: 370c         	adds	r7, #0xc
 8005144: 46bd         	mov	sp, r7
 8005146: f85d 7b04    	ldr	r7, [sp], #4
 800514a: 4770         	bx	lr

0800514c <$d>:
 800514c: f4 25 02 08  	.word	0x080225f4

08005150 <log_core_init>:
; {
 8005150: b580         	push	{r7, lr}
 8005152: af00         	add	r7, sp, #0x0
; 	panic_mode = false;
 8005154: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8005174 <log_core_init+0x24>
 8005156: 2200         	movs	r2, #0x0
 8005158: 701a         	strb	r2, [r3]
; 	dropped_cnt = 0;
 800515a: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8005178 <log_core_init+0x28>
 800515c: 2200         	movs	r2, #0x0
 800515e: 601a         	str	r2, [r3]
; 	buffered_cnt = 0;
 8005160: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800517c <log_core_init+0x2c>
 8005162: 2200         	movs	r2, #0x0
 8005164: 601a         	str	r2, [r3]
; 		log_set_timestamp_func(default_lf_get_timestamp, 1000U);
 8005166: f44f 717a    	mov.w	r1, #0x3e8
 800516a: 4805         	ldr	r0, [pc, #0x14]         @ 0x8005180 <log_core_init+0x30>
 800516c: f000 f86a    	bl	0x8005244 <log_set_timestamp_func> @ imm = #0xd4
; }
 8005170: bd80         	pop	{r7, pc}
 8005172: bf00         	nop

08005174 <$d>:
 8005174: f8 27 00 20  	.word	0x200027f8
 8005178: 58 24 00 20  	.word	0x20002458
 800517c: 54 24 00 20  	.word	0x20002454
 8005180: 8f 6b 01 08  	.word	0x08016b8f

08005184 <z_log_init>:
; {
 8005184: b580         	push	{r7, lr}
 8005186: b086         	sub	sp, #0x18
 8005188: af00         	add	r7, sp, #0x0
 800518a: 4603         	mov	r3, r0
 800518c: 460a         	mov	r2, r1
 800518e: 71fb         	strb	r3, [r7, #0x7]
 8005190: 4613         	mov	r3, r2
 8005192: 71bb         	strb	r3, [r7, #0x6]
; 	uint32_t mask = 0;
 8005194: 2300         	movs	r3, #0x0
 8005196: 617b         	str	r3, [r7, #0x14]
; 	if (atomic_inc(&initialized) != 0) {
 8005198: 4827         	ldr	r0, [pc, #0x9c]         @ 0x8005238 <z_log_init+0xb4>
 800519a: f011 fbfd    	bl	0x8016998 <atomic_inc>  @ imm = #0x117fa
 800519e: 4603         	mov	r3, r0
 80051a0: 2b00         	cmp	r3, #0x0
 80051a2: d001         	beq	0x80051a8 <z_log_init+0x24> @ imm = #0x2
; 		return 0;
 80051a4: 2300         	movs	r3, #0x0
 80051a6: e042         	b	0x800522e <z_log_init+0xaa> @ imm = #0x84
; 	int backend_index = 0;
 80051a8: 2300         	movs	r3, #0x0
 80051aa: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80051ac: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800523c <z_log_init+0xb8>
 80051ae: 60fb         	str	r3, [r7, #0xc]
 80051b0: e022         	b	0x80051f8 <z_log_init+0x74> @ imm = #0x44
; 		if (backend->autostart) {
 80051b2: 68fb         	ldr	r3, [r7, #0xc]
 80051b4: 7b1b         	ldrb	r3, [r3, #0xc]
 80051b6: 2b00         	cmp	r3, #0x0
 80051b8: d018         	beq	0x80051ec <z_log_init+0x68> @ imm = #0x30
; 			log_backend_init(backend);
 80051ba: 68f8         	ldr	r0, [r7, #0xc]
 80051bc: f011 fc79    	bl	0x8016ab2 <log_backend_init> @ imm = #0x118f2
; 			if (log_backend_is_ready(backend) == 0) {
 80051c0: 68f8         	ldr	r0, [r7, #0xc]
 80051c2: f011 fc88    	bl	0x8016ad6 <log_backend_is_ready> @ imm = #0x11910
 80051c6: 4603         	mov	r3, r0
 80051c8: 2b00         	cmp	r3, #0x0
 80051ca: d108         	bne	0x80051de <z_log_init+0x5a> @ imm = #0x10
; 						   backend->cb->ctx,
 80051cc: 68fb         	ldr	r3, [r7, #0xc]
 80051ce: 685b         	ldr	r3, [r3, #0x4]
; 				log_backend_enable(backend,
 80051d0: 681b         	ldr	r3, [r3]
 80051d2: 2204         	movs	r2, #0x4
 80051d4: 4619         	mov	r1, r3
 80051d6: 68f8         	ldr	r0, [r7, #0xc]
 80051d8: f011 fde1    	bl	0x8016d9e <log_backend_enable> @ imm = #0x11bc2
 80051dc: e006         	b	0x80051ec <z_log_init+0x68> @ imm = #0xc
; 				mask |= BIT(backend_index);
 80051de: 2201         	movs	r2, #0x1
 80051e0: 693b         	ldr	r3, [r7, #0x10]
 80051e2: fa02 f303    	lsl.w	r3, r2, r3
 80051e6: 697a         	ldr	r2, [r7, #0x14]
 80051e8: 4313         	orrs	r3, r2
 80051ea: 617b         	str	r3, [r7, #0x14]
; 		++backend_index;
 80051ec: 693b         	ldr	r3, [r7, #0x10]
 80051ee: 3301         	adds	r3, #0x1
 80051f0: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80051f2: 68fb         	ldr	r3, [r7, #0xc]
 80051f4: 3310         	adds	r3, #0x10
 80051f6: 60fb         	str	r3, [r7, #0xc]
 80051f8: 68fb         	ldr	r3, [r7, #0xc]
 80051fa: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8005240 <z_log_init+0xbc>
 80051fc: 4293         	cmp	r3, r2
 80051fe: bf34         	ite	lo
 8005200: 2301         	movlo	r3, #0x1
 8005202: 2300         	movhs	r3, #0x0
 8005204: b2db         	uxtb	r3, r3
 8005206: 2b00         	cmp	r3, #0x0
 8005208: d1d3         	bne	0x80051b2 <z_log_init+0x2e> @ imm = #-0x5a
; 	if (blocking) {
 800520a: 79fb         	ldrb	r3, [r7, #0x7]
 800520c: 2b00         	cmp	r3, #0x0
 800520e: d00d         	beq	0x800522c <z_log_init+0xa8> @ imm = #0x1a
; 		while (mask) {
 8005210: e009         	b	0x8005226 <z_log_init+0xa2> @ imm = #0x12
; 			mask = activate_foreach_backend(mask);
 8005212: 6978         	ldr	r0, [r7, #0x14]
 8005214: f011 fcc2    	bl	0x8016b9c <activate_foreach_backend> @ imm = #0x11984
 8005218: 6178         	str	r0, [r7, #0x14]
; 			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
 800521a: 79bb         	ldrb	r3, [r7, #0x6]
 800521c: 2b00         	cmp	r3, #0x0
 800521e: d002         	beq	0x8005226 <z_log_init+0xa2> @ imm = #0x4
; 				k_msleep(10);
 8005220: 200a         	movs	r0, #0xa
 8005222: f011 fbe7    	bl	0x80169f4 <k_msleep>    @ imm = #0x117ce
; 		while (mask) {
 8005226: 697b         	ldr	r3, [r7, #0x14]
 8005228: 2b00         	cmp	r3, #0x0
 800522a: d1f2         	bne	0x8005212 <z_log_init+0x8e> @ imm = #-0x1c
; 	return mask;
 800522c: 697b         	ldr	r3, [r7, #0x14]
; }
 800522e: 4618         	mov	r0, r3
 8005230: 3718         	adds	r7, #0x18
 8005232: 46bd         	mov	sp, r7
 8005234: bd80         	pop	{r7, pc}
 8005236: bf00         	nop

08005238 <$d>:
 8005238: 50 24 00 20  	.word	0x20002450
 800523c: 34 07 02 08  	.word	0x08020734
 8005240: 44 07 02 08  	.word	0x08020744

08005244 <log_set_timestamp_func>:
; {
 8005244: b580         	push	{r7, lr}
 8005246: b082         	sub	sp, #0x8
 8005248: af00         	add	r7, sp, #0x0
 800524a: 6078         	str	r0, [r7, #0x4]
 800524c: 6039         	str	r1, [r7]
; 	if (timestamp_getter == NULL) {
 800524e: 687b         	ldr	r3, [r7, #0x4]
 8005250: 2b00         	cmp	r3, #0x0
 8005252: d102         	bne	0x800525a <log_set_timestamp_func+0x16> @ imm = #0x4
; 		return -EINVAL;
 8005254: f06f 0315    	mvn	r3, #0x15
 8005258: e009         	b	0x800526e <log_set_timestamp_func+0x2a> @ imm = #0x12
; 	timestamp_func = timestamp_getter;
 800525a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8005278 <log_set_timestamp_func+0x34>
 800525c: 687b         	ldr	r3, [r7, #0x4]
 800525e: 6013         	str	r3, [r2]
; 	timestamp_freq = freq;
 8005260: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800527c <log_set_timestamp_func+0x38>
 8005262: 683b         	ldr	r3, [r7]
 8005264: 6013         	str	r3, [r2]
; 		log_output_timestamp_freq_set(freq);
 8005266: 6838         	ldr	r0, [r7]
 8005268: f000 fcec    	bl	0x8005c44 <log_output_timestamp_freq_set> @ imm = #0x9d8
; 	return 0;
 800526c: 2300         	movs	r3, #0x0
; }
 800526e: 4618         	mov	r0, r3
 8005270: 3708         	adds	r7, #0x8
 8005272: 46bd         	mov	sp, r7
 8005274: bd80         	pop	{r7, pc}
 8005276: bf00         	nop

08005278 <$d>:
 8005278: fc 04 00 20  	.word	0x200004fc
 800527c: 5c 24 00 20  	.word	0x2000245c

08005280 <z_impl_log_panic>:
; {
 8005280: b580         	push	{r7, lr}
 8005282: b082         	sub	sp, #0x8
 8005284: af00         	add	r7, sp, #0x0
; 	if (panic_mode) {
 8005286: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80052d8 <z_impl_log_panic+0x58>
 8005288: 781b         	ldrb	r3, [r3]
 800528a: 2b00         	cmp	r3, #0x0
 800528c: d120         	bne	0x80052d0 <z_impl_log_panic+0x50> @ imm = #0x40
; 	(void)z_log_init(true, false);
 800528e: 2100         	movs	r1, #0x0
 8005290: 2001         	movs	r0, #0x1
 8005292: f7ff ff77    	bl	0x8005184 <z_log_init>  @ imm = #-0x112
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8005296: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80052dc <z_impl_log_panic+0x5c>
 8005298: 607b         	str	r3, [r7, #0x4]
 800529a: e00b         	b	0x80052b4 <z_impl_log_panic+0x34> @ imm = #0x16
; 		if (log_backend_is_active(backend)) {
 800529c: 6878         	ldr	r0, [r7, #0x4]
 800529e: f011 fc4b    	bl	0x8016b38 <log_backend_is_active> @ imm = #0x11896
 80052a2: 4603         	mov	r3, r0
 80052a4: 2b00         	cmp	r3, #0x0
 80052a6: d002         	beq	0x80052ae <z_impl_log_panic+0x2e> @ imm = #0x4
; 			log_backend_panic(backend);
 80052a8: 6878         	ldr	r0, [r7, #0x4]
 80052aa: f011 fc38    	bl	0x8016b1e <log_backend_panic> @ imm = #0x11870
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80052ae: 687b         	ldr	r3, [r7, #0x4]
 80052b0: 3310         	adds	r3, #0x10
 80052b2: 607b         	str	r3, [r7, #0x4]
 80052b4: 687b         	ldr	r3, [r7, #0x4]
 80052b6: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80052e0 <z_impl_log_panic+0x60>
 80052b8: 4293         	cmp	r3, r2
 80052ba: bf34         	ite	lo
 80052bc: 2301         	movlo	r3, #0x1
 80052be: 2300         	movhs	r3, #0x0
 80052c0: b2db         	uxtb	r3, r3
 80052c2: 2b00         	cmp	r3, #0x0
 80052c4: d1ea         	bne	0x800529c <z_impl_log_panic+0x1c> @ imm = #-0x2c
; out:
 80052c6: bf00         	nop
; 	panic_mode = true;
 80052c8: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80052d8 <z_impl_log_panic+0x58>
 80052ca: 2201         	movs	r2, #0x1
 80052cc: 701a         	strb	r2, [r3]
 80052ce: e000         	b	0x80052d2 <z_impl_log_panic+0x52> @ imm = #0x0
; 		return;
 80052d0: bf00         	nop
; }
 80052d2: 3708         	adds	r7, #0x8
 80052d4: 46bd         	mov	sp, r7
 80052d6: bd80         	pop	{r7, pc}

080052d8 <$d>:
 80052d8: f8 27 00 20  	.word	0x200027f8
 80052dc: 34 07 02 08  	.word	0x08020734
 80052e0: 44 07 02 08  	.word	0x08020744

080052e4 <msg_process>:
; {
 80052e4: b580         	push	{r7, lr}
 80052e6: b084         	sub	sp, #0x10
 80052e8: af00         	add	r7, sp, #0x0
 80052ea: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80052ec: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8005338 <msg_process+0x54>
 80052ee: 60fb         	str	r3, [r7, #0xc]
 80052f0: e013         	b	0x800531a <msg_process+0x36> @ imm = #0x26
; 		if (log_backend_is_active(backend) &&
 80052f2: 68f8         	ldr	r0, [r7, #0xc]
 80052f4: f011 fc20    	bl	0x8016b38 <log_backend_is_active> @ imm = #0x11840
 80052f8: 4603         	mov	r3, r0
 80052fa: 2b00         	cmp	r3, #0x0
 80052fc: d00a         	beq	0x8005314 <msg_process+0x30> @ imm = #0x14
; 		    msg_filter_check(backend, msg)) {
 80052fe: 6879         	ldr	r1, [r7, #0x4]
 8005300: 68f8         	ldr	r0, [r7, #0xc]
 8005302: f011 fc86    	bl	0x8016c12 <msg_filter_check> @ imm = #0x1190c
 8005306: 4603         	mov	r3, r0
; 		if (log_backend_is_active(backend) &&
 8005308: 2b00         	cmp	r3, #0x0
 800530a: d003         	beq	0x8005314 <msg_process+0x30> @ imm = #0x6
; 			log_backend_msg_process(backend, msg);
 800530c: 6879         	ldr	r1, [r7, #0x4]
 800530e: 68f8         	ldr	r0, [r7, #0xc]
 8005310: f011 fbf6    	bl	0x8016b00 <log_backend_msg_process> @ imm = #0x117ec
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8005314: 68fb         	ldr	r3, [r7, #0xc]
 8005316: 3310         	adds	r3, #0x10
 8005318: 60fb         	str	r3, [r7, #0xc]
 800531a: 68fb         	ldr	r3, [r7, #0xc]
 800531c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800533c <msg_process+0x58>
 800531e: 4293         	cmp	r3, r2
 8005320: bf34         	ite	lo
 8005322: 2301         	movlo	r3, #0x1
 8005324: 2300         	movhs	r3, #0x0
 8005326: b2db         	uxtb	r3, r3
 8005328: 2b00         	cmp	r3, #0x0
 800532a: d1e2         	bne	0x80052f2 <msg_process+0xe> @ imm = #-0x3c
; }
 800532c: bf00         	nop
 800532e: bf00         	nop
 8005330: 3710         	adds	r7, #0x10
 8005332: 46bd         	mov	sp, r7
 8005334: bd80         	pop	{r7, pc}
 8005336: bf00         	nop

08005338 <$d>:
 8005338: 34 07 02 08  	.word	0x08020734
 800533c: 44 07 02 08  	.word	0x08020744

08005340 <z_log_notify_backend_enabled>:
; {
 8005340: b480         	push	{r7}
 8005342: af00         	add	r7, sp, #0x0
; 	backend_attached = true;
 8005344: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8005354 <z_log_notify_backend_enabled+0x14>
 8005346: 2201         	movs	r2, #0x1
 8005348: 701a         	strb	r2, [r3]
; }
 800534a: bf00         	nop
 800534c: 46bd         	mov	sp, r7
 800534e: f85d 7b04    	ldr	r7, [sp], #4
 8005352: 4770         	bx	lr

08005354 <$d>:
 8005354: f9 27 00 20  	.word	0x200027f9

08005358 <z_log_dropped>:
; {
 8005358: b580         	push	{r7, lr}
 800535a: b082         	sub	sp, #0x8
 800535c: af00         	add	r7, sp, #0x0
 800535e: 4603         	mov	r3, r0
 8005360: 71fb         	strb	r3, [r7, #0x7]
; 	atomic_inc(&dropped_cnt);
 8005362: 4806         	ldr	r0, [pc, #0x18]         @ 0x800537c <z_log_dropped+0x24>
 8005364: f011 fb18    	bl	0x8016998 <atomic_inc>  @ imm = #0x11630
; 	if (buffered) {
 8005368: 79fb         	ldrb	r3, [r7, #0x7]
 800536a: 2b00         	cmp	r3, #0x0
 800536c: d002         	beq	0x8005374 <z_log_dropped+0x1c> @ imm = #0x4
; 		atomic_dec(&buffered_cnt);
 800536e: 4804         	ldr	r0, [pc, #0x10]         @ 0x8005380 <z_log_dropped+0x28>
 8005370: f011 fb1f    	bl	0x80169b2 <atomic_dec>  @ imm = #0x1163e
; }
 8005374: bf00         	nop
 8005376: 3708         	adds	r7, #0x8
 8005378: 46bd         	mov	sp, r7
 800537a: bd80         	pop	{r7, pc}

0800537c <$d>:
 800537c: 58 24 00 20  	.word	0x20002458
 8005380: 54 24 00 20  	.word	0x20002454

08005384 <z_log_msg_commit>:
; {
 8005384: b580         	push	{r7, lr}
 8005386: b082         	sub	sp, #0x8
 8005388: af00         	add	r7, sp, #0x0
 800538a: 6078         	str	r0, [r7, #0x4]
; 	msg->hdr.timestamp = timestamp_func();
 800538c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80053a8 <z_log_msg_commit+0x24>
 800538e: 681b         	ldr	r3, [r3]
 8005390: 4798         	blx	r3
 8005392: 4602         	mov	r2, r0
 8005394: 687b         	ldr	r3, [r7, #0x4]
 8005396: 609a         	str	r2, [r3, #0x8]
; 	msg_commit(&log_buffer, msg);
 8005398: 6879         	ldr	r1, [r7, #0x4]
 800539a: 4804         	ldr	r0, [pc, #0x10]         @ 0x80053ac <z_log_msg_commit+0x28>
 800539c: f011 fc4e    	bl	0x8016c3c <msg_commit>  @ imm = #0x1189c
; }
 80053a0: bf00         	nop
 80053a2: 3708         	adds	r7, #0x8
 80053a4: 46bd         	mov	sp, r7
 80053a6: bd80         	pop	{r7, pc}

080053a8 <$d>:
 80053a8: fc 04 00 20  	.word	0x200004fc
 80053ac: 4c 06 00 20  	.word	0x2000064c

080053b0 <log_const_source_id>:
; {
 80053b0: b480         	push	{r7}
 80053b2: b083         	sub	sp, #0xc
 80053b4: af00         	add	r7, sp, #0x0
 80053b6: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 80053b8: 687b         	ldr	r3, [r7, #0x4]
 80053ba: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80053cc <log_const_source_id+0x1c>
 80053bc: 1a9b         	subs	r3, r3, r2
 80053be: 08db         	lsrs	r3, r3, #0x3
; }
 80053c0: 4618         	mov	r0, r3
 80053c2: 370c         	adds	r7, #0xc
 80053c4: 46bd         	mov	sp, r7
 80053c6: f85d 7b04    	ldr	r7, [sp], #4
 80053ca: 4770         	bx	lr

080053cc <$d>:
 80053cc: bc 06 02 08  	.word	0x080206bc

080053d0 <z_log_sources_count>:
; {
 80053d0: b580         	push	{r7, lr}
 80053d2: af00         	add	r7, sp, #0x0
; 	return log_const_source_id(TYPE_SECTION_END(log_const));
 80053d4: 4802         	ldr	r0, [pc, #0x8]          @ 0x80053e0 <z_log_sources_count+0x10>
 80053d6: f7ff ffeb    	bl	0x80053b0 <log_const_source_id> @ imm = #-0x2a
 80053da: 4603         	mov	r3, r0
; }
 80053dc: 4618         	mov	r0, r3
 80053de: bd80         	pop	{r7, pc}

080053e0 <$d>:
 80053e0: 34 07 02 08  	.word	0x08020734

080053e4 <log_backend_get>:
; {
 80053e4: b480         	push	{r7}
 80053e6: b085         	sub	sp, #0x14
 80053e8: af00         	add	r7, sp, #0x0
 80053ea: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 80053ec: 687b         	ldr	r3, [r7, #0x4]
 80053ee: 011b         	lsls	r3, r3, #0x4
 80053f0: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8005404 <log_backend_get+0x20>
 80053f2: 4413         	add	r3, r2
 80053f4: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 80053f6: 68fb         	ldr	r3, [r7, #0xc]
; }
 80053f8: 4618         	mov	r0, r3
 80053fa: 3714         	adds	r7, #0x14
 80053fc: 46bd         	mov	sp, r7
 80053fe: f85d 7b04    	ldr	r7, [sp], #4
 8005402: 4770         	bx	lr

08005404 <$d>:
 8005404: 34 07 02 08  	.word	0x08020734

08005408 <get_link_domain>:
; {
 8005408: b480         	push	{r7}
 800540a: b085         	sub	sp, #0x14
 800540c: af00         	add	r7, sp, #0x0
 800540e: 4603         	mov	r3, r0
 8005410: 6039         	str	r1, [r7]
 8005412: 71fb         	strb	r3, [r7, #0x7]
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 8005414: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8005478 <get_link_domain+0x70>
 8005416: 60fb         	str	r3, [r7, #0xc]
 8005418: e01b         	b	0x8005452 <get_link_domain+0x4a> @ imm = #0x36
; 		domain_max = link->ctrl_blk->domain_offset +
 800541a: 68fb         	ldr	r3, [r7, #0xc]
 800541c: 689b         	ldr	r3, [r3, #0x8]
 800541e: 689b         	ldr	r3, [r3, #0x8]
 8005420: b2da         	uxtb	r2, r3
; 				link->ctrl_blk->domain_cnt;
 8005422: 68fb         	ldr	r3, [r7, #0xc]
 8005424: 689b         	ldr	r3, [r3, #0x8]
 8005426: 681b         	ldr	r3, [r3]
; 		domain_max = link->ctrl_blk->domain_offset +
 8005428: b2db         	uxtb	r3, r3
 800542a: 4413         	add	r3, r2
 800542c: 72fb         	strb	r3, [r7, #0xb]
; 		if (domain_id < domain_max) {
 800542e: 79fa         	ldrb	r2, [r7, #0x7]
 8005430: 7afb         	ldrb	r3, [r7, #0xb]
 8005432: 429a         	cmp	r2, r3
 8005434: d20a         	bhs	0x800544c <get_link_domain+0x44> @ imm = #0x14
; 			*rel_domain_id = domain_id - link->ctrl_blk->domain_offset;
 8005436: 68fb         	ldr	r3, [r7, #0xc]
 8005438: 689b         	ldr	r3, [r3, #0x8]
 800543a: 689b         	ldr	r3, [r3, #0x8]
 800543c: b2db         	uxtb	r3, r3
 800543e: 79fa         	ldrb	r2, [r7, #0x7]
 8005440: 1ad3         	subs	r3, r2, r3
 8005442: b2da         	uxtb	r2, r3
 8005444: 683b         	ldr	r3, [r7]
 8005446: 701a         	strb	r2, [r3]
; 			return link;
 8005448: 68fb         	ldr	r3, [r7, #0xc]
 800544a: e00f         	b	0x800546c <get_link_domain+0x64> @ imm = #0x1e
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 800544c: 68fb         	ldr	r3, [r7, #0xc]
 800544e: 3318         	adds	r3, #0x18
 8005450: 60fb         	str	r3, [r7, #0xc]
 8005452: 68fb         	ldr	r3, [r7, #0xc]
 8005454: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800547c <get_link_domain+0x74>
 8005456: 4293         	cmp	r3, r2
 8005458: bf34         	ite	lo
 800545a: 2301         	movlo	r3, #0x1
 800545c: 2300         	movhs	r3, #0x0
 800545e: b2db         	uxtb	r3, r3
 8005460: 2b00         	cmp	r3, #0x0
 8005462: d1da         	bne	0x800541a <get_link_domain+0x12> @ imm = #-0x4c
; 	*rel_domain_id = 0;
 8005464: 683b         	ldr	r3, [r7]
 8005466: 2200         	movs	r2, #0x0
 8005468: 701a         	strb	r2, [r3]
; 	return NULL;
 800546a: 2300         	movs	r3, #0x0
; }
 800546c: 4618         	mov	r0, r3
 800546e: 3714         	adds	r7, #0x14
 8005470: 46bd         	mov	sp, r7
 8005472: f85d 7b04    	ldr	r7, [sp], #4
 8005476: 4770         	bx	lr

08005478 <$d>:
 8005478: 44 07 02 08  	.word	0x08020744
 800547c: 44 07 02 08  	.word	0x08020744

08005480 <link_source_name_get>:
; {
 8005480: b580         	push	{r7, lr}
 8005482: b08a         	sub	sp, #0x28
 8005484: af02         	add	r7, sp, #0x8
 8005486: 4603         	mov	r3, r0
 8005488: 6039         	str	r1, [r7]
 800548a: 71fb         	strb	r3, [r7, #0x7]
; 	size_t cache_size = sname_cache.item_size;
 800548c: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8005500 <link_source_name_get+0x80>
 800548e: 69db         	ldr	r3, [r3, #0x1c]
 8005490: 613b         	str	r3, [r7, #0x10]
; 	union log_source_ids id = {
 8005492: 79fb         	ldrb	r3, [r7, #0x7]
 8005494: 733b         	strb	r3, [r7, #0xc]
 8005496: 683b         	ldr	r3, [r7]
 8005498: b29b         	uxth	r3, r3
 800549a: 81fb         	strh	r3, [r7, #0xe]
; 	if (!log_cache_get(&sname_cache, id.raw, &cached)) {
 800549c: 68fb         	ldr	r3, [r7, #0xc]
 800549e: f107 0214    	add.w	r2, r7, #0x14
 80054a2: 4619         	mov	r1, r3
 80054a4: 4816         	ldr	r0, [pc, #0x58]         @ 0x8005500 <link_source_name_get+0x80>
 80054a6: f011 fdb7    	bl	0x8017018 <log_cache_get> @ imm = #0x11b6e
 80054aa: 4603         	mov	r3, r0
 80054ac: f083 0301    	eor	r3, r3, #0x1
 80054b0: b2db         	uxtb	r3, r3
 80054b2: 2b00         	cmp	r3, #0x0
 80054b4: d01f         	beq	0x80054f6 <link_source_name_get+0x76> @ imm = #0x3e
; 		const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 80054b6: f107 020b    	add.w	r2, r7, #0xb
 80054ba: 79fb         	ldrb	r3, [r7, #0x7]
 80054bc: 4611         	mov	r1, r2
 80054be: 4618         	mov	r0, r3
 80054c0: f7ff ffa2    	bl	0x8005408 <get_link_domain> @ imm = #-0xbc
 80054c4: 61f8         	str	r0, [r7, #0x1c]
; 		err = log_link_get_source_name(link, rel_domain_id, source_id,
 80054c6: 7afb         	ldrb	r3, [r7, #0xb]
 80054c8: 4618         	mov	r0, r3
 80054ca: 683b         	ldr	r3, [r7]
 80054cc: b29a         	uxth	r2, r3
 80054ce: 6979         	ldr	r1, [r7, #0x14]
 80054d0: f107 0310    	add.w	r3, r7, #0x10
 80054d4: 9300         	str	r3, [sp]
 80054d6: 460b         	mov	r3, r1
 80054d8: 4601         	mov	r1, r0
 80054da: 69f8         	ldr	r0, [r7, #0x1c]
 80054dc: f011 fc0c    	bl	0x8016cf8 <log_link_get_source_name> @ imm = #0x11818
 80054e0: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 80054e2: 69bb         	ldr	r3, [r7, #0x18]
 80054e4: 2b00         	cmp	r3, #0x0
 80054e6: da01         	bge	0x80054ec <link_source_name_get+0x6c> @ imm = #0x2
; 			return NULL;
 80054e8: 2300         	movs	r3, #0x0
 80054ea: e005         	b	0x80054f8 <link_source_name_get+0x78> @ imm = #0xa
; 		log_cache_put(&sname_cache, cached);
 80054ec: 697b         	ldr	r3, [r7, #0x14]
 80054ee: 4619         	mov	r1, r3
 80054f0: 4803         	ldr	r0, [pc, #0xc]          @ 0x8005500 <link_source_name_get+0x80>
 80054f2: f011 fe14    	bl	0x801711e <log_cache_put> @ imm = #0x11c28
; 	return (const char *)cached;
 80054f6: 697b         	ldr	r3, [r7, #0x14]
; }
 80054f8: 4618         	mov	r0, r3
 80054fa: 3720         	adds	r7, #0x20
 80054fc: 46bd         	mov	sp, r7
 80054fe: bd80         	pop	{r7, pc}

08005500 <$d>:
 8005500: 60 24 00 20  	.word	0x20002460

08005504 <log_source_name_get>:
; {
 8005504: b580         	push	{r7, lr}
 8005506: b082         	sub	sp, #0x8
 8005508: af00         	add	r7, sp, #0x0
 800550a: 6078         	str	r0, [r7, #0x4]
 800550c: 6039         	str	r1, [r7]
; 	if (z_log_is_local_domain(domain_id)) {
 800550e: 687b         	ldr	r3, [r7, #0x4]
 8005510: b2db         	uxtb	r3, r3
 8005512: 4618         	mov	r0, r3
 8005514: f011 fbb0    	bl	0x8016c78 <z_log_is_local_domain> @ imm = #0x11760
 8005518: 4603         	mov	r3, r0
 800551a: 2b00         	cmp	r3, #0x0
 800551c: d00d         	beq	0x800553a <log_source_name_get+0x36> @ imm = #0x1a
; 		if (source_id < log_src_cnt_get(domain_id)) {
 800551e: 6878         	ldr	r0, [r7, #0x4]
 8005520: f011 fc18    	bl	0x8016d54 <log_src_cnt_get> @ imm = #0x11830
 8005524: 4602         	mov	r2, r0
 8005526: 683b         	ldr	r3, [r7]
 8005528: 4293         	cmp	r3, r2
 800552a: d204         	bhs	0x8005536 <log_source_name_get+0x32> @ imm = #0x8
; 			return TYPE_SECTION_START(log_const)[source_id].name;
 800552c: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8005550 <log_source_name_get+0x4c>
 800552e: 683b         	ldr	r3, [r7]
 8005530: f852 3033    	ldr.w	r3, [r2, r3, lsl #3]
 8005534: e008         	b	0x8005548 <log_source_name_get+0x44> @ imm = #0x10
; 			return NULL;
 8005536: 2300         	movs	r3, #0x0
 8005538: e006         	b	0x8005548 <log_source_name_get+0x44> @ imm = #0xc
; 	return link_source_name_get(domain_id, source_id);
 800553a: 687b         	ldr	r3, [r7, #0x4]
 800553c: b2db         	uxtb	r3, r3
 800553e: 6839         	ldr	r1, [r7]
 8005540: 4618         	mov	r0, r3
 8005542: f7ff ff9d    	bl	0x8005480 <link_source_name_get> @ imm = #-0xc6
 8005546: 4603         	mov	r3, r0
; }
 8005548: 4618         	mov	r0, r3
 800554a: 3708         	adds	r7, #0x8
 800554c: 46bd         	mov	sp, r7
 800554e: bd80         	pop	{r7, pc}

08005550 <$d>:
 8005550: bc 06 02 08  	.word	0x080206bc

08005554 <log_const_source_id>:
; {
 8005554: b480         	push	{r7}
 8005556: b083         	sub	sp, #0xc
 8005558: af00         	add	r7, sp, #0x0
 800555a: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 800555c: 687b         	ldr	r3, [r7, #0x4]
 800555e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8005570 <log_const_source_id+0x1c>
 8005560: 1a9b         	subs	r3, r3, r2
 8005562: 08db         	lsrs	r3, r3, #0x3
; }
 8005564: 4618         	mov	r0, r3
 8005566: 370c         	adds	r7, #0xc
 8005568: 46bd         	mov	sp, r7
 800556a: f85d 7b04    	ldr	r7, [sp], #4
 800556e: 4770         	bx	lr

08005570 <$d>:
 8005570: bc 06 02 08  	.word	0x080206bc

08005574 <z_log_msg_runtime_vcreate>:
; {
 8005574: b580         	push	{r7, lr}
 8005576: b090         	sub	sp, #0x40
 8005578: af04         	add	r7, sp, #0x10
 800557a: 60b9         	str	r1, [r7, #0x8]
 800557c: 607b         	str	r3, [r7, #0x4]
 800557e: 4603         	mov	r3, r0
 8005580: 73fb         	strb	r3, [r7, #0xf]
 8005582: 4613         	mov	r3, r2
 8005584: 73bb         	strb	r3, [r7, #0xe]
; 	if (fmt) {
 8005586: 6c3b         	ldr	r3, [r7, #0x40]
 8005588: 2b00         	cmp	r3, #0x0
 800558a: d00b         	beq	0x80055a4 <z_log_msg_runtime_vcreate+0x30> @ imm = #0x16
; 		va_copy(ap2, ap);
 800558c: 6c7b         	ldr	r3, [r7, #0x44]
 800558e: 613b         	str	r3, [r7, #0x10]
; 		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
 8005590: 693b         	ldr	r3, [r7, #0x10]
 8005592: 9300         	str	r3, [sp]
 8005594: 6c3b         	ldr	r3, [r7, #0x40]
 8005596: 6bfa         	ldr	r2, [r7, #0x3c]
 8005598: 2110         	movs	r1, #0x10
 800559a: 2000         	movs	r0, #0x0
 800559c: f7ff f950    	bl	0x8004840 <cbvprintf_package> @ imm = #-0xd60
 80055a0: 62f8         	str	r0, [r7, #0x2c]
 80055a2: e001         	b	0x80055a8 <z_log_msg_runtime_vcreate+0x34> @ imm = #0x2
; 		plen = 0;
 80055a4: 2300         	movs	r3, #0x0
 80055a6: 62fb         	str	r3, [r7, #0x2c]
; 	if (plen > Z_LOG_MSG_MAX_PACKAGE) {
 80055a8: 6afb         	ldr	r3, [r7, #0x2c]
 80055aa: f5b3 6f00    	cmp.w	r3, #0x800
 80055ae: d31d         	blo	0x80055ec <z_log_msg_runtime_vcreate+0x78> @ imm = #0x3a
; 		LOG_WRN("Message dropped because it exceeds size limitation (%u)",
 80055b0: 2303         	movs	r3, #0x3
 80055b2: 2b01         	cmp	r3, #0x1
 80055b4: d973         	bls	0x800569e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xe6
 80055b6: 2301         	movs	r3, #0x1
 80055b8: 77fb         	strb	r3, [r7, #0x1f]
 80055ba: 7ffb         	ldrb	r3, [r7, #0x1f]
 80055bc: f083 0301    	eor	r3, r3, #0x1
 80055c0: b2db         	uxtb	r3, r3
 80055c2: 2b00         	cmp	r3, #0x0
 80055c4: d16b         	bne	0x800569e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xd6
 80055c6: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x80056a4 <z_log_msg_runtime_vcreate+0x130>
 80055c8: 6819         	ldr	r1, [r3]
 80055ca: f240 73ff    	movw	r3, #0x7ff
 80055ce: 9303         	str	r3, [sp, #0xc]
 80055d0: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80056a8 <z_log_msg_runtime_vcreate+0x134>
 80055d2: 9302         	str	r3, [sp, #0x8]
 80055d4: 2300         	movs	r3, #0x0
 80055d6: 9301         	str	r3, [sp, #0x4]
 80055d8: 2300         	movs	r3, #0x0
 80055da: 9300         	str	r3, [sp]
 80055dc: 2300         	movs	r3, #0x0
 80055de: 2202         	movs	r2, #0x2
 80055e0: 2000         	movs	r0, #0x0
 80055e2: f011 fdae    	bl	0x8017142 <z_log_msg_runtime_create> @ imm = #0x11b5c
 80055e6: 2300         	movs	r3, #0x0
 80055e8: 61bb         	str	r3, [r7, #0x18]
; 		return;
 80055ea: e058         	b	0x800569e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xb0
; 	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
 80055ec: 6afa         	ldr	r2, [r7, #0x2c]
 80055ee: 6bbb         	ldr	r3, [r7, #0x38]
 80055f0: 4413         	add	r3, r2
 80055f2: 3317         	adds	r3, #0x17
 80055f4: f023 0307    	bic	r3, r3, #0x7
 80055f8: 3303         	adds	r3, #0x3
 80055fa: 089b         	lsrs	r3, r3, #0x2
 80055fc: 62bb         	str	r3, [r7, #0x28]
; 	struct log_msg_desc desc =
 80055fe: 7d3b         	ldrb	r3, [r7, #0x14]
 8005600: f36f 0300    	bfc	r3, #0, #1
 8005604: 753b         	strb	r3, [r7, #0x14]
 8005606: 7d3b         	ldrb	r3, [r7, #0x14]
 8005608: f36f 0341    	bfc	r3, #1, #1
 800560c: 753b         	strb	r3, [r7, #0x14]
 800560e: 7d3b         	ldrb	r3, [r7, #0x14]
 8005610: f36f 0382    	bfc	r3, #2, #1
 8005614: 753b         	strb	r3, [r7, #0x14]
 8005616: 7bfb         	ldrb	r3, [r7, #0xf]
 8005618: f003 0307    	and	r3, r3, #0x7
 800561c: b2da         	uxtb	r2, r3
 800561e: 7d3b         	ldrb	r3, [r7, #0x14]
 8005620: f362 03c5    	bfi	r3, r2, #3, #3
 8005624: 753b         	strb	r3, [r7, #0x14]
 8005626: 7bbb         	ldrb	r3, [r7, #0xe]
 8005628: f003 0307    	and	r3, r3, #0x7
 800562c: b2da         	uxtb	r2, r3
 800562e: 8abb         	ldrh	r3, [r7, #0x14]
 8005630: f362 1388    	bfi	r3, r2, #6, #3
 8005634: 82bb         	strh	r3, [r7, #0x14]
 8005636: 6afb         	ldr	r3, [r7, #0x2c]
 8005638: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 800563c: b29a         	uxth	r2, r3
 800563e: 697b         	ldr	r3, [r7, #0x14]
 8005640: f362 2353    	bfi	r3, r2, #9, #11
 8005644: 617b         	str	r3, [r7, #0x14]
 8005646: 6bbb         	ldr	r3, [r7, #0x38]
 8005648: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 800564c: b29a         	uxth	r2, r3
 800564e: 8afb         	ldrh	r3, [r7, #0x16]
 8005650: f362 130f    	bfi	r3, r2, #4, #12
 8005654: 82fb         	strh	r3, [r7, #0x16]
; 		msg = alloca(msg_wlen * sizeof(int));
 8005656: 6abb         	ldr	r3, [r7, #0x28]
 8005658: 009b         	lsls	r3, r3, #0x2
 800565a: 3307         	adds	r3, #0x7
 800565c: 08db         	lsrs	r3, r3, #0x3
 800565e: 00db         	lsls	r3, r3, #0x3
 8005660: ebad 0d03    	sub.w	sp, sp, r3
 8005664: ab04         	add	r3, sp, #0x10
 8005666: 3307         	adds	r3, #0x7
 8005668: 08db         	lsrs	r3, r3, #0x3
 800566a: 00db         	lsls	r3, r3, #0x3
 800566c: 627b         	str	r3, [r7, #0x24]
; 		pkg = msg->data;
 800566e: 6a7b         	ldr	r3, [r7, #0x24]
 8005670: 3310         	adds	r3, #0x10
 8005672: 623b         	str	r3, [r7, #0x20]
; 	if (pkg && fmt) {
 8005674: 6a3b         	ldr	r3, [r7, #0x20]
 8005676: 2b00         	cmp	r3, #0x0
 8005678: d00b         	beq	0x8005692 <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x16
 800567a: 6c3b         	ldr	r3, [r7, #0x40]
 800567c: 2b00         	cmp	r3, #0x0
 800567e: d008         	beq	0x8005692 <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x10
; 		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
 8005680: 6af9         	ldr	r1, [r7, #0x2c]
 8005682: 6c7b         	ldr	r3, [r7, #0x44]
 8005684: 9300         	str	r3, [sp]
 8005686: 6c3b         	ldr	r3, [r7, #0x40]
 8005688: 6bfa         	ldr	r2, [r7, #0x3c]
 800568a: 6a38         	ldr	r0, [r7, #0x20]
 800568c: f7ff f8d8    	bl	0x8004840 <cbvprintf_package> @ imm = #-0xe50
 8005690: 62f8         	str	r0, [r7, #0x2c]
; 		z_log_msg_finalize(msg, source, desc, data);
 8005692: 687b         	ldr	r3, [r7, #0x4]
 8005694: 697a         	ldr	r2, [r7, #0x14]
 8005696: 68b9         	ldr	r1, [r7, #0x8]
 8005698: 6a78         	ldr	r0, [r7, #0x24]
 800569a: f011 fda3    	bl	0x80171e4 <z_log_msg_finalize> @ imm = #0x11b46
; }
 800569e: 3730         	adds	r7, #0x30
 80056a0: 46bd         	mov	sp, r7
 80056a2: bd80         	pop	{r7, pc}

080056a4 <$d>:
 80056a4: 00 05 00 20  	.word	0x20000500
 80056a8: 38 0a 02 08  	.word	0x08020a38

080056ac <cbpprintf>:
; {
 80056ac: b580         	push	{r7, lr}
 80056ae: b084         	sub	sp, #0x10
 80056b0: af00         	add	r7, sp, #0x0
 80056b2: 60f8         	str	r0, [r7, #0xc]
 80056b4: 60b9         	str	r1, [r7, #0x8]
 80056b6: 607a         	str	r2, [r7, #0x4]
; 	return cbpprintf_external(out, cbvprintf, ctx, packaged);
 80056b8: 687b         	ldr	r3, [r7, #0x4]
 80056ba: 68ba         	ldr	r2, [r7, #0x8]
 80056bc: 4904         	ldr	r1, [pc, #0x10]         @ 0x80056d0 <cbpprintf+0x24>
 80056be: 68f8         	ldr	r0, [r7, #0xc]
 80056c0: f011 f895    	bl	0x80167ee <cbpprintf_external> @ imm = #0x1112a
 80056c4: 4603         	mov	r3, r0
; }
 80056c6: 4618         	mov	r0, r3
 80056c8: 3710         	adds	r7, #0x10
 80056ca: 46bd         	mov	sp, r7
 80056cc: bd80         	pop	{r7, pc}
 80056ce: bf00         	nop

080056d0 <$d>:
 80056d0: a9 72 00 08  	.word	0x080072a9

080056d4 <__ctype_lookup>:
; static __inline char __ctype_lookup(int c) { return (__CTYPE_PTR + 1)[c]; }
 80056d4: b480         	push	{r7}
 80056d6: b083         	sub	sp, #0xc
 80056d8: af00         	add	r7, sp, #0x0
 80056da: 6078         	str	r0, [r7, #0x4]
 80056dc: 687b         	ldr	r3, [r7, #0x4]
 80056de: 3301         	adds	r3, #0x1
 80056e0: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80056f4 <__ctype_lookup+0x20>
 80056e2: 4413         	add	r3, r2
 80056e4: 781b         	ldrb	r3, [r3]
 80056e6: 4618         	mov	r0, r3
 80056e8: 370c         	adds	r7, #0xc
 80056ea: 46bd         	mov	sp, r7
 80056ec: f85d 7b04    	ldr	r7, [sp], #4
 80056f0: 4770         	bx	lr
 80056f2: bf00         	nop

080056f4 <$d>:
 80056f4: a8 33 02 08  	.word	0x080233a8

080056f8 <print_formatted>:
; {
 80056f8: b40e         	push	{r1, r2, r3}
 80056fa: b580         	push	{r7, lr}
 80056fc: b085         	sub	sp, #0x14
 80056fe: af00         	add	r7, sp, #0x0
 8005700: 6078         	str	r0, [r7, #0x4]
; 	int length = 0;
 8005702: 2300         	movs	r3, #0x0
 8005704: 60fb         	str	r3, [r7, #0xc]
; 	va_start(args, fmt);
 8005706: f107 0320    	add.w	r3, r7, #0x20
 800570a: 60bb         	str	r3, [r7, #0x8]
; 	length = cbvprintf(out_func, (void *)output, fmt, args);
 800570c: 68bb         	ldr	r3, [r7, #0x8]
 800570e: 69fa         	ldr	r2, [r7, #0x1c]
 8005710: 6879         	ldr	r1, [r7, #0x4]
 8005712: 4806         	ldr	r0, [pc, #0x18]         @ 0x800572c <print_formatted+0x34>
 8005714: f001 fdc8    	bl	0x80072a8 <cbvprintf>   @ imm = #0x1b90
 8005718: 60f8         	str	r0, [r7, #0xc]
; 	return length;
 800571a: 68fb         	ldr	r3, [r7, #0xc]
; }
 800571c: 4618         	mov	r0, r3
 800571e: 3714         	adds	r7, #0x14
 8005720: 46bd         	mov	sp, r7
 8005722: e8bd 4080    	pop.w	{r7, lr}
 8005726: b003         	add	sp, #0xc
 8005728: 4770         	bx	lr
 800572a: bf00         	nop

0800572c <$d>:
 800572c: cd 73 01 08  	.word	0x080173cd

08005730 <timestamp_print>:
; {
 8005730: b580         	push	{r7, lr}
 8005732: b09a         	sub	sp, #0x68
 8005734: af04         	add	r7, sp, #0x10
 8005736: 60f8         	str	r0, [r7, #0xc]
 8005738: 60b9         	str	r1, [r7, #0x8]
 800573a: 607a         	str	r2, [r7, #0x4]
; 		IS_ENABLED(CONFIG_LOG_OUTPUT_FORMAT_LINUX_TIMESTAMP) |
 800573c: 68bb         	ldr	r3, [r7, #0x8]
 800573e: f003 0344    	and	r3, r3, #0x44
; 	bool format =
 8005742: 2b00         	cmp	r3, #0x0
 8005744: bf14         	ite	ne
 8005746: 2301         	movne	r3, #0x1
 8005748: 2300         	moveq	r3, #0x0
 800574a: f887 3037    	strb.w	r3, [r7, #0x37]
; 	if (!format) {
 800574e: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8005752: f083 0301    	eor	r3, r3, #0x1
 8005756: b2db         	uxtb	r3, r3
 8005758: 2b00         	cmp	r3, #0x0
 800575a: d006         	beq	0x800576a <timestamp_print+0x3a> @ imm = #0xc
; 		length = print_formatted(output, "[%08lu] ", timestamp);
 800575c: 687a         	ldr	r2, [r7, #0x4]
 800575e: 4938         	ldr	r1, [pc, #0xe0]         @ 0x8005840 <timestamp_print+0x110>
 8005760: 68f8         	ldr	r0, [r7, #0xc]
 8005762: f7ff ffc9    	bl	0x80056f8 <print_formatted> @ imm = #-0x6e
 8005766: 63b8         	str	r0, [r7, #0x38]
 8005768: e065         	b	0x8005836 <timestamp_print+0x106> @ imm = #0xca
; 	} else if (freq != 0U) {
 800576a: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8005844 <timestamp_print+0x114>
 800576c: 681b         	ldr	r3, [r3]
 800576e: 2b00         	cmp	r3, #0x0
 8005770: d05f         	beq	0x8005832 <timestamp_print+0x102> @ imm = #0xbe
; 		timestamp /= timestamp_div;
 8005772: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8005848 <timestamp_print+0x118>
 8005774: 681b         	ldr	r3, [r3]
 8005776: 687a         	ldr	r2, [r7, #0x4]
 8005778: fbb2 f3f3    	udiv	r3, r2, r3
 800577c: 607b         	str	r3, [r7, #0x4]
; 		total_seconds = timestamp / freq;
 800577e: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8005844 <timestamp_print+0x114>
 8005780: 681b         	ldr	r3, [r3]
 8005782: 687a         	ldr	r2, [r7, #0x4]
 8005784: fbb2 f3f3    	udiv	r3, r2, r3
 8005788: 63fb         	str	r3, [r7, #0x3c]
; 		seconds = total_seconds;
 800578a: 6bfb         	ldr	r3, [r7, #0x3c]
 800578c: 653b         	str	r3, [r7, #0x50]
; 		hours = seconds / 3600U;
 800578e: 6d3b         	ldr	r3, [r7, #0x50]
 8005790: 4a2e         	ldr	r2, [pc, #0xb8]         @ 0x800584c <timestamp_print+0x11c>
 8005792: fba2 2303    	umull	r2, r3, r2, r3
 8005796: 0adb         	lsrs	r3, r3, #0xb
 8005798: 643b         	str	r3, [r7, #0x40]
; 		seconds -= hours * 3600U;
 800579a: 6c3b         	ldr	r3, [r7, #0x40]
 800579c: f44f 6261    	mov.w	r2, #0xe10
 80057a0: fb02 f303    	mul	r3, r2, r3
 80057a4: 6d3a         	ldr	r2, [r7, #0x50]
 80057a6: 1ad3         	subs	r3, r2, r3
 80057a8: 653b         	str	r3, [r7, #0x50]
; 		mins = seconds / 60U;
 80057aa: 6d3b         	ldr	r3, [r7, #0x50]
 80057ac: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8005850 <timestamp_print+0x120>
 80057ae: fba2 2303    	umull	r2, r3, r2, r3
 80057b2: 095b         	lsrs	r3, r3, #0x5
 80057b4: 657b         	str	r3, [r7, #0x54]
; 		seconds -= mins * 60U;
 80057b6: 6d7a         	ldr	r2, [r7, #0x54]
 80057b8: 4613         	mov	r3, r2
 80057ba: 011b         	lsls	r3, r3, #0x4
 80057bc: 1a9b         	subs	r3, r3, r2
 80057be: 009b         	lsls	r3, r3, #0x2
 80057c0: 461a         	mov	r2, r3
 80057c2: 6d3b         	ldr	r3, [r7, #0x50]
 80057c4: 1a9b         	subs	r3, r3, r2
 80057c6: 653b         	str	r3, [r7, #0x50]
; 		remainder = timestamp % freq;
 80057c8: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8005844 <timestamp_print+0x114>
 80057ca: 681a         	ldr	r2, [r3]
 80057cc: 687b         	ldr	r3, [r7, #0x4]
 80057ce: fbb3 f1f2    	udiv	r1, r3, r2
 80057d2: fb01 f202    	mul	r2, r1, r2
 80057d6: 1a9b         	subs	r3, r3, r2
 80057d8: 64fb         	str	r3, [r7, #0x4c]
; 		ms = (remainder * 1000U) / freq;
 80057da: 6cfb         	ldr	r3, [r7, #0x4c]
 80057dc: f44f 727a    	mov.w	r2, #0x3e8
 80057e0: fb03 f202    	mul	r2, r3, r2
 80057e4: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8005844 <timestamp_print+0x114>
 80057e6: 681b         	ldr	r3, [r3]
 80057e8: fbb2 f3f3    	udiv	r3, r2, r3
 80057ec: 64bb         	str	r3, [r7, #0x48]
; 		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 80057ee: 6cfb         	ldr	r3, [r7, #0x4c]
 80057f0: f44f 727a    	mov.w	r2, #0x3e8
 80057f4: fb03 f202    	mul	r2, r3, r2
 80057f8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8005844 <timestamp_print+0x114>
 80057fa: 681b         	ldr	r3, [r3]
 80057fc: 6cb9         	ldr	r1, [r7, #0x48]
 80057fe: fb01 f303    	mul	r3, r1, r3
 8005802: 1ad3         	subs	r3, r2, r3
 8005804: f44f 727a    	mov.w	r2, #0x3e8
 8005808: fb03 f202    	mul	r2, r3, r2
 800580c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8005844 <timestamp_print+0x114>
 800580e: 681b         	ldr	r3, [r3]
 8005810: fbb2 f3f3    	udiv	r3, r2, r3
 8005814: 647b         	str	r3, [r7, #0x44]
; 				length = print_formatted(output,
 8005816: 6c7b         	ldr	r3, [r7, #0x44]
 8005818: 9302         	str	r3, [sp, #0x8]
 800581a: 6cbb         	ldr	r3, [r7, #0x48]
 800581c: 9301         	str	r3, [sp, #0x4]
 800581e: 6d3b         	ldr	r3, [r7, #0x50]
 8005820: 9300         	str	r3, [sp]
 8005822: 6d7b         	ldr	r3, [r7, #0x54]
 8005824: 6c3a         	ldr	r2, [r7, #0x40]
 8005826: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8005854 <timestamp_print+0x124>
 8005828: 68f8         	ldr	r0, [r7, #0xc]
 800582a: f7ff ff65    	bl	0x80056f8 <print_formatted> @ imm = #-0x136
 800582e: 63b8         	str	r0, [r7, #0x38]
 8005830: e001         	b	0x8005836 <timestamp_print+0x106> @ imm = #0x2
; 		length = 0;
 8005832: 2300         	movs	r3, #0x0
 8005834: 63bb         	str	r3, [r7, #0x38]
; 	return length;
 8005836: 6bbb         	ldr	r3, [r7, #0x38]
; }
 8005838: 4618         	mov	r0, r3
 800583a: 3758         	adds	r7, #0x58
 800583c: 46bd         	mov	sp, r7
 800583e: bd80         	pop	{r7, pc}

08005840 <$d>:
 8005840: 90 0a 02 08  	.word	0x08020a90
 8005844: 80 24 00 20  	.word	0x20002480
 8005848: 84 24 00 20  	.word	0x20002484
 800584c: c5 b3 a2 91  	.word	0x91a2b3c5
 8005850: 89 88 88 88  	.word	0x88888889
 8005854: 9c 0a 02 08  	.word	0x08020a9c

08005858 <color_print>:
; {
 8005858: b580         	push	{r7, lr}
 800585a: b086         	sub	sp, #0x18
 800585c: af00         	add	r7, sp, #0x0
 800585e: 60f8         	str	r0, [r7, #0xc]
 8005860: 607b         	str	r3, [r7, #0x4]
 8005862: 460b         	mov	r3, r1
 8005864: 72fb         	strb	r3, [r7, #0xb]
 8005866: 4613         	mov	r3, r2
 8005868: 72bb         	strb	r3, [r7, #0xa]
; 	if (color) {
 800586a: 7afb         	ldrb	r3, [r7, #0xb]
 800586c: 2b00         	cmp	r3, #0x0
 800586e: d014         	beq	0x800589a <color_print+0x42> @ imm = #0x28
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8005870: 7abb         	ldrb	r3, [r7, #0xa]
 8005872: 2b00         	cmp	r3, #0x0
 8005874: d00a         	beq	0x800588c <color_print+0x34> @ imm = #0x14
; 		const char *log_color = start && (colors[level] != NULL) ?
 8005876: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80058a4 <color_print+0x4c>
 8005878: 687b         	ldr	r3, [r7, #0x4]
 800587a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800587e: 2b00         	cmp	r3, #0x0
 8005880: d004         	beq	0x800588c <color_print+0x34> @ imm = #0x8
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8005882: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80058a4 <color_print+0x4c>
 8005884: 687b         	ldr	r3, [r7, #0x4]
 8005886: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800588a: e000         	b	0x800588e <color_print+0x36> @ imm = #0x0
 800588c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80058a8 <color_print+0x50>
; 		const char *log_color = start && (colors[level] != NULL) ?
 800588e: 617b         	str	r3, [r7, #0x14]
; 		print_formatted(output, "%s", log_color);
 8005890: 697a         	ldr	r2, [r7, #0x14]
 8005892: 4906         	ldr	r1, [pc, #0x18]         @ 0x80058ac <color_print+0x54>
 8005894: 68f8         	ldr	r0, [r7, #0xc]
 8005896: f7ff ff2f    	bl	0x80056f8 <print_formatted> @ imm = #-0x1a2
; }
 800589a: bf00         	nop
 800589c: 3718         	adds	r7, #0x18
 800589e: 46bd         	mov	sp, r7
 80058a0: bd80         	pop	{r7, pc}
 80058a2: bf00         	nop

080058a4 <$d>:
 80058a4: 18 26 02 08  	.word	0x08022618
 80058a8: b8 0a 02 08  	.word	0x08020ab8
 80058ac: c0 0a 02 08  	.word	0x08020ac0

080058b0 <ids_print>:
; {
 80058b0: b580         	push	{r7, lr}
 80058b2: b084         	sub	sp, #0x10
 80058b4: af00         	add	r7, sp, #0x0
 80058b6: 6078         	str	r0, [r7, #0x4]
 80058b8: 4608         	mov	r0, r1
 80058ba: 4611         	mov	r1, r2
 80058bc: 461a         	mov	r2, r3
 80058be: 4603         	mov	r3, r0
 80058c0: 70fb         	strb	r3, [r7, #0x3]
 80058c2: 460b         	mov	r3, r1
 80058c4: 70bb         	strb	r3, [r7, #0x2]
 80058c6: 4613         	mov	r3, r2
 80058c8: 707b         	strb	r3, [r7, #0x1]
; 	int total = 0;
 80058ca: 2300         	movs	r3, #0x0
 80058cc: 60fb         	str	r3, [r7, #0xc]
; 	if (level_on) {
 80058ce: 78fb         	ldrb	r3, [r7, #0x3]
 80058d0: 2b00         	cmp	r3, #0x0
 80058d2: d00c         	beq	0x80058ee <ids_print+0x3e> @ imm = #0x18
; 		total += print_formatted(output, "<%s> ", severity[level]);
 80058d4: 4a19         	ldr	r2, [pc, #0x64]         @ 0x800593c <ids_print+0x8c>
 80058d6: 6a7b         	ldr	r3, [r7, #0x24]
 80058d8: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80058dc: 461a         	mov	r2, r3
 80058de: 4918         	ldr	r1, [pc, #0x60]         @ 0x8005940 <ids_print+0x90>
 80058e0: 6878         	ldr	r0, [r7, #0x4]
 80058e2: f7ff ff09    	bl	0x80056f8 <print_formatted> @ imm = #-0x1ee
 80058e6: 4602         	mov	r2, r0
 80058e8: 68fb         	ldr	r3, [r7, #0xc]
 80058ea: 4413         	add	r3, r2
 80058ec: 60fb         	str	r3, [r7, #0xc]
; 	if (domain) {
 80058ee: 69bb         	ldr	r3, [r7, #0x18]
 80058f0: 2b00         	cmp	r3, #0x0
 80058f2: d008         	beq	0x8005906 <ids_print+0x56> @ imm = #0x10
; 		total += print_formatted(output, "%s/", domain);
 80058f4: 69ba         	ldr	r2, [r7, #0x18]
 80058f6: 4913         	ldr	r1, [pc, #0x4c]         @ 0x8005944 <ids_print+0x94>
 80058f8: 6878         	ldr	r0, [r7, #0x4]
 80058fa: f7ff fefd    	bl	0x80056f8 <print_formatted> @ imm = #-0x206
 80058fe: 4602         	mov	r2, r0
 8005900: 68fb         	ldr	r3, [r7, #0xc]
 8005902: 4413         	add	r3, r2
 8005904: 60fb         	str	r3, [r7, #0xc]
; 	if (source) {
 8005906: 69fb         	ldr	r3, [r7, #0x1c]
 8005908: 2b00         	cmp	r3, #0x0
 800590a: d011         	beq	0x8005930 <ids_print+0x80> @ imm = #0x22
; 		total += print_formatted(output,
 800590c: 78bb         	ldrb	r3, [r7, #0x2]
 800590e: 2b00         	cmp	r3, #0x0
 8005910: d004         	beq	0x800591c <ids_print+0x6c> @ imm = #0x8
; 				(func_on &&
 8005912: 6a7b         	ldr	r3, [r7, #0x24]
 8005914: 2b04         	cmp	r3, #0x4
 8005916: d101         	bne	0x800591c <ids_print+0x6c> @ imm = #0x2
; 		total += print_formatted(output,
 8005918: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8005948 <ids_print+0x98>
 800591a: e000         	b	0x800591e <ids_print+0x6e> @ imm = #0x0
 800591c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800594c <ids_print+0x9c>
 800591e: 69fa         	ldr	r2, [r7, #0x1c]
 8005920: 4619         	mov	r1, r3
 8005922: 6878         	ldr	r0, [r7, #0x4]
 8005924: f7ff fee8    	bl	0x80056f8 <print_formatted> @ imm = #-0x230
 8005928: 4602         	mov	r2, r0
 800592a: 68fb         	ldr	r3, [r7, #0xc]
 800592c: 4413         	add	r3, r2
 800592e: 60fb         	str	r3, [r7, #0xc]
; 	return total;
 8005930: 68fb         	ldr	r3, [r7, #0xc]
; }
 8005932: 4618         	mov	r0, r3
 8005934: 3710         	adds	r7, #0x10
 8005936: 46bd         	mov	sp, r7
 8005938: bd80         	pop	{r7, pc}
 800593a: bf00         	nop

0800593c <$d>:
 800593c: 04 26 02 08  	.word	0x08022604
 8005940: c4 0a 02 08  	.word	0x08020ac4
 8005944: cc 0a 02 08  	.word	0x08020acc
 8005948: d0 0a 02 08  	.word	0x08020ad0
 800594c: d4 0a 02 08  	.word	0x08020ad4

08005950 <newline_print>:
; {
 8005950: b580         	push	{r7, lr}
 8005952: b082         	sub	sp, #0x8
 8005954: af00         	add	r7, sp, #0x0
 8005956: 6078         	str	r0, [r7, #0x4]
 8005958: 6039         	str	r1, [r7]
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 800595a: 683b         	ldr	r3, [r7]
 800595c: f003 0310    	and	r3, r3, #0x10
 8005960: 2b00         	cmp	r3, #0x0
 8005962: d10e         	bne	0x8005982 <newline_print+0x32> @ imm = #0x1c
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 8005964: 683b         	ldr	r3, [r7]
 8005966: f003 0320    	and	r3, r3, #0x20
 800596a: 2b00         	cmp	r3, #0x0
 800596c: d004         	beq	0x8005978 <newline_print+0x28> @ imm = #0x8
; 		print_formatted(ctx, "\n");
 800596e: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800598c <newline_print+0x3c>
 8005970: 6878         	ldr	r0, [r7, #0x4]
 8005972: f7ff fec1    	bl	0x80056f8 <print_formatted> @ imm = #-0x27e
 8005976: e005         	b	0x8005984 <newline_print+0x34> @ imm = #0xa
; 		print_formatted(ctx, "\r\n");
 8005978: 4905         	ldr	r1, [pc, #0x14]         @ 0x8005990 <newline_print+0x40>
 800597a: 6878         	ldr	r0, [r7, #0x4]
 800597c: f7ff febc    	bl	0x80056f8 <print_formatted> @ imm = #-0x288
 8005980: e000         	b	0x8005984 <newline_print+0x34> @ imm = #0x0
; 		return;
 8005982: bf00         	nop
; }
 8005984: 3708         	adds	r7, #0x8
 8005986: 46bd         	mov	sp, r7
 8005988: bd80         	pop	{r7, pc}
 800598a: bf00         	nop

0800598c <$d>:
 800598c: dc 0a 02 08  	.word	0x08020adc
 8005990: e0 0a 02 08  	.word	0x08020ae0

08005994 <hexdump_line_print>:
; {
 8005994: b580         	push	{r7, lr}
 8005996: b088         	sub	sp, #0x20
 8005998: af00         	add	r7, sp, #0x0
 800599a: 60f8         	str	r0, [r7, #0xc]
 800599c: 60b9         	str	r1, [r7, #0x8]
 800599e: 607a         	str	r2, [r7, #0x4]
 80059a0: 603b         	str	r3, [r7]
; 	newline_print(output, flags);
 80059a2: 6ab9         	ldr	r1, [r7, #0x28]
 80059a4: 68f8         	ldr	r0, [r7, #0xc]
 80059a6: f7ff ffd3    	bl	0x8005950 <newline_print> @ imm = #-0x5a
; 	for (int i = 0; i < prefix_offset; i++) {
 80059aa: 2300         	movs	r3, #0x0
 80059ac: 61fb         	str	r3, [r7, #0x1c]
 80059ae: e006         	b	0x80059be <hexdump_line_print+0x2a> @ imm = #0xc
; 		print_formatted(output, " ");
 80059b0: 4937         	ldr	r1, [pc, #0xdc]         @ 0x8005a90 <hexdump_line_print+0xfc>
 80059b2: 68f8         	ldr	r0, [r7, #0xc]
 80059b4: f7ff fea0    	bl	0x80056f8 <print_formatted> @ imm = #-0x2c0
; 	for (int i = 0; i < prefix_offset; i++) {
 80059b8: 69fb         	ldr	r3, [r7, #0x1c]
 80059ba: 3301         	adds	r3, #0x1
 80059bc: 61fb         	str	r3, [r7, #0x1c]
 80059be: 69fa         	ldr	r2, [r7, #0x1c]
 80059c0: 683b         	ldr	r3, [r7]
 80059c2: 429a         	cmp	r2, r3
 80059c4: dbf4         	blt	0x80059b0 <hexdump_line_print+0x1c> @ imm = #-0x18
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 80059c6: 2300         	movs	r3, #0x0
 80059c8: 61bb         	str	r3, [r7, #0x18]
 80059ca: e020         	b	0x8005a0e <hexdump_line_print+0x7a> @ imm = #0x40
; 		if (i > 0 && !(i % 8)) {
 80059cc: 69bb         	ldr	r3, [r7, #0x18]
 80059ce: 2b00         	cmp	r3, #0x0
 80059d0: dd08         	ble	0x80059e4 <hexdump_line_print+0x50> @ imm = #0x10
 80059d2: 69bb         	ldr	r3, [r7, #0x18]
 80059d4: f003 0307    	and	r3, r3, #0x7
 80059d8: 2b00         	cmp	r3, #0x0
 80059da: d103         	bne	0x80059e4 <hexdump_line_print+0x50> @ imm = #0x6
; 			print_formatted(output, " ");
 80059dc: 492c         	ldr	r1, [pc, #0xb0]         @ 0x8005a90 <hexdump_line_print+0xfc>
 80059de: 68f8         	ldr	r0, [r7, #0xc]
 80059e0: f7ff fe8a    	bl	0x80056f8 <print_formatted> @ imm = #-0x2ec
; 		if (i < length) {
 80059e4: 69bb         	ldr	r3, [r7, #0x18]
 80059e6: 687a         	ldr	r2, [r7, #0x4]
 80059e8: 429a         	cmp	r2, r3
 80059ea: d909         	bls	0x8005a00 <hexdump_line_print+0x6c> @ imm = #0x12
; 			print_formatted(output, "%02x ", data[i]);
 80059ec: 69bb         	ldr	r3, [r7, #0x18]
 80059ee: 68ba         	ldr	r2, [r7, #0x8]
 80059f0: 4413         	add	r3, r2
 80059f2: 781b         	ldrb	r3, [r3]
 80059f4: 461a         	mov	r2, r3
 80059f6: 4927         	ldr	r1, [pc, #0x9c]         @ 0x8005a94 <hexdump_line_print+0x100>
 80059f8: 68f8         	ldr	r0, [r7, #0xc]
 80059fa: f7ff fe7d    	bl	0x80056f8 <print_formatted> @ imm = #-0x306
 80059fe: e003         	b	0x8005a08 <hexdump_line_print+0x74> @ imm = #0x6
; 			print_formatted(output, "   ");
 8005a00: 4925         	ldr	r1, [pc, #0x94]         @ 0x8005a98 <hexdump_line_print+0x104>
 8005a02: 68f8         	ldr	r0, [r7, #0xc]
 8005a04: f7ff fe78    	bl	0x80056f8 <print_formatted> @ imm = #-0x310
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8005a08: 69bb         	ldr	r3, [r7, #0x18]
 8005a0a: 3301         	adds	r3, #0x1
 8005a0c: 61bb         	str	r3, [r7, #0x18]
 8005a0e: 69bb         	ldr	r3, [r7, #0x18]
 8005a10: 2b0f         	cmp	r3, #0xf
 8005a12: dddb         	ble	0x80059cc <hexdump_line_print+0x38> @ imm = #-0x4a
; 	print_formatted(output, "|");
 8005a14: 4921         	ldr	r1, [pc, #0x84]         @ 0x8005a9c <hexdump_line_print+0x108>
 8005a16: 68f8         	ldr	r0, [r7, #0xc]
 8005a18: f7ff fe6e    	bl	0x80056f8 <print_formatted> @ imm = #-0x324
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8005a1c: 2300         	movs	r3, #0x0
 8005a1e: 617b         	str	r3, [r7, #0x14]
 8005a20: e02d         	b	0x8005a7e <hexdump_line_print+0xea> @ imm = #0x5a
; 		if (i > 0 && !(i % 8)) {
 8005a22: 697b         	ldr	r3, [r7, #0x14]
 8005a24: 2b00         	cmp	r3, #0x0
 8005a26: dd08         	ble	0x8005a3a <hexdump_line_print+0xa6> @ imm = #0x10
 8005a28: 697b         	ldr	r3, [r7, #0x14]
 8005a2a: f003 0307    	and	r3, r3, #0x7
 8005a2e: 2b00         	cmp	r3, #0x0
 8005a30: d103         	bne	0x8005a3a <hexdump_line_print+0xa6> @ imm = #0x6
; 			print_formatted(output, " ");
 8005a32: 4917         	ldr	r1, [pc, #0x5c]         @ 0x8005a90 <hexdump_line_print+0xfc>
 8005a34: 68f8         	ldr	r0, [r7, #0xc]
 8005a36: f7ff fe5f    	bl	0x80056f8 <print_formatted> @ imm = #-0x342
; 		if (i < length) {
 8005a3a: 697b         	ldr	r3, [r7, #0x14]
 8005a3c: 687a         	ldr	r2, [r7, #0x4]
 8005a3e: 429a         	cmp	r2, r3
 8005a40: d916         	bls	0x8005a70 <hexdump_line_print+0xdc> @ imm = #0x2c
; 			unsigned char c = (unsigned char)data[i];
 8005a42: 697b         	ldr	r3, [r7, #0x14]
 8005a44: 68ba         	ldr	r2, [r7, #0x8]
 8005a46: 4413         	add	r3, r2
 8005a48: 781b         	ldrb	r3, [r3]
 8005a4a: 74fb         	strb	r3, [r7, #0x13]
; 			      isprint((int)c) != 0 ? c : '.');
 8005a4c: 7cfb         	ldrb	r3, [r7, #0x13]
 8005a4e: 4618         	mov	r0, r3
 8005a50: f7ff fe40    	bl	0x80056d4 <__ctype_lookup> @ imm = #-0x380
 8005a54: 4603         	mov	r3, r0
 8005a56: f003 0397    	and	r3, r3, #0x97
; 			print_formatted(output, "%c",
 8005a5a: 2b00         	cmp	r3, #0x0
 8005a5c: d001         	beq	0x8005a62 <hexdump_line_print+0xce> @ imm = #0x2
 8005a5e: 7cfb         	ldrb	r3, [r7, #0x13]
 8005a60: e000         	b	0x8005a64 <hexdump_line_print+0xd0> @ imm = #0x0
 8005a62: 232e         	movs	r3, #0x2e
 8005a64: 461a         	mov	r2, r3
 8005a66: 490e         	ldr	r1, [pc, #0x38]         @ 0x8005aa0 <hexdump_line_print+0x10c>
 8005a68: 68f8         	ldr	r0, [r7, #0xc]
 8005a6a: f7ff fe45    	bl	0x80056f8 <print_formatted> @ imm = #-0x376
 8005a6e: e003         	b	0x8005a78 <hexdump_line_print+0xe4> @ imm = #0x6
; 			print_formatted(output, " ");
 8005a70: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8005a90 <hexdump_line_print+0xfc>
 8005a72: 68f8         	ldr	r0, [r7, #0xc]
 8005a74: f7ff fe40    	bl	0x80056f8 <print_formatted> @ imm = #-0x380
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8005a78: 697b         	ldr	r3, [r7, #0x14]
 8005a7a: 3301         	adds	r3, #0x1
 8005a7c: 617b         	str	r3, [r7, #0x14]
 8005a7e: 697b         	ldr	r3, [r7, #0x14]
 8005a80: 2b0f         	cmp	r3, #0xf
 8005a82: ddce         	ble	0x8005a22 <hexdump_line_print+0x8e> @ imm = #-0x64
; }
 8005a84: bf00         	nop
 8005a86: bf00         	nop
 8005a88: 3720         	adds	r7, #0x20
 8005a8a: 46bd         	mov	sp, r7
 8005a8c: bd80         	pop	{r7, pc}
 8005a8e: bf00         	nop

08005a90 <$d>:
 8005a90: e4 0a 02 08  	.word	0x08020ae4
 8005a94: e8 0a 02 08  	.word	0x08020ae8
 8005a98: f0 0a 02 08  	.word	0x08020af0
 8005a9c: f4 0a 02 08  	.word	0x08020af4
 8005aa0: f8 0a 02 08  	.word	0x08020af8

08005aa4 <prefix_print>:
; {
 8005aa4: b590         	push	{r4, r7, lr}
 8005aa6: b08d         	sub	sp, #0x34
 8005aa8: af04         	add	r7, sp, #0x10
 8005aaa: 60f8         	str	r0, [r7, #0xc]
 8005aac: 60b9         	str	r1, [r7, #0x8]
 8005aae: 603b         	str	r3, [r7]
 8005ab0: 4613         	mov	r3, r2
 8005ab2: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t length = 0U;
 8005ab4: 2300         	movs	r3, #0x0
 8005ab6: 61fb         	str	r3, [r7, #0x1c]
; 	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
 8005ab8: 68bb         	ldr	r3, [r7, #0x8]
 8005aba: f003 0302    	and	r3, r3, #0x2
 8005abe: 2b00         	cmp	r3, #0x0
 8005ac0: bf14         	ite	ne
 8005ac2: 2301         	movne	r3, #0x1
 8005ac4: 2300         	moveq	r3, #0x0
 8005ac6: 76fb         	strb	r3, [r7, #0x1b]
; 	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
 8005ac8: 68bb         	ldr	r3, [r7, #0x8]
 8005aca: f003 0301    	and	r3, r3, #0x1
 8005ace: 2b00         	cmp	r3, #0x0
 8005ad0: bf14         	ite	ne
 8005ad2: 2301         	movne	r3, #0x1
 8005ad4: 2300         	moveq	r3, #0x0
 8005ad6: 76bb         	strb	r3, [r7, #0x1a]
; 	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
 8005ad8: 68bb         	ldr	r3, [r7, #0x8]
 8005ada: f003 0308    	and	r3, r3, #0x8
 8005ade: 2b00         	cmp	r3, #0x0
 8005ae0: bf14         	ite	ne
 8005ae2: 2301         	movne	r3, #0x1
 8005ae4: 2300         	moveq	r3, #0x0
 8005ae6: 767b         	strb	r3, [r7, #0x19]
; 	bool thread_on = IS_ENABLED(CONFIG_LOG_THREAD_ID_PREFIX) &&
 8005ae8: 2300         	movs	r3, #0x0
 8005aea: 74fb         	strb	r3, [r7, #0x13]
; 	bool source_off = flags & LOG_OUTPUT_FLAG_SKIP_SOURCE;
 8005aec: 68bb         	ldr	r3, [r7, #0x8]
 8005aee: f403 7380    	and	r3, r3, #0x100
 8005af2: 2b00         	cmp	r3, #0x0
 8005af4: bf14         	ite	ne
 8005af6: 2301         	movne	r3, #0x1
 8005af8: 2300         	moveq	r3, #0x0
 8005afa: 763b         	strb	r3, [r7, #0x18]
; 	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
 8005afc: f011 f8ab    	bl	0x8016c56 <z_log_get_tag> @ imm = #0x11156
 8005b00: 6178         	str	r0, [r7, #0x14]
; 	if (tag) {
 8005b02: 697b         	ldr	r3, [r7, #0x14]
 8005b04: 2b00         	cmp	r3, #0x0
 8005b06: d009         	beq	0x8005b1c <prefix_print+0x78> @ imm = #0x12
; 		length += print_formatted(output, "%s ", tag);
 8005b08: 697a         	ldr	r2, [r7, #0x14]
 8005b0a: 491e         	ldr	r1, [pc, #0x78]         @ 0x8005b84 <prefix_print+0xe0>
 8005b0c: 68f8         	ldr	r0, [r7, #0xc]
 8005b0e: f7ff fdf3    	bl	0x80056f8 <print_formatted> @ imm = #-0x41a
 8005b12: 4603         	mov	r3, r0
 8005b14: 461a         	mov	r2, r3
 8005b16: 69fb         	ldr	r3, [r7, #0x1c]
 8005b18: 4413         	add	r3, r2
 8005b1a: 61fb         	str	r3, [r7, #0x1c]
; 	if (stamp) {
 8005b1c: 7efb         	ldrb	r3, [r7, #0x1b]
 8005b1e: 2b00         	cmp	r3, #0x0
 8005b20: d009         	beq	0x8005b36 <prefix_print+0x92> @ imm = #0x12
; 		length += timestamp_print(output, flags, timestamp);
 8005b22: 683a         	ldr	r2, [r7]
 8005b24: 68b9         	ldr	r1, [r7, #0x8]
 8005b26: 68f8         	ldr	r0, [r7, #0xc]
 8005b28: f7ff fe02    	bl	0x8005730 <timestamp_print> @ imm = #-0x3fc
 8005b2c: 4603         	mov	r3, r0
 8005b2e: 461a         	mov	r2, r3
 8005b30: 69fb         	ldr	r3, [r7, #0x1c]
 8005b32: 4413         	add	r3, r2
 8005b34: 61fb         	str	r3, [r7, #0x1c]
; 		color_prefix(output, colors_on, level);
 8005b36: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 8005b3a: 7ebb         	ldrb	r3, [r7, #0x1a]
 8005b3c: 4619         	mov	r1, r3
 8005b3e: 68f8         	ldr	r0, [r7, #0xc]
 8005b40: f011 fc71    	bl	0x8017426 <color_prefix> @ imm = #0x118e2
; 	length += ids_print(output, level_on, func_on, thread_on, domain,
 8005b44: 7cfc         	ldrb	r4, [r7, #0x13]
 8005b46: 7e3b         	ldrb	r3, [r7, #0x18]
 8005b48: 2b00         	cmp	r3, #0x0
 8005b4a: d001         	beq	0x8005b50 <prefix_print+0xac> @ imm = #0x2
 8005b4c: 2300         	movs	r3, #0x0
 8005b4e: e000         	b	0x8005b52 <prefix_print+0xae> @ imm = #0x0
 8005b50: 6b7b         	ldr	r3, [r7, #0x34]
 8005b52: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 8005b56: 79f8         	ldrb	r0, [r7, #0x7]
 8005b58: 7e79         	ldrb	r1, [r7, #0x19]
 8005b5a: 9203         	str	r2, [sp, #0xc]
 8005b5c: 6bba         	ldr	r2, [r7, #0x38]
 8005b5e: 9202         	str	r2, [sp, #0x8]
 8005b60: 9301         	str	r3, [sp, #0x4]
 8005b62: 6b3b         	ldr	r3, [r7, #0x30]
 8005b64: 9300         	str	r3, [sp]
 8005b66: 4623         	mov	r3, r4
 8005b68: 4602         	mov	r2, r0
 8005b6a: 68f8         	ldr	r0, [r7, #0xc]
 8005b6c: f7ff fea0    	bl	0x80058b0 <ids_print>   @ imm = #-0x2c0
 8005b70: 4603         	mov	r3, r0
 8005b72: 461a         	mov	r2, r3
 8005b74: 69fb         	ldr	r3, [r7, #0x1c]
 8005b76: 4413         	add	r3, r2
 8005b78: 61fb         	str	r3, [r7, #0x1c]
; 	return length;
 8005b7a: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8005b7c: 4618         	mov	r0, r3
 8005b7e: 3724         	adds	r7, #0x24
 8005b80: 46bd         	mov	sp, r7
 8005b82: bd90         	pop	{r4, r7, pc}

08005b84 <$d>:
 8005b84: 04 0b 02 08  	.word	0x08020b04

08005b88 <log_output_process>:
; {
 8005b88: b580         	push	{r7, lr}
 8005b8a: b08c         	sub	sp, #0x30
 8005b8c: af04         	add	r7, sp, #0x10
 8005b8e: 60f8         	str	r0, [r7, #0xc]
 8005b90: 60b9         	str	r1, [r7, #0x8]
 8005b92: 607a         	str	r2, [r7, #0x4]
 8005b94: 603b         	str	r3, [r7]
; 	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
 8005b96: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8005b9a: 2b00         	cmp	r3, #0x0
 8005b9c: bf0c         	ite	eq
 8005b9e: 2301         	moveq	r3, #0x1
 8005ba0: 2300         	movne	r3, #0x0
 8005ba2: 75fb         	strb	r3, [r7, #0x17]
; 	if (!raw_string) {
 8005ba4: 7dfb         	ldrb	r3, [r7, #0x17]
 8005ba6: f083 0301    	eor	r3, r3, #0x1
 8005baa: b2db         	uxtb	r3, r3
 8005bac: 2b00         	cmp	r3, #0x0
 8005bae: d012         	beq	0x8005bd6 <log_output_process+0x4e> @ imm = #0x24
; 		prefix_offset = prefix_print(output, flags, 0, timestamp,
 8005bb0: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8005bb4: 9303         	str	r3, [sp, #0xc]
 8005bb6: 6abb         	ldr	r3, [r7, #0x28]
 8005bb8: 9302         	str	r3, [sp, #0x8]
 8005bba: 683b         	ldr	r3, [r7]
 8005bbc: 9301         	str	r3, [sp, #0x4]
 8005bbe: 687b         	ldr	r3, [r7, #0x4]
 8005bc0: 9300         	str	r3, [sp]
 8005bc2: 68bb         	ldr	r3, [r7, #0x8]
 8005bc4: 2200         	movs	r2, #0x0
 8005bc6: 6bf9         	ldr	r1, [r7, #0x3c]
 8005bc8: 68f8         	ldr	r0, [r7, #0xc]
 8005bca: f7ff ff6b    	bl	0x8005aa4 <prefix_print> @ imm = #-0x12a
 8005bce: 61f8         	str	r0, [r7, #0x1c]
; 		cb = out_func;
 8005bd0: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8005c3c <log_output_process+0xb4>
 8005bd2: 61bb         	str	r3, [r7, #0x18]
 8005bd4: e008         	b	0x8005be8 <log_output_process+0x60> @ imm = #0x10
; 		prefix_offset = 0;
 8005bd6: 2300         	movs	r3, #0x0
 8005bd8: 61fb         	str	r3, [r7, #0x1c]
; 		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
 8005bda: 683b         	ldr	r3, [r7]
 8005bdc: 2b01         	cmp	r3, #0x1
 8005bde: d101         	bne	0x8005be4 <log_output_process+0x5c> @ imm = #0x2
 8005be0: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8005c3c <log_output_process+0xb4>
 8005be2: e000         	b	0x8005be6 <log_output_process+0x5e> @ imm = #0x0
 8005be4: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8005c40 <log_output_process+0xb8>
 8005be6: 61bb         	str	r3, [r7, #0x18]
; 	if (package) {
 8005be8: 6b3b         	ldr	r3, [r7, #0x30]
 8005bea: 2b00         	cmp	r3, #0x0
 8005bec: d005         	beq	0x8005bfa <log_output_process+0x72> @ imm = #0xa
; 		int err = cbpprintf(cb, (void *)output, (void *)package);
 8005bee: 6b3a         	ldr	r2, [r7, #0x30]
 8005bf0: 68f9         	ldr	r1, [r7, #0xc]
 8005bf2: 69b8         	ldr	r0, [r7, #0x18]
 8005bf4: f7ff fd5a    	bl	0x80056ac <cbpprintf>   @ imm = #-0x54c
 8005bf8: 6138         	str	r0, [r7, #0x10]
; 	if (data_len) {
 8005bfa: 6bbb         	ldr	r3, [r7, #0x38]
 8005bfc: 2b00         	cmp	r3, #0x0
 8005bfe: d008         	beq	0x8005c12 <log_output_process+0x8a> @ imm = #0x10
; 		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
 8005c00: 69fa         	ldr	r2, [r7, #0x1c]
 8005c02: 6bfb         	ldr	r3, [r7, #0x3c]
 8005c04: 9300         	str	r3, [sp]
 8005c06: 4613         	mov	r3, r2
 8005c08: 6bba         	ldr	r2, [r7, #0x38]
 8005c0a: 6b79         	ldr	r1, [r7, #0x34]
 8005c0c: 68f8         	ldr	r0, [r7, #0xc]
 8005c0e: f011 fc2c    	bl	0x801746a <log_msg_hexdump> @ imm = #0x11858
; 	if (!raw_string) {
 8005c12: 7dfb         	ldrb	r3, [r7, #0x17]
 8005c14: f083 0301    	eor	r3, r3, #0x1
 8005c18: b2db         	uxtb	r3, r3
 8005c1a: 2b00         	cmp	r3, #0x0
 8005c1c: d006         	beq	0x8005c2c <log_output_process+0xa4> @ imm = #0xc
; 		postfix_print(output, flags, level);
 8005c1e: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8005c22: 461a         	mov	r2, r3
 8005c24: 6bf9         	ldr	r1, [r7, #0x3c]
 8005c26: 68f8         	ldr	r0, [r7, #0xc]
 8005c28: f011 fc43    	bl	0x80174b2 <postfix_print> @ imm = #0x11886
; 	log_output_flush(output);
 8005c2c: 68f8         	ldr	r0, [r7, #0xc]
 8005c2e: f011 fbb4    	bl	0x801739a <log_output_flush> @ imm = #0x11768
; }
 8005c32: bf00         	nop
 8005c34: 3720         	adds	r7, #0x20
 8005c36: 46bd         	mov	sp, r7
 8005c38: bd80         	pop	{r7, pc}
 8005c3a: bf00         	nop

08005c3c <$d>:
 8005c3c: cd 73 01 08  	.word	0x080173cd
 8005c40: fd 73 01 08  	.word	0x080173fd

08005c44 <log_output_timestamp_freq_set>:
; {
 8005c44: b480         	push	{r7}
 8005c46: b083         	sub	sp, #0xc
 8005c48: af00         	add	r7, sp, #0x0
 8005c4a: 6078         	str	r0, [r7, #0x4]
; 	timestamp_div = 1U;
 8005c4c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8005c80 <log_output_timestamp_freq_set+0x3c>
 8005c4e: 2201         	movs	r2, #0x1
 8005c50: 601a         	str	r2, [r3]
; 	while (frequency > 1000000) {
 8005c52: e007         	b	0x8005c64 <log_output_timestamp_freq_set+0x20> @ imm = #0xe
; 		frequency /= 2U;
 8005c54: 687b         	ldr	r3, [r7, #0x4]
 8005c56: 085b         	lsrs	r3, r3, #0x1
 8005c58: 607b         	str	r3, [r7, #0x4]
; 		timestamp_div *= 2U;
 8005c5a: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8005c80 <log_output_timestamp_freq_set+0x3c>
 8005c5c: 681b         	ldr	r3, [r3]
 8005c5e: 005b         	lsls	r3, r3, #0x1
 8005c60: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8005c80 <log_output_timestamp_freq_set+0x3c>
 8005c62: 6013         	str	r3, [r2]
; 	while (frequency > 1000000) {
 8005c64: 687b         	ldr	r3, [r7, #0x4]
 8005c66: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8005c84 <log_output_timestamp_freq_set+0x40>
 8005c68: 4293         	cmp	r3, r2
 8005c6a: d8f3         	bhi	0x8005c54 <log_output_timestamp_freq_set+0x10> @ imm = #-0x1a
; 	freq = frequency;
 8005c6c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8005c88 <log_output_timestamp_freq_set+0x44>
 8005c6e: 687b         	ldr	r3, [r7, #0x4]
 8005c70: 6013         	str	r3, [r2]
; }
 8005c72: bf00         	nop
 8005c74: 370c         	adds	r7, #0xc
 8005c76: 46bd         	mov	sp, r7
 8005c78: f85d 7b04    	ldr	r7, [sp], #4
 8005c7c: 4770         	bx	lr
 8005c7e: bf00         	nop

08005c80 <$d>:
 8005c80: 84 24 00 20  	.word	0x20002484
 8005c84: 40 42 0f 00  	.word	0x000f4240
 8005c88: 80 24 00 20  	.word	0x20002480

08005c8c <char_out>:
; {
 8005c8c: b580         	push	{r7, lr}
 8005c8e: b088         	sub	sp, #0x20
 8005c90: af00         	add	r7, sp, #0x0
 8005c92: 60f8         	str	r0, [r7, #0xc]
 8005c94: 60b9         	str	r1, [r7, #0x8]
 8005c96: 607a         	str	r2, [r7, #0x4]
; 	const struct lbu_cb_ctx *cb_ctx = ctx;
 8005c98: 687b         	ldr	r3, [r7, #0x4]
 8005c9a: 61bb         	str	r3, [r7, #0x18]
; 	struct lbu_data *lb_data = cb_ctx->data;
 8005c9c: 69bb         	ldr	r3, [r7, #0x18]
 8005c9e: 685b         	ldr	r3, [r3, #0x4]
 8005ca0: 617b         	str	r3, [r7, #0x14]
; 	const struct device *uart_dev = LBU_UART_DEV(cb_ctx);
 8005ca2: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8005cf8 <char_out+0x6c>
 8005ca4: 613b         	str	r3, [r7, #0x10]
; 	if (pm_device_runtime_get(uart_dev) < 0) {
 8005ca6: 6938         	ldr	r0, [r7, #0x10]
 8005ca8: f011 fcfd    	bl	0x80176a6 <pm_device_runtime_get> @ imm = #0x119fa
 8005cac: 4603         	mov	r3, r0
 8005cae: 2b00         	cmp	r3, #0x0
 8005cb0: da01         	bge	0x8005cb6 <char_out+0x2a> @ imm = #0x2
; 		return length;
 8005cb2: 68b9         	ldr	r1, [r7, #0x8]
 8005cb4: e01a         	b	0x8005cec <char_out+0x60> @ imm = #0x34
; 		for (size_t i = 0; i < length; i++) {
 8005cb6: 2300         	movs	r3, #0x0
 8005cb8: 61fb         	str	r3, [r7, #0x1c]
 8005cba: e00a         	b	0x8005cd2 <char_out+0x46> @ imm = #0x14
; 			uart_poll_out(uart_dev, data[i]);
 8005cbc: 68fa         	ldr	r2, [r7, #0xc]
 8005cbe: 69fb         	ldr	r3, [r7, #0x1c]
 8005cc0: 4413         	add	r3, r2
 8005cc2: 781b         	ldrb	r3, [r3]
 8005cc4: 4619         	mov	r1, r3
 8005cc6: 6938         	ldr	r0, [r7, #0x10]
 8005cc8: f011 fcde    	bl	0x8017688 <uart_poll_out> @ imm = #0x119bc
; 		for (size_t i = 0; i < length; i++) {
 8005ccc: 69fb         	ldr	r3, [r7, #0x1c]
 8005cce: 3301         	adds	r3, #0x1
 8005cd0: 61fb         	str	r3, [r7, #0x1c]
 8005cd2: 69fa         	ldr	r2, [r7, #0x1c]
 8005cd4: 68bb         	ldr	r3, [r7, #0x8]
 8005cd6: 429a         	cmp	r2, r3
 8005cd8: d3f0         	blo	0x8005cbc <char_out+0x30> @ imm = #-0x20
; 		goto cleanup;
 8005cda: bf00         	nop
; 	(void)pm_device_runtime_put_async(uart_dev, K_MSEC(1));
 8005cdc: f04f 020a    	mov.w	r2, #0xa
 8005ce0: f04f 0300    	mov.w	r3, #0x0
 8005ce4: 6938         	ldr	r0, [r7, #0x10]
 8005ce6: f011 fce9    	bl	0x80176bc <pm_device_runtime_put_async> @ imm = #0x119d2
; 	return length;
 8005cea: 68b9         	ldr	r1, [r7, #0x8]
; }
 8005cec: 460b         	mov	r3, r1
 8005cee: 4618         	mov	r0, r3
 8005cf0: 3720         	adds	r7, #0x20
 8005cf2: 46bd         	mov	sp, r7
 8005cf4: bd80         	pop	{r7, pc}
 8005cf6: bf00         	nop

08005cf8 <$d>:
 8005cf8: 98 02 02 08  	.word	0x08020298

08005cfc <log_backend_uart_init>:
; {
 8005cfc: b580         	push	{r7, lr}
 8005cfe: b086         	sub	sp, #0x18
 8005d00: af00         	add	r7, sp, #0x0
 8005d02: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8005d04: 687b         	ldr	r3, [r7, #0x4]
 8005d06: 685b         	ldr	r3, [r3, #0x4]
 8005d08: 681b         	ldr	r3, [r3]
 8005d0a: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 8005d0c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005d28 <log_backend_uart_init+0x2c>
 8005d0e: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 8005d10: 693b         	ldr	r3, [r7, #0x10]
 8005d12: 685b         	ldr	r3, [r3, #0x4]
 8005d14: 617b         	str	r3, [r7, #0x14]
; 	log_output_ctx_set(ctx->output, (void *)ctx);
 8005d16: 693b         	ldr	r3, [r7, #0x10]
 8005d18: 681b         	ldr	r3, [r3]
 8005d1a: 6939         	ldr	r1, [r7, #0x10]
 8005d1c: 4618         	mov	r0, r3
 8005d1e: f011 fc72    	bl	0x8017606 <log_output_ctx_set> @ imm = #0x118e4
; }
 8005d22: 3718         	adds	r7, #0x18
 8005d24: 46bd         	mov	sp, r7
 8005d26: bd80         	pop	{r7, pc}

08005d28 <$d>:
 8005d28: 98 02 02 08  	.word	0x08020298

08005d2c <panic>:
; {
 8005d2c: b580         	push	{r7, lr}
 8005d2e: b086         	sub	sp, #0x18
 8005d30: af00         	add	r7, sp, #0x0
 8005d32: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8005d34: 687b         	ldr	r3, [r7, #0x4]
 8005d36: 685b         	ldr	r3, [r3, #0x4]
 8005d38: 681b         	ldr	r3, [r3]
 8005d3a: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 8005d3c: 697b         	ldr	r3, [r7, #0x14]
 8005d3e: 685b         	ldr	r3, [r3, #0x4]
 8005d40: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 8005d42: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8005d60 <panic+0x34>
 8005d44: 60fb         	str	r3, [r7, #0xc]
; 	data->in_panic = true;
 8005d46: 693b         	ldr	r3, [r7, #0x10]
 8005d48: 2201         	movs	r2, #0x1
 8005d4a: 751a         	strb	r2, [r3, #0x14]
; 	log_backend_std_panic(ctx->output);
 8005d4c: 697b         	ldr	r3, [r7, #0x14]
 8005d4e: 681b         	ldr	r3, [r3]
 8005d50: 4618         	mov	r0, r3
 8005d52: f011 fc7b    	bl	0x801764c <log_backend_std_panic> @ imm = #0x118f6
; }
 8005d56: bf00         	nop
 8005d58: 3718         	adds	r7, #0x18
 8005d5a: 46bd         	mov	sp, r7
 8005d5c: bd80         	pop	{r7, pc}
 8005d5e: bf00         	nop

08005d60 <$d>:
 8005d60: 98 02 02 08  	.word	0x08020298

08005d64 <esf_dump>:
; {
 8005d64: b5f0         	push	{r4, r5, r6, r7, lr}
 8005d66: b09d         	sub	sp, #0x74
 8005d68: af0c         	add	r7, sp, #0x30
 8005d6a: 6078         	str	r0, [r7, #0x4]
; 	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
 8005d6c: 2303         	movs	r3, #0x3
 8005d6e: 2b00         	cmp	r3, #0x0
 8005d70: d020         	beq	0x8005db4 <esf_dump+0x50> @ imm = #0x40
 8005d72: 2301         	movs	r3, #0x1
 8005d74: 77fb         	strb	r3, [r7, #0x1f]
 8005d76: 7ffb         	ldrb	r3, [r7, #0x1f]
 8005d78: f083 0301    	eor	r3, r3, #0x1
 8005d7c: b2db         	uxtb	r3, r3
 8005d7e: 2b00         	cmp	r3, #0x0
 8005d80: d118         	bne	0x8005db4 <esf_dump+0x50> @ imm = #0x30
 8005d82: 4b76         	ldr	r3, [pc, #0x1d8]        @ 0x8005f5c <esf_dump+0x1f8>
 8005d84: 6818         	ldr	r0, [r3]
 8005d86: 687b         	ldr	r3, [r7, #0x4]
 8005d88: 681b         	ldr	r3, [r3]
 8005d8a: 687a         	ldr	r2, [r7, #0x4]
 8005d8c: 6852         	ldr	r2, [r2, #0x4]
 8005d8e: 6879         	ldr	r1, [r7, #0x4]
 8005d90: 6889         	ldr	r1, [r1, #0x8]
 8005d92: 9105         	str	r1, [sp, #0x14]
 8005d94: 9204         	str	r2, [sp, #0x10]
 8005d96: 9303         	str	r3, [sp, #0xc]
 8005d98: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8005f60 <esf_dump+0x1fc>
 8005d9a: 9302         	str	r3, [sp, #0x8]
 8005d9c: 2300         	movs	r3, #0x0
 8005d9e: 9301         	str	r3, [sp, #0x4]
 8005da0: 2300         	movs	r3, #0x0
 8005da2: 9300         	str	r3, [sp]
 8005da4: 2300         	movs	r3, #0x0
 8005da6: 2201         	movs	r2, #0x1
 8005da8: 4601         	mov	r1, r0
 8005daa: 2000         	movs	r0, #0x0
 8005dac: f011 fcc8    	bl	0x8017740 <z_log_msg_runtime_create> @ imm = #0x11990
 8005db0: 2300         	movs	r3, #0x0
 8005db2: 61bb         	str	r3, [r7, #0x18]
; 	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
 8005db4: 2303         	movs	r3, #0x3
 8005db6: 2b00         	cmp	r3, #0x0
 8005db8: d020         	beq	0x8005dfc <esf_dump+0x98> @ imm = #0x40
 8005dba: 2301         	movs	r3, #0x1
 8005dbc: 75fb         	strb	r3, [r7, #0x17]
 8005dbe: 7dfb         	ldrb	r3, [r7, #0x17]
 8005dc0: f083 0301    	eor	r3, r3, #0x1
 8005dc4: b2db         	uxtb	r3, r3
 8005dc6: 2b00         	cmp	r3, #0x0
 8005dc8: d118         	bne	0x8005dfc <esf_dump+0x98> @ imm = #0x30
 8005dca: 4b64         	ldr	r3, [pc, #0x190]        @ 0x8005f5c <esf_dump+0x1f8>
 8005dcc: 6818         	ldr	r0, [r3]
 8005dce: 687b         	ldr	r3, [r7, #0x4]
 8005dd0: 68db         	ldr	r3, [r3, #0xc]
 8005dd2: 687a         	ldr	r2, [r7, #0x4]
 8005dd4: 6912         	ldr	r2, [r2, #0x10]
 8005dd6: 6879         	ldr	r1, [r7, #0x4]
 8005dd8: 6949         	ldr	r1, [r1, #0x14]
 8005dda: 9105         	str	r1, [sp, #0x14]
 8005ddc: 9204         	str	r2, [sp, #0x10]
 8005dde: 9303         	str	r3, [sp, #0xc]
 8005de0: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8005f64 <esf_dump+0x200>
 8005de2: 9302         	str	r3, [sp, #0x8]
 8005de4: 2300         	movs	r3, #0x0
 8005de6: 9301         	str	r3, [sp, #0x4]
 8005de8: 2300         	movs	r3, #0x0
 8005dea: 9300         	str	r3, [sp]
 8005dec: 2300         	movs	r3, #0x0
 8005dee: 2201         	movs	r2, #0x1
 8005df0: 4601         	mov	r1, r0
 8005df2: 2000         	movs	r0, #0x0
 8005df4: f011 fca4    	bl	0x8017740 <z_log_msg_runtime_create> @ imm = #0x11948
 8005df8: 2300         	movs	r3, #0x0
 8005dfa: 613b         	str	r3, [r7, #0x10]
; 	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
 8005dfc: 2303         	movs	r3, #0x3
 8005dfe: 2b00         	cmp	r3, #0x0
 8005e00: d019         	beq	0x8005e36 <esf_dump+0xd2> @ imm = #0x32
 8005e02: 2301         	movs	r3, #0x1
 8005e04: 73fb         	strb	r3, [r7, #0xf]
 8005e06: 7bfb         	ldrb	r3, [r7, #0xf]
 8005e08: f083 0301    	eor	r3, r3, #0x1
 8005e0c: b2db         	uxtb	r3, r3
 8005e0e: 2b00         	cmp	r3, #0x0
 8005e10: d111         	bne	0x8005e36 <esf_dump+0xd2> @ imm = #0x22
 8005e12: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8005f5c <esf_dump+0x1f8>
 8005e14: 6819         	ldr	r1, [r3]
 8005e16: 687b         	ldr	r3, [r7, #0x4]
 8005e18: 69db         	ldr	r3, [r3, #0x1c]
 8005e1a: 9303         	str	r3, [sp, #0xc]
 8005e1c: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8005f68 <esf_dump+0x204>
 8005e1e: 9302         	str	r3, [sp, #0x8]
 8005e20: 2300         	movs	r3, #0x0
 8005e22: 9301         	str	r3, [sp, #0x4]
 8005e24: 2300         	movs	r3, #0x0
 8005e26: 9300         	str	r3, [sp]
 8005e28: 2300         	movs	r3, #0x0
 8005e2a: 2201         	movs	r2, #0x1
 8005e2c: 2000         	movs	r0, #0x0
 8005e2e: f011 fc87    	bl	0x8017740 <z_log_msg_runtime_create> @ imm = #0x1190e
 8005e32: 2300         	movs	r3, #0x0
 8005e34: 63fb         	str	r3, [r7, #0x3c]
; 	for (int i = 0; i < ARRAY_SIZE(esf->fpu.s); i += 4) {
 8005e36: 2300         	movs	r3, #0x0
 8005e38: 63bb         	str	r3, [r7, #0x38]
 8005e3a: e048         	b	0x8005ece <esf_dump+0x16a> @ imm = #0x90
; 		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
 8005e3c: 2303         	movs	r3, #0x3
 8005e3e: 2b00         	cmp	r3, #0x0
 8005e40: d042         	beq	0x8005ec8 <esf_dump+0x164> @ imm = #0x84
 8005e42: 2301         	movs	r3, #0x1
 8005e44: f887 3027    	strb.w	r3, [r7, #0x27]
 8005e48: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8005e4c: f083 0301    	eor	r3, r3, #0x1
 8005e50: b2db         	uxtb	r3, r3
 8005e52: 2b00         	cmp	r3, #0x0
 8005e54: d138         	bne	0x8005ec8 <esf_dump+0x164> @ imm = #0x70
 8005e56: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8005f5c <esf_dump+0x1f8>
 8005e58: 681b         	ldr	r3, [r3]
 8005e5a: 603b         	str	r3, [r7]
 8005e5c: 687b         	ldr	r3, [r7, #0x4]
 8005e5e: 6bba         	ldr	r2, [r7, #0x38]
 8005e60: 3208         	adds	r2, #0x8
 8005e62: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8005e66: 6bba         	ldr	r2, [r7, #0x38]
 8005e68: 3201         	adds	r2, #0x1
 8005e6a: 6bb9         	ldr	r1, [r7, #0x38]
 8005e6c: 1c48         	adds	r0, r1, #0x1
 8005e6e: 6879         	ldr	r1, [r7, #0x4]
 8005e70: 3008         	adds	r0, #0x8
 8005e72: f851 1020    	ldr.w	r1, [r1, r0, lsl #2]
 8005e76: 6bb8         	ldr	r0, [r7, #0x38]
 8005e78: 3002         	adds	r0, #0x2
 8005e7a: 6bbc         	ldr	r4, [r7, #0x38]
 8005e7c: 1ca5         	adds	r5, r4, #0x2
 8005e7e: 687c         	ldr	r4, [r7, #0x4]
 8005e80: 3508         	adds	r5, #0x8
 8005e82: f854 4025    	ldr.w	r4, [r4, r5, lsl #2]
 8005e86: 6bbd         	ldr	r5, [r7, #0x38]
 8005e88: 3503         	adds	r5, #0x3
 8005e8a: 6bbe         	ldr	r6, [r7, #0x38]
 8005e8c: f106 0c03    	add.w	r12, r6, #0x3
 8005e90: 687e         	ldr	r6, [r7, #0x4]
 8005e92: f10c 0c08    	add.w	r12, r12, #0x8
 8005e96: f856 602c    	ldr.w	r6, [r6, r12, lsl #2]
 8005e9a: 960a         	str	r6, [sp, #0x28]
 8005e9c: 9509         	str	r5, [sp, #0x24]
 8005e9e: 9408         	str	r4, [sp, #0x20]
 8005ea0: 9007         	str	r0, [sp, #0x1c]
 8005ea2: 9106         	str	r1, [sp, #0x18]
 8005ea4: 9205         	str	r2, [sp, #0x14]
 8005ea6: 9304         	str	r3, [sp, #0x10]
 8005ea8: 6bbb         	ldr	r3, [r7, #0x38]
 8005eaa: 9303         	str	r3, [sp, #0xc]
 8005eac: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8005f6c <esf_dump+0x208>
 8005eae: 9302         	str	r3, [sp, #0x8]
 8005eb0: 2300         	movs	r3, #0x0
 8005eb2: 9301         	str	r3, [sp, #0x4]
 8005eb4: 2300         	movs	r3, #0x0
 8005eb6: 9300         	str	r3, [sp]
 8005eb8: 2300         	movs	r3, #0x0
 8005eba: 2201         	movs	r2, #0x1
 8005ebc: 6839         	ldr	r1, [r7]
 8005ebe: 2000         	movs	r0, #0x0
 8005ec0: f011 fc3e    	bl	0x8017740 <z_log_msg_runtime_create> @ imm = #0x1187c
 8005ec4: 2300         	movs	r3, #0x0
 8005ec6: 623b         	str	r3, [r7, #0x20]
; 	for (int i = 0; i < ARRAY_SIZE(esf->fpu.s); i += 4) {
 8005ec8: 6bbb         	ldr	r3, [r7, #0x38]
 8005eca: 3304         	adds	r3, #0x4
 8005ecc: 63bb         	str	r3, [r7, #0x38]
 8005ece: 6bbb         	ldr	r3, [r7, #0x38]
 8005ed0: 2b0f         	cmp	r3, #0xf
 8005ed2: d9b3         	bls	0x8005e3c <esf_dump+0xd8> @ imm = #-0x9a
; 	LOG_ERR("fpscr:  0x%08x", esf->fpu.fpscr);
 8005ed4: 2303         	movs	r3, #0x3
 8005ed6: 2b00         	cmp	r3, #0x0
 8005ed8: d01b         	beq	0x8005f12 <esf_dump+0x1ae> @ imm = #0x36
 8005eda: 2301         	movs	r3, #0x1
 8005edc: f887 3037    	strb.w	r3, [r7, #0x37]
 8005ee0: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8005ee4: f083 0301    	eor	r3, r3, #0x1
 8005ee8: b2db         	uxtb	r3, r3
 8005eea: 2b00         	cmp	r3, #0x0
 8005eec: d111         	bne	0x8005f12 <esf_dump+0x1ae> @ imm = #0x22
 8005eee: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8005f5c <esf_dump+0x1f8>
 8005ef0: 6819         	ldr	r1, [r3]
 8005ef2: 687b         	ldr	r3, [r7, #0x4]
 8005ef4: 6e1b         	ldr	r3, [r3, #0x60]
 8005ef6: 9303         	str	r3, [sp, #0xc]
 8005ef8: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8005f70 <esf_dump+0x20c>
 8005efa: 9302         	str	r3, [sp, #0x8]
 8005efc: 2300         	movs	r3, #0x0
 8005efe: 9301         	str	r3, [sp, #0x4]
 8005f00: 2300         	movs	r3, #0x0
 8005f02: 9300         	str	r3, [sp]
 8005f04: 2300         	movs	r3, #0x0
 8005f06: 2201         	movs	r2, #0x1
 8005f08: 2000         	movs	r0, #0x0
 8005f0a: f011 fc19    	bl	0x8017740 <z_log_msg_runtime_create> @ imm = #0x11832
 8005f0e: 2300         	movs	r3, #0x0
 8005f10: 633b         	str	r3, [r7, #0x30]
; 	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
 8005f12: 2303         	movs	r3, #0x3
 8005f14: 2b00         	cmp	r3, #0x0
 8005f16: d01c         	beq	0x8005f52 <esf_dump+0x1ee> @ imm = #0x38
 8005f18: 2301         	movs	r3, #0x1
 8005f1a: f887 302f    	strb.w	r3, [r7, #0x2f]
 8005f1e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8005f22: f083 0301    	eor	r3, r3, #0x1
 8005f26: b2db         	uxtb	r3, r3
 8005f28: 2b00         	cmp	r3, #0x0
 8005f2a: d112         	bne	0x8005f52 <esf_dump+0x1ee> @ imm = #0x24
 8005f2c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8005f5c <esf_dump+0x1f8>
 8005f2e: 6819         	ldr	r1, [r3]
 8005f30: 687b         	ldr	r3, [r7, #0x4]
 8005f32: 699b         	ldr	r3, [r3, #0x18]
 8005f34: 9303         	str	r3, [sp, #0xc]
 8005f36: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8005f74 <esf_dump+0x210>
 8005f38: 9302         	str	r3, [sp, #0x8]
 8005f3a: 2300         	movs	r3, #0x0
 8005f3c: 9301         	str	r3, [sp, #0x4]
 8005f3e: 2300         	movs	r3, #0x0
 8005f40: 9300         	str	r3, [sp]
 8005f42: 2300         	movs	r3, #0x0
 8005f44: 2201         	movs	r2, #0x1
 8005f46: 2000         	movs	r0, #0x0
 8005f48: f011 fbfa    	bl	0x8017740 <z_log_msg_runtime_create> @ imm = #0x117f4
 8005f4c: 2300         	movs	r3, #0x0
 8005f4e: 62bb         	str	r3, [r7, #0x28]
; }
 8005f50: bf00         	nop
 8005f52: bf00         	nop
 8005f54: 3744         	adds	r7, #0x44
 8005f56: 46bd         	mov	sp, r7
 8005f58: bdf0         	pop	{r4, r5, r6, r7, pc}
 8005f5a: bf00         	nop

08005f5c <$d>:
 8005f5c: 0c 05 00 20  	.word	0x2000050c
 8005f60: 40 0b 02 08  	.word	0x08020b40
 8005f64: 70 0b 02 08  	.word	0x08020b70
 8005f68: a0 0b 02 08  	.word	0x08020ba0
 8005f6c: b0 0b 02 08  	.word	0x08020bb0
 8005f70: f4 0b 02 08  	.word	0x08020bf4
 8005f74: 04 0c 02 08  	.word	0x08020c04

08005f78 <z_arm_fatal_error>:
; {
 8005f78: b580         	push	{r7, lr}
 8005f7a: b08a         	sub	sp, #0x28
 8005f7c: af04         	add	r7, sp, #0x10
 8005f7e: 6078         	str	r0, [r7, #0x4]
 8005f80: 6039         	str	r1, [r7]
; 	if (esf != NULL) {
 8005f82: 683b         	ldr	r3, [r7]
 8005f84: 2b00         	cmp	r3, #0x0
 8005f86: d002         	beq	0x8005f8e <z_arm_fatal_error+0x16> @ imm = #0x4
; 		esf_dump(esf);
 8005f88: 6838         	ldr	r0, [r7]
 8005f8a: f7ff feeb    	bl	0x8005d64 <esf_dump>    @ imm = #-0x22a
; 	if (reason == K_ERR_SPURIOUS_IRQ) {
 8005f8e: 687b         	ldr	r3, [r7, #0x4]
 8005f90: 2b01         	cmp	r3, #0x1
 8005f92: d121         	bne	0x8005fd8 <z_arm_fatal_error+0x60> @ imm = #0x42
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8005f94: f3ef 8305    	mrs	r3, ipsr
 8005f98: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 8005f9a: 68bb         	ldr	r3, [r7, #0x8]
; 		uint32_t irqn = __get_IPSR() - 16;
 8005f9c: 3b10         	subs	r3, #0x10
 8005f9e: 617b         	str	r3, [r7, #0x14]
; 		LOG_ERR("Unhandled IRQn: %d", irqn);
 8005fa0: 2303         	movs	r3, #0x3
 8005fa2: 2b00         	cmp	r3, #0x0
 8005fa4: d018         	beq	0x8005fd8 <z_arm_fatal_error+0x60> @ imm = #0x30
 8005fa6: 2301         	movs	r3, #0x1
 8005fa8: 74fb         	strb	r3, [r7, #0x13]
 8005faa: 7cfb         	ldrb	r3, [r7, #0x13]
 8005fac: f083 0301    	eor	r3, r3, #0x1
 8005fb0: b2db         	uxtb	r3, r3
 8005fb2: 2b00         	cmp	r3, #0x0
 8005fb4: d110         	bne	0x8005fd8 <z_arm_fatal_error+0x60> @ imm = #0x20
 8005fb6: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8005fe8 <z_arm_fatal_error+0x70>
 8005fb8: 6819         	ldr	r1, [r3]
 8005fba: 697b         	ldr	r3, [r7, #0x14]
 8005fbc: 9303         	str	r3, [sp, #0xc]
 8005fbe: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8005fec <z_arm_fatal_error+0x74>
 8005fc0: 9302         	str	r3, [sp, #0x8]
 8005fc2: 2300         	movs	r3, #0x0
 8005fc4: 9301         	str	r3, [sp, #0x4]
 8005fc6: 2300         	movs	r3, #0x0
 8005fc8: 9300         	str	r3, [sp]
 8005fca: 2300         	movs	r3, #0x0
 8005fcc: 2201         	movs	r2, #0x1
 8005fce: 2000         	movs	r0, #0x0
 8005fd0: f011 fbb6    	bl	0x8017740 <z_log_msg_runtime_create> @ imm = #0x1176c
 8005fd4: 2300         	movs	r3, #0x0
 8005fd6: 60fb         	str	r3, [r7, #0xc]
; 	z_fatal_error(reason, esf);
 8005fd8: 6839         	ldr	r1, [r7]
 8005fda: 6878         	ldr	r0, [r7, #0x4]
 8005fdc: f009 fa36    	bl	0x800f44c <z_fatal_error> @ imm = #0x946c
; }
 8005fe0: bf00         	nop
 8005fe2: 3718         	adds	r7, #0x18
 8005fe4: 46bd         	mov	sp, r7
 8005fe6: bd80         	pop	{r7, pc}

08005fe8 <$d>:
 8005fe8: 0c 05 00 20  	.word	0x2000050c
 8005fec: 34 0c 02 08  	.word	0x08020c34

08005ff0 <z_arm_nmi>:
; {
 8005ff0: b580         	push	{r7, lr}
 8005ff2: af00         	add	r7, sp, #0x0
; 	handler();
 8005ff4: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8006004 <z_arm_nmi+0x14>
 8005ff6: 681b         	ldr	r3, [r3]
 8005ff8: 4798         	blx	r3
; 	z_arm_int_exit();
 8005ffa: f000 f835    	bl	0x8006068 <z_arm_int_exit> @ imm = #0x6a
; }
 8005ffe: bf00         	nop
 8006000: bd80         	pop	{r7, pc}
 8006002: bf00         	nop

08006004 <$d>:
 8006004: 10 05 00 20  	.word	0x20000510

08006008 <z_SysNmiOnReset>:
;     wfi
 8006008: bf30         	wfi
;     b z_SysNmiOnReset
 800600a: f7ff bffd    	b.w	0x8006008 <z_SysNmiOnReset> @ imm = #-0x6
 800600e: bf00         	nop

08006010 <z_tls_data_size>:
; {
 8006010: b480         	push	{r7}
 8006012: af00         	add	r7, sp, #0x0
; 	return (size_t)(uintptr_t)__tdata_size +
 8006014: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8006024 <z_tls_data_size+0x14>
; 	       (size_t)(uintptr_t)__tbss_size;
 8006016: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8006028 <z_tls_data_size+0x18>
; 	return (size_t)(uintptr_t)__tdata_size +
 8006018: 4413         	add	r3, r2
; }
 800601a: 4618         	mov	r0, r3
 800601c: 46bd         	mov	sp, r7
 800601e: f85d 7b04    	ldr	r7, [sp], #4
 8006022: 4770         	bx	lr

08006024 <$d>:
 8006024: 00 00 00 00  	.word	0x00000000
 8006028: 08 00 00 00  	.word	0x00000008

0800602c <z_tls_copy>:
; {
 800602c: b580         	push	{r7, lr}
 800602e: b082         	sub	sp, #0x8
 8006030: af00         	add	r7, sp, #0x0
 8006032: 6078         	str	r0, [r7, #0x4]
; 	memcpy(dest, __tdata_start, (size_t)(uintptr_t)__tdata_size);
 8006034: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800605c <z_tls_copy+0x30>
 8006036: 461a         	mov	r2, r3
 8006038: 4909         	ldr	r1, [pc, #0x24]         @ 0x8006060 <z_tls_copy+0x34>
 800603a: 6878         	ldr	r0, [r7, #0x4]
 800603c: f019 fe3e    	bl	0x801fcbc <memcpy>      @ imm = #0x19c7c
; 	dest += (size_t)(uintptr_t)__tdata_size;
 8006040: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800605c <z_tls_copy+0x30>
 8006042: 687b         	ldr	r3, [r7, #0x4]
 8006044: 4413         	add	r3, r2
 8006046: 607b         	str	r3, [r7, #0x4]
; 	memset(dest, 0, (size_t)(uintptr_t)__tbss_size);
 8006048: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8006064 <z_tls_copy+0x38>
 800604a: 461a         	mov	r2, r3
 800604c: 2100         	movs	r1, #0x0
 800604e: 6878         	ldr	r0, [r7, #0x4]
 8006050: f019 fe42    	bl	0x801fcd8 <memset>      @ imm = #0x19c84
; }
 8006054: bf00         	nop
 8006056: 3708         	adds	r7, #0x8
 8006058: 46bd         	mov	sp, r7
 800605a: bd80         	pop	{r7, pc}

0800605c <$d>:
 800605c: 00 00 00 00  	.word	0x00000000
 8006060: 44 07 02 08  	.word	0x08020744
 8006064: 08 00 00 00  	.word	0x00000008

08006068 <z_arm_int_exit>:
; {
 8006068: b480         	push	{r7}
 800606a: af00         	add	r7, sp, #0x0
; 	if (_kernel.cpus->current->base.prio >= 0) {
 800606c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800609c <z_arm_int_exit+0x34>
 800606e: 689b         	ldr	r3, [r3, #0x8]
 8006070: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8006074: 2b00         	cmp	r3, #0x0
 8006076: db0b         	blt	0x8006090 <z_arm_int_exit+0x28> @ imm = #0x16
; 		if (_kernel.ready_q.cache != _kernel.cpus->current) {
 8006078: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800609c <z_arm_int_exit+0x34>
 800607a: 6a1a         	ldr	r2, [r3, #0x20]
 800607c: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800609c <z_arm_int_exit+0x34>
 800607e: 689b         	ldr	r3, [r3, #0x8]
 8006080: 429a         	cmp	r2, r3
 8006082: d005         	beq	0x8006090 <z_arm_int_exit+0x28> @ imm = #0xa
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8006084: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80060a0 <z_arm_int_exit+0x38>
 8006086: 685b         	ldr	r3, [r3, #0x4]
 8006088: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80060a0 <z_arm_int_exit+0x38>
 800608a: f043 5380    	orr	r3, r3, #0x10000000
 800608e: 6053         	str	r3, [r2, #0x4]
; }
 8006090: bf00         	nop
 8006092: 46bd         	mov	sp, r7
 8006094: f85d 7b04    	ldr	r7, [sp], #4
 8006098: 4770         	bx	lr
 800609a: bf00         	nop

0800609c <$d>:
 800609c: 48 1d 00 20  	.word	0x20001d48
 80060a0: 00 ed 00 e0  	.word	0xe000ed00

080060a4 <mem_manage_fault>:
; {
 80060a4: b580         	push	{r7, lr}
 80060a6: b09a         	sub	sp, #0x68
 80060a8: af04         	add	r7, sp, #0x10
 80060aa: 60f8         	str	r0, [r7, #0xc]
 80060ac: 60b9         	str	r1, [r7, #0x8]
 80060ae: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
 80060b0: 2310         	movs	r3, #0x10
 80060b2: 657b         	str	r3, [r7, #0x54]
; 	uint32_t mmfar = -EINVAL;
 80060b4: f06f 0315    	mvn	r3, #0x15
 80060b8: 653b         	str	r3, [r7, #0x50]
; 	PR_FAULT_INFO("***** MPU FAULT *****");
 80060ba: 2303         	movs	r3, #0x3
 80060bc: 2b00         	cmp	r3, #0x0
 80060be: d018         	beq	0x80060f2 <mem_manage_fault+0x4e> @ imm = #0x30
 80060c0: 2301         	movs	r3, #0x1
 80060c2: f887 304f    	strb.w	r3, [r7, #0x4f]
 80060c6: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 80060ca: f083 0301    	eor	r3, r3, #0x1
 80060ce: b2db         	uxtb	r3, r3
 80060d0: 2b00         	cmp	r3, #0x0
 80060d2: d10e         	bne	0x80060f2 <mem_manage_fault+0x4e> @ imm = #0x1c
 80060d4: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x8006308 <mem_manage_fault+0x264>
 80060d6: 6819         	ldr	r1, [r3]
 80060d8: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x800630c <mem_manage_fault+0x268>
 80060da: 9302         	str	r3, [sp, #0x8]
 80060dc: 2300         	movs	r3, #0x0
 80060de: 9301         	str	r3, [sp, #0x4]
 80060e0: 2300         	movs	r3, #0x0
 80060e2: 9300         	str	r3, [sp]
 80060e4: 2300         	movs	r3, #0x0
 80060e6: 2201         	movs	r2, #0x1
 80060e8: 2000         	movs	r0, #0x0
 80060ea: f011 fb7b    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x116f6
 80060ee: 2300         	movs	r3, #0x0
 80060f0: 64bb         	str	r3, [r7, #0x48]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 80060f2: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8006310 <mem_manage_fault+0x26c>
 80060f4: 6a9b         	ldr	r3, [r3, #0x28]
 80060f6: f003 0310    	and	r3, r3, #0x10
 80060fa: 2b00         	cmp	r3, #0x0
 80060fc: d01d         	beq	0x800613a <mem_manage_fault+0x96> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_STACKING;
 80060fe: 2311         	movs	r3, #0x11
 8006100: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error (context area might be"
 8006102: 2303         	movs	r3, #0x3
 8006104: 2b00         	cmp	r3, #0x0
 8006106: d018         	beq	0x800613a <mem_manage_fault+0x96> @ imm = #0x30
 8006108: 2301         	movs	r3, #0x1
 800610a: f887 3047    	strb.w	r3, [r7, #0x47]
 800610e: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8006112: f083 0301    	eor	r3, r3, #0x1
 8006116: b2db         	uxtb	r3, r3
 8006118: 2b00         	cmp	r3, #0x0
 800611a: d10e         	bne	0x800613a <mem_manage_fault+0x96> @ imm = #0x1c
 800611c: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x8006308 <mem_manage_fault+0x264>
 800611e: 6819         	ldr	r1, [r3]
 8006120: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x8006314 <mem_manage_fault+0x270>
 8006122: 9302         	str	r3, [sp, #0x8]
 8006124: 2300         	movs	r3, #0x0
 8006126: 9301         	str	r3, [sp, #0x4]
 8006128: 2300         	movs	r3, #0x0
 800612a: 9300         	str	r3, [sp]
 800612c: 2300         	movs	r3, #0x0
 800612e: 2201         	movs	r2, #0x1
 8006130: 2000         	movs	r0, #0x0
 8006132: f011 fb57    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x116ae
 8006136: 2300         	movs	r3, #0x0
 8006138: 643b         	str	r3, [r7, #0x40]
; 	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 800613a: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8006310 <mem_manage_fault+0x26c>
 800613c: 6a9b         	ldr	r3, [r3, #0x28]
 800613e: f003 0308    	and	r3, r3, #0x8
 8006142: 2b00         	cmp	r3, #0x0
 8006144: d01d         	beq	0x8006182 <mem_manage_fault+0xde> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_UNSTACKING;
 8006146: 2312         	movs	r3, #0x12
 8006148: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 800614a: 2303         	movs	r3, #0x3
 800614c: 2b00         	cmp	r3, #0x0
 800614e: d018         	beq	0x8006182 <mem_manage_fault+0xde> @ imm = #0x30
 8006150: 2301         	movs	r3, #0x1
 8006152: f887 303f    	strb.w	r3, [r7, #0x3f]
 8006156: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800615a: f083 0301    	eor	r3, r3, #0x1
 800615e: b2db         	uxtb	r3, r3
 8006160: 2b00         	cmp	r3, #0x0
 8006162: d10e         	bne	0x8006182 <mem_manage_fault+0xde> @ imm = #0x1c
 8006164: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8006308 <mem_manage_fault+0x264>
 8006166: 6819         	ldr	r1, [r3]
 8006168: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x8006318 <mem_manage_fault+0x274>
 800616a: 9302         	str	r3, [sp, #0x8]
 800616c: 2300         	movs	r3, #0x0
 800616e: 9301         	str	r3, [sp, #0x4]
 8006170: 2300         	movs	r3, #0x0
 8006172: 9300         	str	r3, [sp]
 8006174: 2300         	movs	r3, #0x0
 8006176: 2201         	movs	r2, #0x1
 8006178: 2000         	movs	r0, #0x0
 800617a: f011 fb33    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x11666
 800617e: 2300         	movs	r3, #0x0
 8006180: 63bb         	str	r3, [r7, #0x38]
; 	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 8006182: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8006310 <mem_manage_fault+0x26c>
 8006184: 6a9b         	ldr	r3, [r3, #0x28]
 8006186: f003 0302    	and	r3, r3, #0x2
 800618a: 2b00         	cmp	r3, #0x0
 800618c: d04f         	beq	0x800622e <mem_manage_fault+0x18a> @ imm = #0x9e
; 		reason = K_ERR_ARM_MEM_DATA_ACCESS;
 800618e: 2313         	movs	r3, #0x13
 8006190: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Data Access Violation");
 8006192: 2303         	movs	r3, #0x3
 8006194: 2b00         	cmp	r3, #0x0
 8006196: d018         	beq	0x80061ca <mem_manage_fault+0x126> @ imm = #0x30
 8006198: 2301         	movs	r3, #0x1
 800619a: f887 3037    	strb.w	r3, [r7, #0x37]
 800619e: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80061a2: f083 0301    	eor	r3, r3, #0x1
 80061a6: b2db         	uxtb	r3, r3
 80061a8: 2b00         	cmp	r3, #0x0
 80061aa: d10e         	bne	0x80061ca <mem_manage_fault+0x126> @ imm = #0x1c
 80061ac: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8006308 <mem_manage_fault+0x264>
 80061ae: 6819         	ldr	r1, [r3]
 80061b0: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800631c <mem_manage_fault+0x278>
 80061b2: 9302         	str	r3, [sp, #0x8]
 80061b4: 2300         	movs	r3, #0x0
 80061b6: 9301         	str	r3, [sp, #0x4]
 80061b8: 2300         	movs	r3, #0x0
 80061ba: 9300         	str	r3, [sp]
 80061bc: 2300         	movs	r3, #0x0
 80061be: 2201         	movs	r2, #0x1
 80061c0: 2000         	movs	r0, #0x0
 80061c2: f011 fb0f    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x1161e
 80061c6: 2300         	movs	r3, #0x0
 80061c8: 633b         	str	r3, [r7, #0x30]
; 		uint32_t temp = SCB->MMFAR;
 80061ca: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8006310 <mem_manage_fault+0x26c>
 80061cc: 6b5b         	ldr	r3, [r3, #0x34]
 80061ce: 62fb         	str	r3, [r7, #0x2c]
; 		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 80061d0: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8006310 <mem_manage_fault+0x26c>
 80061d2: 6a9b         	ldr	r3, [r3, #0x28]
 80061d4: f003 0380    	and	r3, r3, #0x80
 80061d8: 2b00         	cmp	r3, #0x0
 80061da: d028         	beq	0x800622e <mem_manage_fault+0x18a> @ imm = #0x50
; 			mmfar = temp;
 80061dc: 6afb         	ldr	r3, [r7, #0x2c]
 80061de: 653b         	str	r3, [r7, #0x50]
; 			PR_EXC("  MMFAR Address: 0x%x", mmfar);
 80061e0: 2303         	movs	r3, #0x3
 80061e2: 2b00         	cmp	r3, #0x0
 80061e4: d01a         	beq	0x800621c <mem_manage_fault+0x178> @ imm = #0x34
 80061e6: 2301         	movs	r3, #0x1
 80061e8: f887 302b    	strb.w	r3, [r7, #0x2b]
 80061ec: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80061f0: f083 0301    	eor	r3, r3, #0x1
 80061f4: b2db         	uxtb	r3, r3
 80061f6: 2b00         	cmp	r3, #0x0
 80061f8: d110         	bne	0x800621c <mem_manage_fault+0x178> @ imm = #0x20
 80061fa: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8006308 <mem_manage_fault+0x264>
 80061fc: 6819         	ldr	r1, [r3]
 80061fe: 6d3b         	ldr	r3, [r7, #0x50]
 8006200: 9303         	str	r3, [sp, #0xc]
 8006202: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x8006320 <mem_manage_fault+0x27c>
 8006204: 9302         	str	r3, [sp, #0x8]
 8006206: 2300         	movs	r3, #0x0
 8006208: 9301         	str	r3, [sp, #0x4]
 800620a: 2300         	movs	r3, #0x0
 800620c: 9300         	str	r3, [sp]
 800620e: 2300         	movs	r3, #0x0
 8006210: 2201         	movs	r2, #0x1
 8006212: 2000         	movs	r0, #0x0
 8006214: f011 fae6    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x115cc
 8006218: 2300         	movs	r3, #0x0
 800621a: 627b         	str	r3, [r7, #0x24]
; 			if (from_hard_fault != 0) {
 800621c: 68bb         	ldr	r3, [r7, #0x8]
 800621e: 2b00         	cmp	r3, #0x0
 8006220: d005         	beq	0x800622e <mem_manage_fault+0x18a> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 8006222: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8006310 <mem_manage_fault+0x26c>
 8006224: 6a9b         	ldr	r3, [r3, #0x28]
 8006226: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x8006310 <mem_manage_fault+0x26c>
 8006228: f023 0380    	bic	r3, r3, #0x80
 800622c: 6293         	str	r3, [r2, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 800622e: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x8006310 <mem_manage_fault+0x26c>
 8006230: 6a9b         	ldr	r3, [r3, #0x28]
 8006232: f003 0301    	and	r3, r3, #0x1
 8006236: 2b00         	cmp	r3, #0x0
 8006238: d01d         	beq	0x8006276 <mem_manage_fault+0x1d2> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
 800623a: 2314         	movs	r3, #0x14
 800623c: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction Access Violation");
 800623e: 2303         	movs	r3, #0x3
 8006240: 2b00         	cmp	r3, #0x0
 8006242: d018         	beq	0x8006276 <mem_manage_fault+0x1d2> @ imm = #0x30
 8006244: 2301         	movs	r3, #0x1
 8006246: f887 3023    	strb.w	r3, [r7, #0x23]
 800624a: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800624e: f083 0301    	eor	r3, r3, #0x1
 8006252: b2db         	uxtb	r3, r3
 8006254: 2b00         	cmp	r3, #0x0
 8006256: d10e         	bne	0x8006276 <mem_manage_fault+0x1d2> @ imm = #0x1c
 8006258: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8006308 <mem_manage_fault+0x264>
 800625a: 6819         	ldr	r1, [r3]
 800625c: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8006324 <mem_manage_fault+0x280>
 800625e: 9302         	str	r3, [sp, #0x8]
 8006260: 2300         	movs	r3, #0x0
 8006262: 9301         	str	r3, [sp, #0x4]
 8006264: 2300         	movs	r3, #0x0
 8006266: 9300         	str	r3, [sp]
 8006268: 2300         	movs	r3, #0x0
 800626a: 2201         	movs	r2, #0x1
 800626c: 2000         	movs	r0, #0x0
 800626e: f011 fab9    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x11572
 8006272: 2300         	movs	r3, #0x0
 8006274: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 8006276: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8006310 <mem_manage_fault+0x26c>
 8006278: 6a9b         	ldr	r3, [r3, #0x28]
 800627a: f003 0320    	and	r3, r3, #0x20
 800627e: 2b00         	cmp	r3, #0x0
 8006280: d01b         	beq	0x80062ba <mem_manage_fault+0x216> @ imm = #0x36
; 		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
 8006282: 2315         	movs	r3, #0x15
 8006284: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO(
 8006286: 2303         	movs	r3, #0x3
 8006288: 2b00         	cmp	r3, #0x0
 800628a: d016         	beq	0x80062ba <mem_manage_fault+0x216> @ imm = #0x2c
 800628c: 2301         	movs	r3, #0x1
 800628e: 76fb         	strb	r3, [r7, #0x1b]
 8006290: 7efb         	ldrb	r3, [r7, #0x1b]
 8006292: f083 0301    	eor	r3, r3, #0x1
 8006296: b2db         	uxtb	r3, r3
 8006298: 2b00         	cmp	r3, #0x0
 800629a: d10e         	bne	0x80062ba <mem_manage_fault+0x216> @ imm = #0x1c
 800629c: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8006308 <mem_manage_fault+0x264>
 800629e: 6819         	ldr	r1, [r3]
 80062a0: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8006328 <mem_manage_fault+0x284>
 80062a2: 9302         	str	r3, [sp, #0x8]
 80062a4: 2300         	movs	r3, #0x0
 80062a6: 9301         	str	r3, [sp, #0x4]
 80062a8: 2300         	movs	r3, #0x0
 80062aa: 9300         	str	r3, [sp]
 80062ac: 2300         	movs	r3, #0x0
 80062ae: 2201         	movs	r2, #0x1
 80062b0: 2000         	movs	r0, #0x0
 80062b2: f011 fa97    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x1152e
 80062b6: 2300         	movs	r3, #0x0
 80062b8: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 80062ba: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8006310 <mem_manage_fault+0x26c>
 80062bc: 6a9b         	ldr	r3, [r3, #0x28]
 80062be: f003 0310    	and	r3, r3, #0x10
 80062c2: 2b00         	cmp	r3, #0x0
 80062c4: d101         	bne	0x80062ca <mem_manage_fault+0x226> @ imm = #0x2
; 		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
 80062c6: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8006310 <mem_manage_fault+0x26c>
 80062c8: 6a9b         	ldr	r3, [r3, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 80062ca: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8006310 <mem_manage_fault+0x26c>
 80062cc: 6a9b         	ldr	r3, [r3, #0x28]
 80062ce: f003 0320    	and	r3, r3, #0x20
 80062d2: 2b00         	cmp	r3, #0x0
 80062d4: d005         	beq	0x80062e2 <mem_manage_fault+0x23e> @ imm = #0xa
; 		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
 80062d6: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8006310 <mem_manage_fault+0x26c>
 80062d8: 6a5b         	ldr	r3, [r3, #0x24]
 80062da: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8006310 <mem_manage_fault+0x26c>
 80062dc: f423 5300    	bic	r3, r3, #0x2000
 80062e0: 6253         	str	r3, [r2, #0x24]
; 	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 80062e2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8006310 <mem_manage_fault+0x26c>
 80062e4: 6a9b         	ldr	r3, [r3, #0x28]
 80062e6: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8006310 <mem_manage_fault+0x26c>
 80062e8: f043 03ff    	orr	r3, r3, #0xff
 80062ec: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 80062ee: 2101         	movs	r1, #0x1
 80062f0: 68f8         	ldr	r0, [r7, #0xc]
 80062f2: f011 faa0    	bl	0x8017836 <memory_fault_recoverable> @ imm = #0x11540
 80062f6: 4603         	mov	r3, r0
 80062f8: 461a         	mov	r2, r3
 80062fa: 687b         	ldr	r3, [r7, #0x4]
 80062fc: 701a         	strb	r2, [r3]
; 	return reason;
 80062fe: 6d7b         	ldr	r3, [r7, #0x54]
; }
 8006300: 4618         	mov	r0, r3
 8006302: 3758         	adds	r7, #0x58
 8006304: 46bd         	mov	sp, r7
 8006306: bd80         	pop	{r7, pc}

08006308 <$d>:
 8006308: 14 05 00 20  	.word	0x20000514
 800630c: 48 0c 02 08  	.word	0x08020c48
 8006310: 00 ed 00 e0  	.word	0xe000ed00
 8006314: 60 0c 02 08  	.word	0x08020c60
 8006318: 94 0c 02 08  	.word	0x08020c94
 800631c: a8 0c 02 08  	.word	0x08020ca8
 8006320: c0 0c 02 08  	.word	0x08020cc0
 8006324: d8 0c 02 08  	.word	0x08020cd8
 8006328: f8 0c 02 08  	.word	0x08020cf8

0800632c <bus_fault>:
; {
 800632c: b580         	push	{r7, lr}
 800632e: b09a         	sub	sp, #0x68
 8006330: af04         	add	r7, sp, #0x10
 8006332: 60f8         	str	r0, [r7, #0xc]
 8006334: 60b9         	str	r1, [r7, #0x8]
 8006336: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
 8006338: 2316         	movs	r3, #0x16
 800633a: 657b         	str	r3, [r7, #0x54]
; 	PR_FAULT_INFO("***** BUS FAULT *****");
 800633c: 2303         	movs	r3, #0x3
 800633e: 2b00         	cmp	r3, #0x0
 8006340: d018         	beq	0x8006374 <bus_fault+0x48> @ imm = #0x30
 8006342: 2301         	movs	r3, #0x1
 8006344: f887 3053    	strb.w	r3, [r7, #0x53]
 8006348: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800634c: f083 0301    	eor	r3, r3, #0x1
 8006350: b2db         	uxtb	r3, r3
 8006352: 2b00         	cmp	r3, #0x0
 8006354: d10e         	bne	0x8006374 <bus_fault+0x48> @ imm = #0x1c
 8006356: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x80065a4 <bus_fault+0x278>
 8006358: 6819         	ldr	r1, [r3]
 800635a: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x80065a8 <bus_fault+0x27c>
 800635c: 9302         	str	r3, [sp, #0x8]
 800635e: 2300         	movs	r3, #0x0
 8006360: 9301         	str	r3, [sp, #0x4]
 8006362: 2300         	movs	r3, #0x0
 8006364: 9300         	str	r3, [sp]
 8006366: 2300         	movs	r3, #0x0
 8006368: 2201         	movs	r2, #0x1
 800636a: 2000         	movs	r0, #0x0
 800636c: f011 fa3a    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x11474
 8006370: 2300         	movs	r3, #0x0
 8006372: 64fb         	str	r3, [r7, #0x4c]
; 	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 8006374: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x80065ac <bus_fault+0x280>
 8006376: 6a9b         	ldr	r3, [r3, #0x28]
 8006378: f403 5380    	and	r3, r3, #0x1000
 800637c: 2b00         	cmp	r3, #0x0
 800637e: d01d         	beq	0x80063bc <bus_fault+0x90> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_STACKING;
 8006380: 2317         	movs	r3, #0x17
 8006382: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error");
 8006384: 2303         	movs	r3, #0x3
 8006386: 2b00         	cmp	r3, #0x0
 8006388: d018         	beq	0x80063bc <bus_fault+0x90> @ imm = #0x30
 800638a: 2301         	movs	r3, #0x1
 800638c: f887 304b    	strb.w	r3, [r7, #0x4b]
 8006390: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8006394: f083 0301    	eor	r3, r3, #0x1
 8006398: b2db         	uxtb	r3, r3
 800639a: 2b00         	cmp	r3, #0x0
 800639c: d10e         	bne	0x80063bc <bus_fault+0x90> @ imm = #0x1c
 800639e: 4b81         	ldr	r3, [pc, #0x204]        @ 0x80065a4 <bus_fault+0x278>
 80063a0: 6819         	ldr	r1, [r3]
 80063a2: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x80065b0 <bus_fault+0x284>
 80063a4: 9302         	str	r3, [sp, #0x8]
 80063a6: 2300         	movs	r3, #0x0
 80063a8: 9301         	str	r3, [sp, #0x4]
 80063aa: 2300         	movs	r3, #0x0
 80063ac: 9300         	str	r3, [sp]
 80063ae: 2300         	movs	r3, #0x0
 80063b0: 2201         	movs	r2, #0x1
 80063b2: 2000         	movs	r0, #0x0
 80063b4: f011 fa16    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x1142c
 80063b8: 2300         	movs	r3, #0x0
 80063ba: 647b         	str	r3, [r7, #0x44]
; 	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 80063bc: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x80065ac <bus_fault+0x280>
 80063be: 6a9b         	ldr	r3, [r3, #0x28]
 80063c0: f403 6300    	and	r3, r3, #0x800
 80063c4: 2b00         	cmp	r3, #0x0
 80063c6: d01d         	beq	0x8006404 <bus_fault+0xd8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_UNSTACKING;
 80063c8: 2318         	movs	r3, #0x18
 80063ca: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 80063cc: 2303         	movs	r3, #0x3
 80063ce: 2b00         	cmp	r3, #0x0
 80063d0: d018         	beq	0x8006404 <bus_fault+0xd8> @ imm = #0x30
 80063d2: 2301         	movs	r3, #0x1
 80063d4: f887 3043    	strb.w	r3, [r7, #0x43]
 80063d8: f897 3043    	ldrb.w	r3, [r7, #0x43]
 80063dc: f083 0301    	eor	r3, r3, #0x1
 80063e0: b2db         	uxtb	r3, r3
 80063e2: 2b00         	cmp	r3, #0x0
 80063e4: d10e         	bne	0x8006404 <bus_fault+0xd8> @ imm = #0x1c
 80063e6: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x80065a4 <bus_fault+0x278>
 80063e8: 6819         	ldr	r1, [r3]
 80063ea: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x80065b4 <bus_fault+0x288>
 80063ec: 9302         	str	r3, [sp, #0x8]
 80063ee: 2300         	movs	r3, #0x0
 80063f0: 9301         	str	r3, [sp, #0x4]
 80063f2: 2300         	movs	r3, #0x0
 80063f4: 9300         	str	r3, [sp]
 80063f6: 2300         	movs	r3, #0x0
 80063f8: 2201         	movs	r2, #0x1
 80063fa: 2000         	movs	r0, #0x0
 80063fc: f011 f9f2    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x113e4
 8006400: 2300         	movs	r3, #0x0
 8006402: 63fb         	str	r3, [r7, #0x3c]
; 	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 8006404: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x80065ac <bus_fault+0x280>
 8006406: 6a9b         	ldr	r3, [r3, #0x28]
 8006408: f403 7300    	and	r3, r3, #0x200
 800640c: 2b00         	cmp	r3, #0x0
 800640e: d04d         	beq	0x80064ac <bus_fault+0x180> @ imm = #0x9a
; 		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
 8006410: 2319         	movs	r3, #0x19
 8006412: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Precise data bus error");
 8006414: 2303         	movs	r3, #0x3
 8006416: 2b00         	cmp	r3, #0x0
 8006418: d018         	beq	0x800644c <bus_fault+0x120> @ imm = #0x30
 800641a: 2301         	movs	r3, #0x1
 800641c: f887 303b    	strb.w	r3, [r7, #0x3b]
 8006420: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8006424: f083 0301    	eor	r3, r3, #0x1
 8006428: b2db         	uxtb	r3, r3
 800642a: 2b00         	cmp	r3, #0x0
 800642c: d10e         	bne	0x800644c <bus_fault+0x120> @ imm = #0x1c
 800642e: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x80065a4 <bus_fault+0x278>
 8006430: 6819         	ldr	r1, [r3]
 8006432: 4b61         	ldr	r3, [pc, #0x184]        @ 0x80065b8 <bus_fault+0x28c>
 8006434: 9302         	str	r3, [sp, #0x8]
 8006436: 2300         	movs	r3, #0x0
 8006438: 9301         	str	r3, [sp, #0x4]
 800643a: 2300         	movs	r3, #0x0
 800643c: 9300         	str	r3, [sp]
 800643e: 2300         	movs	r3, #0x0
 8006440: 2201         	movs	r2, #0x1
 8006442: 2000         	movs	r0, #0x0
 8006444: f011 f9ce    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x1139c
 8006448: 2300         	movs	r3, #0x0
 800644a: 637b         	str	r3, [r7, #0x34]
; 		STORE_xFAR(bfar, SCB->BFAR);
 800644c: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x80065ac <bus_fault+0x280>
 800644e: 6b9b         	ldr	r3, [r3, #0x38]
 8006450: 633b         	str	r3, [r7, #0x30]
; 		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 8006452: 4b56         	ldr	r3, [pc, #0x158]        @ 0x80065ac <bus_fault+0x280>
 8006454: 6a9b         	ldr	r3, [r3, #0x28]
 8006456: f403 4300    	and	r3, r3, #0x8000
 800645a: 2b00         	cmp	r3, #0x0
 800645c: d026         	beq	0x80064ac <bus_fault+0x180> @ imm = #0x4c
; 			PR_EXC("  BFAR Address: 0x%x", bfar);
 800645e: 2303         	movs	r3, #0x3
 8006460: 2b00         	cmp	r3, #0x0
 8006462: d01a         	beq	0x800649a <bus_fault+0x16e> @ imm = #0x34
 8006464: 2301         	movs	r3, #0x1
 8006466: f887 302f    	strb.w	r3, [r7, #0x2f]
 800646a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800646e: f083 0301    	eor	r3, r3, #0x1
 8006472: b2db         	uxtb	r3, r3
 8006474: 2b00         	cmp	r3, #0x0
 8006476: d110         	bne	0x800649a <bus_fault+0x16e> @ imm = #0x20
 8006478: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x80065a4 <bus_fault+0x278>
 800647a: 6819         	ldr	r1, [r3]
 800647c: 6b3b         	ldr	r3, [r7, #0x30]
 800647e: 9303         	str	r3, [sp, #0xc]
 8006480: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x80065bc <bus_fault+0x290>
 8006482: 9302         	str	r3, [sp, #0x8]
 8006484: 2300         	movs	r3, #0x0
 8006486: 9301         	str	r3, [sp, #0x4]
 8006488: 2300         	movs	r3, #0x0
 800648a: 9300         	str	r3, [sp]
 800648c: 2300         	movs	r3, #0x0
 800648e: 2201         	movs	r2, #0x1
 8006490: 2000         	movs	r0, #0x0
 8006492: f011 f9a7    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x1134e
 8006496: 2300         	movs	r3, #0x0
 8006498: 62bb         	str	r3, [r7, #0x28]
; 			if (from_hard_fault != 0) {
 800649a: 68bb         	ldr	r3, [r7, #0x8]
 800649c: 2b00         	cmp	r3, #0x0
 800649e: d005         	beq	0x80064ac <bus_fault+0x180> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 80064a0: 4b42         	ldr	r3, [pc, #0x108]        @ 0x80065ac <bus_fault+0x280>
 80064a2: 6a9b         	ldr	r3, [r3, #0x28]
 80064a4: 4a41         	ldr	r2, [pc, #0x104]        @ 0x80065ac <bus_fault+0x280>
 80064a6: f423 4300    	bic	r3, r3, #0x8000
 80064aa: 6293         	str	r3, [r2, #0x28]
; 	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 80064ac: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x80065ac <bus_fault+0x280>
 80064ae: 6a9b         	ldr	r3, [r3, #0x28]
 80064b0: f403 6380    	and	r3, r3, #0x400
 80064b4: 2b00         	cmp	r3, #0x0
 80064b6: d01d         	beq	0x80064f4 <bus_fault+0x1c8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
 80064b8: 231a         	movs	r3, #0x1a
 80064ba: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Imprecise data bus error");
 80064bc: 2303         	movs	r3, #0x3
 80064be: 2b00         	cmp	r3, #0x0
 80064c0: d018         	beq	0x80064f4 <bus_fault+0x1c8> @ imm = #0x30
 80064c2: 2301         	movs	r3, #0x1
 80064c4: f887 3027    	strb.w	r3, [r7, #0x27]
 80064c8: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80064cc: f083 0301    	eor	r3, r3, #0x1
 80064d0: b2db         	uxtb	r3, r3
 80064d2: 2b00         	cmp	r3, #0x0
 80064d4: d10e         	bne	0x80064f4 <bus_fault+0x1c8> @ imm = #0x1c
 80064d6: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80065a4 <bus_fault+0x278>
 80064d8: 6819         	ldr	r1, [r3]
 80064da: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x80065c0 <bus_fault+0x294>
 80064dc: 9302         	str	r3, [sp, #0x8]
 80064de: 2300         	movs	r3, #0x0
 80064e0: 9301         	str	r3, [sp, #0x4]
 80064e2: 2300         	movs	r3, #0x0
 80064e4: 9300         	str	r3, [sp]
 80064e6: 2300         	movs	r3, #0x0
 80064e8: 2201         	movs	r2, #0x1
 80064ea: 2000         	movs	r0, #0x0
 80064ec: f011 f97a    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x112f4
 80064f0: 2300         	movs	r3, #0x0
 80064f2: 623b         	str	r3, [r7, #0x20]
; 	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 80064f4: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x80065ac <bus_fault+0x280>
 80064f6: 6a9b         	ldr	r3, [r3, #0x28]
 80064f8: f403 7380    	and	r3, r3, #0x100
 80064fc: 2b00         	cmp	r3, #0x0
 80064fe: d01c         	beq	0x800653a <bus_fault+0x20e> @ imm = #0x38
; 		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
 8006500: 231b         	movs	r3, #0x1b
 8006502: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction bus error");
 8006504: 2303         	movs	r3, #0x3
 8006506: 2b00         	cmp	r3, #0x0
 8006508: d039         	beq	0x800657e <bus_fault+0x252> @ imm = #0x72
 800650a: 2301         	movs	r3, #0x1
 800650c: 75fb         	strb	r3, [r7, #0x17]
 800650e: 7dfb         	ldrb	r3, [r7, #0x17]
 8006510: f083 0301    	eor	r3, r3, #0x1
 8006514: b2db         	uxtb	r3, r3
 8006516: 2b00         	cmp	r3, #0x0
 8006518: d131         	bne	0x800657e <bus_fault+0x252> @ imm = #0x62
 800651a: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80065a4 <bus_fault+0x278>
 800651c: 6819         	ldr	r1, [r3]
 800651e: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80065c4 <bus_fault+0x298>
 8006520: 9302         	str	r3, [sp, #0x8]
 8006522: 2300         	movs	r3, #0x0
 8006524: 9301         	str	r3, [sp, #0x4]
 8006526: 2300         	movs	r3, #0x0
 8006528: 9300         	str	r3, [sp]
 800652a: 2300         	movs	r3, #0x0
 800652c: 2201         	movs	r2, #0x1
 800652e: 2000         	movs	r0, #0x0
 8006530: f011 f958    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x112b0
 8006534: 2300         	movs	r3, #0x0
 8006536: 613b         	str	r3, [r7, #0x10]
 8006538: e021         	b	0x800657e <bus_fault+0x252> @ imm = #0x42
; 	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
 800653a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80065ac <bus_fault+0x280>
 800653c: 6a9b         	ldr	r3, [r3, #0x28]
 800653e: f403 5300    	and	r3, r3, #0x2000
 8006542: 2b00         	cmp	r3, #0x0
 8006544: d01b         	beq	0x800657e <bus_fault+0x252> @ imm = #0x36
; 		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
 8006546: 231c         	movs	r3, #0x1c
 8006548: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Floating-point lazy state preservation error");
 800654a: 2303         	movs	r3, #0x3
 800654c: 2b00         	cmp	r3, #0x0
 800654e: d016         	beq	0x800657e <bus_fault+0x252> @ imm = #0x2c
 8006550: 2301         	movs	r3, #0x1
 8006552: 77fb         	strb	r3, [r7, #0x1f]
 8006554: 7ffb         	ldrb	r3, [r7, #0x1f]
 8006556: f083 0301    	eor	r3, r3, #0x1
 800655a: b2db         	uxtb	r3, r3
 800655c: 2b00         	cmp	r3, #0x0
 800655e: d10e         	bne	0x800657e <bus_fault+0x252> @ imm = #0x1c
 8006560: 4b10         	ldr	r3, [pc, #0x40]         @ 0x80065a4 <bus_fault+0x278>
 8006562: 6819         	ldr	r1, [r3]
 8006564: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80065c8 <bus_fault+0x29c>
 8006566: 9302         	str	r3, [sp, #0x8]
 8006568: 2300         	movs	r3, #0x0
 800656a: 9301         	str	r3, [sp, #0x4]
 800656c: 2300         	movs	r3, #0x0
 800656e: 9300         	str	r3, [sp]
 8006570: 2300         	movs	r3, #0x0
 8006572: 2201         	movs	r2, #0x1
 8006574: 2000         	movs	r0, #0x0
 8006576: f011 f935    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x1126a
 800657a: 2300         	movs	r3, #0x0
 800657c: 61bb         	str	r3, [r7, #0x18]
; 	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 800657e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80065ac <bus_fault+0x280>
 8006580: 6a9b         	ldr	r3, [r3, #0x28]
 8006582: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80065ac <bus_fault+0x280>
 8006584: f443 437f    	orr	r3, r3, #0xff00
 8006588: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 800658a: 2101         	movs	r1, #0x1
 800658c: 68f8         	ldr	r0, [r7, #0xc]
 800658e: f011 f952    	bl	0x8017836 <memory_fault_recoverable> @ imm = #0x112a4
 8006592: 4603         	mov	r3, r0
 8006594: 461a         	mov	r2, r3
 8006596: 687b         	ldr	r3, [r7, #0x4]
 8006598: 701a         	strb	r2, [r3]
; 	return reason;
 800659a: 6d7b         	ldr	r3, [r7, #0x54]
; }
 800659c: 4618         	mov	r0, r3
 800659e: 3758         	adds	r7, #0x58
 80065a0: 46bd         	mov	sp, r7
 80065a2: bd80         	pop	{r7, pc}

080065a4 <$d>:
 80065a4: 14 05 00 20  	.word	0x20000514
 80065a8: 28 0d 02 08  	.word	0x08020d28
 80065ac: 00 ed 00 e0  	.word	0xe000ed00
 80065b0: 40 0d 02 08  	.word	0x08020d40
 80065b4: 94 0c 02 08  	.word	0x08020c94
 80065b8: 54 0d 02 08  	.word	0x08020d54
 80065bc: 70 0d 02 08  	.word	0x08020d70
 80065c0: 88 0d 02 08  	.word	0x08020d88
 80065c4: a4 0d 02 08  	.word	0x08020da4
 80065c8: f8 0c 02 08  	.word	0x08020cf8

080065cc <usage_fault>:
; {
 80065cc: b580         	push	{r7, lr}
 80065ce: b096         	sub	sp, #0x58
 80065d0: af04         	add	r7, sp, #0x10
 80065d2: 6078         	str	r0, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
 80065d4: 231d         	movs	r3, #0x1d
 80065d6: 647b         	str	r3, [r7, #0x44]
; 	PR_FAULT_INFO("***** USAGE FAULT *****");
 80065d8: 2303         	movs	r3, #0x3
 80065da: 2b00         	cmp	r3, #0x0
 80065dc: d018         	beq	0x8006610 <usage_fault+0x44> @ imm = #0x30
 80065de: 2301         	movs	r3, #0x1
 80065e0: f887 3043    	strb.w	r3, [r7, #0x43]
 80065e4: f897 3043    	ldrb.w	r3, [r7, #0x43]
 80065e8: f083 0301    	eor	r3, r3, #0x1
 80065ec: b2db         	uxtb	r3, r3
 80065ee: 2b00         	cmp	r3, #0x0
 80065f0: d10e         	bne	0x8006610 <usage_fault+0x44> @ imm = #0x1c
 80065f2: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x80067d4 <usage_fault+0x208>
 80065f4: 6819         	ldr	r1, [r3]
 80065f6: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x80067d8 <usage_fault+0x20c>
 80065f8: 9302         	str	r3, [sp, #0x8]
 80065fa: 2300         	movs	r3, #0x0
 80065fc: 9301         	str	r3, [sp, #0x4]
 80065fe: 2300         	movs	r3, #0x0
 8006600: 9300         	str	r3, [sp]
 8006602: 2300         	movs	r3, #0x0
 8006604: 2201         	movs	r2, #0x1
 8006606: 2000         	movs	r0, #0x0
 8006608: f011 f8ec    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x111d8
 800660c: 2300         	movs	r3, #0x0
 800660e: 63fb         	str	r3, [r7, #0x3c]
; 	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 8006610: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x80067dc <usage_fault+0x210>
 8006612: 6a9b         	ldr	r3, [r3, #0x28]
 8006614: f003 7300    	and	r3, r3, #0x2000000
 8006618: 2b00         	cmp	r3, #0x0
 800661a: d01d         	beq	0x8006658 <usage_fault+0x8c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_DIV_0;
 800661c: 231e         	movs	r3, #0x1e
 800661e: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Division by zero");
 8006620: 2303         	movs	r3, #0x3
 8006622: 2b00         	cmp	r3, #0x0
 8006624: d018         	beq	0x8006658 <usage_fault+0x8c> @ imm = #0x30
 8006626: 2301         	movs	r3, #0x1
 8006628: f887 303b    	strb.w	r3, [r7, #0x3b]
 800662c: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8006630: f083 0301    	eor	r3, r3, #0x1
 8006634: b2db         	uxtb	r3, r3
 8006636: 2b00         	cmp	r3, #0x0
 8006638: d10e         	bne	0x8006658 <usage_fault+0x8c> @ imm = #0x1c
 800663a: 4b66         	ldr	r3, [pc, #0x198]        @ 0x80067d4 <usage_fault+0x208>
 800663c: 6819         	ldr	r1, [r3]
 800663e: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x80067e0 <usage_fault+0x214>
 8006640: 9302         	str	r3, [sp, #0x8]
 8006642: 2300         	movs	r3, #0x0
 8006644: 9301         	str	r3, [sp, #0x4]
 8006646: 2300         	movs	r3, #0x0
 8006648: 9300         	str	r3, [sp]
 800664a: 2300         	movs	r3, #0x0
 800664c: 2201         	movs	r2, #0x1
 800664e: 2000         	movs	r0, #0x0
 8006650: f011 f8c8    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x11190
 8006654: 2300         	movs	r3, #0x0
 8006656: 637b         	str	r3, [r7, #0x34]
; 	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 8006658: 4b60         	ldr	r3, [pc, #0x180]        @ 0x80067dc <usage_fault+0x210>
 800665a: 6a9b         	ldr	r3, [r3, #0x28]
 800665c: f003 7380    	and	r3, r3, #0x1000000
 8006660: 2b00         	cmp	r3, #0x0
 8006662: d01d         	beq	0x80066a0 <usage_fault+0xd4> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
 8006664: 231f         	movs	r3, #0x1f
 8006666: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Unaligned memory access");
 8006668: 2303         	movs	r3, #0x3
 800666a: 2b00         	cmp	r3, #0x0
 800666c: d018         	beq	0x80066a0 <usage_fault+0xd4> @ imm = #0x30
 800666e: 2301         	movs	r3, #0x1
 8006670: f887 3033    	strb.w	r3, [r7, #0x33]
 8006674: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8006678: f083 0301    	eor	r3, r3, #0x1
 800667c: b2db         	uxtb	r3, r3
 800667e: 2b00         	cmp	r3, #0x0
 8006680: d10e         	bne	0x80066a0 <usage_fault+0xd4> @ imm = #0x1c
 8006682: 4b54         	ldr	r3, [pc, #0x150]        @ 0x80067d4 <usage_fault+0x208>
 8006684: 6819         	ldr	r1, [r3]
 8006686: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x80067e4 <usage_fault+0x218>
 8006688: 9302         	str	r3, [sp, #0x8]
 800668a: 2300         	movs	r3, #0x0
 800668c: 9301         	str	r3, [sp, #0x4]
 800668e: 2300         	movs	r3, #0x0
 8006690: 9300         	str	r3, [sp]
 8006692: 2300         	movs	r3, #0x0
 8006694: 2201         	movs	r2, #0x1
 8006696: 2000         	movs	r0, #0x0
 8006698: f011 f8a4    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x11148
 800669c: 2300         	movs	r3, #0x0
 800669e: 62fb         	str	r3, [r7, #0x2c]
; 	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 80066a0: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x80067dc <usage_fault+0x210>
 80066a2: 6a9b         	ldr	r3, [r3, #0x28]
 80066a4: f403 2300    	and	r3, r3, #0x80000
 80066a8: 2b00         	cmp	r3, #0x0
 80066aa: d01d         	beq	0x80066e8 <usage_fault+0x11c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
 80066ac: 2321         	movs	r3, #0x21
 80066ae: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  No coprocessor instructions");
 80066b0: 2303         	movs	r3, #0x3
 80066b2: 2b00         	cmp	r3, #0x0
 80066b4: d018         	beq	0x80066e8 <usage_fault+0x11c> @ imm = #0x30
 80066b6: 2301         	movs	r3, #0x1
 80066b8: f887 302b    	strb.w	r3, [r7, #0x2b]
 80066bc: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80066c0: f083 0301    	eor	r3, r3, #0x1
 80066c4: b2db         	uxtb	r3, r3
 80066c6: 2b00         	cmp	r3, #0x0
 80066c8: d10e         	bne	0x80066e8 <usage_fault+0x11c> @ imm = #0x1c
 80066ca: 4b42         	ldr	r3, [pc, #0x108]        @ 0x80067d4 <usage_fault+0x208>
 80066cc: 6819         	ldr	r1, [r3]
 80066ce: 4b46         	ldr	r3, [pc, #0x118]        @ 0x80067e8 <usage_fault+0x21c>
 80066d0: 9302         	str	r3, [sp, #0x8]
 80066d2: 2300         	movs	r3, #0x0
 80066d4: 9301         	str	r3, [sp, #0x4]
 80066d6: 2300         	movs	r3, #0x0
 80066d8: 9300         	str	r3, [sp]
 80066da: 2300         	movs	r3, #0x0
 80066dc: 2201         	movs	r2, #0x1
 80066de: 2000         	movs	r0, #0x0
 80066e0: f011 f880    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x11100
 80066e4: 2300         	movs	r3, #0x0
 80066e6: 627b         	str	r3, [r7, #0x24]
; 	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 80066e8: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x80067dc <usage_fault+0x210>
 80066ea: 6a9b         	ldr	r3, [r3, #0x28]
 80066ec: f403 2380    	and	r3, r3, #0x40000
 80066f0: 2b00         	cmp	r3, #0x0
 80066f2: d01d         	beq	0x8006730 <usage_fault+0x164> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
 80066f4: 2322         	movs	r3, #0x22
 80066f6: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
 80066f8: 2303         	movs	r3, #0x3
 80066fa: 2b00         	cmp	r3, #0x0
 80066fc: d018         	beq	0x8006730 <usage_fault+0x164> @ imm = #0x30
 80066fe: 2301         	movs	r3, #0x1
 8006700: f887 3023    	strb.w	r3, [r7, #0x23]
 8006704: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8006708: f083 0301    	eor	r3, r3, #0x1
 800670c: b2db         	uxtb	r3, r3
 800670e: 2b00         	cmp	r3, #0x0
 8006710: d10e         	bne	0x8006730 <usage_fault+0x164> @ imm = #0x1c
 8006712: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x80067d4 <usage_fault+0x208>
 8006714: 6819         	ldr	r1, [r3]
 8006716: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80067ec <usage_fault+0x220>
 8006718: 9302         	str	r3, [sp, #0x8]
 800671a: 2300         	movs	r3, #0x0
 800671c: 9301         	str	r3, [sp, #0x4]
 800671e: 2300         	movs	r3, #0x0
 8006720: 9300         	str	r3, [sp]
 8006722: 2300         	movs	r3, #0x0
 8006724: 2201         	movs	r2, #0x1
 8006726: 2000         	movs	r0, #0x0
 8006728: f011 f85c    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x110b8
 800672c: 2300         	movs	r3, #0x0
 800672e: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 8006730: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80067dc <usage_fault+0x210>
 8006732: 6a9b         	ldr	r3, [r3, #0x28]
 8006734: f403 3300    	and	r3, r3, #0x20000
 8006738: 2b00         	cmp	r3, #0x0
 800673a: d01b         	beq	0x8006774 <usage_fault+0x1a8> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
 800673c: 2323         	movs	r3, #0x23
 800673e: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal use of the EPSR");
 8006740: 2303         	movs	r3, #0x3
 8006742: 2b00         	cmp	r3, #0x0
 8006744: d016         	beq	0x8006774 <usage_fault+0x1a8> @ imm = #0x2c
 8006746: 2301         	movs	r3, #0x1
 8006748: 76fb         	strb	r3, [r7, #0x1b]
 800674a: 7efb         	ldrb	r3, [r7, #0x1b]
 800674c: f083 0301    	eor	r3, r3, #0x1
 8006750: b2db         	uxtb	r3, r3
 8006752: 2b00         	cmp	r3, #0x0
 8006754: d10e         	bne	0x8006774 <usage_fault+0x1a8> @ imm = #0x1c
 8006756: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80067d4 <usage_fault+0x208>
 8006758: 6819         	ldr	r1, [r3]
 800675a: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80067f0 <usage_fault+0x224>
 800675c: 9302         	str	r3, [sp, #0x8]
 800675e: 2300         	movs	r3, #0x0
 8006760: 9301         	str	r3, [sp, #0x4]
 8006762: 2300         	movs	r3, #0x0
 8006764: 9300         	str	r3, [sp]
 8006766: 2300         	movs	r3, #0x0
 8006768: 2201         	movs	r2, #0x1
 800676a: 2000         	movs	r0, #0x0
 800676c: f011 f83a    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x11074
 8006770: 2300         	movs	r3, #0x0
 8006772: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 8006774: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80067dc <usage_fault+0x210>
 8006776: 6a9b         	ldr	r3, [r3, #0x28]
 8006778: f403 3380    	and	r3, r3, #0x10000
 800677c: 2b00         	cmp	r3, #0x0
 800677e: d01b         	beq	0x80067b8 <usage_fault+0x1ec> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
 8006780: 2324         	movs	r3, #0x24
 8006782: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Attempt to execute undefined instruction");
 8006784: 2303         	movs	r3, #0x3
 8006786: 2b00         	cmp	r3, #0x0
 8006788: d016         	beq	0x80067b8 <usage_fault+0x1ec> @ imm = #0x2c
 800678a: 2301         	movs	r3, #0x1
 800678c: 74fb         	strb	r3, [r7, #0x13]
 800678e: 7cfb         	ldrb	r3, [r7, #0x13]
 8006790: f083 0301    	eor	r3, r3, #0x1
 8006794: b2db         	uxtb	r3, r3
 8006796: 2b00         	cmp	r3, #0x0
 8006798: d10e         	bne	0x80067b8 <usage_fault+0x1ec> @ imm = #0x1c
 800679a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80067d4 <usage_fault+0x208>
 800679c: 6819         	ldr	r1, [r3]
 800679e: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80067f4 <usage_fault+0x228>
 80067a0: 9302         	str	r3, [sp, #0x8]
 80067a2: 2300         	movs	r3, #0x0
 80067a4: 9301         	str	r3, [sp, #0x4]
 80067a6: 2300         	movs	r3, #0x0
 80067a8: 9300         	str	r3, [sp]
 80067aa: 2300         	movs	r3, #0x0
 80067ac: 2201         	movs	r2, #0x1
 80067ae: 2000         	movs	r0, #0x0
 80067b0: f011 f818    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x11030
 80067b4: 2300         	movs	r3, #0x0
 80067b6: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 80067b8: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80067dc <usage_fault+0x210>
 80067ba: 6a9b         	ldr	r3, [r3, #0x28]
 80067bc: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80067dc <usage_fault+0x210>
 80067be: ea6f 4303    	mvn.w	r3, r3, lsl #16
 80067c2: ea6f 4313    	mvn.w	r3, r3, lsr #16
 80067c6: 6293         	str	r3, [r2, #0x28]
; 	return reason;
 80067c8: 6c7b         	ldr	r3, [r7, #0x44]
; }
 80067ca: 4618         	mov	r0, r3
 80067cc: 3748         	adds	r7, #0x48
 80067ce: 46bd         	mov	sp, r7
 80067d0: bd80         	pop	{r7, pc}
 80067d2: bf00         	nop

080067d4 <$d>:
 80067d4: 14 05 00 20  	.word	0x20000514
 80067d8: bc 0d 02 08  	.word	0x08020dbc
 80067dc: 00 ed 00 e0  	.word	0xe000ed00
 80067e0: d4 0d 02 08  	.word	0x08020dd4
 80067e4: e8 0d 02 08  	.word	0x08020de8
 80067e8: 04 0e 02 08  	.word	0x08020e04
 80067ec: 24 0e 02 08  	.word	0x08020e24
 80067f0: 4c 0e 02 08  	.word	0x08020e4c
 80067f4: 68 0e 02 08  	.word	0x08020e68

080067f8 <debug_monitor>:
; {
 80067f8: b580         	push	{r7, lr}
 80067fa: b088         	sub	sp, #0x20
 80067fc: af04         	add	r7, sp, #0x10
 80067fe: 6078         	str	r0, [r7, #0x4]
 8006800: 6039         	str	r1, [r7]
; 	*recoverable = false;
 8006802: 683b         	ldr	r3, [r7]
 8006804: 2200         	movs	r2, #0x0
 8006806: 701a         	strb	r2, [r3]
; 	PR_FAULT_INFO(
 8006808: 2303         	movs	r3, #0x3
 800680a: 2b00         	cmp	r3, #0x0
 800680c: d017         	beq	0x800683e <debug_monitor+0x46> @ imm = #0x2e
 800680e: 2301         	movs	r3, #0x1
 8006810: 73fb         	strb	r3, [r7, #0xf]
 8006812: 7bfb         	ldrb	r3, [r7, #0xf]
 8006814: f083 0301    	eor	r3, r3, #0x1
 8006818: b2db         	uxtb	r3, r3
 800681a: 2b00         	cmp	r3, #0x0
 800681c: d10f         	bne	0x800683e <debug_monitor+0x46> @ imm = #0x1e
 800681e: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8006848 <debug_monitor+0x50>
 8006820: 6819         	ldr	r1, [r3]
 8006822: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800684c <debug_monitor+0x54>
 8006824: 9302         	str	r3, [sp, #0x8]
 8006826: 2300         	movs	r3, #0x0
 8006828: 9301         	str	r3, [sp, #0x4]
 800682a: 2300         	movs	r3, #0x0
 800682c: 9300         	str	r3, [sp]
 800682e: 2300         	movs	r3, #0x0
 8006830: 2201         	movs	r2, #0x1
 8006832: 2000         	movs	r0, #0x0
 8006834: f010 ffd6    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x10fac
 8006838: 2300         	movs	r3, #0x0
 800683a: 60bb         	str	r3, [r7, #0x8]
; }
 800683c: bf00         	nop
 800683e: bf00         	nop
 8006840: 3710         	adds	r7, #0x10
 8006842: 46bd         	mov	sp, r7
 8006844: bd80         	pop	{r7, pc}
 8006846: bf00         	nop

08006848 <$d>:
 8006848: 14 05 00 20  	.word	0x20000514
 800684c: 94 0e 02 08  	.word	0x08020e94

08006850 <z_arm_is_synchronous_svc>:
; {
 8006850: b480         	push	{r7}
 8006852: b085         	sub	sp, #0x14
 8006854: af00         	add	r7, sp, #0x0
 8006856: 6078         	str	r0, [r7, #0x4]
; 	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
 8006858: 687b         	ldr	r3, [r7, #0x4]
 800685a: 699b         	ldr	r3, [r3, #0x18]
 800685c: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
 800685e: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x80068cc <z_arm_is_synchronous_svc+0x7c>
 8006860: 695b         	ldr	r3, [r3, #0x14]
 8006862: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x80068cc <z_arm_is_synchronous_svc+0x7c>
 8006864: f443 7380    	orr	r3, r3, #0x100
 8006868: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 800686a: f3bf 8f4f    	dsb	sy
; }
 800686e: bf00         	nop
; }
 8006870: bf00         	nop
; }
 8006872: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006874: f3bf 8f6f    	isb	sy
; }
 8006878: bf00         	nop
; }
 800687a: bf00         	nop
; }
 800687c: bf00         	nop
; 	uint16_t fault_insn = *(ret_addr - 1);
 800687e: 68fb         	ldr	r3, [r7, #0xc]
 8006880: f833 3c02    	ldrh	r3, [r3, #-2]
 8006884: 817b         	strh	r3, [r7, #0xa]
; 	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
 8006886: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80068cc <z_arm_is_synchronous_svc+0x7c>
 8006888: 695b         	ldr	r3, [r3, #0x14]
 800688a: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80068cc <z_arm_is_synchronous_svc+0x7c>
 800688c: f423 7380    	bic	r3, r3, #0x100
 8006890: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 8006892: f3bf 8f4f    	dsb	sy
; }
 8006896: bf00         	nop
; }
 8006898: bf00         	nop
; }
 800689a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800689c: f3bf 8f6f    	isb	sy
; }
 80068a0: bf00         	nop
; }
 80068a2: bf00         	nop
; }
 80068a4: bf00         	nop
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 80068a6: 897b         	ldrh	r3, [r7, #0xa]
 80068a8: f403 437f    	and	r3, r3, #0xff00
 80068ac: f5b3 4f5f    	cmp.w	r3, #0xdf00
 80068b0: d105         	bne	0x80068be <z_arm_is_synchronous_svc+0x6e> @ imm = #0xa
; 		((fault_insn & 0x00ff) == _SVC_CALL_RUNTIME_EXCEPT)) {
 80068b2: 897b         	ldrh	r3, [r7, #0xa]
 80068b4: b2db         	uxtb	r3, r3
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 80068b6: 2b02         	cmp	r3, #0x2
 80068b8: d101         	bne	0x80068be <z_arm_is_synchronous_svc+0x6e> @ imm = #0x2
; 		return true;
 80068ba: 2301         	movs	r3, #0x1
 80068bc: e000         	b	0x80068c0 <z_arm_is_synchronous_svc+0x70> @ imm = #0x0
; 	return false;
 80068be: 2300         	movs	r3, #0x0
; }
 80068c0: 4618         	mov	r0, r3
 80068c2: 3714         	adds	r7, #0x14
 80068c4: 46bd         	mov	sp, r7
 80068c6: f85d 7b04    	ldr	r7, [sp], #4
 80068ca: 4770         	bx	lr

080068cc <$d>:
 80068cc: 00 ed 00 e0  	.word	0xe000ed00

080068d0 <hard_fault>:
; {
 80068d0: b580         	push	{r7, lr}
 80068d2: b092         	sub	sp, #0x48
 80068d4: af04         	add	r7, sp, #0x10
 80068d6: 6078         	str	r0, [r7, #0x4]
 80068d8: 6039         	str	r1, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 80068da: 2300         	movs	r3, #0x0
 80068dc: 62fb         	str	r3, [r7, #0x2c]
; 	PR_FAULT_INFO("***** HARD FAULT *****");
 80068de: 2303         	movs	r3, #0x3
 80068e0: 2b00         	cmp	r3, #0x0
 80068e2: d018         	beq	0x8006916 <hard_fault+0x46> @ imm = #0x30
 80068e4: 2301         	movs	r3, #0x1
 80068e6: f887 3033    	strb.w	r3, [r7, #0x33]
 80068ea: f897 3033    	ldrb.w	r3, [r7, #0x33]
 80068ee: f083 0301    	eor	r3, r3, #0x1
 80068f2: b2db         	uxtb	r3, r3
 80068f4: 2b00         	cmp	r3, #0x0
 80068f6: d10e         	bne	0x8006916 <hard_fault+0x46> @ imm = #0x1c
 80068f8: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8006a88 <hard_fault+0x1b8>
 80068fa: 6819         	ldr	r1, [r3]
 80068fc: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8006a8c <hard_fault+0x1bc>
 80068fe: 9302         	str	r3, [sp, #0x8]
 8006900: 2300         	movs	r3, #0x0
 8006902: 9301         	str	r3, [sp, #0x4]
 8006904: 2300         	movs	r3, #0x0
 8006906: 9300         	str	r3, [sp]
 8006908: 2300         	movs	r3, #0x0
 800690a: 2201         	movs	r2, #0x1
 800690c: 2000         	movs	r0, #0x0
 800690e: f010 ff69    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x10ed2
 8006912: 2300         	movs	r3, #0x0
 8006914: 637b         	str	r3, [r7, #0x34]
; 	*recoverable = false;
 8006916: 683b         	ldr	r3, [r7]
 8006918: 2200         	movs	r2, #0x0
 800691a: 701a         	strb	r2, [r3]
; 	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 800691c: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8006a90 <hard_fault+0x1c0>
 800691e: 6adb         	ldr	r3, [r3, #0x2c]
 8006920: f003 0302    	and	r3, r3, #0x2
 8006924: 2b00         	cmp	r3, #0x0
 8006926: d01c         	beq	0x8006962 <hard_fault+0x92> @ imm = #0x38
; 		PR_EXC("  Bus fault on vector table read");
 8006928: 2303         	movs	r3, #0x3
 800692a: 2b00         	cmp	r3, #0x0
 800692c: f000 80a7    	beq.w	0x8006a7e <hard_fault+0x1ae> @ imm = #0x14e
 8006930: 2301         	movs	r3, #0x1
 8006932: 74fb         	strb	r3, [r7, #0x13]
 8006934: 7cfb         	ldrb	r3, [r7, #0x13]
 8006936: f083 0301    	eor	r3, r3, #0x1
 800693a: b2db         	uxtb	r3, r3
 800693c: 2b00         	cmp	r3, #0x0
 800693e: f040 809e    	bne.w	0x8006a7e <hard_fault+0x1ae> @ imm = #0x13c
 8006942: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8006a88 <hard_fault+0x1b8>
 8006944: 6819         	ldr	r1, [r3]
 8006946: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8006a94 <hard_fault+0x1c4>
 8006948: 9302         	str	r3, [sp, #0x8]
 800694a: 2300         	movs	r3, #0x0
 800694c: 9301         	str	r3, [sp, #0x4]
 800694e: 2300         	movs	r3, #0x0
 8006950: 9300         	str	r3, [sp]
 8006952: 2300         	movs	r3, #0x0
 8006954: 2201         	movs	r2, #0x1
 8006956: 2000         	movs	r0, #0x0
 8006958: f010 ff44    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x10e88
 800695c: 2300         	movs	r3, #0x0
 800695e: 60fb         	str	r3, [r7, #0xc]
 8006960: e08d         	b	0x8006a7e <hard_fault+0x1ae> @ imm = #0x11a
; 	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
 8006962: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8006a90 <hard_fault+0x1c0>
 8006964: 6adb         	ldr	r3, [r3, #0x2c]
 8006966: 2b00         	cmp	r3, #0x0
 8006968: da1b         	bge	0x80069a2 <hard_fault+0xd2> @ imm = #0x36
; 		PR_EXC("  Debug event");
 800696a: 2303         	movs	r3, #0x3
 800696c: 2b00         	cmp	r3, #0x0
 800696e: f000 8086    	beq.w	0x8006a7e <hard_fault+0x1ae> @ imm = #0x10c
 8006972: 2301         	movs	r3, #0x1
 8006974: 76fb         	strb	r3, [r7, #0x1b]
 8006976: 7efb         	ldrb	r3, [r7, #0x1b]
 8006978: f083 0301    	eor	r3, r3, #0x1
 800697c: b2db         	uxtb	r3, r3
 800697e: 2b00         	cmp	r3, #0x0
 8006980: d17d         	bne	0x8006a7e <hard_fault+0x1ae> @ imm = #0xfa
 8006982: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8006a88 <hard_fault+0x1b8>
 8006984: 6819         	ldr	r1, [r3]
 8006986: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8006a98 <hard_fault+0x1c8>
 8006988: 9302         	str	r3, [sp, #0x8]
 800698a: 2300         	movs	r3, #0x0
 800698c: 9301         	str	r3, [sp, #0x4]
 800698e: 2300         	movs	r3, #0x0
 8006990: 9300         	str	r3, [sp]
 8006992: 2300         	movs	r3, #0x0
 8006994: 2201         	movs	r2, #0x1
 8006996: 2000         	movs	r0, #0x0
 8006998: f010 ff24    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x10e48
 800699c: 2300         	movs	r3, #0x0
 800699e: 617b         	str	r3, [r7, #0x14]
 80069a0: e06d         	b	0x8006a7e <hard_fault+0x1ae> @ imm = #0xda
; 	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 80069a2: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8006a90 <hard_fault+0x1c0>
 80069a4: 6adb         	ldr	r3, [r3, #0x2c]
 80069a6: f003 4380    	and	r3, r3, #0x40000000
 80069aa: 2b00         	cmp	r3, #0x0
 80069ac: d067         	beq	0x8006a7e <hard_fault+0x1ae> @ imm = #0xce
; 		PR_EXC("  Fault escalation (see below)");
 80069ae: 2303         	movs	r3, #0x3
 80069b0: 2b00         	cmp	r3, #0x0
 80069b2: d018         	beq	0x80069e6 <hard_fault+0x116> @ imm = #0x30
 80069b4: 2301         	movs	r3, #0x1
 80069b6: f887 302b    	strb.w	r3, [r7, #0x2b]
 80069ba: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80069be: f083 0301    	eor	r3, r3, #0x1
 80069c2: b2db         	uxtb	r3, r3
 80069c4: 2b00         	cmp	r3, #0x0
 80069c6: d10e         	bne	0x80069e6 <hard_fault+0x116> @ imm = #0x1c
 80069c8: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8006a88 <hard_fault+0x1b8>
 80069ca: 6819         	ldr	r1, [r3]
 80069cc: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8006a9c <hard_fault+0x1cc>
 80069ce: 9302         	str	r3, [sp, #0x8]
 80069d0: 2300         	movs	r3, #0x0
 80069d2: 9301         	str	r3, [sp, #0x4]
 80069d4: 2300         	movs	r3, #0x0
 80069d6: 9300         	str	r3, [sp]
 80069d8: 2300         	movs	r3, #0x0
 80069da: 2201         	movs	r2, #0x1
 80069dc: 2000         	movs	r0, #0x0
 80069de: f010 ff01    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x10e02
 80069e2: 2300         	movs	r3, #0x0
 80069e4: 627b         	str	r3, [r7, #0x24]
; 		if (z_arm_is_synchronous_svc(esf)) {
 80069e6: 6878         	ldr	r0, [r7, #0x4]
 80069e8: f7ff ff32    	bl	0x8006850 <z_arm_is_synchronous_svc> @ imm = #-0x19c
 80069ec: 4603         	mov	r3, r0
 80069ee: 2b00         	cmp	r3, #0x0
 80069f0: d022         	beq	0x8006a38 <hard_fault+0x168> @ imm = #0x44
; 			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
 80069f2: 2303         	movs	r3, #0x3
 80069f4: 2b00         	cmp	r3, #0x0
 80069f6: d01b         	beq	0x8006a30 <hard_fault+0x160> @ imm = #0x36
 80069f8: 2301         	movs	r3, #0x1
 80069fa: f887 3023    	strb.w	r3, [r7, #0x23]
 80069fe: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8006a02: f083 0301    	eor	r3, r3, #0x1
 8006a06: b2db         	uxtb	r3, r3
 8006a08: 2b00         	cmp	r3, #0x0
 8006a0a: d111         	bne	0x8006a30 <hard_fault+0x160> @ imm = #0x22
 8006a0c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8006a88 <hard_fault+0x1b8>
 8006a0e: 6819         	ldr	r1, [r3]
 8006a10: 687b         	ldr	r3, [r7, #0x4]
 8006a12: 681b         	ldr	r3, [r3]
 8006a14: 9303         	str	r3, [sp, #0xc]
 8006a16: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8006aa0 <hard_fault+0x1d0>
 8006a18: 9302         	str	r3, [sp, #0x8]
 8006a1a: 2300         	movs	r3, #0x0
 8006a1c: 9301         	str	r3, [sp, #0x4]
 8006a1e: 2300         	movs	r3, #0x0
 8006a20: 9300         	str	r3, [sp]
 8006a22: 2300         	movs	r3, #0x0
 8006a24: 2201         	movs	r2, #0x1
 8006a26: 2000         	movs	r0, #0x0
 8006a28: f010 fedc    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x10db8
 8006a2c: 2300         	movs	r3, #0x0
 8006a2e: 61fb         	str	r3, [r7, #0x1c]
; 			reason = esf->basic.r0;
 8006a30: 687b         	ldr	r3, [r7, #0x4]
 8006a32: 681b         	ldr	r3, [r3]
 8006a34: 62fb         	str	r3, [r7, #0x2c]
 8006a36: e022         	b	0x8006a7e <hard_fault+0x1ae> @ imm = #0x44
; 		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
 8006a38: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8006a90 <hard_fault+0x1c0>
 8006a3a: 6a9b         	ldr	r3, [r3, #0x28]
 8006a3c: b2db         	uxtb	r3, r3
 8006a3e: 2b00         	cmp	r3, #0x0
 8006a40: d006         	beq	0x8006a50 <hard_fault+0x180> @ imm = #0xc
; 			reason = mem_manage_fault(esf, 1, recoverable);
 8006a42: 683a         	ldr	r2, [r7]
 8006a44: 2101         	movs	r1, #0x1
 8006a46: 6878         	ldr	r0, [r7, #0x4]
 8006a48: f7ff fb2c    	bl	0x80060a4 <mem_manage_fault> @ imm = #-0x9a8
 8006a4c: 62f8         	str	r0, [r7, #0x2c]
 8006a4e: e016         	b	0x8006a7e <hard_fault+0x1ae> @ imm = #0x2c
; 		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
 8006a50: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8006a90 <hard_fault+0x1c0>
 8006a52: 6a9b         	ldr	r3, [r3, #0x28]
 8006a54: f403 437f    	and	r3, r3, #0xff00
 8006a58: 2b00         	cmp	r3, #0x0
 8006a5a: d007         	beq	0x8006a6c <hard_fault+0x19c> @ imm = #0xe
; 			reason = bus_fault(esf, 1, recoverable);
 8006a5c: 683a         	ldr	r2, [r7]
 8006a5e: 2101         	movs	r1, #0x1
 8006a60: 6878         	ldr	r0, [r7, #0x4]
 8006a62: f7ff fc63    	bl	0x800632c <bus_fault>   @ imm = #-0x73a
 8006a66: 4603         	mov	r3, r0
 8006a68: 62fb         	str	r3, [r7, #0x2c]
 8006a6a: e008         	b	0x8006a7e <hard_fault+0x1ae> @ imm = #0x10
; 		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
 8006a6c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8006a90 <hard_fault+0x1c0>
 8006a6e: 6a9b         	ldr	r3, [r3, #0x28]
 8006a70: f5b3 3f80    	cmp.w	r3, #0x10000
 8006a74: d303         	blo	0x8006a7e <hard_fault+0x1ae> @ imm = #0x6
; 			reason = usage_fault(esf);
 8006a76: 6878         	ldr	r0, [r7, #0x4]
 8006a78: f7ff fda8    	bl	0x80065cc <usage_fault> @ imm = #-0x4b0
 8006a7c: 62f8         	str	r0, [r7, #0x2c]
; 	return reason;
 8006a7e: 6afb         	ldr	r3, [r7, #0x2c]
; }
 8006a80: 4618         	mov	r0, r3
 8006a82: 3738         	adds	r7, #0x38
 8006a84: 46bd         	mov	sp, r7
 8006a86: bd80         	pop	{r7, pc}

08006a88 <$d>:
 8006a88: 14 05 00 20  	.word	0x20000514
 8006a8c: b8 0e 02 08  	.word	0x08020eb8
 8006a90: 00 ed 00 e0  	.word	0xe000ed00
 8006a94: d0 0e 02 08  	.word	0x08020ed0
 8006a98: f4 0e 02 08  	.word	0x08020ef4
 8006a9c: 04 0f 02 08  	.word	0x08020f04
 8006aa0: 24 0f 02 08  	.word	0x08020f24

08006aa4 <reserved_exception>:
; {
 8006aa4: b580         	push	{r7, lr}
 8006aa6: b08a         	sub	sp, #0x28
 8006aa8: af06         	add	r7, sp, #0x18
 8006aaa: 6078         	str	r0, [r7, #0x4]
 8006aac: 6039         	str	r1, [r7]
; 	PR_FAULT_INFO("***** %s %d) *****",
 8006aae: 2303         	movs	r3, #0x3
 8006ab0: 2b00         	cmp	r3, #0x0
 8006ab2: d021         	beq	0x8006af8 <reserved_exception+0x54> @ imm = #0x42
 8006ab4: 2301         	movs	r3, #0x1
 8006ab6: 73fb         	strb	r3, [r7, #0xf]
 8006ab8: 7bfb         	ldrb	r3, [r7, #0xf]
 8006aba: f083 0301    	eor	r3, r3, #0x1
 8006abe: b2db         	uxtb	r3, r3
 8006ac0: 2b00         	cmp	r3, #0x0
 8006ac2: d119         	bne	0x8006af8 <reserved_exception+0x54> @ imm = #0x32
 8006ac4: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8006b00 <reserved_exception+0x5c>
 8006ac6: 6819         	ldr	r1, [r3]
 8006ac8: 683b         	ldr	r3, [r7]
 8006aca: 2b0f         	cmp	r3, #0xf
 8006acc: dc01         	bgt	0x8006ad2 <reserved_exception+0x2e> @ imm = #0x2
 8006ace: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8006b04 <reserved_exception+0x60>
 8006ad0: e000         	b	0x8006ad4 <reserved_exception+0x30> @ imm = #0x0
 8006ad2: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8006b08 <reserved_exception+0x64>
 8006ad4: 683a         	ldr	r2, [r7]
 8006ad6: 3a10         	subs	r2, #0x10
 8006ad8: 9204         	str	r2, [sp, #0x10]
 8006ada: 9303         	str	r3, [sp, #0xc]
 8006adc: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8006b0c <reserved_exception+0x68>
 8006ade: 9302         	str	r3, [sp, #0x8]
 8006ae0: 2300         	movs	r3, #0x0
 8006ae2: 9301         	str	r3, [sp, #0x4]
 8006ae4: 2300         	movs	r3, #0x0
 8006ae6: 9300         	str	r3, [sp]
 8006ae8: 2300         	movs	r3, #0x0
 8006aea: 2201         	movs	r2, #0x1
 8006aec: 2000         	movs	r0, #0x0
 8006aee: f010 fe79    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x10cf2
 8006af2: 2300         	movs	r3, #0x0
 8006af4: 60bb         	str	r3, [r7, #0x8]
; }
 8006af6: bf00         	nop
 8006af8: bf00         	nop
 8006afa: 3710         	adds	r7, #0x10
 8006afc: 46bd         	mov	sp, r7
 8006afe: bd80         	pop	{r7, pc}

08006b00 <$d>:
 8006b00: 14 05 00 20  	.word	0x20000514
 8006b04: 40 0f 02 08  	.word	0x08020f40
 8006b08: 58 0f 02 08  	.word	0x08020f58
 8006b0c: 74 0f 02 08  	.word	0x08020f74

08006b10 <fault_handle>:
; {
 8006b10: b580         	push	{r7, lr}
 8006b12: b086         	sub	sp, #0x18
 8006b14: af00         	add	r7, sp, #0x0
 8006b16: 60f8         	str	r0, [r7, #0xc]
 8006b18: 60b9         	str	r1, [r7, #0x8]
 8006b1a: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8006b1c: 2300         	movs	r3, #0x0
 8006b1e: 617b         	str	r3, [r7, #0x14]
; 	*recoverable = false;
 8006b20: 687b         	ldr	r3, [r7, #0x4]
 8006b22: 2200         	movs	r2, #0x0
 8006b24: 701a         	strb	r2, [r3]
; 	switch (fault) {
 8006b26: 68bb         	ldr	r3, [r7, #0x8]
 8006b28: 3b03         	subs	r3, #0x3
 8006b2a: 2b09         	cmp	r3, #0x9
 8006b2c: d835         	bhi	0x8006b9a <fault_handle+0x8a> @ imm = #0x6a
 8006b2e: a201         	adr	r2, #4 <fault_handle+0x23>
 8006b30: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08006b34 <$d>:
 8006b34: 5d 6b 00 08  	.word	0x08006b5d
 8006b38: 69 6b 00 08  	.word	0x08006b69
 8006b3c: 77 6b 00 08  	.word	0x08006b77
 8006b40: 87 6b 00 08  	.word	0x08006b87
 8006b44: 9b 6b 00 08  	.word	0x08006b9b
 8006b48: 9b 6b 00 08  	.word	0x08006b9b
 8006b4c: 9b 6b 00 08  	.word	0x08006b9b
 8006b50: 9b 6b 00 08  	.word	0x08006b9b
 8006b54: 9b 6b 00 08  	.word	0x08006b9b
 8006b58: 91 6b 00 08  	.word	0x08006b91

08006b5c <$t>:
; 		reason = hard_fault(esf, recoverable);
 8006b5c: 6879         	ldr	r1, [r7, #0x4]
 8006b5e: 68f8         	ldr	r0, [r7, #0xc]
 8006b60: f7ff feb6    	bl	0x80068d0 <hard_fault>  @ imm = #-0x294
 8006b64: 6178         	str	r0, [r7, #0x14]
; 		break;
 8006b66: e01d         	b	0x8006ba4 <fault_handle+0x94> @ imm = #0x3a
; 		reason = mem_manage_fault(esf, 0, recoverable);
 8006b68: 687a         	ldr	r2, [r7, #0x4]
 8006b6a: 2100         	movs	r1, #0x0
 8006b6c: 68f8         	ldr	r0, [r7, #0xc]
 8006b6e: f7ff fa99    	bl	0x80060a4 <mem_manage_fault> @ imm = #-0xace
 8006b72: 6178         	str	r0, [r7, #0x14]
; 		break;
 8006b74: e016         	b	0x8006ba4 <fault_handle+0x94> @ imm = #0x2c
; 		reason = bus_fault(esf, 0, recoverable);
 8006b76: 687a         	ldr	r2, [r7, #0x4]
 8006b78: 2100         	movs	r1, #0x0
 8006b7a: 68f8         	ldr	r0, [r7, #0xc]
 8006b7c: f7ff fbd6    	bl	0x800632c <bus_fault>   @ imm = #-0x854
 8006b80: 4603         	mov	r3, r0
 8006b82: 617b         	str	r3, [r7, #0x14]
; 		break;
 8006b84: e00e         	b	0x8006ba4 <fault_handle+0x94> @ imm = #0x1c
; 		reason = usage_fault(esf);
 8006b86: 68f8         	ldr	r0, [r7, #0xc]
 8006b88: f7ff fd20    	bl	0x80065cc <usage_fault> @ imm = #-0x5c0
 8006b8c: 6178         	str	r0, [r7, #0x14]
; 		break;
 8006b8e: e009         	b	0x8006ba4 <fault_handle+0x94> @ imm = #0x12
; 		debug_monitor(esf, recoverable);
 8006b90: 6879         	ldr	r1, [r7, #0x4]
 8006b92: 68f8         	ldr	r0, [r7, #0xc]
 8006b94: f7ff fe30    	bl	0x80067f8 <debug_monitor> @ imm = #-0x3a0
; 		break;
 8006b98: e004         	b	0x8006ba4 <fault_handle+0x94> @ imm = #0x8
; 		reserved_exception(esf, fault);
 8006b9a: 68b9         	ldr	r1, [r7, #0x8]
 8006b9c: 68f8         	ldr	r0, [r7, #0xc]
 8006b9e: f7ff ff81    	bl	0x8006aa4 <reserved_exception> @ imm = #-0xfe
; 		break;
 8006ba2: bf00         	nop
; 	if ((*recoverable) == false) {
 8006ba4: 687b         	ldr	r3, [r7, #0x4]
 8006ba6: 781b         	ldrb	r3, [r3]
 8006ba8: f083 0301    	eor	r3, r3, #0x1
 8006bac: b2db         	uxtb	r3, r3
 8006bae: 2b00         	cmp	r3, #0x0
 8006bb0: d003         	beq	0x8006bba <fault_handle+0xaa> @ imm = #0x6
; 		fault_show(esf, fault);
 8006bb2: 68b9         	ldr	r1, [r7, #0x8]
 8006bb4: 68f8         	ldr	r0, [r7, #0xc]
 8006bb6: f010 fe33    	bl	0x8017820 <fault_show>  @ imm = #0x10c66
; 	return reason;
 8006bba: 697b         	ldr	r3, [r7, #0x14]
; }
 8006bbc: 4618         	mov	r0, r3
 8006bbe: 3718         	adds	r7, #0x18
 8006bc0: 46bd         	mov	sp, r7
 8006bc2: bd80         	pop	{r7, pc}

08006bc4 <get_esf>:
; {
 8006bc4: b580         	push	{r7, lr}
 8006bc6: b08c         	sub	sp, #0x30
 8006bc8: af04         	add	r7, sp, #0x10
 8006bca: 60f8         	str	r0, [r7, #0xc]
 8006bcc: 60b9         	str	r1, [r7, #0x8]
 8006bce: 607a         	str	r2, [r7, #0x4]
 8006bd0: 603b         	str	r3, [r7]
; 	bool alternative_state_exc = false;
 8006bd2: 2300         	movs	r3, #0x0
 8006bd4: 76fb         	strb	r3, [r7, #0x1b]
; 	struct arch_esf *ptr_esf = NULL;
 8006bd6: 2300         	movs	r3, #0x0
 8006bd8: 61fb         	str	r3, [r7, #0x1c]
; 	*nested_exc = false;
 8006bda: 683b         	ldr	r3, [r7]
 8006bdc: 2200         	movs	r2, #0x0
 8006bde: 701a         	strb	r2, [r3]
; 	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 8006be0: 687b         	ldr	r3, [r7, #0x4]
 8006be2: f003 437f    	and	r3, r3, #0xff000000
 8006be6: f1b3 4f7f    	cmp.w	r3, #0xff000000
 8006bea: d001         	beq	0x8006bf0 <get_esf+0x2c> @ imm = #0x2
; 		return NULL;
 8006bec: 2300         	movs	r3, #0x0
 8006bee: e039         	b	0x8006c64 <get_esf+0xa0> @ imm = #0x72
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 8006bf0: 687b         	ldr	r3, [r7, #0x4]
 8006bf2: f003 0308    	and	r3, r3, #0x8
 8006bf6: 2b00         	cmp	r3, #0x0
 8006bf8: d020         	beq	0x8006c3c <get_esf+0x78> @ imm = #0x40
; 		(!(exc_return & EXC_RETURN_SPSEL_PROCESS))) {
 8006bfa: 687b         	ldr	r3, [r7, #0x4]
 8006bfc: f003 0304    	and	r3, r3, #0x4
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 8006c00: 2b00         	cmp	r3, #0x0
 8006c02: d11b         	bne	0x8006c3c <get_esf+0x78> @ imm = #0x36
; 		PR_EXC("SPSEL in thread mode does not indicate PSP");
 8006c04: 2303         	movs	r3, #0x3
 8006c06: 2b00         	cmp	r3, #0x0
 8006c08: d016         	beq	0x8006c38 <get_esf+0x74> @ imm = #0x2c
 8006c0a: 2301         	movs	r3, #0x1
 8006c0c: 76bb         	strb	r3, [r7, #0x1a]
 8006c0e: 7ebb         	ldrb	r3, [r7, #0x1a]
 8006c10: f083 0301    	eor	r3, r3, #0x1
 8006c14: b2db         	uxtb	r3, r3
 8006c16: 2b00         	cmp	r3, #0x0
 8006c18: d10e         	bne	0x8006c38 <get_esf+0x74> @ imm = #0x1c
 8006c1a: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8006c6c <get_esf+0xa8>
 8006c1c: 6819         	ldr	r1, [r3]
 8006c1e: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8006c70 <get_esf+0xac>
 8006c20: 9302         	str	r3, [sp, #0x8]
 8006c22: 2300         	movs	r3, #0x0
 8006c24: 9301         	str	r3, [sp, #0x4]
 8006c26: 2300         	movs	r3, #0x0
 8006c28: 9300         	str	r3, [sp]
 8006c2a: 2300         	movs	r3, #0x0
 8006c2c: 2201         	movs	r2, #0x1
 8006c2e: 2000         	movs	r0, #0x0
 8006c30: f010 fdd8    	bl	0x80177e4 <z_log_msg_runtime_create> @ imm = #0x10bb0
 8006c34: 2300         	movs	r3, #0x0
 8006c36: 617b         	str	r3, [r7, #0x14]
; 		return NULL;
 8006c38: 2300         	movs	r3, #0x0
 8006c3a: e013         	b	0x8006c64 <get_esf+0xa0> @ imm = #0x26
; 	if (!alternative_state_exc) {
 8006c3c: 7efb         	ldrb	r3, [r7, #0x1b]
 8006c3e: f083 0301    	eor	r3, r3, #0x1
 8006c42: b2db         	uxtb	r3, r3
 8006c44: 2b00         	cmp	r3, #0x0
 8006c46: d00c         	beq	0x8006c62 <get_esf+0x9e> @ imm = #0x18
; 		if (exc_return & EXC_RETURN_MODE_THREAD) {
 8006c48: 687b         	ldr	r3, [r7, #0x4]
 8006c4a: f003 0308    	and	r3, r3, #0x8
 8006c4e: 2b00         	cmp	r3, #0x0
 8006c50: d002         	beq	0x8006c58 <get_esf+0x94> @ imm = #0x4
; 			ptr_esf =  (struct arch_esf *)psp;
 8006c52: 68bb         	ldr	r3, [r7, #0x8]
 8006c54: 61fb         	str	r3, [r7, #0x1c]
 8006c56: e004         	b	0x8006c62 <get_esf+0x9e> @ imm = #0x8
; 			ptr_esf = (struct arch_esf *)msp;
 8006c58: 68fb         	ldr	r3, [r7, #0xc]
 8006c5a: 61fb         	str	r3, [r7, #0x1c]
; 			*nested_exc = true;
 8006c5c: 683b         	ldr	r3, [r7]
 8006c5e: 2201         	movs	r2, #0x1
 8006c60: 701a         	strb	r2, [r3]
; 	return ptr_esf;
 8006c62: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8006c64: 4618         	mov	r0, r3
 8006c66: 3720         	adds	r7, #0x20
 8006c68: 46bd         	mov	sp, r7
 8006c6a: bd80         	pop	{r7, pc}

08006c6c <$d>:
 8006c6c: 14 05 00 20  	.word	0x20000514
 8006c70: 88 0f 02 08  	.word	0x08020f88

08006c74 <z_arm_fault>:
; {
 8006c74: b580         	push	{r7, lr}
 8006c76: b0a6         	sub	sp, #0x98
 8006c78: af00         	add	r7, sp, #0x0
 8006c7a: 60f8         	str	r0, [r7, #0xc]
 8006c7c: 60b9         	str	r1, [r7, #0x8]
 8006c7e: 607a         	str	r2, [r7, #0x4]
 8006c80: 603b         	str	r3, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8006c82: 2300         	movs	r3, #0x0
 8006c84: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 8006c88: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8006d44 <z_arm_fault+0xd0>
 8006c8a: 685b         	ldr	r3, [r3, #0x4]
 8006c8c: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8006c90: f8c7 3090    	str.w	r3, [r7, #0x90]
 8006c94: 2300         	movs	r3, #0x0
 8006c96: f8c7 3080    	str.w	r3, [r7, #0x80]
 8006c9a: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8006c9e: 67fb         	str	r3, [r7, #0x7c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006ca0: 6ffb         	ldr	r3, [r7, #0x7c]
 8006ca2: f383 8811    	msr	basepri, r3
; }
 8006ca6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006ca8: f3bf 8f6f    	isb	sy
; }
 8006cac: bf00         	nop
; }
 8006cae: bf00         	nop
; 	 esf = get_esf(msp, psp, exc_return, &nested_exc);
 8006cb0: f107 037a    	add.w	r3, r7, #0x7a
 8006cb4: 687a         	ldr	r2, [r7, #0x4]
 8006cb6: 68b9         	ldr	r1, [r7, #0x8]
 8006cb8: 68f8         	ldr	r0, [r7, #0xc]
 8006cba: f7ff ff83    	bl	0x8006bc4 <get_esf>     @ imm = #-0xfa
 8006cbe: f8c7 008c    	str.w	r0, [r7, #0x8c]
 8006cc2: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8006cc6: f8c7 3088    	str.w	r3, [r7, #0x88]
 8006cca: 687b         	ldr	r3, [r7, #0x4]
 8006ccc: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 8006cd0: bf00         	nop
; 	reason = fault_handle(esf, fault, &recoverable);
 8006cd2: f107 037b    	add.w	r3, r7, #0x7b
 8006cd6: 461a         	mov	r2, r3
 8006cd8: f8d7 1090    	ldr.w	r1, [r7, #0x90]
 8006cdc: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 8006ce0: f7ff ff16    	bl	0x8006b10 <fault_handle> @ imm = #-0x1d4
 8006ce4: f8c7 0094    	str.w	r0, [r7, #0x94]
; 	if (recoverable) {
 8006ce8: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 8006cec: 2b00         	cmp	r3, #0x0
 8006cee: d125         	bne	0x8006d3c <z_arm_fault+0xc8> @ imm = #0x4a
; 	memcpy(&esf_copy, esf, sizeof(struct arch_esf));
 8006cf0: f107 0310    	add.w	r3, r7, #0x10
 8006cf4: 2268         	movs	r2, #0x68
 8006cf6: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8006cfa: 4618         	mov	r0, r3
 8006cfc: f018 ffde    	bl	0x801fcbc <memcpy>      @ imm = #0x18fbc
; 	if (nested_exc) {
 8006d00: f897 307a    	ldrb.w	r3, [r7, #0x7a]
 8006d04: 2b00         	cmp	r3, #0x0
 8006d06: d00b         	beq	0x8006d20 <z_arm_fault+0xac> @ imm = #0x16
; 		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 8006d08: 6afb         	ldr	r3, [r7, #0x2c]
 8006d0a: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8006d0e: 2b00         	cmp	r3, #0x0
 8006d10: d10c         	bne	0x8006d2c <z_arm_fault+0xb8> @ imm = #0x18
; 			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 8006d12: 6afb         	ldr	r3, [r7, #0x2c]
 8006d14: ea6f 2353    	mvn.w	r3, r3, lsr #9
 8006d18: ea6f 2343    	mvn.w	r3, r3, lsl #9
 8006d1c: 62fb         	str	r3, [r7, #0x2c]
 8006d1e: e005         	b	0x8006d2c <z_arm_fault+0xb8> @ imm = #0xa
; 		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 8006d20: 6afb         	ldr	r3, [r7, #0x2c]
 8006d22: f423 73ff    	bic	r3, r3, #0x1fe
 8006d26: f023 0301    	bic	r3, r3, #0x1
 8006d2a: 62fb         	str	r3, [r7, #0x2c]
; 	z_arm_fatal_error(reason, &esf_copy);
 8006d2c: f107 0310    	add.w	r3, r7, #0x10
 8006d30: 4619         	mov	r1, r3
 8006d32: f8d7 0094    	ldr.w	r0, [r7, #0x94]
 8006d36: f7ff f91f    	bl	0x8005f78 <z_arm_fatal_error> @ imm = #-0xdc2
 8006d3a: e000         	b	0x8006d3e <z_arm_fault+0xca> @ imm = #0x0
; 		return;
 8006d3c: bf00         	nop
; }
 8006d3e: 3798         	adds	r7, #0x98
 8006d40: 46bd         	mov	sp, r7
 8006d42: bd80         	pop	{r7, pc}

08006d44 <$d>:
 8006d44: 00 ed 00 e0  	.word	0xe000ed00

08006d48 <z_arm_fault_init>:
; {
 8006d48: b480         	push	{r7}
 8006d4a: af00         	add	r7, sp, #0x0
; 	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 8006d4c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8006d70 <z_arm_fault_init+0x28>
 8006d4e: 695b         	ldr	r3, [r3, #0x14]
 8006d50: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8006d70 <z_arm_fault_init+0x28>
 8006d52: f043 0310    	orr	r3, r3, #0x10
 8006d56: 6153         	str	r3, [r2, #0x14]
; 	SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk;
 8006d58: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8006d70 <z_arm_fault_init+0x28>
 8006d5a: 695b         	ldr	r3, [r3, #0x14]
 8006d5c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8006d70 <z_arm_fault_init+0x28>
 8006d5e: f023 0308    	bic	r3, r3, #0x8
 8006d62: 6153         	str	r3, [r2, #0x14]
; }
 8006d64: bf00         	nop
 8006d66: 46bd         	mov	sp, r7
 8006d68: f85d 7b04    	ldr	r7, [sp], #4
 8006d6c: 4770         	bx	lr
 8006d6e: bf00         	nop

08006d70 <$d>:
 8006d70: 00 ed 00 e0  	.word	0xe000ed00

08006d74 <z_arm_usage_fault>:
; 	mrs r0, MSP
 8006d74: f3ef 8008    	mrs	r0, msp
; 	mrs r1, PSP
 8006d78: f3ef 8109    	mrs	r1, psp
; 	push {r0, lr}
 8006d7c: b501         	push	{r0, lr}
; 	mov r2, lr /* EXC_RETURN */
 8006d7e: 4672         	mov	r2, lr
; 	bl z_arm_fault
 8006d80: f7ff ff78    	bl	0x8006c74 <z_arm_fault> @ imm = #-0x110
; 	pop {r0, pc}
 8006d84: bd01         	pop	{r0, pc}
 8006d86: bf00         	nop

08006d88 <z_arm_reset>:
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8006d88: 2010         	movs	r0, #0x10
;     msr BASEPRI, r0
 8006d8a: f380 8811    	msr	basepri, r0
;     ldr r0, =z_interrupt_stacks
 8006d8e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8006dbc <z_arm_reset+0x34>
;     ldr r1, =0xaa
 8006d90: f04f 01aa    	mov.w	r1, #0xaa
;     ldr r2, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 8006d94: f44f 6200    	mov.w	r2, #0x800
;     bl z_early_memset
 8006d98: f017 f9fd    	bl	0x801e196 <z_early_memset> @ imm = #0x173fa
;     ldr r0, =z_interrupt_stacks
 8006d9c: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8006dbc <z_arm_reset+0x34>
;     ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 8006d9e: f44f 6100    	mov.w	r1, #0x800
;     adds r0, r0, r1
 8006da2: 1840         	adds	r0, r0, r1
;     msr PSP, r0
 8006da4: f380 8809    	msr	psp, r0
;     mrs r0, CONTROL
 8006da8: f3ef 8014    	mrs	r0, control
;     movs r1, #2
 8006dac: 2102         	movs	r1, #0x2
;     orrs r0, r1 /* CONTROL_SPSEL_Msk */
 8006dae: 4308         	orrs	r0, r1
;     msr CONTROL, r0
 8006db0: f380 8814    	msr	control, r0
;     isb
 8006db4: f3bf 8f6f    	isb	sy
;     bl z_prep_c
 8006db8: f010 fd76    	bl	0x80178a8 <z_prep_c>    @ imm = #0x10aec

08006dbc <$d>:
 8006dbc: 40 42 00 20  	.word	0x20004240

08006dc0 <z_impl_k_thread_abort>:
; {
 8006dc0: b580         	push	{r7, lr}
 8006dc2: b084         	sub	sp, #0x10
 8006dc4: af00         	add	r7, sp, #0x0
 8006dc6: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8006dc8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8006e14 <z_impl_k_thread_abort+0x54>
 8006dca: 689b         	ldr	r3, [r3, #0x8]
 8006dcc: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8006dce: 68fb         	ldr	r3, [r7, #0xc]
; 	if (arch_current_thread() == thread) {
 8006dd0: 687a         	ldr	r2, [r7, #0x4]
 8006dd2: 429a         	cmp	r2, r3
 8006dd4: d116         	bne	0x8006e04 <z_impl_k_thread_abort+0x44> @ imm = #0x2c
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8006dd6: f3ef 8305    	mrs	r3, ipsr
 8006dda: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 8006ddc: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 8006dde: 2b00         	cmp	r3, #0x0
 8006de0: bf14         	ite	ne
 8006de2: 2301         	movne	r3, #0x1
 8006de4: 2300         	moveq	r3, #0x0
 8006de6: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 8006de8: 2b00         	cmp	r3, #0x0
 8006dea: d00b         	beq	0x8006e04 <z_impl_k_thread_abort+0x44> @ imm = #0x16
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8006dec: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8006e18 <z_impl_k_thread_abort+0x58>
 8006dee: 685b         	ldr	r3, [r3, #0x4]
 8006df0: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8006e18 <z_impl_k_thread_abort+0x58>
 8006df2: f043 5380    	orr	r3, r3, #0x10000000
 8006df6: 6053         	str	r3, [r2, #0x4]
; 			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
 8006df8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8006e18 <z_impl_k_thread_abort+0x58>
 8006dfa: 6a5b         	ldr	r3, [r3, #0x24]
 8006dfc: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8006e18 <z_impl_k_thread_abort+0x58>
 8006dfe: f423 4300    	bic	r3, r3, #0x8000
 8006e02: 6253         	str	r3, [r2, #0x24]
; 	z_thread_abort(thread);
 8006e04: 6878         	ldr	r0, [r7, #0x4]
 8006e06: f00b fb1d    	bl	0x8012444 <z_thread_abort> @ imm = #0xb63a
; }
 8006e0a: bf00         	nop
 8006e0c: 3710         	adds	r7, #0x10
 8006e0e: 46bd         	mov	sp, r7
 8006e10: bd80         	pop	{r7, pc}
 8006e12: bf00         	nop

08006e14 <$d>:
 8006e14: 48 1d 00 20  	.word	0x20001d48
 8006e18: 00 ed 00 e0  	.word	0xe000ed00

08006e1c <arch_swap>:
; {
 8006e1c: b480         	push	{r7}
 8006e1e: b089         	sub	sp, #0x24
 8006e20: af00         	add	r7, sp, #0x0
 8006e22: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8006e24: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8006e80 <arch_swap+0x64>
 8006e26: 689b         	ldr	r3, [r3, #0x8]
 8006e28: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8006e2a: 68fb         	ldr	r3, [r7, #0xc]
; 	arch_current_thread()->arch.basepri = key;
 8006e2c: 687a         	ldr	r2, [r7, #0x4]
 8006e2e: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8006e32: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8006e80 <arch_swap+0x64>
 8006e34: 689b         	ldr	r3, [r3, #0x8]
 8006e36: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8006e38: 693b         	ldr	r3, [r7, #0x10]
; 	arch_current_thread()->arch.swap_return_value = -EAGAIN;
 8006e3a: f06f 020a    	mvn	r2, #0xa
 8006e3e: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; 	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8006e42: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8006e84 <arch_swap+0x68>
 8006e44: 685b         	ldr	r3, [r3, #0x4]
 8006e46: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8006e84 <arch_swap+0x68>
 8006e48: f043 5380    	orr	r3, r3, #0x10000000
 8006e4c: 6053         	str	r3, [r2, #0x4]
 8006e4e: 2300         	movs	r3, #0x0
 8006e50: 61bb         	str	r3, [r7, #0x18]
 8006e52: 69bb         	ldr	r3, [r7, #0x18]
 8006e54: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8006e56: 697b         	ldr	r3, [r7, #0x14]
 8006e58: f383 8811    	msr	basepri, r3
; }
 8006e5c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8006e5e: f3bf 8f6f    	isb	sy
; }
 8006e62: bf00         	nop
; }
 8006e64: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8006e66: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8006e80 <arch_swap+0x64>
 8006e68: 689b         	ldr	r3, [r3, #0x8]
 8006e6a: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 8006e6c: 69fb         	ldr	r3, [r7, #0x1c]
; 	return arch_current_thread()->arch.swap_return_value;
 8006e6e: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
; }
 8006e72: 4618         	mov	r0, r3
 8006e74: 3724         	adds	r7, #0x24
 8006e76: 46bd         	mov	sp, r7
 8006e78: f85d 7b04    	ldr	r7, [sp], #4
 8006e7c: 4770         	bx	lr
 8006e7e: bf00         	nop

08006e80 <$d>:
 8006e80: 48 1d 00 20  	.word	0x20001d48
 8006e84: 00 ed 00 e0  	.word	0xe000ed00

08006e88 <z_arm_pendsv>:
;     push {r0, lr}
 8006e88: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_out
 8006e8a: f018 f8f6    	bl	0x801f07a <z_thread_mark_switched_out> @ imm = #0x181ec
;     pop {r0, lr}
 8006e8e: e8bd 4001    	pop.w	{r0, lr}
;     ldr r1, =_kernel
 8006e92: 4925         	ldr	r1, [pc, #0x94]         @ 0x8006f28 <in_fp_endif+0x28>
;     ldr r2, [r1, #_kernel_offset_to_current]
 8006e94: 688a         	ldr	r2, [r1, #0x8]
;     strb lr, [r2, #_thread_offset_to_mode_exc_return]
 8006e96: f882 e111    	strb.w	lr, [r2, #0x111]
;     ldr r0, =_thread_offset_to_callee_saved
 8006e9a: f04f 0040    	mov.w	r0, #0x40
;     add r0, r2
 8006e9e: 4410         	add	r0, r2
;     mrs ip, PSP
 8006ea0: f3ef 8c09    	mrs	r12, psp
;     stmia r0, {r4-r11, ip}
 8006ea4: e880 1ff0    	stm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     tst lr, #_EXC_RETURN_FTYPE_Msk
 8006ea8: f01e 0f10    	tst.w	lr, #0x10
;     bne out_fp_endif
 8006eac: d103         	bne	0x8006eb6 <out_fp_endif> @ imm = #0x6
;     add r0, r2, #_thread_offset_to_preempt_float
 8006eae: f102 00d0    	add.w	r0, r2, #0xd0
;     vstmia r0, {s16-s31}
 8006eb2: ec80 8a10    	vstmia	r0, {s16, s17, s18, s19, s20, s21, s22, s23, s24, s25, s26, s27, s28, s29, s30, s31}

08006eb6 <out_fp_endif>:
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8006eb6: 2010         	movs	r0, #0x10
;     msr BASEPRI_MAX, r0
 8006eb8: f380 8812    	msr	basepri_max, r0
;     isb /* Make the effect of disabling interrupts be realized immediately */
 8006ebc: f3bf 8f6f    	isb	sy
;     ldr r7, =_SCS_ICSR
 8006ec0: 4f1a         	ldr	r7, [pc, #0x68]         @ 0x8006f2c <in_fp_endif+0x2c>
;     ldr r6, =_SCS_ICSR_UNPENDSV
 8006ec2: f04f 6600    	mov.w	r6, #0x8000000
;     ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 8006ec6: 6a0a         	ldr	r2, [r1, #0x20]
;     str r2, [r1, #_kernel_offset_to_current]
 8006ec8: 608a         	str	r2, [r1, #0x8]
;     str r6, [r7, #0]
 8006eca: 603e         	str	r6, [r7]
;     ldr r4, =_thread_offset_to_tls
 8006ecc: f04f 04c4    	mov.w	r4, #0xc4
;     adds r4, r2, r4
 8006ed0: 1914         	adds	r4, r2, r4
;     ldr r0, [r4]
 8006ed2: 6820         	ldr	r0, [r4]
;     ldr r4, =z_arm_tls_ptr
 8006ed4: 4c16         	ldr	r4, [pc, #0x58]         @ 0x8006f30 <in_fp_endif+0x30>
;     str r0, [r4]
 8006ed6: 6020         	str	r0, [r4]
;     ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
 8006ed8: f992 e111    	ldrsb.w	lr, [r2, #0x111]
;     ldr r0, [r2, #_thread_offset_to_basepri]
 8006edc: f8d2 00c8    	ldr.w	r0, [r2, #0xc8]
;     movs r3, #0
 8006ee0: 2300         	movs	r3, #0x0
;     str r3, [r2, #_thread_offset_to_basepri]
 8006ee2: f8c2 30c8    	str.w	r3, [r2, #0xc8]
;     msr BASEPRI, r0
 8006ee6: f380 8811    	msr	basepri, r0
;     tst lr, #_EXC_RETURN_FTYPE_Msk
 8006eea: f01e 0f10    	tst.w	lr, #0x10
;     beq in_fp_active
 8006eee: d003         	beq	0x8006ef8 <in_fp_active> @ imm = #0x6
;     movs.n r3, #0
 8006ef0: 2300         	movs	r3, #0x0
;     vmsr fpscr, r3
 8006ef2: eee1 3a10    	vmsr	fpscr, r3
;     b in_fp_endif
 8006ef6: e003         	b	0x8006f00 <in_fp_endif> @ imm = #0x6

08006ef8 <in_fp_active>:
;     add r0, r2, #_thread_offset_to_preempt_float
 8006ef8: f102 00d0    	add.w	r0, r2, #0xd0
;     vldmia r0, {s16-s31}
 8006efc: ec90 8a10    	vldmia	r0, {s16, s17, s18, s19, s20, s21, s22, s23, s24, s25, s26, s27, s28, s29, s30, s31}

08006f00 <in_fp_endif>:
;     mrs r3, CONTROL
 8006f00: f3ef 8314    	mrs	r3, control
;     bic r3, #_CONTROL_FPCA_Msk
 8006f04: f023 0304    	bic	r3, r3, #0x4
;     msr CONTROL, r3
 8006f08: f383 8814    	msr	control, r3
;     isb
 8006f0c: f3bf 8f6f    	isb	sy
;     add r0, r2, #_thread_offset_to_callee_saved
 8006f10: f102 0040    	add.w	r0, r2, #0x40
;     ldmia r0, {r4-r11, ip}
 8006f14: e890 1ff0    	ldm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     msr PSP, ip
 8006f18: f38c 8809    	msr	psp, r12
;     push {r0, lr}
 8006f1c: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_in
 8006f1e: f009 fee7    	bl	0x8010cf0 <z_thread_mark_switched_in> @ imm = #0x9dce
;     pop {r0, lr}
 8006f22: e8bd 4001    	pop.w	{r0, lr}
;     bx lr
 8006f26: 4770         	bx	lr

08006f28 <$d>:
 8006f28: 48 1d 00 20  	.word	0x20001d48
 8006f2c: 04 ed 00 e0  	.word	0xe000ed04
 8006f30: b0 24 00 20  	.word	0x200024b0

08006f34 <z_arm_svc>:
;     tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
 8006f34: f01e 0f04    	tst.w	lr, #0x4
;     ite eq  /* if zero (equal), came from handler mode */
 8006f38: bf0c         	ite	eq
;         mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 8006f3a: f3ef 8008    	mrseq	r0, msp
;         mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 8006f3e: f3ef 8009    	mrsne	r0, psp
;     ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 8006f42: 6981         	ldr	r1, [r0, #0x18]
;     ldrb r1, [r1, #-2]
 8006f44: f811 1c02    	ldrb	r1, [r1, #-2]
;     cmp r1, #2
 8006f48: 2902         	cmp	r1, #0x2
;     beq _oops
 8006f4a: d0ff         	beq	0x8006f4c <_oops>       @ imm = #-0x2

08006f4c <_oops>:
;     push {r0, lr}
 8006f4c: b501         	push	{r0, lr}
;     mov r2, lr /* EXC_RETURN */
 8006f4e: 4672         	mov	r2, lr
;     bl z_do_kernel_oops
 8006f50: f010 fc14    	bl	0x801777c <z_do_kernel_oops> @ imm = #0x10828
;     pop {r0, pc}
 8006f54: bd01         	pop	{r0, pc}
 8006f56: bf00         	nop

08006f58 <__NVIC_EnableIRQ>:
; {
 8006f58: b480         	push	{r7}
 8006f5a: b083         	sub	sp, #0xc
 8006f5c: af00         	add	r7, sp, #0x0
 8006f5e: 4603         	mov	r3, r0
 8006f60: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8006f62: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8006f66: 2b00         	cmp	r3, #0x0
 8006f68: db0b         	blt	0x8006f82 <__NVIC_EnableIRQ+0x2a> @ imm = #0x16
;     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8006f6a: 79fb         	ldrb	r3, [r7, #0x7]
 8006f6c: f003 021f    	and	r2, r3, #0x1f
 8006f70: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8006f90 <__NVIC_EnableIRQ+0x38>
 8006f72: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8006f76: 095b         	lsrs	r3, r3, #0x5
 8006f78: 2001         	movs	r0, #0x1
 8006f7a: fa00 f202    	lsl.w	r2, r0, r2
 8006f7e: f841 2023    	str.w	r2, [r1, r3, lsl #2]
; }
 8006f82: bf00         	nop
 8006f84: 370c         	adds	r7, #0xc
 8006f86: 46bd         	mov	sp, r7
 8006f88: f85d 7b04    	ldr	r7, [sp], #4
 8006f8c: 4770         	bx	lr
 8006f8e: bf00         	nop

08006f90 <$d>:
 8006f90: 00 e1 00 e0  	.word	0xe000e100

08006f94 <__NVIC_SetPriority>:
; {
 8006f94: b480         	push	{r7}
 8006f96: b083         	sub	sp, #0xc
 8006f98: af00         	add	r7, sp, #0x0
 8006f9a: 4603         	mov	r3, r0
 8006f9c: 6039         	str	r1, [r7]
 8006f9e: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8006fa0: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8006fa4: 2b00         	cmp	r3, #0x0
 8006fa6: db0a         	blt	0x8006fbe <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8006fa8: 683b         	ldr	r3, [r7]
 8006faa: b2da         	uxtb	r2, r3
 8006fac: 490c         	ldr	r1, [pc, #0x30]         @ 0x8006fe0 <__NVIC_SetPriority+0x4c>
 8006fae: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8006fb2: 0112         	lsls	r2, r2, #0x4
 8006fb4: b2d2         	uxtb	r2, r2
 8006fb6: 440b         	add	r3, r1
 8006fb8: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8006fbc: e00a         	b	0x8006fd4 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8006fbe: 683b         	ldr	r3, [r7]
 8006fc0: b2da         	uxtb	r2, r3
 8006fc2: 4908         	ldr	r1, [pc, #0x20]         @ 0x8006fe4 <__NVIC_SetPriority+0x50>
 8006fc4: 79fb         	ldrb	r3, [r7, #0x7]
 8006fc6: f003 030f    	and	r3, r3, #0xf
 8006fca: 3b04         	subs	r3, #0x4
 8006fcc: 0112         	lsls	r2, r2, #0x4
 8006fce: b2d2         	uxtb	r2, r2
 8006fd0: 440b         	add	r3, r1
 8006fd2: 761a         	strb	r2, [r3, #0x18]
; }
 8006fd4: bf00         	nop
 8006fd6: 370c         	adds	r7, #0xc
 8006fd8: 46bd         	mov	sp, r7
 8006fda: f85d 7b04    	ldr	r7, [sp], #4
 8006fde: 4770         	bx	lr

08006fe0 <$d>:
 8006fe0: 00 e1 00 e0  	.word	0xe000e100
 8006fe4: 00 ed 00 e0  	.word	0xe000ed00

08006fe8 <relocate_vector_table>:
; {
 8006fe8: b480         	push	{r7}
 8006fea: af00         	add	r7, sp, #0x0
; 	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 8006fec: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8007014 <relocate_vector_table+0x2c>
 8006fee: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007018 <relocate_vector_table+0x30>
 8006ff0: f023 037f    	bic	r3, r3, #0x7f
 8006ff4: 6093         	str	r3, [r2, #0x8]
;   __ASM volatile ("dsb 0xF":::"memory");
 8006ff6: f3bf 8f4f    	dsb	sy
; }
 8006ffa: bf00         	nop
; }
 8006ffc: bf00         	nop
; }
 8006ffe: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8007000: f3bf 8f6f    	isb	sy
; }
 8007004: bf00         	nop
; }
 8007006: bf00         	nop
; }
 8007008: bf00         	nop
; }
 800700a: bf00         	nop
 800700c: 46bd         	mov	sp, r7
 800700e: f85d 7b04    	ldr	r7, [sp], #4
 8007012: 4770         	bx	lr

08007014 <$d>:
 8007014: 00 00 00 08  	.word	0x08000000
 8007018: 00 ed 00 e0  	.word	0xe000ed00

0800701c <z_arm_floating_point_init>:
; {
 800701c: b480         	push	{r7}
 800701e: b083         	sub	sp, #0xc
 8007020: af00         	add	r7, sp, #0x0
; 	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
 8007022: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8007078 <z_arm_floating_point_init+0x5c>
 8007024: f8d3 3088    	ldr.w	r3, [r3, #0x88]
 8007028: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8007078 <z_arm_floating_point_init+0x5c>
 800702a: f423 0370    	bic	r3, r3, #0xf00000
 800702e: f8c2 3088    	str.w	r3, [r2, #0x88]
; 	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
 8007032: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8007078 <z_arm_floating_point_init+0x5c>
 8007034: f8d3 3088    	ldr.w	r3, [r3, #0x88]
 8007038: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8007078 <z_arm_floating_point_init+0x5c>
 800703a: f443 03a0    	orr	r3, r3, #0x500000
 800703e: f8c2 3088    	str.w	r3, [r2, #0x88]
; 	FPU->FPCCR = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
 8007042: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800707c <z_arm_floating_point_init+0x60>
 8007044: f04f 4240    	mov.w	r2, #0xc0000000
 8007048: 605a         	str	r2, [r3, #0x4]
;   __ASM volatile ("dsb 0xF":::"memory");
 800704a: f3bf 8f4f    	dsb	sy
; }
 800704e: bf00         	nop
; }
 8007050: bf00         	nop
; }
 8007052: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8007054: f3bf 8f6f    	isb	sy
; }
 8007058: bf00         	nop
; }
 800705a: bf00         	nop
; }
 800705c: bf00         	nop
 800705e: 2300         	movs	r3, #0x0
 8007060: 607b         	str	r3, [r7, #0x4]
;   __builtin_arm_set_fpscr(fpscr);
 8007062: 687b         	ldr	r3, [r7, #0x4]
 8007064: eee1 3a10    	vmsr	fpscr, r3
; }
 8007068: bf00         	nop
; }
 800706a: bf00         	nop
 800706c: 370c         	adds	r7, #0xc
 800706e: 46bd         	mov	sp, r7
 8007070: f85d 7b04    	ldr	r7, [sp], #4
 8007074: 4770         	bx	lr
 8007076: bf00         	nop

08007078 <$d>:
 8007078: 00 ed 00 e0  	.word	0xe000ed00
 800707c: 30 ef 00 e0  	.word	0xe000ef30

08007080 <arch_new_thread>:
; {
 8007080: b480         	push	{r7}
 8007082: b087         	sub	sp, #0x1c
 8007084: af00         	add	r7, sp, #0x0
 8007086: 60f8         	str	r0, [r7, #0xc]
 8007088: 60b9         	str	r1, [r7, #0x8]
 800708a: 607a         	str	r2, [r7, #0x4]
 800708c: 603b         	str	r3, [r7]
; 	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
 800708e: 687b         	ldr	r3, [r7, #0x4]
 8007090: 3b20         	subs	r3, #0x20
 8007092: 617b         	str	r3, [r7, #0x14]
; 	iframe->pc = (uint32_t)z_thread_entry;
 8007094: 4a16         	ldr	r2, [pc, #0x58]         @ 0x80070f0 <arch_new_thread+0x70>
 8007096: 697b         	ldr	r3, [r7, #0x14]
 8007098: 619a         	str	r2, [r3, #0x18]
; 	iframe->pc &= 0xfffffffe;
 800709a: 697b         	ldr	r3, [r7, #0x14]
 800709c: 699b         	ldr	r3, [r3, #0x18]
 800709e: f023 0201    	bic	r2, r3, #0x1
 80070a2: 697b         	ldr	r3, [r7, #0x14]
 80070a4: 619a         	str	r2, [r3, #0x18]
; 	iframe->a1 = (uint32_t)entry;
 80070a6: 683a         	ldr	r2, [r7]
 80070a8: 697b         	ldr	r3, [r7, #0x14]
 80070aa: 601a         	str	r2, [r3]
; 	iframe->a2 = (uint32_t)p1;
 80070ac: 6a3a         	ldr	r2, [r7, #0x20]
 80070ae: 697b         	ldr	r3, [r7, #0x14]
 80070b0: 605a         	str	r2, [r3, #0x4]
; 	iframe->a3 = (uint32_t)p2;
 80070b2: 6a7a         	ldr	r2, [r7, #0x24]
 80070b4: 697b         	ldr	r3, [r7, #0x14]
 80070b6: 609a         	str	r2, [r3, #0x8]
; 	iframe->a4 = (uint32_t)p3;
 80070b8: 6aba         	ldr	r2, [r7, #0x28]
 80070ba: 697b         	ldr	r3, [r7, #0x14]
 80070bc: 60da         	str	r2, [r3, #0xc]
; 	iframe->xpsr =
 80070be: 697b         	ldr	r3, [r7, #0x14]
 80070c0: f04f 7280    	mov.w	r2, #0x1000000
 80070c4: 61da         	str	r2, [r3, #0x1c]
; 	thread->callee_saved.psp = (uint32_t)iframe;
 80070c6: 697a         	ldr	r2, [r7, #0x14]
 80070c8: 68fb         	ldr	r3, [r7, #0xc]
 80070ca: 661a         	str	r2, [r3, #0x60]
; 	thread->arch.basepri = 0;
 80070cc: 68fb         	ldr	r3, [r7, #0xc]
 80070ce: 2200         	movs	r2, #0x0
 80070d0: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; 	thread->arch.mode = 0;
 80070d4: 68fb         	ldr	r3, [r7, #0xc]
 80070d6: 2200         	movs	r2, #0x0
 80070d8: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	thread->arch.mode_exc_return = DEFAULT_EXC_RETURN;
 80070dc: 68fb         	ldr	r3, [r7, #0xc]
 80070de: 22fd         	movs	r2, #0xfd
 80070e0: f883 2111    	strb.w	r2, [r3, #0x111]
; }
 80070e4: bf00         	nop
 80070e6: 371c         	adds	r7, #0x1c
 80070e8: 46bd         	mov	sp, r7
 80070ea: f85d 7b04    	ldr	r7, [sp], #4
 80070ee: 4770         	bx	lr

080070f0 <$d>:
 80070f0: 31 50 00 08  	.word	0x08005031

080070f4 <arch_float_disable>:
; {
 80070f4: b480         	push	{r7}
 80070f6: b08d         	sub	sp, #0x34
 80070f8: af00         	add	r7, sp, #0x0
 80070fa: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80070fc: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800719c <arch_float_disable+0xa8>
 80070fe: 689b         	ldr	r3, [r3, #0x8]
 8007100: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8007102: 6abb         	ldr	r3, [r7, #0x28]
; 	if (thread != arch_current_thread()) {
 8007104: 687a         	ldr	r2, [r7, #0x4]
 8007106: 429a         	cmp	r2, r3
 8007108: d002         	beq	0x8007110 <arch_float_disable+0x1c> @ imm = #0x4
; 		return -EINVAL;
 800710a: f06f 0315    	mvn	r3, #0x15
 800710e: e03f         	b	0x8007190 <arch_float_disable+0x9c> @ imm = #0x7e
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8007110: f3ef 8305    	mrs	r3, ipsr
 8007114: 627b         	str	r3, [r7, #0x24]
;   return(result);
 8007116: 6a7b         	ldr	r3, [r7, #0x24]
; 	return (__get_IPSR()) ? (true) : (false);
 8007118: 2b00         	cmp	r3, #0x0
 800711a: bf14         	ite	ne
 800711c: 2301         	movne	r3, #0x1
 800711e: 2300         	moveq	r3, #0x0
 8007120: b2db         	uxtb	r3, r3
; 	if (arch_is_in_isr()) {
 8007122: 2b00         	cmp	r3, #0x0
 8007124: d002         	beq	0x800712c <arch_float_disable+0x38> @ imm = #0x4
; 		return -EINVAL;
 8007126: f06f 0315    	mvn	r3, #0x15
 800712a: e031         	b	0x8007190 <arch_float_disable+0x9c> @ imm = #0x62
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800712c: f3ef 8311    	mrs	r3, basepri
 8007130: 613b         	str	r3, [r7, #0x10]
;   return(result);
 8007132: 693b         	ldr	r3, [r7, #0x10]
; 	key = __get_BASEPRI();
 8007134: 60fb         	str	r3, [r7, #0xc]
 8007136: 2310         	movs	r3, #0x10
 8007138: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800713a: 68bb         	ldr	r3, [r7, #0x8]
 800713c: f383 8812    	msr	basepri_max, r3
; }
 8007140: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8007142: f3bf 8f6f    	isb	sy
; }
 8007146: bf00         	nop
; 	return key;
 8007148: 68fb         	ldr	r3, [r7, #0xc]
; 	int key = arch_irq_lock();
 800714a: 62fb         	str	r3, [r7, #0x2c]
; 	thread->base.user_options &= ~K_FP_REGS;
 800714c: 687b         	ldr	r3, [r7, #0x4]
 800714e: 7b1b         	ldrb	r3, [r3, #0xc]
 8007150: f023 0302    	bic	r3, r3, #0x2
 8007154: b2da         	uxtb	r2, r3
 8007156: 687b         	ldr	r3, [r7, #0x4]
 8007158: 731a         	strb	r2, [r3, #0xc]
;   __ASM volatile ("MRS %0, control" : "=r" (result) );
 800715a: f3ef 8314    	mrs	r3, control
 800715e: 617b         	str	r3, [r7, #0x14]
;   return(result);
 8007160: 697b         	ldr	r3, [r7, #0x14]
; 	__set_CONTROL(__get_CONTROL() & (~CONTROL_FPCA_Msk));
 8007162: f023 0304    	bic	r3, r3, #0x4
 8007166: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 8007168: 69bb         	ldr	r3, [r7, #0x18]
 800716a: f383 8814    	msr	control, r3
;   __ASM volatile ("isb 0xF":::"memory");
 800716e: f3bf 8f6f    	isb	sy
; }
 8007172: bf00         	nop
; }
 8007174: bf00         	nop
; 	arch_irq_unlock(key);
 8007176: 6afb         	ldr	r3, [r7, #0x2c]
 8007178: 623b         	str	r3, [r7, #0x20]
 800717a: 6a3b         	ldr	r3, [r7, #0x20]
 800717c: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800717e: 69fb         	ldr	r3, [r7, #0x1c]
 8007180: f383 8811    	msr	basepri, r3
; }
 8007184: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8007186: f3bf 8f6f    	isb	sy
; }
 800718a: bf00         	nop
; }
 800718c: bf00         	nop
; 	return 0;
 800718e: 2300         	movs	r3, #0x0
; }
 8007190: 4618         	mov	r0, r3
 8007192: 3734         	adds	r7, #0x34
 8007194: 46bd         	mov	sp, r7
 8007196: f85d 7b04    	ldr	r7, [sp], #4
 800719a: 4770         	bx	lr

0800719c <$d>:
 800719c: 48 1d 00 20  	.word	0x20001d48

080071a0 <arch_switch_to_main_thread>:
; {
 80071a0: b5f0         	push	{r4, r5, r6, r7, lr}
 80071a2: b087         	sub	sp, #0x1c
 80071a4: af00         	add	r7, sp, #0x0
 80071a6: 60f8         	str	r0, [r7, #0xc]
 80071a8: 60b9         	str	r1, [r7, #0x8]
 80071aa: 607a         	str	r2, [r7, #0x4]
; 	z_arm_prepare_switch_to_main();
 80071ac: f010 fb8a    	bl	0x80178c4 <z_arm_prepare_switch_to_main> @ imm = #0x10714
 80071b0: 68fb         	ldr	r3, [r7, #0xc]
 80071b2: 617b         	str	r3, [r7, #0x14]
; 	_current_cpu->current = thread;
 80071b4: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x80071f0 <arch_switch_to_main_thread+0x50>
 80071b6: 697b         	ldr	r3, [r7, #0x14]
 80071b8: 6093         	str	r3, [r2, #0x8]
; }
 80071ba: bf00         	nop
; 	z_arm_tls_ptr = main_thread->tls;
 80071bc: 68fb         	ldr	r3, [r7, #0xc]
 80071be: f8d3 30c4    	ldr.w	r3, [r3, #0xc4]
 80071c2: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80071f4 <arch_switch_to_main_thread+0x54>
 80071c4: 6013         	str	r3, [r2]
; 	z_thread_mark_switched_in();
 80071c6: f009 fd93    	bl	0x8010cf0 <z_thread_mark_switched_in> @ imm = #0x9b26
; 	__asm__ volatile (
 80071ca: 687d         	ldr	r5, [r7, #0x4]
 80071cc: 68be         	ldr	r6, [r7, #0x8]
 80071ce: 462c         	mov	r4, r5
 80071d0: f386 8809    	msr	psp, r6
 80071d4: f04f 0000    	mov.w	r0, #0x0
 80071d8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80071f8 <arch_switch_to_main_thread+0x58>
 80071da: 4798         	blx	r3
 80071dc: 4620         	mov	r0, r4
 80071de: f04f 0100    	mov.w	r1, #0x0
 80071e2: f04f 0200    	mov.w	r2, #0x0
 80071e6: f04f 0300    	mov.w	r3, #0x0
 80071ea: 4c04         	ldr	r4, [pc, #0x10]         @ 0x80071fc <arch_switch_to_main_thread+0x5c>
 80071ec: 4720         	bx	r4
 80071ee: bf00         	nop

080071f0 <$d>:
 80071f0: 48 1d 00 20  	.word	0x20001d48
 80071f4: b0 24 00 20  	.word	0x200024b0

080071f8 <$d>:
 80071f8: 09 79 01 08  	.word	0x08017909
 80071fc: 31 50 00 08  	.word	0x08005031

08007200 <z_arm_cpu_idle_init>:
; {
 8007200: b480         	push	{r7}
 8007202: af00         	add	r7, sp, #0x0
; 	SCB->SCR = SCB_SCR_SEVONPEND_Msk;
 8007204: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8007214 <z_arm_cpu_idle_init+0x14>
 8007206: 2210         	movs	r2, #0x10
 8007208: 611a         	str	r2, [r3, #0x10]
; }
 800720a: bf00         	nop
 800720c: 46bd         	mov	sp, r7
 800720e: f85d 7b04    	ldr	r7, [sp], #4
 8007212: 4770         	bx	lr

08007214 <$d>:
 8007214: 00 ed 00 e0  	.word	0xe000ed00

08007218 <__NVIC_SetPriority>:
; {
 8007218: b480         	push	{r7}
 800721a: b083         	sub	sp, #0xc
 800721c: af00         	add	r7, sp, #0x0
 800721e: 4603         	mov	r3, r0
 8007220: 6039         	str	r1, [r7]
 8007222: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8007224: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8007228: 2b00         	cmp	r3, #0x0
 800722a: db0a         	blt	0x8007242 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800722c: 683b         	ldr	r3, [r7]
 800722e: b2da         	uxtb	r2, r3
 8007230: 490c         	ldr	r1, [pc, #0x30]         @ 0x8007264 <__NVIC_SetPriority+0x4c>
 8007232: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8007236: 0112         	lsls	r2, r2, #0x4
 8007238: b2d2         	uxtb	r2, r2
 800723a: 440b         	add	r3, r1
 800723c: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8007240: e00a         	b	0x8007258 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8007242: 683b         	ldr	r3, [r7]
 8007244: b2da         	uxtb	r2, r3
 8007246: 4908         	ldr	r1, [pc, #0x20]         @ 0x8007268 <__NVIC_SetPriority+0x50>
 8007248: 79fb         	ldrb	r3, [r7, #0x7]
 800724a: f003 030f    	and	r3, r3, #0xf
 800724e: 3b04         	subs	r3, #0x4
 8007250: 0112         	lsls	r2, r2, #0x4
 8007252: b2d2         	uxtb	r2, r2
 8007254: 440b         	add	r3, r1
 8007256: 761a         	strb	r2, [r3, #0x18]
; }
 8007258: bf00         	nop
 800725a: 370c         	adds	r7, #0xc
 800725c: 46bd         	mov	sp, r7
 800725e: f85d 7b04    	ldr	r7, [sp], #4
 8007262: 4770         	bx	lr

08007264 <$d>:
 8007264: 00 e1 00 e0  	.word	0xe000e100
 8007268: 00 ed 00 e0  	.word	0xe000ed00

0800726c <_isr_wrapper>:
; {
 800726c: b580         	push	{r7, lr}
 800726e: b084         	sub	sp, #0x10
 8007270: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8007272: f3ef 8305    	mrs	r3, ipsr
 8007276: 607b         	str	r3, [r7, #0x4]
;   return(result);
 8007278: 687b         	ldr	r3, [r7, #0x4]
; 	int32_t irq_number = __get_IPSR();
 800727a: 60fb         	str	r3, [r7, #0xc]
; 	irq_number -= 16;
 800727c: 68fb         	ldr	r3, [r7, #0xc]
 800727e: 3b10         	subs	r3, #0x10
 8007280: 60fb         	str	r3, [r7, #0xc]
; 	struct _isr_table_entry *entry = &_sw_isr_table[irq_number];
 8007282: 68fb         	ldr	r3, [r7, #0xc]
 8007284: 00db         	lsls	r3, r3, #0x3
 8007286: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80072a4 <_isr_wrapper+0x38>
 8007288: 4413         	add	r3, r2
 800728a: 60bb         	str	r3, [r7, #0x8]
; 	(entry->isr)(entry->arg);
 800728c: 68bb         	ldr	r3, [r7, #0x8]
 800728e: 685b         	ldr	r3, [r3, #0x4]
 8007290: 68ba         	ldr	r2, [r7, #0x8]
 8007292: 6812         	ldr	r2, [r2]
 8007294: 4610         	mov	r0, r2
 8007296: 4798         	blx	r3
; 	z_arm_exc_exit();
 8007298: f7fe fee6    	bl	0x8006068 <z_arm_int_exit> @ imm = #-0x1234
; }
 800729c: bf00         	nop
 800729e: 3710         	adds	r7, #0x10
 80072a0: 46bd         	mov	sp, r7
 80072a2: bd80         	pop	{r7, pc}

080072a4 <$d>:
 80072a4: 38 03 02 08  	.word	0x08020338

080072a8 <cbvprintf>:
; {
 80072a8: b580         	push	{r7, lr}
 80072aa: b08a         	sub	sp, #0x28
 80072ac: af00         	add	r7, sp, #0x0
 80072ae: 60f8         	str	r0, [r7, #0xc]
 80072b0: 60b9         	str	r1, [r7, #0x8]
 80072b2: 607a         	str	r2, [r7, #0x4]
 80072b4: 603b         	str	r3, [r7]
; 	struct cb_bits	s = {
 80072b6: f107 0310    	add.w	r3, r7, #0x10
 80072ba: 2200         	movs	r2, #0x0
 80072bc: 601a         	str	r2, [r3]
 80072be: 605a         	str	r2, [r3, #0x4]
 80072c0: 609a         	str	r2, [r3, #0x8]
 80072c2: 60da         	str	r2, [r3, #0xc]
 80072c4: 611a         	str	r2, [r3, #0x10]
 80072c6: 615a         	str	r2, [r3, #0x14]
 80072c8: 2302         	movs	r3, #0x2
 80072ca: 74bb         	strb	r3, [r7, #0x12]
 80072cc: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80072f0 <cbvprintf+0x48>
 80072ce: 617b         	str	r3, [r7, #0x14]
 80072d0: 68fb         	ldr	r3, [r7, #0xc]
 80072d2: 623b         	str	r3, [r7, #0x20]
 80072d4: 68bb         	ldr	r3, [r7, #0x8]
 80072d6: 627b         	str	r3, [r7, #0x24]
; 	return vfprintf(&s.f, fp, ap);
 80072d8: f107 0310    	add.w	r3, r7, #0x10
 80072dc: 683a         	ldr	r2, [r7]
 80072de: 6879         	ldr	r1, [r7, #0x4]
 80072e0: 4618         	mov	r0, r3
 80072e2: f00b ff51    	bl	0x8013188 <vfprintf>    @ imm = #0xbea2
 80072e6: 4603         	mov	r3, r0
; }
 80072e8: 4618         	mov	r0, r3
 80072ea: 3728         	adds	r7, #0x28
 80072ec: 46bd         	mov	sp, r7
 80072ee: bd80         	pop	{r7, pc}

080072f0 <$d>:
 80072f0: a5 79 01 08  	.word	0x080179a5

080072f4 <z_impl_zephyr_fputc>:
; {
 80072f4: b580         	push	{r7, lr}
 80072f6: b082         	sub	sp, #0x8
 80072f8: af00         	add	r7, sp, #0x0
 80072fa: 6078         	str	r0, [r7, #0x4]
 80072fc: 6039         	str	r1, [r7]
; 	(*_stdout_hook)(a);
 80072fe: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8007310 <z_impl_zephyr_fputc+0x1c>
 8007300: 681b         	ldr	r3, [r3]
 8007302: 6878         	ldr	r0, [r7, #0x4]
 8007304: 4798         	blx	r3
; 	return 0;
 8007306: 2300         	movs	r3, #0x0
; }
 8007308: 4618         	mov	r0, r3
 800730a: 3708         	adds	r7, #0x8
 800730c: 46bd         	mov	sp, r7
 800730e: bd80         	pop	{r7, pc}

08007310 <$d>:
 8007310: b4 24 00 20  	.word	0x200024b4

08007314 <__stdout_hook_install>:
; {
 8007314: b480         	push	{r7}
 8007316: b083         	sub	sp, #0xc
 8007318: af00         	add	r7, sp, #0x0
 800731a: 6078         	str	r0, [r7, #0x4]
; 	_stdout_hook = hook;
 800731c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800733c <__stdout_hook_install+0x28>
 800731e: 687b         	ldr	r3, [r7, #0x4]
 8007320: 6013         	str	r3, [r2]
; 	__stdout.flags |= _FDEV_SETUP_WRITE;
 8007322: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8007340 <__stdout_hook_install+0x2c>
 8007324: 789b         	ldrb	r3, [r3, #0x2]
 8007326: f043 0302    	orr	r3, r3, #0x2
 800732a: b2da         	uxtb	r2, r3
 800732c: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8007340 <__stdout_hook_install+0x2c>
 800732e: 709a         	strb	r2, [r3, #0x2]
; }
 8007330: bf00         	nop
 8007332: 370c         	adds	r7, #0xc
 8007334: 46bd         	mov	sp, r7
 8007336: f85d 7b04    	ldr	r7, [sp], #4
 800733a: 4770         	bx	lr

0800733c <$d>:
 800733c: b4 24 00 20  	.word	0x200024b4
 8007340: 18 05 00 20  	.word	0x20000518

08007344 <malloc_lock>:
; malloc_lock(void) {
 8007344: b580         	push	{r7, lr}
 8007346: b082         	sub	sp, #0x8
 8007348: af00         	add	r7, sp, #0x0
; 	lock_ret = sys_mutex_lock(&z_malloc_heap_mutex, K_FOREVER);
 800734a: f04f 32ff    	mov.w	r2, #0xffffffff
 800734e: f04f 33ff    	mov.w	r3, #0xffffffff
 8007352: 4804         	ldr	r0, [pc, #0x10]         @ 0x8007364 <malloc_lock+0x20>
 8007354: f010 fb74    	bl	0x8017a40 <sys_mutex_lock> @ imm = #0x106e8
 8007358: 6078         	str	r0, [r7, #0x4]
; }
 800735a: bf00         	nop
 800735c: 3708         	adds	r7, #0x8
 800735e: 46bd         	mov	sp, r7
 8007360: bd80         	pop	{r7, pc}
 8007362: bf00         	nop

08007364 <$d>:
 8007364: 28 05 00 20  	.word	0x20000528

08007368 <malloc_unlock>:
; {
 8007368: b580         	push	{r7, lr}
 800736a: af00         	add	r7, sp, #0x0
; 	(void) sys_mutex_unlock(&z_malloc_heap_mutex);
 800736c: 4802         	ldr	r0, [pc, #0x8]          @ 0x8007378 <malloc_unlock+0x10>
 800736e: f010 fb78    	bl	0x8017a62 <sys_mutex_unlock> @ imm = #0x106f0
; }
 8007372: bf00         	nop
 8007374: bd80         	pop	{r7, pc}
 8007376: bf00         	nop

08007378 <$d>:
 8007378: 28 05 00 20  	.word	0x20000528

0800737c <malloc>:
; {
 800737c: b580         	push	{r7, lr}
 800737e: b084         	sub	sp, #0x10
 8007380: af00         	add	r7, sp, #0x0
 8007382: 6078         	str	r0, [r7, #0x4]
; 	malloc_lock();
 8007384: f7ff ffde    	bl	0x8007344 <malloc_lock> @ imm = #-0x44
; 	void *ret = sys_heap_aligned_alloc(&z_malloc_heap,
 8007388: 687a         	ldr	r2, [r7, #0x4]
 800738a: 2108         	movs	r1, #0x8
 800738c: 480b         	ldr	r0, [pc, #0x2c]         @ 0x80073bc <malloc+0x40>
 800738e: f00f f8e9    	bl	0x8016564 <sys_heap_aligned_alloc> @ imm = #0xf1d2
 8007392: 60f8         	str	r0, [r7, #0xc]
; 	if (ret == NULL && size != 0) {
 8007394: 68fb         	ldr	r3, [r7, #0xc]
 8007396: 2b00         	cmp	r3, #0x0
 8007398: d108         	bne	0x80073ac <malloc+0x30> @ imm = #0x10
 800739a: 687b         	ldr	r3, [r7, #0x4]
 800739c: 2b00         	cmp	r3, #0x0
 800739e: d005         	beq	0x80073ac <malloc+0x30> @ imm = #0xa
; 		errno = ENOMEM;
 80073a0: f018 fe74    	bl	0x802008c <__aeabi_read_tp> @ imm = #0x18ce8
 80073a4: 4603         	mov	r3, r0
 80073a6: 4a06         	ldr	r2, [pc, #0x18]         @ 0x80073c0 <malloc+0x44>
 80073a8: 210c         	movs	r1, #0xc
 80073aa: 5099         	str	r1, [r3, r2]
; 	malloc_unlock();
 80073ac: f7ff ffdc    	bl	0x8007368 <malloc_unlock> @ imm = #-0x48
; 	return ret;
 80073b0: 68fb         	ldr	r3, [r7, #0xc]
; }
 80073b2: 4618         	mov	r0, r3
 80073b4: 3710         	adds	r7, #0x10
 80073b6: 46bd         	mov	sp, r7
 80073b8: bd80         	pop	{r7, pc}
 80073ba: bf00         	nop

080073bc <$d>:
 80073bc: b8 24 00 20  	.word	0x200024b8
 80073c0: 0c 00 00 00  	.word	0x0000000c

080073c4 <malloc_prepare>:
; {
 80073c4: b580         	push	{r7, lr}
 80073c6: b082         	sub	sp, #0x8
 80073c8: af00         	add	r7, sp, #0x0
; 	void *heap_base = NULL;
 80073ca: 2300         	movs	r3, #0x0
 80073cc: 607b         	str	r3, [r7, #0x4]
; 	heap_base = UINT_TO_POINTER(HEAP_BASE);
 80073ce: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007400 <malloc_prepare+0x3c>
 80073d0: 3307         	adds	r3, #0x7
 80073d2: f023 0307    	bic	r3, r3, #0x7
 80073d6: 607b         	str	r3, [r7, #0x4]
; 	heap_size = HEAP_SIZE;
 80073d8: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8007400 <malloc_prepare+0x3c>
 80073da: 3307         	adds	r3, #0x7
 80073dc: f023 0307    	bic	r3, r3, #0x7
 80073e0: f1c3 5300    	rsb.w	r3, r3, #0x20000000
 80073e4: f503 3300    	add.w	r3, r3, #0x20000
 80073e8: 603b         	str	r3, [r7]
; 	sys_heap_init(&z_malloc_heap, heap_base, heap_size);
 80073ea: 683a         	ldr	r2, [r7]
 80073ec: 6879         	ldr	r1, [r7, #0x4]
 80073ee: 4805         	ldr	r0, [pc, #0x14]         @ 0x8007404 <malloc_prepare+0x40>
 80073f0: f00f f961    	bl	0x80166b6 <sys_heap_init> @ imm = #0xf2c2
; 	return 0;
 80073f4: 2300         	movs	r3, #0x0
; }
 80073f6: 4618         	mov	r0, r3
 80073f8: 3708         	adds	r7, #0x8
 80073fa: 46bd         	mov	sp, r7
 80073fc: bd80         	pop	{r7, pc}
 80073fe: bf00         	nop

08007400 <$d>:
 8007400: 40 4e 00 20  	.word	0x20004e40
 8007404: b8 24 00 20  	.word	0x200024b8

08007408 <LL_EXTI_EnableIT_0_31>:
; {
 8007408: b480         	push	{r7}
 800740a: b083         	sub	sp, #0xc
 800740c: af00         	add	r7, sp, #0x0
 800740e: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->IMR, ExtiLine);
 8007410: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8007428 <LL_EXTI_EnableIT_0_31+0x20>
 8007412: 681a         	ldr	r2, [r3]
 8007414: 4904         	ldr	r1, [pc, #0x10]         @ 0x8007428 <LL_EXTI_EnableIT_0_31+0x20>
 8007416: 687b         	ldr	r3, [r7, #0x4]
 8007418: 4313         	orrs	r3, r2
 800741a: 600b         	str	r3, [r1]
; }
 800741c: bf00         	nop
 800741e: 370c         	adds	r7, #0xc
 8007420: 46bd         	mov	sp, r7
 8007422: f85d 7b04    	ldr	r7, [sp], #4
 8007426: 4770         	bx	lr

08007428 <$d>:
 8007428: 00 3c 01 40  	.word	0x40013c00

0800742c <LL_EXTI_DisableIT_0_31>:
; {
 800742c: b480         	push	{r7}
 800742e: b083         	sub	sp, #0xc
 8007430: af00         	add	r7, sp, #0x0
 8007432: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->IMR, ExtiLine);
 8007434: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007450 <LL_EXTI_DisableIT_0_31+0x24>
 8007436: 681a         	ldr	r2, [r3]
 8007438: 687b         	ldr	r3, [r7, #0x4]
 800743a: 43db         	mvns	r3, r3
 800743c: 4904         	ldr	r1, [pc, #0x10]         @ 0x8007450 <LL_EXTI_DisableIT_0_31+0x24>
 800743e: 4013         	ands	r3, r2
 8007440: 600b         	str	r3, [r1]
; }
 8007442: bf00         	nop
 8007444: 370c         	adds	r7, #0xc
 8007446: 46bd         	mov	sp, r7
 8007448: f85d 7b04    	ldr	r7, [sp], #4
 800744c: 4770         	bx	lr
 800744e: bf00         	nop

08007450 <$d>:
 8007450: 00 3c 01 40  	.word	0x40013c00

08007454 <LL_EXTI_EnableRisingTrig_0_31>:
; {
 8007454: b480         	push	{r7}
 8007456: b083         	sub	sp, #0xc
 8007458: af00         	add	r7, sp, #0x0
 800745a: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->RTSR, ExtiLine);
 800745c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8007474 <LL_EXTI_EnableRisingTrig_0_31+0x20>
 800745e: 689a         	ldr	r2, [r3, #0x8]
 8007460: 4904         	ldr	r1, [pc, #0x10]         @ 0x8007474 <LL_EXTI_EnableRisingTrig_0_31+0x20>
 8007462: 687b         	ldr	r3, [r7, #0x4]
 8007464: 4313         	orrs	r3, r2
 8007466: 608b         	str	r3, [r1, #0x8]
; }
 8007468: bf00         	nop
 800746a: 370c         	adds	r7, #0xc
 800746c: 46bd         	mov	sp, r7
 800746e: f85d 7b04    	ldr	r7, [sp], #4
 8007472: 4770         	bx	lr

08007474 <$d>:
 8007474: 00 3c 01 40  	.word	0x40013c00

08007478 <LL_EXTI_DisableRisingTrig_0_31>:
; {
 8007478: b480         	push	{r7}
 800747a: b083         	sub	sp, #0xc
 800747c: af00         	add	r7, sp, #0x0
 800747e: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->RTSR, ExtiLine);
 8007480: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800749c <LL_EXTI_DisableRisingTrig_0_31+0x24>
 8007482: 689a         	ldr	r2, [r3, #0x8]
 8007484: 687b         	ldr	r3, [r7, #0x4]
 8007486: 43db         	mvns	r3, r3
 8007488: 4904         	ldr	r1, [pc, #0x10]         @ 0x800749c <LL_EXTI_DisableRisingTrig_0_31+0x24>
 800748a: 4013         	ands	r3, r2
 800748c: 608b         	str	r3, [r1, #0x8]
; }
 800748e: bf00         	nop
 8007490: 370c         	adds	r7, #0xc
 8007492: 46bd         	mov	sp, r7
 8007494: f85d 7b04    	ldr	r7, [sp], #4
 8007498: 4770         	bx	lr
 800749a: bf00         	nop

0800749c <$d>:
 800749c: 00 3c 01 40  	.word	0x40013c00

080074a0 <LL_EXTI_EnableFallingTrig_0_31>:
; {
 80074a0: b480         	push	{r7}
 80074a2: b083         	sub	sp, #0xc
 80074a4: af00         	add	r7, sp, #0x0
 80074a6: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->FTSR, ExtiLine);
 80074a8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80074c0 <LL_EXTI_EnableFallingTrig_0_31+0x20>
 80074aa: 68da         	ldr	r2, [r3, #0xc]
 80074ac: 4904         	ldr	r1, [pc, #0x10]         @ 0x80074c0 <LL_EXTI_EnableFallingTrig_0_31+0x20>
 80074ae: 687b         	ldr	r3, [r7, #0x4]
 80074b0: 4313         	orrs	r3, r2
 80074b2: 60cb         	str	r3, [r1, #0xc]
; }
 80074b4: bf00         	nop
 80074b6: 370c         	adds	r7, #0xc
 80074b8: 46bd         	mov	sp, r7
 80074ba: f85d 7b04    	ldr	r7, [sp], #4
 80074be: 4770         	bx	lr

080074c0 <$d>:
 80074c0: 00 3c 01 40  	.word	0x40013c00

080074c4 <LL_EXTI_DisableFallingTrig_0_31>:
; {
 80074c4: b480         	push	{r7}
 80074c6: b083         	sub	sp, #0xc
 80074c8: af00         	add	r7, sp, #0x0
 80074ca: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->FTSR, ExtiLine);
 80074cc: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80074e8 <LL_EXTI_DisableFallingTrig_0_31+0x24>
 80074ce: 68da         	ldr	r2, [r3, #0xc]
 80074d0: 687b         	ldr	r3, [r7, #0x4]
 80074d2: 43db         	mvns	r3, r3
 80074d4: 4904         	ldr	r1, [pc, #0x10]         @ 0x80074e8 <LL_EXTI_DisableFallingTrig_0_31+0x24>
 80074d6: 4013         	ands	r3, r2
 80074d8: 60cb         	str	r3, [r1, #0xc]
; }
 80074da: bf00         	nop
 80074dc: 370c         	adds	r7, #0xc
 80074de: 46bd         	mov	sp, r7
 80074e0: f85d 7b04    	ldr	r7, [sp], #4
 80074e4: 4770         	bx	lr
 80074e6: bf00         	nop

080074e8 <$d>:
 80074e8: 00 3c 01 40  	.word	0x40013c00

080074ec <LL_EXTI_IsActiveFlag_0_31>:
; {
 80074ec: b480         	push	{r7}
 80074ee: b083         	sub	sp, #0xc
 80074f0: af00         	add	r7, sp, #0x0
 80074f2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(EXTI->PR, ExtiLine) == (ExtiLine));
 80074f4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8007514 <LL_EXTI_IsActiveFlag_0_31+0x28>
 80074f6: 695a         	ldr	r2, [r3, #0x14]
 80074f8: 687b         	ldr	r3, [r7, #0x4]
 80074fa: 4013         	ands	r3, r2
 80074fc: 687a         	ldr	r2, [r7, #0x4]
 80074fe: 429a         	cmp	r2, r3
 8007500: bf0c         	ite	eq
 8007502: 2301         	moveq	r3, #0x1
 8007504: 2300         	movne	r3, #0x0
 8007506: b2db         	uxtb	r3, r3
; }
 8007508: 4618         	mov	r0, r3
 800750a: 370c         	adds	r7, #0xc
 800750c: 46bd         	mov	sp, r7
 800750e: f85d 7b04    	ldr	r7, [sp], #4
 8007512: 4770         	bx	lr

08007514 <$d>:
 8007514: 00 3c 01 40  	.word	0x40013c00

08007518 <LL_EXTI_ClearFlag_0_31>:
; {
 8007518: b480         	push	{r7}
 800751a: b083         	sub	sp, #0xc
 800751c: af00         	add	r7, sp, #0x0
 800751e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(EXTI->PR, ExtiLine);
 8007520: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8007534 <LL_EXTI_ClearFlag_0_31+0x1c>
 8007522: 687b         	ldr	r3, [r7, #0x4]
 8007524: 6153         	str	r3, [r2, #0x14]
; }
 8007526: bf00         	nop
 8007528: 370c         	adds	r7, #0xc
 800752a: 46bd         	mov	sp, r7
 800752c: f85d 7b04    	ldr	r7, [sp], #4
 8007530: 4770         	bx	lr
 8007532: bf00         	nop

08007534 <$d>:
 8007534: 00 3c 01 40  	.word	0x40013c00

08007538 <LL_SYSCFG_SetEXTISource>:
; {
 8007538: b480         	push	{r7}
 800753a: b087         	sub	sp, #0x1c
 800753c: af00         	add	r7, sp, #0x0
 800753e: 6078         	str	r0, [r7, #0x4]
 8007540: 6039         	str	r1, [r7]
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 8007542: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x80075a0 <LL_SYSCFG_SetEXTISource+0x68>
 8007544: 683b         	ldr	r3, [r7]
 8007546: b2db         	uxtb	r3, r3
 8007548: 3302         	adds	r3, #0x2
 800754a: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 800754e: 683b         	ldr	r3, [r7]
 8007550: 0c1b         	lsrs	r3, r3, #0x10
 8007552: 43db         	mvns	r3, r3
 8007554: ea02 0103    	and.w	r1, r2, r3
 8007558: 683b         	ldr	r3, [r7]
 800755a: 0c1b         	lsrs	r3, r3, #0x10
 800755c: 613b         	str	r3, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800755e: 693b         	ldr	r3, [r7, #0x10]
 8007560: fa93 f3a3    	rbit	r3, r3
 8007564: 60fb         	str	r3, [r7, #0xc]
;   return result;
 8007566: 68fb         	ldr	r3, [r7, #0xc]
 8007568: 617b         	str	r3, [r7, #0x14]
;   if (value == 0U)
 800756a: 697b         	ldr	r3, [r7, #0x14]
 800756c: 2b00         	cmp	r3, #0x0
 800756e: d101         	bne	0x8007574 <LL_SYSCFG_SetEXTISource+0x3c> @ imm = #0x2
;     return 32U;
 8007570: 2320         	movs	r3, #0x20
 8007572: e003         	b	0x800757c <LL_SYSCFG_SetEXTISource+0x44> @ imm = #0x6
;   return __builtin_clz(value);
 8007574: 697b         	ldr	r3, [r7, #0x14]
 8007576: fab3 f383    	clz	r3, r3
 800757a: b2db         	uxtb	r3, r3
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 800757c: 461a         	mov	r2, r3
 800757e: 687b         	ldr	r3, [r7, #0x4]
 8007580: fa03 f202    	lsl.w	r2, r3, r2
 8007584: 4806         	ldr	r0, [pc, #0x18]         @ 0x80075a0 <LL_SYSCFG_SetEXTISource+0x68>
 8007586: 683b         	ldr	r3, [r7]
 8007588: b2db         	uxtb	r3, r3
 800758a: 430a         	orrs	r2, r1
 800758c: 3302         	adds	r3, #0x2
 800758e: f840 2023    	str.w	r2, [r0, r3, lsl #2]
; }
 8007592: bf00         	nop
 8007594: 371c         	adds	r7, #0x1c
 8007596: 46bd         	mov	sp, r7
 8007598: f85d 7b04    	ldr	r7, [sp], #4
 800759c: 4770         	bx	lr
 800759e: bf00         	nop

080075a0 <$d>:
 80075a0: 00 38 01 40  	.word	0x40013800

080075a4 <LL_SYSCFG_GetEXTISource>:
; {
 80075a4: b480         	push	{r7}
 80075a6: b087         	sub	sp, #0x1c
 80075a8: af00         	add	r7, sp, #0x0
 80075aa: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 80075ac: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80075f0 <LL_SYSCFG_GetEXTISource+0x4c>
 80075ae: 687b         	ldr	r3, [r7, #0x4]
 80075b0: b2db         	uxtb	r3, r3
 80075b2: 3302         	adds	r3, #0x2
 80075b4: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 80075b8: 687b         	ldr	r3, [r7, #0x4]
 80075ba: 0c1b         	lsrs	r3, r3, #0x10
 80075bc: 4013         	ands	r3, r2
 80075be: 687a         	ldr	r2, [r7, #0x4]
 80075c0: 0c12         	lsrs	r2, r2, #0x10
 80075c2: 613a         	str	r2, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80075c4: 693a         	ldr	r2, [r7, #0x10]
 80075c6: fa92 f2a2    	rbit	r2, r2
 80075ca: 60fa         	str	r2, [r7, #0xc]
;   return result;
 80075cc: 68fa         	ldr	r2, [r7, #0xc]
 80075ce: 617a         	str	r2, [r7, #0x14]
;   if (value == 0U)
 80075d0: 697a         	ldr	r2, [r7, #0x14]
 80075d2: 2a00         	cmp	r2, #0x0
 80075d4: d101         	bne	0x80075da <LL_SYSCFG_GetEXTISource+0x36> @ imm = #0x2
;     return 32U;
 80075d6: 2220         	movs	r2, #0x20
 80075d8: e003         	b	0x80075e2 <LL_SYSCFG_GetEXTISource+0x3e> @ imm = #0x6
;   return __builtin_clz(value);
 80075da: 697a         	ldr	r2, [r7, #0x14]
 80075dc: fab2 f282    	clz	r2, r2
 80075e0: b2d2         	uxtb	r2, r2
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 80075e2: 40d3         	lsrs	r3, r2
; }
 80075e4: 4618         	mov	r0, r3
 80075e6: 371c         	adds	r7, #0x1c
 80075e8: 46bd         	mov	sp, r7
 80075ea: f85d 7b04    	ldr	r7, [sp], #4
 80075ee: 4770         	bx	lr

080075f0 <$d>:
 80075f0: 00 38 01 40  	.word	0x40013800

080075f4 <stm32_exti_isr>:
; {
 80075f4: b580         	push	{r7, lr}
 80075f6: b088         	sub	sp, #0x20
 80075f8: af00         	add	r7, sp, #0x0
 80075fa: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = DEVICE_DT_GET(EXTI_NODE);
 80075fc: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800767c <stm32_exti_isr+0x88>
 80075fe: 61bb         	str	r3, [r7, #0x18]
; 	struct stm32_exti_data *data = dev->data;
 8007600: 69bb         	ldr	r3, [r7, #0x18]
 8007602: 691b         	ldr	r3, [r3, #0x10]
 8007604: 617b         	str	r3, [r7, #0x14]
; 	const struct stm32_exti_range *range = exti_range;
 8007606: 687b         	ldr	r3, [r7, #0x4]
 8007608: 613b         	str	r3, [r7, #0x10]
; 	for (uint8_t i = 0; i <= range->len; i++) {
 800760a: 2300         	movs	r3, #0x0
 800760c: 77fb         	strb	r3, [r7, #0x1f]
 800760e: e02b         	b	0x8007668 <stm32_exti_isr+0x74> @ imm = #0x56
; 		line_num = range->start + i;
 8007610: 693b         	ldr	r3, [r7, #0x10]
 8007612: 781b         	ldrb	r3, [r3]
 8007614: 461a         	mov	r2, r3
 8007616: 7ffb         	ldrb	r3, [r7, #0x1f]
 8007618: 4413         	add	r3, r2
 800761a: 60fb         	str	r3, [r7, #0xc]
; 		line = linenum_to_ll_exti_line(line_num);
 800761c: 68fb         	ldr	r3, [r7, #0xc]
 800761e: b2db         	uxtb	r3, r3
 8007620: 4618         	mov	r0, r3
 8007622: f010 fa80    	bl	0x8017b26 <linenum_to_ll_exti_line> @ imm = #0x10500
 8007626: 60b8         	str	r0, [r7, #0x8]
; 		if (stm32_exti_is_pending(line) != 0) {
 8007628: 68b8         	ldr	r0, [r7, #0x8]
 800762a: f010 fa65    	bl	0x8017af8 <stm32_exti_is_pending> @ imm = #0x104ca
 800762e: 4603         	mov	r3, r0
 8007630: 2b00         	cmp	r3, #0x0
 8007632: d016         	beq	0x8007662 <stm32_exti_isr+0x6e> @ imm = #0x2c
; 			stm32_exti_clear_pending(line);
 8007634: 68b8         	ldr	r0, [r7, #0x8]
 8007636: f010 fa6b    	bl	0x8017b10 <stm32_exti_clear_pending> @ imm = #0x104d6
; 			if (!data->cb[line_num].cb) {
 800763a: 697b         	ldr	r3, [r7, #0x14]
 800763c: 68fa         	ldr	r2, [r7, #0xc]
 800763e: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 8007642: 2b00         	cmp	r3, #0x0
 8007644: d00c         	beq	0x8007660 <stm32_exti_isr+0x6c> @ imm = #0x18
; 			data->cb[line_num].cb(line, data->cb[line_num].data);
 8007646: 697b         	ldr	r3, [r7, #0x14]
 8007648: 68fa         	ldr	r2, [r7, #0xc]
 800764a: f853 2032    	ldr.w	r2, [r3, r2, lsl #3]
 800764e: 6979         	ldr	r1, [r7, #0x14]
 8007650: 68fb         	ldr	r3, [r7, #0xc]
 8007652: 00db         	lsls	r3, r3, #0x3
 8007654: 440b         	add	r3, r1
 8007656: 685b         	ldr	r3, [r3, #0x4]
 8007658: 4619         	mov	r1, r3
 800765a: 68b8         	ldr	r0, [r7, #0x8]
 800765c: 4790         	blx	r2
 800765e: e000         	b	0x8007662 <stm32_exti_isr+0x6e> @ imm = #0x0
; 				continue;
 8007660: bf00         	nop
; 	for (uint8_t i = 0; i <= range->len; i++) {
 8007662: 7ffb         	ldrb	r3, [r7, #0x1f]
 8007664: 3301         	adds	r3, #0x1
 8007666: 77fb         	strb	r3, [r7, #0x1f]
 8007668: 693b         	ldr	r3, [r7, #0x10]
 800766a: 785b         	ldrb	r3, [r3, #0x1]
 800766c: 7ffa         	ldrb	r2, [r7, #0x1f]
 800766e: 429a         	cmp	r2, r3
 8007670: d9ce         	bls	0x8007610 <stm32_exti_isr+0x1c> @ imm = #-0x64
; }
 8007672: bf00         	nop
 8007674: bf00         	nop
 8007676: 3720         	adds	r7, #0x20
 8007678: 46bd         	mov	sp, r7
 800767a: bd80         	pop	{r7, pc}

0800767c <$d>:
 800767c: a8 01 02 08  	.word	0x080201a8

08007680 <stm32_exti_enable_registers>:
; {
 8007680: b580         	push	{r7, lr}
 8007682: b084         	sub	sp, #0x10
 8007684: af00         	add	r7, sp, #0x0
; 	int ret = 0;
 8007686: 2300         	movs	r3, #0x0
 8007688: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800768a: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80076b0 <stm32_exti_enable_registers+0x30>
 800768c: 60bb         	str	r3, [r7, #0x8]
; 	struct stm32_pclken pclken = {
 800768e: 4a09         	ldr	r2, [pc, #0x24]         @ 0x80076b4 <stm32_exti_enable_registers+0x34>
 8007690: 463b         	mov	r3, r7
 8007692: e892 0003    	ldm.w	r2, {r0, r1}
 8007696: e883 0003    	stm.w	r3, {r0, r1}
; 	ret = clock_control_on(clk, (clock_control_subsys_t) &pclken);
 800769a: 463b         	mov	r3, r7
 800769c: 4619         	mov	r1, r3
 800769e: 68b8         	ldr	r0, [r7, #0x8]
 80076a0: f010 f9ec    	bl	0x8017a7c <clock_control_on> @ imm = #0x103d8
 80076a4: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 80076a6: 68fb         	ldr	r3, [r7, #0xc]
; }
 80076a8: 4618         	mov	r0, r3
 80076aa: 3710         	adds	r7, #0x10
 80076ac: 46bd         	mov	sp, r7
 80076ae: bd80         	pop	{r7, pc}

080076b0 <$d>:
 80076b0: 80 01 02 08  	.word	0x08020180
 80076b4: b4 0f 02 08  	.word	0x08020fb4

080076b8 <stm32_fill_irq_table>:
; {
 80076b8: b480         	push	{r7}
 80076ba: b085         	sub	sp, #0x14
 80076bc: af00         	add	r7, sp, #0x0
 80076be: 4603         	mov	r3, r0
 80076c0: 603a         	str	r2, [r7]
 80076c2: 71fb         	strb	r3, [r7, #0x7]
 80076c4: 460b         	mov	r3, r1
 80076c6: 71bb         	strb	r3, [r7, #0x6]
; 	for (int i = 0; i < len; i++) {
 80076c8: 2300         	movs	r3, #0x0
 80076ca: 60fb         	str	r3, [r7, #0xc]
 80076cc: e00a         	b	0x80076e4 <stm32_fill_irq_table+0x2c> @ imm = #0x14
; 		exti_irq_table[start + i] = irqn;
 80076ce: f997 2007    	ldrsb.w	r2, [r7, #0x7]
 80076d2: 68fb         	ldr	r3, [r7, #0xc]
 80076d4: 4413         	add	r3, r2
 80076d6: 683a         	ldr	r2, [r7]
 80076d8: b251         	sxtb	r1, r2
 80076da: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80076fc <stm32_fill_irq_table+0x44>
 80076dc: 54d1         	strb	r1, [r2, r3]
; 	for (int i = 0; i < len; i++) {
 80076de: 68fb         	ldr	r3, [r7, #0xc]
 80076e0: 3301         	adds	r3, #0x1
 80076e2: 60fb         	str	r3, [r7, #0xc]
 80076e4: f997 3006    	ldrsb.w	r3, [r7, #0x6]
 80076e8: 68fa         	ldr	r2, [r7, #0xc]
 80076ea: 429a         	cmp	r2, r3
 80076ec: dbef         	blt	0x80076ce <stm32_fill_irq_table+0x16> @ imm = #-0x22
; }
 80076ee: bf00         	nop
 80076f0: bf00         	nop
 80076f2: 3714         	adds	r7, #0x14
 80076f4: 46bd         	mov	sp, r7
 80076f6: f85d 7b04    	ldr	r7, [sp], #4
 80076fa: 4770         	bx	lr

080076fc <$d>:
 80076fc: 3c 05 00 20  	.word	0x2000053c

08007700 <stm32_exti_init>:
; {
 8007700: b580         	push	{r7, lr}
 8007702: b082         	sub	sp, #0x8
 8007704: af00         	add	r7, sp, #0x0
 8007706: 6078         	str	r0, [r7, #0x4]
; 	DT_FOREACH_PROP_ELEM(DT_NODELABEL(exti),
 8007708: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x80077e8 <stm32_exti_init+0xe8>
 800770a: 781b         	ldrb	r3, [r3]
 800770c: b25b         	sxtb	r3, r3
 800770e: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x80077e8 <stm32_exti_init+0xe8>
 8007710: 7852         	ldrb	r2, [r2, #0x1]
 8007712: b251         	sxtb	r1, r2
 8007714: 2206         	movs	r2, #0x6
 8007716: 4618         	mov	r0, r3
 8007718: f7ff ffce    	bl	0x80076b8 <stm32_fill_irq_table> @ imm = #-0x64
 800771c: 2200         	movs	r2, #0x0
 800771e: 2100         	movs	r1, #0x0
 8007720: 2006         	movs	r0, #0x6
 8007722: f010 f8a2    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #0x10144
 8007726: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80077ec <stm32_exti_init+0xec>
 8007728: 781b         	ldrb	r3, [r3]
 800772a: b25b         	sxtb	r3, r3
 800772c: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x80077ec <stm32_exti_init+0xec>
 800772e: 7852         	ldrb	r2, [r2, #0x1]
 8007730: b251         	sxtb	r1, r2
 8007732: 2207         	movs	r2, #0x7
 8007734: 4618         	mov	r0, r3
 8007736: f7ff ffbf    	bl	0x80076b8 <stm32_fill_irq_table> @ imm = #-0x82
 800773a: 2200         	movs	r2, #0x0
 800773c: 2100         	movs	r1, #0x0
 800773e: 2007         	movs	r0, #0x7
 8007740: f010 f893    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #0x10126
 8007744: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80077f0 <stm32_exti_init+0xf0>
 8007746: 781b         	ldrb	r3, [r3]
 8007748: b25b         	sxtb	r3, r3
 800774a: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x80077f0 <stm32_exti_init+0xf0>
 800774c: 7852         	ldrb	r2, [r2, #0x1]
 800774e: b251         	sxtb	r1, r2
 8007750: 2208         	movs	r2, #0x8
 8007752: 4618         	mov	r0, r3
 8007754: f7ff ffb0    	bl	0x80076b8 <stm32_fill_irq_table> @ imm = #-0xa0
 8007758: 2200         	movs	r2, #0x0
 800775a: 2100         	movs	r1, #0x0
 800775c: 2008         	movs	r0, #0x8
 800775e: f010 f884    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #0x10108
 8007762: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80077f4 <stm32_exti_init+0xf4>
 8007764: 781b         	ldrb	r3, [r3]
 8007766: b25b         	sxtb	r3, r3
 8007768: 4a22         	ldr	r2, [pc, #0x88]         @ 0x80077f4 <stm32_exti_init+0xf4>
 800776a: 7852         	ldrb	r2, [r2, #0x1]
 800776c: b251         	sxtb	r1, r2
 800776e: 2209         	movs	r2, #0x9
 8007770: 4618         	mov	r0, r3
 8007772: f7ff ffa1    	bl	0x80076b8 <stm32_fill_irq_table> @ imm = #-0xbe
 8007776: 2200         	movs	r2, #0x0
 8007778: 2100         	movs	r1, #0x0
 800777a: 2009         	movs	r0, #0x9
 800777c: f010 f875    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #0x100ea
 8007780: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x80077f8 <stm32_exti_init+0xf8>
 8007782: 781b         	ldrb	r3, [r3]
 8007784: b25b         	sxtb	r3, r3
 8007786: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x80077f8 <stm32_exti_init+0xf8>
 8007788: 7852         	ldrb	r2, [r2, #0x1]
 800778a: b251         	sxtb	r1, r2
 800778c: 220a         	movs	r2, #0xa
 800778e: 4618         	mov	r0, r3
 8007790: f7ff ff92    	bl	0x80076b8 <stm32_fill_irq_table> @ imm = #-0xdc
 8007794: 2200         	movs	r2, #0x0
 8007796: 2100         	movs	r1, #0x0
 8007798: 200a         	movs	r0, #0xa
 800779a: f010 f866    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #0x100cc
 800779e: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80077fc <stm32_exti_init+0xfc>
 80077a0: 781b         	ldrb	r3, [r3]
 80077a2: b25b         	sxtb	r3, r3
 80077a4: 4a15         	ldr	r2, [pc, #0x54]         @ 0x80077fc <stm32_exti_init+0xfc>
 80077a6: 7852         	ldrb	r2, [r2, #0x1]
 80077a8: b251         	sxtb	r1, r2
 80077aa: 2217         	movs	r2, #0x17
 80077ac: 4618         	mov	r0, r3
 80077ae: f7ff ff83    	bl	0x80076b8 <stm32_fill_irq_table> @ imm = #-0xfa
 80077b2: 2200         	movs	r2, #0x0
 80077b4: 2100         	movs	r1, #0x0
 80077b6: 2017         	movs	r0, #0x17
 80077b8: f010 f857    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #0x100ae
 80077bc: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8007800 <stm32_exti_init+0x100>
 80077be: 781b         	ldrb	r3, [r3]
 80077c0: b25b         	sxtb	r3, r3
 80077c2: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8007800 <stm32_exti_init+0x100>
 80077c4: 7852         	ldrb	r2, [r2, #0x1]
 80077c6: b251         	sxtb	r1, r2
 80077c8: 2228         	movs	r2, #0x28
 80077ca: 4618         	mov	r0, r3
 80077cc: f7ff ff74    	bl	0x80076b8 <stm32_fill_irq_table> @ imm = #-0x118
 80077d0: 2200         	movs	r2, #0x0
 80077d2: 2100         	movs	r1, #0x0
 80077d4: 2028         	movs	r0, #0x28
 80077d6: f010 f848    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #0x10090
; 	return stm32_exti_enable_registers();
 80077da: f7ff ff51    	bl	0x8007680 <stm32_exti_enable_registers> @ imm = #-0x15e
 80077de: 4603         	mov	r3, r0
; }
 80077e0: 4618         	mov	r0, r3
 80077e2: 3708         	adds	r7, #0x8
 80077e4: 46bd         	mov	sp, r7
 80077e6: bd80         	pop	{r7, pc}

080077e8 <$d>:
 80077e8: 60 26 02 08  	.word	0x08022660
 80077ec: 64 26 02 08  	.word	0x08022664
 80077f0: 68 26 02 08  	.word	0x08022668
 80077f4: 6c 26 02 08  	.word	0x0802266c
 80077f8: 70 26 02 08  	.word	0x08022670
 80077fc: 74 26 02 08  	.word	0x08022674
 8007800: 78 26 02 08  	.word	0x08022678

08007804 <stm32_gpio_intc_enable_line>:
; {
 8007804: b580         	push	{r7, lr}
 8007806: b084         	sub	sp, #0x10
 8007808: af00         	add	r7, sp, #0x0
 800780a: 6078         	str	r0, [r7, #0x4]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 800780c: 6878         	ldr	r0, [r7, #0x4]
 800780e: f010 f999    	bl	0x8017b44 <ll_exti_line_to_linenum> @ imm = #0x10332
 8007812: 4603         	mov	r3, r0
 8007814: 60fb         	str	r3, [r7, #0xc]
; 	irqnum = exti_irq_table[line_num];
 8007816: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007838 <stm32_gpio_intc_enable_line+0x34>
 8007818: 68fb         	ldr	r3, [r7, #0xc]
 800781a: 4413         	add	r3, r2
 800781c: f993 3000    	ldrsb.w	r3, [r3]
 8007820: 60bb         	str	r3, [r7, #0x8]
; 	LL_EXTI_EnableIT_0_31(line);
 8007822: 6878         	ldr	r0, [r7, #0x4]
 8007824: f7ff fdf0    	bl	0x8007408 <LL_EXTI_EnableIT_0_31> @ imm = #-0x420
; 	irq_enable(irqnum);
 8007828: 68b8         	ldr	r0, [r7, #0x8]
 800782a: f010 f811    	bl	0x8017850 <arch_irq_enable> @ imm = #0x10022
; }
 800782e: bf00         	nop
 8007830: 3710         	adds	r7, #0x10
 8007832: 46bd         	mov	sp, r7
 8007834: bd80         	pop	{r7, pc}
 8007836: bf00         	nop

08007838 <$d>:
 8007838: 3c 05 00 20  	.word	0x2000053c

0800783c <stm32_gpio_intc_select_line_trigger>:
; {
 800783c: b580         	push	{r7, lr}
 800783e: b082         	sub	sp, #0x8
 8007840: af00         	add	r7, sp, #0x0
 8007842: 6078         	str	r0, [r7, #0x4]
 8007844: 6039         	str	r1, [r7]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8007846: f44f 1180    	mov.w	r1, #0x100000
 800784a: 2000         	movs	r0, #0x0
 800784c: f010 f928    	bl	0x8017aa0 <z_stm32_hsem_lock> @ imm = #0x10250
; 	switch (trg) {
 8007850: 683b         	ldr	r3, [r7]
 8007852: 2b03         	cmp	r3, #0x3
 8007854: d826         	bhi	0x80078a4 <stm32_gpio_intc_select_line_trigger+0x68> @ imm = #0x4c
 8007856: a201         	adr	r2, #4 <stm32_gpio_intc_select_line_trigger+0x1f>
 8007858: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800785c <$d>:
 800785c: 6d 78 00 08  	.word	0x0800786d
 8007860: 7b 78 00 08  	.word	0x0800787b
 8007864: 89 78 00 08  	.word	0x08007889
 8007868: 97 78 00 08  	.word	0x08007897

0800786c <$t>:
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 800786c: 6878         	ldr	r0, [r7, #0x4]
 800786e: f7ff fe03    	bl	0x8007478 <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x3fa
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 8007872: 6878         	ldr	r0, [r7, #0x4]
 8007874: f7ff fe26    	bl	0x80074c4 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3b4
; 		break;
 8007878: e015         	b	0x80078a6 <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x2a
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 800787a: 6878         	ldr	r0, [r7, #0x4]
 800787c: f7ff fdea    	bl	0x8007454 <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x42c
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 8007880: 6878         	ldr	r0, [r7, #0x4]
 8007882: f7ff fe1f    	bl	0x80074c4 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3c2
; 		break;
 8007886: e00e         	b	0x80078a6 <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x1c
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 8007888: 6878         	ldr	r0, [r7, #0x4]
 800788a: f7ff fe09    	bl	0x80074a0 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x3ee
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 800788e: 6878         	ldr	r0, [r7, #0x4]
 8007890: f7ff fdf2    	bl	0x8007478 <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x41c
; 		break;
 8007894: e007         	b	0x80078a6 <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0xe
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 8007896: 6878         	ldr	r0, [r7, #0x4]
 8007898: f7ff fddc    	bl	0x8007454 <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x448
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 800789c: 6878         	ldr	r0, [r7, #0x4]
 800789e: f7ff fdff    	bl	0x80074a0 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x402
; 		break;
 80078a2: e000         	b	0x80078a6 <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x0
; 		break;
 80078a4: bf00         	nop
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 80078a6: 2000         	movs	r0, #0x0
 80078a8: f010 f905    	bl	0x8017ab6 <z_stm32_hsem_unlock> @ imm = #0x1020a
; }
 80078ac: bf00         	nop
 80078ae: 3708         	adds	r7, #0x8
 80078b0: 46bd         	mov	sp, r7
 80078b2: bd80         	pop	{r7, pc}

080078b4 <stm32_gpio_intc_set_irq_callback>:
; {
 80078b4: b580         	push	{r7, lr}
 80078b6: b088         	sub	sp, #0x20
 80078b8: af00         	add	r7, sp, #0x0
 80078ba: 60f8         	str	r0, [r7, #0xc]
 80078bc: 60b9         	str	r1, [r7, #0x8]
 80078be: 607a         	str	r2, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 80078c0: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8007928 <stm32_gpio_intc_set_irq_callback+0x74>
 80078c2: 61fb         	str	r3, [r7, #0x1c]
; 	struct stm32_exti_data *data = dev->data;
 80078c4: 69fb         	ldr	r3, [r7, #0x1c]
 80078c6: 691b         	ldr	r3, [r3, #0x10]
 80078c8: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 80078ca: 68f8         	ldr	r0, [r7, #0xc]
 80078cc: f010 f93a    	bl	0x8017b44 <ll_exti_line_to_linenum> @ imm = #0x10274
 80078d0: 4603         	mov	r3, r0
 80078d2: 617b         	str	r3, [r7, #0x14]
; 	if ((data->cb[line_num].cb == cb) && (data->cb[line_num].data == user)) {
 80078d4: 69bb         	ldr	r3, [r7, #0x18]
 80078d6: 697a         	ldr	r2, [r7, #0x14]
 80078d8: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 80078dc: 68ba         	ldr	r2, [r7, #0x8]
 80078de: 429a         	cmp	r2, r3
 80078e0: d109         	bne	0x80078f6 <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x12
 80078e2: 69ba         	ldr	r2, [r7, #0x18]
 80078e4: 697b         	ldr	r3, [r7, #0x14]
 80078e6: 00db         	lsls	r3, r3, #0x3
 80078e8: 4413         	add	r3, r2
 80078ea: 685b         	ldr	r3, [r3, #0x4]
 80078ec: 687a         	ldr	r2, [r7, #0x4]
 80078ee: 429a         	cmp	r2, r3
 80078f0: d101         	bne	0x80078f6 <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x2
; 		return 0;
 80078f2: 2300         	movs	r3, #0x0
 80078f4: e014         	b	0x8007920 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x28
; 	if (data->cb[line_num].cb != NULL) {
 80078f6: 69bb         	ldr	r3, [r7, #0x18]
 80078f8: 697a         	ldr	r2, [r7, #0x14]
 80078fa: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 80078fe: 2b00         	cmp	r3, #0x0
 8007900: d002         	beq	0x8007908 <stm32_gpio_intc_set_irq_callback+0x54> @ imm = #0x4
; 		return -EBUSY;
 8007902: f06f 030f    	mvn	r3, #0xf
 8007906: e00b         	b	0x8007920 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x16
; 	data->cb[line_num].cb = cb;
 8007908: 69bb         	ldr	r3, [r7, #0x18]
 800790a: 697a         	ldr	r2, [r7, #0x14]
 800790c: 68b9         	ldr	r1, [r7, #0x8]
 800790e: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = user;
 8007912: 69ba         	ldr	r2, [r7, #0x18]
 8007914: 697b         	ldr	r3, [r7, #0x14]
 8007916: 00db         	lsls	r3, r3, #0x3
 8007918: 4413         	add	r3, r2
 800791a: 687a         	ldr	r2, [r7, #0x4]
 800791c: 605a         	str	r2, [r3, #0x4]
; 	return 0;
 800791e: 2300         	movs	r3, #0x0
; }
 8007920: 4618         	mov	r0, r3
 8007922: 3720         	adds	r7, #0x20
 8007924: 46bd         	mov	sp, r7
 8007926: bd80         	pop	{r7, pc}

08007928 <$d>:
 8007928: a8 01 02 08  	.word	0x080201a8

0800792c <stm32_gpio_intc_remove_irq_callback>:
; {
 800792c: b580         	push	{r7, lr}
 800792e: b086         	sub	sp, #0x18
 8007930: af00         	add	r7, sp, #0x0
 8007932: 6078         	str	r0, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 8007934: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007968 <stm32_gpio_intc_remove_irq_callback+0x3c>
 8007936: 617b         	str	r3, [r7, #0x14]
; 	struct stm32_exti_data *data = dev->data;
 8007938: 697b         	ldr	r3, [r7, #0x14]
 800793a: 691b         	ldr	r3, [r3, #0x10]
 800793c: 613b         	str	r3, [r7, #0x10]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 800793e: 6878         	ldr	r0, [r7, #0x4]
 8007940: f010 f900    	bl	0x8017b44 <ll_exti_line_to_linenum> @ imm = #0x10200
 8007944: 4603         	mov	r3, r0
 8007946: 60fb         	str	r3, [r7, #0xc]
; 	data->cb[line_num].cb = NULL;
 8007948: 693b         	ldr	r3, [r7, #0x10]
 800794a: 68fa         	ldr	r2, [r7, #0xc]
 800794c: 2100         	movs	r1, #0x0
 800794e: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = NULL;
 8007952: 693a         	ldr	r2, [r7, #0x10]
 8007954: 68fb         	ldr	r3, [r7, #0xc]
 8007956: 00db         	lsls	r3, r3, #0x3
 8007958: 4413         	add	r3, r2
 800795a: 2200         	movs	r2, #0x0
 800795c: 605a         	str	r2, [r3, #0x4]
; }
 800795e: bf00         	nop
 8007960: 3718         	adds	r7, #0x18
 8007962: 46bd         	mov	sp, r7
 8007964: bd80         	pop	{r7, pc}
 8007966: bf00         	nop

08007968 <$d>:
 8007968: a8 01 02 08  	.word	0x080201a8

0800796c <LL_RCC_HSE_DisableBypass>:
; {
 800796c: b480         	push	{r7}
 800796e: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 8007970: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8007988 <LL_RCC_HSE_DisableBypass+0x1c>
 8007972: 681b         	ldr	r3, [r3]
 8007974: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8007988 <LL_RCC_HSE_DisableBypass+0x1c>
 8007976: f423 2380    	bic	r3, r3, #0x40000
 800797a: 6013         	str	r3, [r2]
; }
 800797c: bf00         	nop
 800797e: 46bd         	mov	sp, r7
 8007980: f85d 7b04    	ldr	r7, [sp], #4
 8007984: 4770         	bx	lr
 8007986: bf00         	nop

08007988 <$d>:
 8007988: 00 38 02 40  	.word	0x40023800

0800798c <LL_RCC_HSE_Enable>:
; {
 800798c: b480         	push	{r7}
 800798e: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSEON);
 8007990: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80079a8 <LL_RCC_HSE_Enable+0x1c>
 8007992: 681b         	ldr	r3, [r3]
 8007994: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80079a8 <LL_RCC_HSE_Enable+0x1c>
 8007996: f443 3380    	orr	r3, r3, #0x10000
 800799a: 6013         	str	r3, [r2]
; }
 800799c: bf00         	nop
 800799e: 46bd         	mov	sp, r7
 80079a0: f85d 7b04    	ldr	r7, [sp], #4
 80079a4: 4770         	bx	lr
 80079a6: bf00         	nop

080079a8 <$d>:
 80079a8: 00 38 02 40  	.word	0x40023800

080079ac <LL_RCC_HSE_IsReady>:
; {
 80079ac: b480         	push	{r7}
 80079ae: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
 80079b0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80079d0 <LL_RCC_HSE_IsReady+0x24>
 80079b2: 681b         	ldr	r3, [r3]
 80079b4: f403 3300    	and	r3, r3, #0x20000
 80079b8: f5b3 3f00    	cmp.w	r3, #0x20000
 80079bc: bf0c         	ite	eq
 80079be: 2301         	moveq	r3, #0x1
 80079c0: 2300         	movne	r3, #0x0
 80079c2: b2db         	uxtb	r3, r3
; }
 80079c4: 4618         	mov	r0, r3
 80079c6: 46bd         	mov	sp, r7
 80079c8: f85d 7b04    	ldr	r7, [sp], #4
 80079cc: 4770         	bx	lr
 80079ce: bf00         	nop

080079d0 <$d>:
 80079d0: 00 38 02 40  	.word	0x40023800

080079d4 <LL_RCC_HSI_Enable>:
; {
 80079d4: b480         	push	{r7}
 80079d6: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSION);
 80079d8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80079f0 <LL_RCC_HSI_Enable+0x1c>
 80079da: 681b         	ldr	r3, [r3]
 80079dc: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80079f0 <LL_RCC_HSI_Enable+0x1c>
 80079de: f043 0301    	orr	r3, r3, #0x1
 80079e2: 6013         	str	r3, [r2]
; }
 80079e4: bf00         	nop
 80079e6: 46bd         	mov	sp, r7
 80079e8: f85d 7b04    	ldr	r7, [sp], #4
 80079ec: 4770         	bx	lr
 80079ee: bf00         	nop

080079f0 <$d>:
 80079f0: 00 38 02 40  	.word	0x40023800

080079f4 <LL_RCC_HSI_IsReady>:
; {
 80079f4: b480         	push	{r7}
 80079f6: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
 80079f8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007a14 <LL_RCC_HSI_IsReady+0x20>
 80079fa: 681b         	ldr	r3, [r3]
 80079fc: f003 0302    	and	r3, r3, #0x2
 8007a00: 2b02         	cmp	r3, #0x2
 8007a02: bf0c         	ite	eq
 8007a04: 2301         	moveq	r3, #0x1
 8007a06: 2300         	movne	r3, #0x0
 8007a08: b2db         	uxtb	r3, r3
; }
 8007a0a: 4618         	mov	r0, r3
 8007a0c: 46bd         	mov	sp, r7
 8007a0e: f85d 7b04    	ldr	r7, [sp], #4
 8007a12: 4770         	bx	lr

08007a14 <$d>:
 8007a14: 00 38 02 40  	.word	0x40023800

08007a18 <LL_RCC_LSI_Enable>:
; {
 8007a18: b480         	push	{r7}
 8007a1a: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CSR, RCC_CSR_LSION);
 8007a1c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8007a34 <LL_RCC_LSI_Enable+0x1c>
 8007a1e: 6f5b         	ldr	r3, [r3, #0x74]
 8007a20: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8007a34 <LL_RCC_LSI_Enable+0x1c>
 8007a22: f043 0301    	orr	r3, r3, #0x1
 8007a26: 6753         	str	r3, [r2, #0x74]
; }
 8007a28: bf00         	nop
 8007a2a: 46bd         	mov	sp, r7
 8007a2c: f85d 7b04    	ldr	r7, [sp], #4
 8007a30: 4770         	bx	lr
 8007a32: bf00         	nop

08007a34 <$d>:
 8007a34: 00 38 02 40  	.word	0x40023800

08007a38 <LL_RCC_LSI_IsReady>:
; {
 8007a38: b480         	push	{r7}
 8007a3a: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY));
 8007a3c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007a58 <LL_RCC_LSI_IsReady+0x20>
 8007a3e: 6f5b         	ldr	r3, [r3, #0x74]
 8007a40: f003 0302    	and	r3, r3, #0x2
 8007a44: 2b02         	cmp	r3, #0x2
 8007a46: bf0c         	ite	eq
 8007a48: 2301         	moveq	r3, #0x1
 8007a4a: 2300         	movne	r3, #0x0
 8007a4c: b2db         	uxtb	r3, r3
; }
 8007a4e: 4618         	mov	r0, r3
 8007a50: 46bd         	mov	sp, r7
 8007a52: f85d 7b04    	ldr	r7, [sp], #4
 8007a56: 4770         	bx	lr

08007a58 <$d>:
 8007a58: 00 38 02 40  	.word	0x40023800

08007a5c <LL_RCC_SetSysClkSource>:
; {
 8007a5c: b480         	push	{r7}
 8007a5e: b083         	sub	sp, #0xc
 8007a60: af00         	add	r7, sp, #0x0
 8007a62: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8007a64: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007a80 <LL_RCC_SetSysClkSource+0x24>
 8007a66: 689b         	ldr	r3, [r3, #0x8]
 8007a68: f023 0203    	bic	r2, r3, #0x3
 8007a6c: 4904         	ldr	r1, [pc, #0x10]         @ 0x8007a80 <LL_RCC_SetSysClkSource+0x24>
 8007a6e: 687b         	ldr	r3, [r7, #0x4]
 8007a70: 4313         	orrs	r3, r2
 8007a72: 608b         	str	r3, [r1, #0x8]
; }
 8007a74: bf00         	nop
 8007a76: 370c         	adds	r7, #0xc
 8007a78: 46bd         	mov	sp, r7
 8007a7a: f85d 7b04    	ldr	r7, [sp], #4
 8007a7e: 4770         	bx	lr

08007a80 <$d>:
 8007a80: 00 38 02 40  	.word	0x40023800

08007a84 <LL_RCC_GetSysClkSource>:
; {
 8007a84: b480         	push	{r7}
 8007a86: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8007a88: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8007a9c <LL_RCC_GetSysClkSource+0x18>
 8007a8a: 689b         	ldr	r3, [r3, #0x8]
 8007a8c: f003 030c    	and	r3, r3, #0xc
; }
 8007a90: 4618         	mov	r0, r3
 8007a92: 46bd         	mov	sp, r7
 8007a94: f85d 7b04    	ldr	r7, [sp], #4
 8007a98: 4770         	bx	lr
 8007a9a: bf00         	nop

08007a9c <$d>:
 8007a9c: 00 38 02 40  	.word	0x40023800

08007aa0 <LL_RCC_SetAHBPrescaler>:
; {
 8007aa0: b480         	push	{r7}
 8007aa2: b083         	sub	sp, #0xc
 8007aa4: af00         	add	r7, sp, #0x0
 8007aa6: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8007aa8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007ac4 <LL_RCC_SetAHBPrescaler+0x24>
 8007aaa: 689b         	ldr	r3, [r3, #0x8]
 8007aac: f023 02f0    	bic	r2, r3, #0xf0
 8007ab0: 4904         	ldr	r1, [pc, #0x10]         @ 0x8007ac4 <LL_RCC_SetAHBPrescaler+0x24>
 8007ab2: 687b         	ldr	r3, [r7, #0x4]
 8007ab4: 4313         	orrs	r3, r2
 8007ab6: 608b         	str	r3, [r1, #0x8]
; }
 8007ab8: bf00         	nop
 8007aba: 370c         	adds	r7, #0xc
 8007abc: 46bd         	mov	sp, r7
 8007abe: f85d 7b04    	ldr	r7, [sp], #4
 8007ac2: 4770         	bx	lr

08007ac4 <$d>:
 8007ac4: 00 38 02 40  	.word	0x40023800

08007ac8 <LL_RCC_SetAPB1Prescaler>:
; {
 8007ac8: b480         	push	{r7}
 8007aca: b083         	sub	sp, #0xc
 8007acc: af00         	add	r7, sp, #0x0
 8007ace: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 8007ad0: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007aec <LL_RCC_SetAPB1Prescaler+0x24>
 8007ad2: 689b         	ldr	r3, [r3, #0x8]
 8007ad4: f423 52e0    	bic	r2, r3, #0x1c00
 8007ad8: 4904         	ldr	r1, [pc, #0x10]         @ 0x8007aec <LL_RCC_SetAPB1Prescaler+0x24>
 8007ada: 687b         	ldr	r3, [r7, #0x4]
 8007adc: 4313         	orrs	r3, r2
 8007ade: 608b         	str	r3, [r1, #0x8]
; }
 8007ae0: bf00         	nop
 8007ae2: 370c         	adds	r7, #0xc
 8007ae4: 46bd         	mov	sp, r7
 8007ae6: f85d 7b04    	ldr	r7, [sp], #4
 8007aea: 4770         	bx	lr

08007aec <$d>:
 8007aec: 00 38 02 40  	.word	0x40023800

08007af0 <LL_RCC_SetAPB2Prescaler>:
; {
 8007af0: b480         	push	{r7}
 8007af2: b083         	sub	sp, #0xc
 8007af4: af00         	add	r7, sp, #0x0
 8007af6: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 8007af8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007b14 <LL_RCC_SetAPB2Prescaler+0x24>
 8007afa: 689b         	ldr	r3, [r3, #0x8]
 8007afc: f423 4260    	bic	r2, r3, #0xe000
 8007b00: 4904         	ldr	r1, [pc, #0x10]         @ 0x8007b14 <LL_RCC_SetAPB2Prescaler+0x24>
 8007b02: 687b         	ldr	r3, [r7, #0x4]
 8007b04: 4313         	orrs	r3, r2
 8007b06: 608b         	str	r3, [r1, #0x8]
; }
 8007b08: bf00         	nop
 8007b0a: 370c         	adds	r7, #0xc
 8007b0c: 46bd         	mov	sp, r7
 8007b0e: f85d 7b04    	ldr	r7, [sp], #4
 8007b12: 4770         	bx	lr

08007b14 <$d>:
 8007b14: 00 38 02 40  	.word	0x40023800

08007b18 <LL_RCC_GetAHBPrescaler>:
; {
 8007b18: b480         	push	{r7}
 8007b1a: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8007b1c: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8007b30 <LL_RCC_GetAHBPrescaler+0x18>
 8007b1e: 689b         	ldr	r3, [r3, #0x8]
 8007b20: f003 03f0    	and	r3, r3, #0xf0
; }
 8007b24: 4618         	mov	r0, r3
 8007b26: 46bd         	mov	sp, r7
 8007b28: f85d 7b04    	ldr	r7, [sp], #4
 8007b2c: 4770         	bx	lr
 8007b2e: bf00         	nop

08007b30 <$d>:
 8007b30: 00 38 02 40  	.word	0x40023800

08007b34 <LL_RCC_PLL_Enable>:
; {
 8007b34: b480         	push	{r7}
 8007b36: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_PLLON);
 8007b38: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8007b50 <LL_RCC_PLL_Enable+0x1c>
 8007b3a: 681b         	ldr	r3, [r3]
 8007b3c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8007b50 <LL_RCC_PLL_Enable+0x1c>
 8007b3e: f043 7380    	orr	r3, r3, #0x1000000
 8007b42: 6013         	str	r3, [r2]
; }
 8007b44: bf00         	nop
 8007b46: 46bd         	mov	sp, r7
 8007b48: f85d 7b04    	ldr	r7, [sp], #4
 8007b4c: 4770         	bx	lr
 8007b4e: bf00         	nop

08007b50 <$d>:
 8007b50: 00 38 02 40  	.word	0x40023800

08007b54 <LL_RCC_PLL_Disable>:
; {
 8007b54: b480         	push	{r7}
 8007b56: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8007b58: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8007b70 <LL_RCC_PLL_Disable+0x1c>
 8007b5a: 681b         	ldr	r3, [r3]
 8007b5c: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8007b70 <LL_RCC_PLL_Disable+0x1c>
 8007b5e: f023 7380    	bic	r3, r3, #0x1000000
 8007b62: 6013         	str	r3, [r2]
; }
 8007b64: bf00         	nop
 8007b66: 46bd         	mov	sp, r7
 8007b68: f85d 7b04    	ldr	r7, [sp], #4
 8007b6c: 4770         	bx	lr
 8007b6e: bf00         	nop

08007b70 <$d>:
 8007b70: 00 38 02 40  	.word	0x40023800

08007b74 <LL_RCC_PLL_IsReady>:
; {
 8007b74: b480         	push	{r7}
 8007b76: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8007b78: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8007b98 <LL_RCC_PLL_IsReady+0x24>
 8007b7a: 681b         	ldr	r3, [r3]
 8007b7c: f003 7300    	and	r3, r3, #0x2000000
 8007b80: f1b3 7f00    	cmp.w	r3, #0x2000000
 8007b84: bf0c         	ite	eq
 8007b86: 2301         	moveq	r3, #0x1
 8007b88: 2300         	movne	r3, #0x0
 8007b8a: b2db         	uxtb	r3, r3
; }
 8007b8c: 4618         	mov	r0, r3
 8007b8e: 46bd         	mov	sp, r7
 8007b90: f85d 7b04    	ldr	r7, [sp], #4
 8007b94: 4770         	bx	lr
 8007b96: bf00         	nop

08007b98 <$d>:
 8007b98: 00 38 02 40  	.word	0x40023800

08007b9c <enabled_clock>:
; {
 8007b9c: b480         	push	{r7}
 8007b9e: b085         	sub	sp, #0x14
 8007ba0: af00         	add	r7, sp, #0x0
 8007ba2: 6078         	str	r0, [r7, #0x4]
; 	int r = 0;
 8007ba4: 2300         	movs	r3, #0x0
 8007ba6: 60fb         	str	r3, [r7, #0xc]
; 	switch (src_clk) {
 8007ba8: 687b         	ldr	r3, [r7, #0x4]
 8007baa: 3b01         	subs	r3, #0x1
 8007bac: 2b08         	cmp	r3, #0x8
 8007bae: d825         	bhi	0x8007bfc <enabled_clock+0x60> @ imm = #0x4a
 8007bb0: a201         	adr	r2, #4 <enabled_clock+0x19>
 8007bb2: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8007bb6: bf00         	nop

08007bb8 <$d>:
 8007bb8: 03 7c 00 08  	.word	0x08007c03
 8007bbc: e5 7b 00 08  	.word	0x08007be5
 8007bc0: 03 7c 00 08  	.word	0x08007c03
 8007bc4: dd 7b 00 08  	.word	0x08007bdd
 8007bc8: 03 7c 00 08  	.word	0x08007c03
 8007bcc: 03 7c 00 08  	.word	0x08007c03
 8007bd0: 03 7c 00 08  	.word	0x08007c03
 8007bd4: ed 7b 00 08  	.word	0x08007bed
 8007bd8: f5 7b 00 08  	.word	0x08007bf5

08007bdc <$t>:
; 			r = -ENOTSUP;
 8007bdc: f06f 0385    	mvn	r3, #0x85
 8007be0: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8007be2: e00f         	b	0x8007c04 <enabled_clock+0x68> @ imm = #0x1e
; 			r = -ENOTSUP;
 8007be4: f06f 0385    	mvn	r3, #0x85
 8007be8: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8007bea: e00b         	b	0x8007c04 <enabled_clock+0x68> @ imm = #0x16
; 			r = -ENOTSUP;
 8007bec: f06f 0385    	mvn	r3, #0x85
 8007bf0: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8007bf2: e007         	b	0x8007c04 <enabled_clock+0x68> @ imm = #0xe
; 			r = -ENOTSUP;
 8007bf4: f06f 0385    	mvn	r3, #0x85
 8007bf8: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8007bfa: e003         	b	0x8007c04 <enabled_clock+0x68> @ imm = #0x6
; 		return -ENOTSUP;
 8007bfc: f06f 0385    	mvn	r3, #0x85
 8007c00: e001         	b	0x8007c06 <enabled_clock+0x6a> @ imm = #0x2
; 		break;
 8007c02: bf00         	nop
; 	return r;
 8007c04: 68fb         	ldr	r3, [r7, #0xc]
; }
 8007c06: 4618         	mov	r0, r3
 8007c08: 3714         	adds	r7, #0x14
 8007c0a: 46bd         	mov	sp, r7
 8007c0c: f85d 7b04    	ldr	r7, [sp], #4
 8007c10: 4770         	bx	lr
 8007c12: bf00         	nop

08007c14 <stm32_clock_control_get_subsys_rate>:
; {
 8007c14: b580         	push	{r7, lr}
 8007c16: b08a         	sub	sp, #0x28
 8007c18: af00         	add	r7, sp, #0x0
 8007c1a: 60f8         	str	r0, [r7, #0xc]
 8007c1c: 60b9         	str	r1, [r7, #0x8]
 8007c1e: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8007c20: 68bb         	ldr	r3, [r7, #0x8]
 8007c22: 627b         	str	r3, [r7, #0x24]
; 	uint32_t ahb_clock = SystemCoreClock;
 8007c24: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8007e08 <stm32_clock_control_get_subsys_rate+0x1f4>
 8007c26: 681b         	ldr	r3, [r3]
 8007c28: 623b         	str	r3, [r7, #0x20]
; 	uint32_t apb1_clock = get_bus_clock(ahb_clock, STM32_APB1_PRESCALER);
 8007c2a: 2104         	movs	r1, #0x4
 8007c2c: 6a38         	ldr	r0, [r7, #0x20]
 8007c2e: f010 f805    	bl	0x8017c3c <get_bus_clock> @ imm = #0x1000a
 8007c32: 61f8         	str	r0, [r7, #0x1c]
; 	uint32_t apb2_clock = get_bus_clock(ahb_clock, STM32_APB2_PRESCALER);
 8007c34: 2102         	movs	r1, #0x2
 8007c36: 6a38         	ldr	r0, [r7, #0x20]
 8007c38: f010 f800    	bl	0x8017c3c <get_bus_clock> @ imm = #0x10000
 8007c3c: 61b8         	str	r0, [r7, #0x18]
; 	uint32_t ahb3_clock = ahb_clock;
 8007c3e: 6a3b         	ldr	r3, [r7, #0x20]
 8007c40: 617b         	str	r3, [r7, #0x14]
; 	switch (pclken->bus) {
 8007c42: 6a7b         	ldr	r3, [r7, #0x24]
 8007c44: 681b         	ldr	r3, [r3]
 8007c46: 2b44         	cmp	r3, #0x44
 8007c48: f200 8092    	bhi.w	0x8007d70 <stm32_clock_control_get_subsys_rate+0x15c> @ imm = #0x124
 8007c4c: 2b00         	cmp	r3, #0x0
 8007c4e: f000 80d2    	beq.w	0x8007df6 <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x1a4
 8007c52: 3b01         	subs	r3, #0x1
 8007c54: 2b43         	cmp	r3, #0x43
 8007c56: f200 80ce    	bhi.w	0x8007df6 <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x19c
 8007c5a: a201         	adr	r2, #4 <stm32_clock_control_get_subsys_rate+0x4b>
 8007c5c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08007c60 <$d>:
 8007c60: 9f 7d 00 08  	.word	0x08007d9f
 8007c64: d5 7d 00 08  	.word	0x08007dd5
 8007c68: dd 7d 00 08  	.word	0x08007ddd
 8007c6c: e7 7d 00 08  	.word	0x08007de7
 8007c70: ef 7d 00 08  	.word	0x08007def
 8007c74: a9 7d 00 08  	.word	0x08007da9
 8007c78: bf 7d 00 08  	.word	0x08007dbf
 8007c7c: f7 7d 00 08  	.word	0x08007df7
 8007c80: f7 7d 00 08  	.word	0x08007df7
 8007c84: f7 7d 00 08  	.word	0x08007df7
 8007c88: f7 7d 00 08  	.word	0x08007df7
 8007c8c: f7 7d 00 08  	.word	0x08007df7
 8007c90: f7 7d 00 08  	.word	0x08007df7
 8007c94: f7 7d 00 08  	.word	0x08007df7
 8007c98: f7 7d 00 08  	.word	0x08007df7
 8007c9c: f7 7d 00 08  	.word	0x08007df7
 8007ca0: f7 7d 00 08  	.word	0x08007df7
 8007ca4: f7 7d 00 08  	.word	0x08007df7
 8007ca8: f7 7d 00 08  	.word	0x08007df7
 8007cac: f7 7d 00 08  	.word	0x08007df7
 8007cb0: f7 7d 00 08  	.word	0x08007df7
 8007cb4: f7 7d 00 08  	.word	0x08007df7
 8007cb8: f7 7d 00 08  	.word	0x08007df7
 8007cbc: f7 7d 00 08  	.word	0x08007df7
 8007cc0: f7 7d 00 08  	.word	0x08007df7
 8007cc4: f7 7d 00 08  	.word	0x08007df7
 8007cc8: f7 7d 00 08  	.word	0x08007df7
 8007ccc: f7 7d 00 08  	.word	0x08007df7
 8007cd0: f7 7d 00 08  	.word	0x08007df7
 8007cd4: f7 7d 00 08  	.word	0x08007df7
 8007cd8: f7 7d 00 08  	.word	0x08007df7
 8007cdc: f7 7d 00 08  	.word	0x08007df7
 8007ce0: f7 7d 00 08  	.word	0x08007df7
 8007ce4: f7 7d 00 08  	.word	0x08007df7
 8007ce8: f7 7d 00 08  	.word	0x08007df7
 8007cec: f7 7d 00 08  	.word	0x08007df7
 8007cf0: f7 7d 00 08  	.word	0x08007df7
 8007cf4: f7 7d 00 08  	.word	0x08007df7
 8007cf8: f7 7d 00 08  	.word	0x08007df7
 8007cfc: f7 7d 00 08  	.word	0x08007df7
 8007d00: f7 7d 00 08  	.word	0x08007df7
 8007d04: f7 7d 00 08  	.word	0x08007df7
 8007d08: f7 7d 00 08  	.word	0x08007df7
 8007d0c: f7 7d 00 08  	.word	0x08007df7
 8007d10: f7 7d 00 08  	.word	0x08007df7
 8007d14: f7 7d 00 08  	.word	0x08007df7
 8007d18: f7 7d 00 08  	.word	0x08007df7
 8007d1c: 77 7d 00 08  	.word	0x08007d77
 8007d20: f7 7d 00 08  	.word	0x08007df7
 8007d24: f7 7d 00 08  	.word	0x08007df7
 8007d28: f7 7d 00 08  	.word	0x08007df7
 8007d2c: 77 7d 00 08  	.word	0x08007d77
 8007d30: f7 7d 00 08  	.word	0x08007df7
 8007d34: f7 7d 00 08  	.word	0x08007df7
 8007d38: f7 7d 00 08  	.word	0x08007df7
 8007d3c: 7f 7d 00 08  	.word	0x08007d7f
 8007d40: f7 7d 00 08  	.word	0x08007df7
 8007d44: f7 7d 00 08  	.word	0x08007df7
 8007d48: f7 7d 00 08  	.word	0x08007df7
 8007d4c: f7 7d 00 08  	.word	0x08007df7
 8007d50: f7 7d 00 08  	.word	0x08007df7
 8007d54: f7 7d 00 08  	.word	0x08007df7
 8007d58: f7 7d 00 08  	.word	0x08007df7
 8007d5c: 87 7d 00 08  	.word	0x08007d87
 8007d60: f7 7d 00 08  	.word	0x08007df7
 8007d64: f7 7d 00 08  	.word	0x08007df7
 8007d68: f7 7d 00 08  	.word	0x08007df7
 8007d6c: 8f 7d 00 08  	.word	0x08007d8f

08007d70 <$t>:
 8007d70: 2ba8         	cmp	r3, #0xa8
 8007d72: d010         	beq	0x8007d96 <stm32_clock_control_get_subsys_rate+0x182> @ imm = #0x20
 8007d74: e03f         	b	0x8007df6 <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x7e
; 		*rate = ahb_clock;
 8007d76: 687b         	ldr	r3, [r7, #0x4]
 8007d78: 6a3a         	ldr	r2, [r7, #0x20]
 8007d7a: 601a         	str	r2, [r3]
; 		break;
 8007d7c: e03e         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x7c
; 		*rate = ahb3_clock;
 8007d7e: 687b         	ldr	r3, [r7, #0x4]
 8007d80: 697a         	ldr	r2, [r7, #0x14]
 8007d82: 601a         	str	r2, [r3]
; 		break;
 8007d84: e03a         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x74
; 		*rate = apb1_clock;
 8007d86: 687b         	ldr	r3, [r7, #0x4]
 8007d88: 69fa         	ldr	r2, [r7, #0x1c]
 8007d8a: 601a         	str	r2, [r3]
; 		break;
 8007d8c: e036         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x6c
; 		*rate = apb2_clock;
 8007d8e: 687b         	ldr	r3, [r7, #0x4]
 8007d90: 69ba         	ldr	r2, [r7, #0x18]
 8007d92: 601a         	str	r2, [r3]
; 		break;
 8007d94: e032         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x64
; 		*rate = ahb3_clock;
 8007d96: 687b         	ldr	r3, [r7, #0x4]
 8007d98: 697a         	ldr	r2, [r7, #0x14]
 8007d9a: 601a         	str	r2, [r3]
; 		break;
 8007d9c: e02e         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x5c
; 		*rate = SystemCoreClock * STM32_CORE_PRESCALER;
 8007d9e: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8007e08 <stm32_clock_control_get_subsys_rate+0x1f4>
 8007da0: 681a         	ldr	r2, [r3]
 8007da2: 687b         	ldr	r3, [r7, #0x4]
 8007da4: 601a         	str	r2, [r3]
; 		break;
 8007da6: e029         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x52
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 8007da8: f000 f8f0    	bl	0x8007f8c <get_pllsrc_frequency> @ imm = #0x1e0
 8007dac: 2302         	movs	r3, #0x2
 8007dae: 22a8         	movs	r2, #0xa8
 8007db0: 2106         	movs	r1, #0x6
 8007db2: f00f ff2c    	bl	0x8017c0e <get_pll_div_frequency> @ imm = #0xfe58
 8007db6: 4602         	mov	r2, r0
 8007db8: 687b         	ldr	r3, [r7, #0x4]
 8007dba: 601a         	str	r2, [r3]
; 		break;
 8007dbc: e01e         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x3c
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 8007dbe: f000 f8e5    	bl	0x8007f8c <get_pllsrc_frequency> @ imm = #0x1ca
 8007dc2: 2304         	movs	r3, #0x4
 8007dc4: 22a8         	movs	r2, #0xa8
 8007dc6: 2106         	movs	r1, #0x6
 8007dc8: f00f ff21    	bl	0x8017c0e <get_pll_div_frequency> @ imm = #0xfe42
 8007dcc: 4602         	mov	r2, r0
 8007dce: 687b         	ldr	r3, [r7, #0x4]
 8007dd0: 601a         	str	r2, [r3]
; 		break;
 8007dd2: e013         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x26
; 		*rate = STM32_LSE_FREQ;
 8007dd4: 687b         	ldr	r3, [r7, #0x4]
 8007dd6: 2200         	movs	r2, #0x0
 8007dd8: 601a         	str	r2, [r3]
; 		break;
 8007dda: e00f         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x1e
; 		*rate = STM32_LSI_FREQ;
 8007ddc: 687b         	ldr	r3, [r7, #0x4]
 8007dde: f44f 42fa    	mov.w	r2, #0x7d00
 8007de2: 601a         	str	r2, [r3]
; 		break;
 8007de4: e00a         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x14
; 		*rate = STM32_HSI_FREQ;
 8007de6: 687b         	ldr	r3, [r7, #0x4]
 8007de8: 2200         	movs	r2, #0x0
 8007dea: 601a         	str	r2, [r3]
; 		break;
 8007dec: e006         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0xc
; 		*rate = STM32_HSE_FREQ;
 8007dee: 687b         	ldr	r3, [r7, #0x4]
 8007df0: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8007e0c <stm32_clock_control_get_subsys_rate+0x1f8>
 8007df2: 601a         	str	r2, [r3]
; 		break;
 8007df4: e002         	b	0x8007dfc <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x4
; 		return -ENOTSUP;
 8007df6: f06f 0385    	mvn	r3, #0x85
 8007dfa: e000         	b	0x8007dfe <stm32_clock_control_get_subsys_rate+0x1ea> @ imm = #0x0
; 	return 0;
 8007dfc: 2300         	movs	r3, #0x0
; }
 8007dfe: 4618         	mov	r0, r3
 8007e00: 3728         	adds	r7, #0x28
 8007e02: 46bd         	mov	sp, r7
 8007e04: bd80         	pop	{r7, pc}
 8007e06: bf00         	nop

08007e08 <$d>:
 8007e08: ec 05 00 20  	.word	0x200005ec
 8007e0c: 00 1b b7 00  	.word	0x00b71b00

08007e10 <set_up_plls>:
; {
 8007e10: b580         	push	{r7, lr}
 8007e12: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_GetSysClkSource() == LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 8007e14: f7ff fe36    	bl	0x8007a84 <LL_RCC_GetSysClkSource> @ imm = #-0x394
 8007e18: 4603         	mov	r3, r0
 8007e1a: 2b08         	cmp	r3, #0x8
 8007e1c: d104         	bne	0x8007e28 <set_up_plls+0x18> @ imm = #0x8
; 		stm32_clock_switch_to_hsi();
 8007e1e: f010 f81c    	bl	0x8017e5a <stm32_clock_switch_to_hsi> @ imm = #0x10038
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(1));
 8007e22: 2000         	movs	r0, #0x0
 8007e24: f7ff fe3c    	bl	0x8007aa0 <LL_RCC_SetAHBPrescaler> @ imm = #-0x388
; 	LL_RCC_PLL_Disable();
 8007e28: f7ff fe94    	bl	0x8007b54 <LL_RCC_PLL_Disable> @ imm = #-0x2d8
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, pllp(STM32_PLL_P_DIVISOR));
 8007e2c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8007e64 <set_up_plls+0x54>
 8007e2e: 685b         	ldr	r3, [r3, #0x4]
 8007e30: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8007e64 <set_up_plls+0x54>
 8007e32: f423 3340    	bic	r3, r3, #0x30000
 8007e36: 6053         	str	r3, [r2, #0x4]
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ, pllq(STM32_PLL_Q_DIVISOR));
 8007e38: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8007e64 <set_up_plls+0x54>
 8007e3a: 685b         	ldr	r3, [r3, #0x4]
 8007e3c: f023 6370    	bic	r3, r3, #0xf000000
 8007e40: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007e64 <set_up_plls+0x54>
 8007e42: f043 6380    	orr	r3, r3, #0x4000000
 8007e46: 6053         	str	r3, [r2, #0x4]
; 	config_pll_sysclock();
 8007e48: f010 f84c    	bl	0x8017ee4 <config_pll_sysclock> @ imm = #0x10098
; 	LL_RCC_PLL_Enable();
 8007e4c: f7ff fe72    	bl	0x8007b34 <LL_RCC_PLL_Enable> @ imm = #-0x31c
; 	while (LL_RCC_PLL_IsReady() != 1U) {
 8007e50: bf00         	nop
 8007e52: f7ff fe8f    	bl	0x8007b74 <LL_RCC_PLL_IsReady> @ imm = #-0x2e2
 8007e56: 4603         	mov	r3, r0
 8007e58: 2b01         	cmp	r3, #0x1
 8007e5a: d1fa         	bne	0x8007e52 <set_up_plls+0x42> @ imm = #-0xc
; }
 8007e5c: bf00         	nop
 8007e5e: bf00         	nop
 8007e60: bd80         	pop	{r7, pc}
 8007e62: bf00         	nop

08007e64 <$d>:
 8007e64: 00 38 02 40  	.word	0x40023800

08007e68 <stm32_clock_control_init>:
; {
 8007e68: b590         	push	{r4, r7, lr}
 8007e6a: b085         	sub	sp, #0x14
 8007e6c: af00         	add	r7, sp, #0x0
 8007e6e: 6078         	str	r0, [r7, #0x4]
; 	config_enable_default_clocks();
 8007e70: f010 f843    	bl	0x8017efa <config_enable_default_clocks> @ imm = #0x10086
; 	config_regulator_voltage(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC);
 8007e74: 4823         	ldr	r0, [pc, #0x8c]         @ 0x8007f04 <stm32_clock_control_init+0x9c>
 8007e76: f010 f822    	bl	0x8017ebe <config_regulator_voltage> @ imm = #0x10044
; 	old_flash_freq = RCC_CALC_FLASH_FREQ(HAL_RCC_GetSysClockFreq(),
 8007e7a: f006 fd7b    	bl	0x800e974 <HAL_RCC_GetSysClockFreq> @ imm = #0x6af6
 8007e7e: 4604         	mov	r4, r0
 8007e80: f7ff fe4a    	bl	0x8007b18 <LL_RCC_GetAHBPrescaler> @ imm = #-0x36c
 8007e84: 4603         	mov	r3, r0
 8007e86: 091b         	lsrs	r3, r3, #0x4
 8007e88: f003 030f    	and	r3, r3, #0xf
 8007e8c: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x8007f08 <stm32_clock_control_init+0xa0>
 8007e8e: 5cd3         	ldrb	r3, [r2, r3]
 8007e90: fa24 f303    	lsr.w	r3, r4, r3
 8007e94: 60fb         	str	r3, [r7, #0xc]
; 	new_flash_freq = RCC_CALC_FLASH_FREQ(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC,
 8007e96: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8007f08 <stm32_clock_control_init+0xa0>
 8007e98: 781b         	ldrb	r3, [r3]
 8007e9a: 461a         	mov	r2, r3
 8007e9c: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8007f04 <stm32_clock_control_init+0x9c>
 8007e9e: 4113         	asrs	r3, r2
 8007ea0: 60bb         	str	r3, [r7, #0x8]
; 	if (old_flash_freq < new_flash_freq) {
 8007ea2: 68fa         	ldr	r2, [r7, #0xc]
 8007ea4: 68bb         	ldr	r3, [r7, #0x8]
 8007ea6: 429a         	cmp	r2, r3
 8007ea8: d202         	bhs	0x8007eb0 <stm32_clock_control_init+0x48> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 8007eaa: 68b8         	ldr	r0, [r7, #0x8]
 8007eac: f007 f9a2    	bl	0x800f1f4 <LL_SetFlashLatency> @ imm = #0x7344
; 	set_up_fixed_clock_sources();
 8007eb0: f00f ffee    	bl	0x8017e90 <set_up_fixed_clock_sources> @ imm = #0xffdc
; 	set_up_plls();
 8007eb4: f7ff ffac    	bl	0x8007e10 <set_up_plls> @ imm = #-0xa8
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(STM32_CORE_PRESCALER));
 8007eb8: 2000         	movs	r0, #0x0
 8007eba: f7ff fdf1    	bl	0x8007aa0 <LL_RCC_SetAHBPrescaler> @ imm = #-0x41e
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
 8007ebe: 2002         	movs	r0, #0x2
 8007ec0: f7ff fdcc    	bl	0x8007a5c <LL_RCC_SetSysClkSource> @ imm = #-0x468
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 8007ec4: bf00         	nop
 8007ec6: f7ff fddd    	bl	0x8007a84 <LL_RCC_GetSysClkSource> @ imm = #-0x446
 8007eca: 4603         	mov	r3, r0
 8007ecc: 2b08         	cmp	r3, #0x8
 8007ece: d1fa         	bne	0x8007ec6 <stm32_clock_control_init+0x5e> @ imm = #-0xc
; 	if (old_flash_freq >= new_flash_freq) {
 8007ed0: 68fa         	ldr	r2, [r7, #0xc]
 8007ed2: 68bb         	ldr	r3, [r7, #0x8]
 8007ed4: 429a         	cmp	r2, r3
 8007ed6: d302         	blo	0x8007ede <stm32_clock_control_init+0x76> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 8007ed8: 68b8         	ldr	r0, [r7, #0x8]
 8007eda: f007 f98b    	bl	0x800f1f4 <LL_SetFlashLatency> @ imm = #0x7316
; 	SystemCoreClock = CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC;
 8007ede: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8007f0c <stm32_clock_control_init+0xa4>
 8007ee0: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8007f04 <stm32_clock_control_init+0x9c>
 8007ee2: 601a         	str	r2, [r3]
; 	LL_RCC_SetAPB1Prescaler(apb1_prescaler(STM32_APB1_PRESCALER));
 8007ee4: f44f 50a0    	mov.w	r0, #0x1400
 8007ee8: f7ff fdee    	bl	0x8007ac8 <LL_RCC_SetAPB1Prescaler> @ imm = #-0x424
; 	LL_RCC_SetAPB2Prescaler(apb2_prescaler(STM32_APB2_PRESCALER));
 8007eec: f44f 4000    	mov.w	r0, #0x8000
 8007ef0: f7ff fdfe    	bl	0x8007af0 <LL_RCC_SetAPB2Prescaler> @ imm = #-0x404
; 	stm32_clock_control_mco_init();
 8007ef4: f00f fe84    	bl	0x8017c00 <stm32_clock_control_mco_init> @ imm = #0xfd08
; 	return 0;
 8007ef8: 2300         	movs	r3, #0x0
; }
 8007efa: 4618         	mov	r0, r3
 8007efc: 3714         	adds	r7, #0x14
 8007efe: 46bd         	mov	sp, r7
 8007f00: bd90         	pop	{r4, r7, pc}
 8007f02: bf00         	nop

08007f04 <$d>:
 8007f04: 00 7a 03 0a  	.word	0x0a037a00
 8007f08: 84 2e 02 08  	.word	0x08022e84
 8007f0c: ec 05 00 20  	.word	0x200005ec

08007f10 <LL_APB1_GRP1_EnableClock>:
; {
 8007f10: b480         	push	{r7}
 8007f12: b085         	sub	sp, #0x14
 8007f14: af00         	add	r7, sp, #0x0
 8007f16: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(RCC->APB1ENR, Periphs);
 8007f18: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8007f3c <LL_APB1_GRP1_EnableClock+0x2c>
 8007f1a: 6c1a         	ldr	r2, [r3, #0x40]
 8007f1c: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8007f3c <LL_APB1_GRP1_EnableClock+0x2c>
 8007f1e: 687b         	ldr	r3, [r7, #0x4]
 8007f20: 4313         	orrs	r3, r2
 8007f22: 640b         	str	r3, [r1, #0x40]
;   tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8007f24: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8007f3c <LL_APB1_GRP1_EnableClock+0x2c>
 8007f26: 6c1a         	ldr	r2, [r3, #0x40]
 8007f28: 687b         	ldr	r3, [r7, #0x4]
 8007f2a: 4013         	ands	r3, r2
 8007f2c: 60fb         	str	r3, [r7, #0xc]
;   (void)tmpreg;
 8007f2e: 68fb         	ldr	r3, [r7, #0xc]
; }
 8007f30: bf00         	nop
 8007f32: 3714         	adds	r7, #0x14
 8007f34: 46bd         	mov	sp, r7
 8007f36: f85d 7b04    	ldr	r7, [sp], #4
 8007f3a: 4770         	bx	lr

08007f3c <$d>:
 8007f3c: 00 38 02 40  	.word	0x40023800

08007f40 <LL_RCC_PLL_ConfigDomain_SYS>:
; {
 8007f40: b480         	push	{r7}
 8007f42: b085         	sub	sp, #0x14
 8007f44: af00         	add	r7, sp, #0x0
 8007f46: 60f8         	str	r0, [r7, #0xc]
 8007f48: 60b9         	str	r1, [r7, #0x8]
 8007f4a: 607a         	str	r2, [r7, #0x4]
 8007f4c: 603b         	str	r3, [r7]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN,
 8007f4e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8007f84 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8007f50: 685a         	ldr	r2, [r3, #0x4]
 8007f52: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8007f88 <LL_RCC_PLL_ConfigDomain_SYS+0x48>
 8007f54: 4013         	ands	r3, r2
 8007f56: 68f9         	ldr	r1, [r7, #0xc]
 8007f58: 68ba         	ldr	r2, [r7, #0x8]
 8007f5a: 4311         	orrs	r1, r2
 8007f5c: 687a         	ldr	r2, [r7, #0x4]
 8007f5e: 0192         	lsls	r2, r2, #0x6
 8007f60: 430a         	orrs	r2, r1
 8007f62: 4908         	ldr	r1, [pc, #0x20]         @ 0x8007f84 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8007f64: 4313         	orrs	r3, r2
 8007f66: 604b         	str	r3, [r1, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, PLLP_R);
 8007f68: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007f84 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8007f6a: 685b         	ldr	r3, [r3, #0x4]
 8007f6c: f423 3240    	bic	r2, r3, #0x30000
 8007f70: 4904         	ldr	r1, [pc, #0x10]         @ 0x8007f84 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8007f72: 683b         	ldr	r3, [r7]
 8007f74: 4313         	orrs	r3, r2
 8007f76: 604b         	str	r3, [r1, #0x4]
; }
 8007f78: bf00         	nop
 8007f7a: 3714         	adds	r7, #0x14
 8007f7c: 46bd         	mov	sp, r7
 8007f7e: f85d 7b04    	ldr	r7, [sp], #4
 8007f82: 4770         	bx	lr

08007f84 <$d>:
 8007f84: 00 38 02 40  	.word	0x40023800
 8007f88: 00 80 bf ff  	.word	0xffbf8000

08007f8c <get_pllsrc_frequency>:
; {
 8007f8c: b480         	push	{r7}
 8007f8e: af00         	add	r7, sp, #0x0
; 		return STM32_HSE_FREQ;
 8007f90: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8007f9c <get_pllsrc_frequency+0x10>
; }
 8007f92: 4618         	mov	r0, r3
 8007f94: 46bd         	mov	sp, r7
 8007f96: f85d 7b04    	ldr	r7, [sp], #4
 8007f9a: 4770         	bx	lr

08007f9c <$d>:
 8007f9c: 00 1b b7 00  	.word	0x00b71b00

08007fa0 <console_out>:
; {
 8007fa0: b580         	push	{r7, lr}
 8007fa2: b082         	sub	sp, #0x8
 8007fa4: af00         	add	r7, sp, #0x0
 8007fa6: 6078         	str	r0, [r7, #0x4]
; 	if (pm_device_runtime_get(uart_console_dev) < 0) {
 8007fa8: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8007ff4 <console_out+0x54>
 8007faa: 4618         	mov	r0, r3
 8007fac: f00f ffdb    	bl	0x8017f66 <pm_device_runtime_get> @ imm = #0xffb6
 8007fb0: 4603         	mov	r3, r0
 8007fb2: 2b00         	cmp	r3, #0x0
 8007fb4: da01         	bge	0x8007fba <console_out+0x1a> @ imm = #0x2
; 		return c;
 8007fb6: 6879         	ldr	r1, [r7, #0x4]
 8007fb8: e017         	b	0x8007fea <console_out+0x4a> @ imm = #0x2e
; 	if ('\n' == c) {
 8007fba: 687b         	ldr	r3, [r7, #0x4]
 8007fbc: 2b0a         	cmp	r3, #0xa
 8007fbe: d104         	bne	0x8007fca <console_out+0x2a> @ imm = #0x8
; 		uart_poll_out(uart_console_dev, '\r');
 8007fc0: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007ff4 <console_out+0x54>
 8007fc2: 210d         	movs	r1, #0xd
 8007fc4: 4618         	mov	r0, r3
 8007fc6: f00f ffbf    	bl	0x8017f48 <uart_poll_out> @ imm = #0xff7e
; 	uart_poll_out(uart_console_dev, c);
 8007fca: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8007ff4 <console_out+0x54>
 8007fcc: 687b         	ldr	r3, [r7, #0x4]
 8007fce: b2db         	uxtb	r3, r3
 8007fd0: 4619         	mov	r1, r3
 8007fd2: 4610         	mov	r0, r2
 8007fd4: f00f ffb8    	bl	0x8017f48 <uart_poll_out> @ imm = #0xff70
; 	(void)pm_device_runtime_put_async(uart_console_dev, K_MSEC(1));
 8007fd8: 4906         	ldr	r1, [pc, #0x18]         @ 0x8007ff4 <console_out+0x54>
 8007fda: f04f 020a    	mov.w	r2, #0xa
 8007fde: f04f 0300    	mov.w	r3, #0x0
 8007fe2: 4608         	mov	r0, r1
 8007fe4: f00f ffca    	bl	0x8017f7c <pm_device_runtime_put_async> @ imm = #0xff94
; 	return c;
 8007fe8: 6879         	ldr	r1, [r7, #0x4]
; }
 8007fea: 460b         	mov	r3, r1
 8007fec: 4618         	mov	r0, r3
 8007fee: 3708         	adds	r7, #0x8
 8007ff0: 46bd         	mov	sp, r7
 8007ff2: bd80         	pop	{r7, pc}

08007ff4 <$d>:
 8007ff4: 98 02 02 08  	.word	0x08020298

08007ff8 <uart_console_hook_install>:
; {
 8007ff8: b580         	push	{r7, lr}
 8007ffa: af00         	add	r7, sp, #0x0
; 	__stdout_hook_install(console_out);
 8007ffc: 4803         	ldr	r0, [pc, #0xc]          @ 0x800800c <uart_console_hook_install+0x14>
 8007ffe: f7ff f989    	bl	0x8007314 <__stdout_hook_install> @ imm = #-0xcee
; 	__printk_hook_install(console_out);
 8008002: 4802         	ldr	r0, [pc, #0x8]          @ 0x800800c <uart_console_hook_install+0x14>
 8008004: f7fc fff8    	bl	0x8004ff8 <__printk_hook_install> @ imm = #-0x3010
; }
 8008008: bf00         	nop
 800800a: bd80         	pop	{r7, pc}

0800800c <$d>:
 800800c: a1 7f 00 08  	.word	0x08007fa1

08008010 <uart_console_init>:
; {
 8008010: b580         	push	{r7, lr}
 8008012: af00         	add	r7, sp, #0x0
; 	if (!device_is_ready(uart_console_dev)) {
 8008014: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8008038 <uart_console_init+0x28>
 8008016: 4618         	mov	r0, r3
 8008018: f00f ff77    	bl	0x8017f0a <device_is_ready> @ imm = #0xfeee
 800801c: 4603         	mov	r3, r0
 800801e: f083 0301    	eor	r3, r3, #0x1
 8008022: b2db         	uxtb	r3, r3
 8008024: 2b00         	cmp	r3, #0x0
 8008026: d002         	beq	0x800802e <uart_console_init+0x1e> @ imm = #0x4
; 		return -ENODEV;
 8008028: f06f 0312    	mvn	r3, #0x12
 800802c: e002         	b	0x8008034 <uart_console_init+0x24> @ imm = #0x4
; 	uart_console_hook_install();
 800802e: f7ff ffe3    	bl	0x8007ff8 <uart_console_hook_install> @ imm = #-0x3a
; 	return 0;
 8008032: 2300         	movs	r3, #0x0
; }
 8008034: 4618         	mov	r0, r3
 8008036: bd80         	pop	{r7, pc}

08008038 <$d>:
 8008038: 98 02 02 08  	.word	0x08020298

0800803c <LL_DMA_SetDataLength>:
; {
 800803c: b480         	push	{r7}
 800803e: b085         	sub	sp, #0x14
 8008040: af00         	add	r7, sp, #0x0
 8008042: 60f8         	str	r0, [r7, #0xc]
 8008044: 60b9         	str	r1, [r7, #0x8]
 8008046: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT, NbData);
 8008048: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8008080 <LL_DMA_SetDataLength+0x44>
 800804a: 68bb         	ldr	r3, [r7, #0x8]
 800804c: 4413         	add	r3, r2
 800804e: 781b         	ldrb	r3, [r3]
 8008050: 461a         	mov	r2, r3
 8008052: 68fb         	ldr	r3, [r7, #0xc]
 8008054: 4413         	add	r3, r2
 8008056: 685b         	ldr	r3, [r3, #0x4]
 8008058: 0c1b         	lsrs	r3, r3, #0x10
 800805a: 041b         	lsls	r3, r3, #0x10
 800805c: 4908         	ldr	r1, [pc, #0x20]         @ 0x8008080 <LL_DMA_SetDataLength+0x44>
 800805e: 68ba         	ldr	r2, [r7, #0x8]
 8008060: 440a         	add	r2, r1
 8008062: 7812         	ldrb	r2, [r2]
 8008064: 4611         	mov	r1, r2
 8008066: 68fa         	ldr	r2, [r7, #0xc]
 8008068: 440a         	add	r2, r1
 800806a: 4611         	mov	r1, r2
 800806c: 687a         	ldr	r2, [r7, #0x4]
 800806e: 4313         	orrs	r3, r2
 8008070: 604b         	str	r3, [r1, #0x4]
; }
 8008072: bf00         	nop
 8008074: 3714         	adds	r7, #0x14
 8008076: 46bd         	mov	sp, r7
 8008078: f85d 7b04    	ldr	r7, [sp], #4
 800807c: 4770         	bx	lr
 800807e: bf00         	nop

08008080 <$d>:
 8008080: 7c 26 02 08  	.word	0x0802267c

08008084 <LL_DMA_GetDataLength>:
; {
 8008084: b480         	push	{r7}
 8008086: b083         	sub	sp, #0xc
 8008088: af00         	add	r7, sp, #0x0
 800808a: 6078         	str	r0, [r7, #0x4]
 800808c: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT));
 800808e: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80080ac <LL_DMA_GetDataLength+0x28>
 8008090: 683b         	ldr	r3, [r7]
 8008092: 4413         	add	r3, r2
 8008094: 781b         	ldrb	r3, [r3]
 8008096: 461a         	mov	r2, r3
 8008098: 687b         	ldr	r3, [r7, #0x4]
 800809a: 4413         	add	r3, r2
 800809c: 685b         	ldr	r3, [r3, #0x4]
 800809e: b29b         	uxth	r3, r3
; }
 80080a0: 4618         	mov	r0, r3
 80080a2: 370c         	adds	r7, #0xc
 80080a4: 46bd         	mov	sp, r7
 80080a6: f85d 7b04    	ldr	r7, [sp], #4
 80080aa: 4770         	bx	lr

080080ac <$d>:
 80080ac: 7c 26 02 08  	.word	0x0802267c

080080b0 <LL_DMA_DisableFifoMode>:
; {
 80080b0: b480         	push	{r7}
 80080b2: b083         	sub	sp, #0xc
 80080b4: af00         	add	r7, sp, #0x0
 80080b6: 6078         	str	r0, [r7, #0x4]
 80080b8: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_DMDIS);
 80080ba: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80080ec <LL_DMA_DisableFifoMode+0x3c>
 80080bc: 683b         	ldr	r3, [r7]
 80080be: 4413         	add	r3, r2
 80080c0: 781b         	ldrb	r3, [r3]
 80080c2: 461a         	mov	r2, r3
 80080c4: 687b         	ldr	r3, [r7, #0x4]
 80080c6: 4413         	add	r3, r2
 80080c8: 695b         	ldr	r3, [r3, #0x14]
 80080ca: 4908         	ldr	r1, [pc, #0x20]         @ 0x80080ec <LL_DMA_DisableFifoMode+0x3c>
 80080cc: 683a         	ldr	r2, [r7]
 80080ce: 440a         	add	r2, r1
 80080d0: 7812         	ldrb	r2, [r2]
 80080d2: 4611         	mov	r1, r2
 80080d4: 687a         	ldr	r2, [r7, #0x4]
 80080d6: 440a         	add	r2, r1
 80080d8: f023 0304    	bic	r3, r3, #0x4
 80080dc: 6153         	str	r3, [r2, #0x14]
; }
 80080de: bf00         	nop
 80080e0: 370c         	adds	r7, #0xc
 80080e2: 46bd         	mov	sp, r7
 80080e4: f85d 7b04    	ldr	r7, [sp], #4
 80080e8: 4770         	bx	lr
 80080ea: bf00         	nop

080080ec <$d>:
 80080ec: 7c 26 02 08  	.word	0x0802267c

080080f0 <LL_DMA_EnableFifoMode>:
; {
 80080f0: b480         	push	{r7}
 80080f2: b083         	sub	sp, #0xc
 80080f4: af00         	add	r7, sp, #0x0
 80080f6: 6078         	str	r0, [r7, #0x4]
 80080f8: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_DMDIS);
 80080fa: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800812c <LL_DMA_EnableFifoMode+0x3c>
 80080fc: 683b         	ldr	r3, [r7]
 80080fe: 4413         	add	r3, r2
 8008100: 781b         	ldrb	r3, [r3]
 8008102: 461a         	mov	r2, r3
 8008104: 687b         	ldr	r3, [r7, #0x4]
 8008106: 4413         	add	r3, r2
 8008108: 695b         	ldr	r3, [r3, #0x14]
 800810a: 4908         	ldr	r1, [pc, #0x20]         @ 0x800812c <LL_DMA_EnableFifoMode+0x3c>
 800810c: 683a         	ldr	r2, [r7]
 800810e: 440a         	add	r2, r1
 8008110: 7812         	ldrb	r2, [r2]
 8008112: 4611         	mov	r1, r2
 8008114: 687a         	ldr	r2, [r7, #0x4]
 8008116: 440a         	add	r2, r1
 8008118: f043 0304    	orr	r3, r3, #0x4
 800811c: 6153         	str	r3, [r2, #0x14]
; }
 800811e: bf00         	nop
 8008120: 370c         	adds	r7, #0xc
 8008122: 46bd         	mov	sp, r7
 8008124: f85d 7b04    	ldr	r7, [sp], #4
 8008128: 4770         	bx	lr
 800812a: bf00         	nop

0800812c <$d>:
 800812c: 7c 26 02 08  	.word	0x0802267c

08008130 <LL_DMA_SetMemoryAddress>:
; {
 8008130: b480         	push	{r7}
 8008132: b085         	sub	sp, #0x14
 8008134: af00         	add	r7, sp, #0x0
 8008136: 60f8         	str	r0, [r7, #0xc]
 8008138: 60b9         	str	r1, [r7, #0x8]
 800813a: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->M0AR, MemoryAddress);
 800813c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800815c <LL_DMA_SetMemoryAddress+0x2c>
 800813e: 68bb         	ldr	r3, [r7, #0x8]
 8008140: 4413         	add	r3, r2
 8008142: 781b         	ldrb	r3, [r3]
 8008144: 461a         	mov	r2, r3
 8008146: 68fb         	ldr	r3, [r7, #0xc]
 8008148: 4413         	add	r3, r2
 800814a: 461a         	mov	r2, r3
 800814c: 687b         	ldr	r3, [r7, #0x4]
 800814e: 60d3         	str	r3, [r2, #0xc]
; }
 8008150: bf00         	nop
 8008152: 3714         	adds	r7, #0x14
 8008154: 46bd         	mov	sp, r7
 8008156: f85d 7b04    	ldr	r7, [sp], #4
 800815a: 4770         	bx	lr

0800815c <$d>:
 800815c: 7c 26 02 08  	.word	0x0802267c

08008160 <LL_DMA_SetPeriphAddress>:
; {
 8008160: b480         	push	{r7}
 8008162: b085         	sub	sp, #0x14
 8008164: af00         	add	r7, sp, #0x0
 8008166: 60f8         	str	r0, [r7, #0xc]
 8008168: 60b9         	str	r1, [r7, #0x8]
 800816a: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->PAR, PeriphAddress);
 800816c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800818c <LL_DMA_SetPeriphAddress+0x2c>
 800816e: 68bb         	ldr	r3, [r7, #0x8]
 8008170: 4413         	add	r3, r2
 8008172: 781b         	ldrb	r3, [r3]
 8008174: 461a         	mov	r2, r3
 8008176: 68fb         	ldr	r3, [r7, #0xc]
 8008178: 4413         	add	r3, r2
 800817a: 461a         	mov	r2, r3
 800817c: 687b         	ldr	r3, [r7, #0x4]
 800817e: 6093         	str	r3, [r2, #0x8]
; }
 8008180: bf00         	nop
 8008182: 3714         	adds	r7, #0x14
 8008184: 46bd         	mov	sp, r7
 8008186: f85d 7b04    	ldr	r7, [sp], #4
 800818a: 4770         	bx	lr

0800818c <$d>:
 800818c: 7c 26 02 08  	.word	0x0802267c

08008190 <LL_DMA_EnableIT_HT>:
; {
 8008190: b480         	push	{r7}
 8008192: b083         	sub	sp, #0xc
 8008194: af00         	add	r7, sp, #0x0
 8008196: 6078         	str	r0, [r7, #0x4]
 8008198: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_HTIE);
 800819a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80081cc <LL_DMA_EnableIT_HT+0x3c>
 800819c: 683b         	ldr	r3, [r7]
 800819e: 4413         	add	r3, r2
 80081a0: 781b         	ldrb	r3, [r3]
 80081a2: 461a         	mov	r2, r3
 80081a4: 687b         	ldr	r3, [r7, #0x4]
 80081a6: 4413         	add	r3, r2
 80081a8: 681b         	ldr	r3, [r3]
 80081aa: 4908         	ldr	r1, [pc, #0x20]         @ 0x80081cc <LL_DMA_EnableIT_HT+0x3c>
 80081ac: 683a         	ldr	r2, [r7]
 80081ae: 440a         	add	r2, r1
 80081b0: 7812         	ldrb	r2, [r2]
 80081b2: 4611         	mov	r1, r2
 80081b4: 687a         	ldr	r2, [r7, #0x4]
 80081b6: 440a         	add	r2, r1
 80081b8: f043 0308    	orr	r3, r3, #0x8
 80081bc: 6013         	str	r3, [r2]
; }
 80081be: bf00         	nop
 80081c0: 370c         	adds	r7, #0xc
 80081c2: 46bd         	mov	sp, r7
 80081c4: f85d 7b04    	ldr	r7, [sp], #4
 80081c8: 4770         	bx	lr
 80081ca: bf00         	nop

080081cc <$d>:
 80081cc: 7c 26 02 08  	.word	0x0802267c

080081d0 <LL_DMA_EnableIT_TC>:
; {
 80081d0: b480         	push	{r7}
 80081d2: b083         	sub	sp, #0xc
 80081d4: af00         	add	r7, sp, #0x0
 80081d6: 6078         	str	r0, [r7, #0x4]
 80081d8: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE);
 80081da: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800820c <LL_DMA_EnableIT_TC+0x3c>
 80081dc: 683b         	ldr	r3, [r7]
 80081de: 4413         	add	r3, r2
 80081e0: 781b         	ldrb	r3, [r3]
 80081e2: 461a         	mov	r2, r3
 80081e4: 687b         	ldr	r3, [r7, #0x4]
 80081e6: 4413         	add	r3, r2
 80081e8: 681b         	ldr	r3, [r3]
 80081ea: 4908         	ldr	r1, [pc, #0x20]         @ 0x800820c <LL_DMA_EnableIT_TC+0x3c>
 80081ec: 683a         	ldr	r2, [r7]
 80081ee: 440a         	add	r2, r1
 80081f0: 7812         	ldrb	r2, [r2]
 80081f2: 4611         	mov	r1, r2
 80081f4: 687a         	ldr	r2, [r7, #0x4]
 80081f6: 440a         	add	r2, r1
 80081f8: f043 0310    	orr	r3, r3, #0x10
 80081fc: 6013         	str	r3, [r2]
; }
 80081fe: bf00         	nop
 8008200: 370c         	adds	r7, #0xc
 8008202: 46bd         	mov	sp, r7
 8008204: f85d 7b04    	ldr	r7, [sp], #4
 8008208: 4770         	bx	lr
 800820a: bf00         	nop

0800820c <$d>:
 800820c: 7c 26 02 08  	.word	0x0802267c

08008210 <LL_DMA_EnableIT_FE>:
; {
 8008210: b480         	push	{r7}
 8008212: b083         	sub	sp, #0xc
 8008214: af00         	add	r7, sp, #0x0
 8008216: 6078         	str	r0, [r7, #0x4]
 8008218: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 800821a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800824c <LL_DMA_EnableIT_FE+0x3c>
 800821c: 683b         	ldr	r3, [r7]
 800821e: 4413         	add	r3, r2
 8008220: 781b         	ldrb	r3, [r3]
 8008222: 461a         	mov	r2, r3
 8008224: 687b         	ldr	r3, [r7, #0x4]
 8008226: 4413         	add	r3, r2
 8008228: 695b         	ldr	r3, [r3, #0x14]
 800822a: 4908         	ldr	r1, [pc, #0x20]         @ 0x800824c <LL_DMA_EnableIT_FE+0x3c>
 800822c: 683a         	ldr	r2, [r7]
 800822e: 440a         	add	r2, r1
 8008230: 7812         	ldrb	r2, [r2]
 8008232: 4611         	mov	r1, r2
 8008234: 687a         	ldr	r2, [r7, #0x4]
 8008236: 440a         	add	r2, r1
 8008238: f043 0380    	orr	r3, r3, #0x80
 800823c: 6153         	str	r3, [r2, #0x14]
; }
 800823e: bf00         	nop
 8008240: 370c         	adds	r7, #0xc
 8008242: 46bd         	mov	sp, r7
 8008244: f85d 7b04    	ldr	r7, [sp], #4
 8008248: 4770         	bx	lr
 800824a: bf00         	nop

0800824c <$d>:
 800824c: 7c 26 02 08  	.word	0x0802267c

08008250 <LL_DMA_DisableIT_TC>:
; {
 8008250: b480         	push	{r7}
 8008252: b083         	sub	sp, #0xc
 8008254: af00         	add	r7, sp, #0x0
 8008256: 6078         	str	r0, [r7, #0x4]
 8008258: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE);
 800825a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800828c <LL_DMA_DisableIT_TC+0x3c>
 800825c: 683b         	ldr	r3, [r7]
 800825e: 4413         	add	r3, r2
 8008260: 781b         	ldrb	r3, [r3]
 8008262: 461a         	mov	r2, r3
 8008264: 687b         	ldr	r3, [r7, #0x4]
 8008266: 4413         	add	r3, r2
 8008268: 681b         	ldr	r3, [r3]
 800826a: 4908         	ldr	r1, [pc, #0x20]         @ 0x800828c <LL_DMA_DisableIT_TC+0x3c>
 800826c: 683a         	ldr	r2, [r7]
 800826e: 440a         	add	r2, r1
 8008270: 7812         	ldrb	r2, [r2]
 8008272: 4611         	mov	r1, r2
 8008274: 687a         	ldr	r2, [r7, #0x4]
 8008276: 440a         	add	r2, r1
 8008278: f023 0310    	bic	r3, r3, #0x10
 800827c: 6013         	str	r3, [r2]
; }
 800827e: bf00         	nop
 8008280: 370c         	adds	r7, #0xc
 8008282: 46bd         	mov	sp, r7
 8008284: f85d 7b04    	ldr	r7, [sp], #4
 8008288: 4770         	bx	lr
 800828a: bf00         	nop

0800828c <$d>:
 800828c: 7c 26 02 08  	.word	0x0802267c

08008290 <LL_DMA_DisableIT_FE>:
; {
 8008290: b480         	push	{r7}
 8008292: b083         	sub	sp, #0xc
 8008294: af00         	add	r7, sp, #0x0
 8008296: 6078         	str	r0, [r7, #0x4]
 8008298: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 800829a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80082cc <LL_DMA_DisableIT_FE+0x3c>
 800829c: 683b         	ldr	r3, [r7]
 800829e: 4413         	add	r3, r2
 80082a0: 781b         	ldrb	r3, [r3]
 80082a2: 461a         	mov	r2, r3
 80082a4: 687b         	ldr	r3, [r7, #0x4]
 80082a6: 4413         	add	r3, r2
 80082a8: 695b         	ldr	r3, [r3, #0x14]
 80082aa: 4908         	ldr	r1, [pc, #0x20]         @ 0x80082cc <LL_DMA_DisableIT_FE+0x3c>
 80082ac: 683a         	ldr	r2, [r7]
 80082ae: 440a         	add	r2, r1
 80082b0: 7812         	ldrb	r2, [r2]
 80082b2: 4611         	mov	r1, r2
 80082b4: 687a         	ldr	r2, [r7, #0x4]
 80082b6: 440a         	add	r2, r1
 80082b8: f023 0380    	bic	r3, r3, #0x80
 80082bc: 6153         	str	r3, [r2, #0x14]
; }
 80082be: bf00         	nop
 80082c0: 370c         	adds	r7, #0xc
 80082c2: 46bd         	mov	sp, r7
 80082c4: f85d 7b04    	ldr	r7, [sp], #4
 80082c8: 4770         	bx	lr
 80082ca: bf00         	nop

080082cc <$d>:
 80082cc: 7c 26 02 08  	.word	0x0802267c

080082d0 <dma_stm32_irq_handler>:
; {
 80082d0: b590         	push	{r4, r7, lr}
 80082d2: b08f         	sub	sp, #0x3c
 80082d4: af04         	add	r7, sp, #0x10
 80082d6: 6078         	str	r0, [r7, #0x4]
 80082d8: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 80082da: 687b         	ldr	r3, [r7, #0x4]
 80082dc: 685b         	ldr	r3, [r3, #0x4]
 80082de: 627b         	str	r3, [r7, #0x24]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 80082e0: 6a7b         	ldr	r3, [r7, #0x24]
 80082e2: 691b         	ldr	r3, [r3, #0x10]
 80082e4: 623b         	str	r3, [r7, #0x20]
; 	stream = &config->streams[id];
 80082e6: 6a7b         	ldr	r3, [r7, #0x24]
 80082e8: 6999         	ldr	r1, [r3, #0x18]
 80082ea: 683a         	ldr	r2, [r7]
 80082ec: 4613         	mov	r3, r2
 80082ee: 00db         	lsls	r3, r3, #0x3
 80082f0: 1a9b         	subs	r3, r3, r2
 80082f2: 009b         	lsls	r3, r3, #0x2
 80082f4: 440b         	add	r3, r1
 80082f6: 61fb         	str	r3, [r7, #0x1c]
; 	if ((stream->hal_override != true) && (stream->busy == false)) {
 80082f8: 69fb         	ldr	r3, [r7, #0x1c]
 80082fa: 795b         	ldrb	r3, [r3, #0x5]
 80082fc: f083 0301    	eor	r3, r3, #0x1
 8008300: b2db         	uxtb	r3, r3
 8008302: 2b00         	cmp	r3, #0x0
 8008304: d00c         	beq	0x8008320 <dma_stm32_irq_handler+0x50> @ imm = #0x18
 8008306: 69fb         	ldr	r3, [r7, #0x1c]
 8008308: 799b         	ldrb	r3, [r3, #0x6]
 800830a: b2db         	uxtb	r3, r3
 800830c: f083 0301    	eor	r3, r3, #0x1
 8008310: b2db         	uxtb	r3, r3
 8008312: 2b00         	cmp	r3, #0x0
 8008314: d004         	beq	0x8008320 <dma_stm32_irq_handler+0x50> @ imm = #0x8
; 		dma_stm32_clear_stream_irq(dev, id);
 8008316: 6839         	ldr	r1, [r7]
 8008318: 6878         	ldr	r0, [r7, #0x4]
 800831a: f00f fe99    	bl	0x8018050 <dma_stm32_clear_stream_irq> @ imm = #0xfd32
; 		return;
 800831e: e09a         	b	0x8008456 <dma_stm32_irq_handler+0x186> @ imm = #0x134
; 	callback_arg = id + STM32_DMA_STREAM_OFFSET;
 8008320: 683b         	ldr	r3, [r7]
 8008322: 61bb         	str	r3, [r7, #0x18]
; 	if (stm32_dma_is_ht_irq_active(dma, id)) {
 8008324: 6839         	ldr	r1, [r7]
 8008326: 6a38         	ldr	r0, [r7, #0x20]
 8008328: f010 fecb    	bl	0x80190c2 <stm32_dma_is_ht_irq_active> @ imm = #0x10d96
 800832c: 4603         	mov	r3, r0
 800832e: 2b00         	cmp	r3, #0x0
 8008330: d013         	beq	0x800835a <dma_stm32_irq_handler+0x8a> @ imm = #0x26
; 		if (!stream->hal_override) {
 8008332: 69fb         	ldr	r3, [r7, #0x1c]
 8008334: 795b         	ldrb	r3, [r3, #0x5]
 8008336: f083 0301    	eor	r3, r3, #0x1
 800833a: b2db         	uxtb	r3, r3
 800833c: 2b00         	cmp	r3, #0x0
 800833e: d003         	beq	0x8008348 <dma_stm32_irq_handler+0x78> @ imm = #0x6
; 			dma_stm32_clear_ht(dma, id);
 8008340: 6839         	ldr	r1, [r7]
 8008342: 6a38         	ldr	r0, [r7, #0x20]
 8008344: f000 ff8c    	bl	0x8009260 <dma_stm32_clear_ht> @ imm = #0xf18
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_BLOCK);
 8008348: 69fb         	ldr	r3, [r7, #0x1c]
 800834a: 695c         	ldr	r4, [r3, #0x14]
 800834c: 69fb         	ldr	r3, [r7, #0x1c]
 800834e: 6919         	ldr	r1, [r3, #0x10]
 8008350: 2301         	movs	r3, #0x1
 8008352: 69ba         	ldr	r2, [r7, #0x18]
 8008354: 6878         	ldr	r0, [r7, #0x4]
 8008356: 47a0         	blx	r4
 8008358: e07d         	b	0x8008456 <dma_stm32_irq_handler+0x186> @ imm = #0xfa
; 	} else if (stm32_dma_is_tc_irq_active(dma, id)) {
 800835a: 6839         	ldr	r1, [r7]
 800835c: 6a38         	ldr	r0, [r7, #0x20]
 800835e: f010 fe8f    	bl	0x8019080 <stm32_dma_is_tc_irq_active> @ imm = #0x10d1e
 8008362: 4603         	mov	r3, r0
 8008364: 2b00         	cmp	r3, #0x0
 8008366: d01d         	beq	0x80083a4 <dma_stm32_irq_handler+0xd4> @ imm = #0x3a
; 		if (!stream->cyclic) {
 8008368: 69fb         	ldr	r3, [r7, #0x1c]
 800836a: 7e1b         	ldrb	r3, [r3, #0x18]
 800836c: f083 0301    	eor	r3, r3, #0x1
 8008370: b2db         	uxtb	r3, r3
 8008372: 2b00         	cmp	r3, #0x0
 8008374: d002         	beq	0x800837c <dma_stm32_irq_handler+0xac> @ imm = #0x4
; 			stream->busy = false;
 8008376: 69fb         	ldr	r3, [r7, #0x1c]
 8008378: 2200         	movs	r2, #0x0
 800837a: 719a         	strb	r2, [r3, #0x6]
; 		if (!stream->hal_override) {
 800837c: 69fb         	ldr	r3, [r7, #0x1c]
 800837e: 795b         	ldrb	r3, [r3, #0x5]
 8008380: f083 0301    	eor	r3, r3, #0x1
 8008384: b2db         	uxtb	r3, r3
 8008386: 2b00         	cmp	r3, #0x0
 8008388: d003         	beq	0x8008392 <dma_stm32_irq_handler+0xc2> @ imm = #0x6
; 			dma_stm32_clear_tc(dma, id);
 800838a: 6839         	ldr	r1, [r7]
 800838c: 6a38         	ldr	r0, [r7, #0x20]
 800838e: f000 ff79    	bl	0x8009284 <dma_stm32_clear_tc> @ imm = #0xef2
; 		stream->dma_callback(dev, stream->user_data, callback_arg, DMA_STATUS_COMPLETE);
 8008392: 69fb         	ldr	r3, [r7, #0x1c]
 8008394: 695c         	ldr	r4, [r3, #0x14]
 8008396: 69fb         	ldr	r3, [r7, #0x1c]
 8008398: 6919         	ldr	r1, [r3, #0x10]
 800839a: 2300         	movs	r3, #0x0
 800839c: 69ba         	ldr	r2, [r7, #0x18]
 800839e: 6878         	ldr	r0, [r7, #0x4]
 80083a0: 47a0         	blx	r4
 80083a2: e058         	b	0x8008456 <dma_stm32_irq_handler+0x186> @ imm = #0xb0
; 	} else if (stm32_dma_is_unexpected_irq_happened(dma, id)) {
 80083a4: 6839         	ldr	r1, [r7]
 80083a6: 6a38         	ldr	r0, [r7, #0x20]
 80083a8: f001 f87a    	bl	0x80094a0 <stm32_dma_is_unexpected_irq_happened> @ imm = #0x10f4
 80083ac: 4603         	mov	r3, r0
 80083ae: 2b00         	cmp	r3, #0x0
 80083b0: d023         	beq	0x80083fa <dma_stm32_irq_handler+0x12a> @ imm = #0x46
; 		LOG_ERR("Unexpected irq happened.");
 80083b2: 2303         	movs	r3, #0x3
 80083b4: 2b00         	cmp	r3, #0x0
 80083b6: d016         	beq	0x80083e6 <dma_stm32_irq_handler+0x116> @ imm = #0x2c
 80083b8: 2301         	movs	r3, #0x1
 80083ba: 73fb         	strb	r3, [r7, #0xf]
 80083bc: 7bfb         	ldrb	r3, [r7, #0xf]
 80083be: f083 0301    	eor	r3, r3, #0x1
 80083c2: b2db         	uxtb	r3, r3
 80083c4: 2b00         	cmp	r3, #0x0
 80083c6: d10e         	bne	0x80083e6 <dma_stm32_irq_handler+0x116> @ imm = #0x1c
 80083c8: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800845c <dma_stm32_irq_handler+0x18c>
 80083ca: 6819         	ldr	r1, [r3]
 80083cc: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8008460 <dma_stm32_irq_handler+0x190>
 80083ce: 9302         	str	r3, [sp, #0x8]
 80083d0: 2300         	movs	r3, #0x0
 80083d2: 9301         	str	r3, [sp, #0x4]
 80083d4: 2300         	movs	r3, #0x0
 80083d6: 9300         	str	r3, [sp]
 80083d8: 2300         	movs	r3, #0x0
 80083da: 2201         	movs	r2, #0x1
 80083dc: 2000         	movs	r0, #0x0
 80083de: f00f fe06    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xfc0c
 80083e2: 2300         	movs	r3, #0x0
 80083e4: 60bb         	str	r3, [r7, #0x8]
; 		stream->dma_callback(dev, stream->user_data,
 80083e6: 69fb         	ldr	r3, [r7, #0x1c]
 80083e8: 695c         	ldr	r4, [r3, #0x14]
 80083ea: 69fb         	ldr	r3, [r7, #0x1c]
 80083ec: 6919         	ldr	r1, [r3, #0x10]
 80083ee: f06f 0304    	mvn	r3, #0x4
 80083f2: 69ba         	ldr	r2, [r7, #0x18]
 80083f4: 6878         	ldr	r0, [r7, #0x4]
 80083f6: 47a0         	blx	r4
 80083f8: e02d         	b	0x8008456 <dma_stm32_irq_handler+0x186> @ imm = #0x5a
; 		LOG_ERR("Transfer Error.");
 80083fa: 2303         	movs	r3, #0x3
 80083fc: 2b00         	cmp	r3, #0x0
 80083fe: d016         	beq	0x800842e <dma_stm32_irq_handler+0x15e> @ imm = #0x2c
 8008400: 2301         	movs	r3, #0x1
 8008402: 75fb         	strb	r3, [r7, #0x17]
 8008404: 7dfb         	ldrb	r3, [r7, #0x17]
 8008406: f083 0301    	eor	r3, r3, #0x1
 800840a: b2db         	uxtb	r3, r3
 800840c: 2b00         	cmp	r3, #0x0
 800840e: d10e         	bne	0x800842e <dma_stm32_irq_handler+0x15e> @ imm = #0x1c
 8008410: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800845c <dma_stm32_irq_handler+0x18c>
 8008412: 6819         	ldr	r1, [r3]
 8008414: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8008464 <dma_stm32_irq_handler+0x194>
 8008416: 9302         	str	r3, [sp, #0x8]
 8008418: 2300         	movs	r3, #0x0
 800841a: 9301         	str	r3, [sp, #0x4]
 800841c: 2300         	movs	r3, #0x0
 800841e: 9300         	str	r3, [sp]
 8008420: 2300         	movs	r3, #0x0
 8008422: 2201         	movs	r2, #0x1
 8008424: 2000         	movs	r0, #0x0
 8008426: f00f fde2    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xfbc4
 800842a: 2300         	movs	r3, #0x0
 800842c: 613b         	str	r3, [r7, #0x10]
; 		stream->busy = false;
 800842e: 69fb         	ldr	r3, [r7, #0x1c]
 8008430: 2200         	movs	r2, #0x0
 8008432: 719a         	strb	r2, [r3, #0x6]
; 		dma_stm32_dump_stream_irq(dev, id);
 8008434: 6839         	ldr	r1, [r7]
 8008436: 6878         	ldr	r0, [r7, #0x4]
 8008438: f00f fdf7    	bl	0x801802a <dma_stm32_dump_stream_irq> @ imm = #0xfbee
; 		dma_stm32_clear_stream_irq(dev, id);
 800843c: 6839         	ldr	r1, [r7]
 800843e: 6878         	ldr	r0, [r7, #0x4]
 8008440: f00f fe06    	bl	0x8018050 <dma_stm32_clear_stream_irq> @ imm = #0xfc0c
; 		stream->dma_callback(dev, stream->user_data,
 8008444: 69fb         	ldr	r3, [r7, #0x1c]
 8008446: 695c         	ldr	r4, [r3, #0x14]
 8008448: 69fb         	ldr	r3, [r7, #0x1c]
 800844a: 6919         	ldr	r1, [r3, #0x10]
 800844c: f06f 0304    	mvn	r3, #0x4
 8008450: 69ba         	ldr	r2, [r7, #0x18]
 8008452: 6878         	ldr	r0, [r7, #0x4]
 8008454: 47a0         	blx	r4
; }
 8008456: 372c         	adds	r7, #0x2c
 8008458: 46bd         	mov	sp, r7
 800845a: bd90         	pop	{r4, r7, pc}

0800845c <$d>:
 800845c: 4c 05 00 20  	.word	0x2000054c
 8008460: f8 0f 02 08  	.word	0x08020ff8
 8008464: 14 10 02 08  	.word	0x08021014

08008468 <dma_stm32_get_priority>:
; {
 8008468: b580         	push	{r7, lr}
 800846a: b088         	sub	sp, #0x20
 800846c: af04         	add	r7, sp, #0x10
 800846e: 4603         	mov	r3, r0
 8008470: 6039         	str	r1, [r7]
 8008472: 71fb         	strb	r3, [r7, #0x7]
; 	switch (priority) {
 8008474: 79fb         	ldrb	r3, [r7, #0x7]
 8008476: 2b03         	cmp	r3, #0x3
 8008478: d81d         	bhi	0x80084b6 <dma_stm32_get_priority+0x4e> @ imm = #0x3a
 800847a: a201         	adr	r2, #4 <dma_stm32_get_priority+0x17>
 800847c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08008480 <$d>:
 8008480: 91 84 00 08  	.word	0x08008491
 8008484: 99 84 00 08  	.word	0x08008499
 8008488: a3 84 00 08  	.word	0x080084a3
 800848c: ad 84 00 08  	.word	0x080084ad

08008490 <$t>:
; 		*ll_priority = LL_DMA_PRIORITY_LOW;
 8008490: 683b         	ldr	r3, [r7]
 8008492: 2200         	movs	r2, #0x0
 8008494: 601a         	str	r2, [r3]
; 		break;
 8008496: e02d         	b	0x80084f4 <dma_stm32_get_priority+0x8c> @ imm = #0x5a
; 		*ll_priority = LL_DMA_PRIORITY_MEDIUM;
 8008498: 683b         	ldr	r3, [r7]
 800849a: f44f 3280    	mov.w	r2, #0x10000
 800849e: 601a         	str	r2, [r3]
; 		break;
 80084a0: e028         	b	0x80084f4 <dma_stm32_get_priority+0x8c> @ imm = #0x50
; 		*ll_priority = LL_DMA_PRIORITY_HIGH;
 80084a2: 683b         	ldr	r3, [r7]
 80084a4: f44f 3200    	mov.w	r2, #0x20000
 80084a8: 601a         	str	r2, [r3]
; 		break;
 80084aa: e023         	b	0x80084f4 <dma_stm32_get_priority+0x8c> @ imm = #0x46
; 		*ll_priority = LL_DMA_PRIORITY_VERYHIGH;
 80084ac: 683b         	ldr	r3, [r7]
 80084ae: f44f 3240    	mov.w	r2, #0x30000
 80084b2: 601a         	str	r2, [r3]
; 		break;
 80084b4: e01e         	b	0x80084f4 <dma_stm32_get_priority+0x8c> @ imm = #0x3c
; 		LOG_ERR("Priority error. %d", priority);
 80084b6: 2303         	movs	r3, #0x3
 80084b8: 2b00         	cmp	r3, #0x0
 80084ba: d018         	beq	0x80084ee <dma_stm32_get_priority+0x86> @ imm = #0x30
 80084bc: 2301         	movs	r3, #0x1
 80084be: 73fb         	strb	r3, [r7, #0xf]
 80084c0: 7bfb         	ldrb	r3, [r7, #0xf]
 80084c2: f083 0301    	eor	r3, r3, #0x1
 80084c6: b2db         	uxtb	r3, r3
 80084c8: 2b00         	cmp	r3, #0x0
 80084ca: d110         	bne	0x80084ee <dma_stm32_get_priority+0x86> @ imm = #0x20
 80084cc: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8008500 <dma_stm32_get_priority+0x98>
 80084ce: 6819         	ldr	r1, [r3]
 80084d0: 79fb         	ldrb	r3, [r7, #0x7]
 80084d2: 9303         	str	r3, [sp, #0xc]
 80084d4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008504 <dma_stm32_get_priority+0x9c>
 80084d6: 9302         	str	r3, [sp, #0x8]
 80084d8: 2300         	movs	r3, #0x0
 80084da: 9301         	str	r3, [sp, #0x4]
 80084dc: 2300         	movs	r3, #0x0
 80084de: 9300         	str	r3, [sp]
 80084e0: 2300         	movs	r3, #0x0
 80084e2: 2201         	movs	r2, #0x1
 80084e4: 2000         	movs	r0, #0x0
 80084e6: f00f fd82    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xfb04
 80084ea: 2300         	movs	r3, #0x0
 80084ec: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 80084ee: f06f 0315    	mvn	r3, #0x15
 80084f2: e000         	b	0x80084f6 <dma_stm32_get_priority+0x8e> @ imm = #0x0
; 	return 0;
 80084f4: 2300         	movs	r3, #0x0
; }
 80084f6: 4618         	mov	r0, r3
 80084f8: 3710         	adds	r7, #0x10
 80084fa: 46bd         	mov	sp, r7
 80084fc: bd80         	pop	{r7, pc}
 80084fe: bf00         	nop

08008500 <$d>:
 8008500: 4c 05 00 20  	.word	0x2000054c
 8008504: 24 10 02 08  	.word	0x08021024

08008508 <dma_stm32_get_direction>:
; {
 8008508: b580         	push	{r7, lr}
 800850a: b088         	sub	sp, #0x20
 800850c: af04         	add	r7, sp, #0x10
 800850e: 4603         	mov	r3, r0
 8008510: 6039         	str	r1, [r7]
 8008512: 71fb         	strb	r3, [r7, #0x7]
; 	switch (direction) {
 8008514: 79fb         	ldrb	r3, [r7, #0x7]
 8008516: 2b02         	cmp	r3, #0x2
 8008518: d00e         	beq	0x8008538 <dma_stm32_get_direction+0x30> @ imm = #0x1c
 800851a: 2b02         	cmp	r3, #0x2
 800851c: dc10         	bgt	0x8008540 <dma_stm32_get_direction+0x38> @ imm = #0x20
 800851e: 2b00         	cmp	r3, #0x0
 8008520: d002         	beq	0x8008528 <dma_stm32_get_direction+0x20> @ imm = #0x4
 8008522: 2b01         	cmp	r3, #0x1
 8008524: d004         	beq	0x8008530 <dma_stm32_get_direction+0x28> @ imm = #0x8
 8008526: e00b         	b	0x8008540 <dma_stm32_get_direction+0x38> @ imm = #0x16
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_MEMORY;
 8008528: 683b         	ldr	r3, [r7]
 800852a: 2280         	movs	r2, #0x80
 800852c: 601a         	str	r2, [r3]
; 		break;
 800852e: e026         	b	0x800857e <dma_stm32_get_direction+0x76> @ imm = #0x4c
; 		*ll_direction = LL_DMA_DIRECTION_MEMORY_TO_PERIPH;
 8008530: 683b         	ldr	r3, [r7]
 8008532: 2240         	movs	r2, #0x40
 8008534: 601a         	str	r2, [r3]
; 		break;
 8008536: e022         	b	0x800857e <dma_stm32_get_direction+0x76> @ imm = #0x44
; 		*ll_direction = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 8008538: 683b         	ldr	r3, [r7]
 800853a: 2200         	movs	r2, #0x0
 800853c: 601a         	str	r2, [r3]
; 		break;
 800853e: e01e         	b	0x800857e <dma_stm32_get_direction+0x76> @ imm = #0x3c
; 		LOG_ERR("Direction error. %d", direction);
 8008540: 2303         	movs	r3, #0x3
 8008542: 2b00         	cmp	r3, #0x0
 8008544: d018         	beq	0x8008578 <dma_stm32_get_direction+0x70> @ imm = #0x30
 8008546: 2301         	movs	r3, #0x1
 8008548: 73fb         	strb	r3, [r7, #0xf]
 800854a: 7bfb         	ldrb	r3, [r7, #0xf]
 800854c: f083 0301    	eor	r3, r3, #0x1
 8008550: b2db         	uxtb	r3, r3
 8008552: 2b00         	cmp	r3, #0x0
 8008554: d110         	bne	0x8008578 <dma_stm32_get_direction+0x70> @ imm = #0x20
 8008556: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8008588 <dma_stm32_get_direction+0x80>
 8008558: 6819         	ldr	r1, [r3]
 800855a: 79fb         	ldrb	r3, [r7, #0x7]
 800855c: 9303         	str	r3, [sp, #0xc]
 800855e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800858c <dma_stm32_get_direction+0x84>
 8008560: 9302         	str	r3, [sp, #0x8]
 8008562: 2300         	movs	r3, #0x0
 8008564: 9301         	str	r3, [sp, #0x4]
 8008566: 2300         	movs	r3, #0x0
 8008568: 9300         	str	r3, [sp]
 800856a: 2300         	movs	r3, #0x0
 800856c: 2201         	movs	r2, #0x1
 800856e: 2000         	movs	r0, #0x0
 8008570: f00f fd3d    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xfa7a
 8008574: 2300         	movs	r3, #0x0
 8008576: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8008578: f06f 0315    	mvn	r3, #0x15
 800857c: e000         	b	0x8008580 <dma_stm32_get_direction+0x78> @ imm = #0x0
; 	return 0;
 800857e: 2300         	movs	r3, #0x0
; }
 8008580: 4618         	mov	r0, r3
 8008582: 3710         	adds	r7, #0x10
 8008584: 46bd         	mov	sp, r7
 8008586: bd80         	pop	{r7, pc}

08008588 <$d>:
 8008588: 4c 05 00 20  	.word	0x2000054c
 800858c: 38 10 02 08  	.word	0x08021038

08008590 <dma_stm32_get_memory_increment>:
; {
 8008590: b580         	push	{r7, lr}
 8008592: b088         	sub	sp, #0x20
 8008594: af04         	add	r7, sp, #0x10
 8008596: 4603         	mov	r3, r0
 8008598: 6039         	str	r1, [r7]
 800859a: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 800859c: 79fb         	ldrb	r3, [r7, #0x7]
 800859e: 2b02         	cmp	r3, #0x2
 80085a0: d00b         	beq	0x80085ba <dma_stm32_get_memory_increment+0x2a> @ imm = #0x16
 80085a2: 2b02         	cmp	r3, #0x2
 80085a4: dc10         	bgt	0x80085c8 <dma_stm32_get_memory_increment+0x38> @ imm = #0x20
 80085a6: 2b00         	cmp	r3, #0x0
 80085a8: d002         	beq	0x80085b0 <dma_stm32_get_memory_increment+0x20> @ imm = #0x4
 80085aa: 2b01         	cmp	r3, #0x1
 80085ac: d009         	beq	0x80085c2 <dma_stm32_get_memory_increment+0x32> @ imm = #0x12
 80085ae: e00b         	b	0x80085c8 <dma_stm32_get_memory_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_MEMORY_INCREMENT;
 80085b0: 683b         	ldr	r3, [r7]
 80085b2: f44f 6280    	mov.w	r2, #0x400
 80085b6: 601a         	str	r2, [r3]
; 		break;
 80085b8: e025         	b	0x8008606 <dma_stm32_get_memory_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_MEMORY_NOINCREMENT;
 80085ba: 683b         	ldr	r3, [r7]
 80085bc: 2200         	movs	r2, #0x0
 80085be: 601a         	str	r2, [r3]
; 		break;
 80085c0: e021         	b	0x8008606 <dma_stm32_get_memory_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 80085c2: f06f 0385    	mvn	r3, #0x85
 80085c6: e01f         	b	0x8008608 <dma_stm32_get_memory_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Memory increment error. %d", increment);
 80085c8: 2303         	movs	r3, #0x3
 80085ca: 2b00         	cmp	r3, #0x0
 80085cc: d018         	beq	0x8008600 <dma_stm32_get_memory_increment+0x70> @ imm = #0x30
 80085ce: 2301         	movs	r3, #0x1
 80085d0: 73fb         	strb	r3, [r7, #0xf]
 80085d2: 7bfb         	ldrb	r3, [r7, #0xf]
 80085d4: f083 0301    	eor	r3, r3, #0x1
 80085d8: b2db         	uxtb	r3, r3
 80085da: 2b00         	cmp	r3, #0x0
 80085dc: d110         	bne	0x8008600 <dma_stm32_get_memory_increment+0x70> @ imm = #0x20
 80085de: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8008610 <dma_stm32_get_memory_increment+0x80>
 80085e0: 6819         	ldr	r1, [r3]
 80085e2: 79fb         	ldrb	r3, [r7, #0x7]
 80085e4: 9303         	str	r3, [sp, #0xc]
 80085e6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008614 <dma_stm32_get_memory_increment+0x84>
 80085e8: 9302         	str	r3, [sp, #0x8]
 80085ea: 2300         	movs	r3, #0x0
 80085ec: 9301         	str	r3, [sp, #0x4]
 80085ee: 2300         	movs	r3, #0x0
 80085f0: 9300         	str	r3, [sp]
 80085f2: 2300         	movs	r3, #0x0
 80085f4: 2201         	movs	r2, #0x1
 80085f6: 2000         	movs	r0, #0x0
 80085f8: f00f fcf9    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf9f2
 80085fc: 2300         	movs	r3, #0x0
 80085fe: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8008600: f06f 0315    	mvn	r3, #0x15
 8008604: e000         	b	0x8008608 <dma_stm32_get_memory_increment+0x78> @ imm = #0x0
; 	return 0;
 8008606: 2300         	movs	r3, #0x0
; }
 8008608: 4618         	mov	r0, r3
 800860a: 3710         	adds	r7, #0x10
 800860c: 46bd         	mov	sp, r7
 800860e: bd80         	pop	{r7, pc}

08008610 <$d>:
 8008610: 4c 05 00 20  	.word	0x2000054c
 8008614: 4c 10 02 08  	.word	0x0802104c

08008618 <dma_stm32_get_periph_increment>:
; {
 8008618: b580         	push	{r7, lr}
 800861a: b088         	sub	sp, #0x20
 800861c: af04         	add	r7, sp, #0x10
 800861e: 4603         	mov	r3, r0
 8008620: 6039         	str	r1, [r7]
 8008622: 71fb         	strb	r3, [r7, #0x7]
; 	switch (increment) {
 8008624: 79fb         	ldrb	r3, [r7, #0x7]
 8008626: 2b02         	cmp	r3, #0x2
 8008628: d00b         	beq	0x8008642 <dma_stm32_get_periph_increment+0x2a> @ imm = #0x16
 800862a: 2b02         	cmp	r3, #0x2
 800862c: dc10         	bgt	0x8008650 <dma_stm32_get_periph_increment+0x38> @ imm = #0x20
 800862e: 2b00         	cmp	r3, #0x0
 8008630: d002         	beq	0x8008638 <dma_stm32_get_periph_increment+0x20> @ imm = #0x4
 8008632: 2b01         	cmp	r3, #0x1
 8008634: d009         	beq	0x800864a <dma_stm32_get_periph_increment+0x32> @ imm = #0x12
 8008636: e00b         	b	0x8008650 <dma_stm32_get_periph_increment+0x38> @ imm = #0x16
; 		*ll_increment = LL_DMA_PERIPH_INCREMENT;
 8008638: 683b         	ldr	r3, [r7]
 800863a: f44f 7200    	mov.w	r2, #0x200
 800863e: 601a         	str	r2, [r3]
; 		break;
 8008640: e025         	b	0x800868e <dma_stm32_get_periph_increment+0x76> @ imm = #0x4a
; 		*ll_increment = LL_DMA_PERIPH_NOINCREMENT;
 8008642: 683b         	ldr	r3, [r7]
 8008644: 2200         	movs	r2, #0x0
 8008646: 601a         	str	r2, [r3]
; 		break;
 8008648: e021         	b	0x800868e <dma_stm32_get_periph_increment+0x76> @ imm = #0x42
; 		return -ENOTSUP;
 800864a: f06f 0385    	mvn	r3, #0x85
 800864e: e01f         	b	0x8008690 <dma_stm32_get_periph_increment+0x78> @ imm = #0x3e
; 		LOG_ERR("Periph increment error. %d", increment);
 8008650: 2303         	movs	r3, #0x3
 8008652: 2b00         	cmp	r3, #0x0
 8008654: d018         	beq	0x8008688 <dma_stm32_get_periph_increment+0x70> @ imm = #0x30
 8008656: 2301         	movs	r3, #0x1
 8008658: 73fb         	strb	r3, [r7, #0xf]
 800865a: 7bfb         	ldrb	r3, [r7, #0xf]
 800865c: f083 0301    	eor	r3, r3, #0x1
 8008660: b2db         	uxtb	r3, r3
 8008662: 2b00         	cmp	r3, #0x0
 8008664: d110         	bne	0x8008688 <dma_stm32_get_periph_increment+0x70> @ imm = #0x20
 8008666: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8008698 <dma_stm32_get_periph_increment+0x80>
 8008668: 6819         	ldr	r1, [r3]
 800866a: 79fb         	ldrb	r3, [r7, #0x7]
 800866c: 9303         	str	r3, [sp, #0xc]
 800866e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800869c <dma_stm32_get_periph_increment+0x84>
 8008670: 9302         	str	r3, [sp, #0x8]
 8008672: 2300         	movs	r3, #0x0
 8008674: 9301         	str	r3, [sp, #0x4]
 8008676: 2300         	movs	r3, #0x0
 8008678: 9300         	str	r3, [sp]
 800867a: 2300         	movs	r3, #0x0
 800867c: 2201         	movs	r2, #0x1
 800867e: 2000         	movs	r0, #0x0
 8008680: f00f fcb5    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf96a
 8008684: 2300         	movs	r3, #0x0
 8008686: 60bb         	str	r3, [r7, #0x8]
; 		return -EINVAL;
 8008688: f06f 0315    	mvn	r3, #0x15
 800868c: e000         	b	0x8008690 <dma_stm32_get_periph_increment+0x78> @ imm = #0x0
; 	return 0;
 800868e: 2300         	movs	r3, #0x0
; }
 8008690: 4618         	mov	r0, r3
 8008692: 3710         	adds	r7, #0x10
 8008694: 46bd         	mov	sp, r7
 8008696: bd80         	pop	{r7, pc}

08008698 <$d>:
 8008698: 4c 05 00 20  	.word	0x2000054c
 800869c: 68 10 02 08  	.word	0x08021068

080086a0 <dma_stm32_configure>:
; {
 80086a0: b580         	push	{r7, lr}
 80086a2: b0be         	sub	sp, #0xf8
 80086a4: af06         	add	r7, sp, #0x18
 80086a6: 60f8         	str	r0, [r7, #0xc]
 80086a8: 60b9         	str	r1, [r7, #0x8]
 80086aa: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *dev_config = dev->config;
 80086ac: 68fb         	ldr	r3, [r7, #0xc]
 80086ae: 685b         	ldr	r3, [r3, #0x4]
 80086b0: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 				&dev_config->streams[id - STM32_DMA_STREAM_OFFSET];
 80086b4: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 80086b8: 6999         	ldr	r1, [r3, #0x18]
 80086ba: 68ba         	ldr	r2, [r7, #0x8]
 80086bc: 4613         	mov	r3, r2
 80086be: 00db         	lsls	r3, r3, #0x3
 80086c0: 1a9b         	subs	r3, r3, r2
 80086c2: 009b         	lsls	r3, r3, #0x2
; 	struct dma_stm32_stream *stream =
 80086c4: 440b         	add	r3, r1
 80086c6: f8c7 30d0    	str.w	r3, [r7, #0xd0]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)dev_config->base;
 80086ca: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 80086ce: 691b         	ldr	r3, [r3, #0x10]
 80086d0: f8c7 30cc    	str.w	r3, [r7, #0xcc]
; 	LL_DMA_StructInit(&DMA_InitStruct);
 80086d4: f107 0310    	add.w	r3, r7, #0x10
 80086d8: 4618         	mov	r0, r3
 80086da: f015 fb1c    	bl	0x801dd16 <LL_DMA_StructInit> @ imm = #0x15638
; 	if (id >= dev_config->max_streams) {
 80086de: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 80086e2: 695b         	ldr	r3, [r3, #0x14]
 80086e4: 68ba         	ldr	r2, [r7, #0x8]
 80086e6: 429a         	cmp	r2, r3
 80086e8: d321         	blo	0x800872e <dma_stm32_configure+0x8e> @ imm = #0x42
; 		LOG_ERR("cannot configure the dma stream %d.", id);
 80086ea: 2303         	movs	r3, #0x3
 80086ec: 2b00         	cmp	r3, #0x0
 80086ee: d01a         	beq	0x8008726 <dma_stm32_configure+0x86> @ imm = #0x34
 80086f0: 2301         	movs	r3, #0x1
 80086f2: f887 305b    	strb.w	r3, [r7, #0x5b]
 80086f6: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 80086fa: f083 0301    	eor	r3, r3, #0x1
 80086fe: b2db         	uxtb	r3, r3
 8008700: 2b00         	cmp	r3, #0x0
 8008702: d110         	bne	0x8008726 <dma_stm32_configure+0x86> @ imm = #0x20
 8008704: 4b9b         	ldr	r3, [pc, #0x26c]        @ 0x8008974 <dma_stm32_configure+0x2d4>
 8008706: 6819         	ldr	r1, [r3]
 8008708: 68bb         	ldr	r3, [r7, #0x8]
 800870a: 9303         	str	r3, [sp, #0xc]
 800870c: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x8008978 <dma_stm32_configure+0x2d8>
 800870e: 9302         	str	r3, [sp, #0x8]
 8008710: 2300         	movs	r3, #0x0
 8008712: 9301         	str	r3, [sp, #0x4]
 8008714: 2300         	movs	r3, #0x0
 8008716: 9300         	str	r3, [sp]
 8008718: 2300         	movs	r3, #0x0
 800871a: 2201         	movs	r2, #0x1
 800871c: 2000         	movs	r0, #0x0
 800871e: f00f fc66    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf8cc
 8008722: 2300         	movs	r3, #0x0
 8008724: 657b         	str	r3, [r7, #0x54]
; 		return -EINVAL;
 8008726: f06f 0315    	mvn	r3, #0x15
 800872a: f000 bc1f    	b.w	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x83e
; 	if (stream->busy) {
 800872e: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008732: 799b         	ldrb	r3, [r3, #0x6]
 8008734: b2db         	uxtb	r3, r3
 8008736: 2b00         	cmp	r3, #0x0
 8008738: d020         	beq	0x800877c <dma_stm32_configure+0xdc> @ imm = #0x40
; 		LOG_ERR("dma stream %d is busy.", id);
 800873a: 2303         	movs	r3, #0x3
 800873c: 2b00         	cmp	r3, #0x0
 800873e: d01a         	beq	0x8008776 <dma_stm32_configure+0xd6> @ imm = #0x34
 8008740: 2301         	movs	r3, #0x1
 8008742: f887 3063    	strb.w	r3, [r7, #0x63]
 8008746: f897 3063    	ldrb.w	r3, [r7, #0x63]
 800874a: f083 0301    	eor	r3, r3, #0x1
 800874e: b2db         	uxtb	r3, r3
 8008750: 2b00         	cmp	r3, #0x0
 8008752: d110         	bne	0x8008776 <dma_stm32_configure+0xd6> @ imm = #0x20
 8008754: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x8008974 <dma_stm32_configure+0x2d4>
 8008756: 6819         	ldr	r1, [r3]
 8008758: 68bb         	ldr	r3, [r7, #0x8]
 800875a: 9303         	str	r3, [sp, #0xc]
 800875c: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x800897c <dma_stm32_configure+0x2dc>
 800875e: 9302         	str	r3, [sp, #0x8]
 8008760: 2300         	movs	r3, #0x0
 8008762: 9301         	str	r3, [sp, #0x4]
 8008764: 2300         	movs	r3, #0x0
 8008766: 9300         	str	r3, [sp]
 8008768: 2300         	movs	r3, #0x0
 800876a: 2201         	movs	r2, #0x1
 800876c: 2000         	movs	r0, #0x0
 800876e: f00f fc3e    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf87c
 8008772: 2300         	movs	r3, #0x0
 8008774: 65fb         	str	r3, [r7, #0x5c]
; 		return -EBUSY;
 8008776: f06f 030f    	mvn	r3, #0xf
 800877a: e3f7         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x7ee
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 800877c: 68b9         	ldr	r1, [r7, #0x8]
 800877e: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8008782: f00f fc80    	bl	0x8018086 <dma_stm32_disable_stream> @ imm = #0xf900
 8008786: 4603         	mov	r3, r0
 8008788: 2b00         	cmp	r3, #0x0
 800878a: d020         	beq	0x80087ce <dma_stm32_configure+0x12e> @ imm = #0x40
; 		LOG_ERR("could not disable dma stream %d.", id);
 800878c: 2303         	movs	r3, #0x3
 800878e: 2b00         	cmp	r3, #0x0
 8008790: d01a         	beq	0x80087c8 <dma_stm32_configure+0x128> @ imm = #0x34
 8008792: 2301         	movs	r3, #0x1
 8008794: f887 306b    	strb.w	r3, [r7, #0x6b]
 8008798: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 800879c: f083 0301    	eor	r3, r3, #0x1
 80087a0: b2db         	uxtb	r3, r3
 80087a2: 2b00         	cmp	r3, #0x0
 80087a4: d110         	bne	0x80087c8 <dma_stm32_configure+0x128> @ imm = #0x20
 80087a6: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8008974 <dma_stm32_configure+0x2d4>
 80087a8: 6819         	ldr	r1, [r3]
 80087aa: 68bb         	ldr	r3, [r7, #0x8]
 80087ac: 9303         	str	r3, [sp, #0xc]
 80087ae: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8008980 <dma_stm32_configure+0x2e0>
 80087b0: 9302         	str	r3, [sp, #0x8]
 80087b2: 2300         	movs	r3, #0x0
 80087b4: 9301         	str	r3, [sp, #0x4]
 80087b6: 2300         	movs	r3, #0x0
 80087b8: 9300         	str	r3, [sp]
 80087ba: 2300         	movs	r3, #0x0
 80087bc: 2201         	movs	r2, #0x1
 80087be: 2000         	movs	r0, #0x0
 80087c0: f00f fc15    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf82a
 80087c4: 2300         	movs	r3, #0x0
 80087c6: 667b         	str	r3, [r7, #0x64]
; 		return -EBUSY;
 80087c8: f06f 030f    	mvn	r3, #0xf
 80087cc: e3ce         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x79c
; 	dma_stm32_clear_stream_irq(dev, id);
 80087ce: 68b9         	ldr	r1, [r7, #0x8]
 80087d0: 68f8         	ldr	r0, [r7, #0xc]
 80087d2: f00f fc3d    	bl	0x8018050 <dma_stm32_clear_stream_irq> @ imm = #0xf87a
; 	if (config->linked_channel == STM32_DMA_HAL_OVERRIDE) {
 80087d6: 687b         	ldr	r3, [r7, #0x4]
 80087d8: 885b         	ldrh	r3, [r3, #0x2]
 80087da: f403 637e    	and	r3, r3, #0xfe0
 80087de: b29b         	uxth	r3, r3
 80087e0: f5b3 6f7e    	cmp.w	r3, #0xfe0
 80087e4: d117         	bne	0x8008816 <dma_stm32_configure+0x176> @ imm = #0x2e
; 		stream->busy = true;
 80087e6: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80087ea: 2201         	movs	r2, #0x1
 80087ec: 719a         	strb	r2, [r3, #0x6]
; 		stream->hal_override = true;
 80087ee: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80087f2: 2201         	movs	r2, #0x1
 80087f4: 715a         	strb	r2, [r3, #0x5]
; 		stream->dma_callback = config->dma_callback;
 80087f6: 687b         	ldr	r3, [r7, #0x4]
 80087f8: 699a         	ldr	r2, [r3, #0x18]
 80087fa: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80087fe: 615a         	str	r2, [r3, #0x14]
; 		stream->user_data = config->user_data;
 8008800: 687b         	ldr	r3, [r7, #0x4]
 8008802: 695a         	ldr	r2, [r3, #0x14]
 8008804: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008808: 611a         	str	r2, [r3, #0x10]
; 		stream->cyclic = false;
 800880a: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 800880e: 2200         	movs	r2, #0x0
 8008810: 761a         	strb	r2, [r3, #0x18]
; 		return 0;
 8008812: 2300         	movs	r3, #0x0
 8008814: e3aa         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x754
; 	if (config->head_block->block_size > DMA_STM32_MAX_DATA_ITEMS) {
 8008816: 687b         	ldr	r3, [r7, #0x4]
 8008818: 691b         	ldr	r3, [r3, #0x10]
 800881a: 695b         	ldr	r3, [r3, #0x14]
 800881c: f5b3 3f80    	cmp.w	r3, #0x10000
 8008820: d322         	blo	0x8008868 <dma_stm32_configure+0x1c8> @ imm = #0x44
; 		LOG_ERR("Data size too big: %d\n",
 8008822: 2303         	movs	r3, #0x3
 8008824: 2b00         	cmp	r3, #0x0
 8008826: d01c         	beq	0x8008862 <dma_stm32_configure+0x1c2> @ imm = #0x38
 8008828: 2301         	movs	r3, #0x1
 800882a: f887 3073    	strb.w	r3, [r7, #0x73]
 800882e: f897 3073    	ldrb.w	r3, [r7, #0x73]
 8008832: f083 0301    	eor	r3, r3, #0x1
 8008836: b2db         	uxtb	r3, r3
 8008838: 2b00         	cmp	r3, #0x0
 800883a: d112         	bne	0x8008862 <dma_stm32_configure+0x1c2> @ imm = #0x24
 800883c: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x8008974 <dma_stm32_configure+0x2d4>
 800883e: 6819         	ldr	r1, [r3]
 8008840: 687b         	ldr	r3, [r7, #0x4]
 8008842: 691b         	ldr	r3, [r3, #0x10]
 8008844: 695b         	ldr	r3, [r3, #0x14]
 8008846: 9303         	str	r3, [sp, #0xc]
 8008848: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8008984 <dma_stm32_configure+0x2e4>
 800884a: 9302         	str	r3, [sp, #0x8]
 800884c: 2300         	movs	r3, #0x0
 800884e: 9301         	str	r3, [sp, #0x4]
 8008850: 2300         	movs	r3, #0x0
 8008852: 9300         	str	r3, [sp]
 8008854: 2300         	movs	r3, #0x0
 8008856: 2201         	movs	r2, #0x1
 8008858: 2000         	movs	r0, #0x0
 800885a: f00f fbc8    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf790
 800885e: 2300         	movs	r3, #0x0
 8008860: 66fb         	str	r3, [r7, #0x6c]
; 		return -EINVAL;
 8008862: f06f 0315    	mvn	r3, #0x15
 8008866: e381         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x702
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 8008868: 687b         	ldr	r3, [r7, #0x4]
 800886a: 785b         	ldrb	r3, [r3, #0x1]
 800886c: f003 0307    	and	r3, r3, #0x7
 8008870: b2db         	uxtb	r3, r3
 8008872: 2b00         	cmp	r3, #0x0
 8008874: d12a         	bne	0x80088cc <dma_stm32_configure+0x22c> @ imm = #0x54
; 		(!dev_config->support_m2m)) {
 8008876: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 800887a: 7b1b         	ldrb	r3, [r3, #0xc]
 800887c: f083 0301    	eor	r3, r3, #0x1
 8008880: b2db         	uxtb	r3, r3
; 	if ((config->channel_direction == MEMORY_TO_MEMORY) &&
 8008882: 2b00         	cmp	r3, #0x0
 8008884: d022         	beq	0x80088cc <dma_stm32_configure+0x22c> @ imm = #0x44
; 		LOG_ERR("Memcopy not supported for device %s",
 8008886: 2303         	movs	r3, #0x3
 8008888: 2b00         	cmp	r3, #0x0
 800888a: d01c         	beq	0x80088c6 <dma_stm32_configure+0x226> @ imm = #0x38
 800888c: 2301         	movs	r3, #0x1
 800888e: f887 30d6    	strb.w	r3, [r7, #0xd6]
 8008892: f897 30d6    	ldrb.w	r3, [r7, #0xd6]
 8008896: f083 0301    	eor	r3, r3, #0x1
 800889a: b2db         	uxtb	r3, r3
 800889c: 2b00         	cmp	r3, #0x0
 800889e: d112         	bne	0x80088c6 <dma_stm32_configure+0x226> @ imm = #0x24
 80088a0: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8008974 <dma_stm32_configure+0x2d4>
 80088a2: 6819         	ldr	r1, [r3]
 80088a4: 68fb         	ldr	r3, [r7, #0xc]
 80088a6: 681b         	ldr	r3, [r3]
 80088a8: 9303         	str	r3, [sp, #0xc]
 80088aa: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8008988 <dma_stm32_configure+0x2e8>
 80088ac: 9302         	str	r3, [sp, #0x8]
 80088ae: 2300         	movs	r3, #0x0
 80088b0: 9301         	str	r3, [sp, #0x4]
 80088b2: 2300         	movs	r3, #0x0
 80088b4: 9300         	str	r3, [sp]
 80088b6: 2300         	movs	r3, #0x0
 80088b8: 2201         	movs	r2, #0x1
 80088ba: 2000         	movs	r0, #0x0
 80088bc: f00f fb97    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf72e
 80088c0: 2300         	movs	r3, #0x0
 80088c2: f8c7 30d8    	str.w	r3, [r7, #0xd8]
; 		return -ENOTSUP;
 80088c6: f06f 0385    	mvn	r3, #0x85
 80088ca: e34f         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x69e
; 	if ((config->dest_data_size != config->source_data_size)) {
 80088cc: 687b         	ldr	r3, [r7, #0x4]
 80088ce: 88da         	ldrh	r2, [r3, #0x6]
 80088d0: 687b         	ldr	r3, [r7, #0x4]
 80088d2: 889b         	ldrh	r3, [r3, #0x4]
 80088d4: 429a         	cmp	r2, r3
 80088d6: d01e         	beq	0x8008916 <dma_stm32_configure+0x276> @ imm = #0x3c
; 		LOG_ERR("source and dest data size differ.");
 80088d8: 2303         	movs	r3, #0x3
 80088da: 2b00         	cmp	r3, #0x0
 80088dc: d018         	beq	0x8008910 <dma_stm32_configure+0x270> @ imm = #0x30
 80088de: 2301         	movs	r3, #0x1
 80088e0: f887 307b    	strb.w	r3, [r7, #0x7b]
 80088e4: f897 307b    	ldrb.w	r3, [r7, #0x7b]
 80088e8: f083 0301    	eor	r3, r3, #0x1
 80088ec: b2db         	uxtb	r3, r3
 80088ee: 2b00         	cmp	r3, #0x0
 80088f0: d10e         	bne	0x8008910 <dma_stm32_configure+0x270> @ imm = #0x1c
 80088f2: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8008974 <dma_stm32_configure+0x2d4>
 80088f4: 6819         	ldr	r1, [r3]
 80088f6: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800898c <dma_stm32_configure+0x2ec>
 80088f8: 9302         	str	r3, [sp, #0x8]
 80088fa: 2300         	movs	r3, #0x0
 80088fc: 9301         	str	r3, [sp, #0x4]
 80088fe: 2300         	movs	r3, #0x0
 8008900: 9300         	str	r3, [sp]
 8008902: 2300         	movs	r3, #0x0
 8008904: 2201         	movs	r2, #0x1
 8008906: 2000         	movs	r0, #0x0
 8008908: f00f fb71    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf6e2
 800890c: 2300         	movs	r3, #0x0
 800890e: 677b         	str	r3, [r7, #0x74]
; 		return -EINVAL;
 8008910: f06f 0315    	mvn	r3, #0x15
 8008914: e32a         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x654
; 	if (config->source_data_size != 4U &&
 8008916: 687b         	ldr	r3, [r7, #0x4]
 8008918: 889b         	ldrh	r3, [r3, #0x4]
 800891a: 2b04         	cmp	r3, #0x4
 800891c: d03a         	beq	0x8008994 <dma_stm32_configure+0x2f4> @ imm = #0x74
; 	    config->source_data_size != 2U &&
 800891e: 687b         	ldr	r3, [r7, #0x4]
 8008920: 889b         	ldrh	r3, [r3, #0x4]
; 	if (config->source_data_size != 4U &&
 8008922: 2b02         	cmp	r3, #0x2
 8008924: d036         	beq	0x8008994 <dma_stm32_configure+0x2f4> @ imm = #0x6c
; 	    config->source_data_size != 1U) {
 8008926: 687b         	ldr	r3, [r7, #0x4]
 8008928: 889b         	ldrh	r3, [r3, #0x4]
; 	    config->source_data_size != 2U &&
 800892a: 2b01         	cmp	r3, #0x1
 800892c: d032         	beq	0x8008994 <dma_stm32_configure+0x2f4> @ imm = #0x64
; 		LOG_ERR("source and dest unit size error, %d",
 800892e: 2303         	movs	r3, #0x3
 8008930: 2b00         	cmp	r3, #0x0
 8008932: d01c         	beq	0x800896e <dma_stm32_configure+0x2ce> @ imm = #0x38
 8008934: 2301         	movs	r3, #0x1
 8008936: f887 30d7    	strb.w	r3, [r7, #0xd7]
 800893a: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 800893e: f083 0301    	eor	r3, r3, #0x1
 8008942: b2db         	uxtb	r3, r3
 8008944: 2b00         	cmp	r3, #0x0
 8008946: d112         	bne	0x800896e <dma_stm32_configure+0x2ce> @ imm = #0x24
 8008948: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8008974 <dma_stm32_configure+0x2d4>
 800894a: 6819         	ldr	r1, [r3]
 800894c: 687b         	ldr	r3, [r7, #0x4]
 800894e: 889b         	ldrh	r3, [r3, #0x4]
 8008950: 9303         	str	r3, [sp, #0xc]
 8008952: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8008990 <dma_stm32_configure+0x2f0>
 8008954: 9302         	str	r3, [sp, #0x8]
 8008956: 2300         	movs	r3, #0x0
 8008958: 9301         	str	r3, [sp, #0x4]
 800895a: 2300         	movs	r3, #0x0
 800895c: 9300         	str	r3, [sp]
 800895e: 2300         	movs	r3, #0x0
 8008960: 2201         	movs	r2, #0x1
 8008962: 2000         	movs	r0, #0x0
 8008964: f00f fb43    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf686
 8008968: 2300         	movs	r3, #0x0
 800896a: f8c7 30dc    	str.w	r3, [r7, #0xdc]
; 		return -EINVAL;
 800896e: f06f 0315    	mvn	r3, #0x15
 8008972: e2fb         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x5f6

08008974 <$d>:
 8008974: 4c 05 00 20  	.word	0x2000054c
 8008978: 84 10 02 08  	.word	0x08021084
 800897c: a8 10 02 08  	.word	0x080210a8
 8008980: c0 10 02 08  	.word	0x080210c0
 8008984: e4 10 02 08  	.word	0x080210e4
 8008988: fc 10 02 08  	.word	0x080210fc
 800898c: 20 11 02 08  	.word	0x08021120
 8008990: 44 11 02 08  	.word	0x08021144

08008994 <$t>:
; 	if (config->head_block->source_reload_en !=
 8008994: 687b         	ldr	r3, [r7, #0x4]
 8008996: 691b         	ldr	r3, [r3, #0x10]
 8008998: 7f1b         	ldrb	r3, [r3, #0x1c]
 800899a: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 800899e: b2da         	uxtb	r2, r3
; 		config->head_block->dest_reload_en) {
 80089a0: 687b         	ldr	r3, [r7, #0x4]
 80089a2: 691b         	ldr	r3, [r3, #0x10]
 80089a4: 7f1b         	ldrb	r3, [r3, #0x1c]
 80089a6: f3c3 13c0    	ubfx	r3, r3, #0x7, #0x1
 80089aa: b2db         	uxtb	r3, r3
; 	if (config->head_block->source_reload_en !=
 80089ac: 429a         	cmp	r2, r3
 80089ae: d01e         	beq	0x80089ee <dma_stm32_configure+0x34e> @ imm = #0x3c
; 		LOG_ERR("source_reload_en and dest_reload_en must "
 80089b0: 2303         	movs	r3, #0x3
 80089b2: 2b00         	cmp	r3, #0x0
 80089b4: d018         	beq	0x80089e8 <dma_stm32_configure+0x348> @ imm = #0x30
 80089b6: 2301         	movs	r3, #0x1
 80089b8: f887 3083    	strb.w	r3, [r7, #0x83]
 80089bc: f897 3083    	ldrb.w	r3, [r7, #0x83]
 80089c0: f083 0301    	eor	r3, r3, #0x1
 80089c4: b2db         	uxtb	r3, r3
 80089c6: 2b00         	cmp	r3, #0x0
 80089c8: d10e         	bne	0x80089e8 <dma_stm32_configure+0x348> @ imm = #0x1c
 80089ca: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8008c3c <dma_stm32_configure+0x59c>
 80089cc: 6819         	ldr	r1, [r3]
 80089ce: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8008c40 <dma_stm32_configure+0x5a0>
 80089d0: 9302         	str	r3, [sp, #0x8]
 80089d2: 2300         	movs	r3, #0x0
 80089d4: 9301         	str	r3, [sp, #0x4]
 80089d6: 2300         	movs	r3, #0x0
 80089d8: 9300         	str	r3, [sp]
 80089da: 2300         	movs	r3, #0x0
 80089dc: 2201         	movs	r2, #0x1
 80089de: 2000         	movs	r0, #0x0
 80089e0: f00f fb05    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf60a
 80089e4: 2300         	movs	r3, #0x0
 80089e6: 67fb         	str	r3, [r7, #0x7c]
; 		return -EINVAL;
 80089e8: f06f 0315    	mvn	r3, #0x15
 80089ec: e2be         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x57c
; 	stream->busy		= true;
 80089ee: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80089f2: 2201         	movs	r2, #0x1
 80089f4: 719a         	strb	r2, [r3, #0x6]
; 	stream->dma_callback	= config->dma_callback;
 80089f6: 687b         	ldr	r3, [r7, #0x4]
 80089f8: 699a         	ldr	r2, [r3, #0x18]
 80089fa: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 80089fe: 615a         	str	r2, [r3, #0x14]
; 	stream->direction	= config->channel_direction;
 8008a00: 687b         	ldr	r3, [r7, #0x4]
 8008a02: 785b         	ldrb	r3, [r3, #0x1]
 8008a04: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8008a08: b2db         	uxtb	r3, r3
 8008a0a: 461a         	mov	r2, r3
 8008a0c: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008a10: 601a         	str	r2, [r3]
; 	stream->user_data       = config->user_data;
 8008a12: 687b         	ldr	r3, [r7, #0x4]
 8008a14: 695a         	ldr	r2, [r3, #0x14]
 8008a16: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008a1a: 611a         	str	r2, [r3, #0x10]
; 	stream->src_size	= config->source_data_size;
 8008a1c: 687b         	ldr	r3, [r7, #0x4]
 8008a1e: 889b         	ldrh	r3, [r3, #0x4]
 8008a20: 461a         	mov	r2, r3
 8008a22: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008a26: 609a         	str	r2, [r3, #0x8]
; 	stream->dst_size	= config->dest_data_size;
 8008a28: 687b         	ldr	r3, [r7, #0x4]
 8008a2a: 88db         	ldrh	r3, [r3, #0x6]
 8008a2c: 461a         	mov	r2, r3
 8008a2e: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008a32: 60da         	str	r2, [r3, #0xc]
; 	stream->cyclic		= config->head_block->source_reload_en;
 8008a34: 687b         	ldr	r3, [r7, #0x4]
 8008a36: 691b         	ldr	r3, [r3, #0x10]
 8008a38: 7f1b         	ldrb	r3, [r3, #0x1c]
 8008a3a: f3c3 1380    	ubfx	r3, r3, #0x6, #0x1
 8008a3e: b2db         	uxtb	r3, r3
 8008a40: 2b00         	cmp	r3, #0x0
 8008a42: bf14         	ite	ne
 8008a44: 2301         	movne	r3, #0x1
 8008a46: 2300         	moveq	r3, #0x0
 8008a48: b2da         	uxtb	r2, r3
 8008a4a: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008a4e: 761a         	strb	r2, [r3, #0x18]
; 	if (config->head_block->source_address == 0) {
 8008a50: 687b         	ldr	r3, [r7, #0x4]
 8008a52: 691b         	ldr	r3, [r3, #0x10]
 8008a54: 681b         	ldr	r3, [r3]
 8008a56: 2b00         	cmp	r3, #0x0
 8008a58: d11c         	bne	0x8008a94 <dma_stm32_configure+0x3f4> @ imm = #0x38
; 		LOG_WRN("source_buffer address is null.");
 8008a5a: 2303         	movs	r3, #0x3
 8008a5c: 2b01         	cmp	r3, #0x1
 8008a5e: d919         	bls	0x8008a94 <dma_stm32_configure+0x3f4> @ imm = #0x32
 8008a60: 2301         	movs	r3, #0x1
 8008a62: f887 30c3    	strb.w	r3, [r7, #0xc3]
 8008a66: f897 30c3    	ldrb.w	r3, [r7, #0xc3]
 8008a6a: f083 0301    	eor	r3, r3, #0x1
 8008a6e: b2db         	uxtb	r3, r3
 8008a70: 2b00         	cmp	r3, #0x0
 8008a72: d10f         	bne	0x8008a94 <dma_stm32_configure+0x3f4> @ imm = #0x1e
 8008a74: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8008c3c <dma_stm32_configure+0x59c>
 8008a76: 6819         	ldr	r1, [r3]
 8008a78: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8008c44 <dma_stm32_configure+0x5a4>
 8008a7a: 9302         	str	r3, [sp, #0x8]
 8008a7c: 2300         	movs	r3, #0x0
 8008a7e: 9301         	str	r3, [sp, #0x4]
 8008a80: 2300         	movs	r3, #0x0
 8008a82: 9300         	str	r3, [sp]
 8008a84: 2300         	movs	r3, #0x0
 8008a86: 2202         	movs	r2, #0x2
 8008a88: 2000         	movs	r0, #0x0
 8008a8a: f00f fab0    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf560
 8008a8e: 2300         	movs	r3, #0x0
 8008a90: f8c7 30bc    	str.w	r3, [r7, #0xbc]
; 	if (config->head_block->dest_address == 0) {
 8008a94: 687b         	ldr	r3, [r7, #0x4]
 8008a96: 691b         	ldr	r3, [r3, #0x10]
 8008a98: 685b         	ldr	r3, [r3, #0x4]
 8008a9a: 2b00         	cmp	r3, #0x0
 8008a9c: d11c         	bne	0x8008ad8 <dma_stm32_configure+0x438> @ imm = #0x38
; 		LOG_WRN("dest_buffer address is null.");
 8008a9e: 2303         	movs	r3, #0x3
 8008aa0: 2b01         	cmp	r3, #0x1
 8008aa2: d919         	bls	0x8008ad8 <dma_stm32_configure+0x438> @ imm = #0x32
 8008aa4: 2301         	movs	r3, #0x1
 8008aa6: f887 30bb    	strb.w	r3, [r7, #0xbb]
 8008aaa: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 8008aae: f083 0301    	eor	r3, r3, #0x1
 8008ab2: b2db         	uxtb	r3, r3
 8008ab4: 2b00         	cmp	r3, #0x0
 8008ab6: d10f         	bne	0x8008ad8 <dma_stm32_configure+0x438> @ imm = #0x1e
 8008ab8: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8008c3c <dma_stm32_configure+0x59c>
 8008aba: 6819         	ldr	r1, [r3]
 8008abc: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8008c48 <dma_stm32_configure+0x5a8>
 8008abe: 9302         	str	r3, [sp, #0x8]
 8008ac0: 2300         	movs	r3, #0x0
 8008ac2: 9301         	str	r3, [sp, #0x4]
 8008ac4: 2300         	movs	r3, #0x0
 8008ac6: 9300         	str	r3, [sp]
 8008ac8: 2300         	movs	r3, #0x0
 8008aca: 2202         	movs	r2, #0x2
 8008acc: 2000         	movs	r0, #0x0
 8008ace: f00f fa8e    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf51c
 8008ad2: 2300         	movs	r3, #0x0
 8008ad4: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (stream->direction == MEMORY_TO_PERIPHERAL) {
 8008ad8: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008adc: 681b         	ldr	r3, [r3]
 8008ade: 2b01         	cmp	r3, #0x1
 8008ae0: d108         	bne	0x8008af4 <dma_stm32_configure+0x454> @ imm = #0x10
; 					config->head_block->source_address;
 8008ae2: 687b         	ldr	r3, [r7, #0x4]
 8008ae4: 691b         	ldr	r3, [r3, #0x10]
 8008ae6: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 8008ae8: 617b         	str	r3, [r7, #0x14]
; 					config->head_block->dest_address;
 8008aea: 687b         	ldr	r3, [r7, #0x4]
 8008aec: 691b         	ldr	r3, [r3, #0x10]
 8008aee: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 8008af0: 613b         	str	r3, [r7, #0x10]
 8008af2: e007         	b	0x8008b04 <dma_stm32_configure+0x464> @ imm = #0xe
; 					config->head_block->source_address;
 8008af4: 687b         	ldr	r3, [r7, #0x4]
 8008af6: 691b         	ldr	r3, [r3, #0x10]
 8008af8: 681b         	ldr	r3, [r3]
; 		DMA_InitStruct.PeriphOrM2MSrcAddress =
 8008afa: 613b         	str	r3, [r7, #0x10]
; 					config->head_block->dest_address;
 8008afc: 687b         	ldr	r3, [r7, #0x4]
 8008afe: 691b         	ldr	r3, [r3, #0x10]
 8008b00: 685b         	ldr	r3, [r3, #0x4]
; 		DMA_InitStruct.MemoryOrM2MDstAddress =
 8008b02: 617b         	str	r3, [r7, #0x14]
; 	uint16_t memory_addr_adj = 0, periph_addr_adj = 0;
 8008b04: 2300         	movs	r3, #0x0
 8008b06: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
 8008b0a: 2300         	movs	r3, #0x0
 8008b0c: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 	ret = dma_stm32_get_priority(config->channel_priority,
 8008b10: 687b         	ldr	r3, [r7, #0x4]
 8008b12: 681b         	ldr	r3, [r3]
 8008b14: f3c3 33c3    	ubfx	r3, r3, #0xf, #0x4
 8008b18: b2db         	uxtb	r3, r3
 8008b1a: 461a         	mov	r2, r3
 8008b1c: f107 0310    	add.w	r3, r7, #0x10
 8008b20: 3328         	adds	r3, #0x28
 8008b22: 4619         	mov	r1, r3
 8008b24: 4610         	mov	r0, r2
 8008b26: f7ff fc9f    	bl	0x8008468 <dma_stm32_get_priority> @ imm = #-0x6c2
 8008b2a: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8008b2e: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8008b32: 2b00         	cmp	r3, #0x0
 8008b34: da02         	bge	0x8008b3c <dma_stm32_configure+0x49c> @ imm = #0x4
; 		return ret;
 8008b36: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8008b3a: e217         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x42e
; 	ret = dma_stm32_get_direction(config->channel_direction,
 8008b3c: 687b         	ldr	r3, [r7, #0x4]
 8008b3e: 785b         	ldrb	r3, [r3, #0x1]
 8008b40: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8008b44: b2db         	uxtb	r3, r3
 8008b46: 461a         	mov	r2, r3
 8008b48: f107 0310    	add.w	r3, r7, #0x10
 8008b4c: 3308         	adds	r3, #0x8
 8008b4e: 4619         	mov	r1, r3
 8008b50: 4610         	mov	r0, r2
 8008b52: f7ff fcd9    	bl	0x8008508 <dma_stm32_get_direction> @ imm = #-0x64e
 8008b56: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8008b5a: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8008b5e: 2b00         	cmp	r3, #0x0
 8008b60: da02         	bge	0x8008b68 <dma_stm32_configure+0x4c8> @ imm = #0x4
; 		return ret;
 8008b62: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8008b66: e201         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x402
; 	switch (config->channel_direction) {
 8008b68: 687b         	ldr	r3, [r7, #0x4]
 8008b6a: 785b         	ldrb	r3, [r3, #0x1]
 8008b6c: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8008b70: b2db         	uxtb	r3, r3
 8008b72: 2b02         	cmp	r3, #0x2
 8008b74: d006         	beq	0x8008b84 <dma_stm32_configure+0x4e4> @ imm = #0xc
 8008b76: 2b02         	cmp	r3, #0x2
 8008b78: dc26         	bgt	0x8008bc8 <dma_stm32_configure+0x528> @ imm = #0x4c
 8008b7a: 2b00         	cmp	r3, #0x0
 8008b7c: d002         	beq	0x8008b84 <dma_stm32_configure+0x4e4> @ imm = #0x4
 8008b7e: 2b01         	cmp	r3, #0x1
 8008b80: d011         	beq	0x8008ba6 <dma_stm32_configure+0x506> @ imm = #0x22
 8008b82: e021         	b	0x8008bc8 <dma_stm32_configure+0x528> @ imm = #0x42
; 		memory_addr_adj = config->head_block->dest_addr_adj;
 8008b84: 687b         	ldr	r3, [r7, #0x4]
 8008b86: 691b         	ldr	r3, [r3, #0x10]
 8008b88: 7f1b         	ldrb	r3, [r3, #0x1c]
 8008b8a: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 8008b8e: b2db         	uxtb	r3, r3
 8008b90: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
; 		periph_addr_adj = config->head_block->source_addr_adj;
 8008b94: 687b         	ldr	r3, [r7, #0x4]
 8008b96: 691b         	ldr	r3, [r3, #0x10]
 8008b98: 7f1b         	ldrb	r3, [r3, #0x1c]
 8008b9a: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 8008b9e: b2db         	uxtb	r3, r3
 8008ba0: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 		break;
 8008ba4: e036         	b	0x8008c14 <dma_stm32_configure+0x574> @ imm = #0x6c
; 		memory_addr_adj = config->head_block->source_addr_adj;
 8008ba6: 687b         	ldr	r3, [r7, #0x4]
 8008ba8: 691b         	ldr	r3, [r3, #0x10]
 8008baa: 7f1b         	ldrb	r3, [r3, #0x1c]
 8008bac: f3c3 0381    	ubfx	r3, r3, #0x2, #0x2
 8008bb0: b2db         	uxtb	r3, r3
 8008bb2: f8a7 30c6    	strh.w	r3, [r7, #0xc6]
; 		periph_addr_adj = config->head_block->dest_addr_adj;
 8008bb6: 687b         	ldr	r3, [r7, #0x4]
 8008bb8: 691b         	ldr	r3, [r3, #0x10]
 8008bba: 7f1b         	ldrb	r3, [r3, #0x1c]
 8008bbc: f3c3 1301    	ubfx	r3, r3, #0x4, #0x2
 8008bc0: b2db         	uxtb	r3, r3
 8008bc2: f8a7 30c4    	strh.w	r3, [r7, #0xc4]
; 		break;
 8008bc6: e025         	b	0x8008c14 <dma_stm32_configure+0x574> @ imm = #0x4a
; 		LOG_ERR("Channel direction error (%d).",
 8008bc8: 2303         	movs	r3, #0x3
 8008bca: 2b00         	cmp	r3, #0x0
 8008bcc: d01f         	beq	0x8008c0e <dma_stm32_configure+0x56e> @ imm = #0x3e
 8008bce: 2301         	movs	r3, #0x1
 8008bd0: f887 308b    	strb.w	r3, [r7, #0x8b]
 8008bd4: f897 308b    	ldrb.w	r3, [r7, #0x8b]
 8008bd8: f083 0301    	eor	r3, r3, #0x1
 8008bdc: b2db         	uxtb	r3, r3
 8008bde: 2b00         	cmp	r3, #0x0
 8008be0: d115         	bne	0x8008c0e <dma_stm32_configure+0x56e> @ imm = #0x2a
 8008be2: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8008c3c <dma_stm32_configure+0x59c>
 8008be4: 6819         	ldr	r1, [r3]
 8008be6: 687b         	ldr	r3, [r7, #0x4]
 8008be8: 785b         	ldrb	r3, [r3, #0x1]
 8008bea: f3c3 0302    	ubfx	r3, r3, #0x0, #0x3
 8008bee: b2db         	uxtb	r3, r3
 8008bf0: 9303         	str	r3, [sp, #0xc]
 8008bf2: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8008c4c <dma_stm32_configure+0x5ac>
 8008bf4: 9302         	str	r3, [sp, #0x8]
 8008bf6: 2300         	movs	r3, #0x0
 8008bf8: 9301         	str	r3, [sp, #0x4]
 8008bfa: 2300         	movs	r3, #0x0
 8008bfc: 9300         	str	r3, [sp]
 8008bfe: 2300         	movs	r3, #0x0
 8008c00: 2201         	movs	r2, #0x1
 8008c02: 2000         	movs	r0, #0x0
 8008c04: f00f f9f3    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf3e6
 8008c08: 2300         	movs	r3, #0x0
 8008c0a: f8c7 3084    	str.w	r3, [r7, #0x84]
; 		return -EINVAL;
 8008c0e: f06f 0315    	mvn	r3, #0x15
 8008c12: e1ab         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x356
; 	ret = dma_stm32_get_memory_increment(memory_addr_adj,
 8008c14: f8b7 30c6    	ldrh.w	r3, [r7, #0xc6]
 8008c18: b2da         	uxtb	r2, r3
 8008c1a: f107 0310    	add.w	r3, r7, #0x10
 8008c1e: 3314         	adds	r3, #0x14
 8008c20: 4619         	mov	r1, r3
 8008c22: 4610         	mov	r0, r2
 8008c24: f7ff fcb4    	bl	0x8008590 <dma_stm32_get_memory_increment> @ imm = #-0x698
 8008c28: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8008c2c: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8008c30: 2b00         	cmp	r3, #0x0
 8008c32: da0d         	bge	0x8008c50 <dma_stm32_configure+0x5b0> @ imm = #0x1a
; 		return ret;
 8008c34: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8008c38: e198         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x330
 8008c3a: bf00         	nop

08008c3c <$d>:
 8008c3c: 4c 05 00 20  	.word	0x2000054c
 8008c40: 68 11 02 08  	.word	0x08021168
 8008c44: a0 11 02 08  	.word	0x080211a0
 8008c48: c0 11 02 08  	.word	0x080211c0
 8008c4c: e0 11 02 08  	.word	0x080211e0

08008c50 <$t>:
; 	LOG_DBG("Channel (%d) memory inc (%x).",
 8008c50: 2303         	movs	r3, #0x3
 8008c52: 2b03         	cmp	r3, #0x3
 8008c54: d91f         	bls	0x8008c96 <dma_stm32_configure+0x5f6> @ imm = #0x3e
 8008c56: 2301         	movs	r3, #0x1
 8008c58: f887 30af    	strb.w	r3, [r7, #0xaf]
 8008c5c: f897 30af    	ldrb.w	r3, [r7, #0xaf]
 8008c60: f083 0301    	eor	r3, r3, #0x1
 8008c64: b2db         	uxtb	r3, r3
 8008c66: 2b00         	cmp	r3, #0x0
 8008c68: d115         	bne	0x8008c96 <dma_stm32_configure+0x5f6> @ imm = #0x2a
 8008c6a: 4bae         	ldr	r3, [pc, #0x2b8]        @ 0x8008f24 <dma_stm32_configure+0x884>
 8008c6c: 6819         	ldr	r1, [r3]
 8008c6e: 6a7b         	ldr	r3, [r7, #0x24]
 8008c70: 9305         	str	r3, [sp, #0x14]
 8008c72: 68bb         	ldr	r3, [r7, #0x8]
 8008c74: 9304         	str	r3, [sp, #0x10]
 8008c76: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8008f28 <dma_stm32_configure+0x888>
 8008c78: 9303         	str	r3, [sp, #0xc]
 8008c7a: 4bac         	ldr	r3, [pc, #0x2b0]        @ 0x8008f2c <dma_stm32_configure+0x88c>
 8008c7c: 9302         	str	r3, [sp, #0x8]
 8008c7e: 2308         	movs	r3, #0x8
 8008c80: 9301         	str	r3, [sp, #0x4]
 8008c82: 2300         	movs	r3, #0x0
 8008c84: 9300         	str	r3, [sp]
 8008c86: 2300         	movs	r3, #0x0
 8008c88: 2204         	movs	r2, #0x4
 8008c8a: 2000         	movs	r0, #0x0
 8008c8c: f00f f9af    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf35e
 8008c90: 2300         	movs	r3, #0x0
 8008c92: f8c7 30a8    	str.w	r3, [r7, #0xa8]
; 	ret = dma_stm32_get_periph_increment(periph_addr_adj,
 8008c96: f8b7 30c4    	ldrh.w	r3, [r7, #0xc4]
 8008c9a: b2da         	uxtb	r2, r3
 8008c9c: f107 0310    	add.w	r3, r7, #0x10
 8008ca0: 3310         	adds	r3, #0x10
 8008ca2: 4619         	mov	r1, r3
 8008ca4: 4610         	mov	r0, r2
 8008ca6: f7ff fcb7    	bl	0x8008618 <dma_stm32_get_periph_increment> @ imm = #-0x692
 8008caa: f8c7 00b0    	str.w	r0, [r7, #0xb0]
; 	if (ret < 0) {
 8008cae: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8008cb2: 2b00         	cmp	r3, #0x0
 8008cb4: da02         	bge	0x8008cbc <dma_stm32_configure+0x61c> @ imm = #0x4
; 		return ret;
 8008cb6: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 8008cba: e157         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x2ae
; 	LOG_DBG("Channel (%d) peripheral inc (%x).",
 8008cbc: 2303         	movs	r3, #0x3
 8008cbe: 2b03         	cmp	r3, #0x3
 8008cc0: d91f         	bls	0x8008d02 <dma_stm32_configure+0x662> @ imm = #0x3e
 8008cc2: 2301         	movs	r3, #0x1
 8008cc4: f887 30a7    	strb.w	r3, [r7, #0xa7]
 8008cc8: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 8008ccc: f083 0301    	eor	r3, r3, #0x1
 8008cd0: b2db         	uxtb	r3, r3
 8008cd2: 2b00         	cmp	r3, #0x0
 8008cd4: d115         	bne	0x8008d02 <dma_stm32_configure+0x662> @ imm = #0x2a
 8008cd6: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8008f24 <dma_stm32_configure+0x884>
 8008cd8: 6819         	ldr	r1, [r3]
 8008cda: 6a3b         	ldr	r3, [r7, #0x20]
 8008cdc: 9305         	str	r3, [sp, #0x14]
 8008cde: 68bb         	ldr	r3, [r7, #0x8]
 8008ce0: 9304         	str	r3, [sp, #0x10]
 8008ce2: 4b91         	ldr	r3, [pc, #0x244]        @ 0x8008f28 <dma_stm32_configure+0x888>
 8008ce4: 9303         	str	r3, [sp, #0xc]
 8008ce6: 4b92         	ldr	r3, [pc, #0x248]        @ 0x8008f30 <dma_stm32_configure+0x890>
 8008ce8: 9302         	str	r3, [sp, #0x8]
 8008cea: 2308         	movs	r3, #0x8
 8008cec: 9301         	str	r3, [sp, #0x4]
 8008cee: 2300         	movs	r3, #0x0
 8008cf0: 9300         	str	r3, [sp]
 8008cf2: 2300         	movs	r3, #0x0
 8008cf4: 2204         	movs	r2, #0x4
 8008cf6: 2000         	movs	r0, #0x0
 8008cf8: f00f f979    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf2f2
 8008cfc: 2300         	movs	r3, #0x0
 8008cfe: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 	if (stream->cyclic) {
 8008d02: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008d06: 7e1b         	ldrb	r3, [r3, #0x18]
 8008d08: 2b00         	cmp	r3, #0x0
 8008d0a: d003         	beq	0x8008d14 <dma_stm32_configure+0x674> @ imm = #0x6
; 		DMA_InitStruct.Mode = LL_DMA_MODE_CIRCULAR;
 8008d0c: f44f 7380    	mov.w	r3, #0x100
 8008d10: 61fb         	str	r3, [r7, #0x1c]
 8008d12: e001         	b	0x8008d18 <dma_stm32_configure+0x678> @ imm = #0x2
; 		DMA_InitStruct.Mode = LL_DMA_MODE_NORMAL;
 8008d14: 2300         	movs	r3, #0x0
 8008d16: 61fb         	str	r3, [r7, #0x1c]
; 	stream->source_periph = (stream->direction == PERIPHERAL_TO_MEMORY);
 8008d18: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008d1c: 681b         	ldr	r3, [r3]
 8008d1e: 2b02         	cmp	r3, #0x2
 8008d20: bf0c         	ite	eq
 8008d22: 2301         	moveq	r3, #0x1
 8008d24: 2300         	movne	r3, #0x0
 8008d26: b2da         	uxtb	r2, r3
 8008d28: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008d2c: 711a         	strb	r2, [r3, #0x4]
; 	int index = find_lsb_set(config->source_data_size) - 1;
 8008d2e: 687b         	ldr	r3, [r7, #0x4]
 8008d30: 889b         	ldrh	r3, [r3, #0x4]
 8008d32: 64fb         	str	r3, [r7, #0x4c]
; 	return __builtin_ffs(op);
 8008d34: 6cfb         	ldr	r3, [r7, #0x4c]
 8008d36: fa93 f2a3    	rbit	r2, r3
 8008d3a: fab2 f282    	clz	r2, r2
 8008d3e: 2b00         	cmp	r3, #0x0
 8008d40: d101         	bne	0x8008d46 <dma_stm32_configure+0x6a6> @ imm = #0x2
 8008d42: f04f 32ff    	mov.w	r2, #0xffffffff
 8008d46: 1c53         	adds	r3, r2, #0x1
; 	int index = find_lsb_set(config->source_data_size) - 1;
 8008d48: 3b01         	subs	r3, #0x1
 8008d4a: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	DMA_InitStruct.PeriphOrM2MSrcDataSize = table_p_size[index];
 8008d4e: 4a79         	ldr	r2, [pc, #0x1e4]        @ 0x8008f34 <dma_stm32_configure+0x894>
 8008d50: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 8008d54: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8008d58: 62bb         	str	r3, [r7, #0x28]
; 	index = find_lsb_set(config->dest_data_size) - 1;
 8008d5a: 687b         	ldr	r3, [r7, #0x4]
 8008d5c: 88db         	ldrh	r3, [r3, #0x6]
 8008d5e: 653b         	str	r3, [r7, #0x50]
; 	return __builtin_ffs(op);
 8008d60: 6d3b         	ldr	r3, [r7, #0x50]
 8008d62: fa93 f2a3    	rbit	r2, r3
 8008d66: fab2 f282    	clz	r2, r2
 8008d6a: 2b00         	cmp	r3, #0x0
 8008d6c: d101         	bne	0x8008d72 <dma_stm32_configure+0x6d2> @ imm = #0x2
 8008d6e: f04f 32ff    	mov.w	r2, #0xffffffff
 8008d72: 1c53         	adds	r3, r2, #0x1
; 	index = find_lsb_set(config->dest_data_size) - 1;
 8008d74: 3b01         	subs	r3, #0x1
 8008d76: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	DMA_InitStruct.MemoryOrM2MDstDataSize = table_m_size[index];
 8008d7a: 4a6f         	ldr	r2, [pc, #0x1bc]        @ 0x8008f38 <dma_stm32_configure+0x898>
 8008d7c: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 8008d80: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8008d84: 62fb         	str	r3, [r7, #0x2c]
; 	DMA_InitStruct.MemBurst = stm32_dma_get_mburst(config,
 8008d86: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008d8a: 791b         	ldrb	r3, [r3, #0x4]
 8008d8c: 4619         	mov	r1, r3
 8008d8e: 6878         	ldr	r0, [r7, #0x4]
 8008d90: f000 fbca    	bl	0x8009528 <stm32_dma_get_mburst> @ imm = #0x794
 8008d94: 4603         	mov	r3, r0
 8008d96: 647b         	str	r3, [r7, #0x44]
; 	DMA_InitStruct.PeriphBurst = stm32_dma_get_pburst(config,
 8008d98: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008d9c: 791b         	ldrb	r3, [r3, #0x4]
 8008d9e: 4619         	mov	r1, r3
 8008da0: 6878         	ldr	r0, [r7, #0x4]
 8008da2: f000 fc27    	bl	0x80095f4 <stm32_dma_get_pburst> @ imm = #0x84e
 8008da6: 4603         	mov	r3, r0
 8008da8: 64bb         	str	r3, [r7, #0x48]
; 	if (config->channel_direction != MEMORY_TO_MEMORY) {
 8008daa: 687b         	ldr	r3, [r7, #0x4]
 8008dac: 785b         	ldrb	r3, [r3, #0x1]
 8008dae: f003 0307    	and	r3, r3, #0x7
 8008db2: b2db         	uxtb	r3, r3
 8008db4: 2b00         	cmp	r3, #0x0
 8008db6: d023         	beq	0x8008e00 <dma_stm32_configure+0x760> @ imm = #0x46
; 		if (config->dma_slot >= 8) {
 8008db8: 687b         	ldr	r3, [r7, #0x4]
 8008dba: 781b         	ldrb	r3, [r3]
 8008dbc: 2b07         	cmp	r3, #0x7
 8008dbe: d943         	bls	0x8008e48 <dma_stm32_configure+0x7a8> @ imm = #0x86
; 			LOG_ERR("dma slot error.");
 8008dc0: 2303         	movs	r3, #0x3
 8008dc2: 2b00         	cmp	r3, #0x0
 8008dc4: d019         	beq	0x8008dfa <dma_stm32_configure+0x75a> @ imm = #0x32
 8008dc6: 2301         	movs	r3, #0x1
 8008dc8: f887 3093    	strb.w	r3, [r7, #0x93]
 8008dcc: f897 3093    	ldrb.w	r3, [r7, #0x93]
 8008dd0: f083 0301    	eor	r3, r3, #0x1
 8008dd4: b2db         	uxtb	r3, r3
 8008dd6: 2b00         	cmp	r3, #0x0
 8008dd8: d10f         	bne	0x8008dfa <dma_stm32_configure+0x75a> @ imm = #0x1e
 8008dda: 4b52         	ldr	r3, [pc, #0x148]        @ 0x8008f24 <dma_stm32_configure+0x884>
 8008ddc: 6819         	ldr	r1, [r3]
 8008dde: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8008f3c <dma_stm32_configure+0x89c>
 8008de0: 9302         	str	r3, [sp, #0x8]
 8008de2: 2300         	movs	r3, #0x0
 8008de4: 9301         	str	r3, [sp, #0x4]
 8008de6: 2300         	movs	r3, #0x0
 8008de8: 9300         	str	r3, [sp]
 8008dea: 2300         	movs	r3, #0x0
 8008dec: 2201         	movs	r2, #0x1
 8008dee: 2000         	movs	r0, #0x0
 8008df0: f00f f8fd    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf1fa
 8008df4: 2300         	movs	r3, #0x0
 8008df6: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			return -EINVAL;
 8008dfa: f06f 0315    	mvn	r3, #0x15
 8008dfe: e0b5         	b	0x8008f6c <dma_stm32_configure+0x8cc> @ imm = #0x16a
; 		if (config->dma_slot >= 8) {
 8008e00: 687b         	ldr	r3, [r7, #0x4]
 8008e02: 781b         	ldrb	r3, [r3]
 8008e04: 2b07         	cmp	r3, #0x7
 8008e06: d91f         	bls	0x8008e48 <dma_stm32_configure+0x7a8> @ imm = #0x3e
; 			LOG_ERR("dma slot is too big, using 0 as default.");
 8008e08: 2303         	movs	r3, #0x3
 8008e0a: 2b00         	cmp	r3, #0x0
 8008e0c: d019         	beq	0x8008e42 <dma_stm32_configure+0x7a2> @ imm = #0x32
 8008e0e: 2301         	movs	r3, #0x1
 8008e10: f887 309b    	strb.w	r3, [r7, #0x9b]
 8008e14: f897 309b    	ldrb.w	r3, [r7, #0x9b]
 8008e18: f083 0301    	eor	r3, r3, #0x1
 8008e1c: b2db         	uxtb	r3, r3
 8008e1e: 2b00         	cmp	r3, #0x0
 8008e20: d10f         	bne	0x8008e42 <dma_stm32_configure+0x7a2> @ imm = #0x1e
 8008e22: 4b40         	ldr	r3, [pc, #0x100]        @ 0x8008f24 <dma_stm32_configure+0x884>
 8008e24: 6819         	ldr	r1, [r3]
 8008e26: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8008f40 <dma_stm32_configure+0x8a0>
 8008e28: 9302         	str	r3, [sp, #0x8]
 8008e2a: 2300         	movs	r3, #0x0
 8008e2c: 9301         	str	r3, [sp, #0x4]
 8008e2e: 2300         	movs	r3, #0x0
 8008e30: 9300         	str	r3, [sp]
 8008e32: 2300         	movs	r3, #0x0
 8008e34: 2201         	movs	r2, #0x1
 8008e36: 2000         	movs	r0, #0x0
 8008e38: f00f f8d9    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf1b2
 8008e3c: 2300         	movs	r3, #0x0
 8008e3e: f8c7 3094    	str.w	r3, [r7, #0x94]
; 			config->dma_slot = 0;
 8008e42: 687b         	ldr	r3, [r7, #0x4]
 8008e44: 2200         	movs	r2, #0x0
 8008e46: 701a         	strb	r2, [r3]
; 	DMA_InitStruct.Channel = dma_stm32_slot_to_channel(config->dma_slot);
 8008e48: 687b         	ldr	r3, [r7, #0x4]
 8008e4a: 781b         	ldrb	r3, [r3]
 8008e4c: 4618         	mov	r0, r3
 8008e4e: f000 f9f7    	bl	0x8009240 <dma_stm32_slot_to_channel> @ imm = #0x3ee
 8008e52: 4603         	mov	r3, r0
 8008e54: 637b         	str	r3, [r7, #0x34]
; 					config->head_block->fifo_mode_control);
 8008e56: 687b         	ldr	r3, [r7, #0x4]
 8008e58: 691b         	ldr	r3, [r3, #0x10]
 8008e5a: 7f5b         	ldrb	r3, [r3, #0x1d]
 8008e5c: f3c3 0303    	ubfx	r3, r3, #0x0, #0x4
 8008e60: b2db         	uxtb	r3, r3
; 	DMA_InitStruct.FIFOThreshold = stm32_dma_get_fifo_threshold(
 8008e62: 4618         	mov	r0, r3
 8008e64: f000 fc2c    	bl	0x80096c0 <stm32_dma_get_fifo_threshold> @ imm = #0x858
 8008e68: 4603         	mov	r3, r0
 8008e6a: 643b         	str	r3, [r7, #0x40]
; 	if (stm32_dma_check_fifo_mburst(&DMA_InitStruct)) {
 8008e6c: f107 0310    	add.w	r3, r7, #0x10
 8008e70: 4618         	mov	r0, r3
 8008e72: f010 f9b3    	bl	0x80191dc <stm32_dma_check_fifo_mburst> @ imm = #0x10366
 8008e76: 4603         	mov	r3, r0
 8008e78: 2b00         	cmp	r3, #0x0
 8008e7a: d002         	beq	0x8008e82 <dma_stm32_configure+0x7e2> @ imm = #0x4
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_ENABLE;
 8008e7c: 2304         	movs	r3, #0x4
 8008e7e: 63fb         	str	r3, [r7, #0x3c]
 8008e80: e001         	b	0x8008e86 <dma_stm32_configure+0x7e6> @ imm = #0x2
; 		DMA_InitStruct.FIFOMode = LL_DMA_FIFOMODE_DISABLE;
 8008e82: 2300         	movs	r3, #0x0
 8008e84: 63fb         	str	r3, [r7, #0x3c]
; 	if (stream->source_periph) {
 8008e86: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008e8a: 791b         	ldrb	r3, [r3, #0x4]
 8008e8c: 2b00         	cmp	r3, #0x0
 8008e8e: d008         	beq	0x8008ea2 <dma_stm32_configure+0x802> @ imm = #0x10
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8008e90: 687b         	ldr	r3, [r7, #0x4]
 8008e92: 691b         	ldr	r3, [r3, #0x10]
 8008e94: 695b         	ldr	r3, [r3, #0x14]
; 					config->source_data_size;
 8008e96: 687a         	ldr	r2, [r7, #0x4]
 8008e98: 8892         	ldrh	r2, [r2, #0x4]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8008e9a: fbb3 f3f2    	udiv	r3, r3, r2
 8008e9e: 633b         	str	r3, [r7, #0x30]
 8008ea0: e007         	b	0x8008eb2 <dma_stm32_configure+0x812> @ imm = #0xe
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8008ea2: 687b         	ldr	r3, [r7, #0x4]
 8008ea4: 691b         	ldr	r3, [r3, #0x10]
 8008ea6: 695b         	ldr	r3, [r3, #0x14]
; 					config->dest_data_size;
 8008ea8: 687a         	ldr	r2, [r7, #0x4]
 8008eaa: 88d2         	ldrh	r2, [r2, #0x6]
; 		DMA_InitStruct.NbData = config->head_block->block_size /
 8008eac: fbb3 f3f2    	udiv	r3, r3, r2
 8008eb0: 633b         	str	r3, [r7, #0x30]
; 	LL_DMA_Init(dma, dma_stm32_id_to_stream(id), &DMA_InitStruct);
 8008eb2: 68b8         	ldr	r0, [r7, #0x8]
 8008eb4: f000 f9b4    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #0x368
 8008eb8: 4601         	mov	r1, r0
 8008eba: f107 0310    	add.w	r3, r7, #0x10
 8008ebe: 461a         	mov	r2, r3
 8008ec0: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8008ec4: f014 fecd    	bl	0x801dc62 <LL_DMA_Init> @ imm = #0x14d9a
; 	LL_DMA_EnableIT_TC(dma, dma_stm32_id_to_stream(id));
 8008ec8: 68b8         	ldr	r0, [r7, #0x8]
 8008eca: f000 f9a9    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #0x352
 8008ece: 4603         	mov	r3, r0
 8008ed0: 4619         	mov	r1, r3
 8008ed2: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8008ed6: f7ff f97b    	bl	0x80081d0 <LL_DMA_EnableIT_TC> @ imm = #-0xd0a
; 	if (stream->cyclic) {
 8008eda: f8d7 30d0    	ldr.w	r3, [r7, #0xd0]
 8008ede: 7e1b         	ldrb	r3, [r3, #0x18]
 8008ee0: 2b00         	cmp	r3, #0x0
 8008ee2: d008         	beq	0x8008ef6 <dma_stm32_configure+0x856> @ imm = #0x10
; 		LL_DMA_EnableIT_HT(dma, dma_stm32_id_to_stream(id));
 8008ee4: 68b8         	ldr	r0, [r7, #0x8]
 8008ee6: f000 f99b    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #0x336
 8008eea: 4603         	mov	r3, r0
 8008eec: 4619         	mov	r1, r3
 8008eee: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8008ef2: f7ff f94d    	bl	0x8008190 <LL_DMA_EnableIT_HT> @ imm = #-0xd66
; 	if (DMA_InitStruct.FIFOMode == LL_DMA_FIFOMODE_ENABLE) {
 8008ef6: 6bfb         	ldr	r3, [r7, #0x3c]
 8008ef8: 2b04         	cmp	r3, #0x4
 8008efa: d123         	bne	0x8008f44 <dma_stm32_configure+0x8a4> @ imm = #0x46
; 		LL_DMA_EnableFifoMode(dma, dma_stm32_id_to_stream(id));
 8008efc: 68b8         	ldr	r0, [r7, #0x8]
 8008efe: f000 f98f    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #0x31e
 8008f02: 4603         	mov	r3, r0
 8008f04: 4619         	mov	r1, r3
 8008f06: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8008f0a: f7ff f8f1    	bl	0x80080f0 <LL_DMA_EnableFifoMode> @ imm = #-0xe1e
; 		LL_DMA_EnableIT_FE(dma, dma_stm32_id_to_stream(id));
 8008f0e: 68b8         	ldr	r0, [r7, #0x8]
 8008f10: f000 f986    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #0x30c
 8008f14: 4603         	mov	r3, r0
 8008f16: 4619         	mov	r1, r3
 8008f18: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8008f1c: f7ff f978    	bl	0x8008210 <LL_DMA_EnableIT_FE> @ imm = #-0xd10
 8008f20: e022         	b	0x8008f68 <dma_stm32_configure+0x8c8> @ imm = #0x44
 8008f22: bf00         	nop

08008f24 <$d>:
 8008f24: 4c 05 00 20  	.word	0x2000054c
 8008f28: fc 26 02 08  	.word	0x080226fc
 8008f2c: 00 12 02 08  	.word	0x08021200
 8008f30: 24 12 02 08  	.word	0x08021224
 8008f34: 90 26 02 08  	.word	0x08022690
 8008f38: 84 26 02 08  	.word	0x08022684
 8008f3c: 4c 12 02 08  	.word	0x0802124c
 8008f40: 5c 12 02 08  	.word	0x0802125c

08008f44 <$t>:
; 		LL_DMA_DisableFifoMode(dma, dma_stm32_id_to_stream(id));
 8008f44: 68b8         	ldr	r0, [r7, #0x8]
 8008f46: f000 f96b    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #0x2d6
 8008f4a: 4603         	mov	r3, r0
 8008f4c: 4619         	mov	r1, r3
 8008f4e: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8008f52: f7ff f8ad    	bl	0x80080b0 <LL_DMA_DisableFifoMode> @ imm = #-0xea6
; 		LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 8008f56: 68b8         	ldr	r0, [r7, #0x8]
 8008f58: f000 f962    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #0x2c4
 8008f5c: 4603         	mov	r3, r0
 8008f5e: 4619         	mov	r1, r3
 8008f60: f8d7 00cc    	ldr.w	r0, [r7, #0xcc]
 8008f64: f7ff f994    	bl	0x8008290 <LL_DMA_DisableIT_FE> @ imm = #-0xcd8
; 	return ret;
 8008f68: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
; }
 8008f6c: 4618         	mov	r0, r3
 8008f6e: 37e0         	adds	r7, #0xe0
 8008f70: 46bd         	mov	sp, r7
 8008f72: bd80         	pop	{r7, pc}

08008f74 <dma_stm32_init>:
; {
 8008f74: b580         	push	{r7, lr}
 8008f76: b08e         	sub	sp, #0x38
 8008f78: af04         	add	r7, sp, #0x10
 8008f7a: 6078         	str	r0, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 8008f7c: 687b         	ldr	r3, [r7, #0x4]
 8008f7e: 685b         	ldr	r3, [r3, #0x4]
 8008f80: 623b         	str	r3, [r7, #0x20]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8008f82: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8009070 <dma_stm32_init+0xfc>
 8008f84: 61fb         	str	r3, [r7, #0x1c]
; 	if (!device_is_ready(clk)) {
 8008f86: 69f8         	ldr	r0, [r7, #0x1c]
 8008f88: f00f f805    	bl	0x8017f96 <device_is_ready> @ imm = #0xf00a
 8008f8c: 4603         	mov	r3, r0
 8008f8e: f083 0301    	eor	r3, r3, #0x1
 8008f92: b2db         	uxtb	r3, r3
 8008f94: 2b00         	cmp	r3, #0x0
 8008f96: d01c         	beq	0x8008fd2 <dma_stm32_init+0x5e> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 8008f98: 2303         	movs	r3, #0x3
 8008f9a: 2b00         	cmp	r3, #0x0
 8008f9c: d016         	beq	0x8008fcc <dma_stm32_init+0x58> @ imm = #0x2c
 8008f9e: 2301         	movs	r3, #0x1
 8008fa0: 74fb         	strb	r3, [r7, #0x13]
 8008fa2: 7cfb         	ldrb	r3, [r7, #0x13]
 8008fa4: f083 0301    	eor	r3, r3, #0x1
 8008fa8: b2db         	uxtb	r3, r3
 8008faa: 2b00         	cmp	r3, #0x0
 8008fac: d10e         	bne	0x8008fcc <dma_stm32_init+0x58> @ imm = #0x1c
 8008fae: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8009074 <dma_stm32_init+0x100>
 8008fb0: 6819         	ldr	r1, [r3]
 8008fb2: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8009078 <dma_stm32_init+0x104>
 8008fb4: 9302         	str	r3, [sp, #0x8]
 8008fb6: 2300         	movs	r3, #0x0
 8008fb8: 9301         	str	r3, [sp, #0x4]
 8008fba: 2300         	movs	r3, #0x0
 8008fbc: 9300         	str	r3, [sp]
 8008fbe: 2300         	movs	r3, #0x0
 8008fc0: 2201         	movs	r2, #0x1
 8008fc2: 2000         	movs	r0, #0x0
 8008fc4: f00f f813    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xf026
 8008fc8: 2300         	movs	r3, #0x0
 8008fca: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 8008fcc: f06f 0312    	mvn	r3, #0x12
 8008fd0: e04a         	b	0x8009068 <dma_stm32_init+0xf4> @ imm = #0x94
; 		(clock_control_subsys_t) &config->pclken) != 0) {
 8008fd2: 6a3b         	ldr	r3, [r7, #0x20]
; 	if (clock_control_on(clk,
 8008fd4: 4619         	mov	r1, r3
 8008fd6: 69f8         	ldr	r0, [r7, #0x1c]
 8008fd8: f00e fff7    	bl	0x8017fca <clock_control_on> @ imm = #0xefee
 8008fdc: 4603         	mov	r3, r0
 8008fde: 2b00         	cmp	r3, #0x0
 8008fe0: d01c         	beq	0x800901c <dma_stm32_init+0xa8> @ imm = #0x38
; 		LOG_ERR("clock op failed\n");
 8008fe2: 2303         	movs	r3, #0x3
 8008fe4: 2b00         	cmp	r3, #0x0
 8008fe6: d016         	beq	0x8009016 <dma_stm32_init+0xa2> @ imm = #0x2c
 8008fe8: 2301         	movs	r3, #0x1
 8008fea: 76fb         	strb	r3, [r7, #0x1b]
 8008fec: 7efb         	ldrb	r3, [r7, #0x1b]
 8008fee: f083 0301    	eor	r3, r3, #0x1
 8008ff2: b2db         	uxtb	r3, r3
 8008ff4: 2b00         	cmp	r3, #0x0
 8008ff6: d10e         	bne	0x8009016 <dma_stm32_init+0xa2> @ imm = #0x1c
 8008ff8: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8009074 <dma_stm32_init+0x100>
 8008ffa: 6819         	ldr	r1, [r3]
 8008ffc: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800907c <dma_stm32_init+0x108>
 8008ffe: 9302         	str	r3, [sp, #0x8]
 8009000: 2300         	movs	r3, #0x0
 8009002: 9301         	str	r3, [sp, #0x4]
 8009004: 2300         	movs	r3, #0x0
 8009006: 9300         	str	r3, [sp]
 8009008: 2300         	movs	r3, #0x0
 800900a: 2201         	movs	r2, #0x1
 800900c: 2000         	movs	r0, #0x0
 800900e: f00e ffee    	bl	0x8017fee <z_log_msg_runtime_create> @ imm = #0xefdc
 8009012: 2300         	movs	r3, #0x0
 8009014: 617b         	str	r3, [r7, #0x14]
; 		return -EIO;
 8009016: f06f 0304    	mvn	r3, #0x4
 800901a: e025         	b	0x8009068 <dma_stm32_init+0xf4> @ imm = #0x4a
; 	config->config_irq(dev);
 800901c: 6a3b         	ldr	r3, [r7, #0x20]
 800901e: 689b         	ldr	r3, [r3, #0x8]
 8009020: 6878         	ldr	r0, [r7, #0x4]
 8009022: 4798         	blx	r3
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 8009024: 2300         	movs	r3, #0x0
 8009026: 627b         	str	r3, [r7, #0x24]
 8009028: e00c         	b	0x8009044 <dma_stm32_init+0xd0> @ imm = #0x18
; 		config->streams[i].busy = false;
 800902a: 6a3b         	ldr	r3, [r7, #0x20]
 800902c: 6999         	ldr	r1, [r3, #0x18]
 800902e: 6a7a         	ldr	r2, [r7, #0x24]
 8009030: 4613         	mov	r3, r2
 8009032: 00db         	lsls	r3, r3, #0x3
 8009034: 1a9b         	subs	r3, r3, r2
 8009036: 009b         	lsls	r3, r3, #0x2
 8009038: 440b         	add	r3, r1
 800903a: 2200         	movs	r2, #0x0
 800903c: 719a         	strb	r2, [r3, #0x6]
; 	for (uint32_t i = 0; i < config->max_streams; i++) {
 800903e: 6a7b         	ldr	r3, [r7, #0x24]
 8009040: 3301         	adds	r3, #0x1
 8009042: 627b         	str	r3, [r7, #0x24]
 8009044: 6a3b         	ldr	r3, [r7, #0x20]
 8009046: 695b         	ldr	r3, [r3, #0x14]
 8009048: 6a7a         	ldr	r2, [r7, #0x24]
 800904a: 429a         	cmp	r2, r3
 800904c: d3ed         	blo	0x800902a <dma_stm32_init+0xb6> @ imm = #-0x26
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.magic = 0;
 800904e: 687b         	ldr	r3, [r7, #0x4]
 8009050: 691b         	ldr	r3, [r3, #0x10]
 8009052: 2200         	movs	r2, #0x0
 8009054: 601a         	str	r2, [r3]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.dma_channels = 0;
 8009056: 687b         	ldr	r3, [r7, #0x4]
 8009058: 691b         	ldr	r3, [r3, #0x10]
 800905a: 2200         	movs	r2, #0x0
 800905c: 605a         	str	r2, [r3, #0x4]
; 	((struct dma_stm32_data *)dev->data)->dma_ctx.atomic = 0;
 800905e: 687b         	ldr	r3, [r7, #0x4]
 8009060: 691b         	ldr	r3, [r3, #0x10]
 8009062: 2200         	movs	r2, #0x0
 8009064: 609a         	str	r2, [r3, #0x8]
; 	return 0;
 8009066: 2300         	movs	r3, #0x0
; }
 8009068: 4618         	mov	r0, r3
 800906a: 3728         	adds	r7, #0x28
 800906c: 46bd         	mov	sp, r7
 800906e: bd80         	pop	{r7, pc}

08009070 <$d>:
 8009070: 80 01 02 08  	.word	0x08020180
 8009074: 4c 05 00 20  	.word	0x2000054c
 8009078: 88 12 02 08  	.word	0x08021288
 800907c: a8 12 02 08  	.word	0x080212a8

08009080 <LL_DMA_EnableStream>:
; {
 8009080: b480         	push	{r7}
 8009082: b083         	sub	sp, #0xc
 8009084: af00         	add	r7, sp, #0x0
 8009086: 6078         	str	r0, [r7, #0x4]
 8009088: 6039         	str	r1, [r7]
;   SET_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN);
 800908a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80090bc <LL_DMA_EnableStream+0x3c>
 800908c: 683b         	ldr	r3, [r7]
 800908e: 4413         	add	r3, r2
 8009090: 781b         	ldrb	r3, [r3]
 8009092: 461a         	mov	r2, r3
 8009094: 687b         	ldr	r3, [r7, #0x4]
 8009096: 4413         	add	r3, r2
 8009098: 681b         	ldr	r3, [r3]
 800909a: 4908         	ldr	r1, [pc, #0x20]         @ 0x80090bc <LL_DMA_EnableStream+0x3c>
 800909c: 683a         	ldr	r2, [r7]
 800909e: 440a         	add	r2, r1
 80090a0: 7812         	ldrb	r2, [r2]
 80090a2: 4611         	mov	r1, r2
 80090a4: 687a         	ldr	r2, [r7, #0x4]
 80090a6: 440a         	add	r2, r1
 80090a8: f043 0301    	orr	r3, r3, #0x1
 80090ac: 6013         	str	r3, [r2]
; }
 80090ae: bf00         	nop
 80090b0: 370c         	adds	r7, #0xc
 80090b2: 46bd         	mov	sp, r7
 80090b4: f85d 7b04    	ldr	r7, [sp], #4
 80090b8: 4770         	bx	lr
 80090ba: bf00         	nop

080090bc <$d>:
 80090bc: 10 27 02 08  	.word	0x08022710

080090c0 <LL_DMA_DisableStream>:
; {
 80090c0: b480         	push	{r7}
 80090c2: b083         	sub	sp, #0xc
 80090c4: af00         	add	r7, sp, #0x0
 80090c6: 6078         	str	r0, [r7, #0x4]
 80090c8: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN);
 80090ca: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80090fc <LL_DMA_DisableStream+0x3c>
 80090cc: 683b         	ldr	r3, [r7]
 80090ce: 4413         	add	r3, r2
 80090d0: 781b         	ldrb	r3, [r3]
 80090d2: 461a         	mov	r2, r3
 80090d4: 687b         	ldr	r3, [r7, #0x4]
 80090d6: 4413         	add	r3, r2
 80090d8: 681b         	ldr	r3, [r3]
 80090da: 4908         	ldr	r1, [pc, #0x20]         @ 0x80090fc <LL_DMA_DisableStream+0x3c>
 80090dc: 683a         	ldr	r2, [r7]
 80090de: 440a         	add	r2, r1
 80090e0: 7812         	ldrb	r2, [r2]
 80090e2: 4611         	mov	r1, r2
 80090e4: 687a         	ldr	r2, [r7, #0x4]
 80090e6: 440a         	add	r2, r1
 80090e8: f023 0301    	bic	r3, r3, #0x1
 80090ec: 6013         	str	r3, [r2]
; }
 80090ee: bf00         	nop
 80090f0: 370c         	adds	r7, #0xc
 80090f2: 46bd         	mov	sp, r7
 80090f4: f85d 7b04    	ldr	r7, [sp], #4
 80090f8: 4770         	bx	lr
 80090fa: bf00         	nop

080090fc <$d>:
 80090fc: 10 27 02 08  	.word	0x08022710

08009100 <LL_DMA_IsEnabledStream>:
; {
 8009100: b480         	push	{r7}
 8009102: b083         	sub	sp, #0xc
 8009104: af00         	add	r7, sp, #0x0
 8009106: 6078         	str	r0, [r7, #0x4]
 8009108: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_EN) == (DMA_SxCR_EN));
 800910a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8009134 <LL_DMA_IsEnabledStream+0x34>
 800910c: 683b         	ldr	r3, [r7]
 800910e: 4413         	add	r3, r2
 8009110: 781b         	ldrb	r3, [r3]
 8009112: 461a         	mov	r2, r3
 8009114: 687b         	ldr	r3, [r7, #0x4]
 8009116: 4413         	add	r3, r2
 8009118: 681b         	ldr	r3, [r3]
 800911a: f003 0301    	and	r3, r3, #0x1
 800911e: 2b01         	cmp	r3, #0x1
 8009120: bf0c         	ite	eq
 8009122: 2301         	moveq	r3, #0x1
 8009124: 2300         	movne	r3, #0x0
 8009126: b2db         	uxtb	r3, r3
; }
 8009128: 4618         	mov	r0, r3
 800912a: 370c         	adds	r7, #0xc
 800912c: 46bd         	mov	sp, r7
 800912e: f85d 7b04    	ldr	r7, [sp], #4
 8009132: 4770         	bx	lr

08009134 <$d>:
 8009134: 10 27 02 08  	.word	0x08022710

08009138 <LL_DMA_DisableIT_FE>:
; {
 8009138: b480         	push	{r7}
 800913a: b083         	sub	sp, #0xc
 800913c: af00         	add	r7, sp, #0x0
 800913e: 6078         	str	r0, [r7, #0x4]
 8009140: 6039         	str	r1, [r7]
;   CLEAR_BIT(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE);
 8009142: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8009174 <LL_DMA_DisableIT_FE+0x3c>
 8009144: 683b         	ldr	r3, [r7]
 8009146: 4413         	add	r3, r2
 8009148: 781b         	ldrb	r3, [r3]
 800914a: 461a         	mov	r2, r3
 800914c: 687b         	ldr	r3, [r7, #0x4]
 800914e: 4413         	add	r3, r2
 8009150: 695b         	ldr	r3, [r3, #0x14]
 8009152: 4908         	ldr	r1, [pc, #0x20]         @ 0x8009174 <LL_DMA_DisableIT_FE+0x3c>
 8009154: 683a         	ldr	r2, [r7]
 8009156: 440a         	add	r2, r1
 8009158: 7812         	ldrb	r2, [r2]
 800915a: 4611         	mov	r1, r2
 800915c: 687a         	ldr	r2, [r7, #0x4]
 800915e: 440a         	add	r2, r1
 8009160: f023 0380    	bic	r3, r3, #0x80
 8009164: 6153         	str	r3, [r2, #0x14]
; }
 8009166: bf00         	nop
 8009168: 370c         	adds	r7, #0xc
 800916a: 46bd         	mov	sp, r7
 800916c: f85d 7b04    	ldr	r7, [sp], #4
 8009170: 4770         	bx	lr
 8009172: bf00         	nop

08009174 <$d>:
 8009174: 10 27 02 08  	.word	0x08022710

08009178 <LL_DMA_IsEnabledIT_HT>:
; {
 8009178: b480         	push	{r7}
 800917a: b083         	sub	sp, #0xc
 800917c: af00         	add	r7, sp, #0x0
 800917e: 6078         	str	r0, [r7, #0x4]
 8009180: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_HTIE) == DMA_SxCR_HTIE);
 8009182: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80091ac <LL_DMA_IsEnabledIT_HT+0x34>
 8009184: 683b         	ldr	r3, [r7]
 8009186: 4413         	add	r3, r2
 8009188: 781b         	ldrb	r3, [r3]
 800918a: 461a         	mov	r2, r3
 800918c: 687b         	ldr	r3, [r7, #0x4]
 800918e: 4413         	add	r3, r2
 8009190: 681b         	ldr	r3, [r3]
 8009192: f003 0308    	and	r3, r3, #0x8
 8009196: 2b08         	cmp	r3, #0x8
 8009198: bf0c         	ite	eq
 800919a: 2301         	moveq	r3, #0x1
 800919c: 2300         	movne	r3, #0x0
 800919e: b2db         	uxtb	r3, r3
; }
 80091a0: 4618         	mov	r0, r3
 80091a2: 370c         	adds	r7, #0xc
 80091a4: 46bd         	mov	sp, r7
 80091a6: f85d 7b04    	ldr	r7, [sp], #4
 80091aa: 4770         	bx	lr

080091ac <$d>:
 80091ac: 10 27 02 08  	.word	0x08022710

080091b0 <LL_DMA_IsEnabledIT_TC>:
; {
 80091b0: b480         	push	{r7}
 80091b2: b083         	sub	sp, #0xc
 80091b4: af00         	add	r7, sp, #0x0
 80091b6: 6078         	str	r0, [r7, #0x4]
 80091b8: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_TCIE) == DMA_SxCR_TCIE);
 80091ba: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80091e4 <LL_DMA_IsEnabledIT_TC+0x34>
 80091bc: 683b         	ldr	r3, [r7]
 80091be: 4413         	add	r3, r2
 80091c0: 781b         	ldrb	r3, [r3]
 80091c2: 461a         	mov	r2, r3
 80091c4: 687b         	ldr	r3, [r7, #0x4]
 80091c6: 4413         	add	r3, r2
 80091c8: 681b         	ldr	r3, [r3]
 80091ca: f003 0310    	and	r3, r3, #0x10
 80091ce: 2b10         	cmp	r3, #0x10
 80091d0: bf0c         	ite	eq
 80091d2: 2301         	moveq	r3, #0x1
 80091d4: 2300         	movne	r3, #0x0
 80091d6: b2db         	uxtb	r3, r3
; }
 80091d8: 4618         	mov	r0, r3
 80091da: 370c         	adds	r7, #0xc
 80091dc: 46bd         	mov	sp, r7
 80091de: f85d 7b04    	ldr	r7, [sp], #4
 80091e2: 4770         	bx	lr

080091e4 <$d>:
 80091e4: 10 27 02 08  	.word	0x08022710

080091e8 <LL_DMA_IsEnabledIT_FE>:
; {
 80091e8: b480         	push	{r7}
 80091ea: b083         	sub	sp, #0xc
 80091ec: af00         	add	r7, sp, #0x0
 80091ee: 6078         	str	r0, [r7, #0x4]
 80091f0: 6039         	str	r1, [r7]
;   return (READ_BIT(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FEIE) == DMA_SxFCR_FEIE);
 80091f2: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800921c <LL_DMA_IsEnabledIT_FE+0x34>
 80091f4: 683b         	ldr	r3, [r7]
 80091f6: 4413         	add	r3, r2
 80091f8: 781b         	ldrb	r3, [r3]
 80091fa: 461a         	mov	r2, r3
 80091fc: 687b         	ldr	r3, [r7, #0x4]
 80091fe: 4413         	add	r3, r2
 8009200: 695b         	ldr	r3, [r3, #0x14]
 8009202: f003 0380    	and	r3, r3, #0x80
 8009206: 2b80         	cmp	r3, #0x80
 8009208: bf0c         	ite	eq
 800920a: 2301         	moveq	r3, #0x1
 800920c: 2300         	movne	r3, #0x0
 800920e: b2db         	uxtb	r3, r3
; }
 8009210: 4618         	mov	r0, r3
 8009212: 370c         	adds	r7, #0xc
 8009214: 46bd         	mov	sp, r7
 8009216: f85d 7b04    	ldr	r7, [sp], #4
 800921a: 4770         	bx	lr

0800921c <$d>:
 800921c: 10 27 02 08  	.word	0x08022710

08009220 <dma_stm32_id_to_stream>:
; {
 8009220: b480         	push	{r7}
 8009222: b083         	sub	sp, #0xc
 8009224: af00         	add	r7, sp, #0x0
 8009226: 6078         	str	r0, [r7, #0x4]
; 	return stream_nr[id];
 8009228: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800923c <dma_stm32_id_to_stream+0x1c>
 800922a: 687b         	ldr	r3, [r7, #0x4]
 800922c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8009230: 4618         	mov	r0, r3
 8009232: 370c         	adds	r7, #0xc
 8009234: 46bd         	mov	sp, r7
 8009236: f85d 7b04    	ldr	r7, [sp], #4
 800923a: 4770         	bx	lr

0800923c <$d>:
 800923c: 18 27 02 08  	.word	0x08022718

08009240 <dma_stm32_slot_to_channel>:
; {
 8009240: b480         	push	{r7}
 8009242: b083         	sub	sp, #0xc
 8009244: af00         	add	r7, sp, #0x0
 8009246: 6078         	str	r0, [r7, #0x4]
; 	return channel_nr[slot];
 8009248: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800925c <dma_stm32_slot_to_channel+0x1c>
 800924a: 687b         	ldr	r3, [r7, #0x4]
 800924c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8009250: 4618         	mov	r0, r3
 8009252: 370c         	adds	r7, #0xc
 8009254: 46bd         	mov	sp, r7
 8009256: f85d 7b04    	ldr	r7, [sp], #4
 800925a: 4770         	bx	lr

0800925c <$d>:
 800925c: 38 27 02 08  	.word	0x08022738

08009260 <dma_stm32_clear_ht>:
; {
 8009260: b580         	push	{r7, lr}
 8009262: b082         	sub	sp, #0x8
 8009264: af00         	add	r7, sp, #0x0
 8009266: 6078         	str	r0, [r7, #0x4]
 8009268: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800926a: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8009280 <dma_stm32_clear_ht+0x20>
 800926c: 683b         	ldr	r3, [r7]
 800926e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8009272: 6878         	ldr	r0, [r7, #0x4]
 8009274: 4798         	blx	r3
; }
 8009276: bf00         	nop
 8009278: 3708         	adds	r7, #0x8
 800927a: 46bd         	mov	sp, r7
 800927c: bd80         	pop	{r7, pc}
 800927e: bf00         	nop

08009280 <$d>:
 8009280: 58 27 02 08  	.word	0x08022758

08009284 <dma_stm32_clear_tc>:
; {
 8009284: b580         	push	{r7, lr}
 8009286: b082         	sub	sp, #0x8
 8009288: af00         	add	r7, sp, #0x0
 800928a: 6078         	str	r0, [r7, #0x4]
 800928c: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800928e: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80092a4 <dma_stm32_clear_tc+0x20>
 8009290: 683b         	ldr	r3, [r7]
 8009292: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8009296: 6878         	ldr	r0, [r7, #0x4]
 8009298: 4798         	blx	r3
; }
 800929a: bf00         	nop
 800929c: 3708         	adds	r7, #0x8
 800929e: 46bd         	mov	sp, r7
 80092a0: bd80         	pop	{r7, pc}
 80092a2: bf00         	nop

080092a4 <$d>:
 80092a4: 78 27 02 08  	.word	0x08022778

080092a8 <dma_stm32_is_ht_active>:
; {
 80092a8: b580         	push	{r7, lr}
 80092aa: b082         	sub	sp, #0x8
 80092ac: af00         	add	r7, sp, #0x0
 80092ae: 6078         	str	r0, [r7, #0x4]
 80092b0: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 80092b2: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80092d4 <dma_stm32_is_ht_active+0x2c>
 80092b4: 683b         	ldr	r3, [r7]
 80092b6: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80092ba: 6878         	ldr	r0, [r7, #0x4]
 80092bc: 4798         	blx	r3
 80092be: 4603         	mov	r3, r0
 80092c0: 2b00         	cmp	r3, #0x0
 80092c2: bf14         	ite	ne
 80092c4: 2301         	movne	r3, #0x1
 80092c6: 2300         	moveq	r3, #0x0
 80092c8: b2db         	uxtb	r3, r3
; }
 80092ca: 4618         	mov	r0, r3
 80092cc: 3708         	adds	r7, #0x8
 80092ce: 46bd         	mov	sp, r7
 80092d0: bd80         	pop	{r7, pc}
 80092d2: bf00         	nop

080092d4 <$d>:
 80092d4: 98 27 02 08  	.word	0x08022798

080092d8 <dma_stm32_is_tc_active>:
; {
 80092d8: b580         	push	{r7, lr}
 80092da: b082         	sub	sp, #0x8
 80092dc: af00         	add	r7, sp, #0x0
 80092de: 6078         	str	r0, [r7, #0x4]
 80092e0: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 80092e2: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8009304 <dma_stm32_is_tc_active+0x2c>
 80092e4: 683b         	ldr	r3, [r7]
 80092e6: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80092ea: 6878         	ldr	r0, [r7, #0x4]
 80092ec: 4798         	blx	r3
 80092ee: 4603         	mov	r3, r0
 80092f0: 2b00         	cmp	r3, #0x0
 80092f2: bf14         	ite	ne
 80092f4: 2301         	movne	r3, #0x1
 80092f6: 2300         	moveq	r3, #0x0
 80092f8: b2db         	uxtb	r3, r3
; }
 80092fa: 4618         	mov	r0, r3
 80092fc: 3708         	adds	r7, #0x8
 80092fe: 46bd         	mov	sp, r7
 8009300: bd80         	pop	{r7, pc}
 8009302: bf00         	nop

08009304 <$d>:
 8009304: b8 27 02 08  	.word	0x080227b8

08009308 <dma_stm32_clear_te>:
; {
 8009308: b580         	push	{r7, lr}
 800930a: b082         	sub	sp, #0x8
 800930c: af00         	add	r7, sp, #0x0
 800930e: 6078         	str	r0, [r7, #0x4]
 8009310: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 8009312: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8009328 <dma_stm32_clear_te+0x20>
 8009314: 683b         	ldr	r3, [r7]
 8009316: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800931a: 6878         	ldr	r0, [r7, #0x4]
 800931c: 4798         	blx	r3
; }
 800931e: bf00         	nop
 8009320: 3708         	adds	r7, #0x8
 8009322: 46bd         	mov	sp, r7
 8009324: bd80         	pop	{r7, pc}
 8009326: bf00         	nop

08009328 <$d>:
 8009328: d8 27 02 08  	.word	0x080227d8

0800932c <dma_stm32_clear_dme>:
; {
 800932c: b580         	push	{r7, lr}
 800932e: b082         	sub	sp, #0x8
 8009330: af00         	add	r7, sp, #0x0
 8009332: 6078         	str	r0, [r7, #0x4]
 8009334: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 8009336: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800934c <dma_stm32_clear_dme+0x20>
 8009338: 683b         	ldr	r3, [r7]
 800933a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800933e: 6878         	ldr	r0, [r7, #0x4]
 8009340: 4798         	blx	r3
; }
 8009342: bf00         	nop
 8009344: 3708         	adds	r7, #0x8
 8009346: 46bd         	mov	sp, r7
 8009348: bd80         	pop	{r7, pc}
 800934a: bf00         	nop

0800934c <$d>:
 800934c: f8 27 02 08  	.word	0x080227f8

08009350 <dma_stm32_clear_fe>:
; {
 8009350: b580         	push	{r7, lr}
 8009352: b082         	sub	sp, #0x8
 8009354: af00         	add	r7, sp, #0x0
 8009356: 6078         	str	r0, [r7, #0x4]
 8009358: 6039         	str	r1, [r7]
; 	func[id](DMAx);
 800935a: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8009370 <dma_stm32_clear_fe+0x20>
 800935c: 683b         	ldr	r3, [r7]
 800935e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8009362: 6878         	ldr	r0, [r7, #0x4]
 8009364: 4798         	blx	r3
; }
 8009366: bf00         	nop
 8009368: 3708         	adds	r7, #0x8
 800936a: 46bd         	mov	sp, r7
 800936c: bd80         	pop	{r7, pc}
 800936e: bf00         	nop

08009370 <$d>:
 8009370: 18 28 02 08  	.word	0x08022818

08009374 <dma_stm32_is_te_active>:
; {
 8009374: b580         	push	{r7, lr}
 8009376: b082         	sub	sp, #0x8
 8009378: af00         	add	r7, sp, #0x0
 800937a: 6078         	str	r0, [r7, #0x4]
 800937c: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 800937e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80093a0 <dma_stm32_is_te_active+0x2c>
 8009380: 683b         	ldr	r3, [r7]
 8009382: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8009386: 6878         	ldr	r0, [r7, #0x4]
 8009388: 4798         	blx	r3
 800938a: 4603         	mov	r3, r0
 800938c: 2b00         	cmp	r3, #0x0
 800938e: bf14         	ite	ne
 8009390: 2301         	movne	r3, #0x1
 8009392: 2300         	moveq	r3, #0x0
 8009394: b2db         	uxtb	r3, r3
; }
 8009396: 4618         	mov	r0, r3
 8009398: 3708         	adds	r7, #0x8
 800939a: 46bd         	mov	sp, r7
 800939c: bd80         	pop	{r7, pc}
 800939e: bf00         	nop

080093a0 <$d>:
 80093a0: 38 28 02 08  	.word	0x08022838

080093a4 <dma_stm32_is_dme_active>:
; {
 80093a4: b580         	push	{r7, lr}
 80093a6: b082         	sub	sp, #0x8
 80093a8: af00         	add	r7, sp, #0x0
 80093aa: 6078         	str	r0, [r7, #0x4]
 80093ac: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 80093ae: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80093d0 <dma_stm32_is_dme_active+0x2c>
 80093b0: 683b         	ldr	r3, [r7]
 80093b2: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80093b6: 6878         	ldr	r0, [r7, #0x4]
 80093b8: 4798         	blx	r3
 80093ba: 4603         	mov	r3, r0
 80093bc: 2b00         	cmp	r3, #0x0
 80093be: bf14         	ite	ne
 80093c0: 2301         	movne	r3, #0x1
 80093c2: 2300         	moveq	r3, #0x0
 80093c4: b2db         	uxtb	r3, r3
; }
 80093c6: 4618         	mov	r0, r3
 80093c8: 3708         	adds	r7, #0x8
 80093ca: 46bd         	mov	sp, r7
 80093cc: bd80         	pop	{r7, pc}
 80093ce: bf00         	nop

080093d0 <$d>:
 80093d0: 58 28 02 08  	.word	0x08022858

080093d4 <dma_stm32_is_fe_active>:
; {
 80093d4: b580         	push	{r7, lr}
 80093d6: b082         	sub	sp, #0x8
 80093d8: af00         	add	r7, sp, #0x0
 80093da: 6078         	str	r0, [r7, #0x4]
 80093dc: 6039         	str	r1, [r7]
; 	return func[id](DMAx);
 80093de: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8009400 <dma_stm32_is_fe_active+0x2c>
 80093e0: 683b         	ldr	r3, [r7]
 80093e2: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80093e6: 6878         	ldr	r0, [r7, #0x4]
 80093e8: 4798         	blx	r3
 80093ea: 4603         	mov	r3, r0
 80093ec: 2b00         	cmp	r3, #0x0
 80093ee: bf14         	ite	ne
 80093f0: 2301         	movne	r3, #0x1
 80093f2: 2300         	moveq	r3, #0x0
 80093f4: b2db         	uxtb	r3, r3
; }
 80093f6: 4618         	mov	r0, r3
 80093f8: 3708         	adds	r7, #0x8
 80093fa: 46bd         	mov	sp, r7
 80093fc: bd80         	pop	{r7, pc}
 80093fe: bf00         	nop

08009400 <$d>:
 8009400: 78 28 02 08  	.word	0x08022878

08009404 <stm32_dma_dump_stream_irq>:
; {
 8009404: b5f0         	push	{r4, r5, r6, r7, lr}
 8009406: b08f         	sub	sp, #0x3c
 8009408: af08         	add	r7, sp, #0x20
 800940a: 60f8         	str	r0, [r7, #0xc]
 800940c: 60b9         	str	r1, [r7, #0x8]
; 	LOG_INF("tc: %d, ht: %d, te: %d, dme: %d, fe: %d",
 800940e: 2303         	movs	r3, #0x3
 8009410: 2b02         	cmp	r3, #0x2
 8009412: d93c         	bls	0x800948e <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x78
 8009414: 2301         	movs	r3, #0x1
 8009416: 74fb         	strb	r3, [r7, #0x13]
 8009418: 7cfb         	ldrb	r3, [r7, #0x13]
 800941a: f083 0301    	eor	r3, r3, #0x1
 800941e: b2db         	uxtb	r3, r3
 8009420: 2b00         	cmp	r3, #0x0
 8009422: d134         	bne	0x800948e <stm32_dma_dump_stream_irq+0x8a> @ imm = #0x68
 8009424: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8009498 <stm32_dma_dump_stream_irq+0x94>
 8009426: 681c         	ldr	r4, [r3]
 8009428: 68b9         	ldr	r1, [r7, #0x8]
 800942a: 68f8         	ldr	r0, [r7, #0xc]
 800942c: f7ff ff54    	bl	0x80092d8 <dma_stm32_is_tc_active> @ imm = #-0x158
 8009430: 4603         	mov	r3, r0
 8009432: 461d         	mov	r5, r3
 8009434: 68b9         	ldr	r1, [r7, #0x8]
 8009436: 68f8         	ldr	r0, [r7, #0xc]
 8009438: f7ff ff36    	bl	0x80092a8 <dma_stm32_is_ht_active> @ imm = #-0x194
 800943c: 4603         	mov	r3, r0
 800943e: 461e         	mov	r6, r3
 8009440: 68b9         	ldr	r1, [r7, #0x8]
 8009442: 68f8         	ldr	r0, [r7, #0xc]
 8009444: f7ff ff96    	bl	0x8009374 <dma_stm32_is_te_active> @ imm = #-0xd4
 8009448: 4603         	mov	r3, r0
 800944a: 607b         	str	r3, [r7, #0x4]
 800944c: 68b9         	ldr	r1, [r7, #0x8]
 800944e: 68f8         	ldr	r0, [r7, #0xc]
 8009450: f7ff ffa8    	bl	0x80093a4 <dma_stm32_is_dme_active> @ imm = #-0xb0
 8009454: 4603         	mov	r3, r0
 8009456: 603b         	str	r3, [r7]
 8009458: 68b9         	ldr	r1, [r7, #0x8]
 800945a: 68f8         	ldr	r0, [r7, #0xc]
 800945c: f7ff ffba    	bl	0x80093d4 <dma_stm32_is_fe_active> @ imm = #-0x8c
 8009460: 4603         	mov	r3, r0
 8009462: 9307         	str	r3, [sp, #0x1c]
 8009464: 683a         	ldr	r2, [r7]
 8009466: 9206         	str	r2, [sp, #0x18]
 8009468: 687b         	ldr	r3, [r7, #0x4]
 800946a: 9305         	str	r3, [sp, #0x14]
 800946c: 9604         	str	r6, [sp, #0x10]
 800946e: 9503         	str	r5, [sp, #0xc]
 8009470: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800949c <stm32_dma_dump_stream_irq+0x98>
 8009472: 9302         	str	r3, [sp, #0x8]
 8009474: 2300         	movs	r3, #0x0
 8009476: 9301         	str	r3, [sp, #0x4]
 8009478: 2300         	movs	r3, #0x0
 800947a: 9300         	str	r3, [sp]
 800947c: 2300         	movs	r3, #0x0
 800947e: 2203         	movs	r2, #0x3
 8009480: 4621         	mov	r1, r4
 8009482: 2000         	movs	r0, #0x0
 8009484: f00f fdde    	bl	0x8019044 <z_log_msg_runtime_create> @ imm = #0xfbbc
 8009488: 2300         	movs	r3, #0x0
 800948a: 617b         	str	r3, [r7, #0x14]
; }
 800948c: bf00         	nop
 800948e: bf00         	nop
 8009490: 371c         	adds	r7, #0x1c
 8009492: 46bd         	mov	sp, r7
 8009494: bdf0         	pop	{r4, r5, r6, r7, pc}
 8009496: bf00         	nop

08009498 <$d>:
 8009498: 50 05 00 20  	.word	0x20000550
 800949c: ec 12 02 08  	.word	0x080212ec

080094a0 <stm32_dma_is_unexpected_irq_happened>:
; {
 80094a0: b580         	push	{r7, lr}
 80094a2: b088         	sub	sp, #0x20
 80094a4: af04         	add	r7, sp, #0x10
 80094a6: 6078         	str	r0, [r7, #0x4]
 80094a8: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 80094aa: 6838         	ldr	r0, [r7]
 80094ac: f7ff feb8    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0x290
 80094b0: 4603         	mov	r3, r0
 80094b2: 4619         	mov	r1, r3
 80094b4: 6878         	ldr	r0, [r7, #0x4]
 80094b6: f7ff fe97    	bl	0x80091e8 <LL_DMA_IsEnabledIT_FE> @ imm = #-0x2d2
 80094ba: 4603         	mov	r3, r0
 80094bc: 2b00         	cmp	r3, #0x0
 80094be: d02a         	beq	0x8009516 <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x54
; 	    dma_stm32_is_fe_active(dma, id)) {
 80094c0: 6839         	ldr	r1, [r7]
 80094c2: 6878         	ldr	r0, [r7, #0x4]
 80094c4: f7ff ff86    	bl	0x80093d4 <dma_stm32_is_fe_active> @ imm = #-0xf4
 80094c8: 4603         	mov	r3, r0
; 	if (LL_DMA_IsEnabledIT_FE(dma, dma_stm32_id_to_stream(id)) &&
 80094ca: 2b00         	cmp	r3, #0x0
 80094cc: d023         	beq	0x8009516 <stm32_dma_is_unexpected_irq_happened+0x76> @ imm = #0x46
; 		LOG_ERR("FiFo error.");
 80094ce: 2303         	movs	r3, #0x3
 80094d0: 2b00         	cmp	r3, #0x0
 80094d2: d016         	beq	0x8009502 <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x2c
 80094d4: 2301         	movs	r3, #0x1
 80094d6: 73fb         	strb	r3, [r7, #0xf]
 80094d8: 7bfb         	ldrb	r3, [r7, #0xf]
 80094da: f083 0301    	eor	r3, r3, #0x1
 80094de: b2db         	uxtb	r3, r3
 80094e0: 2b00         	cmp	r3, #0x0
 80094e2: d10e         	bne	0x8009502 <stm32_dma_is_unexpected_irq_happened+0x62> @ imm = #0x1c
 80094e4: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8009520 <stm32_dma_is_unexpected_irq_happened+0x80>
 80094e6: 6819         	ldr	r1, [r3]
 80094e8: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8009524 <stm32_dma_is_unexpected_irq_happened+0x84>
 80094ea: 9302         	str	r3, [sp, #0x8]
 80094ec: 2300         	movs	r3, #0x0
 80094ee: 9301         	str	r3, [sp, #0x4]
 80094f0: 2300         	movs	r3, #0x0
 80094f2: 9300         	str	r3, [sp]
 80094f4: 2300         	movs	r3, #0x0
 80094f6: 2201         	movs	r2, #0x1
 80094f8: 2000         	movs	r0, #0x0
 80094fa: f00f fda3    	bl	0x8019044 <z_log_msg_runtime_create> @ imm = #0xfb46
 80094fe: 2300         	movs	r3, #0x0
 8009500: 60bb         	str	r3, [r7, #0x8]
; 		stm32_dma_dump_stream_irq(dma, id);
 8009502: 6839         	ldr	r1, [r7]
 8009504: 6878         	ldr	r0, [r7, #0x4]
 8009506: f7ff ff7d    	bl	0x8009404 <stm32_dma_dump_stream_irq> @ imm = #-0x106
; 		stm32_dma_clear_stream_irq(dma, id);
 800950a: 6839         	ldr	r1, [r7]
 800950c: 6878         	ldr	r0, [r7, #0x4]
 800950e: f00f fdf9    	bl	0x8019104 <stm32_dma_clear_stream_irq> @ imm = #0xfbf2
; 		return true;
 8009512: 2301         	movs	r3, #0x1
 8009514: e000         	b	0x8009518 <stm32_dma_is_unexpected_irq_happened+0x78> @ imm = #0x0
; 	return false;
 8009516: 2300         	movs	r3, #0x0
; }
 8009518: 4618         	mov	r0, r3
 800951a: 3710         	adds	r7, #0x10
 800951c: 46bd         	mov	sp, r7
 800951e: bd80         	pop	{r7, pc}

08009520 <$d>:
 8009520: 50 05 00 20  	.word	0x20000550
 8009524: 14 13 02 08  	.word	0x08021314

08009528 <stm32_dma_get_mburst>:
; {
 8009528: b580         	push	{r7, lr}
 800952a: b08a         	sub	sp, #0x28
 800952c: af04         	add	r7, sp, #0x10
 800952e: 6078         	str	r0, [r7, #0x4]
 8009530: 460b         	mov	r3, r1
 8009532: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 8009534: 78fb         	ldrb	r3, [r7, #0x3]
 8009536: 2b00         	cmp	r3, #0x0
 8009538: d003         	beq	0x8009542 <stm32_dma_get_mburst+0x1a> @ imm = #0x6
; 		memory_burst = config->dest_burst_length;
 800953a: 687b         	ldr	r3, [r7, #0x4]
 800953c: 895b         	ldrh	r3, [r3, #0xa]
 800953e: 617b         	str	r3, [r7, #0x14]
 8009540: e002         	b	0x8009548 <stm32_dma_get_mburst+0x20> @ imm = #0x4
; 		memory_burst = config->source_burst_length;
 8009542: 687b         	ldr	r3, [r7, #0x4]
 8009544: 891b         	ldrh	r3, [r3, #0x8]
 8009546: 617b         	str	r3, [r7, #0x14]
; 	switch (memory_burst) {
 8009548: 697b         	ldr	r3, [r7, #0x14]
 800954a: 3b01         	subs	r3, #0x1
 800954c: 2b0f         	cmp	r3, #0xf
 800954e: d82e         	bhi	0x80095ae <stm32_dma_get_mburst+0x86> @ imm = #0x5c
 8009550: a201         	adr	r2, #4 <stm32_dma_get_mburst+0x2d>
 8009552: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8009556: bf00         	nop

08009558 <$d>:
 8009558: 99 95 00 08  	.word	0x08009599
 800955c: af 95 00 08  	.word	0x080095af
 8009560: af 95 00 08  	.word	0x080095af
 8009564: 9d 95 00 08  	.word	0x0800959d
 8009568: af 95 00 08  	.word	0x080095af
 800956c: af 95 00 08  	.word	0x080095af
 8009570: af 95 00 08  	.word	0x080095af
 8009574: a3 95 00 08  	.word	0x080095a3
 8009578: af 95 00 08  	.word	0x080095af
 800957c: af 95 00 08  	.word	0x080095af
 8009580: af 95 00 08  	.word	0x080095af
 8009584: af 95 00 08  	.word	0x080095af
 8009588: af 95 00 08  	.word	0x080095af
 800958c: af 95 00 08  	.word	0x080095af
 8009590: af 95 00 08  	.word	0x080095af
 8009594: a9 95 00 08  	.word	0x080095a9

08009598 <$t>:
; 		return LL_DMA_MBURST_SINGLE;
 8009598: 2300         	movs	r3, #0x0
 800959a: e023         	b	0x80095e4 <stm32_dma_get_mburst+0xbc> @ imm = #0x46
; 		return LL_DMA_MBURST_INC4;
 800959c: f44f 0300    	mov.w	r3, #0x800000
 80095a0: e020         	b	0x80095e4 <stm32_dma_get_mburst+0xbc> @ imm = #0x40
; 		return LL_DMA_MBURST_INC8;
 80095a2: f04f 7380    	mov.w	r3, #0x1000000
 80095a6: e01d         	b	0x80095e4 <stm32_dma_get_mburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_MBURST_INC16;
 80095a8: f04f 73c0    	mov.w	r3, #0x1800000
 80095ac: e01a         	b	0x80095e4 <stm32_dma_get_mburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Memory burst size error,"
 80095ae: 2303         	movs	r3, #0x3
 80095b0: 2b00         	cmp	r3, #0x0
 80095b2: d016         	beq	0x80095e2 <stm32_dma_get_mburst+0xba> @ imm = #0x2c
 80095b4: 2301         	movs	r3, #0x1
 80095b6: 74fb         	strb	r3, [r7, #0x13]
 80095b8: 7cfb         	ldrb	r3, [r7, #0x13]
 80095ba: f083 0301    	eor	r3, r3, #0x1
 80095be: b2db         	uxtb	r3, r3
 80095c0: 2b00         	cmp	r3, #0x0
 80095c2: d10e         	bne	0x80095e2 <stm32_dma_get_mburst+0xba> @ imm = #0x1c
 80095c4: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80095ec <stm32_dma_get_mburst+0xc4>
 80095c6: 6819         	ldr	r1, [r3]
 80095c8: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80095f0 <stm32_dma_get_mburst+0xc8>
 80095ca: 9302         	str	r3, [sp, #0x8]
 80095cc: 2300         	movs	r3, #0x0
 80095ce: 9301         	str	r3, [sp, #0x4]
 80095d0: 2300         	movs	r3, #0x0
 80095d2: 9300         	str	r3, [sp]
 80095d4: 2300         	movs	r3, #0x0
 80095d6: 2201         	movs	r2, #0x1
 80095d8: 2000         	movs	r0, #0x0
 80095da: f00f fd33    	bl	0x8019044 <z_log_msg_runtime_create> @ imm = #0xfa66
 80095de: 2300         	movs	r3, #0x0
 80095e0: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_MBURST_SINGLE;
 80095e2: 2300         	movs	r3, #0x0
; }
 80095e4: 4618         	mov	r0, r3
 80095e6: 3718         	adds	r7, #0x18
 80095e8: 46bd         	mov	sp, r7
 80095ea: bd80         	pop	{r7, pc}

080095ec <$d>:
 80095ec: 50 05 00 20  	.word	0x20000550
 80095f0: 20 13 02 08  	.word	0x08021320

080095f4 <stm32_dma_get_pburst>:
; {
 80095f4: b580         	push	{r7, lr}
 80095f6: b08a         	sub	sp, #0x28
 80095f8: af04         	add	r7, sp, #0x10
 80095fa: 6078         	str	r0, [r7, #0x4]
 80095fc: 460b         	mov	r3, r1
 80095fe: 70fb         	strb	r3, [r7, #0x3]
; 	if (source_periph) {
 8009600: 78fb         	ldrb	r3, [r7, #0x3]
 8009602: 2b00         	cmp	r3, #0x0
 8009604: d003         	beq	0x800960e <stm32_dma_get_pburst+0x1a> @ imm = #0x6
; 		periph_burst = config->source_burst_length;
 8009606: 687b         	ldr	r3, [r7, #0x4]
 8009608: 891b         	ldrh	r3, [r3, #0x8]
 800960a: 617b         	str	r3, [r7, #0x14]
 800960c: e002         	b	0x8009614 <stm32_dma_get_pburst+0x20> @ imm = #0x4
; 		periph_burst = config->dest_burst_length;
 800960e: 687b         	ldr	r3, [r7, #0x4]
 8009610: 895b         	ldrh	r3, [r3, #0xa]
 8009612: 617b         	str	r3, [r7, #0x14]
; 	switch (periph_burst) {
 8009614: 697b         	ldr	r3, [r7, #0x14]
 8009616: 3b01         	subs	r3, #0x1
 8009618: 2b0f         	cmp	r3, #0xf
 800961a: d82e         	bhi	0x800967a <stm32_dma_get_pburst+0x86> @ imm = #0x5c
 800961c: a201         	adr	r2, #4 <stm32_dma_get_pburst+0x2d>
 800961e: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 8009622: bf00         	nop

08009624 <$d>:
 8009624: 65 96 00 08  	.word	0x08009665
 8009628: 7b 96 00 08  	.word	0x0800967b
 800962c: 7b 96 00 08  	.word	0x0800967b
 8009630: 69 96 00 08  	.word	0x08009669
 8009634: 7b 96 00 08  	.word	0x0800967b
 8009638: 7b 96 00 08  	.word	0x0800967b
 800963c: 7b 96 00 08  	.word	0x0800967b
 8009640: 6f 96 00 08  	.word	0x0800966f
 8009644: 7b 96 00 08  	.word	0x0800967b
 8009648: 7b 96 00 08  	.word	0x0800967b
 800964c: 7b 96 00 08  	.word	0x0800967b
 8009650: 7b 96 00 08  	.word	0x0800967b
 8009654: 7b 96 00 08  	.word	0x0800967b
 8009658: 7b 96 00 08  	.word	0x0800967b
 800965c: 7b 96 00 08  	.word	0x0800967b
 8009660: 75 96 00 08  	.word	0x08009675

08009664 <$t>:
; 		return LL_DMA_PBURST_SINGLE;
 8009664: 2300         	movs	r3, #0x0
 8009666: e023         	b	0x80096b0 <stm32_dma_get_pburst+0xbc> @ imm = #0x46
; 		return LL_DMA_PBURST_INC4;
 8009668: f44f 1300    	mov.w	r3, #0x200000
 800966c: e020         	b	0x80096b0 <stm32_dma_get_pburst+0xbc> @ imm = #0x40
; 		return LL_DMA_PBURST_INC8;
 800966e: f44f 0380    	mov.w	r3, #0x400000
 8009672: e01d         	b	0x80096b0 <stm32_dma_get_pburst+0xbc> @ imm = #0x3a
; 		return LL_DMA_PBURST_INC16;
 8009674: f44f 03c0    	mov.w	r3, #0x600000
 8009678: e01a         	b	0x80096b0 <stm32_dma_get_pburst+0xbc> @ imm = #0x34
; 		LOG_ERR("Peripheral burst size error,"
 800967a: 2303         	movs	r3, #0x3
 800967c: 2b00         	cmp	r3, #0x0
 800967e: d016         	beq	0x80096ae <stm32_dma_get_pburst+0xba> @ imm = #0x2c
 8009680: 2301         	movs	r3, #0x1
 8009682: 74fb         	strb	r3, [r7, #0x13]
 8009684: 7cfb         	ldrb	r3, [r7, #0x13]
 8009686: f083 0301    	eor	r3, r3, #0x1
 800968a: b2db         	uxtb	r3, r3
 800968c: 2b00         	cmp	r3, #0x0
 800968e: d10e         	bne	0x80096ae <stm32_dma_get_pburst+0xba> @ imm = #0x1c
 8009690: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80096b8 <stm32_dma_get_pburst+0xc4>
 8009692: 6819         	ldr	r1, [r3]
 8009694: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80096bc <stm32_dma_get_pburst+0xc8>
 8009696: 9302         	str	r3, [sp, #0x8]
 8009698: 2300         	movs	r3, #0x0
 800969a: 9301         	str	r3, [sp, #0x4]
 800969c: 2300         	movs	r3, #0x0
 800969e: 9300         	str	r3, [sp]
 80096a0: 2300         	movs	r3, #0x0
 80096a2: 2201         	movs	r2, #0x1
 80096a4: 2000         	movs	r0, #0x0
 80096a6: f00f fccd    	bl	0x8019044 <z_log_msg_runtime_create> @ imm = #0xf99a
 80096aa: 2300         	movs	r3, #0x0
 80096ac: 60fb         	str	r3, [r7, #0xc]
; 		return LL_DMA_PBURST_SINGLE;
 80096ae: 2300         	movs	r3, #0x0
; }
 80096b0: 4618         	mov	r0, r3
 80096b2: 3718         	adds	r7, #0x18
 80096b4: 46bd         	mov	sp, r7
 80096b6: bd80         	pop	{r7, pc}

080096b8 <$d>:
 80096b8: 50 05 00 20  	.word	0x20000550
 80096bc: 58 13 02 08  	.word	0x08021358

080096c0 <stm32_dma_get_fifo_threshold>:
; {
 80096c0: b580         	push	{r7, lr}
 80096c2: b088         	sub	sp, #0x20
 80096c4: af04         	add	r7, sp, #0x10
 80096c6: 4603         	mov	r3, r0
 80096c8: 80fb         	strh	r3, [r7, #0x6]
; 	switch (fifo_mode_control) {
 80096ca: 88fb         	ldrh	r3, [r7, #0x6]
 80096cc: 2b03         	cmp	r3, #0x3
 80096ce: d813         	bhi	0x80096f8 <stm32_dma_get_fifo_threshold+0x38> @ imm = #0x26
 80096d0: a201         	adr	r2, #4 <stm32_dma_get_fifo_threshold+0x15>
 80096d2: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 80096d6: bf00         	nop

080096d8 <$d>:
 80096d8: e9 96 00 08  	.word	0x080096e9
 80096dc: ed 96 00 08  	.word	0x080096ed
 80096e0: f1 96 00 08  	.word	0x080096f1
 80096e4: f5 96 00 08  	.word	0x080096f5

080096e8 <$t>:
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 80096e8: 2300         	movs	r3, #0x0
 80096ea: e020         	b	0x800972e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x40
; 		return LL_DMA_FIFOTHRESHOLD_1_2;
 80096ec: 2301         	movs	r3, #0x1
 80096ee: e01e         	b	0x800972e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x3c
; 		return LL_DMA_FIFOTHRESHOLD_3_4;
 80096f0: 2302         	movs	r3, #0x2
 80096f2: e01c         	b	0x800972e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x38
; 		return LL_DMA_FIFOTHRESHOLD_FULL;
 80096f4: 2303         	movs	r3, #0x3
 80096f6: e01a         	b	0x800972e <stm32_dma_get_fifo_threshold+0x6e> @ imm = #0x34
; 		LOG_WRN("FIFO threshold parameter error, reset to 1/4");
 80096f8: 2303         	movs	r3, #0x3
 80096fa: 2b01         	cmp	r3, #0x1
 80096fc: d916         	bls	0x800972c <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x2c
 80096fe: 2301         	movs	r3, #0x1
 8009700: 73fb         	strb	r3, [r7, #0xf]
 8009702: 7bfb         	ldrb	r3, [r7, #0xf]
 8009704: f083 0301    	eor	r3, r3, #0x1
 8009708: b2db         	uxtb	r3, r3
 800970a: 2b00         	cmp	r3, #0x0
 800970c: d10e         	bne	0x800972c <stm32_dma_get_fifo_threshold+0x6c> @ imm = #0x1c
 800970e: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8009738 <stm32_dma_get_fifo_threshold+0x78>
 8009710: 6819         	ldr	r1, [r3]
 8009712: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800973c <stm32_dma_get_fifo_threshold+0x7c>
 8009714: 9302         	str	r3, [sp, #0x8]
 8009716: 2300         	movs	r3, #0x0
 8009718: 9301         	str	r3, [sp, #0x4]
 800971a: 2300         	movs	r3, #0x0
 800971c: 9300         	str	r3, [sp]
 800971e: 2300         	movs	r3, #0x0
 8009720: 2202         	movs	r2, #0x2
 8009722: 2000         	movs	r0, #0x0
 8009724: f00f fc8e    	bl	0x8019044 <z_log_msg_runtime_create> @ imm = #0xf91c
 8009728: 2300         	movs	r3, #0x0
 800972a: 60bb         	str	r3, [r7, #0x8]
; 		return LL_DMA_FIFOTHRESHOLD_1_4;
 800972c: 2300         	movs	r3, #0x0
; }
 800972e: 4618         	mov	r0, r3
 8009730: 3710         	adds	r7, #0x10
 8009732: 46bd         	mov	sp, r7
 8009734: bd80         	pop	{r7, pc}
 8009736: bf00         	nop

08009738 <$d>:
 8009738: 50 05 00 20  	.word	0x20000550
 800973c: 94 13 02 08  	.word	0x08021394

08009740 <gpio_stm32_clock_request>:
; {
 8009740: b580         	push	{r7, lr}
 8009742: b086         	sub	sp, #0x18
 8009744: af00         	add	r7, sp, #0x0
 8009746: 6078         	str	r0, [r7, #0x4]
 8009748: 460b         	mov	r3, r1
 800974a: 70fb         	strb	r3, [r7, #0x3]
; 	const struct gpio_stm32_config *cfg = dev->config;
 800974c: 687b         	ldr	r3, [r7, #0x4]
 800974e: 685b         	ldr	r3, [r3, #0x4]
 8009750: 613b         	str	r3, [r7, #0x10]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8009752: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8009784 <gpio_stm32_clock_request+0x44>
 8009754: 60fb         	str	r3, [r7, #0xc]
; 	if (on) {
 8009756: 78fb         	ldrb	r3, [r7, #0x3]
 8009758: 2b00         	cmp	r3, #0x0
 800975a: d007         	beq	0x800976c <gpio_stm32_clock_request+0x2c> @ imm = #0xe
; 					(clock_control_subsys_t)&cfg->pclken);
 800975c: 693b         	ldr	r3, [r7, #0x10]
 800975e: 330c         	adds	r3, #0xc
; 		ret = clock_control_on(clk,
 8009760: 4619         	mov	r1, r3
 8009762: 68f8         	ldr	r0, [r7, #0xc]
 8009764: f010 f830    	bl	0x80197c8 <clock_control_on> @ imm = #0x10060
 8009768: 6178         	str	r0, [r7, #0x14]
 800976a: e006         	b	0x800977a <gpio_stm32_clock_request+0x3a> @ imm = #0xc
; 					(clock_control_subsys_t)&cfg->pclken);
 800976c: 693b         	ldr	r3, [r7, #0x10]
 800976e: 330c         	adds	r3, #0xc
; 		ret = clock_control_off(clk,
 8009770: 4619         	mov	r1, r3
 8009772: 68f8         	ldr	r0, [r7, #0xc]
 8009774: f010 f83a    	bl	0x80197ec <clock_control_off> @ imm = #0x10074
 8009778: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 800977a: 697b         	ldr	r3, [r7, #0x14]
; }
 800977c: 4618         	mov	r0, r3
 800977e: 3718         	adds	r7, #0x18
 8009780: 46bd         	mov	sp, r7
 8009782: bd80         	pop	{r7, pc}

08009784 <$d>:
 8009784: 80 01 02 08  	.word	0x08020180

08009788 <gpio_stm32_pin_interrupt_configure>:
; {
 8009788: b580         	push	{r7, lr}
 800978a: b08a         	sub	sp, #0x28
 800978c: af00         	add	r7, sp, #0x0
 800978e: 60f8         	str	r0, [r7, #0xc]
 8009790: 607a         	str	r2, [r7, #0x4]
 8009792: 603b         	str	r3, [r7]
 8009794: 460b         	mov	r3, r1
 8009796: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8009798: 68fb         	ldr	r3, [r7, #0xc]
 800979a: 685b         	ldr	r3, [r3, #0x4]
 800979c: 61fb         	str	r3, [r7, #0x1c]
; 	struct gpio_stm32_data *data = dev->data;
 800979e: 68fb         	ldr	r3, [r7, #0xc]
 80097a0: 691b         	ldr	r3, [r3, #0x10]
 80097a2: 61bb         	str	r3, [r7, #0x18]
; 	const stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(cfg->port, pin);
 80097a4: 69fb         	ldr	r3, [r7, #0x1c]
 80097a6: 689b         	ldr	r3, [r3, #0x8]
 80097a8: 461a         	mov	r2, r3
 80097aa: 7afb         	ldrb	r3, [r7, #0xb]
 80097ac: 4619         	mov	r1, r3
 80097ae: 4610         	mov	r0, r2
 80097b0: f00e f9de    	bl	0x8017b70 <stm32_gpio_intc_get_pin_irq_line> @ imm = #0xe3bc
 80097b4: 6178         	str	r0, [r7, #0x14]
; 	uint32_t irq_trigger = 0;
 80097b6: 2300         	movs	r3, #0x0
 80097b8: 627b         	str	r3, [r7, #0x24]
; 	int err = 0;
 80097ba: 2300         	movs	r3, #0x0
 80097bc: 623b         	str	r3, [r7, #0x20]
; 	if (mode == GPIO_INT_MODE_DISABLED) {
 80097be: 687b         	ldr	r3, [r7, #0x4]
 80097c0: f5b3 1f00    	cmp.w	r3, #0x200000
 80097c4: d108         	bne	0x80097d8 <gpio_stm32_pin_interrupt_configure+0x50> @ imm = #0x10
; 		gpio_stm32_disable_pin_irqs(cfg->port, pin);
 80097c6: 69fb         	ldr	r3, [r7, #0x1c]
 80097c8: 689b         	ldr	r3, [r3, #0x8]
 80097ca: 461a         	mov	r2, r3
 80097cc: 7afb         	ldrb	r3, [r7, #0xb]
 80097ce: 4619         	mov	r1, r3
 80097d0: 4610         	mov	r0, r2
 80097d2: f010 f982    	bl	0x8019ada <gpio_stm32_disable_pin_irqs> @ imm = #0x10304
; 		goto exit;
 80097d6: e040         	b	0x800985a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x80
; 	if (mode == GPIO_INT_MODE_LEVEL) {
 80097d8: 687b         	ldr	r3, [r7, #0x4]
 80097da: f5b3 0f80    	cmp.w	r3, #0x400000
 80097de: d103         	bne	0x80097e8 <gpio_stm32_pin_interrupt_configure+0x60> @ imm = #0x6
; 			err = -ENOTSUP;
 80097e0: f06f 0385    	mvn	r3, #0x85
 80097e4: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 80097e6: e038         	b	0x800985a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x70
; 		switch (trig) {
 80097e8: 683b         	ldr	r3, [r7]
 80097ea: f1b3 6fc0    	cmp.w	r3, #0x6000000
 80097ee: d012         	beq	0x8009816 <gpio_stm32_pin_interrupt_configure+0x8e> @ imm = #0x24
 80097f0: 683b         	ldr	r3, [r7]
 80097f2: f1b3 6fc0    	cmp.w	r3, #0x6000000
 80097f6: d811         	bhi	0x800981c <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x22
 80097f8: 683b         	ldr	r3, [r7]
 80097fa: f1b3 7f00    	cmp.w	r3, #0x2000000
 80097fe: d004         	beq	0x800980a <gpio_stm32_pin_interrupt_configure+0x82> @ imm = #0x8
 8009800: 683b         	ldr	r3, [r7]
 8009802: f1b3 6f80    	cmp.w	r3, #0x4000000
 8009806: d003         	beq	0x8009810 <gpio_stm32_pin_interrupt_configure+0x88> @ imm = #0x6
 8009808: e008         	b	0x800981c <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x10
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_FALLING;
 800980a: 2302         	movs	r3, #0x2
 800980c: 627b         	str	r3, [r7, #0x24]
; 			break;
 800980e: e009         	b	0x8009824 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x12
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_RISING;
 8009810: 2301         	movs	r3, #0x1
 8009812: 627b         	str	r3, [r7, #0x24]
; 			break;
 8009814: e006         	b	0x8009824 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0xc
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_BOTH;
 8009816: 2303         	movs	r3, #0x3
 8009818: 627b         	str	r3, [r7, #0x24]
; 			break;
 800981a: e003         	b	0x8009824 <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x6
; 			err = -EINVAL;
 800981c: f06f 0315    	mvn	r3, #0x15
 8009820: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 8009822: e01a         	b	0x800985a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x34
; 	if (stm32_gpio_intc_set_irq_callback(irq_line, gpio_stm32_isr, data) != 0) {
 8009824: 69ba         	ldr	r2, [r7, #0x18]
 8009826: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8009864 <gpio_stm32_pin_interrupt_configure+0xdc>
 8009828: 6978         	ldr	r0, [r7, #0x14]
 800982a: f7fe f843    	bl	0x80078b4 <stm32_gpio_intc_set_irq_callback> @ imm = #-0x1f7a
 800982e: 4603         	mov	r3, r0
 8009830: 2b00         	cmp	r3, #0x0
 8009832: d003         	beq	0x800983c <gpio_stm32_pin_interrupt_configure+0xb4> @ imm = #0x6
; 		err = -EBUSY;
 8009834: f06f 030f    	mvn	r3, #0xf
 8009838: 623b         	str	r3, [r7, #0x20]
; 		goto exit;
 800983a: e00e         	b	0x800985a <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x1c
; 	stm32_exti_set_line_src_port(pin, cfg->port);
 800983c: 69fb         	ldr	r3, [r7, #0x1c]
 800983e: 689b         	ldr	r3, [r3, #0x8]
 8009840: 461a         	mov	r2, r3
 8009842: 7afb         	ldrb	r3, [r7, #0xb]
 8009844: 4611         	mov	r1, r2
 8009846: 4618         	mov	r0, r3
 8009848: f00e f9ac    	bl	0x8017ba4 <stm32_exti_set_line_src_port> @ imm = #0xe358
; 	stm32_gpio_intc_select_line_trigger(irq_line, irq_trigger);
 800984c: 6a79         	ldr	r1, [r7, #0x24]
 800984e: 6978         	ldr	r0, [r7, #0x14]
 8009850: f7fd fff4    	bl	0x800783c <stm32_gpio_intc_select_line_trigger> @ imm = #-0x2018
; 	stm32_gpio_intc_enable_line(irq_line);
 8009854: 6978         	ldr	r0, [r7, #0x14]
 8009856: f7fd ffd5    	bl	0x8007804 <stm32_gpio_intc_enable_line> @ imm = #-0x2056
; 	return err;
 800985a: 6a3b         	ldr	r3, [r7, #0x20]
; }
 800985c: 4618         	mov	r0, r3
 800985e: 3728         	adds	r7, #0x28
 8009860: 46bd         	mov	sp, r7
 8009862: bd80         	pop	{r7, pc}

08009864 <$d>:
 8009864: 9b 99 01 08  	.word	0x0801999b

08009868 <gpio_stm32_init>:
; {
 8009868: b580         	push	{r7, lr}
 800986a: b084         	sub	sp, #0x10
 800986c: af00         	add	r7, sp, #0x0
 800986e: 6078         	str	r0, [r7, #0x4]
; 	struct gpio_stm32_data *data = dev->data;
 8009870: 687b         	ldr	r3, [r7, #0x4]
 8009872: 691b         	ldr	r3, [r3, #0x10]
 8009874: 60fb         	str	r3, [r7, #0xc]
; 	data->dev = dev;
 8009876: 68fb         	ldr	r3, [r7, #0xc]
 8009878: 687a         	ldr	r2, [r7, #0x4]
 800987a: 605a         	str	r2, [r3, #0x4]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 800987c: 480e         	ldr	r0, [pc, #0x38]         @ 0x80098b8 <gpio_stm32_init+0x50>
 800987e: f00f fe17    	bl	0x80194b0 <device_is_ready> @ imm = #0xfc2e
 8009882: 4603         	mov	r3, r0
 8009884: f083 0301    	eor	r3, r3, #0x1
 8009888: b2db         	uxtb	r3, r3
 800988a: 2b00         	cmp	r3, #0x0
 800988c: d002         	beq	0x8009894 <gpio_stm32_init+0x2c> @ imm = #0x4
; 		return -ENODEV;
 800988e: f06f 0312    	mvn	r3, #0x12
 8009892: e00d         	b	0x80098b0 <gpio_stm32_init+0x48> @ imm = #0x1a
; 	ret = gpio_stm32_clock_request(dev, !IS_ENABLED(CONFIG_PM_DEVICE_RUNTIME));
 8009894: 2101         	movs	r1, #0x1
 8009896: 6878         	ldr	r0, [r7, #0x4]
 8009898: f7ff ff52    	bl	0x8009740 <gpio_stm32_clock_request> @ imm = #-0x15c
 800989c: 60b8         	str	r0, [r7, #0x8]
; 	if (ret < 0) {
 800989e: 68bb         	ldr	r3, [r7, #0x8]
 80098a0: 2b00         	cmp	r3, #0x0
 80098a2: da01         	bge	0x80098a8 <gpio_stm32_init+0x40> @ imm = #0x2
; 		return ret;
 80098a4: 68bb         	ldr	r3, [r7, #0x8]
 80098a6: e003         	b	0x80098b0 <gpio_stm32_init+0x48> @ imm = #0x6
; 	(void)pm_device_runtime_enable(dev);
 80098a8: 6878         	ldr	r0, [r7, #0x4]
 80098aa: f00f ffb1    	bl	0x8019810 <pm_device_runtime_enable> @ imm = #0xff62
; 	return 0;
 80098ae: 2300         	movs	r3, #0x0
; }
 80098b0: 4618         	mov	r0, r3
 80098b2: 3710         	adds	r7, #0x10
 80098b4: 46bd         	mov	sp, r7
 80098b6: bd80         	pop	{r7, pc}

080098b8 <$d>:
 80098b8: 80 01 02 08  	.word	0x08020180

080098bc <stm32_pin_configure>:
; {
 80098bc: b580         	push	{r7, lr}
 80098be: b086         	sub	sp, #0x18
 80098c0: af00         	add	r7, sp, #0x0
 80098c2: 60f8         	str	r0, [r7, #0xc]
 80098c4: 60b9         	str	r1, [r7, #0x8]
 80098c6: 607a         	str	r2, [r7, #0x4]
; 	if (STM32_PORT(pin) >= gpio_ports_cnt) {
 80098c8: 68fb         	ldr	r3, [r7, #0xc]
 80098ca: 091b         	lsrs	r3, r3, #0x4
 80098cc: 2210         	movs	r2, #0x10
 80098ce: 4293         	cmp	r3, r2
 80098d0: d302         	blo	0x80098d8 <stm32_pin_configure+0x1c> @ imm = #0x4
; 		return -EINVAL;
 80098d2: f06f 0315    	mvn	r3, #0x15
 80098d6: e01f         	b	0x8009918 <stm32_pin_configure+0x5c> @ imm = #0x3e
; 	port_device = gpio_ports[STM32_PORT(pin)];
 80098d8: 68fb         	ldr	r3, [r7, #0xc]
 80098da: 091b         	lsrs	r3, r3, #0x4
 80098dc: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8009920 <stm32_pin_configure+0x64>
 80098de: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80098e2: 617b         	str	r3, [r7, #0x14]
; 	if ((port_device == NULL) || (!device_is_ready(port_device))) {
 80098e4: 697b         	ldr	r3, [r7, #0x14]
 80098e6: 2b00         	cmp	r3, #0x0
 80098e8: d008         	beq	0x80098fc <stm32_pin_configure+0x40> @ imm = #0x10
 80098ea: 6978         	ldr	r0, [r7, #0x14]
 80098ec: f010 fb06    	bl	0x8019efc <device_is_ready> @ imm = #0x1060c
 80098f0: 4603         	mov	r3, r0
 80098f2: f083 0301    	eor	r3, r3, #0x1
 80098f6: b2db         	uxtb	r3, r3
 80098f8: 2b00         	cmp	r3, #0x0
 80098fa: d002         	beq	0x8009902 <stm32_pin_configure+0x46> @ imm = #0x4
; 		return -ENODEV;
 80098fc: f06f 0312    	mvn	r3, #0x12
 8009900: e00a         	b	0x8009918 <stm32_pin_configure+0x5c> @ imm = #0x14
; 	return gpio_stm32_configure(port_device, STM32_PIN(pin), pin_cgf, pin_func);
 8009902: 68fb         	ldr	r3, [r7, #0xc]
 8009904: b2db         	uxtb	r3, r3
 8009906: f003 030f    	and	r3, r3, #0xf
 800990a: b2d9         	uxtb	r1, r3
 800990c: 687b         	ldr	r3, [r7, #0x4]
 800990e: 68ba         	ldr	r2, [r7, #0x8]
 8009910: 6978         	ldr	r0, [r7, #0x14]
 8009912: f010 f9e7    	bl	0x8019ce4 <gpio_stm32_configure> @ imm = #0x103ce
 8009916: 4603         	mov	r3, r0
; }
 8009918: 4618         	mov	r0, r3
 800991a: 3718         	adds	r7, #0x18
 800991c: 46bd         	mov	sp, r7
 800991e: bd80         	pop	{r7, pc}

08009920 <$d>:
 8009920: 4c 29 02 08  	.word	0x0802294c

08009924 <LL_TIM_OC_SetPolarity>:
; {
 8009924: b480         	push	{r7}
 8009926: b087         	sub	sp, #0x1c
 8009928: af00         	add	r7, sp, #0x0
 800992a: 60f8         	str	r0, [r7, #0xc]
 800992c: 60b9         	str	r1, [r7, #0x8]
 800992e: 607a         	str	r2, [r7, #0x4]
;   uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
 8009930: 68bb         	ldr	r3, [r7, #0x8]
 8009932: 2b01         	cmp	r3, #0x1
 8009934: d01c         	beq	0x8009970 <LL_TIM_OC_SetPolarity+0x4c> @ imm = #0x38
 8009936: 68bb         	ldr	r3, [r7, #0x8]
 8009938: 2b04         	cmp	r3, #0x4
 800993a: d017         	beq	0x800996c <LL_TIM_OC_SetPolarity+0x48> @ imm = #0x2e
 800993c: 68bb         	ldr	r3, [r7, #0x8]
 800993e: 2b10         	cmp	r3, #0x10
 8009940: d012         	beq	0x8009968 <LL_TIM_OC_SetPolarity+0x44> @ imm = #0x24
 8009942: 68bb         	ldr	r3, [r7, #0x8]
 8009944: 2b40         	cmp	r3, #0x40
 8009946: d00d         	beq	0x8009964 <LL_TIM_OC_SetPolarity+0x40> @ imm = #0x1a
 8009948: 68bb         	ldr	r3, [r7, #0x8]
 800994a: f5b3 7f80    	cmp.w	r3, #0x100
 800994e: d007         	beq	0x8009960 <LL_TIM_OC_SetPolarity+0x3c> @ imm = #0xe
 8009950: 68bb         	ldr	r3, [r7, #0x8]
 8009952: f5b3 6f80    	cmp.w	r3, #0x400
 8009956: d101         	bne	0x800995c <LL_TIM_OC_SetPolarity+0x38> @ imm = #0x2
 8009958: 2305         	movs	r3, #0x5
 800995a: e00a         	b	0x8009972 <LL_TIM_OC_SetPolarity+0x4e> @ imm = #0x14
 800995c: 2306         	movs	r3, #0x6
 800995e: e008         	b	0x8009972 <LL_TIM_OC_SetPolarity+0x4e> @ imm = #0x10
 8009960: 2304         	movs	r3, #0x4
 8009962: e006         	b	0x8009972 <LL_TIM_OC_SetPolarity+0x4e> @ imm = #0xc
 8009964: 2303         	movs	r3, #0x3
 8009966: e004         	b	0x8009972 <LL_TIM_OC_SetPolarity+0x4e> @ imm = #0x8
 8009968: 2302         	movs	r3, #0x2
 800996a: e002         	b	0x8009972 <LL_TIM_OC_SetPolarity+0x4e> @ imm = #0x4
 800996c: 2301         	movs	r3, #0x1
 800996e: e000         	b	0x8009972 <LL_TIM_OC_SetPolarity+0x4e> @ imm = #0x0
 8009970: 2300         	movs	r3, #0x0
 8009972: 75fb         	strb	r3, [r7, #0x17]
;   MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
 8009974: 68fb         	ldr	r3, [r7, #0xc]
 8009976: 6a1a         	ldr	r2, [r3, #0x20]
 8009978: 7dfb         	ldrb	r3, [r7, #0x17]
 800997a: 490b         	ldr	r1, [pc, #0x2c]         @ 0x80099a8 <LL_TIM_OC_SetPolarity+0x84>
 800997c: 5ccb         	ldrb	r3, [r1, r3]
 800997e: 4619         	mov	r1, r3
 8009980: 2302         	movs	r3, #0x2
 8009982: 408b         	lsls	r3, r1
 8009984: 43db         	mvns	r3, r3
 8009986: 401a         	ands	r2, r3
 8009988: 7dfb         	ldrb	r3, [r7, #0x17]
 800998a: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80099a8 <LL_TIM_OC_SetPolarity+0x84>
 800998c: 5ccb         	ldrb	r3, [r1, r3]
 800998e: 4619         	mov	r1, r3
 8009990: 687b         	ldr	r3, [r7, #0x4]
 8009992: 408b         	lsls	r3, r1
 8009994: 431a         	orrs	r2, r3
 8009996: 68fb         	ldr	r3, [r7, #0xc]
 8009998: 621a         	str	r2, [r3, #0x20]
; }
 800999a: bf00         	nop
 800999c: 371c         	adds	r7, #0x1c
 800999e: 46bd         	mov	sp, r7
 80099a0: f85d 7b04    	ldr	r7, [sp], #4
 80099a4: 4770         	bx	lr
 80099a6: bf00         	nop

080099a8 <$d>:
 80099a8: 9c 29 02 08  	.word	0x0802299c

080099ac <LL_TIM_OC_GetPolarity>:
; {
 80099ac: b480         	push	{r7}
 80099ae: b085         	sub	sp, #0x14
 80099b0: af00         	add	r7, sp, #0x0
 80099b2: 6078         	str	r0, [r7, #0x4]
 80099b4: 6039         	str	r1, [r7]
;   uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
 80099b6: 683b         	ldr	r3, [r7]
 80099b8: 2b01         	cmp	r3, #0x1
 80099ba: d01c         	beq	0x80099f6 <LL_TIM_OC_GetPolarity+0x4a> @ imm = #0x38
 80099bc: 683b         	ldr	r3, [r7]
 80099be: 2b04         	cmp	r3, #0x4
 80099c0: d017         	beq	0x80099f2 <LL_TIM_OC_GetPolarity+0x46> @ imm = #0x2e
 80099c2: 683b         	ldr	r3, [r7]
 80099c4: 2b10         	cmp	r3, #0x10
 80099c6: d012         	beq	0x80099ee <LL_TIM_OC_GetPolarity+0x42> @ imm = #0x24
 80099c8: 683b         	ldr	r3, [r7]
 80099ca: 2b40         	cmp	r3, #0x40
 80099cc: d00d         	beq	0x80099ea <LL_TIM_OC_GetPolarity+0x3e> @ imm = #0x1a
 80099ce: 683b         	ldr	r3, [r7]
 80099d0: f5b3 7f80    	cmp.w	r3, #0x100
 80099d4: d007         	beq	0x80099e6 <LL_TIM_OC_GetPolarity+0x3a> @ imm = #0xe
 80099d6: 683b         	ldr	r3, [r7]
 80099d8: f5b3 6f80    	cmp.w	r3, #0x400
 80099dc: d101         	bne	0x80099e2 <LL_TIM_OC_GetPolarity+0x36> @ imm = #0x2
 80099de: 2305         	movs	r3, #0x5
 80099e0: e00a         	b	0x80099f8 <LL_TIM_OC_GetPolarity+0x4c> @ imm = #0x14
 80099e2: 2306         	movs	r3, #0x6
 80099e4: e008         	b	0x80099f8 <LL_TIM_OC_GetPolarity+0x4c> @ imm = #0x10
 80099e6: 2304         	movs	r3, #0x4
 80099e8: e006         	b	0x80099f8 <LL_TIM_OC_GetPolarity+0x4c> @ imm = #0xc
 80099ea: 2303         	movs	r3, #0x3
 80099ec: e004         	b	0x80099f8 <LL_TIM_OC_GetPolarity+0x4c> @ imm = #0x8
 80099ee: 2302         	movs	r3, #0x2
 80099f0: e002         	b	0x80099f8 <LL_TIM_OC_GetPolarity+0x4c> @ imm = #0x4
 80099f2: 2301         	movs	r3, #0x1
 80099f4: e000         	b	0x80099f8 <LL_TIM_OC_GetPolarity+0x4c> @ imm = #0x0
 80099f6: 2300         	movs	r3, #0x0
 80099f8: 73fb         	strb	r3, [r7, #0xf]
;   return (READ_BIT(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel])) >> SHIFT_TAB_CCxP[iChannel]);
 80099fa: 687b         	ldr	r3, [r7, #0x4]
 80099fc: 6a1a         	ldr	r2, [r3, #0x20]
 80099fe: 7bfb         	ldrb	r3, [r7, #0xf]
 8009a00: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8009a20 <LL_TIM_OC_GetPolarity+0x74>
 8009a02: 5ccb         	ldrb	r3, [r1, r3]
 8009a04: 4619         	mov	r1, r3
 8009a06: 2302         	movs	r3, #0x2
 8009a08: 408b         	lsls	r3, r1
 8009a0a: 4013         	ands	r3, r2
 8009a0c: 7bfa         	ldrb	r2, [r7, #0xf]
 8009a0e: 4904         	ldr	r1, [pc, #0x10]         @ 0x8009a20 <LL_TIM_OC_GetPolarity+0x74>
 8009a10: 5c8a         	ldrb	r2, [r1, r2]
 8009a12: 40d3         	lsrs	r3, r2
; }
 8009a14: 4618         	mov	r0, r3
 8009a16: 3714         	adds	r7, #0x14
 8009a18: 46bd         	mov	sp, r7
 8009a1a: f85d 7b04    	ldr	r7, [sp], #4
 8009a1e: 4770         	bx	lr

08009a20 <$d>:
 8009a20: 9c 29 02 08  	.word	0x0802299c

08009a24 <LL_TIM_OC_EnablePreload>:
; {
 8009a24: b480         	push	{r7}
 8009a26: b085         	sub	sp, #0x14
 8009a28: af00         	add	r7, sp, #0x0
 8009a2a: 6078         	str	r0, [r7, #0x4]
 8009a2c: 6039         	str	r1, [r7]
;   uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
 8009a2e: 683b         	ldr	r3, [r7]
 8009a30: 2b01         	cmp	r3, #0x1
 8009a32: d01c         	beq	0x8009a6e <LL_TIM_OC_EnablePreload+0x4a> @ imm = #0x38
 8009a34: 683b         	ldr	r3, [r7]
 8009a36: 2b04         	cmp	r3, #0x4
 8009a38: d017         	beq	0x8009a6a <LL_TIM_OC_EnablePreload+0x46> @ imm = #0x2e
 8009a3a: 683b         	ldr	r3, [r7]
 8009a3c: 2b10         	cmp	r3, #0x10
 8009a3e: d012         	beq	0x8009a66 <LL_TIM_OC_EnablePreload+0x42> @ imm = #0x24
 8009a40: 683b         	ldr	r3, [r7]
 8009a42: 2b40         	cmp	r3, #0x40
 8009a44: d00d         	beq	0x8009a62 <LL_TIM_OC_EnablePreload+0x3e> @ imm = #0x1a
 8009a46: 683b         	ldr	r3, [r7]
 8009a48: f5b3 7f80    	cmp.w	r3, #0x100
 8009a4c: d007         	beq	0x8009a5e <LL_TIM_OC_EnablePreload+0x3a> @ imm = #0xe
 8009a4e: 683b         	ldr	r3, [r7]
 8009a50: f5b3 6f80    	cmp.w	r3, #0x400
 8009a54: d101         	bne	0x8009a5a <LL_TIM_OC_EnablePreload+0x36> @ imm = #0x2
 8009a56: 2305         	movs	r3, #0x5
 8009a58: e00a         	b	0x8009a70 <LL_TIM_OC_EnablePreload+0x4c> @ imm = #0x14
 8009a5a: 2306         	movs	r3, #0x6
 8009a5c: e008         	b	0x8009a70 <LL_TIM_OC_EnablePreload+0x4c> @ imm = #0x10
 8009a5e: 2304         	movs	r3, #0x4
 8009a60: e006         	b	0x8009a70 <LL_TIM_OC_EnablePreload+0x4c> @ imm = #0xc
 8009a62: 2303         	movs	r3, #0x3
 8009a64: e004         	b	0x8009a70 <LL_TIM_OC_EnablePreload+0x4c> @ imm = #0x8
 8009a66: 2302         	movs	r3, #0x2
 8009a68: e002         	b	0x8009a70 <LL_TIM_OC_EnablePreload+0x4c> @ imm = #0x4
 8009a6a: 2301         	movs	r3, #0x1
 8009a6c: e000         	b	0x8009a70 <LL_TIM_OC_EnablePreload+0x4c> @ imm = #0x0
 8009a6e: 2300         	movs	r3, #0x0
 8009a70: 73fb         	strb	r3, [r7, #0xf]
;   __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 8009a72: 687b         	ldr	r3, [r7, #0x4]
 8009a74: 3318         	adds	r3, #0x18
 8009a76: 4619         	mov	r1, r3
 8009a78: 7bfb         	ldrb	r3, [r7, #0xf]
 8009a7a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8009aa4 <LL_TIM_OC_EnablePreload+0x80>
 8009a7c: 5cd3         	ldrb	r3, [r2, r3]
 8009a7e: 440b         	add	r3, r1
 8009a80: 60bb         	str	r3, [r7, #0x8]
;   SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 8009a82: 68bb         	ldr	r3, [r7, #0x8]
 8009a84: 681a         	ldr	r2, [r3]
 8009a86: 7bfb         	ldrb	r3, [r7, #0xf]
 8009a88: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8009aa8 <LL_TIM_OC_EnablePreload+0x84>
 8009a8a: 5ccb         	ldrb	r3, [r1, r3]
 8009a8c: 4619         	mov	r1, r3
 8009a8e: 2308         	movs	r3, #0x8
 8009a90: 408b         	lsls	r3, r1
 8009a92: 431a         	orrs	r2, r3
 8009a94: 68bb         	ldr	r3, [r7, #0x8]
 8009a96: 601a         	str	r2, [r3]
; }
 8009a98: bf00         	nop
 8009a9a: 3714         	adds	r7, #0x14
 8009a9c: 46bd         	mov	sp, r7
 8009a9e: f85d 7b04    	ldr	r7, [sp], #4
 8009aa2: 4770         	bx	lr

08009aa4 <$d>:
 8009aa4: 8c 29 02 08  	.word	0x0802298c
 8009aa8: 94 29 02 08  	.word	0x08022994

08009aac <get_tim_clk>:
; {
 8009aac: b580         	push	{r7, lr}
 8009aae: b086         	sub	sp, #0x18
 8009ab0: af00         	add	r7, sp, #0x0
 8009ab2: 6078         	str	r0, [r7, #0x4]
 8009ab4: 6039         	str	r1, [r7]
; 	clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8009ab6: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8009b08 <get_tim_clk+0x5c>
 8009ab8: 613b         	str	r3, [r7, #0x10]
; 	r = clock_control_get_rate(clk, (clock_control_subsys_t)pclken,
 8009aba: f107 0308    	add.w	r3, r7, #0x8
 8009abe: 461a         	mov	r2, r3
 8009ac0: 6879         	ldr	r1, [r7, #0x4]
 8009ac2: 6938         	ldr	r0, [r7, #0x10]
 8009ac4: f010 fbbb    	bl	0x801a23e <clock_control_get_rate> @ imm = #0x10776
 8009ac8: 60f8         	str	r0, [r7, #0xc]
; 	if (r < 0) {
 8009aca: 68fb         	ldr	r3, [r7, #0xc]
 8009acc: 2b00         	cmp	r3, #0x0
 8009ace: da01         	bge	0x8009ad4 <get_tim_clk+0x28> @ imm = #0x2
; 		return r;
 8009ad0: 68fb         	ldr	r3, [r7, #0xc]
 8009ad2: e014         	b	0x8009afe <get_tim_clk+0x52> @ imm = #0x28
; 	if (pclken->bus == STM32_CLOCK_BUS_APB1) {
 8009ad4: 687b         	ldr	r3, [r7, #0x4]
 8009ad6: 681b         	ldr	r3, [r3]
 8009ad8: 2b40         	cmp	r3, #0x40
 8009ada: d102         	bne	0x8009ae2 <get_tim_clk+0x36> @ imm = #0x4
; 		apb_psc = STM32_APB1_PRESCALER;
 8009adc: 2304         	movs	r3, #0x4
 8009ade: 617b         	str	r3, [r7, #0x14]
 8009ae0: e001         	b	0x8009ae6 <get_tim_clk+0x3a> @ imm = #0x2
; 		apb_psc = STM32_APB2_PRESCALER;
 8009ae2: 2302         	movs	r3, #0x2
 8009ae4: 617b         	str	r3, [r7, #0x14]
; 	if (apb_psc == 1u) {
 8009ae6: 697b         	ldr	r3, [r7, #0x14]
 8009ae8: 2b01         	cmp	r3, #0x1
 8009aea: d103         	bne	0x8009af4 <get_tim_clk+0x48> @ imm = #0x6
; 		*tim_clk = bus_clk;
 8009aec: 68ba         	ldr	r2, [r7, #0x8]
 8009aee: 683b         	ldr	r3, [r7]
 8009af0: 601a         	str	r2, [r3]
 8009af2: e003         	b	0x8009afc <get_tim_clk+0x50> @ imm = #0x6
; 		*tim_clk = bus_clk * 2u;
 8009af4: 68bb         	ldr	r3, [r7, #0x8]
 8009af6: 005a         	lsls	r2, r3, #0x1
 8009af8: 683b         	ldr	r3, [r7]
 8009afa: 601a         	str	r2, [r3]
; 	return 0;
 8009afc: 2300         	movs	r3, #0x0
; }
 8009afe: 4618         	mov	r0, r3
 8009b00: 3718         	adds	r7, #0x18
 8009b02: 46bd         	mov	sp, r7
 8009b04: bd80         	pop	{r7, pc}
 8009b06: bf00         	nop

08009b08 <$d>:
 8009b08: 80 01 02 08  	.word	0x08020180

08009b0c <pwm_stm32_set_cycles>:
; {
 8009b0c: b590         	push	{r4, r7, lr}
 8009b0e: b09d         	sub	sp, #0x74
 8009b10: af04         	add	r7, sp, #0x10
 8009b12: 60f8         	str	r0, [r7, #0xc]
 8009b14: 60b9         	str	r1, [r7, #0x8]
 8009b16: 607a         	str	r2, [r7, #0x4]
 8009b18: 603b         	str	r3, [r7]
; 	const struct pwm_stm32_config *cfg = dev->config;
 8009b1a: 68fb         	ldr	r3, [r7, #0xc]
 8009b1c: 685b         	ldr	r3, [r3, #0x4]
 8009b1e: 657b         	str	r3, [r7, #0x54]
; 	if (channel < 1u || channel > TIMER_MAX_CH) {
 8009b20: 68bb         	ldr	r3, [r7, #0x8]
 8009b22: 2b00         	cmp	r3, #0x0
 8009b24: d002         	beq	0x8009b2c <pwm_stm32_set_cycles+0x20> @ imm = #0x4
 8009b26: 68bb         	ldr	r3, [r7, #0x8]
 8009b28: 2b04         	cmp	r3, #0x4
 8009b2a: d920         	bls	0x8009b6e <pwm_stm32_set_cycles+0x62> @ imm = #0x40
; 		LOG_ERR("Invalid channel (%d)", channel);
 8009b2c: 2303         	movs	r3, #0x3
 8009b2e: 2b00         	cmp	r3, #0x0
 8009b30: d01a         	beq	0x8009b68 <pwm_stm32_set_cycles+0x5c> @ imm = #0x34
 8009b32: 2301         	movs	r3, #0x1
 8009b34: f887 3037    	strb.w	r3, [r7, #0x37]
 8009b38: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8009b3c: f083 0301    	eor	r3, r3, #0x1
 8009b40: b2db         	uxtb	r3, r3
 8009b42: 2b00         	cmp	r3, #0x0
 8009b44: d110         	bne	0x8009b68 <pwm_stm32_set_cycles+0x5c> @ imm = #0x20
 8009b46: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8009de0 <pwm_stm32_set_cycles+0x2d4>
 8009b48: 6819         	ldr	r1, [r3]
 8009b4a: 68bb         	ldr	r3, [r7, #0x8]
 8009b4c: 9303         	str	r3, [sp, #0xc]
 8009b4e: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8009de4 <pwm_stm32_set_cycles+0x2d8>
 8009b50: 9302         	str	r3, [sp, #0x8]
 8009b52: 2300         	movs	r3, #0x0
 8009b54: 9301         	str	r3, [sp, #0x4]
 8009b56: 2300         	movs	r3, #0x0
 8009b58: 9300         	str	r3, [sp]
 8009b5a: 2300         	movs	r3, #0x0
 8009b5c: 2201         	movs	r2, #0x1
 8009b5e: 2000         	movs	r0, #0x0
 8009b60: f010 fb88    	bl	0x801a274 <z_log_msg_runtime_create> @ imm = #0x10710
 8009b64: 2300         	movs	r3, #0x0
 8009b66: 633b         	str	r3, [r7, #0x30]
; 		return -EINVAL;
 8009b68: f06f 0315    	mvn	r3, #0x15
 8009b6c: e166         	b	0x8009e3c <pwm_stm32_set_cycles+0x330> @ imm = #0x2cc
; 	if (!IS_TIM_32B_COUNTER_INSTANCE(cfg->timer) &&
 8009b6e: 6d7b         	ldr	r3, [r7, #0x54]
 8009b70: 681b         	ldr	r3, [r3]
 8009b72: f1b3 4f80    	cmp.w	r3, #0x40000000
 8009b76: d027         	beq	0x8009bc8 <pwm_stm32_set_cycles+0xbc> @ imm = #0x4e
 8009b78: 6d7b         	ldr	r3, [r7, #0x54]
 8009b7a: 681b         	ldr	r3, [r3]
 8009b7c: 4a9a         	ldr	r2, [pc, #0x268]        @ 0x8009de8 <pwm_stm32_set_cycles+0x2dc>
 8009b7e: 4293         	cmp	r3, r2
 8009b80: d022         	beq	0x8009bc8 <pwm_stm32_set_cycles+0xbc> @ imm = #0x44
 8009b82: 687b         	ldr	r3, [r7, #0x4]
 8009b84: f5b3 3f80    	cmp.w	r3, #0x10000
 8009b88: d91e         	bls	0x8009bc8 <pwm_stm32_set_cycles+0xbc> @ imm = #0x3c
; 		LOG_ERR("Cannot set PWM output, value exceeds 16-bit timer limit.");
 8009b8a: 2303         	movs	r3, #0x3
 8009b8c: 2b00         	cmp	r3, #0x0
 8009b8e: d018         	beq	0x8009bc2 <pwm_stm32_set_cycles+0xb6> @ imm = #0x30
 8009b90: 2301         	movs	r3, #0x1
 8009b92: f887 3053    	strb.w	r3, [r7, #0x53]
 8009b96: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8009b9a: f083 0301    	eor	r3, r3, #0x1
 8009b9e: b2db         	uxtb	r3, r3
 8009ba0: 2b00         	cmp	r3, #0x0
 8009ba2: d10e         	bne	0x8009bc2 <pwm_stm32_set_cycles+0xb6> @ imm = #0x1c
 8009ba4: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8009de0 <pwm_stm32_set_cycles+0x2d4>
 8009ba6: 6819         	ldr	r1, [r3]
 8009ba8: 4b90         	ldr	r3, [pc, #0x240]        @ 0x8009dec <pwm_stm32_set_cycles+0x2e0>
 8009baa: 9302         	str	r3, [sp, #0x8]
 8009bac: 2300         	movs	r3, #0x0
 8009bae: 9301         	str	r3, [sp, #0x4]
 8009bb0: 2300         	movs	r3, #0x0
 8009bb2: 9300         	str	r3, [sp]
 8009bb4: 2300         	movs	r3, #0x0
 8009bb6: 2201         	movs	r2, #0x1
 8009bb8: 2000         	movs	r0, #0x0
 8009bba: f010 fb5b    	bl	0x801a274 <z_log_msg_runtime_create> @ imm = #0x106b6
 8009bbe: 2300         	movs	r3, #0x0
 8009bc0: 64fb         	str	r3, [r7, #0x4c]
; 		return -ENOTSUP;
 8009bc2: f06f 0385    	mvn	r3, #0x85
 8009bc6: e139         	b	0x8009e3c <pwm_stm32_set_cycles+0x330> @ imm = #0x272
; 	ll_channel = ch2ll[channel - 1u];
 8009bc8: 68bb         	ldr	r3, [r7, #0x8]
 8009bca: 3b01         	subs	r3, #0x1
 8009bcc: 4a88         	ldr	r2, [pc, #0x220]        @ 0x8009df0 <pwm_stm32_set_cycles+0x2e4>
 8009bce: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8009bd2: 64bb         	str	r3, [r7, #0x48]
; 	if (channel <= ARRAY_SIZE(ch2ll_n)) {
 8009bd4: 68bb         	ldr	r3, [r7, #0x8]
 8009bd6: 2b03         	cmp	r3, #0x3
 8009bd8: d806         	bhi	0x8009be8 <pwm_stm32_set_cycles+0xdc> @ imm = #0xc
; 		negative_ll_channel = ch2ll_n[channel - 1u];
 8009bda: 68bb         	ldr	r3, [r7, #0x8]
 8009bdc: 3b01         	subs	r3, #0x1
 8009bde: 4a85         	ldr	r2, [pc, #0x214]        @ 0x8009df4 <pwm_stm32_set_cycles+0x2e8>
 8009be0: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8009be4: 65bb         	str	r3, [r7, #0x58]
 8009be6: e001         	b	0x8009bec <pwm_stm32_set_cycles+0xe0> @ imm = #0x2
; 		negative_ll_channel = 0;
 8009be8: 2300         	movs	r3, #0x0
 8009bea: 65bb         	str	r3, [r7, #0x58]
; 	if ((flags & STM32_PWM_COMPLEMENTARY_MASK) == STM32_PWM_COMPLEMENTARY) {
 8009bec: f8b7 3070    	ldrh.w	r3, [r7, #0x70]
 8009bf0: f403 7380    	and	r3, r3, #0x100
 8009bf4: 2b00         	cmp	r3, #0x0
 8009bf6: d026         	beq	0x8009c46 <pwm_stm32_set_cycles+0x13a> @ imm = #0x4c
; 		if (!negative_ll_channel) {
 8009bf8: 6dbb         	ldr	r3, [r7, #0x58]
 8009bfa: 2b00         	cmp	r3, #0x0
 8009bfc: d120         	bne	0x8009c40 <pwm_stm32_set_cycles+0x134> @ imm = #0x40
; 			LOG_ERR("Channel %d has NO complementary output", channel);
 8009bfe: 2303         	movs	r3, #0x3
 8009c00: 2b00         	cmp	r3, #0x0
 8009c02: d01a         	beq	0x8009c3a <pwm_stm32_set_cycles+0x12e> @ imm = #0x34
 8009c04: 2301         	movs	r3, #0x1
 8009c06: f887 3047    	strb.w	r3, [r7, #0x47]
 8009c0a: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8009c0e: f083 0301    	eor	r3, r3, #0x1
 8009c12: b2db         	uxtb	r3, r3
 8009c14: 2b00         	cmp	r3, #0x0
 8009c16: d110         	bne	0x8009c3a <pwm_stm32_set_cycles+0x12e> @ imm = #0x20
 8009c18: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x8009de0 <pwm_stm32_set_cycles+0x2d4>
 8009c1a: 6819         	ldr	r1, [r3]
 8009c1c: 68bb         	ldr	r3, [r7, #0x8]
 8009c1e: 9303         	str	r3, [sp, #0xc]
 8009c20: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8009df8 <pwm_stm32_set_cycles+0x2ec>
 8009c22: 9302         	str	r3, [sp, #0x8]
 8009c24: 2300         	movs	r3, #0x0
 8009c26: 9301         	str	r3, [sp, #0x4]
 8009c28: 2300         	movs	r3, #0x0
 8009c2a: 9300         	str	r3, [sp]
 8009c2c: 2300         	movs	r3, #0x0
 8009c2e: 2201         	movs	r2, #0x1
 8009c30: 2000         	movs	r0, #0x0
 8009c32: f010 fb1f    	bl	0x801a274 <z_log_msg_runtime_create> @ imm = #0x1063e
 8009c36: 2300         	movs	r3, #0x0
 8009c38: 643b         	str	r3, [r7, #0x40]
; 			return -EINVAL;
 8009c3a: f06f 0315    	mvn	r3, #0x15
 8009c3e: e0fd         	b	0x8009e3c <pwm_stm32_set_cycles+0x330> @ imm = #0x1fa
; 		current_ll_channel = negative_ll_channel;
 8009c40: 6dbb         	ldr	r3, [r7, #0x58]
 8009c42: 65fb         	str	r3, [r7, #0x5c]
 8009c44: e001         	b	0x8009c4a <pwm_stm32_set_cycles+0x13e> @ imm = #0x2
; 		current_ll_channel = ll_channel;
 8009c46: 6cbb         	ldr	r3, [r7, #0x48]
 8009c48: 65fb         	str	r3, [r7, #0x5c]
; 	if (period_cycles == 0u) {
 8009c4a: 687b         	ldr	r3, [r7, #0x4]
 8009c4c: 2b00         	cmp	r3, #0x0
 8009c4e: d107         	bne	0x8009c60 <pwm_stm32_set_cycles+0x154> @ imm = #0xe
; 		LL_TIM_CC_DisableChannel(cfg->timer, current_ll_channel);
 8009c50: 6d7b         	ldr	r3, [r7, #0x54]
 8009c52: 681b         	ldr	r3, [r3]
 8009c54: 6df9         	ldr	r1, [r7, #0x5c]
 8009c56: 4618         	mov	r0, r3
 8009c58: f010 f9eb    	bl	0x801a032 <LL_TIM_CC_DisableChannel> @ imm = #0x103d6
; 		return 0;
 8009c5c: 2300         	movs	r3, #0x0
 8009c5e: e0ed         	b	0x8009e3c <pwm_stm32_set_cycles+0x330> @ imm = #0x1da
; 	if (cfg->countermode == LL_TIM_COUNTERMODE_UP) {
 8009c60: 6d7b         	ldr	r3, [r7, #0x54]
 8009c62: 689b         	ldr	r3, [r3, #0x8]
 8009c64: 2b00         	cmp	r3, #0x0
 8009c66: d103         	bne	0x8009c70 <pwm_stm32_set_cycles+0x164> @ imm = #0x6
; 		period_cycles -= 1U;
 8009c68: 687b         	ldr	r3, [r7, #0x4]
 8009c6a: 3b01         	subs	r3, #0x1
 8009c6c: 607b         	str	r3, [r7, #0x4]
 8009c6e: e01c         	b	0x8009caa <pwm_stm32_set_cycles+0x19e> @ imm = #0x38
; 	} else if (cfg->countermode == LL_TIM_COUNTERMODE_DOWN) {
 8009c70: 6d7b         	ldr	r3, [r7, #0x54]
 8009c72: 689b         	ldr	r3, [r3, #0x8]
 8009c74: 2b10         	cmp	r3, #0x10
 8009c76: d106         	bne	0x8009c86 <pwm_stm32_set_cycles+0x17a> @ imm = #0xc
; 		pulse_cycles -= 1U;
 8009c78: 683b         	ldr	r3, [r7]
 8009c7a: 3b01         	subs	r3, #0x1
 8009c7c: 603b         	str	r3, [r7]
; 		period_cycles -= 1U;
 8009c7e: 687b         	ldr	r3, [r7, #0x4]
 8009c80: 3b01         	subs	r3, #0x1
 8009c82: 607b         	str	r3, [r7, #0x4]
 8009c84: e011         	b	0x8009caa <pwm_stm32_set_cycles+0x19e> @ imm = #0x22
; 	} else if (is_center_aligned(cfg->countermode)) {
 8009c86: 6d7b         	ldr	r3, [r7, #0x54]
 8009c88: 689b         	ldr	r3, [r3, #0x8]
 8009c8a: 4618         	mov	r0, r3
 8009c8c: f010 fb23    	bl	0x801a2d6 <is_center_aligned> @ imm = #0x10646
 8009c90: 4603         	mov	r3, r0
 8009c92: 2b00         	cmp	r3, #0x0
 8009c94: d006         	beq	0x8009ca4 <pwm_stm32_set_cycles+0x198> @ imm = #0xc
; 		pulse_cycles /= 2U;
 8009c96: 683b         	ldr	r3, [r7]
 8009c98: 085b         	lsrs	r3, r3, #0x1
 8009c9a: 603b         	str	r3, [r7]
; 		period_cycles /= 2U;
 8009c9c: 687b         	ldr	r3, [r7, #0x4]
 8009c9e: 085b         	lsrs	r3, r3, #0x1
 8009ca0: 607b         	str	r3, [r7, #0x4]
 8009ca2: e002         	b	0x8009caa <pwm_stm32_set_cycles+0x19e> @ imm = #0x4
; 		return -ENOTSUP;
 8009ca4: f06f 0385    	mvn	r3, #0x85
 8009ca8: e0c8         	b	0x8009e3c <pwm_stm32_set_cycles+0x330> @ imm = #0x190
; 	if (!LL_TIM_CC_IsEnabledChannel(cfg->timer, current_ll_channel)) {
 8009caa: 6d7b         	ldr	r3, [r7, #0x54]
 8009cac: 681b         	ldr	r3, [r3]
 8009cae: 6df9         	ldr	r1, [r7, #0x5c]
 8009cb0: 4618         	mov	r0, r3
 8009cb2: f010 f9d0    	bl	0x801a056 <LL_TIM_CC_IsEnabledChannel> @ imm = #0x103a0
 8009cb6: 4603         	mov	r3, r0
 8009cb8: 2b00         	cmp	r3, #0x0
 8009cba: f040 80a1    	bne.w	0x8009e00 <pwm_stm32_set_cycles+0x2f4> @ imm = #0x142
; 		LL_TIM_OC_StructInit(&oc_init);
 8009cbe: f107 0310    	add.w	r3, r7, #0x10
 8009cc2: 4618         	mov	r0, r3
 8009cc4: f014 f8ea    	bl	0x801de9c <LL_TIM_OC_StructInit> @ imm = #0x141d4
; 		oc_init.OCMode = LL_TIM_OCMODE_PWM1;
 8009cc8: 2360         	movs	r3, #0x60
 8009cca: 613b         	str	r3, [r7, #0x10]
; 		if ((flags & STM32_PWM_COMPLEMENTARY_MASK) == STM32_PWM_COMPLEMENTARY) {
 8009ccc: f8b7 3070    	ldrh.w	r3, [r7, #0x70]
 8009cd0: f403 7380    	and	r3, r3, #0x100
 8009cd4: 2b00         	cmp	r3, #0x0
 8009cd6: d01e         	beq	0x8009d16 <pwm_stm32_set_cycles+0x20a> @ imm = #0x3c
; 			oc_init.OCNState = LL_TIM_OCSTATE_ENABLE;
 8009cd8: 2301         	movs	r3, #0x1
 8009cda: 61bb         	str	r3, [r7, #0x18]
; 			oc_init.OCNPolarity = get_polarity(flags);
 8009cdc: f8b7 3070    	ldrh.w	r3, [r7, #0x70]
 8009ce0: 4618         	mov	r0, r3
 8009ce2: f010 fae5    	bl	0x801a2b0 <get_polarity> @ imm = #0x105ca
 8009ce6: 4603         	mov	r3, r0
 8009ce8: 627b         	str	r3, [r7, #0x24]
; 			oc_init.OCState = LL_TIM_CC_IsEnabledChannel(cfg->timer, ll_channel)
 8009cea: 6d7b         	ldr	r3, [r7, #0x54]
 8009cec: 681b         	ldr	r3, [r3]
 8009cee: 6cb9         	ldr	r1, [r7, #0x48]
 8009cf0: 4618         	mov	r0, r3
 8009cf2: f010 f9b0    	bl	0x801a056 <LL_TIM_CC_IsEnabledChannel> @ imm = #0x10360
 8009cf6: 4603         	mov	r3, r0
; 						  : LL_TIM_OCSTATE_DISABLE;
 8009cf8: 2b00         	cmp	r3, #0x0
 8009cfa: d001         	beq	0x8009d00 <pwm_stm32_set_cycles+0x1f4> @ imm = #0x2
 8009cfc: 2301         	movs	r3, #0x1
 8009cfe: e000         	b	0x8009d02 <pwm_stm32_set_cycles+0x1f6> @ imm = #0x0
 8009d00: 2300         	movs	r3, #0x0
; 			oc_init.OCState = LL_TIM_CC_IsEnabledChannel(cfg->timer, ll_channel)
 8009d02: 617b         	str	r3, [r7, #0x14]
; 			oc_init.OCPolarity = LL_TIM_OC_GetPolarity(cfg->timer, ll_channel);
 8009d04: 6d7b         	ldr	r3, [r7, #0x54]
 8009d06: 681b         	ldr	r3, [r3]
 8009d08: 6cb9         	ldr	r1, [r7, #0x48]
 8009d0a: 4618         	mov	r0, r3
 8009d0c: f7ff fe4e    	bl	0x80099ac <LL_TIM_OC_GetPolarity> @ imm = #-0x364
 8009d10: 4603         	mov	r3, r0
 8009d12: 623b         	str	r3, [r7, #0x20]
 8009d14: e020         	b	0x8009d58 <pwm_stm32_set_cycles+0x24c> @ imm = #0x40
; 			oc_init.OCState = LL_TIM_OCSTATE_ENABLE;
 8009d16: 2301         	movs	r3, #0x1
 8009d18: 617b         	str	r3, [r7, #0x14]
; 			oc_init.OCPolarity = get_polarity(flags);
 8009d1a: f8b7 3070    	ldrh.w	r3, [r7, #0x70]
 8009d1e: 4618         	mov	r0, r3
 8009d20: f010 fac6    	bl	0x801a2b0 <get_polarity> @ imm = #0x1058c
 8009d24: 4603         	mov	r3, r0
 8009d26: 623b         	str	r3, [r7, #0x20]
; 			if (negative_ll_channel) {
 8009d28: 6dbb         	ldr	r3, [r7, #0x58]
 8009d2a: 2b00         	cmp	r3, #0x0
 8009d2c: d014         	beq	0x8009d58 <pwm_stm32_set_cycles+0x24c> @ imm = #0x28
; 					LL_TIM_CC_IsEnabledChannel(cfg->timer, negative_ll_channel)
 8009d2e: 6d7b         	ldr	r3, [r7, #0x54]
 8009d30: 681b         	ldr	r3, [r3]
 8009d32: 6db9         	ldr	r1, [r7, #0x58]
 8009d34: 4618         	mov	r0, r3
 8009d36: f010 f98e    	bl	0x801a056 <LL_TIM_CC_IsEnabledChannel> @ imm = #0x1031c
 8009d3a: 4603         	mov	r3, r0
; 						: LL_TIM_OCSTATE_DISABLE;
 8009d3c: 2b00         	cmp	r3, #0x0
 8009d3e: d001         	beq	0x8009d44 <pwm_stm32_set_cycles+0x238> @ imm = #0x2
 8009d40: 2301         	movs	r3, #0x1
 8009d42: e000         	b	0x8009d46 <pwm_stm32_set_cycles+0x23a> @ imm = #0x0
 8009d44: 2300         	movs	r3, #0x0
; 				oc_init.OCNState =
 8009d46: 61bb         	str	r3, [r7, #0x18]
; 					LL_TIM_OC_GetPolarity(cfg->timer, negative_ll_channel);
 8009d48: 6d7b         	ldr	r3, [r7, #0x54]
 8009d4a: 681b         	ldr	r3, [r3]
 8009d4c: 6db9         	ldr	r1, [r7, #0x58]
 8009d4e: 4618         	mov	r0, r3
 8009d50: f7ff fe2c    	bl	0x80099ac <LL_TIM_OC_GetPolarity> @ imm = #-0x3a8
 8009d54: 4603         	mov	r3, r0
; 				oc_init.OCNPolarity =
 8009d56: 627b         	str	r3, [r7, #0x24]
; 		oc_init.CompareValue = pulse_cycles;
 8009d58: 683b         	ldr	r3, [r7]
 8009d5a: 61fb         	str	r3, [r7, #0x1c]
; 		if (LL_TIM_OC_Init(cfg->timer, ll_channel, &oc_init) != SUCCESS) {
 8009d5c: 6d7b         	ldr	r3, [r7, #0x54]
 8009d5e: 681b         	ldr	r3, [r3]
 8009d60: f107 0210    	add.w	r2, r7, #0x10
 8009d64: 6cb9         	ldr	r1, [r7, #0x48]
 8009d66: 4618         	mov	r0, r3
 8009d68: f014 f8ba    	bl	0x801dee0 <LL_TIM_OC_Init> @ imm = #0x14174
 8009d6c: 4603         	mov	r3, r0
 8009d6e: 2b00         	cmp	r3, #0x0
 8009d70: d01e         	beq	0x8009db0 <pwm_stm32_set_cycles+0x2a4> @ imm = #0x3c
; 			LOG_ERR("Could not initialize timer channel output");
 8009d72: 2303         	movs	r3, #0x3
 8009d74: 2b00         	cmp	r3, #0x0
 8009d76: d018         	beq	0x8009daa <pwm_stm32_set_cycles+0x29e> @ imm = #0x30
 8009d78: 2301         	movs	r3, #0x1
 8009d7a: f887 303f    	strb.w	r3, [r7, #0x3f]
 8009d7e: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8009d82: f083 0301    	eor	r3, r3, #0x1
 8009d86: b2db         	uxtb	r3, r3
 8009d88: 2b00         	cmp	r3, #0x0
 8009d8a: d10e         	bne	0x8009daa <pwm_stm32_set_cycles+0x29e> @ imm = #0x1c
 8009d8c: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8009de0 <pwm_stm32_set_cycles+0x2d4>
 8009d8e: 6819         	ldr	r1, [r3]
 8009d90: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8009dfc <pwm_stm32_set_cycles+0x2f0>
 8009d92: 9302         	str	r3, [sp, #0x8]
 8009d94: 2300         	movs	r3, #0x0
 8009d96: 9301         	str	r3, [sp, #0x4]
 8009d98: 2300         	movs	r3, #0x0
 8009d9a: 9300         	str	r3, [sp]
 8009d9c: 2300         	movs	r3, #0x0
 8009d9e: 2201         	movs	r2, #0x1
 8009da0: 2000         	movs	r0, #0x0
 8009da2: f010 fa67    	bl	0x801a274 <z_log_msg_runtime_create> @ imm = #0x104ce
 8009da6: 2300         	movs	r3, #0x0
 8009da8: 63bb         	str	r3, [r7, #0x38]
; 			return -EIO;
 8009daa: f06f 0304    	mvn	r3, #0x4
 8009dae: e045         	b	0x8009e3c <pwm_stm32_set_cycles+0x330> @ imm = #0x8a
; 		LL_TIM_EnableARRPreload(cfg->timer);
 8009db0: 6d7b         	ldr	r3, [r7, #0x54]
 8009db2: 681b         	ldr	r3, [r3]
 8009db4: 4618         	mov	r0, r3
 8009db6: f010 f91e    	bl	0x8019ff6 <LL_TIM_EnableARRPreload> @ imm = #0x1023c
; 		LL_TIM_OC_EnablePreload(cfg->timer, ll_channel);
 8009dba: 6d7b         	ldr	r3, [r7, #0x54]
 8009dbc: 681b         	ldr	r3, [r3]
 8009dbe: 6cb9         	ldr	r1, [r7, #0x48]
 8009dc0: 4618         	mov	r0, r3
 8009dc2: f7ff fe2f    	bl	0x8009a24 <LL_TIM_OC_EnablePreload> @ imm = #-0x3a2
; 		LL_TIM_SetAutoReload(cfg->timer, period_cycles);
 8009dc6: 6d7b         	ldr	r3, [r7, #0x54]
 8009dc8: 681b         	ldr	r3, [r3]
 8009dca: 6879         	ldr	r1, [r7, #0x4]
 8009dcc: 4618         	mov	r0, r3
 8009dce: f010 f922    	bl	0x801a016 <LL_TIM_SetAutoReload> @ imm = #0x10244
; 		LL_TIM_GenerateEvent_UPDATE(cfg->timer);
 8009dd2: 6d7b         	ldr	r3, [r7, #0x54]
 8009dd4: 681b         	ldr	r3, [r3]
 8009dd6: 4618         	mov	r0, r3
 8009dd8: f010 f99a    	bl	0x801a110 <LL_TIM_GenerateEvent_UPDATE> @ imm = #0x10334
 8009ddc: e02d         	b	0x8009e3a <pwm_stm32_set_cycles+0x32e> @ imm = #0x5a
 8009dde: bf00         	nop

08009de0 <$d>:
 8009de0: 54 05 00 20  	.word	0x20000554
 8009de4: 68 14 02 08  	.word	0x08021468
 8009de8: 00 0c 00 40  	.word	0x40000c00
 8009dec: 80 14 02 08  	.word	0x08021480
 8009df0: a4 29 02 08  	.word	0x080229a4
 8009df4: b4 29 02 08  	.word	0x080229b4
 8009df8: bc 14 02 08  	.word	0x080214bc
 8009dfc: e4 14 02 08  	.word	0x080214e4

08009e00 <$t>:
; 		LL_TIM_OC_SetPolarity(cfg->timer, current_ll_channel, get_polarity(flags));
 8009e00: 6d7b         	ldr	r3, [r7, #0x54]
 8009e02: 681c         	ldr	r4, [r3]
 8009e04: f8b7 3070    	ldrh.w	r3, [r7, #0x70]
 8009e08: 4618         	mov	r0, r3
 8009e0a: f010 fa51    	bl	0x801a2b0 <get_polarity> @ imm = #0x104a2
 8009e0e: 4603         	mov	r3, r0
 8009e10: 461a         	mov	r2, r3
 8009e12: 6df9         	ldr	r1, [r7, #0x5c]
 8009e14: 4620         	mov	r0, r4
 8009e16: f7ff fd85    	bl	0x8009924 <LL_TIM_OC_SetPolarity> @ imm = #-0x4f6
; 		set_timer_compare[channel - 1u](cfg->timer, pulse_cycles);
 8009e1a: 68bb         	ldr	r3, [r7, #0x8]
 8009e1c: 3b01         	subs	r3, #0x1
 8009e1e: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8009e44 <pwm_stm32_set_cycles+0x338>
 8009e20: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8009e24: 6d7a         	ldr	r2, [r7, #0x54]
 8009e26: 6812         	ldr	r2, [r2]
 8009e28: 6839         	ldr	r1, [r7]
 8009e2a: 4610         	mov	r0, r2
 8009e2c: 4798         	blx	r3
; 		LL_TIM_SetAutoReload(cfg->timer, period_cycles);
 8009e2e: 6d7b         	ldr	r3, [r7, #0x54]
 8009e30: 681b         	ldr	r3, [r3]
 8009e32: 6879         	ldr	r1, [r7, #0x4]
 8009e34: 4618         	mov	r0, r3
 8009e36: f010 f8ee    	bl	0x801a016 <LL_TIM_SetAutoReload> @ imm = #0x101dc
; 	return 0;
 8009e3a: 2300         	movs	r3, #0x0
; }
 8009e3c: 4618         	mov	r0, r3
 8009e3e: 3764         	adds	r7, #0x64
 8009e40: 46bd         	mov	sp, r7
 8009e42: bd90         	pop	{r4, r7, pc}

08009e44 <$d>:
 8009e44: c0 29 02 08  	.word	0x080229c0

08009e48 <pwm_stm32_init>:
; {
 8009e48: b580         	push	{r7, lr}
 8009e4a: b09a         	sub	sp, #0x68
 8009e4c: af04         	add	r7, sp, #0x10
 8009e4e: 6078         	str	r0, [r7, #0x4]
; 	struct pwm_stm32_data *data = dev->data;
 8009e50: 687b         	ldr	r3, [r7, #0x4]
 8009e52: 691b         	ldr	r3, [r3, #0x10]
 8009e54: 657b         	str	r3, [r7, #0x54]
; 	const struct pwm_stm32_config *cfg = dev->config;
 8009e56: 687b         	ldr	r3, [r7, #0x4]
 8009e58: 685b         	ldr	r3, [r3, #0x4]
 8009e5a: 653b         	str	r3, [r7, #0x50]
; 	clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8009e5c: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800a060 <pwm_stm32_init+0x218>
 8009e5e: 64fb         	str	r3, [r7, #0x4c]
; 	if (!device_is_ready(clk)) {
 8009e60: 6cf8         	ldr	r0, [r7, #0x4c]
 8009e62: f010 f965    	bl	0x801a130 <device_is_ready> @ imm = #0x102ca
 8009e66: 4603         	mov	r3, r0
 8009e68: f083 0301    	eor	r3, r3, #0x1
 8009e6c: b2db         	uxtb	r3, r3
 8009e6e: 2b00         	cmp	r3, #0x0
 8009e70: d01e         	beq	0x8009eb0 <pwm_stm32_init+0x68> @ imm = #0x3c
; 		LOG_ERR("clock control device not ready");
 8009e72: 2303         	movs	r3, #0x3
 8009e74: 2b00         	cmp	r3, #0x0
 8009e76: d018         	beq	0x8009eaa <pwm_stm32_init+0x62> @ imm = #0x30
 8009e78: 2301         	movs	r3, #0x1
 8009e7a: f887 3027    	strb.w	r3, [r7, #0x27]
 8009e7e: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8009e82: f083 0301    	eor	r3, r3, #0x1
 8009e86: b2db         	uxtb	r3, r3
 8009e88: 2b00         	cmp	r3, #0x0
 8009e8a: d10e         	bne	0x8009eaa <pwm_stm32_init+0x62> @ imm = #0x1c
 8009e8c: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x800a064 <pwm_stm32_init+0x21c>
 8009e8e: 6819         	ldr	r1, [r3]
 8009e90: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x800a068 <pwm_stm32_init+0x220>
 8009e92: 9302         	str	r3, [sp, #0x8]
 8009e94: 2300         	movs	r3, #0x0
 8009e96: 9301         	str	r3, [sp, #0x4]
 8009e98: 2300         	movs	r3, #0x0
 8009e9a: 9300         	str	r3, [sp]
 8009e9c: 2300         	movs	r3, #0x0
 8009e9e: 2201         	movs	r2, #0x1
 8009ea0: 2000         	movs	r0, #0x0
 8009ea2: f010 f9e7    	bl	0x801a274 <z_log_msg_runtime_create> @ imm = #0x103ce
 8009ea6: 2300         	movs	r3, #0x0
 8009ea8: 623b         	str	r3, [r7, #0x20]
; 		return -ENODEV;
 8009eaa: f06f 0312    	mvn	r3, #0x12
 8009eae: e0d2         	b	0x800a056 <pwm_stm32_init+0x20e> @ imm = #0x1a4
; 	r = clock_control_on(clk, (clock_control_subsys_t)&cfg->pclken);
 8009eb0: 6d3b         	ldr	r3, [r7, #0x50]
 8009eb2: 330c         	adds	r3, #0xc
 8009eb4: 4619         	mov	r1, r3
 8009eb6: 6cf8         	ldr	r0, [r7, #0x4c]
 8009eb8: f010 f9af    	bl	0x801a21a <clock_control_on> @ imm = #0x1035e
 8009ebc: 64b8         	str	r0, [r7, #0x48]
; 	if (r < 0) {
 8009ebe: 6cbb         	ldr	r3, [r7, #0x48]
 8009ec0: 2b00         	cmp	r3, #0x0
 8009ec2: da1f         	bge	0x8009f04 <pwm_stm32_init+0xbc> @ imm = #0x3e
; 		LOG_ERR("Could not initialize clock (%d)", r);
 8009ec4: 2303         	movs	r3, #0x3
 8009ec6: 2b00         	cmp	r3, #0x0
 8009ec8: d01a         	beq	0x8009f00 <pwm_stm32_init+0xb8> @ imm = #0x34
 8009eca: 2301         	movs	r3, #0x1
 8009ecc: f887 302f    	strb.w	r3, [r7, #0x2f]
 8009ed0: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8009ed4: f083 0301    	eor	r3, r3, #0x1
 8009ed8: b2db         	uxtb	r3, r3
 8009eda: 2b00         	cmp	r3, #0x0
 8009edc: d110         	bne	0x8009f00 <pwm_stm32_init+0xb8> @ imm = #0x20
 8009ede: 4b61         	ldr	r3, [pc, #0x184]        @ 0x800a064 <pwm_stm32_init+0x21c>
 8009ee0: 6819         	ldr	r1, [r3]
 8009ee2: 6cbb         	ldr	r3, [r7, #0x48]
 8009ee4: 9303         	str	r3, [sp, #0xc]
 8009ee6: 4b61         	ldr	r3, [pc, #0x184]        @ 0x800a06c <pwm_stm32_init+0x224>
 8009ee8: 9302         	str	r3, [sp, #0x8]
 8009eea: 2300         	movs	r3, #0x0
 8009eec: 9301         	str	r3, [sp, #0x4]
 8009eee: 2300         	movs	r3, #0x0
 8009ef0: 9300         	str	r3, [sp]
 8009ef2: 2300         	movs	r3, #0x0
 8009ef4: 2201         	movs	r2, #0x1
 8009ef6: 2000         	movs	r0, #0x0
 8009ef8: f010 f9bc    	bl	0x801a274 <z_log_msg_runtime_create> @ imm = #0x10378
 8009efc: 2300         	movs	r3, #0x0
 8009efe: 62bb         	str	r3, [r7, #0x28]
; 		return r;
 8009f00: 6cbb         	ldr	r3, [r7, #0x48]
 8009f02: e0a8         	b	0x800a056 <pwm_stm32_init+0x20e> @ imm = #0x150
; 	r = get_tim_clk(&cfg->pclken, &data->tim_clk);
 8009f04: 6d3b         	ldr	r3, [r7, #0x50]
 8009f06: 330c         	adds	r3, #0xc
 8009f08: 6d7a         	ldr	r2, [r7, #0x54]
 8009f0a: 4611         	mov	r1, r2
 8009f0c: 4618         	mov	r0, r3
 8009f0e: f7ff fdcd    	bl	0x8009aac <get_tim_clk> @ imm = #-0x466
 8009f12: 64b8         	str	r0, [r7, #0x48]
; 	if (r < 0) {
 8009f14: 6cbb         	ldr	r3, [r7, #0x48]
 8009f16: 2b00         	cmp	r3, #0x0
 8009f18: da1f         	bge	0x8009f5a <pwm_stm32_init+0x112> @ imm = #0x3e
; 		LOG_ERR("Could not obtain timer clock (%d)", r);
 8009f1a: 2303         	movs	r3, #0x3
 8009f1c: 2b00         	cmp	r3, #0x0
 8009f1e: d01a         	beq	0x8009f56 <pwm_stm32_init+0x10e> @ imm = #0x34
 8009f20: 2301         	movs	r3, #0x1
 8009f22: f887 3037    	strb.w	r3, [r7, #0x37]
 8009f26: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8009f2a: f083 0301    	eor	r3, r3, #0x1
 8009f2e: b2db         	uxtb	r3, r3
 8009f30: 2b00         	cmp	r3, #0x0
 8009f32: d110         	bne	0x8009f56 <pwm_stm32_init+0x10e> @ imm = #0x20
 8009f34: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800a064 <pwm_stm32_init+0x21c>
 8009f36: 6819         	ldr	r1, [r3]
 8009f38: 6cbb         	ldr	r3, [r7, #0x48]
 8009f3a: 9303         	str	r3, [sp, #0xc]
 8009f3c: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x800a070 <pwm_stm32_init+0x228>
 8009f3e: 9302         	str	r3, [sp, #0x8]
 8009f40: 2300         	movs	r3, #0x0
 8009f42: 9301         	str	r3, [sp, #0x4]
 8009f44: 2300         	movs	r3, #0x0
 8009f46: 9300         	str	r3, [sp]
 8009f48: 2300         	movs	r3, #0x0
 8009f4a: 2201         	movs	r2, #0x1
 8009f4c: 2000         	movs	r0, #0x0
 8009f4e: f010 f991    	bl	0x801a274 <z_log_msg_runtime_create> @ imm = #0x10322
 8009f52: 2300         	movs	r3, #0x0
 8009f54: 633b         	str	r3, [r7, #0x30]
; 		return r;
 8009f56: 6cbb         	ldr	r3, [r7, #0x48]
 8009f58: e07d         	b	0x800a056 <pwm_stm32_init+0x20e> @ imm = #0xfa
; 	(void)reset_line_toggle_dt(&data->reset);
 8009f5a: 6d7b         	ldr	r3, [r7, #0x54]
 8009f5c: 3304         	adds	r3, #0x4
 8009f5e: 4618         	mov	r0, r3
 8009f60: f010 f93c    	bl	0x801a1dc <reset_line_toggle_dt> @ imm = #0x10278
; 	r = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
 8009f64: 6d3b         	ldr	r3, [r7, #0x50]
 8009f66: 695b         	ldr	r3, [r3, #0x14]
 8009f68: 2100         	movs	r1, #0x0
 8009f6a: 4618         	mov	r0, r3
 8009f6c: f010 f900    	bl	0x801a170 <pinctrl_apply_state> @ imm = #0x10200
 8009f70: 64b8         	str	r0, [r7, #0x48]
; 	if (r < 0) {
 8009f72: 6cbb         	ldr	r3, [r7, #0x48]
 8009f74: 2b00         	cmp	r3, #0x0
 8009f76: da1f         	bge	0x8009fb8 <pwm_stm32_init+0x170> @ imm = #0x3e
; 		LOG_ERR("PWM pinctrl setup failed (%d)", r);
 8009f78: 2303         	movs	r3, #0x3
 8009f7a: 2b00         	cmp	r3, #0x0
 8009f7c: d01a         	beq	0x8009fb4 <pwm_stm32_init+0x16c> @ imm = #0x34
 8009f7e: 2301         	movs	r3, #0x1
 8009f80: f887 303f    	strb.w	r3, [r7, #0x3f]
 8009f84: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8009f88: f083 0301    	eor	r3, r3, #0x1
 8009f8c: b2db         	uxtb	r3, r3
 8009f8e: 2b00         	cmp	r3, #0x0
 8009f90: d110         	bne	0x8009fb4 <pwm_stm32_init+0x16c> @ imm = #0x20
 8009f92: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x800a064 <pwm_stm32_init+0x21c>
 8009f94: 6819         	ldr	r1, [r3]
 8009f96: 6cbb         	ldr	r3, [r7, #0x48]
 8009f98: 9303         	str	r3, [sp, #0xc]
 8009f9a: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800a074 <pwm_stm32_init+0x22c>
 8009f9c: 9302         	str	r3, [sp, #0x8]
 8009f9e: 2300         	movs	r3, #0x0
 8009fa0: 9301         	str	r3, [sp, #0x4]
 8009fa2: 2300         	movs	r3, #0x0
 8009fa4: 9300         	str	r3, [sp]
 8009fa6: 2300         	movs	r3, #0x0
 8009fa8: 2201         	movs	r2, #0x1
 8009faa: 2000         	movs	r0, #0x0
 8009fac: f010 f962    	bl	0x801a274 <z_log_msg_runtime_create> @ imm = #0x102c4
 8009fb0: 2300         	movs	r3, #0x0
 8009fb2: 63bb         	str	r3, [r7, #0x38]
; 		return r;
 8009fb4: 6cbb         	ldr	r3, [r7, #0x48]
 8009fb6: e04e         	b	0x800a056 <pwm_stm32_init+0x20e> @ imm = #0x9c
; 	LL_TIM_StructInit(&init);
 8009fb8: f107 030c    	add.w	r3, r7, #0xc
 8009fbc: 4618         	mov	r0, r3
 8009fbe: f013 ff53    	bl	0x801de68 <LL_TIM_StructInit> @ imm = #0x13ea6
; 	init.Prescaler = cfg->prescaler;
 8009fc2: 6d3b         	ldr	r3, [r7, #0x50]
 8009fc4: 685b         	ldr	r3, [r3, #0x4]
 8009fc6: b29b         	uxth	r3, r3
 8009fc8: 81bb         	strh	r3, [r7, #0xc]
; 	init.CounterMode = cfg->countermode;
 8009fca: 6d3b         	ldr	r3, [r7, #0x50]
 8009fcc: 689b         	ldr	r3, [r3, #0x8]
 8009fce: 613b         	str	r3, [r7, #0x10]
; 	init.Autoreload = 0u;
 8009fd0: 2300         	movs	r3, #0x0
 8009fd2: 617b         	str	r3, [r7, #0x14]
; 	init.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
 8009fd4: 2300         	movs	r3, #0x0
 8009fd6: 61bb         	str	r3, [r7, #0x18]
; 	if (LL_TIM_Init(cfg->timer, &init) != SUCCESS) {
 8009fd8: 6d3b         	ldr	r3, [r7, #0x50]
 8009fda: 681b         	ldr	r3, [r3]
 8009fdc: f107 020c    	add.w	r2, r7, #0xc
 8009fe0: 4611         	mov	r1, r2
 8009fe2: 4618         	mov	r0, r3
 8009fe4: f004 fe98    	bl	0x800ed18 <LL_TIM_Init> @ imm = #0x4d30
 8009fe8: 4603         	mov	r3, r0
 8009fea: 2b00         	cmp	r3, #0x0
 8009fec: d01e         	beq	0x800a02c <pwm_stm32_init+0x1e4> @ imm = #0x3c
; 		LOG_ERR("Could not initialize timer");
 8009fee: 2303         	movs	r3, #0x3
 8009ff0: 2b00         	cmp	r3, #0x0
 8009ff2: d018         	beq	0x800a026 <pwm_stm32_init+0x1de> @ imm = #0x30
 8009ff4: 2301         	movs	r3, #0x1
 8009ff6: f887 3047    	strb.w	r3, [r7, #0x47]
 8009ffa: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8009ffe: f083 0301    	eor	r3, r3, #0x1
 800a002: b2db         	uxtb	r3, r3
 800a004: 2b00         	cmp	r3, #0x0
 800a006: d10e         	bne	0x800a026 <pwm_stm32_init+0x1de> @ imm = #0x1c
 800a008: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800a064 <pwm_stm32_init+0x21c>
 800a00a: 6819         	ldr	r1, [r3]
 800a00c: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800a078 <pwm_stm32_init+0x230>
 800a00e: 9302         	str	r3, [sp, #0x8]
 800a010: 2300         	movs	r3, #0x0
 800a012: 9301         	str	r3, [sp, #0x4]
 800a014: 2300         	movs	r3, #0x0
 800a016: 9300         	str	r3, [sp]
 800a018: 2300         	movs	r3, #0x0
 800a01a: 2201         	movs	r2, #0x1
 800a01c: 2000         	movs	r0, #0x0
 800a01e: f010 f929    	bl	0x801a274 <z_log_msg_runtime_create> @ imm = #0x10252
 800a022: 2300         	movs	r3, #0x0
 800a024: 643b         	str	r3, [r7, #0x40]
; 		return -EIO;
 800a026: f06f 0304    	mvn	r3, #0x4
 800a02a: e014         	b	0x800a056 <pwm_stm32_init+0x20e> @ imm = #0x28
; 	if (IS_TIM_BREAK_INSTANCE(cfg->timer)) {
 800a02c: 6d3b         	ldr	r3, [r7, #0x50]
 800a02e: 681b         	ldr	r3, [r3]
 800a030: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800a07c <pwm_stm32_init+0x234>
 800a032: 4293         	cmp	r3, r2
 800a034: d004         	beq	0x800a040 <pwm_stm32_init+0x1f8> @ imm = #0x8
 800a036: 6d3b         	ldr	r3, [r7, #0x50]
 800a038: 681b         	ldr	r3, [r3]
 800a03a: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800a080 <pwm_stm32_init+0x238>
 800a03c: 4293         	cmp	r3, r2
 800a03e: d104         	bne	0x800a04a <pwm_stm32_init+0x202> @ imm = #0x8
; 		LL_TIM_EnableAllOutputs(cfg->timer);
 800a040: 6d3b         	ldr	r3, [r7, #0x50]
 800a042: 681b         	ldr	r3, [r3]
 800a044: 4618         	mov	r0, r3
 800a046: f010 f853    	bl	0x801a0f0 <LL_TIM_EnableAllOutputs> @ imm = #0x100a6
; 	LL_TIM_EnableCounter(cfg->timer);
 800a04a: 6d3b         	ldr	r3, [r7, #0x50]
 800a04c: 681b         	ldr	r3, [r3]
 800a04e: 4618         	mov	r0, r3
 800a050: f00f ffc1    	bl	0x8019fd6 <LL_TIM_EnableCounter> @ imm = #0xff82
; 	return 0;
 800a054: 2300         	movs	r3, #0x0
; }
 800a056: 4618         	mov	r0, r3
 800a058: 3758         	adds	r7, #0x58
 800a05a: 46bd         	mov	sp, r7
 800a05c: bd80         	pop	{r7, pc}
 800a05e: bf00         	nop

0800a060 <$d>:
 800a060: 80 01 02 08  	.word	0x08020180
 800a064: 54 05 00 20  	.word	0x20000554
 800a068: 10 15 02 08  	.word	0x08021510
 800a06c: 30 15 02 08  	.word	0x08021530
 800a070: 50 15 02 08  	.word	0x08021550
 800a074: 74 15 02 08  	.word	0x08021574
 800a078: 94 15 02 08  	.word	0x08021594
 800a07c: 00 00 01 40  	.word	0x40010000
 800a080: 00 04 01 40  	.word	0x40010400

0800a084 <bmi08x_bus_init_spi>:
; {
 800a084: b580         	push	{r7, lr}
 800a086: b08a         	sub	sp, #0x28
 800a088: af04         	add	r7, sp, #0x10
 800a08a: 6078         	str	r0, [r7, #0x4]
; 	ret = bmi08x_accel_byte_read(dev, 0x7F, &val);
 800a08c: f107 030b    	add.w	r3, r7, #0xb
 800a090: 461a         	mov	r2, r3
 800a092: 217f         	movs	r1, #0x7f
 800a094: 6878         	ldr	r0, [r7, #0x4]
 800a096: f010 fbdb    	bl	0x801a850 <bmi08x_accel_byte_read> @ imm = #0x107b6
 800a09a: 6178         	str	r0, [r7, #0x14]
; 	if (ret < 0) {
 800a09c: 697b         	ldr	r3, [r7, #0x14]
 800a09e: 2b00         	cmp	r3, #0x0
 800a0a0: da1b         	bge	0x800a0da <bmi08x_bus_init_spi+0x56> @ imm = #0x36
; 		LOG_ERR("Cannot read from 0x7F..");
 800a0a2: 2303         	movs	r3, #0x3
 800a0a4: 2b00         	cmp	r3, #0x0
 800a0a6: d016         	beq	0x800a0d6 <bmi08x_bus_init_spi+0x52> @ imm = #0x2c
 800a0a8: 2301         	movs	r3, #0x1
 800a0aa: 74fb         	strb	r3, [r7, #0x13]
 800a0ac: 7cfb         	ldrb	r3, [r7, #0x13]
 800a0ae: f083 0301    	eor	r3, r3, #0x1
 800a0b2: b2db         	uxtb	r3, r3
 800a0b4: 2b00         	cmp	r3, #0x0
 800a0b6: d10e         	bne	0x800a0d6 <bmi08x_bus_init_spi+0x52> @ imm = #0x1c
 800a0b8: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800a0ec <bmi08x_bus_init_spi+0x68>
 800a0ba: 6819         	ldr	r1, [r3]
 800a0bc: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800a0f0 <bmi08x_bus_init_spi+0x6c>
 800a0be: 9302         	str	r3, [sp, #0x8]
 800a0c0: 2300         	movs	r3, #0x0
 800a0c2: 9301         	str	r3, [sp, #0x4]
 800a0c4: 2300         	movs	r3, #0x0
 800a0c6: 9300         	str	r3, [sp]
 800a0c8: 2300         	movs	r3, #0x0
 800a0ca: 2201         	movs	r2, #0x1
 800a0cc: 2000         	movs	r0, #0x0
 800a0ce: f010 fa31    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0x10462
 800a0d2: 2300         	movs	r3, #0x0
 800a0d4: 60fb         	str	r3, [r7, #0xc]
; 		return ret;
 800a0d6: 697b         	ldr	r3, [r7, #0x14]
 800a0d8: e003         	b	0x800a0e2 <bmi08x_bus_init_spi+0x5e> @ imm = #0x6
; 	k_usleep(100);
 800a0da: 2064         	movs	r0, #0x64
 800a0dc: f010 fa0a    	bl	0x801a4f4 <k_usleep>    @ imm = #0x10414
; 	return ret;
 800a0e0: 697b         	ldr	r3, [r7, #0x14]
; }
 800a0e2: 4618         	mov	r0, r3
 800a0e4: 3718         	adds	r7, #0x18
 800a0e6: 46bd         	mov	sp, r7
 800a0e8: bd80         	pop	{r7, pc}
 800a0ea: bf00         	nop

0800a0ec <$d>:
 800a0ec: 64 05 00 20  	.word	0x20000564
 800a0f0: d8 15 02 08  	.word	0x080215d8

0800a0f4 <bmi08x_acc_range_set>:
; {
 800a0f4: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800a0f8: b086         	sub	sp, #0x18
 800a0fa: af00         	add	r7, sp, #0x0
 800a0fc: 6078         	str	r0, [r7, #0x4]
 800a0fe: 6039         	str	r1, [r7]
; 	struct bmi08x_accel_data *data = dev->data;
 800a100: 687b         	ldr	r3, [r7, #0x4]
 800a102: 691b         	ldr	r3, [r3, #0x10]
 800a104: 613b         	str	r3, [r7, #0x10]
; 	int32_t reg_val = -1;
 800a106: f04f 33ff    	mov.w	r3, #0xffffffff
 800a10a: 617b         	str	r3, [r7, #0x14]
; 	if (data->accel_chip_id == BMI085_ACCEL_CHIP_ID) {
 800a10c: 693b         	ldr	r3, [r7, #0x10]
 800a10e: f893 3948    	ldrb.w	r3, [r3, #0x948]
 800a112: 2b1f         	cmp	r3, #0x1f
 800a114: d108         	bne	0x800a128 <bmi08x_acc_range_set+0x34> @ imm = #0x10
; 		reg_val = bmi08x_range_to_reg_val(range, bmi085_acc_range_map,
 800a116: 683b         	ldr	r3, [r7]
 800a118: b29b         	uxth	r3, r3
 800a11a: 2204         	movs	r2, #0x4
 800a11c: 492b         	ldr	r1, [pc, #0xac]         @ 0x800a1cc <bmi08x_acc_range_set+0xd8>
 800a11e: 4618         	mov	r0, r3
 800a120: f010 ff0a    	bl	0x801af38 <bmi08x_range_to_reg_val> @ imm = #0x10e14
 800a124: 6178         	str	r0, [r7, #0x14]
 800a126: e010         	b	0x800a14a <bmi08x_acc_range_set+0x56> @ imm = #0x20
; 	} else if (data->accel_chip_id == BMI088_ACCEL_CHIP_ID) {
 800a128: 693b         	ldr	r3, [r7, #0x10]
 800a12a: f893 3948    	ldrb.w	r3, [r3, #0x948]
 800a12e: 2b1e         	cmp	r3, #0x1e
 800a130: d108         	bne	0x800a144 <bmi08x_acc_range_set+0x50> @ imm = #0x10
; 		reg_val = bmi08x_range_to_reg_val(range, bmi088_acc_range_map,
 800a132: 683b         	ldr	r3, [r7]
 800a134: b29b         	uxth	r3, r3
 800a136: 2204         	movs	r2, #0x4
 800a138: 4925         	ldr	r1, [pc, #0x94]         @ 0x800a1d0 <bmi08x_acc_range_set+0xdc>
 800a13a: 4618         	mov	r0, r3
 800a13c: f010 fefc    	bl	0x801af38 <bmi08x_range_to_reg_val> @ imm = #0x10df8
 800a140: 6178         	str	r0, [r7, #0x14]
 800a142: e002         	b	0x800a14a <bmi08x_acc_range_set+0x56> @ imm = #0x4
; 		return -ENODEV;
 800a144: f06f 0312    	mvn	r3, #0x12
 800a148: e03b         	b	0x800a1c2 <bmi08x_acc_range_set+0xce> @ imm = #0x76
; 	if (reg_val < 0) {
 800a14a: 697b         	ldr	r3, [r7, #0x14]
 800a14c: 2b00         	cmp	r3, #0x0
 800a14e: da01         	bge	0x800a154 <bmi08x_acc_range_set+0x60> @ imm = #0x2
; 		return reg_val;
 800a150: 697b         	ldr	r3, [r7, #0x14]
 800a152: e036         	b	0x800a1c2 <bmi08x_acc_range_set+0xce> @ imm = #0x6c
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_RANGE, reg_val & 0xff);
 800a154: 697b         	ldr	r3, [r7, #0x14]
 800a156: b2db         	uxtb	r3, r3
 800a158: 461a         	mov	r2, r3
 800a15a: 2141         	movs	r1, #0x41
 800a15c: 6878         	ldr	r0, [r7, #0x4]
 800a15e: f010 fbaf    	bl	0x801a8c0 <bmi08x_accel_byte_write> @ imm = #0x1075e
 800a162: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 800a164: 68fb         	ldr	r3, [r7, #0xc]
 800a166: 2b00         	cmp	r3, #0x0
 800a168: da01         	bge	0x800a16e <bmi08x_acc_range_set+0x7a> @ imm = #0x2
; 		return ret;
 800a16a: 68fb         	ldr	r3, [r7, #0xc]
 800a16c: e029         	b	0x800a1c2 <bmi08x_acc_range_set+0xce> @ imm = #0x52
; 	data->scale = BMI08X_ACC_SCALE(range);
 800a16e: 683b         	ldr	r3, [r7]
 800a170: 17da         	asrs	r2, r3, #0x1f
 800a172: 4698         	mov	r8, r3
 800a174: 4691         	mov	r9, r2
 800a176: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800a1d4 <bmi08x_acc_range_set+0xe0>
 800a178: fb03 f209    	mul	r2, r3, r9
 800a17c: 2300         	movs	r3, #0x0
 800a17e: fb03 f308    	mul	r3, r3, r8
 800a182: 4413         	add	r3, r2
 800a184: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800a1d4 <bmi08x_acc_range_set+0xe0>
 800a186: fba8 4502    	umull	r4, r5, r8, r2
 800a18a: 442b         	add	r3, r5
 800a18c: 461d         	mov	r5, r3
 800a18e: 4622         	mov	r2, r4
 800a190: 462b         	mov	r3, r5
 800a192: 2b00         	cmp	r3, #0x0
 800a194: da07         	bge	0x800a1a6 <bmi08x_acc_range_set+0xb2> @ imm = #0xe
 800a196: f64f 71ff    	movw	r1, #0xffff
 800a19a: eb12 0a01    	adds.w	r10, r2, r1
 800a19e: f143 0b00    	adc	r11, r3, #0x0
 800a1a2: 4652         	mov	r2, r10
 800a1a4: 465b         	mov	r3, r11
 800a1a6: f04f 0000    	mov.w	r0, #0x0
 800a1aa: f04f 0100    	mov.w	r1, #0x0
 800a1ae: 0c10         	lsrs	r0, r2, #0x10
 800a1b0: ea40 4003    	orr.w	r0, r0, r3, lsl #16
 800a1b4: 1419         	asrs	r1, r3, #0x10
 800a1b6: 4602         	mov	r2, r0
 800a1b8: 460b         	mov	r3, r1
 800a1ba: b292         	uxth	r2, r2
 800a1bc: 693b         	ldr	r3, [r7, #0x10]
 800a1be: 825a         	strh	r2, [r3, #0x12]
; 	return ret;
 800a1c0: 68fb         	ldr	r3, [r7, #0xc]
; }
 800a1c2: 4618         	mov	r0, r3
 800a1c4: 3718         	adds	r7, #0x18
 800a1c6: 46bd         	mov	sp, r7
 800a1c8: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800a1cc <$d>:
 800a1cc: 18 2a 02 08  	.word	0x08022a18
 800a1d0: 28 2a 02 08  	.word	0x08022a28
 800a1d4: 74 46 2b 01  	.word	0x012b4674

0800a1d8 <bmi08x_acc_config>:
; {
 800a1d8: b580         	push	{r7, lr}
 800a1da: b08a         	sub	sp, #0x28
 800a1dc: af04         	add	r7, sp, #0x10
 800a1de: 60f8         	str	r0, [r7, #0xc]
 800a1e0: 607b         	str	r3, [r7, #0x4]
 800a1e2: 460b         	mov	r3, r1
 800a1e4: 817b         	strh	r3, [r7, #0xa]
 800a1e6: 4613         	mov	r3, r2
 800a1e8: 813b         	strh	r3, [r7, #0x8]
; 	switch (attr) {
 800a1ea: 893b         	ldrh	r3, [r7, #0x8]
 800a1ec: 2b00         	cmp	r3, #0x0
 800a1ee: d00b         	beq	0x800a208 <bmi08x_acc_config+0x30> @ imm = #0x16
 800a1f0: 2b07         	cmp	r3, #0x7
 800a1f2: d11b         	bne	0x800a22c <bmi08x_acc_config+0x54> @ imm = #0x36
; 		return bmi08x_acc_range_set(dev, sensor_ms2_to_g(val));
 800a1f4: 6878         	ldr	r0, [r7, #0x4]
 800a1f6: f7f6 ff7f    	bl	0x80010f8 <sensor_ms2_to_g> @ imm = #-0x9102
 800a1fa: 4603         	mov	r3, r0
 800a1fc: 4619         	mov	r1, r3
 800a1fe: 68f8         	ldr	r0, [r7, #0xc]
 800a200: f7ff ff78    	bl	0x800a0f4 <bmi08x_acc_range_set> @ imm = #-0x110
 800a204: 4603         	mov	r3, r0
 800a206: e02f         	b	0x800a268 <bmi08x_acc_config+0x90> @ imm = #0x5e
; 		return bmi08x_acc_odr_set(dev, val->val1, val->val2 / 1000);
 800a208: 687b         	ldr	r3, [r7, #0x4]
 800a20a: 681b         	ldr	r3, [r3]
 800a20c: b299         	uxth	r1, r3
 800a20e: 687b         	ldr	r3, [r7, #0x4]
 800a210: 685b         	ldr	r3, [r3, #0x4]
 800a212: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800a270 <bmi08x_acc_config+0x98>
 800a214: fb82 0203    	smull	r0, r2, r2, r3
 800a218: 1192         	asrs	r2, r2, #0x6
 800a21a: 17db         	asrs	r3, r3, #0x1f
 800a21c: 1ad3         	subs	r3, r2, r3
 800a21e: b29b         	uxth	r3, r3
 800a220: 461a         	mov	r2, r3
 800a222: 68f8         	ldr	r0, [r7, #0xc]
 800a224: f010 fb9c    	bl	0x801a960 <bmi08x_acc_odr_set> @ imm = #0x10738
 800a228: 4603         	mov	r3, r0
 800a22a: e01d         	b	0x800a268 <bmi08x_acc_config+0x90> @ imm = #0x3a
; 		LOG_DBG("Accel attribute not supported.");
 800a22c: 2303         	movs	r3, #0x3
 800a22e: 2b03         	cmp	r3, #0x3
 800a230: d918         	bls	0x800a264 <bmi08x_acc_config+0x8c> @ imm = #0x30
 800a232: 2301         	movs	r3, #0x1
 800a234: 75fb         	strb	r3, [r7, #0x17]
 800a236: 7dfb         	ldrb	r3, [r7, #0x17]
 800a238: f083 0301    	eor	r3, r3, #0x1
 800a23c: b2db         	uxtb	r3, r3
 800a23e: 2b00         	cmp	r3, #0x0
 800a240: d110         	bne	0x800a264 <bmi08x_acc_config+0x8c> @ imm = #0x20
 800a242: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800a274 <bmi08x_acc_config+0x9c>
 800a244: 6819         	ldr	r1, [r3]
 800a246: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800a278 <bmi08x_acc_config+0xa0>
 800a248: 9303         	str	r3, [sp, #0xc]
 800a24a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800a27c <bmi08x_acc_config+0xa4>
 800a24c: 9302         	str	r3, [sp, #0x8]
 800a24e: 2308         	movs	r3, #0x8
 800a250: 9301         	str	r3, [sp, #0x4]
 800a252: 2300         	movs	r3, #0x0
 800a254: 9300         	str	r3, [sp]
 800a256: 2300         	movs	r3, #0x0
 800a258: 2204         	movs	r2, #0x4
 800a25a: 2000         	movs	r0, #0x0
 800a25c: f010 f96a    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0x102d4
 800a260: 2300         	movs	r3, #0x0
 800a262: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800a264: f06f 0385    	mvn	r3, #0x85
; }
 800a268: 4618         	mov	r0, r3
 800a26a: 3718         	adds	r7, #0x18
 800a26c: 46bd         	mov	sp, r7
 800a26e: bd80         	pop	{r7, pc}

0800a270 <$d>:
 800a270: d3 4d 62 10  	.word	0x10624dd3
 800a274: 64 05 00 20  	.word	0x20000564
 800a278: 64 2a 02 08  	.word	0x08022a64
 800a27c: f0 15 02 08  	.word	0x080215f0

0800a280 <bmi08x_attr_set>:
; {
 800a280: b580         	push	{r7, lr}
 800a282: b08a         	sub	sp, #0x28
 800a284: af04         	add	r7, sp, #0x10
 800a286: 60f8         	str	r0, [r7, #0xc]
 800a288: 607b         	str	r3, [r7, #0x4]
 800a28a: 460b         	mov	r3, r1
 800a28c: 817b         	strh	r3, [r7, #0xa]
 800a28e: 4613         	mov	r3, r2
 800a290: 813b         	strh	r3, [r7, #0x8]
; 	switch (chan) {
 800a292: 897b         	ldrh	r3, [r7, #0xa]
 800a294: 2b03         	cmp	r3, #0x3
 800a296: d807         	bhi	0x800a2a8 <bmi08x_attr_set+0x28> @ imm = #0xe
; 		return bmi08x_acc_config(dev, chan, attr, val);
 800a298: 893a         	ldrh	r2, [r7, #0x8]
 800a29a: 8979         	ldrh	r1, [r7, #0xa]
 800a29c: 687b         	ldr	r3, [r7, #0x4]
 800a29e: 68f8         	ldr	r0, [r7, #0xc]
 800a2a0: f7ff ff9a    	bl	0x800a1d8 <bmi08x_acc_config> @ imm = #-0xcc
 800a2a4: 4603         	mov	r3, r0
 800a2a6: e01d         	b	0x800a2e4 <bmi08x_attr_set+0x64> @ imm = #0x3a
; 		LOG_DBG("attr_set() not supported on this channel.");
 800a2a8: 2303         	movs	r3, #0x3
 800a2aa: 2b03         	cmp	r3, #0x3
 800a2ac: d918         	bls	0x800a2e0 <bmi08x_attr_set+0x60> @ imm = #0x30
 800a2ae: 2301         	movs	r3, #0x1
 800a2b0: 75fb         	strb	r3, [r7, #0x17]
 800a2b2: 7dfb         	ldrb	r3, [r7, #0x17]
 800a2b4: f083 0301    	eor	r3, r3, #0x1
 800a2b8: b2db         	uxtb	r3, r3
 800a2ba: 2b00         	cmp	r3, #0x0
 800a2bc: d110         	bne	0x800a2e0 <bmi08x_attr_set+0x60> @ imm = #0x20
 800a2be: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800a2ec <bmi08x_attr_set+0x6c>
 800a2c0: 6819         	ldr	r1, [r3]
 800a2c2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800a2f0 <bmi08x_attr_set+0x70>
 800a2c4: 9303         	str	r3, [sp, #0xc]
 800a2c6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800a2f4 <bmi08x_attr_set+0x74>
 800a2c8: 9302         	str	r3, [sp, #0x8]
 800a2ca: 2308         	movs	r3, #0x8
 800a2cc: 9301         	str	r3, [sp, #0x4]
 800a2ce: 2300         	movs	r3, #0x0
 800a2d0: 9300         	str	r3, [sp]
 800a2d2: 2300         	movs	r3, #0x0
 800a2d4: 2204         	movs	r2, #0x4
 800a2d6: 2000         	movs	r0, #0x0
 800a2d8: f010 f92c    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0x10258
 800a2dc: 2300         	movs	r3, #0x0
 800a2de: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800a2e0: f06f 0385    	mvn	r3, #0x85
; }
 800a2e4: 4618         	mov	r0, r3
 800a2e6: 3718         	adds	r7, #0x18
 800a2e8: 46bd         	mov	sp, r7
 800a2ea: bd80         	pop	{r7, pc}

0800a2ec <$d>:
 800a2ec: 64 05 00 20  	.word	0x20000564
 800a2f0: 78 2a 02 08  	.word	0x08022a78
 800a2f4: 14 16 02 08  	.word	0x08021614

0800a2f8 <bmi08x_sample_fetch>:
; {
 800a2f8: b580         	push	{r7, lr}
 800a2fa: b08c         	sub	sp, #0x30
 800a2fc: af04         	add	r7, sp, #0x10
 800a2fe: 6078         	str	r0, [r7, #0x4]
 800a300: 460b         	mov	r3, r1
 800a302: 807b         	strh	r3, [r7, #0x2]
; 	struct bmi08x_accel_data *data = dev->data;
 800a304: 687b         	ldr	r3, [r7, #0x4]
 800a306: 691b         	ldr	r3, [r3, #0x10]
 800a308: 61bb         	str	r3, [r7, #0x18]
; 	if (chan != SENSOR_CHAN_ALL && chan != SENSOR_CHAN_ACCEL_XYZ) {
 800a30a: 887b         	ldrh	r3, [r7, #0x2]
 800a30c: 2b3c         	cmp	r3, #0x3c
 800a30e: d021         	beq	0x800a354 <bmi08x_sample_fetch+0x5c> @ imm = #0x42
 800a310: 887b         	ldrh	r3, [r7, #0x2]
 800a312: 2b03         	cmp	r3, #0x3
 800a314: d01e         	beq	0x800a354 <bmi08x_sample_fetch+0x5c> @ imm = #0x3c
; 		LOG_DBG("Unsupported sensor channel");
 800a316: 2303         	movs	r3, #0x3
 800a318: 2b03         	cmp	r3, #0x3
 800a31a: d918         	bls	0x800a34e <bmi08x_sample_fetch+0x56> @ imm = #0x30
 800a31c: 2301         	movs	r3, #0x1
 800a31e: 75fb         	strb	r3, [r7, #0x17]
 800a320: 7dfb         	ldrb	r3, [r7, #0x17]
 800a322: f083 0301    	eor	r3, r3, #0x1
 800a326: b2db         	uxtb	r3, r3
 800a328: 2b00         	cmp	r3, #0x0
 800a32a: d110         	bne	0x800a34e <bmi08x_sample_fetch+0x56> @ imm = #0x20
 800a32c: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800a3b8 <bmi08x_sample_fetch+0xc0>
 800a32e: 6819         	ldr	r1, [r3]
 800a330: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800a3bc <bmi08x_sample_fetch+0xc4>
 800a332: 9303         	str	r3, [sp, #0xc]
 800a334: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800a3c0 <bmi08x_sample_fetch+0xc8>
 800a336: 9302         	str	r3, [sp, #0x8]
 800a338: 2308         	movs	r3, #0x8
 800a33a: 9301         	str	r3, [sp, #0x4]
 800a33c: 2300         	movs	r3, #0x0
 800a33e: 9300         	str	r3, [sp]
 800a340: 2300         	movs	r3, #0x0
 800a342: 2204         	movs	r2, #0x4
 800a344: 2000         	movs	r0, #0x0
 800a346: f010 f8f5    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0x101ea
 800a34a: 2300         	movs	r3, #0x0
 800a34c: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800a34e: f06f 0385    	mvn	r3, #0x85
 800a352: e02d         	b	0x800a3b0 <bmi08x_sample_fetch+0xb8> @ imm = #0x5a
; 	pm_device_busy_set(dev);
 800a354: 6878         	ldr	r0, [r7, #0x4]
 800a356: f010 f8d9    	bl	0x801a50c <pm_device_busy_set> @ imm = #0x101b2
; 	ret = bmi08x_accel_read(dev, BMI08X_REG_ACCEL_X_LSB, (uint8_t *)data->acc_sample,
 800a35a: 69bb         	ldr	r3, [r7, #0x18]
 800a35c: f103 020c    	add.w	r2, r3, #0xc
 800a360: 2306         	movs	r3, #0x6
 800a362: 2112         	movs	r1, #0x12
 800a364: 6878         	ldr	r0, [r7, #0x4]
 800a366: f010 fa59    	bl	0x801a81c <bmi08x_accel_read> @ imm = #0x104b2
 800a36a: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 800a36c: 68fb         	ldr	r3, [r7, #0xc]
 800a36e: 2b00         	cmp	r3, #0x0
 800a370: da04         	bge	0x800a37c <bmi08x_sample_fetch+0x84> @ imm = #0x8
; 		pm_device_busy_clear(dev);
 800a372: 6878         	ldr	r0, [r7, #0x4]
 800a374: f010 f8d4    	bl	0x801a520 <pm_device_busy_clear> @ imm = #0x101a8
; 		return ret;
 800a378: 68fb         	ldr	r3, [r7, #0xc]
 800a37a: e019         	b	0x800a3b0 <bmi08x_sample_fetch+0xb8> @ imm = #0x32
; 	for (i = 0; i < ARRAY_SIZE(data->acc_sample); i++) {
 800a37c: 2300         	movs	r3, #0x0
 800a37e: 61fb         	str	r3, [r7, #0x1c]
 800a380: e00f         	b	0x800a3a2 <bmi08x_sample_fetch+0xaa> @ imm = #0x1e
; 		data->acc_sample[i] = sys_le16_to_cpu(data->acc_sample[i]);
 800a382: 69ba         	ldr	r2, [r7, #0x18]
 800a384: 69fb         	ldr	r3, [r7, #0x1c]
 800a386: 3304         	adds	r3, #0x4
 800a388: 005b         	lsls	r3, r3, #0x1
 800a38a: 4413         	add	r3, r2
 800a38c: 8899         	ldrh	r1, [r3, #0x4]
 800a38e: 69ba         	ldr	r2, [r7, #0x18]
 800a390: 69fb         	ldr	r3, [r7, #0x1c]
 800a392: 3304         	adds	r3, #0x4
 800a394: 005b         	lsls	r3, r3, #0x1
 800a396: 4413         	add	r3, r2
 800a398: 460a         	mov	r2, r1
 800a39a: 809a         	strh	r2, [r3, #0x4]
; 	for (i = 0; i < ARRAY_SIZE(data->acc_sample); i++) {
 800a39c: 69fb         	ldr	r3, [r7, #0x1c]
 800a39e: 3301         	adds	r3, #0x1
 800a3a0: 61fb         	str	r3, [r7, #0x1c]
 800a3a2: 69fb         	ldr	r3, [r7, #0x1c]
 800a3a4: 2b02         	cmp	r3, #0x2
 800a3a6: d9ec         	bls	0x800a382 <bmi08x_sample_fetch+0x8a> @ imm = #-0x28
; 	pm_device_busy_clear(dev);
 800a3a8: 6878         	ldr	r0, [r7, #0x4]
 800a3aa: f010 f8b9    	bl	0x801a520 <pm_device_busy_clear> @ imm = #0x10172
; 	return ret;
 800a3ae: 68fb         	ldr	r3, [r7, #0xc]
; }
 800a3b0: 4618         	mov	r0, r3
 800a3b2: 3720         	adds	r7, #0x20
 800a3b4: 46bd         	mov	sp, r7
 800a3b6: bd80         	pop	{r7, pc}

0800a3b8 <$d>:
 800a3b8: 64 05 00 20  	.word	0x20000564
 800a3bc: 88 2a 02 08  	.word	0x08022a88
 800a3c0: 44 16 02 08  	.word	0x08021644

0800a3c4 <bmi08x_to_fixed_point>:
; {
 800a3c4: b480         	push	{r7}
 800a3c6: b085         	sub	sp, #0x14
 800a3c8: af00         	add	r7, sp, #0x0
 800a3ca: 4603         	mov	r3, r0
 800a3cc: 603a         	str	r2, [r7]
 800a3ce: 80fb         	strh	r3, [r7, #0x6]
 800a3d0: 460b         	mov	r3, r1
 800a3d2: 80bb         	strh	r3, [r7, #0x4]
; 	converted_val = raw_val * scale;
 800a3d4: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 800a3d8: 88ba         	ldrh	r2, [r7, #0x4]
 800a3da: fb02 f303    	mul	r3, r2, r3
 800a3de: 60fb         	str	r3, [r7, #0xc]
; 	val->val1 = converted_val / 1000000;
 800a3e0: 68fb         	ldr	r3, [r7, #0xc]
 800a3e2: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800a418 <bmi08x_to_fixed_point+0x54>
 800a3e4: fb82 1203    	smull	r1, r2, r2, r3
 800a3e8: 1492         	asrs	r2, r2, #0x12
 800a3ea: 17db         	asrs	r3, r3, #0x1f
 800a3ec: 1ad2         	subs	r2, r2, r3
 800a3ee: 683b         	ldr	r3, [r7]
 800a3f0: 601a         	str	r2, [r3]
; 	val->val2 = converted_val % 1000000;
 800a3f2: 68fa         	ldr	r2, [r7, #0xc]
 800a3f4: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800a418 <bmi08x_to_fixed_point+0x54>
 800a3f6: fb83 1302    	smull	r1, r3, r3, r2
 800a3fa: 1499         	asrs	r1, r3, #0x12
 800a3fc: 17d3         	asrs	r3, r2, #0x1f
 800a3fe: 1acb         	subs	r3, r1, r3
 800a400: 4906         	ldr	r1, [pc, #0x18]         @ 0x800a41c <bmi08x_to_fixed_point+0x58>
 800a402: fb01 f303    	mul	r3, r1, r3
 800a406: 1ad3         	subs	r3, r2, r3
 800a408: 683a         	ldr	r2, [r7]
 800a40a: 6053         	str	r3, [r2, #0x4]
; }
 800a40c: bf00         	nop
 800a40e: 3714         	adds	r7, #0x14
 800a410: 46bd         	mov	sp, r7
 800a412: f85d 7b04    	ldr	r7, [sp], #4
 800a416: 4770         	bx	lr

0800a418 <$d>:
 800a418: 83 de 1b 43  	.word	0x431bde83
 800a41c: 40 42 0f 00  	.word	0x000f4240

0800a420 <bmi08x_temp_channel_get>:
; {
 800a420: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800a424: b090         	sub	sp, #0x40
 800a426: af04         	add	r7, sp, #0x10
 800a428: 6078         	str	r0, [r7, #0x4]
 800a42a: 6039         	str	r1, [r7]
; 	uint16_t temp_raw = 0U;
 800a42c: 2300         	movs	r3, #0x0
 800a42e: 817b         	strh	r3, [r7, #0xa]
; 	int32_t temp_micro = 0;
 800a430: 2300         	movs	r3, #0x0
 800a432: 62bb         	str	r3, [r7, #0x28]
; 	int16_t temp_int11 = 0;
 800a434: 2300         	movs	r3, #0x0
 800a436: 85fb         	strh	r3, [r7, #0x2e]
; 	ret = bmi08x_accel_word_read(dev, BMI08X_REG_TEMP_MSB, &temp_raw);
 800a438: f107 030a    	add.w	r3, r7, #0xa
 800a43c: 461a         	mov	r2, r3
 800a43e: 2122         	movs	r1, #0x22
 800a440: 6878         	ldr	r0, [r7, #0x4]
 800a442: f010 fa1c    	bl	0x801a87e <bmi08x_accel_word_read> @ imm = #0x10438
 800a446: 6278         	str	r0, [r7, #0x24]
; 	if (!ret) {
 800a448: 6a7b         	ldr	r3, [r7, #0x24]
 800a44a: 2b00         	cmp	r3, #0x0
 800a44c: d109         	bne	0x800a462 <bmi08x_temp_channel_get+0x42> @ imm = #0x12
; 		temp_int11 = (temp_raw & 0xFF) << 3;
 800a44e: 897b         	ldrh	r3, [r7, #0xa]
 800a450: 00db         	lsls	r3, r3, #0x3
 800a452: b21b         	sxth	r3, r3
 800a454: f403 63ff    	and	r3, r3, #0x7f8
 800a458: 85fb         	strh	r3, [r7, #0x2e]
; 	if (temp_raw == 0x80) {
 800a45a: 897b         	ldrh	r3, [r7, #0xa]
 800a45c: 2b80         	cmp	r3, #0x80
 800a45e: d13d         	bne	0x800a4dc <bmi08x_temp_channel_get+0xbc> @ imm = #0x7a
 800a460: e01f         	b	0x800a4a2 <bmi08x_temp_channel_get+0x82> @ imm = #0x3e
; 		LOG_ERR("Error reading BMI08X_REG_TEMP_MSB. (err %d)", ret);
 800a462: 2303         	movs	r3, #0x3
 800a464: 2b00         	cmp	r3, #0x0
 800a466: d01a         	beq	0x800a49e <bmi08x_temp_channel_get+0x7e> @ imm = #0x34
 800a468: 2301         	movs	r3, #0x1
 800a46a: f887 3023    	strb.w	r3, [r7, #0x23]
 800a46e: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800a472: f083 0301    	eor	r3, r3, #0x1
 800a476: b2db         	uxtb	r3, r3
 800a478: 2b00         	cmp	r3, #0x0
 800a47a: d110         	bne	0x800a49e <bmi08x_temp_channel_get+0x7e> @ imm = #0x20
 800a47c: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800a5ac <bmi08x_temp_channel_get+0x18c>
 800a47e: 6819         	ldr	r1, [r3]
 800a480: 6a7b         	ldr	r3, [r7, #0x24]
 800a482: 9303         	str	r3, [sp, #0xc]
 800a484: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x800a5b0 <bmi08x_temp_channel_get+0x190>
 800a486: 9302         	str	r3, [sp, #0x8]
 800a488: 2300         	movs	r3, #0x0
 800a48a: 9301         	str	r3, [sp, #0x4]
 800a48c: 2300         	movs	r3, #0x0
 800a48e: 9300         	str	r3, [sp]
 800a490: 2300         	movs	r3, #0x0
 800a492: 2201         	movs	r2, #0x1
 800a494: 2000         	movs	r0, #0x0
 800a496: f010 f84d    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0x1009a
 800a49a: 2300         	movs	r3, #0x0
 800a49c: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 800a49e: 6a7b         	ldr	r3, [r7, #0x24]
 800a4a0: e07e         	b	0x800a5a0 <bmi08x_temp_channel_get+0x180> @ imm = #0xfc
; 		LOG_ERR("BMI08X returned invalid temperature.");
 800a4a2: 2303         	movs	r3, #0x3
 800a4a4: 2b00         	cmp	r3, #0x0
 800a4a6: d016         	beq	0x800a4d6 <bmi08x_temp_channel_get+0xb6> @ imm = #0x2c
 800a4a8: 2301         	movs	r3, #0x1
 800a4aa: 74fb         	strb	r3, [r7, #0x13]
 800a4ac: 7cfb         	ldrb	r3, [r7, #0x13]
 800a4ae: f083 0301    	eor	r3, r3, #0x1
 800a4b2: b2db         	uxtb	r3, r3
 800a4b4: 2b00         	cmp	r3, #0x0
 800a4b6: d10e         	bne	0x800a4d6 <bmi08x_temp_channel_get+0xb6> @ imm = #0x1c
 800a4b8: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x800a5ac <bmi08x_temp_channel_get+0x18c>
 800a4ba: 6819         	ldr	r1, [r3]
 800a4bc: 4b3d         	ldr	r3, [pc, #0xf4]         @ 0x800a5b4 <bmi08x_temp_channel_get+0x194>
 800a4be: 9302         	str	r3, [sp, #0x8]
 800a4c0: 2300         	movs	r3, #0x0
 800a4c2: 9301         	str	r3, [sp, #0x4]
 800a4c4: 2300         	movs	r3, #0x0
 800a4c6: 9300         	str	r3, [sp]
 800a4c8: 2300         	movs	r3, #0x0
 800a4ca: 2201         	movs	r2, #0x1
 800a4cc: 2000         	movs	r0, #0x0
 800a4ce: f010 f831    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0x10062
 800a4d2: 2300         	movs	r3, #0x0
 800a4d4: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODATA;
 800a4d6: f06f 033c    	mvn	r3, #0x3c
 800a4da: e061         	b	0x800a5a0 <bmi08x_temp_channel_get+0x180> @ imm = #0xc2
; 	ret = bmi08x_accel_word_read(dev, BMI08X_REG_TEMP_LSB, &temp_raw);
 800a4dc: f107 030a    	add.w	r3, r7, #0xa
 800a4e0: 461a         	mov	r2, r3
 800a4e2: 2123         	movs	r1, #0x23
 800a4e4: 6878         	ldr	r0, [r7, #0x4]
 800a4e6: f010 f9ca    	bl	0x801a87e <bmi08x_accel_word_read> @ imm = #0x10394
 800a4ea: 6278         	str	r0, [r7, #0x24]
; 	if (!ret) {
 800a4ec: 6a7b         	ldr	r3, [r7, #0x24]
 800a4ee: 2b00         	cmp	r3, #0x0
 800a4f0: d10e         	bne	0x800a510 <bmi08x_temp_channel_get+0xf0> @ imm = #0x1c
; 		temp_int11 |= (temp_raw & 0xE0) >> 5;
 800a4f2: 897b         	ldrh	r3, [r7, #0xa]
 800a4f4: 115b         	asrs	r3, r3, #0x5
 800a4f6: b21b         	sxth	r3, r3
 800a4f8: f003 0307    	and	r3, r3, #0x7
 800a4fc: b21a         	sxth	r2, r3
 800a4fe: 8dfb         	ldrh	r3, [r7, #0x2e]
 800a500: 4313         	orrs	r3, r2
 800a502: 85fb         	strh	r3, [r7, #0x2e]
; 	if (temp_int11 > 1023) {
 800a504: f9b7 302e    	ldrsh.w	r3, [r7, #0x2e]
 800a508: f5b3 6f80    	cmp.w	r3, #0x400
 800a50c: db23         	blt	0x800a556 <bmi08x_temp_channel_get+0x136> @ imm = #0x46
 800a50e: e01d         	b	0x800a54c <bmi08x_temp_channel_get+0x12c> @ imm = #0x3a
; 		LOG_ERR("Error reading BMI08X_REG_TEMP_LSB. (err %d)", ret);
 800a510: 2303         	movs	r3, #0x3
 800a512: 2b00         	cmp	r3, #0x0
 800a514: d018         	beq	0x800a548 <bmi08x_temp_channel_get+0x128> @ imm = #0x30
 800a516: 2301         	movs	r3, #0x1
 800a518: 76fb         	strb	r3, [r7, #0x1b]
 800a51a: 7efb         	ldrb	r3, [r7, #0x1b]
 800a51c: f083 0301    	eor	r3, r3, #0x1
 800a520: b2db         	uxtb	r3, r3
 800a522: 2b00         	cmp	r3, #0x0
 800a524: d110         	bne	0x800a548 <bmi08x_temp_channel_get+0x128> @ imm = #0x20
 800a526: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800a5ac <bmi08x_temp_channel_get+0x18c>
 800a528: 6819         	ldr	r1, [r3]
 800a52a: 6a7b         	ldr	r3, [r7, #0x24]
 800a52c: 9303         	str	r3, [sp, #0xc]
 800a52e: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800a5b8 <bmi08x_temp_channel_get+0x198>
 800a530: 9302         	str	r3, [sp, #0x8]
 800a532: 2300         	movs	r3, #0x0
 800a534: 9301         	str	r3, [sp, #0x4]
 800a536: 2300         	movs	r3, #0x0
 800a538: 9300         	str	r3, [sp]
 800a53a: 2300         	movs	r3, #0x0
 800a53c: 2201         	movs	r2, #0x1
 800a53e: 2000         	movs	r0, #0x0
 800a540: f00f fff8    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfff0
 800a544: 2300         	movs	r3, #0x0
 800a546: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 800a548: 6a7b         	ldr	r3, [r7, #0x24]
 800a54a: e029         	b	0x800a5a0 <bmi08x_temp_channel_get+0x180> @ imm = #0x52
; 		temp_int11 -= 2048;
 800a54c: 8dfb         	ldrh	r3, [r7, #0x2e]
 800a54e: f5a3 6300    	sub.w	r3, r3, #0x800
 800a552: b29b         	uxth	r3, r3
 800a554: 85fb         	strh	r3, [r7, #0x2e]
; 	temp_micro = temp_int11 * 125000 + 23 * 1000000;
 800a556: f9b7 302e    	ldrsh.w	r3, [r7, #0x2e]
 800a55a: 4a18         	ldr	r2, [pc, #0x60]         @ 0x800a5bc <bmi08x_temp_channel_get+0x19c>
 800a55c: fb03 f202    	mul	r2, r3, r2
 800a560: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800a5c0 <bmi08x_temp_channel_get+0x1a0>
 800a562: 4413         	add	r3, r2
 800a564: 62bb         	str	r3, [r7, #0x28]
; 	val->val1 = temp_micro / 1000000ULL;
 800a566: 6abb         	ldr	r3, [r7, #0x28]
 800a568: 17da         	asrs	r2, r3, #0x1f
 800a56a: 4698         	mov	r8, r3
 800a56c: 4691         	mov	r9, r2
 800a56e: 4a15         	ldr	r2, [pc, #0x54]         @ 0x800a5c4 <bmi08x_temp_channel_get+0x1a4>
 800a570: f04f 0300    	mov.w	r3, #0x0
 800a574: 4640         	mov	r0, r8
 800a576: 4649         	mov	r1, r9
 800a578: f7f6 fa74    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x9b18
 800a57c: 4602         	mov	r2, r0
 800a57e: 460b         	mov	r3, r1
 800a580: 683b         	ldr	r3, [r7]
 800a582: 601a         	str	r2, [r3]
; 	val->val2 = temp_micro % 1000000ULL;
 800a584: 6abb         	ldr	r3, [r7, #0x28]
 800a586: 17da         	asrs	r2, r3, #0x1f
 800a588: 461c         	mov	r4, r3
 800a58a: 4615         	mov	r5, r2
 800a58c: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800a5c4 <bmi08x_temp_channel_get+0x1a4>
 800a58e: f04f 0300    	mov.w	r3, #0x0
 800a592: 4620         	mov	r0, r4
 800a594: 4629         	mov	r1, r5
 800a596: f7f6 fa65    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x9b36
 800a59a: 683b         	ldr	r3, [r7]
 800a59c: 605a         	str	r2, [r3, #0x4]
; 	return ret;
 800a59e: 6a7b         	ldr	r3, [r7, #0x24]
; }
 800a5a0: 4618         	mov	r0, r3
 800a5a2: 3730         	adds	r7, #0x30
 800a5a4: 46bd         	mov	sp, r7
 800a5a6: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 800a5aa: bf00         	nop

0800a5ac <$d>:
 800a5ac: 64 05 00 20  	.word	0x20000564
 800a5b0: 64 16 02 08  	.word	0x08021664
 800a5b4: 90 16 02 08  	.word	0x08021690
 800a5b8: b8 16 02 08  	.word	0x080216b8
 800a5bc: 48 e8 01 00  	.word	0x0001e848
 800a5c0: c0 f3 5e 01  	.word	0x015ef3c0
 800a5c4: 40 42 0f 00  	.word	0x000f4240

0800a5c8 <bmi08x_channel_get>:
; {
 800a5c8: b580         	push	{r7, lr}
 800a5ca: b08a         	sub	sp, #0x28
 800a5cc: af04         	add	r7, sp, #0x10
 800a5ce: 60f8         	str	r0, [r7, #0xc]
 800a5d0: 460b         	mov	r3, r1
 800a5d2: 607a         	str	r2, [r7, #0x4]
 800a5d4: 817b         	strh	r3, [r7, #0xa]
; 	switch ((int16_t)chan) {
 800a5d6: f9b7 300a    	ldrsh.w	r3, [r7, #0xa]
 800a5da: 2b03         	cmp	r3, #0x3
 800a5dc: dc02         	bgt	0x800a5e4 <bmi08x_channel_get+0x1c> @ imm = #0x4
 800a5de: 2b00         	cmp	r3, #0x0
 800a5e0: da03         	bge	0x800a5ea <bmi08x_channel_get+0x22> @ imm = #0x6
 800a5e2: e010         	b	0x800a606 <bmi08x_channel_get+0x3e> @ imm = #0x20
 800a5e4: 2b0c         	cmp	r3, #0xc
 800a5e6: d008         	beq	0x800a5fa <bmi08x_channel_get+0x32> @ imm = #0x10
 800a5e8: e00d         	b	0x800a606 <bmi08x_channel_get+0x3e> @ imm = #0x1a
; 		bmi08x_acc_channel_get(dev, chan, val);
 800a5ea: 897b         	ldrh	r3, [r7, #0xa]
 800a5ec: 687a         	ldr	r2, [r7, #0x4]
 800a5ee: 4619         	mov	r1, r3
 800a5f0: 68f8         	ldr	r0, [r7, #0xc]
 800a5f2: f010 fa1b    	bl	0x801aa2c <bmi08x_acc_channel_get> @ imm = #0x10436
; 		return 0;
 800a5f6: 2300         	movs	r3, #0x0
 800a5f8: e023         	b	0x800a642 <bmi08x_channel_get+0x7a> @ imm = #0x46
; 		return bmi08x_temp_channel_get(dev, val);
 800a5fa: 6879         	ldr	r1, [r7, #0x4]
 800a5fc: 68f8         	ldr	r0, [r7, #0xc]
 800a5fe: f7ff ff0f    	bl	0x800a420 <bmi08x_temp_channel_get> @ imm = #-0x1e2
 800a602: 4603         	mov	r3, r0
 800a604: e01d         	b	0x800a642 <bmi08x_channel_get+0x7a> @ imm = #0x3a
; 		LOG_DBG("Channel not supported.");
 800a606: 2303         	movs	r3, #0x3
 800a608: 2b03         	cmp	r3, #0x3
 800a60a: d918         	bls	0x800a63e <bmi08x_channel_get+0x76> @ imm = #0x30
 800a60c: 2301         	movs	r3, #0x1
 800a60e: 75fb         	strb	r3, [r7, #0x17]
 800a610: 7dfb         	ldrb	r3, [r7, #0x17]
 800a612: f083 0301    	eor	r3, r3, #0x1
 800a616: b2db         	uxtb	r3, r3
 800a618: 2b00         	cmp	r3, #0x0
 800a61a: d110         	bne	0x800a63e <bmi08x_channel_get+0x76> @ imm = #0x20
 800a61c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800a64c <bmi08x_channel_get+0x84>
 800a61e: 6819         	ldr	r1, [r3]
 800a620: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800a650 <bmi08x_channel_get+0x88>
 800a622: 9303         	str	r3, [sp, #0xc]
 800a624: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800a654 <bmi08x_channel_get+0x8c>
 800a626: 9302         	str	r3, [sp, #0x8]
 800a628: 2308         	movs	r3, #0x8
 800a62a: 9301         	str	r3, [sp, #0x4]
 800a62c: 2300         	movs	r3, #0x0
 800a62e: 9300         	str	r3, [sp]
 800a630: 2300         	movs	r3, #0x0
 800a632: 2204         	movs	r2, #0x4
 800a634: 2000         	movs	r0, #0x0
 800a636: f00f ff7d    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfefa
 800a63a: 2300         	movs	r3, #0x0
 800a63c: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800a63e: f06f 0385    	mvn	r3, #0x85
; }
 800a642: 4618         	mov	r0, r3
 800a644: 3718         	adds	r7, #0x18
 800a646: 46bd         	mov	sp, r7
 800a648: bd80         	pop	{r7, pc}
 800a64a: bf00         	nop

0800a64c <$d>:
 800a64c: 64 05 00 20  	.word	0x20000564
 800a650: 9c 2a 02 08  	.word	0x08022a9c
 800a654: e4 16 02 08  	.word	0x080216e4

0800a658 <bmi08x_accel_init>:
; {
 800a658: b580         	push	{r7, lr}
 800a65a: b09e         	sub	sp, #0x78
 800a65c: af04         	add	r7, sp, #0x10
 800a65e: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 800a660: 687b         	ldr	r3, [r7, #0x4]
 800a662: 685b         	ldr	r3, [r3, #0x4]
 800a664: 65fb         	str	r3, [r7, #0x5c]
; 	struct bmi08x_accel_data *data = dev->data;
 800a666: 687b         	ldr	r3, [r7, #0x4]
 800a668: 691b         	ldr	r3, [r3, #0x10]
 800a66a: 65bb         	str	r3, [r7, #0x58]
; 	uint8_t val = 0U;
 800a66c: 2300         	movs	r3, #0x0
 800a66e: 72fb         	strb	r3, [r7, #0xb]
; 	ret = bmi08x_bus_check(dev);
 800a670: 6878         	ldr	r0, [r7, #0x4]
 800a672: f010 f88e    	bl	0x801a792 <bmi08x_bus_check> @ imm = #0x1011c
 800a676: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800a678: 6e7b         	ldr	r3, [r7, #0x64]
 800a67a: 2b00         	cmp	r3, #0x0
 800a67c: da1e         	bge	0x800a6bc <bmi08x_accel_init+0x64> @ imm = #0x3c
; 		LOG_ERR("Bus not ready for '%s'", dev->name);
 800a67e: 2303         	movs	r3, #0x3
 800a680: 2b00         	cmp	r3, #0x0
 800a682: d019         	beq	0x800a6b8 <bmi08x_accel_init+0x60> @ imm = #0x32
 800a684: 2301         	movs	r3, #0x1
 800a686: 74fb         	strb	r3, [r7, #0x13]
 800a688: 7cfb         	ldrb	r3, [r7, #0x13]
 800a68a: f083 0301    	eor	r3, r3, #0x1
 800a68e: b2db         	uxtb	r3, r3
 800a690: 2b00         	cmp	r3, #0x0
 800a692: d111         	bne	0x800a6b8 <bmi08x_accel_init+0x60> @ imm = #0x22
 800a694: 4b9a         	ldr	r3, [pc, #0x268]        @ 0x800a900 <bmi08x_accel_init+0x2a8>
 800a696: 6819         	ldr	r1, [r3]
 800a698: 687b         	ldr	r3, [r7, #0x4]
 800a69a: 681b         	ldr	r3, [r3]
 800a69c: 9303         	str	r3, [sp, #0xc]
 800a69e: 4b99         	ldr	r3, [pc, #0x264]        @ 0x800a904 <bmi08x_accel_init+0x2ac>
 800a6a0: 9302         	str	r3, [sp, #0x8]
 800a6a2: 2300         	movs	r3, #0x0
 800a6a4: 9301         	str	r3, [sp, #0x4]
 800a6a6: 2300         	movs	r3, #0x0
 800a6a8: 9300         	str	r3, [sp]
 800a6aa: 2300         	movs	r3, #0x0
 800a6ac: 2201         	movs	r2, #0x1
 800a6ae: 2000         	movs	r0, #0x0
 800a6b0: f00f ff40    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfe80
 800a6b4: 2300         	movs	r3, #0x0
 800a6b6: 60fb         	str	r3, [r7, #0xc]
; 		return ret;
 800a6b8: 6e7b         	ldr	r3, [r7, #0x64]
 800a6ba: e185         	b	0x800a9c8 <bmi08x_accel_init+0x370> @ imm = #0x30a
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_SOFTRESET, BMI08X_SOFT_RESET_CMD);
 800a6bc: 22b6         	movs	r2, #0xb6
 800a6be: 217e         	movs	r1, #0x7e
 800a6c0: 6878         	ldr	r0, [r7, #0x4]
 800a6c2: f010 f8fd    	bl	0x801a8c0 <bmi08x_accel_byte_write> @ imm = #0x101fa
 800a6c6: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800a6c8: 6e7b         	ldr	r3, [r7, #0x64]
 800a6ca: 2b00         	cmp	r3, #0x0
 800a6cc: da1b         	bge	0x800a706 <bmi08x_accel_init+0xae> @ imm = #0x36
; 		LOG_ERR("Cannot reboot chip.");
 800a6ce: 2303         	movs	r3, #0x3
 800a6d0: 2b00         	cmp	r3, #0x0
 800a6d2: d016         	beq	0x800a702 <bmi08x_accel_init+0xaa> @ imm = #0x2c
 800a6d4: 2301         	movs	r3, #0x1
 800a6d6: 76fb         	strb	r3, [r7, #0x1b]
 800a6d8: 7efb         	ldrb	r3, [r7, #0x1b]
 800a6da: f083 0301    	eor	r3, r3, #0x1
 800a6de: b2db         	uxtb	r3, r3
 800a6e0: 2b00         	cmp	r3, #0x0
 800a6e2: d10e         	bne	0x800a702 <bmi08x_accel_init+0xaa> @ imm = #0x1c
 800a6e4: 4b86         	ldr	r3, [pc, #0x218]        @ 0x800a900 <bmi08x_accel_init+0x2a8>
 800a6e6: 6819         	ldr	r1, [r3]
 800a6e8: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x800a908 <bmi08x_accel_init+0x2b0>
 800a6ea: 9302         	str	r3, [sp, #0x8]
 800a6ec: 2300         	movs	r3, #0x0
 800a6ee: 9301         	str	r3, [sp, #0x4]
 800a6f0: 2300         	movs	r3, #0x0
 800a6f2: 9300         	str	r3, [sp]
 800a6f4: 2300         	movs	r3, #0x0
 800a6f6: 2201         	movs	r2, #0x1
 800a6f8: 2000         	movs	r0, #0x0
 800a6fa: f00f ff1b    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfe36
 800a6fe: 2300         	movs	r3, #0x0
 800a700: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 800a702: 6e7b         	ldr	r3, [r7, #0x64]
 800a704: e160         	b	0x800a9c8 <bmi08x_accel_init+0x370> @ imm = #0x2c0
; 	k_msleep(BMI08X_ACCEL_SOFTRESET_DELAY_MS);
 800a706: 2001         	movs	r0, #0x1
 800a708: f00f feba    	bl	0x801a480 <k_msleep>    @ imm = #0xfd74
; 	ret = bmi08x_bus_init(dev);
 800a70c: 6878         	ldr	r0, [r7, #0x4]
 800a70e: f010 f852    	bl	0x801a7b6 <bmi08x_bus_init> @ imm = #0x100a4
 800a712: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800a714: 6e7b         	ldr	r3, [r7, #0x64]
 800a716: 2b00         	cmp	r3, #0x0
 800a718: da20         	bge	0x800a75c <bmi08x_accel_init+0x104> @ imm = #0x40
; 		LOG_ERR("Can't initialize bus for %s", dev->name);
 800a71a: 2303         	movs	r3, #0x3
 800a71c: 2b00         	cmp	r3, #0x0
 800a71e: d01b         	beq	0x800a758 <bmi08x_accel_init+0x100> @ imm = #0x36
 800a720: 2301         	movs	r3, #0x1
 800a722: f887 3023    	strb.w	r3, [r7, #0x23]
 800a726: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800a72a: f083 0301    	eor	r3, r3, #0x1
 800a72e: b2db         	uxtb	r3, r3
 800a730: 2b00         	cmp	r3, #0x0
 800a732: d111         	bne	0x800a758 <bmi08x_accel_init+0x100> @ imm = #0x22
 800a734: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800a900 <bmi08x_accel_init+0x2a8>
 800a736: 6819         	ldr	r1, [r3]
 800a738: 687b         	ldr	r3, [r7, #0x4]
 800a73a: 681b         	ldr	r3, [r3]
 800a73c: 9303         	str	r3, [sp, #0xc]
 800a73e: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x800a90c <bmi08x_accel_init+0x2b4>
 800a740: 9302         	str	r3, [sp, #0x8]
 800a742: 2300         	movs	r3, #0x0
 800a744: 9301         	str	r3, [sp, #0x4]
 800a746: 2300         	movs	r3, #0x0
 800a748: 9300         	str	r3, [sp]
 800a74a: 2300         	movs	r3, #0x0
 800a74c: 2201         	movs	r2, #0x1
 800a74e: 2000         	movs	r0, #0x0
 800a750: f00f fef0    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfde0
 800a754: 2300         	movs	r3, #0x0
 800a756: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 800a758: 6e7b         	ldr	r3, [r7, #0x64]
 800a75a: e135         	b	0x800a9c8 <bmi08x_accel_init+0x370> @ imm = #0x26a
; 	ret = bmi08x_accel_byte_read(dev, BMI08X_REG_ACCEL_CHIP_ID, &val);
 800a75c: f107 030b    	add.w	r3, r7, #0xb
 800a760: 461a         	mov	r2, r3
 800a762: 2100         	movs	r1, #0x0
 800a764: 6878         	ldr	r0, [r7, #0x4]
 800a766: f010 f873    	bl	0x801a850 <bmi08x_accel_byte_read> @ imm = #0x100e6
 800a76a: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800a76c: 6e7b         	ldr	r3, [r7, #0x64]
 800a76e: 2b00         	cmp	r3, #0x0
 800a770: da1d         	bge	0x800a7ae <bmi08x_accel_init+0x156> @ imm = #0x3a
; 		LOG_ERR("Failed to read chip id.");
 800a772: 2303         	movs	r3, #0x3
 800a774: 2b00         	cmp	r3, #0x0
 800a776: d018         	beq	0x800a7aa <bmi08x_accel_init+0x152> @ imm = #0x30
 800a778: 2301         	movs	r3, #0x1
 800a77a: f887 302b    	strb.w	r3, [r7, #0x2b]
 800a77e: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800a782: f083 0301    	eor	r3, r3, #0x1
 800a786: b2db         	uxtb	r3, r3
 800a788: 2b00         	cmp	r3, #0x0
 800a78a: d10e         	bne	0x800a7aa <bmi08x_accel_init+0x152> @ imm = #0x1c
 800a78c: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800a900 <bmi08x_accel_init+0x2a8>
 800a78e: 6819         	ldr	r1, [r3]
 800a790: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800a910 <bmi08x_accel_init+0x2b8>
 800a792: 9302         	str	r3, [sp, #0x8]
 800a794: 2300         	movs	r3, #0x0
 800a796: 9301         	str	r3, [sp, #0x4]
 800a798: 2300         	movs	r3, #0x0
 800a79a: 9300         	str	r3, [sp]
 800a79c: 2300         	movs	r3, #0x0
 800a79e: 2201         	movs	r2, #0x1
 800a7a0: 2000         	movs	r0, #0x0
 800a7a2: f00f fec7    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfd8e
 800a7a6: 2300         	movs	r3, #0x0
 800a7a8: 627b         	str	r3, [r7, #0x24]
; 		return ret;
 800a7aa: 6e7b         	ldr	r3, [r7, #0x64]
 800a7ac: e10c         	b	0x800a9c8 <bmi08x_accel_init+0x370> @ imm = #0x218
; 	if ((val != BMI085_ACCEL_CHIP_ID) && (val != BMI088_ACCEL_CHIP_ID)) {
 800a7ae: 7afb         	ldrb	r3, [r7, #0xb]
 800a7b0: 2b1f         	cmp	r3, #0x1f
 800a7b2: d023         	beq	0x800a7fc <bmi08x_accel_init+0x1a4> @ imm = #0x46
 800a7b4: 7afb         	ldrb	r3, [r7, #0xb]
 800a7b6: 2b1e         	cmp	r3, #0x1e
 800a7b8: d020         	beq	0x800a7fc <bmi08x_accel_init+0x1a4> @ imm = #0x40
; 		LOG_ERR("Unsupported chip detected (0x%02x)!", val);
 800a7ba: 2303         	movs	r3, #0x3
 800a7bc: 2b00         	cmp	r3, #0x0
 800a7be: d01a         	beq	0x800a7f6 <bmi08x_accel_init+0x19e> @ imm = #0x34
 800a7c0: 2301         	movs	r3, #0x1
 800a7c2: f887 3063    	strb.w	r3, [r7, #0x63]
 800a7c6: f897 3063    	ldrb.w	r3, [r7, #0x63]
 800a7ca: f083 0301    	eor	r3, r3, #0x1
 800a7ce: b2db         	uxtb	r3, r3
 800a7d0: 2b00         	cmp	r3, #0x0
 800a7d2: d110         	bne	0x800a7f6 <bmi08x_accel_init+0x19e> @ imm = #0x20
 800a7d4: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x800a900 <bmi08x_accel_init+0x2a8>
 800a7d6: 6819         	ldr	r1, [r3]
 800a7d8: 7afb         	ldrb	r3, [r7, #0xb]
 800a7da: 9303         	str	r3, [sp, #0xc]
 800a7dc: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800a914 <bmi08x_accel_init+0x2bc>
 800a7de: 9302         	str	r3, [sp, #0x8]
 800a7e0: 2300         	movs	r3, #0x0
 800a7e2: 9301         	str	r3, [sp, #0x4]
 800a7e4: 2300         	movs	r3, #0x0
 800a7e6: 9300         	str	r3, [sp]
 800a7e8: 2300         	movs	r3, #0x0
 800a7ea: 2201         	movs	r2, #0x1
 800a7ec: 2000         	movs	r0, #0x0
 800a7ee: f00f fea1    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfd42
 800a7f2: 2300         	movs	r3, #0x0
 800a7f4: 657b         	str	r3, [r7, #0x54]
; 		return -ENODEV;
 800a7f6: f06f 0312    	mvn	r3, #0x12
 800a7fa: e0e5         	b	0x800a9c8 <bmi08x_accel_init+0x370> @ imm = #0x1ca
; 	data->accel_chip_id = val;
 800a7fc: 7afa         	ldrb	r2, [r7, #0xb]
 800a7fe: 6dbb         	ldr	r3, [r7, #0x58]
 800a800: f883 2948    	strb.w	r2, [r3, #0x948]
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_PWR_CONF, BMI08X_ACCEL_PM_ACTIVE);
 800a804: 2200         	movs	r2, #0x0
 800a806: 217c         	movs	r1, #0x7c
 800a808: 6878         	ldr	r0, [r7, #0x4]
 800a80a: f010 f859    	bl	0x801a8c0 <bmi08x_accel_byte_write> @ imm = #0x100b2
 800a80e: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800a810: 6e7b         	ldr	r3, [r7, #0x64]
 800a812: 2b00         	cmp	r3, #0x0
 800a814: da1d         	bge	0x800a852 <bmi08x_accel_init+0x1fa> @ imm = #0x3a
; 		LOG_ERR("Failed to set conf power mode");
 800a816: 2303         	movs	r3, #0x3
 800a818: 2b00         	cmp	r3, #0x0
 800a81a: d018         	beq	0x800a84e <bmi08x_accel_init+0x1f6> @ imm = #0x30
 800a81c: 2301         	movs	r3, #0x1
 800a81e: f887 3033    	strb.w	r3, [r7, #0x33]
 800a822: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800a826: f083 0301    	eor	r3, r3, #0x1
 800a82a: b2db         	uxtb	r3, r3
 800a82c: 2b00         	cmp	r3, #0x0
 800a82e: d10e         	bne	0x800a84e <bmi08x_accel_init+0x1f6> @ imm = #0x1c
 800a830: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800a900 <bmi08x_accel_init+0x2a8>
 800a832: 6819         	ldr	r1, [r3]
 800a834: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800a918 <bmi08x_accel_init+0x2c0>
 800a836: 9302         	str	r3, [sp, #0x8]
 800a838: 2300         	movs	r3, #0x0
 800a83a: 9301         	str	r3, [sp, #0x4]
 800a83c: 2300         	movs	r3, #0x0
 800a83e: 9300         	str	r3, [sp]
 800a840: 2300         	movs	r3, #0x0
 800a842: 2201         	movs	r2, #0x1
 800a844: 2000         	movs	r0, #0x0
 800a846: f00f fe75    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfcea
 800a84a: 2300         	movs	r3, #0x0
 800a84c: 62fb         	str	r3, [r7, #0x2c]
; 		return ret;
 800a84e: 6e7b         	ldr	r3, [r7, #0x64]
 800a850: e0ba         	b	0x800a9c8 <bmi08x_accel_init+0x370> @ imm = #0x174
; 	k_msleep(BMI08X_POWER_CONFIG_DELAY);
 800a852: 2005         	movs	r0, #0x5
 800a854: f00f fe14    	bl	0x801a480 <k_msleep>    @ imm = #0xfc28
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_PWR_CTRL, BMI08X_ACCEL_POWER_ENABLE);
 800a858: 2204         	movs	r2, #0x4
 800a85a: 217d         	movs	r1, #0x7d
 800a85c: 6878         	ldr	r0, [r7, #0x4]
 800a85e: f010 f82f    	bl	0x801a8c0 <bmi08x_accel_byte_write> @ imm = #0x1005e
 800a862: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800a864: 6e7b         	ldr	r3, [r7, #0x64]
 800a866: 2b00         	cmp	r3, #0x0
 800a868: da1d         	bge	0x800a8a6 <bmi08x_accel_init+0x24e> @ imm = #0x3a
; 		LOG_ERR("Failed to set ctrl power mode");
 800a86a: 2303         	movs	r3, #0x3
 800a86c: 2b00         	cmp	r3, #0x0
 800a86e: d018         	beq	0x800a8a2 <bmi08x_accel_init+0x24a> @ imm = #0x30
 800a870: 2301         	movs	r3, #0x1
 800a872: f887 303b    	strb.w	r3, [r7, #0x3b]
 800a876: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800a87a: f083 0301    	eor	r3, r3, #0x1
 800a87e: b2db         	uxtb	r3, r3
 800a880: 2b00         	cmp	r3, #0x0
 800a882: d10e         	bne	0x800a8a2 <bmi08x_accel_init+0x24a> @ imm = #0x1c
 800a884: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800a900 <bmi08x_accel_init+0x2a8>
 800a886: 6819         	ldr	r1, [r3]
 800a888: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800a91c <bmi08x_accel_init+0x2c4>
 800a88a: 9302         	str	r3, [sp, #0x8]
 800a88c: 2300         	movs	r3, #0x0
 800a88e: 9301         	str	r3, [sp, #0x4]
 800a890: 2300         	movs	r3, #0x0
 800a892: 9300         	str	r3, [sp]
 800a894: 2300         	movs	r3, #0x0
 800a896: 2201         	movs	r2, #0x1
 800a898: 2000         	movs	r0, #0x0
 800a89a: f00f fe4b    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfc96
 800a89e: 2300         	movs	r3, #0x0
 800a8a0: 637b         	str	r3, [r7, #0x34]
; 		return ret;
 800a8a2: 6e7b         	ldr	r3, [r7, #0x64]
 800a8a4: e090         	b	0x800a9c8 <bmi08x_accel_init+0x370> @ imm = #0x120
; 	k_msleep(BMI08X_POWER_CONFIG_DELAY);
 800a8a6: 2005         	movs	r0, #0x5
 800a8a8: f00f fdea    	bl	0x801a480 <k_msleep>    @ imm = #0xfbd4
; 	ret = bmi08x_acc_range_set(dev, config->accel_fs);
 800a8ac: 6dfb         	ldr	r3, [r7, #0x5c]
 800a8ae: f893 3029    	ldrb.w	r3, [r3, #0x29]
 800a8b2: 4619         	mov	r1, r3
 800a8b4: 6878         	ldr	r0, [r7, #0x4]
 800a8b6: f7ff fc1d    	bl	0x800a0f4 <bmi08x_acc_range_set> @ imm = #-0x7c6
 800a8ba: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800a8bc: 6e7b         	ldr	r3, [r7, #0x64]
 800a8be: 2b00         	cmp	r3, #0x0
 800a8c0: da30         	bge	0x800a924 <bmi08x_accel_init+0x2cc> @ imm = #0x60
; 		LOG_ERR("Cannot set default range for accelerometer.");
 800a8c2: 2303         	movs	r3, #0x3
 800a8c4: 2b00         	cmp	r3, #0x0
 800a8c6: d018         	beq	0x800a8fa <bmi08x_accel_init+0x2a2> @ imm = #0x30
 800a8c8: 2301         	movs	r3, #0x1
 800a8ca: f887 3043    	strb.w	r3, [r7, #0x43]
 800a8ce: f897 3043    	ldrb.w	r3, [r7, #0x43]
 800a8d2: f083 0301    	eor	r3, r3, #0x1
 800a8d6: b2db         	uxtb	r3, r3
 800a8d8: 2b00         	cmp	r3, #0x0
 800a8da: d10e         	bne	0x800a8fa <bmi08x_accel_init+0x2a2> @ imm = #0x1c
 800a8dc: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800a900 <bmi08x_accel_init+0x2a8>
 800a8de: 6819         	ldr	r1, [r3]
 800a8e0: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800a920 <bmi08x_accel_init+0x2c8>
 800a8e2: 9302         	str	r3, [sp, #0x8]
 800a8e4: 2300         	movs	r3, #0x0
 800a8e6: 9301         	str	r3, [sp, #0x4]
 800a8e8: 2300         	movs	r3, #0x0
 800a8ea: 9300         	str	r3, [sp]
 800a8ec: 2300         	movs	r3, #0x0
 800a8ee: 2201         	movs	r2, #0x1
 800a8f0: 2000         	movs	r0, #0x0
 800a8f2: f00f fe1f    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfc3e
 800a8f6: 2300         	movs	r3, #0x0
 800a8f8: 63fb         	str	r3, [r7, #0x3c]
; 		return ret;
 800a8fa: 6e7b         	ldr	r3, [r7, #0x64]
 800a8fc: e064         	b	0x800a9c8 <bmi08x_accel_init+0x370> @ imm = #0xc8
 800a8fe: bf00         	nop

0800a900 <$d>:
 800a900: 64 05 00 20  	.word	0x20000564
 800a904: 00 17 02 08  	.word	0x08021700
 800a908: 18 17 02 08  	.word	0x08021718
 800a90c: 2c 17 02 08  	.word	0x0802172c
 800a910: 48 17 02 08  	.word	0x08021748
 800a914: 60 17 02 08  	.word	0x08021760
 800a918: 84 17 02 08  	.word	0x08021784
 800a91c: a4 17 02 08  	.word	0x080217a4
 800a920: c4 17 02 08  	.word	0x080217c4

0800a924 <$t>:
; 					    config->accel_hz);
 800a924: 6dfb         	ldr	r3, [r7, #0x5c]
 800a926: f893 3028    	ldrb.w	r3, [r3, #0x28]
; 	ret = bmi08x_accel_reg_field_update(dev, BMI08X_REG_ACCEL_CONF, 0, BMI08X_ACCEL_ODR_MASK,
 800a92a: 9300         	str	r3, [sp]
 800a92c: 230f         	movs	r3, #0xf
 800a92e: 2200         	movs	r2, #0x0
 800a930: 2140         	movs	r1, #0x40
 800a932: 6878         	ldr	r0, [r7, #0x4]
 800a934: f00f ffdc    	bl	0x801a8f0 <bmi08x_accel_reg_field_update> @ imm = #0xffb8
 800a938: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800a93a: 6e7b         	ldr	r3, [r7, #0x64]
 800a93c: 2b00         	cmp	r3, #0x0
 800a93e: da1d         	bge	0x800a97c <bmi08x_accel_init+0x324> @ imm = #0x3a
; 		LOG_ERR("Failed to set accel's default ODR.");
 800a940: 2303         	movs	r3, #0x3
 800a942: 2b00         	cmp	r3, #0x0
 800a944: d018         	beq	0x800a978 <bmi08x_accel_init+0x320> @ imm = #0x30
 800a946: 2301         	movs	r3, #0x1
 800a948: f887 304b    	strb.w	r3, [r7, #0x4b]
 800a94c: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 800a950: f083 0301    	eor	r3, r3, #0x1
 800a954: b2db         	uxtb	r3, r3
 800a956: 2b00         	cmp	r3, #0x0
 800a958: d10e         	bne	0x800a978 <bmi08x_accel_init+0x320> @ imm = #0x1c
 800a95a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800a9d0 <bmi08x_accel_init+0x378>
 800a95c: 6819         	ldr	r1, [r3]
 800a95e: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800a9d4 <bmi08x_accel_init+0x37c>
 800a960: 9302         	str	r3, [sp, #0x8]
 800a962: 2300         	movs	r3, #0x0
 800a964: 9301         	str	r3, [sp, #0x4]
 800a966: 2300         	movs	r3, #0x0
 800a968: 9300         	str	r3, [sp]
 800a96a: 2300         	movs	r3, #0x0
 800a96c: 2201         	movs	r2, #0x1
 800a96e: 2000         	movs	r0, #0x0
 800a970: f00f fde0    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfbc0
 800a974: 2300         	movs	r3, #0x0
 800a976: 647b         	str	r3, [r7, #0x44]
; 		return ret;
 800a978: 6e7b         	ldr	r3, [r7, #0x64]
 800a97a: e025         	b	0x800a9c8 <bmi08x_accel_init+0x370> @ imm = #0x4a
; 	ret = bmi08x_acc_trigger_mode_init(dev);
 800a97c: 6878         	ldr	r0, [r7, #0x4]
 800a97e: f000 fc61    	bl	0x800b244 <bmi08x_acc_trigger_mode_init> @ imm = #0x8c2
 800a982: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800a984: 6e7b         	ldr	r3, [r7, #0x64]
 800a986: 2b00         	cmp	r3, #0x0
 800a988: da1d         	bge	0x800a9c6 <bmi08x_accel_init+0x36e> @ imm = #0x3a
; 		LOG_ERR("Cannot set up trigger mode.");
 800a98a: 2303         	movs	r3, #0x3
 800a98c: 2b00         	cmp	r3, #0x0
 800a98e: d018         	beq	0x800a9c2 <bmi08x_accel_init+0x36a> @ imm = #0x30
 800a990: 2301         	movs	r3, #0x1
 800a992: f887 3053    	strb.w	r3, [r7, #0x53]
 800a996: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800a99a: f083 0301    	eor	r3, r3, #0x1
 800a99e: b2db         	uxtb	r3, r3
 800a9a0: 2b00         	cmp	r3, #0x0
 800a9a2: d10e         	bne	0x800a9c2 <bmi08x_accel_init+0x36a> @ imm = #0x1c
 800a9a4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800a9d0 <bmi08x_accel_init+0x378>
 800a9a6: 6819         	ldr	r1, [r3]
 800a9a8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800a9d8 <bmi08x_accel_init+0x380>
 800a9aa: 9302         	str	r3, [sp, #0x8]
 800a9ac: 2300         	movs	r3, #0x0
 800a9ae: 9301         	str	r3, [sp, #0x4]
 800a9b0: 2300         	movs	r3, #0x0
 800a9b2: 9300         	str	r3, [sp]
 800a9b4: 2300         	movs	r3, #0x0
 800a9b6: 2201         	movs	r2, #0x1
 800a9b8: 2000         	movs	r0, #0x0
 800a9ba: f00f fdbb    	bl	0x801a534 <z_log_msg_runtime_create> @ imm = #0xfb76
 800a9be: 2300         	movs	r3, #0x0
 800a9c0: 64fb         	str	r3, [r7, #0x4c]
; 		return ret;
 800a9c2: 6e7b         	ldr	r3, [r7, #0x64]
 800a9c4: e000         	b	0x800a9c8 <bmi08x_accel_init+0x370> @ imm = #0x0
; 	return ret;
 800a9c6: 6e7b         	ldr	r3, [r7, #0x64]
; }
 800a9c8: 4618         	mov	r0, r3
 800a9ca: 3768         	adds	r7, #0x68
 800a9cc: 46bd         	mov	sp, r7
 800a9ce: bd80         	pop	{r7, pc}

0800a9d0 <$d>:
 800a9d0: 64 05 00 20  	.word	0x20000564
 800a9d4: f0 17 02 08  	.word	0x080217f0
 800a9d8: 14 18 02 08  	.word	0x08021814

0800a9dc <bmi08x_gyr_range_set>:
; {
 800a9dc: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800a9e0: b08c         	sub	sp, #0x30
 800a9e2: af00         	add	r7, sp, #0x0
 800a9e4: 61f8         	str	r0, [r7, #0x1c]
 800a9e6: 460b         	mov	r3, r1
 800a9e8: 837b         	strh	r3, [r7, #0x1a]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 800a9ea: 69fb         	ldr	r3, [r7, #0x1c]
 800a9ec: 691b         	ldr	r3, [r3, #0x10]
 800a9ee: 62fb         	str	r3, [r7, #0x2c]
; 		bmi08x_range_to_reg_val(range, bmi08x_gyr_range_map, BMI08X_GYR_RANGE_MAP_SIZE);
 800a9f0: 8b7b         	ldrh	r3, [r7, #0x1a]
 800a9f2: 2205         	movs	r2, #0x5
 800a9f4: 493d         	ldr	r1, [pc, #0xf4]         @ 0x800aaec <bmi08x_gyr_range_set+0x110>
 800a9f6: 4618         	mov	r0, r3
 800a9f8: f010 fa9e    	bl	0x801af38 <bmi08x_range_to_reg_val> @ imm = #0x1053c
 800a9fc: 62b8         	str	r0, [r7, #0x28]
; 	if (reg_val < 0) {
 800a9fe: 6abb         	ldr	r3, [r7, #0x28]
 800aa00: 2b00         	cmp	r3, #0x0
 800aa02: da01         	bge	0x800aa08 <bmi08x_gyr_range_set+0x2c> @ imm = #0x2
; 		return reg_val;
 800aa04: 6abb         	ldr	r3, [r7, #0x28]
 800aa06: e06c         	b	0x800aae2 <bmi08x_gyr_range_set+0x106> @ imm = #0xd8
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_RANGE, reg_val);
 800aa08: 6abb         	ldr	r3, [r7, #0x28]
 800aa0a: b2db         	uxtb	r3, r3
 800aa0c: 461a         	mov	r2, r3
 800aa0e: 210f         	movs	r1, #0xf
 800aa10: 69f8         	ldr	r0, [r7, #0x1c]
 800aa12: f010 f9f5    	bl	0x801ae00 <bmi08x_gyro_byte_write> @ imm = #0x103ea
 800aa16: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 800aa18: 6a7b         	ldr	r3, [r7, #0x24]
 800aa1a: 2b00         	cmp	r3, #0x0
 800aa1c: da01         	bge	0x800aa22 <bmi08x_gyr_range_set+0x46> @ imm = #0x2
; 		return ret;
 800aa1e: 6a7b         	ldr	r3, [r7, #0x24]
 800aa20: e05f         	b	0x800aae2 <bmi08x_gyr_range_set+0x106> @ imm = #0xbe
; 	bmi08x->scale = BMI08X_GYR_SCALE(range);
 800aa22: 8b7b         	ldrh	r3, [r7, #0x1a]
 800aa24: 2200         	movs	r2, #0x0
 800aa26: 461c         	mov	r4, r3
 800aa28: 4615         	mov	r5, r2
 800aa2a: 4622         	mov	r2, r4
 800aa2c: 462b         	mov	r3, r5
 800aa2e: 1891         	adds	r1, r2, r2
 800aa30: 60b9         	str	r1, [r7, #0x8]
 800aa32: 415b         	adcs	r3, r3
 800aa34: 60fb         	str	r3, [r7, #0xc]
 800aa36: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800aa3a: 1911         	adds	r1, r2, r4
 800aa3c: 6139         	str	r1, [r7, #0x10]
 800aa3e: 416b         	adcs	r3, r5
 800aa40: 617b         	str	r3, [r7, #0x14]
 800aa42: f04f 0200    	mov.w	r2, #0x0
 800aa46: f04f 0300    	mov.w	r3, #0x0
 800aa4a: 6979         	ldr	r1, [r7, #0x14]
 800aa4c: 020b         	lsls	r3, r1, #0x8
 800aa4e: 6939         	ldr	r1, [r7, #0x10]
 800aa50: ea43 6311    	orr.w	r3, r3, r1, lsr #24
 800aa54: 6939         	ldr	r1, [r7, #0x10]
 800aa56: 020a         	lsls	r2, r1, #0x8
 800aa58: 4611         	mov	r1, r2
 800aa5a: 461a         	mov	r2, r3
 800aa5c: 460b         	mov	r3, r1
 800aa5e: ebb3 0a04    	subs.w	r10, r3, r4
 800aa62: 4613         	mov	r3, r2
 800aa64: eb63 0b05    	sbc.w	r11, r3, r5
 800aa68: f04f 0200    	mov.w	r2, #0x0
 800aa6c: f04f 0300    	mov.w	r3, #0x0
 800aa70: ea4f 13cb    	lsl.w	r3, r11, #0x7
 800aa74: ea43 635a    	orr.w	r3, r3, r10, lsr #25
 800aa78: ea4f 12ca    	lsl.w	r2, r10, #0x7
 800aa7c: 4692         	mov	r10, r2
 800aa7e: 469b         	mov	r11, r3
 800aa80: ebba 0804    	subs.w	r8, r10, r4
 800aa84: eb6b 0905    	sbc.w	r9, r11, r5
 800aa88: f04f 0200    	mov.w	r2, #0x0
 800aa8c: f04f 0300    	mov.w	r3, #0x0
 800aa90: ea4f 0389    	lsl.w	r3, r9, #0x2
 800aa94: ea43 7398    	orr.w	r3, r3, r8, lsr #30
 800aa98: ea4f 0288    	lsl.w	r2, r8, #0x2
 800aa9c: 4690         	mov	r8, r2
 800aa9e: 4699         	mov	r9, r3
 800aaa0: ebb8 0304    	subs.w	r3, r8, r4
 800aaa4: 603b         	str	r3, [r7]
 800aaa6: eb69 0305    	sbc.w	r3, r9, r5
 800aaaa: 607b         	str	r3, [r7, #0x4]
 800aaac: f04f 0200    	mov.w	r2, #0x0
 800aab0: f04f 0300    	mov.w	r3, #0x0
 800aab4: e9d7 4500    	ldrd	r4, r5, [r7]
 800aab8: 4629         	mov	r1, r5
 800aaba: 010b         	lsls	r3, r1, #0x4
 800aabc: 4621         	mov	r1, r4
 800aabe: ea43 7311    	orr.w	r3, r3, r1, lsr #28
 800aac2: 4621         	mov	r1, r4
 800aac4: 010a         	lsls	r2, r1, #0x4
 800aac6: 4610         	mov	r0, r2
 800aac8: 4619         	mov	r1, r3
 800aaca: f44f 0234    	mov.w	r2, #0xb40000
 800aace: f04f 0300    	mov.w	r3, #0x0
 800aad2: f7f5 ff77    	bl	0x80009c4 <__aeabi_ldivmod> @ imm = #-0xa112
 800aad6: 4602         	mov	r2, r0
 800aad8: 460b         	mov	r3, r1
 800aada: b292         	uxth	r2, r2
 800aadc: 6afb         	ldr	r3, [r7, #0x2c]
 800aade: 825a         	strh	r2, [r3, #0x12]
; 	return ret;
 800aae0: 6a7b         	ldr	r3, [r7, #0x24]
; }
 800aae2: 4618         	mov	r0, r3
 800aae4: 3730         	adds	r7, #0x30
 800aae6: 46bd         	mov	sp, r7
 800aae8: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800aaec <$d>:
 800aaec: b8 2a 02 08  	.word	0x08022ab8

0800aaf0 <bmi08x_gyr_config>:
; {
 800aaf0: b580         	push	{r7, lr}
 800aaf2: b08a         	sub	sp, #0x28
 800aaf4: af04         	add	r7, sp, #0x10
 800aaf6: 60f8         	str	r0, [r7, #0xc]
 800aaf8: 607b         	str	r3, [r7, #0x4]
 800aafa: 460b         	mov	r3, r1
 800aafc: 817b         	strh	r3, [r7, #0xa]
 800aafe: 4613         	mov	r3, r2
 800ab00: 813b         	strh	r3, [r7, #0x8]
; 	switch (attr) {
 800ab02: 893b         	ldrh	r3, [r7, #0x8]
 800ab04: 2b00         	cmp	r3, #0x0
 800ab06: d00c         	beq	0x800ab22 <bmi08x_gyr_config+0x32> @ imm = #0x18
 800ab08: 2b07         	cmp	r3, #0x7
 800ab0a: d11c         	bne	0x800ab46 <bmi08x_gyr_config+0x56> @ imm = #0x38
; 		return bmi08x_gyr_range_set(dev, sensor_rad_to_degrees(val));
 800ab0c: 6878         	ldr	r0, [r7, #0x4]
 800ab0e: f7f6 fb83    	bl	0x8001218 <sensor_rad_to_degrees> @ imm = #-0x98fa
 800ab12: 4603         	mov	r3, r0
 800ab14: b29b         	uxth	r3, r3
 800ab16: 4619         	mov	r1, r3
 800ab18: 68f8         	ldr	r0, [r7, #0xc]
 800ab1a: f7ff ff5f    	bl	0x800a9dc <bmi08x_gyr_range_set> @ imm = #-0x142
 800ab1e: 4603         	mov	r3, r0
 800ab20: e02f         	b	0x800ab82 <bmi08x_gyr_config+0x92> @ imm = #0x5e
; 		return bmi08x_gyr_odr_set(dev, val->val1, val->val2 / 1000);
 800ab22: 687b         	ldr	r3, [r7, #0x4]
 800ab24: 681b         	ldr	r3, [r3]
 800ab26: b299         	uxth	r1, r3
 800ab28: 687b         	ldr	r3, [r7, #0x4]
 800ab2a: 685b         	ldr	r3, [r3, #0x4]
 800ab2c: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800ab8c <bmi08x_gyr_config+0x9c>
 800ab2e: fb82 0203    	smull	r0, r2, r2, r3
 800ab32: 1192         	asrs	r2, r2, #0x6
 800ab34: 17db         	asrs	r3, r3, #0x1f
 800ab36: 1ad3         	subs	r3, r2, r3
 800ab38: b29b         	uxth	r3, r3
 800ab3a: 461a         	mov	r2, r3
 800ab3c: 68f8         	ldr	r0, [r7, #0xc]
 800ab3e: f010 f977    	bl	0x801ae30 <bmi08x_gyr_odr_set> @ imm = #0x102ee
 800ab42: 4603         	mov	r3, r0
 800ab44: e01d         	b	0x800ab82 <bmi08x_gyr_config+0x92> @ imm = #0x3a
; 		LOG_DBG("Gyro attribute not supported.");
 800ab46: 2303         	movs	r3, #0x3
 800ab48: 2b03         	cmp	r3, #0x3
 800ab4a: d918         	bls	0x800ab7e <bmi08x_gyr_config+0x8e> @ imm = #0x30
 800ab4c: 2301         	movs	r3, #0x1
 800ab4e: 75fb         	strb	r3, [r7, #0x17]
 800ab50: 7dfb         	ldrb	r3, [r7, #0x17]
 800ab52: f083 0301    	eor	r3, r3, #0x1
 800ab56: b2db         	uxtb	r3, r3
 800ab58: 2b00         	cmp	r3, #0x0
 800ab5a: d110         	bne	0x800ab7e <bmi08x_gyr_config+0x8e> @ imm = #0x20
 800ab5c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800ab90 <bmi08x_gyr_config+0xa0>
 800ab5e: 6819         	ldr	r1, [r3]
 800ab60: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800ab94 <bmi08x_gyr_config+0xa4>
 800ab62: 9303         	str	r3, [sp, #0xc]
 800ab64: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800ab98 <bmi08x_gyr_config+0xa8>
 800ab66: 9302         	str	r3, [sp, #0x8]
 800ab68: 2308         	movs	r3, #0x8
 800ab6a: 9301         	str	r3, [sp, #0x4]
 800ab6c: 2300         	movs	r3, #0x0
 800ab6e: 9300         	str	r3, [sp]
 800ab70: 2300         	movs	r3, #0x0
 800ab72: 2204         	movs	r2, #0x4
 800ab74: 2000         	movs	r0, #0x0
 800ab76: f00f ffb6    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xff6c
 800ab7a: 2300         	movs	r3, #0x0
 800ab7c: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800ab7e: f06f 0385    	mvn	r3, #0x85
; }
 800ab82: 4618         	mov	r0, r3
 800ab84: 3718         	adds	r7, #0x18
 800ab86: 46bd         	mov	sp, r7
 800ab88: bd80         	pop	{r7, pc}
 800ab8a: bf00         	nop

0800ab8c <$d>:
 800ab8c: d3 4d 62 10  	.word	0x10624dd3
 800ab90: 68 05 00 20  	.word	0x20000568
 800ab94: f8 2a 02 08  	.word	0x08022af8
 800ab98: 4c 18 02 08  	.word	0x0802184c

0800ab9c <bmi08x_attr_set>:
; {
 800ab9c: b580         	push	{r7, lr}
 800ab9e: b08a         	sub	sp, #0x28
 800aba0: af04         	add	r7, sp, #0x10
 800aba2: 60f8         	str	r0, [r7, #0xc]
 800aba4: 607b         	str	r3, [r7, #0x4]
 800aba6: 460b         	mov	r3, r1
 800aba8: 817b         	strh	r3, [r7, #0xa]
 800abaa: 4613         	mov	r3, r2
 800abac: 813b         	strh	r3, [r7, #0x8]
; 	switch (chan) {
 800abae: 897b         	ldrh	r3, [r7, #0xa]
 800abb0: 3b04         	subs	r3, #0x4
 800abb2: 2b03         	cmp	r3, #0x3
 800abb4: d807         	bhi	0x800abc6 <bmi08x_attr_set+0x2a> @ imm = #0xe
; 		return bmi08x_gyr_config(dev, chan, attr, val);
 800abb6: 893a         	ldrh	r2, [r7, #0x8]
 800abb8: 8979         	ldrh	r1, [r7, #0xa]
 800abba: 687b         	ldr	r3, [r7, #0x4]
 800abbc: 68f8         	ldr	r0, [r7, #0xc]
 800abbe: f7ff ff97    	bl	0x800aaf0 <bmi08x_gyr_config> @ imm = #-0xd2
 800abc2: 4603         	mov	r3, r0
 800abc4: e01d         	b	0x800ac02 <bmi08x_attr_set+0x66> @ imm = #0x3a
; 		LOG_DBG("attr_set() not supported on this channel.");
 800abc6: 2303         	movs	r3, #0x3
 800abc8: 2b03         	cmp	r3, #0x3
 800abca: d918         	bls	0x800abfe <bmi08x_attr_set+0x62> @ imm = #0x30
 800abcc: 2301         	movs	r3, #0x1
 800abce: 75fb         	strb	r3, [r7, #0x17]
 800abd0: 7dfb         	ldrb	r3, [r7, #0x17]
 800abd2: f083 0301    	eor	r3, r3, #0x1
 800abd6: b2db         	uxtb	r3, r3
 800abd8: 2b00         	cmp	r3, #0x0
 800abda: d110         	bne	0x800abfe <bmi08x_attr_set+0x62> @ imm = #0x20
 800abdc: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ac0c <bmi08x_attr_set+0x70>
 800abde: 6819         	ldr	r1, [r3]
 800abe0: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ac10 <bmi08x_attr_set+0x74>
 800abe2: 9303         	str	r3, [sp, #0xc]
 800abe4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ac14 <bmi08x_attr_set+0x78>
 800abe6: 9302         	str	r3, [sp, #0x8]
 800abe8: 2308         	movs	r3, #0x8
 800abea: 9301         	str	r3, [sp, #0x4]
 800abec: 2300         	movs	r3, #0x0
 800abee: 9300         	str	r3, [sp]
 800abf0: 2300         	movs	r3, #0x0
 800abf2: 2204         	movs	r2, #0x4
 800abf4: 2000         	movs	r0, #0x0
 800abf6: f00f ff76    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfeec
 800abfa: 2300         	movs	r3, #0x0
 800abfc: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800abfe: f06f 0385    	mvn	r3, #0x85
; }
 800ac02: 4618         	mov	r0, r3
 800ac04: 3718         	adds	r7, #0x18
 800ac06: 46bd         	mov	sp, r7
 800ac08: bd80         	pop	{r7, pc}
 800ac0a: bf00         	nop

0800ac0c <$d>:
 800ac0c: 68 05 00 20  	.word	0x20000568
 800ac10: 0c 2b 02 08  	.word	0x08022b0c
 800ac14: 70 18 02 08  	.word	0x08021870

0800ac18 <bmi08x_sample_fetch>:
; {
 800ac18: b580         	push	{r7, lr}
 800ac1a: b08c         	sub	sp, #0x30
 800ac1c: af04         	add	r7, sp, #0x10
 800ac1e: 6078         	str	r0, [r7, #0x4]
 800ac20: 460b         	mov	r3, r1
 800ac22: 807b         	strh	r3, [r7, #0x2]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 800ac24: 687b         	ldr	r3, [r7, #0x4]
 800ac26: 691b         	ldr	r3, [r3, #0x10]
 800ac28: 61bb         	str	r3, [r7, #0x18]
; 	if (chan != SENSOR_CHAN_ALL && chan != SENSOR_CHAN_GYRO_XYZ) {
 800ac2a: 887b         	ldrh	r3, [r7, #0x2]
 800ac2c: 2b3c         	cmp	r3, #0x3c
 800ac2e: d021         	beq	0x800ac74 <bmi08x_sample_fetch+0x5c> @ imm = #0x42
 800ac30: 887b         	ldrh	r3, [r7, #0x2]
 800ac32: 2b07         	cmp	r3, #0x7
 800ac34: d01e         	beq	0x800ac74 <bmi08x_sample_fetch+0x5c> @ imm = #0x3c
; 		LOG_DBG("Unsupported sensor channel");
 800ac36: 2303         	movs	r3, #0x3
 800ac38: 2b03         	cmp	r3, #0x3
 800ac3a: d918         	bls	0x800ac6e <bmi08x_sample_fetch+0x56> @ imm = #0x30
 800ac3c: 2301         	movs	r3, #0x1
 800ac3e: 75fb         	strb	r3, [r7, #0x17]
 800ac40: 7dfb         	ldrb	r3, [r7, #0x17]
 800ac42: f083 0301    	eor	r3, r3, #0x1
 800ac46: b2db         	uxtb	r3, r3
 800ac48: 2b00         	cmp	r3, #0x0
 800ac4a: d110         	bne	0x800ac6e <bmi08x_sample_fetch+0x56> @ imm = #0x20
 800ac4c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800acc8 <bmi08x_sample_fetch+0xb0>
 800ac4e: 6819         	ldr	r1, [r3]
 800ac50: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800accc <bmi08x_sample_fetch+0xb4>
 800ac52: 9303         	str	r3, [sp, #0xc]
 800ac54: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800acd0 <bmi08x_sample_fetch+0xb8>
 800ac56: 9302         	str	r3, [sp, #0x8]
 800ac58: 2308         	movs	r3, #0x8
 800ac5a: 9301         	str	r3, [sp, #0x4]
 800ac5c: 2300         	movs	r3, #0x0
 800ac5e: 9300         	str	r3, [sp]
 800ac60: 2300         	movs	r3, #0x0
 800ac62: 2204         	movs	r2, #0x4
 800ac64: 2000         	movs	r0, #0x0
 800ac66: f00f ff3e    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfe7c
 800ac6a: 2300         	movs	r3, #0x0
 800ac6c: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800ac6e: f06f 0385    	mvn	r3, #0x85
 800ac72: e024         	b	0x800acbe <bmi08x_sample_fetch+0xa6> @ imm = #0x48
; 	ret = bmi08x_gyro_read(dev, BMI08X_REG_GYRO_X_LSB, (uint8_t *)bmi08x->gyr_sample,
 800ac74: 69bb         	ldr	r3, [r7, #0x18]
 800ac76: f103 020c    	add.w	r2, r3, #0xc
 800ac7a: 2306         	movs	r3, #0x6
 800ac7c: 2102         	movs	r1, #0x2
 800ac7e: 6878         	ldr	r0, [r7, #0x4]
 800ac80: f010 f88d    	bl	0x801ad9e <bmi08x_gyro_read> @ imm = #0x1011a
 800ac84: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 800ac86: 68fb         	ldr	r3, [r7, #0xc]
 800ac88: 2b00         	cmp	r3, #0x0
 800ac8a: da01         	bge	0x800ac90 <bmi08x_sample_fetch+0x78> @ imm = #0x2
; 		return ret;
 800ac8c: 68fb         	ldr	r3, [r7, #0xc]
 800ac8e: e016         	b	0x800acbe <bmi08x_sample_fetch+0xa6> @ imm = #0x2c
; 	for (i = 0; i < ARRAY_SIZE(bmi08x->gyr_sample); i++) {
 800ac90: 2300         	movs	r3, #0x0
 800ac92: 61fb         	str	r3, [r7, #0x1c]
 800ac94: e00f         	b	0x800acb6 <bmi08x_sample_fetch+0x9e> @ imm = #0x1e
; 		bmi08x->gyr_sample[i] = sys_le16_to_cpu(bmi08x->gyr_sample[i]);
 800ac96: 69ba         	ldr	r2, [r7, #0x18]
 800ac98: 69fb         	ldr	r3, [r7, #0x1c]
 800ac9a: 3304         	adds	r3, #0x4
 800ac9c: 005b         	lsls	r3, r3, #0x1
 800ac9e: 4413         	add	r3, r2
 800aca0: 8899         	ldrh	r1, [r3, #0x4]
 800aca2: 69ba         	ldr	r2, [r7, #0x18]
 800aca4: 69fb         	ldr	r3, [r7, #0x1c]
 800aca6: 3304         	adds	r3, #0x4
 800aca8: 005b         	lsls	r3, r3, #0x1
 800acaa: 4413         	add	r3, r2
 800acac: 460a         	mov	r2, r1
 800acae: 809a         	strh	r2, [r3, #0x4]
; 	for (i = 0; i < ARRAY_SIZE(bmi08x->gyr_sample); i++) {
 800acb0: 69fb         	ldr	r3, [r7, #0x1c]
 800acb2: 3301         	adds	r3, #0x1
 800acb4: 61fb         	str	r3, [r7, #0x1c]
 800acb6: 69fb         	ldr	r3, [r7, #0x1c]
 800acb8: 2b02         	cmp	r3, #0x2
 800acba: d9ec         	bls	0x800ac96 <bmi08x_sample_fetch+0x7e> @ imm = #-0x28
; 	return ret;
 800acbc: 68fb         	ldr	r3, [r7, #0xc]
; }
 800acbe: 4618         	mov	r0, r3
 800acc0: 3720         	adds	r7, #0x20
 800acc2: 46bd         	mov	sp, r7
 800acc4: bd80         	pop	{r7, pc}
 800acc6: bf00         	nop

0800acc8 <$d>:
 800acc8: 68 05 00 20  	.word	0x20000568
 800accc: 1c 2b 02 08  	.word	0x08022b1c
 800acd0: a0 18 02 08  	.word	0x080218a0

0800acd4 <bmi08x_to_fixed_point>:
; {
 800acd4: b480         	push	{r7}
 800acd6: b085         	sub	sp, #0x14
 800acd8: af00         	add	r7, sp, #0x0
 800acda: 4603         	mov	r3, r0
 800acdc: 603a         	str	r2, [r7]
 800acde: 80fb         	strh	r3, [r7, #0x6]
 800ace0: 460b         	mov	r3, r1
 800ace2: 80bb         	strh	r3, [r7, #0x4]
; 	converted_val = raw_val * scale;
 800ace4: f9b7 3006    	ldrsh.w	r3, [r7, #0x6]
 800ace8: 88ba         	ldrh	r2, [r7, #0x4]
 800acea: fb02 f303    	mul	r3, r2, r3
 800acee: 60fb         	str	r3, [r7, #0xc]
; 	val->val1 = converted_val / 1000000;
 800acf0: 68fb         	ldr	r3, [r7, #0xc]
 800acf2: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800ad28 <bmi08x_to_fixed_point+0x54>
 800acf4: fb82 1203    	smull	r1, r2, r2, r3
 800acf8: 1492         	asrs	r2, r2, #0x12
 800acfa: 17db         	asrs	r3, r3, #0x1f
 800acfc: 1ad2         	subs	r2, r2, r3
 800acfe: 683b         	ldr	r3, [r7]
 800ad00: 601a         	str	r2, [r3]
; 	val->val2 = converted_val % 1000000;
 800ad02: 68fa         	ldr	r2, [r7, #0xc]
 800ad04: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800ad28 <bmi08x_to_fixed_point+0x54>
 800ad06: fb83 1302    	smull	r1, r3, r3, r2
 800ad0a: 1499         	asrs	r1, r3, #0x12
 800ad0c: 17d3         	asrs	r3, r2, #0x1f
 800ad0e: 1acb         	subs	r3, r1, r3
 800ad10: 4906         	ldr	r1, [pc, #0x18]         @ 0x800ad2c <bmi08x_to_fixed_point+0x58>
 800ad12: fb01 f303    	mul	r3, r1, r3
 800ad16: 1ad3         	subs	r3, r2, r3
 800ad18: 683a         	ldr	r2, [r7]
 800ad1a: 6053         	str	r3, [r2, #0x4]
; }
 800ad1c: bf00         	nop
 800ad1e: 3714         	adds	r7, #0x14
 800ad20: 46bd         	mov	sp, r7
 800ad22: f85d 7b04    	ldr	r7, [sp], #4
 800ad26: 4770         	bx	lr

0800ad28 <$d>:
 800ad28: 83 de 1b 43  	.word	0x431bde83
 800ad2c: 40 42 0f 00  	.word	0x000f4240

0800ad30 <bmi08x_channel_get>:
; {
 800ad30: b580         	push	{r7, lr}
 800ad32: b08a         	sub	sp, #0x28
 800ad34: af04         	add	r7, sp, #0x10
 800ad36: 60f8         	str	r0, [r7, #0xc]
 800ad38: 460b         	mov	r3, r1
 800ad3a: 607a         	str	r2, [r7, #0x4]
 800ad3c: 817b         	strh	r3, [r7, #0xa]
; 	switch ((int16_t)chan) {
 800ad3e: f9b7 300a    	ldrsh.w	r3, [r7, #0xa]
 800ad42: 3b04         	subs	r3, #0x4
 800ad44: 2b03         	cmp	r3, #0x3
 800ad46: d807         	bhi	0x800ad58 <bmi08x_channel_get+0x28> @ imm = #0xe
; 		bmi08x_gyr_channel_get(dev, chan, val);
 800ad48: 897b         	ldrh	r3, [r7, #0xa]
 800ad4a: 687a         	ldr	r2, [r7, #0x4]
 800ad4c: 4619         	mov	r1, r3
 800ad4e: 68f8         	ldr	r0, [r7, #0xc]
 800ad50: f010 f8db    	bl	0x801af0a <bmi08x_gyr_channel_get> @ imm = #0x101b6
; 		return 0;
 800ad54: 2300         	movs	r3, #0x0
 800ad56: e01d         	b	0x800ad94 <bmi08x_channel_get+0x64> @ imm = #0x3a
; 		LOG_DBG("Channel not supported.");
 800ad58: 2303         	movs	r3, #0x3
 800ad5a: 2b03         	cmp	r3, #0x3
 800ad5c: d918         	bls	0x800ad90 <bmi08x_channel_get+0x60> @ imm = #0x30
 800ad5e: 2301         	movs	r3, #0x1
 800ad60: 75fb         	strb	r3, [r7, #0x17]
 800ad62: 7dfb         	ldrb	r3, [r7, #0x17]
 800ad64: f083 0301    	eor	r3, r3, #0x1
 800ad68: b2db         	uxtb	r3, r3
 800ad6a: 2b00         	cmp	r3, #0x0
 800ad6c: d110         	bne	0x800ad90 <bmi08x_channel_get+0x60> @ imm = #0x20
 800ad6e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ad9c <bmi08x_channel_get+0x6c>
 800ad70: 6819         	ldr	r1, [r3]
 800ad72: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ada0 <bmi08x_channel_get+0x70>
 800ad74: 9303         	str	r3, [sp, #0xc]
 800ad76: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800ada4 <bmi08x_channel_get+0x74>
 800ad78: 9302         	str	r3, [sp, #0x8]
 800ad7a: 2308         	movs	r3, #0x8
 800ad7c: 9301         	str	r3, [sp, #0x4]
 800ad7e: 2300         	movs	r3, #0x0
 800ad80: 9300         	str	r3, [sp]
 800ad82: 2300         	movs	r3, #0x0
 800ad84: 2204         	movs	r2, #0x4
 800ad86: 2000         	movs	r0, #0x0
 800ad88: f00f fead    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfd5a
 800ad8c: 2300         	movs	r3, #0x0
 800ad8e: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 800ad90: f06f 0385    	mvn	r3, #0x85
; }
 800ad94: 4618         	mov	r0, r3
 800ad96: 3718         	adds	r7, #0x18
 800ad98: 46bd         	mov	sp, r7
 800ad9a: bd80         	pop	{r7, pc}

0800ad9c <$d>:
 800ad9c: 68 05 00 20  	.word	0x20000568
 800ada0: 30 2b 02 08  	.word	0x08022b30
 800ada4: c0 18 02 08  	.word	0x080218c0

0800ada8 <bmi08x_gyro_init>:
; {
 800ada8: b580         	push	{r7, lr}
 800adaa: b09e         	sub	sp, #0x78
 800adac: af04         	add	r7, sp, #0x10
 800adae: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_gyro_config *config = dev->config;
 800adb0: 687b         	ldr	r3, [r7, #0x4]
 800adb2: 685b         	ldr	r3, [r3, #0x4]
 800adb4: 663b         	str	r3, [r7, #0x60]
; 	uint8_t val = 0U;
 800adb6: 2300         	movs	r3, #0x0
 800adb8: 73fb         	strb	r3, [r7, #0xf]
; 	ret = bmi08x_bus_check(dev);
 800adba: 6878         	ldr	r0, [r7, #0x4]
 800adbc: f00f ffc2    	bl	0x801ad44 <bmi08x_bus_check> @ imm = #0xff84
 800adc0: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800adc2: 6e7b         	ldr	r3, [r7, #0x64]
 800adc4: 2b00         	cmp	r3, #0x0
 800adc6: da1e         	bge	0x800ae06 <bmi08x_gyro_init+0x5e> @ imm = #0x3c
; 		LOG_ERR("Bus not ready for '%s'", dev->name);
 800adc8: 2303         	movs	r3, #0x3
 800adca: 2b00         	cmp	r3, #0x0
 800adcc: d019         	beq	0x800ae02 <bmi08x_gyro_init+0x5a> @ imm = #0x32
 800adce: 2301         	movs	r3, #0x1
 800add0: 75fb         	strb	r3, [r7, #0x17]
 800add2: 7dfb         	ldrb	r3, [r7, #0x17]
 800add4: f083 0301    	eor	r3, r3, #0x1
 800add8: b2db         	uxtb	r3, r3
 800adda: 2b00         	cmp	r3, #0x0
 800addc: d111         	bne	0x800ae02 <bmi08x_gyro_init+0x5a> @ imm = #0x22
 800adde: 4ba8         	ldr	r3, [pc, #0x2a0]        @ 0x800b080 <bmi08x_gyro_init+0x2d8>
 800ade0: 6819         	ldr	r1, [r3]
 800ade2: 687b         	ldr	r3, [r7, #0x4]
 800ade4: 681b         	ldr	r3, [r3]
 800ade6: 9303         	str	r3, [sp, #0xc]
 800ade8: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x800b084 <bmi08x_gyro_init+0x2dc>
 800adea: 9302         	str	r3, [sp, #0x8]
 800adec: 2300         	movs	r3, #0x0
 800adee: 9301         	str	r3, [sp, #0x4]
 800adf0: 2300         	movs	r3, #0x0
 800adf2: 9300         	str	r3, [sp]
 800adf4: 2300         	movs	r3, #0x0
 800adf6: 2201         	movs	r2, #0x1
 800adf8: 2000         	movs	r0, #0x0
 800adfa: f00f fe74    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfce8
 800adfe: 2300         	movs	r3, #0x0
 800ae00: 613b         	str	r3, [r7, #0x10]
; 		return ret;
 800ae02: 6e7b         	ldr	r3, [r7, #0x64]
 800ae04: e179         	b	0x800b0fa <bmi08x_gyro_init+0x352> @ imm = #0x2f2
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_SOFTRESET, BMI08X_SOFT_RESET_CMD);
 800ae06: 22b6         	movs	r2, #0xb6
 800ae08: 2114         	movs	r1, #0x14
 800ae0a: 6878         	ldr	r0, [r7, #0x4]
 800ae0c: f00f fff8    	bl	0x801ae00 <bmi08x_gyro_byte_write> @ imm = #0xfff0
 800ae10: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800ae12: 6e7b         	ldr	r3, [r7, #0x64]
 800ae14: 2b00         	cmp	r3, #0x0
 800ae16: da1b         	bge	0x800ae50 <bmi08x_gyro_init+0xa8> @ imm = #0x36
; 		LOG_ERR("Cannot reboot chip.");
 800ae18: 2303         	movs	r3, #0x3
 800ae1a: 2b00         	cmp	r3, #0x0
 800ae1c: d016         	beq	0x800ae4c <bmi08x_gyro_init+0xa4> @ imm = #0x2c
 800ae1e: 2301         	movs	r3, #0x1
 800ae20: 77fb         	strb	r3, [r7, #0x1f]
 800ae22: 7ffb         	ldrb	r3, [r7, #0x1f]
 800ae24: f083 0301    	eor	r3, r3, #0x1
 800ae28: b2db         	uxtb	r3, r3
 800ae2a: 2b00         	cmp	r3, #0x0
 800ae2c: d10e         	bne	0x800ae4c <bmi08x_gyro_init+0xa4> @ imm = #0x1c
 800ae2e: 4b94         	ldr	r3, [pc, #0x250]        @ 0x800b080 <bmi08x_gyro_init+0x2d8>
 800ae30: 6819         	ldr	r1, [r3]
 800ae32: 4b95         	ldr	r3, [pc, #0x254]        @ 0x800b088 <bmi08x_gyro_init+0x2e0>
 800ae34: 9302         	str	r3, [sp, #0x8]
 800ae36: 2300         	movs	r3, #0x0
 800ae38: 9301         	str	r3, [sp, #0x4]
 800ae3a: 2300         	movs	r3, #0x0
 800ae3c: 9300         	str	r3, [sp]
 800ae3e: 2300         	movs	r3, #0x0
 800ae40: 2201         	movs	r2, #0x1
 800ae42: 2000         	movs	r0, #0x0
 800ae44: f00f fe4f    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfc9e
 800ae48: 2300         	movs	r3, #0x0
 800ae4a: 61bb         	str	r3, [r7, #0x18]
; 		return ret;
 800ae4c: 6e7b         	ldr	r3, [r7, #0x64]
 800ae4e: e154         	b	0x800b0fa <bmi08x_gyro_init+0x352> @ imm = #0x2a8
; 	k_msleep(BMI08X_GYRO_SOFTRESET_DELAY);
 800ae50: 201e         	movs	r0, #0x1e
 800ae52: f00f fe0e    	bl	0x801aa72 <k_msleep>    @ imm = #0xfc1c
; 	ret = bmi08x_gyro_byte_read(dev, BMI08X_REG_GYRO_CHIP_ID, &val);
 800ae56: f107 030f    	add.w	r3, r7, #0xf
 800ae5a: 461a         	mov	r2, r3
 800ae5c: 2100         	movs	r1, #0x0
 800ae5e: 6878         	ldr	r0, [r7, #0x4]
 800ae60: f00f ffb7    	bl	0x801add2 <bmi08x_gyro_byte_read> @ imm = #0xff6e
 800ae64: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800ae66: 6e7b         	ldr	r3, [r7, #0x64]
 800ae68: 2b00         	cmp	r3, #0x0
 800ae6a: da1d         	bge	0x800aea8 <bmi08x_gyro_init+0x100> @ imm = #0x3a
; 		LOG_ERR("Failed to read chip id.");
 800ae6c: 2303         	movs	r3, #0x3
 800ae6e: 2b00         	cmp	r3, #0x0
 800ae70: d018         	beq	0x800aea4 <bmi08x_gyro_init+0xfc> @ imm = #0x30
 800ae72: 2301         	movs	r3, #0x1
 800ae74: f887 3027    	strb.w	r3, [r7, #0x27]
 800ae78: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800ae7c: f083 0301    	eor	r3, r3, #0x1
 800ae80: b2db         	uxtb	r3, r3
 800ae82: 2b00         	cmp	r3, #0x0
 800ae84: d10e         	bne	0x800aea4 <bmi08x_gyro_init+0xfc> @ imm = #0x1c
 800ae86: 4b7e         	ldr	r3, [pc, #0x1f8]        @ 0x800b080 <bmi08x_gyro_init+0x2d8>
 800ae88: 6819         	ldr	r1, [r3]
 800ae8a: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800b08c <bmi08x_gyro_init+0x2e4>
 800ae8c: 9302         	str	r3, [sp, #0x8]
 800ae8e: 2300         	movs	r3, #0x0
 800ae90: 9301         	str	r3, [sp, #0x4]
 800ae92: 2300         	movs	r3, #0x0
 800ae94: 9300         	str	r3, [sp]
 800ae96: 2300         	movs	r3, #0x0
 800ae98: 2201         	movs	r2, #0x1
 800ae9a: 2000         	movs	r0, #0x0
 800ae9c: f00f fe23    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfc46
 800aea0: 2300         	movs	r3, #0x0
 800aea2: 623b         	str	r3, [r7, #0x20]
; 		return ret;
 800aea4: 6e7b         	ldr	r3, [r7, #0x64]
 800aea6: e128         	b	0x800b0fa <bmi08x_gyro_init+0x352> @ imm = #0x250
; 	if (val != BMI08X_GYRO_CHIP_ID) {
 800aea8: 7bfb         	ldrb	r3, [r7, #0xf]
 800aeaa: 2b0f         	cmp	r3, #0xf
 800aeac: d020         	beq	0x800aef0 <bmi08x_gyro_init+0x148> @ imm = #0x40
; 		LOG_ERR("Unsupported chip detected (0x%02x)!", val);
 800aeae: 2303         	movs	r3, #0x3
 800aeb0: 2b00         	cmp	r3, #0x0
 800aeb2: d01a         	beq	0x800aeea <bmi08x_gyro_init+0x142> @ imm = #0x34
 800aeb4: 2301         	movs	r3, #0x1
 800aeb6: f887 302f    	strb.w	r3, [r7, #0x2f]
 800aeba: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800aebe: f083 0301    	eor	r3, r3, #0x1
 800aec2: b2db         	uxtb	r3, r3
 800aec4: 2b00         	cmp	r3, #0x0
 800aec6: d110         	bne	0x800aeea <bmi08x_gyro_init+0x142> @ imm = #0x20
 800aec8: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x800b080 <bmi08x_gyro_init+0x2d8>
 800aeca: 6819         	ldr	r1, [r3]
 800aecc: 7bfb         	ldrb	r3, [r7, #0xf]
 800aece: 9303         	str	r3, [sp, #0xc]
 800aed0: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x800b090 <bmi08x_gyro_init+0x2e8>
 800aed2: 9302         	str	r3, [sp, #0x8]
 800aed4: 2300         	movs	r3, #0x0
 800aed6: 9301         	str	r3, [sp, #0x4]
 800aed8: 2300         	movs	r3, #0x0
 800aeda: 9300         	str	r3, [sp]
 800aedc: 2300         	movs	r3, #0x0
 800aede: 2201         	movs	r2, #0x1
 800aee0: 2000         	movs	r0, #0x0
 800aee2: f00f fe00    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfc00
 800aee6: 2300         	movs	r3, #0x0
 800aee8: 62bb         	str	r3, [r7, #0x28]
; 		return -ENODEV;
 800aeea: f06f 0312    	mvn	r3, #0x12
 800aeee: e104         	b	0x800b0fa <bmi08x_gyro_init+0x352> @ imm = #0x208
; 	ret = bmi08x_gyr_range_set(dev, config->gyro_fs);
 800aef0: 6e3b         	ldr	r3, [r7, #0x60]
 800aef2: 8d1b         	ldrh	r3, [r3, #0x28]
 800aef4: 4619         	mov	r1, r3
 800aef6: 6878         	ldr	r0, [r7, #0x4]
 800aef8: f7ff fd70    	bl	0x800a9dc <bmi08x_gyr_range_set> @ imm = #-0x520
 800aefc: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800aefe: 6e7b         	ldr	r3, [r7, #0x64]
 800af00: 2b00         	cmp	r3, #0x0
 800af02: da1d         	bge	0x800af40 <bmi08x_gyro_init+0x198> @ imm = #0x3a
; 		LOG_ERR("Cannot set default range for gyroscope.");
 800af04: 2303         	movs	r3, #0x3
 800af06: 2b00         	cmp	r3, #0x0
 800af08: d018         	beq	0x800af3c <bmi08x_gyro_init+0x194> @ imm = #0x30
 800af0a: 2301         	movs	r3, #0x1
 800af0c: f887 3037    	strb.w	r3, [r7, #0x37]
 800af10: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800af14: f083 0301    	eor	r3, r3, #0x1
 800af18: b2db         	uxtb	r3, r3
 800af1a: 2b00         	cmp	r3, #0x0
 800af1c: d10e         	bne	0x800af3c <bmi08x_gyro_init+0x194> @ imm = #0x1c
 800af1e: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800b080 <bmi08x_gyro_init+0x2d8>
 800af20: 6819         	ldr	r1, [r3]
 800af22: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800b094 <bmi08x_gyro_init+0x2ec>
 800af24: 9302         	str	r3, [sp, #0x8]
 800af26: 2300         	movs	r3, #0x0
 800af28: 9301         	str	r3, [sp, #0x4]
 800af2a: 2300         	movs	r3, #0x0
 800af2c: 9300         	str	r3, [sp]
 800af2e: 2300         	movs	r3, #0x0
 800af30: 2201         	movs	r2, #0x1
 800af32: 2000         	movs	r0, #0x0
 800af34: f00f fdd7    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfbae
 800af38: 2300         	movs	r3, #0x0
 800af3a: 633b         	str	r3, [r7, #0x30]
; 		return ret;
 800af3c: 6e7b         	ldr	r3, [r7, #0x64]
 800af3e: e0dc         	b	0x800b0fa <bmi08x_gyro_init+0x352> @ imm = #0x1b8
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_BANDWIDTH, config->gyro_hz);
 800af40: 6e3b         	ldr	r3, [r7, #0x60]
 800af42: f893 3026    	ldrb.w	r3, [r3, #0x26]
 800af46: 461a         	mov	r2, r3
 800af48: 2110         	movs	r1, #0x10
 800af4a: 6878         	ldr	r0, [r7, #0x4]
 800af4c: f00f ff58    	bl	0x801ae00 <bmi08x_gyro_byte_write> @ imm = #0xfeb0
 800af50: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800af52: 6e7b         	ldr	r3, [r7, #0x64]
 800af54: 2b00         	cmp	r3, #0x0
 800af56: da1d         	bge	0x800af94 <bmi08x_gyro_init+0x1ec> @ imm = #0x3a
; 		LOG_ERR("Failed to set gyro's default ODR.");
 800af58: 2303         	movs	r3, #0x3
 800af5a: 2b00         	cmp	r3, #0x0
 800af5c: d018         	beq	0x800af90 <bmi08x_gyro_init+0x1e8> @ imm = #0x30
 800af5e: 2301         	movs	r3, #0x1
 800af60: f887 303f    	strb.w	r3, [r7, #0x3f]
 800af64: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800af68: f083 0301    	eor	r3, r3, #0x1
 800af6c: b2db         	uxtb	r3, r3
 800af6e: 2b00         	cmp	r3, #0x0
 800af70: d10e         	bne	0x800af90 <bmi08x_gyro_init+0x1e8> @ imm = #0x1c
 800af72: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800b080 <bmi08x_gyro_init+0x2d8>
 800af74: 6819         	ldr	r1, [r3]
 800af76: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800b098 <bmi08x_gyro_init+0x2f0>
 800af78: 9302         	str	r3, [sp, #0x8]
 800af7a: 2300         	movs	r3, #0x0
 800af7c: 9301         	str	r3, [sp, #0x4]
 800af7e: 2300         	movs	r3, #0x0
 800af80: 9300         	str	r3, [sp]
 800af82: 2300         	movs	r3, #0x0
 800af84: 2201         	movs	r2, #0x1
 800af86: 2000         	movs	r0, #0x0
 800af88: f00f fdad    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfb5a
 800af8c: 2300         	movs	r3, #0x0
 800af8e: 63bb         	str	r3, [r7, #0x38]
; 		return ret;
 800af90: 6e7b         	ldr	r3, [r7, #0x64]
 800af92: e0b2         	b	0x800b0fa <bmi08x_gyro_init+0x352> @ imm = #0x164
; 	ret = bmi08x_gyr_trigger_mode_init(dev);
 800af94: 6878         	ldr	r0, [r7, #0x4]
 800af96: f000 faed    	bl	0x800b574 <bmi08x_gyr_trigger_mode_init> @ imm = #0x5da
 800af9a: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800af9c: 6e7b         	ldr	r3, [r7, #0x64]
 800af9e: 2b00         	cmp	r3, #0x0
 800afa0: da1d         	bge	0x800afde <bmi08x_gyro_init+0x236> @ imm = #0x3a
; 		LOG_ERR("Cannot set up trigger mode.");
 800afa2: 2303         	movs	r3, #0x3
 800afa4: 2b00         	cmp	r3, #0x0
 800afa6: d018         	beq	0x800afda <bmi08x_gyro_init+0x232> @ imm = #0x30
 800afa8: 2301         	movs	r3, #0x1
 800afaa: f887 3047    	strb.w	r3, [r7, #0x47]
 800afae: f897 3047    	ldrb.w	r3, [r7, #0x47]
 800afb2: f083 0301    	eor	r3, r3, #0x1
 800afb6: b2db         	uxtb	r3, r3
 800afb8: 2b00         	cmp	r3, #0x0
 800afba: d10e         	bne	0x800afda <bmi08x_gyro_init+0x232> @ imm = #0x1c
 800afbc: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x800b080 <bmi08x_gyro_init+0x2d8>
 800afbe: 6819         	ldr	r1, [r3]
 800afc0: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800b09c <bmi08x_gyro_init+0x2f4>
 800afc2: 9302         	str	r3, [sp, #0x8]
 800afc4: 2300         	movs	r3, #0x0
 800afc6: 9301         	str	r3, [sp, #0x4]
 800afc8: 2300         	movs	r3, #0x0
 800afca: 9300         	str	r3, [sp]
 800afcc: 2300         	movs	r3, #0x0
 800afce: 2201         	movs	r2, #0x1
 800afd0: 2000         	movs	r0, #0x0
 800afd2: f00f fd88    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfb10
 800afd6: 2300         	movs	r3, #0x0
 800afd8: 643b         	str	r3, [r7, #0x40]
; 		return ret;
 800afda: 6e7b         	ldr	r3, [r7, #0x64]
 800afdc: e08d         	b	0x800b0fa <bmi08x_gyro_init+0x352> @ imm = #0x11a
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT_CTRL, 0x80);
 800afde: 2280         	movs	r2, #0x80
 800afe0: 2115         	movs	r1, #0x15
 800afe2: 6878         	ldr	r0, [r7, #0x4]
 800afe4: f00f ff0c    	bl	0x801ae00 <bmi08x_gyro_byte_write> @ imm = #0xfe18
 800afe8: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800afea: 6e7b         	ldr	r3, [r7, #0x64]
 800afec: 2b00         	cmp	r3, #0x0
 800afee: da1d         	bge	0x800b02c <bmi08x_gyro_init+0x284> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800aff0: 2303         	movs	r3, #0x3
 800aff2: 2b00         	cmp	r3, #0x0
 800aff4: d018         	beq	0x800b028 <bmi08x_gyro_init+0x280> @ imm = #0x30
 800aff6: 2301         	movs	r3, #0x1
 800aff8: f887 304f    	strb.w	r3, [r7, #0x4f]
 800affc: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 800b000: f083 0301    	eor	r3, r3, #0x1
 800b004: b2db         	uxtb	r3, r3
 800b006: 2b00         	cmp	r3, #0x0
 800b008: d10e         	bne	0x800b028 <bmi08x_gyro_init+0x280> @ imm = #0x1c
 800b00a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800b080 <bmi08x_gyro_init+0x2d8>
 800b00c: 6819         	ldr	r1, [r3]
 800b00e: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800b0a0 <bmi08x_gyro_init+0x2f8>
 800b010: 9302         	str	r3, [sp, #0x8]
 800b012: 2300         	movs	r3, #0x0
 800b014: 9301         	str	r3, [sp, #0x4]
 800b016: 2300         	movs	r3, #0x0
 800b018: 9300         	str	r3, [sp]
 800b01a: 2300         	movs	r3, #0x0
 800b01c: 2201         	movs	r2, #0x1
 800b01e: 2000         	movs	r0, #0x0
 800b020: f00f fd61    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfac2
 800b024: 2300         	movs	r3, #0x0
 800b026: 64bb         	str	r3, [r7, #0x48]
; 		return ret;
 800b028: 6e7b         	ldr	r3, [r7, #0x64]
 800b02a: e066         	b	0x800b0fa <bmi08x_gyro_init+0x352> @ imm = #0xcc
; 				     config->int3_4_conf_io);
 800b02c: 6e3b         	ldr	r3, [r7, #0x60]
 800b02e: f893 3025    	ldrb.w	r3, [r3, #0x25]
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT3_INT4_IO_CONF,
 800b032: 461a         	mov	r2, r3
 800b034: 2116         	movs	r1, #0x16
 800b036: 6878         	ldr	r0, [r7, #0x4]
 800b038: f00f fee2    	bl	0x801ae00 <bmi08x_gyro_byte_write> @ imm = #0xfdc4
 800b03c: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800b03e: 6e7b         	ldr	r3, [r7, #0x64]
 800b040: 2b00         	cmp	r3, #0x0
 800b042: da2f         	bge	0x800b0a4 <bmi08x_gyro_init+0x2fc> @ imm = #0x5e
; 		LOG_ERR("Failed to map interrupts.");
 800b044: 2303         	movs	r3, #0x3
 800b046: 2b00         	cmp	r3, #0x0
 800b048: d018         	beq	0x800b07c <bmi08x_gyro_init+0x2d4> @ imm = #0x30
 800b04a: 2301         	movs	r3, #0x1
 800b04c: f887 3057    	strb.w	r3, [r7, #0x57]
 800b050: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800b054: f083 0301    	eor	r3, r3, #0x1
 800b058: b2db         	uxtb	r3, r3
 800b05a: 2b00         	cmp	r3, #0x0
 800b05c: d10e         	bne	0x800b07c <bmi08x_gyro_init+0x2d4> @ imm = #0x1c
 800b05e: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800b080 <bmi08x_gyro_init+0x2d8>
 800b060: 6819         	ldr	r1, [r3]
 800b062: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800b0a0 <bmi08x_gyro_init+0x2f8>
 800b064: 9302         	str	r3, [sp, #0x8]
 800b066: 2300         	movs	r3, #0x0
 800b068: 9301         	str	r3, [sp, #0x4]
 800b06a: 2300         	movs	r3, #0x0
 800b06c: 9300         	str	r3, [sp]
 800b06e: 2300         	movs	r3, #0x0
 800b070: 2201         	movs	r2, #0x1
 800b072: 2000         	movs	r0, #0x0
 800b074: f00f fd37    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xfa6e
 800b078: 2300         	movs	r3, #0x0
 800b07a: 653b         	str	r3, [r7, #0x50]
; 		return ret;
 800b07c: 6e7b         	ldr	r3, [r7, #0x64]
 800b07e: e03c         	b	0x800b0fa <bmi08x_gyro_init+0x352> @ imm = #0x78

0800b080 <$d>:
 800b080: 68 05 00 20  	.word	0x20000568
 800b084: dc 18 02 08  	.word	0x080218dc
 800b088: f4 18 02 08  	.word	0x080218f4
 800b08c: 08 19 02 08  	.word	0x08021908
 800b090: 20 19 02 08  	.word	0x08021920
 800b094: 44 19 02 08  	.word	0x08021944
 800b098: 6c 19 02 08  	.word	0x0802196c
 800b09c: 90 19 02 08  	.word	0x08021990
 800b0a0: ac 19 02 08  	.word	0x080219ac

0800b0a4 <$t>:
; 	ret = bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_INT3_INT4_IO_MAP, config->int3_4_map);
 800b0a4: 6e3b         	ldr	r3, [r7, #0x60]
 800b0a6: f893 3024    	ldrb.w	r3, [r3, #0x24]
 800b0aa: 461a         	mov	r2, r3
 800b0ac: 2118         	movs	r1, #0x18
 800b0ae: 6878         	ldr	r0, [r7, #0x4]
 800b0b0: f00f fea6    	bl	0x801ae00 <bmi08x_gyro_byte_write> @ imm = #0xfd4c
 800b0b4: 6678         	str	r0, [r7, #0x64]
; 	if (ret < 0) {
 800b0b6: 6e7b         	ldr	r3, [r7, #0x64]
 800b0b8: 2b00         	cmp	r3, #0x0
 800b0ba: da1d         	bge	0x800b0f8 <bmi08x_gyro_init+0x350> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800b0bc: 2303         	movs	r3, #0x3
 800b0be: 2b00         	cmp	r3, #0x0
 800b0c0: d018         	beq	0x800b0f4 <bmi08x_gyro_init+0x34c> @ imm = #0x30
 800b0c2: 2301         	movs	r3, #0x1
 800b0c4: f887 305f    	strb.w	r3, [r7, #0x5f]
 800b0c8: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 800b0cc: f083 0301    	eor	r3, r3, #0x1
 800b0d0: b2db         	uxtb	r3, r3
 800b0d2: 2b00         	cmp	r3, #0x0
 800b0d4: d10e         	bne	0x800b0f4 <bmi08x_gyro_init+0x34c> @ imm = #0x1c
 800b0d6: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b104 <bmi08x_gyro_init+0x35c>
 800b0d8: 6819         	ldr	r1, [r3]
 800b0da: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b108 <bmi08x_gyro_init+0x360>
 800b0dc: 9302         	str	r3, [sp, #0x8]
 800b0de: 2300         	movs	r3, #0x0
 800b0e0: 9301         	str	r3, [sp, #0x4]
 800b0e2: 2300         	movs	r3, #0x0
 800b0e4: 9300         	str	r3, [sp]
 800b0e6: 2300         	movs	r3, #0x0
 800b0e8: 2201         	movs	r2, #0x1
 800b0ea: 2000         	movs	r0, #0x0
 800b0ec: f00f fcfb    	bl	0x801aae6 <z_log_msg_runtime_create> @ imm = #0xf9f6
 800b0f0: 2300         	movs	r3, #0x0
 800b0f2: 65bb         	str	r3, [r7, #0x58]
; 		return ret;
 800b0f4: 6e7b         	ldr	r3, [r7, #0x64]
 800b0f6: e000         	b	0x800b0fa <bmi08x_gyro_init+0x352> @ imm = #0x0
; 	return ret;
 800b0f8: 6e7b         	ldr	r3, [r7, #0x64]
; }
 800b0fa: 4618         	mov	r0, r3
 800b0fc: 3768         	adds	r7, #0x68
 800b0fe: 46bd         	mov	sp, r7
 800b100: bd80         	pop	{r7, pc}
 800b102: bf00         	nop

0800b104 <$d>:
 800b104: 68 05 00 20  	.word	0x20000568
 800b108: ac 19 02 08  	.word	0x080219ac

0800b10c <bmi08x_freq_to_odr_val>:
; {
 800b10c: b480         	push	{r7}
 800b10e: b085         	sub	sp, #0x14
 800b110: af00         	add	r7, sp, #0x0
 800b112: 4603         	mov	r3, r0
 800b114: 460a         	mov	r2, r1
 800b116: 80fb         	strh	r3, [r7, #0x6]
 800b118: 4613         	mov	r3, r2
 800b11a: 80bb         	strh	r3, [r7, #0x4]
; 	if (freq_int == 0U && freq_milli == 0U) {
 800b11c: 88fb         	ldrh	r3, [r7, #0x6]
 800b11e: 2b00         	cmp	r3, #0x0
 800b120: d105         	bne	0x800b12e <bmi08x_freq_to_odr_val+0x22> @ imm = #0xa
 800b122: 88bb         	ldrh	r3, [r7, #0x4]
 800b124: 2b00         	cmp	r3, #0x0
 800b126: d102         	bne	0x800b12e <bmi08x_freq_to_odr_val+0x22> @ imm = #0x4
; 		return -EINVAL;
 800b128: f06f 0315    	mvn	r3, #0x15
 800b12c: e022         	b	0x800b174 <bmi08x_freq_to_odr_val+0x68> @ imm = #0x44
; 	for (i = 0; i < ARRAY_SIZE(bmi08x_odr_map); i++) {
 800b12e: 2300         	movs	r3, #0x0
 800b130: 60fb         	str	r3, [r7, #0xc]
 800b132: e01a         	b	0x800b16a <bmi08x_freq_to_odr_val+0x5e> @ imm = #0x34
; 		if (freq_int < bmi08x_odr_map[i].freq_int ||
 800b134: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800b180 <bmi08x_freq_to_odr_val+0x74>
 800b136: 68fb         	ldr	r3, [r7, #0xc]
 800b138: f832 3023    	ldrh.w	r3, [r2, r3, lsl #2]
 800b13c: 88fa         	ldrh	r2, [r7, #0x6]
 800b13e: 429a         	cmp	r2, r3
 800b140: d30e         	blo	0x800b160 <bmi08x_freq_to_odr_val+0x54> @ imm = #0x1c
; 		    (freq_int == bmi08x_odr_map[i].freq_int &&
 800b142: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x800b180 <bmi08x_freq_to_odr_val+0x74>
 800b144: 68fb         	ldr	r3, [r7, #0xc]
 800b146: f832 3023    	ldrh.w	r3, [r2, r3, lsl #2]
; 		if (freq_int < bmi08x_odr_map[i].freq_int ||
 800b14a: 88fa         	ldrh	r2, [r7, #0x6]
 800b14c: 429a         	cmp	r2, r3
 800b14e: d109         	bne	0x800b164 <bmi08x_freq_to_odr_val+0x58> @ imm = #0x12
; 		     freq_milli <= bmi08x_odr_map[i].freq_milli)) {
 800b150: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800b180 <bmi08x_freq_to_odr_val+0x74>
 800b152: 68fb         	ldr	r3, [r7, #0xc]
 800b154: 009b         	lsls	r3, r3, #0x2
 800b156: 4413         	add	r3, r2
 800b158: 885b         	ldrh	r3, [r3, #0x2]
; 		    (freq_int == bmi08x_odr_map[i].freq_int &&
 800b15a: 88ba         	ldrh	r2, [r7, #0x4]
 800b15c: 429a         	cmp	r2, r3
 800b15e: d801         	bhi	0x800b164 <bmi08x_freq_to_odr_val+0x58> @ imm = #0x2
; 			return i;
 800b160: 68fb         	ldr	r3, [r7, #0xc]
 800b162: e007         	b	0x800b174 <bmi08x_freq_to_odr_val+0x68> @ imm = #0xe
; 	for (i = 0; i < ARRAY_SIZE(bmi08x_odr_map); i++) {
 800b164: 68fb         	ldr	r3, [r7, #0xc]
 800b166: 3301         	adds	r3, #0x1
 800b168: 60fb         	str	r3, [r7, #0xc]
 800b16a: 68fb         	ldr	r3, [r7, #0xc]
 800b16c: 2b0d         	cmp	r3, #0xd
 800b16e: d9e1         	bls	0x800b134 <bmi08x_freq_to_odr_val+0x28> @ imm = #-0x3e
; 	return -EINVAL;
 800b170: f06f 0315    	mvn	r3, #0x15
; }
 800b174: 4618         	mov	r0, r3
 800b176: 3714         	adds	r7, #0x14
 800b178: 46bd         	mov	sp, r7
 800b17a: f85d 7b04    	ldr	r7, [sp], #4
 800b17e: 4770         	bx	lr

0800b180 <$d>:
 800b180: 44 2b 02 08  	.word	0x08022b44

0800b184 <z_impl_gpio_pin_interrupt_configure>:
; {
 800b184: b590         	push	{r4, r7, lr}
 800b186: b08b         	sub	sp, #0x2c
 800b188: af00         	add	r7, sp, #0x0
 800b18a: 60f8         	str	r0, [r7, #0xc]
 800b18c: 460b         	mov	r3, r1
 800b18e: 607a         	str	r2, [r7, #0x4]
 800b190: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 800b192: 68fb         	ldr	r3, [r7, #0xc]
 800b194: 689b         	ldr	r3, [r3, #0x8]
 800b196: 627b         	str	r3, [r7, #0x24]
; 	__unused const struct gpio_driver_config *const cfg =
 800b198: 68fb         	ldr	r3, [r7, #0xc]
 800b19a: 685b         	ldr	r3, [r3, #0x4]
 800b19c: 623b         	str	r3, [r7, #0x20]
; 	const struct gpio_driver_data *const data =
 800b19e: 68fb         	ldr	r3, [r7, #0xc]
 800b1a0: 691b         	ldr	r3, [r3, #0x10]
 800b1a2: 61fb         	str	r3, [r7, #0x1c]
; 	if (api->pin_interrupt_configure == NULL) {
 800b1a4: 6a7b         	ldr	r3, [r7, #0x24]
 800b1a6: 699b         	ldr	r3, [r3, #0x18]
 800b1a8: 2b00         	cmp	r3, #0x0
 800b1aa: d102         	bne	0x800b1b2 <z_impl_gpio_pin_interrupt_configure+0x2e> @ imm = #0x4
; 		return -ENOSYS;
 800b1ac: f06f 0357    	mvn	r3, #0x57
 800b1b0: e021         	b	0x800b1f6 <z_impl_gpio_pin_interrupt_configure+0x72> @ imm = #0x42
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800b1b2: 687b         	ldr	r3, [r7, #0x4]
 800b1b4: f403 0300    	and	r3, r3, #0x800000
 800b1b8: 2b00         	cmp	r3, #0x0
 800b1ba: d00c         	beq	0x800b1d6 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x18
; 	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
 800b1bc: 69fb         	ldr	r3, [r7, #0x1c]
 800b1be: 681a         	ldr	r2, [r3]
 800b1c0: 7afb         	ldrb	r3, [r7, #0xb]
 800b1c2: 2101         	movs	r1, #0x1
 800b1c4: fa01 f303    	lsl.w	r3, r1, r3
 800b1c8: 4013         	ands	r3, r2
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800b1ca: 2b00         	cmp	r3, #0x0
 800b1cc: d003         	beq	0x800b1d6 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x6
; 		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
 800b1ce: 687b         	ldr	r3, [r7, #0x4]
 800b1d0: f083 63c0    	eor	r3, r3, #0x6000000
 800b1d4: 607b         	str	r3, [r7, #0x4]
; 	trig = (enum gpio_int_trig)(flags & (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1 | GPIO_INT_WAKEUP));
 800b1d6: 687a         	ldr	r2, [r7, #0x4]
 800b1d8: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800b200 <z_impl_gpio_pin_interrupt_configure+0x7c>
 800b1da: 4013         	ands	r3, r2
 800b1dc: 61bb         	str	r3, [r7, #0x18]
; 	mode = (enum gpio_int_mode)(flags & (GPIO_INT_EDGE | GPIO_INT_DISABLE | GPIO_INT_ENABLE));
 800b1de: 687b         	ldr	r3, [r7, #0x4]
 800b1e0: f003 73b0    	and	r3, r3, #0x1600000
 800b1e4: 617b         	str	r3, [r7, #0x14]
; 	return api->pin_interrupt_configure(port, pin, mode, trig);
 800b1e6: 6a7b         	ldr	r3, [r7, #0x24]
 800b1e8: 699c         	ldr	r4, [r3, #0x18]
 800b1ea: 7af9         	ldrb	r1, [r7, #0xb]
 800b1ec: 69bb         	ldr	r3, [r7, #0x18]
 800b1ee: 697a         	ldr	r2, [r7, #0x14]
 800b1f0: 68f8         	ldr	r0, [r7, #0xc]
 800b1f2: 47a0         	blx	r4
 800b1f4: 4603         	mov	r3, r0
; }
 800b1f6: 4618         	mov	r0, r3
 800b1f8: 372c         	adds	r7, #0x2c
 800b1fa: 46bd         	mov	sp, r7
 800b1fc: bd90         	pop	{r4, r7, pc}
 800b1fe: bf00         	nop

0800b200 <$d>:
 800b200: 40 00 00 06  	.word	0x06000040

0800b204 <bmi08x_acc_thread_main>:
; {
 800b204: b580         	push	{r7, lr}
 800b206: b086         	sub	sp, #0x18
 800b208: af00         	add	r7, sp, #0x0
 800b20a: 60f8         	str	r0, [r7, #0xc]
 800b20c: 60b9         	str	r1, [r7, #0x8]
 800b20e: 607a         	str	r2, [r7, #0x4]
; 	k_thread_name_set(NULL, "bmi08x_acc_trig");
 800b210: 490b         	ldr	r1, [pc, #0x2c]         @ 0x800b240 <bmi08x_acc_thread_main+0x3c>
 800b212: 2000         	movs	r0, #0x0
 800b214: f00f ffb5    	bl	0x801b182 <k_thread_name_set> @ imm = #0xff6a
; 	const struct device *dev = (const struct device *)arg1;
 800b218: 68fb         	ldr	r3, [r7, #0xc]
 800b21a: 617b         	str	r3, [r7, #0x14]
; 	struct bmi08x_accel_data *data = dev->data;
 800b21c: 697b         	ldr	r3, [r7, #0x14]
 800b21e: 691b         	ldr	r3, [r3, #0x10]
 800b220: 613b         	str	r3, [r7, #0x10]
; 		k_sem_take(&data->sem, K_FOREVER);
 800b222: 693b         	ldr	r3, [r7, #0x10]
 800b224: f503 6113    	add.w	r1, r3, #0x930
 800b228: f04f 32ff    	mov.w	r2, #0xffffffff
 800b22c: f04f 33ff    	mov.w	r3, #0xffffffff
 800b230: 4608         	mov	r0, r1
 800b232: f00f ffc4    	bl	0x801b1be <k_sem_take>  @ imm = #0xff88
; 		bmi08x_handle_interrupts_acc((void *)dev);
 800b236: 6978         	ldr	r0, [r7, #0x14]
 800b238: f010 f813    	bl	0x801b262 <bmi08x_handle_interrupts_acc> @ imm = #0x10026
; 	while (1) {
 800b23c: bf00         	nop
 800b23e: e7f0         	b	0x800b222 <bmi08x_acc_thread_main+0x1e> @ imm = #-0x20

0800b240 <$d>:
 800b240: d8 19 02 08  	.word	0x080219d8

0800b244 <bmi08x_acc_trigger_mode_init>:
; {
 800b244: b5b0         	push	{r4, r5, r7, lr}
 800b246: b098         	sub	sp, #0x60
 800b248: af08         	add	r7, sp, #0x20
 800b24a: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 800b24c: 687b         	ldr	r3, [r7, #0x4]
 800b24e: 691b         	ldr	r3, [r3, #0x10]
 800b250: 63fb         	str	r3, [r7, #0x3c]
; 	const struct bmi08x_accel_config *cfg = dev->config;
 800b252: 687b         	ldr	r3, [r7, #0x4]
 800b254: 685b         	ldr	r3, [r3, #0x4]
 800b256: 63bb         	str	r3, [r7, #0x38]
; 	int ret = 0;
 800b258: 2300         	movs	r3, #0x0
 800b25a: 637b         	str	r3, [r7, #0x34]
; 	if (!gpio_is_ready_dt(&cfg->int_gpio)) {
 800b25c: 6bbb         	ldr	r3, [r7, #0x38]
 800b25e: 331c         	adds	r3, #0x1c
 800b260: 4618         	mov	r0, r3
 800b262: f00f fe9d    	bl	0x801afa0 <gpio_is_ready_dt> @ imm = #0xfd3a
 800b266: 4603         	mov	r3, r0
 800b268: f083 0301    	eor	r3, r3, #0x1
 800b26c: b2db         	uxtb	r3, r3
 800b26e: 2b00         	cmp	r3, #0x0
 800b270: d01c         	beq	0x800b2ac <bmi08x_acc_trigger_mode_init+0x68> @ imm = #0x38
; 		LOG_ERR("GPIO device not ready");
 800b272: 2303         	movs	r3, #0x3
 800b274: 2b00         	cmp	r3, #0x0
 800b276: d016         	beq	0x800b2a6 <bmi08x_acc_trigger_mode_init+0x62> @ imm = #0x2c
 800b278: 2301         	movs	r3, #0x1
 800b27a: 74fb         	strb	r3, [r7, #0x13]
 800b27c: 7cfb         	ldrb	r3, [r7, #0x13]
 800b27e: f083 0301    	eor	r3, r3, #0x1
 800b282: b2db         	uxtb	r3, r3
 800b284: 2b00         	cmp	r3, #0x0
 800b286: d10e         	bne	0x800b2a6 <bmi08x_acc_trigger_mode_init+0x62> @ imm = #0x1c
 800b288: 4b84         	ldr	r3, [pc, #0x210]        @ 0x800b49c <bmi08x_acc_trigger_mode_init+0x258>
 800b28a: 6819         	ldr	r1, [r3]
 800b28c: 4b84         	ldr	r3, [pc, #0x210]        @ 0x800b4a0 <bmi08x_acc_trigger_mode_init+0x25c>
 800b28e: 9302         	str	r3, [sp, #0x8]
 800b290: 2300         	movs	r3, #0x0
 800b292: 9301         	str	r3, [sp, #0x4]
 800b294: 2300         	movs	r3, #0x0
 800b296: 9300         	str	r3, [sp]
 800b298: 2300         	movs	r3, #0x0
 800b29a: 2201         	movs	r2, #0x1
 800b29c: 2000         	movs	r0, #0x0
 800b29e: f00f ffa9    	bl	0x801b1f4 <z_log_msg_runtime_create> @ imm = #0xff52
 800b2a2: 2300         	movs	r3, #0x0
 800b2a4: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800b2a6: f06f 0312    	mvn	r3, #0x12
 800b2aa: e0f2         	b	0x800b492 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x1e4
; 	k_sem_init(&data->sem, 0, K_SEM_MAX_LIMIT);
 800b2ac: 6bfb         	ldr	r3, [r7, #0x3c]
 800b2ae: f503 6313    	add.w	r3, r3, #0x930
 800b2b2: f04f 32ff    	mov.w	r2, #0xffffffff
 800b2b6: 2100         	movs	r1, #0x0
 800b2b8: 4618         	mov	r0, r3
 800b2ba: f00f ff70    	bl	0x801b19e <k_sem_init>  @ imm = #0xfee0
; 	k_thread_create(&data->thread, data->thread_stack,
 800b2be: 6bfb         	ldr	r3, [r7, #0x3c]
 800b2c0: f603 0418    	addw	r4, r3, #0x818
 800b2c4: 6bfb         	ldr	r3, [r7, #0x3c]
 800b2c6: f103 0518    	add.w	r5, r3, #0x18
; 			NULL, NULL, K_PRIO_COOP(CONFIG_BMI08X_ACCEL_THREAD_PRIORITY), 0, K_NO_WAIT);
 800b2ca: f04f 0000    	mov.w	r0, #0x0
 800b2ce: f04f 0100    	mov.w	r1, #0x0
; 	k_thread_create(&data->thread, data->thread_stack,
 800b2d2: e9cd 0106    	strd	r0, r1, [sp, #24]
 800b2d6: 2300         	movs	r3, #0x0
 800b2d8: 9304         	str	r3, [sp, #0x10]
 800b2da: f06f 0305    	mvn	r3, #0x5
 800b2de: 9303         	str	r3, [sp, #0xc]
 800b2e0: 2300         	movs	r3, #0x0
 800b2e2: 9302         	str	r3, [sp, #0x8]
 800b2e4: 2300         	movs	r3, #0x0
 800b2e6: 9301         	str	r3, [sp, #0x4]
 800b2e8: 687b         	ldr	r3, [r7, #0x4]
 800b2ea: 9300         	str	r3, [sp]
 800b2ec: 4b6d         	ldr	r3, [pc, #0x1b4]        @ 0x800b4a4 <bmi08x_acc_trigger_mode_init+0x260>
 800b2ee: f44f 6200    	mov.w	r2, #0x800
 800b2f2: 4629         	mov	r1, r5
 800b2f4: 4620         	mov	r0, r4
 800b2f6: f00f ff24    	bl	0x801b142 <k_thread_create> @ imm = #0xfe48
; 		uint8_t map_data = ((cfg->int2_map << BMI08X_ACCEL_INT2_DRDY_POS) |
 800b2fa: 6bbb         	ldr	r3, [r7, #0x38]
 800b2fc: f893 3025    	ldrb.w	r3, [r3, #0x25]
 800b300: 019b         	lsls	r3, r3, #0x6
 800b302: b25a         	sxtb	r2, r3
; 				    (cfg->int1_map << BMI08X_ACCEL_INT1_DRDY_POS));
 800b304: 6bbb         	ldr	r3, [r7, #0x38]
 800b306: f893 3024    	ldrb.w	r3, [r3, #0x24]
 800b30a: 009b         	lsls	r3, r3, #0x2
; 		uint8_t map_data = ((cfg->int2_map << BMI08X_ACCEL_INT2_DRDY_POS) |
 800b30c: b25b         	sxtb	r3, r3
 800b30e: 4313         	orrs	r3, r2
 800b310: b25b         	sxtb	r3, r3
 800b312: f887 3033    	strb.w	r3, [r7, #0x33]
; 		ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT1_INT2_MAP_DATA, map_data);
 800b316: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800b31a: 461a         	mov	r2, r3
 800b31c: 2158         	movs	r1, #0x58
 800b31e: 6878         	ldr	r0, [r7, #0x4]
 800b320: f00f face    	bl	0x801a8c0 <bmi08x_accel_byte_write> @ imm = #0xf59c
 800b324: 6378         	str	r0, [r7, #0x34]
; 		if (ret < 0) {
 800b326: 6b7b         	ldr	r3, [r7, #0x34]
 800b328: 2b00         	cmp	r3, #0x0
 800b32a: da1b         	bge	0x800b364 <bmi08x_acc_trigger_mode_init+0x120> @ imm = #0x36
; 			LOG_ERR("Failed to map interrupts.");
 800b32c: 2303         	movs	r3, #0x3
 800b32e: 2b00         	cmp	r3, #0x0
 800b330: d016         	beq	0x800b360 <bmi08x_acc_trigger_mode_init+0x11c> @ imm = #0x2c
 800b332: 2301         	movs	r3, #0x1
 800b334: 76fb         	strb	r3, [r7, #0x1b]
 800b336: 7efb         	ldrb	r3, [r7, #0x1b]
 800b338: f083 0301    	eor	r3, r3, #0x1
 800b33c: b2db         	uxtb	r3, r3
 800b33e: 2b00         	cmp	r3, #0x0
 800b340: d10e         	bne	0x800b360 <bmi08x_acc_trigger_mode_init+0x11c> @ imm = #0x1c
 800b342: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800b49c <bmi08x_acc_trigger_mode_init+0x258>
 800b344: 6819         	ldr	r1, [r3]
 800b346: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800b4a8 <bmi08x_acc_trigger_mode_init+0x264>
 800b348: 9302         	str	r3, [sp, #0x8]
 800b34a: 2300         	movs	r3, #0x0
 800b34c: 9301         	str	r3, [sp, #0x4]
 800b34e: 2300         	movs	r3, #0x0
 800b350: 9300         	str	r3, [sp]
 800b352: 2300         	movs	r3, #0x0
 800b354: 2201         	movs	r2, #0x1
 800b356: 2000         	movs	r0, #0x0
 800b358: f00f ff4c    	bl	0x801b1f4 <z_log_msg_runtime_create> @ imm = #0xfe98
 800b35c: 2300         	movs	r3, #0x0
 800b35e: 617b         	str	r3, [r7, #0x14]
; 			return ret;
 800b360: 6b7b         	ldr	r3, [r7, #0x34]
 800b362: e096         	b	0x800b492 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x12c
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT1_IO_CONF, cfg->int1_conf_io);
 800b364: 6bbb         	ldr	r3, [r7, #0x38]
 800b366: f893 3026    	ldrb.w	r3, [r3, #0x26]
 800b36a: 461a         	mov	r2, r3
 800b36c: 2153         	movs	r1, #0x53
 800b36e: 6878         	ldr	r0, [r7, #0x4]
 800b370: f00f faa6    	bl	0x801a8c0 <bmi08x_accel_byte_write> @ imm = #0xf54c
 800b374: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 800b376: 6b7b         	ldr	r3, [r7, #0x34]
 800b378: 2b00         	cmp	r3, #0x0
 800b37a: da1d         	bge	0x800b3b8 <bmi08x_acc_trigger_mode_init+0x174> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800b37c: 2303         	movs	r3, #0x3
 800b37e: 2b00         	cmp	r3, #0x0
 800b380: d018         	beq	0x800b3b4 <bmi08x_acc_trigger_mode_init+0x170> @ imm = #0x30
 800b382: 2301         	movs	r3, #0x1
 800b384: f887 3023    	strb.w	r3, [r7, #0x23]
 800b388: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800b38c: f083 0301    	eor	r3, r3, #0x1
 800b390: b2db         	uxtb	r3, r3
 800b392: 2b00         	cmp	r3, #0x0
 800b394: d10e         	bne	0x800b3b4 <bmi08x_acc_trigger_mode_init+0x170> @ imm = #0x1c
 800b396: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800b49c <bmi08x_acc_trigger_mode_init+0x258>
 800b398: 6819         	ldr	r1, [r3]
 800b39a: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800b4a8 <bmi08x_acc_trigger_mode_init+0x264>
 800b39c: 9302         	str	r3, [sp, #0x8]
 800b39e: 2300         	movs	r3, #0x0
 800b3a0: 9301         	str	r3, [sp, #0x4]
 800b3a2: 2300         	movs	r3, #0x0
 800b3a4: 9300         	str	r3, [sp]
 800b3a6: 2300         	movs	r3, #0x0
 800b3a8: 2201         	movs	r2, #0x1
 800b3aa: 2000         	movs	r0, #0x0
 800b3ac: f00f ff22    	bl	0x801b1f4 <z_log_msg_runtime_create> @ imm = #0xfe44
 800b3b0: 2300         	movs	r3, #0x0
 800b3b2: 61fb         	str	r3, [r7, #0x1c]
; 		return ret;
 800b3b4: 6b7b         	ldr	r3, [r7, #0x34]
 800b3b6: e06c         	b	0x800b492 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0xd8
; 	ret = bmi08x_accel_byte_write(dev, BMI08X_REG_ACCEL_INT2_IO_CONF, cfg->int2_conf_io);
 800b3b8: 6bbb         	ldr	r3, [r7, #0x38]
 800b3ba: f893 3027    	ldrb.w	r3, [r3, #0x27]
 800b3be: 461a         	mov	r2, r3
 800b3c0: 2154         	movs	r1, #0x54
 800b3c2: 6878         	ldr	r0, [r7, #0x4]
 800b3c4: f00f fa7c    	bl	0x801a8c0 <bmi08x_accel_byte_write> @ imm = #0xf4f8
 800b3c8: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 800b3ca: 6b7b         	ldr	r3, [r7, #0x34]
 800b3cc: 2b00         	cmp	r3, #0x0
 800b3ce: da1d         	bge	0x800b40c <bmi08x_acc_trigger_mode_init+0x1c8> @ imm = #0x3a
; 		LOG_ERR("Failed to map interrupts.");
 800b3d0: 2303         	movs	r3, #0x3
 800b3d2: 2b00         	cmp	r3, #0x0
 800b3d4: d018         	beq	0x800b408 <bmi08x_acc_trigger_mode_init+0x1c4> @ imm = #0x30
 800b3d6: 2301         	movs	r3, #0x1
 800b3d8: f887 302b    	strb.w	r3, [r7, #0x2b]
 800b3dc: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800b3e0: f083 0301    	eor	r3, r3, #0x1
 800b3e4: b2db         	uxtb	r3, r3
 800b3e6: 2b00         	cmp	r3, #0x0
 800b3e8: d10e         	bne	0x800b408 <bmi08x_acc_trigger_mode_init+0x1c4> @ imm = #0x1c
 800b3ea: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800b49c <bmi08x_acc_trigger_mode_init+0x258>
 800b3ec: 6819         	ldr	r1, [r3]
 800b3ee: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x800b4a8 <bmi08x_acc_trigger_mode_init+0x264>
 800b3f0: 9302         	str	r3, [sp, #0x8]
 800b3f2: 2300         	movs	r3, #0x0
 800b3f4: 9301         	str	r3, [sp, #0x4]
 800b3f6: 2300         	movs	r3, #0x0
 800b3f8: 9300         	str	r3, [sp]
 800b3fa: 2300         	movs	r3, #0x0
 800b3fc: 2201         	movs	r2, #0x1
 800b3fe: 2000         	movs	r0, #0x0
 800b400: f00f fef8    	bl	0x801b1f4 <z_log_msg_runtime_create> @ imm = #0xfdf0
 800b404: 2300         	movs	r3, #0x0
 800b406: 627b         	str	r3, [r7, #0x24]
; 		return ret;
 800b408: 6b7b         	ldr	r3, [r7, #0x34]
 800b40a: e042         	b	0x800b492 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0x84
; 	gpio_pin_configure_dt(&cfg->int_gpio, GPIO_INPUT);
 800b40c: 6bbb         	ldr	r3, [r7, #0x38]
 800b40e: 331c         	adds	r3, #0x1c
 800b410: f44f 3180    	mov.w	r1, #0x10000
 800b414: 4618         	mov	r0, r3
 800b416: f00f fe2e    	bl	0x801b076 <gpio_pin_configure_dt> @ imm = #0xfc5c
; 	gpio_init_callback(&data->gpio_cb, bmi08x_acc_gpio_callback, BIT(cfg->int_gpio.pin));
 800b41a: 6bf8         	ldr	r0, [r7, #0x3c]
 800b41c: 6bbb         	ldr	r3, [r7, #0x38]
 800b41e: f893 3020    	ldrb.w	r3, [r3, #0x20]
 800b422: 461a         	mov	r2, r3
 800b424: 2301         	movs	r3, #0x1
 800b426: 4093         	lsls	r3, r2
 800b428: 461a         	mov	r2, r3
 800b42a: 4920         	ldr	r1, [pc, #0x80]         @ 0x800b4ac <bmi08x_acc_trigger_mode_init+0x268>
 800b42c: f00f fe39    	bl	0x801b0a2 <gpio_init_callback> @ imm = #0xfc72
; 	ret = gpio_add_callback(cfg->int_gpio.port, &data->gpio_cb);
 800b430: 6bbb         	ldr	r3, [r7, #0x38]
 800b432: 69db         	ldr	r3, [r3, #0x1c]
 800b434: 6bfa         	ldr	r2, [r7, #0x3c]
 800b436: 4611         	mov	r1, r2
 800b438: 4618         	mov	r0, r3
 800b43a: f00f fe44    	bl	0x801b0c6 <gpio_add_callback> @ imm = #0xfc88
 800b43e: 6378         	str	r0, [r7, #0x34]
; 	if (ret < 0) {
 800b440: 6b7b         	ldr	r3, [r7, #0x34]
 800b442: 2b00         	cmp	r3, #0x0
 800b444: da1d         	bge	0x800b482 <bmi08x_acc_trigger_mode_init+0x23e> @ imm = #0x3a
; 		LOG_ERR("Failed to set gpio callback.");
 800b446: 2303         	movs	r3, #0x3
 800b448: 2b00         	cmp	r3, #0x0
 800b44a: d018         	beq	0x800b47e <bmi08x_acc_trigger_mode_init+0x23a> @ imm = #0x30
 800b44c: 2301         	movs	r3, #0x1
 800b44e: f887 3032    	strb.w	r3, [r7, #0x32]
 800b452: f897 3032    	ldrb.w	r3, [r7, #0x32]
 800b456: f083 0301    	eor	r3, r3, #0x1
 800b45a: b2db         	uxtb	r3, r3
 800b45c: 2b00         	cmp	r3, #0x0
 800b45e: d10e         	bne	0x800b47e <bmi08x_acc_trigger_mode_init+0x23a> @ imm = #0x1c
 800b460: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800b49c <bmi08x_acc_trigger_mode_init+0x258>
 800b462: 6819         	ldr	r1, [r3]
 800b464: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800b4b0 <bmi08x_acc_trigger_mode_init+0x26c>
 800b466: 9302         	str	r3, [sp, #0x8]
 800b468: 2300         	movs	r3, #0x0
 800b46a: 9301         	str	r3, [sp, #0x4]
 800b46c: 2300         	movs	r3, #0x0
 800b46e: 9300         	str	r3, [sp]
 800b470: 2300         	movs	r3, #0x0
 800b472: 2201         	movs	r2, #0x1
 800b474: 2000         	movs	r0, #0x0
 800b476: f00f febd    	bl	0x801b1f4 <z_log_msg_runtime_create> @ imm = #0xfd7a
 800b47a: 2300         	movs	r3, #0x0
 800b47c: 62fb         	str	r3, [r7, #0x2c]
; 		return ret;
 800b47e: 6b7b         	ldr	r3, [r7, #0x34]
 800b480: e007         	b	0x800b492 <bmi08x_acc_trigger_mode_init+0x24e> @ imm = #0xe
; 	gpio_pin_interrupt_configure_dt(&cfg->int_gpio, GPIO_INT_EDGE_TO_ACTIVE);
 800b482: 6bbb         	ldr	r3, [r7, #0x38]
 800b484: 331c         	adds	r3, #0x1c
 800b486: f04f 61b8    	mov.w	r1, #0x5c00000
 800b48a: 4618         	mov	r0, r3
 800b48c: f00f fd96    	bl	0x801afbc <gpio_pin_interrupt_configure_dt> @ imm = #0xfb2c
; 	return ret;
 800b490: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800b492: 4618         	mov	r0, r3
 800b494: 3740         	adds	r7, #0x40
 800b496: 46bd         	mov	sp, r7
 800b498: bdb0         	pop	{r4, r5, r7, pc}
 800b49a: bf00         	nop

0800b49c <$d>:
 800b49c: 6c 05 00 20  	.word	0x2000056c
 800b4a0: e8 19 02 08  	.word	0x080219e8
 800b4a4: 05 b2 00 08  	.word	0x0800b205
 800b4a8: 00 1a 02 08  	.word	0x08021a00
 800b4ac: 7d b2 01 08  	.word	0x0801b27d
 800b4b0: 1c 1a 02 08  	.word	0x08021a1c

0800b4b4 <z_impl_gpio_pin_interrupt_configure>:
; {
 800b4b4: b590         	push	{r4, r7, lr}
 800b4b6: b08b         	sub	sp, #0x2c
 800b4b8: af00         	add	r7, sp, #0x0
 800b4ba: 60f8         	str	r0, [r7, #0xc]
 800b4bc: 460b         	mov	r3, r1
 800b4be: 607a         	str	r2, [r7, #0x4]
 800b4c0: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 800b4c2: 68fb         	ldr	r3, [r7, #0xc]
 800b4c4: 689b         	ldr	r3, [r3, #0x8]
 800b4c6: 627b         	str	r3, [r7, #0x24]
; 	__unused const struct gpio_driver_config *const cfg =
 800b4c8: 68fb         	ldr	r3, [r7, #0xc]
 800b4ca: 685b         	ldr	r3, [r3, #0x4]
 800b4cc: 623b         	str	r3, [r7, #0x20]
; 	const struct gpio_driver_data *const data =
 800b4ce: 68fb         	ldr	r3, [r7, #0xc]
 800b4d0: 691b         	ldr	r3, [r3, #0x10]
 800b4d2: 61fb         	str	r3, [r7, #0x1c]
; 	if (api->pin_interrupt_configure == NULL) {
 800b4d4: 6a7b         	ldr	r3, [r7, #0x24]
 800b4d6: 699b         	ldr	r3, [r3, #0x18]
 800b4d8: 2b00         	cmp	r3, #0x0
 800b4da: d102         	bne	0x800b4e2 <z_impl_gpio_pin_interrupt_configure+0x2e> @ imm = #0x4
; 		return -ENOSYS;
 800b4dc: f06f 0357    	mvn	r3, #0x57
 800b4e0: e021         	b	0x800b526 <z_impl_gpio_pin_interrupt_configure+0x72> @ imm = #0x42
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800b4e2: 687b         	ldr	r3, [r7, #0x4]
 800b4e4: f403 0300    	and	r3, r3, #0x800000
 800b4e8: 2b00         	cmp	r3, #0x0
 800b4ea: d00c         	beq	0x800b506 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x18
; 	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
 800b4ec: 69fb         	ldr	r3, [r7, #0x1c]
 800b4ee: 681a         	ldr	r2, [r3]
 800b4f0: 7afb         	ldrb	r3, [r7, #0xb]
 800b4f2: 2101         	movs	r1, #0x1
 800b4f4: fa01 f303    	lsl.w	r3, r1, r3
 800b4f8: 4013         	ands	r3, r2
; 	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
 800b4fa: 2b00         	cmp	r3, #0x0
 800b4fc: d003         	beq	0x800b506 <z_impl_gpio_pin_interrupt_configure+0x52> @ imm = #0x6
; 		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
 800b4fe: 687b         	ldr	r3, [r7, #0x4]
 800b500: f083 63c0    	eor	r3, r3, #0x6000000
 800b504: 607b         	str	r3, [r7, #0x4]
; 	trig = (enum gpio_int_trig)(flags & (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1 | GPIO_INT_WAKEUP));
 800b506: 687a         	ldr	r2, [r7, #0x4]
 800b508: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800b530 <z_impl_gpio_pin_interrupt_configure+0x7c>
 800b50a: 4013         	ands	r3, r2
 800b50c: 61bb         	str	r3, [r7, #0x18]
; 	mode = (enum gpio_int_mode)(flags & (GPIO_INT_EDGE | GPIO_INT_DISABLE | GPIO_INT_ENABLE));
 800b50e: 687b         	ldr	r3, [r7, #0x4]
 800b510: f003 73b0    	and	r3, r3, #0x1600000
 800b514: 617b         	str	r3, [r7, #0x14]
; 	return api->pin_interrupt_configure(port, pin, mode, trig);
 800b516: 6a7b         	ldr	r3, [r7, #0x24]
 800b518: 699c         	ldr	r4, [r3, #0x18]
 800b51a: 7af9         	ldrb	r1, [r7, #0xb]
 800b51c: 69bb         	ldr	r3, [r7, #0x18]
 800b51e: 697a         	ldr	r2, [r7, #0x14]
 800b520: 68f8         	ldr	r0, [r7, #0xc]
 800b522: 47a0         	blx	r4
 800b524: 4603         	mov	r3, r0
; }
 800b526: 4618         	mov	r0, r3
 800b528: 372c         	adds	r7, #0x2c
 800b52a: 46bd         	mov	sp, r7
 800b52c: bd90         	pop	{r4, r7, pc}
 800b52e: bf00         	nop

0800b530 <$d>:
 800b530: 40 00 00 06  	.word	0x06000040

0800b534 <bmi08x_gyr_thread_main>:
; {
 800b534: b580         	push	{r7, lr}
 800b536: b086         	sub	sp, #0x18
 800b538: af00         	add	r7, sp, #0x0
 800b53a: 60f8         	str	r0, [r7, #0xc]
 800b53c: 60b9         	str	r1, [r7, #0x8]
 800b53e: 607a         	str	r2, [r7, #0x4]
; 	k_thread_name_set(NULL, "bmi08x_gyr_trig");
 800b540: 490b         	ldr	r1, [pc, #0x2c]         @ 0x800b570 <bmi08x_gyr_thread_main+0x3c>
 800b542: 2000         	movs	r0, #0x0
 800b544: f00f ffcc    	bl	0x801b4e0 <k_thread_name_set> @ imm = #0xff98
; 	const struct device *dev = (const struct device *)arg1;
 800b548: 68fb         	ldr	r3, [r7, #0xc]
 800b54a: 617b         	str	r3, [r7, #0x14]
; 	struct bmi08x_gyro_data *data = dev->data;
 800b54c: 697b         	ldr	r3, [r7, #0x14]
 800b54e: 691b         	ldr	r3, [r3, #0x10]
 800b550: 613b         	str	r3, [r7, #0x10]
; 		k_sem_take(&data->sem, K_FOREVER);
 800b552: 693b         	ldr	r3, [r7, #0x10]
 800b554: f503 6113    	add.w	r1, r3, #0x930
 800b558: f04f 32ff    	mov.w	r2, #0xffffffff
 800b55c: f04f 33ff    	mov.w	r3, #0xffffffff
 800b560: 4608         	mov	r0, r1
 800b562: f00f ffdb    	bl	0x801b51c <k_sem_take>  @ imm = #0xffb6
; 		bmi08x_handle_interrupts_gyr((void *)dev);
 800b566: 6978         	ldr	r0, [r7, #0x14]
 800b568: f010 f82a    	bl	0x801b5c0 <bmi08x_handle_interrupts_gyr> @ imm = #0x10054
; 	while (1) {
 800b56c: bf00         	nop
 800b56e: e7f0         	b	0x800b552 <bmi08x_gyr_thread_main+0x1e> @ imm = #-0x20

0800b570 <$d>:
 800b570: 3c 1a 02 08  	.word	0x08021a3c

0800b574 <bmi08x_gyr_trigger_mode_init>:
; {
 800b574: b5b0         	push	{r4, r5, r7, lr}
 800b576: b092         	sub	sp, #0x48
 800b578: af08         	add	r7, sp, #0x20
 800b57a: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 800b57c: 687b         	ldr	r3, [r7, #0x4]
 800b57e: 691b         	ldr	r3, [r3, #0x10]
 800b580: 627b         	str	r3, [r7, #0x24]
; 	const struct bmi08x_gyro_config *cfg = dev->config;
 800b582: 687b         	ldr	r3, [r7, #0x4]
 800b584: 685b         	ldr	r3, [r3, #0x4]
 800b586: 623b         	str	r3, [r7, #0x20]
; 	if (!gpio_is_ready_dt(&cfg->int_gpio)) {
 800b588: 6a3b         	ldr	r3, [r7, #0x20]
 800b58a: 331c         	adds	r3, #0x1c
 800b58c: 4618         	mov	r0, r3
 800b58e: f00f feb6    	bl	0x801b2fe <gpio_is_ready_dt> @ imm = #0xfd6c
 800b592: 4603         	mov	r3, r0
 800b594: f083 0301    	eor	r3, r3, #0x1
 800b598: b2db         	uxtb	r3, r3
 800b59a: 2b00         	cmp	r3, #0x0
 800b59c: d01c         	beq	0x800b5d8 <bmi08x_gyr_trigger_mode_init+0x64> @ imm = #0x38
; 		LOG_ERR("GPIO device not ready");
 800b59e: 2303         	movs	r3, #0x3
 800b5a0: 2b00         	cmp	r3, #0x0
 800b5a2: d016         	beq	0x800b5d2 <bmi08x_gyr_trigger_mode_init+0x5e> @ imm = #0x2c
 800b5a4: 2301         	movs	r3, #0x1
 800b5a6: 74fb         	strb	r3, [r7, #0x13]
 800b5a8: 7cfb         	ldrb	r3, [r7, #0x13]
 800b5aa: f083 0301    	eor	r3, r3, #0x1
 800b5ae: b2db         	uxtb	r3, r3
 800b5b0: 2b00         	cmp	r3, #0x0
 800b5b2: d10e         	bne	0x800b5d2 <bmi08x_gyr_trigger_mode_init+0x5e> @ imm = #0x1c
 800b5b4: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800b6b0 <bmi08x_gyr_trigger_mode_init+0x13c>
 800b5b6: 6819         	ldr	r1, [r3]
 800b5b8: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800b6b4 <bmi08x_gyr_trigger_mode_init+0x140>
 800b5ba: 9302         	str	r3, [sp, #0x8]
 800b5bc: 2300         	movs	r3, #0x0
 800b5be: 9301         	str	r3, [sp, #0x4]
 800b5c0: 2300         	movs	r3, #0x0
 800b5c2: 9300         	str	r3, [sp]
 800b5c4: 2300         	movs	r3, #0x0
 800b5c6: 2201         	movs	r2, #0x1
 800b5c8: 2000         	movs	r0, #0x0
 800b5ca: f00f ffc2    	bl	0x801b552 <z_log_msg_runtime_create> @ imm = #0xff84
 800b5ce: 2300         	movs	r3, #0x0
 800b5d0: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800b5d2: f06f 0312    	mvn	r3, #0x12
 800b5d6: e067         	b	0x800b6a8 <bmi08x_gyr_trigger_mode_init+0x134> @ imm = #0xce
; 	k_sem_init(&data->sem, 0, K_SEM_MAX_LIMIT);
 800b5d8: 6a7b         	ldr	r3, [r7, #0x24]
 800b5da: f503 6313    	add.w	r3, r3, #0x930
 800b5de: f04f 32ff    	mov.w	r2, #0xffffffff
 800b5e2: 2100         	movs	r1, #0x0
 800b5e4: 4618         	mov	r0, r3
 800b5e6: f00f ff89    	bl	0x801b4fc <k_sem_init>  @ imm = #0xff12
; 	k_thread_create(&data->thread, data->thread_stack,
 800b5ea: 6a7b         	ldr	r3, [r7, #0x24]
 800b5ec: f603 0418    	addw	r4, r3, #0x818
 800b5f0: 6a7b         	ldr	r3, [r7, #0x24]
 800b5f2: f103 0518    	add.w	r5, r3, #0x18
; 			NULL, NULL, K_PRIO_COOP(CONFIG_BMI08X_GYRO_THREAD_PRIORITY), 0, K_NO_WAIT);
 800b5f6: f04f 0000    	mov.w	r0, #0x0
 800b5fa: f04f 0100    	mov.w	r1, #0x0
; 	k_thread_create(&data->thread, data->thread_stack,
 800b5fe: e9cd 0106    	strd	r0, r1, [sp, #24]
 800b602: 2300         	movs	r3, #0x0
 800b604: 9304         	str	r3, [sp, #0x10]
 800b606: f06f 0305    	mvn	r3, #0x5
 800b60a: 9303         	str	r3, [sp, #0xc]
 800b60c: 2300         	movs	r3, #0x0
 800b60e: 9302         	str	r3, [sp, #0x8]
 800b610: 2300         	movs	r3, #0x0
 800b612: 9301         	str	r3, [sp, #0x4]
 800b614: 687b         	ldr	r3, [r7, #0x4]
 800b616: 9300         	str	r3, [sp]
 800b618: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800b6b8 <bmi08x_gyr_trigger_mode_init+0x144>
 800b61a: f44f 6200    	mov.w	r2, #0x800
 800b61e: 4629         	mov	r1, r5
 800b620: 4620         	mov	r0, r4
 800b622: f00f ff3d    	bl	0x801b4a0 <k_thread_create> @ imm = #0xfe7a
; 	gpio_pin_configure_dt(&cfg->int_gpio, GPIO_INPUT);
 800b626: 6a3b         	ldr	r3, [r7, #0x20]
 800b628: 331c         	adds	r3, #0x1c
 800b62a: f44f 3180    	mov.w	r1, #0x10000
 800b62e: 4618         	mov	r0, r3
 800b630: f00f fed0    	bl	0x801b3d4 <gpio_pin_configure_dt> @ imm = #0xfda0
; 	gpio_init_callback(&data->gpio_cb, bmi08x_gyr_gpio_callback, BIT(cfg->int_gpio.pin));
 800b634: 6a78         	ldr	r0, [r7, #0x24]
 800b636: 6a3b         	ldr	r3, [r7, #0x20]
 800b638: f893 3020    	ldrb.w	r3, [r3, #0x20]
 800b63c: 461a         	mov	r2, r3
 800b63e: 2301         	movs	r3, #0x1
 800b640: 4093         	lsls	r3, r2
 800b642: 461a         	mov	r2, r3
 800b644: 491d         	ldr	r1, [pc, #0x74]         @ 0x800b6bc <bmi08x_gyr_trigger_mode_init+0x148>
 800b646: f00f fedb    	bl	0x801b400 <gpio_init_callback> @ imm = #0xfdb6
; 	ret = gpio_add_callback(cfg->int_gpio.port, &data->gpio_cb);
 800b64a: 6a3b         	ldr	r3, [r7, #0x20]
 800b64c: 69db         	ldr	r3, [r3, #0x1c]
 800b64e: 6a7a         	ldr	r2, [r7, #0x24]
 800b650: 4611         	mov	r1, r2
 800b652: 4618         	mov	r0, r3
 800b654: f00f fee6    	bl	0x801b424 <gpio_add_callback> @ imm = #0xfdcc
 800b658: 61f8         	str	r0, [r7, #0x1c]
; 	if (ret < 0) {
 800b65a: 69fb         	ldr	r3, [r7, #0x1c]
 800b65c: 2b00         	cmp	r3, #0x0
 800b65e: da1b         	bge	0x800b698 <bmi08x_gyr_trigger_mode_init+0x124> @ imm = #0x36
; 		LOG_ERR("Failed to set gpio callback.");
 800b660: 2303         	movs	r3, #0x3
 800b662: 2b00         	cmp	r3, #0x0
 800b664: d016         	beq	0x800b694 <bmi08x_gyr_trigger_mode_init+0x120> @ imm = #0x2c
 800b666: 2301         	movs	r3, #0x1
 800b668: 76fb         	strb	r3, [r7, #0x1b]
 800b66a: 7efb         	ldrb	r3, [r7, #0x1b]
 800b66c: f083 0301    	eor	r3, r3, #0x1
 800b670: b2db         	uxtb	r3, r3
 800b672: 2b00         	cmp	r3, #0x0
 800b674: d10e         	bne	0x800b694 <bmi08x_gyr_trigger_mode_init+0x120> @ imm = #0x1c
 800b676: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800b6b0 <bmi08x_gyr_trigger_mode_init+0x13c>
 800b678: 6819         	ldr	r1, [r3]
 800b67a: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800b6c0 <bmi08x_gyr_trigger_mode_init+0x14c>
 800b67c: 9302         	str	r3, [sp, #0x8]
 800b67e: 2300         	movs	r3, #0x0
 800b680: 9301         	str	r3, [sp, #0x4]
 800b682: 2300         	movs	r3, #0x0
 800b684: 9300         	str	r3, [sp]
 800b686: 2300         	movs	r3, #0x0
 800b688: 2201         	movs	r2, #0x1
 800b68a: 2000         	movs	r0, #0x0
 800b68c: f00f ff61    	bl	0x801b552 <z_log_msg_runtime_create> @ imm = #0xfec2
 800b690: 2300         	movs	r3, #0x0
 800b692: 617b         	str	r3, [r7, #0x14]
; 		return ret;
 800b694: 69fb         	ldr	r3, [r7, #0x1c]
 800b696: e007         	b	0x800b6a8 <bmi08x_gyr_trigger_mode_init+0x134> @ imm = #0xe
; 	gpio_pin_interrupt_configure_dt(&cfg->int_gpio, GPIO_INT_EDGE_TO_ACTIVE);
 800b698: 6a3b         	ldr	r3, [r7, #0x20]
 800b69a: 331c         	adds	r3, #0x1c
 800b69c: f04f 61b8    	mov.w	r1, #0x5c00000
 800b6a0: 4618         	mov	r0, r3
 800b6a2: f00f fe3a    	bl	0x801b31a <gpio_pin_interrupt_configure_dt> @ imm = #0xfc74
; 	return ret;
 800b6a6: 69fb         	ldr	r3, [r7, #0x1c]
; }
 800b6a8: 4618         	mov	r0, r3
 800b6aa: 3728         	adds	r7, #0x28
 800b6ac: 46bd         	mov	sp, r7
 800b6ae: bdb0         	pop	{r4, r5, r7, pc}

0800b6b0 <$d>:
 800b6b0: 70 05 00 20  	.word	0x20000570
 800b6b4: 4c 1a 02 08  	.word	0x08021a4c
 800b6b8: 35 b5 00 08  	.word	0x0800b535
 800b6bc: db b5 01 08  	.word	0x0801b5db
 800b6c0: 64 1a 02 08  	.word	0x08021a64

0800b6c4 <LL_USART_SetBaudRate>:
; {
 800b6c4: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800b6c8: b0c0         	sub	sp, #0x100
 800b6ca: af00         	add	r7, sp, #0x0
 800b6cc: f8c7 00fc    	str.w	r0, [r7, #0xfc]
 800b6d0: f8c7 10f8    	str.w	r1, [r7, #0xf8]
 800b6d4: f8c7 20f4    	str.w	r2, [r7, #0xf4]
 800b6d8: f8c7 30f0    	str.w	r3, [r7, #0xf0]
;   if (OverSampling == LL_USART_OVERSAMPLING_8)
 800b6dc: f8d7 30f4    	ldr.w	r3, [r7, #0xf4]
 800b6e0: f5b3 4f00    	cmp.w	r3, #0x8000
 800b6e4: f040 810c    	bne.w	0x800b900 <LL_USART_SetBaudRate+0x23c> @ imm = #0x218
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 800b6e8: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800b6ec: 2200         	movs	r2, #0x0
 800b6ee: f8c7 30e8    	str.w	r3, [r7, #0xe8]
 800b6f2: f8c7 20ec    	str.w	r2, [r7, #0xec]
 800b6f6: e9d7 453a    	ldrd	r4, r5, [r7, #232]
 800b6fa: 4622         	mov	r2, r4
 800b6fc: 462b         	mov	r3, r5
 800b6fe: 1891         	adds	r1, r2, r2
 800b700: 6639         	str	r1, [r7, #0x60]
 800b702: 415b         	adcs	r3, r3
 800b704: 667b         	str	r3, [r7, #0x64]
 800b706: e9d7 2318    	ldrd	r2, r3, [r7, #96]
 800b70a: 4621         	mov	r1, r4
 800b70c: eb12 0801    	adds.w	r8, r2, r1
 800b710: 4629         	mov	r1, r5
 800b712: eb43 0901    	adc.w	r9, r3, r1
 800b716: f04f 0200    	mov.w	r2, #0x0
 800b71a: f04f 0300    	mov.w	r3, #0x0
 800b71e: ea4f 03c9    	lsl.w	r3, r9, #0x3
 800b722: ea43 7358    	orr.w	r3, r3, r8, lsr #29
 800b726: ea4f 02c8    	lsl.w	r2, r8, #0x3
 800b72a: 4690         	mov	r8, r2
 800b72c: 4699         	mov	r9, r3
 800b72e: 4623         	mov	r3, r4
 800b730: eb18 0303    	adds.w	r3, r8, r3
 800b734: f8c7 30e0    	str.w	r3, [r7, #0xe0]
 800b738: 462b         	mov	r3, r5
 800b73a: eb49 0303    	adc.w	r3, r9, r3
 800b73e: f8c7 30e4    	str.w	r3, [r7, #0xe4]
 800b742: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800b746: 2200         	movs	r2, #0x0
 800b748: 469a         	mov	r10, r3
 800b74a: 4693         	mov	r11, r2
 800b74c: eb1a 030a    	adds.w	r3, r10, r10
 800b750: 65bb         	str	r3, [r7, #0x58]
 800b752: eb4b 030b    	adc.w	r3, r11, r11
 800b756: 65fb         	str	r3, [r7, #0x5c]
 800b758: e9d7 2316    	ldrd	r2, r3, [r7, #88]
 800b75c: e9d7 0138    	ldrd	r0, r1, [r7, #224]
 800b760: f7f5 f980    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0xad00
 800b764: 4602         	mov	r2, r0
 800b766: 460b         	mov	r3, r1
 800b768: 4b64         	ldr	r3, [pc, #0x190]        @ 0x800b8fc <LL_USART_SetBaudRate+0x238>
 800b76a: fba3 2302    	umull	r2, r3, r3, r2
 800b76e: 095b         	lsrs	r3, r3, #0x5
 800b770: b29b         	uxth	r3, r3
 800b772: 011b         	lsls	r3, r3, #0x4
 800b774: b29c         	uxth	r4, r3
 800b776: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800b77a: 2200         	movs	r2, #0x0
 800b77c: f8c7 30d8    	str.w	r3, [r7, #0xd8]
 800b780: f8c7 20dc    	str.w	r2, [r7, #0xdc]
 800b784: e9d7 8936    	ldrd	r8, r9, [r7, #216]
 800b788: 4642         	mov	r2, r8
 800b78a: 464b         	mov	r3, r9
 800b78c: 1891         	adds	r1, r2, r2
 800b78e: 6539         	str	r1, [r7, #0x50]
 800b790: 415b         	adcs	r3, r3
 800b792: 657b         	str	r3, [r7, #0x54]
 800b794: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 800b798: 4641         	mov	r1, r8
 800b79a: 1851         	adds	r1, r2, r1
 800b79c: 64b9         	str	r1, [r7, #0x48]
 800b79e: 4649         	mov	r1, r9
 800b7a0: 414b         	adcs	r3, r1
 800b7a2: 64fb         	str	r3, [r7, #0x4c]
 800b7a4: f04f 0200    	mov.w	r2, #0x0
 800b7a8: f04f 0300    	mov.w	r3, #0x0
 800b7ac: e9d7 ab12    	ldrd	r10, r11, [r7, #72]
 800b7b0: 4659         	mov	r1, r11
 800b7b2: 00cb         	lsls	r3, r1, #0x3
 800b7b4: 4651         	mov	r1, r10
 800b7b6: ea43 7351    	orr.w	r3, r3, r1, lsr #29
 800b7ba: 4651         	mov	r1, r10
 800b7bc: 00ca         	lsls	r2, r1, #0x3
 800b7be: 4610         	mov	r0, r2
 800b7c0: 4619         	mov	r1, r3
 800b7c2: 4603         	mov	r3, r0
 800b7c4: 4642         	mov	r2, r8
 800b7c6: 189b         	adds	r3, r3, r2
 800b7c8: f8c7 30d0    	str.w	r3, [r7, #0xd0]
 800b7cc: 464b         	mov	r3, r9
 800b7ce: 460a         	mov	r2, r1
 800b7d0: eb42 0303    	adc.w	r3, r2, r3
 800b7d4: f8c7 30d4    	str.w	r3, [r7, #0xd4]
 800b7d8: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800b7dc: 2200         	movs	r2, #0x0
 800b7de: f8c7 30c8    	str.w	r3, [r7, #0xc8]
 800b7e2: f8c7 20cc    	str.w	r2, [r7, #0xcc]
 800b7e6: e9d7 1232    	ldrd	r1, r2, [r7, #200]
 800b7ea: 460b         	mov	r3, r1
 800b7ec: 18db         	adds	r3, r3, r3
 800b7ee: 643b         	str	r3, [r7, #0x40]
 800b7f0: 4613         	mov	r3, r2
 800b7f2: eb42 0303    	adc.w	r3, r2, r3
 800b7f6: 647b         	str	r3, [r7, #0x44]
 800b7f8: e9d7 2310    	ldrd	r2, r3, [r7, #64]
 800b7fc: e9d7 0134    	ldrd	r0, r1, [r7, #208]
 800b800: f7f5 f930    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0xada0
 800b804: 4602         	mov	r2, r0
 800b806: 460b         	mov	r3, r1
 800b808: 4611         	mov	r1, r2
 800b80a: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x800b8fc <LL_USART_SetBaudRate+0x238>
 800b80c: fba3 2301    	umull	r2, r3, r3, r1
 800b810: 095b         	lsrs	r3, r3, #0x5
 800b812: 2264         	movs	r2, #0x64
 800b814: fb02 f303    	mul	r3, r2, r3
 800b818: 1acb         	subs	r3, r1, r3
 800b81a: 00db         	lsls	r3, r3, #0x3
 800b81c: f103 0232    	add.w	r2, r3, #0x32
 800b820: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800b8fc <LL_USART_SetBaudRate+0x238>
 800b822: fba3 2302    	umull	r2, r3, r3, r2
 800b826: 095b         	lsrs	r3, r3, #0x5
 800b828: b29b         	uxth	r3, r3
 800b82a: 005b         	lsls	r3, r3, #0x1
 800b82c: b29b         	uxth	r3, r3
 800b82e: f403 73f8    	and	r3, r3, #0x1f0
 800b832: b29b         	uxth	r3, r3
 800b834: 4423         	add	r3, r4
 800b836: b29c         	uxth	r4, r3
 800b838: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800b83c: 2200         	movs	r2, #0x0
 800b83e: f8c7 30c0    	str.w	r3, [r7, #0xc0]
 800b842: f8c7 20c4    	str.w	r2, [r7, #0xc4]
 800b846: e9d7 8930    	ldrd	r8, r9, [r7, #192]
 800b84a: 4642         	mov	r2, r8
 800b84c: 464b         	mov	r3, r9
 800b84e: 1891         	adds	r1, r2, r2
 800b850: 63b9         	str	r1, [r7, #0x38]
 800b852: 415b         	adcs	r3, r3
 800b854: 63fb         	str	r3, [r7, #0x3c]
 800b856: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 800b85a: 4641         	mov	r1, r8
 800b85c: 1851         	adds	r1, r2, r1
 800b85e: 6339         	str	r1, [r7, #0x30]
 800b860: 4649         	mov	r1, r9
 800b862: 414b         	adcs	r3, r1
 800b864: 637b         	str	r3, [r7, #0x34]
 800b866: f04f 0200    	mov.w	r2, #0x0
 800b86a: f04f 0300    	mov.w	r3, #0x0
 800b86e: e9d7 ab0c    	ldrd	r10, r11, [r7, #48]
 800b872: 4659         	mov	r1, r11
 800b874: 00cb         	lsls	r3, r1, #0x3
 800b876: 4651         	mov	r1, r10
 800b878: ea43 7351    	orr.w	r3, r3, r1, lsr #29
 800b87c: 4651         	mov	r1, r10
 800b87e: 00ca         	lsls	r2, r1, #0x3
 800b880: 4610         	mov	r0, r2
 800b882: 4619         	mov	r1, r3
 800b884: 4603         	mov	r3, r0
 800b886: 4642         	mov	r2, r8
 800b888: 189b         	adds	r3, r3, r2
 800b88a: f8c7 30b8    	str.w	r3, [r7, #0xb8]
 800b88e: 464b         	mov	r3, r9
 800b890: 460a         	mov	r2, r1
 800b892: eb42 0303    	adc.w	r3, r2, r3
 800b896: f8c7 30bc    	str.w	r3, [r7, #0xbc]
 800b89a: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800b89e: 2200         	movs	r2, #0x0
 800b8a0: f8c7 30b0    	str.w	r3, [r7, #0xb0]
 800b8a4: f8c7 20b4    	str.w	r2, [r7, #0xb4]
 800b8a8: e9d7 122c    	ldrd	r1, r2, [r7, #176]
 800b8ac: 460b         	mov	r3, r1
 800b8ae: 18db         	adds	r3, r3, r3
 800b8b0: 62bb         	str	r3, [r7, #0x28]
 800b8b2: 4613         	mov	r3, r2
 800b8b4: eb42 0303    	adc.w	r3, r2, r3
 800b8b8: 62fb         	str	r3, [r7, #0x2c]
 800b8ba: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 800b8be: e9d7 012e    	ldrd	r0, r1, [r7, #184]
 800b8c2: f7f5 f8cf    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0xae62
 800b8c6: 4602         	mov	r2, r0
 800b8c8: 460b         	mov	r3, r1
 800b8ca: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800b8fc <LL_USART_SetBaudRate+0x238>
 800b8cc: fba3 1302    	umull	r1, r3, r3, r2
 800b8d0: 095b         	lsrs	r3, r3, #0x5
 800b8d2: 2164         	movs	r1, #0x64
 800b8d4: fb01 f303    	mul	r3, r1, r3
 800b8d8: 1ad3         	subs	r3, r2, r3
 800b8da: 00db         	lsls	r3, r3, #0x3
 800b8dc: 3332         	adds	r3, #0x32
 800b8de: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800b8fc <LL_USART_SetBaudRate+0x238>
 800b8e0: fba2 2303    	umull	r2, r3, r2, r3
 800b8e4: 095b         	lsrs	r3, r3, #0x5
 800b8e6: b29b         	uxth	r3, r3
 800b8e8: f003 0307    	and	r3, r3, #0x7
 800b8ec: b29b         	uxth	r3, r3
 800b8ee: 4423         	add	r3, r4
 800b8f0: b29b         	uxth	r3, r3
 800b8f2: 461a         	mov	r2, r3
 800b8f4: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 800b8f8: 609a         	str	r2, [r3, #0x8]
; }
 800b8fa: e108         	b	0x800bb0e <LL_USART_SetBaudRate+0x44a> @ imm = #0x210

0800b8fc <$d>:
 800b8fc: 1f 85 eb 51  	.word	0x51eb851f

0800b900 <$t>:
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 800b900: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800b904: 2200         	movs	r2, #0x0
 800b906: f8c7 30a8    	str.w	r3, [r7, #0xa8]
 800b90a: f8c7 20ac    	str.w	r2, [r7, #0xac]
 800b90e: e9d7 892a    	ldrd	r8, r9, [r7, #168]
 800b912: 4642         	mov	r2, r8
 800b914: 464b         	mov	r3, r9
 800b916: 1891         	adds	r1, r2, r2
 800b918: 6239         	str	r1, [r7, #0x20]
 800b91a: 415b         	adcs	r3, r3
 800b91c: 627b         	str	r3, [r7, #0x24]
 800b91e: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 800b922: 4641         	mov	r1, r8
 800b924: 1854         	adds	r4, r2, r1
 800b926: 4649         	mov	r1, r9
 800b928: eb43 0501    	adc.w	r5, r3, r1
 800b92c: f04f 0200    	mov.w	r2, #0x0
 800b930: f04f 0300    	mov.w	r3, #0x0
 800b934: 00eb         	lsls	r3, r5, #0x3
 800b936: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 800b93a: 00e2         	lsls	r2, r4, #0x3
 800b93c: 4614         	mov	r4, r2
 800b93e: 461d         	mov	r5, r3
 800b940: 4643         	mov	r3, r8
 800b942: 18e3         	adds	r3, r4, r3
 800b944: f8c7 30a0    	str.w	r3, [r7, #0xa0]
 800b948: 464b         	mov	r3, r9
 800b94a: eb45 0303    	adc.w	r3, r5, r3
 800b94e: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 800b952: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800b956: 2200         	movs	r2, #0x0
 800b958: f8c7 3098    	str.w	r3, [r7, #0x98]
 800b95c: f8c7 209c    	str.w	r2, [r7, #0x9c]
 800b960: f04f 0200    	mov.w	r2, #0x0
 800b964: f04f 0300    	mov.w	r3, #0x0
 800b968: e9d7 4526    	ldrd	r4, r5, [r7, #152]
 800b96c: 4629         	mov	r1, r5
 800b96e: 008b         	lsls	r3, r1, #0x2
 800b970: 4621         	mov	r1, r4
 800b972: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 800b976: 4621         	mov	r1, r4
 800b978: 008a         	lsls	r2, r1, #0x2
 800b97a: e9d7 0128    	ldrd	r0, r1, [r7, #160]
 800b97e: f7f5 f871    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0xaf1e
 800b982: 4602         	mov	r2, r0
 800b984: 460b         	mov	r3, r1
 800b986: 4b65         	ldr	r3, [pc, #0x194]        @ 0x800bb1c <LL_USART_SetBaudRate+0x458>
 800b988: fba3 2302    	umull	r2, r3, r3, r2
 800b98c: 095b         	lsrs	r3, r3, #0x5
 800b98e: b29b         	uxth	r3, r3
 800b990: 011b         	lsls	r3, r3, #0x4
 800b992: b29c         	uxth	r4, r3
 800b994: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800b998: 2200         	movs	r2, #0x0
 800b99a: f8c7 3090    	str.w	r3, [r7, #0x90]
 800b99e: f8c7 2094    	str.w	r2, [r7, #0x94]
 800b9a2: e9d7 8924    	ldrd	r8, r9, [r7, #144]
 800b9a6: 4642         	mov	r2, r8
 800b9a8: 464b         	mov	r3, r9
 800b9aa: 1891         	adds	r1, r2, r2
 800b9ac: 61b9         	str	r1, [r7, #0x18]
 800b9ae: 415b         	adcs	r3, r3
 800b9b0: 61fb         	str	r3, [r7, #0x1c]
 800b9b2: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 800b9b6: 4641         	mov	r1, r8
 800b9b8: 1851         	adds	r1, r2, r1
 800b9ba: 6139         	str	r1, [r7, #0x10]
 800b9bc: 4649         	mov	r1, r9
 800b9be: 414b         	adcs	r3, r1
 800b9c0: 617b         	str	r3, [r7, #0x14]
 800b9c2: f04f 0200    	mov.w	r2, #0x0
 800b9c6: f04f 0300    	mov.w	r3, #0x0
 800b9ca: e9d7 ab04    	ldrd	r10, r11, [r7, #16]
 800b9ce: 4659         	mov	r1, r11
 800b9d0: 00cb         	lsls	r3, r1, #0x3
 800b9d2: 4651         	mov	r1, r10
 800b9d4: ea43 7351    	orr.w	r3, r3, r1, lsr #29
 800b9d8: 4651         	mov	r1, r10
 800b9da: 00ca         	lsls	r2, r1, #0x3
 800b9dc: 4610         	mov	r0, r2
 800b9de: 4619         	mov	r1, r3
 800b9e0: 4603         	mov	r3, r0
 800b9e2: 4642         	mov	r2, r8
 800b9e4: 189b         	adds	r3, r3, r2
 800b9e6: f8c7 3088    	str.w	r3, [r7, #0x88]
 800b9ea: 464b         	mov	r3, r9
 800b9ec: 460a         	mov	r2, r1
 800b9ee: eb42 0303    	adc.w	r3, r2, r3
 800b9f2: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800b9f6: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800b9fa: 2200         	movs	r2, #0x0
 800b9fc: f8c7 3080    	str.w	r3, [r7, #0x80]
 800ba00: f8c7 2084    	str.w	r2, [r7, #0x84]
 800ba04: f04f 0200    	mov.w	r2, #0x0
 800ba08: f04f 0300    	mov.w	r3, #0x0
 800ba0c: e9d7 8920    	ldrd	r8, r9, [r7, #128]
 800ba10: 4649         	mov	r1, r9
 800ba12: 008b         	lsls	r3, r1, #0x2
 800ba14: 4641         	mov	r1, r8
 800ba16: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 800ba1a: 4641         	mov	r1, r8
 800ba1c: 008a         	lsls	r2, r1, #0x2
 800ba1e: e9d7 0122    	ldrd	r0, r1, [r7, #136]
 800ba22: f7f5 f81f    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0xafc2
 800ba26: 4602         	mov	r2, r0
 800ba28: 460b         	mov	r3, r1
 800ba2a: 4611         	mov	r1, r2
 800ba2c: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x800bb1c <LL_USART_SetBaudRate+0x458>
 800ba2e: fba3 2301    	umull	r2, r3, r3, r1
 800ba32: 095b         	lsrs	r3, r3, #0x5
 800ba34: 2264         	movs	r2, #0x64
 800ba36: fb02 f303    	mul	r3, r2, r3
 800ba3a: 1acb         	subs	r3, r1, r3
 800ba3c: 011b         	lsls	r3, r3, #0x4
 800ba3e: 3332         	adds	r3, #0x32
 800ba40: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x800bb1c <LL_USART_SetBaudRate+0x458>
 800ba42: fba2 2303    	umull	r2, r3, r2, r3
 800ba46: 095b         	lsrs	r3, r3, #0x5
 800ba48: b29b         	uxth	r3, r3
 800ba4a: f003 03f0    	and	r3, r3, #0xf0
 800ba4e: b29b         	uxth	r3, r3
 800ba50: 4423         	add	r3, r4
 800ba52: b29c         	uxth	r4, r3
 800ba54: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 800ba58: 2200         	movs	r2, #0x0
 800ba5a: 67bb         	str	r3, [r7, #0x78]
 800ba5c: 67fa         	str	r2, [r7, #0x7c]
 800ba5e: e9d7 891e    	ldrd	r8, r9, [r7, #120]
 800ba62: 4642         	mov	r2, r8
 800ba64: 464b         	mov	r3, r9
 800ba66: 1891         	adds	r1, r2, r2
 800ba68: 60b9         	str	r1, [r7, #0x8]
 800ba6a: 415b         	adcs	r3, r3
 800ba6c: 60fb         	str	r3, [r7, #0xc]
 800ba6e: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800ba72: 4641         	mov	r1, r8
 800ba74: 1851         	adds	r1, r2, r1
 800ba76: 6039         	str	r1, [r7]
 800ba78: 4649         	mov	r1, r9
 800ba7a: 414b         	adcs	r3, r1
 800ba7c: 607b         	str	r3, [r7, #0x4]
 800ba7e: f04f 0200    	mov.w	r2, #0x0
 800ba82: f04f 0300    	mov.w	r3, #0x0
 800ba86: e9d7 ab00    	ldrd	r10, r11, [r7]
 800ba8a: 4659         	mov	r1, r11
 800ba8c: 00cb         	lsls	r3, r1, #0x3
 800ba8e: 4651         	mov	r1, r10
 800ba90: ea43 7351    	orr.w	r3, r3, r1, lsr #29
 800ba94: 4651         	mov	r1, r10
 800ba96: 00ca         	lsls	r2, r1, #0x3
 800ba98: 4610         	mov	r0, r2
 800ba9a: 4619         	mov	r1, r3
 800ba9c: 4603         	mov	r3, r0
 800ba9e: 4642         	mov	r2, r8
 800baa0: 189b         	adds	r3, r3, r2
 800baa2: 673b         	str	r3, [r7, #0x70]
 800baa4: 464b         	mov	r3, r9
 800baa6: 460a         	mov	r2, r1
 800baa8: eb42 0303    	adc.w	r3, r2, r3
 800baac: 677b         	str	r3, [r7, #0x74]
 800baae: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 800bab2: 2200         	movs	r2, #0x0
 800bab4: 66bb         	str	r3, [r7, #0x68]
 800bab6: 66fa         	str	r2, [r7, #0x6c]
 800bab8: f04f 0200    	mov.w	r2, #0x0
 800babc: f04f 0300    	mov.w	r3, #0x0
 800bac0: e9d7 891a    	ldrd	r8, r9, [r7, #104]
 800bac4: 4649         	mov	r1, r9
 800bac6: 008b         	lsls	r3, r1, #0x2
 800bac8: 4641         	mov	r1, r8
 800baca: ea43 7391    	orr.w	r3, r3, r1, lsr #30
 800bace: 4641         	mov	r1, r8
 800bad0: 008a         	lsls	r2, r1, #0x2
 800bad2: e9d7 011c    	ldrd	r0, r1, [r7, #112]
 800bad6: f7f4 ffc5    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0xb076
 800bada: 4602         	mov	r2, r0
 800badc: 460b         	mov	r3, r1
 800bade: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800bb1c <LL_USART_SetBaudRate+0x458>
 800bae0: fba3 1302    	umull	r1, r3, r3, r2
 800bae4: 095b         	lsrs	r3, r3, #0x5
 800bae6: 2164         	movs	r1, #0x64
 800bae8: fb01 f303    	mul	r3, r1, r3
 800baec: 1ad3         	subs	r3, r2, r3
 800baee: 011b         	lsls	r3, r3, #0x4
 800baf0: 3332         	adds	r3, #0x32
 800baf2: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800bb1c <LL_USART_SetBaudRate+0x458>
 800baf4: fba2 2303    	umull	r2, r3, r2, r3
 800baf8: 095b         	lsrs	r3, r3, #0x5
 800bafa: b29b         	uxth	r3, r3
 800bafc: f003 030f    	and	r3, r3, #0xf
 800bb00: b29b         	uxth	r3, r3
 800bb02: 4423         	add	r3, r4
 800bb04: b29b         	uxth	r3, r3
 800bb06: 461a         	mov	r2, r3
 800bb08: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 800bb0c: 609a         	str	r2, [r3, #0x8]
; }
 800bb0e: bf00         	nop
 800bb10: f507 7780    	add.w	r7, r7, #0x100
 800bb14: 46bd         	mov	sp, r7
 800bb16: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 800bb1a: bf00         	nop

0800bb1c <$d>:
 800bb1c: 1f 85 eb 51  	.word	0x51eb851f

0800bb20 <uart_stm32_set_baudrate>:
; {
 800bb20: b580         	push	{r7, lr}
 800bb22: b08c         	sub	sp, #0x30
 800bb24: af04         	add	r7, sp, #0x10
 800bb26: 6078         	str	r0, [r7, #0x4]
 800bb28: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800bb2a: 687b         	ldr	r3, [r7, #0x4]
 800bb2c: 685b         	ldr	r3, [r3, #0x4]
 800bb2e: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 800bb30: 69bb         	ldr	r3, [r7, #0x18]
 800bb32: 681b         	ldr	r3, [r3]
 800bb34: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = dev->data;
 800bb36: 687b         	ldr	r3, [r7, #0x4]
 800bb38: 691b         	ldr	r3, [r3, #0x10]
 800bb3a: 61fb         	str	r3, [r7, #0x1c]
; 		if (clock_control_get_rate(data->clock,
 800bb3c: 69fb         	ldr	r3, [r7, #0x1c]
 800bb3e: 6818         	ldr	r0, [r3]
; 					   (clock_control_subsys_t)&config->pclken[0],
 800bb40: 69bb         	ldr	r3, [r7, #0x18]
 800bb42: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(data->clock,
 800bb44: f107 0208    	add.w	r2, r7, #0x8
 800bb48: 4619         	mov	r1, r3
 800bb4a: f00f fda4    	bl	0x801b696 <clock_control_get_rate> @ imm = #0xfb48
 800bb4e: 4603         	mov	r3, r0
 800bb50: 2b00         	cmp	r3, #0x0
 800bb52: da1a         	bge	0x800bb8a <uart_stm32_set_baudrate+0x6a> @ imm = #0x34
; 			LOG_ERR("Failed call clock_control_get_rate(pclken[0])");
 800bb54: 2303         	movs	r3, #0x3
 800bb56: 2b00         	cmp	r3, #0x0
 800bb58: d021         	beq	0x800bb9e <uart_stm32_set_baudrate+0x7e> @ imm = #0x42
 800bb5a: 2301         	movs	r3, #0x1
 800bb5c: 74fb         	strb	r3, [r7, #0x13]
 800bb5e: 7cfb         	ldrb	r3, [r7, #0x13]
 800bb60: f083 0301    	eor	r3, r3, #0x1
 800bb64: b2db         	uxtb	r3, r3
 800bb66: 2b00         	cmp	r3, #0x0
 800bb68: d119         	bne	0x800bb9e <uart_stm32_set_baudrate+0x7e> @ imm = #0x32
 800bb6a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800bba4 <uart_stm32_set_baudrate+0x84>
 800bb6c: 6819         	ldr	r1, [r3]
 800bb6e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800bba8 <uart_stm32_set_baudrate+0x88>
 800bb70: 9302         	str	r3, [sp, #0x8]
 800bb72: 2300         	movs	r3, #0x0
 800bb74: 9301         	str	r3, [sp, #0x4]
 800bb76: 2300         	movs	r3, #0x0
 800bb78: 9300         	str	r3, [sp]
 800bb7a: 2300         	movs	r3, #0x0
 800bb7c: 2201         	movs	r2, #0x1
 800bb7e: 2000         	movs	r0, #0x0
 800bb80: f010 fb1f    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0x1063e
 800bb84: 2300         	movs	r3, #0x0
 800bb86: 60fb         	str	r3, [r7, #0xc]
; 			return;
 800bb88: e009         	b	0x800bb9e <uart_stm32_set_baudrate+0x7e> @ imm = #0x12
; 		LL_USART_SetOverSampling(usart,
 800bb8a: 2100         	movs	r1, #0x0
 800bb8c: 6978         	ldr	r0, [r7, #0x14]
 800bb8e: f00f ff1c    	bl	0x801b9ca <LL_USART_SetOverSampling> @ imm = #0xfe38
; 		LL_USART_SetBaudRate(usart,
 800bb92: 68b9         	ldr	r1, [r7, #0x8]
 800bb94: 683b         	ldr	r3, [r7]
 800bb96: 2200         	movs	r2, #0x0
 800bb98: 6978         	ldr	r0, [r7, #0x14]
 800bb9a: f7ff fd93    	bl	0x800b6c4 <LL_USART_SetBaudRate> @ imm = #-0x4da
; }
 800bb9e: 3720         	adds	r7, #0x20
 800bba0: 46bd         	mov	sp, r7
 800bba2: bd80         	pop	{r7, pc}

0800bba4 <$d>:
 800bba4: 74 05 00 20  	.word	0x20000574
 800bba8: 90 1a 02 08  	.word	0x08021a90

0800bbac <uart_stm32_configure>:
; {
 800bbac: b580         	push	{r7, lr}
 800bbae: b08a         	sub	sp, #0x28
 800bbb0: af00         	add	r7, sp, #0x0
 800bbb2: 6078         	str	r0, [r7, #0x4]
 800bbb4: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800bbb6: 687b         	ldr	r3, [r7, #0x4]
 800bbb8: 685b         	ldr	r3, [r3, #0x4]
 800bbba: 627b         	str	r3, [r7, #0x24]
; 	USART_TypeDef *usart = config->usart;
 800bbbc: 6a7b         	ldr	r3, [r7, #0x24]
 800bbbe: 681b         	ldr	r3, [r3]
 800bbc0: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 800bbc2: 687b         	ldr	r3, [r7, #0x4]
 800bbc4: 691b         	ldr	r3, [r3, #0x10]
 800bbc6: 61fb         	str	r3, [r7, #0x1c]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 800bbc8: 69fb         	ldr	r3, [r7, #0x1c]
 800bbca: 685b         	ldr	r3, [r3, #0x4]
 800bbcc: 61bb         	str	r3, [r7, #0x18]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 800bbce: 683b         	ldr	r3, [r7]
 800bbd0: 791b         	ldrb	r3, [r3, #0x4]
 800bbd2: 4618         	mov	r0, r3
 800bbd4: f010 fb9f    	bl	0x801c316 <uart_stm32_cfg2ll_parity> @ imm = #0x1073e
 800bbd8: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 800bbda: 683b         	ldr	r3, [r7]
 800bbdc: 795b         	ldrb	r3, [r3, #0x5]
 800bbde: 4619         	mov	r1, r3
 800bbe0: 6a78         	ldr	r0, [r7, #0x24]
 800bbe2: f010 fbc7    	bl	0x801c374 <uart_stm32_cfg2ll_stopbits> @ imm = #0x1078e
 800bbe6: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 800bbe8: 683b         	ldr	r3, [r7]
 800bbea: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 800bbec: 683b         	ldr	r3, [r7]
 800bbee: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 800bbf0: 4619         	mov	r1, r3
 800bbf2: 4610         	mov	r0, r2
 800bbf4: f010 fbfe    	bl	0x801c3f4 <uart_stm32_cfg2ll_databits> @ imm = #0x107fc
 800bbf8: 60f8         	str	r0, [r7, #0xc]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 800bbfa: 683b         	ldr	r3, [r7]
 800bbfc: 791b         	ldrb	r3, [r3, #0x4]
 800bbfe: 2b03         	cmp	r3, #0x3
 800bc00: d003         	beq	0x800bc0a <uart_stm32_configure+0x5e> @ imm = #0x6
; 	    (cfg->parity == UART_CFG_PARITY_SPACE)) {
 800bc02: 683b         	ldr	r3, [r7]
 800bc04: 791b         	ldrb	r3, [r3, #0x4]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 800bc06: 2b04         	cmp	r3, #0x4
 800bc08: d102         	bne	0x800bc10 <uart_stm32_configure+0x64> @ imm = #0x4
; 		return -ENOTSUP;
 800bc0a: f06f 0385    	mvn	r3, #0x85
 800bc0e: e04f         	b	0x800bcb0 <uart_stm32_configure+0x104> @ imm = #0x9e
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 800bc10: 683b         	ldr	r3, [r7]
 800bc12: 791b         	ldrb	r3, [r3, #0x4]
 800bc14: 2b00         	cmp	r3, #0x0
 800bc16: d006         	beq	0x800bc26 <uart_stm32_configure+0x7a> @ imm = #0xc
; 	    (cfg->data_bits == UART_CFG_DATA_BITS_9)) {
 800bc18: 683b         	ldr	r3, [r7]
 800bc1a: 799b         	ldrb	r3, [r3, #0x6]
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 800bc1c: 2b04         	cmp	r3, #0x4
 800bc1e: d102         	bne	0x800bc26 <uart_stm32_configure+0x7a> @ imm = #0x4
; 		return -ENOTSUP;
 800bc20: f06f 0385    	mvn	r3, #0x85
 800bc24: e044         	b	0x800bcb0 <uart_stm32_configure+0x104> @ imm = #0x88
; 	if (uart_stm32_ll2cfg_stopbits(stopbits) != cfg->stop_bits) {
 800bc26: 6938         	ldr	r0, [r7, #0x10]
 800bc28: f010 fbc4    	bl	0x801c3b4 <uart_stm32_ll2cfg_stopbits> @ imm = #0x10788
 800bc2c: 4603         	mov	r3, r0
 800bc2e: 461a         	mov	r2, r3
 800bc30: 683b         	ldr	r3, [r7]
 800bc32: 795b         	ldrb	r3, [r3, #0x5]
 800bc34: 429a         	cmp	r2, r3
 800bc36: d002         	beq	0x800bc3e <uart_stm32_configure+0x92> @ imm = #0x4
; 		return -ENOTSUP;
 800bc38: f06f 0385    	mvn	r3, #0x85
 800bc3c: e038         	b	0x800bcb0 <uart_stm32_configure+0x104> @ imm = #0x70
; 	if (uart_stm32_ll2cfg_databits(databits, parity) != cfg->data_bits) {
 800bc3e: 6979         	ldr	r1, [r7, #0x14]
 800bc40: 68f8         	ldr	r0, [r7, #0xc]
 800bc42: f010 fbf2    	bl	0x801c42a <uart_stm32_ll2cfg_databits> @ imm = #0x107e4
 800bc46: 4603         	mov	r3, r0
 800bc48: 461a         	mov	r2, r3
 800bc4a: 683b         	ldr	r3, [r7]
 800bc4c: 799b         	ldrb	r3, [r3, #0x6]
 800bc4e: 429a         	cmp	r2, r3
 800bc50: d002         	beq	0x800bc58 <uart_stm32_configure+0xac> @ imm = #0x4
; 		return -ENOTSUP;
 800bc52: f06f 0385    	mvn	r3, #0x85
 800bc56: e02b         	b	0x800bcb0 <uart_stm32_configure+0x104> @ imm = #0x56
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 800bc58: 683b         	ldr	r3, [r7]
 800bc5a: 79db         	ldrb	r3, [r3, #0x7]
 800bc5c: 2b00         	cmp	r3, #0x0
 800bc5e: d016         	beq	0x800bc8e <uart_stm32_configure+0xe2> @ imm = #0x2c
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 800bc60: 683b         	ldr	r3, [r7]
 800bc62: 79db         	ldrb	r3, [r3, #0x7]
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 800bc64: 2b01         	cmp	r3, #0x1
 800bc66: d10f         	bne	0x800bc88 <uart_stm32_configure+0xdc> @ imm = #0x1e
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 800bc68: 6a3b         	ldr	r3, [r7, #0x20]
 800bc6a: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800bcb8 <uart_stm32_configure+0x10c>
 800bc6c: 4293         	cmp	r3, r2
 800bc6e: d00e         	beq	0x800bc8e <uart_stm32_configure+0xe2> @ imm = #0x1c
; 			IS_UART_HWFLOW_INSTANCE(usart))
 800bc70: 6a3b         	ldr	r3, [r7, #0x20]
 800bc72: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800bcbc <uart_stm32_configure+0x110>
 800bc74: 4293         	cmp	r3, r2
 800bc76: d00a         	beq	0x800bc8e <uart_stm32_configure+0xe2> @ imm = #0x14
 800bc78: 6a3b         	ldr	r3, [r7, #0x20]
 800bc7a: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800bcc0 <uart_stm32_configure+0x114>
 800bc7c: 4293         	cmp	r3, r2
 800bc7e: d006         	beq	0x800bc8e <uart_stm32_configure+0xe2> @ imm = #0xc
 800bc80: 6a3b         	ldr	r3, [r7, #0x20]
 800bc82: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800bcc4 <uart_stm32_configure+0x118>
 800bc84: 4293         	cmp	r3, r2
 800bc86: d002         	beq	0x800bc8e <uart_stm32_configure+0xe2> @ imm = #0x4
; 		return -ENOTSUP;
 800bc88: f06f 0385    	mvn	r3, #0x85
 800bc8c: e010         	b	0x800bcb0 <uart_stm32_configure+0x104> @ imm = #0x20
; 	LL_USART_Disable(usart);
 800bc8e: 6a38         	ldr	r0, [r7, #0x20]
 800bc90: f00f fe23    	bl	0x801b8da <LL_USART_Disable> @ imm = #0xfc46
; 	uart_stm32_parameters_set(dev, cfg);
 800bc94: 6839         	ldr	r1, [r7]
 800bc96: 6878         	ldr	r0, [r7, #0x4]
 800bc98: f010 fc0b    	bl	0x801c4b2 <uart_stm32_parameters_set> @ imm = #0x10816
; 	LL_USART_Enable(usart);
 800bc9c: 6a38         	ldr	r0, [r7, #0x20]
 800bc9e: f00f fe0c    	bl	0x801b8ba <LL_USART_Enable> @ imm = #0xfc18
; 	*uart_cfg = *cfg;
 800bca2: 69bb         	ldr	r3, [r7, #0x18]
 800bca4: 683a         	ldr	r2, [r7]
 800bca6: e892 0003    	ldm.w	r2, {r0, r1}
 800bcaa: e883 0003    	stm.w	r3, {r0, r1}
; 	return 0;
 800bcae: 2300         	movs	r3, #0x0
; };
 800bcb0: 4618         	mov	r0, r3
 800bcb2: 3728         	adds	r7, #0x28
 800bcb4: 46bd         	mov	sp, r7
 800bcb6: bd80         	pop	{r7, pc}

0800bcb8 <$d>:
 800bcb8: 00 10 01 40  	.word	0x40011000
 800bcbc: 00 44 00 40  	.word	0x40004400
 800bcc0: 00 48 00 40  	.word	0x40004800
 800bcc4: 00 14 01 40  	.word	0x40011400

0800bcc8 <uart_stm32_poll_in>:
; {
 800bcc8: b580         	push	{r7, lr}
 800bcca: b082         	sub	sp, #0x8
 800bccc: af00         	add	r7, sp, #0x0
 800bcce: 6078         	str	r0, [r7, #0x4]
 800bcd0: 6039         	str	r1, [r7]
; 	return uart_stm32_poll_in_visitor(dev, (void *)c, poll_in_u8);
 800bcd2: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800bce8 <uart_stm32_poll_in+0x20>
 800bcd4: 6839         	ldr	r1, [r7]
 800bcd6: 6878         	ldr	r0, [r7, #0x4]
 800bcd8: f010 fcb0    	bl	0x801c63c <uart_stm32_poll_in_visitor> @ imm = #0x10960
 800bcdc: 4603         	mov	r3, r0
; }
 800bcde: 4618         	mov	r0, r3
 800bce0: 3708         	adds	r7, #0x8
 800bce2: 46bd         	mov	sp, r7
 800bce4: bd80         	pop	{r7, pc}
 800bce6: bf00         	nop

0800bce8 <$d>:
 800bce8: 23 c7 01 08  	.word	0x0801c723

0800bcec <uart_stm32_poll_out>:
; {
 800bcec: b580         	push	{r7, lr}
 800bcee: b082         	sub	sp, #0x8
 800bcf0: af00         	add	r7, sp, #0x0
 800bcf2: 6078         	str	r0, [r7, #0x4]
 800bcf4: 460b         	mov	r3, r1
 800bcf6: 70fb         	strb	r3, [r7, #0x3]
; 	uart_stm32_poll_out_visitor(dev, c, poll_out_u8);
 800bcf8: 78fb         	ldrb	r3, [r7, #0x3]
 800bcfa: b29b         	uxth	r3, r3
 800bcfc: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800bd10 <uart_stm32_poll_out+0x24>
 800bcfe: 4619         	mov	r1, r3
 800bd00: 6878         	ldr	r0, [r7, #0x4]
 800bd02: f010 fcc2    	bl	0x801c68a <uart_stm32_poll_out_visitor> @ imm = #0x10984
; }
 800bd06: bf00         	nop
 800bd08: 3708         	adds	r7, #0x8
 800bd0a: 46bd         	mov	sp, r7
 800bd0c: bd80         	pop	{r7, pc}
 800bd0e: bf00         	nop

0800bd10 <$d>:
 800bd10: 43 c7 01 08  	.word	0x0801c743

0800bd14 <__uart_stm32_get_clock>:
; {
 800bd14: b480         	push	{r7}
 800bd16: b085         	sub	sp, #0x14
 800bd18: af00         	add	r7, sp, #0x0
 800bd1a: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800bd1c: 687b         	ldr	r3, [r7, #0x4]
 800bd1e: 691b         	ldr	r3, [r3, #0x10]
 800bd20: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 800bd22: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800bd38 <__uart_stm32_get_clock+0x24>
 800bd24: 60bb         	str	r3, [r7, #0x8]
; 	data->clock = clk;
 800bd26: 68fb         	ldr	r3, [r7, #0xc]
 800bd28: 68ba         	ldr	r2, [r7, #0x8]
 800bd2a: 601a         	str	r2, [r3]
; }
 800bd2c: bf00         	nop
 800bd2e: 3714         	adds	r7, #0x14
 800bd30: 46bd         	mov	sp, r7
 800bd32: f85d 7b04    	ldr	r7, [sp], #4
 800bd36: 4770         	bx	lr

0800bd38 <$d>:
 800bd38: 80 01 02 08  	.word	0x08020180

0800bd3c <uart_stm32_fifo_fill>:
; {
 800bd3c: b590         	push	{r4, r7, lr}
 800bd3e: b085         	sub	sp, #0x14
 800bd40: af00         	add	r7, sp, #0x0
 800bd42: 60f8         	str	r0, [r7, #0xc]
 800bd44: 60b9         	str	r1, [r7, #0x8]
 800bd46: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 800bd48: 68f8         	ldr	r0, [r7, #0xc]
 800bd4a: f010 fab0    	bl	0x801c2ae <uart_stm32_get_databits> @ imm = #0x10560
 800bd4e: 4604         	mov	r4, r0
 800bd50: 68f8         	ldr	r0, [r7, #0xc]
 800bd52: f010 fa66    	bl	0x801c222 <uart_stm32_get_parity> @ imm = #0x104cc
 800bd56: 4603         	mov	r3, r0
 800bd58: 4619         	mov	r1, r3
 800bd5a: 4620         	mov	r0, r4
 800bd5c: f010 fb65    	bl	0x801c42a <uart_stm32_ll2cfg_databits> @ imm = #0x106ca
 800bd60: 4603         	mov	r3, r0
 800bd62: 2b04         	cmp	r3, #0x4
 800bd64: d102         	bne	0x800bd6c <uart_stm32_fifo_fill+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 800bd66: f06f 0385    	mvn	r3, #0x85
 800bd6a: e006         	b	0x800bd7a <uart_stm32_fifo_fill+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_fill_visitor(dev, (const void *)tx_data, size,
 800bd6c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800bd84 <uart_stm32_fifo_fill+0x48>
 800bd6e: 687a         	ldr	r2, [r7, #0x4]
 800bd70: 68b9         	ldr	r1, [r7, #0x8]
 800bd72: 68f8         	ldr	r0, [r7, #0xc]
 800bd74: f010 fd60    	bl	0x801c838 <uart_stm32_fifo_fill_visitor> @ imm = #0x10ac0
 800bd78: 4603         	mov	r3, r0
; }
 800bd7a: 4618         	mov	r0, r3
 800bd7c: 3714         	adds	r7, #0x14
 800bd7e: 46bd         	mov	sp, r7
 800bd80: bd90         	pop	{r4, r7, pc}
 800bd82: bf00         	nop

0800bd84 <$d>:
 800bd84: d1 c8 01 08  	.word	0x0801c8d1

0800bd88 <uart_stm32_fifo_read>:
; {
 800bd88: b590         	push	{r4, r7, lr}
 800bd8a: b085         	sub	sp, #0x14
 800bd8c: af00         	add	r7, sp, #0x0
 800bd8e: 60f8         	str	r0, [r7, #0xc]
 800bd90: 60b9         	str	r1, [r7, #0x8]
 800bd92: 607a         	str	r2, [r7, #0x4]
; 	if (uart_stm32_ll2cfg_databits(uart_stm32_get_databits(dev), uart_stm32_get_parity(dev)) ==
 800bd94: 68f8         	ldr	r0, [r7, #0xc]
 800bd96: f010 fa8a    	bl	0x801c2ae <uart_stm32_get_databits> @ imm = #0x10514
 800bd9a: 4604         	mov	r4, r0
 800bd9c: 68f8         	ldr	r0, [r7, #0xc]
 800bd9e: f010 fa40    	bl	0x801c222 <uart_stm32_get_parity> @ imm = #0x10480
 800bda2: 4603         	mov	r3, r0
 800bda4: 4619         	mov	r1, r3
 800bda6: 4620         	mov	r0, r4
 800bda8: f010 fb3f    	bl	0x801c42a <uart_stm32_ll2cfg_databits> @ imm = #0x1067e
 800bdac: 4603         	mov	r3, r0
 800bdae: 2b04         	cmp	r3, #0x4
 800bdb0: d102         	bne	0x800bdb8 <uart_stm32_fifo_read+0x30> @ imm = #0x4
; 		return -ENOTSUP;
 800bdb2: f06f 0385    	mvn	r3, #0x85
 800bdb6: e006         	b	0x800bdc6 <uart_stm32_fifo_read+0x3e> @ imm = #0xc
; 	return uart_stm32_fifo_read_visitor(dev, (void *)rx_data, size,
 800bdb8: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800bdd0 <uart_stm32_fifo_read+0x48>
 800bdba: 687a         	ldr	r2, [r7, #0x4]
 800bdbc: 68b9         	ldr	r1, [r7, #0x8]
 800bdbe: 68f8         	ldr	r0, [r7, #0xc]
 800bdc0: f010 fd9a    	bl	0x801c8f8 <uart_stm32_fifo_read_visitor> @ imm = #0x10b34
 800bdc4: 4603         	mov	r3, r0
; }
 800bdc6: 4618         	mov	r0, r3
 800bdc8: 3714         	adds	r7, #0x14
 800bdca: 46bd         	mov	sp, r7
 800bdcc: bd90         	pop	{r4, r7, pc}
 800bdce: bf00         	nop

0800bdd0 <$d>:
 800bdd0: 5b c9 01 08  	.word	0x0801c95b

0800bdd4 <uart_stm32_irq_err_enable>:
; {
 800bdd4: b580         	push	{r7, lr}
 800bdd6: b084         	sub	sp, #0x10
 800bdd8: af00         	add	r7, sp, #0x0
 800bdda: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800bddc: 687b         	ldr	r3, [r7, #0x4]
 800bdde: 685b         	ldr	r3, [r3, #0x4]
 800bde0: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 800bde2: 68fb         	ldr	r3, [r7, #0xc]
 800bde4: 681b         	ldr	r3, [r3]
 800bde6: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableIT_ERROR(usart);
 800bde8: 68b8         	ldr	r0, [r7, #0x8]
 800bdea: f010 f83e    	bl	0x801be6a <LL_USART_EnableIT_ERROR> @ imm = #0x1007c
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 800bdee: 68bb         	ldr	r3, [r7, #0x8]
 800bdf0: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800be34 <uart_stm32_irq_err_enable+0x60>
 800bdf2: 4293         	cmp	r3, r2
 800bdf4: d013         	beq	0x800be1e <uart_stm32_irq_err_enable+0x4a> @ imm = #0x26
 800bdf6: 68bb         	ldr	r3, [r7, #0x8]
 800bdf8: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x800be38 <uart_stm32_irq_err_enable+0x64>
 800bdfa: 4293         	cmp	r3, r2
 800bdfc: d00f         	beq	0x800be1e <uart_stm32_irq_err_enable+0x4a> @ imm = #0x1e
 800bdfe: 68bb         	ldr	r3, [r7, #0x8]
 800be00: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800be3c <uart_stm32_irq_err_enable+0x68>
 800be02: 4293         	cmp	r3, r2
 800be04: d00b         	beq	0x800be1e <uart_stm32_irq_err_enable+0x4a> @ imm = #0x16
 800be06: 68bb         	ldr	r3, [r7, #0x8]
 800be08: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800be40 <uart_stm32_irq_err_enable+0x6c>
 800be0a: 4293         	cmp	r3, r2
 800be0c: d007         	beq	0x800be1e <uart_stm32_irq_err_enable+0x4a> @ imm = #0xe
 800be0e: 68bb         	ldr	r3, [r7, #0x8]
 800be10: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800be44 <uart_stm32_irq_err_enable+0x70>
 800be12: 4293         	cmp	r3, r2
 800be14: d003         	beq	0x800be1e <uart_stm32_irq_err_enable+0x4a> @ imm = #0x6
 800be16: 68bb         	ldr	r3, [r7, #0x8]
 800be18: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800be48 <uart_stm32_irq_err_enable+0x74>
 800be1a: 4293         	cmp	r3, r2
 800be1c: d102         	bne	0x800be24 <uart_stm32_irq_err_enable+0x50> @ imm = #0x4
; 		LL_USART_EnableIT_LBD(usart);
 800be1e: 68b8         	ldr	r0, [r7, #0x8]
 800be20: f010 f813    	bl	0x801be4a <LL_USART_EnableIT_LBD> @ imm = #0x10026
; 	LL_USART_EnableIT_PE(usart);
 800be24: 68b8         	ldr	r0, [r7, #0x8]
 800be26: f00f ffed    	bl	0x801be04 <LL_USART_EnableIT_PE> @ imm = #0xffda
; }
 800be2a: bf00         	nop
 800be2c: 3710         	adds	r7, #0x10
 800be2e: 46bd         	mov	sp, r7
 800be30: bd80         	pop	{r7, pc}
 800be32: bf00         	nop

0800be34 <$d>:
 800be34: 00 10 01 40  	.word	0x40011000
 800be38: 00 44 00 40  	.word	0x40004400
 800be3c: 00 48 00 40  	.word	0x40004800
 800be40: 00 4c 00 40  	.word	0x40004c00
 800be44: 00 50 00 40  	.word	0x40005000
 800be48: 00 14 01 40  	.word	0x40011400

0800be4c <uart_stm32_irq_err_disable>:
; {
 800be4c: b580         	push	{r7, lr}
 800be4e: b084         	sub	sp, #0x10
 800be50: af00         	add	r7, sp, #0x0
 800be52: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800be54: 687b         	ldr	r3, [r7, #0x4]
 800be56: 685b         	ldr	r3, [r3, #0x4]
 800be58: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 800be5a: 68fb         	ldr	r3, [r7, #0xc]
 800be5c: 681b         	ldr	r3, [r3]
 800be5e: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_DisableIT_ERROR(usart);
 800be60: 68b8         	ldr	r0, [r7, #0x8]
 800be62: f010 f8c1    	bl	0x801bfe8 <LL_USART_DisableIT_ERROR> @ imm = #0x10182
; 	if (IS_UART_LIN_INSTANCE(usart)) {
 800be66: 68bb         	ldr	r3, [r7, #0x8]
 800be68: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800beac <uart_stm32_irq_err_disable+0x60>
 800be6a: 4293         	cmp	r3, r2
 800be6c: d013         	beq	0x800be96 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x26
 800be6e: 68bb         	ldr	r3, [r7, #0x8]
 800be70: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x800beb0 <uart_stm32_irq_err_disable+0x64>
 800be72: 4293         	cmp	r3, r2
 800be74: d00f         	beq	0x800be96 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x1e
 800be76: 68bb         	ldr	r3, [r7, #0x8]
 800be78: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800beb4 <uart_stm32_irq_err_disable+0x68>
 800be7a: 4293         	cmp	r3, r2
 800be7c: d00b         	beq	0x800be96 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x16
 800be7e: 68bb         	ldr	r3, [r7, #0x8]
 800be80: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800beb8 <uart_stm32_irq_err_disable+0x6c>
 800be82: 4293         	cmp	r3, r2
 800be84: d007         	beq	0x800be96 <uart_stm32_irq_err_disable+0x4a> @ imm = #0xe
 800be86: 68bb         	ldr	r3, [r7, #0x8]
 800be88: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800bebc <uart_stm32_irq_err_disable+0x70>
 800be8a: 4293         	cmp	r3, r2
 800be8c: d003         	beq	0x800be96 <uart_stm32_irq_err_disable+0x4a> @ imm = #0x6
 800be8e: 68bb         	ldr	r3, [r7, #0x8]
 800be90: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800bec0 <uart_stm32_irq_err_disable+0x74>
 800be92: 4293         	cmp	r3, r2
 800be94: d102         	bne	0x800be9c <uart_stm32_irq_err_disable+0x50> @ imm = #0x4
; 		LL_USART_DisableIT_LBD(usart);
 800be96: 68b8         	ldr	r0, [r7, #0x8]
 800be98: f010 f896    	bl	0x801bfc8 <LL_USART_DisableIT_LBD> @ imm = #0x1012c
; 	LL_USART_DisableIT_PE(usart);
 800be9c: 68b8         	ldr	r0, [r7, #0x8]
 800be9e: f010 f870    	bl	0x801bf82 <LL_USART_DisableIT_PE> @ imm = #0x100e0
; }
 800bea2: bf00         	nop
 800bea4: 3710         	adds	r7, #0x10
 800bea6: 46bd         	mov	sp, r7
 800bea8: bd80         	pop	{r7, pc}
 800beaa: bf00         	nop

0800beac <$d>:
 800beac: 00 10 01 40  	.word	0x40011000
 800beb0: 00 44 00 40  	.word	0x40004400
 800beb4: 00 48 00 40  	.word	0x40004800
 800beb8: 00 4c 00 40  	.word	0x40004c00
 800bebc: 00 50 00 40  	.word	0x40005000
 800bec0: 00 14 01 40  	.word	0x40011400

0800bec4 <async_evt_rx_rdy>:
; {
 800bec4: b580         	push	{r7, lr}
 800bec6: b090         	sub	sp, #0x40
 800bec8: af06         	add	r7, sp, #0x18
 800beca: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("rx_rdy: (%d %d)", data->dma_rx.offset, data->dma_rx.counter);
 800becc: 2303         	movs	r3, #0x3
 800bece: 2b03         	cmp	r3, #0x3
 800bed0: d920         	bls	0x800bf14 <async_evt_rx_rdy+0x50> @ imm = #0x40
 800bed2: 2301         	movs	r3, #0x1
 800bed4: f887 3027    	strb.w	r3, [r7, #0x27]
 800bed8: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800bedc: f083 0301    	eor	r3, r3, #0x1
 800bee0: b2db         	uxtb	r3, r3
 800bee2: 2b00         	cmp	r3, #0x0
 800bee4: d116         	bne	0x800bf14 <async_evt_rx_rdy+0x50> @ imm = #0x2c
 800bee6: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800bf64 <async_evt_rx_rdy+0xa0>
 800bee8: 6819         	ldr	r1, [r3]
 800beea: 687b         	ldr	r3, [r7, #0x4]
 800beec: 6f5b         	ldr	r3, [r3, #0x74]
 800beee: 687a         	ldr	r2, [r7, #0x4]
 800bef0: 6f92         	ldr	r2, [r2, #0x78]
 800bef2: 9205         	str	r2, [sp, #0x14]
 800bef4: 9304         	str	r3, [sp, #0x10]
 800bef6: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800bf68 <async_evt_rx_rdy+0xa4>
 800bef8: 9303         	str	r3, [sp, #0xc]
 800befa: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800bf6c <async_evt_rx_rdy+0xa8>
 800befc: 9302         	str	r3, [sp, #0x8]
 800befe: 2308         	movs	r3, #0x8
 800bf00: 9301         	str	r3, [sp, #0x4]
 800bf02: 2300         	movs	r3, #0x0
 800bf04: 9300         	str	r3, [sp]
 800bf06: 2300         	movs	r3, #0x0
 800bf08: 2204         	movs	r2, #0x4
 800bf0a: 2000         	movs	r0, #0x0
 800bf0c: f010 f959    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0x102b2
 800bf10: 2300         	movs	r3, #0x0
 800bf12: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800bf14: f107 030c    	add.w	r3, r7, #0xc
 800bf18: 2200         	movs	r2, #0x0
 800bf1a: 601a         	str	r2, [r3]
 800bf1c: 605a         	str	r2, [r3, #0x4]
 800bf1e: 609a         	str	r2, [r3, #0x8]
 800bf20: 60da         	str	r2, [r3, #0xc]
 800bf22: 611a         	str	r2, [r3, #0x10]
 800bf24: 2302         	movs	r3, #0x2
 800bf26: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx.buf = data->dma_rx.buffer,
 800bf28: 687b         	ldr	r3, [r7, #0x4]
 800bf2a: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 800bf2c: 613b         	str	r3, [r7, #0x10]
; 		.data.rx.offset = data->dma_rx.offset
 800bf2e: 687b         	ldr	r3, [r7, #0x4]
 800bf30: 6f5b         	ldr	r3, [r3, #0x74]
; 	struct uart_event event = {
 800bf32: 617b         	str	r3, [r7, #0x14]
; 		.data.rx.len = data->dma_rx.counter - data->dma_rx.offset,
 800bf34: 687b         	ldr	r3, [r7, #0x4]
 800bf36: 6f9a         	ldr	r2, [r3, #0x78]
 800bf38: 687b         	ldr	r3, [r7, #0x4]
 800bf3a: 6f5b         	ldr	r3, [r3, #0x74]
 800bf3c: 1ad3         	subs	r3, r2, r3
; 	struct uart_event event = {
 800bf3e: 61bb         	str	r3, [r7, #0x18]
; 	data->dma_rx.offset = data->dma_rx.counter;
 800bf40: 687b         	ldr	r3, [r7, #0x4]
 800bf42: 6f9a         	ldr	r2, [r3, #0x78]
 800bf44: 687b         	ldr	r3, [r7, #0x4]
 800bf46: 675a         	str	r2, [r3, #0x74]
; 	if (event.data.rx.len > 0) {
 800bf48: 69bb         	ldr	r3, [r7, #0x18]
 800bf4a: 2b00         	cmp	r3, #0x0
 800bf4c: d005         	beq	0x800bf5a <async_evt_rx_rdy+0x96> @ imm = #0xa
; 		async_user_callback(data, &event);
 800bf4e: f107 030c    	add.w	r3, r7, #0xc
 800bf52: 4619         	mov	r1, r3
 800bf54: 6878         	ldr	r0, [r7, #0x4]
 800bf56: f010 fde3    	bl	0x801cb20 <async_user_callback> @ imm = #0x10bc6
; }
 800bf5a: bf00         	nop
 800bf5c: 3728         	adds	r7, #0x28
 800bf5e: 46bd         	mov	sp, r7
 800bf60: bd80         	pop	{r7, pc}
 800bf62: bf00         	nop

0800bf64 <$d>:
 800bf64: 74 05 00 20  	.word	0x20000574
 800bf68: 6c 2c 02 08  	.word	0x08022c6c
 800bf6c: c0 1a 02 08  	.word	0x08021ac0

0800bf70 <async_evt_rx_err>:
; {
 800bf70: b580         	push	{r7, lr}
 800bf72: b090         	sub	sp, #0x40
 800bf74: af06         	add	r7, sp, #0x18
 800bf76: 6078         	str	r0, [r7, #0x4]
 800bf78: 6039         	str	r1, [r7]
; 	LOG_DBG("rx error: %d", err_code);
 800bf7a: 2303         	movs	r3, #0x3
 800bf7c: 2b03         	cmp	r3, #0x3
 800bf7e: d91c         	bls	0x800bfba <async_evt_rx_err+0x4a> @ imm = #0x38
 800bf80: 2301         	movs	r3, #0x1
 800bf82: f887 3027    	strb.w	r3, [r7, #0x27]
 800bf86: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800bf8a: f083 0301    	eor	r3, r3, #0x1
 800bf8e: b2db         	uxtb	r3, r3
 800bf90: 2b00         	cmp	r3, #0x0
 800bf92: d112         	bne	0x800bfba <async_evt_rx_err+0x4a> @ imm = #0x24
 800bf94: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800bfe8 <async_evt_rx_err+0x78>
 800bf96: 6819         	ldr	r1, [r3]
 800bf98: 683b         	ldr	r3, [r7]
 800bf9a: 9304         	str	r3, [sp, #0x10]
 800bf9c: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800bfec <async_evt_rx_err+0x7c>
 800bf9e: 9303         	str	r3, [sp, #0xc]
 800bfa0: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800bff0 <async_evt_rx_err+0x80>
 800bfa2: 9302         	str	r3, [sp, #0x8]
 800bfa4: 2308         	movs	r3, #0x8
 800bfa6: 9301         	str	r3, [sp, #0x4]
 800bfa8: 2300         	movs	r3, #0x0
 800bfaa: 9300         	str	r3, [sp]
 800bfac: 2300         	movs	r3, #0x0
 800bfae: 2204         	movs	r2, #0x4
 800bfb0: 2000         	movs	r0, #0x0
 800bfb2: f010 f906    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0x1020c
 800bfb6: 2300         	movs	r3, #0x0
 800bfb8: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800bfba: 2306         	movs	r3, #0x6
 800bfbc: 733b         	strb	r3, [r7, #0xc]
 800bfbe: 683b         	ldr	r3, [r7]
 800bfc0: b2db         	uxtb	r3, r3
 800bfc2: 743b         	strb	r3, [r7, #0x10]
; 		.data.rx_stop.data.buf = data->dma_rx.buffer
 800bfc4: 687b         	ldr	r3, [r7, #0x4]
 800bfc6: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event event = {
 800bfc8: 617b         	str	r3, [r7, #0x14]
 800bfca: 2300         	movs	r3, #0x0
 800bfcc: 61bb         	str	r3, [r7, #0x18]
; 		.data.rx_stop.data.len = data->dma_rx.counter,
 800bfce: 687b         	ldr	r3, [r7, #0x4]
 800bfd0: 6f9b         	ldr	r3, [r3, #0x78]
; 	struct uart_event event = {
 800bfd2: 61fb         	str	r3, [r7, #0x1c]
; 	async_user_callback(data, &event);
 800bfd4: f107 030c    	add.w	r3, r7, #0xc
 800bfd8: 4619         	mov	r1, r3
 800bfda: 6878         	ldr	r0, [r7, #0x4]
 800bfdc: f010 fda0    	bl	0x801cb20 <async_user_callback> @ imm = #0x10b40
; }
 800bfe0: bf00         	nop
 800bfe2: 3728         	adds	r7, #0x28
 800bfe4: 46bd         	mov	sp, r7
 800bfe6: bd80         	pop	{r7, pc}

0800bfe8 <$d>:
 800bfe8: 74 05 00 20  	.word	0x20000574
 800bfec: f4 2c 02 08  	.word	0x08022cf4
 800bff0: d4 1a 02 08  	.word	0x08021ad4

0800bff4 <async_evt_tx_done>:
; {
 800bff4: b580         	push	{r7, lr}
 800bff6: b090         	sub	sp, #0x40
 800bff8: af06         	add	r7, sp, #0x18
 800bffa: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx done: %d", data->dma_tx.counter);
 800bffc: 2303         	movs	r3, #0x3
 800bffe: 2b03         	cmp	r3, #0x3
 800c000: d91e         	bls	0x800c040 <async_evt_tx_done+0x4c> @ imm = #0x3c
 800c002: 2301         	movs	r3, #0x1
 800c004: f887 3027    	strb.w	r3, [r7, #0x27]
 800c008: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800c00c: f083 0301    	eor	r3, r3, #0x1
 800c010: b2db         	uxtb	r3, r3
 800c012: 2b00         	cmp	r3, #0x0
 800c014: d114         	bne	0x800c040 <async_evt_tx_done+0x4c> @ imm = #0x28
 800c016: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800c084 <async_evt_tx_done+0x90>
 800c018: 6819         	ldr	r1, [r3]
 800c01a: 687b         	ldr	r3, [r7, #0x4]
 800c01c: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 800c020: 9304         	str	r3, [sp, #0x10]
 800c022: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800c088 <async_evt_tx_done+0x94>
 800c024: 9303         	str	r3, [sp, #0xc]
 800c026: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800c08c <async_evt_tx_done+0x98>
 800c028: 9302         	str	r3, [sp, #0x8]
 800c02a: 2308         	movs	r3, #0x8
 800c02c: 9301         	str	r3, [sp, #0x4]
 800c02e: 2300         	movs	r3, #0x0
 800c030: 9300         	str	r3, [sp]
 800c032: 2300         	movs	r3, #0x0
 800c034: 2204         	movs	r2, #0x4
 800c036: 2000         	movs	r0, #0x0
 800c038: f010 f8c3    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0x10186
 800c03c: 2300         	movs	r3, #0x0
 800c03e: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800c040: f107 030c    	add.w	r3, r7, #0xc
 800c044: 2200         	movs	r2, #0x0
 800c046: 601a         	str	r2, [r3]
 800c048: 605a         	str	r2, [r3, #0x4]
 800c04a: 609a         	str	r2, [r3, #0x8]
 800c04c: 60da         	str	r2, [r3, #0xc]
 800c04e: 611a         	str	r2, [r3, #0x10]
; 		.data.tx.buf = data->dma_tx.buffer,
 800c050: 687b         	ldr	r3, [r7, #0x4]
 800c052: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 800c056: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 800c058: 687b         	ldr	r3, [r7, #0x4]
 800c05a: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 800c05e: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 800c060: 687b         	ldr	r3, [r7, #0x4]
 800c062: 2200         	movs	r2, #0x0
 800c064: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 800c068: 687b         	ldr	r3, [r7, #0x4]
 800c06a: 2200         	movs	r2, #0x0
 800c06c: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 800c070: f107 030c    	add.w	r3, r7, #0xc
 800c074: 4619         	mov	r1, r3
 800c076: 6878         	ldr	r0, [r7, #0x4]
 800c078: f010 fd52    	bl	0x801cb20 <async_user_callback> @ imm = #0x10aa4
; }
 800c07c: bf00         	nop
 800c07e: 3728         	adds	r7, #0x28
 800c080: 46bd         	mov	sp, r7
 800c082: bd80         	pop	{r7, pc}

0800c084 <$d>:
 800c084: 74 05 00 20  	.word	0x20000574
 800c088: a4 2c 02 08  	.word	0x08022ca4
 800c08c: e8 1a 02 08  	.word	0x08021ae8

0800c090 <async_evt_tx_abort>:
; {
 800c090: b580         	push	{r7, lr}
 800c092: b090         	sub	sp, #0x40
 800c094: af06         	add	r7, sp, #0x18
 800c096: 6078         	str	r0, [r7, #0x4]
; 	LOG_DBG("tx abort: %d", data->dma_tx.counter);
 800c098: 2303         	movs	r3, #0x3
 800c09a: 2b03         	cmp	r3, #0x3
 800c09c: d91e         	bls	0x800c0dc <async_evt_tx_abort+0x4c> @ imm = #0x3c
 800c09e: 2301         	movs	r3, #0x1
 800c0a0: f887 3027    	strb.w	r3, [r7, #0x27]
 800c0a4: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800c0a8: f083 0301    	eor	r3, r3, #0x1
 800c0ac: b2db         	uxtb	r3, r3
 800c0ae: 2b00         	cmp	r3, #0x0
 800c0b0: d114         	bne	0x800c0dc <async_evt_tx_abort+0x4c> @ imm = #0x28
 800c0b2: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800c124 <async_evt_tx_abort+0x94>
 800c0b4: 6819         	ldr	r1, [r3]
 800c0b6: 687b         	ldr	r3, [r7, #0x4]
 800c0b8: f8d3 3110    	ldr.w	r3, [r3, #0x110]
 800c0bc: 9304         	str	r3, [sp, #0x10]
 800c0be: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800c128 <async_evt_tx_abort+0x98>
 800c0c0: 9303         	str	r3, [sp, #0xc]
 800c0c2: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800c12c <async_evt_tx_abort+0x9c>
 800c0c4: 9302         	str	r3, [sp, #0x8]
 800c0c6: 2308         	movs	r3, #0x8
 800c0c8: 9301         	str	r3, [sp, #0x4]
 800c0ca: 2300         	movs	r3, #0x0
 800c0cc: 9300         	str	r3, [sp]
 800c0ce: 2300         	movs	r3, #0x0
 800c0d0: 2204         	movs	r2, #0x4
 800c0d2: 2000         	movs	r0, #0x0
 800c0d4: f010 f875    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0x100ea
 800c0d8: 2300         	movs	r3, #0x0
 800c0da: 623b         	str	r3, [r7, #0x20]
; 	struct uart_event event = {
 800c0dc: f107 030c    	add.w	r3, r7, #0xc
 800c0e0: 2200         	movs	r2, #0x0
 800c0e2: 601a         	str	r2, [r3]
 800c0e4: 605a         	str	r2, [r3, #0x4]
 800c0e6: 609a         	str	r2, [r3, #0x8]
 800c0e8: 60da         	str	r2, [r3, #0xc]
 800c0ea: 611a         	str	r2, [r3, #0x10]
 800c0ec: 2301         	movs	r3, #0x1
 800c0ee: 733b         	strb	r3, [r7, #0xc]
; 		.data.tx.buf = data->dma_tx.buffer,
 800c0f0: 687b         	ldr	r3, [r7, #0x4]
 800c0f2: f8d3 3104    	ldr.w	r3, [r3, #0x104]
; 	struct uart_event event = {
 800c0f6: 613b         	str	r3, [r7, #0x10]
; 		.data.tx.len = data->dma_tx.counter
 800c0f8: 687b         	ldr	r3, [r7, #0x4]
 800c0fa: f8d3 3110    	ldr.w	r3, [r3, #0x110]
; 	struct uart_event event = {
 800c0fe: 617b         	str	r3, [r7, #0x14]
; 	data->dma_tx.buffer_length = 0;
 800c100: 687b         	ldr	r3, [r7, #0x4]
 800c102: 2200         	movs	r2, #0x0
 800c104: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.counter = 0;
 800c108: 687b         	ldr	r3, [r7, #0x4]
 800c10a: 2200         	movs	r2, #0x0
 800c10c: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	async_user_callback(data, &event);
 800c110: f107 030c    	add.w	r3, r7, #0xc
 800c114: 4619         	mov	r1, r3
 800c116: 6878         	ldr	r0, [r7, #0x4]
 800c118: f010 fd02    	bl	0x801cb20 <async_user_callback> @ imm = #0x10a04
; }
 800c11c: bf00         	nop
 800c11e: 3728         	adds	r7, #0x28
 800c120: 46bd         	mov	sp, r7
 800c122: bd80         	pop	{r7, pc}

0800c124 <$d>:
 800c124: 74 05 00 20  	.word	0x20000574
 800c128: 38 2d 02 08  	.word	0x08022d38
 800c12c: f8 1a 02 08  	.word	0x08021af8

0800c130 <async_timer_start>:
; {
 800c130: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800c134: b08a         	sub	sp, #0x28
 800c136: af06         	add	r7, sp, #0x18
 800c138: 6078         	str	r0, [r7, #0x4]
 800c13a: 6039         	str	r1, [r7]
; 	if ((timeout != SYS_FOREVER_US) && (timeout != 0)) {
 800c13c: 683b         	ldr	r3, [r7]
 800c13e: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800c142: d037         	beq	0x800c1b4 <async_timer_start+0x84> @ imm = #0x6e
 800c144: 683b         	ldr	r3, [r7]
 800c146: 2b00         	cmp	r3, #0x0
 800c148: d034         	beq	0x800c1b4 <async_timer_start+0x84> @ imm = #0x68
; 		LOG_DBG("async timer started for %d us", timeout);
 800c14a: 2303         	movs	r3, #0x3
 800c14c: 2b03         	cmp	r3, #0x3
 800c14e: d91a         	bls	0x800c186 <async_timer_start+0x56> @ imm = #0x34
 800c150: 2301         	movs	r3, #0x1
 800c152: 73fb         	strb	r3, [r7, #0xf]
 800c154: 7bfb         	ldrb	r3, [r7, #0xf]
 800c156: f083 0301    	eor	r3, r3, #0x1
 800c15a: b2db         	uxtb	r3, r3
 800c15c: 2b00         	cmp	r3, #0x0
 800c15e: d112         	bne	0x800c186 <async_timer_start+0x56> @ imm = #0x24
 800c160: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800c1c0 <async_timer_start+0x90>
 800c162: 6819         	ldr	r1, [r3]
 800c164: 683b         	ldr	r3, [r7]
 800c166: 9304         	str	r3, [sp, #0x10]
 800c168: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800c1c4 <async_timer_start+0x94>
 800c16a: 9303         	str	r3, [sp, #0xc]
 800c16c: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800c1c8 <async_timer_start+0x98>
 800c16e: 9302         	str	r3, [sp, #0x8]
 800c170: 2308         	movs	r3, #0x8
 800c172: 9301         	str	r3, [sp, #0x4]
 800c174: 2300         	movs	r3, #0x0
 800c176: 9300         	str	r3, [sp]
 800c178: 2300         	movs	r3, #0x0
 800c17a: 2204         	movs	r2, #0x4
 800c17c: 2000         	movs	r0, #0x0
 800c17e: f010 f820    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0x10040
 800c182: 2300         	movs	r3, #0x0
 800c184: 60bb         	str	r3, [r7, #0x8]
; 		k_work_reschedule(work, K_USEC(timeout));
 800c186: 683b         	ldr	r3, [r7]
 800c188: ea23 73e3    	bic.w	r3, r3, r3, asr #31
 800c18c: 17da         	asrs	r2, r3, #0x1f
 800c18e: 461c         	mov	r4, r3
 800c190: 4615         	mov	r5, r2
 800c192: f114 0863    	adds.w	r8, r4, #0x63
 800c196: f145 0900    	adc	r9, r5, #0x0
 800c19a: f04f 0264    	mov.w	r2, #0x64
 800c19e: f04f 0300    	mov.w	r3, #0x0
 800c1a2: 4640         	mov	r0, r8
 800c1a4: 4649         	mov	r1, r9
 800c1a6: f7f4 fc5d    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0xb746
 800c1aa: 4602         	mov	r2, r0
 800c1ac: 460b         	mov	r3, r1
 800c1ae: 6878         	ldr	r0, [r7, #0x4]
 800c1b0: f004 fc02    	bl	0x80109b8 <k_work_reschedule> @ imm = #0x4804
; }
 800c1b4: bf00         	nop
 800c1b6: 3710         	adds	r7, #0x10
 800c1b8: 46bd         	mov	sp, r7
 800c1ba: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}
 800c1be: bf00         	nop

0800c1c0 <$d>:
 800c1c0: 74 05 00 20  	.word	0x20000574
 800c1c4: 90 2c 02 08  	.word	0x08022c90
 800c1c8: 0c 1b 02 08  	.word	0x08021b0c

0800c1cc <uart_stm32_isr>:
; {
 800c1cc: b580         	push	{r7, lr}
 800c1ce: b08c         	sub	sp, #0x30
 800c1d0: af04         	add	r7, sp, #0x10
 800c1d2: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800c1d4: 687b         	ldr	r3, [r7, #0x4]
 800c1d6: 691b         	ldr	r3, [r3, #0x10]
 800c1d8: 61fb         	str	r3, [r7, #0x1c]
; 	const struct uart_stm32_config *config = dev->config;
 800c1da: 687b         	ldr	r3, [r7, #0x4]
 800c1dc: 685b         	ldr	r3, [r3, #0x4]
 800c1de: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 800c1e0: 69bb         	ldr	r3, [r7, #0x18]
 800c1e2: 681b         	ldr	r3, [r3]
 800c1e4: 617b         	str	r3, [r7, #0x14]
; 	if (data->user_cb) {
 800c1e6: 69fb         	ldr	r3, [r7, #0x1c]
 800c1e8: 689b         	ldr	r3, [r3, #0x8]
 800c1ea: 2b00         	cmp	r3, #0x0
 800c1ec: d006         	beq	0x800c1fc <uart_stm32_isr+0x30> @ imm = #0xc
; 		data->user_cb(dev, data->user_data);
 800c1ee: 69fb         	ldr	r3, [r7, #0x1c]
 800c1f0: 689b         	ldr	r3, [r3, #0x8]
 800c1f2: 69fa         	ldr	r2, [r7, #0x1c]
 800c1f4: 68d2         	ldr	r2, [r2, #0xc]
 800c1f6: 4611         	mov	r1, r2
 800c1f8: 6878         	ldr	r0, [r7, #0x4]
 800c1fa: 4798         	blx	r3
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 800c1fc: 6978         	ldr	r0, [r7, #0x14]
 800c1fe: f00f ff16    	bl	0x801c02e <LL_USART_IsEnabledIT_IDLE> @ imm = #0xfe2c
 800c202: 4603         	mov	r3, r0
 800c204: 2b00         	cmp	r3, #0x0
 800c206: d036         	beq	0x800c276 <uart_stm32_isr+0xaa> @ imm = #0x6c
; 			LL_USART_IsActiveFlag_IDLE(usart)) {
 800c208: 6978         	ldr	r0, [r7, #0x14]
 800c20a: f00f fcae    	bl	0x801bb6a <LL_USART_IsActiveFlag_IDLE> @ imm = #0xf95c
 800c20e: 4603         	mov	r3, r0
; 	if (LL_USART_IsEnabledIT_IDLE(usart) &&
 800c210: 2b00         	cmp	r3, #0x0
 800c212: d030         	beq	0x800c276 <uart_stm32_isr+0xaa> @ imm = #0x60
; 		LL_USART_ClearFlag_IDLE(usart);
 800c214: 6978         	ldr	r0, [r7, #0x14]
 800c216: f00f fd50    	bl	0x801bcba <LL_USART_ClearFlag_IDLE> @ imm = #0xfaa0
; 		LOG_DBG("idle interrupt occurred");
 800c21a: 2303         	movs	r3, #0x3
 800c21c: 2b03         	cmp	r3, #0x3
 800c21e: d918         	bls	0x800c252 <uart_stm32_isr+0x86> @ imm = #0x30
 800c220: 2301         	movs	r3, #0x1
 800c222: 74fb         	strb	r3, [r7, #0x13]
 800c224: 7cfb         	ldrb	r3, [r7, #0x13]
 800c226: f083 0301    	eor	r3, r3, #0x1
 800c22a: b2db         	uxtb	r3, r3
 800c22c: 2b00         	cmp	r3, #0x0
 800c22e: d110         	bne	0x800c252 <uart_stm32_isr+0x86> @ imm = #0x20
 800c230: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800c2c8 <uart_stm32_isr+0xfc>
 800c232: 6819         	ldr	r1, [r3]
 800c234: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800c2cc <uart_stm32_isr+0x100>
 800c236: 9303         	str	r3, [sp, #0xc]
 800c238: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800c2d0 <uart_stm32_isr+0x104>
 800c23a: 9302         	str	r3, [sp, #0x8]
 800c23c: 2308         	movs	r3, #0x8
 800c23e: 9301         	str	r3, [sp, #0x4]
 800c240: 2300         	movs	r3, #0x0
 800c242: 9300         	str	r3, [sp]
 800c244: 2300         	movs	r3, #0x0
 800c246: 2204         	movs	r2, #0x4
 800c248: 2000         	movs	r0, #0x0
 800c24a: f00f ffba    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xff74
 800c24e: 2300         	movs	r3, #0x0
 800c250: 60fb         	str	r3, [r7, #0xc]
; 		if (data->dma_rx.timeout == 0) {
 800c252: 69fb         	ldr	r3, [r7, #0x1c]
 800c254: 6fdb         	ldr	r3, [r3, #0x7c]
 800c256: 2b00         	cmp	r3, #0x0
 800c258: d103         	bne	0x800c262 <uart_stm32_isr+0x96> @ imm = #0x6
; 			uart_stm32_dma_rx_flush(dev);
 800c25a: 6878         	ldr	r0, [r7, #0x4]
 800c25c: f010 fca8    	bl	0x801cbb0 <uart_stm32_dma_rx_flush> @ imm = #0x10950
; 		if (data->dma_rx.timeout == 0) {
 800c260: e02b         	b	0x800c2ba <uart_stm32_isr+0xee> @ imm = #0x56
; 			async_timer_start(&data->dma_rx.timeout_work,
 800c262: 69fb         	ldr	r3, [r7, #0x1c]
 800c264: f103 0280    	add.w	r2, r3, #0x80
 800c268: 69fb         	ldr	r3, [r7, #0x1c]
 800c26a: 6fdb         	ldr	r3, [r3, #0x7c]
 800c26c: 4619         	mov	r1, r3
 800c26e: 4610         	mov	r0, r2
 800c270: f7ff ff5e    	bl	0x800c130 <async_timer_start> @ imm = #-0x144
; 		if (data->dma_rx.timeout == 0) {
 800c274: e021         	b	0x800c2ba <uart_stm32_isr+0xee> @ imm = #0x42
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 800c276: 6978         	ldr	r0, [r7, #0x14]
 800c278: f00f feff    	bl	0x801c07a <LL_USART_IsEnabledIT_TC> @ imm = #0xfdfe
 800c27c: 4603         	mov	r3, r0
 800c27e: 2b00         	cmp	r3, #0x0
 800c280: d00c         	beq	0x800c29c <uart_stm32_isr+0xd0> @ imm = #0x18
; 			LL_USART_IsActiveFlag_TC(usart)) {
 800c282: 6978         	ldr	r0, [r7, #0x14]
 800c284: f00f fc97    	bl	0x801bbb6 <LL_USART_IsActiveFlag_TC> @ imm = #0xf92e
 800c288: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_TC(usart) &&
 800c28a: 2b00         	cmp	r3, #0x0
 800c28c: d006         	beq	0x800c29c <uart_stm32_isr+0xd0> @ imm = #0xc
; 		LL_USART_DisableIT_TC(usart);
 800c28e: 6978         	ldr	r0, [r7, #0x14]
 800c290: f00f fe54    	bl	0x801bf3c <LL_USART_DisableIT_TC> @ imm = #0xfca8
; 		async_evt_tx_done(data);
 800c294: 69f8         	ldr	r0, [r7, #0x1c]
 800c296: f7ff fead    	bl	0x800bff4 <async_evt_tx_done> @ imm = #-0x2a6
 800c29a: e00e         	b	0x800c2ba <uart_stm32_isr+0xee> @ imm = #0x1c
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 800c29c: 6978         	ldr	r0, [r7, #0x14]
 800c29e: f00f fed9    	bl	0x801c054 <LL_USART_IsEnabledIT_RXNE> @ imm = #0xfdb2
 800c2a2: 4603         	mov	r3, r0
 800c2a4: 2b00         	cmp	r3, #0x0
 800c2a6: d008         	beq	0x800c2ba <uart_stm32_isr+0xee> @ imm = #0x10
; 			LL_USART_IsActiveFlag_RXNE(usart)) {
 800c2a8: 6978         	ldr	r0, [r7, #0x14]
 800c2aa: f00f fc71    	bl	0x801bb90 <LL_USART_IsActiveFlag_RXNE> @ imm = #0xf8e2
 800c2ae: 4603         	mov	r3, r0
; 	} else if (LL_USART_IsEnabledIT_RXNE(usart) &&
 800c2b0: 2b00         	cmp	r3, #0x0
 800c2b2: d002         	beq	0x800c2ba <uart_stm32_isr+0xee> @ imm = #0x4
; 		LL_USART_ClearFlag_RXNE(usart);
 800c2b4: 6978         	ldr	r0, [r7, #0x14]
 800c2b6: f00f fd20    	bl	0x801bcfa <LL_USART_ClearFlag_RXNE> @ imm = #0xfa40
; 	uart_stm32_err_check(dev);
 800c2ba: 6878         	ldr	r0, [r7, #0x4]
 800c2bc: f010 fa51    	bl	0x801c762 <uart_stm32_err_check> @ imm = #0x104a2
; }
 800c2c0: bf00         	nop
 800c2c2: 3720         	adds	r7, #0x20
 800c2c4: 46bd         	mov	sp, r7
 800c2c6: bd80         	pop	{r7, pc}

0800c2c8 <$d>:
 800c2c8: 74 05 00 20  	.word	0x20000574
 800c2cc: 80 2c 02 08  	.word	0x08022c80
 800c2d0: 30 1b 02 08  	.word	0x08021b30

0800c2d4 <uart_stm32_async_rx_disable>:
; {
 800c2d4: b580         	push	{r7, lr}
 800c2d6: b096         	sub	sp, #0x58
 800c2d8: af04         	add	r7, sp, #0x10
 800c2da: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800c2dc: 687b         	ldr	r3, [r7, #0x4]
 800c2de: 685b         	ldr	r3, [r3, #0x4]
 800c2e0: 647b         	str	r3, [r7, #0x44]
; 	USART_TypeDef *usart = config->usart;
 800c2e2: 6c7b         	ldr	r3, [r7, #0x44]
 800c2e4: 681b         	ldr	r3, [r3]
 800c2e6: 643b         	str	r3, [r7, #0x40]
; 	struct uart_stm32_data *data = dev->data;
 800c2e8: 687b         	ldr	r3, [r7, #0x4]
 800c2ea: 691b         	ldr	r3, [r3, #0x10]
 800c2ec: 63fb         	str	r3, [r7, #0x3c]
; 	struct uart_event disabled_event = {
 800c2ee: f107 0320    	add.w	r3, r7, #0x20
 800c2f2: 2200         	movs	r2, #0x0
 800c2f4: 601a         	str	r2, [r3]
 800c2f6: 605a         	str	r2, [r3, #0x4]
 800c2f8: 609a         	str	r2, [r3, #0x8]
 800c2fa: 60da         	str	r2, [r3, #0xc]
 800c2fc: 611a         	str	r2, [r3, #0x10]
 800c2fe: 2305         	movs	r3, #0x5
 800c300: f887 3020    	strb.w	r3, [r7, #0x20]
; 	if (!data->dma_rx.enabled) {
 800c304: 6bfb         	ldr	r3, [r7, #0x3c]
 800c306: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800c30a: f083 0301    	eor	r3, r3, #0x1
 800c30e: b2db         	uxtb	r3, r3
 800c310: 2b00         	cmp	r3, #0x0
 800c312: d008         	beq	0x800c326 <uart_stm32_async_rx_disable+0x52> @ imm = #0x10
; 		async_user_callback(data, &disabled_event);
 800c314: f107 0320    	add.w	r3, r7, #0x20
 800c318: 4619         	mov	r1, r3
 800c31a: 6bf8         	ldr	r0, [r7, #0x3c]
 800c31c: f010 fc00    	bl	0x801cb20 <async_user_callback> @ imm = #0x10800
; 		return -EFAULT;
 800c320: f06f 030d    	mvn	r3, #0xd
 800c324: e061         	b	0x800c3ea <uart_stm32_async_rx_disable+0x116> @ imm = #0xc2
; 	LL_USART_DisableIT_IDLE(usart);
 800c326: 6c38         	ldr	r0, [r7, #0x40]
 800c328: f00f fdc2    	bl	0x801beb0 <LL_USART_DisableIT_IDLE> @ imm = #0xfb84
; 	uart_stm32_dma_rx_flush(dev);
 800c32c: 6878         	ldr	r0, [r7, #0x4]
 800c32e: f010 fc3f    	bl	0x801cbb0 <uart_stm32_dma_rx_flush> @ imm = #0x1087e
; 	async_evt_rx_buf_release(data);
 800c332: 6bf8         	ldr	r0, [r7, #0x3c]
 800c334: f010 fc21    	bl	0x801cb7a <async_evt_rx_buf_release> @ imm = #0x10842
; 	uart_stm32_dma_rx_disable(dev);
 800c338: 6878         	ldr	r0, [r7, #0x4]
 800c33a: f010 fcb3    	bl	0x801cca4 <uart_stm32_dma_rx_disable> @ imm = #0x10966
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 800c33e: 6bfb         	ldr	r3, [r7, #0x3c]
 800c340: 3380         	adds	r3, #0x80
 800c342: 4618         	mov	r0, r3
 800c344: f004 fb4c    	bl	0x80109e0 <k_work_cancel_delayable> @ imm = #0x4698
; 	dma_stop(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 800c348: 6bfb         	ldr	r3, [r7, #0x3c]
 800c34a: 6a1a         	ldr	r2, [r3, #0x20]
 800c34c: 6bfb         	ldr	r3, [r7, #0x3c]
 800c34e: 6a5b         	ldr	r3, [r3, #0x24]
 800c350: 4619         	mov	r1, r3
 800c352: 4610         	mov	r0, r2
 800c354: f00f fa3a    	bl	0x801b7cc <dma_stop>    @ imm = #0xf474
; 	if (data->rx_next_buffer) {
 800c358: 6bfb         	ldr	r3, [r7, #0x3c]
 800c35a: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 800c35e: 2b00         	cmp	r3, #0x0
 800c360: d013         	beq	0x800c38a <uart_stm32_async_rx_disable+0xb6> @ imm = #0x26
; 		struct uart_event rx_next_buf_release_evt = {
 800c362: f107 030c    	add.w	r3, r7, #0xc
 800c366: 2200         	movs	r2, #0x0
 800c368: 601a         	str	r2, [r3]
 800c36a: 605a         	str	r2, [r3, #0x4]
 800c36c: 609a         	str	r2, [r3, #0x8]
 800c36e: 60da         	str	r2, [r3, #0xc]
 800c370: 611a         	str	r2, [r3, #0x10]
 800c372: 2304         	movs	r3, #0x4
 800c374: 733b         	strb	r3, [r7, #0xc]
; 			.data.rx_buf.buf = data->rx_next_buffer,
 800c376: 6bfb         	ldr	r3, [r7, #0x3c]
 800c378: f8d3 3150    	ldr.w	r3, [r3, #0x150]
; 		struct uart_event rx_next_buf_release_evt = {
 800c37c: 613b         	str	r3, [r7, #0x10]
; 		async_user_callback(data, &rx_next_buf_release_evt);
 800c37e: f107 030c    	add.w	r3, r7, #0xc
 800c382: 4619         	mov	r1, r3
 800c384: 6bf8         	ldr	r0, [r7, #0x3c]
 800c386: f010 fbcb    	bl	0x801cb20 <async_user_callback> @ imm = #0x10796
; 	data->rx_next_buffer = NULL;
 800c38a: 6bfb         	ldr	r3, [r7, #0x3c]
 800c38c: 2200         	movs	r2, #0x0
 800c38e: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800c392: 6bfb         	ldr	r3, [r7, #0x3c]
 800c394: 2200         	movs	r2, #0x0
 800c396: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	LL_USART_EnableIT_RXNE(usart);
 800c39a: 6c38         	ldr	r0, [r7, #0x40]
 800c39c: f00f fcec    	bl	0x801bd78 <LL_USART_EnableIT_RXNE> @ imm = #0xf9d8
; 	LOG_DBG("rx: disabled");
 800c3a0: 2303         	movs	r3, #0x3
 800c3a2: 2b03         	cmp	r3, #0x3
 800c3a4: d91a         	bls	0x800c3dc <uart_stm32_async_rx_disable+0x108> @ imm = #0x34
 800c3a6: 2301         	movs	r3, #0x1
 800c3a8: f887 303b    	strb.w	r3, [r7, #0x3b]
 800c3ac: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800c3b0: f083 0301    	eor	r3, r3, #0x1
 800c3b4: b2db         	uxtb	r3, r3
 800c3b6: 2b00         	cmp	r3, #0x0
 800c3b8: d110         	bne	0x800c3dc <uart_stm32_async_rx_disable+0x108> @ imm = #0x20
 800c3ba: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800c3f4 <uart_stm32_async_rx_disable+0x120>
 800c3bc: 6819         	ldr	r1, [r3]
 800c3be: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800c3f8 <uart_stm32_async_rx_disable+0x124>
 800c3c0: 9303         	str	r3, [sp, #0xc]
 800c3c2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800c3fc <uart_stm32_async_rx_disable+0x128>
 800c3c4: 9302         	str	r3, [sp, #0x8]
 800c3c6: 2308         	movs	r3, #0x8
 800c3c8: 9301         	str	r3, [sp, #0x4]
 800c3ca: 2300         	movs	r3, #0x0
 800c3cc: 9300         	str	r3, [sp]
 800c3ce: 2300         	movs	r3, #0x0
 800c3d0: 2204         	movs	r2, #0x4
 800c3d2: 2000         	movs	r0, #0x0
 800c3d4: f00f fef5    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xfdea
 800c3d8: 2300         	movs	r3, #0x0
 800c3da: 637b         	str	r3, [r7, #0x34]
; 	async_user_callback(data, &disabled_event);
 800c3dc: f107 0320    	add.w	r3, r7, #0x20
 800c3e0: 4619         	mov	r1, r3
 800c3e2: 6bf8         	ldr	r0, [r7, #0x3c]
 800c3e4: f010 fb9c    	bl	0x801cb20 <async_user_callback> @ imm = #0x10738
; 	return 0;
 800c3e8: 2300         	movs	r3, #0x0
; }
 800c3ea: 4618         	mov	r0, r3
 800c3ec: 3748         	adds	r7, #0x48
 800c3ee: 46bd         	mov	sp, r7
 800c3f0: bd80         	pop	{r7, pc}
 800c3f2: bf00         	nop

0800c3f4 <$d>:
 800c3f4: 74 05 00 20  	.word	0x20000574
 800c3f8: b8 2c 02 08  	.word	0x08022cb8
 800c3fc: 4c 1b 02 08  	.word	0x08021b4c

0800c400 <uart_stm32_dma_replace_buffer>:
; {
 800c400: b590         	push	{r4, r7, lr}
 800c402: b08f         	sub	sp, #0x3c
 800c404: af06         	add	r7, sp, #0x18
 800c406: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800c408: 687b         	ldr	r3, [r7, #0x4]
 800c40a: 685b         	ldr	r3, [r3, #0x4]
 800c40c: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 800c40e: 69fb         	ldr	r3, [r7, #0x1c]
 800c410: 681b         	ldr	r3, [r3]
 800c412: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 800c414: 687b         	ldr	r3, [r7, #0x4]
 800c416: 691b         	ldr	r3, [r3, #0x10]
 800c418: 617b         	str	r3, [r7, #0x14]
; 	LOG_DBG("Replacing RX buffer: %d", data->rx_next_buffer_len);
 800c41a: 2303         	movs	r3, #0x3
 800c41c: 2b03         	cmp	r3, #0x3
 800c41e: d91c         	bls	0x800c45a <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x38
 800c420: 2301         	movs	r3, #0x1
 800c422: 74fb         	strb	r3, [r7, #0x13]
 800c424: 7cfb         	ldrb	r3, [r7, #0x13]
 800c426: f083 0301    	eor	r3, r3, #0x1
 800c42a: b2db         	uxtb	r3, r3
 800c42c: 2b00         	cmp	r3, #0x0
 800c42e: d114         	bne	0x800c45a <uart_stm32_dma_replace_buffer+0x5a> @ imm = #0x28
 800c430: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800c4dc <uart_stm32_dma_replace_buffer+0xdc>
 800c432: 6819         	ldr	r1, [r3]
 800c434: 697b         	ldr	r3, [r7, #0x14]
 800c436: f8d3 3154    	ldr.w	r3, [r3, #0x154]
 800c43a: 9304         	str	r3, [sp, #0x10]
 800c43c: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800c4e0 <uart_stm32_dma_replace_buffer+0xe0>
 800c43e: 9303         	str	r3, [sp, #0xc]
 800c440: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800c4e4 <uart_stm32_dma_replace_buffer+0xe4>
 800c442: 9302         	str	r3, [sp, #0x8]
 800c444: 2308         	movs	r3, #0x8
 800c446: 9301         	str	r3, [sp, #0x4]
 800c448: 2300         	movs	r3, #0x0
 800c44a: 9300         	str	r3, [sp]
 800c44c: 2300         	movs	r3, #0x0
 800c44e: 2204         	movs	r2, #0x4
 800c450: 2000         	movs	r0, #0x0
 800c452: f00f feb6    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xfd6c
 800c456: 2300         	movs	r3, #0x0
 800c458: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.offset = 0;
 800c45a: 697b         	ldr	r3, [r7, #0x14]
 800c45c: 2200         	movs	r2, #0x0
 800c45e: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.counter = 0;
 800c460: 697b         	ldr	r3, [r7, #0x14]
 800c462: 2200         	movs	r2, #0x0
 800c464: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.buffer = data->rx_next_buffer;
 800c466: 697b         	ldr	r3, [r7, #0x14]
 800c468: f8d3 2150    	ldr.w	r2, [r3, #0x150]
 800c46c: 697b         	ldr	r3, [r7, #0x14]
 800c46e: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = data->rx_next_buffer_len;
 800c470: 697b         	ldr	r3, [r7, #0x14]
 800c472: f8d3 2154    	ldr.w	r2, [r3, #0x154]
 800c476: 697b         	ldr	r3, [r7, #0x14]
 800c478: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.blk_cfg.block_size = data->dma_rx.buffer_length;
 800c47a: 697b         	ldr	r3, [r7, #0x14]
 800c47c: 6f1a         	ldr	r2, [r3, #0x70]
 800c47e: 697b         	ldr	r3, [r7, #0x14]
 800c480: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 800c482: 697b         	ldr	r3, [r7, #0x14]
 800c484: 6edb         	ldr	r3, [r3, #0x6c]
 800c486: 461a         	mov	r2, r3
 800c488: 697b         	ldr	r3, [r7, #0x14]
 800c48a: 651a         	str	r2, [r3, #0x50]
; 	data->rx_next_buffer = NULL;
 800c48c: 697b         	ldr	r3, [r7, #0x14]
 800c48e: 2200         	movs	r2, #0x0
 800c490: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800c494: 697b         	ldr	r3, [r7, #0x14]
 800c496: 2200         	movs	r2, #0x0
 800c498: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	dma_reload(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 800c49c: 697b         	ldr	r3, [r7, #0x14]
 800c49e: 6a18         	ldr	r0, [r3, #0x20]
 800c4a0: 697b         	ldr	r3, [r7, #0x14]
 800c4a2: 6a59         	ldr	r1, [r3, #0x24]
 800c4a4: 697b         	ldr	r3, [r7, #0x14]
 800c4a6: 6cda         	ldr	r2, [r3, #0x4c]
 800c4a8: 697b         	ldr	r3, [r7, #0x14]
 800c4aa: 6d1c         	ldr	r4, [r3, #0x50]
 800c4ac: 697b         	ldr	r3, [r7, #0x14]
 800c4ae: 6e1b         	ldr	r3, [r3, #0x60]
 800c4b0: 9300         	str	r3, [sp]
 800c4b2: 4623         	mov	r3, r4
 800c4b4: f00f f91e    	bl	0x801b6f4 <dma_reload>  @ imm = #0xf23c
; 	dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel);
 800c4b8: 697b         	ldr	r3, [r7, #0x14]
 800c4ba: 6a1a         	ldr	r2, [r3, #0x20]
 800c4bc: 697b         	ldr	r3, [r7, #0x14]
 800c4be: 6a5b         	ldr	r3, [r3, #0x24]
 800c4c0: 4619         	mov	r1, r3
 800c4c2: 4610         	mov	r0, r2
 800c4c4: f00f f974    	bl	0x801b7b0 <dma_start>   @ imm = #0xf2e8
; 	LL_USART_ClearFlag_IDLE(usart);
 800c4c8: 69b8         	ldr	r0, [r7, #0x18]
 800c4ca: f00f fbf6    	bl	0x801bcba <LL_USART_ClearFlag_IDLE> @ imm = #0xf7ec
; 	async_evt_rx_buf_request(data);
 800c4ce: 6978         	ldr	r0, [r7, #0x14]
 800c4d0: f010 fb3b    	bl	0x801cb4a <async_evt_rx_buf_request> @ imm = #0x10676
; }
 800c4d4: bf00         	nop
 800c4d6: 3724         	adds	r7, #0x24
 800c4d8: 46bd         	mov	sp, r7
 800c4da: bd90         	pop	{r4, r7, pc}

0800c4dc <$d>:
 800c4dc: 74 05 00 20  	.word	0x20000574
 800c4e0: d4 2c 02 08  	.word	0x08022cd4
 800c4e4: 60 1b 02 08  	.word	0x08021b60

0800c4e8 <uart_stm32_async_tx>:
; {
 800c4e8: b580         	push	{r7, lr}
 800c4ea: b094         	sub	sp, #0x50
 800c4ec: af06         	add	r7, sp, #0x18
 800c4ee: 60f8         	str	r0, [r7, #0xc]
 800c4f0: 60b9         	str	r1, [r7, #0x8]
 800c4f2: 607a         	str	r2, [r7, #0x4]
 800c4f4: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800c4f6: 68fb         	ldr	r3, [r7, #0xc]
 800c4f8: 685b         	ldr	r3, [r3, #0x4]
 800c4fa: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 800c4fc: 6b7b         	ldr	r3, [r7, #0x34]
 800c4fe: 681b         	ldr	r3, [r3]
 800c500: 633b         	str	r3, [r7, #0x30]
; 	struct uart_stm32_data *data = dev->data;
 800c502: 68fb         	ldr	r3, [r7, #0xc]
 800c504: 691b         	ldr	r3, [r3, #0x10]
 800c506: 62fb         	str	r3, [r7, #0x2c]
; 	if (data->dma_tx.dma_dev == NULL) {
 800c508: 6afb         	ldr	r3, [r7, #0x2c]
 800c50a: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800c50e: 2b00         	cmp	r3, #0x0
 800c510: d102         	bne	0x800c518 <uart_stm32_async_tx+0x30> @ imm = #0x4
; 		return -ENODEV;
 800c512: f06f 0312    	mvn	r3, #0x12
 800c516: e0ac         	b	0x800c672 <uart_stm32_async_tx+0x18a> @ imm = #0x158
; 	if (data->dma_tx.buffer_length != 0) {
 800c518: 6afb         	ldr	r3, [r7, #0x2c]
 800c51a: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 800c51e: 2b00         	cmp	r3, #0x0
 800c520: d002         	beq	0x800c528 <uart_stm32_async_tx+0x40> @ imm = #0x4
; 		return -EBUSY;
 800c522: f06f 030f    	mvn	r3, #0xf
 800c526: e0a4         	b	0x800c672 <uart_stm32_async_tx+0x18a> @ imm = #0x148
; 	data->dma_tx.buffer = (uint8_t *)tx_data;
 800c528: 6afb         	ldr	r3, [r7, #0x2c]
 800c52a: 68ba         	ldr	r2, [r7, #0x8]
 800c52c: f8c3 2104    	str.w	r2, [r3, #0x104]
; 	data->dma_tx.buffer_length = buf_size;
 800c530: 6afb         	ldr	r3, [r7, #0x2c]
 800c532: 687a         	ldr	r2, [r7, #0x4]
 800c534: f8c3 2108    	str.w	r2, [r3, #0x108]
; 	data->dma_tx.timeout = timeout;
 800c538: 6afb         	ldr	r3, [r7, #0x2c]
 800c53a: 683a         	ldr	r2, [r7]
 800c53c: f8c3 2114    	str.w	r2, [r3, #0x114]
; 	LOG_DBG("tx: l=%d", data->dma_tx.buffer_length);
 800c540: 2303         	movs	r3, #0x3
 800c542: 2b03         	cmp	r3, #0x3
 800c544: d91e         	bls	0x800c584 <uart_stm32_async_tx+0x9c> @ imm = #0x3c
 800c546: 2301         	movs	r3, #0x1
 800c548: f887 302b    	strb.w	r3, [r7, #0x2b]
 800c54c: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800c550: f083 0301    	eor	r3, r3, #0x1
 800c554: b2db         	uxtb	r3, r3
 800c556: 2b00         	cmp	r3, #0x0
 800c558: d114         	bne	0x800c584 <uart_stm32_async_tx+0x9c> @ imm = #0x28
 800c55a: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800c67c <uart_stm32_async_tx+0x194>
 800c55c: 6819         	ldr	r1, [r3]
 800c55e: 6afb         	ldr	r3, [r7, #0x2c]
 800c560: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 800c564: 9304         	str	r3, [sp, #0x10]
 800c566: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800c680 <uart_stm32_async_tx+0x198>
 800c568: 9303         	str	r3, [sp, #0xc]
 800c56a: 4b46         	ldr	r3, [pc, #0x118]        @ 0x800c684 <uart_stm32_async_tx+0x19c>
 800c56c: 9302         	str	r3, [sp, #0x8]
 800c56e: 2308         	movs	r3, #0x8
 800c570: 9301         	str	r3, [sp, #0x4]
 800c572: 2300         	movs	r3, #0x0
 800c574: 9300         	str	r3, [sp]
 800c576: 2300         	movs	r3, #0x0
 800c578: 2204         	movs	r2, #0x4
 800c57a: 2000         	movs	r0, #0x0
 800c57c: f00f fe21    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xfc42
 800c580: 2300         	movs	r3, #0x0
 800c582: 627b         	str	r3, [r7, #0x24]
; 	LL_USART_ClearFlag_TC(usart);
 800c584: 6b38         	ldr	r0, [r7, #0x30]
 800c586: f00f fbaa    	bl	0x801bcde <LL_USART_ClearFlag_TC> @ imm = #0xf754
; 	LL_USART_EnableIT_TC(usart);
 800c58a: 6b38         	ldr	r0, [r7, #0x30]
 800c58c: f00f fc17    	bl	0x801bdbe <LL_USART_EnableIT_TC> @ imm = #0xf82e
; 	data->dma_tx.blk_cfg.source_address = (uint32_t)data->dma_tx.buffer;
 800c590: 6afb         	ldr	r3, [r7, #0x2c]
 800c592: f8d3 3104    	ldr.w	r3, [r3, #0x104]
 800c596: 461a         	mov	r2, r3
 800c598: 6afb         	ldr	r3, [r7, #0x2c]
 800c59a: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	data->dma_tx.blk_cfg.block_size = data->dma_tx.buffer_length;
 800c59e: 6afb         	ldr	r3, [r7, #0x2c]
 800c5a0: f8d3 2108    	ldr.w	r2, [r3, #0x108]
 800c5a4: 6afb         	ldr	r3, [r7, #0x2c]
 800c5a6: f8c3 20f8    	str.w	r2, [r3, #0xf8]
; 	ret = dma_config(data->dma_tx.dma_dev, data->dma_tx.dma_channel,
 800c5aa: 6afb         	ldr	r3, [r7, #0x2c]
 800c5ac: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 800c5b0: 6afb         	ldr	r3, [r7, #0x2c]
 800c5b2: f8d3 10bc    	ldr.w	r1, [r3, #0xbc]
 800c5b6: 6afb         	ldr	r3, [r7, #0x2c]
 800c5b8: 33c0         	adds	r3, #0xc0
 800c5ba: 461a         	mov	r2, r3
 800c5bc: f00f f886    	bl	0x801b6cc <dma_config>  @ imm = #0xf10c
 800c5c0: 6238         	str	r0, [r7, #0x20]
; 	if (ret != 0) {
 800c5c2: 6a3b         	ldr	r3, [r7, #0x20]
 800c5c4: 2b00         	cmp	r3, #0x0
 800c5c6: d01c         	beq	0x800c602 <uart_stm32_async_tx+0x11a> @ imm = #0x38
; 		LOG_ERR("dma tx config error!");
 800c5c8: 2303         	movs	r3, #0x3
 800c5ca: 2b00         	cmp	r3, #0x0
 800c5cc: d016         	beq	0x800c5fc <uart_stm32_async_tx+0x114> @ imm = #0x2c
 800c5ce: 2301         	movs	r3, #0x1
 800c5d0: 75fb         	strb	r3, [r7, #0x17]
 800c5d2: 7dfb         	ldrb	r3, [r7, #0x17]
 800c5d4: f083 0301    	eor	r3, r3, #0x1
 800c5d8: b2db         	uxtb	r3, r3
 800c5da: 2b00         	cmp	r3, #0x0
 800c5dc: d10e         	bne	0x800c5fc <uart_stm32_async_tx+0x114> @ imm = #0x1c
 800c5de: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800c67c <uart_stm32_async_tx+0x194>
 800c5e0: 6819         	ldr	r1, [r3]
 800c5e2: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800c688 <uart_stm32_async_tx+0x1a0>
 800c5e4: 9302         	str	r3, [sp, #0x8]
 800c5e6: 2300         	movs	r3, #0x0
 800c5e8: 9301         	str	r3, [sp, #0x4]
 800c5ea: 2300         	movs	r3, #0x0
 800c5ec: 9300         	str	r3, [sp]
 800c5ee: 2300         	movs	r3, #0x0
 800c5f0: 2201         	movs	r2, #0x1
 800c5f2: 2000         	movs	r0, #0x0
 800c5f4: f00f fde5    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xfbca
 800c5f8: 2300         	movs	r3, #0x0
 800c5fa: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 800c5fc: f06f 0315    	mvn	r3, #0x15
 800c600: e037         	b	0x800c672 <uart_stm32_async_tx+0x18a> @ imm = #0x6e
; 	if (dma_start(data->dma_tx.dma_dev, data->dma_tx.dma_channel)) {
 800c602: 6afb         	ldr	r3, [r7, #0x2c]
 800c604: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 800c608: 6afb         	ldr	r3, [r7, #0x2c]
 800c60a: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 800c60e: 4619         	mov	r1, r3
 800c610: 4610         	mov	r0, r2
 800c612: f00f f8cd    	bl	0x801b7b0 <dma_start>   @ imm = #0xf19a
 800c616: 4603         	mov	r3, r0
 800c618: 2b00         	cmp	r3, #0x0
 800c61a: d01c         	beq	0x800c656 <uart_stm32_async_tx+0x16e> @ imm = #0x38
; 		LOG_ERR("UART err: TX DMA start failed!");
 800c61c: 2303         	movs	r3, #0x3
 800c61e: 2b00         	cmp	r3, #0x0
 800c620: d016         	beq	0x800c650 <uart_stm32_async_tx+0x168> @ imm = #0x2c
 800c622: 2301         	movs	r3, #0x1
 800c624: 77fb         	strb	r3, [r7, #0x1f]
 800c626: 7ffb         	ldrb	r3, [r7, #0x1f]
 800c628: f083 0301    	eor	r3, r3, #0x1
 800c62c: b2db         	uxtb	r3, r3
 800c62e: 2b00         	cmp	r3, #0x0
 800c630: d10e         	bne	0x800c650 <uart_stm32_async_tx+0x168> @ imm = #0x1c
 800c632: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800c67c <uart_stm32_async_tx+0x194>
 800c634: 6819         	ldr	r1, [r3]
 800c636: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800c68c <uart_stm32_async_tx+0x1a4>
 800c638: 9302         	str	r3, [sp, #0x8]
 800c63a: 2300         	movs	r3, #0x0
 800c63c: 9301         	str	r3, [sp, #0x4]
 800c63e: 2300         	movs	r3, #0x0
 800c640: 9300         	str	r3, [sp]
 800c642: 2300         	movs	r3, #0x0
 800c644: 2201         	movs	r2, #0x1
 800c646: 2000         	movs	r0, #0x0
 800c648: f00f fdbb    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xfb76
 800c64c: 2300         	movs	r3, #0x0
 800c64e: 61bb         	str	r3, [r7, #0x18]
; 		return -EFAULT;
 800c650: f06f 030d    	mvn	r3, #0xd
 800c654: e00d         	b	0x800c672 <uart_stm32_async_tx+0x18a> @ imm = #0x1a
; 	async_timer_start(&data->dma_tx.timeout_work, data->dma_tx.timeout);
 800c656: 6afb         	ldr	r3, [r7, #0x2c]
 800c658: f503 728c    	add.w	r2, r3, #0x118
 800c65c: 6afb         	ldr	r3, [r7, #0x2c]
 800c65e: f8d3 3114    	ldr.w	r3, [r3, #0x114]
 800c662: 4619         	mov	r1, r3
 800c664: 4610         	mov	r0, r2
 800c666: f7ff fd63    	bl	0x800c130 <async_timer_start> @ imm = #-0x53a
; 	uart_stm32_dma_tx_enable(dev);
 800c66a: 68f8         	ldr	r0, [r7, #0xc]
 800c66c: f010 fae3    	bl	0x801cc36 <uart_stm32_dma_tx_enable> @ imm = #0x105c6
; 	return 0;
 800c670: 2300         	movs	r3, #0x0
; }
 800c672: 4618         	mov	r0, r3
 800c674: 3738         	adds	r7, #0x38
 800c676: 46bd         	mov	sp, r7
 800c678: bd80         	pop	{r7, pc}
 800c67a: bf00         	nop

0800c67c <$d>:
 800c67c: 74 05 00 20  	.word	0x20000574
 800c680: 08 2d 02 08  	.word	0x08022d08
 800c684: 7c 1b 02 08  	.word	0x08021b7c
 800c688: 8c 1b 02 08  	.word	0x08021b8c
 800c68c: a4 1b 02 08  	.word	0x08021ba4

0800c690 <uart_stm32_async_rx_enable>:
; {
 800c690: b580         	push	{r7, lr}
 800c692: b094         	sub	sp, #0x50
 800c694: af04         	add	r7, sp, #0x10
 800c696: 60f8         	str	r0, [r7, #0xc]
 800c698: 60b9         	str	r1, [r7, #0x8]
 800c69a: 607a         	str	r2, [r7, #0x4]
 800c69c: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800c69e: 68fb         	ldr	r3, [r7, #0xc]
 800c6a0: 685b         	ldr	r3, [r3, #0x4]
 800c6a2: 63fb         	str	r3, [r7, #0x3c]
; 	USART_TypeDef *usart = config->usart;
 800c6a4: 6bfb         	ldr	r3, [r7, #0x3c]
 800c6a6: 681b         	ldr	r3, [r3]
 800c6a8: 63bb         	str	r3, [r7, #0x38]
; 	struct uart_stm32_data *data = dev->data;
 800c6aa: 68fb         	ldr	r3, [r7, #0xc]
 800c6ac: 691b         	ldr	r3, [r3, #0x10]
 800c6ae: 637b         	str	r3, [r7, #0x34]
; 	if (data->dma_rx.dma_dev == NULL) {
 800c6b0: 6b7b         	ldr	r3, [r7, #0x34]
 800c6b2: 6a1b         	ldr	r3, [r3, #0x20]
 800c6b4: 2b00         	cmp	r3, #0x0
 800c6b6: d102         	bne	0x800c6be <uart_stm32_async_rx_enable+0x2e> @ imm = #0x4
; 		return -ENODEV;
 800c6b8: f06f 0312    	mvn	r3, #0x12
 800c6bc: e0c0         	b	0x800c840 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x180
; 	if (data->dma_rx.enabled) {
 800c6be: 6b7b         	ldr	r3, [r7, #0x34]
 800c6c0: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800c6c4: 2b00         	cmp	r3, #0x0
 800c6c6: d01c         	beq	0x800c702 <uart_stm32_async_rx_enable+0x72> @ imm = #0x38
; 		LOG_WRN("RX was already enabled");
 800c6c8: 2303         	movs	r3, #0x3
 800c6ca: 2b01         	cmp	r3, #0x1
 800c6cc: d916         	bls	0x800c6fc <uart_stm32_async_rx_enable+0x6c> @ imm = #0x2c
 800c6ce: 2301         	movs	r3, #0x1
 800c6d0: 75fb         	strb	r3, [r7, #0x17]
 800c6d2: 7dfb         	ldrb	r3, [r7, #0x17]
 800c6d4: f083 0301    	eor	r3, r3, #0x1
 800c6d8: b2db         	uxtb	r3, r3
 800c6da: 2b00         	cmp	r3, #0x0
 800c6dc: d10e         	bne	0x800c6fc <uart_stm32_async_rx_enable+0x6c> @ imm = #0x1c
 800c6de: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800c848 <uart_stm32_async_rx_enable+0x1b8>
 800c6e0: 6819         	ldr	r1, [r3]
 800c6e2: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x800c84c <uart_stm32_async_rx_enable+0x1bc>
 800c6e4: 9302         	str	r3, [sp, #0x8]
 800c6e6: 2300         	movs	r3, #0x0
 800c6e8: 9301         	str	r3, [sp, #0x4]
 800c6ea: 2300         	movs	r3, #0x0
 800c6ec: 9300         	str	r3, [sp]
 800c6ee: 2300         	movs	r3, #0x0
 800c6f0: 2202         	movs	r2, #0x2
 800c6f2: 2000         	movs	r0, #0x0
 800c6f4: f00f fd65    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xfaca
 800c6f8: 2300         	movs	r3, #0x0
 800c6fa: 613b         	str	r3, [r7, #0x10]
; 		return -EBUSY;
 800c6fc: f06f 030f    	mvn	r3, #0xf
 800c700: e09e         	b	0x800c840 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x13c
; 	data->dma_rx.offset = 0;
 800c702: 6b7b         	ldr	r3, [r7, #0x34]
 800c704: 2200         	movs	r2, #0x0
 800c706: 675a         	str	r2, [r3, #0x74]
; 	data->dma_rx.buffer = rx_buf;
 800c708: 6b7b         	ldr	r3, [r7, #0x34]
 800c70a: 68ba         	ldr	r2, [r7, #0x8]
 800c70c: 66da         	str	r2, [r3, #0x6c]
; 	data->dma_rx.buffer_length = buf_size;
 800c70e: 6b7b         	ldr	r3, [r7, #0x34]
 800c710: 687a         	ldr	r2, [r7, #0x4]
 800c712: 671a         	str	r2, [r3, #0x70]
; 	data->dma_rx.counter = 0;
 800c714: 6b7b         	ldr	r3, [r7, #0x34]
 800c716: 2200         	movs	r2, #0x0
 800c718: 679a         	str	r2, [r3, #0x78]
; 	data->dma_rx.timeout = timeout;
 800c71a: 6b7b         	ldr	r3, [r7, #0x34]
 800c71c: 683a         	ldr	r2, [r7]
 800c71e: 67da         	str	r2, [r3, #0x7c]
; 	LL_USART_DisableIT_RXNE(usart);
 800c720: 6bb8         	ldr	r0, [r7, #0x38]
 800c722: f00f fbe8    	bl	0x801bef6 <LL_USART_DisableIT_RXNE> @ imm = #0xf7d0
; 	data->dma_rx.blk_cfg.block_size = buf_size;
 800c726: 6b7b         	ldr	r3, [r7, #0x34]
 800c728: 687a         	ldr	r2, [r7, #0x4]
 800c72a: 661a         	str	r2, [r3, #0x60]
; 	data->dma_rx.blk_cfg.dest_address = (uint32_t)data->dma_rx.buffer;
 800c72c: 6b7b         	ldr	r3, [r7, #0x34]
 800c72e: 6edb         	ldr	r3, [r3, #0x6c]
 800c730: 461a         	mov	r2, r3
 800c732: 6b7b         	ldr	r3, [r7, #0x34]
 800c734: 651a         	str	r2, [r3, #0x50]
; 	ret = dma_config(data->dma_rx.dma_dev, data->dma_rx.dma_channel,
 800c736: 6b7b         	ldr	r3, [r7, #0x34]
 800c738: 6a18         	ldr	r0, [r3, #0x20]
 800c73a: 6b7b         	ldr	r3, [r7, #0x34]
 800c73c: 6a59         	ldr	r1, [r3, #0x24]
 800c73e: 6b7b         	ldr	r3, [r7, #0x34]
 800c740: 3328         	adds	r3, #0x28
 800c742: 461a         	mov	r2, r3
 800c744: f00e ffc2    	bl	0x801b6cc <dma_config>  @ imm = #0xef84
 800c748: 6338         	str	r0, [r7, #0x30]
; 	if (ret != 0) {
 800c74a: 6b3b         	ldr	r3, [r7, #0x30]
 800c74c: 2b00         	cmp	r3, #0x0
 800c74e: d01c         	beq	0x800c78a <uart_stm32_async_rx_enable+0xfa> @ imm = #0x38
; 		LOG_ERR("UART ERR: RX DMA config failed!");
 800c750: 2303         	movs	r3, #0x3
 800c752: 2b00         	cmp	r3, #0x0
 800c754: d016         	beq	0x800c784 <uart_stm32_async_rx_enable+0xf4> @ imm = #0x2c
 800c756: 2301         	movs	r3, #0x1
 800c758: 77fb         	strb	r3, [r7, #0x1f]
 800c75a: 7ffb         	ldrb	r3, [r7, #0x1f]
 800c75c: f083 0301    	eor	r3, r3, #0x1
 800c760: b2db         	uxtb	r3, r3
 800c762: 2b00         	cmp	r3, #0x0
 800c764: d10e         	bne	0x800c784 <uart_stm32_async_rx_enable+0xf4> @ imm = #0x1c
 800c766: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800c848 <uart_stm32_async_rx_enable+0x1b8>
 800c768: 6819         	ldr	r1, [r3]
 800c76a: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800c850 <uart_stm32_async_rx_enable+0x1c0>
 800c76c: 9302         	str	r3, [sp, #0x8]
 800c76e: 2300         	movs	r3, #0x0
 800c770: 9301         	str	r3, [sp, #0x4]
 800c772: 2300         	movs	r3, #0x0
 800c774: 9300         	str	r3, [sp]
 800c776: 2300         	movs	r3, #0x0
 800c778: 2201         	movs	r2, #0x1
 800c77a: 2000         	movs	r0, #0x0
 800c77c: f00f fd21    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xfa42
 800c780: 2300         	movs	r3, #0x0
 800c782: 61bb         	str	r3, [r7, #0x18]
; 		return -EINVAL;
 800c784: f06f 0315    	mvn	r3, #0x15
 800c788: e05a         	b	0x800c840 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0xb4
; 	if (dma_start(data->dma_rx.dma_dev, data->dma_rx.dma_channel)) {
 800c78a: 6b7b         	ldr	r3, [r7, #0x34]
 800c78c: 6a1a         	ldr	r2, [r3, #0x20]
 800c78e: 6b7b         	ldr	r3, [r7, #0x34]
 800c790: 6a5b         	ldr	r3, [r3, #0x24]
 800c792: 4619         	mov	r1, r3
 800c794: 4610         	mov	r0, r2
 800c796: f00f f80b    	bl	0x801b7b0 <dma_start>   @ imm = #0xf016
 800c79a: 4603         	mov	r3, r0
 800c79c: 2b00         	cmp	r3, #0x0
 800c79e: d01e         	beq	0x800c7de <uart_stm32_async_rx_enable+0x14e> @ imm = #0x3c
; 		LOG_ERR("UART ERR: RX DMA start failed!");
 800c7a0: 2303         	movs	r3, #0x3
 800c7a2: 2b00         	cmp	r3, #0x0
 800c7a4: d018         	beq	0x800c7d8 <uart_stm32_async_rx_enable+0x148> @ imm = #0x30
 800c7a6: 2301         	movs	r3, #0x1
 800c7a8: f887 3027    	strb.w	r3, [r7, #0x27]
 800c7ac: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800c7b0: f083 0301    	eor	r3, r3, #0x1
 800c7b4: b2db         	uxtb	r3, r3
 800c7b6: 2b00         	cmp	r3, #0x0
 800c7b8: d10e         	bne	0x800c7d8 <uart_stm32_async_rx_enable+0x148> @ imm = #0x1c
 800c7ba: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800c848 <uart_stm32_async_rx_enable+0x1b8>
 800c7bc: 6819         	ldr	r1, [r3]
 800c7be: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800c854 <uart_stm32_async_rx_enable+0x1c4>
 800c7c0: 9302         	str	r3, [sp, #0x8]
 800c7c2: 2300         	movs	r3, #0x0
 800c7c4: 9301         	str	r3, [sp, #0x4]
 800c7c6: 2300         	movs	r3, #0x0
 800c7c8: 9300         	str	r3, [sp]
 800c7ca: 2300         	movs	r3, #0x0
 800c7cc: 2201         	movs	r2, #0x1
 800c7ce: 2000         	movs	r0, #0x0
 800c7d0: f00f fcf7    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xf9ee
 800c7d4: 2300         	movs	r3, #0x0
 800c7d6: 623b         	str	r3, [r7, #0x20]
; 		return -EFAULT;
 800c7d8: f06f 030d    	mvn	r3, #0xd
 800c7dc: e030         	b	0x800c840 <uart_stm32_async_rx_enable+0x1b0> @ imm = #0x60
; 	LL_USART_ClearFlag_RXNE(usart);
 800c7de: 6bb8         	ldr	r0, [r7, #0x38]
 800c7e0: f00f fa8b    	bl	0x801bcfa <LL_USART_ClearFlag_RXNE> @ imm = #0xf516
; 	uart_stm32_dma_rx_enable(dev);
 800c7e4: 68f8         	ldr	r0, [r7, #0xc]
 800c7e6: f010 fa46    	bl	0x801cc76 <uart_stm32_dma_rx_enable> @ imm = #0x1048c
; 	LL_USART_ClearFlag_IDLE(usart);
 800c7ea: 6bb8         	ldr	r0, [r7, #0x38]
 800c7ec: f00f fa65    	bl	0x801bcba <LL_USART_ClearFlag_IDLE> @ imm = #0xf4ca
; 	LL_USART_EnableIT_IDLE(usart);
 800c7f0: 6bb8         	ldr	r0, [r7, #0x38]
 800c7f2: f00f fa9e    	bl	0x801bd32 <LL_USART_EnableIT_IDLE> @ imm = #0xf53c
; 	LL_USART_EnableIT_ERROR(usart);
 800c7f6: 6bb8         	ldr	r0, [r7, #0x38]
 800c7f8: f00f fb37    	bl	0x801be6a <LL_USART_EnableIT_ERROR> @ imm = #0xf66e
; 	async_evt_rx_buf_request(data);
 800c7fc: 6b78         	ldr	r0, [r7, #0x34]
 800c7fe: f010 f9a4    	bl	0x801cb4a <async_evt_rx_buf_request> @ imm = #0x10348
; 	LOG_DBG("async rx enabled");
 800c802: 2303         	movs	r3, #0x3
 800c804: 2b03         	cmp	r3, #0x3
 800c806: d91a         	bls	0x800c83e <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x34
 800c808: 2301         	movs	r3, #0x1
 800c80a: f887 302f    	strb.w	r3, [r7, #0x2f]
 800c80e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800c812: f083 0301    	eor	r3, r3, #0x1
 800c816: b2db         	uxtb	r3, r3
 800c818: 2b00         	cmp	r3, #0x0
 800c81a: d110         	bne	0x800c83e <uart_stm32_async_rx_enable+0x1ae> @ imm = #0x20
 800c81c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800c848 <uart_stm32_async_rx_enable+0x1b8>
 800c81e: 6819         	ldr	r1, [r3]
 800c820: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800c858 <uart_stm32_async_rx_enable+0x1c8>
 800c822: 9303         	str	r3, [sp, #0xc]
 800c824: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800c85c <uart_stm32_async_rx_enable+0x1cc>
 800c826: 9302         	str	r3, [sp, #0x8]
 800c828: 2308         	movs	r3, #0x8
 800c82a: 9301         	str	r3, [sp, #0x4]
 800c82c: 2300         	movs	r3, #0x0
 800c82e: 9300         	str	r3, [sp]
 800c830: 2300         	movs	r3, #0x0
 800c832: 2204         	movs	r2, #0x4
 800c834: 2000         	movs	r0, #0x0
 800c836: f00f fcc4    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xf988
 800c83a: 2300         	movs	r3, #0x0
 800c83c: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800c83e: 6b3b         	ldr	r3, [r7, #0x30]
; }
 800c840: 4618         	mov	r0, r3
 800c842: 3740         	adds	r7, #0x40
 800c844: 46bd         	mov	sp, r7
 800c846: bd80         	pop	{r7, pc}

0800c848 <$d>:
 800c848: 74 05 00 20  	.word	0x20000574
 800c84c: c4 1b 02 08  	.word	0x08021bc4
 800c850: dc 1b 02 08  	.word	0x08021bdc
 800c854: fc 1b 02 08  	.word	0x08021bfc
 800c858: 1c 2d 02 08  	.word	0x08022d1c
 800c85c: 1c 1c 02 08  	.word	0x08021c1c

0800c860 <uart_stm32_async_rx_timeout>:
; {
 800c860: b580         	push	{r7, lr}
 800c862: b08c         	sub	sp, #0x30
 800c864: af04         	add	r7, sp, #0x10
 800c866: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 800c868: 6878         	ldr	r0, [r7, #0x4]
 800c86a: f00e fef7    	bl	0x801b65c <k_work_delayable_from_work> @ imm = #0xedee
 800c86e: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *rx_stream = CONTAINER_OF(dwork,
 800c870: 69fb         	ldr	r3, [r7, #0x1c]
 800c872: 3b60         	subs	r3, #0x60
 800c874: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(rx_stream,
 800c876: 69bb         	ldr	r3, [r7, #0x18]
 800c878: 3b20         	subs	r3, #0x20
 800c87a: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 800c87c: 697b         	ldr	r3, [r7, #0x14]
 800c87e: 691b         	ldr	r3, [r3, #0x10]
 800c880: 613b         	str	r3, [r7, #0x10]
; 	LOG_DBG("rx timeout");
 800c882: 2303         	movs	r3, #0x3
 800c884: 2b03         	cmp	r3, #0x3
 800c886: d918         	bls	0x800c8ba <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x30
 800c888: 2301         	movs	r3, #0x1
 800c88a: 73fb         	strb	r3, [r7, #0xf]
 800c88c: 7bfb         	ldrb	r3, [r7, #0xf]
 800c88e: f083 0301    	eor	r3, r3, #0x1
 800c892: b2db         	uxtb	r3, r3
 800c894: 2b00         	cmp	r3, #0x0
 800c896: d110         	bne	0x800c8ba <uart_stm32_async_rx_timeout+0x5a> @ imm = #0x20
 800c898: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800c8dc <uart_stm32_async_rx_timeout+0x7c>
 800c89a: 6819         	ldr	r1, [r3]
 800c89c: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800c8e0 <uart_stm32_async_rx_timeout+0x80>
 800c89e: 9303         	str	r3, [sp, #0xc]
 800c8a0: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800c8e4 <uart_stm32_async_rx_timeout+0x84>
 800c8a2: 9302         	str	r3, [sp, #0x8]
 800c8a4: 2308         	movs	r3, #0x8
 800c8a6: 9301         	str	r3, [sp, #0x4]
 800c8a8: 2300         	movs	r3, #0x0
 800c8aa: 9300         	str	r3, [sp]
 800c8ac: 2300         	movs	r3, #0x0
 800c8ae: 2204         	movs	r2, #0x4
 800c8b0: 2000         	movs	r0, #0x0
 800c8b2: f00f fc86    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xf90c
 800c8b6: 2300         	movs	r3, #0x0
 800c8b8: 60bb         	str	r3, [r7, #0x8]
; 	if (data->dma_rx.counter == data->dma_rx.buffer_length) {
 800c8ba: 697b         	ldr	r3, [r7, #0x14]
 800c8bc: 6f9a         	ldr	r2, [r3, #0x78]
 800c8be: 697b         	ldr	r3, [r7, #0x14]
 800c8c0: 6f1b         	ldr	r3, [r3, #0x70]
 800c8c2: 429a         	cmp	r2, r3
 800c8c4: d103         	bne	0x800c8ce <uart_stm32_async_rx_timeout+0x6e> @ imm = #0x6
; 		uart_stm32_async_rx_disable(dev);
 800c8c6: 6938         	ldr	r0, [r7, #0x10]
 800c8c8: f7ff fd04    	bl	0x800c2d4 <uart_stm32_async_rx_disable> @ imm = #-0x5f8
; }
 800c8cc: e002         	b	0x800c8d4 <uart_stm32_async_rx_timeout+0x74> @ imm = #0x4
; 		uart_stm32_dma_rx_flush(dev);
 800c8ce: 6938         	ldr	r0, [r7, #0x10]
 800c8d0: f010 f96e    	bl	0x801cbb0 <uart_stm32_dma_rx_flush> @ imm = #0x102dc
; }
 800c8d4: bf00         	nop
 800c8d6: 3720         	adds	r7, #0x20
 800c8d8: 46bd         	mov	sp, r7
 800c8da: bd80         	pop	{r7, pc}

0800c8dc <$d>:
 800c8dc: 74 05 00 20  	.word	0x20000574
 800c8e0: 4c 2d 02 08  	.word	0x08022d4c
 800c8e4: 34 1c 02 08  	.word	0x08021c34

0800c8e8 <uart_stm32_async_tx_timeout>:
; {
 800c8e8: b580         	push	{r7, lr}
 800c8ea: b08c         	sub	sp, #0x30
 800c8ec: af04         	add	r7, sp, #0x10
 800c8ee: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dwork = k_work_delayable_from_work(work);
 800c8f0: 6878         	ldr	r0, [r7, #0x4]
 800c8f2: f00e feb3    	bl	0x801b65c <k_work_delayable_from_work> @ imm = #0xed66
 800c8f6: 61f8         	str	r0, [r7, #0x1c]
; 	struct uart_dma_stream *tx_stream = CONTAINER_OF(dwork,
 800c8f8: 69fb         	ldr	r3, [r7, #0x1c]
 800c8fa: 3b60         	subs	r3, #0x60
 800c8fc: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = CONTAINER_OF(tx_stream,
 800c8fe: 69bb         	ldr	r3, [r7, #0x18]
 800c900: 3bb8         	subs	r3, #0xb8
 800c902: 617b         	str	r3, [r7, #0x14]
; 	const struct device *dev = data->uart_dev;
 800c904: 697b         	ldr	r3, [r7, #0x14]
 800c906: 691b         	ldr	r3, [r3, #0x10]
 800c908: 613b         	str	r3, [r7, #0x10]
; 	uart_stm32_async_tx_abort(dev);
 800c90a: 6938         	ldr	r0, [r7, #0x10]
 800c90c: f010 fa63    	bl	0x801cdd6 <uart_stm32_async_tx_abort> @ imm = #0x104c6
; 	LOG_DBG("tx: async timeout");
 800c910: 2303         	movs	r3, #0x3
 800c912: 2b03         	cmp	r3, #0x3
 800c914: d919         	bls	0x800c94a <uart_stm32_async_tx_timeout+0x62> @ imm = #0x32
 800c916: 2301         	movs	r3, #0x1
 800c918: 73fb         	strb	r3, [r7, #0xf]
 800c91a: 7bfb         	ldrb	r3, [r7, #0xf]
 800c91c: f083 0301    	eor	r3, r3, #0x1
 800c920: b2db         	uxtb	r3, r3
 800c922: 2b00         	cmp	r3, #0x0
 800c924: d111         	bne	0x800c94a <uart_stm32_async_tx_timeout+0x62> @ imm = #0x22
 800c926: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800c954 <uart_stm32_async_tx_timeout+0x6c>
 800c928: 6819         	ldr	r1, [r3]
 800c92a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800c958 <uart_stm32_async_tx_timeout+0x70>
 800c92c: 9303         	str	r3, [sp, #0xc]
 800c92e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800c95c <uart_stm32_async_tx_timeout+0x74>
 800c930: 9302         	str	r3, [sp, #0x8]
 800c932: 2308         	movs	r3, #0x8
 800c934: 9301         	str	r3, [sp, #0x4]
 800c936: 2300         	movs	r3, #0x0
 800c938: 9300         	str	r3, [sp]
 800c93a: 2300         	movs	r3, #0x0
 800c93c: 2204         	movs	r2, #0x4
 800c93e: 2000         	movs	r0, #0x0
 800c940: f00f fc3f    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xf87e
 800c944: 2300         	movs	r3, #0x0
 800c946: 60bb         	str	r3, [r7, #0x8]
; }
 800c948: bf00         	nop
 800c94a: bf00         	nop
 800c94c: 3720         	adds	r7, #0x20
 800c94e: 46bd         	mov	sp, r7
 800c950: bd80         	pop	{r7, pc}
 800c952: bf00         	nop

0800c954 <$d>:
 800c954: 74 05 00 20  	.word	0x20000574
 800c958: 68 2d 02 08  	.word	0x08022d68
 800c95c: 44 1c 02 08  	.word	0x08021c44

0800c960 <uart_stm32_async_rx_buf_rsp>:
; {
 800c960: b580         	push	{r7, lr}
 800c962: b094         	sub	sp, #0x50
 800c964: af06         	add	r7, sp, #0x18
 800c966: 60f8         	str	r0, [r7, #0xc]
 800c968: 60b9         	str	r1, [r7, #0x8]
 800c96a: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 800c96c: 68fb         	ldr	r3, [r7, #0xc]
 800c96e: 691b         	ldr	r3, [r3, #0x10]
 800c970: 633b         	str	r3, [r7, #0x30]
; 	int err = 0;
 800c972: 2300         	movs	r3, #0x0
 800c974: 637b         	str	r3, [r7, #0x34]
; 	LOG_DBG("replace buffer (%d)", len);
 800c976: 2303         	movs	r3, #0x3
 800c978: 2b03         	cmp	r3, #0x3
 800c97a: d91c         	bls	0x800c9b6 <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x38
 800c97c: 2301         	movs	r3, #0x1
 800c97e: f887 302f    	strb.w	r3, [r7, #0x2f]
 800c982: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800c986: f083 0301    	eor	r3, r3, #0x1
 800c98a: b2db         	uxtb	r3, r3
 800c98c: 2b00         	cmp	r3, #0x0
 800c98e: d112         	bne	0x800c9b6 <uart_stm32_async_rx_buf_rsp+0x56> @ imm = #0x24
 800c990: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800ca34 <uart_stm32_async_rx_buf_rsp+0xd4>
 800c992: 6819         	ldr	r1, [r3]
 800c994: 687b         	ldr	r3, [r7, #0x4]
 800c996: 9304         	str	r3, [sp, #0x10]
 800c998: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800ca38 <uart_stm32_async_rx_buf_rsp+0xd8>
 800c99a: 9303         	str	r3, [sp, #0xc]
 800c99c: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800ca3c <uart_stm32_async_rx_buf_rsp+0xdc>
 800c99e: 9302         	str	r3, [sp, #0x8]
 800c9a0: 2308         	movs	r3, #0x8
 800c9a2: 9301         	str	r3, [sp, #0x4]
 800c9a4: 2300         	movs	r3, #0x0
 800c9a6: 9300         	str	r3, [sp]
 800c9a8: 2300         	movs	r3, #0x0
 800c9aa: 2204         	movs	r2, #0x4
 800c9ac: 2000         	movs	r0, #0x0
 800c9ae: f00f fc08    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xf810
 800c9b2: 2300         	movs	r3, #0x0
 800c9b4: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c9b6: f3ef 8311    	mrs	r3, basepri
 800c9ba: 623b         	str	r3, [r7, #0x20]
;   return(result);
 800c9bc: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 800c9be: 61fb         	str	r3, [r7, #0x1c]
 800c9c0: 2310         	movs	r3, #0x10
 800c9c2: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c9c4: 69bb         	ldr	r3, [r7, #0x18]
 800c9c6: f383 8812    	msr	basepri_max, r3
; }
 800c9ca: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c9cc: f3bf 8f6f    	isb	sy
; }
 800c9d0: bf00         	nop
; 	return key;
 800c9d2: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = irq_lock();
 800c9d4: 627b         	str	r3, [r7, #0x24]
; 	if (data->rx_next_buffer != NULL) {
 800c9d6: 6b3b         	ldr	r3, [r7, #0x30]
 800c9d8: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 800c9dc: 2b00         	cmp	r3, #0x0
 800c9de: d003         	beq	0x800c9e8 <uart_stm32_async_rx_buf_rsp+0x88> @ imm = #0x6
; 		err = -EBUSY;
 800c9e0: f06f 030f    	mvn	r3, #0xf
 800c9e4: 637b         	str	r3, [r7, #0x34]
 800c9e6: e013         	b	0x800ca10 <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0x26
; 	} else if (!data->dma_rx.enabled) {
 800c9e8: 6b3b         	ldr	r3, [r7, #0x30]
 800c9ea: f893 30b0    	ldrb.w	r3, [r3, #0xb0]
 800c9ee: f083 0301    	eor	r3, r3, #0x1
 800c9f2: b2db         	uxtb	r3, r3
 800c9f4: 2b00         	cmp	r3, #0x0
 800c9f6: d003         	beq	0x800ca00 <uart_stm32_async_rx_buf_rsp+0xa0> @ imm = #0x6
; 		err = -EACCES;
 800c9f8: f06f 030c    	mvn	r3, #0xc
 800c9fc: 637b         	str	r3, [r7, #0x34]
 800c9fe: e007         	b	0x800ca10 <uart_stm32_async_rx_buf_rsp+0xb0> @ imm = #0xe
; 		data->rx_next_buffer = buf;
 800ca00: 6b3b         	ldr	r3, [r7, #0x30]
 800ca02: 68ba         	ldr	r2, [r7, #0x8]
 800ca04: f8c3 2150    	str.w	r2, [r3, #0x150]
; 		data->rx_next_buffer_len = len;
 800ca08: 6b3b         	ldr	r3, [r7, #0x30]
 800ca0a: 687a         	ldr	r2, [r7, #0x4]
 800ca0c: f8c3 2154    	str.w	r2, [r3, #0x154]
 800ca10: 6a7b         	ldr	r3, [r7, #0x24]
 800ca12: 617b         	str	r3, [r7, #0x14]
 800ca14: 697b         	ldr	r3, [r7, #0x14]
 800ca16: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ca18: 693b         	ldr	r3, [r7, #0x10]
 800ca1a: f383 8811    	msr	basepri, r3
; }
 800ca1e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ca20: f3bf 8f6f    	isb	sy
; }
 800ca24: bf00         	nop
; }
 800ca26: bf00         	nop
; 	return err;
 800ca28: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800ca2a: 4618         	mov	r0, r3
 800ca2c: 3738         	adds	r7, #0x38
 800ca2e: 46bd         	mov	sp, r7
 800ca30: bd80         	pop	{r7, pc}
 800ca32: bf00         	nop

0800ca34 <$d>:
 800ca34: 74 05 00 20  	.word	0x20000574
 800ca38: 84 2d 02 08  	.word	0x08022d84
 800ca3c: 5c 1c 02 08  	.word	0x08021c5c

0800ca40 <uart_stm32_async_init>:
; {
 800ca40: b580         	push	{r7, lr}
 800ca42: b086         	sub	sp, #0x18
 800ca44: af00         	add	r7, sp, #0x0
 800ca46: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800ca48: 687b         	ldr	r3, [r7, #0x4]
 800ca4a: 685b         	ldr	r3, [r3, #0x4]
 800ca4c: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 800ca4e: 697b         	ldr	r3, [r7, #0x14]
 800ca50: 681b         	ldr	r3, [r3]
 800ca52: 613b         	str	r3, [r7, #0x10]
; 	struct uart_stm32_data *data = dev->data;
 800ca54: 687b         	ldr	r3, [r7, #0x4]
 800ca56: 691b         	ldr	r3, [r3, #0x10]
 800ca58: 60fb         	str	r3, [r7, #0xc]
; 	data->uart_dev = dev;
 800ca5a: 68fb         	ldr	r3, [r7, #0xc]
 800ca5c: 687a         	ldr	r2, [r7, #0x4]
 800ca5e: 611a         	str	r2, [r3, #0x10]
; 	if (data->dma_rx.dma_dev != NULL) {
 800ca60: 68fb         	ldr	r3, [r7, #0xc]
 800ca62: 6a1b         	ldr	r3, [r3, #0x20]
 800ca64: 2b00         	cmp	r3, #0x0
 800ca66: d00d         	beq	0x800ca84 <uart_stm32_async_init+0x44> @ imm = #0x1a
; 		if (!device_is_ready(data->dma_rx.dma_dev)) {
 800ca68: 68fb         	ldr	r3, [r7, #0xc]
 800ca6a: 6a1b         	ldr	r3, [r3, #0x20]
 800ca6c: 4618         	mov	r0, r3
 800ca6e: f00e fde9    	bl	0x801b644 <device_is_ready> @ imm = #0xebd2
 800ca72: 4603         	mov	r3, r0
 800ca74: f083 0301    	eor	r3, r3, #0x1
 800ca78: b2db         	uxtb	r3, r3
 800ca7a: 2b00         	cmp	r3, #0x0
 800ca7c: d002         	beq	0x800ca84 <uart_stm32_async_init+0x44> @ imm = #0x4
; 			return -ENODEV;
 800ca7e: f06f 0312    	mvn	r3, #0x12
 800ca82: e0de         	b	0x800cc42 <uart_stm32_async_init+0x202> @ imm = #0x1bc
; 	if (data->dma_tx.dma_dev != NULL) {
 800ca84: 68fb         	ldr	r3, [r7, #0xc]
 800ca86: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800ca8a: 2b00         	cmp	r3, #0x0
 800ca8c: d00e         	beq	0x800caac <uart_stm32_async_init+0x6c> @ imm = #0x1c
; 		if (!device_is_ready(data->dma_tx.dma_dev)) {
 800ca8e: 68fb         	ldr	r3, [r7, #0xc]
 800ca90: f8d3 30b8    	ldr.w	r3, [r3, #0xb8]
 800ca94: 4618         	mov	r0, r3
 800ca96: f00e fdd5    	bl	0x801b644 <device_is_ready> @ imm = #0xebaa
 800ca9a: 4603         	mov	r3, r0
 800ca9c: f083 0301    	eor	r3, r3, #0x1
 800caa0: b2db         	uxtb	r3, r3
 800caa2: 2b00         	cmp	r3, #0x0
 800caa4: d002         	beq	0x800caac <uart_stm32_async_init+0x6c> @ imm = #0x4
; 			return -ENODEV;
 800caa6: f06f 0312    	mvn	r3, #0x12
 800caaa: e0ca         	b	0x800cc42 <uart_stm32_async_init+0x202> @ imm = #0x194
; 	uart_stm32_dma_rx_disable(dev);
 800caac: 6878         	ldr	r0, [r7, #0x4]
 800caae: f010 f8f9    	bl	0x801cca4 <uart_stm32_dma_rx_disable> @ imm = #0x101f2
; 	uart_stm32_dma_tx_disable(dev);
 800cab2: 6878         	ldr	r0, [r7, #0x4]
 800cab4: f010 f8cf    	bl	0x801cc56 <uart_stm32_dma_tx_disable> @ imm = #0x1019e
; 	k_work_init_delayable(&data->dma_rx.timeout_work,
 800cab8: 68fb         	ldr	r3, [r7, #0xc]
 800caba: 3380         	adds	r3, #0x80
 800cabc: 4963         	ldr	r1, [pc, #0x18c]        @ 0x800cc4c <uart_stm32_async_init+0x20c>
 800cabe: 4618         	mov	r0, r3
 800cac0: f012 f982    	bl	0x801edc8 <k_work_init_delayable> @ imm = #0x12304
; 	k_work_init_delayable(&data->dma_tx.timeout_work,
 800cac4: 68fb         	ldr	r3, [r7, #0xc]
 800cac6: f503 738c    	add.w	r3, r3, #0x118
 800caca: 4961         	ldr	r1, [pc, #0x184]        @ 0x800cc50 <uart_stm32_async_init+0x210>
 800cacc: 4618         	mov	r0, r3
 800cace: f012 f97b    	bl	0x801edc8 <k_work_init_delayable> @ imm = #0x122f6
; 	memset(&data->dma_rx.blk_cfg, 0, sizeof(data->dma_rx.blk_cfg));
 800cad2: 68fb         	ldr	r3, [r7, #0xc]
 800cad4: 334c         	adds	r3, #0x4c
 800cad6: 2220         	movs	r2, #0x20
 800cad8: 2100         	movs	r1, #0x0
 800cada: 4618         	mov	r0, r3
 800cadc: f013 f8fc    	bl	0x801fcd8 <memset>      @ imm = #0x131f8
; 				LL_USART_DMA_GetRegAddr(usart);
 800cae0: 6938         	ldr	r0, [r7, #0x10]
 800cae2: f00f fb46    	bl	0x801c172 <LL_USART_DMA_GetRegAddr> @ imm = #0xf68c
 800cae6: 4602         	mov	r2, r0
; 	data->dma_rx.blk_cfg.source_address =
 800cae8: 68fb         	ldr	r3, [r7, #0xc]
 800caea: 64da         	str	r2, [r3, #0x4c]
; 	data->dma_rx.blk_cfg.dest_address = 0; /* dest not ready */
 800caec: 68fb         	ldr	r3, [r7, #0xc]
 800caee: 2200         	movs	r2, #0x0
 800caf0: 651a         	str	r2, [r3, #0x50]
; 	if (data->dma_rx.src_addr_increment) {
 800caf2: 68fb         	ldr	r3, [r7, #0xc]
 800caf4: f893 3045    	ldrb.w	r3, [r3, #0x45]
 800caf8: 2b00         	cmp	r3, #0x0
 800cafa: d007         	beq	0x800cb0c <uart_stm32_async_init+0xcc> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800cafc: 68fa         	ldr	r2, [r7, #0xc]
 800cafe: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800cb02: f36f 0383    	bfc	r3, #2, #2
 800cb06: f882 3068    	strb.w	r3, [r2, #0x68]
 800cb0a: e007         	b	0x800cb1c <uart_stm32_async_init+0xdc> @ imm = #0xe
; 		data->dma_rx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800cb0c: 68fa         	ldr	r2, [r7, #0xc]
 800cb0e: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800cb12: 2102         	movs	r1, #0x2
 800cb14: f361 0383    	bfi	r3, r1, #2, #2
 800cb18: f882 3068    	strb.w	r3, [r2, #0x68]
; 	if (data->dma_rx.dst_addr_increment) {
 800cb1c: 68fb         	ldr	r3, [r7, #0xc]
 800cb1e: f893 3046    	ldrb.w	r3, [r3, #0x46]
 800cb22: 2b00         	cmp	r3, #0x0
 800cb24: d007         	beq	0x800cb36 <uart_stm32_async_init+0xf6> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800cb26: 68fa         	ldr	r2, [r7, #0xc]
 800cb28: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800cb2c: f36f 1305    	bfc	r3, #4, #2
 800cb30: f882 3068    	strb.w	r3, [r2, #0x68]
 800cb34: e007         	b	0x800cb46 <uart_stm32_async_init+0x106> @ imm = #0xe
; 		data->dma_rx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800cb36: 68fa         	ldr	r2, [r7, #0xc]
 800cb38: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800cb3c: 2102         	movs	r1, #0x2
 800cb3e: f361 1305    	bfi	r3, r1, #4, #2
 800cb42: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.source_reload_en  = 0;
 800cb46: 68fa         	ldr	r2, [r7, #0xc]
 800cb48: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800cb4c: f36f 1386    	bfc	r3, #6, #1
 800cb50: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.dest_reload_en = 0;
 800cb54: 68fa         	ldr	r2, [r7, #0xc]
 800cb56: f892 3068    	ldrb.w	r3, [r2, #0x68]
 800cb5a: f36f 13c7    	bfc	r3, #7, #1
 800cb5e: f882 3068    	strb.w	r3, [r2, #0x68]
; 	data->dma_rx.blk_cfg.fifo_mode_control = data->dma_rx.fifo_threshold;
 800cb62: 68fb         	ldr	r3, [r7, #0xc]
 800cb64: 6c9b         	ldr	r3, [r3, #0x48]
 800cb66: f003 030f    	and	r3, r3, #0xf
 800cb6a: b2d9         	uxtb	r1, r3
 800cb6c: 68fa         	ldr	r2, [r7, #0xc]
 800cb6e: f892 3069    	ldrb.w	r3, [r2, #0x69]
 800cb72: f361 0303    	bfi	r3, r1, #0, #4
 800cb76: f882 3069    	strb.w	r3, [r2, #0x69]
; 	data->dma_rx.dma_cfg.head_block = &data->dma_rx.blk_cfg;
 800cb7a: 68fb         	ldr	r3, [r7, #0xc]
 800cb7c: f103 024c    	add.w	r2, r3, #0x4c
 800cb80: 68fb         	ldr	r3, [r7, #0xc]
 800cb82: 639a         	str	r2, [r3, #0x38]
; 	data->dma_rx.dma_cfg.user_data = (void *)dev;
 800cb84: 68fb         	ldr	r3, [r7, #0xc]
 800cb86: 687a         	ldr	r2, [r7, #0x4]
 800cb88: 63da         	str	r2, [r3, #0x3c]
; 	data->rx_next_buffer = NULL;
 800cb8a: 68fb         	ldr	r3, [r7, #0xc]
 800cb8c: 2200         	movs	r2, #0x0
 800cb8e: f8c3 2150    	str.w	r2, [r3, #0x150]
; 	data->rx_next_buffer_len = 0;
 800cb92: 68fb         	ldr	r3, [r7, #0xc]
 800cb94: 2200         	movs	r2, #0x0
 800cb96: f8c3 2154    	str.w	r2, [r3, #0x154]
; 	memset(&data->dma_tx.blk_cfg, 0, sizeof(data->dma_tx.blk_cfg));
 800cb9a: 68fb         	ldr	r3, [r7, #0xc]
 800cb9c: 33e4         	adds	r3, #0xe4
 800cb9e: 2220         	movs	r2, #0x20
 800cba0: 2100         	movs	r1, #0x0
 800cba2: 4618         	mov	r0, r3
 800cba4: f013 f898    	bl	0x801fcd8 <memset>      @ imm = #0x13130
; 			LL_USART_DMA_GetRegAddr(usart);
 800cba8: 6938         	ldr	r0, [r7, #0x10]
 800cbaa: f00f fae2    	bl	0x801c172 <LL_USART_DMA_GetRegAddr> @ imm = #0xf5c4
 800cbae: 4602         	mov	r2, r0
; 	data->dma_tx.blk_cfg.dest_address =
 800cbb0: 68fb         	ldr	r3, [r7, #0xc]
 800cbb2: f8c3 20e8    	str.w	r2, [r3, #0xe8]
; 	data->dma_tx.blk_cfg.source_address = 0; /* not ready */
 800cbb6: 68fb         	ldr	r3, [r7, #0xc]
 800cbb8: 2200         	movs	r2, #0x0
 800cbba: f8c3 20e4    	str.w	r2, [r3, #0xe4]
; 	if (data->dma_tx.src_addr_increment) {
 800cbbe: 68fb         	ldr	r3, [r7, #0xc]
 800cbc0: f893 30dd    	ldrb.w	r3, [r3, #0xdd]
 800cbc4: 2b00         	cmp	r3, #0x0
 800cbc6: d007         	beq	0x800cbd8 <uart_stm32_async_init+0x198> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800cbc8: 68fa         	ldr	r2, [r7, #0xc]
 800cbca: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800cbce: f36f 0383    	bfc	r3, #2, #2
 800cbd2: f882 3100    	strb.w	r3, [r2, #0x100]
 800cbd6: e007         	b	0x800cbe8 <uart_stm32_async_init+0x1a8> @ imm = #0xe
; 		data->dma_tx.blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800cbd8: 68fa         	ldr	r2, [r7, #0xc]
 800cbda: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800cbde: 2102         	movs	r1, #0x2
 800cbe0: f361 0383    	bfi	r3, r1, #2, #2
 800cbe4: f882 3100    	strb.w	r3, [r2, #0x100]
; 	if (data->dma_tx.dst_addr_increment) {
 800cbe8: 68fb         	ldr	r3, [r7, #0xc]
 800cbea: f893 30de    	ldrb.w	r3, [r3, #0xde]
 800cbee: 2b00         	cmp	r3, #0x0
 800cbf0: d007         	beq	0x800cc02 <uart_stm32_async_init+0x1c2> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 800cbf2: 68fa         	ldr	r2, [r7, #0xc]
 800cbf4: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800cbf8: f36f 1305    	bfc	r3, #4, #2
 800cbfc: f882 3100    	strb.w	r3, [r2, #0x100]
 800cc00: e007         	b	0x800cc12 <uart_stm32_async_init+0x1d2> @ imm = #0xe
; 		data->dma_tx.blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 800cc02: 68fa         	ldr	r2, [r7, #0xc]
 800cc04: f892 3100    	ldrb.w	r3, [r2, #0x100]
 800cc08: 2102         	movs	r1, #0x2
 800cc0a: f361 1305    	bfi	r3, r1, #4, #2
 800cc0e: f882 3100    	strb.w	r3, [r2, #0x100]
; 	data->dma_tx.blk_cfg.fifo_mode_control = data->dma_tx.fifo_threshold;
 800cc12: 68fb         	ldr	r3, [r7, #0xc]
 800cc14: f8d3 30e0    	ldr.w	r3, [r3, #0xe0]
 800cc18: f003 030f    	and	r3, r3, #0xf
 800cc1c: b2d9         	uxtb	r1, r3
 800cc1e: 68fa         	ldr	r2, [r7, #0xc]
 800cc20: f892 3101    	ldrb.w	r3, [r2, #0x101]
 800cc24: f361 0303    	bfi	r3, r1, #0, #4
 800cc28: f882 3101    	strb.w	r3, [r2, #0x101]
; 	data->dma_tx.dma_cfg.head_block = &data->dma_tx.blk_cfg;
 800cc2c: 68fb         	ldr	r3, [r7, #0xc]
 800cc2e: f103 02e4    	add.w	r2, r3, #0xe4
 800cc32: 68fb         	ldr	r3, [r7, #0xc]
 800cc34: f8c3 20d0    	str.w	r2, [r3, #0xd0]
; 	data->dma_tx.dma_cfg.user_data = (void *)dev;
 800cc38: 68fb         	ldr	r3, [r7, #0xc]
 800cc3a: 687a         	ldr	r2, [r7, #0x4]
 800cc3c: f8c3 20d4    	str.w	r2, [r3, #0xd4]
; 	return 0;
 800cc40: 2300         	movs	r3, #0x0
; }
 800cc42: 4618         	mov	r0, r3
 800cc44: 3718         	adds	r7, #0x18
 800cc46: 46bd         	mov	sp, r7
 800cc48: bd80         	pop	{r7, pc}
 800cc4a: bf00         	nop

0800cc4c <$d>:
 800cc4c: 61 c8 00 08  	.word	0x0800c861
 800cc50: e9 c8 00 08  	.word	0x0800c8e9

0800cc54 <uart_stm32_clocks_enable>:
; {
 800cc54: b580         	push	{r7, lr}
 800cc56: b08e         	sub	sp, #0x38
 800cc58: af04         	add	r7, sp, #0x10
 800cc5a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800cc5c: 687b         	ldr	r3, [r7, #0x4]
 800cc5e: 685b         	ldr	r3, [r3, #0x4]
 800cc60: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 800cc62: 687b         	ldr	r3, [r7, #0x4]
 800cc64: 691b         	ldr	r3, [r3, #0x10]
 800cc66: 627b         	str	r3, [r7, #0x24]
; 	__uart_stm32_get_clock(dev);
 800cc68: 6878         	ldr	r0, [r7, #0x4]
 800cc6a: f7ff f853    	bl	0x800bd14 <__uart_stm32_get_clock> @ imm = #-0xf5a
; 	if (!device_is_ready(data->clock)) {
 800cc6e: 6a7b         	ldr	r3, [r7, #0x24]
 800cc70: 681b         	ldr	r3, [r3]
 800cc72: 4618         	mov	r0, r3
 800cc74: f00e fce6    	bl	0x801b644 <device_is_ready> @ imm = #0xe9cc
 800cc78: 4603         	mov	r3, r0
 800cc7a: f083 0301    	eor	r3, r3, #0x1
 800cc7e: b2db         	uxtb	r3, r3
 800cc80: 2b00         	cmp	r3, #0x0
 800cc82: d01c         	beq	0x800ccbe <uart_stm32_clocks_enable+0x6a> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800cc84: 2303         	movs	r3, #0x3
 800cc86: 2b00         	cmp	r3, #0x0
 800cc88: d016         	beq	0x800ccb8 <uart_stm32_clocks_enable+0x64> @ imm = #0x2c
 800cc8a: 2301         	movs	r3, #0x1
 800cc8c: 74fb         	strb	r3, [r7, #0x13]
 800cc8e: 7cfb         	ldrb	r3, [r7, #0x13]
 800cc90: f083 0301    	eor	r3, r3, #0x1
 800cc94: b2db         	uxtb	r3, r3
 800cc96: 2b00         	cmp	r3, #0x0
 800cc98: d10e         	bne	0x800ccb8 <uart_stm32_clocks_enable+0x64> @ imm = #0x1c
 800cc9a: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800cd18 <uart_stm32_clocks_enable+0xc4>
 800cc9c: 6819         	ldr	r1, [r3]
 800cc9e: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800cd1c <uart_stm32_clocks_enable+0xc8>
 800cca0: 9302         	str	r3, [sp, #0x8]
 800cca2: 2300         	movs	r3, #0x0
 800cca4: 9301         	str	r3, [sp, #0x4]
 800cca6: 2300         	movs	r3, #0x0
 800cca8: 9300         	str	r3, [sp]
 800ccaa: 2300         	movs	r3, #0x0
 800ccac: 2201         	movs	r2, #0x1
 800ccae: 2000         	movs	r0, #0x0
 800ccb0: f00f fa87    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xf50e
 800ccb4: 2300         	movs	r3, #0x0
 800ccb6: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800ccb8: f06f 0312    	mvn	r3, #0x12
 800ccbc: e028         	b	0x800cd10 <uart_stm32_clocks_enable+0xbc> @ imm = #0x50
; 	err = clock_control_on(data->clock, (clock_control_subsys_t)&config->pclken[0]);
 800ccbe: 6a7b         	ldr	r3, [r7, #0x24]
 800ccc0: 681a         	ldr	r2, [r3]
 800ccc2: 6a3b         	ldr	r3, [r7, #0x20]
 800ccc4: 68db         	ldr	r3, [r3, #0xc]
 800ccc6: 4619         	mov	r1, r3
 800ccc8: 4610         	mov	r0, r2
 800ccca: f00e fcd2    	bl	0x801b672 <clock_control_on> @ imm = #0xe9a4
 800ccce: 61f8         	str	r0, [r7, #0x1c]
; 	if (err != 0) {
 800ccd0: 69fb         	ldr	r3, [r7, #0x1c]
 800ccd2: 2b00         	cmp	r3, #0x0
 800ccd4: d01b         	beq	0x800cd0e <uart_stm32_clocks_enable+0xba> @ imm = #0x36
; 		LOG_ERR("Could not enable (LP)UART clock");
 800ccd6: 2303         	movs	r3, #0x3
 800ccd8: 2b00         	cmp	r3, #0x0
 800ccda: d016         	beq	0x800cd0a <uart_stm32_clocks_enable+0xb6> @ imm = #0x2c
 800ccdc: 2301         	movs	r3, #0x1
 800ccde: 76fb         	strb	r3, [r7, #0x1b]
 800cce0: 7efb         	ldrb	r3, [r7, #0x1b]
 800cce2: f083 0301    	eor	r3, r3, #0x1
 800cce6: b2db         	uxtb	r3, r3
 800cce8: 2b00         	cmp	r3, #0x0
 800ccea: d10e         	bne	0x800cd0a <uart_stm32_clocks_enable+0xb6> @ imm = #0x1c
 800ccec: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800cd18 <uart_stm32_clocks_enable+0xc4>
 800ccee: 6819         	ldr	r1, [r3]
 800ccf0: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800cd20 <uart_stm32_clocks_enable+0xcc>
 800ccf2: 9302         	str	r3, [sp, #0x8]
 800ccf4: 2300         	movs	r3, #0x0
 800ccf6: 9301         	str	r3, [sp, #0x4]
 800ccf8: 2300         	movs	r3, #0x0
 800ccfa: 9300         	str	r3, [sp]
 800ccfc: 2300         	movs	r3, #0x0
 800ccfe: 2201         	movs	r2, #0x1
 800cd00: 2000         	movs	r0, #0x0
 800cd02: f00f fa5e    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xf4bc
 800cd06: 2300         	movs	r3, #0x0
 800cd08: 617b         	str	r3, [r7, #0x14]
; 		return err;
 800cd0a: 69fb         	ldr	r3, [r7, #0x1c]
 800cd0c: e000         	b	0x800cd10 <uart_stm32_clocks_enable+0xbc> @ imm = #0x0
; 	return 0;
 800cd0e: 2300         	movs	r3, #0x0
; }
 800cd10: 4618         	mov	r0, r3
 800cd12: 3728         	adds	r7, #0x28
 800cd14: 46bd         	mov	sp, r7
 800cd16: bd80         	pop	{r7, pc}

0800cd18 <$d>:
 800cd18: 74 05 00 20  	.word	0x20000574
 800cd1c: 74 1c 02 08  	.word	0x08021c74
 800cd20: 94 1c 02 08  	.word	0x08021c94

0800cd24 <uart_stm32_registers_configure>:
; {
 800cd24: b580         	push	{r7, lr}
 800cd26: b08c         	sub	sp, #0x30
 800cd28: af04         	add	r7, sp, #0x10
 800cd2a: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 800cd2c: 687b         	ldr	r3, [r7, #0x4]
 800cd2e: 685b         	ldr	r3, [r3, #0x4]
 800cd30: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 800cd32: 69fb         	ldr	r3, [r7, #0x1c]
 800cd34: 681b         	ldr	r3, [r3]
 800cd36: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 800cd38: 687b         	ldr	r3, [r7, #0x4]
 800cd3a: 691b         	ldr	r3, [r3, #0x10]
 800cd3c: 617b         	str	r3, [r7, #0x14]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 800cd3e: 697b         	ldr	r3, [r7, #0x14]
 800cd40: 685b         	ldr	r3, [r3, #0x4]
 800cd42: 613b         	str	r3, [r7, #0x10]
; 	LL_USART_Disable(usart);
 800cd44: 69b8         	ldr	r0, [r7, #0x18]
 800cd46: f00e fdc8    	bl	0x801b8da <LL_USART_Disable> @ imm = #0xeb90
; 	if (!device_is_ready(config->reset.dev)) {
 800cd4a: 69fb         	ldr	r3, [r7, #0x1c]
 800cd4c: 685b         	ldr	r3, [r3, #0x4]
 800cd4e: 4618         	mov	r0, r3
 800cd50: f00e fc78    	bl	0x801b644 <device_is_ready> @ imm = #0xe8f0
 800cd54: 4603         	mov	r3, r0
 800cd56: f083 0301    	eor	r3, r3, #0x1
 800cd5a: b2db         	uxtb	r3, r3
 800cd5c: 2b00         	cmp	r3, #0x0
 800cd5e: d01c         	beq	0x800cd9a <uart_stm32_registers_configure+0x76> @ imm = #0x38
; 		LOG_ERR("reset controller not ready");
 800cd60: 2303         	movs	r3, #0x3
 800cd62: 2b00         	cmp	r3, #0x0
 800cd64: d016         	beq	0x800cd94 <uart_stm32_registers_configure+0x70> @ imm = #0x2c
 800cd66: 2301         	movs	r3, #0x1
 800cd68: 73fb         	strb	r3, [r7, #0xf]
 800cd6a: 7bfb         	ldrb	r3, [r7, #0xf]
 800cd6c: f083 0301    	eor	r3, r3, #0x1
 800cd70: b2db         	uxtb	r3, r3
 800cd72: 2b00         	cmp	r3, #0x0
 800cd74: d10e         	bne	0x800cd94 <uart_stm32_registers_configure+0x70> @ imm = #0x1c
 800cd76: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800cdd4 <uart_stm32_registers_configure+0xb0>
 800cd78: 6819         	ldr	r1, [r3]
 800cd7a: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800cdd8 <uart_stm32_registers_configure+0xb4>
 800cd7c: 9302         	str	r3, [sp, #0x8]
 800cd7e: 2300         	movs	r3, #0x0
 800cd80: 9301         	str	r3, [sp, #0x4]
 800cd82: 2300         	movs	r3, #0x0
 800cd84: 9300         	str	r3, [sp]
 800cd86: 2300         	movs	r3, #0x0
 800cd88: 2201         	movs	r2, #0x1
 800cd8a: 2000         	movs	r0, #0x0
 800cd8c: f00f fa19    	bl	0x801c1c2 <z_log_msg_runtime_create> @ imm = #0xf432
 800cd90: 2300         	movs	r3, #0x0
 800cd92: 60bb         	str	r3, [r7, #0x8]
; 		return -ENODEV;
 800cd94: f06f 0312    	mvn	r3, #0x12
 800cd98: e017         	b	0x800cdca <uart_stm32_registers_configure+0xa6> @ imm = #0x2e
; 	(void)reset_line_toggle_dt(&config->reset);
 800cd9a: 69fb         	ldr	r3, [r7, #0x1c]
 800cd9c: 3304         	adds	r3, #0x4
 800cd9e: 4618         	mov	r0, r3
 800cda0: f00e fd6c    	bl	0x801b87c <reset_line_toggle_dt> @ imm = #0xead8
; 	LL_USART_SetTransferDirection(usart, LL_USART_DIRECTION_TX_RX);
 800cda4: 210c         	movs	r1, #0xc
 800cda6: 69b8         	ldr	r0, [r7, #0x18]
 800cda8: f00e fda7    	bl	0x801b8fa <LL_USART_SetTransferDirection> @ imm = #0xeb4e
; 	uart_stm32_parameters_set(dev, uart_cfg);
 800cdac: 6939         	ldr	r1, [r7, #0x10]
 800cdae: 6878         	ldr	r0, [r7, #0x4]
 800cdb0: f00f fb7f    	bl	0x801c4b2 <uart_stm32_parameters_set> @ imm = #0xf6fe
; 	if (config->single_wire) {
 800cdb4: 69fb         	ldr	r3, [r7, #0x1c]
 800cdb6: 7d1b         	ldrb	r3, [r3, #0x14]
 800cdb8: 2b00         	cmp	r3, #0x0
 800cdba: d002         	beq	0x800cdc2 <uart_stm32_registers_configure+0x9e> @ imm = #0x4
; 		LL_USART_EnableHalfDuplex(usart);
 800cdbc: 69b8         	ldr	r0, [r7, #0x18]
 800cdbe: f00e fe78    	bl	0x801bab2 <LL_USART_EnableHalfDuplex> @ imm = #0xecf0
; 	LL_USART_Enable(usart);
 800cdc2: 69b8         	ldr	r0, [r7, #0x18]
 800cdc4: f00e fd79    	bl	0x801b8ba <LL_USART_Enable> @ imm = #0xeaf2
; 	return 0;
 800cdc8: 2300         	movs	r3, #0x0
; }
 800cdca: 4618         	mov	r0, r3
 800cdcc: 3720         	adds	r7, #0x20
 800cdce: 46bd         	mov	sp, r7
 800cdd0: bd80         	pop	{r7, pc}
 800cdd2: bf00         	nop

0800cdd4 <$d>:
 800cdd4: 74 05 00 20  	.word	0x20000574
 800cdd8: b4 1c 02 08  	.word	0x08021cb4

0800cddc <spi_context_cs_configure_all>:
; {
 800cddc: b580         	push	{r7, lr}
 800cdde: b08c         	sub	sp, #0x30
 800cde0: af06         	add	r7, sp, #0x18
 800cde2: 6078         	str	r0, [r7, #0x4]
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 800cde4: 687b         	ldr	r3, [r7, #0x4]
 800cde6: 689b         	ldr	r3, [r3, #0x8]
 800cde8: 617b         	str	r3, [r7, #0x14]
 800cdea: e03c         	b	0x800ce66 <spi_context_cs_configure_all+0x8a> @ imm = #0x78
; 		if (!device_is_ready(cs_gpio->port)) {
 800cdec: 697b         	ldr	r3, [r7, #0x14]
 800cdee: 681b         	ldr	r3, [r3]
 800cdf0: 4618         	mov	r0, r3
 800cdf2: f010 f88b    	bl	0x801cf0c <device_is_ready> @ imm = #0x10116
 800cdf6: 4603         	mov	r3, r0
 800cdf8: f083 0301    	eor	r3, r3, #0x1
 800cdfc: b2db         	uxtb	r3, r3
 800cdfe: 2b00         	cmp	r3, #0x0
 800ce00: d023         	beq	0x800ce4a <spi_context_cs_configure_all+0x6e> @ imm = #0x46
; 			LOG_ERR("CS GPIO port %s pin %d is not ready",
 800ce02: 2303         	movs	r3, #0x3
 800ce04: 2b00         	cmp	r3, #0x0
 800ce06: d01d         	beq	0x800ce44 <spi_context_cs_configure_all+0x68> @ imm = #0x3a
 800ce08: 2301         	movs	r3, #0x1
 800ce0a: 73fb         	strb	r3, [r7, #0xf]
 800ce0c: 7bfb         	ldrb	r3, [r7, #0xf]
 800ce0e: f083 0301    	eor	r3, r3, #0x1
 800ce12: b2db         	uxtb	r3, r3
 800ce14: 2b00         	cmp	r3, #0x0
 800ce16: d115         	bne	0x800ce44 <spi_context_cs_configure_all+0x68> @ imm = #0x2a
 800ce18: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800ce84 <spi_context_cs_configure_all+0xa8>
 800ce1a: 6819         	ldr	r1, [r3]
 800ce1c: 697b         	ldr	r3, [r7, #0x14]
 800ce1e: 681b         	ldr	r3, [r3]
 800ce20: 681b         	ldr	r3, [r3]
 800ce22: 697a         	ldr	r2, [r7, #0x14]
 800ce24: 7912         	ldrb	r2, [r2, #0x4]
 800ce26: 9204         	str	r2, [sp, #0x10]
 800ce28: 9303         	str	r3, [sp, #0xc]
 800ce2a: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800ce88 <spi_context_cs_configure_all+0xac>
 800ce2c: 9302         	str	r3, [sp, #0x8]
 800ce2e: 2300         	movs	r3, #0x0
 800ce30: 9301         	str	r3, [sp, #0x4]
 800ce32: 2300         	movs	r3, #0x0
 800ce34: 9300         	str	r3, [sp]
 800ce36: 2300         	movs	r3, #0x0
 800ce38: 2201         	movs	r2, #0x1
 800ce3a: 2000         	movs	r0, #0x0
 800ce3c: f010 f872    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0x100e4
 800ce40: 2300         	movs	r3, #0x0
 800ce42: 60bb         	str	r3, [r7, #0x8]
; 			return -ENODEV;
 800ce44: f06f 0312    	mvn	r3, #0x12
 800ce48: e017         	b	0x800ce7a <spi_context_cs_configure_all+0x9e> @ imm = #0x2e
; 		ret = gpio_pin_configure_dt(cs_gpio, GPIO_OUTPUT_INACTIVE);
 800ce4a: f44f 11b0    	mov.w	r1, #0x160000
 800ce4e: 6978         	ldr	r0, [r7, #0x14]
 800ce50: f010 fae8    	bl	0x801d424 <gpio_pin_configure_dt> @ imm = #0x105d0
 800ce54: 6138         	str	r0, [r7, #0x10]
; 		if (ret < 0) {
 800ce56: 693b         	ldr	r3, [r7, #0x10]
 800ce58: 2b00         	cmp	r3, #0x0
 800ce5a: da01         	bge	0x800ce60 <spi_context_cs_configure_all+0x84> @ imm = #0x2
; 			return ret;
 800ce5c: 693b         	ldr	r3, [r7, #0x10]
 800ce5e: e00c         	b	0x800ce7a <spi_context_cs_configure_all+0x9e> @ imm = #0x18
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 800ce60: 697b         	ldr	r3, [r7, #0x14]
 800ce62: 3308         	adds	r3, #0x8
 800ce64: 617b         	str	r3, [r7, #0x14]
 800ce66: 687b         	ldr	r3, [r7, #0x4]
 800ce68: 689a         	ldr	r2, [r3, #0x8]
 800ce6a: 687b         	ldr	r3, [r7, #0x4]
 800ce6c: 68db         	ldr	r3, [r3, #0xc]
 800ce6e: 00db         	lsls	r3, r3, #0x3
 800ce70: 4413         	add	r3, r2
 800ce72: 697a         	ldr	r2, [r7, #0x14]
 800ce74: 429a         	cmp	r2, r3
 800ce76: d3b9         	blo	0x800cdec <spi_context_cs_configure_all+0x10> @ imm = #-0x8e
; 	return 0;
 800ce78: 2300         	movs	r3, #0x0
; }
 800ce7a: 4618         	mov	r0, r3
 800ce7c: 3718         	adds	r7, #0x18
 800ce7e: 46bd         	mov	sp, r7
 800ce80: bd80         	pop	{r7, pc}
 800ce82: bf00         	nop

0800ce84 <$d>:
 800ce84: 90 05 00 20  	.word	0x20000590
 800ce88: 10 1d 02 08  	.word	0x08021d10

0800ce8c <spi_context_buffers_setup>:
; {
 800ce8c: b5f0         	push	{r4, r5, r6, r7, lr}
 800ce8e: b097         	sub	sp, #0x5c
 800ce90: af0c         	add	r7, sp, #0x30
 800ce92: 6178         	str	r0, [r7, #0x14]
 800ce94: 6139         	str	r1, [r7, #0x10]
 800ce96: 60fa         	str	r2, [r7, #0xc]
 800ce98: 72fb         	strb	r3, [r7, #0xb]
; 	LOG_DBG("tx_bufs %p - rx_bufs %p - %u", tx_bufs, rx_bufs, dfs);
 800ce9a: 2303         	movs	r3, #0x3
 800ce9c: 2b03         	cmp	r3, #0x3
 800ce9e: d920         	bls	0x800cee2 <spi_context_buffers_setup+0x56> @ imm = #0x40
 800cea0: 2301         	movs	r3, #0x1
 800cea2: f887 3023    	strb.w	r3, [r7, #0x23]
 800cea6: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800ceaa: f083 0301    	eor	r3, r3, #0x1
 800ceae: b2db         	uxtb	r3, r3
 800ceb0: 2b00         	cmp	r3, #0x0
 800ceb2: d116         	bne	0x800cee2 <spi_context_buffers_setup+0x56> @ imm = #0x2c
 800ceb4: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x800cff0 <spi_context_buffers_setup+0x164>
 800ceb6: 6819         	ldr	r1, [r3]
 800ceb8: 7afb         	ldrb	r3, [r7, #0xb]
 800ceba: 9306         	str	r3, [sp, #0x18]
 800cebc: 68fb         	ldr	r3, [r7, #0xc]
 800cebe: 9305         	str	r3, [sp, #0x14]
 800cec0: 693b         	ldr	r3, [r7, #0x10]
 800cec2: 9304         	str	r3, [sp, #0x10]
 800cec4: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800cff4 <spi_context_buffers_setup+0x168>
 800cec6: 9303         	str	r3, [sp, #0xc]
 800cec8: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800cff8 <spi_context_buffers_setup+0x16c>
 800ceca: 9302         	str	r3, [sp, #0x8]
 800cecc: 2308         	movs	r3, #0x8
 800cece: 9301         	str	r3, [sp, #0x4]
 800ced0: 2300         	movs	r3, #0x0
 800ced2: 9300         	str	r3, [sp]
 800ced4: 2300         	movs	r3, #0x0
 800ced6: 2204         	movs	r2, #0x4
 800ced8: 2000         	movs	r0, #0x0
 800ceda: f010 f823    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0x10046
 800cede: 2300         	movs	r3, #0x0
 800cee0: 627b         	str	r3, [r7, #0x24]
; 	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
 800cee2: 693b         	ldr	r3, [r7, #0x10]
 800cee4: 2b00         	cmp	r3, #0x0
 800cee6: d002         	beq	0x800ceee <spi_context_buffers_setup+0x62> @ imm = #0x4
 800cee8: 693b         	ldr	r3, [r7, #0x10]
 800ceea: 681b         	ldr	r3, [r3]
 800ceec: e000         	b	0x800cef0 <spi_context_buffers_setup+0x64> @ imm = #0x0
 800ceee: 2300         	movs	r3, #0x0
 800cef0: 697a         	ldr	r2, [r7, #0x14]
 800cef2: 6353         	str	r3, [r2, #0x34]
; 	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
 800cef4: 697b         	ldr	r3, [r7, #0x14]
 800cef6: 6b5b         	ldr	r3, [r3, #0x34]
 800cef8: 2b00         	cmp	r3, #0x0
 800cefa: d002         	beq	0x800cf02 <spi_context_buffers_setup+0x76> @ imm = #0x4
 800cefc: 693b         	ldr	r3, [r7, #0x10]
 800cefe: 685b         	ldr	r3, [r3, #0x4]
 800cf00: e000         	b	0x800cf04 <spi_context_buffers_setup+0x78> @ imm = #0x0
 800cf02: 2300         	movs	r3, #0x0
 800cf04: 697a         	ldr	r2, [r7, #0x14]
 800cf06: 6393         	str	r3, [r2, #0x38]
; 		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
 800cf08: 697b         	ldr	r3, [r7, #0x14]
 800cf0a: f103 0034    	add.w	r0, r3, #0x34
 800cf0e: 697b         	ldr	r3, [r7, #0x14]
 800cf10: f103 0138    	add.w	r1, r3, #0x38
 800cf14: 697b         	ldr	r3, [r7, #0x14]
 800cf16: f103 0248    	add.w	r2, r3, #0x48
 800cf1a: 7afb         	ldrb	r3, [r7, #0xb]
 800cf1c: f010 fc8b    	bl	0x801d836 <spi_context_get_next_buf> @ imm = #0x10916
 800cf20: 4602         	mov	r2, r0
; 	ctx->tx_buf = (const uint8_t *)
 800cf22: 697b         	ldr	r3, [r7, #0x14]
 800cf24: 645a         	str	r2, [r3, #0x44]
; 	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
 800cf26: 68fb         	ldr	r3, [r7, #0xc]
 800cf28: 2b00         	cmp	r3, #0x0
 800cf2a: d002         	beq	0x800cf32 <spi_context_buffers_setup+0xa6> @ imm = #0x4
 800cf2c: 68fb         	ldr	r3, [r7, #0xc]
 800cf2e: 681b         	ldr	r3, [r3]
 800cf30: e000         	b	0x800cf34 <spi_context_buffers_setup+0xa8> @ imm = #0x0
 800cf32: 2300         	movs	r3, #0x0
 800cf34: 697a         	ldr	r2, [r7, #0x14]
 800cf36: 63d3         	str	r3, [r2, #0x3c]
; 	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
 800cf38: 697b         	ldr	r3, [r7, #0x14]
 800cf3a: 6bdb         	ldr	r3, [r3, #0x3c]
 800cf3c: 2b00         	cmp	r3, #0x0
 800cf3e: d002         	beq	0x800cf46 <spi_context_buffers_setup+0xba> @ imm = #0x4
 800cf40: 68fb         	ldr	r3, [r7, #0xc]
 800cf42: 685b         	ldr	r3, [r3, #0x4]
 800cf44: e000         	b	0x800cf48 <spi_context_buffers_setup+0xbc> @ imm = #0x0
 800cf46: 2300         	movs	r3, #0x0
 800cf48: 697a         	ldr	r2, [r7, #0x14]
 800cf4a: 6413         	str	r3, [r2, #0x40]
; 		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
 800cf4c: 697b         	ldr	r3, [r7, #0x14]
 800cf4e: f103 003c    	add.w	r0, r3, #0x3c
 800cf52: 697b         	ldr	r3, [r7, #0x14]
 800cf54: f103 0140    	add.w	r1, r3, #0x40
 800cf58: 697b         	ldr	r3, [r7, #0x14]
 800cf5a: f103 0250    	add.w	r2, r3, #0x50
 800cf5e: 7afb         	ldrb	r3, [r7, #0xb]
 800cf60: f010 fc69    	bl	0x801d836 <spi_context_get_next_buf> @ imm = #0x108d2
 800cf64: 4602         	mov	r2, r0
; 	ctx->rx_buf = (uint8_t *)
 800cf66: 697b         	ldr	r3, [r7, #0x14]
 800cf68: 64da         	str	r2, [r3, #0x4c]
; 	ctx->sync_status = 0;
 800cf6a: 697b         	ldr	r3, [r7, #0x14]
 800cf6c: 2200         	movs	r2, #0x0
 800cf6e: 631a         	str	r2, [r3, #0x30]
; 	LOG_DBG("current_tx %p (%zu), current_rx %p (%zu),"
 800cf70: 2303         	movs	r3, #0x3
 800cf72: 2b03         	cmp	r3, #0x3
 800cf74: d937         	bls	0x800cfe6 <spi_context_buffers_setup+0x15a> @ imm = #0x6e
 800cf76: 2301         	movs	r3, #0x1
 800cf78: f887 3022    	strb.w	r3, [r7, #0x22]
 800cf7c: f897 3022    	ldrb.w	r3, [r7, #0x22]
 800cf80: f083 0301    	eor	r3, r3, #0x1
 800cf84: b2db         	uxtb	r3, r3
 800cf86: 2b00         	cmp	r3, #0x0
 800cf88: d12d         	bne	0x800cfe6 <spi_context_buffers_setup+0x15a> @ imm = #0x5a
 800cf8a: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800cff0 <spi_context_buffers_setup+0x164>
 800cf8c: 681b         	ldr	r3, [r3]
 800cf8e: 607b         	str	r3, [r7, #0x4]
 800cf90: 697b         	ldr	r3, [r7, #0x14]
 800cf92: 6b5b         	ldr	r3, [r3, #0x34]
 800cf94: 697a         	ldr	r2, [r7, #0x14]
 800cf96: 6b92         	ldr	r2, [r2, #0x38]
 800cf98: 603a         	str	r2, [r7]
 800cf9a: 6979         	ldr	r1, [r7, #0x14]
 800cf9c: 6bc9         	ldr	r1, [r1, #0x3c]
 800cf9e: 6978         	ldr	r0, [r7, #0x14]
 800cfa0: 6c00         	ldr	r0, [r0, #0x40]
 800cfa2: 697c         	ldr	r4, [r7, #0x14]
 800cfa4: 6c64         	ldr	r4, [r4, #0x44]
 800cfa6: 697d         	ldr	r5, [r7, #0x14]
 800cfa8: 6cad         	ldr	r5, [r5, #0x48]
 800cfaa: 697e         	ldr	r6, [r7, #0x14]
 800cfac: 6cf6         	ldr	r6, [r6, #0x4c]
 800cfae: 697a         	ldr	r2, [r7, #0x14]
 800cfb0: 6d12         	ldr	r2, [r2, #0x50]
 800cfb2: 920b         	str	r2, [sp, #0x2c]
 800cfb4: 960a         	str	r6, [sp, #0x28]
 800cfb6: 9509         	str	r5, [sp, #0x24]
 800cfb8: 9408         	str	r4, [sp, #0x20]
 800cfba: 9007         	str	r0, [sp, #0x1c]
 800cfbc: 9106         	str	r1, [sp, #0x18]
 800cfbe: 683a         	ldr	r2, [r7]
 800cfc0: 9205         	str	r2, [sp, #0x14]
 800cfc2: 9304         	str	r3, [sp, #0x10]
 800cfc4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800cff4 <spi_context_buffers_setup+0x168>
 800cfc6: 9303         	str	r3, [sp, #0xc]
 800cfc8: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800cffc <spi_context_buffers_setup+0x170>
 800cfca: 9302         	str	r3, [sp, #0x8]
 800cfcc: 2308         	movs	r3, #0x8
 800cfce: 9301         	str	r3, [sp, #0x4]
 800cfd0: 2300         	movs	r3, #0x0
 800cfd2: 9300         	str	r3, [sp]
 800cfd4: 2300         	movs	r3, #0x0
 800cfd6: 2204         	movs	r2, #0x4
 800cfd8: 6879         	ldr	r1, [r7, #0x4]
 800cfda: 2000         	movs	r0, #0x0
 800cfdc: f00f ffa2    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xff44
 800cfe0: 2300         	movs	r3, #0x0
 800cfe2: 61fb         	str	r3, [r7, #0x1c]
; }
 800cfe4: bf00         	nop
 800cfe6: bf00         	nop
 800cfe8: 372c         	adds	r7, #0x2c
 800cfea: 46bd         	mov	sp, r7
 800cfec: bdf0         	pop	{r4, r5, r6, r7, pc}
 800cfee: bf00         	nop

0800cff0 <$d>:
 800cff0: 90 05 00 20  	.word	0x20000590
 800cff4: 4c 2e 02 08  	.word	0x08022e4c
 800cff8: 34 1d 02 08  	.word	0x08021d34
 800cffc: 58 1d 02 08  	.word	0x08021d58

0800d000 <spi_stm32_send_next_frame>:
; {
 800d000: b580         	push	{r7, lr}
 800d002: b09c         	sub	sp, #0x70
 800d004: af06         	add	r7, sp, #0x18
 800d006: 6078         	str	r0, [r7, #0x4]
 800d008: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 800d00a: 683b         	ldr	r3, [r7]
 800d00c: 681b         	ldr	r3, [r3]
 800d00e: 889b         	ldrh	r3, [r3, #0x4]
 800d010: 095b         	lsrs	r3, r3, #0x5
 800d012: b2db         	uxtb	r3, r3
 800d014: f003 033f    	and	r3, r3, #0x3f
 800d018: f887 3053    	strb.w	r3, [r7, #0x53]
; 	uint32_t tx_frame = SPI_STM32_TX_NOP;
 800d01c: 2300         	movs	r3, #0x0
 800d01e: 657b         	str	r3, [r7, #0x54]
; 	if (frame_size == 8) {
 800d020: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800d024: 2b08         	cmp	r3, #0x8
 800d026: f040 80a8    	bne.w	0x800d17a <spi_stm32_send_next_frame+0x17a> @ imm = #0x150
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800d02a: 683b         	ldr	r3, [r7]
 800d02c: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 800d02e: 6c7b         	ldr	r3, [r7, #0x44]
 800d030: 6c5b         	ldr	r3, [r3, #0x44]
 800d032: 2b00         	cmp	r3, #0x0
 800d034: d005         	beq	0x800d042 <spi_stm32_send_next_frame+0x42> @ imm = #0xa
 800d036: 6c7b         	ldr	r3, [r7, #0x44]
 800d038: 6c9b         	ldr	r3, [r3, #0x48]
 800d03a: 2b00         	cmp	r3, #0x0
 800d03c: d001         	beq	0x800d042 <spi_stm32_send_next_frame+0x42> @ imm = #0x2
 800d03e: 2301         	movs	r3, #0x1
 800d040: e000         	b	0x800d044 <spi_stm32_send_next_frame+0x44> @ imm = #0x0
 800d042: 2300         	movs	r3, #0x0
 800d044: f003 0301    	and	r3, r3, #0x1
 800d048: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800d04a: 2b00         	cmp	r3, #0x0
 800d04c: d005         	beq	0x800d05a <spi_stm32_send_next_frame+0x5a> @ imm = #0xa
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 800d04e: 683b         	ldr	r3, [r7]
 800d050: 6c5b         	ldr	r3, [r3, #0x44]
 800d052: 64bb         	str	r3, [r7, #0x48]
 800d054: 6cbb         	ldr	r3, [r7, #0x48]
 800d056: 781b         	ldrb	r3, [r3]
 800d058: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData8(spi, tx_frame);
 800d05a: 6d7b         	ldr	r3, [r7, #0x54]
 800d05c: b2db         	uxtb	r3, r3
 800d05e: 4619         	mov	r1, r3
 800d060: 6878         	ldr	r0, [r7, #0x4]
 800d062: f010 f970    	bl	0x801d346 <LL_SPI_TransmitData8> @ imm = #0x102e0
; 		spi_context_update_tx(&data->ctx, 1, 1);
 800d066: 683b         	ldr	r3, [r7]
 800d068: 643b         	str	r3, [r7, #0x40]
 800d06a: 2301         	movs	r3, #0x1
 800d06c: f887 303f    	strb.w	r3, [r7, #0x3f]
 800d070: 2301         	movs	r3, #0x1
 800d072: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->tx_len) {
 800d074: 6c3b         	ldr	r3, [r7, #0x40]
 800d076: 6c9b         	ldr	r3, [r3, #0x48]
 800d078: 2b00         	cmp	r3, #0x0
 800d07a: f000 811d    	beq.w	0x800d2b8 <spi_stm32_send_next_frame+0x2b8> @ imm = #0x23a
; 	if (len > ctx->tx_len) {
 800d07e: 6c3b         	ldr	r3, [r7, #0x40]
 800d080: 6c9b         	ldr	r3, [r3, #0x48]
 800d082: 6bba         	ldr	r2, [r7, #0x38]
 800d084: 429a         	cmp	r2, r3
 800d086: d91d         	bls	0x800d0c4 <spi_stm32_send_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800d088: 2303         	movs	r3, #0x3
 800d08a: 2b00         	cmp	r3, #0x0
 800d08c: d019         	beq	0x800d0c2 <spi_stm32_send_next_frame+0xc2> @ imm = #0x32
 800d08e: 2301         	movs	r3, #0x1
 800d090: f887 3037    	strb.w	r3, [r7, #0x37]
 800d094: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800d098: f083 0301    	eor	r3, r3, #0x1
 800d09c: b2db         	uxtb	r3, r3
 800d09e: 2b00         	cmp	r3, #0x0
 800d0a0: d10f         	bne	0x800d0c2 <spi_stm32_send_next_frame+0xc2> @ imm = #0x1e
 800d0a2: 4b89         	ldr	r3, [pc, #0x224]        @ 0x800d2c8 <spi_stm32_send_next_frame+0x2c8>
 800d0a4: 6819         	ldr	r1, [r3]
 800d0a6: 4b89         	ldr	r3, [pc, #0x224]        @ 0x800d2cc <spi_stm32_send_next_frame+0x2cc>
 800d0a8: 9302         	str	r3, [sp, #0x8]
 800d0aa: 2300         	movs	r3, #0x0
 800d0ac: 9301         	str	r3, [sp, #0x4]
 800d0ae: 2300         	movs	r3, #0x0
 800d0b0: 9300         	str	r3, [sp]
 800d0b2: 2300         	movs	r3, #0x0
 800d0b4: 2201         	movs	r2, #0x1
 800d0b6: 2000         	movs	r0, #0x0
 800d0b8: f00f ff34    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xfe68
 800d0bc: 2300         	movs	r3, #0x0
 800d0be: 633b         	str	r3, [r7, #0x30]
; 		return;
 800d0c0: e0fd         	b	0x800d2be <spi_stm32_send_next_frame+0x2be> @ imm = #0x1fa
 800d0c2: e0fc         	b	0x800d2be <spi_stm32_send_next_frame+0x2be> @ imm = #0x1f8
; 	ctx->tx_len -= len;
 800d0c4: 6c3b         	ldr	r3, [r7, #0x40]
 800d0c6: 6c9a         	ldr	r2, [r3, #0x48]
 800d0c8: 6bbb         	ldr	r3, [r7, #0x38]
 800d0ca: 1ad2         	subs	r2, r2, r3
 800d0cc: 6c3b         	ldr	r3, [r7, #0x40]
 800d0ce: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800d0d0: 6c3b         	ldr	r3, [r7, #0x40]
 800d0d2: 6c9b         	ldr	r3, [r3, #0x48]
 800d0d4: 2b00         	cmp	r3, #0x0
 800d0d6: d11b         	bne	0x800d110 <spi_stm32_send_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_tx;
 800d0d8: 6c3b         	ldr	r3, [r7, #0x40]
 800d0da: 6b5b         	ldr	r3, [r3, #0x34]
 800d0dc: f103 0208    	add.w	r2, r3, #0x8
 800d0e0: 6c3b         	ldr	r3, [r7, #0x40]
 800d0e2: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800d0e4: 6c3b         	ldr	r3, [r7, #0x40]
 800d0e6: 6b9b         	ldr	r3, [r3, #0x38]
 800d0e8: 1e5a         	subs	r2, r3, #0x1
 800d0ea: 6c3b         	ldr	r3, [r7, #0x40]
 800d0ec: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800d0ee: 6c3b         	ldr	r3, [r7, #0x40]
 800d0f0: f103 0034    	add.w	r0, r3, #0x34
 800d0f4: 6c3b         	ldr	r3, [r7, #0x40]
 800d0f6: f103 0138    	add.w	r1, r3, #0x38
 800d0fa: 6c3b         	ldr	r3, [r7, #0x40]
 800d0fc: f103 0248    	add.w	r2, r3, #0x48
 800d100: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800d104: f010 fb97    	bl	0x801d836 <spi_context_get_next_buf> @ imm = #0x1072e
 800d108: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800d10a: 6c3b         	ldr	r3, [r7, #0x40]
 800d10c: 645a         	str	r2, [r3, #0x44]
 800d10e: e00d         	b	0x800d12c <spi_stm32_send_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 800d110: 6c3b         	ldr	r3, [r7, #0x40]
 800d112: 6c5b         	ldr	r3, [r3, #0x44]
 800d114: 2b00         	cmp	r3, #0x0
 800d116: d009         	beq	0x800d12c <spi_stm32_send_next_frame+0x12c> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 800d118: 6c3b         	ldr	r3, [r7, #0x40]
 800d11a: 6c5a         	ldr	r2, [r3, #0x44]
 800d11c: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800d120: 6bb9         	ldr	r1, [r7, #0x38]
 800d122: fb01 f303    	mul	r3, r1, r3
 800d126: 441a         	add	r2, r3
 800d128: 6c3b         	ldr	r3, [r7, #0x40]
 800d12a: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800d12c: 2303         	movs	r3, #0x3
 800d12e: 2b03         	cmp	r3, #0x3
 800d130: f240 80c5    	bls.w	0x800d2be <spi_stm32_send_next_frame+0x2be> @ imm = #0x18a
 800d134: 2301         	movs	r3, #0x1
 800d136: f887 302f    	strb.w	r3, [r7, #0x2f]
 800d13a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800d13e: f083 0301    	eor	r3, r3, #0x1
 800d142: b2db         	uxtb	r3, r3
 800d144: 2b00         	cmp	r3, #0x0
 800d146: f040 80ba    	bne.w	0x800d2be <spi_stm32_send_next_frame+0x2be> @ imm = #0x174
 800d14a: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x800d2c8 <spi_stm32_send_next_frame+0x2c8>
 800d14c: 6819         	ldr	r1, [r3]
 800d14e: 6c3b         	ldr	r3, [r7, #0x40]
 800d150: 6c5b         	ldr	r3, [r3, #0x44]
 800d152: 6c3a         	ldr	r2, [r7, #0x40]
 800d154: 6c92         	ldr	r2, [r2, #0x48]
 800d156: 9205         	str	r2, [sp, #0x14]
 800d158: 9304         	str	r3, [sp, #0x10]
 800d15a: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x800d2d0 <spi_stm32_send_next_frame+0x2d0>
 800d15c: 9303         	str	r3, [sp, #0xc]
 800d15e: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x800d2d4 <spi_stm32_send_next_frame+0x2d4>
 800d160: 9302         	str	r3, [sp, #0x8]
 800d162: 2308         	movs	r3, #0x8
 800d164: 9301         	str	r3, [sp, #0x4]
 800d166: 2300         	movs	r3, #0x0
 800d168: 9300         	str	r3, [sp]
 800d16a: 2300         	movs	r3, #0x0
 800d16c: 2204         	movs	r2, #0x4
 800d16e: 2000         	movs	r0, #0x0
 800d170: f00f fed8    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xfdb0
 800d174: 2300         	movs	r3, #0x0
 800d176: 62bb         	str	r3, [r7, #0x28]
; }
 800d178: e0a1         	b	0x800d2be <spi_stm32_send_next_frame+0x2be> @ imm = #0x142
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800d17a: 683b         	ldr	r3, [r7]
 800d17c: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 800d17e: 6a7b         	ldr	r3, [r7, #0x24]
 800d180: 6c5b         	ldr	r3, [r3, #0x44]
 800d182: 2b00         	cmp	r3, #0x0
 800d184: d005         	beq	0x800d192 <spi_stm32_send_next_frame+0x192> @ imm = #0xa
 800d186: 6a7b         	ldr	r3, [r7, #0x24]
 800d188: 6c9b         	ldr	r3, [r3, #0x48]
 800d18a: 2b00         	cmp	r3, #0x0
 800d18c: d001         	beq	0x800d192 <spi_stm32_send_next_frame+0x192> @ imm = #0x2
 800d18e: 2301         	movs	r3, #0x1
 800d190: e000         	b	0x800d194 <spi_stm32_send_next_frame+0x194> @ imm = #0x0
 800d192: 2300         	movs	r3, #0x0
 800d194: f003 0301    	and	r3, r3, #0x1
 800d198: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 800d19a: 2b00         	cmp	r3, #0x0
 800d19c: d006         	beq	0x800d1ac <spi_stm32_send_next_frame+0x1ac> @ imm = #0xc
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 800d19e: 683b         	ldr	r3, [r7]
 800d1a0: 6c5b         	ldr	r3, [r3, #0x44]
 800d1a2: 64fb         	str	r3, [r7, #0x4c]
 800d1a4: 6cfb         	ldr	r3, [r7, #0x4c]
 800d1a6: 881b         	ldrh	r3, [r3]
 800d1a8: b29b         	uxth	r3, r3
 800d1aa: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData16(spi, tx_frame);
 800d1ac: 6d7b         	ldr	r3, [r7, #0x54]
 800d1ae: b29b         	uxth	r3, r3
 800d1b0: 4619         	mov	r1, r3
 800d1b2: 6878         	ldr	r0, [r7, #0x4]
 800d1b4: f010 f8d9    	bl	0x801d36a <LL_SPI_TransmitData16> @ imm = #0x101b2
; 		spi_context_update_tx(&data->ctx, 2, 1);
 800d1b8: 683b         	ldr	r3, [r7]
 800d1ba: 623b         	str	r3, [r7, #0x20]
 800d1bc: 2302         	movs	r3, #0x2
 800d1be: 77fb         	strb	r3, [r7, #0x1f]
 800d1c0: 2301         	movs	r3, #0x1
 800d1c2: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->tx_len) {
 800d1c4: 6a3b         	ldr	r3, [r7, #0x20]
 800d1c6: 6c9b         	ldr	r3, [r3, #0x48]
 800d1c8: 2b00         	cmp	r3, #0x0
 800d1ca: d077         	beq	0x800d2bc <spi_stm32_send_next_frame+0x2bc> @ imm = #0xee
; 	if (len > ctx->tx_len) {
 800d1cc: 6a3b         	ldr	r3, [r7, #0x20]
 800d1ce: 6c9b         	ldr	r3, [r3, #0x48]
 800d1d0: 69ba         	ldr	r2, [r7, #0x18]
 800d1d2: 429a         	cmp	r2, r3
 800d1d4: d91b         	bls	0x800d20e <spi_stm32_send_next_frame+0x20e> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 800d1d6: 2303         	movs	r3, #0x3
 800d1d8: 2b00         	cmp	r3, #0x0
 800d1da: d017         	beq	0x800d20c <spi_stm32_send_next_frame+0x20c> @ imm = #0x2e
 800d1dc: 2301         	movs	r3, #0x1
 800d1de: 75fb         	strb	r3, [r7, #0x17]
 800d1e0: 7dfb         	ldrb	r3, [r7, #0x17]
 800d1e2: f083 0301    	eor	r3, r3, #0x1
 800d1e6: b2db         	uxtb	r3, r3
 800d1e8: 2b00         	cmp	r3, #0x0
 800d1ea: d10f         	bne	0x800d20c <spi_stm32_send_next_frame+0x20c> @ imm = #0x1e
 800d1ec: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800d2c8 <spi_stm32_send_next_frame+0x2c8>
 800d1ee: 6819         	ldr	r1, [r3]
 800d1f0: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800d2cc <spi_stm32_send_next_frame+0x2cc>
 800d1f2: 9302         	str	r3, [sp, #0x8]
 800d1f4: 2300         	movs	r3, #0x0
 800d1f6: 9301         	str	r3, [sp, #0x4]
 800d1f8: 2300         	movs	r3, #0x0
 800d1fa: 9300         	str	r3, [sp]
 800d1fc: 2300         	movs	r3, #0x0
 800d1fe: 2201         	movs	r2, #0x1
 800d200: 2000         	movs	r0, #0x0
 800d202: f00f fe8f    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xfd1e
 800d206: 2300         	movs	r3, #0x0
 800d208: 613b         	str	r3, [r7, #0x10]
; 		return;
 800d20a: e058         	b	0x800d2be <spi_stm32_send_next_frame+0x2be> @ imm = #0xb0
 800d20c: e057         	b	0x800d2be <spi_stm32_send_next_frame+0x2be> @ imm = #0xae
; 	ctx->tx_len -= len;
 800d20e: 6a3b         	ldr	r3, [r7, #0x20]
 800d210: 6c9a         	ldr	r2, [r3, #0x48]
 800d212: 69bb         	ldr	r3, [r7, #0x18]
 800d214: 1ad2         	subs	r2, r2, r3
 800d216: 6a3b         	ldr	r3, [r7, #0x20]
 800d218: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800d21a: 6a3b         	ldr	r3, [r7, #0x20]
 800d21c: 6c9b         	ldr	r3, [r3, #0x48]
 800d21e: 2b00         	cmp	r3, #0x0
 800d220: d11a         	bne	0x800d258 <spi_stm32_send_next_frame+0x258> @ imm = #0x34
; 		++ctx->current_tx;
 800d222: 6a3b         	ldr	r3, [r7, #0x20]
 800d224: 6b5b         	ldr	r3, [r3, #0x34]
 800d226: f103 0208    	add.w	r2, r3, #0x8
 800d22a: 6a3b         	ldr	r3, [r7, #0x20]
 800d22c: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800d22e: 6a3b         	ldr	r3, [r7, #0x20]
 800d230: 6b9b         	ldr	r3, [r3, #0x38]
 800d232: 1e5a         	subs	r2, r3, #0x1
 800d234: 6a3b         	ldr	r3, [r7, #0x20]
 800d236: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800d238: 6a3b         	ldr	r3, [r7, #0x20]
 800d23a: f103 0034    	add.w	r0, r3, #0x34
 800d23e: 6a3b         	ldr	r3, [r7, #0x20]
 800d240: f103 0138    	add.w	r1, r3, #0x38
 800d244: 6a3b         	ldr	r3, [r7, #0x20]
 800d246: f103 0248    	add.w	r2, r3, #0x48
 800d24a: 7ffb         	ldrb	r3, [r7, #0x1f]
 800d24c: f010 faf3    	bl	0x801d836 <spi_context_get_next_buf> @ imm = #0x105e6
 800d250: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800d252: 6a3b         	ldr	r3, [r7, #0x20]
 800d254: 645a         	str	r2, [r3, #0x44]
 800d256: e00c         	b	0x800d272 <spi_stm32_send_next_frame+0x272> @ imm = #0x18
; 	} else if (ctx->tx_buf) {
 800d258: 6a3b         	ldr	r3, [r7, #0x20]
 800d25a: 6c5b         	ldr	r3, [r3, #0x44]
 800d25c: 2b00         	cmp	r3, #0x0
 800d25e: d008         	beq	0x800d272 <spi_stm32_send_next_frame+0x272> @ imm = #0x10
; 		ctx->tx_buf += dfs * len;
 800d260: 6a3b         	ldr	r3, [r7, #0x20]
 800d262: 6c5a         	ldr	r2, [r3, #0x44]
 800d264: 7ffb         	ldrb	r3, [r7, #0x1f]
 800d266: 69b9         	ldr	r1, [r7, #0x18]
 800d268: fb01 f303    	mul	r3, r1, r3
 800d26c: 441a         	add	r2, r3
 800d26e: 6a3b         	ldr	r3, [r7, #0x20]
 800d270: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800d272: 2303         	movs	r3, #0x3
 800d274: 2b03         	cmp	r3, #0x3
 800d276: d922         	bls	0x800d2be <spi_stm32_send_next_frame+0x2be> @ imm = #0x44
 800d278: 2301         	movs	r3, #0x1
 800d27a: 73fb         	strb	r3, [r7, #0xf]
 800d27c: 7bfb         	ldrb	r3, [r7, #0xf]
 800d27e: f083 0301    	eor	r3, r3, #0x1
 800d282: b2db         	uxtb	r3, r3
 800d284: 2b00         	cmp	r3, #0x0
 800d286: d11a         	bne	0x800d2be <spi_stm32_send_next_frame+0x2be> @ imm = #0x34
 800d288: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800d2c8 <spi_stm32_send_next_frame+0x2c8>
 800d28a: 6819         	ldr	r1, [r3]
 800d28c: 6a3b         	ldr	r3, [r7, #0x20]
 800d28e: 6c5b         	ldr	r3, [r3, #0x44]
 800d290: 6a3a         	ldr	r2, [r7, #0x20]
 800d292: 6c92         	ldr	r2, [r2, #0x48]
 800d294: 9205         	str	r2, [sp, #0x14]
 800d296: 9304         	str	r3, [sp, #0x10]
 800d298: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800d2d0 <spi_stm32_send_next_frame+0x2d0>
 800d29a: 9303         	str	r3, [sp, #0xc]
 800d29c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800d2d4 <spi_stm32_send_next_frame+0x2d4>
 800d29e: 9302         	str	r3, [sp, #0x8]
 800d2a0: 2308         	movs	r3, #0x8
 800d2a2: 9301         	str	r3, [sp, #0x4]
 800d2a4: 2300         	movs	r3, #0x0
 800d2a6: 9300         	str	r3, [sp]
 800d2a8: 2300         	movs	r3, #0x0
 800d2aa: 2204         	movs	r2, #0x4
 800d2ac: 2000         	movs	r0, #0x0
 800d2ae: f00f fe39    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xfc72
 800d2b2: 2300         	movs	r3, #0x0
 800d2b4: 60bb         	str	r3, [r7, #0x8]
; }
 800d2b6: e002         	b	0x800d2be <spi_stm32_send_next_frame+0x2be> @ imm = #0x4
; 		return;
 800d2b8: bf00         	nop
 800d2ba: e000         	b	0x800d2be <spi_stm32_send_next_frame+0x2be> @ imm = #0x0
 800d2bc: bf00         	nop
; }
 800d2be: bf00         	nop
 800d2c0: 3758         	adds	r7, #0x58
 800d2c2: 46bd         	mov	sp, r7
 800d2c4: bd80         	pop	{r7, pc}
 800d2c6: bf00         	nop

0800d2c8 <$d>:
 800d2c8: 90 05 00 20  	.word	0x20000590
 800d2cc: ac 1d 02 08  	.word	0x08021dac
 800d2d0: f4 2d 02 08  	.word	0x08022df4
 800d2d4: cc 1d 02 08  	.word	0x08021dcc

0800d2d8 <spi_stm32_read_next_frame>:
; {
 800d2d8: b580         	push	{r7, lr}
 800d2da: b09c         	sub	sp, #0x70
 800d2dc: af06         	add	r7, sp, #0x18
 800d2de: 6078         	str	r0, [r7, #0x4]
 800d2e0: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 800d2e2: 683b         	ldr	r3, [r7]
 800d2e4: 681b         	ldr	r3, [r3]
 800d2e6: 889b         	ldrh	r3, [r3, #0x4]
 800d2e8: 095b         	lsrs	r3, r3, #0x5
 800d2ea: b2db         	uxtb	r3, r3
 800d2ec: f003 033f    	and	r3, r3, #0x3f
 800d2f0: f887 3057    	strb.w	r3, [r7, #0x57]
; 	uint32_t rx_frame = 0;
 800d2f4: 2300         	movs	r3, #0x0
 800d2f6: 653b         	str	r3, [r7, #0x50]
; 	if (frame_size == 8) {
 800d2f8: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800d2fc: 2b08         	cmp	r3, #0x8
 800d2fe: f040 80a8    	bne.w	0x800d452 <spi_stm32_read_next_frame+0x17a> @ imm = #0x150
; 		rx_frame = LL_SPI_ReceiveData8(spi);
 800d302: 6878         	ldr	r0, [r7, #0x4]
 800d304: f010 f804    	bl	0x801d310 <LL_SPI_ReceiveData8> @ imm = #0x10008
 800d308: 4603         	mov	r3, r0
 800d30a: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800d30c: 683b         	ldr	r3, [r7]
 800d30e: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 800d310: 6c7b         	ldr	r3, [r7, #0x44]
 800d312: 6cdb         	ldr	r3, [r3, #0x4c]
 800d314: 2b00         	cmp	r3, #0x0
 800d316: d005         	beq	0x800d324 <spi_stm32_read_next_frame+0x4c> @ imm = #0xa
 800d318: 6c7b         	ldr	r3, [r7, #0x44]
 800d31a: 6d1b         	ldr	r3, [r3, #0x50]
 800d31c: 2b00         	cmp	r3, #0x0
 800d31e: d001         	beq	0x800d324 <spi_stm32_read_next_frame+0x4c> @ imm = #0x2
 800d320: 2301         	movs	r3, #0x1
 800d322: e000         	b	0x800d326 <spi_stm32_read_next_frame+0x4e> @ imm = #0x0
 800d324: 2300         	movs	r3, #0x0
 800d326: f003 0301    	and	r3, r3, #0x1
 800d32a: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800d32c: 2b00         	cmp	r3, #0x0
 800d32e: d006         	beq	0x800d33e <spi_stm32_read_next_frame+0x66> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 800d330: 683b         	ldr	r3, [r7]
 800d332: 6cdb         	ldr	r3, [r3, #0x4c]
 800d334: 64bb         	str	r3, [r7, #0x48]
 800d336: 6d3b         	ldr	r3, [r7, #0x50]
 800d338: b2da         	uxtb	r2, r3
 800d33a: 6cbb         	ldr	r3, [r7, #0x48]
 800d33c: 701a         	strb	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 1, 1);
 800d33e: 683b         	ldr	r3, [r7]
 800d340: 643b         	str	r3, [r7, #0x40]
 800d342: 2301         	movs	r3, #0x1
 800d344: f887 303f    	strb.w	r3, [r7, #0x3f]
 800d348: 2301         	movs	r3, #0x1
 800d34a: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->rx_len) {
 800d34c: 6c3b         	ldr	r3, [r7, #0x40]
 800d34e: 6d1b         	ldr	r3, [r3, #0x50]
 800d350: 2b00         	cmp	r3, #0x0
 800d352: f000 811c    	beq.w	0x800d58e <spi_stm32_read_next_frame+0x2b6> @ imm = #0x238
; 	if (len > ctx->rx_len) {
 800d356: 6c3b         	ldr	r3, [r7, #0x40]
 800d358: 6d1b         	ldr	r3, [r3, #0x50]
 800d35a: 6bba         	ldr	r2, [r7, #0x38]
 800d35c: 429a         	cmp	r2, r3
 800d35e: d91d         	bls	0x800d39c <spi_stm32_read_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800d360: 2303         	movs	r3, #0x3
 800d362: 2b00         	cmp	r3, #0x0
 800d364: d019         	beq	0x800d39a <spi_stm32_read_next_frame+0xc2> @ imm = #0x32
 800d366: 2301         	movs	r3, #0x1
 800d368: f887 3037    	strb.w	r3, [r7, #0x37]
 800d36c: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800d370: f083 0301    	eor	r3, r3, #0x1
 800d374: b2db         	uxtb	r3, r3
 800d376: 2b00         	cmp	r3, #0x0
 800d378: d10f         	bne	0x800d39a <spi_stm32_read_next_frame+0xc2> @ imm = #0x1e
 800d37a: 4b88         	ldr	r3, [pc, #0x220]        @ 0x800d59c <spi_stm32_read_next_frame+0x2c4>
 800d37c: 6819         	ldr	r1, [r3]
 800d37e: 4b88         	ldr	r3, [pc, #0x220]        @ 0x800d5a0 <spi_stm32_read_next_frame+0x2c8>
 800d380: 9302         	str	r3, [sp, #0x8]
 800d382: 2300         	movs	r3, #0x0
 800d384: 9301         	str	r3, [sp, #0x4]
 800d386: 2300         	movs	r3, #0x0
 800d388: 9300         	str	r3, [sp]
 800d38a: 2300         	movs	r3, #0x0
 800d38c: 2201         	movs	r2, #0x1
 800d38e: 2000         	movs	r0, #0x0
 800d390: f00f fdc8    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xfb90
 800d394: 2300         	movs	r3, #0x0
 800d396: 633b         	str	r3, [r7, #0x30]
; 		return;
 800d398: e0fc         	b	0x800d594 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f8
 800d39a: e0fb         	b	0x800d594 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f6
; 	ctx->rx_len -= len;
 800d39c: 6c3b         	ldr	r3, [r7, #0x40]
 800d39e: 6d1a         	ldr	r2, [r3, #0x50]
 800d3a0: 6bbb         	ldr	r3, [r7, #0x38]
 800d3a2: 1ad2         	subs	r2, r2, r3
 800d3a4: 6c3b         	ldr	r3, [r7, #0x40]
 800d3a6: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800d3a8: 6c3b         	ldr	r3, [r7, #0x40]
 800d3aa: 6d1b         	ldr	r3, [r3, #0x50]
 800d3ac: 2b00         	cmp	r3, #0x0
 800d3ae: d11b         	bne	0x800d3e8 <spi_stm32_read_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_rx;
 800d3b0: 6c3b         	ldr	r3, [r7, #0x40]
 800d3b2: 6bdb         	ldr	r3, [r3, #0x3c]
 800d3b4: f103 0208    	add.w	r2, r3, #0x8
 800d3b8: 6c3b         	ldr	r3, [r7, #0x40]
 800d3ba: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800d3bc: 6c3b         	ldr	r3, [r7, #0x40]
 800d3be: 6c1b         	ldr	r3, [r3, #0x40]
 800d3c0: 1e5a         	subs	r2, r3, #0x1
 800d3c2: 6c3b         	ldr	r3, [r7, #0x40]
 800d3c4: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800d3c6: 6c3b         	ldr	r3, [r7, #0x40]
 800d3c8: f103 003c    	add.w	r0, r3, #0x3c
 800d3cc: 6c3b         	ldr	r3, [r7, #0x40]
 800d3ce: f103 0140    	add.w	r1, r3, #0x40
 800d3d2: 6c3b         	ldr	r3, [r7, #0x40]
 800d3d4: f103 0250    	add.w	r2, r3, #0x50
 800d3d8: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800d3dc: f010 fa2b    	bl	0x801d836 <spi_context_get_next_buf> @ imm = #0x10456
 800d3e0: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800d3e2: 6c3b         	ldr	r3, [r7, #0x40]
 800d3e4: 64da         	str	r2, [r3, #0x4c]
 800d3e6: e00d         	b	0x800d404 <spi_stm32_read_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 800d3e8: 6c3b         	ldr	r3, [r7, #0x40]
 800d3ea: 6cdb         	ldr	r3, [r3, #0x4c]
 800d3ec: 2b00         	cmp	r3, #0x0
 800d3ee: d009         	beq	0x800d404 <spi_stm32_read_next_frame+0x12c> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 800d3f0: 6c3b         	ldr	r3, [r7, #0x40]
 800d3f2: 6cda         	ldr	r2, [r3, #0x4c]
 800d3f4: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800d3f8: 6bb9         	ldr	r1, [r7, #0x38]
 800d3fa: fb01 f303    	mul	r3, r1, r3
 800d3fe: 441a         	add	r2, r3
 800d400: 6c3b         	ldr	r3, [r7, #0x40]
 800d402: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800d404: 2303         	movs	r3, #0x3
 800d406: 2b03         	cmp	r3, #0x3
 800d408: f240 80c4    	bls.w	0x800d594 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x188
 800d40c: 2301         	movs	r3, #0x1
 800d40e: f887 302f    	strb.w	r3, [r7, #0x2f]
 800d412: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800d416: f083 0301    	eor	r3, r3, #0x1
 800d41a: b2db         	uxtb	r3, r3
 800d41c: 2b00         	cmp	r3, #0x0
 800d41e: f040 80b9    	bne.w	0x800d594 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x172
 800d422: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x800d59c <spi_stm32_read_next_frame+0x2c4>
 800d424: 6819         	ldr	r1, [r3]
 800d426: 6c3b         	ldr	r3, [r7, #0x40]
 800d428: 6cdb         	ldr	r3, [r3, #0x4c]
 800d42a: 6c3a         	ldr	r2, [r7, #0x40]
 800d42c: 6d12         	ldr	r2, [r2, #0x50]
 800d42e: 9205         	str	r2, [sp, #0x14]
 800d430: 9304         	str	r3, [sp, #0x10]
 800d432: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800d5a4 <spi_stm32_read_next_frame+0x2cc>
 800d434: 9303         	str	r3, [sp, #0xc]
 800d436: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800d5a8 <spi_stm32_read_next_frame+0x2d0>
 800d438: 9302         	str	r3, [sp, #0x8]
 800d43a: 2308         	movs	r3, #0x8
 800d43c: 9301         	str	r3, [sp, #0x4]
 800d43e: 2300         	movs	r3, #0x0
 800d440: 9300         	str	r3, [sp]
 800d442: 2300         	movs	r3, #0x0
 800d444: 2204         	movs	r2, #0x4
 800d446: 2000         	movs	r0, #0x0
 800d448: f00f fd6c    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xfad8
 800d44c: 2300         	movs	r3, #0x0
 800d44e: 62bb         	str	r3, [r7, #0x28]
; }
 800d450: e0a0         	b	0x800d594 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x140
; 		rx_frame = LL_SPI_ReceiveData16(spi);
 800d452: 6878         	ldr	r0, [r7, #0x4]
 800d454: f00f ff6a    	bl	0x801d32c <LL_SPI_ReceiveData16> @ imm = #0xfed4
 800d458: 4603         	mov	r3, r0
 800d45a: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800d45c: 683b         	ldr	r3, [r7]
 800d45e: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 800d460: 6a7b         	ldr	r3, [r7, #0x24]
 800d462: 6cdb         	ldr	r3, [r3, #0x4c]
 800d464: 2b00         	cmp	r3, #0x0
 800d466: d005         	beq	0x800d474 <spi_stm32_read_next_frame+0x19c> @ imm = #0xa
 800d468: 6a7b         	ldr	r3, [r7, #0x24]
 800d46a: 6d1b         	ldr	r3, [r3, #0x50]
 800d46c: 2b00         	cmp	r3, #0x0
 800d46e: d001         	beq	0x800d474 <spi_stm32_read_next_frame+0x19c> @ imm = #0x2
 800d470: 2301         	movs	r3, #0x1
 800d472: e000         	b	0x800d476 <spi_stm32_read_next_frame+0x19e> @ imm = #0x0
 800d474: 2300         	movs	r3, #0x0
 800d476: f003 0301    	and	r3, r3, #0x1
 800d47a: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 800d47c: 2b00         	cmp	r3, #0x0
 800d47e: d006         	beq	0x800d48e <spi_stm32_read_next_frame+0x1b6> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 800d480: 683b         	ldr	r3, [r7]
 800d482: 6cdb         	ldr	r3, [r3, #0x4c]
 800d484: 64fb         	str	r3, [r7, #0x4c]
 800d486: 6d3b         	ldr	r3, [r7, #0x50]
 800d488: b29a         	uxth	r2, r3
 800d48a: 6cfb         	ldr	r3, [r7, #0x4c]
 800d48c: 801a         	strh	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 2, 1);
 800d48e: 683b         	ldr	r3, [r7]
 800d490: 623b         	str	r3, [r7, #0x20]
 800d492: 2302         	movs	r3, #0x2
 800d494: 77fb         	strb	r3, [r7, #0x1f]
 800d496: 2301         	movs	r3, #0x1
 800d498: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 800d49a: 6a3b         	ldr	r3, [r7, #0x20]
 800d49c: 6d1b         	ldr	r3, [r3, #0x50]
 800d49e: 2b00         	cmp	r3, #0x0
 800d4a0: d077         	beq	0x800d592 <spi_stm32_read_next_frame+0x2ba> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 800d4a2: 6a3b         	ldr	r3, [r7, #0x20]
 800d4a4: 6d1b         	ldr	r3, [r3, #0x50]
 800d4a6: 69ba         	ldr	r2, [r7, #0x18]
 800d4a8: 429a         	cmp	r2, r3
 800d4aa: d91b         	bls	0x800d4e4 <spi_stm32_read_next_frame+0x20c> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 800d4ac: 2303         	movs	r3, #0x3
 800d4ae: 2b00         	cmp	r3, #0x0
 800d4b0: d017         	beq	0x800d4e2 <spi_stm32_read_next_frame+0x20a> @ imm = #0x2e
 800d4b2: 2301         	movs	r3, #0x1
 800d4b4: 75fb         	strb	r3, [r7, #0x17]
 800d4b6: 7dfb         	ldrb	r3, [r7, #0x17]
 800d4b8: f083 0301    	eor	r3, r3, #0x1
 800d4bc: b2db         	uxtb	r3, r3
 800d4be: 2b00         	cmp	r3, #0x0
 800d4c0: d10f         	bne	0x800d4e2 <spi_stm32_read_next_frame+0x20a> @ imm = #0x1e
 800d4c2: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800d59c <spi_stm32_read_next_frame+0x2c4>
 800d4c4: 6819         	ldr	r1, [r3]
 800d4c6: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800d5a0 <spi_stm32_read_next_frame+0x2c8>
 800d4c8: 9302         	str	r3, [sp, #0x8]
 800d4ca: 2300         	movs	r3, #0x0
 800d4cc: 9301         	str	r3, [sp, #0x4]
 800d4ce: 2300         	movs	r3, #0x0
 800d4d0: 9300         	str	r3, [sp]
 800d4d2: 2300         	movs	r3, #0x0
 800d4d4: 2201         	movs	r2, #0x1
 800d4d6: 2000         	movs	r0, #0x0
 800d4d8: f00f fd24    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xfa48
 800d4dc: 2300         	movs	r3, #0x0
 800d4de: 613b         	str	r3, [r7, #0x10]
; 		return;
 800d4e0: e058         	b	0x800d594 <spi_stm32_read_next_frame+0x2bc> @ imm = #0xb0
 800d4e2: e057         	b	0x800d594 <spi_stm32_read_next_frame+0x2bc> @ imm = #0xae
; 	ctx->rx_len -= len;
 800d4e4: 6a3b         	ldr	r3, [r7, #0x20]
 800d4e6: 6d1a         	ldr	r2, [r3, #0x50]
 800d4e8: 69bb         	ldr	r3, [r7, #0x18]
 800d4ea: 1ad2         	subs	r2, r2, r3
 800d4ec: 6a3b         	ldr	r3, [r7, #0x20]
 800d4ee: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800d4f0: 6a3b         	ldr	r3, [r7, #0x20]
 800d4f2: 6d1b         	ldr	r3, [r3, #0x50]
 800d4f4: 2b00         	cmp	r3, #0x0
 800d4f6: d11a         	bne	0x800d52e <spi_stm32_read_next_frame+0x256> @ imm = #0x34
; 		++ctx->current_rx;
 800d4f8: 6a3b         	ldr	r3, [r7, #0x20]
 800d4fa: 6bdb         	ldr	r3, [r3, #0x3c]
 800d4fc: f103 0208    	add.w	r2, r3, #0x8
 800d500: 6a3b         	ldr	r3, [r7, #0x20]
 800d502: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800d504: 6a3b         	ldr	r3, [r7, #0x20]
 800d506: 6c1b         	ldr	r3, [r3, #0x40]
 800d508: 1e5a         	subs	r2, r3, #0x1
 800d50a: 6a3b         	ldr	r3, [r7, #0x20]
 800d50c: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800d50e: 6a3b         	ldr	r3, [r7, #0x20]
 800d510: f103 003c    	add.w	r0, r3, #0x3c
 800d514: 6a3b         	ldr	r3, [r7, #0x20]
 800d516: f103 0140    	add.w	r1, r3, #0x40
 800d51a: 6a3b         	ldr	r3, [r7, #0x20]
 800d51c: f103 0250    	add.w	r2, r3, #0x50
 800d520: 7ffb         	ldrb	r3, [r7, #0x1f]
 800d522: f010 f988    	bl	0x801d836 <spi_context_get_next_buf> @ imm = #0x10310
 800d526: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800d528: 6a3b         	ldr	r3, [r7, #0x20]
 800d52a: 64da         	str	r2, [r3, #0x4c]
 800d52c: e00c         	b	0x800d548 <spi_stm32_read_next_frame+0x270> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 800d52e: 6a3b         	ldr	r3, [r7, #0x20]
 800d530: 6cdb         	ldr	r3, [r3, #0x4c]
 800d532: 2b00         	cmp	r3, #0x0
 800d534: d008         	beq	0x800d548 <spi_stm32_read_next_frame+0x270> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 800d536: 6a3b         	ldr	r3, [r7, #0x20]
 800d538: 6cda         	ldr	r2, [r3, #0x4c]
 800d53a: 7ffb         	ldrb	r3, [r7, #0x1f]
 800d53c: 69b9         	ldr	r1, [r7, #0x18]
 800d53e: fb01 f303    	mul	r3, r1, r3
 800d542: 441a         	add	r2, r3
 800d544: 6a3b         	ldr	r3, [r7, #0x20]
 800d546: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800d548: 2303         	movs	r3, #0x3
 800d54a: 2b03         	cmp	r3, #0x3
 800d54c: d922         	bls	0x800d594 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x44
 800d54e: 2301         	movs	r3, #0x1
 800d550: 73fb         	strb	r3, [r7, #0xf]
 800d552: 7bfb         	ldrb	r3, [r7, #0xf]
 800d554: f083 0301    	eor	r3, r3, #0x1
 800d558: b2db         	uxtb	r3, r3
 800d55a: 2b00         	cmp	r3, #0x0
 800d55c: d11a         	bne	0x800d594 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x34
 800d55e: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800d59c <spi_stm32_read_next_frame+0x2c4>
 800d560: 6819         	ldr	r1, [r3]
 800d562: 6a3b         	ldr	r3, [r7, #0x20]
 800d564: 6cdb         	ldr	r3, [r3, #0x4c]
 800d566: 6a3a         	ldr	r2, [r7, #0x20]
 800d568: 6d12         	ldr	r2, [r2, #0x50]
 800d56a: 9205         	str	r2, [sp, #0x14]
 800d56c: 9304         	str	r3, [sp, #0x10]
 800d56e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800d5a4 <spi_stm32_read_next_frame+0x2cc>
 800d570: 9303         	str	r3, [sp, #0xc]
 800d572: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800d5a8 <spi_stm32_read_next_frame+0x2d0>
 800d574: 9302         	str	r3, [sp, #0x8]
 800d576: 2308         	movs	r3, #0x8
 800d578: 9301         	str	r3, [sp, #0x4]
 800d57a: 2300         	movs	r3, #0x0
 800d57c: 9300         	str	r3, [sp]
 800d57e: 2300         	movs	r3, #0x0
 800d580: 2204         	movs	r2, #0x4
 800d582: 2000         	movs	r0, #0x0
 800d584: f00f fcce    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf99c
 800d588: 2300         	movs	r3, #0x0
 800d58a: 60bb         	str	r3, [r7, #0x8]
; }
 800d58c: e002         	b	0x800d594 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x4
; 		return;
 800d58e: bf00         	nop
 800d590: e000         	b	0x800d594 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x0
 800d592: bf00         	nop
; }
 800d594: bf00         	nop
 800d596: 3758         	adds	r7, #0x58
 800d598: 46bd         	mov	sp, r7
 800d59a: bd80         	pop	{r7, pc}

0800d59c <$d>:
 800d59c: 90 05 00 20  	.word	0x20000590
 800d5a0: ac 1d 02 08  	.word	0x08021dac
 800d5a4: 0c 2e 02 08  	.word	0x08022e0c
 800d5a8: e4 1d 02 08  	.word	0x08021de4

0800d5ac <spi_stm32_get_err>:
; {
 800d5ac: b580         	push	{r7, lr}
 800d5ae: b08c         	sub	sp, #0x30
 800d5b0: af06         	add	r7, sp, #0x18
 800d5b2: 6078         	str	r0, [r7, #0x4]
; 	uint32_t sr = LL_SPI_ReadReg(spi, SR);
 800d5b4: 687b         	ldr	r3, [r7, #0x4]
 800d5b6: 689b         	ldr	r3, [r3, #0x8]
 800d5b8: 617b         	str	r3, [r7, #0x14]
; 	if (sr & SPI_STM32_ERR_MSK) {
 800d5ba: 697b         	ldr	r3, [r7, #0x14]
 800d5bc: f403 73b8    	and	r3, r3, #0x170
 800d5c0: 2b00         	cmp	r3, #0x0
 800d5c2: d02b         	beq	0x800d61c <spi_stm32_get_err+0x70> @ imm = #0x56
; 		LOG_ERR("%s: err=%d", __func__, sr & (uint32_t)SPI_STM32_ERR_MSK);
 800d5c4: 2303         	movs	r3, #0x3
 800d5c6: 2b00         	cmp	r3, #0x0
 800d5c8: d01c         	beq	0x800d604 <spi_stm32_get_err+0x58> @ imm = #0x38
 800d5ca: 2301         	movs	r3, #0x1
 800d5cc: 74fb         	strb	r3, [r7, #0x13]
 800d5ce: 7cfb         	ldrb	r3, [r7, #0x13]
 800d5d0: f083 0301    	eor	r3, r3, #0x1
 800d5d4: b2db         	uxtb	r3, r3
 800d5d6: 2b00         	cmp	r3, #0x0
 800d5d8: d114         	bne	0x800d604 <spi_stm32_get_err+0x58> @ imm = #0x28
 800d5da: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800d628 <spi_stm32_get_err+0x7c>
 800d5dc: 6819         	ldr	r1, [r3]
 800d5de: 697b         	ldr	r3, [r7, #0x14]
 800d5e0: f403 73b8    	and	r3, r3, #0x170
 800d5e4: 9304         	str	r3, [sp, #0x10]
 800d5e6: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800d62c <spi_stm32_get_err+0x80>
 800d5e8: 9303         	str	r3, [sp, #0xc]
 800d5ea: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800d630 <spi_stm32_get_err+0x84>
 800d5ec: 9302         	str	r3, [sp, #0x8]
 800d5ee: 2300         	movs	r3, #0x0
 800d5f0: 9301         	str	r3, [sp, #0x4]
 800d5f2: 2300         	movs	r3, #0x0
 800d5f4: 9300         	str	r3, [sp]
 800d5f6: 2300         	movs	r3, #0x0
 800d5f8: 2201         	movs	r2, #0x1
 800d5fa: 2000         	movs	r0, #0x0
 800d5fc: f00f fc92    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf924
 800d600: 2300         	movs	r3, #0x0
 800d602: 60fb         	str	r3, [r7, #0xc]
; 		if (LL_SPI_IsActiveFlag_OVR(spi)) {
 800d604: 6878         	ldr	r0, [r7, #0x4]
 800d606: f00f fe27    	bl	0x801d258 <LL_SPI_IsActiveFlag_OVR> @ imm = #0xfc4e
 800d60a: 4603         	mov	r3, r0
 800d60c: 2b00         	cmp	r3, #0x0
 800d60e: d002         	beq	0x800d616 <spi_stm32_get_err+0x6a> @ imm = #0x4
; 			LL_SPI_ClearFlag_OVR(spi);
 800d610: 6878         	ldr	r0, [r7, #0x4]
 800d612: f00f fe5b    	bl	0x801d2cc <LL_SPI_ClearFlag_OVR> @ imm = #0xfcb6
; 		return -EIO;
 800d616: f06f 0304    	mvn	r3, #0x4
 800d61a: e000         	b	0x800d61e <spi_stm32_get_err+0x72> @ imm = #0x0
; 	return 0;
 800d61c: 2300         	movs	r3, #0x0
; }
 800d61e: 4618         	mov	r0, r3
 800d620: 3718         	adds	r7, #0x18
 800d622: 46bd         	mov	sp, r7
 800d624: bd80         	pop	{r7, pc}
 800d626: bf00         	nop

0800d628 <$d>:
 800d628: 90 05 00 20  	.word	0x20000590
 800d62c: 24 2e 02 08  	.word	0x08022e24
 800d630: fc 1d 02 08  	.word	0x08021dfc

0800d634 <spi_stm32_shift_s>:
; {
 800d634: b580         	push	{r7, lr}
 800d636: b0ac         	sub	sp, #0xb0
 800d638: af06         	add	r7, sp, #0x18
 800d63a: 6078         	str	r0, [r7, #0x4]
 800d63c: 6039         	str	r1, [r7]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800d63e: 6878         	ldr	r0, [r7, #0x4]
 800d640: f010 f92c    	bl	0x801d89c <ll_func_tx_is_not_full> @ imm = #0x10258
 800d644: 4603         	mov	r3, r0
 800d646: 2b00         	cmp	r3, #0x0
 800d648: f000 814a    	beq.w	0x800d8e0 <spi_stm32_shift_s+0x2ac> @ imm = #0x294
 800d64c: 683b         	ldr	r3, [r7]
 800d64e: 67fb         	str	r3, [r7, #0x7c]
; 	return !!(ctx->tx_len);
 800d650: 6ffb         	ldr	r3, [r7, #0x7c]
 800d652: 6c9b         	ldr	r3, [r3, #0x48]
 800d654: 2b00         	cmp	r3, #0x0
 800d656: bf14         	ite	ne
 800d658: 2301         	movne	r3, #0x1
 800d65a: 2300         	moveq	r3, #0x0
 800d65c: b2db         	uxtb	r3, r3
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800d65e: 2b00         	cmp	r3, #0x0
 800d660: f000 813e    	beq.w	0x800d8e0 <spi_stm32_shift_s+0x2ac> @ imm = #0x27c
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 800d664: 683b         	ldr	r3, [r7]
 800d666: 681b         	ldr	r3, [r3]
 800d668: 889b         	ldrh	r3, [r3, #0x4]
 800d66a: 095b         	lsrs	r3, r3, #0x5
 800d66c: f003 033f    	and	r3, r3, #0x3f
 800d670: 2b08         	cmp	r3, #0x8
 800d672: f040 809a    	bne.w	0x800d7aa <spi_stm32_shift_s+0x176> @ imm = #0x134
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 800d676: 683b         	ldr	r3, [r7]
 800d678: 6c5b         	ldr	r3, [r3, #0x44]
 800d67a: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800d67e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800d682: 781b         	ldrb	r3, [r3]
 800d684: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData8(spi, tx_frame);
 800d688: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 800d68c: b2db         	uxtb	r3, r3
 800d68e: 4619         	mov	r1, r3
 800d690: 6878         	ldr	r0, [r7, #0x4]
 800d692: f00f fe58    	bl	0x801d346 <LL_SPI_TransmitData8> @ imm = #0xfcb0
; 			spi_context_update_tx(&data->ctx, 1, 1);
 800d696: 683b         	ldr	r3, [r7]
 800d698: 67bb         	str	r3, [r7, #0x78]
 800d69a: 2301         	movs	r3, #0x1
 800d69c: f887 3077    	strb.w	r3, [r7, #0x77]
 800d6a0: 2301         	movs	r3, #0x1
 800d6a2: 673b         	str	r3, [r7, #0x70]
; 	if (!ctx->tx_len) {
 800d6a4: 6fbb         	ldr	r3, [r7, #0x78]
 800d6a6: 6c9b         	ldr	r3, [r3, #0x48]
 800d6a8: 2b00         	cmp	r3, #0x0
 800d6aa: f000 8115    	beq.w	0x800d8d8 <spi_stm32_shift_s+0x2a4> @ imm = #0x22a
; 	if (len > ctx->tx_len) {
 800d6ae: 6fbb         	ldr	r3, [r7, #0x78]
 800d6b0: 6c9b         	ldr	r3, [r3, #0x48]
 800d6b2: 6f3a         	ldr	r2, [r7, #0x70]
 800d6b4: 429a         	cmp	r2, r3
 800d6b6: d91d         	bls	0x800d6f4 <spi_stm32_shift_s+0xc0> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800d6b8: 2303         	movs	r3, #0x3
 800d6ba: 2b00         	cmp	r3, #0x0
 800d6bc: d019         	beq	0x800d6f2 <spi_stm32_shift_s+0xbe> @ imm = #0x32
 800d6be: 2301         	movs	r3, #0x1
 800d6c0: f887 306f    	strb.w	r3, [r7, #0x6f]
 800d6c4: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800d6c8: f083 0301    	eor	r3, r3, #0x1
 800d6cc: b2db         	uxtb	r3, r3
 800d6ce: 2b00         	cmp	r3, #0x0
 800d6d0: d10f         	bne	0x800d6f2 <spi_stm32_shift_s+0xbe> @ imm = #0x1e
 800d6d2: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800d90c <spi_stm32_shift_s+0x2d8>
 800d6d4: 6819         	ldr	r1, [r3]
 800d6d6: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800d910 <spi_stm32_shift_s+0x2dc>
 800d6d8: 9302         	str	r3, [sp, #0x8]
 800d6da: 2300         	movs	r3, #0x0
 800d6dc: 9301         	str	r3, [sp, #0x4]
 800d6de: 2300         	movs	r3, #0x0
 800d6e0: 9300         	str	r3, [sp]
 800d6e2: 2300         	movs	r3, #0x0
 800d6e4: 2201         	movs	r2, #0x1
 800d6e6: 2000         	movs	r0, #0x0
 800d6e8: f00f fc1c    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf838
 800d6ec: 2300         	movs	r3, #0x0
 800d6ee: 66bb         	str	r3, [r7, #0x68]
; 		return;
 800d6f0: e0f5         	b	0x800d8de <spi_stm32_shift_s+0x2aa> @ imm = #0x1ea
 800d6f2: e0f4         	b	0x800d8de <spi_stm32_shift_s+0x2aa> @ imm = #0x1e8
; 	ctx->tx_len -= len;
 800d6f4: 6fbb         	ldr	r3, [r7, #0x78]
 800d6f6: 6c9a         	ldr	r2, [r3, #0x48]
 800d6f8: 6f3b         	ldr	r3, [r7, #0x70]
 800d6fa: 1ad2         	subs	r2, r2, r3
 800d6fc: 6fbb         	ldr	r3, [r7, #0x78]
 800d6fe: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800d700: 6fbb         	ldr	r3, [r7, #0x78]
 800d702: 6c9b         	ldr	r3, [r3, #0x48]
 800d704: 2b00         	cmp	r3, #0x0
 800d706: d11b         	bne	0x800d740 <spi_stm32_shift_s+0x10c> @ imm = #0x36
; 		++ctx->current_tx;
 800d708: 6fbb         	ldr	r3, [r7, #0x78]
 800d70a: 6b5b         	ldr	r3, [r3, #0x34]
 800d70c: f103 0208    	add.w	r2, r3, #0x8
 800d710: 6fbb         	ldr	r3, [r7, #0x78]
 800d712: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800d714: 6fbb         	ldr	r3, [r7, #0x78]
 800d716: 6b9b         	ldr	r3, [r3, #0x38]
 800d718: 1e5a         	subs	r2, r3, #0x1
 800d71a: 6fbb         	ldr	r3, [r7, #0x78]
 800d71c: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800d71e: 6fbb         	ldr	r3, [r7, #0x78]
 800d720: f103 0034    	add.w	r0, r3, #0x34
 800d724: 6fbb         	ldr	r3, [r7, #0x78]
 800d726: f103 0138    	add.w	r1, r3, #0x38
 800d72a: 6fbb         	ldr	r3, [r7, #0x78]
 800d72c: f103 0248    	add.w	r2, r3, #0x48
 800d730: f897 3077    	ldrb.w	r3, [r7, #0x77]
 800d734: f010 f87f    	bl	0x801d836 <spi_context_get_next_buf> @ imm = #0x100fe
 800d738: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800d73a: 6fbb         	ldr	r3, [r7, #0x78]
 800d73c: 645a         	str	r2, [r3, #0x44]
 800d73e: e00d         	b	0x800d75c <spi_stm32_shift_s+0x128> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 800d740: 6fbb         	ldr	r3, [r7, #0x78]
 800d742: 6c5b         	ldr	r3, [r3, #0x44]
 800d744: 2b00         	cmp	r3, #0x0
 800d746: d009         	beq	0x800d75c <spi_stm32_shift_s+0x128> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 800d748: 6fbb         	ldr	r3, [r7, #0x78]
 800d74a: 6c5a         	ldr	r2, [r3, #0x44]
 800d74c: f897 3077    	ldrb.w	r3, [r7, #0x77]
 800d750: 6f39         	ldr	r1, [r7, #0x70]
 800d752: fb01 f303    	mul	r3, r1, r3
 800d756: 441a         	add	r2, r3
 800d758: 6fbb         	ldr	r3, [r7, #0x78]
 800d75a: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800d75c: 2303         	movs	r3, #0x3
 800d75e: 2b03         	cmp	r3, #0x3
 800d760: f240 80bd    	bls.w	0x800d8de <spi_stm32_shift_s+0x2aa> @ imm = #0x17a
 800d764: 2301         	movs	r3, #0x1
 800d766: f887 3067    	strb.w	r3, [r7, #0x67]
 800d76a: f897 3067    	ldrb.w	r3, [r7, #0x67]
 800d76e: f083 0301    	eor	r3, r3, #0x1
 800d772: b2db         	uxtb	r3, r3
 800d774: 2b00         	cmp	r3, #0x0
 800d776: f040 80b2    	bne.w	0x800d8de <spi_stm32_shift_s+0x2aa> @ imm = #0x164
 800d77a: 4b64         	ldr	r3, [pc, #0x190]        @ 0x800d90c <spi_stm32_shift_s+0x2d8>
 800d77c: 6819         	ldr	r1, [r3]
 800d77e: 6fbb         	ldr	r3, [r7, #0x78]
 800d780: 6c5b         	ldr	r3, [r3, #0x44]
 800d782: 6fba         	ldr	r2, [r7, #0x78]
 800d784: 6c92         	ldr	r2, [r2, #0x48]
 800d786: 9205         	str	r2, [sp, #0x14]
 800d788: 9304         	str	r3, [sp, #0x10]
 800d78a: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800d914 <spi_stm32_shift_s+0x2e0>
 800d78c: 9303         	str	r3, [sp, #0xc]
 800d78e: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800d918 <spi_stm32_shift_s+0x2e4>
 800d790: 9302         	str	r3, [sp, #0x8]
 800d792: 2308         	movs	r3, #0x8
 800d794: 9301         	str	r3, [sp, #0x4]
 800d796: 2300         	movs	r3, #0x0
 800d798: 9300         	str	r3, [sp]
 800d79a: 2300         	movs	r3, #0x0
 800d79c: 2204         	movs	r2, #0x4
 800d79e: 2000         	movs	r0, #0x0
 800d7a0: f00f fbc0    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf780
 800d7a4: 2300         	movs	r3, #0x0
 800d7a6: 663b         	str	r3, [r7, #0x60]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800d7a8: e09d         	b	0x800d8e6 <spi_stm32_shift_s+0x2b2> @ imm = #0x13a
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 800d7aa: 683b         	ldr	r3, [r7]
 800d7ac: 6c5b         	ldr	r3, [r3, #0x44]
 800d7ae: f8c7 3094    	str.w	r3, [r7, #0x94]
 800d7b2: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800d7b6: 881b         	ldrh	r3, [r3]
 800d7b8: b29b         	uxth	r3, r3
 800d7ba: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData16(spi, tx_frame);
 800d7be: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 800d7c2: 4619         	mov	r1, r3
 800d7c4: 6878         	ldr	r0, [r7, #0x4]
 800d7c6: f00f fdd0    	bl	0x801d36a <LL_SPI_TransmitData16> @ imm = #0xfba0
; 			spi_context_update_tx(&data->ctx, 2, 1);
 800d7ca: 683b         	ldr	r3, [r7]
 800d7cc: 65fb         	str	r3, [r7, #0x5c]
 800d7ce: 2302         	movs	r3, #0x2
 800d7d0: f887 305b    	strb.w	r3, [r7, #0x5b]
 800d7d4: 2301         	movs	r3, #0x1
 800d7d6: 657b         	str	r3, [r7, #0x54]
; 	if (!ctx->tx_len) {
 800d7d8: 6dfb         	ldr	r3, [r7, #0x5c]
 800d7da: 6c9b         	ldr	r3, [r3, #0x48]
 800d7dc: 2b00         	cmp	r3, #0x0
 800d7de: d07d         	beq	0x800d8dc <spi_stm32_shift_s+0x2a8> @ imm = #0xfa
; 	if (len > ctx->tx_len) {
 800d7e0: 6dfb         	ldr	r3, [r7, #0x5c]
 800d7e2: 6c9b         	ldr	r3, [r3, #0x48]
 800d7e4: 6d7a         	ldr	r2, [r7, #0x54]
 800d7e6: 429a         	cmp	r2, r3
 800d7e8: d91d         	bls	0x800d826 <spi_stm32_shift_s+0x1f2> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800d7ea: 2303         	movs	r3, #0x3
 800d7ec: 2b00         	cmp	r3, #0x0
 800d7ee: d019         	beq	0x800d824 <spi_stm32_shift_s+0x1f0> @ imm = #0x32
 800d7f0: 2301         	movs	r3, #0x1
 800d7f2: f887 3053    	strb.w	r3, [r7, #0x53]
 800d7f6: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800d7fa: f083 0301    	eor	r3, r3, #0x1
 800d7fe: b2db         	uxtb	r3, r3
 800d800: 2b00         	cmp	r3, #0x0
 800d802: d10f         	bne	0x800d824 <spi_stm32_shift_s+0x1f0> @ imm = #0x1e
 800d804: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800d90c <spi_stm32_shift_s+0x2d8>
 800d806: 6819         	ldr	r1, [r3]
 800d808: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800d910 <spi_stm32_shift_s+0x2dc>
 800d80a: 9302         	str	r3, [sp, #0x8]
 800d80c: 2300         	movs	r3, #0x0
 800d80e: 9301         	str	r3, [sp, #0x4]
 800d810: 2300         	movs	r3, #0x0
 800d812: 9300         	str	r3, [sp]
 800d814: 2300         	movs	r3, #0x0
 800d816: 2201         	movs	r2, #0x1
 800d818: 2000         	movs	r0, #0x0
 800d81a: f00f fb83    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf706
 800d81e: 2300         	movs	r3, #0x0
 800d820: 64fb         	str	r3, [r7, #0x4c]
; 		return;
 800d822: e05c         	b	0x800d8de <spi_stm32_shift_s+0x2aa> @ imm = #0xb8
 800d824: e05b         	b	0x800d8de <spi_stm32_shift_s+0x2aa> @ imm = #0xb6
; 	ctx->tx_len -= len;
 800d826: 6dfb         	ldr	r3, [r7, #0x5c]
 800d828: 6c9a         	ldr	r2, [r3, #0x48]
 800d82a: 6d7b         	ldr	r3, [r7, #0x54]
 800d82c: 1ad2         	subs	r2, r2, r3
 800d82e: 6dfb         	ldr	r3, [r7, #0x5c]
 800d830: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800d832: 6dfb         	ldr	r3, [r7, #0x5c]
 800d834: 6c9b         	ldr	r3, [r3, #0x48]
 800d836: 2b00         	cmp	r3, #0x0
 800d838: d11b         	bne	0x800d872 <spi_stm32_shift_s+0x23e> @ imm = #0x36
; 		++ctx->current_tx;
 800d83a: 6dfb         	ldr	r3, [r7, #0x5c]
 800d83c: 6b5b         	ldr	r3, [r3, #0x34]
 800d83e: f103 0208    	add.w	r2, r3, #0x8
 800d842: 6dfb         	ldr	r3, [r7, #0x5c]
 800d844: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 800d846: 6dfb         	ldr	r3, [r7, #0x5c]
 800d848: 6b9b         	ldr	r3, [r3, #0x38]
 800d84a: 1e5a         	subs	r2, r3, #0x1
 800d84c: 6dfb         	ldr	r3, [r7, #0x5c]
 800d84e: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800d850: 6dfb         	ldr	r3, [r7, #0x5c]
 800d852: f103 0034    	add.w	r0, r3, #0x34
 800d856: 6dfb         	ldr	r3, [r7, #0x5c]
 800d858: f103 0138    	add.w	r1, r3, #0x38
 800d85c: 6dfb         	ldr	r3, [r7, #0x5c]
 800d85e: f103 0248    	add.w	r2, r3, #0x48
 800d862: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 800d866: f00f ffe6    	bl	0x801d836 <spi_context_get_next_buf> @ imm = #0xffcc
 800d86a: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 800d86c: 6dfb         	ldr	r3, [r7, #0x5c]
 800d86e: 645a         	str	r2, [r3, #0x44]
 800d870: e00d         	b	0x800d88e <spi_stm32_shift_s+0x25a> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 800d872: 6dfb         	ldr	r3, [r7, #0x5c]
 800d874: 6c5b         	ldr	r3, [r3, #0x44]
 800d876: 2b00         	cmp	r3, #0x0
 800d878: d009         	beq	0x800d88e <spi_stm32_shift_s+0x25a> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 800d87a: 6dfb         	ldr	r3, [r7, #0x5c]
 800d87c: 6c5a         	ldr	r2, [r3, #0x44]
 800d87e: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 800d882: 6d79         	ldr	r1, [r7, #0x54]
 800d884: fb01 f303    	mul	r3, r1, r3
 800d888: 441a         	add	r2, r3
 800d88a: 6dfb         	ldr	r3, [r7, #0x5c]
 800d88c: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 800d88e: 2303         	movs	r3, #0x3
 800d890: 2b03         	cmp	r3, #0x3
 800d892: d924         	bls	0x800d8de <spi_stm32_shift_s+0x2aa> @ imm = #0x48
 800d894: 2301         	movs	r3, #0x1
 800d896: f887 304b    	strb.w	r3, [r7, #0x4b]
 800d89a: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 800d89e: f083 0301    	eor	r3, r3, #0x1
 800d8a2: b2db         	uxtb	r3, r3
 800d8a4: 2b00         	cmp	r3, #0x0
 800d8a6: d11a         	bne	0x800d8de <spi_stm32_shift_s+0x2aa> @ imm = #0x34
 800d8a8: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800d90c <spi_stm32_shift_s+0x2d8>
 800d8aa: 6819         	ldr	r1, [r3]
 800d8ac: 6dfb         	ldr	r3, [r7, #0x5c]
 800d8ae: 6c5b         	ldr	r3, [r3, #0x44]
 800d8b0: 6dfa         	ldr	r2, [r7, #0x5c]
 800d8b2: 6c92         	ldr	r2, [r2, #0x48]
 800d8b4: 9205         	str	r2, [sp, #0x14]
 800d8b6: 9304         	str	r3, [sp, #0x10]
 800d8b8: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800d914 <spi_stm32_shift_s+0x2e0>
 800d8ba: 9303         	str	r3, [sp, #0xc]
 800d8bc: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800d918 <spi_stm32_shift_s+0x2e4>
 800d8be: 9302         	str	r3, [sp, #0x8]
 800d8c0: 2308         	movs	r3, #0x8
 800d8c2: 9301         	str	r3, [sp, #0x4]
 800d8c4: 2300         	movs	r3, #0x0
 800d8c6: 9300         	str	r3, [sp]
 800d8c8: 2300         	movs	r3, #0x0
 800d8ca: 2204         	movs	r2, #0x4
 800d8cc: 2000         	movs	r0, #0x0
 800d8ce: f00f fb29    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf652
 800d8d2: 2300         	movs	r3, #0x0
 800d8d4: 647b         	str	r3, [r7, #0x44]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800d8d6: e006         	b	0x800d8e6 <spi_stm32_shift_s+0x2b2> @ imm = #0xc
; 		return;
 800d8d8: bf00         	nop
 800d8da: e004         	b	0x800d8e6 <spi_stm32_shift_s+0x2b2> @ imm = #0x8
 800d8dc: bf00         	nop
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 800d8de: e002         	b	0x800d8e6 <spi_stm32_shift_s+0x2b2> @ imm = #0x4
; 		ll_func_disable_int_tx_empty(spi);
 800d8e0: 6878         	ldr	r0, [r7, #0x4]
 800d8e2: f00f fff3    	bl	0x801d8cc <ll_func_disable_int_tx_empty> @ imm = #0xffe6
; 	if (ll_func_rx_is_not_empty(spi) && spi_context_rx_buf_on(&data->ctx)) {
 800d8e6: 6878         	ldr	r0, [r7, #0x4]
 800d8e8: f00f ffe4    	bl	0x801d8b4 <ll_func_rx_is_not_empty> @ imm = #0xffc8
 800d8ec: 4603         	mov	r3, r0
 800d8ee: 2b00         	cmp	r3, #0x0
 800d8f0: f000 8150    	beq.w	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0x2a0
 800d8f4: 683b         	ldr	r3, [r7]
 800d8f6: 643b         	str	r3, [r7, #0x40]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 800d8f8: 6c3b         	ldr	r3, [r7, #0x40]
 800d8fa: 6cdb         	ldr	r3, [r3, #0x4c]
 800d8fc: 2b00         	cmp	r3, #0x0
 800d8fe: d00d         	beq	0x800d91c <spi_stm32_shift_s+0x2e8> @ imm = #0x1a
 800d900: 6c3b         	ldr	r3, [r7, #0x40]
 800d902: 6d1b         	ldr	r3, [r3, #0x50]
 800d904: 2b00         	cmp	r3, #0x0
 800d906: d009         	beq	0x800d91c <spi_stm32_shift_s+0x2e8> @ imm = #0x12
 800d908: 2301         	movs	r3, #0x1
 800d90a: e008         	b	0x800d91e <spi_stm32_shift_s+0x2ea> @ imm = #0x10

0800d90c <$d>:
 800d90c: 90 05 00 20  	.word	0x20000590
 800d910: ac 1d 02 08  	.word	0x08021dac
 800d914: f4 2d 02 08  	.word	0x08022df4
 800d918: cc 1d 02 08  	.word	0x08021dcc

0800d91c <$t>:
 800d91c: 2300         	movs	r3, #0x0
 800d91e: f003 0301    	and	r3, r3, #0x1
 800d922: b2db         	uxtb	r3, r3
; 	if (ll_func_rx_is_not_empty(spi) && spi_context_rx_buf_on(&data->ctx)) {
 800d924: 2b00         	cmp	r3, #0x0
 800d926: f000 8135    	beq.w	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0x26a
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 800d92a: 683b         	ldr	r3, [r7]
 800d92c: 681b         	ldr	r3, [r3]
 800d92e: 889b         	ldrh	r3, [r3, #0x4]
 800d930: 095b         	lsrs	r3, r3, #0x5
 800d932: f003 033f    	and	r3, r3, #0x3f
 800d936: 2b08         	cmp	r3, #0x8
 800d938: f040 809a    	bne.w	0x800da70 <spi_stm32_shift_s+0x43c> @ imm = #0x134
; 			rx_frame = LL_SPI_ReceiveData8(spi);
 800d93c: 6878         	ldr	r0, [r7, #0x4]
 800d93e: f00f fce7    	bl	0x801d310 <LL_SPI_ReceiveData8> @ imm = #0xf9ce
 800d942: 4603         	mov	r3, r0
 800d944: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 800d948: 683b         	ldr	r3, [r7]
 800d94a: 6cdb         	ldr	r3, [r3, #0x4c]
 800d94c: f8c7 3080    	str.w	r3, [r7, #0x80]
 800d950: f8b7 308a    	ldrh.w	r3, [r7, #0x8a]
 800d954: b2da         	uxtb	r2, r3
 800d956: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800d95a: 701a         	strb	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 1, 1);
 800d95c: 683b         	ldr	r3, [r7]
 800d95e: 63fb         	str	r3, [r7, #0x3c]
 800d960: 2301         	movs	r3, #0x1
 800d962: f887 303b    	strb.w	r3, [r7, #0x3b]
 800d966: 2301         	movs	r3, #0x1
 800d968: 637b         	str	r3, [r7, #0x34]
; 	if (!ctx->rx_len) {
 800d96a: 6bfb         	ldr	r3, [r7, #0x3c]
 800d96c: 6d1b         	ldr	r3, [r3, #0x50]
 800d96e: 2b00         	cmp	r3, #0x0
 800d970: f000 810d    	beq.w	0x800db8e <spi_stm32_shift_s+0x55a> @ imm = #0x21a
; 	if (len > ctx->rx_len) {
 800d974: 6bfb         	ldr	r3, [r7, #0x3c]
 800d976: 6d1b         	ldr	r3, [r3, #0x50]
 800d978: 6b7a         	ldr	r2, [r7, #0x34]
 800d97a: 429a         	cmp	r2, r3
 800d97c: d91d         	bls	0x800d9ba <spi_stm32_shift_s+0x386> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 800d97e: 2303         	movs	r3, #0x3
 800d980: 2b00         	cmp	r3, #0x0
 800d982: d019         	beq	0x800d9b8 <spi_stm32_shift_s+0x384> @ imm = #0x32
 800d984: 2301         	movs	r3, #0x1
 800d986: f887 3033    	strb.w	r3, [r7, #0x33]
 800d98a: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800d98e: f083 0301    	eor	r3, r3, #0x1
 800d992: b2db         	uxtb	r3, r3
 800d994: 2b00         	cmp	r3, #0x0
 800d996: d10f         	bne	0x800d9b8 <spi_stm32_shift_s+0x384> @ imm = #0x1e
 800d998: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800db9c <spi_stm32_shift_s+0x568>
 800d99a: 6819         	ldr	r1, [r3]
 800d99c: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800dba0 <spi_stm32_shift_s+0x56c>
 800d99e: 9302         	str	r3, [sp, #0x8]
 800d9a0: 2300         	movs	r3, #0x0
 800d9a2: 9301         	str	r3, [sp, #0x4]
 800d9a4: 2300         	movs	r3, #0x0
 800d9a6: 9300         	str	r3, [sp]
 800d9a8: 2300         	movs	r3, #0x0
 800d9aa: 2201         	movs	r2, #0x1
 800d9ac: 2000         	movs	r0, #0x0
 800d9ae: f00f fab9    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf572
 800d9b2: 2300         	movs	r3, #0x0
 800d9b4: 62fb         	str	r3, [r7, #0x2c]
; 		return;
 800d9b6: e0ed         	b	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0x1da
 800d9b8: e0ec         	b	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0x1d8
; 	ctx->rx_len -= len;
 800d9ba: 6bfb         	ldr	r3, [r7, #0x3c]
 800d9bc: 6d1a         	ldr	r2, [r3, #0x50]
 800d9be: 6b7b         	ldr	r3, [r7, #0x34]
 800d9c0: 1ad2         	subs	r2, r2, r3
 800d9c2: 6bfb         	ldr	r3, [r7, #0x3c]
 800d9c4: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800d9c6: 6bfb         	ldr	r3, [r7, #0x3c]
 800d9c8: 6d1b         	ldr	r3, [r3, #0x50]
 800d9ca: 2b00         	cmp	r3, #0x0
 800d9cc: d11b         	bne	0x800da06 <spi_stm32_shift_s+0x3d2> @ imm = #0x36
; 		++ctx->current_rx;
 800d9ce: 6bfb         	ldr	r3, [r7, #0x3c]
 800d9d0: 6bdb         	ldr	r3, [r3, #0x3c]
 800d9d2: f103 0208    	add.w	r2, r3, #0x8
 800d9d6: 6bfb         	ldr	r3, [r7, #0x3c]
 800d9d8: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800d9da: 6bfb         	ldr	r3, [r7, #0x3c]
 800d9dc: 6c1b         	ldr	r3, [r3, #0x40]
 800d9de: 1e5a         	subs	r2, r3, #0x1
 800d9e0: 6bfb         	ldr	r3, [r7, #0x3c]
 800d9e2: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800d9e4: 6bfb         	ldr	r3, [r7, #0x3c]
 800d9e6: f103 003c    	add.w	r0, r3, #0x3c
 800d9ea: 6bfb         	ldr	r3, [r7, #0x3c]
 800d9ec: f103 0140    	add.w	r1, r3, #0x40
 800d9f0: 6bfb         	ldr	r3, [r7, #0x3c]
 800d9f2: f103 0250    	add.w	r2, r3, #0x50
 800d9f6: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800d9fa: f00f ff1c    	bl	0x801d836 <spi_context_get_next_buf> @ imm = #0xfe38
 800d9fe: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800da00: 6bfb         	ldr	r3, [r7, #0x3c]
 800da02: 64da         	str	r2, [r3, #0x4c]
 800da04: e00d         	b	0x800da22 <spi_stm32_shift_s+0x3ee> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 800da06: 6bfb         	ldr	r3, [r7, #0x3c]
 800da08: 6cdb         	ldr	r3, [r3, #0x4c]
 800da0a: 2b00         	cmp	r3, #0x0
 800da0c: d009         	beq	0x800da22 <spi_stm32_shift_s+0x3ee> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 800da0e: 6bfb         	ldr	r3, [r7, #0x3c]
 800da10: 6cda         	ldr	r2, [r3, #0x4c]
 800da12: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800da16: 6b79         	ldr	r1, [r7, #0x34]
 800da18: fb01 f303    	mul	r3, r1, r3
 800da1c: 441a         	add	r2, r3
 800da1e: 6bfb         	ldr	r3, [r7, #0x3c]
 800da20: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800da22: 2303         	movs	r3, #0x3
 800da24: 2b03         	cmp	r3, #0x3
 800da26: f240 80b5    	bls.w	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0x16a
 800da2a: 2301         	movs	r3, #0x1
 800da2c: f887 302b    	strb.w	r3, [r7, #0x2b]
 800da30: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800da34: f083 0301    	eor	r3, r3, #0x1
 800da38: b2db         	uxtb	r3, r3
 800da3a: 2b00         	cmp	r3, #0x0
 800da3c: f040 80aa    	bne.w	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0x154
 800da40: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800db9c <spi_stm32_shift_s+0x568>
 800da42: 6819         	ldr	r1, [r3]
 800da44: 6bfb         	ldr	r3, [r7, #0x3c]
 800da46: 6cdb         	ldr	r3, [r3, #0x4c]
 800da48: 6bfa         	ldr	r2, [r7, #0x3c]
 800da4a: 6d12         	ldr	r2, [r2, #0x50]
 800da4c: 9205         	str	r2, [sp, #0x14]
 800da4e: 9304         	str	r3, [sp, #0x10]
 800da50: 4b54         	ldr	r3, [pc, #0x150]        @ 0x800dba4 <spi_stm32_shift_s+0x570>
 800da52: 9303         	str	r3, [sp, #0xc]
 800da54: 4b54         	ldr	r3, [pc, #0x150]        @ 0x800dba8 <spi_stm32_shift_s+0x574>
 800da56: 9302         	str	r3, [sp, #0x8]
 800da58: 2308         	movs	r3, #0x8
 800da5a: 9301         	str	r3, [sp, #0x4]
 800da5c: 2300         	movs	r3, #0x0
 800da5e: 9300         	str	r3, [sp]
 800da60: 2300         	movs	r3, #0x0
 800da62: 2204         	movs	r2, #0x4
 800da64: 2000         	movs	r0, #0x0
 800da66: f00f fa5d    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf4ba
 800da6a: 2300         	movs	r3, #0x0
 800da6c: 627b         	str	r3, [r7, #0x24]
; }
 800da6e: e091         	b	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0x122
; 			rx_frame = LL_SPI_ReceiveData16(spi);
 800da70: 6878         	ldr	r0, [r7, #0x4]
 800da72: f00f fc5b    	bl	0x801d32c <LL_SPI_ReceiveData16> @ imm = #0xf8b6
 800da76: 4603         	mov	r3, r0
 800da78: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 800da7c: 683b         	ldr	r3, [r7]
 800da7e: 6cdb         	ldr	r3, [r3, #0x4c]
 800da80: f8c7 3084    	str.w	r3, [r7, #0x84]
 800da84: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800da88: f8b7 208a    	ldrh.w	r2, [r7, #0x8a]
 800da8c: 801a         	strh	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 2, 1);
 800da8e: 683b         	ldr	r3, [r7]
 800da90: 623b         	str	r3, [r7, #0x20]
 800da92: 2302         	movs	r3, #0x2
 800da94: 77fb         	strb	r3, [r7, #0x1f]
 800da96: 2301         	movs	r3, #0x1
 800da98: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 800da9a: 6a3b         	ldr	r3, [r7, #0x20]
 800da9c: 6d1b         	ldr	r3, [r3, #0x50]
 800da9e: 2b00         	cmp	r3, #0x0
 800daa0: d077         	beq	0x800db92 <spi_stm32_shift_s+0x55e> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 800daa2: 6a3b         	ldr	r3, [r7, #0x20]
 800daa4: 6d1b         	ldr	r3, [r3, #0x50]
 800daa6: 69ba         	ldr	r2, [r7, #0x18]
 800daa8: 429a         	cmp	r2, r3
 800daaa: d91b         	bls	0x800dae4 <spi_stm32_shift_s+0x4b0> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 800daac: 2303         	movs	r3, #0x3
 800daae: 2b00         	cmp	r3, #0x0
 800dab0: d017         	beq	0x800dae2 <spi_stm32_shift_s+0x4ae> @ imm = #0x2e
 800dab2: 2301         	movs	r3, #0x1
 800dab4: 75fb         	strb	r3, [r7, #0x17]
 800dab6: 7dfb         	ldrb	r3, [r7, #0x17]
 800dab8: f083 0301    	eor	r3, r3, #0x1
 800dabc: b2db         	uxtb	r3, r3
 800dabe: 2b00         	cmp	r3, #0x0
 800dac0: d10f         	bne	0x800dae2 <spi_stm32_shift_s+0x4ae> @ imm = #0x1e
 800dac2: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800db9c <spi_stm32_shift_s+0x568>
 800dac4: 6819         	ldr	r1, [r3]
 800dac6: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800dba0 <spi_stm32_shift_s+0x56c>
 800dac8: 9302         	str	r3, [sp, #0x8]
 800daca: 2300         	movs	r3, #0x0
 800dacc: 9301         	str	r3, [sp, #0x4]
 800dace: 2300         	movs	r3, #0x0
 800dad0: 9300         	str	r3, [sp]
 800dad2: 2300         	movs	r3, #0x0
 800dad4: 2201         	movs	r2, #0x1
 800dad6: 2000         	movs	r0, #0x0
 800dad8: f00f fa24    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf448
 800dadc: 2300         	movs	r3, #0x0
 800dade: 613b         	str	r3, [r7, #0x10]
; 		return;
 800dae0: e058         	b	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0xb0
 800dae2: e057         	b	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0xae
; 	ctx->rx_len -= len;
 800dae4: 6a3b         	ldr	r3, [r7, #0x20]
 800dae6: 6d1a         	ldr	r2, [r3, #0x50]
 800dae8: 69bb         	ldr	r3, [r7, #0x18]
 800daea: 1ad2         	subs	r2, r2, r3
 800daec: 6a3b         	ldr	r3, [r7, #0x20]
 800daee: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800daf0: 6a3b         	ldr	r3, [r7, #0x20]
 800daf2: 6d1b         	ldr	r3, [r3, #0x50]
 800daf4: 2b00         	cmp	r3, #0x0
 800daf6: d11a         	bne	0x800db2e <spi_stm32_shift_s+0x4fa> @ imm = #0x34
; 		++ctx->current_rx;
 800daf8: 6a3b         	ldr	r3, [r7, #0x20]
 800dafa: 6bdb         	ldr	r3, [r3, #0x3c]
 800dafc: f103 0208    	add.w	r2, r3, #0x8
 800db00: 6a3b         	ldr	r3, [r7, #0x20]
 800db02: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 800db04: 6a3b         	ldr	r3, [r7, #0x20]
 800db06: 6c1b         	ldr	r3, [r3, #0x40]
 800db08: 1e5a         	subs	r2, r3, #0x1
 800db0a: 6a3b         	ldr	r3, [r7, #0x20]
 800db0c: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800db0e: 6a3b         	ldr	r3, [r7, #0x20]
 800db10: f103 003c    	add.w	r0, r3, #0x3c
 800db14: 6a3b         	ldr	r3, [r7, #0x20]
 800db16: f103 0140    	add.w	r1, r3, #0x40
 800db1a: 6a3b         	ldr	r3, [r7, #0x20]
 800db1c: f103 0250    	add.w	r2, r3, #0x50
 800db20: 7ffb         	ldrb	r3, [r7, #0x1f]
 800db22: f00f fe88    	bl	0x801d836 <spi_context_get_next_buf> @ imm = #0xfd10
 800db26: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800db28: 6a3b         	ldr	r3, [r7, #0x20]
 800db2a: 64da         	str	r2, [r3, #0x4c]
 800db2c: e00c         	b	0x800db48 <spi_stm32_shift_s+0x514> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 800db2e: 6a3b         	ldr	r3, [r7, #0x20]
 800db30: 6cdb         	ldr	r3, [r3, #0x4c]
 800db32: 2b00         	cmp	r3, #0x0
 800db34: d008         	beq	0x800db48 <spi_stm32_shift_s+0x514> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 800db36: 6a3b         	ldr	r3, [r7, #0x20]
 800db38: 6cda         	ldr	r2, [r3, #0x4c]
 800db3a: 7ffb         	ldrb	r3, [r7, #0x1f]
 800db3c: 69b9         	ldr	r1, [r7, #0x18]
 800db3e: fb01 f303    	mul	r3, r1, r3
 800db42: 441a         	add	r2, r3
 800db44: 6a3b         	ldr	r3, [r7, #0x20]
 800db46: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800db48: 2303         	movs	r3, #0x3
 800db4a: 2b03         	cmp	r3, #0x3
 800db4c: d922         	bls	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0x44
 800db4e: 2301         	movs	r3, #0x1
 800db50: 73fb         	strb	r3, [r7, #0xf]
 800db52: 7bfb         	ldrb	r3, [r7, #0xf]
 800db54: f083 0301    	eor	r3, r3, #0x1
 800db58: b2db         	uxtb	r3, r3
 800db5a: 2b00         	cmp	r3, #0x0
 800db5c: d11a         	bne	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0x34
 800db5e: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800db9c <spi_stm32_shift_s+0x568>
 800db60: 6819         	ldr	r1, [r3]
 800db62: 6a3b         	ldr	r3, [r7, #0x20]
 800db64: 6cdb         	ldr	r3, [r3, #0x4c]
 800db66: 6a3a         	ldr	r2, [r7, #0x20]
 800db68: 6d12         	ldr	r2, [r2, #0x50]
 800db6a: 9205         	str	r2, [sp, #0x14]
 800db6c: 9304         	str	r3, [sp, #0x10]
 800db6e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800dba4 <spi_stm32_shift_s+0x570>
 800db70: 9303         	str	r3, [sp, #0xc]
 800db72: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800dba8 <spi_stm32_shift_s+0x574>
 800db74: 9302         	str	r3, [sp, #0x8]
 800db76: 2308         	movs	r3, #0x8
 800db78: 9301         	str	r3, [sp, #0x4]
 800db7a: 2300         	movs	r3, #0x0
 800db7c: 9300         	str	r3, [sp]
 800db7e: 2300         	movs	r3, #0x0
 800db80: 2204         	movs	r2, #0x4
 800db82: 2000         	movs	r0, #0x0
 800db84: f00f f9ce    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf39c
 800db88: 2300         	movs	r3, #0x0
 800db8a: 60bb         	str	r3, [r7, #0x8]
; }
 800db8c: e002         	b	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0x4
; 		return;
 800db8e: bf00         	nop
 800db90: e000         	b	0x800db94 <spi_stm32_shift_s+0x560> @ imm = #0x0
 800db92: bf00         	nop
; }
 800db94: bf00         	nop
 800db96: 3798         	adds	r7, #0x98
 800db98: 46bd         	mov	sp, r7
 800db9a: bd80         	pop	{r7, pc}

0800db9c <$d>:
 800db9c: 90 05 00 20  	.word	0x20000590
 800dba0: ac 1d 02 08  	.word	0x08021dac
 800dba4: 0c 2e 02 08  	.word	0x08022e0c
 800dba8: e4 1d 02 08  	.word	0x08021de4

0800dbac <spi_stm32_configure>:
; {
 800dbac: b5f0         	push	{r4, r5, r6, r7, lr}
 800dbae: b0a3         	sub	sp, #0x8c
 800dbb0: af0c         	add	r7, sp, #0x30
 800dbb2: 6078         	str	r0, [r7, #0x4]
 800dbb4: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 800dbb6: 687b         	ldr	r3, [r7, #0x4]
 800dbb8: 685b         	ldr	r3, [r3, #0x4]
 800dbba: 63bb         	str	r3, [r7, #0x38]
; 	struct spi_stm32_data *data = dev->data;
 800dbbc: 687b         	ldr	r3, [r7, #0x4]
 800dbbe: 691b         	ldr	r3, [r3, #0x10]
 800dbc0: 637b         	str	r3, [r7, #0x34]
; 	const uint32_t scaler[] = {
 800dbc2: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x800ddf8 <spi_stm32_configure+0x24c>
 800dbc4: f107 0410    	add.w	r4, r7, #0x10
 800dbc8: 461d         	mov	r5, r3
 800dbca: cd0f         	ldm	r5!, {r0, r1, r2, r3}
 800dbcc: c40f         	stm	r4!, {r0, r1, r2, r3}
 800dbce: e895 000f    	ldm.w	r5, {r0, r1, r2, r3}
 800dbd2: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
; 	SPI_TypeDef *spi = cfg->spi;
 800dbd6: 6bbb         	ldr	r3, [r7, #0x38]
 800dbd8: 681b         	ldr	r3, [r3]
 800dbda: 633b         	str	r3, [r7, #0x30]
; 	if (spi_context_configured(&data->ctx, config)) {
 800dbdc: 6b7b         	ldr	r3, [r7, #0x34]
 800dbde: 6839         	ldr	r1, [r7]
 800dbe0: 4618         	mov	r0, r3
 800dbe2: f00f fd60    	bl	0x801d6a6 <spi_context_configured> @ imm = #0xfac0
 800dbe6: 4603         	mov	r3, r0
 800dbe8: 2b00         	cmp	r3, #0x0
 800dbea: d001         	beq	0x800dbf0 <spi_stm32_configure+0x44> @ imm = #0x2
; 		return 0;
 800dbec: 2300         	movs	r3, #0x0
 800dbee: e156         	b	0x800de9e <spi_stm32_configure+0x2f2> @ imm = #0x2ac
; 	if ((SPI_WORD_SIZE_GET(config->operation) != 8) &&
 800dbf0: 683b         	ldr	r3, [r7]
 800dbf2: 889b         	ldrh	r3, [r3, #0x4]
 800dbf4: 095b         	lsrs	r3, r3, #0x5
 800dbf6: f003 033f    	and	r3, r3, #0x3f
 800dbfa: 2b08         	cmp	r3, #0x8
 800dbfc: d009         	beq	0x800dc12 <spi_stm32_configure+0x66> @ imm = #0x12
; 	    (SPI_WORD_SIZE_GET(config->operation) != 16)) {
 800dbfe: 683b         	ldr	r3, [r7]
 800dc00: 889b         	ldrh	r3, [r3, #0x4]
 800dc02: 095b         	lsrs	r3, r3, #0x5
 800dc04: f003 033f    	and	r3, r3, #0x3f
; 	if ((SPI_WORD_SIZE_GET(config->operation) != 8) &&
 800dc08: 2b10         	cmp	r3, #0x10
 800dc0a: d002         	beq	0x800dc12 <spi_stm32_configure+0x66> @ imm = #0x4
; 		return -ENOTSUP;
 800dc0c: f06f 0385    	mvn	r3, #0x85
 800dc10: e145         	b	0x800de9e <spi_stm32_configure+0x2f2> @ imm = #0x28a
; 	if ((config->operation & SPI_FRAME_FORMAT_TI) == SPI_FRAME_FORMAT_TI) {
 800dc12: 683b         	ldr	r3, [r7]
 800dc14: 889b         	ldrh	r3, [r3, #0x4]
 800dc16: b21b         	sxth	r3, r3
 800dc18: 2b00         	cmp	r3, #0x0
 800dc1a: da04         	bge	0x800dc26 <spi_stm32_configure+0x7a> @ imm = #0x8
; 		LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_TI);
 800dc1c: 2110         	movs	r1, #0x10
 800dc1e: 6b38         	ldr	r0, [r7, #0x30]
 800dc20: f00f fa30    	bl	0x801d084 <LL_SPI_SetStandard> @ imm = #0xf460
 800dc24: e003         	b	0x800dc2e <spi_stm32_configure+0x82> @ imm = #0x6
; 		LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_MOTOROLA);
 800dc26: 2100         	movs	r1, #0x0
 800dc28: 6b38         	ldr	r0, [r7, #0x30]
 800dc2a: f00f fa2b    	bl	0x801d084 <LL_SPI_SetStandard> @ imm = #0xf456
; 					   (clock_control_subsys_t)&cfg->pclken[0], &clock) < 0) {
 800dc2e: 6bbb         	ldr	r3, [r7, #0x38]
 800dc30: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 800dc32: f107 020c    	add.w	r2, r7, #0xc
 800dc36: 4619         	mov	r1, r3
 800dc38: 4870         	ldr	r0, [pc, #0x1c0]        @ 0x800ddfc <spi_stm32_configure+0x250>
 800dc3a: f00f fd19    	bl	0x801d670 <clock_control_get_rate> @ imm = #0xfa32
 800dc3e: 4603         	mov	r3, r0
 800dc40: 2b00         	cmp	r3, #0x0
 800dc42: da1e         	bge	0x800dc82 <spi_stm32_configure+0xd6> @ imm = #0x3c
; 			LOG_ERR("Failed call clock_control_get_rate(pclk[0])");
 800dc44: 2303         	movs	r3, #0x3
 800dc46: 2b00         	cmp	r3, #0x0
 800dc48: d018         	beq	0x800dc7c <spi_stm32_configure+0xd0> @ imm = #0x30
 800dc4a: 2301         	movs	r3, #0x1
 800dc4c: f887 3053    	strb.w	r3, [r7, #0x53]
 800dc50: f897 3053    	ldrb.w	r3, [r7, #0x53]
 800dc54: f083 0301    	eor	r3, r3, #0x1
 800dc58: b2db         	uxtb	r3, r3
 800dc5a: 2b00         	cmp	r3, #0x0
 800dc5c: d10e         	bne	0x800dc7c <spi_stm32_configure+0xd0> @ imm = #0x1c
 800dc5e: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x800de00 <spi_stm32_configure+0x254>
 800dc60: 6819         	ldr	r1, [r3]
 800dc62: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x800de04 <spi_stm32_configure+0x258>
 800dc64: 9302         	str	r3, [sp, #0x8]
 800dc66: 2300         	movs	r3, #0x0
 800dc68: 9301         	str	r3, [sp, #0x4]
 800dc6a: 2300         	movs	r3, #0x0
 800dc6c: 9300         	str	r3, [sp]
 800dc6e: 2300         	movs	r3, #0x0
 800dc70: 2201         	movs	r2, #0x1
 800dc72: 2000         	movs	r0, #0x0
 800dc74: f00f f956    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf2ac
 800dc78: 2300         	movs	r3, #0x0
 800dc7a: 657b         	str	r3, [r7, #0x54]
; 			return -EIO;
 800dc7c: f06f 0304    	mvn	r3, #0x4
 800dc80: e10d         	b	0x800de9e <spi_stm32_configure+0x2f2> @ imm = #0x21a
; 	for (br = 1; br <= ARRAY_SIZE(scaler); ++br) {
 800dc82: 2301         	movs	r3, #0x1
 800dc84: 643b         	str	r3, [r7, #0x40]
 800dc86: e00c         	b	0x800dca2 <spi_stm32_configure+0xf6> @ imm = #0x18
; 		uint32_t clk = clock >> br;
 800dc88: 68fa         	ldr	r2, [r7, #0xc]
 800dc8a: 6c3b         	ldr	r3, [r7, #0x40]
 800dc8c: fa22 f303    	lsr.w	r3, r2, r3
 800dc90: 63fb         	str	r3, [r7, #0x3c]
; 		if (clk <= config->frequency) {
 800dc92: 683b         	ldr	r3, [r7]
 800dc94: 681b         	ldr	r3, [r3]
 800dc96: 6bfa         	ldr	r2, [r7, #0x3c]
 800dc98: 429a         	cmp	r2, r3
 800dc9a: d906         	bls	0x800dcaa <spi_stm32_configure+0xfe> @ imm = #0xc
; 	for (br = 1; br <= ARRAY_SIZE(scaler); ++br) {
 800dc9c: 6c3b         	ldr	r3, [r7, #0x40]
 800dc9e: 3301         	adds	r3, #0x1
 800dca0: 643b         	str	r3, [r7, #0x40]
 800dca2: 6c3b         	ldr	r3, [r7, #0x40]
 800dca4: 2b08         	cmp	r3, #0x8
 800dca6: d9ef         	bls	0x800dc88 <spi_stm32_configure+0xdc> @ imm = #-0x22
 800dca8: e000         	b	0x800dcac <spi_stm32_configure+0x100> @ imm = #0x0
; 			break;
 800dcaa: bf00         	nop
; 	if (br > ARRAY_SIZE(scaler)) {
 800dcac: 6c3b         	ldr	r3, [r7, #0x40]
 800dcae: 2b08         	cmp	r3, #0x8
 800dcb0: d928         	bls	0x800dd04 <spi_stm32_configure+0x158> @ imm = #0x50
; 		LOG_ERR("Unsupported frequency %uHz, max %uHz, min %uHz", config->frequency,
 800dcb2: 2303         	movs	r3, #0x3
 800dcb4: 2b00         	cmp	r3, #0x0
 800dcb6: d022         	beq	0x800dcfe <spi_stm32_configure+0x152> @ imm = #0x44
 800dcb8: 2301         	movs	r3, #0x1
 800dcba: f887 304b    	strb.w	r3, [r7, #0x4b]
 800dcbe: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 800dcc2: f083 0301    	eor	r3, r3, #0x1
 800dcc6: b2db         	uxtb	r3, r3
 800dcc8: 2b00         	cmp	r3, #0x0
 800dcca: d118         	bne	0x800dcfe <spi_stm32_configure+0x152> @ imm = #0x30
 800dccc: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x800de00 <spi_stm32_configure+0x254>
 800dcce: 6818         	ldr	r0, [r3]
 800dcd0: 683b         	ldr	r3, [r7]
 800dcd2: 681b         	ldr	r3, [r3]
 800dcd4: 68fa         	ldr	r2, [r7, #0xc]
 800dcd6: 0852         	lsrs	r2, r2, #0x1
 800dcd8: 68f9         	ldr	r1, [r7, #0xc]
 800dcda: 0a09         	lsrs	r1, r1, #0x8
 800dcdc: 9105         	str	r1, [sp, #0x14]
 800dcde: 9204         	str	r2, [sp, #0x10]
 800dce0: 9303         	str	r3, [sp, #0xc]
 800dce2: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800de08 <spi_stm32_configure+0x25c>
 800dce4: 9302         	str	r3, [sp, #0x8]
 800dce6: 2300         	movs	r3, #0x0
 800dce8: 9301         	str	r3, [sp, #0x4]
 800dcea: 2300         	movs	r3, #0x0
 800dcec: 9300         	str	r3, [sp]
 800dcee: 2300         	movs	r3, #0x0
 800dcf0: 2201         	movs	r2, #0x1
 800dcf2: 4601         	mov	r1, r0
 800dcf4: 2000         	movs	r0, #0x0
 800dcf6: f00f f915    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf22a
 800dcfa: 2300         	movs	r3, #0x0
 800dcfc: 647b         	str	r3, [r7, #0x44]
; 		return -EINVAL;
 800dcfe: f06f 0315    	mvn	r3, #0x15
 800dd02: e0cc         	b	0x800de9e <spi_stm32_configure+0x2f2> @ imm = #0x198
; 	LL_SPI_Disable(spi);
 800dd04: 6b38         	ldr	r0, [r7, #0x30]
 800dd06: f00f f979    	bl	0x801cffc <LL_SPI_Disable> @ imm = #0xf2f2
; 	LL_SPI_SetBaudRatePrescaler(spi, scaler[br - 1]);
 800dd0a: 6c3b         	ldr	r3, [r7, #0x40]
 800dd0c: 3b01         	subs	r3, #0x1
 800dd0e: 009b         	lsls	r3, r3, #0x2
 800dd10: 3358         	adds	r3, #0x58
 800dd12: 443b         	add	r3, r7
 800dd14: f853 3c48    	ldr	r3, [r3, #-72]
 800dd18: 4619         	mov	r1, r3
 800dd1a: 6b38         	ldr	r0, [r7, #0x30]
 800dd1c: f00f f9eb    	bl	0x801d0f6 <LL_SPI_SetBaudRatePrescaler> @ imm = #0xf3d6
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPOL) {
 800dd20: 683b         	ldr	r3, [r7]
 800dd22: 889b         	ldrh	r3, [r3, #0x4]
 800dd24: f003 0302    	and	r3, r3, #0x2
 800dd28: 2b00         	cmp	r3, #0x0
 800dd2a: d004         	beq	0x800dd36 <spi_stm32_configure+0x18a> @ imm = #0x8
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_HIGH);
 800dd2c: 2102         	movs	r1, #0x2
 800dd2e: 6b38         	ldr	r0, [r7, #0x30]
 800dd30: f00f f9ce    	bl	0x801d0d0 <LL_SPI_SetClockPolarity> @ imm = #0xf39c
 800dd34: e003         	b	0x800dd3e <spi_stm32_configure+0x192> @ imm = #0x6
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_LOW);
 800dd36: 2100         	movs	r1, #0x0
 800dd38: 6b38         	ldr	r0, [r7, #0x30]
 800dd3a: f00f f9c9    	bl	0x801d0d0 <LL_SPI_SetClockPolarity> @ imm = #0xf392
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPHA) {
 800dd3e: 683b         	ldr	r3, [r7]
 800dd40: 889b         	ldrh	r3, [r3, #0x4]
 800dd42: f003 0304    	and	r3, r3, #0x4
 800dd46: 2b00         	cmp	r3, #0x0
 800dd48: d004         	beq	0x800dd54 <spi_stm32_configure+0x1a8> @ imm = #0x8
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_2EDGE);
 800dd4a: 2101         	movs	r1, #0x1
 800dd4c: 6b38         	ldr	r0, [r7, #0x30]
 800dd4e: f00f f9ac    	bl	0x801d0aa <LL_SPI_SetClockPhase> @ imm = #0xf358
 800dd52: e003         	b	0x800dd5c <spi_stm32_configure+0x1b0> @ imm = #0x6
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_1EDGE);
 800dd54: 2100         	movs	r1, #0x0
 800dd56: 6b38         	ldr	r0, [r7, #0x30]
 800dd58: f00f f9a7    	bl	0x801d0aa <LL_SPI_SetClockPhase> @ imm = #0xf34e
; 	LL_SPI_SetTransferDirection(spi, LL_SPI_FULL_DUPLEX);
 800dd5c: 2100         	movs	r1, #0x0
 800dd5e: 6b38         	ldr	r0, [r7, #0x30]
 800dd60: f00f f9ef    	bl	0x801d142 <LL_SPI_SetTransferDirection> @ imm = #0xf3de
; 	if (config->operation & SPI_TRANSFER_LSB) {
 800dd64: 683b         	ldr	r3, [r7]
 800dd66: 889b         	ldrh	r3, [r3, #0x4]
 800dd68: f003 0310    	and	r3, r3, #0x10
 800dd6c: 2b00         	cmp	r3, #0x0
 800dd6e: d004         	beq	0x800dd7a <spi_stm32_configure+0x1ce> @ imm = #0x8
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_LSB_FIRST);
 800dd70: 2180         	movs	r1, #0x80
 800dd72: 6b38         	ldr	r0, [r7, #0x30]
 800dd74: f00f f9d2    	bl	0x801d11c <LL_SPI_SetTransferBitOrder> @ imm = #0xf3a4
 800dd78: e003         	b	0x800dd82 <spi_stm32_configure+0x1d6> @ imm = #0x6
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_MSB_FIRST);
 800dd7a: 2100         	movs	r1, #0x0
 800dd7c: 6b38         	ldr	r0, [r7, #0x30]
 800dd7e: f00f f9cd    	bl	0x801d11c <LL_SPI_SetTransferBitOrder> @ imm = #0xf39a
; 	LL_SPI_DisableCRC(spi);
 800dd82: 6b38         	ldr	r0, [r7, #0x30]
 800dd84: f00f fa03    	bl	0x801d18e <LL_SPI_DisableCRC> @ imm = #0xf406
; 	if (spi_cs_is_gpio(config) || !IS_ENABLED(CONFIG_SPI_STM32_USE_HW_SS)) {
 800dd88: 6838         	ldr	r0, [r7]
 800dd8a: f00f fc12    	bl	0x801d5b2 <spi_cs_is_gpio> @ imm = #0xf824
 800dd8e: 4603         	mov	r3, r0
 800dd90: 2b00         	cmp	r3, #0x0
 800dd92: d005         	beq	0x800dda0 <spi_stm32_configure+0x1f4> @ imm = #0xa
; 		LL_SPI_SetNSSMode(spi, LL_SPI_NSS_SOFT);
 800dd94: f44f 7100    	mov.w	r1, #0x200
 800dd98: 6b38         	ldr	r0, [r7, #0x30]
 800dd9a: f00f fa08    	bl	0x801d1ae <LL_SPI_SetNSSMode> @ imm = #0xf410
 800dd9e: e00f         	b	0x800ddc0 <spi_stm32_configure+0x214> @ imm = #0x1e
; 		if (config->operation & SPI_OP_MODE_SLAVE) {
 800dda0: 683b         	ldr	r3, [r7]
 800dda2: 889b         	ldrh	r3, [r3, #0x4]
 800dda4: f003 0301    	and	r3, r3, #0x1
 800dda8: 2b00         	cmp	r3, #0x0
 800ddaa: d004         	beq	0x800ddb6 <spi_stm32_configure+0x20a> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_INPUT);
 800ddac: 2100         	movs	r1, #0x0
 800ddae: 6b38         	ldr	r0, [r7, #0x30]
 800ddb0: f00f f9fd    	bl	0x801d1ae <LL_SPI_SetNSSMode> @ imm = #0xf3fa
 800ddb4: e004         	b	0x800ddc0 <spi_stm32_configure+0x214> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_OUTPUT);
 800ddb6: f44f 2180    	mov.w	r1, #0x40000
 800ddba: 6b38         	ldr	r0, [r7, #0x30]
 800ddbc: f00f f9f7    	bl	0x801d1ae <LL_SPI_SetNSSMode> @ imm = #0xf3ee
; 	if (config->operation & SPI_OP_MODE_SLAVE) {
 800ddc0: 683b         	ldr	r3, [r7]
 800ddc2: 889b         	ldrh	r3, [r3, #0x4]
 800ddc4: f003 0301    	and	r3, r3, #0x1
 800ddc8: 2b00         	cmp	r3, #0x0
 800ddca: d004         	beq	0x800ddd6 <spi_stm32_configure+0x22a> @ imm = #0x8
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_SLAVE);
 800ddcc: 2100         	movs	r1, #0x0
 800ddce: 6b38         	ldr	r0, [r7, #0x30]
 800ddd0: f00f f937    	bl	0x801d042 <LL_SPI_SetMode> @ imm = #0xf26e
 800ddd4: e004         	b	0x800dde0 <spi_stm32_configure+0x234> @ imm = #0x8
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_MASTER);
 800ddd6: f44f 7182    	mov.w	r1, #0x104
 800ddda: 6b38         	ldr	r0, [r7, #0x30]
 800dddc: f00f f931    	bl	0x801d042 <LL_SPI_SetMode> @ imm = #0xf262
; 	if (SPI_WORD_SIZE_GET(config->operation) == 8) {
 800dde0: 683b         	ldr	r3, [r7]
 800dde2: 889b         	ldrh	r3, [r3, #0x4]
 800dde4: 095b         	lsrs	r3, r3, #0x5
 800dde6: f003 033f    	and	r3, r3, #0x3f
 800ddea: 2b08         	cmp	r3, #0x8
 800ddec: d10e         	bne	0x800de0c <spi_stm32_configure+0x260> @ imm = #0x1c
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_8BIT);
 800ddee: 2100         	movs	r1, #0x0
 800ddf0: 6b38         	ldr	r0, [r7, #0x30]
 800ddf2: f00f f9b9    	bl	0x801d168 <LL_SPI_SetDataWidth> @ imm = #0xf372
 800ddf6: e00e         	b	0x800de16 <spi_stm32_configure+0x26a> @ imm = #0x1c

0800ddf8 <$d>:
 800ddf8: ac 1e 02 08  	.word	0x08021eac
 800ddfc: 80 01 02 08  	.word	0x08020180
 800de00: 90 05 00 20  	.word	0x20000590
 800de04: 08 1e 02 08  	.word	0x08021e08
 800de08: 34 1e 02 08  	.word	0x08021e34

0800de0c <$t>:
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_16BIT);
 800de0c: f44f 6100    	mov.w	r1, #0x800
 800de10: 6b38         	ldr	r0, [r7, #0x30]
 800de12: f00f f9a9    	bl	0x801d168 <LL_SPI_SetDataWidth> @ imm = #0xf352
; 	data->ctx.config = config;
 800de16: 6b7b         	ldr	r3, [r7, #0x34]
 800de18: 683a         	ldr	r2, [r7]
 800de1a: 601a         	str	r2, [r3]
; 	LOG_DBG("Installed config %p: freq %uHz (div = %u),"
 800de1c: 2303         	movs	r3, #0x3
 800de1e: 2b03         	cmp	r3, #0x3
 800de20: d93c         	bls	0x800de9c <spi_stm32_configure+0x2f0> @ imm = #0x78
 800de22: 2301         	movs	r3, #0x1
 800de24: f887 3052    	strb.w	r3, [r7, #0x52]
 800de28: f897 3052    	ldrb.w	r3, [r7, #0x52]
 800de2c: f083 0301    	eor	r3, r3, #0x1
 800de30: b2db         	uxtb	r3, r3
 800de32: 2b00         	cmp	r3, #0x0
 800de34: d132         	bne	0x800de9c <spi_stm32_configure+0x2f0> @ imm = #0x64
 800de36: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800dea8 <spi_stm32_configure+0x2fc>
 800de38: 681e         	ldr	r6, [r3]
 800de3a: 68fa         	ldr	r2, [r7, #0xc]
 800de3c: 6c3b         	ldr	r3, [r7, #0x40]
 800de3e: fa22 f303    	lsr.w	r3, r2, r3
 800de42: 2101         	movs	r1, #0x1
 800de44: 6c3a         	ldr	r2, [r7, #0x40]
 800de46: fa01 f202    	lsl.w	r2, r1, r2
 800de4a: 6839         	ldr	r1, [r7]
 800de4c: 8889         	ldrh	r1, [r1, #0x4]
 800de4e: 0849         	lsrs	r1, r1, #0x1
 800de50: f001 0101    	and	r1, r1, #0x1
 800de54: 6838         	ldr	r0, [r7]
 800de56: 8880         	ldrh	r0, [r0, #0x4]
 800de58: 0880         	lsrs	r0, r0, #0x2
 800de5a: f000 0001    	and	r0, r0, #0x1
 800de5e: 683c         	ldr	r4, [r7]
 800de60: 88a4         	ldrh	r4, [r4, #0x4]
 800de62: 08e4         	lsrs	r4, r4, #0x3
 800de64: f004 0401    	and	r4, r4, #0x1
 800de68: 683d         	ldr	r5, [r7]
 800de6a: 88ed         	ldrh	r5, [r5, #0x6]
 800de6c: 950a         	str	r5, [sp, #0x28]
 800de6e: 9409         	str	r4, [sp, #0x24]
 800de70: 9008         	str	r0, [sp, #0x20]
 800de72: 9107         	str	r1, [sp, #0x1c]
 800de74: 9206         	str	r2, [sp, #0x18]
 800de76: 9305         	str	r3, [sp, #0x14]
 800de78: 683b         	ldr	r3, [r7]
 800de7a: 9304         	str	r3, [sp, #0x10]
 800de7c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800deac <spi_stm32_configure+0x300>
 800de7e: 9303         	str	r3, [sp, #0xc]
 800de80: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800deb0 <spi_stm32_configure+0x304>
 800de82: 9302         	str	r3, [sp, #0x8]
 800de84: 2308         	movs	r3, #0x8
 800de86: 9301         	str	r3, [sp, #0x4]
 800de88: 2300         	movs	r3, #0x0
 800de8a: 9300         	str	r3, [sp]
 800de8c: 2300         	movs	r3, #0x0
 800de8e: 2204         	movs	r2, #0x4
 800de90: 4631         	mov	r1, r6
 800de92: 2000         	movs	r0, #0x0
 800de94: f00f f846    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf08c
 800de98: 2300         	movs	r3, #0x0
 800de9a: 64fb         	str	r3, [r7, #0x4c]
; 	return 0;
 800de9c: 2300         	movs	r3, #0x0
; }
 800de9e: 4618         	mov	r0, r3
 800dea0: 375c         	adds	r7, #0x5c
 800dea2: 46bd         	mov	sp, r7
 800dea4: bdf0         	pop	{r4, r5, r6, r7, pc}
 800dea6: bf00         	nop

0800dea8 <$d>:
 800dea8: 90 05 00 20  	.word	0x20000590
 800deac: 38 2e 02 08  	.word	0x08022e38
 800deb0: 64 1e 02 08  	.word	0x08021e64

0800deb4 <spi_stm32_init>:
; {
 800deb4: b580         	push	{r7, lr}
 800deb6: b090         	sub	sp, #0x40
 800deb8: af04         	add	r7, sp, #0x10
 800deba: 6078         	str	r0, [r7, #0x4]
; 	struct spi_stm32_data *data __attribute__((unused)) = dev->data;
 800debc: 687b         	ldr	r3, [r7, #0x4]
 800debe: 691b         	ldr	r3, [r3, #0x10]
 800dec0: 627b         	str	r3, [r7, #0x24]
; 	const struct spi_stm32_config *cfg = dev->config;
 800dec2: 687b         	ldr	r3, [r7, #0x4]
 800dec4: 685b         	ldr	r3, [r3, #0x4]
 800dec6: 62bb         	str	r3, [r7, #0x28]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 800dec8: 484a         	ldr	r0, [pc, #0x128]        @ 0x800dff4 <spi_stm32_init+0x140>
 800deca: f00f f81f    	bl	0x801cf0c <device_is_ready> @ imm = #0xf03e
 800dece: 4603         	mov	r3, r0
 800ded0: f083 0301    	eor	r3, r3, #0x1
 800ded4: b2db         	uxtb	r3, r3
 800ded6: 2b00         	cmp	r3, #0x0
 800ded8: d01c         	beq	0x800df14 <spi_stm32_init+0x60> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800deda: 2303         	movs	r3, #0x3
 800dedc: 2b00         	cmp	r3, #0x0
 800dede: d016         	beq	0x800df0e <spi_stm32_init+0x5a> @ imm = #0x2c
 800dee0: 2301         	movs	r3, #0x1
 800dee2: 74fb         	strb	r3, [r7, #0x13]
 800dee4: 7cfb         	ldrb	r3, [r7, #0x13]
 800dee6: f083 0301    	eor	r3, r3, #0x1
 800deea: b2db         	uxtb	r3, r3
 800deec: 2b00         	cmp	r3, #0x0
 800deee: d10e         	bne	0x800df0e <spi_stm32_init+0x5a> @ imm = #0x1c
 800def0: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800dff8 <spi_stm32_init+0x144>
 800def2: 6819         	ldr	r1, [r3]
 800def4: 4b41         	ldr	r3, [pc, #0x104]        @ 0x800dffc <spi_stm32_init+0x148>
 800def6: 9302         	str	r3, [sp, #0x8]
 800def8: 2300         	movs	r3, #0x0
 800defa: 9301         	str	r3, [sp, #0x4]
 800defc: 2300         	movs	r3, #0x0
 800defe: 9300         	str	r3, [sp]
 800df00: 2300         	movs	r3, #0x0
 800df02: 2201         	movs	r2, #0x1
 800df04: 2000         	movs	r0, #0x0
 800df06: f00f f80d    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xf01a
 800df0a: 2300         	movs	r3, #0x0
 800df0c: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800df0e: f06f 0312    	mvn	r3, #0x12
 800df12: e06a         	b	0x800dfea <spi_stm32_init+0x136> @ imm = #0xd4
; 			       (clock_control_subsys_t)&cfg->pclken[0]);
 800df14: 6abb         	ldr	r3, [r7, #0x28]
 800df16: 68db         	ldr	r3, [r3, #0xc]
; 	err = clock_control_on(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 800df18: 4619         	mov	r1, r3
 800df1a: 4836         	ldr	r0, [pc, #0xd8]         @ 0x800dff4 <spi_stm32_init+0x140>
 800df1c: f00f fb96    	bl	0x801d64c <clock_control_on> @ imm = #0xf72c
 800df20: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 800df22: 6afb         	ldr	r3, [r7, #0x2c]
 800df24: 2b00         	cmp	r3, #0x0
 800df26: da1b         	bge	0x800df60 <spi_stm32_init+0xac> @ imm = #0x36
; 		LOG_ERR("Could not enable SPI clock");
 800df28: 2303         	movs	r3, #0x3
 800df2a: 2b00         	cmp	r3, #0x0
 800df2c: d016         	beq	0x800df5c <spi_stm32_init+0xa8> @ imm = #0x2c
 800df2e: 2301         	movs	r3, #0x1
 800df30: 76fb         	strb	r3, [r7, #0x1b]
 800df32: 7efb         	ldrb	r3, [r7, #0x1b]
 800df34: f083 0301    	eor	r3, r3, #0x1
 800df38: b2db         	uxtb	r3, r3
 800df3a: 2b00         	cmp	r3, #0x0
 800df3c: d10e         	bne	0x800df5c <spi_stm32_init+0xa8> @ imm = #0x1c
 800df3e: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x800dff8 <spi_stm32_init+0x144>
 800df40: 6819         	ldr	r1, [r3]
 800df42: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800e000 <spi_stm32_init+0x14c>
 800df44: 9302         	str	r3, [sp, #0x8]
 800df46: 2300         	movs	r3, #0x0
 800df48: 9301         	str	r3, [sp, #0x4]
 800df4a: 2300         	movs	r3, #0x0
 800df4c: 9300         	str	r3, [sp]
 800df4e: 2300         	movs	r3, #0x0
 800df50: 2201         	movs	r2, #0x1
 800df52: 2000         	movs	r0, #0x0
 800df54: f00e ffe6    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xefcc
 800df58: 2300         	movs	r3, #0x0
 800df5a: 617b         	str	r3, [r7, #0x14]
; 		return err;
 800df5c: 6afb         	ldr	r3, [r7, #0x2c]
 800df5e: e044         	b	0x800dfea <spi_stm32_init+0x136> @ imm = #0x88
; 	if (!spi_stm32_is_subghzspi(dev)) {
 800df60: 6878         	ldr	r0, [r7, #0x4]
 800df62: f00f fe73    	bl	0x801dc4c <spi_stm32_is_subghzspi> @ imm = #0xfce6
 800df66: 4603         	mov	r3, r0
 800df68: f083 0301    	eor	r3, r3, #0x1
 800df6c: b2db         	uxtb	r3, r3
 800df6e: 2b00         	cmp	r3, #0x0
 800df70: d029         	beq	0x800dfc6 <spi_stm32_init+0x112> @ imm = #0x52
; 		err = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
 800df72: 6abb         	ldr	r3, [r7, #0x28]
 800df74: 685b         	ldr	r3, [r3, #0x4]
 800df76: 2100         	movs	r1, #0x0
 800df78: 4618         	mov	r0, r3
 800df7a: f00f fb3f    	bl	0x801d5fc <pinctrl_apply_state> @ imm = #0xf67e
 800df7e: 62f8         	str	r0, [r7, #0x2c]
; 		if (err < 0) {
 800df80: 6afb         	ldr	r3, [r7, #0x2c]
 800df82: 2b00         	cmp	r3, #0x0
 800df84: da1f         	bge	0x800dfc6 <spi_stm32_init+0x112> @ imm = #0x3e
; 			LOG_ERR("SPI pinctrl setup failed (%d)", err);
 800df86: 2303         	movs	r3, #0x3
 800df88: 2b00         	cmp	r3, #0x0
 800df8a: d01a         	beq	0x800dfc2 <spi_stm32_init+0x10e> @ imm = #0x34
 800df8c: 2301         	movs	r3, #0x1
 800df8e: f887 3023    	strb.w	r3, [r7, #0x23]
 800df92: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800df96: f083 0301    	eor	r3, r3, #0x1
 800df9a: b2db         	uxtb	r3, r3
 800df9c: 2b00         	cmp	r3, #0x0
 800df9e: d110         	bne	0x800dfc2 <spi_stm32_init+0x10e> @ imm = #0x20
 800dfa0: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800dff8 <spi_stm32_init+0x144>
 800dfa2: 6819         	ldr	r1, [r3]
 800dfa4: 6afb         	ldr	r3, [r7, #0x2c]
 800dfa6: 9303         	str	r3, [sp, #0xc]
 800dfa8: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800e004 <spi_stm32_init+0x150>
 800dfaa: 9302         	str	r3, [sp, #0x8]
 800dfac: 2300         	movs	r3, #0x0
 800dfae: 9301         	str	r3, [sp, #0x4]
 800dfb0: 2300         	movs	r3, #0x0
 800dfb2: 9300         	str	r3, [sp]
 800dfb4: 2300         	movs	r3, #0x0
 800dfb6: 2201         	movs	r2, #0x1
 800dfb8: 2000         	movs	r0, #0x0
 800dfba: f00e ffb3    	bl	0x801cf24 <z_log_msg_runtime_create> @ imm = #0xef66
 800dfbe: 2300         	movs	r3, #0x0
 800dfc0: 61fb         	str	r3, [r7, #0x1c]
; 			return err;
 800dfc2: 6afb         	ldr	r3, [r7, #0x2c]
 800dfc4: e011         	b	0x800dfea <spi_stm32_init+0x136> @ imm = #0x22
; 	err = spi_context_cs_configure_all(&data->ctx);
 800dfc6: 6a7b         	ldr	r3, [r7, #0x24]
 800dfc8: 4618         	mov	r0, r3
 800dfca: f7fe ff07    	bl	0x800cddc <spi_context_cs_configure_all> @ imm = #-0x11f2
 800dfce: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 800dfd0: 6afb         	ldr	r3, [r7, #0x2c]
 800dfd2: 2b00         	cmp	r3, #0x0
 800dfd4: da01         	bge	0x800dfda <spi_stm32_init+0x126> @ imm = #0x2
; 		return err;
 800dfd6: 6afb         	ldr	r3, [r7, #0x2c]
 800dfd8: e007         	b	0x800dfea <spi_stm32_init+0x136> @ imm = #0xe
; 	spi_context_unlock_unconditionally(&data->ctx);
 800dfda: 6a7b         	ldr	r3, [r7, #0x24]
 800dfdc: 4618         	mov	r0, r3
 800dfde: f00f fc0d    	bl	0x801d7fc <spi_context_unlock_unconditionally> @ imm = #0xf81a
; 	return pm_device_runtime_enable(dev);
 800dfe2: 6878         	ldr	r0, [r7, #0x4]
 800dfe4: f00f fb27    	bl	0x801d636 <pm_device_runtime_enable> @ imm = #0xf64e
 800dfe8: 4603         	mov	r3, r0
; }
 800dfea: 4618         	mov	r0, r3
 800dfec: 3730         	adds	r7, #0x30
 800dfee: 46bd         	mov	sp, r7
 800dff0: bd80         	pop	{r7, pc}
 800dff2: bf00         	nop

0800dff4 <$d>:
 800dff4: 80 01 02 08  	.word	0x08020180
 800dff8: 90 05 00 20  	.word	0x20000590
 800dffc: cc 1e 02 08  	.word	0x08021ecc
 800e000: ec 1e 02 08  	.word	0x08021eec
 800e004: 08 1f 02 08  	.word	0x08021f08

0800e008 <__NVIC_SetPriority>:
; {
 800e008: b480         	push	{r7}
 800e00a: b083         	sub	sp, #0xc
 800e00c: af00         	add	r7, sp, #0x0
 800e00e: 4603         	mov	r3, r0
 800e010: 6039         	str	r1, [r7]
 800e012: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 800e014: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800e018: 2b00         	cmp	r3, #0x0
 800e01a: db0a         	blt	0x800e032 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800e01c: 683b         	ldr	r3, [r7]
 800e01e: b2da         	uxtb	r2, r3
 800e020: 490c         	ldr	r1, [pc, #0x30]         @ 0x800e054 <__NVIC_SetPriority+0x4c>
 800e022: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800e026: 0112         	lsls	r2, r2, #0x4
 800e028: b2d2         	uxtb	r2, r2
 800e02a: 440b         	add	r3, r1
 800e02c: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 800e030: e00a         	b	0x800e048 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800e032: 683b         	ldr	r3, [r7]
 800e034: b2da         	uxtb	r2, r3
 800e036: 4908         	ldr	r1, [pc, #0x20]         @ 0x800e058 <__NVIC_SetPriority+0x50>
 800e038: 79fb         	ldrb	r3, [r7, #0x7]
 800e03a: f003 030f    	and	r3, r3, #0xf
 800e03e: 3b04         	subs	r3, #0x4
 800e040: 0112         	lsls	r2, r2, #0x4
 800e042: b2d2         	uxtb	r2, r2
 800e044: 440b         	add	r3, r1
 800e046: 761a         	strb	r2, [r3, #0x18]
; }
 800e048: bf00         	nop
 800e04a: 370c         	adds	r7, #0xc
 800e04c: 46bd         	mov	sp, r7
 800e04e: f85d 7b04    	ldr	r7, [sp], #4
 800e052: 4770         	bx	lr

0800e054 <$d>:
 800e054: 00 e1 00 e0  	.word	0xe000e100
 800e058: 00 ed 00 e0  	.word	0xe000ed00

0800e05c <elapsed>:
; {
 800e05c: b480         	push	{r7}
 800e05e: b085         	sub	sp, #0x14
 800e060: af00         	add	r7, sp, #0x0
; 	uint32_t val1 = SysTick->VAL;	/* A */
 800e062: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800e0cc <elapsed+0x70>
 800e064: 689b         	ldr	r3, [r3, #0x8]
 800e066: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ctrl = SysTick->CTRL;	/* B */
 800e068: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800e0cc <elapsed+0x70>
 800e06a: 681b         	ldr	r3, [r3]
 800e06c: 607b         	str	r3, [r7, #0x4]
; 	uint32_t val2 = SysTick->VAL;	/* C */
 800e06e: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800e0cc <elapsed+0x70>
 800e070: 689b         	ldr	r3, [r3, #0x8]
 800e072: 60bb         	str	r3, [r7, #0x8]
; 	if (val1 == 0) {
 800e074: 68fb         	ldr	r3, [r7, #0xc]
 800e076: 2b00         	cmp	r3, #0x0
 800e078: d102         	bne	0x800e080 <elapsed+0x24> @ imm = #0x4
; 		val1 = last_load;
 800e07a: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800e0d0 <elapsed+0x74>
 800e07c: 681b         	ldr	r3, [r3]
 800e07e: 60fb         	str	r3, [r7, #0xc]
; 	if (val2 == 0) {
 800e080: 68bb         	ldr	r3, [r7, #0x8]
 800e082: 2b00         	cmp	r3, #0x0
 800e084: d102         	bne	0x800e08c <elapsed+0x30> @ imm = #0x4
; 		val2 = last_load;
 800e086: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800e0d0 <elapsed+0x74>
 800e088: 681b         	ldr	r3, [r3]
 800e08a: 60bb         	str	r3, [r7, #0x8]
; 	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
 800e08c: 687b         	ldr	r3, [r7, #0x4]
 800e08e: f403 3380    	and	r3, r3, #0x10000
 800e092: 2b00         	cmp	r3, #0x0
 800e094: d103         	bne	0x800e09e <elapsed+0x42> @ imm = #0x6
; 	    || (val1 < val2)) {
 800e096: 68fa         	ldr	r2, [r7, #0xc]
 800e098: 68bb         	ldr	r3, [r7, #0x8]
 800e09a: 429a         	cmp	r2, r3
 800e09c: d208         	bhs	0x800e0b0 <elapsed+0x54> @ imm = #0x10
; 		overflow_cyc += last_load;
 800e09e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e0d4 <elapsed+0x78>
 800e0a0: 681a         	ldr	r2, [r3]
 800e0a2: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800e0d0 <elapsed+0x74>
 800e0a4: 681b         	ldr	r3, [r3]
 800e0a6: 4413         	add	r3, r2
 800e0a8: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800e0d4 <elapsed+0x78>
 800e0aa: 6013         	str	r3, [r2]
; 		(void)SysTick->CTRL;
 800e0ac: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800e0cc <elapsed+0x70>
 800e0ae: 681b         	ldr	r3, [r3]
; 	return (last_load - val2) + overflow_cyc;
 800e0b0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800e0d0 <elapsed+0x74>
 800e0b2: 681a         	ldr	r2, [r3]
 800e0b4: 68bb         	ldr	r3, [r7, #0x8]
 800e0b6: 1ad2         	subs	r2, r2, r3
 800e0b8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800e0d4 <elapsed+0x78>
 800e0ba: 681b         	ldr	r3, [r3]
 800e0bc: 4413         	add	r3, r2
; }
 800e0be: 4618         	mov	r0, r3
 800e0c0: 3714         	adds	r7, #0x14
 800e0c2: 46bd         	mov	sp, r7
 800e0c4: f85d 7b04    	ldr	r7, [sp], #4
 800e0c8: 4770         	bx	lr
 800e0ca: bf00         	nop

0800e0cc <$d>:
 800e0cc: 10 e0 00 e0  	.word	0xe000e010
 800e0d0: d0 27 00 20  	.word	0x200027d0
 800e0d4: d4 27 00 20  	.word	0x200027d4

0800e0d8 <sys_clock_isr>:
; {
 800e0d8: 4668         	mov	r0, sp
 800e0da: f020 0107    	bic	r1, r0, #0x7
 800e0de: 468d         	mov	sp, r1
 800e0e0: e92d 4fb1    	push.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 800e0e4: b085         	sub	sp, #0x14
 800e0e6: af00         	add	r7, sp, #0x0
; 	elapsed();
 800e0e8: f7ff ffb8    	bl	0x800e05c <elapsed>     @ imm = #-0x90
; 	cycle_count += overflow_cyc;
 800e0ec: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800e178 <sys_clock_isr+0xa0>
 800e0ee: 681b         	ldr	r3, [r3]
 800e0f0: 2200         	movs	r2, #0x0
 800e0f2: 4698         	mov	r8, r3
 800e0f4: 4691         	mov	r9, r2
 800e0f6: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800e17c <sys_clock_isr+0xa4>
 800e0f8: e9d3 2300    	ldrd	r2, r3, [r3]
 800e0fc: eb18 0102    	adds.w	r1, r8, r2
 800e100: 6039         	str	r1, [r7]
 800e102: eb49 0303    	adc.w	r3, r9, r3
 800e106: 607b         	str	r3, [r7, #0x4]
 800e108: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800e17c <sys_clock_isr+0xa4>
 800e10a: e9d7 1200    	ldrd	r1, r2, [r7]
 800e10e: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0;
 800e112: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800e178 <sys_clock_isr+0xa0>
 800e114: 2200         	movs	r2, #0x0
 800e116: 601a         	str	r2, [r3]
; 		dcycles = cycle_count - announced_cycles;
 800e118: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800e17c <sys_clock_isr+0xa4>
 800e11a: e9d3 2300    	ldrd	r2, r3, [r3]
 800e11e: 4611         	mov	r1, r2
 800e120: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800e180 <sys_clock_isr+0xa8>
 800e122: e9d3 2300    	ldrd	r2, r3, [r3]
 800e126: 4613         	mov	r3, r2
 800e128: 1acb         	subs	r3, r1, r3
 800e12a: 60fb         	str	r3, [r7, #0xc]
; 		dticks = dcycles / CYC_PER_TICK;
 800e12c: 68fb         	ldr	r3, [r7, #0xc]
 800e12e: 4a15         	ldr	r2, [pc, #0x54]         @ 0x800e184 <sys_clock_isr+0xac>
 800e130: fba2 2303    	umull	r2, r3, r2, r3
 800e134: 0b9b         	lsrs	r3, r3, #0xe
 800e136: 60bb         	str	r3, [r7, #0x8]
; 		announced_cycles += dticks * CYC_PER_TICK;
 800e138: 68bb         	ldr	r3, [r7, #0x8]
 800e13a: f244 12a0    	movw	r2, #0x41a0
 800e13e: fb02 f303    	mul	r3, r2, r3
 800e142: 2200         	movs	r2, #0x0
 800e144: 461c         	mov	r4, r3
 800e146: 4615         	mov	r5, r2
 800e148: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e180 <sys_clock_isr+0xa8>
 800e14a: e9d3 2300    	ldrd	r2, r3, [r3]
 800e14e: eb14 0a02    	adds.w	r10, r4, r2
 800e152: eb45 0b03    	adc.w	r11, r5, r3
 800e156: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800e180 <sys_clock_isr+0xa8>
 800e158: e9c3 ab00    	strd	r10, r11, [r3]
; 		sys_clock_announce(dticks);
 800e15c: 68bb         	ldr	r3, [r7, #0x8]
 800e15e: 4618         	mov	r0, r3
 800e160: f004 fd9c    	bl	0x8012c9c <sys_clock_announce> @ imm = #0x4b38
; 	z_arm_int_exit();
 800e164: f7f7 ff80    	bl	0x8006068 <z_arm_int_exit> @ imm = #-0x8100
; }
 800e168: bf00         	nop
 800e16a: 3714         	adds	r7, #0x14
 800e16c: 46bd         	mov	sp, r7
 800e16e: e8bd 4fb1    	pop.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 800e172: 4685         	mov	sp, r0
 800e174: 4770         	bx	lr
 800e176: bf00         	nop

0800e178 <$d>:
 800e178: d4 27 00 20  	.word	0x200027d4
 800e17c: 38 1d 00 20  	.word	0x20001d38
 800e180: 40 1d 00 20  	.word	0x20001d40
 800e184: 2d 34 a9 f9  	.word	0xf9a9342d

0800e188 <sys_clock_set_timeout>:
; {
 800e188: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800e18c: b09a         	sub	sp, #0x68
 800e18e: af00         	add	r7, sp, #0x0
 800e190: 61f8         	str	r0, [r7, #0x1c]
 800e192: 460b         	mov	r3, r1
 800e194: 76fb         	strb	r3, [r7, #0x1b]
; 	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
 800e196: 7efb         	ldrb	r3, [r7, #0x1b]
 800e198: 2b00         	cmp	r3, #0x0
 800e19a: d00e         	beq	0x800e1ba <sys_clock_set_timeout+0x32> @ imm = #0x1c
 800e19c: 69fb         	ldr	r3, [r7, #0x1c]
 800e19e: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800e1a2: d10a         	bne	0x800e1ba <sys_clock_set_timeout+0x32> @ imm = #0x14
; 		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 800e1a4: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800e370 <sys_clock_set_timeout+0x1e8>
 800e1a6: 681b         	ldr	r3, [r3]
 800e1a8: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x800e370 <sys_clock_set_timeout+0x1e8>
 800e1aa: f023 0301    	bic	r3, r3, #0x1
 800e1ae: 6013         	str	r3, [r2]
; 		last_load = TIMER_STOPPED;
 800e1b0: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x800e374 <sys_clock_set_timeout+0x1ec>
 800e1b2: f04f 427f    	mov.w	r2, #0xff000000
 800e1b6: 601a         	str	r2, [r3]
 800e1b8: e0d6         	b	0x800e368 <sys_clock_set_timeout+0x1e0> @ imm = #0x1ac
; 	uint32_t last_load_ = last_load;
 800e1ba: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800e374 <sys_clock_set_timeout+0x1ec>
 800e1bc: 681b         	ldr	r3, [r3]
 800e1be: 667b         	str	r3, [r7, #0x64]
; 	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 800e1c0: 69fb         	ldr	r3, [r7, #0x1c]
 800e1c2: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800e1c6: d001         	beq	0x800e1cc <sys_clock_set_timeout+0x44> @ imm = #0x2
 800e1c8: 69fb         	ldr	r3, [r7, #0x1c]
 800e1ca: e001         	b	0x800e1d0 <sys_clock_set_timeout+0x48> @ imm = #0x2
 800e1cc: f240 33e5    	movw	r3, #0x3e5
 800e1d0: 61fb         	str	r3, [r7, #0x1c]
; 	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
 800e1d2: 69fb         	ldr	r3, [r7, #0x1c]
 800e1d4: 2b01         	cmp	r3, #0x1
 800e1d6: dd07         	ble	0x800e1e8 <sys_clock_set_timeout+0x60> @ imm = #0xe
 800e1d8: 69fb         	ldr	r3, [r7, #0x1c]
 800e1da: f240 32e6    	movw	r2, #0x3e6
 800e1de: 4293         	cmp	r3, r2
 800e1e0: bfa8         	it	ge
 800e1e2: 4613         	movge	r3, r2
 800e1e4: 3b01         	subs	r3, #0x1
 800e1e6: e000         	b	0x800e1ea <sys_clock_set_timeout+0x62> @ imm = #0x0
 800e1e8: 2300         	movs	r3, #0x0
 800e1ea: 61fb         	str	r3, [r7, #0x1c]
 800e1ec: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800e378 <sys_clock_set_timeout+0x1f0>
 800e1ee: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e1f0: f3ef 8311    	mrs	r3, basepri
 800e1f4: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800e1f6: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800e1f8: 647b         	str	r3, [r7, #0x44]
 800e1fa: 2310         	movs	r3, #0x10
 800e1fc: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e1fe: 6c3b         	ldr	r3, [r7, #0x40]
 800e200: f383 8812    	msr	basepri_max, r3
; }
 800e204: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e206: f3bf 8f6f    	isb	sy
; }
 800e20a: bf00         	nop
; 	return key;
 800e20c: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800e20e: 623b         	str	r3, [r7, #0x20]
 800e210: 6cfb         	ldr	r3, [r7, #0x4c]
 800e212: 63fb         	str	r3, [r7, #0x3c]
; }
 800e214: bf00         	nop
 800e216: 6cfb         	ldr	r3, [r7, #0x4c]
 800e218: 63bb         	str	r3, [r7, #0x38]
; }
 800e21a: bf00         	nop
; 	return k;
 800e21c: 6a3b         	ldr	r3, [r7, #0x20]
 800e21e: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pending = elapsed();
 800e220: f7ff ff1c    	bl	0x800e05c <elapsed>     @ imm = #-0x1c8
 800e224: 6638         	str	r0, [r7, #0x60]
; 	val1 = SysTick->VAL;
 800e226: 4b52         	ldr	r3, [pc, #0x148]        @ 0x800e370 <sys_clock_set_timeout+0x1e8>
 800e228: 689b         	ldr	r3, [r3, #0x8]
 800e22a: 65fb         	str	r3, [r7, #0x5c]
; 	cycle_count += pending;
 800e22c: 6e3b         	ldr	r3, [r7, #0x60]
 800e22e: 2200         	movs	r2, #0x0
 800e230: 469a         	mov	r10, r3
 800e232: 4693         	mov	r11, r2
 800e234: 4b51         	ldr	r3, [pc, #0x144]        @ 0x800e37c <sys_clock_set_timeout+0x1f4>
 800e236: e9d3 2300    	ldrd	r2, r3, [r3]
 800e23a: eb1a 0102    	adds.w	r1, r10, r2
 800e23e: 6139         	str	r1, [r7, #0x10]
 800e240: eb4b 0303    	adc.w	r3, r11, r3
 800e244: 617b         	str	r3, [r7, #0x14]
 800e246: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800e37c <sys_clock_set_timeout+0x1f4>
 800e248: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 800e24c: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0U;
 800e250: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800e380 <sys_clock_set_timeout+0x1f8>
 800e252: 2200         	movs	r2, #0x0
 800e254: 601a         	str	r2, [r3]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 800e256: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800e37c <sys_clock_set_timeout+0x1f4>
 800e258: e9d3 2300    	ldrd	r2, r3, [r3]
 800e25c: 4611         	mov	r1, r2
 800e25e: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800e384 <sys_clock_set_timeout+0x1fc>
 800e260: e9d3 2300    	ldrd	r2, r3, [r3]
 800e264: 4613         	mov	r3, r2
 800e266: 1acb         	subs	r3, r1, r3
 800e268: 65bb         	str	r3, [r7, #0x58]
; 	if ((int32_t)unannounced < 0) {
 800e26a: 6dbb         	ldr	r3, [r7, #0x58]
 800e26c: 2b00         	cmp	r3, #0x0
 800e26e: da04         	bge	0x800e27a <sys_clock_set_timeout+0xf2> @ imm = #0x8
; 		last_load = MIN_DELAY;
 800e270: 4b40         	ldr	r3, [pc, #0x100]        @ 0x800e374 <sys_clock_set_timeout+0x1ec>
 800e272: f240 421a    	movw	r2, #0x41a
 800e276: 601a         	str	r2, [r3]
 800e278: e02c         	b	0x800e2d4 <sys_clock_set_timeout+0x14c> @ imm = #0x58
; 		delay = ticks * CYC_PER_TICK;
 800e27a: 69fb         	ldr	r3, [r7, #0x1c]
 800e27c: f244 12a0    	movw	r2, #0x41a0
 800e280: fb02 f303    	mul	r3, r2, r3
 800e284: 657b         	str	r3, [r7, #0x54]
; 		delay += unannounced;
 800e286: 6d7a         	ldr	r2, [r7, #0x54]
 800e288: 6dbb         	ldr	r3, [r7, #0x58]
 800e28a: 4413         	add	r3, r2
 800e28c: 657b         	str	r3, [r7, #0x54]
; 		delay = DIV_ROUND_UP(delay, CYC_PER_TICK) * CYC_PER_TICK;
 800e28e: 6d7b         	ldr	r3, [r7, #0x54]
 800e290: f503 4383    	add.w	r3, r3, #0x4180
 800e294: 331f         	adds	r3, #0x1f
 800e296: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x800e388 <sys_clock_set_timeout+0x200>
 800e298: fba2 2303    	umull	r2, r3, r2, r3
 800e29c: 0b9b         	lsrs	r3, r3, #0xe
 800e29e: f244 12a0    	movw	r2, #0x41a0
 800e2a2: fb02 f303    	mul	r3, r2, r3
 800e2a6: 657b         	str	r3, [r7, #0x54]
; 		delay -= unannounced;
 800e2a8: 6d7a         	ldr	r2, [r7, #0x54]
 800e2aa: 6dbb         	ldr	r3, [r7, #0x58]
 800e2ac: 1ad3         	subs	r3, r2, r3
 800e2ae: 657b         	str	r3, [r7, #0x54]
; 		delay = MAX(delay, MIN_DELAY);
 800e2b0: 6d7b         	ldr	r3, [r7, #0x54]
 800e2b2: f240 421a    	movw	r2, #0x41a
 800e2b6: 4293         	cmp	r3, r2
 800e2b8: bf38         	it	lo
 800e2ba: 4613         	movlo	r3, r2
 800e2bc: 657b         	str	r3, [r7, #0x54]
; 		if (delay > MAX_CYCLES) {
 800e2be: 6d7b         	ldr	r3, [r7, #0x54]
 800e2c0: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x800e38c <sys_clock_set_timeout+0x204>
 800e2c2: 4293         	cmp	r3, r2
 800e2c4: d903         	bls	0x800e2ce <sys_clock_set_timeout+0x146> @ imm = #0x6
; 			last_load = MAX_CYCLES;
 800e2c6: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800e374 <sys_clock_set_timeout+0x1ec>
 800e2c8: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x800e38c <sys_clock_set_timeout+0x204>
 800e2ca: 601a         	str	r2, [r3]
 800e2cc: e002         	b	0x800e2d4 <sys_clock_set_timeout+0x14c> @ imm = #0x4
; 			last_load = delay;
 800e2ce: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x800e374 <sys_clock_set_timeout+0x1ec>
 800e2d0: 6d7b         	ldr	r3, [r7, #0x54]
 800e2d2: 6013         	str	r3, [r2]
; 	val2 = SysTick->VAL;
 800e2d4: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800e370 <sys_clock_set_timeout+0x1e8>
 800e2d6: 689b         	ldr	r3, [r3, #0x8]
 800e2d8: 653b         	str	r3, [r7, #0x50]
; 	SysTick->LOAD = last_load - 1;
 800e2da: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800e374 <sys_clock_set_timeout+0x1ec>
 800e2dc: 681b         	ldr	r3, [r3]
 800e2de: 4a24         	ldr	r2, [pc, #0x90]         @ 0x800e370 <sys_clock_set_timeout+0x1e8>
 800e2e0: 3b01         	subs	r3, #0x1
 800e2e2: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 800e2e4: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800e370 <sys_clock_set_timeout+0x1e8>
 800e2e6: 2200         	movs	r2, #0x0
 800e2e8: 609a         	str	r2, [r3, #0x8]
; 	if (val1 < val2) {
 800e2ea: 6dfa         	ldr	r2, [r7, #0x5c]
 800e2ec: 6d3b         	ldr	r3, [r7, #0x50]
 800e2ee: 429a         	cmp	r2, r3
 800e2f0: d216         	bhs	0x800e320 <sys_clock_set_timeout+0x198> @ imm = #0x2c
; 		cycle_count += (val1 + (last_load_ - val2));
 800e2f2: 6e7a         	ldr	r2, [r7, #0x64]
 800e2f4: 6d3b         	ldr	r3, [r7, #0x50]
 800e2f6: 1ad2         	subs	r2, r2, r3
 800e2f8: 6dfb         	ldr	r3, [r7, #0x5c]
 800e2fa: 4413         	add	r3, r2
 800e2fc: 2200         	movs	r2, #0x0
 800e2fe: 4698         	mov	r8, r3
 800e300: 4691         	mov	r9, r2
 800e302: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800e37c <sys_clock_set_timeout+0x1f4>
 800e304: e9d3 2300    	ldrd	r2, r3, [r3]
 800e308: eb18 0102    	adds.w	r1, r8, r2
 800e30c: 60b9         	str	r1, [r7, #0x8]
 800e30e: eb49 0303    	adc.w	r3, r9, r3
 800e312: 60fb         	str	r3, [r7, #0xc]
 800e314: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800e37c <sys_clock_set_timeout+0x1f4>
 800e316: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 800e31a: e9c3 1200    	strd	r1, r2, [r3]
 800e31e: e012         	b	0x800e346 <sys_clock_set_timeout+0x1be> @ imm = #0x24
; 		cycle_count += (val1 - val2);
 800e320: 6dfa         	ldr	r2, [r7, #0x5c]
 800e322: 6d3b         	ldr	r3, [r7, #0x50]
 800e324: 1ad3         	subs	r3, r2, r3
 800e326: 2200         	movs	r2, #0x0
 800e328: 461c         	mov	r4, r3
 800e32a: 4615         	mov	r5, r2
 800e32c: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800e37c <sys_clock_set_timeout+0x1f4>
 800e32e: e9d3 2300    	ldrd	r2, r3, [r3]
 800e332: 18a1         	adds	r1, r4, r2
 800e334: 6039         	str	r1, [r7]
 800e336: eb45 0303    	adc.w	r3, r5, r3
 800e33a: 607b         	str	r3, [r7, #0x4]
 800e33c: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800e37c <sys_clock_set_timeout+0x1f4>
 800e33e: e9d7 1200    	ldrd	r1, r2, [r7]
 800e342: e9c3 1200    	strd	r1, r2, [r3]
 800e346: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800e378 <sys_clock_set_timeout+0x1f0>
 800e348: 637b         	str	r3, [r7, #0x34]
 800e34a: 6abb         	ldr	r3, [r7, #0x28]
 800e34c: 627b         	str	r3, [r7, #0x24]
; 	arch_irq_unlock(key.key);
 800e34e: 6a7b         	ldr	r3, [r7, #0x24]
 800e350: 633b         	str	r3, [r7, #0x30]
 800e352: 6b3b         	ldr	r3, [r7, #0x30]
 800e354: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e356: 6afb         	ldr	r3, [r7, #0x2c]
 800e358: f383 8811    	msr	basepri, r3
; }
 800e35c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e35e: f3bf 8f6f    	isb	sy
; }
 800e362: bf00         	nop
; }
 800e364: bf00         	nop
; }
 800e366: bf00         	nop
; }
 800e368: 3768         	adds	r7, #0x68
 800e36a: 46bd         	mov	sp, r7
 800e36c: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800e370 <$d>:
 800e370: 10 e0 00 e0  	.word	0xe000e010
 800e374: d0 27 00 20  	.word	0x200027d0
 800e378: d0 27 00 20  	.word	0x200027d0
 800e37c: 38 1d 00 20  	.word	0x20001d38
 800e380: d4 27 00 20  	.word	0x200027d4
 800e384: 40 1d 00 20  	.word	0x20001d40
 800e388: 2d 34 a9 f9  	.word	0xf9a9342d
 800e38c: 20 94 ff 00  	.word	0x00ff9420

0800e390 <sys_clock_elapsed>:
; {
 800e390: b580         	push	{r7, lr}
 800e392: b08e         	sub	sp, #0x38
 800e394: af00         	add	r7, sp, #0x0
 800e396: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800e420 <sys_clock_elapsed+0x90>
 800e398: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e39a: f3ef 8311    	mrs	r3, basepri
 800e39e: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 800e3a0: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 800e3a2: 61bb         	str	r3, [r7, #0x18]
 800e3a4: 2310         	movs	r3, #0x10
 800e3a6: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e3a8: 697b         	ldr	r3, [r7, #0x14]
 800e3aa: f383 8812    	msr	basepri_max, r3
; }
 800e3ae: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e3b0: f3bf 8f6f    	isb	sy
; }
 800e3b4: bf00         	nop
; 	return key;
 800e3b6: 69bb         	ldr	r3, [r7, #0x18]
; 	k.key = arch_irq_lock();
 800e3b8: 607b         	str	r3, [r7, #0x4]
 800e3ba: 6a3b         	ldr	r3, [r7, #0x20]
 800e3bc: 613b         	str	r3, [r7, #0x10]
; }
 800e3be: bf00         	nop
 800e3c0: 6a3b         	ldr	r3, [r7, #0x20]
 800e3c2: 60fb         	str	r3, [r7, #0xc]
; }
 800e3c4: bf00         	nop
; 	return k;
 800e3c6: 687b         	ldr	r3, [r7, #0x4]
 800e3c8: 60bb         	str	r3, [r7, #0x8]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 800e3ca: 4b16         	ldr	r3, [pc, #0x58]         @ 0x800e424 <sys_clock_elapsed+0x94>
 800e3cc: e9d3 2300    	ldrd	r2, r3, [r3]
 800e3d0: 4611         	mov	r1, r2
 800e3d2: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800e428 <sys_clock_elapsed+0x98>
 800e3d4: e9d3 2300    	ldrd	r2, r3, [r3]
 800e3d8: 4613         	mov	r3, r2
 800e3da: 1acb         	subs	r3, r1, r3
 800e3dc: 637b         	str	r3, [r7, #0x34]
; 	uint32_t cyc = elapsed() + unannounced;
 800e3de: f7ff fe3d    	bl	0x800e05c <elapsed>     @ imm = #-0x386
 800e3e2: 4602         	mov	r2, r0
 800e3e4: 6b7b         	ldr	r3, [r7, #0x34]
 800e3e6: 4413         	add	r3, r2
 800e3e8: 633b         	str	r3, [r7, #0x30]
 800e3ea: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800e420 <sys_clock_elapsed+0x90>
 800e3ec: 62fb         	str	r3, [r7, #0x2c]
 800e3ee: 68bb         	ldr	r3, [r7, #0x8]
 800e3f0: 603b         	str	r3, [r7]
; 	arch_irq_unlock(key.key);
 800e3f2: 683b         	ldr	r3, [r7]
 800e3f4: 62bb         	str	r3, [r7, #0x28]
 800e3f6: 6abb         	ldr	r3, [r7, #0x28]
 800e3f8: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e3fa: 6a7b         	ldr	r3, [r7, #0x24]
 800e3fc: f383 8811    	msr	basepri, r3
; }
 800e400: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e402: f3bf 8f6f    	isb	sy
; }
 800e406: bf00         	nop
; }
 800e408: bf00         	nop
; }
 800e40a: bf00         	nop
; 	return cyc / CYC_PER_TICK;
 800e40c: 6b3b         	ldr	r3, [r7, #0x30]
 800e40e: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800e42c <sys_clock_elapsed+0x9c>
 800e410: fba2 2303    	umull	r2, r3, r2, r3
 800e414: 0b9b         	lsrs	r3, r3, #0xe
; }
 800e416: 4618         	mov	r0, r3
 800e418: 3738         	adds	r7, #0x38
 800e41a: 46bd         	mov	sp, r7
 800e41c: bd80         	pop	{r7, pc}
 800e41e: bf00         	nop

0800e420 <$d>:
 800e420: d0 27 00 20  	.word	0x200027d0
 800e424: 38 1d 00 20  	.word	0x20001d38
 800e428: 40 1d 00 20  	.word	0x20001d40
 800e42c: 2d 34 a9 f9  	.word	0xf9a9342d

0800e430 <sys_clock_cycle_get_32>:
; {
 800e430: b580         	push	{r7, lr}
 800e432: b08e         	sub	sp, #0x38
 800e434: af00         	add	r7, sp, #0x0
 800e436: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800e4ac <sys_clock_cycle_get_32+0x7c>
 800e438: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800e43a: f3ef 8311    	mrs	r3, basepri
 800e43e: 623b         	str	r3, [r7, #0x20]
;   return(result);
 800e440: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 800e442: 61fb         	str	r3, [r7, #0x1c]
 800e444: 2310         	movs	r3, #0x10
 800e446: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800e448: 69bb         	ldr	r3, [r7, #0x18]
 800e44a: f383 8812    	msr	basepri_max, r3
; }
 800e44e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e450: f3bf 8f6f    	isb	sy
; }
 800e454: bf00         	nop
; 	return key;
 800e456: 69fb         	ldr	r3, [r7, #0x1c]
; 	k.key = arch_irq_lock();
 800e458: 60bb         	str	r3, [r7, #0x8]
 800e45a: 6a7b         	ldr	r3, [r7, #0x24]
 800e45c: 617b         	str	r3, [r7, #0x14]
; }
 800e45e: bf00         	nop
 800e460: 6a7b         	ldr	r3, [r7, #0x24]
 800e462: 613b         	str	r3, [r7, #0x10]
; }
 800e464: bf00         	nop
; 	return k;
 800e466: 68bb         	ldr	r3, [r7, #0x8]
 800e468: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ret = cycle_count;
 800e46a: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800e4b0 <sys_clock_cycle_get_32+0x80>
 800e46c: e9d3 2300    	ldrd	r2, r3, [r3]
 800e470: 4613         	mov	r3, r2
 800e472: 637b         	str	r3, [r7, #0x34]
; 	ret += elapsed();
 800e474: f7ff fdf2    	bl	0x800e05c <elapsed>     @ imm = #-0x41c
 800e478: 4602         	mov	r2, r0
 800e47a: 6b7b         	ldr	r3, [r7, #0x34]
 800e47c: 4413         	add	r3, r2
 800e47e: 637b         	str	r3, [r7, #0x34]
 800e480: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800e4ac <sys_clock_cycle_get_32+0x7c>
 800e482: 633b         	str	r3, [r7, #0x30]
 800e484: 68fb         	ldr	r3, [r7, #0xc]
 800e486: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 800e488: 687b         	ldr	r3, [r7, #0x4]
 800e48a: 62fb         	str	r3, [r7, #0x2c]
 800e48c: 6afb         	ldr	r3, [r7, #0x2c]
 800e48e: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800e490: 6abb         	ldr	r3, [r7, #0x28]
 800e492: f383 8811    	msr	basepri, r3
; }
 800e496: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800e498: f3bf 8f6f    	isb	sy
; }
 800e49c: bf00         	nop
; }
 800e49e: bf00         	nop
; }
 800e4a0: bf00         	nop
; 	return ret;
 800e4a2: 6b7b         	ldr	r3, [r7, #0x34]
; }
 800e4a4: 4618         	mov	r0, r3
 800e4a6: 3738         	adds	r7, #0x38
 800e4a8: 46bd         	mov	sp, r7
 800e4aa: bd80         	pop	{r7, pc}

0800e4ac <$d>:
 800e4ac: d0 27 00 20  	.word	0x200027d0
 800e4b0: 38 1d 00 20  	.word	0x20001d38

0800e4b4 <sys_clock_driver_init>:
; {
 800e4b4: b580         	push	{r7, lr}
 800e4b6: af00         	add	r7, sp, #0x0
; 	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
 800e4b8: 2101         	movs	r1, #0x1
 800e4ba: f04f 30ff    	mov.w	r0, #0xffffffff
 800e4be: f7ff fda3    	bl	0x800e008 <__NVIC_SetPriority> @ imm = #-0x4ba
; 	last_load = CYC_PER_TICK;
 800e4c2: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800e4f4 <sys_clock_driver_init+0x40>
 800e4c4: f244 12a0    	movw	r2, #0x41a0
 800e4c8: 601a         	str	r2, [r3]
; 	overflow_cyc = 0U;
 800e4ca: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800e4f8 <sys_clock_driver_init+0x44>
 800e4cc: 2200         	movs	r2, #0x0
 800e4ce: 601a         	str	r2, [r3]
; 	SysTick->LOAD = last_load - 1;
 800e4d0: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800e4f4 <sys_clock_driver_init+0x40>
 800e4d2: 681b         	ldr	r3, [r3]
 800e4d4: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800e4fc <sys_clock_driver_init+0x48>
 800e4d6: 3b01         	subs	r3, #0x1
 800e4d8: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 800e4da: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800e4fc <sys_clock_driver_init+0x48>
 800e4dc: 2200         	movs	r2, #0x0
 800e4de: 609a         	str	r2, [r3, #0x8]
; 	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
 800e4e0: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800e4fc <sys_clock_driver_init+0x48>
 800e4e2: 681b         	ldr	r3, [r3]
 800e4e4: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800e4fc <sys_clock_driver_init+0x48>
 800e4e6: f043 0307    	orr	r3, r3, #0x7
 800e4ea: 6013         	str	r3, [r2]
; 	return 0;
 800e4ec: 2300         	movs	r3, #0x0
; }
 800e4ee: 4618         	mov	r0, r3
 800e4f0: bd80         	pop	{r7, pc}
 800e4f2: bf00         	nop

0800e4f4 <$d>:
 800e4f4: d0 27 00 20  	.word	0x200027d0
 800e4f8: d4 27 00 20  	.word	0x200027d4
 800e4fc: 10 e0 00 e0  	.word	0xe000e010

0800e500 <arm_mat_add_f32>:
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 800e500: 8803         	ldrh	r3, [r0]
 800e502: f8b0 c002    	ldrh.w	r12, [r0, #0x2]
;   float32_t *pInB = pSrcB->pData;                /* input data matrix pointer B */
 800e506: 6849         	ldr	r1, [r1, #0x4]
;   float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A */
 800e508: 6840         	ldr	r0, [r0, #0x4]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 800e50a: 6852         	ldr	r2, [r2, #0x4]
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 800e50c: fb0c f303    	mul	r3, r12, r3
;     while (blkCnt > 0U)
 800e510: b14b         	cbz	r3, 0x800e526 <arm_mat_add_f32+0x26> @ imm = #0x12
;       *pOut++ = *pInA++ + *pInB++;
 800e512: ecf0 7a01    	vldmia	r0!, {s15}
 800e516: ecb1 7a01    	vldmia	r1!, {s14}
 800e51a: ee77 7a87    	vadd.f32	s15, s15, s14
;     while (blkCnt > 0U)
 800e51e: 3b01         	subs	r3, #0x1
;       *pOut++ = *pInA++ + *pInB++;
 800e520: ece2 7a01    	vstmia	r2!, {s15}
;     while (blkCnt > 0U)
 800e524: d1f5         	bne	0x800e512 <arm_mat_add_f32+0x12> @ imm = #-0x16
; }
 800e526: 2000         	movs	r0, #0x0
 800e528: 4770         	bx	lr
 800e52a: bf00         	nop

0800e52c <arm_mat_init_f32>:
;   S->numRows = nRows;
 800e52c: 8001         	strh	r1, [r0]
;   S->numCols = nColumns;
 800e52e: 8042         	strh	r2, [r0, #0x2]
;   S->pData = pData;
 800e530: 6043         	str	r3, [r0, #0x4]
; }
 800e532: 4770         	bx	lr

0800e534 <arm_mat_inverse_f32>:
; {
 800e534: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800e538: 4604         	mov	r4, r0
;   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
 800e53a: 8806         	ldrh	r6, [r0]
;   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
 800e53c: 8863         	ldrh	r3, [r4, #0x2]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 800e53e: 6848         	ldr	r0, [r1, #0x4]
; {
 800e540: b083         	sub	sp, #0xc
 800e542: 460d         	mov	r5, r1
;   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
 800e544: 9301         	str	r3, [sp, #0x4]
;     while (rowCnt > 0U)
 800e546: b346         	cbz	r6, 0x800e59a <arm_mat_inverse_f32+0x66> @ imm = #0x50
;   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
 800e548: 46b1         	mov	r9, r6
;     while (rowCnt > 0U)
 800e54a: f04f 0a00    	mov.w	r10, #0x0
;       *pTmp++ = 1.0f;
 800e54e: f04f 5b7e    	mov.w	r11, #0x3f800000
 800e552: e011         	b	0x800e578 <arm_mat_inverse_f32+0x44> @ imm = #0x22
;         *pTmp++ = 0.0f;
 800e554: f011 fbc0    	bl	0x801fcd8 <memset>      @ imm = #0x11780
;       while (j > 0U)
 800e558: f1b9 0901    	subs.w	r9, r9, #0x1
;       *pTmp++ = 1.0f;
 800e55c: f848 bb04    	str	r11, [r8], #4
;       while (j > 0U)
 800e560: f10a 0a01    	add.w	r10, r10, #0x1
 800e564: d019         	beq	0x800e59a <arm_mat_inverse_f32+0x66> @ imm = #0x32
 800e566: ea4f 0789    	lsl.w	r7, r9, #0x2
;         *pTmp++ = 0.0f;
 800e56a: 463a         	mov	r2, r7
 800e56c: 2100         	movs	r1, #0x0
 800e56e: 4640         	mov	r0, r8
 800e570: f011 fbb2    	bl	0x801fcd8 <memset>      @ imm = #0x11764
 800e574: eb08 0007    	add.w	r0, r8, r7
;       while (j > 0U)
 800e578: ea4f 028a    	lsl.w	r2, r10, #0x2
;       *pTmp++ = 1.0f;
 800e57c: eb00 0802    	add.w	r8, r0, r2
;         *pTmp++ = 0.0f;
 800e580: 2100         	movs	r1, #0x0
;       while (j > 0U)
 800e582: f1ba 0f00    	cmp.w	r10, #0x0
 800e586: d1e5         	bne	0x800e554 <arm_mat_inverse_f32+0x20> @ imm = #-0x36
;       *pTmp++ = 1.0f;
 800e588: 4680         	mov	r8, r0
;       while (j > 0U)
 800e58a: f1b9 0901    	subs.w	r9, r9, #0x1
;       *pTmp++ = 1.0f;
 800e58e: f848 bb04    	str	r11, [r8], #4
;       while (j > 0U)
 800e592: d002         	beq	0x800e59a <arm_mat_inverse_f32+0x66> @ imm = #0x4
 800e594: f04f 0a01    	mov.w	r10, #0x1
 800e598: e7e5         	b	0x800e566 <arm_mat_inverse_f32+0x32> @ imm = #-0x36
;     for(column = 0U; column < numCols; column++)
 800e59a: 9b01         	ldr	r3, [sp, #0x4]
 800e59c: 2b00         	cmp	r3, #0x0
 800e59e: f000 80ef    	beq.w	0x800e780 <arm_mat_inverse_f32+0x24c> @ imm = #0x1de
 800e5a2: f04f 0800    	mov.w	r8, #0x0
;       pivot = 1.0f / pivot;
 800e5a6: eef7 5a00    	vmov.f32	s11, #1.000000e+00
;     for(column = 0U; column < numCols; column++)
 800e5aa: 46c1         	mov	r9, r8
;   uint32_t selectedRow,pivotRow,i, rowNb, rowCnt, flag = 0U, j,column;      /* loop counters */
 800e5ac: 46c2         	mov	r10, r8
;       pTmp = ELEM(pSrc,column,column) ;
 800e5ae: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
 800e5b2: f8d4 b004    	ldr.w	r11, [r4, #0x4]
 800e5b6: f10c 0e01    	add.w	lr, r12, #0x1
 800e5ba: ea4f 0e8e    	lsl.w	lr, lr, #0x2
 800e5be: fb0e b209    	mla	r2, lr, r9, r11
;       pivot = *pTmp;
 800e5c2: 464b         	mov	r3, r9
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800e5c4: f109 0901    	add.w	r9, r9, #0x1
 800e5c8: 454e         	cmp	r6, r9
;       pivot = *pTmp;
 800e5ca: ed92 7a00    	vldr	s14, [r2]
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800e5ce: f240 810d    	bls.w	0x800e7ec <arm_mat_inverse_f32+0x2b8> @ imm = #0x21a
 800e5d2: fb09 300c    	mla	r0, r9, r12, r3
 800e5d6: f1ae 0e04    	sub.w	lr, lr, #0x4
 800e5da: eb0b 0080    	add.w	r0, r11, r0, lsl #2
 800e5de: 4649         	mov	r1, r9
 800e5e0: 461f         	mov	r7, r3
;           newPivot = *pTmp;
 800e5e2: edd0 7a00    	vldr	s15, [r0]
;     __asm__ ("vabs.f32\t%0, %1" : "=t" (result) : "t" (x));
 800e5e6: eeb0 6ac7    	vabs.f32	s12, s14
 800e5ea: eef0 6ae7    	vabs.f32	s13, s15
;             pivot = newPivot;
 800e5ee: eeb4 6ae6    	vcmpe.f32	s12, s13
 800e5f2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800e5f6: bf48         	it	mi
 800e5f8: 460f         	movmi	r7, r1
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800e5fa: f101 0101    	add.w	r1, r1, #0x1
;             pivot = newPivot;
 800e5fe: bf48         	it	mi
 800e600: eeb0 7a67    	vmovmi.f32	s14, s15
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800e604: 428e         	cmp	r6, r1
 800e606: 4470         	add	r0, lr
 800e608: d1eb         	bne	0x800e5e2 <arm_mat_inverse_f32+0xae> @ imm = #-0x2a
;       if ((pivot != 0.0f) && (selectedRow != column))
 800e60a: eeb5 7a40    	vcmp.f32	s14, #0
 800e60e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800e612: f000 80b1    	beq.w	0x800e778 <arm_mat_inverse_f32+0x244> @ imm = #0x162
 800e616: 4547         	cmp	r7, r8
 800e618: f040 80b7    	bne.w	0x800e78a <arm_mat_inverse_f32+0x256> @ imm = #0x16e
;       if ((flag != 1U) && (pivot == 0.0f))
 800e61c: f1ba 0f01    	cmp.w	r10, #0x1
 800e620: f000 80dd    	beq.w	0x800e7de <arm_mat_inverse_f32+0x2aa> @ imm = #0x1ba
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800e624: fb0c 3203    	mla	r2, r12, r3, r3
 800e628: eb0b 0282    	add.w	r2, r11, r2, lsl #2
 800e62c: ebac 0103    	sub.w	r1, r12, r3
 800e630: 2900         	cmp	r1, #0x0
;       pivot = 1.0f / pivot;
 800e632: eec5 7a87    	vdiv.f32	s15, s11, s14
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800e636: dd09         	ble	0x800e64c <arm_mat_inverse_f32+0x118> @ imm = #0x12
 800e638: eb02 0181    	add.w	r1, r2, r1, lsl #2
 800e63c: ecb2 7a01    	vldmia	r2!, {s14}
 800e640: ee27 7a27    	vmul.f32	s14, s14, s15
 800e644: 428a         	cmp	r2, r1
 800e646: ed02 7a01    	vstr	s14, [r2, #-4]
 800e64a: d1f7         	bne	0x800e63c <arm_mat_inverse_f32+0x108> @ imm = #-0x12
;       SCALE_ROW_F32(pDst,0,pivot,pivotRow);
 800e64c: 8868         	ldrh	r0, [r5, #0x2]
 800e64e: 686a         	ldr	r2, [r5, #0x4]
 800e650: 0081         	lsls	r1, r0, #0x2
 800e652: fb01 2203    	mla	r2, r1, r3, r2
 800e656: 4411         	add	r1, r2
 800e658: b138         	cbz	r0, 0x800e66a <arm_mat_inverse_f32+0x136> @ imm = #0xe
 800e65a: ecb2 7a01    	vldmia	r2!, {s14}
 800e65e: ee27 7a27    	vmul.f32	s14, s14, s15
 800e662: 428a         	cmp	r2, r1
 800e664: ed02 7a01    	vstr	s14, [r2, #-4]
 800e668: d1f7         	bne	0x800e65a <arm_mat_inverse_f32+0x126> @ imm = #-0x12
;       rowNb = 0;
 800e66a: 2000         	movs	r0, #0x0
;       for (;rowNb < pivotRow; rowNb++)
 800e66c: f1b8 0f00    	cmp.w	r8, #0x0
 800e670: d036         	beq	0x800e6e0 <arm_mat_inverse_f32+0x1ac> @ imm = #0x6c
;            pTmp = ELEM(pSrc,rowNb,column) ;
 800e672: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
 800e676: 6861         	ldr	r1, [r4, #0x4]
 800e678: fb00 320c    	mla	r2, r0, r12, r3
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800e67c: ebac 0703    	sub.w	r7, r12, r3
;            pTmp = ELEM(pSrc,rowNb,column) ;
 800e680: eb01 0282    	add.w	r2, r1, r2, lsl #2
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800e684: fb0c 3c03    	mla	r12, r12, r3, r3
 800e688: 2f00         	cmp	r7, #0x0
;            pivot = *pTmp;
 800e68a: edd2 7a00    	vldr	s15, [r2]
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800e68e: eb01 018c    	add.w	r1, r1, r12, lsl #2
 800e692: dd0b         	ble	0x800e6ac <arm_mat_inverse_f32+0x178> @ imm = #0x16
 800e694: eb02 0787    	add.w	r7, r2, r7, lsl #2
 800e698: ecb2 7a01    	vldmia	r2!, {s14}
 800e69c: ecf1 6a01    	vldmia	r1!, {s13}
 800e6a0: eea6 7ae7    	vfms.f32	s14, s13, s15
 800e6a4: 42ba         	cmp	r2, r7
 800e6a6: ed02 7a01    	vstr	s14, [r2, #-4]
 800e6aa: d1f5         	bne	0x800e698 <arm_mat_inverse_f32+0x164> @ imm = #-0x16
;            MAS_ROW_F32(0     ,pDst,rowNb,pivot,pDst,pivotRow);
 800e6ac: f8b5 c002    	ldrh.w	r12, [r5, #0x2]
 800e6b0: 6869         	ldr	r1, [r5, #0x4]
 800e6b2: ea4f 078c    	lsl.w	r7, r12, #0x2
 800e6b6: fb07 1200    	mla	r2, r7, r0, r1
 800e6ba: fb07 1103    	mla	r1, r7, r3, r1
 800e6be: 4417         	add	r7, r2
 800e6c0: f1bc 0f00    	cmp.w	r12, #0x0
 800e6c4: d009         	beq	0x800e6da <arm_mat_inverse_f32+0x1a6> @ imm = #0x12
 800e6c6: ecb2 7a01    	vldmia	r2!, {s14}
 800e6ca: ecf1 6a01    	vldmia	r1!, {s13}
 800e6ce: eea6 7ae7    	vfms.f32	s14, s13, s15
 800e6d2: 42ba         	cmp	r2, r7
 800e6d4: ed02 7a01    	vstr	s14, [r2, #-4]
 800e6d8: d1f5         	bne	0x800e6c6 <arm_mat_inverse_f32+0x192> @ imm = #-0x16
;       for (;rowNb < pivotRow; rowNb++)
 800e6da: 3001         	adds	r0, #0x1
 800e6dc: 4540         	cmp	r0, r8
 800e6de: d1c8         	bne	0x800e672 <arm_mat_inverse_f32+0x13e> @ imm = #-0x70
;       for (rowNb = pivotRow + 1; rowNb < numRows; rowNb++)
 800e6e0: 454e         	cmp	r6, r9
 800e6e2: d937         	bls	0x800e754 <arm_mat_inverse_f32+0x220> @ imm = #0x6e
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800e6e4: 4648         	mov	r0, r9
;            pTmp = ELEM(pSrc,rowNb,column) ;
 800e6e6: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
 800e6ea: 6861         	ldr	r1, [r4, #0x4]
 800e6ec: fb00 320c    	mla	r2, r0, r12, r3
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800e6f0: ebac 0703    	sub.w	r7, r12, r3
;            pTmp = ELEM(pSrc,rowNb,column) ;
 800e6f4: eb01 0282    	add.w	r2, r1, r2, lsl #2
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800e6f8: fb0c 3c03    	mla	r12, r12, r3, r3
 800e6fc: 2f00         	cmp	r7, #0x0
;            pivot = *pTmp;
 800e6fe: edd2 7a00    	vldr	s15, [r2]
;            MAS_ROW_F32(column,pSrc,rowNb,pivot,pSrc,pivotRow);
 800e702: eb01 018c    	add.w	r1, r1, r12, lsl #2
 800e706: dd0b         	ble	0x800e720 <arm_mat_inverse_f32+0x1ec> @ imm = #0x16
 800e708: eb02 0787    	add.w	r7, r2, r7, lsl #2
 800e70c: ecb2 7a01    	vldmia	r2!, {s14}
 800e710: ecf1 6a01    	vldmia	r1!, {s13}
 800e714: eea6 7ae7    	vfms.f32	s14, s13, s15
 800e718: 42ba         	cmp	r2, r7
 800e71a: ed02 7a01    	vstr	s14, [r2, #-4]
 800e71e: d1f5         	bne	0x800e70c <arm_mat_inverse_f32+0x1d8> @ imm = #-0x16
;            MAS_ROW_F32(0     ,pDst,rowNb,pivot,pDst,pivotRow);
 800e720: f8b5 c002    	ldrh.w	r12, [r5, #0x2]
 800e724: 6869         	ldr	r1, [r5, #0x4]
 800e726: ea4f 078c    	lsl.w	r7, r12, #0x2
 800e72a: fb00 1207    	mla	r2, r0, r7, r1
 800e72e: fb03 1107    	mla	r1, r3, r7, r1
 800e732: 4417         	add	r7, r2
 800e734: f1bc 0f00    	cmp.w	r12, #0x0
 800e738: d009         	beq	0x800e74e <arm_mat_inverse_f32+0x21a> @ imm = #0x12
 800e73a: ecb2 7a01    	vldmia	r2!, {s14}
 800e73e: ecf1 6a01    	vldmia	r1!, {s13}
 800e742: eea6 7ae7    	vfms.f32	s14, s13, s15
 800e746: 42ba         	cmp	r2, r7
 800e748: ed02 7a01    	vstr	s14, [r2, #-4]
 800e74c: d1f5         	bne	0x800e73a <arm_mat_inverse_f32+0x206> @ imm = #-0x16
;       for (rowNb = pivotRow + 1; rowNb < numRows; rowNb++)
 800e74e: 3001         	adds	r0, #0x1
 800e750: 4286         	cmp	r6, r0
 800e752: d1c8         	bne	0x800e6e6 <arm_mat_inverse_f32+0x1b2> @ imm = #-0x70
;     for(column = 0U; column < numCols; column++)
 800e754: 9b01         	ldr	r3, [sp, #0x4]
 800e756: 454b         	cmp	r3, r9
 800e758: f108 0801    	add.w	r8, r8, #0x1
 800e75c: f47f af27    	bne.w	0x800e5ae <arm_mat_inverse_f32+0x7a> @ imm = #-0x1b2
;     if ((flag != 1U) && (pivot == 0.0f))
 800e760: f1ba 0f01    	cmp.w	r10, #0x1
 800e764: d004         	beq	0x800e770 <arm_mat_inverse_f32+0x23c> @ imm = #0x8
 800e766: eef5 7a40    	vcmp.f32	s15, #0
 800e76a: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800e76e: d050         	beq	0x800e812 <arm_mat_inverse_f32+0x2de> @ imm = #0xa0
;     status = ARM_MATH_SUCCESS;
 800e770: 2000         	movs	r0, #0x0
; }
 800e772: b003         	add	sp, #0xc
 800e774: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
;       if ((flag != 1U) && (pivot == 0.0f))
 800e778: f1ba 0f01    	cmp.w	r10, #0x1
 800e77c: f43f af56    	beq.w	0x800e62c <arm_mat_inverse_f32+0xf8> @ imm = #-0x154
;         return ARM_MATH_SINGULAR;
 800e780: f06f 0004    	mvn	r0, #0x4
; }
 800e784: b003         	add	sp, #0xc
 800e786: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
;             SWAP_ROWS_F32(pSrc,column, pivotRow,selectedRow);
 800e78a: fb07 310c    	mla	r1, r7, r12, r3
 800e78e: ebac 0c03    	sub.w	r12, r12, r3
 800e792: f1bc 0f00    	cmp.w	r12, #0x0
 800e796: eb0b 0181    	add.w	r1, r11, r1, lsl #2
 800e79a: dd0a         	ble	0x800e7b2 <arm_mat_inverse_f32+0x27e> @ imm = #0x14
 800e79c: eb02 0e8c    	add.w	lr, r2, r12, lsl #2
 800e7a0: f8d1 c000    	ldr.w	r12, [r1]
 800e7a4: 6810         	ldr	r0, [r2]
 800e7a6: f842 cb04    	str	r12, [r2], #4
 800e7aa: 4572         	cmp	r2, lr
 800e7ac: f841 0b04    	str	r0, [r1], #4
 800e7b0: d1f6         	bne	0x800e7a0 <arm_mat_inverse_f32+0x26c> @ imm = #-0x14
;             SWAP_ROWS_F32(pDst,0, pivotRow,selectedRow);
 800e7b2: 8869         	ldrh	r1, [r5, #0x2]
 800e7b4: 686a         	ldr	r2, [r5, #0x4]
 800e7b6: ea4f 0c81    	lsl.w	r12, r1, #0x2
 800e7ba: fb0c 2707    	mla	r7, r12, r7, r2
 800e7be: fb0c 2203    	mla	r2, r12, r3, r2
 800e7c2: b1a9         	cbz	r1, 0x800e7f0 <arm_mat_inverse_f32+0x2bc> @ imm = #0x2a
 800e7c4: 4494         	add	r12, r2
 800e7c6: 6838         	ldr	r0, [r7]
 800e7c8: 6811         	ldr	r1, [r2]
 800e7ca: f842 0b04    	str	r0, [r2], #4
 800e7ce: 4562         	cmp	r2, r12
 800e7d0: f847 1b04    	str	r1, [r7], #4
 800e7d4: d1f7         	bne	0x800e7c6 <arm_mat_inverse_f32+0x292> @ imm = #-0x12
 800e7d6: f8b4 c002    	ldrh.w	r12, [r4, #0x2]
 800e7da: f8d4 b004    	ldr.w	r11, [r4, #0x4]
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800e7de: fb0c 3203    	mla	r2, r12, r3, r3
 800e7e2: eb0b 0282    	add.w	r2, r11, r2, lsl #2
 800e7e6: f04f 0a01    	mov.w	r10, #0x1
 800e7ea: e71f         	b	0x800e62c <arm_mat_inverse_f32+0xf8> @ imm = #-0x1c2
;       for (rowNb = column+1; rowNb < numRows; rowNb++)
 800e7ec: 461f         	mov	r7, r3
 800e7ee: e70c         	b	0x800e60a <arm_mat_inverse_f32+0xd6> @ imm = #-0x1e8
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800e7f0: 8861         	ldrh	r1, [r4, #0x2]
 800e7f2: 6862         	ldr	r2, [r4, #0x4]
 800e7f4: fb01 3003    	mla	r0, r1, r3, r3
 800e7f8: 1ac9         	subs	r1, r1, r3
;       pivot = 1.0f / pivot;
 800e7fa: eef7 6a00    	vmov.f32	s13, #1.000000e+00
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800e7fe: 2900         	cmp	r1, #0x0
;       pivot = 1.0f / pivot;
 800e800: eec6 7a87    	vdiv.f32	s15, s13, s14
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800e804: eb02 0280    	add.w	r2, r2, r0, lsl #2
;             flag = 1U;
 800e808: f04f 0a01    	mov.w	r10, #0x1
;       SCALE_ROW_F32(pSrc,column,pivot,pivotRow);
 800e80c: f73f af14    	bgt.w	0x800e638 <arm_mat_inverse_f32+0x104> @ imm = #-0x1d8
 800e810: e72b         	b	0x800e66a <arm_mat_inverse_f32+0x136> @ imm = #-0x1aa
;       for (i = 0; i < numRows * numCols; i++)
 800e812: fb03 f606    	mul	r6, r3, r6
;       pIn = pSrc->pData;
 800e816: 6863         	ldr	r3, [r4, #0x4]
;       for (i = 0; i < numRows * numCols; i++)
 800e818: b926         	cbnz	r6, 0x800e824 <arm_mat_inverse_f32+0x2f0> @ imm = #0x8
 800e81a: e7b1         	b	0x800e780 <arm_mat_inverse_f32+0x24c> @ imm = #-0x9e
 800e81c: f10a 0a01    	add.w	r10, r10, #0x1
 800e820: 45b2         	cmp	r10, r6
 800e822: d0ad         	beq	0x800e780 <arm_mat_inverse_f32+0x24c> @ imm = #-0xa6
;         if (pIn[i] != 0.0f)
 800e824: ecf3 7a01    	vldmia	r3!, {s15}
 800e828: eef5 7a40    	vcmp.f32	s15, #0
 800e82c: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 800e830: d0f4         	beq	0x800e81c <arm_mat_inverse_f32+0x2e8> @ imm = #-0x18
;       if (i == numRows * numCols)
 800e832: 4556         	cmp	r6, r10
 800e834: d19c         	bne	0x800e770 <arm_mat_inverse_f32+0x23c> @ imm = #-0xc8
 800e836: e7a3         	b	0x800e780 <arm_mat_inverse_f32+0x24c> @ imm = #-0xba

0800e838 <arm_mat_mult_f32>:
; {
 800e838: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 800e83c: 460e         	mov	r6, r1
;   float32_t *pIn2 = pSrcB->pData;                /* Input data matrix pointer B */
 800e83e: 684b         	ldr	r3, [r1, #0x4]
;   uint16_t numColsB = pSrcB->numCols;            /* Number of columns of input matrix B */
 800e840: 8849         	ldrh	r1, [r1, #0x2]
;         colCnt = numColsA;
 800e842: 8844         	ldrh	r4, [r0, #0x2]
;   float32_t *pIn1 = pSrcA->pData;                /* Input data matrix pointer A */
 800e844: f8d0 e004    	ldr.w	lr, [r0, #0x4]
;   uint32_t col, i = 0U, row = numRowsA, colCnt;  /* Loop counters */
 800e848: 8805         	ldrh	r5, [r0]
;   float32_t *pOut = pDst->pData;                 /* Output data matrix pointer */
 800e84a: 6852         	ldr	r2, [r2, #0x4]
;   uint32_t col, i = 0U, row = numRowsA, colCnt;  /* Loop counters */
 800e84c: 2901         	cmp	r1, #0x1
;           pIn2 += numColsB;
 800e84e: ea4f 0081    	lsl.w	r0, r1, #0x2
;       pInA = pInA + numColsA;
 800e852: ea4f 0784    	lsl.w	r7, r4, #0x2
 800e856: d124         	bne	0x800e8a2 <arm_mat_mult_f32+0x6a> @ imm = #0x48
 800e858: eb02 0a00    	add.w	r10, r2, r0
 800e85c: f103 0804    	add.w	r8, r3, #0x4
;       px = pOut + i;
 800e860: ebaa 0c00    	sub.w	r12, r10, r0
;       pIn2 = pSrcB->pData;
 800e864: 46c1         	mov	r9, r8
;         sum = 0.0f;
 800e866: eddf 7a20    	vldr	s15, [pc, #128]         @ 0x800e8e8 <arm_mat_mult_f32+0xb0>
;         while (colCnt > 0U)
 800e86a: b154         	cbz	r4, 0x800e882 <arm_mat_mult_f32+0x4a> @ imm = #0x14
;         colCnt = numColsA;
 800e86c: 4622         	mov	r2, r4
;         while (colCnt > 0U)
 800e86e: 4671         	mov	r1, lr
;           sum += *pIn1++ * *pIn2;
 800e870: edd3 6a00    	vldr	s13, [r3]
 800e874: ecb1 7a01    	vldmia	r1!, {s14}
;         while (colCnt > 0U)
 800e878: 3a01         	subs	r2, #0x1
;           sum += *pIn1++ * *pIn2;
 800e87a: eee6 7a87    	vfma.f32	s15, s13, s14
;           pIn2 += numColsB;
 800e87e: 4403         	add	r3, r0
;         while (colCnt > 0U)
 800e880: d1f6         	bne	0x800e870 <arm_mat_mult_f32+0x38> @ imm = #-0x14
;         *px++ = sum;
 800e882: ecec 7a01    	vstmia	r12!, {s15}
;       } while (col > 0U);
 800e886: 45d4         	cmp	r12, r10
;         pIn2 = pInB + (numColsB - col);
 800e888: 464b         	mov	r3, r9
;       } while (col > 0U);
 800e88a: f109 0904    	add.w	r9, r9, #0x4
 800e88e: d1ea         	bne	0x800e866 <arm_mat_mult_f32+0x2e> @ imm = #-0x2c
;     } while (row > 0U);
 800e890: 3d01         	subs	r5, #0x1
;       pInA = pInA + numColsA;
 800e892: 44be         	add	lr, r7
;     } while (row > 0U);
 800e894: 4482         	add	r10, r0
 800e896: d001         	beq	0x800e89c <arm_mat_mult_f32+0x64> @ imm = #0x2
;       pIn2 = pSrcB->pData;
 800e898: 6873         	ldr	r3, [r6, #0x4]
 800e89a: e7e1         	b	0x800e860 <arm_mat_mult_f32+0x28> @ imm = #-0x3e
; }
 800e89c: 2000         	movs	r0, #0x0
 800e89e: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}
 800e8a2: eb02 0c00    	add.w	r12, r2, r0
 800e8a6: f103 0804    	add.w	r8, r3, #0x4
;       px = pOut + i;
 800e8aa: ebac 0900    	sub.w	r9, r12, r0
;       pIn2 = pSrcB->pData;
 800e8ae: 46c2         	mov	r10, r8
;         sum = 0.0f;
 800e8b0: eddf 7a0d    	vldr	s15, [pc, #52]          @ 0x800e8e8 <arm_mat_mult_f32+0xb0>
;         while (colCnt > 0U)
 800e8b4: b154         	cbz	r4, 0x800e8cc <arm_mat_mult_f32+0x94> @ imm = #0x14
;         colCnt = numColsA;
 800e8b6: 4622         	mov	r2, r4
;         while (colCnt > 0U)
 800e8b8: 4671         	mov	r1, lr
;           sum += *pIn1++ * *pIn2;
 800e8ba: ed93 7a00    	vldr	s14, [r3]
 800e8be: ecf1 6a01    	vldmia	r1!, {s13}
;         while (colCnt > 0U)
 800e8c2: 3a01         	subs	r2, #0x1
;           sum += *pIn1++ * *pIn2;
 800e8c4: eee6 7a87    	vfma.f32	s15, s13, s14
;           pIn2 += numColsB;
 800e8c8: 4403         	add	r3, r0
;         while (colCnt > 0U)
 800e8ca: d1f6         	bne	0x800e8ba <arm_mat_mult_f32+0x82> @ imm = #-0x14
;         *px++ = sum;
 800e8cc: ece9 7a01    	vstmia	r9!, {s15}
;       } while (col > 0U);
 800e8d0: 45e1         	cmp	r9, r12
;         pIn2 = pInB + (numColsB - col);
 800e8d2: 4653         	mov	r3, r10
;       } while (col > 0U);
 800e8d4: f10a 0a04    	add.w	r10, r10, #0x4
 800e8d8: d1ea         	bne	0x800e8b0 <arm_mat_mult_f32+0x78> @ imm = #-0x2c
;     } while (row > 0U);
 800e8da: 3d01         	subs	r5, #0x1
;       pInA = pInA + numColsA;
 800e8dc: 44be         	add	lr, r7
;     } while (row > 0U);
 800e8de: 4484         	add	r12, r0
 800e8e0: d0dc         	beq	0x800e89c <arm_mat_mult_f32+0x64> @ imm = #-0x48
;       pIn2 = pSrcB->pData;
 800e8e2: 6873         	ldr	r3, [r6, #0x4]
 800e8e4: e7e1         	b	0x800e8aa <arm_mat_mult_f32+0x72> @ imm = #-0x3e
 800e8e6: bf00         	nop

0800e8e8 <$d>:
 800e8e8: 00 00 00 00  	.word	0x00000000

0800e8ec <arm_mat_sub_f32>:
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 800e8ec: 8803         	ldrh	r3, [r0]
 800e8ee: f8b0 c002    	ldrh.w	r12, [r0, #0x2]
;   float32_t *pInB = pSrcB->pData;                /* input data matrix pointer B */
 800e8f2: 6849         	ldr	r1, [r1, #0x4]
;   float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A */
 800e8f4: 6840         	ldr	r0, [r0, #0x4]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 800e8f6: 6852         	ldr	r2, [r2, #0x4]
;     numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
 800e8f8: fb0c f303    	mul	r3, r12, r3
;     while (blkCnt > 0U)
 800e8fc: b14b         	cbz	r3, 0x800e912 <arm_mat_sub_f32+0x26> @ imm = #0x12
;       *pOut++ = (*pInA++) - (*pInB++);
 800e8fe: ecf0 7a01    	vldmia	r0!, {s15}
 800e902: ecb1 7a01    	vldmia	r1!, {s14}
 800e906: ee77 7ac7    	vsub.f32	s15, s15, s14
;     while (blkCnt > 0U)
 800e90a: 3b01         	subs	r3, #0x1
;       *pOut++ = (*pInA++) - (*pInB++);
 800e90c: ece2 7a01    	vstmia	r2!, {s15}
;     while (blkCnt > 0U)
 800e910: d1f5         	bne	0x800e8fe <arm_mat_sub_f32+0x12> @ imm = #-0x16
; }
 800e912: 2000         	movs	r0, #0x0
 800e914: 4770         	bx	lr
 800e916: bf00         	nop

0800e918 <arm_mat_trans_f32>:
; {
 800e918: b5f0         	push	{r4, r5, r6, r7, lr}
;       col = nCols;
 800e91a: 8845         	ldrh	r5, [r0, #0x2]
;   uint16_t nRows = pSrc->numRows;                /* number of rows */
 800e91c: 8802         	ldrh	r2, [r0]
;   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
 800e91e: 6844         	ldr	r4, [r0, #0x4]
;   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 800e920: 684b         	ldr	r3, [r1, #0x4]
;   uint32_t col, row = nRows, i = 0U;             /* Loop counters */
 800e922: b1b5         	cbz	r5, 0x800e952 <arm_mat_trans_f32+0x3a> @ imm = #0x2c
 800e924: ea4f 0c82    	lsl.w	r12, r2, #0x2
 800e928: 2a01         	cmp	r2, #0x1
 800e92a: 469e         	mov	lr, r3
 800e92c: eb03 070c    	add.w	r7, r3, r12
 800e930: ea4f 0685    	lsl.w	r6, r5, #0x2
 800e934: d114         	bne	0x800e960 <arm_mat_trans_f32+0x48> @ imm = #0x28
;       px = pOut + i;
 800e936: 4672         	mov	r2, lr
;       col = nCols;
 800e938: 462b         	mov	r3, r5
;       px = pOut + i;
 800e93a: 4621         	mov	r1, r4
;         *px = *pIn++;
 800e93c: f851 0b04    	ldr	r0, [r1], #4
 800e940: 6010         	str	r0, [r2]
;       while (col > 0U)
 800e942: 3b01         	subs	r3, #0x1
;         px += nRows;
 800e944: 4462         	add	r2, r12
;       while (col > 0U)
 800e946: d1f9         	bne	0x800e93c <arm_mat_trans_f32+0x24> @ imm = #-0xe
;     } while (row > 0U);          /* row loop end */
 800e948: f10e 0e04    	add.w	lr, lr, #0x4
 800e94c: 45be         	cmp	lr, r7
;         *px = *pIn++;
 800e94e: 4434         	add	r4, r6
;     } while (row > 0U);          /* row loop end */
 800e950: d1f1         	bne	0x800e936 <arm_mat_trans_f32+0x1e> @ imm = #-0x1e
; }
 800e952: 2000         	movs	r0, #0x0
 800e954: bdf0         	pop	{r4, r5, r6, r7, pc}
;     } while (row > 0U);          /* row loop end */
 800e956: f10e 0e04    	add.w	lr, lr, #0x4
 800e95a: 45be         	cmp	lr, r7
;         *px = *pIn++;
 800e95c: 4434         	add	r4, r6
;     } while (row > 0U);          /* row loop end */
 800e95e: d0f8         	beq	0x800e952 <arm_mat_trans_f32+0x3a> @ imm = #-0x10
;       px = pOut + i;
 800e960: 4672         	mov	r2, lr
;       col = nCols;
 800e962: 462b         	mov	r3, r5
;       px = pOut + i;
 800e964: 4621         	mov	r1, r4
;         *px = *pIn++;
 800e966: f851 0b04    	ldr	r0, [r1], #4
 800e96a: 6010         	str	r0, [r2]
;       while (col > 0U)
 800e96c: 3b01         	subs	r3, #0x1
;         px += nRows;
 800e96e: 4462         	add	r2, r12
;       while (col > 0U)
 800e970: d1f9         	bne	0x800e966 <arm_mat_trans_f32+0x4e> @ imm = #-0xe
 800e972: e7f0         	b	0x800e956 <arm_mat_trans_f32+0x3e> @ imm = #-0x20

0800e974 <HAL_RCC_GetSysClockFreq>:
; {
 800e974: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800e978: b090         	sub	sp, #0x40
 800e97a: af00         	add	r7, sp, #0x0
;   uint32_t pllm = 0U;
 800e97c: 2300         	movs	r3, #0x0
 800e97e: 637b         	str	r3, [r7, #0x34]
;   uint32_t pllvco = 0U;
 800e980: 2300         	movs	r3, #0x0
 800e982: 63fb         	str	r3, [r7, #0x3c]
;   uint32_t pllp = 0U;
 800e984: 2300         	movs	r3, #0x0
 800e986: 633b         	str	r3, [r7, #0x30]
;   uint32_t sysclockfreq = 0U;
 800e988: 2300         	movs	r3, #0x0
 800e98a: 63bb         	str	r3, [r7, #0x38]
;   switch (RCC->CFGR & RCC_CFGR_SWS)
 800e98c: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800eaf4 <HAL_RCC_GetSysClockFreq+0x180>
 800e98e: 689b         	ldr	r3, [r3, #0x8]
 800e990: f003 030c    	and	r3, r3, #0xc
 800e994: 2b08         	cmp	r3, #0x8
 800e996: d00d         	beq	0x800e9b4 <HAL_RCC_GetSysClockFreq+0x40> @ imm = #0x1a
 800e998: 2b08         	cmp	r3, #0x8
 800e99a: f200 80a1    	bhi.w	0x800eae0 <HAL_RCC_GetSysClockFreq+0x16c> @ imm = #0x142
 800e99e: 2b00         	cmp	r3, #0x0
 800e9a0: d002         	beq	0x800e9a8 <HAL_RCC_GetSysClockFreq+0x34> @ imm = #0x4
 800e9a2: 2b04         	cmp	r3, #0x4
 800e9a4: d003         	beq	0x800e9ae <HAL_RCC_GetSysClockFreq+0x3a> @ imm = #0x6
 800e9a6: e09b         	b	0x800eae0 <HAL_RCC_GetSysClockFreq+0x16c> @ imm = #0x136
;       sysclockfreq = HSI_VALUE;
 800e9a8: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800eaf8 <HAL_RCC_GetSysClockFreq+0x184>
 800e9aa: 63bb         	str	r3, [r7, #0x38]
;       break;
 800e9ac: e09b         	b	0x800eae6 <HAL_RCC_GetSysClockFreq+0x172> @ imm = #0x136
;       sysclockfreq = HSE_VALUE;
 800e9ae: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800eafc <HAL_RCC_GetSysClockFreq+0x188>
 800e9b0: 63bb         	str	r3, [r7, #0x38]
;       break;
 800e9b2: e098         	b	0x800eae6 <HAL_RCC_GetSysClockFreq+0x172> @ imm = #0x130
;       pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800e9b4: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x800eaf4 <HAL_RCC_GetSysClockFreq+0x180>
 800e9b6: 685b         	ldr	r3, [r3, #0x4]
 800e9b8: f003 033f    	and	r3, r3, #0x3f
 800e9bc: 637b         	str	r3, [r7, #0x34]
;       if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800e9be: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800eaf4 <HAL_RCC_GetSysClockFreq+0x180>
 800e9c0: 685b         	ldr	r3, [r3, #0x4]
 800e9c2: f403 0380    	and	r3, r3, #0x400000
 800e9c6: 2b00         	cmp	r3, #0x0
 800e9c8: d028         	beq	0x800ea1c <HAL_RCC_GetSysClockFreq+0xa8> @ imm = #0x50
;         pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800e9ca: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x800eaf4 <HAL_RCC_GetSysClockFreq+0x180>
 800e9cc: 685b         	ldr	r3, [r3, #0x4]
 800e9ce: 099b         	lsrs	r3, r3, #0x6
 800e9d0: 2200         	movs	r2, #0x0
 800e9d2: 623b         	str	r3, [r7, #0x20]
 800e9d4: 627a         	str	r2, [r7, #0x24]
 800e9d6: 6a3b         	ldr	r3, [r7, #0x20]
 800e9d8: f3c3 0008    	ubfx	r0, r3, #0x0, #0x9
 800e9dc: 2100         	movs	r1, #0x0
 800e9de: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x800eafc <HAL_RCC_GetSysClockFreq+0x188>
 800e9e0: fb03 f201    	mul	r2, r3, r1
 800e9e4: 2300         	movs	r3, #0x0
 800e9e6: fb00 f303    	mul	r3, r0, r3
 800e9ea: 4413         	add	r3, r2
 800e9ec: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x800eafc <HAL_RCC_GetSysClockFreq+0x188>
 800e9ee: fba0 1202    	umull	r1, r2, r0, r2
 800e9f2: 62fa         	str	r2, [r7, #0x2c]
 800e9f4: 460a         	mov	r2, r1
 800e9f6: 62ba         	str	r2, [r7, #0x28]
 800e9f8: 6afa         	ldr	r2, [r7, #0x2c]
 800e9fa: 4413         	add	r3, r2
 800e9fc: 62fb         	str	r3, [r7, #0x2c]
 800e9fe: 6b7b         	ldr	r3, [r7, #0x34]
 800ea00: 2200         	movs	r2, #0x0
 800ea02: 61bb         	str	r3, [r7, #0x18]
 800ea04: 61fa         	str	r2, [r7, #0x1c]
 800ea06: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 800ea0a: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 800ea0e: f7f2 f829    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0xdfae
 800ea12: 4602         	mov	r2, r0
 800ea14: 460b         	mov	r3, r1
 800ea16: 4613         	mov	r3, r2
 800ea18: 63fb         	str	r3, [r7, #0x3c]
 800ea1a: e053         	b	0x800eac4 <HAL_RCC_GetSysClockFreq+0x150> @ imm = #0xa6
;         pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800ea1c: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800eaf4 <HAL_RCC_GetSysClockFreq+0x180>
 800ea1e: 685b         	ldr	r3, [r3, #0x4]
 800ea20: 099b         	lsrs	r3, r3, #0x6
 800ea22: 2200         	movs	r2, #0x0
 800ea24: 613b         	str	r3, [r7, #0x10]
 800ea26: 617a         	str	r2, [r7, #0x14]
 800ea28: 693b         	ldr	r3, [r7, #0x10]
 800ea2a: f3c3 0a08    	ubfx	r10, r3, #0x0, #0x9
 800ea2e: f04f 0b00    	mov.w	r11, #0x0
 800ea32: 4652         	mov	r2, r10
 800ea34: 465b         	mov	r3, r11
 800ea36: f04f 0000    	mov.w	r0, #0x0
 800ea3a: f04f 0100    	mov.w	r1, #0x0
 800ea3e: 0159         	lsls	r1, r3, #0x5
 800ea40: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 800ea44: 0150         	lsls	r0, r2, #0x5
 800ea46: 4602         	mov	r2, r0
 800ea48: 460b         	mov	r3, r1
 800ea4a: ebb2 080a    	subs.w	r8, r2, r10
 800ea4e: eb63 090b    	sbc.w	r9, r3, r11
 800ea52: f04f 0200    	mov.w	r2, #0x0
 800ea56: f04f 0300    	mov.w	r3, #0x0
 800ea5a: ea4f 1389    	lsl.w	r3, r9, #0x6
 800ea5e: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 800ea62: ea4f 1288    	lsl.w	r2, r8, #0x6
 800ea66: ebb2 0408    	subs.w	r4, r2, r8
 800ea6a: eb63 0509    	sbc.w	r5, r3, r9
 800ea6e: f04f 0200    	mov.w	r2, #0x0
 800ea72: f04f 0300    	mov.w	r3, #0x0
 800ea76: 00eb         	lsls	r3, r5, #0x3
 800ea78: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 800ea7c: 00e2         	lsls	r2, r4, #0x3
 800ea7e: 4614         	mov	r4, r2
 800ea80: 461d         	mov	r5, r3
 800ea82: eb14 030a    	adds.w	r3, r4, r10
 800ea86: 603b         	str	r3, [r7]
 800ea88: eb45 030b    	adc.w	r3, r5, r11
 800ea8c: 607b         	str	r3, [r7, #0x4]
 800ea8e: f04f 0200    	mov.w	r2, #0x0
 800ea92: f04f 0300    	mov.w	r3, #0x0
 800ea96: e9d7 4500    	ldrd	r4, r5, [r7]
 800ea9a: 4629         	mov	r1, r5
 800ea9c: 028b         	lsls	r3, r1, #0xa
 800ea9e: 4621         	mov	r1, r4
 800eaa0: ea43 5391    	orr.w	r3, r3, r1, lsr #22
 800eaa4: 4621         	mov	r1, r4
 800eaa6: 028a         	lsls	r2, r1, #0xa
 800eaa8: 4610         	mov	r0, r2
 800eaaa: 4619         	mov	r1, r3
 800eaac: 6b7b         	ldr	r3, [r7, #0x34]
 800eaae: 2200         	movs	r2, #0x0
 800eab0: 60bb         	str	r3, [r7, #0x8]
 800eab2: 60fa         	str	r2, [r7, #0xc]
 800eab4: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800eab8: f7f1 ffd4    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0xe058
 800eabc: 4602         	mov	r2, r0
 800eabe: 460b         	mov	r3, r1
 800eac0: 4613         	mov	r3, r2
 800eac2: 63fb         	str	r3, [r7, #0x3c]
;       pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) * 2U);
 800eac4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800eaf4 <HAL_RCC_GetSysClockFreq+0x180>
 800eac6: 685b         	ldr	r3, [r3, #0x4]
 800eac8: 0c1b         	lsrs	r3, r3, #0x10
 800eaca: f003 0303    	and	r3, r3, #0x3
 800eace: 3301         	adds	r3, #0x1
 800ead0: 005b         	lsls	r3, r3, #0x1
 800ead2: 633b         	str	r3, [r7, #0x30]
;       sysclockfreq = pllvco / pllp;
 800ead4: 6bfa         	ldr	r2, [r7, #0x3c]
 800ead6: 6b3b         	ldr	r3, [r7, #0x30]
 800ead8: fbb2 f3f3    	udiv	r3, r2, r3
 800eadc: 63bb         	str	r3, [r7, #0x38]
;       break;
 800eade: e002         	b	0x800eae6 <HAL_RCC_GetSysClockFreq+0x172> @ imm = #0x4
;       sysclockfreq = HSI_VALUE;
 800eae0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800eaf8 <HAL_RCC_GetSysClockFreq+0x184>
 800eae2: 63bb         	str	r3, [r7, #0x38]
;       break;
 800eae4: bf00         	nop
;   return sysclockfreq;
 800eae6: 6bbb         	ldr	r3, [r7, #0x38]
; }
 800eae8: 4618         	mov	r0, r3
 800eaea: 3740         	adds	r7, #0x40
 800eaec: 46bd         	mov	sp, r7
 800eaee: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 800eaf2: bf00         	nop

0800eaf4 <$d>:
 800eaf4: 00 38 02 40  	.word	0x40023800
 800eaf8: 00 24 f4 00  	.word	0x00f42400
 800eafc: 00 1b b7 00  	.word	0x00b71b00

0800eb00 <LL_DMA_ConfigTransfer>:
; {
 800eb00: b480         	push	{r7}
 800eb02: b085         	sub	sp, #0x14
 800eb04: af00         	add	r7, sp, #0x0
 800eb06: 60f8         	str	r0, [r7, #0xc]
 800eb08: 60b9         	str	r1, [r7, #0x8]
 800eb0a: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef *)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR,
 800eb0c: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800eb48 <LL_DMA_ConfigTransfer+0x48>
 800eb0e: 68bb         	ldr	r3, [r7, #0x8]
 800eb10: 4413         	add	r3, r2
 800eb12: 781b         	ldrb	r3, [r3]
 800eb14: 461a         	mov	r2, r3
 800eb16: 68fb         	ldr	r3, [r7, #0xc]
 800eb18: 4413         	add	r3, r2
 800eb1a: 681b         	ldr	r3, [r3]
 800eb1c: f423 335f    	bic	r3, r3, #0x37c00
 800eb20: f423 7378    	bic	r3, r3, #0x3e0
 800eb24: 4908         	ldr	r1, [pc, #0x20]         @ 0x800eb48 <LL_DMA_ConfigTransfer+0x48>
 800eb26: 68ba         	ldr	r2, [r7, #0x8]
 800eb28: 440a         	add	r2, r1
 800eb2a: 7812         	ldrb	r2, [r2]
 800eb2c: 4611         	mov	r1, r2
 800eb2e: 68fa         	ldr	r2, [r7, #0xc]
 800eb30: 440a         	add	r2, r1
 800eb32: 4611         	mov	r1, r2
 800eb34: 687a         	ldr	r2, [r7, #0x4]
 800eb36: 4313         	orrs	r3, r2
 800eb38: 600b         	str	r3, [r1]
; }
 800eb3a: bf00         	nop
 800eb3c: 3714         	adds	r7, #0x14
 800eb3e: 46bd         	mov	sp, r7
 800eb40: f85d 7b04    	ldr	r7, [sp], #4
 800eb44: 4770         	bx	lr
 800eb46: bf00         	nop

0800eb48 <$d>:
 800eb48: 94 2e 02 08  	.word	0x08022e94

0800eb4c <LL_DMA_SetDataLength>:
; {
 800eb4c: b480         	push	{r7}
 800eb4e: b085         	sub	sp, #0x14
 800eb50: af00         	add	r7, sp, #0x0
 800eb52: 60f8         	str	r0, [r7, #0xc]
 800eb54: 60b9         	str	r1, [r7, #0x8]
 800eb56: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->NDTR, DMA_SxNDT, NbData);
 800eb58: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800eb90 <LL_DMA_SetDataLength+0x44>
 800eb5a: 68bb         	ldr	r3, [r7, #0x8]
 800eb5c: 4413         	add	r3, r2
 800eb5e: 781b         	ldrb	r3, [r3]
 800eb60: 461a         	mov	r2, r3
 800eb62: 68fb         	ldr	r3, [r7, #0xc]
 800eb64: 4413         	add	r3, r2
 800eb66: 685b         	ldr	r3, [r3, #0x4]
 800eb68: 0c1b         	lsrs	r3, r3, #0x10
 800eb6a: 041b         	lsls	r3, r3, #0x10
 800eb6c: 4908         	ldr	r1, [pc, #0x20]         @ 0x800eb90 <LL_DMA_SetDataLength+0x44>
 800eb6e: 68ba         	ldr	r2, [r7, #0x8]
 800eb70: 440a         	add	r2, r1
 800eb72: 7812         	ldrb	r2, [r2]
 800eb74: 4611         	mov	r1, r2
 800eb76: 68fa         	ldr	r2, [r7, #0xc]
 800eb78: 440a         	add	r2, r1
 800eb7a: 4611         	mov	r1, r2
 800eb7c: 687a         	ldr	r2, [r7, #0x4]
 800eb7e: 4313         	orrs	r3, r2
 800eb80: 604b         	str	r3, [r1, #0x4]
; }
 800eb82: bf00         	nop
 800eb84: 3714         	adds	r7, #0x14
 800eb86: 46bd         	mov	sp, r7
 800eb88: f85d 7b04    	ldr	r7, [sp], #4
 800eb8c: 4770         	bx	lr
 800eb8e: bf00         	nop

0800eb90 <$d>:
 800eb90: 94 2e 02 08  	.word	0x08022e94

0800eb94 <LL_DMA_SetChannelSelection>:
; {
 800eb94: b480         	push	{r7}
 800eb96: b085         	sub	sp, #0x14
 800eb98: af00         	add	r7, sp, #0x0
 800eb9a: 60f8         	str	r0, [r7, #0xc]
 800eb9c: 60b9         	str	r1, [r7, #0x8]
 800eb9e: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_CHSEL, Channel);
 800eba0: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800ebd8 <LL_DMA_SetChannelSelection+0x44>
 800eba2: 68bb         	ldr	r3, [r7, #0x8]
 800eba4: 4413         	add	r3, r2
 800eba6: 781b         	ldrb	r3, [r3]
 800eba8: 461a         	mov	r2, r3
 800ebaa: 68fb         	ldr	r3, [r7, #0xc]
 800ebac: 4413         	add	r3, r2
 800ebae: 681b         	ldr	r3, [r3]
 800ebb0: f023 6260    	bic	r2, r3, #0xe000000
 800ebb4: 4908         	ldr	r1, [pc, #0x20]         @ 0x800ebd8 <LL_DMA_SetChannelSelection+0x44>
 800ebb6: 68bb         	ldr	r3, [r7, #0x8]
 800ebb8: 440b         	add	r3, r1
 800ebba: 781b         	ldrb	r3, [r3]
 800ebbc: 4619         	mov	r1, r3
 800ebbe: 68fb         	ldr	r3, [r7, #0xc]
 800ebc0: 440b         	add	r3, r1
 800ebc2: 4619         	mov	r1, r3
 800ebc4: 687b         	ldr	r3, [r7, #0x4]
 800ebc6: 4313         	orrs	r3, r2
 800ebc8: 600b         	str	r3, [r1]
; }
 800ebca: bf00         	nop
 800ebcc: 3714         	adds	r7, #0x14
 800ebce: 46bd         	mov	sp, r7
 800ebd0: f85d 7b04    	ldr	r7, [sp], #4
 800ebd4: 4770         	bx	lr
 800ebd6: bf00         	nop

0800ebd8 <$d>:
 800ebd8: 94 2e 02 08  	.word	0x08022e94

0800ebdc <LL_DMA_SetMemoryBurstxfer>:
; {
 800ebdc: b480         	push	{r7}
 800ebde: b085         	sub	sp, #0x14
 800ebe0: af00         	add	r7, sp, #0x0
 800ebe2: 60f8         	str	r0, [r7, #0xc]
 800ebe4: 60b9         	str	r1, [r7, #0x8]
 800ebe6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_MBURST, Mburst);
 800ebe8: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800ec20 <LL_DMA_SetMemoryBurstxfer+0x44>
 800ebea: 68bb         	ldr	r3, [r7, #0x8]
 800ebec: 4413         	add	r3, r2
 800ebee: 781b         	ldrb	r3, [r3]
 800ebf0: 461a         	mov	r2, r3
 800ebf2: 68fb         	ldr	r3, [r7, #0xc]
 800ebf4: 4413         	add	r3, r2
 800ebf6: 681b         	ldr	r3, [r3]
 800ebf8: f023 72c0    	bic	r2, r3, #0x1800000
 800ebfc: 4908         	ldr	r1, [pc, #0x20]         @ 0x800ec20 <LL_DMA_SetMemoryBurstxfer+0x44>
 800ebfe: 68bb         	ldr	r3, [r7, #0x8]
 800ec00: 440b         	add	r3, r1
 800ec02: 781b         	ldrb	r3, [r3]
 800ec04: 4619         	mov	r1, r3
 800ec06: 68fb         	ldr	r3, [r7, #0xc]
 800ec08: 440b         	add	r3, r1
 800ec0a: 4619         	mov	r1, r3
 800ec0c: 687b         	ldr	r3, [r7, #0x4]
 800ec0e: 4313         	orrs	r3, r2
 800ec10: 600b         	str	r3, [r1]
; }
 800ec12: bf00         	nop
 800ec14: 3714         	adds	r7, #0x14
 800ec16: 46bd         	mov	sp, r7
 800ec18: f85d 7b04    	ldr	r7, [sp], #4
 800ec1c: 4770         	bx	lr
 800ec1e: bf00         	nop

0800ec20 <$d>:
 800ec20: 94 2e 02 08  	.word	0x08022e94

0800ec24 <LL_DMA_SetPeriphBurstxfer>:
; {
 800ec24: b480         	push	{r7}
 800ec26: b085         	sub	sp, #0x14
 800ec28: af00         	add	r7, sp, #0x0
 800ec2a: 60f8         	str	r0, [r7, #0xc]
 800ec2c: 60b9         	str	r1, [r7, #0x8]
 800ec2e: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->CR, DMA_SxCR_PBURST, Pburst);
 800ec30: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800ec68 <LL_DMA_SetPeriphBurstxfer+0x44>
 800ec32: 68bb         	ldr	r3, [r7, #0x8]
 800ec34: 4413         	add	r3, r2
 800ec36: 781b         	ldrb	r3, [r3]
 800ec38: 461a         	mov	r2, r3
 800ec3a: 68fb         	ldr	r3, [r7, #0xc]
 800ec3c: 4413         	add	r3, r2
 800ec3e: 681b         	ldr	r3, [r3]
 800ec40: f423 02c0    	bic	r2, r3, #0x600000
 800ec44: 4908         	ldr	r1, [pc, #0x20]         @ 0x800ec68 <LL_DMA_SetPeriphBurstxfer+0x44>
 800ec46: 68bb         	ldr	r3, [r7, #0x8]
 800ec48: 440b         	add	r3, r1
 800ec4a: 781b         	ldrb	r3, [r3]
 800ec4c: 4619         	mov	r1, r3
 800ec4e: 68fb         	ldr	r3, [r7, #0xc]
 800ec50: 440b         	add	r3, r1
 800ec52: 4619         	mov	r1, r3
 800ec54: 687b         	ldr	r3, [r7, #0x4]
 800ec56: 4313         	orrs	r3, r2
 800ec58: 600b         	str	r3, [r1]
; }
 800ec5a: bf00         	nop
 800ec5c: 3714         	adds	r7, #0x14
 800ec5e: 46bd         	mov	sp, r7
 800ec60: f85d 7b04    	ldr	r7, [sp], #4
 800ec64: 4770         	bx	lr
 800ec66: bf00         	nop

0800ec68 <$d>:
 800ec68: 94 2e 02 08  	.word	0x08022e94

0800ec6c <LL_DMA_ConfigFifo>:
; {
 800ec6c: b480         	push	{r7}
 800ec6e: b085         	sub	sp, #0x14
 800ec70: af00         	add	r7, sp, #0x0
 800ec72: 60f8         	str	r0, [r7, #0xc]
 800ec74: 60b9         	str	r1, [r7, #0x8]
 800ec76: 607a         	str	r2, [r7, #0x4]
 800ec78: 603b         	str	r3, [r7]
;   MODIFY_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->FCR, DMA_SxFCR_FTH|DMA_SxFCR_DMDIS, FifoMode|FifoThreshold);
 800ec7a: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800ecb4 <LL_DMA_ConfigFifo+0x48>
 800ec7c: 68bb         	ldr	r3, [r7, #0x8]
 800ec7e: 4413         	add	r3, r2
 800ec80: 781b         	ldrb	r3, [r3]
 800ec82: 461a         	mov	r2, r3
 800ec84: 68fb         	ldr	r3, [r7, #0xc]
 800ec86: 4413         	add	r3, r2
 800ec88: 695b         	ldr	r3, [r3, #0x14]
 800ec8a: f023 0207    	bic	r2, r3, #0x7
 800ec8e: 6879         	ldr	r1, [r7, #0x4]
 800ec90: 683b         	ldr	r3, [r7]
 800ec92: 430b         	orrs	r3, r1
 800ec94: 4807         	ldr	r0, [pc, #0x1c]         @ 0x800ecb4 <LL_DMA_ConfigFifo+0x48>
 800ec96: 68b9         	ldr	r1, [r7, #0x8]
 800ec98: 4401         	add	r1, r0
 800ec9a: 7809         	ldrb	r1, [r1]
 800ec9c: 4608         	mov	r0, r1
 800ec9e: 68f9         	ldr	r1, [r7, #0xc]
 800eca0: 4401         	add	r1, r0
 800eca2: 4313         	orrs	r3, r2
 800eca4: 614b         	str	r3, [r1, #0x14]
; }
 800eca6: bf00         	nop
 800eca8: 3714         	adds	r7, #0x14
 800ecaa: 46bd         	mov	sp, r7
 800ecac: f85d 7b04    	ldr	r7, [sp], #4
 800ecb0: 4770         	bx	lr
 800ecb2: bf00         	nop

0800ecb4 <$d>:
 800ecb4: 94 2e 02 08  	.word	0x08022e94

0800ecb8 <LL_DMA_SetMemoryAddress>:
; {
 800ecb8: b480         	push	{r7}
 800ecba: b085         	sub	sp, #0x14
 800ecbc: af00         	add	r7, sp, #0x0
 800ecbe: 60f8         	str	r0, [r7, #0xc]
 800ecc0: 60b9         	str	r1, [r7, #0x8]
 800ecc2: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->M0AR, MemoryAddress);
 800ecc4: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800ece4 <LL_DMA_SetMemoryAddress+0x2c>
 800ecc6: 68bb         	ldr	r3, [r7, #0x8]
 800ecc8: 4413         	add	r3, r2
 800ecca: 781b         	ldrb	r3, [r3]
 800eccc: 461a         	mov	r2, r3
 800ecce: 68fb         	ldr	r3, [r7, #0xc]
 800ecd0: 4413         	add	r3, r2
 800ecd2: 461a         	mov	r2, r3
 800ecd4: 687b         	ldr	r3, [r7, #0x4]
 800ecd6: 60d3         	str	r3, [r2, #0xc]
; }
 800ecd8: bf00         	nop
 800ecda: 3714         	adds	r7, #0x14
 800ecdc: 46bd         	mov	sp, r7
 800ecde: f85d 7b04    	ldr	r7, [sp], #4
 800ece2: 4770         	bx	lr

0800ece4 <$d>:
 800ece4: 94 2e 02 08  	.word	0x08022e94

0800ece8 <LL_DMA_SetPeriphAddress>:
; {
 800ece8: b480         	push	{r7}
 800ecea: b085         	sub	sp, #0x14
 800ecec: af00         	add	r7, sp, #0x0
 800ecee: 60f8         	str	r0, [r7, #0xc]
 800ecf0: 60b9         	str	r1, [r7, #0x8]
 800ecf2: 607a         	str	r2, [r7, #0x4]
;   WRITE_REG(((DMA_Stream_TypeDef*)((uint32_t)((uint32_t)DMAx + STREAM_OFFSET_TAB[Stream])))->PAR, PeriphAddress);
 800ecf4: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800ed14 <LL_DMA_SetPeriphAddress+0x2c>
 800ecf6: 68bb         	ldr	r3, [r7, #0x8]
 800ecf8: 4413         	add	r3, r2
 800ecfa: 781b         	ldrb	r3, [r3]
 800ecfc: 461a         	mov	r2, r3
 800ecfe: 68fb         	ldr	r3, [r7, #0xc]
 800ed00: 4413         	add	r3, r2
 800ed02: 461a         	mov	r2, r3
 800ed04: 687b         	ldr	r3, [r7, #0x4]
 800ed06: 6093         	str	r3, [r2, #0x8]
; }
 800ed08: bf00         	nop
 800ed0a: 3714         	adds	r7, #0x14
 800ed0c: 46bd         	mov	sp, r7
 800ed0e: f85d 7b04    	ldr	r7, [sp], #4
 800ed12: 4770         	bx	lr

0800ed14 <$d>:
 800ed14: 94 2e 02 08  	.word	0x08022e94

0800ed18 <LL_TIM_Init>:
; {
 800ed18: b580         	push	{r7, lr}
 800ed1a: b084         	sub	sp, #0x10
 800ed1c: af00         	add	r7, sp, #0x0
 800ed1e: 6078         	str	r0, [r7, #0x4]
 800ed20: 6039         	str	r1, [r7]
;   tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
 800ed22: 687b         	ldr	r3, [r7, #0x4]
 800ed24: 681b         	ldr	r3, [r3]
 800ed26: 60fb         	str	r3, [r7, #0xc]
;   if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800ed28: 687b         	ldr	r3, [r7, #0x4]
 800ed2a: 4a3d         	ldr	r2, [pc, #0xf4]         @ 0x800ee20 <LL_TIM_Init+0x108>
 800ed2c: 4293         	cmp	r3, r2
 800ed2e: d013         	beq	0x800ed58 <LL_TIM_Init+0x40> @ imm = #0x26
 800ed30: 687b         	ldr	r3, [r7, #0x4]
 800ed32: f1b3 4f80    	cmp.w	r3, #0x40000000
 800ed36: d00f         	beq	0x800ed58 <LL_TIM_Init+0x40> @ imm = #0x1e
 800ed38: 687b         	ldr	r3, [r7, #0x4]
 800ed3a: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x800ee24 <LL_TIM_Init+0x10c>
 800ed3c: 4293         	cmp	r3, r2
 800ed3e: d00b         	beq	0x800ed58 <LL_TIM_Init+0x40> @ imm = #0x16
 800ed40: 687b         	ldr	r3, [r7, #0x4]
 800ed42: 4a39         	ldr	r2, [pc, #0xe4]         @ 0x800ee28 <LL_TIM_Init+0x110>
 800ed44: 4293         	cmp	r3, r2
 800ed46: d007         	beq	0x800ed58 <LL_TIM_Init+0x40> @ imm = #0xe
 800ed48: 687b         	ldr	r3, [r7, #0x4]
 800ed4a: 4a38         	ldr	r2, [pc, #0xe0]         @ 0x800ee2c <LL_TIM_Init+0x114>
 800ed4c: 4293         	cmp	r3, r2
 800ed4e: d003         	beq	0x800ed58 <LL_TIM_Init+0x40> @ imm = #0x6
 800ed50: 687b         	ldr	r3, [r7, #0x4]
 800ed52: 4a37         	ldr	r2, [pc, #0xdc]         @ 0x800ee30 <LL_TIM_Init+0x118>
 800ed54: 4293         	cmp	r3, r2
 800ed56: d106         	bne	0x800ed66 <LL_TIM_Init+0x4e> @ imm = #0xc
;     MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
 800ed58: 68fb         	ldr	r3, [r7, #0xc]
 800ed5a: f023 0270    	bic	r2, r3, #0x70
 800ed5e: 683b         	ldr	r3, [r7]
 800ed60: 685b         	ldr	r3, [r3, #0x4]
 800ed62: 4313         	orrs	r3, r2
 800ed64: 60fb         	str	r3, [r7, #0xc]
;   if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800ed66: 687b         	ldr	r3, [r7, #0x4]
 800ed68: 4a2d         	ldr	r2, [pc, #0xb4]         @ 0x800ee20 <LL_TIM_Init+0x108>
 800ed6a: 4293         	cmp	r3, r2
 800ed6c: d02b         	beq	0x800edc6 <LL_TIM_Init+0xae> @ imm = #0x56
 800ed6e: 687b         	ldr	r3, [r7, #0x4]
 800ed70: f1b3 4f80    	cmp.w	r3, #0x40000000
 800ed74: d027         	beq	0x800edc6 <LL_TIM_Init+0xae> @ imm = #0x4e
 800ed76: 687b         	ldr	r3, [r7, #0x4]
 800ed78: 4a2a         	ldr	r2, [pc, #0xa8]         @ 0x800ee24 <LL_TIM_Init+0x10c>
 800ed7a: 4293         	cmp	r3, r2
 800ed7c: d023         	beq	0x800edc6 <LL_TIM_Init+0xae> @ imm = #0x46
 800ed7e: 687b         	ldr	r3, [r7, #0x4]
 800ed80: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x800ee28 <LL_TIM_Init+0x110>
 800ed82: 4293         	cmp	r3, r2
 800ed84: d01f         	beq	0x800edc6 <LL_TIM_Init+0xae> @ imm = #0x3e
 800ed86: 687b         	ldr	r3, [r7, #0x4]
 800ed88: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x800ee2c <LL_TIM_Init+0x114>
 800ed8a: 4293         	cmp	r3, r2
 800ed8c: d01b         	beq	0x800edc6 <LL_TIM_Init+0xae> @ imm = #0x36
 800ed8e: 687b         	ldr	r3, [r7, #0x4]
 800ed90: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x800ee30 <LL_TIM_Init+0x118>
 800ed92: 4293         	cmp	r3, r2
 800ed94: d017         	beq	0x800edc6 <LL_TIM_Init+0xae> @ imm = #0x2e
 800ed96: 687b         	ldr	r3, [r7, #0x4]
 800ed98: 4a26         	ldr	r2, [pc, #0x98]         @ 0x800ee34 <LL_TIM_Init+0x11c>
 800ed9a: 4293         	cmp	r3, r2
 800ed9c: d013         	beq	0x800edc6 <LL_TIM_Init+0xae> @ imm = #0x26
 800ed9e: 687b         	ldr	r3, [r7, #0x4]
 800eda0: 4a25         	ldr	r2, [pc, #0x94]         @ 0x800ee38 <LL_TIM_Init+0x120>
 800eda2: 4293         	cmp	r3, r2
 800eda4: d00f         	beq	0x800edc6 <LL_TIM_Init+0xae> @ imm = #0x1e
 800eda6: 687b         	ldr	r3, [r7, #0x4]
 800eda8: 4a24         	ldr	r2, [pc, #0x90]         @ 0x800ee3c <LL_TIM_Init+0x124>
 800edaa: 4293         	cmp	r3, r2
 800edac: d00b         	beq	0x800edc6 <LL_TIM_Init+0xae> @ imm = #0x16
 800edae: 687b         	ldr	r3, [r7, #0x4]
 800edb0: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x800ee40 <LL_TIM_Init+0x128>
 800edb2: 4293         	cmp	r3, r2
 800edb4: d007         	beq	0x800edc6 <LL_TIM_Init+0xae> @ imm = #0xe
 800edb6: 687b         	ldr	r3, [r7, #0x4]
 800edb8: 4a22         	ldr	r2, [pc, #0x88]         @ 0x800ee44 <LL_TIM_Init+0x12c>
 800edba: 4293         	cmp	r3, r2
 800edbc: d003         	beq	0x800edc6 <LL_TIM_Init+0xae> @ imm = #0x6
 800edbe: 687b         	ldr	r3, [r7, #0x4]
 800edc0: 4a21         	ldr	r2, [pc, #0x84]         @ 0x800ee48 <LL_TIM_Init+0x130>
 800edc2: 4293         	cmp	r3, r2
 800edc4: d106         	bne	0x800edd4 <LL_TIM_Init+0xbc> @ imm = #0xc
;     MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
 800edc6: 68fb         	ldr	r3, [r7, #0xc]
 800edc8: f423 7240    	bic	r2, r3, #0x300
 800edcc: 683b         	ldr	r3, [r7]
 800edce: 68db         	ldr	r3, [r3, #0xc]
 800edd0: 4313         	orrs	r3, r2
 800edd2: 60fb         	str	r3, [r7, #0xc]
;   LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
 800edd4: 687b         	ldr	r3, [r7, #0x4]
 800edd6: 68fa         	ldr	r2, [r7, #0xc]
 800edd8: 601a         	str	r2, [r3]
;   LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
 800edda: 683b         	ldr	r3, [r7]
 800eddc: 689b         	ldr	r3, [r3, #0x8]
 800edde: 4619         	mov	r1, r3
 800ede0: 6878         	ldr	r0, [r7, #0x4]
 800ede2: f00e ffdd    	bl	0x801dda0 <LL_TIM_SetAutoReload> @ imm = #0xefba
;   LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
 800ede6: 683b         	ldr	r3, [r7]
 800ede8: 881b         	ldrh	r3, [r3]
 800edea: 4619         	mov	r1, r3
 800edec: 6878         	ldr	r0, [r7, #0x4]
 800edee: f00e ffc9    	bl	0x801dd84 <LL_TIM_SetPrescaler> @ imm = #0xef92
;   if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800edf2: 687b         	ldr	r3, [r7, #0x4]
 800edf4: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800ee20 <LL_TIM_Init+0x108>
 800edf6: 4293         	cmp	r3, r2
 800edf8: d003         	beq	0x800ee02 <LL_TIM_Init+0xea> @ imm = #0x6
 800edfa: 687b         	ldr	r3, [r7, #0x4]
 800edfc: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x800ee30 <LL_TIM_Init+0x118>
 800edfe: 4293         	cmp	r3, r2
 800ee00: d105         	bne	0x800ee0e <LL_TIM_Init+0xf6> @ imm = #0xa
;     LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
 800ee02: 683b         	ldr	r3, [r7]
 800ee04: 691b         	ldr	r3, [r3, #0x10]
 800ee06: 4619         	mov	r1, r3
 800ee08: 6878         	ldr	r0, [r7, #0x4]
 800ee0a: f00e ffd7    	bl	0x801ddbc <LL_TIM_SetRepetitionCounter> @ imm = #0xefae
;   LL_TIM_GenerateEvent_UPDATE(TIMx);
 800ee0e: 6878         	ldr	r0, [r7, #0x4]
 800ee10: f00f f81a    	bl	0x801de48 <LL_TIM_GenerateEvent_UPDATE> @ imm = #0xf034
;   return SUCCESS;
 800ee14: 2300         	movs	r3, #0x0
; }
 800ee16: 4618         	mov	r0, r3
 800ee18: 3710         	adds	r7, #0x10
 800ee1a: 46bd         	mov	sp, r7
 800ee1c: bd80         	pop	{r7, pc}
 800ee1e: bf00         	nop

0800ee20 <$d>:
 800ee20: 00 00 01 40  	.word	0x40010000
 800ee24: 00 04 00 40  	.word	0x40000400
 800ee28: 00 08 00 40  	.word	0x40000800
 800ee2c: 00 0c 00 40  	.word	0x40000c00
 800ee30: 00 04 01 40  	.word	0x40010400
 800ee34: 00 40 01 40  	.word	0x40014000
 800ee38: 00 44 01 40  	.word	0x40014400
 800ee3c: 00 48 01 40  	.word	0x40014800
 800ee40: 00 18 00 40  	.word	0x40001800
 800ee44: 00 1c 00 40  	.word	0x40001c00
 800ee48: 00 20 00 40  	.word	0x40002000

0800ee4c <OC1Config>:
; {
 800ee4c: b580         	push	{r7, lr}
 800ee4e: b086         	sub	sp, #0x18
 800ee50: af00         	add	r7, sp, #0x0
 800ee52: 6078         	str	r0, [r7, #0x4]
 800ee54: 6039         	str	r1, [r7]
;   CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
 800ee56: 687b         	ldr	r3, [r7, #0x4]
 800ee58: 6a1b         	ldr	r3, [r3, #0x20]
 800ee5a: f023 0201    	bic	r2, r3, #0x1
 800ee5e: 687b         	ldr	r3, [r7, #0x4]
 800ee60: 621a         	str	r2, [r3, #0x20]
;   tmpccer = LL_TIM_ReadReg(TIMx, CCER);
 800ee62: 687b         	ldr	r3, [r7, #0x4]
 800ee64: 6a1b         	ldr	r3, [r3, #0x20]
 800ee66: 617b         	str	r3, [r7, #0x14]
;   tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 800ee68: 687b         	ldr	r3, [r7, #0x4]
 800ee6a: 685b         	ldr	r3, [r3, #0x4]
 800ee6c: 613b         	str	r3, [r7, #0x10]
;   tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
 800ee6e: 687b         	ldr	r3, [r7, #0x4]
 800ee70: 699b         	ldr	r3, [r3, #0x18]
 800ee72: 60fb         	str	r3, [r7, #0xc]
;   CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);
 800ee74: 68fb         	ldr	r3, [r7, #0xc]
 800ee76: f023 0303    	bic	r3, r3, #0x3
 800ee7a: 60fb         	str	r3, [r7, #0xc]
;   MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
 800ee7c: 68fb         	ldr	r3, [r7, #0xc]
 800ee7e: f023 0270    	bic	r2, r3, #0x70
 800ee82: 683b         	ldr	r3, [r7]
 800ee84: 681b         	ldr	r3, [r3]
 800ee86: 4313         	orrs	r3, r2
 800ee88: 60fb         	str	r3, [r7, #0xc]
;   MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
 800ee8a: 697b         	ldr	r3, [r7, #0x14]
 800ee8c: f023 0202    	bic	r2, r3, #0x2
 800ee90: 683b         	ldr	r3, [r7]
 800ee92: 691b         	ldr	r3, [r3, #0x10]
 800ee94: 4313         	orrs	r3, r2
 800ee96: 617b         	str	r3, [r7, #0x14]
;   MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
 800ee98: 697b         	ldr	r3, [r7, #0x14]
 800ee9a: f023 0201    	bic	r2, r3, #0x1
 800ee9e: 683b         	ldr	r3, [r7]
 800eea0: 685b         	ldr	r3, [r3, #0x4]
 800eea2: 4313         	orrs	r3, r2
 800eea4: 617b         	str	r3, [r7, #0x14]
;   if (IS_TIM_BREAK_INSTANCE(TIMx))
 800eea6: 687b         	ldr	r3, [r7, #0x4]
 800eea8: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x800ef1c <OC1Config+0xd0>
 800eeaa: 4293         	cmp	r3, r2
 800eeac: d003         	beq	0x800eeb6 <OC1Config+0x6a> @ imm = #0x6
 800eeae: 687b         	ldr	r3, [r7, #0x4]
 800eeb0: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800ef20 <OC1Config+0xd4>
 800eeb2: 4293         	cmp	r3, r2
 800eeb4: d11e         	bne	0x800eef4 <OC1Config+0xa8> @ imm = #0x3c
;     MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
 800eeb6: 697b         	ldr	r3, [r7, #0x14]
 800eeb8: f023 0208    	bic	r2, r3, #0x8
 800eebc: 683b         	ldr	r3, [r7]
 800eebe: 695b         	ldr	r3, [r3, #0x14]
 800eec0: 009b         	lsls	r3, r3, #0x2
 800eec2: 4313         	orrs	r3, r2
 800eec4: 617b         	str	r3, [r7, #0x14]
;     MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
 800eec6: 697b         	ldr	r3, [r7, #0x14]
 800eec8: f023 0204    	bic	r2, r3, #0x4
 800eecc: 683b         	ldr	r3, [r7]
 800eece: 689b         	ldr	r3, [r3, #0x8]
 800eed0: 009b         	lsls	r3, r3, #0x2
 800eed2: 4313         	orrs	r3, r2
 800eed4: 617b         	str	r3, [r7, #0x14]
;     MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
 800eed6: 693b         	ldr	r3, [r7, #0x10]
 800eed8: f423 7280    	bic	r2, r3, #0x100
 800eedc: 683b         	ldr	r3, [r7]
 800eede: 699b         	ldr	r3, [r3, #0x18]
 800eee0: 4313         	orrs	r3, r2
 800eee2: 613b         	str	r3, [r7, #0x10]
;     MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
 800eee4: 693b         	ldr	r3, [r7, #0x10]
 800eee6: f423 7200    	bic	r2, r3, #0x200
 800eeea: 683b         	ldr	r3, [r7]
 800eeec: 69db         	ldr	r3, [r3, #0x1c]
 800eeee: 005b         	lsls	r3, r3, #0x1
 800eef0: 4313         	orrs	r3, r2
 800eef2: 613b         	str	r3, [r7, #0x10]
;   LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 800eef4: 687b         	ldr	r3, [r7, #0x4]
 800eef6: 693a         	ldr	r2, [r7, #0x10]
 800eef8: 605a         	str	r2, [r3, #0x4]
;   LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
 800eefa: 687b         	ldr	r3, [r7, #0x4]
 800eefc: 68fa         	ldr	r2, [r7, #0xc]
 800eefe: 619a         	str	r2, [r3, #0x18]
;   LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
 800ef00: 683b         	ldr	r3, [r7]
 800ef02: 68db         	ldr	r3, [r3, #0xc]
 800ef04: 4619         	mov	r1, r3
 800ef06: 6878         	ldr	r0, [r7, #0x4]
 800ef08: f00e ff66    	bl	0x801ddd8 <LL_TIM_OC_SetCompareCH1> @ imm = #0xeecc
;   LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 800ef0c: 687b         	ldr	r3, [r7, #0x4]
 800ef0e: 697a         	ldr	r2, [r7, #0x14]
 800ef10: 621a         	str	r2, [r3, #0x20]
;   return SUCCESS;
 800ef12: 2300         	movs	r3, #0x0
; }
 800ef14: 4618         	mov	r0, r3
 800ef16: 3718         	adds	r7, #0x18
 800ef18: 46bd         	mov	sp, r7
 800ef1a: bd80         	pop	{r7, pc}

0800ef1c <$d>:
 800ef1c: 00 00 01 40  	.word	0x40010000
 800ef20: 00 04 01 40  	.word	0x40010400

0800ef24 <OC2Config>:
; {
 800ef24: b580         	push	{r7, lr}
 800ef26: b086         	sub	sp, #0x18
 800ef28: af00         	add	r7, sp, #0x0
 800ef2a: 6078         	str	r0, [r7, #0x4]
 800ef2c: 6039         	str	r1, [r7]
;   CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
 800ef2e: 687b         	ldr	r3, [r7, #0x4]
 800ef30: 6a1b         	ldr	r3, [r3, #0x20]
 800ef32: f023 0210    	bic	r2, r3, #0x10
 800ef36: 687b         	ldr	r3, [r7, #0x4]
 800ef38: 621a         	str	r2, [r3, #0x20]
;   tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
 800ef3a: 687b         	ldr	r3, [r7, #0x4]
 800ef3c: 6a1b         	ldr	r3, [r3, #0x20]
 800ef3e: 617b         	str	r3, [r7, #0x14]
;   tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 800ef40: 687b         	ldr	r3, [r7, #0x4]
 800ef42: 685b         	ldr	r3, [r3, #0x4]
 800ef44: 613b         	str	r3, [r7, #0x10]
;   tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
 800ef46: 687b         	ldr	r3, [r7, #0x4]
 800ef48: 699b         	ldr	r3, [r3, #0x18]
 800ef4a: 60fb         	str	r3, [r7, #0xc]
;   CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);
 800ef4c: 68fb         	ldr	r3, [r7, #0xc]
 800ef4e: f423 7340    	bic	r3, r3, #0x300
 800ef52: 60fb         	str	r3, [r7, #0xc]
;   MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
 800ef54: 68fb         	ldr	r3, [r7, #0xc]
 800ef56: f423 42e0    	bic	r2, r3, #0x7000
 800ef5a: 683b         	ldr	r3, [r7]
 800ef5c: 681b         	ldr	r3, [r3]
 800ef5e: 021b         	lsls	r3, r3, #0x8
 800ef60: 4313         	orrs	r3, r2
 800ef62: 60fb         	str	r3, [r7, #0xc]
;   MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
 800ef64: 697b         	ldr	r3, [r7, #0x14]
 800ef66: f023 0220    	bic	r2, r3, #0x20
 800ef6a: 683b         	ldr	r3, [r7]
 800ef6c: 691b         	ldr	r3, [r3, #0x10]
 800ef6e: 011b         	lsls	r3, r3, #0x4
 800ef70: 4313         	orrs	r3, r2
 800ef72: 617b         	str	r3, [r7, #0x14]
;   MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
 800ef74: 697b         	ldr	r3, [r7, #0x14]
 800ef76: f023 0210    	bic	r2, r3, #0x10
 800ef7a: 683b         	ldr	r3, [r7]
 800ef7c: 685b         	ldr	r3, [r3, #0x4]
 800ef7e: 011b         	lsls	r3, r3, #0x4
 800ef80: 4313         	orrs	r3, r2
 800ef82: 617b         	str	r3, [r7, #0x14]
;   if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ef84: 687b         	ldr	r3, [r7, #0x4]
 800ef86: 4a1d         	ldr	r2, [pc, #0x74]         @ 0x800effc <OC2Config+0xd8>
 800ef88: 4293         	cmp	r3, r2
 800ef8a: d003         	beq	0x800ef94 <OC2Config+0x70> @ imm = #0x6
 800ef8c: 687b         	ldr	r3, [r7, #0x4]
 800ef8e: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x800f000 <OC2Config+0xdc>
 800ef90: 4293         	cmp	r3, r2
 800ef92: d11f         	bne	0x800efd4 <OC2Config+0xb0> @ imm = #0x3e
;     MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
 800ef94: 697b         	ldr	r3, [r7, #0x14]
 800ef96: f023 0280    	bic	r2, r3, #0x80
 800ef9a: 683b         	ldr	r3, [r7]
 800ef9c: 695b         	ldr	r3, [r3, #0x14]
 800ef9e: 019b         	lsls	r3, r3, #0x6
 800efa0: 4313         	orrs	r3, r2
 800efa2: 617b         	str	r3, [r7, #0x14]
;     MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
 800efa4: 697b         	ldr	r3, [r7, #0x14]
 800efa6: f023 0240    	bic	r2, r3, #0x40
 800efaa: 683b         	ldr	r3, [r7]
 800efac: 689b         	ldr	r3, [r3, #0x8]
 800efae: 019b         	lsls	r3, r3, #0x6
 800efb0: 4313         	orrs	r3, r2
 800efb2: 617b         	str	r3, [r7, #0x14]
;     MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
 800efb4: 693b         	ldr	r3, [r7, #0x10]
 800efb6: f423 6280    	bic	r2, r3, #0x400
 800efba: 683b         	ldr	r3, [r7]
 800efbc: 699b         	ldr	r3, [r3, #0x18]
 800efbe: 009b         	lsls	r3, r3, #0x2
 800efc0: 4313         	orrs	r3, r2
 800efc2: 613b         	str	r3, [r7, #0x10]
;     MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
 800efc4: 693b         	ldr	r3, [r7, #0x10]
 800efc6: f423 6200    	bic	r2, r3, #0x800
 800efca: 683b         	ldr	r3, [r7]
 800efcc: 69db         	ldr	r3, [r3, #0x1c]
 800efce: 00db         	lsls	r3, r3, #0x3
 800efd0: 4313         	orrs	r3, r2
 800efd2: 613b         	str	r3, [r7, #0x10]
;   LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 800efd4: 687b         	ldr	r3, [r7, #0x4]
 800efd6: 693a         	ldr	r2, [r7, #0x10]
 800efd8: 605a         	str	r2, [r3, #0x4]
;   LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
 800efda: 687b         	ldr	r3, [r7, #0x4]
 800efdc: 68fa         	ldr	r2, [r7, #0xc]
 800efde: 619a         	str	r2, [r3, #0x18]
;   LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
 800efe0: 683b         	ldr	r3, [r7]
 800efe2: 68db         	ldr	r3, [r3, #0xc]
 800efe4: 4619         	mov	r1, r3
 800efe6: 6878         	ldr	r0, [r7, #0x4]
 800efe8: f00e ff04    	bl	0x801ddf4 <LL_TIM_OC_SetCompareCH2> @ imm = #0xee08
;   LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 800efec: 687b         	ldr	r3, [r7, #0x4]
 800efee: 697a         	ldr	r2, [r7, #0x14]
 800eff0: 621a         	str	r2, [r3, #0x20]
;   return SUCCESS;
 800eff2: 2300         	movs	r3, #0x0
; }
 800eff4: 4618         	mov	r0, r3
 800eff6: 3718         	adds	r7, #0x18
 800eff8: 46bd         	mov	sp, r7
 800effa: bd80         	pop	{r7, pc}

0800effc <$d>:
 800effc: 00 00 01 40  	.word	0x40010000
 800f000: 00 04 01 40  	.word	0x40010400

0800f004 <OC3Config>:
; {
 800f004: b580         	push	{r7, lr}
 800f006: b086         	sub	sp, #0x18
 800f008: af00         	add	r7, sp, #0x0
 800f00a: 6078         	str	r0, [r7, #0x4]
 800f00c: 6039         	str	r1, [r7]
;   CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
 800f00e: 687b         	ldr	r3, [r7, #0x4]
 800f010: 6a1b         	ldr	r3, [r3, #0x20]
 800f012: f423 7280    	bic	r2, r3, #0x100
 800f016: 687b         	ldr	r3, [r7, #0x4]
 800f018: 621a         	str	r2, [r3, #0x20]
;   tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
 800f01a: 687b         	ldr	r3, [r7, #0x4]
 800f01c: 6a1b         	ldr	r3, [r3, #0x20]
 800f01e: 617b         	str	r3, [r7, #0x14]
;   tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 800f020: 687b         	ldr	r3, [r7, #0x4]
 800f022: 685b         	ldr	r3, [r3, #0x4]
 800f024: 613b         	str	r3, [r7, #0x10]
;   tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
 800f026: 687b         	ldr	r3, [r7, #0x4]
 800f028: 69db         	ldr	r3, [r3, #0x1c]
 800f02a: 60fb         	str	r3, [r7, #0xc]
;   CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);
 800f02c: 68fb         	ldr	r3, [r7, #0xc]
 800f02e: f023 0303    	bic	r3, r3, #0x3
 800f032: 60fb         	str	r3, [r7, #0xc]
;   MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
 800f034: 68fb         	ldr	r3, [r7, #0xc]
 800f036: f023 0270    	bic	r2, r3, #0x70
 800f03a: 683b         	ldr	r3, [r7]
 800f03c: 681b         	ldr	r3, [r3]
 800f03e: 4313         	orrs	r3, r2
 800f040: 60fb         	str	r3, [r7, #0xc]
;   MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
 800f042: 697b         	ldr	r3, [r7, #0x14]
 800f044: f423 7200    	bic	r2, r3, #0x200
 800f048: 683b         	ldr	r3, [r7]
 800f04a: 691b         	ldr	r3, [r3, #0x10]
 800f04c: 021b         	lsls	r3, r3, #0x8
 800f04e: 4313         	orrs	r3, r2
 800f050: 617b         	str	r3, [r7, #0x14]
;   MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
 800f052: 697b         	ldr	r3, [r7, #0x14]
 800f054: f423 7280    	bic	r2, r3, #0x100
 800f058: 683b         	ldr	r3, [r7]
 800f05a: 685b         	ldr	r3, [r3, #0x4]
 800f05c: 021b         	lsls	r3, r3, #0x8
 800f05e: 4313         	orrs	r3, r2
 800f060: 617b         	str	r3, [r7, #0x14]
;   if (IS_TIM_BREAK_INSTANCE(TIMx))
 800f062: 687b         	ldr	r3, [r7, #0x4]
 800f064: 4a1d         	ldr	r2, [pc, #0x74]         @ 0x800f0dc <OC3Config+0xd8>
 800f066: 4293         	cmp	r3, r2
 800f068: d003         	beq	0x800f072 <OC3Config+0x6e> @ imm = #0x6
 800f06a: 687b         	ldr	r3, [r7, #0x4]
 800f06c: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x800f0e0 <OC3Config+0xdc>
 800f06e: 4293         	cmp	r3, r2
 800f070: d11f         	bne	0x800f0b2 <OC3Config+0xae> @ imm = #0x3e
;     MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
 800f072: 697b         	ldr	r3, [r7, #0x14]
 800f074: f423 6200    	bic	r2, r3, #0x800
 800f078: 683b         	ldr	r3, [r7]
 800f07a: 695b         	ldr	r3, [r3, #0x14]
 800f07c: 029b         	lsls	r3, r3, #0xa
 800f07e: 4313         	orrs	r3, r2
 800f080: 617b         	str	r3, [r7, #0x14]
;     MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
 800f082: 697b         	ldr	r3, [r7, #0x14]
 800f084: f423 6280    	bic	r2, r3, #0x400
 800f088: 683b         	ldr	r3, [r7]
 800f08a: 689b         	ldr	r3, [r3, #0x8]
 800f08c: 029b         	lsls	r3, r3, #0xa
 800f08e: 4313         	orrs	r3, r2
 800f090: 617b         	str	r3, [r7, #0x14]
;     MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
 800f092: 693b         	ldr	r3, [r7, #0x10]
 800f094: f423 5280    	bic	r2, r3, #0x1000
 800f098: 683b         	ldr	r3, [r7]
 800f09a: 699b         	ldr	r3, [r3, #0x18]
 800f09c: 011b         	lsls	r3, r3, #0x4
 800f09e: 4313         	orrs	r3, r2
 800f0a0: 613b         	str	r3, [r7, #0x10]
;     MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
 800f0a2: 693b         	ldr	r3, [r7, #0x10]
 800f0a4: f423 5200    	bic	r2, r3, #0x2000
 800f0a8: 683b         	ldr	r3, [r7]
 800f0aa: 69db         	ldr	r3, [r3, #0x1c]
 800f0ac: 015b         	lsls	r3, r3, #0x5
 800f0ae: 4313         	orrs	r3, r2
 800f0b0: 613b         	str	r3, [r7, #0x10]
;   LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 800f0b2: 687b         	ldr	r3, [r7, #0x4]
 800f0b4: 693a         	ldr	r2, [r7, #0x10]
 800f0b6: 605a         	str	r2, [r3, #0x4]
;   LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
 800f0b8: 687b         	ldr	r3, [r7, #0x4]
 800f0ba: 68fa         	ldr	r2, [r7, #0xc]
 800f0bc: 61da         	str	r2, [r3, #0x1c]
;   LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
 800f0be: 683b         	ldr	r3, [r7]
 800f0c0: 68db         	ldr	r3, [r3, #0xc]
 800f0c2: 4619         	mov	r1, r3
 800f0c4: 6878         	ldr	r0, [r7, #0x4]
 800f0c6: f00e fea3    	bl	0x801de10 <LL_TIM_OC_SetCompareCH3> @ imm = #0xed46
;   LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 800f0ca: 687b         	ldr	r3, [r7, #0x4]
 800f0cc: 697a         	ldr	r2, [r7, #0x14]
 800f0ce: 621a         	str	r2, [r3, #0x20]
;   return SUCCESS;
 800f0d0: 2300         	movs	r3, #0x0
; }
 800f0d2: 4618         	mov	r0, r3
 800f0d4: 3718         	adds	r7, #0x18
 800f0d6: 46bd         	mov	sp, r7
 800f0d8: bd80         	pop	{r7, pc}
 800f0da: bf00         	nop

0800f0dc <$d>:
 800f0dc: 00 00 01 40  	.word	0x40010000
 800f0e0: 00 04 01 40  	.word	0x40010400

0800f0e4 <OC4Config>:
; {
 800f0e4: b580         	push	{r7, lr}
 800f0e6: b086         	sub	sp, #0x18
 800f0e8: af00         	add	r7, sp, #0x0
 800f0ea: 6078         	str	r0, [r7, #0x4]
 800f0ec: 6039         	str	r1, [r7]
;   CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
 800f0ee: 687b         	ldr	r3, [r7, #0x4]
 800f0f0: 6a1b         	ldr	r3, [r3, #0x20]
 800f0f2: f423 5280    	bic	r2, r3, #0x1000
 800f0f6: 687b         	ldr	r3, [r7, #0x4]
 800f0f8: 621a         	str	r2, [r3, #0x20]
;   tmpccer = LL_TIM_ReadReg(TIMx, CCER);
 800f0fa: 687b         	ldr	r3, [r7, #0x4]
 800f0fc: 6a1b         	ldr	r3, [r3, #0x20]
 800f0fe: 613b         	str	r3, [r7, #0x10]
;   tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
 800f100: 687b         	ldr	r3, [r7, #0x4]
 800f102: 685b         	ldr	r3, [r3, #0x4]
 800f104: 617b         	str	r3, [r7, #0x14]
;   tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
 800f106: 687b         	ldr	r3, [r7, #0x4]
 800f108: 69db         	ldr	r3, [r3, #0x1c]
 800f10a: 60fb         	str	r3, [r7, #0xc]
;   CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);
 800f10c: 68fb         	ldr	r3, [r7, #0xc]
 800f10e: f423 7340    	bic	r3, r3, #0x300
 800f112: 60fb         	str	r3, [r7, #0xc]
;   MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
 800f114: 68fb         	ldr	r3, [r7, #0xc]
 800f116: f423 42e0    	bic	r2, r3, #0x7000
 800f11a: 683b         	ldr	r3, [r7]
 800f11c: 681b         	ldr	r3, [r3]
 800f11e: 021b         	lsls	r3, r3, #0x8
 800f120: 4313         	orrs	r3, r2
 800f122: 60fb         	str	r3, [r7, #0xc]
;   MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
 800f124: 693b         	ldr	r3, [r7, #0x10]
 800f126: f423 5200    	bic	r2, r3, #0x2000
 800f12a: 683b         	ldr	r3, [r7]
 800f12c: 691b         	ldr	r3, [r3, #0x10]
 800f12e: 031b         	lsls	r3, r3, #0xc
 800f130: 4313         	orrs	r3, r2
 800f132: 613b         	str	r3, [r7, #0x10]
;   MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
 800f134: 693b         	ldr	r3, [r7, #0x10]
 800f136: f423 5280    	bic	r2, r3, #0x1000
 800f13a: 683b         	ldr	r3, [r7]
 800f13c: 685b         	ldr	r3, [r3, #0x4]
 800f13e: 031b         	lsls	r3, r3, #0xc
 800f140: 4313         	orrs	r3, r2
 800f142: 613b         	str	r3, [r7, #0x10]
;   if (IS_TIM_BREAK_INSTANCE(TIMx))
 800f144: 687b         	ldr	r3, [r7, #0x4]
 800f146: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800f18c <OC4Config+0xa8>
 800f148: 4293         	cmp	r3, r2
 800f14a: d003         	beq	0x800f154 <OC4Config+0x70> @ imm = #0x6
 800f14c: 687b         	ldr	r3, [r7, #0x4]
 800f14e: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800f190 <OC4Config+0xac>
 800f150: 4293         	cmp	r3, r2
 800f152: d107         	bne	0x800f164 <OC4Config+0x80> @ imm = #0xe
;     MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
 800f154: 697b         	ldr	r3, [r7, #0x14]
 800f156: f423 4280    	bic	r2, r3, #0x4000
 800f15a: 683b         	ldr	r3, [r7]
 800f15c: 699b         	ldr	r3, [r3, #0x18]
 800f15e: 019b         	lsls	r3, r3, #0x6
 800f160: 4313         	orrs	r3, r2
 800f162: 617b         	str	r3, [r7, #0x14]
;   LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 800f164: 687b         	ldr	r3, [r7, #0x4]
 800f166: 697a         	ldr	r2, [r7, #0x14]
 800f168: 605a         	str	r2, [r3, #0x4]
;   LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
 800f16a: 687b         	ldr	r3, [r7, #0x4]
 800f16c: 68fa         	ldr	r2, [r7, #0xc]
 800f16e: 61da         	str	r2, [r3, #0x1c]
;   LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
 800f170: 683b         	ldr	r3, [r7]
 800f172: 68db         	ldr	r3, [r3, #0xc]
 800f174: 4619         	mov	r1, r3
 800f176: 6878         	ldr	r0, [r7, #0x4]
 800f178: f00e fe58    	bl	0x801de2c <LL_TIM_OC_SetCompareCH4> @ imm = #0xecb0
;   LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 800f17c: 687b         	ldr	r3, [r7, #0x4]
 800f17e: 693a         	ldr	r2, [r7, #0x10]
 800f180: 621a         	str	r2, [r3, #0x20]
;   return SUCCESS;
 800f182: 2300         	movs	r3, #0x0
; }
 800f184: 4618         	mov	r0, r3
 800f186: 3718         	adds	r7, #0x18
 800f188: 46bd         	mov	sp, r7
 800f18a: bd80         	pop	{r7, pc}

0800f18c <$d>:
 800f18c: 00 00 01 40  	.word	0x40010000
 800f190: 00 04 01 40  	.word	0x40010400

0800f194 <LL_FLASH_SetLatency>:
; {
 800f194: b480         	push	{r7}
 800f196: b083         	sub	sp, #0xc
 800f198: af00         	add	r7, sp, #0x0
 800f19a: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 800f19c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800f1b8 <LL_FLASH_SetLatency+0x24>
 800f19e: 681b         	ldr	r3, [r3]
 800f1a0: f023 0207    	bic	r2, r3, #0x7
 800f1a4: 4904         	ldr	r1, [pc, #0x10]         @ 0x800f1b8 <LL_FLASH_SetLatency+0x24>
 800f1a6: 687b         	ldr	r3, [r7, #0x4]
 800f1a8: 4313         	orrs	r3, r2
 800f1aa: 600b         	str	r3, [r1]
; }
 800f1ac: bf00         	nop
 800f1ae: 370c         	adds	r7, #0xc
 800f1b0: 46bd         	mov	sp, r7
 800f1b2: f85d 7b04    	ldr	r7, [sp], #4
 800f1b6: 4770         	bx	lr

0800f1b8 <$d>:
 800f1b8: 00 3c 02 40  	.word	0x40023c00

0800f1bc <LL_FLASH_GetLatency>:
; {
 800f1bc: b480         	push	{r7}
 800f1be: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
 800f1c0: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800f1d4 <LL_FLASH_GetLatency+0x18>
 800f1c2: 681b         	ldr	r3, [r3]
 800f1c4: f003 0307    	and	r3, r3, #0x7
; }
 800f1c8: 4618         	mov	r0, r3
 800f1ca: 46bd         	mov	sp, r7
 800f1cc: f85d 7b04    	ldr	r7, [sp], #4
 800f1d0: 4770         	bx	lr
 800f1d2: bf00         	nop

0800f1d4 <$d>:
 800f1d4: 00 3c 02 40  	.word	0x40023c00

0800f1d8 <LL_PWR_GetRegulVoltageScaling>:
; {
 800f1d8: b480         	push	{r7}
 800f1da: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(PWR->CR, PWR_CR_VOS));
 800f1dc: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800f1f0 <LL_PWR_GetRegulVoltageScaling+0x18>
 800f1de: 681b         	ldr	r3, [r3]
 800f1e0: f403 4380    	and	r3, r3, #0x4000
; }
 800f1e4: 4618         	mov	r0, r3
 800f1e6: 46bd         	mov	sp, r7
 800f1e8: f85d 7b04    	ldr	r7, [sp], #4
 800f1ec: 4770         	bx	lr
 800f1ee: bf00         	nop

0800f1f0 <$d>:
 800f1f0: 00 70 00 40  	.word	0x40007000

0800f1f4 <LL_SetFlashLatency>:
; {
 800f1f4: b580         	push	{r7, lr}
 800f1f6: b086         	sub	sp, #0x18
 800f1f8: af00         	add	r7, sp, #0x0
 800f1fa: 6078         	str	r0, [r7, #0x4]
;   uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */
 800f1fc: 2300         	movs	r3, #0x0
 800f1fe: 613b         	str	r3, [r7, #0x10]
;   ErrorStatus status = SUCCESS;
 800f200: 2300         	movs	r3, #0x0
 800f202: 73fb         	strb	r3, [r7, #0xf]
;   if(HCLK_Frequency == 0U)
 800f204: 687b         	ldr	r3, [r7, #0x4]
 800f206: 2b00         	cmp	r3, #0x0
 800f208: d102         	bne	0x800f210 <LL_SetFlashLatency+0x1c> @ imm = #0x4
;     status = ERROR;
 800f20a: 2301         	movs	r3, #0x1
 800f20c: 73fb         	strb	r3, [r7, #0xf]
 800f20e: e078         	b	0x800f302 <LL_SetFlashLatency+0x10e> @ imm = #0xf0
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)
 800f210: f7ff ffe2    	bl	0x800f1d8 <LL_PWR_GetRegulVoltageScaling> @ imm = #-0x3c
 800f214: 4603         	mov	r3, r0
 800f216: f5b3 4f80    	cmp.w	r3, #0x4000
 800f21a: d12d         	bne	0x800f278 <LL_SetFlashLatency+0x84> @ imm = #0x5a
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY5_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800f21c: 687b         	ldr	r3, [r7, #0x4]
 800f21e: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x800f30c <LL_SetFlashLatency+0x118>
 800f220: 4293         	cmp	r3, r2
 800f222: d904         	bls	0x800f22e <LL_SetFlashLatency+0x3a> @ imm = #0x8
 800f224: 693b         	ldr	r3, [r7, #0x10]
 800f226: 2b00         	cmp	r3, #0x0
 800f228: d101         	bne	0x800f22e <LL_SetFlashLatency+0x3a> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_5;
 800f22a: 2305         	movs	r3, #0x5
 800f22c: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800f22e: 687b         	ldr	r3, [r7, #0x4]
 800f230: 4a37         	ldr	r2, [pc, #0xdc]         @ 0x800f310 <LL_SetFlashLatency+0x11c>
 800f232: 4293         	cmp	r3, r2
 800f234: d904         	bls	0x800f240 <LL_SetFlashLatency+0x4c> @ imm = #0x8
 800f236: 693b         	ldr	r3, [r7, #0x10]
 800f238: 2b00         	cmp	r3, #0x0
 800f23a: d101         	bne	0x800f240 <LL_SetFlashLatency+0x4c> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 800f23c: 2304         	movs	r3, #0x4
 800f23e: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800f240: 687b         	ldr	r3, [r7, #0x4]
 800f242: 4a34         	ldr	r2, [pc, #0xd0]         @ 0x800f314 <LL_SetFlashLatency+0x120>
 800f244: 4293         	cmp	r3, r2
 800f246: d904         	bls	0x800f252 <LL_SetFlashLatency+0x5e> @ imm = #0x8
 800f248: 693b         	ldr	r3, [r7, #0x10]
 800f24a: 2b00         	cmp	r3, #0x0
 800f24c: d101         	bne	0x800f252 <LL_SetFlashLatency+0x5e> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 800f24e: 2303         	movs	r3, #0x3
 800f250: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800f252: 687b         	ldr	r3, [r7, #0x4]
 800f254: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x800f318 <LL_SetFlashLatency+0x124>
 800f256: 4293         	cmp	r3, r2
 800f258: d905         	bls	0x800f266 <LL_SetFlashLatency+0x72> @ imm = #0xa
 800f25a: 693b         	ldr	r3, [r7, #0x10]
 800f25c: 2b00         	cmp	r3, #0x0
 800f25e: d102         	bne	0x800f266 <LL_SetFlashLatency+0x72> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 800f260: 2302         	movs	r3, #0x2
 800f262: 613b         	str	r3, [r7, #0x10]
 800f264: e008         	b	0x800f278 <LL_SetFlashLatency+0x84> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800f266: 687b         	ldr	r3, [r7, #0x4]
 800f268: 4a2c         	ldr	r2, [pc, #0xb0]         @ 0x800f31c <LL_SetFlashLatency+0x128>
 800f26a: 4293         	cmp	r3, r2
 800f26c: d904         	bls	0x800f278 <LL_SetFlashLatency+0x84> @ imm = #0x8
 800f26e: 693b         	ldr	r3, [r7, #0x10]
 800f270: 2b00         	cmp	r3, #0x0
 800f272: d101         	bne	0x800f278 <LL_SetFlashLatency+0x84> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 800f274: 2301         	movs	r3, #0x1
 800f276: 613b         	str	r3, [r7, #0x10]
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)
 800f278: f7ff ffae    	bl	0x800f1d8 <LL_PWR_GetRegulVoltageScaling> @ imm = #-0xa4
 800f27c: 4603         	mov	r3, r0
 800f27e: 2b00         	cmp	r3, #0x0
 800f280: d124         	bne	0x800f2cc <LL_SetFlashLatency+0xd8> @ imm = #0x48
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800f282: 687b         	ldr	r3, [r7, #0x4]
 800f284: 4a22         	ldr	r2, [pc, #0x88]         @ 0x800f310 <LL_SetFlashLatency+0x11c>
 800f286: 4293         	cmp	r3, r2
 800f288: d904         	bls	0x800f294 <LL_SetFlashLatency+0xa0> @ imm = #0x8
 800f28a: 693b         	ldr	r3, [r7, #0x10]
 800f28c: 2b00         	cmp	r3, #0x0
 800f28e: d101         	bne	0x800f294 <LL_SetFlashLatency+0xa0> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 800f290: 2304         	movs	r3, #0x4
 800f292: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800f294: 687b         	ldr	r3, [r7, #0x4]
 800f296: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x800f314 <LL_SetFlashLatency+0x120>
 800f298: 4293         	cmp	r3, r2
 800f29a: d904         	bls	0x800f2a6 <LL_SetFlashLatency+0xb2> @ imm = #0x8
 800f29c: 693b         	ldr	r3, [r7, #0x10]
 800f29e: 2b00         	cmp	r3, #0x0
 800f2a0: d101         	bne	0x800f2a6 <LL_SetFlashLatency+0xb2> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 800f2a2: 2303         	movs	r3, #0x3
 800f2a4: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800f2a6: 687b         	ldr	r3, [r7, #0x4]
 800f2a8: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800f318 <LL_SetFlashLatency+0x124>
 800f2aa: 4293         	cmp	r3, r2
 800f2ac: d905         	bls	0x800f2ba <LL_SetFlashLatency+0xc6> @ imm = #0xa
 800f2ae: 693b         	ldr	r3, [r7, #0x10]
 800f2b0: 2b00         	cmp	r3, #0x0
 800f2b2: d102         	bne	0x800f2ba <LL_SetFlashLatency+0xc6> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 800f2b4: 2302         	movs	r3, #0x2
 800f2b6: 613b         	str	r3, [r7, #0x10]
 800f2b8: e008         	b	0x800f2cc <LL_SetFlashLatency+0xd8> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 800f2ba: 687b         	ldr	r3, [r7, #0x4]
 800f2bc: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800f31c <LL_SetFlashLatency+0x128>
 800f2be: 4293         	cmp	r3, r2
 800f2c0: d904         	bls	0x800f2cc <LL_SetFlashLatency+0xd8> @ imm = #0x8
 800f2c2: 693b         	ldr	r3, [r7, #0x10]
 800f2c4: 2b00         	cmp	r3, #0x0
 800f2c6: d101         	bne	0x800f2cc <LL_SetFlashLatency+0xd8> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 800f2c8: 2301         	movs	r3, #0x1
 800f2ca: 613b         	str	r3, [r7, #0x10]
;     LL_FLASH_SetLatency(latency);
 800f2cc: 6938         	ldr	r0, [r7, #0x10]
 800f2ce: f7ff ff61    	bl	0x800f194 <LL_FLASH_SetLatency> @ imm = #-0x13e
;     timeout = 2;
 800f2d2: 2302         	movs	r3, #0x2
 800f2d4: 617b         	str	r3, [r7, #0x14]
;     getlatency = LL_FLASH_GetLatency();
 800f2d6: f7ff ff71    	bl	0x800f1bc <LL_FLASH_GetLatency> @ imm = #-0x11e
 800f2da: 60b8         	str	r0, [r7, #0x8]
;     timeout--;
 800f2dc: 697b         	ldr	r3, [r7, #0x14]
 800f2de: 3b01         	subs	r3, #0x1
 800f2e0: 617b         	str	r3, [r7, #0x14]
;     } while ((getlatency != latency) && (timeout > 0));
 800f2e2: 68ba         	ldr	r2, [r7, #0x8]
 800f2e4: 693b         	ldr	r3, [r7, #0x10]
 800f2e6: 429a         	cmp	r2, r3
 800f2e8: d002         	beq	0x800f2f0 <LL_SetFlashLatency+0xfc> @ imm = #0x4
 800f2ea: 697b         	ldr	r3, [r7, #0x14]
 800f2ec: 2b00         	cmp	r3, #0x0
 800f2ee: d1f2         	bne	0x800f2d6 <LL_SetFlashLatency+0xe2> @ imm = #-0x1c
;     if(getlatency != latency)
 800f2f0: 68ba         	ldr	r2, [r7, #0x8]
 800f2f2: 693b         	ldr	r3, [r7, #0x10]
 800f2f4: 429a         	cmp	r2, r3
 800f2f6: d002         	beq	0x800f2fe <LL_SetFlashLatency+0x10a> @ imm = #0x4
;       status = ERROR;
 800f2f8: 2301         	movs	r3, #0x1
 800f2fa: 73fb         	strb	r3, [r7, #0xf]
 800f2fc: e001         	b	0x800f302 <LL_SetFlashLatency+0x10e> @ imm = #0x2
;       status = SUCCESS;
 800f2fe: 2300         	movs	r3, #0x0
 800f300: 73fb         	strb	r3, [r7, #0xf]
;   return status;
 800f302: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 800f304: 4618         	mov	r0, r3
 800f306: 3718         	adds	r7, #0x18
 800f308: 46bd         	mov	sp, r7
 800f30a: bd80         	pop	{r7, pc}

0800f30c <$d>:
 800f30c: 80 d1 f0 08  	.word	0x08f0d180
 800f310: 00 0e 27 07  	.word	0x07270e00
 800f314: 80 4a 5d 05  	.word	0x055d4a80
 800f318: 00 87 93 03  	.word	0x03938700
 800f31c: 80 c3 c9 01  	.word	0x01c9c380

0800f320 <z_device_state_init>:
; {
 800f320: b580         	push	{r7, lr}
 800f322: b082         	sub	sp, #0x8
 800f324: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(device, dev) {
 800f326: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800f354 <z_device_state_init+0x34>
 800f328: 607b         	str	r3, [r7, #0x4]
 800f32a: e005         	b	0x800f338 <z_device_state_init+0x18> @ imm = #0xa
; 		k_object_init(dev);
 800f32c: 6878         	ldr	r0, [r7, #0x4]
 800f32e: f00e fe45    	bl	0x801dfbc <k_object_init> @ imm = #0xec8a
; 	STRUCT_SECTION_FOREACH(device, dev) {
 800f332: 687b         	ldr	r3, [r7, #0x4]
 800f334: 3314         	adds	r3, #0x14
 800f336: 607b         	str	r3, [r7, #0x4]
 800f338: 687b         	ldr	r3, [r7, #0x4]
 800f33a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800f358 <z_device_state_init+0x38>
 800f33c: 4293         	cmp	r3, r2
 800f33e: bf34         	ite	lo
 800f340: 2301         	movlo	r3, #0x1
 800f342: 2300         	movhs	r3, #0x0
 800f344: b2db         	uxtb	r3, r3
 800f346: 2b00         	cmp	r3, #0x0
 800f348: d1f0         	bne	0x800f32c <z_device_state_init+0xc> @ imm = #-0x20
; }
 800f34a: bf00         	nop
 800f34c: bf00         	nop
 800f34e: 3708         	adds	r7, #0x8
 800f350: 46bd         	mov	sp, r7
 800f352: bd80         	pop	{r7, pc}

0800f354 <$d>:
 800f354: 80 01 02 08  	.word	0x08020180
 800f358: 38 03 02 08  	.word	0x08020338

0800f35c <k_sys_fatal_error_handler>:
; {
 800f35c: b580         	push	{r7, lr}
 800f35e: b088         	sub	sp, #0x20
 800f360: af04         	add	r7, sp, #0x10
 800f362: 6078         	str	r0, [r7, #0x4]
 800f364: 6039         	str	r1, [r7]
; 	LOG_PANIC();
 800f366: f00e fe7e    	bl	0x801e066 <log_panic>   @ imm = #0xecfc
; 	LOG_ERR("Halting system");
 800f36a: 2303         	movs	r3, #0x3
 800f36c: 2b00         	cmp	r3, #0x0
 800f36e: d016         	beq	0x800f39e <k_sys_fatal_error_handler+0x42> @ imm = #0x2c
 800f370: 2301         	movs	r3, #0x1
 800f372: 73fb         	strb	r3, [r7, #0xf]
 800f374: 7bfb         	ldrb	r3, [r7, #0xf]
 800f376: f083 0301    	eor	r3, r3, #0x1
 800f37a: b2db         	uxtb	r3, r3
 800f37c: 2b00         	cmp	r3, #0x0
 800f37e: d10e         	bne	0x800f39e <k_sys_fatal_error_handler+0x42> @ imm = #0x1c
 800f380: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800f3a4 <k_sys_fatal_error_handler+0x48>
 800f382: 6819         	ldr	r1, [r3]
 800f384: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800f3a8 <k_sys_fatal_error_handler+0x4c>
 800f386: 9302         	str	r3, [sp, #0x8]
 800f388: 2300         	movs	r3, #0x0
 800f38a: 9301         	str	r3, [sp, #0x4]
 800f38c: 2300         	movs	r3, #0x0
 800f38e: 9300         	str	r3, [sp]
 800f390: 2300         	movs	r3, #0x0
 800f392: 2201         	movs	r2, #0x1
 800f394: 2000         	movs	r0, #0x0
 800f396: f00e fe48    	bl	0x801e02a <z_log_msg_runtime_create> @ imm = #0xec90
 800f39a: 2300         	movs	r3, #0x0
 800f39c: 60bb         	str	r3, [r7, #0x8]
; 	arch_system_halt(reason);
 800f39e: 6878         	ldr	r0, [r7, #0x4]
 800f3a0: f00e fe73    	bl	0x801e08a <arch_system_halt> @ imm = #0xece6

0800f3a4 <$d>:
 800f3a4: f0 05 00 20  	.word	0x200005f0
 800f3a8: 48 1f 02 08  	.word	0x08021f48

0800f3ac <thread_name_get>:
; {
 800f3ac: b580         	push	{r7, lr}
 800f3ae: b084         	sub	sp, #0x10
 800f3b0: af00         	add	r7, sp, #0x0
 800f3b2: 6078         	str	r0, [r7, #0x4]
; 	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
 800f3b4: 687b         	ldr	r3, [r7, #0x4]
 800f3b6: 2b00         	cmp	r3, #0x0
 800f3b8: d004         	beq	0x800f3c4 <thread_name_get+0x18> @ imm = #0x8
 800f3ba: 6878         	ldr	r0, [r7, #0x4]
 800f3bc: f00f fe04    	bl	0x801efc8 <k_thread_name_get> @ imm = #0xfc08
 800f3c0: 4603         	mov	r3, r0
 800f3c2: e000         	b	0x800f3c6 <thread_name_get+0x1a> @ imm = #0x0
 800f3c4: 2300         	movs	r3, #0x0
 800f3c6: 60fb         	str	r3, [r7, #0xc]
; 	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
 800f3c8: 68fb         	ldr	r3, [r7, #0xc]
 800f3ca: 2b00         	cmp	r3, #0x0
 800f3cc: d003         	beq	0x800f3d6 <thread_name_get+0x2a> @ imm = #0x6
 800f3ce: 68fb         	ldr	r3, [r7, #0xc]
 800f3d0: 781b         	ldrb	r3, [r3]
 800f3d2: 2b00         	cmp	r3, #0x0
 800f3d4: d101         	bne	0x800f3da <thread_name_get+0x2e> @ imm = #0x2
; 		thread_name = "unknown";
 800f3d6: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800f3e4 <thread_name_get+0x38>
 800f3d8: 60fb         	str	r3, [r7, #0xc]
; 	return thread_name;
 800f3da: 68fb         	ldr	r3, [r7, #0xc]
; }
 800f3dc: 4618         	mov	r0, r3
 800f3de: 3710         	adds	r7, #0x10
 800f3e0: 46bd         	mov	sp, r7
 800f3e2: bd80         	pop	{r7, pc}

0800f3e4 <$d>:
 800f3e4: 58 1f 02 08  	.word	0x08021f58

0800f3e8 <reason_to_str>:
; {
 800f3e8: b480         	push	{r7}
 800f3ea: b083         	sub	sp, #0xc
 800f3ec: af00         	add	r7, sp, #0x0
 800f3ee: 6078         	str	r0, [r7, #0x4]
; 	switch (reason) {
 800f3f0: 687b         	ldr	r3, [r7, #0x4]
 800f3f2: 2b04         	cmp	r3, #0x4
 800f3f4: d816         	bhi	0x800f424 <reason_to_str+0x3c> @ imm = #0x2c
 800f3f6: a201         	adr	r2, #4 <reason_to_str+0x13>
 800f3f8: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800f3fc <$d>:
 800f3fc: 11 f4 00 08  	.word	0x0800f411
 800f400: 15 f4 00 08  	.word	0x0800f415
 800f404: 19 f4 00 08  	.word	0x0800f419
 800f408: 1d f4 00 08  	.word	0x0800f41d
 800f40c: 21 f4 00 08  	.word	0x0800f421

0800f410 <$t>:
; 		return "CPU exception";
 800f410: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800f434 <reason_to_str+0x4c>
 800f412: e008         	b	0x800f426 <reason_to_str+0x3e> @ imm = #0x10
; 		return "Unhandled interrupt";
 800f414: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800f438 <reason_to_str+0x50>
 800f416: e006         	b	0x800f426 <reason_to_str+0x3e> @ imm = #0xc
; 		return "Stack overflow";
 800f418: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800f43c <reason_to_str+0x54>
 800f41a: e004         	b	0x800f426 <reason_to_str+0x3e> @ imm = #0x8
; 		return "Kernel oops";
 800f41c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800f440 <reason_to_str+0x58>
 800f41e: e002         	b	0x800f426 <reason_to_str+0x3e> @ imm = #0x4
; 		return "Kernel panic";
 800f420: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800f444 <reason_to_str+0x5c>
 800f422: e000         	b	0x800f426 <reason_to_str+0x3e> @ imm = #0x0
; 		return "Unknown error";
 800f424: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800f448 <reason_to_str+0x60>
; }
 800f426: 4618         	mov	r0, r3
 800f428: 370c         	adds	r7, #0xc
 800f42a: 46bd         	mov	sp, r7
 800f42c: f85d 7b04    	ldr	r7, [sp], #4
 800f430: 4770         	bx	lr
 800f432: bf00         	nop

0800f434 <$d>:
 800f434: 60 1f 02 08  	.word	0x08021f60
 800f438: 70 1f 02 08  	.word	0x08021f70
 800f43c: 84 1f 02 08  	.word	0x08021f84
 800f440: 94 1f 02 08  	.word	0x08021f94
 800f444: a0 1f 02 08  	.word	0x08021fa0
 800f448: b0 1f 02 08  	.word	0x08021fb0

0800f44c <z_fatal_error>:
; {
 800f44c: b590         	push	{r4, r7, lr}
 800f44e: b099         	sub	sp, #0x64
 800f450: af06         	add	r7, sp, #0x18
 800f452: 6078         	str	r0, [r7, #0x4]
 800f454: 6039         	str	r1, [r7]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800f456: f3ef 8311    	mrs	r3, basepri
 800f45a: 623b         	str	r3, [r7, #0x20]
;   return(result);
 800f45c: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 800f45e: 61fb         	str	r3, [r7, #0x1c]
 800f460: 2310         	movs	r3, #0x10
 800f462: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800f464: 69bb         	ldr	r3, [r7, #0x18]
 800f466: f383 8812    	msr	basepri_max, r3
; }
 800f46a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f46c: f3bf 8f6f    	isb	sy
; }
 800f470: bf00         	nop
; 	return key;
 800f472: 69fb         	ldr	r3, [r7, #0x1c]
; 	unsigned int key = arch_irq_lock();
 800f474: 63bb         	str	r3, [r7, #0x38]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800f476: 4b50         	ldr	r3, [pc, #0x140]        @ 0x800f5b8 <z_fatal_error+0x16c>
 800f478: 689b         	ldr	r3, [r3, #0x8]
 800f47a: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800f47c: 6a7b         	ldr	r3, [r7, #0x24]
; 	struct k_thread *thread = IS_ENABLED(CONFIG_MULTITHREADING) ? arch_current_thread() : NULL;
 800f47e: 643b         	str	r3, [r7, #0x40]
; 	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason, reason_to_str(reason),
 800f480: 2303         	movs	r3, #0x3
 800f482: 2b00         	cmp	r3, #0x0
 800f484: d023         	beq	0x800f4ce <z_fatal_error+0x82> @ imm = #0x46
 800f486: 2301         	movs	r3, #0x1
 800f488: f887 303f    	strb.w	r3, [r7, #0x3f]
 800f48c: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800f490: f083 0301    	eor	r3, r3, #0x1
 800f494: b2db         	uxtb	r3, r3
 800f496: 2b00         	cmp	r3, #0x0
 800f498: d119         	bne	0x800f4ce <z_fatal_error+0x82> @ imm = #0x32
 800f49a: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800f5bc <z_fatal_error+0x170>
 800f49c: 681c         	ldr	r4, [r3]
 800f49e: 6878         	ldr	r0, [r7, #0x4]
 800f4a0: f7ff ffa2    	bl	0x800f3e8 <reason_to_str> @ imm = #-0xbc
 800f4a4: 4603         	mov	r3, r0
 800f4a6: 4a44         	ldr	r2, [pc, #0x110]        @ 0x800f5b8 <z_fatal_error+0x16c>
 800f4a8: 7c12         	ldrb	r2, [r2, #0x10]
 800f4aa: 9205         	str	r2, [sp, #0x14]
 800f4ac: 9304         	str	r3, [sp, #0x10]
 800f4ae: 687b         	ldr	r3, [r7, #0x4]
 800f4b0: 9303         	str	r3, [sp, #0xc]
 800f4b2: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800f5c0 <z_fatal_error+0x174>
 800f4b4: 9302         	str	r3, [sp, #0x8]
 800f4b6: 2300         	movs	r3, #0x0
 800f4b8: 9301         	str	r3, [sp, #0x4]
 800f4ba: 2300         	movs	r3, #0x0
 800f4bc: 9300         	str	r3, [sp]
 800f4be: 2300         	movs	r3, #0x0
 800f4c0: 2201         	movs	r2, #0x1
 800f4c2: 4621         	mov	r1, r4
 800f4c4: 2000         	movs	r0, #0x0
 800f4c6: f00e fdb0    	bl	0x801e02a <z_log_msg_runtime_create> @ imm = #0xeb60
 800f4ca: 2300         	movs	r3, #0x0
 800f4cc: 647b         	str	r3, [r7, #0x44]
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800f4ce: 683b         	ldr	r3, [r7]
 800f4d0: 2b00         	cmp	r3, #0x0
 800f4d2: d028         	beq	0x800f526 <z_fatal_error+0xda> @ imm = #0x50
 800f4d4: 683b         	ldr	r3, [r7]
 800f4d6: 617b         	str	r3, [r7, #0x14]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 800f4d8: 697b         	ldr	r3, [r7, #0x14]
 800f4da: 69db         	ldr	r3, [r3, #0x1c]
 800f4dc: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 800f4e0: 2b00         	cmp	r3, #0x0
 800f4e2: bf14         	ite	ne
 800f4e4: 2301         	movne	r3, #0x1
 800f4e6: 2300         	moveq	r3, #0x0
 800f4e8: b2db         	uxtb	r3, r3
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800f4ea: 2b00         	cmp	r3, #0x0
 800f4ec: d01b         	beq	0x800f526 <z_fatal_error+0xda> @ imm = #0x36
; 		LOG_ERR("Fault during interrupt handling\n");
 800f4ee: 2303         	movs	r3, #0x3
 800f4f0: 2b00         	cmp	r3, #0x0
 800f4f2: d018         	beq	0x800f526 <z_fatal_error+0xda> @ imm = #0x30
 800f4f4: 2301         	movs	r3, #0x1
 800f4f6: f887 3037    	strb.w	r3, [r7, #0x37]
 800f4fa: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800f4fe: f083 0301    	eor	r3, r3, #0x1
 800f502: b2db         	uxtb	r3, r3
 800f504: 2b00         	cmp	r3, #0x0
 800f506: d10e         	bne	0x800f526 <z_fatal_error+0xda> @ imm = #0x1c
 800f508: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800f5bc <z_fatal_error+0x170>
 800f50a: 6819         	ldr	r1, [r3]
 800f50c: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x800f5c4 <z_fatal_error+0x178>
 800f50e: 9302         	str	r3, [sp, #0x8]
 800f510: 2300         	movs	r3, #0x0
 800f512: 9301         	str	r3, [sp, #0x4]
 800f514: 2300         	movs	r3, #0x0
 800f516: 9300         	str	r3, [sp]
 800f518: 2300         	movs	r3, #0x0
 800f51a: 2201         	movs	r2, #0x1
 800f51c: 2000         	movs	r0, #0x0
 800f51e: f00e fd84    	bl	0x801e02a <z_log_msg_runtime_create> @ imm = #0xeb08
 800f522: 2300         	movs	r3, #0x0
 800f524: 633b         	str	r3, [r7, #0x30]
; 		LOG_ERR("Current thread: %p (%s)", thread, thread_name_get(thread));
 800f526: 2303         	movs	r3, #0x3
 800f528: 2b00         	cmp	r3, #0x0
 800f52a: d020         	beq	0x800f56e <z_fatal_error+0x122> @ imm = #0x40
 800f52c: 2301         	movs	r3, #0x1
 800f52e: f887 302f    	strb.w	r3, [r7, #0x2f]
 800f532: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800f536: f083 0301    	eor	r3, r3, #0x1
 800f53a: b2db         	uxtb	r3, r3
 800f53c: 2b00         	cmp	r3, #0x0
 800f53e: d116         	bne	0x800f56e <z_fatal_error+0x122> @ imm = #0x2c
 800f540: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800f5bc <z_fatal_error+0x170>
 800f542: 681c         	ldr	r4, [r3]
 800f544: 6c38         	ldr	r0, [r7, #0x40]
 800f546: f7ff ff31    	bl	0x800f3ac <thread_name_get> @ imm = #-0x19e
 800f54a: 4603         	mov	r3, r0
 800f54c: 9304         	str	r3, [sp, #0x10]
 800f54e: 6c3b         	ldr	r3, [r7, #0x40]
 800f550: 9303         	str	r3, [sp, #0xc]
 800f552: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800f5c8 <z_fatal_error+0x17c>
 800f554: 9302         	str	r3, [sp, #0x8]
 800f556: 2300         	movs	r3, #0x0
 800f558: 9301         	str	r3, [sp, #0x4]
 800f55a: 2300         	movs	r3, #0x0
 800f55c: 9300         	str	r3, [sp]
 800f55e: 2300         	movs	r3, #0x0
 800f560: 2201         	movs	r2, #0x1
 800f562: 4621         	mov	r1, r4
 800f564: 2000         	movs	r0, #0x0
 800f566: f00e fd60    	bl	0x801e02a <z_log_msg_runtime_create> @ imm = #0xeac0
 800f56a: 2300         	movs	r3, #0x0
 800f56c: 62bb         	str	r3, [r7, #0x28]
; 	coredump(reason, esf, thread);
 800f56e: 6c3a         	ldr	r2, [r7, #0x40]
 800f570: 6839         	ldr	r1, [r7]
 800f572: 6878         	ldr	r0, [r7, #0x4]
 800f574: f00e fd7d    	bl	0x801e072 <coredump>    @ imm = #0xeafa
; 	k_sys_fatal_error_handler(reason, esf);
 800f578: 6839         	ldr	r1, [r7]
 800f57a: 6878         	ldr	r0, [r7, #0x4]
 800f57c: f7ff feee    	bl	0x800f35c <k_sys_fatal_error_handler> @ imm = #-0x224
; 		if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 800f580: 683b         	ldr	r3, [r7]
 800f582: 2b00         	cmp	r3, #0x0
 800f584: d006         	beq	0x800f594 <z_fatal_error+0x148> @ imm = #0xc
 800f586: 683b         	ldr	r3, [r7]
 800f588: 613b         	str	r3, [r7, #0x10]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 800f58a: 693b         	ldr	r3, [r7, #0x10]
 800f58c: 69db         	ldr	r3, [r3, #0x1c]
 800f58e: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 800f592: 2b00         	cmp	r3, #0x0
 800f594: 6bbb         	ldr	r3, [r7, #0x38]
 800f596: 60fb         	str	r3, [r7, #0xc]
 800f598: 68fb         	ldr	r3, [r7, #0xc]
 800f59a: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800f59c: 68bb         	ldr	r3, [r7, #0x8]
 800f59e: f383 8811    	msr	basepri, r3
; }
 800f5a2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800f5a4: f3bf 8f6f    	isb	sy
; }
 800f5a8: bf00         	nop
; }
 800f5aa: bf00         	nop
; 		k_thread_abort(thread);
 800f5ac: 6c38         	ldr	r0, [r7, #0x40]
 800f5ae: f00e fd31    	bl	0x801e014 <k_thread_abort> @ imm = #0xea62
; }
 800f5b2: 374c         	adds	r7, #0x4c
 800f5b4: 46bd         	mov	sp, r7
 800f5b6: bd90         	pop	{r4, r7, pc}

0800f5b8 <$d>:
 800f5b8: 48 1d 00 20  	.word	0x20001d48
 800f5bc: f0 05 00 20  	.word	0x200005f0
 800f5c0: c0 1f 02 08  	.word	0x08021fc0
 800f5c4: e8 1f 02 08  	.word	0x08021fe8
 800f5c8: 0c 20 02 08  	.word	0x0802200c

0800f5cc <__NVIC_SetPriority>:
; {
 800f5cc: b480         	push	{r7}
 800f5ce: b083         	sub	sp, #0xc
 800f5d0: af00         	add	r7, sp, #0x0
 800f5d2: 4603         	mov	r3, r0
 800f5d4: 6039         	str	r1, [r7]
 800f5d6: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 800f5d8: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800f5dc: 2b00         	cmp	r3, #0x0
 800f5de: db0a         	blt	0x800f5f6 <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f5e0: 683b         	ldr	r3, [r7]
 800f5e2: b2da         	uxtb	r2, r3
 800f5e4: 490c         	ldr	r1, [pc, #0x30]         @ 0x800f618 <__NVIC_SetPriority+0x4c>
 800f5e6: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800f5ea: 0112         	lsls	r2, r2, #0x4
 800f5ec: b2d2         	uxtb	r2, r2
 800f5ee: 440b         	add	r3, r1
 800f5f0: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 800f5f4: e00a         	b	0x800f60c <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f5f6: 683b         	ldr	r3, [r7]
 800f5f8: b2da         	uxtb	r2, r3
 800f5fa: 4908         	ldr	r1, [pc, #0x20]         @ 0x800f61c <__NVIC_SetPriority+0x50>
 800f5fc: 79fb         	ldrb	r3, [r7, #0x7]
 800f5fe: f003 030f    	and	r3, r3, #0xf
 800f602: 3b04         	subs	r3, #0x4
 800f604: 0112         	lsls	r2, r2, #0x4
 800f606: b2d2         	uxtb	r2, r2
 800f608: 440b         	add	r3, r1
 800f60a: 761a         	strb	r2, [r3, #0x18]
; }
 800f60c: bf00         	nop
 800f60e: 370c         	adds	r7, #0xc
 800f610: 46bd         	mov	sp, r7
 800f612: f85d 7b04    	ldr	r7, [sp], #4
 800f616: 4770         	bx	lr

0800f618 <$d>:
 800f618: 00 e1 00 e0  	.word	0xe000e100
 800f61c: 00 ed 00 e0  	.word	0xe000ed00

0800f620 <z_add_thread_timeout>:
; {
 800f620: b580         	push	{r7, lr}
 800f622: b084         	sub	sp, #0x10
 800f624: af00         	add	r7, sp, #0x0
 800f626: 60f8         	str	r0, [r7, #0xc]
 800f628: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 800f62c: 68fb         	ldr	r3, [r7, #0xc]
 800f62e: f103 0018    	add.w	r0, r3, #0x18
 800f632: e9d7 2300    	ldrd	r2, r3, [r7]
 800f636: 4903         	ldr	r1, [pc, #0xc]          @ 0x800f644 <z_add_thread_timeout+0x24>
 800f638: f003 f9ee    	bl	0x8012a18 <z_add_timeout> @ imm = #0x33dc
; }
 800f63c: bf00         	nop
 800f63e: 3710         	adds	r7, #0x10
 800f640: 46bd         	mov	sp, r7
 800f642: bd80         	pop	{r7, pc}

0800f644 <$d>:
 800f644: 37 f7 01 08  	.word	0x0801f737

0800f648 <z_dummy_thread_init>:
; {
 800f648: b480         	push	{r7}
 800f64a: b085         	sub	sp, #0x14
 800f64c: af00         	add	r7, sp, #0x0
 800f64e: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 800f650: 687b         	ldr	r3, [r7, #0x4]
 800f652: 2201         	movs	r2, #0x1
 800f654: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 800f656: 687b         	ldr	r3, [r7, #0x4]
 800f658: 2201         	movs	r2, #0x1
 800f65a: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 800f65c: 687b         	ldr	r3, [r7, #0x4]
 800f65e: 2200         	movs	r2, #0x0
 800f660: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 800f664: 687b         	ldr	r3, [r7, #0x4]
 800f666: 2200         	movs	r2, #0x0
 800f668: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	dummy_thread->resource_pool = NULL;
 800f66c: 687b         	ldr	r3, [r7, #0x4]
 800f66e: 2200         	movs	r2, #0x0
 800f670: f8c3 20c0    	str.w	r2, [r3, #0xc0]
 800f674: 687b         	ldr	r3, [r7, #0x4]
 800f676: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 800f678: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800f68c <z_dummy_thread_init+0x44>
 800f67a: 68fb         	ldr	r3, [r7, #0xc]
 800f67c: 6093         	str	r3, [r2, #0x8]
; }
 800f67e: bf00         	nop
; }
 800f680: bf00         	nop
 800f682: 3714         	adds	r7, #0x14
 800f684: 46bd         	mov	sp, r7
 800f686: f85d 7b04    	ldr	r7, [sp], #4
 800f68a: 4770         	bx	lr

0800f68c <$d>:
 800f68c: 48 1d 00 20  	.word	0x20001d48

0800f690 <z_init_static_threads>:
; {
 800f690: b5f0         	push	{r4, r5, r6, r7, lr}
 800f692: b08f         	sub	sp, #0x3c
 800f694: af06         	add	r7, sp, #0x18
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800f696: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x800f75c <z_init_static_threads+0xcc>
 800f698: 61fb         	str	r3, [r7, #0x1c]
 800f69a: e029         	b	0x800f6f0 <z_init_static_threads+0x60> @ imm = #0x52
; 		z_setup_new_thread(
 800f69c: 69fb         	ldr	r3, [r7, #0x1c]
 800f69e: 681e         	ldr	r6, [r3]
 800f6a0: 69fb         	ldr	r3, [r7, #0x1c]
 800f6a2: 685b         	ldr	r3, [r3, #0x4]
 800f6a4: 60fb         	str	r3, [r7, #0xc]
 800f6a6: 69fb         	ldr	r3, [r7, #0x1c]
 800f6a8: 689a         	ldr	r2, [r3, #0x8]
 800f6aa: 60ba         	str	r2, [r7, #0x8]
 800f6ac: 69fb         	ldr	r3, [r7, #0x1c]
 800f6ae: 68d8         	ldr	r0, [r3, #0xc]
 800f6b0: 6078         	str	r0, [r7, #0x4]
 800f6b2: 69fb         	ldr	r3, [r7, #0x1c]
 800f6b4: 691b         	ldr	r3, [r3, #0x10]
 800f6b6: 69fa         	ldr	r2, [r7, #0x1c]
 800f6b8: 6952         	ldr	r2, [r2, #0x14]
 800f6ba: 69f9         	ldr	r1, [r7, #0x1c]
 800f6bc: 6989         	ldr	r1, [r1, #0x18]
 800f6be: 69f8         	ldr	r0, [r7, #0x1c]
 800f6c0: 69c0         	ldr	r0, [r0, #0x1c]
 800f6c2: 69fc         	ldr	r4, [r7, #0x1c]
 800f6c4: 6a24         	ldr	r4, [r4, #0x20]
 800f6c6: 69fd         	ldr	r5, [r7, #0x1c]
 800f6c8: 6a6d         	ldr	r5, [r5, #0x24]
 800f6ca: 9505         	str	r5, [sp, #0x14]
 800f6cc: 9404         	str	r4, [sp, #0x10]
 800f6ce: 9003         	str	r0, [sp, #0xc]
 800f6d0: 9102         	str	r1, [sp, #0x8]
 800f6d2: 9201         	str	r2, [sp, #0x4]
 800f6d4: 9300         	str	r3, [sp]
 800f6d6: 687b         	ldr	r3, [r7, #0x4]
 800f6d8: 68ba         	ldr	r2, [r7, #0x8]
 800f6da: 68f9         	ldr	r1, [r7, #0xc]
 800f6dc: 4630         	mov	r0, r6
 800f6de: f001 fa5d    	bl	0x8010b9c <z_setup_new_thread> @ imm = #0x14ba
; 		thread_data->init_thread->init_data = thread_data;
 800f6e2: 69fb         	ldr	r3, [r7, #0x1c]
 800f6e4: 681b         	ldr	r3, [r3]
 800f6e6: 69fa         	ldr	r2, [r7, #0x1c]
 800f6e8: 665a         	str	r2, [r3, #0x64]
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800f6ea: 69fb         	ldr	r3, [r7, #0x1c]
 800f6ec: 3330         	adds	r3, #0x30
 800f6ee: 61fb         	str	r3, [r7, #0x1c]
 800f6f0: 69fb         	ldr	r3, [r7, #0x1c]
 800f6f2: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800f760 <z_init_static_threads+0xd0>
 800f6f4: 4293         	cmp	r3, r2
 800f6f6: bf34         	ite	lo
 800f6f8: 2301         	movlo	r3, #0x1
 800f6fa: 2300         	movhs	r3, #0x0
 800f6fc: b2db         	uxtb	r3, r3
 800f6fe: 2b00         	cmp	r3, #0x0
 800f700: d1cc         	bne	0x800f69c <z_init_static_threads+0xc> @ imm = #-0x68
; 	k_sched_lock();
 800f702: f002 fa6f    	bl	0x8011be4 <k_sched_lock> @ imm = #0x24de
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800f706: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800f75c <z_init_static_threads+0xcc>
 800f708: 61bb         	str	r3, [r7, #0x18]
 800f70a: e018         	b	0x800f73e <z_init_static_threads+0xae> @ imm = #0x30
; 		k_timeout_t init_delay = Z_THREAD_INIT_DELAY(thread_data);
 800f70c: 69bb         	ldr	r3, [r7, #0x18]
 800f70e: e9d3 230a    	ldrd	r2, r3, [r3, #40]
 800f712: e9c7 2304    	strd	r2, r3, [r7, #16]
; 		if (!K_TIMEOUT_EQ(init_delay, K_FOREVER)) {
 800f716: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800f71a: f04f 30ff    	mov.w	r0, #0xffffffff
 800f71e: f04f 31ff    	mov.w	r1, #0xffffffff
 800f722: 428b         	cmp	r3, r1
 800f724: bf08         	it	eq
 800f726: 4282         	cmpeq	r2, r0
 800f728: d006         	beq	0x800f738 <z_init_static_threads+0xa8> @ imm = #0xc
; 			thread_schedule_new(thread_data->init_thread,
 800f72a: 69bb         	ldr	r3, [r7, #0x18]
 800f72c: 6819         	ldr	r1, [r3]
 800f72e: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800f732: 4608         	mov	r0, r1
 800f734: f00e fcde    	bl	0x801e0f4 <thread_schedule_new> @ imm = #0xe9bc
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800f738: 69bb         	ldr	r3, [r7, #0x18]
 800f73a: 3330         	adds	r3, #0x30
 800f73c: 61bb         	str	r3, [r7, #0x18]
 800f73e: 69bb         	ldr	r3, [r7, #0x18]
 800f740: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800f760 <z_init_static_threads+0xd0>
 800f742: 4293         	cmp	r3, r2
 800f744: bf34         	ite	lo
 800f746: 2301         	movlo	r3, #0x1
 800f748: 2300         	movhs	r3, #0x0
 800f74a: b2db         	uxtb	r3, r3
 800f74c: 2b00         	cmp	r3, #0x0
 800f74e: d1dd         	bne	0x800f70c <z_init_static_threads+0x7c> @ imm = #-0x46
; 	k_sched_unlock();
 800f750: f002 fa88    	bl	0x8011c64 <k_sched_unlock> @ imm = #0x2510
; }
 800f754: bf00         	nop
 800f756: 3724         	adds	r7, #0x24
 800f758: 46bd         	mov	sp, r7
 800f75a: bdf0         	pop	{r4, r5, r6, r7, pc}

0800f75c <$d>:
 800f75c: c8 05 02 08  	.word	0x080205c8
 800f760: c8 05 02 08  	.word	0x080205c8

0800f764 <z_bss_zero>:
; {
 800f764: b580         	push	{r7, lr}
 800f766: af00         	add	r7, sp, #0x0
; 	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
 800f768: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800f77c <z_bss_zero+0x18>
 800f76a: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800f780 <z_bss_zero+0x1c>
 800f76c: 1ad3         	subs	r3, r2, r3
 800f76e: 461a         	mov	r2, r3
 800f770: 2100         	movs	r1, #0x0
 800f772: 4803         	ldr	r0, [pc, #0xc]          @ 0x800f780 <z_bss_zero+0x1c>
 800f774: f00e fd0f    	bl	0x801e196 <z_early_memset> @ imm = #0xea1e
; }
 800f778: bd80         	pop	{r7, pc}
 800f77a: bf00         	nop

0800f77c <$d>:
 800f77c: fc 27 00 20  	.word	0x200027fc
 800f780: 88 06 00 20  	.word	0x20000688

0800f784 <z_sys_init_run_level>:
; {
 800f784: b580         	push	{r7, lr}
 800f786: b086         	sub	sp, #0x18
 800f788: af00         	add	r7, sp, #0x0
 800f78a: 4603         	mov	r3, r0
 800f78c: 71fb         	strb	r3, [r7, #0x7]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 800f78e: 79fb         	ldrb	r3, [r7, #0x7]
 800f790: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800f7d8 <z_sys_init_run_level+0x54>
 800f792: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800f796: 617b         	str	r3, [r7, #0x14]
 800f798: e011         	b	0x800f7be <z_sys_init_run_level+0x3a> @ imm = #0x22
; 		const struct device *dev = entry->dev;
 800f79a: 697b         	ldr	r3, [r7, #0x14]
 800f79c: 685b         	ldr	r3, [r3, #0x4]
 800f79e: 613b         	str	r3, [r7, #0x10]
; 		if (dev != NULL) {
 800f7a0: 693b         	ldr	r3, [r7, #0x10]
 800f7a2: 2b00         	cmp	r3, #0x0
 800f7a4: d004         	beq	0x800f7b0 <z_sys_init_run_level+0x2c> @ imm = #0x8
; 			result = do_device_init(entry);
 800f7a6: 6978         	ldr	r0, [r7, #0x14]
 800f7a8: f00e fd13    	bl	0x801e1d2 <do_device_init> @ imm = #0xea26
 800f7ac: 60f8         	str	r0, [r7, #0xc]
 800f7ae: e003         	b	0x800f7b8 <z_sys_init_run_level+0x34> @ imm = #0x6
; 			result = entry->init_fn.sys();
 800f7b0: 697b         	ldr	r3, [r7, #0x14]
 800f7b2: 681b         	ldr	r3, [r3]
 800f7b4: 4798         	blx	r3
 800f7b6: 60f8         	str	r0, [r7, #0xc]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 800f7b8: 697b         	ldr	r3, [r7, #0x14]
 800f7ba: 3308         	adds	r3, #0x8
 800f7bc: 617b         	str	r3, [r7, #0x14]
 800f7be: 79fb         	ldrb	r3, [r7, #0x7]
 800f7c0: 3301         	adds	r3, #0x1
 800f7c2: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800f7d8 <z_sys_init_run_level+0x54>
 800f7c4: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800f7c8: 697a         	ldr	r2, [r7, #0x14]
 800f7ca: 429a         	cmp	r2, r3
 800f7cc: d3e5         	blo	0x800f79a <z_sys_init_run_level+0x16> @ imm = #-0x36
; }
 800f7ce: bf00         	nop
 800f7d0: bf00         	nop
 800f7d2: 3718         	adds	r7, #0x18
 800f7d4: 46bd         	mov	sp, r7
 800f7d6: bd80         	pop	{r7, pc}

0800f7d8 <$d>:
 800f7d8: f4 05 00 20  	.word	0x200005f4

0800f7dc <bg_thread_main>:
; {
 800f7dc: b580         	push	{r7, lr}
 800f7de: b084         	sub	sp, #0x10
 800f7e0: af00         	add	r7, sp, #0x0
 800f7e2: 60f8         	str	r0, [r7, #0xc]
 800f7e4: 60b9         	str	r1, [r7, #0x8]
 800f7e6: 607a         	str	r2, [r7, #0x4]
; 	z_sys_post_kernel = true;
 800f7e8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800f818 <bg_thread_main+0x3c>
 800f7ea: 2201         	movs	r2, #0x1
 800f7ec: 701a         	strb	r2, [r3]
; 	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 800f7ee: 2003         	movs	r0, #0x3
 800f7f0: f7ff ffc8    	bl	0x800f784 <z_sys_init_run_level> @ imm = #-0x70
; 	boot_banner();
 800f7f4: f003 fc04    	bl	0x8013000 <boot_banner> @ imm = #0x3808
; 	z_init_static();
 800f7f8: f00e fd21    	bl	0x801e23e <z_init_static> @ imm = #0xea42
; 	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
 800f7fc: 2004         	movs	r0, #0x4
 800f7fe: f7ff ffc1    	bl	0x800f784 <z_sys_init_run_level> @ imm = #-0x7e
; 	z_init_static_threads();
 800f802: f7ff ff45    	bl	0x800f690 <z_init_static_threads> @ imm = #-0x176
; 	(void)main();
 800f806: f7f4 ff99    	bl	0x800473c <main>        @ imm = #-0xb0ce
; 	z_thread_essential_clear(&z_main_thread);
 800f80a: 4804         	ldr	r0, [pc, #0x10]         @ 0x800f81c <bg_thread_main+0x40>
 800f80c: f00e fca0    	bl	0x801e150 <z_thread_essential_clear> @ imm = #0xe940
; } /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 800f810: bf00         	nop
 800f812: 3710         	adds	r7, #0x10
 800f814: 46bd         	mov	sp, r7
 800f816: bd80         	pop	{r7, pc}

0800f818 <$d>:
 800f818: fa 27 00 20  	.word	0x200027fa
 800f81c: 90 1d 00 20  	.word	0x20001d90

0800f820 <init_idle_thread>:
; {
 800f820: b580         	push	{r7, lr}
 800f822: b08c         	sub	sp, #0x30
 800f824: af06         	add	r7, sp, #0x18
 800f826: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = &z_idle_threads[i];
 800f828: 687b         	ldr	r3, [r7, #0x4]
 800f82a: f44f 728c    	mov.w	r2, #0x118
 800f82e: fb02 f303    	mul	r3, r2, r3
 800f832: 4a16         	ldr	r2, [pc, #0x58]         @ 0x800f88c <init_idle_thread+0x6c>
 800f834: 4413         	add	r3, r2
 800f836: 617b         	str	r3, [r7, #0x14]
; 	k_thread_stack_t *stack = z_idle_stacks[i];
 800f838: 687a         	ldr	r2, [r7, #0x4]
 800f83a: 4613         	mov	r3, r2
 800f83c: 009b         	lsls	r3, r3, #0x2
 800f83e: 4413         	add	r3, r2
 800f840: 019b         	lsls	r3, r3, #0x6
 800f842: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800f890 <init_idle_thread+0x70>
 800f844: 4413         	add	r3, r2
 800f846: 613b         	str	r3, [r7, #0x10]
; 	size_t stack_size = K_KERNEL_STACK_SIZEOF(z_idle_stacks[i]);
 800f848: f44f 73a0    	mov.w	r3, #0x140
 800f84c: 60fb         	str	r3, [r7, #0xc]
; 	char *tname = "idle";
 800f84e: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800f894 <init_idle_thread+0x74>
 800f850: 60bb         	str	r3, [r7, #0x8]
; 			  stack_size, idle, &_kernel.cpus[i],
 800f852: 687b         	ldr	r3, [r7, #0x4]
 800f854: 015b         	lsls	r3, r3, #0x5
 800f856: 4a10         	ldr	r2, [pc, #0x40]         @ 0x800f898 <init_idle_thread+0x78>
 800f858: 4413         	add	r3, r2
; 	z_setup_new_thread(thread, stack,
 800f85a: 68ba         	ldr	r2, [r7, #0x8]
 800f85c: 9205         	str	r2, [sp, #0x14]
 800f85e: 2201         	movs	r2, #0x1
 800f860: 9204         	str	r2, [sp, #0x10]
 800f862: 220f         	movs	r2, #0xf
 800f864: 9203         	str	r2, [sp, #0xc]
 800f866: 2200         	movs	r2, #0x0
 800f868: 9202         	str	r2, [sp, #0x8]
 800f86a: 2200         	movs	r2, #0x0
 800f86c: 9201         	str	r2, [sp, #0x4]
 800f86e: 9300         	str	r3, [sp]
 800f870: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800f89c <init_idle_thread+0x7c>
 800f872: 68fa         	ldr	r2, [r7, #0xc]
 800f874: 6939         	ldr	r1, [r7, #0x10]
 800f876: 6978         	ldr	r0, [r7, #0x14]
 800f878: f001 f990    	bl	0x8010b9c <z_setup_new_thread> @ imm = #0x1320
; 	z_mark_thread_as_not_suspended(thread);
 800f87c: 6978         	ldr	r0, [r7, #0x14]
 800f87e: f00e fc56    	bl	0x801e12e <z_mark_thread_as_not_suspended> @ imm = #0xe8ac
; }
 800f882: bf00         	nop
 800f884: 3718         	adds	r7, #0x18
 800f886: 46bd         	mov	sp, r7
 800f888: bd80         	pop	{r7, pc}
 800f88a: bf00         	nop

0800f88c <$d>:
 800f88c: a8 1e 00 20  	.word	0x20001ea8
 800f890: 00 41 00 20  	.word	0x20004100
 800f894: 28 20 02 08  	.word	0x08022028
 800f898: 48 1d 00 20  	.word	0x20001d48
 800f89c: 59 e2 01 08  	.word	0x0801e259

0800f8a0 <z_init_cpu>:
; {
 800f8a0: b580         	push	{r7, lr}
 800f8a2: b082         	sub	sp, #0x8
 800f8a4: af00         	add	r7, sp, #0x0
 800f8a6: 6078         	str	r0, [r7, #0x4]
; 	init_idle_thread(id);
 800f8a8: 6878         	ldr	r0, [r7, #0x4]
 800f8aa: f7ff ffb9    	bl	0x800f820 <init_idle_thread> @ imm = #-0x8e
; 	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 800f8ae: 687b         	ldr	r3, [r7, #0x4]
 800f8b0: f44f 728c    	mov.w	r2, #0x118
 800f8b4: fb02 f303    	mul	r3, r2, r3
 800f8b8: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800f928 <z_init_cpu+0x88>
 800f8ba: 441a         	add	r2, r3
 800f8bc: 491b         	ldr	r1, [pc, #0x6c]         @ 0x800f92c <z_init_cpu+0x8c>
 800f8be: 687b         	ldr	r3, [r7, #0x4]
 800f8c0: 015b         	lsls	r3, r3, #0x5
 800f8c2: 440b         	add	r3, r1
 800f8c4: 330c         	adds	r3, #0xc
 800f8c6: 601a         	str	r2, [r3]
; 	_kernel.cpus[id].id = id;
 800f8c8: 687b         	ldr	r3, [r7, #0x4]
 800f8ca: b2d9         	uxtb	r1, r3
 800f8cc: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800f92c <z_init_cpu+0x8c>
 800f8ce: 687b         	ldr	r3, [r7, #0x4]
 800f8d0: 015b         	lsls	r3, r3, #0x5
 800f8d2: 4413         	add	r3, r2
 800f8d4: 3310         	adds	r3, #0x10
 800f8d6: 460a         	mov	r2, r1
 800f8d8: 701a         	strb	r2, [r3]
; 		(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 800f8da: 687b         	ldr	r3, [r7, #0x4]
 800f8dc: 02db         	lsls	r3, r3, #0xb
 800f8de: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800f930 <z_init_cpu+0x90>
 800f8e0: 4413         	add	r3, r2
 800f8e2: 4618         	mov	r0, r3
 800f8e4: f00e fbe5    	bl	0x801e0b2 <K_KERNEL_STACK_BUFFER> @ imm = #0xe7ca
 800f8e8: 4603         	mov	r3, r0
 800f8ea: f503 6200    	add.w	r2, r3, #0x800
; 	_kernel.cpus[id].irq_stack =
 800f8ee: 490f         	ldr	r1, [pc, #0x3c]         @ 0x800f92c <z_init_cpu+0x8c>
 800f8f0: 687b         	ldr	r3, [r7, #0x4]
 800f8f2: 015b         	lsls	r3, r3, #0x5
 800f8f4: 440b         	add	r3, r1
 800f8f6: 3304         	adds	r3, #0x4
 800f8f8: 601a         	str	r2, [r3]
; 	_kernel.cpus[id].usage = &_kernel.usage[id];
 800f8fa: 687b         	ldr	r3, [r7, #0x4]
 800f8fc: 011b         	lsls	r3, r3, #0x4
 800f8fe: 3338         	adds	r3, #0x38
 800f900: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800f92c <z_init_cpu+0x8c>
 800f902: 441a         	add	r2, r3
 800f904: 4909         	ldr	r1, [pc, #0x24]         @ 0x800f92c <z_init_cpu+0x8c>
 800f906: 687b         	ldr	r3, [r7, #0x4]
 800f908: 015b         	lsls	r3, r3, #0x5
 800f90a: 440b         	add	r3, r1
 800f90c: 331c         	adds	r3, #0x1c
 800f90e: 601a         	str	r2, [r3]
; 	_kernel.cpus[id].usage->track_usage =
 800f910: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800f92c <z_init_cpu+0x8c>
 800f912: 687b         	ldr	r3, [r7, #0x4]
 800f914: 015b         	lsls	r3, r3, #0x5
 800f916: 4413         	add	r3, r2
 800f918: 331c         	adds	r3, #0x1c
 800f91a: 681b         	ldr	r3, [r3]
 800f91c: 2201         	movs	r2, #0x1
 800f91e: 721a         	strb	r2, [r3, #0x8]
; }
 800f920: bf00         	nop
 800f922: 3708         	adds	r7, #0x8
 800f924: 46bd         	mov	sp, r7
 800f926: bd80         	pop	{r7, pc}

0800f928 <$d>:
 800f928: a8 1e 00 20  	.word	0x20001ea8
 800f92c: 48 1d 00 20  	.word	0x20001d48
 800f930: 40 42 00 20  	.word	0x20004240

0800f934 <prepare_multithreading>:
; {
 800f934: b580         	push	{r7, lr}
 800f936: b088         	sub	sp, #0x20
 800f938: af06         	add	r7, sp, #0x18
; 	z_sched_init();
 800f93a: f002 fa71    	bl	0x8011e20 <z_sched_init> @ imm = #0x24e2
; 	_kernel.ready_q.cache = &z_main_thread;
 800f93e: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800f988 <prepare_multithreading+0x54>
 800f940: 4a12         	ldr	r2, [pc, #0x48]         @ 0x800f98c <prepare_multithreading+0x58>
 800f942: 621a         	str	r2, [r3, #0x20]
; 	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 800f944: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800f990 <prepare_multithreading+0x5c>
 800f946: 9305         	str	r3, [sp, #0x14]
 800f948: 2301         	movs	r3, #0x1
 800f94a: 9304         	str	r3, [sp, #0x10]
 800f94c: 2300         	movs	r3, #0x0
 800f94e: 9303         	str	r3, [sp, #0xc]
 800f950: 2300         	movs	r3, #0x0
 800f952: 9302         	str	r3, [sp, #0x8]
 800f954: 2300         	movs	r3, #0x0
 800f956: 9301         	str	r3, [sp, #0x4]
 800f958: 2300         	movs	r3, #0x0
 800f95a: 9300         	str	r3, [sp]
 800f95c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800f994 <prepare_multithreading+0x60>
 800f95e: f44f 6200    	mov.w	r2, #0x800
 800f962: 490d         	ldr	r1, [pc, #0x34]         @ 0x800f998 <prepare_multithreading+0x64>
 800f964: 4809         	ldr	r0, [pc, #0x24]         @ 0x800f98c <prepare_multithreading+0x58>
 800f966: f001 f919    	bl	0x8010b9c <z_setup_new_thread> @ imm = #0x1232
 800f96a: 6078         	str	r0, [r7, #0x4]
; 	z_mark_thread_as_not_suspended(&z_main_thread);
 800f96c: 4807         	ldr	r0, [pc, #0x1c]         @ 0x800f98c <prepare_multithreading+0x58>
 800f96e: f00e fbde    	bl	0x801e12e <z_mark_thread_as_not_suspended> @ imm = #0xe7bc
; 	z_ready_thread(&z_main_thread);
 800f972: 4806         	ldr	r0, [pc, #0x18]         @ 0x800f98c <prepare_multithreading+0x58>
 800f974: f001 fbdc    	bl	0x8011130 <z_ready_thread> @ imm = #0x17b8
; 	z_init_cpu(0);
 800f978: 2000         	movs	r0, #0x0
 800f97a: f7ff ff91    	bl	0x800f8a0 <z_init_cpu>  @ imm = #-0xde
; 	return stack_ptr;
 800f97e: 687b         	ldr	r3, [r7, #0x4]
; }
 800f980: 4618         	mov	r0, r3
 800f982: 3708         	adds	r7, #0x8
 800f984: 46bd         	mov	sp, r7
 800f986: bd80         	pop	{r7, pc}

0800f988 <$d>:
 800f988: 48 1d 00 20  	.word	0x20001d48
 800f98c: 90 1d 00 20  	.word	0x20001d90
 800f990: 30 20 02 08  	.word	0x08022030
 800f994: dd f7 00 08  	.word	0x0800f7dd
 800f998: 00 39 00 20  	.word	0x20003900

0800f99c <switch_to_main_thread>:
; {
 800f99c: b580         	push	{r7, lr}
 800f99e: b082         	sub	sp, #0x8
 800f9a0: af00         	add	r7, sp, #0x0
 800f9a2: 6078         	str	r0, [r7, #0x4]
; 	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 800f9a4: 4a02         	ldr	r2, [pc, #0x8]          @ 0x800f9b0 <switch_to_main_thread+0x14>
 800f9a6: 6879         	ldr	r1, [r7, #0x4]
 800f9a8: 4802         	ldr	r0, [pc, #0x8]          @ 0x800f9b4 <switch_to_main_thread+0x18>
 800f9aa: f7f7 fbf9    	bl	0x80071a0 <arch_switch_to_main_thread> @ imm = #-0x880e
 800f9ae: bf00         	nop

0800f9b0 <$d>:
 800f9b0: dd f7 00 08  	.word	0x0800f7dd
 800f9b4: 90 1d 00 20  	.word	0x20001d90

0800f9b8 <z_cstart>:
; {
 800f9b8: b580         	push	{r7, lr}
 800f9ba: b082         	sub	sp, #0x8
 800f9bc: af00         	add	r7, sp, #0x0
; 	gcov_static_init();
 800f9be: f00e fbd8    	bl	0x801e172 <gcov_static_init> @ imm = #0xe7b0
; 	z_sys_init_run_level(INIT_LEVEL_EARLY);
 800f9c2: 2000         	movs	r0, #0x0
 800f9c4: f7ff fede    	bl	0x800f784 <z_sys_init_run_level> @ imm = #-0x244
; 		(uint32_t)(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
 800f9c8: 482d         	ldr	r0, [pc, #0xb4]         @ 0x800fa80 <z_cstart+0xc8>
 800f9ca: f00e fb72    	bl	0x801e0b2 <K_KERNEL_STACK_BUFFER> @ imm = #0xe6e4
 800f9ce: 4603         	mov	r3, r0
; 	uint32_t msp =
 800f9d0: f503 6300    	add.w	r3, r3, #0x800
 800f9d4: 607b         	str	r3, [r7, #0x4]
 800f9d6: 687b         	ldr	r3, [r7, #0x4]
 800f9d8: 603b         	str	r3, [r7]
;   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 800f9da: 683b         	ldr	r3, [r7]
 800f9dc: f383 8808    	msr	msp, r3
; }
 800f9e0: bf00         	nop
; 	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
 800f9e2: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800fa84 <z_cstart+0xcc>
 800f9e4: 695b         	ldr	r3, [r3, #0x14]
 800f9e6: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x800fa84 <z_cstart+0xcc>
 800f9e8: f443 7300    	orr	r3, r3, #0x200
 800f9ec: 6153         	str	r3, [r2, #0x14]
; }
 800f9ee: bf00         	nop
; 	NVIC_SetPriority(PendSV_IRQn, _EXC_PENDSV_PRIO);
 800f9f0: 21ff         	movs	r1, #0xff
 800f9f2: f06f 0001    	mvn	r0, #0x1
 800f9f6: f7ff fde9    	bl	0x800f5cc <__NVIC_SetPriority> @ imm = #-0x42e
; 	NVIC_SetPriority(SVCall_IRQn, _EXC_SVC_PRIO);
 800f9fa: 2100         	movs	r1, #0x0
 800f9fc: f06f 0004    	mvn	r0, #0x4
 800fa00: f7ff fde4    	bl	0x800f5cc <__NVIC_SetPriority> @ imm = #-0x438
; 	NVIC_SetPriority(MemoryManagement_IRQn, _EXC_FAULT_PRIO);
 800fa04: 2100         	movs	r1, #0x0
 800fa06: f06f 000b    	mvn	r0, #0xb
 800fa0a: f7ff fddf    	bl	0x800f5cc <__NVIC_SetPriority> @ imm = #-0x442
; 	NVIC_SetPriority(BusFault_IRQn, _EXC_FAULT_PRIO);
 800fa0e: 2100         	movs	r1, #0x0
 800fa10: f06f 000a    	mvn	r0, #0xa
 800fa14: f7ff fdda    	bl	0x800f5cc <__NVIC_SetPriority> @ imm = #-0x44c
; 	NVIC_SetPriority(UsageFault_IRQn, _EXC_FAULT_PRIO);
 800fa18: 2100         	movs	r1, #0x0
 800fa1a: f06f 0009    	mvn	r0, #0x9
 800fa1e: f7ff fdd5    	bl	0x800f5cc <__NVIC_SetPriority> @ imm = #-0x456
; 	NVIC_SetPriority(DebugMonitor_IRQn, _EXC_FAULT_PRIO);
 800fa22: 2100         	movs	r1, #0x0
 800fa24: f06f 0003    	mvn	r0, #0x3
 800fa28: f7ff fdd0    	bl	0x800f5cc <__NVIC_SetPriority> @ imm = #-0x460
; 	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 800fa2c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800fa84 <z_cstart+0xcc>
 800fa2e: 6a5b         	ldr	r3, [r3, #0x24]
 800fa30: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800fa84 <z_cstart+0xcc>
 800fa32: f443 23e0    	orr	r3, r3, #0x70000
 800fa36: 6253         	str	r3, [r2, #0x24]
; }
 800fa38: bf00         	nop
; 	z_arm_fault_init();
 800fa3a: f7f7 f985    	bl	0x8006d48 <z_arm_fault_init> @ imm = #-0x8cf6
; 	z_arm_cpu_idle_init();
 800fa3e: f7f7 fbdf    	bl	0x8007200 <z_arm_cpu_idle_init> @ imm = #-0x8842
; 	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 800fa42: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800fa84 <z_cstart+0xcc>
 800fa44: f04f 32ff    	mov.w	r2, #0xffffffff
 800fa48: 629a         	str	r2, [r3, #0x28]
; 	SCB->HFSR = 0xffffffff;
 800fa4a: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800fa84 <z_cstart+0xcc>
 800fa4c: f04f 32ff    	mov.w	r2, #0xffffffff
 800fa50: 62da         	str	r2, [r3, #0x2c]
; }
 800fa52: bf00         	nop
; }
 800fa54: bf00         	nop
; 	LOG_CORE_INIT();
 800fa56: f7f5 fb7b    	bl	0x8005150 <log_core_init> @ imm = #-0xa90a
; 	z_dummy_thread_init(&_thread_dummy);
 800fa5a: 480b         	ldr	r0, [pc, #0x2c]         @ 0x800fa88 <z_cstart+0xd0>
 800fa5c: f7ff fdf4    	bl	0x800f648 <z_dummy_thread_init> @ imm = #-0x418
; 	z_device_state_init();
 800fa60: f7ff fc5e    	bl	0x800f320 <z_device_state_init> @ imm = #-0x744
; 	soc_early_init_hook();
 800fa64: f7f5 fb40    	bl	0x80050e8 <soc_early_init_hook> @ imm = #-0xa980
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
 800fa68: 2001         	movs	r0, #0x1
 800fa6a: f7ff fe8b    	bl	0x800f784 <z_sys_init_run_level> @ imm = #-0x2ea
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 800fa6e: 2002         	movs	r0, #0x2
 800fa70: f7ff fe88    	bl	0x800f784 <z_sys_init_run_level> @ imm = #-0x2f0
; 	switch_to_main_thread(prepare_multithreading());
 800fa74: f7ff ff5e    	bl	0x800f934 <prepare_multithreading> @ imm = #-0x144
 800fa78: 4603         	mov	r3, r0
 800fa7a: 4618         	mov	r0, r3
 800fa7c: f7ff ff8e    	bl	0x800f99c <switch_to_main_thread> @ imm = #-0xe4

0800fa80 <$d>:
 800fa80: 40 42 00 20  	.word	0x20004240
 800fa84: 00 ed 00 e0  	.word	0xe000ed00
 800fa88: c0 1f 00 20  	.word	0x20001fc0

0800fa8c <adjust_owner_prio>:
; {
 800fa8c: b5b0         	push	{r4, r5, r7, lr}
 800fa8e: b08c         	sub	sp, #0x30
 800fa90: af08         	add	r7, sp, #0x20
 800fa92: 6078         	str	r0, [r7, #0x4]
 800fa94: 6039         	str	r1, [r7]
; 	if (mutex->owner->base.prio != new_prio) {
 800fa96: 687b         	ldr	r3, [r7, #0x4]
 800fa98: 689b         	ldr	r3, [r3, #0x8]
 800fa9a: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800fa9e: 461a         	mov	r2, r3
 800faa0: 683b         	ldr	r3, [r7]
 800faa2: 4293         	cmp	r3, r2
 800faa4: d03a         	beq	0x800fb1c <adjust_owner_prio+0x90> @ imm = #0x74
; 		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
 800faa6: 2303         	movs	r3, #0x3
 800faa8: 2b03         	cmp	r3, #0x3
 800faaa: d92f         	bls	0x800fb0c <adjust_owner_prio+0x80> @ imm = #0x5e
 800faac: 2301         	movs	r3, #0x1
 800faae: 72fb         	strb	r3, [r7, #0xb]
 800fab0: 7afb         	ldrb	r3, [r7, #0xb]
 800fab2: f083 0301    	eor	r3, r3, #0x1
 800fab6: b2db         	uxtb	r3, r3
 800fab8: 2b00         	cmp	r3, #0x0
 800faba: d127         	bne	0x800fb0c <adjust_owner_prio+0x80> @ imm = #0x4e
 800fabc: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800fb28 <adjust_owner_prio+0x9c>
 800fabe: 681d         	ldr	r5, [r3]
 800fac0: 687b         	ldr	r3, [r7, #0x4]
 800fac2: 689c         	ldr	r4, [r3, #0x8]
 800fac4: 687b         	ldr	r3, [r7, #0x4]
 800fac6: 689b         	ldr	r3, [r3, #0x8]
 800fac8: 4618         	mov	r0, r3
 800faca: f00e fc96    	bl	0x801e3fa <z_is_thread_ready> @ imm = #0xe92c
 800face: 4603         	mov	r3, r0
 800fad0: 2b00         	cmp	r3, #0x0
 800fad2: d001         	beq	0x800fad8 <adjust_owner_prio+0x4c> @ imm = #0x2
 800fad4: 2379         	movs	r3, #0x79
 800fad6: e000         	b	0x800fada <adjust_owner_prio+0x4e> @ imm = #0x0
 800fad8: 236e         	movs	r3, #0x6e
 800fada: 687a         	ldr	r2, [r7, #0x4]
 800fadc: 6892         	ldr	r2, [r2, #0x8]
 800fade: f992 200e    	ldrsb.w	r2, [r2, #0xe]
 800fae2: 9207         	str	r2, [sp, #0x1c]
 800fae4: 683a         	ldr	r2, [r7]
 800fae6: 9206         	str	r2, [sp, #0x18]
 800fae8: 9305         	str	r3, [sp, #0x14]
 800faea: 9404         	str	r4, [sp, #0x10]
 800faec: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800fb2c <adjust_owner_prio+0xa0>
 800faee: 9303         	str	r3, [sp, #0xc]
 800faf0: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800fb30 <adjust_owner_prio+0xa4>
 800faf2: 9302         	str	r3, [sp, #0x8]
 800faf4: 2308         	movs	r3, #0x8
 800faf6: 9301         	str	r3, [sp, #0x4]
 800faf8: 2300         	movs	r3, #0x0
 800fafa: 9300         	str	r3, [sp]
 800fafc: 2300         	movs	r3, #0x0
 800fafe: 2204         	movs	r2, #0x4
 800fb00: 4629         	mov	r1, r5
 800fb02: 2000         	movs	r0, #0x0
 800fb04: f00e fd14    	bl	0x801e530 <z_log_msg_runtime_create> @ imm = #0xea28
 800fb08: 2300         	movs	r3, #0x0
 800fb0a: 60fb         	str	r3, [r7, #0xc]
; 		return z_thread_prio_set(mutex->owner, new_prio);
 800fb0c: 687b         	ldr	r3, [r7, #0x4]
 800fb0e: 689b         	ldr	r3, [r3, #0x8]
 800fb10: 6839         	ldr	r1, [r7]
 800fb12: 4618         	mov	r0, r3
 800fb14: f001 ff0e    	bl	0x8011934 <z_thread_prio_set> @ imm = #0x1e1c
 800fb18: 4603         	mov	r3, r0
 800fb1a: e000         	b	0x800fb1e <adjust_owner_prio+0x92> @ imm = #0x0
; 	return false;
 800fb1c: 2300         	movs	r3, #0x0
; }
 800fb1e: 4618         	mov	r0, r3
 800fb20: 3710         	adds	r7, #0x10
 800fb22: 46bd         	mov	sp, r7
 800fb24: bdb0         	pop	{r4, r5, r7, pc}
 800fb26: bf00         	nop

0800fb28 <$d>:
 800fb28: 0c 06 00 20  	.word	0x2000060c
 800fb2c: 9c 2e 02 08  	.word	0x08022e9c
 800fb30: 38 20 02 08  	.word	0x08022038

0800fb34 <z_impl_k_mutex_lock>:
; {
 800fb34: b580         	push	{r7, lr}
 800fb36: b0be         	sub	sp, #0xf8
 800fb38: af08         	add	r7, sp, #0x20
 800fb3a: 60f8         	str	r0, [r7, #0xc]
 800fb3c: e9c7 2300    	strd	r2, r3, [r7]
; 	bool resched = false;
 800fb40: 2300         	movs	r3, #0x0
 800fb42: f887 30d7    	strb.w	r3, [r7, #0xd7]
 800fb46: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x800fde0 <z_impl_k_mutex_lock+0x2ac>
 800fb48: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fb4c: f3ef 8311    	mrs	r3, basepri
 800fb50: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 800fb54: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 800fb58: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800fb5c: 2310         	movs	r3, #0x10
 800fb5e: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800fb62: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800fb66: f383 8812    	msr	basepri_max, r3
; }
 800fb6a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fb6c: f3bf 8f6f    	isb	sy
; }
 800fb70: bf00         	nop
; 	return key;
 800fb72: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 800fb76: 617b         	str	r3, [r7, #0x14]
 800fb78: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800fb7c: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 800fb80: bf00         	nop
 800fb82: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800fb86: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 800fb8a: bf00         	nop
; 	return k;
 800fb8c: 697b         	ldr	r3, [r7, #0x14]
 800fb8e: 627b         	str	r3, [r7, #0x24]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 800fb90: 68fb         	ldr	r3, [r7, #0xc]
 800fb92: 68db         	ldr	r3, [r3, #0xc]
 800fb94: 2b00         	cmp	r3, #0x0
 800fb96: bf0c         	ite	eq
 800fb98: 2301         	moveq	r3, #0x1
 800fb9a: 2300         	movne	r3, #0x0
 800fb9c: b2db         	uxtb	r3, r3
 800fb9e: 2b00         	cmp	r3, #0x0
 800fba0: d10c         	bne	0x800fbbc <z_impl_k_mutex_lock+0x88> @ imm = #0x18
 800fba2: 68fb         	ldr	r3, [r7, #0xc]
 800fba4: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fba6: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x800fde4 <z_impl_k_mutex_lock+0x2b0>
 800fba8: 689b         	ldr	r3, [r3, #0x8]
 800fbaa: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 800fbac: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 800fbae: 429a         	cmp	r2, r3
 800fbb0: bf0c         	ite	eq
 800fbb2: 2301         	moveq	r3, #0x1
 800fbb4: 2300         	movne	r3, #0x0
 800fbb6: b2db         	uxtb	r3, r3
 800fbb8: 2b00         	cmp	r3, #0x0
 800fbba: d001         	beq	0x800fbc0 <z_impl_k_mutex_lock+0x8c> @ imm = #0x2
 800fbbc: 2301         	movs	r3, #0x1
 800fbbe: e000         	b	0x800fbc2 <z_impl_k_mutex_lock+0x8e> @ imm = #0x0
 800fbc0: 2300         	movs	r3, #0x0
 800fbc2: 2b00         	cmp	r3, #0x0
 800fbc4: d059         	beq	0x800fc7a <z_impl_k_mutex_lock+0x146> @ imm = #0xb2
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 800fbc6: 68fb         	ldr	r3, [r7, #0xc]
 800fbc8: 68db         	ldr	r3, [r3, #0xc]
; 					arch_current_thread()->base.prio :
 800fbca: 2b00         	cmp	r3, #0x0
 800fbcc: d106         	bne	0x800fbdc <z_impl_k_mutex_lock+0xa8> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fbce: 4b85         	ldr	r3, [pc, #0x214]        @ 0x800fde4 <z_impl_k_mutex_lock+0x2b0>
 800fbd0: 689b         	ldr	r3, [r3, #0x8]
 800fbd2: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 800fbd4: 6fbb         	ldr	r3, [r7, #0x78]
; 					arch_current_thread()->base.prio :
 800fbd6: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800fbda: e001         	b	0x800fbe0 <z_impl_k_mutex_lock+0xac> @ imm = #0x2
 800fbdc: 68fb         	ldr	r3, [r7, #0xc]
 800fbde: 691b         	ldr	r3, [r3, #0x10]
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 800fbe0: 68fa         	ldr	r2, [r7, #0xc]
 800fbe2: 6113         	str	r3, [r2, #0x10]
; 		mutex->lock_count++;
 800fbe4: 68fb         	ldr	r3, [r7, #0xc]
 800fbe6: 68db         	ldr	r3, [r3, #0xc]
 800fbe8: 1c5a         	adds	r2, r3, #0x1
 800fbea: 68fb         	ldr	r3, [r7, #0xc]
 800fbec: 60da         	str	r2, [r3, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fbee: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x800fde4 <z_impl_k_mutex_lock+0x2b0>
 800fbf0: 689b         	ldr	r3, [r3, #0x8]
 800fbf2: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 800fbf4: 6f7a         	ldr	r2, [r7, #0x74]
; 		mutex->owner = arch_current_thread();
 800fbf6: 68fb         	ldr	r3, [r7, #0xc]
 800fbf8: 609a         	str	r2, [r3, #0x8]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 800fbfa: 2303         	movs	r3, #0x3
 800fbfc: 2b03         	cmp	r3, #0x3
 800fbfe: d929         	bls	0x800fc54 <z_impl_k_mutex_lock+0x120> @ imm = #0x52
 800fc00: 2301         	movs	r3, #0x1
 800fc02: f887 309f    	strb.w	r3, [r7, #0x9f]
 800fc06: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 800fc0a: f083 0301    	eor	r3, r3, #0x1
 800fc0e: b2db         	uxtb	r3, r3
 800fc10: 2b00         	cmp	r3, #0x0
 800fc12: d11f         	bne	0x800fc54 <z_impl_k_mutex_lock+0x120> @ imm = #0x3e
 800fc14: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800fde8 <z_impl_k_mutex_lock+0x2b4>
 800fc16: 6818         	ldr	r0, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fc18: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x800fde4 <z_impl_k_mutex_lock+0x2b0>
 800fc1a: 689b         	ldr	r3, [r3, #0x8]
 800fc1c: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 800fc1e: 6f3b         	ldr	r3, [r7, #0x70]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 800fc20: 68fa         	ldr	r2, [r7, #0xc]
 800fc22: 68d2         	ldr	r2, [r2, #0xc]
 800fc24: 68f9         	ldr	r1, [r7, #0xc]
 800fc26: 6909         	ldr	r1, [r1, #0x10]
 800fc28: 9107         	str	r1, [sp, #0x1c]
 800fc2a: 9206         	str	r2, [sp, #0x18]
 800fc2c: 68fa         	ldr	r2, [r7, #0xc]
 800fc2e: 9205         	str	r2, [sp, #0x14]
 800fc30: 9304         	str	r3, [sp, #0x10]
 800fc32: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800fdec <z_impl_k_mutex_lock+0x2b8>
 800fc34: 9303         	str	r3, [sp, #0xc]
 800fc36: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x800fdf0 <z_impl_k_mutex_lock+0x2bc>
 800fc38: 9302         	str	r3, [sp, #0x8]
 800fc3a: 2308         	movs	r3, #0x8
 800fc3c: 9301         	str	r3, [sp, #0x4]
 800fc3e: 2300         	movs	r3, #0x0
 800fc40: 9300         	str	r3, [sp]
 800fc42: 2300         	movs	r3, #0x0
 800fc44: 2204         	movs	r2, #0x4
 800fc46: 4601         	mov	r1, r0
 800fc48: 2000         	movs	r0, #0x0
 800fc4a: f00e fc71    	bl	0x801e530 <z_log_msg_runtime_create> @ imm = #0xe8e2
 800fc4e: 2300         	movs	r3, #0x0
 800fc50: f8c7 3098    	str.w	r3, [r7, #0x98]
 800fc54: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800fde0 <z_impl_k_mutex_lock+0x2ac>
 800fc56: 66fb         	str	r3, [r7, #0x6c]
 800fc58: 6a7b         	ldr	r3, [r7, #0x24]
 800fc5a: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800fc5c: 69bb         	ldr	r3, [r7, #0x18]
 800fc5e: 66bb         	str	r3, [r7, #0x68]
 800fc60: 6ebb         	ldr	r3, [r7, #0x68]
 800fc62: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800fc64: 6e7b         	ldr	r3, [r7, #0x64]
 800fc66: f383 8811    	msr	basepri, r3
; }
 800fc6a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fc6c: f3bf 8f6f    	isb	sy
; }
 800fc70: bf00         	nop
; }
 800fc72: bf00         	nop
; }
 800fc74: bf00         	nop
; 		return 0;
 800fc76: 2300         	movs	r3, #0x0
 800fc78: e193         	b	0x800ffa2 <z_impl_k_mutex_lock+0x46e> @ imm = #0x326
; 	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
 800fc7a: e9d7 2300    	ldrd	r2, r3, [r7]
 800fc7e: f04f 0000    	mov.w	r0, #0x0
 800fc82: f04f 0100    	mov.w	r1, #0x0
 800fc86: 428b         	cmp	r3, r1
 800fc88: bf08         	it	eq
 800fc8a: 4282         	cmpeq	r2, r0
 800fc8c: bf0c         	ite	eq
 800fc8e: 2301         	moveq	r3, #0x1
 800fc90: 2300         	movne	r3, #0x0
 800fc92: b2db         	uxtb	r3, r3
 800fc94: 2b00         	cmp	r3, #0x0
 800fc96: d013         	beq	0x800fcc0 <z_impl_k_mutex_lock+0x18c> @ imm = #0x26
 800fc98: 4b51         	ldr	r3, [pc, #0x144]        @ 0x800fde0 <z_impl_k_mutex_lock+0x2ac>
 800fc9a: 663b         	str	r3, [r7, #0x60]
 800fc9c: 6a7b         	ldr	r3, [r7, #0x24]
 800fc9e: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800fca0: 693b         	ldr	r3, [r7, #0x10]
 800fca2: 65fb         	str	r3, [r7, #0x5c]
 800fca4: 6dfb         	ldr	r3, [r7, #0x5c]
 800fca6: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800fca8: 6dbb         	ldr	r3, [r7, #0x58]
 800fcaa: f383 8811    	msr	basepri, r3
; }
 800fcae: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fcb0: f3bf 8f6f    	isb	sy
; }
 800fcb4: bf00         	nop
; }
 800fcb6: bf00         	nop
; }
 800fcb8: bf00         	nop
; 		return -EBUSY;
 800fcba: f06f 030f    	mvn	r3, #0xf
 800fcbe: e170         	b	0x800ffa2 <z_impl_k_mutex_lock+0x46e> @ imm = #0x2e0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fcc0: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800fde4 <z_impl_k_mutex_lock+0x2b0>
 800fcc2: 689b         	ldr	r3, [r3, #0x8]
 800fcc4: 657b         	str	r3, [r7, #0x54]
; 	return ret;
 800fcc6: 6d7b         	ldr	r3, [r7, #0x54]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 800fcc8: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800fccc: 461a         	mov	r2, r3
; 					    mutex->owner->base.prio);
 800fcce: 68fb         	ldr	r3, [r7, #0xc]
 800fcd0: 689b         	ldr	r3, [r3, #0x8]
 800fcd2: f993 300e    	ldrsb.w	r3, [r3, #0xe]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 800fcd6: 4619         	mov	r1, r3
 800fcd8: 4610         	mov	r0, r2
 800fcda: f00e fc47    	bl	0x801e56c <new_prio_for_inheritance> @ imm = #0xe88e
 800fcde: f8c7 00d0    	str.w	r0, [r7, #0xd0]
; 	LOG_DBG("adjusting prio up on mutex %p", mutex);
 800fce2: 2303         	movs	r3, #0x3
 800fce4: 2b03         	cmp	r3, #0x3
 800fce6: d91d         	bls	0x800fd24 <z_impl_k_mutex_lock+0x1f0> @ imm = #0x3a
 800fce8: 2301         	movs	r3, #0x1
 800fcea: f887 30cf    	strb.w	r3, [r7, #0xcf]
 800fcee: f897 30cf    	ldrb.w	r3, [r7, #0xcf]
 800fcf2: f083 0301    	eor	r3, r3, #0x1
 800fcf6: b2db         	uxtb	r3, r3
 800fcf8: 2b00         	cmp	r3, #0x0
 800fcfa: d113         	bne	0x800fd24 <z_impl_k_mutex_lock+0x1f0> @ imm = #0x26
 800fcfc: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x800fde8 <z_impl_k_mutex_lock+0x2b4>
 800fcfe: 6819         	ldr	r1, [r3]
 800fd00: 68fb         	ldr	r3, [r7, #0xc]
 800fd02: 9304         	str	r3, [sp, #0x10]
 800fd04: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800fdec <z_impl_k_mutex_lock+0x2b8>
 800fd06: 9303         	str	r3, [sp, #0xc]
 800fd08: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x800fdf4 <z_impl_k_mutex_lock+0x2c0>
 800fd0a: 9302         	str	r3, [sp, #0x8]
 800fd0c: 2308         	movs	r3, #0x8
 800fd0e: 9301         	str	r3, [sp, #0x4]
 800fd10: 2300         	movs	r3, #0x0
 800fd12: 9300         	str	r3, [sp]
 800fd14: 2300         	movs	r3, #0x0
 800fd16: 2204         	movs	r2, #0x4
 800fd18: 2000         	movs	r0, #0x0
 800fd1a: f00e fc09    	bl	0x801e530 <z_log_msg_runtime_create> @ imm = #0xe812
 800fd1e: 2300         	movs	r3, #0x0
 800fd20: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
 800fd24: 68fb         	ldr	r3, [r7, #0xc]
 800fd26: 689b         	ldr	r3, [r3, #0x8]
 800fd28: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800fd2c: 4619         	mov	r1, r3
 800fd2e: f8d7 00d0    	ldr.w	r0, [r7, #0xd0]
 800fd32: f00e fbc8    	bl	0x801e4c6 <z_is_prio_higher> @ imm = #0xe790
 800fd36: 4603         	mov	r3, r0
 800fd38: 2b00         	cmp	r3, #0x0
 800fd3a: d007         	beq	0x800fd4c <z_impl_k_mutex_lock+0x218> @ imm = #0xe
; 		resched = adjust_owner_prio(mutex, new_prio);
 800fd3c: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 800fd40: 68f8         	ldr	r0, [r7, #0xc]
 800fd42: f7ff fea3    	bl	0x800fa8c <adjust_owner_prio> @ imm = #-0x2ba
 800fd46: 4603         	mov	r3, r0
 800fd48: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
 800fd4c: 68f9         	ldr	r1, [r7, #0xc]
 800fd4e: e9d7 2300    	ldrd	r2, r3, [r7]
 800fd52: e9cd 2300    	strd	r2, r3, [sp]
 800fd56: 460a         	mov	r2, r1
 800fd58: 6a79         	ldr	r1, [r7, #0x24]
 800fd5a: 4821         	ldr	r0, [pc, #0x84]         @ 0x800fde0 <z_impl_k_mutex_lock+0x2ac>
 800fd5c: f001 fda4    	bl	0x80118a8 <z_pend_curr> @ imm = #0x1b48
 800fd60: f8c7 00c4    	str.w	r0, [r7, #0xc4]
; 	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);
 800fd64: 2303         	movs	r3, #0x3
 800fd66: 2b03         	cmp	r3, #0x3
 800fd68: d920         	bls	0x800fdac <z_impl_k_mutex_lock+0x278> @ imm = #0x40
 800fd6a: 2301         	movs	r3, #0x1
 800fd6c: f887 30c3    	strb.w	r3, [r7, #0xc3]
 800fd70: f897 30c3    	ldrb.w	r3, [r7, #0xc3]
 800fd74: f083 0301    	eor	r3, r3, #0x1
 800fd78: b2db         	uxtb	r3, r3
 800fd7a: 2b00         	cmp	r3, #0x0
 800fd7c: d116         	bne	0x800fdac <z_impl_k_mutex_lock+0x278> @ imm = #0x2c
 800fd7e: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800fde8 <z_impl_k_mutex_lock+0x2b4>
 800fd80: 6819         	ldr	r1, [r3]
 800fd82: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800fd86: 9305         	str	r3, [sp, #0x14]
 800fd88: 68fb         	ldr	r3, [r7, #0xc]
 800fd8a: 9304         	str	r3, [sp, #0x10]
 800fd8c: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800fdec <z_impl_k_mutex_lock+0x2b8>
 800fd8e: 9303         	str	r3, [sp, #0xc]
 800fd90: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800fdf8 <z_impl_k_mutex_lock+0x2c4>
 800fd92: 9302         	str	r3, [sp, #0x8]
 800fd94: 2308         	movs	r3, #0x8
 800fd96: 9301         	str	r3, [sp, #0x4]
 800fd98: 2300         	movs	r3, #0x0
 800fd9a: 9300         	str	r3, [sp]
 800fd9c: 2300         	movs	r3, #0x0
 800fd9e: 2204         	movs	r2, #0x4
 800fda0: 2000         	movs	r0, #0x0
 800fda2: f00e fbc5    	bl	0x801e530 <z_log_msg_runtime_create> @ imm = #0xe78a
 800fda6: 2300         	movs	r3, #0x0
 800fda8: f8c7 30bc    	str.w	r3, [r7, #0xbc]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 800fdac: 2303         	movs	r3, #0x3
 800fdae: 2b03         	cmp	r3, #0x3
 800fdb0: d939         	bls	0x800fe26 <z_impl_k_mutex_lock+0x2f2> @ imm = #0x72
 800fdb2: 2301         	movs	r3, #0x1
 800fdb4: f887 30bb    	strb.w	r3, [r7, #0xbb]
 800fdb8: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 800fdbc: f083 0301    	eor	r3, r3, #0x1
 800fdc0: b2db         	uxtb	r3, r3
 800fdc2: 2b00         	cmp	r3, #0x0
 800fdc4: d12f         	bne	0x800fe26 <z_impl_k_mutex_lock+0x2f2> @ imm = #0x5e
 800fdc6: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800fde8 <z_impl_k_mutex_lock+0x2b4>
 800fdc8: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fdca: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800fde4 <z_impl_k_mutex_lock+0x2b0>
 800fdcc: 689b         	ldr	r3, [r3, #0x8]
 800fdce: 653b         	str	r3, [r7, #0x50]
; 	return ret;
 800fdd0: 6d3b         	ldr	r3, [r7, #0x50]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 800fdd2: f8d7 20c4    	ldr.w	r2, [r7, #0xc4]
 800fdd6: 2a00         	cmp	r2, #0x0
 800fdd8: d010         	beq	0x800fdfc <z_impl_k_mutex_lock+0x2c8> @ imm = #0x20
 800fdda: 2279         	movs	r2, #0x79
 800fddc: e00f         	b	0x800fdfe <z_impl_k_mutex_lock+0x2ca> @ imm = #0x1e
 800fdde: bf00         	nop

0800fde0 <$d>:
 800fde0: d8 27 00 20  	.word	0x200027d8
 800fde4: 48 1d 00 20  	.word	0x20001d48
 800fde8: 0c 06 00 20  	.word	0x2000060c
 800fdec: b0 2e 02 08  	.word	0x08022eb0
 800fdf0: 70 20 02 08  	.word	0x08022070
 800fdf4: a0 20 02 08  	.word	0x080220a0
 800fdf8: c4 20 02 08  	.word	0x080220c4

0800fdfc <$t>:
 800fdfc: 226e         	movs	r2, #0x6e
 800fdfe: 9206         	str	r2, [sp, #0x18]
 800fe00: 68fa         	ldr	r2, [r7, #0xc]
 800fe02: 9205         	str	r2, [sp, #0x14]
 800fe04: 9304         	str	r3, [sp, #0x10]
 800fe06: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x800ffac <z_impl_k_mutex_lock+0x478>
 800fe08: 9303         	str	r3, [sp, #0xc]
 800fe0a: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x800ffb0 <z_impl_k_mutex_lock+0x47c>
 800fe0c: 9302         	str	r3, [sp, #0x8]
 800fe0e: 2308         	movs	r3, #0x8
 800fe10: 9301         	str	r3, [sp, #0x4]
 800fe12: 2300         	movs	r3, #0x0
 800fe14: 9300         	str	r3, [sp]
 800fe16: 2300         	movs	r3, #0x0
 800fe18: 2204         	movs	r2, #0x4
 800fe1a: 2000         	movs	r0, #0x0
 800fe1c: f00e fb88    	bl	0x801e530 <z_log_msg_runtime_create> @ imm = #0xe710
 800fe20: 2300         	movs	r3, #0x0
 800fe22: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (got_mutex == 0) {
 800fe26: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800fe2a: 2b00         	cmp	r3, #0x0
 800fe2c: d101         	bne	0x800fe32 <z_impl_k_mutex_lock+0x2fe> @ imm = #0x2
; 		return 0;
 800fe2e: 2300         	movs	r3, #0x0
 800fe30: e0b7         	b	0x800ffa2 <z_impl_k_mutex_lock+0x46e> @ imm = #0x16e
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 800fe32: 2303         	movs	r3, #0x3
 800fe34: 2b03         	cmp	r3, #0x3
 800fe36: d922         	bls	0x800fe7e <z_impl_k_mutex_lock+0x34a> @ imm = #0x44
 800fe38: 2301         	movs	r3, #0x1
 800fe3a: f887 30b3    	strb.w	r3, [r7, #0xb3]
 800fe3e: f897 30b3    	ldrb.w	r3, [r7, #0xb3]
 800fe42: f083 0301    	eor	r3, r3, #0x1
 800fe46: b2db         	uxtb	r3, r3
 800fe48: 2b00         	cmp	r3, #0x0
 800fe4a: d118         	bne	0x800fe7e <z_impl_k_mutex_lock+0x34a> @ imm = #0x30
 800fe4c: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800ffb4 <z_impl_k_mutex_lock+0x480>
 800fe4e: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800fe50: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800ffb8 <z_impl_k_mutex_lock+0x484>
 800fe52: 689b         	ldr	r3, [r3, #0x8]
 800fe54: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 800fe56: 6cfb         	ldr	r3, [r7, #0x4c]
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 800fe58: 68fa         	ldr	r2, [r7, #0xc]
 800fe5a: 9205         	str	r2, [sp, #0x14]
 800fe5c: 9304         	str	r3, [sp, #0x10]
 800fe5e: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800ffac <z_impl_k_mutex_lock+0x478>
 800fe60: 9303         	str	r3, [sp, #0xc]
 800fe62: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800ffbc <z_impl_k_mutex_lock+0x488>
 800fe64: 9302         	str	r3, [sp, #0x8]
 800fe66: 2308         	movs	r3, #0x8
 800fe68: 9301         	str	r3, [sp, #0x4]
 800fe6a: 2300         	movs	r3, #0x0
 800fe6c: 9300         	str	r3, [sp]
 800fe6e: 2300         	movs	r3, #0x0
 800fe70: 2204         	movs	r2, #0x4
 800fe72: 2000         	movs	r0, #0x0
 800fe74: f00e fb5c    	bl	0x801e530 <z_log_msg_runtime_create> @ imm = #0xe6b8
 800fe78: 2300         	movs	r3, #0x0
 800fe7a: f8c7 30ac    	str.w	r3, [r7, #0xac]
 800fe7e: 4b50         	ldr	r3, [pc, #0x140]        @ 0x800ffc0 <z_impl_k_mutex_lock+0x48c>
 800fe80: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fe82: f3ef 8311    	mrs	r3, basepri
 800fe86: 647b         	str	r3, [r7, #0x44]
;   return(result);
 800fe88: 6c7b         	ldr	r3, [r7, #0x44]
; 	key = __get_BASEPRI();
 800fe8a: 643b         	str	r3, [r7, #0x40]
 800fe8c: 2310         	movs	r3, #0x10
 800fe8e: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800fe90: 6bfb         	ldr	r3, [r7, #0x3c]
 800fe92: f383 8812    	msr	basepri_max, r3
; }
 800fe96: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800fe98: f3bf 8f6f    	isb	sy
; }
 800fe9c: bf00         	nop
; 	return key;
 800fe9e: 6c3b         	ldr	r3, [r7, #0x40]
; 	k.key = arch_irq_lock();
 800fea0: 61fb         	str	r3, [r7, #0x1c]
 800fea2: 6cbb         	ldr	r3, [r7, #0x48]
 800fea4: 63bb         	str	r3, [r7, #0x38]
; }
 800fea6: bf00         	nop
 800fea8: 6cbb         	ldr	r3, [r7, #0x48]
 800feaa: 637b         	str	r3, [r7, #0x34]
; }
 800feac: bf00         	nop
; 	return k;
 800feae: 69fb         	ldr	r3, [r7, #0x1c]
 800feb0: 627b         	str	r3, [r7, #0x24]
; 	if (likely(mutex->owner != NULL)) {
 800feb2: 68fb         	ldr	r3, [r7, #0xc]
 800feb4: 689b         	ldr	r3, [r3, #0x8]
 800feb6: 2b00         	cmp	r3, #0x0
 800feb8: bf14         	ite	ne
 800feba: 2301         	movne	r3, #0x1
 800febc: 2300         	moveq	r3, #0x0
 800febe: b2db         	uxtb	r3, r3
 800fec0: 2b00         	cmp	r3, #0x0
 800fec2: d052         	beq	0x800ff6a <z_impl_k_mutex_lock+0x436> @ imm = #0xa4
; 		struct k_thread *waiter = z_waitq_head(&mutex->wait_q);
 800fec4: 68fb         	ldr	r3, [r7, #0xc]
 800fec6: 4618         	mov	r0, r3
 800fec8: f00e fb25    	bl	0x801e516 <z_waitq_head> @ imm = #0xe64a
 800fecc: f8c7 00a8    	str.w	r0, [r7, #0xa8]
; 			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
 800fed0: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800fed4: 2b00         	cmp	r3, #0x0
 800fed6: d00c         	beq	0x800fef2 <z_impl_k_mutex_lock+0x3be> @ imm = #0x18
 800fed8: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 800fedc: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800fee0: 461a         	mov	r2, r3
 800fee2: 68fb         	ldr	r3, [r7, #0xc]
 800fee4: 691b         	ldr	r3, [r3, #0x10]
 800fee6: 4619         	mov	r1, r3
 800fee8: 4610         	mov	r0, r2
 800feea: f00e fb3f    	bl	0x801e56c <new_prio_for_inheritance> @ imm = #0xe67e
 800feee: 4603         	mov	r3, r0
 800fef0: e001         	b	0x800fef6 <z_impl_k_mutex_lock+0x3c2> @ imm = #0x2
 800fef2: 68fb         	ldr	r3, [r7, #0xc]
 800fef4: 691b         	ldr	r3, [r3, #0x10]
; 		new_prio = (waiter != NULL) ?
 800fef6: f8c7 30d0    	str.w	r3, [r7, #0xd0]
; 		LOG_DBG("adjusting prio down on mutex %p", mutex);
 800fefa: 2303         	movs	r3, #0x3
 800fefc: 2b03         	cmp	r3, #0x3
 800fefe: d91d         	bls	0x800ff3c <z_impl_k_mutex_lock+0x408> @ imm = #0x3a
 800ff00: 2301         	movs	r3, #0x1
 800ff02: f887 30a7    	strb.w	r3, [r7, #0xa7]
 800ff06: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 800ff0a: f083 0301    	eor	r3, r3, #0x1
 800ff0e: b2db         	uxtb	r3, r3
 800ff10: 2b00         	cmp	r3, #0x0
 800ff12: d113         	bne	0x800ff3c <z_impl_k_mutex_lock+0x408> @ imm = #0x26
 800ff14: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800ffb4 <z_impl_k_mutex_lock+0x480>
 800ff16: 6819         	ldr	r1, [r3]
 800ff18: 68fb         	ldr	r3, [r7, #0xc]
 800ff1a: 9304         	str	r3, [sp, #0x10]
 800ff1c: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800ffac <z_impl_k_mutex_lock+0x478>
 800ff1e: 9303         	str	r3, [sp, #0xc]
 800ff20: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800ffc4 <z_impl_k_mutex_lock+0x490>
 800ff22: 9302         	str	r3, [sp, #0x8]
 800ff24: 2308         	movs	r3, #0x8
 800ff26: 9301         	str	r3, [sp, #0x4]
 800ff28: 2300         	movs	r3, #0x0
 800ff2a: 9300         	str	r3, [sp]
 800ff2c: 2300         	movs	r3, #0x0
 800ff2e: 2204         	movs	r2, #0x4
 800ff30: 2000         	movs	r0, #0x0
 800ff32: f00e fafd    	bl	0x801e530 <z_log_msg_runtime_create> @ imm = #0xe5fa
 800ff36: 2300         	movs	r3, #0x0
 800ff38: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 		resched = adjust_owner_prio(mutex, new_prio) || resched;
 800ff3c: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 800ff40: 68f8         	ldr	r0, [r7, #0xc]
 800ff42: f7ff fda3    	bl	0x800fa8c <adjust_owner_prio> @ imm = #-0x4ba
 800ff46: 4603         	mov	r3, r0
 800ff48: 2b00         	cmp	r3, #0x0
 800ff4a: d103         	bne	0x800ff54 <z_impl_k_mutex_lock+0x420> @ imm = #0x6
 800ff4c: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 800ff50: 2b00         	cmp	r3, #0x0
 800ff52: d001         	beq	0x800ff58 <z_impl_k_mutex_lock+0x424> @ imm = #0x2
 800ff54: 2301         	movs	r3, #0x1
 800ff56: e000         	b	0x800ff5a <z_impl_k_mutex_lock+0x426> @ imm = #0x0
 800ff58: 2300         	movs	r3, #0x0
 800ff5a: f887 30d7    	strb.w	r3, [r7, #0xd7]
 800ff5e: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 800ff62: f003 0301    	and	r3, r3, #0x1
 800ff66: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	if (resched) {
 800ff6a: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 800ff6e: 2b00         	cmp	r3, #0x0
 800ff70: d004         	beq	0x800ff7c <z_impl_k_mutex_lock+0x448> @ imm = #0x8
; 		z_reschedule(&lock, key);
 800ff72: 6a79         	ldr	r1, [r7, #0x24]
 800ff74: 4812         	ldr	r0, [pc, #0x48]         @ 0x800ffc0 <z_impl_k_mutex_lock+0x48c>
 800ff76: f00f fc15    	bl	0x801f7a4 <z_reschedule> @ imm = #0xf82a
 800ff7a: e010         	b	0x800ff9e <z_impl_k_mutex_lock+0x46a> @ imm = #0x20
 800ff7c: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800ffc0 <z_impl_k_mutex_lock+0x48c>
 800ff7e: 633b         	str	r3, [r7, #0x30]
 800ff80: 6a7b         	ldr	r3, [r7, #0x24]
 800ff82: 623b         	str	r3, [r7, #0x20]
; 	arch_irq_unlock(key.key);
 800ff84: 6a3b         	ldr	r3, [r7, #0x20]
 800ff86: 62fb         	str	r3, [r7, #0x2c]
 800ff88: 6afb         	ldr	r3, [r7, #0x2c]
 800ff8a: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ff8c: 6abb         	ldr	r3, [r7, #0x28]
 800ff8e: f383 8811    	msr	basepri, r3
; }
 800ff92: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ff94: f3bf 8f6f    	isb	sy
; }
 800ff98: bf00         	nop
; }
 800ff9a: bf00         	nop
; }
 800ff9c: bf00         	nop
; 	return -EAGAIN;
 800ff9e: f06f 030a    	mvn	r3, #0xa
; }
 800ffa2: 4618         	mov	r0, r3
 800ffa4: 37d8         	adds	r7, #0xd8
 800ffa6: 46bd         	mov	sp, r7
 800ffa8: bd80         	pop	{r7, pc}
 800ffaa: bf00         	nop

0800ffac <$d>:
 800ffac: b0 2e 02 08  	.word	0x08022eb0
 800ffb0: e8 20 02 08  	.word	0x080220e8
 800ffb4: 0c 06 00 20  	.word	0x2000060c
 800ffb8: 48 1d 00 20  	.word	0x20001d48
 800ffbc: 08 21 02 08  	.word	0x08022108
 800ffc0: d8 27 00 20  	.word	0x200027d8
 800ffc4: 24 21 02 08  	.word	0x08022124

0800ffc8 <z_impl_k_mutex_unlock>:
; {
 800ffc8: b580         	push	{r7, lr}
 800ffca: b0a4         	sub	sp, #0x90
 800ffcc: af08         	add	r7, sp, #0x20
 800ffce: 6078         	str	r0, [r7, #0x4]
; 	CHECKIF(mutex->owner == NULL) {
 800ffd0: 687b         	ldr	r3, [r7, #0x4]
 800ffd2: 689b         	ldr	r3, [r3, #0x8]
 800ffd4: 2b00         	cmp	r3, #0x0
 800ffd6: d102         	bne	0x800ffde <z_impl_k_mutex_unlock+0x16> @ imm = #0x4
; 		return -EINVAL;
 800ffd8: f06f 0315    	mvn	r3, #0x15
 800ffdc: e0dc         	b	0x8010198 <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1b8
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 800ffde: 687b         	ldr	r3, [r7, #0x4]
 800ffe0: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ffe2: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x80101a0 <z_impl_k_mutex_unlock+0x1d8>
 800ffe4: 689b         	ldr	r3, [r3, #0x8]
 800ffe6: 65bb         	str	r3, [r7, #0x58]
; 	return ret;
 800ffe8: 6dbb         	ldr	r3, [r7, #0x58]
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 800ffea: 429a         	cmp	r2, r3
 800ffec: d002         	beq	0x800fff4 <z_impl_k_mutex_unlock+0x2c> @ imm = #0x4
; 		return -EPERM;
 800ffee: f04f 33ff    	mov.w	r3, #0xffffffff
 800fff2: e0d1         	b	0x8010198 <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1a2
; 	LOG_DBG("mutex %p lock_count: %d", mutex, mutex->lock_count);
 800fff4: 2303         	movs	r3, #0x3
 800fff6: 2b03         	cmp	r3, #0x3
 800fff8: d91f         	bls	0x801003a <z_impl_k_mutex_unlock+0x72> @ imm = #0x3e
 800fffa: 2301         	movs	r3, #0x1
 800fffc: f887 306f    	strb.w	r3, [r7, #0x6f]
 8010000: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 8010004: f083 0301    	eor	r3, r3, #0x1
 8010008: b2db         	uxtb	r3, r3
 801000a: 2b00         	cmp	r3, #0x0
 801000c: d115         	bne	0x801003a <z_impl_k_mutex_unlock+0x72> @ imm = #0x2a
 801000e: 4b65         	ldr	r3, [pc, #0x194]        @ 0x80101a4 <z_impl_k_mutex_unlock+0x1dc>
 8010010: 6819         	ldr	r1, [r3]
 8010012: 687b         	ldr	r3, [r7, #0x4]
 8010014: 68db         	ldr	r3, [r3, #0xc]
 8010016: 9305         	str	r3, [sp, #0x14]
 8010018: 687b         	ldr	r3, [r7, #0x4]
 801001a: 9304         	str	r3, [sp, #0x10]
 801001c: 4b62         	ldr	r3, [pc, #0x188]        @ 0x80101a8 <z_impl_k_mutex_unlock+0x1e0>
 801001e: 9303         	str	r3, [sp, #0xc]
 8010020: 4b62         	ldr	r3, [pc, #0x188]        @ 0x80101ac <z_impl_k_mutex_unlock+0x1e4>
 8010022: 9302         	str	r3, [sp, #0x8]
 8010024: 2308         	movs	r3, #0x8
 8010026: 9301         	str	r3, [sp, #0x4]
 8010028: 2300         	movs	r3, #0x0
 801002a: 9300         	str	r3, [sp]
 801002c: 2300         	movs	r3, #0x0
 801002e: 2204         	movs	r2, #0x4
 8010030: 2000         	movs	r0, #0x0
 8010032: f00e fa7d    	bl	0x801e530 <z_log_msg_runtime_create> @ imm = #0xe4fa
 8010036: 2300         	movs	r3, #0x0
 8010038: 66bb         	str	r3, [r7, #0x68]
; 	if (mutex->lock_count > 1U) {
 801003a: 687b         	ldr	r3, [r7, #0x4]
 801003c: 68db         	ldr	r3, [r3, #0xc]
 801003e: 2b01         	cmp	r3, #0x1
 8010040: d905         	bls	0x801004e <z_impl_k_mutex_unlock+0x86> @ imm = #0xa
; 		mutex->lock_count--;
 8010042: 687b         	ldr	r3, [r7, #0x4]
 8010044: 68db         	ldr	r3, [r3, #0xc]
 8010046: 1e5a         	subs	r2, r3, #0x1
 8010048: 687b         	ldr	r3, [r7, #0x4]
 801004a: 60da         	str	r2, [r3, #0xc]
; 		goto k_mutex_unlock_return;
 801004c: e0a3         	b	0x8010196 <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x146
 801004e: 4b58         	ldr	r3, [pc, #0x160]        @ 0x80101b0 <z_impl_k_mutex_unlock+0x1e8>
 8010050: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010052: f3ef 8311    	mrs	r3, basepri
 8010056: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 8010058: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 801005a: 63bb         	str	r3, [r7, #0x38]
 801005c: 2310         	movs	r3, #0x10
 801005e: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010060: 6b7b         	ldr	r3, [r7, #0x34]
 8010062: f383 8812    	msr	basepri_max, r3
; }
 8010066: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010068: f3bf 8f6f    	isb	sy
; }
 801006c: bf00         	nop
; 	return key;
 801006e: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 8010070: 60fb         	str	r3, [r7, #0xc]
 8010072: 6c3b         	ldr	r3, [r7, #0x40]
 8010074: 633b         	str	r3, [r7, #0x30]
; }
 8010076: bf00         	nop
 8010078: 6c3b         	ldr	r3, [r7, #0x40]
 801007a: 62fb         	str	r3, [r7, #0x2c]
; }
 801007c: bf00         	nop
; 	return k;
 801007e: 68fb         	ldr	r3, [r7, #0xc]
 8010080: 617b         	str	r3, [r7, #0x14]
; 	adjust_owner_prio(mutex, mutex->owner_orig_prio);
 8010082: 687b         	ldr	r3, [r7, #0x4]
 8010084: 691b         	ldr	r3, [r3, #0x10]
 8010086: 4619         	mov	r1, r3
 8010088: 6878         	ldr	r0, [r7, #0x4]
 801008a: f7ff fcff    	bl	0x800fa8c <adjust_owner_prio> @ imm = #-0x602
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 801008e: 687b         	ldr	r3, [r7, #0x4]
 8010090: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 8010092: 2300         	movs	r3, #0x0
 8010094: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8010096: 6d7b         	ldr	r3, [r7, #0x54]
 8010098: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 801009a: 2300         	movs	r3, #0x0
 801009c: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 801009e: 6cf8         	ldr	r0, [r7, #0x4c]
 80100a0: f00e f92e    	bl	0x801e300 <sys_dlist_peek_head> @ imm = #0xe25c
 80100a4: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 80100a6: 6c7b         	ldr	r3, [r7, #0x44]
 80100a8: 2b00         	cmp	r3, #0x0
 80100aa: d001         	beq	0x80100b0 <z_impl_k_mutex_unlock+0xe8> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80100ac: 6c7b         	ldr	r3, [r7, #0x44]
 80100ae: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 80100b0: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80100b2: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 80100b4: 6d3b         	ldr	r3, [r7, #0x50]
 80100b6: 2b00         	cmp	r3, #0x0
 80100b8: bf14         	ite	ne
 80100ba: 2301         	movne	r3, #0x1
 80100bc: 2300         	moveq	r3, #0x0
 80100be: b2db         	uxtb	r3, r3
 80100c0: 2b00         	cmp	r3, #0x0
 80100c2: d005         	beq	0x80100d0 <z_impl_k_mutex_unlock+0x108> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 80100c4: 6d38         	ldr	r0, [r7, #0x50]
 80100c6: f00e fa0c    	bl	0x801e4e2 <unpend_thread_no_timeout> @ imm = #0xe418
; 			(void)z_abort_thread_timeout(thread);
 80100ca: 6d38         	ldr	r0, [r7, #0x50]
 80100cc: f00e f959    	bl	0x801e382 <z_abort_thread_timeout> @ imm = #0xe2b2
; 	return thread;
 80100d0: 6d3b         	ldr	r3, [r7, #0x50]
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 80100d2: 667b         	str	r3, [r7, #0x64]
; 	mutex->owner = new_owner;
 80100d4: 687b         	ldr	r3, [r7, #0x4]
 80100d6: 6e7a         	ldr	r2, [r7, #0x64]
 80100d8: 609a         	str	r2, [r3, #0x8]
; 	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
 80100da: 2303         	movs	r3, #0x3
 80100dc: 2b03         	cmp	r3, #0x3
 80100de: d927         	bls	0x8010130 <z_impl_k_mutex_unlock+0x168> @ imm = #0x4e
 80100e0: 2301         	movs	r3, #0x1
 80100e2: f887 3063    	strb.w	r3, [r7, #0x63]
 80100e6: f897 3063    	ldrb.w	r3, [r7, #0x63]
 80100ea: f083 0301    	eor	r3, r3, #0x1
 80100ee: b2db         	uxtb	r3, r3
 80100f0: 2b00         	cmp	r3, #0x0
 80100f2: d11d         	bne	0x8010130 <z_impl_k_mutex_unlock+0x168> @ imm = #0x3a
 80100f4: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x80101a4 <z_impl_k_mutex_unlock+0x1dc>
 80100f6: 6819         	ldr	r1, [r3]
 80100f8: 6e7b         	ldr	r3, [r7, #0x64]
 80100fa: 2b00         	cmp	r3, #0x0
 80100fc: d003         	beq	0x8010106 <z_impl_k_mutex_unlock+0x13e> @ imm = #0x6
 80100fe: 6e7b         	ldr	r3, [r7, #0x64]
 8010100: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8010104: e000         	b	0x8010108 <z_impl_k_mutex_unlock+0x140> @ imm = #0x0
 8010106: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x80101b4 <z_impl_k_mutex_unlock+0x1ec>
 8010108: 9306         	str	r3, [sp, #0x18]
 801010a: 6e7b         	ldr	r3, [r7, #0x64]
 801010c: 9305         	str	r3, [sp, #0x14]
 801010e: 687b         	ldr	r3, [r7, #0x4]
 8010110: 9304         	str	r3, [sp, #0x10]
 8010112: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80101a8 <z_impl_k_mutex_unlock+0x1e0>
 8010114: 9303         	str	r3, [sp, #0xc]
 8010116: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x80101b8 <z_impl_k_mutex_unlock+0x1f0>
 8010118: 9302         	str	r3, [sp, #0x8]
 801011a: 2308         	movs	r3, #0x8
 801011c: 9301         	str	r3, [sp, #0x4]
 801011e: 2300         	movs	r3, #0x0
 8010120: 9300         	str	r3, [sp]
 8010122: 2300         	movs	r3, #0x0
 8010124: 2204         	movs	r2, #0x4
 8010126: 2000         	movs	r0, #0x0
 8010128: f00e fa02    	bl	0x801e530 <z_log_msg_runtime_create> @ imm = #0xe404
 801012c: 2300         	movs	r3, #0x0
 801012e: 65fb         	str	r3, [r7, #0x5c]
; 	if (unlikely(new_owner != NULL)) {
 8010130: 6e7b         	ldr	r3, [r7, #0x64]
 8010132: 2b00         	cmp	r3, #0x0
 8010134: bf14         	ite	ne
 8010136: 2301         	movne	r3, #0x1
 8010138: 2300         	moveq	r3, #0x0
 801013a: b2db         	uxtb	r3, r3
 801013c: 2b00         	cmp	r3, #0x0
 801013e: d016         	beq	0x801016e <z_impl_k_mutex_unlock+0x1a6> @ imm = #0x2c
; 		mutex->owner_orig_prio = new_owner->base.prio;
 8010140: 6e7b         	ldr	r3, [r7, #0x64]
 8010142: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8010146: 461a         	mov	r2, r3
 8010148: 687b         	ldr	r3, [r7, #0x4]
 801014a: 611a         	str	r2, [r3, #0x10]
 801014c: 6e7b         	ldr	r3, [r7, #0x64]
 801014e: 62bb         	str	r3, [r7, #0x28]
 8010150: 2300         	movs	r3, #0x0
 8010152: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 8010154: 6abb         	ldr	r3, [r7, #0x28]
 8010156: 6a7a         	ldr	r2, [r7, #0x24]
 8010158: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 801015c: bf00         	nop
; 		z_ready_thread(new_owner);
 801015e: 6e78         	ldr	r0, [r7, #0x64]
 8010160: f000 ffe6    	bl	0x8011130 <z_ready_thread> @ imm = #0xfcc
; 		z_reschedule(&lock, key);
 8010164: 6979         	ldr	r1, [r7, #0x14]
 8010166: 4812         	ldr	r0, [pc, #0x48]         @ 0x80101b0 <z_impl_k_mutex_unlock+0x1e8>
 8010168: f00f fb1c    	bl	0x801f7a4 <z_reschedule> @ imm = #0xf638
 801016c: e013         	b	0x8010196 <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x26
; 		mutex->lock_count = 0U;
 801016e: 687b         	ldr	r3, [r7, #0x4]
 8010170: 2200         	movs	r2, #0x0
 8010172: 60da         	str	r2, [r3, #0xc]
 8010174: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80101b0 <z_impl_k_mutex_unlock+0x1e8>
 8010176: 623b         	str	r3, [r7, #0x20]
 8010178: 697b         	ldr	r3, [r7, #0x14]
 801017a: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 801017c: 693b         	ldr	r3, [r7, #0x10]
 801017e: 61fb         	str	r3, [r7, #0x1c]
 8010180: 69fb         	ldr	r3, [r7, #0x1c]
 8010182: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010184: 69bb         	ldr	r3, [r7, #0x18]
 8010186: f383 8811    	msr	basepri, r3
; }
 801018a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801018c: f3bf 8f6f    	isb	sy
; }
 8010190: bf00         	nop
; }
 8010192: bf00         	nop
; }
 8010194: bf00         	nop
; 	return 0;
 8010196: 2300         	movs	r3, #0x0
; }
 8010198: 4618         	mov	r0, r3
 801019a: 3770         	adds	r7, #0x70
 801019c: 46bd         	mov	sp, r7
 801019e: bd80         	pop	{r7, pc}

080101a0 <$d>:
 80101a0: 48 1d 00 20  	.word	0x20001d48
 80101a4: 0c 06 00 20  	.word	0x2000060c
 80101a8: c4 2e 02 08  	.word	0x08022ec4
 80101ac: 48 21 02 08  	.word	0x08022148
 80101b0: d8 27 00 20  	.word	0x200027d8
 80101b4: 18 fc ff ff  	.word	0xfffffc18
 80101b8: 64 21 02 08  	.word	0x08022164

080101bc <z_impl_k_sem_give>:
; {
 80101bc: b580         	push	{r7, lr}
 80101be: b098         	sub	sp, #0x60
 80101c0: af00         	add	r7, sp, #0x0
 80101c2: 6078         	str	r0, [r7, #0x4]
 80101c4: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x80102d4 <z_impl_k_sem_give+0x118>
 80101c6: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80101c8: f3ef 8311    	mrs	r3, basepri
 80101cc: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 80101ce: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 80101d0: 63bb         	str	r3, [r7, #0x38]
 80101d2: 2310         	movs	r3, #0x10
 80101d4: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80101d6: 6b7b         	ldr	r3, [r7, #0x34]
 80101d8: f383 8812    	msr	basepri_max, r3
; }
 80101dc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80101de: f3bf 8f6f    	isb	sy
; }
 80101e2: bf00         	nop
; 	return key;
 80101e4: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 80101e6: 60fb         	str	r3, [r7, #0xc]
 80101e8: 6c3b         	ldr	r3, [r7, #0x40]
 80101ea: 633b         	str	r3, [r7, #0x30]
; }
 80101ec: bf00         	nop
 80101ee: 6c3b         	ldr	r3, [r7, #0x40]
 80101f0: 62fb         	str	r3, [r7, #0x2c]
; }
 80101f2: bf00         	nop
; 	return k;
 80101f4: 68fb         	ldr	r3, [r7, #0xc]
 80101f6: 617b         	str	r3, [r7, #0x14]
; 	bool resched = true;
 80101f8: 2301         	movs	r3, #0x1
 80101fa: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 80101fe: 687b         	ldr	r3, [r7, #0x4]
 8010200: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 8010202: 2300         	movs	r3, #0x0
 8010204: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8010206: 6d7b         	ldr	r3, [r7, #0x54]
 8010208: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 801020a: 2300         	movs	r3, #0x0
 801020c: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 801020e: 6cf8         	ldr	r0, [r7, #0x4c]
 8010210: f00e f9f7    	bl	0x801e602 <sys_dlist_peek_head> @ imm = #0xe3ee
 8010214: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8010216: 6c7b         	ldr	r3, [r7, #0x44]
 8010218: 2b00         	cmp	r3, #0x0
 801021a: d001         	beq	0x8010220 <z_impl_k_sem_give+0x64> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 801021c: 6c7b         	ldr	r3, [r7, #0x44]
 801021e: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 8010220: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8010222: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 8010224: 6d3b         	ldr	r3, [r7, #0x50]
 8010226: 2b00         	cmp	r3, #0x0
 8010228: bf14         	ite	ne
 801022a: 2301         	movne	r3, #0x1
 801022c: 2300         	moveq	r3, #0x0
 801022e: b2db         	uxtb	r3, r3
 8010230: 2b00         	cmp	r3, #0x0
 8010232: d005         	beq	0x8010240 <z_impl_k_sem_give+0x84> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 8010234: 6d38         	ldr	r0, [r7, #0x50]
 8010236: f00e fa42    	bl	0x801e6be <unpend_thread_no_timeout> @ imm = #0xe484
; 			(void)z_abort_thread_timeout(thread);
 801023a: 6d38         	ldr	r0, [r7, #0x50]
 801023c: f00e fa14    	bl	0x801e668 <z_abort_thread_timeout> @ imm = #0xe428
; 	return thread;
 8010240: 6d3b         	ldr	r3, [r7, #0x50]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 8010242: 65bb         	str	r3, [r7, #0x58]
; 	if (unlikely(thread != NULL)) {
 8010244: 6dbb         	ldr	r3, [r7, #0x58]
 8010246: 2b00         	cmp	r3, #0x0
 8010248: bf14         	ite	ne
 801024a: 2301         	movne	r3, #0x1
 801024c: 2300         	moveq	r3, #0x0
 801024e: b2db         	uxtb	r3, r3
 8010250: 2b00         	cmp	r3, #0x0
 8010252: d00c         	beq	0x801026e <z_impl_k_sem_give+0xb2> @ imm = #0x18
 8010254: 6dbb         	ldr	r3, [r7, #0x58]
 8010256: 62bb         	str	r3, [r7, #0x28]
 8010258: 2300         	movs	r3, #0x0
 801025a: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 801025c: 6abb         	ldr	r3, [r7, #0x28]
 801025e: 6a7a         	ldr	r2, [r7, #0x24]
 8010260: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8010264: bf00         	nop
; 		z_ready_thread(thread);
 8010266: 6db8         	ldr	r0, [r7, #0x58]
 8010268: f000 ff62    	bl	0x8011130 <z_ready_thread> @ imm = #0xec4
 801026c: e013         	b	0x8010296 <z_impl_k_sem_give+0xda> @ imm = #0x26
; 		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 801026e: 687b         	ldr	r3, [r7, #0x4]
 8010270: 689b         	ldr	r3, [r3, #0x8]
 8010272: 687a         	ldr	r2, [r7, #0x4]
 8010274: 6891         	ldr	r1, [r2, #0x8]
 8010276: 687a         	ldr	r2, [r7, #0x4]
 8010278: 68d2         	ldr	r2, [r2, #0xc]
 801027a: 4291         	cmp	r1, r2
 801027c: d001         	beq	0x8010282 <z_impl_k_sem_give+0xc6> @ imm = #0x2
 801027e: 2201         	movs	r2, #0x1
 8010280: e000         	b	0x8010284 <z_impl_k_sem_give+0xc8> @ imm = #0x0
 8010282: 2200         	movs	r2, #0x0
 8010284: 441a         	add	r2, r3
 8010286: 687b         	ldr	r3, [r7, #0x4]
 8010288: 609a         	str	r2, [r3, #0x8]
; 		resched = handle_poll_events(sem);
 801028a: 6878         	ldr	r0, [r7, #0x4]
 801028c: f00e fa53    	bl	0x801e736 <handle_poll_events> @ imm = #0xe4a6
 8010290: 4603         	mov	r3, r0
 8010292: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	if (unlikely(resched)) {
 8010296: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 801029a: 2b00         	cmp	r3, #0x0
 801029c: d004         	beq	0x80102a8 <z_impl_k_sem_give+0xec> @ imm = #0x8
; 		z_reschedule(&lock, key);
 801029e: 6979         	ldr	r1, [r7, #0x14]
 80102a0: 480c         	ldr	r0, [pc, #0x30]         @ 0x80102d4 <z_impl_k_sem_give+0x118>
 80102a2: f00f fa7f    	bl	0x801f7a4 <z_reschedule> @ imm = #0xf4fe
; }
 80102a6: e010         	b	0x80102ca <z_impl_k_sem_give+0x10e> @ imm = #0x20
 80102a8: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80102d4 <z_impl_k_sem_give+0x118>
 80102aa: 623b         	str	r3, [r7, #0x20]
 80102ac: 697b         	ldr	r3, [r7, #0x14]
 80102ae: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 80102b0: 693b         	ldr	r3, [r7, #0x10]
 80102b2: 61fb         	str	r3, [r7, #0x1c]
 80102b4: 69fb         	ldr	r3, [r7, #0x1c]
 80102b6: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80102b8: 69bb         	ldr	r3, [r7, #0x18]
 80102ba: f383 8811    	msr	basepri, r3
; }
 80102be: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80102c0: f3bf 8f6f    	isb	sy
; }
 80102c4: bf00         	nop
; }
 80102c6: bf00         	nop
; }
 80102c8: bf00         	nop
; }
 80102ca: bf00         	nop
 80102cc: 3760         	adds	r7, #0x60
 80102ce: 46bd         	mov	sp, r7
 80102d0: bd80         	pop	{r7, pc}
 80102d2: bf00         	nop

080102d4 <$d>:
 80102d4: d8 27 00 20  	.word	0x200027d8

080102d8 <z_impl_k_sem_take>:
; {
 80102d8: b580         	push	{r7, lr}
 80102da: b098         	sub	sp, #0x60
 80102dc: af02         	add	r7, sp, #0x8
 80102de: 60f8         	str	r0, [r7, #0xc]
 80102e0: e9c7 2300    	strd	r2, r3, [r7]
 80102e4: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80103bc <z_impl_k_sem_take+0xe4>
 80102e6: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80102e8: f3ef 8311    	mrs	r3, basepri
 80102ec: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 80102ee: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 80102f0: 64bb         	str	r3, [r7, #0x48]
 80102f2: 2310         	movs	r3, #0x10
 80102f4: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80102f6: 6c7b         	ldr	r3, [r7, #0x44]
 80102f8: f383 8812    	msr	basepri_max, r3
; }
 80102fc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80102fe: f3bf 8f6f    	isb	sy
; }
 8010302: bf00         	nop
; 	return key;
 8010304: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 8010306: 61bb         	str	r3, [r7, #0x18]
 8010308: 6d3b         	ldr	r3, [r7, #0x50]
 801030a: 643b         	str	r3, [r7, #0x40]
; }
 801030c: bf00         	nop
 801030e: 6d3b         	ldr	r3, [r7, #0x50]
 8010310: 63fb         	str	r3, [r7, #0x3c]
; }
 8010312: bf00         	nop
; 	return k;
 8010314: 69bb         	ldr	r3, [r7, #0x18]
 8010316: 623b         	str	r3, [r7, #0x20]
; 	if (likely(sem->count > 0U)) {
 8010318: 68fb         	ldr	r3, [r7, #0xc]
 801031a: 689b         	ldr	r3, [r3, #0x8]
 801031c: 2b00         	cmp	r3, #0x0
 801031e: bf14         	ite	ne
 8010320: 2301         	movne	r3, #0x1
 8010322: 2300         	moveq	r3, #0x0
 8010324: b2db         	uxtb	r3, r3
 8010326: 2b00         	cmp	r3, #0x0
 8010328: d018         	beq	0x801035c <z_impl_k_sem_take+0x84> @ imm = #0x30
; 		sem->count--;
 801032a: 68fb         	ldr	r3, [r7, #0xc]
 801032c: 689b         	ldr	r3, [r3, #0x8]
 801032e: 1e5a         	subs	r2, r3, #0x1
 8010330: 68fb         	ldr	r3, [r7, #0xc]
 8010332: 609a         	str	r2, [r3, #0x8]
 8010334: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80103bc <z_impl_k_sem_take+0xe4>
 8010336: 63bb         	str	r3, [r7, #0x38]
 8010338: 6a3b         	ldr	r3, [r7, #0x20]
 801033a: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 801033c: 69fb         	ldr	r3, [r7, #0x1c]
 801033e: 637b         	str	r3, [r7, #0x34]
 8010340: 6b7b         	ldr	r3, [r7, #0x34]
 8010342: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010344: 6b3b         	ldr	r3, [r7, #0x30]
 8010346: f383 8811    	msr	basepri, r3
; }
 801034a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801034c: f3bf 8f6f    	isb	sy
; }
 8010350: bf00         	nop
; }
 8010352: bf00         	nop
; }
 8010354: bf00         	nop
; 		ret = 0;
 8010356: 2300         	movs	r3, #0x0
 8010358: 657b         	str	r3, [r7, #0x54]
; 		goto out;
 801035a: e029         	b	0x80103b0 <z_impl_k_sem_take+0xd8> @ imm = #0x52
; 	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 801035c: e9d7 2300    	ldrd	r2, r3, [r7]
 8010360: f04f 0000    	mov.w	r0, #0x0
 8010364: f04f 0100    	mov.w	r1, #0x0
 8010368: 428b         	cmp	r3, r1
 801036a: bf08         	it	eq
 801036c: 4282         	cmpeq	r2, r0
 801036e: d114         	bne	0x801039a <z_impl_k_sem_take+0xc2> @ imm = #0x28
 8010370: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80103bc <z_impl_k_sem_take+0xe4>
 8010372: 62fb         	str	r3, [r7, #0x2c]
 8010374: 6a3b         	ldr	r3, [r7, #0x20]
 8010376: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8010378: 697b         	ldr	r3, [r7, #0x14]
 801037a: 62bb         	str	r3, [r7, #0x28]
 801037c: 6abb         	ldr	r3, [r7, #0x28]
 801037e: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010380: 6a7b         	ldr	r3, [r7, #0x24]
 8010382: f383 8811    	msr	basepri, r3
; }
 8010386: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010388: f3bf 8f6f    	isb	sy
; }
 801038c: bf00         	nop
; }
 801038e: bf00         	nop
; }
 8010390: bf00         	nop
; 		ret = -EBUSY;
 8010392: f06f 030f    	mvn	r3, #0xf
 8010396: 657b         	str	r3, [r7, #0x54]
 8010398: e00a         	b	0x80103b0 <z_impl_k_sem_take+0xd8> @ imm = #0x14
; 	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 801039a: 68f9         	ldr	r1, [r7, #0xc]
 801039c: e9d7 2300    	ldrd	r2, r3, [r7]
 80103a0: e9cd 2300    	strd	r2, r3, [sp]
 80103a4: 460a         	mov	r2, r1
 80103a6: 6a39         	ldr	r1, [r7, #0x20]
 80103a8: 4804         	ldr	r0, [pc, #0x10]         @ 0x80103bc <z_impl_k_sem_take+0xe4>
 80103aa: f001 fa7d    	bl	0x80118a8 <z_pend_curr> @ imm = #0x14fa
 80103ae: 6578         	str	r0, [r7, #0x54]
; 	return ret;
 80103b0: 6d7b         	ldr	r3, [r7, #0x54]
; }
 80103b2: 4618         	mov	r0, r3
 80103b4: 3758         	adds	r7, #0x58
 80103b6: 46bd         	mov	sp, r7
 80103b8: bd80         	pop	{r7, pc}
 80103ba: bf00         	nop

080103bc <$d>:
 80103bc: d8 27 00 20  	.word	0x200027d8

080103c0 <finalize_cancel_locked>:
; {
 80103c0: b580         	push	{r7, lr}
 80103c2: b086         	sub	sp, #0x18
 80103c4: af00         	add	r7, sp, #0x0
 80103c6: 6078         	str	r0, [r7, #0x4]
; 	sys_snode_t *prev = NULL;
 80103c8: 2300         	movs	r3, #0x0
 80103ca: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_CANCELING_BIT);
 80103cc: 687b         	ldr	r3, [r7, #0x4]
 80103ce: 330c         	adds	r3, #0xc
 80103d0: 2101         	movs	r1, #0x1
 80103d2: 4618         	mov	r0, r3
 80103d4: f00e fbaa    	bl	0x801eb2c <flag_clear>  @ imm = #0xe754
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 80103d8: 4829         	ldr	r0, [pc, #0xa4]         @ 0x8010480 <finalize_cancel_locked+0xc0>
 80103da: f00e fa1d    	bl	0x801e818 <sys_slist_peek_head> @ imm = #0xe43a
 80103de: 4603         	mov	r3, r0
 80103e0: 2b00         	cmp	r3, #0x0
 80103e2: d004         	beq	0x80103ee <finalize_cancel_locked+0x2e> @ imm = #0x8
 80103e4: 4826         	ldr	r0, [pc, #0x98]         @ 0x8010480 <finalize_cancel_locked+0xc0>
 80103e6: f00e fa17    	bl	0x801e818 <sys_slist_peek_head> @ imm = #0xe42e
 80103ea: 4603         	mov	r3, r0
 80103ec: e000         	b	0x80103f0 <finalize_cancel_locked+0x30> @ imm = #0x0
 80103ee: 2300         	movs	r3, #0x0
 80103f0: 617b         	str	r3, [r7, #0x14]
 80103f2: 697b         	ldr	r3, [r7, #0x14]
 80103f4: 2b00         	cmp	r3, #0x0
 80103f6: d00e         	beq	0x8010416 <finalize_cancel_locked+0x56> @ imm = #0x1c
 80103f8: 697b         	ldr	r3, [r7, #0x14]
 80103fa: 4618         	mov	r0, r3
 80103fc: f00e fa41    	bl	0x801e882 <sys_slist_peek_next> @ imm = #0xe482
 8010400: 4603         	mov	r3, r0
 8010402: 2b00         	cmp	r3, #0x0
 8010404: d005         	beq	0x8010412 <finalize_cancel_locked+0x52> @ imm = #0xa
 8010406: 697b         	ldr	r3, [r7, #0x14]
 8010408: 4618         	mov	r0, r3
 801040a: f00e fa3a    	bl	0x801e882 <sys_slist_peek_next> @ imm = #0xe474
 801040e: 4603         	mov	r3, r0
 8010410: e002         	b	0x8010418 <finalize_cancel_locked+0x58> @ imm = #0x4
 8010412: 2300         	movs	r3, #0x0
 8010414: e000         	b	0x8010418 <finalize_cancel_locked+0x58> @ imm = #0x0
 8010416: 2300         	movs	r3, #0x0
 8010418: 613b         	str	r3, [r7, #0x10]
 801041a: e028         	b	0x801046e <finalize_cancel_locked+0xae> @ imm = #0x50
; 		if (wc->work == work) {
 801041c: 697b         	ldr	r3, [r7, #0x14]
 801041e: 685b         	ldr	r3, [r3, #0x4]
 8010420: 687a         	ldr	r2, [r7, #0x4]
 8010422: 429a         	cmp	r2, r3
 8010424: d10b         	bne	0x801043e <finalize_cancel_locked+0x7e> @ imm = #0x16
; 			sys_slist_remove(&pending_cancels, prev, &wc->node);
 8010426: 697b         	ldr	r3, [r7, #0x14]
 8010428: 461a         	mov	r2, r3
 801042a: 68f9         	ldr	r1, [r7, #0xc]
 801042c: 4814         	ldr	r0, [pc, #0x50]         @ 0x8010480 <finalize_cancel_locked+0xc0>
 801042e: f00e fa98    	bl	0x801e962 <sys_slist_remove> @ imm = #0xe530
; 			k_sem_give(&wc->sem);
 8010432: 697b         	ldr	r3, [r7, #0x14]
 8010434: 3308         	adds	r3, #0x8
 8010436: 4618         	mov	r0, r3
 8010438: f00e fb3d    	bl	0x801eab6 <k_sem_give>  @ imm = #0xe67a
; 			break;
 801043c: e01b         	b	0x8010476 <finalize_cancel_locked+0xb6> @ imm = #0x36
; 		prev = &wc->node;
 801043e: 697b         	ldr	r3, [r7, #0x14]
 8010440: 60fb         	str	r3, [r7, #0xc]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
 8010442: 693b         	ldr	r3, [r7, #0x10]
 8010444: 617b         	str	r3, [r7, #0x14]
 8010446: 697b         	ldr	r3, [r7, #0x14]
 8010448: 2b00         	cmp	r3, #0x0
 801044a: d00e         	beq	0x801046a <finalize_cancel_locked+0xaa> @ imm = #0x1c
 801044c: 697b         	ldr	r3, [r7, #0x14]
 801044e: 4618         	mov	r0, r3
 8010450: f00e fa17    	bl	0x801e882 <sys_slist_peek_next> @ imm = #0xe42e
 8010454: 4603         	mov	r3, r0
 8010456: 2b00         	cmp	r3, #0x0
 8010458: d005         	beq	0x8010466 <finalize_cancel_locked+0xa6> @ imm = #0xa
 801045a: 697b         	ldr	r3, [r7, #0x14]
 801045c: 4618         	mov	r0, r3
 801045e: f00e fa10    	bl	0x801e882 <sys_slist_peek_next> @ imm = #0xe420
 8010462: 4603         	mov	r3, r0
 8010464: e002         	b	0x801046c <finalize_cancel_locked+0xac> @ imm = #0x4
 8010466: 2300         	movs	r3, #0x0
 8010468: e000         	b	0x801046c <finalize_cancel_locked+0xac> @ imm = #0x0
 801046a: 2300         	movs	r3, #0x0
 801046c: 613b         	str	r3, [r7, #0x10]
 801046e: 697b         	ldr	r3, [r7, #0x14]
 8010470: 2b00         	cmp	r3, #0x0
 8010472: d1d3         	bne	0x801041c <finalize_cancel_locked+0x5c> @ imm = #-0x5a
; }
 8010474: bf00         	nop
 8010476: bf00         	nop
 8010478: 3718         	adds	r7, #0x18
 801047a: 46bd         	mov	sp, r7
 801047c: bd80         	pop	{r7, pc}
 801047e: bf00         	nop

08010480 <$d>:
 8010480: d8 27 00 20  	.word	0x200027d8

08010484 <queue_submit_locked>:
; {
 8010484: b580         	push	{r7, lr}
 8010486: b086         	sub	sp, #0x18
 8010488: af00         	add	r7, sp, #0x0
 801048a: 6078         	str	r0, [r7, #0x4]
 801048c: 6039         	str	r1, [r7]
; 	if (queue == NULL) {
 801048e: 687b         	ldr	r3, [r7, #0x4]
 8010490: 2b00         	cmp	r3, #0x0
 8010492: d102         	bne	0x801049a <queue_submit_locked+0x16> @ imm = #0x4
; 		return -EINVAL;
 8010494: f06f 0315    	mvn	r3, #0x15
 8010498: e061         	b	0x801055e <queue_submit_locked+0xda> @ imm = #0xc2
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801049a: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8010568 <queue_submit_locked+0xe4>
 801049c: 689b         	ldr	r3, [r3, #0x8]
 801049e: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 80104a0: 68fa         	ldr	r2, [r7, #0xc]
; 	bool chained = (arch_current_thread() == &queue->thread) && !k_is_in_isr();
 80104a2: 687b         	ldr	r3, [r7, #0x4]
 80104a4: 429a         	cmp	r2, r3
 80104a6: d109         	bne	0x80104bc <queue_submit_locked+0x38> @ imm = #0x12
 80104a8: f00e fd7c    	bl	0x801efa4 <k_is_in_isr> @ imm = #0xeaf8
 80104ac: 4603         	mov	r3, r0
 80104ae: f083 0301    	eor	r3, r3, #0x1
 80104b2: b2db         	uxtb	r3, r3
 80104b4: 2b00         	cmp	r3, #0x0
 80104b6: d001         	beq	0x80104bc <queue_submit_locked+0x38> @ imm = #0x2
 80104b8: 2301         	movs	r3, #0x1
 80104ba: e000         	b	0x80104be <queue_submit_locked+0x3a> @ imm = #0x0
 80104bc: 2300         	movs	r3, #0x0
 80104be: 74fb         	strb	r3, [r7, #0x13]
 80104c0: 7cfb         	ldrb	r3, [r7, #0x13]
 80104c2: f003 0301    	and	r3, r3, #0x1
 80104c6: 74fb         	strb	r3, [r7, #0x13]
; 	bool draining = flag_test(&queue->flags, K_WORK_QUEUE_DRAIN_BIT);
 80104c8: 687b         	ldr	r3, [r7, #0x4]
 80104ca: f503 7398    	add.w	r3, r3, #0x130
 80104ce: 2102         	movs	r1, #0x2
 80104d0: 4618         	mov	r0, r3
 80104d2: f00e fb54    	bl	0x801eb7e <flag_test>   @ imm = #0xe6a8
 80104d6: 4603         	mov	r3, r0
 80104d8: 74bb         	strb	r3, [r7, #0x12]
; 	bool plugged = flag_test(&queue->flags, K_WORK_QUEUE_PLUGGED_BIT);
 80104da: 687b         	ldr	r3, [r7, #0x4]
 80104dc: f503 7398    	add.w	r3, r3, #0x130
 80104e0: 2103         	movs	r1, #0x3
 80104e2: 4618         	mov	r0, r3
 80104e4: f00e fb4b    	bl	0x801eb7e <flag_test>   @ imm = #0xe696
 80104e8: 4603         	mov	r3, r0
 80104ea: 747b         	strb	r3, [r7, #0x11]
; 	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
 80104ec: 687b         	ldr	r3, [r7, #0x4]
 80104ee: f503 7398    	add.w	r3, r3, #0x130
 80104f2: 2100         	movs	r1, #0x0
 80104f4: 4618         	mov	r0, r3
 80104f6: f00e fb42    	bl	0x801eb7e <flag_test>   @ imm = #0xe684
 80104fa: 4603         	mov	r3, r0
 80104fc: f083 0301    	eor	r3, r3, #0x1
 8010500: b2db         	uxtb	r3, r3
 8010502: 2b00         	cmp	r3, #0x0
 8010504: d003         	beq	0x801050e <queue_submit_locked+0x8a> @ imm = #0x6
; 		ret = -ENODEV;
 8010506: f06f 0312    	mvn	r3, #0x12
 801050a: 617b         	str	r3, [r7, #0x14]
 801050c: e026         	b	0x801055c <queue_submit_locked+0xd8> @ imm = #0x4c
; 	} else if (draining && !chained) {
 801050e: 7cbb         	ldrb	r3, [r7, #0x12]
 8010510: 2b00         	cmp	r3, #0x0
 8010512: d009         	beq	0x8010528 <queue_submit_locked+0xa4> @ imm = #0x12
 8010514: 7cfb         	ldrb	r3, [r7, #0x13]
 8010516: f083 0301    	eor	r3, r3, #0x1
 801051a: b2db         	uxtb	r3, r3
 801051c: 2b00         	cmp	r3, #0x0
 801051e: d003         	beq	0x8010528 <queue_submit_locked+0xa4> @ imm = #0x6
; 		ret = -EBUSY;
 8010520: f06f 030f    	mvn	r3, #0xf
 8010524: 617b         	str	r3, [r7, #0x14]
 8010526: e019         	b	0x801055c <queue_submit_locked+0xd8> @ imm = #0x32
; 	} else if (plugged && !draining) {
 8010528: 7c7b         	ldrb	r3, [r7, #0x11]
 801052a: 2b00         	cmp	r3, #0x0
 801052c: d009         	beq	0x8010542 <queue_submit_locked+0xbe> @ imm = #0x12
 801052e: 7cbb         	ldrb	r3, [r7, #0x12]
 8010530: f083 0301    	eor	r3, r3, #0x1
 8010534: b2db         	uxtb	r3, r3
 8010536: 2b00         	cmp	r3, #0x0
 8010538: d003         	beq	0x8010542 <queue_submit_locked+0xbe> @ imm = #0x6
; 		ret = -EBUSY;
 801053a: f06f 030f    	mvn	r3, #0xf
 801053e: 617b         	str	r3, [r7, #0x14]
 8010540: e00c         	b	0x801055c <queue_submit_locked+0xd8> @ imm = #0x18
; 		sys_slist_append(&queue->pending, &work->node);
 8010542: 687b         	ldr	r3, [r7, #0x4]
 8010544: f503 738c    	add.w	r3, r3, #0x118
 8010548: 683a         	ldr	r2, [r7]
 801054a: 4611         	mov	r1, r2
 801054c: 4618         	mov	r0, r3
 801054e: f00e f9a9    	bl	0x801e8a4 <sys_slist_append> @ imm = #0xe352
; 		ret = 1;
 8010552: 2301         	movs	r3, #0x1
 8010554: 617b         	str	r3, [r7, #0x14]
; 		(void)notify_queue_locked(queue);
 8010556: 6878         	ldr	r0, [r7, #0x4]
 8010558: f00e fb97    	bl	0x801ec8a <notify_queue_locked> @ imm = #0xe72e
; 	return ret;
 801055c: 697b         	ldr	r3, [r7, #0x14]
; }
 801055e: 4618         	mov	r0, r3
 8010560: 3718         	adds	r7, #0x18
 8010562: 46bd         	mov	sp, r7
 8010564: bd80         	pop	{r7, pc}
 8010566: bf00         	nop

08010568 <$d>:
 8010568: 48 1d 00 20  	.word	0x20001d48

0801056c <work_queue_main>:
; {
 801056c: b580         	push	{r7, lr}
 801056e: b0a4         	sub	sp, #0x90
 8010570: af04         	add	r7, sp, #0x10
 8010572: 60f8         	str	r0, [r7, #0xc]
 8010574: 60b9         	str	r1, [r7, #0x8]
 8010576: 607a         	str	r2, [r7, #0x4]
; 	struct k_work_q *queue = (struct k_work_q *)workq_ptr;
 8010578: 68fb         	ldr	r3, [r7, #0xc]
 801057a: 677b         	str	r3, [r7, #0x74]
; 		struct k_work *work = NULL;
 801057c: 2300         	movs	r3, #0x0
 801057e: 67fb         	str	r3, [r7, #0x7c]
; 		k_work_handler_t handler = NULL;
 8010580: 2300         	movs	r3, #0x0
 8010582: 67bb         	str	r3, [r7, #0x78]
 8010584: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8010754 <work_queue_main+0x1e8>
 8010586: 66bb         	str	r3, [r7, #0x68]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010588: f3ef 8311    	mrs	r3, basepri
 801058c: 667b         	str	r3, [r7, #0x64]
;   return(result);
 801058e: 6e7b         	ldr	r3, [r7, #0x64]
; 	key = __get_BASEPRI();
 8010590: 663b         	str	r3, [r7, #0x60]
 8010592: 2310         	movs	r3, #0x10
 8010594: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010596: 6dfb         	ldr	r3, [r7, #0x5c]
 8010598: f383 8812    	msr	basepri_max, r3
; }
 801059c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801059e: f3bf 8f6f    	isb	sy
; }
 80105a2: bf00         	nop
; 	return key;
 80105a4: 6e3b         	ldr	r3, [r7, #0x60]
; 	k.key = arch_irq_lock();
 80105a6: 613b         	str	r3, [r7, #0x10]
 80105a8: 6ebb         	ldr	r3, [r7, #0x68]
 80105aa: 65bb         	str	r3, [r7, #0x58]
; }
 80105ac: bf00         	nop
 80105ae: 6ebb         	ldr	r3, [r7, #0x68]
 80105b0: 657b         	str	r3, [r7, #0x54]
; }
 80105b2: bf00         	nop
; 	return k;
 80105b4: 693b         	ldr	r3, [r7, #0x10]
 80105b6: 623b         	str	r3, [r7, #0x20]
; 		node = sys_slist_get(&queue->pending);
 80105b8: 6f7b         	ldr	r3, [r7, #0x74]
 80105ba: f503 738c    	add.w	r3, r3, #0x118
 80105be: 4618         	mov	r0, r3
 80105c0: f00e f9bb    	bl	0x801e93a <sys_slist_get> @ imm = #0xe376
 80105c4: 6738         	str	r0, [r7, #0x70]
; 		if (node != NULL) {
 80105c6: 6f3b         	ldr	r3, [r7, #0x70]
 80105c8: 2b00         	cmp	r3, #0x0
 80105ca: d018         	beq	0x80105fe <work_queue_main+0x92> @ imm = #0x30
; 			flag_set(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 80105cc: 6f7b         	ldr	r3, [r7, #0x74]
 80105ce: f503 7398    	add.w	r3, r3, #0x130
 80105d2: 2101         	movs	r1, #0x1
 80105d4: 4618         	mov	r0, r3
 80105d6: f00e fabe    	bl	0x801eb56 <flag_set>    @ imm = #0xe57c
; 			work = CONTAINER_OF(node, struct k_work, node);
 80105da: 6f3b         	ldr	r3, [r7, #0x70]
 80105dc: 67fb         	str	r3, [r7, #0x7c]
; 			flag_set(&work->flags, K_WORK_RUNNING_BIT);
 80105de: 6ffb         	ldr	r3, [r7, #0x7c]
 80105e0: 330c         	adds	r3, #0xc
 80105e2: 2100         	movs	r1, #0x0
 80105e4: 4618         	mov	r0, r3
 80105e6: f00e fab6    	bl	0x801eb56 <flag_set>    @ imm = #0xe56c
; 			flag_clear(&work->flags, K_WORK_QUEUED_BIT);
 80105ea: 6ffb         	ldr	r3, [r7, #0x7c]
 80105ec: 330c         	adds	r3, #0xc
 80105ee: 2102         	movs	r1, #0x2
 80105f0: 4618         	mov	r0, r3
 80105f2: f00e fa9b    	bl	0x801eb2c <flag_clear>  @ imm = #0xe536
; 			handler = work->handler;
 80105f6: 6ffb         	ldr	r3, [r7, #0x7c]
 80105f8: 685b         	ldr	r3, [r3, #0x4]
 80105fa: 67bb         	str	r3, [r7, #0x78]
 80105fc: e011         	b	0x8010622 <work_queue_main+0xb6> @ imm = #0x22
; 		} else if (flag_test_and_clear(&queue->flags, K_WORK_QUEUE_DRAIN_BIT)) {
 80105fe: 6f7b         	ldr	r3, [r7, #0x74]
 8010600: f503 7398    	add.w	r3, r3, #0x130
 8010604: 2102         	movs	r1, #0x2
 8010606: 4618         	mov	r0, r3
 8010608: f00e fad0    	bl	0x801ebac <flag_test_and_clear> @ imm = #0xe5a0
 801060c: 4603         	mov	r3, r0
 801060e: 2b00         	cmp	r3, #0x0
 8010610: d007         	beq	0x8010622 <work_queue_main+0xb6> @ imm = #0xe
; 			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
 8010612: 6f7b         	ldr	r3, [r7, #0x74]
 8010614: f503 7394    	add.w	r3, r3, #0x128
 8010618: 2200         	movs	r2, #0x0
 801061a: 2101         	movs	r1, #0x1
 801061c: 4618         	mov	r0, r3
 801061e: f00e fa6d    	bl	0x801eafc <z_sched_wake_all> @ imm = #0xe4da
; 		if (work == NULL) {
 8010622: 6ffb         	ldr	r3, [r7, #0x7c]
 8010624: 2b00         	cmp	r3, #0x0
 8010626: d111         	bne	0x801064c <work_queue_main+0xe0> @ imm = #0x22
; 			(void)z_sched_wait(&lock, key, &queue->notifyq, K_FOREVER, NULL);
 8010628: 6f7b         	ldr	r3, [r7, #0x74]
 801062a: f503 7190    	add.w	r1, r3, #0x120
 801062e: f04f 32ff    	mov.w	r2, #0xffffffff
 8010632: f04f 33ff    	mov.w	r3, #0xffffffff
 8010636: 2000         	movs	r0, #0x0
 8010638: 9002         	str	r0, [sp, #0x8]
 801063a: e9cd 2300    	strd	r2, r3, [sp]
 801063e: 460a         	mov	r2, r1
 8010640: 6a39         	ldr	r1, [r7, #0x20]
 8010642: 4844         	ldr	r0, [pc, #0x110]        @ 0x8010754 <work_queue_main+0x1e8>
 8010644: f001 ffdc    	bl	0x8012600 <z_sched_wait> @ imm = #0x1fb8
; 			continue;
 8010648: bf00         	nop
 801064a: e797         	b	0x801057c <work_queue_main+0x10> @ imm = #-0xd2
 801064c: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8010754 <work_queue_main+0x1e8>
 801064e: 63bb         	str	r3, [r7, #0x38]
 8010650: 6a3b         	ldr	r3, [r7, #0x20]
 8010652: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8010654: 69bb         	ldr	r3, [r7, #0x18]
 8010656: 637b         	str	r3, [r7, #0x34]
 8010658: 6b7b         	ldr	r3, [r7, #0x34]
 801065a: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801065c: 6b3b         	ldr	r3, [r7, #0x30]
 801065e: f383 8811    	msr	basepri, r3
; }
 8010662: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010664: f3bf 8f6f    	isb	sy
; }
 8010668: bf00         	nop
; }
 801066a: bf00         	nop
; }
 801066c: bf00         	nop
; 		handler(work);
 801066e: 6fbb         	ldr	r3, [r7, #0x78]
 8010670: 6ff8         	ldr	r0, [r7, #0x7c]
 8010672: 4798         	blx	r3
 8010674: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8010754 <work_queue_main+0x1e8>
 8010676: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010678: f3ef 8311    	mrs	r3, basepri
 801067c: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 801067e: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 8010680: 64bb         	str	r3, [r7, #0x48]
 8010682: 2310         	movs	r3, #0x10
 8010684: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010686: 6c7b         	ldr	r3, [r7, #0x44]
 8010688: f383 8812    	msr	basepri_max, r3
; }
 801068c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801068e: f3bf 8f6f    	isb	sy
; }
 8010692: bf00         	nop
; 	return key;
 8010694: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 8010696: 617b         	str	r3, [r7, #0x14]
 8010698: 6d3b         	ldr	r3, [r7, #0x50]
 801069a: 643b         	str	r3, [r7, #0x40]
; }
 801069c: bf00         	nop
 801069e: 6d3b         	ldr	r3, [r7, #0x50]
 80106a0: 63fb         	str	r3, [r7, #0x3c]
; }
 80106a2: bf00         	nop
; 	return k;
 80106a4: 697b         	ldr	r3, [r7, #0x14]
 80106a6: 623b         	str	r3, [r7, #0x20]
; 		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
 80106a8: 6ffb         	ldr	r3, [r7, #0x7c]
 80106aa: 330c         	adds	r3, #0xc
 80106ac: 2100         	movs	r1, #0x0
 80106ae: 4618         	mov	r0, r3
 80106b0: f00e fa3c    	bl	0x801eb2c <flag_clear>  @ imm = #0xe478
; 		if (flag_test(&work->flags, K_WORK_FLUSHING_BIT)) {
 80106b4: 6ffb         	ldr	r3, [r7, #0x7c]
 80106b6: 330c         	adds	r3, #0xc
 80106b8: 2104         	movs	r1, #0x4
 80106ba: 4618         	mov	r0, r3
 80106bc: f00e fa5f    	bl	0x801eb7e <flag_test>   @ imm = #0xe4be
 80106c0: 4603         	mov	r3, r0
 80106c2: 2b00         	cmp	r3, #0x0
 80106c4: d002         	beq	0x80106cc <work_queue_main+0x160> @ imm = #0x4
; 			finalize_flush_locked(work);
 80106c6: 6ff8         	ldr	r0, [r7, #0x7c]
 80106c8: f00e faa0    	bl	0x801ec0c <finalize_flush_locked> @ imm = #0xe540
; 		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 80106cc: 6ffb         	ldr	r3, [r7, #0x7c]
 80106ce: 330c         	adds	r3, #0xc
 80106d0: 2101         	movs	r1, #0x1
 80106d2: 4618         	mov	r0, r3
 80106d4: f00e fa53    	bl	0x801eb7e <flag_test>   @ imm = #0xe4a6
 80106d8: 4603         	mov	r3, r0
 80106da: 2b00         	cmp	r3, #0x0
 80106dc: d002         	beq	0x80106e4 <work_queue_main+0x178> @ imm = #0x4
; 			finalize_cancel_locked(work);
 80106de: 6ff8         	ldr	r0, [r7, #0x7c]
 80106e0: f7ff fe6e    	bl	0x80103c0 <finalize_cancel_locked> @ imm = #-0x324
; 		flag_clear(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
 80106e4: 6f7b         	ldr	r3, [r7, #0x74]
 80106e6: f503 7398    	add.w	r3, r3, #0x130
 80106ea: 2101         	movs	r1, #0x1
 80106ec: 4618         	mov	r0, r3
 80106ee: f00e fa1d    	bl	0x801eb2c <flag_clear>  @ imm = #0xe43a
; 		yield = !flag_test(&queue->flags, K_WORK_QUEUE_NO_YIELD_BIT);
 80106f2: 6f7b         	ldr	r3, [r7, #0x74]
 80106f4: f503 7398    	add.w	r3, r3, #0x130
 80106f8: 2108         	movs	r1, #0x8
 80106fa: 4618         	mov	r0, r3
 80106fc: f00e fa3f    	bl	0x801eb7e <flag_test>   @ imm = #0xe47e
 8010700: 4603         	mov	r3, r0
 8010702: 2b00         	cmp	r3, #0x0
 8010704: bf14         	ite	ne
 8010706: 2301         	movne	r3, #0x1
 8010708: 2300         	moveq	r3, #0x0
 801070a: b2db         	uxtb	r3, r3
 801070c: f083 0301    	eor	r3, r3, #0x1
 8010710: b2db         	uxtb	r3, r3
 8010712: f887 306f    	strb.w	r3, [r7, #0x6f]
 8010716: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 801071a: f003 0301    	and	r3, r3, #0x1
 801071e: f887 306f    	strb.w	r3, [r7, #0x6f]
 8010722: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8010754 <work_queue_main+0x1e8>
 8010724: 62fb         	str	r3, [r7, #0x2c]
 8010726: 6a3b         	ldr	r3, [r7, #0x20]
 8010728: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 801072a: 69fb         	ldr	r3, [r7, #0x1c]
 801072c: 62bb         	str	r3, [r7, #0x28]
 801072e: 6abb         	ldr	r3, [r7, #0x28]
 8010730: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010732: 6a7b         	ldr	r3, [r7, #0x24]
 8010734: f383 8811    	msr	basepri, r3
; }
 8010738: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801073a: f3bf 8f6f    	isb	sy
; }
 801073e: bf00         	nop
; }
 8010740: bf00         	nop
; }
 8010742: bf00         	nop
; 		if (yield) {
 8010744: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 8010748: 2b00         	cmp	r3, #0x0
 801074a: f43f af17    	beq.w	0x801057c <work_queue_main+0x10> @ imm = #-0x1d2
; 			k_yield();
 801074e: f00e f993    	bl	0x801ea78 <k_yield>     @ imm = #0xe326
; 	while (true) {
 8010752: e713         	b	0x801057c <work_queue_main+0x10> @ imm = #-0x1da

08010754 <$d>:
 8010754: d8 27 00 20  	.word	0x200027d8

08010758 <k_work_queue_start>:
; {
 8010758: b580         	push	{r7, lr}
 801075a: b08e         	sub	sp, #0x38
 801075c: af08         	add	r7, sp, #0x20
 801075e: 60f8         	str	r0, [r7, #0xc]
 8010760: 60b9         	str	r1, [r7, #0x8]
 8010762: 607a         	str	r2, [r7, #0x4]
 8010764: 603b         	str	r3, [r7]
; 	uint32_t flags = K_WORK_QUEUE_STARTED;
 8010766: 2301         	movs	r3, #0x1
 8010768: 617b         	str	r3, [r7, #0x14]
; 	sys_slist_init(&queue->pending);
 801076a: 68fb         	ldr	r3, [r7, #0xc]
 801076c: f503 738c    	add.w	r3, r3, #0x118
 8010770: 4618         	mov	r0, r3
 8010772: f00e f80b    	bl	0x801e78c <sys_slist_init> @ imm = #0xe016
; 	z_waitq_init(&queue->notifyq);
 8010776: 68fb         	ldr	r3, [r7, #0xc]
 8010778: f503 7390    	add.w	r3, r3, #0x120
 801077c: 4618         	mov	r0, r3
 801077e: f00e f9b1    	bl	0x801eae4 <z_waitq_init> @ imm = #0xe362
; 	z_waitq_init(&queue->drainq);
 8010782: 68fb         	ldr	r3, [r7, #0xc]
 8010784: f503 7394    	add.w	r3, r3, #0x128
 8010788: 4618         	mov	r0, r3
 801078a: f00e f9ab    	bl	0x801eae4 <z_waitq_init> @ imm = #0xe356
; 	if ((cfg != NULL) && cfg->no_yield) {
 801078e: 6a3b         	ldr	r3, [r7, #0x20]
 8010790: 2b00         	cmp	r3, #0x0
 8010792: d007         	beq	0x80107a4 <k_work_queue_start+0x4c> @ imm = #0xe
 8010794: 6a3b         	ldr	r3, [r7, #0x20]
 8010796: 791b         	ldrb	r3, [r3, #0x4]
 8010798: 2b00         	cmp	r3, #0x0
 801079a: d003         	beq	0x80107a4 <k_work_queue_start+0x4c> @ imm = #0x6
; 		flags |= K_WORK_QUEUE_NO_YIELD;
 801079c: 697b         	ldr	r3, [r7, #0x14]
 801079e: f443 7380    	orr	r3, r3, #0x100
 80107a2: 617b         	str	r3, [r7, #0x14]
; 	flags_set(&queue->flags, flags);
 80107a4: 68fb         	ldr	r3, [r7, #0xc]
 80107a6: f503 7398    	add.w	r3, r3, #0x130
 80107aa: 6979         	ldr	r1, [r7, #0x14]
 80107ac: 4618         	mov	r0, r3
 80107ae: f00e fa13    	bl	0x801ebd8 <flags_set>   @ imm = #0xe426
; 	(void)k_thread_create(&queue->thread, stack, stack_size, work_queue_main, queue, NULL, NULL,
 80107b2: 68f8         	ldr	r0, [r7, #0xc]
; 			      prio, 0, K_FOREVER);
 80107b4: f04f 32ff    	mov.w	r2, #0xffffffff
 80107b8: f04f 33ff    	mov.w	r3, #0xffffffff
; 	(void)k_thread_create(&queue->thread, stack, stack_size, work_queue_main, queue, NULL, NULL,
 80107bc: e9cd 2306    	strd	r2, r3, [sp, #24]
 80107c0: 2300         	movs	r3, #0x0
 80107c2: 9304         	str	r3, [sp, #0x10]
 80107c4: 683b         	ldr	r3, [r7]
 80107c6: 9303         	str	r3, [sp, #0xc]
 80107c8: 2300         	movs	r3, #0x0
 80107ca: 9302         	str	r3, [sp, #0x8]
 80107cc: 2300         	movs	r3, #0x0
 80107ce: 9301         	str	r3, [sp, #0x4]
 80107d0: 68fb         	ldr	r3, [r7, #0xc]
 80107d2: 9300         	str	r3, [sp]
 80107d4: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8010828 <k_work_queue_start+0xd0>
 80107d6: 687a         	ldr	r2, [r7, #0x4]
 80107d8: 68b9         	ldr	r1, [r7, #0x8]
 80107da: f00e f92d    	bl	0x801ea38 <k_thread_create> @ imm = #0xe25a
; 	if ((cfg != NULL) && (cfg->name != NULL)) {
 80107de: 6a3b         	ldr	r3, [r7, #0x20]
 80107e0: 2b00         	cmp	r3, #0x0
 80107e2: d00a         	beq	0x80107fa <k_work_queue_start+0xa2> @ imm = #0x14
 80107e4: 6a3b         	ldr	r3, [r7, #0x20]
 80107e6: 681b         	ldr	r3, [r3]
 80107e8: 2b00         	cmp	r3, #0x0
 80107ea: d006         	beq	0x80107fa <k_work_queue_start+0xa2> @ imm = #0xc
; 		k_thread_name_set(&queue->thread, cfg->name);
 80107ec: 68fa         	ldr	r2, [r7, #0xc]
 80107ee: 6a3b         	ldr	r3, [r7, #0x20]
 80107f0: 681b         	ldr	r3, [r3]
 80107f2: 4619         	mov	r1, r3
 80107f4: 4610         	mov	r0, r2
 80107f6: f00e f950    	bl	0x801ea9a <k_thread_name_set> @ imm = #0xe2a0
; 	if ((cfg != NULL) && (cfg->essential)) {
 80107fa: 6a3b         	ldr	r3, [r7, #0x20]
 80107fc: 2b00         	cmp	r3, #0x0
 80107fe: d00a         	beq	0x8010816 <k_work_queue_start+0xbe> @ imm = #0x14
 8010800: 6a3b         	ldr	r3, [r7, #0x20]
 8010802: 795b         	ldrb	r3, [r3, #0x5]
 8010804: 2b00         	cmp	r3, #0x0
 8010806: d006         	beq	0x8010816 <k_work_queue_start+0xbe> @ imm = #0xc
; 		queue->thread.base.user_options |= K_ESSENTIAL;
 8010808: 68fb         	ldr	r3, [r7, #0xc]
 801080a: 7b1b         	ldrb	r3, [r3, #0xc]
 801080c: f043 0301    	orr	r3, r3, #0x1
 8010810: b2da         	uxtb	r2, r3
 8010812: 68fb         	ldr	r3, [r7, #0xc]
 8010814: 731a         	strb	r2, [r3, #0xc]
; 	k_thread_start(&queue->thread);
 8010816: 68fb         	ldr	r3, [r7, #0xc]
 8010818: 4618         	mov	r0, r3
 801081a: f00e f902    	bl	0x801ea22 <k_thread_start> @ imm = #0xe204
; }
 801081e: bf00         	nop
 8010820: 3718         	adds	r7, #0x18
 8010822: 46bd         	mov	sp, r7
 8010824: bd80         	pop	{r7, pc}
 8010826: bf00         	nop

08010828 <$d>:
 8010828: 6d 05 01 08  	.word	0x0801056d

0801082c <work_timeout>:
; {
 801082c: b580         	push	{r7, lr}
 801082e: b092         	sub	sp, #0x48
 8010830: af00         	add	r7, sp, #0x0
 8010832: 6078         	str	r0, [r7, #0x4]
; 	struct k_work_delayable *dw = CONTAINER_OF(to, struct k_work_delayable, timeout);
 8010834: 687b         	ldr	r3, [r7, #0x4]
 8010836: 3b10         	subs	r3, #0x10
 8010838: 647b         	str	r3, [r7, #0x44]
; 	struct k_work *wp = &dw->work;
 801083a: 6c7b         	ldr	r3, [r7, #0x44]
 801083c: 643b         	str	r3, [r7, #0x40]
 801083e: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80108c4 <work_timeout+0x98>
 8010840: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010842: f3ef 8311    	mrs	r3, basepri
 8010846: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 8010848: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 801084a: 637b         	str	r3, [r7, #0x34]
 801084c: 2310         	movs	r3, #0x10
 801084e: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010850: 6b3b         	ldr	r3, [r7, #0x30]
 8010852: f383 8812    	msr	basepri_max, r3
; }
 8010856: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010858: f3bf 8f6f    	isb	sy
; }
 801085c: bf00         	nop
; 	return key;
 801085e: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 8010860: 60fb         	str	r3, [r7, #0xc]
 8010862: 6bfb         	ldr	r3, [r7, #0x3c]
 8010864: 62fb         	str	r3, [r7, #0x2c]
; }
 8010866: bf00         	nop
 8010868: 6bfb         	ldr	r3, [r7, #0x3c]
 801086a: 62bb         	str	r3, [r7, #0x28]
; }
 801086c: bf00         	nop
; 	return k;
 801086e: 68fb         	ldr	r3, [r7, #0xc]
 8010870: 61bb         	str	r3, [r7, #0x18]
; 	struct k_work_q *queue = NULL;
 8010872: 2300         	movs	r3, #0x0
 8010874: 617b         	str	r3, [r7, #0x14]
; 	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
 8010876: 6c3b         	ldr	r3, [r7, #0x40]
 8010878: 330c         	adds	r3, #0xc
 801087a: 2103         	movs	r1, #0x3
 801087c: 4618         	mov	r0, r3
 801087e: f00e f995    	bl	0x801ebac <flag_test_and_clear> @ imm = #0xe32a
 8010882: 4603         	mov	r3, r0
 8010884: 2b00         	cmp	r3, #0x0
 8010886: d008         	beq	0x801089a <work_timeout+0x6e> @ imm = #0x10
; 		queue = dw->queue;
 8010888: 6c7b         	ldr	r3, [r7, #0x44]
 801088a: 6a9b         	ldr	r3, [r3, #0x28]
 801088c: 617b         	str	r3, [r7, #0x14]
; 		(void)submit_to_queue_locked(wp, &queue);
 801088e: f107 0314    	add.w	r3, r7, #0x14
 8010892: 4619         	mov	r1, r3
 8010894: 6c38         	ldr	r0, [r7, #0x40]
 8010896: f00e fa10    	bl	0x801ecba <submit_to_queue_locked> @ imm = #0xe420
 801089a: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80108c4 <work_timeout+0x98>
 801089c: 627b         	str	r3, [r7, #0x24]
 801089e: 69bb         	ldr	r3, [r7, #0x18]
 80108a0: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 80108a2: 693b         	ldr	r3, [r7, #0x10]
 80108a4: 623b         	str	r3, [r7, #0x20]
 80108a6: 6a3b         	ldr	r3, [r7, #0x20]
 80108a8: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80108aa: 69fb         	ldr	r3, [r7, #0x1c]
 80108ac: f383 8811    	msr	basepri, r3
; }
 80108b0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80108b2: f3bf 8f6f    	isb	sy
; }
 80108b6: bf00         	nop
; }
 80108b8: bf00         	nop
; }
 80108ba: bf00         	nop
; }
 80108bc: bf00         	nop
 80108be: 3748         	adds	r7, #0x48
 80108c0: 46bd         	mov	sp, r7
 80108c2: bd80         	pop	{r7, pc}

080108c4 <$d>:
 80108c4: d8 27 00 20  	.word	0x200027d8

080108c8 <schedule_for_queue_locked>:
; {
 80108c8: b580         	push	{r7, lr}
 80108ca: b086         	sub	sp, #0x18
 80108cc: af00         	add	r7, sp, #0x0
 80108ce: 60f8         	str	r0, [r7, #0xc]
 80108d0: 60b9         	str	r1, [r7, #0x8]
 80108d2: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = 1;
 80108d6: 2301         	movs	r3, #0x1
 80108d8: 617b         	str	r3, [r7, #0x14]
; 	struct k_work *work = &dwork->work;
 80108da: 68bb         	ldr	r3, [r7, #0x8]
 80108dc: 613b         	str	r3, [r7, #0x10]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 80108de: e9d7 2300    	ldrd	r2, r3, [r7]
 80108e2: f04f 0000    	mov.w	r0, #0x0
 80108e6: f04f 0100    	mov.w	r1, #0x0
 80108ea: 428b         	cmp	r3, r1
 80108ec: bf08         	it	eq
 80108ee: 4282         	cmpeq	r2, r0
 80108f0: d105         	bne	0x80108fe <schedule_for_queue_locked+0x36> @ imm = #0xa
; 		return submit_to_queue_locked(work, queuep);
 80108f2: 68f9         	ldr	r1, [r7, #0xc]
 80108f4: 6938         	ldr	r0, [r7, #0x10]
 80108f6: f00e f9e0    	bl	0x801ecba <submit_to_queue_locked> @ imm = #0xe3c0
 80108fa: 4603         	mov	r3, r0
 80108fc: e012         	b	0x8010924 <schedule_for_queue_locked+0x5c> @ imm = #0x24
; 	flag_set(&work->flags, K_WORK_DELAYED_BIT);
 80108fe: 693b         	ldr	r3, [r7, #0x10]
 8010900: 330c         	adds	r3, #0xc
 8010902: 2103         	movs	r1, #0x3
 8010904: 4618         	mov	r0, r3
 8010906: f00e f926    	bl	0x801eb56 <flag_set>    @ imm = #0xe24c
; 	dwork->queue = *queuep;
 801090a: 68fb         	ldr	r3, [r7, #0xc]
 801090c: 681a         	ldr	r2, [r3]
 801090e: 68bb         	ldr	r3, [r7, #0x8]
 8010910: 629a         	str	r2, [r3, #0x28]
; 	z_add_timeout(&dwork->timeout, work_timeout, delay);
 8010912: 68bb         	ldr	r3, [r7, #0x8]
 8010914: f103 0010    	add.w	r0, r3, #0x10
 8010918: e9d7 2300    	ldrd	r2, r3, [r7]
 801091c: 4903         	ldr	r1, [pc, #0xc]          @ 0x801092c <schedule_for_queue_locked+0x64>
 801091e: f002 f87b    	bl	0x8012a18 <z_add_timeout> @ imm = #0x20f6
; 	return ret;
 8010922: 697b         	ldr	r3, [r7, #0x14]
; }
 8010924: 4618         	mov	r0, r3
 8010926: 3718         	adds	r7, #0x18
 8010928: 46bd         	mov	sp, r7
 801092a: bd80         	pop	{r7, pc}

0801092c <$d>:
 801092c: 2d 08 01 08  	.word	0x0801082d

08010930 <k_work_reschedule_for_queue>:
; {
 8010930: b580         	push	{r7, lr}
 8010932: b092         	sub	sp, #0x48
 8010934: af00         	add	r7, sp, #0x0
 8010936: 60f8         	str	r0, [r7, #0xc]
 8010938: 60b9         	str	r1, [r7, #0x8]
 801093a: e9c7 2300    	strd	r2, r3, [r7]
 801093e: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x80109b4 <k_work_reschedule_for_queue+0x84>
 8010940: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010942: f3ef 8311    	mrs	r3, basepri
 8010946: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8010948: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 801094a: 62fb         	str	r3, [r7, #0x2c]
 801094c: 2310         	movs	r3, #0x10
 801094e: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010950: 6abb         	ldr	r3, [r7, #0x28]
 8010952: f383 8812    	msr	basepri_max, r3
; }
 8010956: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010958: f3bf 8f6f    	isb	sy
; }
 801095c: bf00         	nop
; 	return key;
 801095e: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 8010960: 61bb         	str	r3, [r7, #0x18]
 8010962: 6b7b         	ldr	r3, [r7, #0x34]
 8010964: 627b         	str	r3, [r7, #0x24]
; }
 8010966: bf00         	nop
 8010968: 6b7b         	ldr	r3, [r7, #0x34]
 801096a: 623b         	str	r3, [r7, #0x20]
; }
 801096c: bf00         	nop
; 	return k;
 801096e: 69bb         	ldr	r3, [r7, #0x18]
 8010970: 61fb         	str	r3, [r7, #0x1c]
; 	(void)unschedule_locked(dwork);
 8010972: 68b8         	ldr	r0, [r7, #0x8]
 8010974: f00e fa44    	bl	0x801ee00 <unschedule_locked> @ imm = #0xe488
; 	ret = schedule_for_queue_locked(&queue, dwork, delay);
 8010978: f107 000c    	add.w	r0, r7, #0xc
 801097c: e9d7 2300    	ldrd	r2, r3, [r7]
 8010980: 68b9         	ldr	r1, [r7, #0x8]
 8010982: f7ff ffa1    	bl	0x80108c8 <schedule_for_queue_locked> @ imm = #-0xbe
 8010986: 6478         	str	r0, [r7, #0x44]
 8010988: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80109b4 <k_work_reschedule_for_queue+0x84>
 801098a: 643b         	str	r3, [r7, #0x40]
 801098c: 69fb         	ldr	r3, [r7, #0x1c]
 801098e: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 8010990: 697b         	ldr	r3, [r7, #0x14]
 8010992: 63fb         	str	r3, [r7, #0x3c]
 8010994: 6bfb         	ldr	r3, [r7, #0x3c]
 8010996: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010998: 6bbb         	ldr	r3, [r7, #0x38]
 801099a: f383 8811    	msr	basepri, r3
; }
 801099e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80109a0: f3bf 8f6f    	isb	sy
; }
 80109a4: bf00         	nop
; }
 80109a6: bf00         	nop
; }
 80109a8: bf00         	nop
; 	return ret;
 80109aa: 6c7b         	ldr	r3, [r7, #0x44]
; }
 80109ac: 4618         	mov	r0, r3
 80109ae: 3748         	adds	r7, #0x48
 80109b0: 46bd         	mov	sp, r7
 80109b2: bd80         	pop	{r7, pc}

080109b4 <$d>:
 80109b4: d8 27 00 20  	.word	0x200027d8

080109b8 <k_work_reschedule>:
; {
 80109b8: b580         	push	{r7, lr}
 80109ba: b086         	sub	sp, #0x18
 80109bc: af00         	add	r7, sp, #0x0
 80109be: 60f8         	str	r0, [r7, #0xc]
 80109c0: e9c7 2300    	strd	r2, r3, [r7]
; 	int ret = k_work_reschedule_for_queue(&k_sys_work_q, dwork, delay);
 80109c4: e9d7 2300    	ldrd	r2, r3, [r7]
 80109c8: 68f9         	ldr	r1, [r7, #0xc]
 80109ca: 4804         	ldr	r0, [pc, #0x10]         @ 0x80109dc <k_work_reschedule+0x24>
 80109cc: f7ff ffb0    	bl	0x8010930 <k_work_reschedule_for_queue> @ imm = #-0xa0
 80109d0: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 80109d2: 697b         	ldr	r3, [r7, #0x14]
; }
 80109d4: 4618         	mov	r0, r3
 80109d6: 3718         	adds	r7, #0x18
 80109d8: 46bd         	mov	sp, r7
 80109da: bd80         	pop	{r7, pc}

080109dc <$d>:
 80109dc: f8 20 00 20  	.word	0x200020f8

080109e0 <k_work_cancel_delayable>:
; {
 80109e0: b580         	push	{r7, lr}
 80109e2: b090         	sub	sp, #0x40
 80109e4: af00         	add	r7, sp, #0x0
 80109e6: 6078         	str	r0, [r7, #0x4]
 80109e8: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8010a50 <k_work_cancel_delayable+0x70>
 80109ea: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80109ec: f3ef 8311    	mrs	r3, basepri
 80109f0: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 80109f2: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 80109f4: 627b         	str	r3, [r7, #0x24]
 80109f6: 2310         	movs	r3, #0x10
 80109f8: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80109fa: 6a3b         	ldr	r3, [r7, #0x20]
 80109fc: f383 8812    	msr	basepri_max, r3
; }
 8010a00: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010a02: f3bf 8f6f    	isb	sy
; }
 8010a06: bf00         	nop
; 	return key;
 8010a08: 6a7b         	ldr	r3, [r7, #0x24]
; 	k.key = arch_irq_lock();
 8010a0a: 613b         	str	r3, [r7, #0x10]
 8010a0c: 6afb         	ldr	r3, [r7, #0x2c]
 8010a0e: 61fb         	str	r3, [r7, #0x1c]
; }
 8010a10: bf00         	nop
 8010a12: 6afb         	ldr	r3, [r7, #0x2c]
 8010a14: 61bb         	str	r3, [r7, #0x18]
; }
 8010a16: bf00         	nop
; 	return k;
 8010a18: 693b         	ldr	r3, [r7, #0x10]
 8010a1a: 617b         	str	r3, [r7, #0x14]
; 	int ret = cancel_delayable_async_locked(dwork);
 8010a1c: 6878         	ldr	r0, [r7, #0x4]
 8010a1e: f00e fa10    	bl	0x801ee42 <cancel_delayable_async_locked> @ imm = #0xe420
 8010a22: 63f8         	str	r0, [r7, #0x3c]
 8010a24: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8010a50 <k_work_cancel_delayable+0x70>
 8010a26: 63bb         	str	r3, [r7, #0x38]
 8010a28: 697b         	ldr	r3, [r7, #0x14]
 8010a2a: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8010a2c: 68fb         	ldr	r3, [r7, #0xc]
 8010a2e: 637b         	str	r3, [r7, #0x34]
 8010a30: 6b7b         	ldr	r3, [r7, #0x34]
 8010a32: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010a34: 6b3b         	ldr	r3, [r7, #0x30]
 8010a36: f383 8811    	msr	basepri, r3
; }
 8010a3a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010a3c: f3bf 8f6f    	isb	sy
; }
 8010a40: bf00         	nop
; }
 8010a42: bf00         	nop
; }
 8010a44: bf00         	nop
; 	return ret;
 8010a46: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 8010a48: 4618         	mov	r0, r3
 8010a4a: 3740         	adds	r7, #0x40
 8010a4c: 46bd         	mov	sp, r7
 8010a4e: bd80         	pop	{r7, pc}

08010a50 <$d>:
 8010a50: d8 27 00 20  	.word	0x200027d8

08010a54 <z_add_thread_timeout>:
; {
 8010a54: b580         	push	{r7, lr}
 8010a56: b084         	sub	sp, #0x10
 8010a58: af00         	add	r7, sp, #0x0
 8010a5a: 60f8         	str	r0, [r7, #0xc]
 8010a5c: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 8010a60: 68fb         	ldr	r3, [r7, #0xc]
 8010a62: f103 0018    	add.w	r0, r3, #0x18
 8010a66: e9d7 2300    	ldrd	r2, r3, [r7]
 8010a6a: 4903         	ldr	r1, [pc, #0xc]          @ 0x8010a78 <z_add_thread_timeout+0x24>
 8010a6c: f001 ffd4    	bl	0x8012a18 <z_add_timeout> @ imm = #0x1fa8
; }
 8010a70: bf00         	nop
 8010a72: 3710         	adds	r7, #0x10
 8010a74: 46bd         	mov	sp, r7
 8010a76: bd80         	pop	{r7, pc}

08010a78 <$d>:
 8010a78: 37 f7 01 08  	.word	0x0801f737

08010a7c <z_impl_k_thread_name_set>:
; {
 8010a7c: b580         	push	{r7, lr}
 8010a7e: b084         	sub	sp, #0x10
 8010a80: af00         	add	r7, sp, #0x0
 8010a82: 6078         	str	r0, [r7, #0x4]
 8010a84: 6039         	str	r1, [r7]
; 	if (thread == NULL) {
 8010a86: 687b         	ldr	r3, [r7, #0x4]
 8010a88: 2b00         	cmp	r3, #0x0
 8010a8a: d104         	bne	0x8010a96 <z_impl_k_thread_name_set+0x1a> @ imm = #0x8
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010a8c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8010ab8 <z_impl_k_thread_name_set+0x3c>
 8010a8e: 689b         	ldr	r3, [r3, #0x8]
 8010a90: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8010a92: 68fb         	ldr	r3, [r7, #0xc]
; 		thread = arch_current_thread();
 8010a94: 607b         	str	r3, [r7, #0x4]
; 	strncpy(thread->name, str, CONFIG_THREAD_MAX_NAME_LEN - 1);
 8010a96: 687b         	ldr	r3, [r7, #0x4]
 8010a98: 3394         	adds	r3, #0x94
 8010a9a: 221f         	movs	r2, #0x1f
 8010a9c: 6839         	ldr	r1, [r7]
 8010a9e: 4618         	mov	r0, r3
 8010aa0: f00f f922    	bl	0x801fce8 <strncpy>     @ imm = #0xf244
; 	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 8010aa4: 687b         	ldr	r3, [r7, #0x4]
 8010aa6: 2200         	movs	r2, #0x0
 8010aa8: f883 20b3    	strb.w	r2, [r3, #0xb3]
; 	return 0;
 8010aac: 2300         	movs	r3, #0x0
; }
 8010aae: 4618         	mov	r0, r3
 8010ab0: 3710         	adds	r7, #0x10
 8010ab2: 46bd         	mov	sp, r7
 8010ab4: bd80         	pop	{r7, pc}
 8010ab6: bf00         	nop

08010ab8 <$d>:
 8010ab8: 48 1d 00 20  	.word	0x20001d48

08010abc <setup_thread_stack>:
; {
 8010abc: b580         	push	{r7, lr}
 8010abe: b096         	sub	sp, #0x58
 8010ac0: af0a         	add	r7, sp, #0x28
 8010ac2: 60f8         	str	r0, [r7, #0xc]
 8010ac4: 60b9         	str	r1, [r7, #0x8]
 8010ac6: 607a         	str	r2, [r7, #0x4]
; 	size_t delta = 0;
 8010ac8: 2300         	movs	r3, #0x0
 8010aca: 62fb         	str	r3, [r7, #0x2c]
; 		stack_obj_size = K_KERNEL_STACK_LEN(stack_size);
 8010acc: 687b         	ldr	r3, [r7, #0x4]
 8010ace: 3307         	adds	r3, #0x7
 8010ad0: f023 0307    	bic	r3, r3, #0x7
 8010ad4: 3307         	adds	r3, #0x7
 8010ad6: f023 0307    	bic	r3, r3, #0x7
 8010ada: 62bb         	str	r3, [r7, #0x28]
; 		stack_buf_start = K_KERNEL_STACK_BUFFER(stack);
 8010adc: 68b8         	ldr	r0, [r7, #0x8]
 8010ade: f00e f9e0    	bl	0x801eea2 <K_KERNEL_STACK_BUFFER> @ imm = #0xe3c0
 8010ae2: 6278         	str	r0, [r7, #0x24]
; 		stack_buf_size = stack_obj_size - K_KERNEL_STACK_RESERVED;
 8010ae4: 6abb         	ldr	r3, [r7, #0x28]
 8010ae6: 623b         	str	r3, [r7, #0x20]
; 	stack_ptr = (char *)stack + stack_obj_size;
 8010ae8: 68ba         	ldr	r2, [r7, #0x8]
 8010aea: 6abb         	ldr	r3, [r7, #0x28]
 8010aec: 4413         	add	r3, r2
 8010aee: 61fb         	str	r3, [r7, #0x1c]
; 	LOG_DBG("stack %p for thread %p: obj_size=%zu buf_start=%p "
 8010af0: 2303         	movs	r3, #0x3
 8010af2: 2b03         	cmp	r3, #0x3
 8010af4: d924         	bls	0x8010b40 <setup_thread_stack+0x84> @ imm = #0x48
 8010af6: 2301         	movs	r3, #0x1
 8010af8: 76fb         	strb	r3, [r7, #0x1b]
 8010afa: 7efb         	ldrb	r3, [r7, #0x1b]
 8010afc: f083 0301    	eor	r3, r3, #0x1
 8010b00: b2db         	uxtb	r3, r3
 8010b02: 2b00         	cmp	r3, #0x0
 8010b04: d11c         	bne	0x8010b40 <setup_thread_stack+0x84> @ imm = #0x38
 8010b06: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8010b90 <setup_thread_stack+0xd4>
 8010b08: 6819         	ldr	r1, [r3]
 8010b0a: 69fb         	ldr	r3, [r7, #0x1c]
 8010b0c: 9309         	str	r3, [sp, #0x24]
 8010b0e: 6a3b         	ldr	r3, [r7, #0x20]
 8010b10: 9308         	str	r3, [sp, #0x20]
 8010b12: 6a7b         	ldr	r3, [r7, #0x24]
 8010b14: 9307         	str	r3, [sp, #0x1c]
 8010b16: 6abb         	ldr	r3, [r7, #0x28]
 8010b18: 9306         	str	r3, [sp, #0x18]
 8010b1a: 68fb         	ldr	r3, [r7, #0xc]
 8010b1c: 9305         	str	r3, [sp, #0x14]
 8010b1e: 68bb         	ldr	r3, [r7, #0x8]
 8010b20: 9304         	str	r3, [sp, #0x10]
 8010b22: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8010b94 <setup_thread_stack+0xd8>
 8010b24: 9303         	str	r3, [sp, #0xc]
 8010b26: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8010b98 <setup_thread_stack+0xdc>
 8010b28: 9302         	str	r3, [sp, #0x8]
 8010b2a: 2308         	movs	r3, #0x8
 8010b2c: 9301         	str	r3, [sp, #0x4]
 8010b2e: 2300         	movs	r3, #0x0
 8010b30: 9300         	str	r3, [sp]
 8010b32: 2300         	movs	r3, #0x0
 8010b34: 2204         	movs	r2, #0x4
 8010b36: 2000         	movs	r0, #0x0
 8010b38: f00e fa16    	bl	0x801ef68 <z_log_msg_runtime_create> @ imm = #0xe42c
 8010b3c: 2300         	movs	r3, #0x0
 8010b3e: 617b         	str	r3, [r7, #0x14]
; 	memset(stack_buf_start, 0xaa, stack_buf_size);
 8010b40: 6a3a         	ldr	r2, [r7, #0x20]
 8010b42: 21aa         	movs	r1, #0xaa
 8010b44: 6a78         	ldr	r0, [r7, #0x24]
 8010b46: f00f f8c7    	bl	0x801fcd8 <memset>      @ imm = #0xf18e
; 	delta += arch_tls_stack_setup(new_thread, stack_ptr);
 8010b4a: 69f9         	ldr	r1, [r7, #0x1c]
 8010b4c: 68f8         	ldr	r0, [r7, #0xc]
 8010b4e: f006 fe2b    	bl	0x80177a8 <arch_tls_stack_setup> @ imm = #0x6c56
 8010b52: 4602         	mov	r2, r0
 8010b54: 6afb         	ldr	r3, [r7, #0x2c]
 8010b56: 4413         	add	r3, r2
 8010b58: 62fb         	str	r3, [r7, #0x2c]
; 	delta = ROUND_UP(delta, ARCH_STACK_PTR_ALIGN);
 8010b5a: 6afb         	ldr	r3, [r7, #0x2c]
 8010b5c: 3307         	adds	r3, #0x7
 8010b5e: f023 0307    	bic	r3, r3, #0x7
 8010b62: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
 8010b64: 6a7a         	ldr	r2, [r7, #0x24]
 8010b66: 68fb         	ldr	r3, [r7, #0xc]
 8010b68: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	new_thread->stack_info.size = stack_buf_size;
 8010b6c: 68fb         	ldr	r3, [r7, #0xc]
 8010b6e: 6a3a         	ldr	r2, [r7, #0x20]
 8010b70: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	new_thread->stack_info.delta = delta;
 8010b74: 68fb         	ldr	r3, [r7, #0xc]
 8010b76: 6afa         	ldr	r2, [r7, #0x2c]
 8010b78: f8c3 20bc    	str.w	r2, [r3, #0xbc]
; 	stack_ptr -= delta;
 8010b7c: 6afb         	ldr	r3, [r7, #0x2c]
 8010b7e: 425b         	rsbs	r3, r3, #0
 8010b80: 69fa         	ldr	r2, [r7, #0x1c]
 8010b82: 4413         	add	r3, r2
 8010b84: 61fb         	str	r3, [r7, #0x1c]
; 	return stack_ptr;
 8010b86: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8010b88: 4618         	mov	r0, r3
 8010b8a: 3730         	adds	r7, #0x30
 8010b8c: 46bd         	mov	sp, r7
 8010b8e: bd80         	pop	{r7, pc}

08010b90 <$d>:
 8010b90: 10 06 00 20  	.word	0x20000610
 8010b94: dc 2e 02 08  	.word	0x08022edc
 8010b98: 98 21 02 08  	.word	0x08022198

08010b9c <z_setup_new_thread>:
; {
 8010b9c: b580         	push	{r7, lr}
 8010b9e: b09c         	sub	sp, #0x70
 8010ba0: af04         	add	r7, sp, #0x10
 8010ba2: 60f8         	str	r0, [r7, #0xc]
 8010ba4: 60b9         	str	r1, [r7, #0x8]
 8010ba6: 607a         	str	r2, [r7, #0x4]
 8010ba8: 603b         	str	r3, [r7]
; 	z_waitq_init(&new_thread->join_queue);
 8010baa: 68fb         	ldr	r3, [r7, #0xc]
 8010bac: 3368         	adds	r3, #0x68
 8010bae: 4618         	mov	r0, r3
 8010bb0: f00e f9ce    	bl	0x801ef50 <z_waitq_init> @ imm = #0xe39c
; 	z_init_thread_base(&new_thread->base, prio, _THREAD_SUSPENDED, options);
 8010bb4: 68f8         	ldr	r0, [r7, #0xc]
 8010bb6: 6fbb         	ldr	r3, [r7, #0x78]
 8010bb8: 2210         	movs	r2, #0x10
 8010bba: 6f79         	ldr	r1, [r7, #0x74]
 8010bbc: f00e fa3d    	bl	0x801f03a <z_init_thread_base> @ imm = #0xe47a
; 	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
 8010bc0: 687a         	ldr	r2, [r7, #0x4]
 8010bc2: 68b9         	ldr	r1, [r7, #0x8]
 8010bc4: 68f8         	ldr	r0, [r7, #0xc]
 8010bc6: f7ff ff79    	bl	0x8010abc <setup_thread_stack> @ imm = #-0x10e
 8010bca: 65f8         	str	r0, [r7, #0x5c]
; 	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 8010bcc: 6f3b         	ldr	r3, [r7, #0x70]
 8010bce: 9302         	str	r3, [sp, #0x8]
 8010bd0: 6efb         	ldr	r3, [r7, #0x6c]
 8010bd2: 9301         	str	r3, [sp, #0x4]
 8010bd4: 6ebb         	ldr	r3, [r7, #0x68]
 8010bd6: 9300         	str	r3, [sp]
 8010bd8: 683b         	ldr	r3, [r7]
 8010bda: 6dfa         	ldr	r2, [r7, #0x5c]
 8010bdc: 68b9         	ldr	r1, [r7, #0x8]
 8010bde: 68f8         	ldr	r0, [r7, #0xc]
 8010be0: f7f6 fa4e    	bl	0x8007080 <arch_new_thread> @ imm = #-0x9b64
; 	new_thread->init_data = NULL;
 8010be4: 68fb         	ldr	r3, [r7, #0xc]
 8010be6: 2200         	movs	r2, #0x0
 8010be8: 665a         	str	r2, [r3, #0x64]
; 	new_thread->no_wake_on_timeout = false;
 8010bea: 68fb         	ldr	r3, [r7, #0xc]
 8010bec: 2200         	movs	r2, #0x0
 8010bee: f883 207c    	strb.w	r2, [r3, #0x7c]
; 	new_thread->entry.pEntry = entry;
 8010bf2: 68fb         	ldr	r3, [r7, #0xc]
 8010bf4: 683a         	ldr	r2, [r7]
 8010bf6: f8c3 2080    	str.w	r2, [r3, #0x80]
; 	new_thread->entry.parameter1 = p1;
 8010bfa: 68fb         	ldr	r3, [r7, #0xc]
 8010bfc: 6eba         	ldr	r2, [r7, #0x68]
 8010bfe: f8c3 2084    	str.w	r2, [r3, #0x84]
; 	new_thread->entry.parameter2 = p2;
 8010c02: 68fb         	ldr	r3, [r7, #0xc]
 8010c04: 6efa         	ldr	r2, [r7, #0x6c]
 8010c06: f8c3 2088    	str.w	r2, [r3, #0x88]
; 	new_thread->entry.parameter3 = p3;
 8010c0a: 68fb         	ldr	r3, [r7, #0xc]
 8010c0c: 6f3a         	ldr	r2, [r7, #0x70]
 8010c0e: f8c3 208c    	str.w	r2, [r3, #0x8c]
 8010c12: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8010ce8 <z_setup_new_thread+0x14c>
 8010c14: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8010c16: f3ef 8311    	mrs	r3, basepri
 8010c1a: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 8010c1c: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 8010c1e: 647b         	str	r3, [r7, #0x44]
 8010c20: 2310         	movs	r3, #0x10
 8010c22: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8010c24: 6c3b         	ldr	r3, [r7, #0x40]
 8010c26: f383 8812    	msr	basepri_max, r3
; }
 8010c2a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010c2c: f3bf 8f6f    	isb	sy
; }
 8010c30: bf00         	nop
; 	return key;
 8010c32: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 8010c34: 617b         	str	r3, [r7, #0x14]
 8010c36: 6cfb         	ldr	r3, [r7, #0x4c]
 8010c38: 63fb         	str	r3, [r7, #0x3c]
; }
 8010c3a: bf00         	nop
 8010c3c: 6cfb         	ldr	r3, [r7, #0x4c]
 8010c3e: 63bb         	str	r3, [r7, #0x38]
; }
 8010c40: bf00         	nop
; 	return k;
 8010c42: 697b         	ldr	r3, [r7, #0x14]
 8010c44: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->next_thread = _kernel.threads;
 8010c46: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8010cec <z_setup_new_thread+0x150>
 8010c48: 6b1a         	ldr	r2, [r3, #0x30]
 8010c4a: 68fb         	ldr	r3, [r7, #0xc]
 8010c4c: f8c3 2090    	str.w	r2, [r3, #0x90]
; 	_kernel.threads = new_thread;
 8010c50: 4a26         	ldr	r2, [pc, #0x98]         @ 0x8010cec <z_setup_new_thread+0x150>
 8010c52: 68fb         	ldr	r3, [r7, #0xc]
 8010c54: 6313         	str	r3, [r2, #0x30]
 8010c56: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8010ce8 <z_setup_new_thread+0x14c>
 8010c58: 65bb         	str	r3, [r7, #0x58]
 8010c5a: 6afb         	ldr	r3, [r7, #0x2c]
 8010c5c: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8010c5e: 693b         	ldr	r3, [r7, #0x10]
 8010c60: 657b         	str	r3, [r7, #0x54]
 8010c62: 6d7b         	ldr	r3, [r7, #0x54]
 8010c64: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8010c66: 6d3b         	ldr	r3, [r7, #0x50]
 8010c68: f383 8811    	msr	basepri, r3
; }
 8010c6c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8010c6e: f3bf 8f6f    	isb	sy
; }
 8010c72: bf00         	nop
; }
 8010c74: bf00         	nop
; }
 8010c76: bf00         	nop
; 	if (name != NULL) {
 8010c78: 6ffb         	ldr	r3, [r7, #0x7c]
 8010c7a: 2b00         	cmp	r3, #0x0
 8010c7c: d00b         	beq	0x8010c96 <z_setup_new_thread+0xfa> @ imm = #0x16
; 		strncpy(new_thread->name, name,
 8010c7e: 68fb         	ldr	r3, [r7, #0xc]
 8010c80: 3394         	adds	r3, #0x94
 8010c82: 221f         	movs	r2, #0x1f
 8010c84: 6ff9         	ldr	r1, [r7, #0x7c]
 8010c86: 4618         	mov	r0, r3
 8010c88: f00f f82e    	bl	0x801fce8 <strncpy>     @ imm = #0xf05c
; 		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 8010c8c: 68fb         	ldr	r3, [r7, #0xc]
 8010c8e: 2200         	movs	r2, #0x0
 8010c90: f883 20b3    	strb.w	r2, [r3, #0xb3]
 8010c94: e003         	b	0x8010c9e <z_setup_new_thread+0x102> @ imm = #0x6
; 		new_thread->name[0] = '\0';
 8010c96: 68fb         	ldr	r3, [r7, #0xc]
 8010c98: 2200         	movs	r2, #0x0
 8010c9a: f883 2094    	strb.w	r2, [r3, #0x94]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010c9e: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8010cec <z_setup_new_thread+0x150>
 8010ca0: 689b         	ldr	r3, [r3, #0x8]
 8010ca2: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 8010ca4: 6b7b         	ldr	r3, [r7, #0x34]
; 	if (!arch_current_thread()) {
 8010ca6: 2b00         	cmp	r3, #0x0
 8010ca8: d105         	bne	0x8010cb6 <z_setup_new_thread+0x11a> @ imm = #0xa
; 		new_thread->resource_pool = NULL;
 8010caa: 68fb         	ldr	r3, [r7, #0xc]
 8010cac: 2200         	movs	r2, #0x0
 8010cae: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 		return stack_ptr;
 8010cb2: 6dfb         	ldr	r3, [r7, #0x5c]
 8010cb4: e014         	b	0x8010ce0 <z_setup_new_thread+0x144> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010cb6: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8010cec <z_setup_new_thread+0x150>
 8010cb8: 689b         	ldr	r3, [r3, #0x8]
 8010cba: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 8010cbc: 6b3b         	ldr	r3, [r7, #0x30]
; 	new_thread->resource_pool = arch_current_thread()->resource_pool;
 8010cbe: f8d3 20c0    	ldr.w	r2, [r3, #0xc0]
 8010cc2: 68fb         	ldr	r3, [r7, #0xc]
 8010cc4: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 	new_thread->base.usage = (struct k_cycle_stats) {};
 8010cc8: 68fb         	ldr	r3, [r7, #0xc]
 8010cca: 3330         	adds	r3, #0x30
 8010ccc: 2200         	movs	r2, #0x0
 8010cce: 601a         	str	r2, [r3]
 8010cd0: 605a         	str	r2, [r3, #0x4]
 8010cd2: 609a         	str	r2, [r3, #0x8]
 8010cd4: 60da         	str	r2, [r3, #0xc]
; 	new_thread->base.usage.track_usage =
 8010cd6: 68fb         	ldr	r3, [r7, #0xc]
 8010cd8: 2201         	movs	r2, #0x1
 8010cda: f883 2038    	strb.w	r2, [r3, #0x38]
; 	return stack_ptr;
 8010cde: 6dfb         	ldr	r3, [r7, #0x5c]
; }
 8010ce0: 4618         	mov	r0, r3
 8010ce2: 3760         	adds	r7, #0x60
 8010ce4: 46bd         	mov	sp, r7
 8010ce6: bd80         	pop	{r7, pc}

08010ce8 <$d>:
 8010ce8: f0 27 00 20  	.word	0x200027f0
 8010cec: 48 1d 00 20  	.word	0x20001d48

08010cf0 <z_thread_mark_switched_in>:
; {
 8010cf0: b580         	push	{r7, lr}
 8010cf2: b082         	sub	sp, #0x8
 8010cf4: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010cf6: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8010d0c <z_thread_mark_switched_in+0x1c>
 8010cf8: 689b         	ldr	r3, [r3, #0x8]
 8010cfa: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 8010cfc: 687b         	ldr	r3, [r7, #0x4]
; 	z_sched_usage_start(arch_current_thread());
 8010cfe: 4618         	mov	r0, r3
 8010d00: f002 f916    	bl	0x8012f30 <z_sched_usage_start> @ imm = #0x222c
; }
 8010d04: bf00         	nop
 8010d06: 3708         	adds	r7, #0x8
 8010d08: 46bd         	mov	sp, r7
 8010d0a: bd80         	pop	{r7, pc}

08010d0c <$d>:
 8010d0c: 48 1d 00 20  	.word	0x20001d48

08010d10 <z_add_thread_timeout>:
; {
 8010d10: b580         	push	{r7, lr}
 8010d12: b084         	sub	sp, #0x10
 8010d14: af00         	add	r7, sp, #0x0
 8010d16: 60f8         	str	r0, [r7, #0xc]
 8010d18: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 8010d1c: 68fb         	ldr	r3, [r7, #0xc]
 8010d1e: f103 0018    	add.w	r0, r3, #0x18
 8010d22: e9d7 2300    	ldrd	r2, r3, [r7]
 8010d26: 4903         	ldr	r1, [pc, #0xc]          @ 0x8010d34 <z_add_thread_timeout+0x24>
 8010d28: f001 fe76    	bl	0x8012a18 <z_add_timeout> @ imm = #0x1cec
; }
 8010d2c: bf00         	nop
 8010d2e: 3710         	adds	r7, #0x10
 8010d30: 46bd         	mov	sp, r7
 8010d32: bd80         	pop	{r7, pc}

08010d34 <$d>:
 8010d34: 37 f7 01 08  	.word	0x0801f737

08010d38 <z_sched_lock>:
; {
 8010d38: b480         	push	{r7}
 8010d3a: b083         	sub	sp, #0xc
 8010d3c: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010d3e: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8010d5c <z_sched_lock+0x24>
 8010d40: 689b         	ldr	r3, [r3, #0x8]
 8010d42: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 8010d44: 687b         	ldr	r3, [r7, #0x4]
; 	--arch_current_thread()->base.sched_locked;
 8010d46: 7bda         	ldrb	r2, [r3, #0xf]
 8010d48: 3a01         	subs	r2, #0x1
 8010d4a: b2d2         	uxtb	r2, r2
 8010d4c: 73da         	strb	r2, [r3, #0xf]
; }
 8010d4e: bf00         	nop
 8010d50: 370c         	adds	r7, #0xc
 8010d52: 46bd         	mov	sp, r7
 8010d54: f85d 7b04    	ldr	r7, [sp], #4
 8010d58: 4770         	bx	lr
 8010d5a: bf00         	nop

08010d5c <$d>:
 8010d5c: 48 1d 00 20  	.word	0x20001d48

08010d60 <z_dummy_thread_init>:
; {
 8010d60: b480         	push	{r7}
 8010d62: b085         	sub	sp, #0x14
 8010d64: af00         	add	r7, sp, #0x0
 8010d66: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 8010d68: 687b         	ldr	r3, [r7, #0x4]
 8010d6a: 2201         	movs	r2, #0x1
 8010d6c: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 8010d6e: 687b         	ldr	r3, [r7, #0x4]
 8010d70: 2201         	movs	r2, #0x1
 8010d72: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 8010d74: 687b         	ldr	r3, [r7, #0x4]
 8010d76: 2200         	movs	r2, #0x0
 8010d78: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 8010d7c: 687b         	ldr	r3, [r7, #0x4]
 8010d7e: 2200         	movs	r2, #0x0
 8010d80: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	dummy_thread->resource_pool = NULL;
 8010d84: 687b         	ldr	r3, [r7, #0x4]
 8010d86: 2200         	movs	r2, #0x0
 8010d88: f8c3 20c0    	str.w	r2, [r3, #0xc0]
 8010d8c: 687b         	ldr	r3, [r7, #0x4]
 8010d8e: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 8010d90: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8010da4 <z_dummy_thread_init+0x44>
 8010d92: 68fb         	ldr	r3, [r7, #0xc]
 8010d94: 6093         	str	r3, [r2, #0x8]
; }
 8010d96: bf00         	nop
; }
 8010d98: bf00         	nop
 8010d9a: 3714         	adds	r7, #0x14
 8010d9c: 46bd         	mov	sp, r7
 8010d9e: f85d 7b04    	ldr	r7, [sp], #4
 8010da2: 4770         	bx	lr

08010da4 <$d>:
 8010da4: 48 1d 00 20  	.word	0x20001d48

08010da8 <move_thread_to_end_of_prio_q>:
; {
 8010da8: b580         	push	{r7, lr}
 8010daa: b09a         	sub	sp, #0x68
 8010dac: af00         	add	r7, sp, #0x0
 8010dae: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 8010db0: 6878         	ldr	r0, [r7, #0x4]
 8010db2: f00e faf8    	bl	0x801f3a6 <z_is_thread_queued> @ imm = #0xe5f0
 8010db6: 4603         	mov	r3, r0
 8010db8: 2b00         	cmp	r3, #0x0
 8010dba: d01d         	beq	0x8010df8 <move_thread_to_end_of_prio_q+0x50> @ imm = #0x3a
 8010dbc: 687b         	ldr	r3, [r7, #0x4]
 8010dbe: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8010dc0: 6e7b         	ldr	r3, [r7, #0x64]
 8010dc2: 7b5b         	ldrb	r3, [r3, #0xd]
 8010dc4: f003 037f    	and	r3, r3, #0x7f
 8010dc8: b2da         	uxtb	r2, r3
 8010dca: 6e7b         	ldr	r3, [r7, #0x64]
 8010dcc: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8010dce: 6e78         	ldr	r0, [r7, #0x64]
 8010dd0: f00e fbd4    	bl	0x801f57c <should_queue_thread> @ imm = #0xe7a8
 8010dd4: 4603         	mov	r3, r0
 8010dd6: 2b00         	cmp	r3, #0x0
 8010dd8: d00d         	beq	0x8010df6 <move_thread_to_end_of_prio_q+0x4e> @ imm = #0x1a
 8010dda: 6e7b         	ldr	r3, [r7, #0x64]
 8010ddc: 663b         	str	r3, [r7, #0x60]
 8010dde: 6e3b         	ldr	r3, [r7, #0x60]
 8010de0: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 8010de2: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x8010f80 <move_thread_to_end_of_prio_q+0x1d8>
 8010de4: 65bb         	str	r3, [r7, #0x58]
 8010de6: 6e3b         	ldr	r3, [r7, #0x60]
 8010de8: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8010dea: 6d7b         	ldr	r3, [r7, #0x54]
 8010dec: 4618         	mov	r0, r3
 8010dee: f00e f9fa    	bl	0x801f1e6 <sys_dlist_remove> @ imm = #0xe3f4
; }
 8010df2: bf00         	nop
; }
 8010df4: bf00         	nop
; }
 8010df6: bf00         	nop
 8010df8: 687b         	ldr	r3, [r7, #0x4]
 8010dfa: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 8010dfc: 69fb         	ldr	r3, [r7, #0x1c]
 8010dfe: 7b5b         	ldrb	r3, [r3, #0xd]
 8010e00: f063 037f    	orn	r3, r3, #0x7f
 8010e04: b2da         	uxtb	r2, r3
 8010e06: 69fb         	ldr	r3, [r7, #0x1c]
 8010e08: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8010e0a: 69f8         	ldr	r0, [r7, #0x1c]
 8010e0c: f00e fbb6    	bl	0x801f57c <should_queue_thread> @ imm = #0xe76c
 8010e10: 4603         	mov	r3, r0
 8010e12: 2b00         	cmp	r3, #0x0
 8010e14: d042         	beq	0x8010e9c <move_thread_to_end_of_prio_q+0xf4> @ imm = #0x84
 8010e16: 69fb         	ldr	r3, [r7, #0x1c]
 8010e18: 61bb         	str	r3, [r7, #0x18]
 8010e1a: 69bb         	ldr	r3, [r7, #0x18]
 8010e1c: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 8010e1e: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8010f80 <move_thread_to_end_of_prio_q+0x1d8>
 8010e20: 613b         	str	r3, [r7, #0x10]
 8010e22: 69bb         	ldr	r3, [r7, #0x18]
 8010e24: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8010e26: 6938         	ldr	r0, [r7, #0x10]
 8010e28: f00e f970    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xe2e0
 8010e2c: 4603         	mov	r3, r0
 8010e2e: 2b00         	cmp	r3, #0x0
 8010e30: d004         	beq	0x8010e3c <move_thread_to_end_of_prio_q+0x94> @ imm = #0x8
 8010e32: 6938         	ldr	r0, [r7, #0x10]
 8010e34: f00e f96a    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xe2d4
 8010e38: 4603         	mov	r3, r0
 8010e3a: e000         	b	0x8010e3e <move_thread_to_end_of_prio_q+0x96> @ imm = #0x0
 8010e3c: 2300         	movs	r3, #0x0
 8010e3e: 60bb         	str	r3, [r7, #0x8]
 8010e40: e023         	b	0x8010e8a <move_thread_to_end_of_prio_q+0xe2> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8010e42: 68b9         	ldr	r1, [r7, #0x8]
 8010e44: 68f8         	ldr	r0, [r7, #0xc]
 8010e46: f00e fb7d    	bl	0x801f544 <z_sched_prio_cmp> @ imm = #0xe6fa
 8010e4a: 4603         	mov	r3, r0
 8010e4c: 2b00         	cmp	r3, #0x0
 8010e4e: dd06         	ble	0x8010e5e <move_thread_to_end_of_prio_q+0xb6> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8010e50: 68bb         	ldr	r3, [r7, #0x8]
 8010e52: 68fa         	ldr	r2, [r7, #0xc]
 8010e54: 4611         	mov	r1, r2
 8010e56: 4618         	mov	r0, r3
 8010e58: f00e f9ab    	bl	0x801f1b2 <sys_dlist_insert> @ imm = #0xe356
; 			return;
 8010e5c: e01d         	b	0x8010e9a <move_thread_to_end_of_prio_q+0xf2> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8010e5e: 68bb         	ldr	r3, [r7, #0x8]
 8010e60: 2b00         	cmp	r3, #0x0
 8010e62: d010         	beq	0x8010e86 <move_thread_to_end_of_prio_q+0xde> @ imm = #0x20
 8010e64: 68bb         	ldr	r3, [r7, #0x8]
 8010e66: 4619         	mov	r1, r3
 8010e68: 6938         	ldr	r0, [r7, #0x10]
 8010e6a: f00e f975    	bl	0x801f158 <sys_dlist_peek_next> @ imm = #0xe2ea
 8010e6e: 4603         	mov	r3, r0
 8010e70: 2b00         	cmp	r3, #0x0
 8010e72: d006         	beq	0x8010e82 <move_thread_to_end_of_prio_q+0xda> @ imm = #0xc
 8010e74: 68bb         	ldr	r3, [r7, #0x8]
 8010e76: 4619         	mov	r1, r3
 8010e78: 6938         	ldr	r0, [r7, #0x10]
 8010e7a: f00e f96d    	bl	0x801f158 <sys_dlist_peek_next> @ imm = #0xe2da
 8010e7e: 4603         	mov	r3, r0
 8010e80: e002         	b	0x8010e88 <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x4
 8010e82: 2300         	movs	r3, #0x0
 8010e84: e000         	b	0x8010e88 <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x0
 8010e86: 2300         	movs	r3, #0x0
 8010e88: 60bb         	str	r3, [r7, #0x8]
 8010e8a: 68bb         	ldr	r3, [r7, #0x8]
 8010e8c: 2b00         	cmp	r3, #0x0
 8010e8e: d1d8         	bne	0x8010e42 <move_thread_to_end_of_prio_q+0x9a> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8010e90: 68fb         	ldr	r3, [r7, #0xc]
 8010e92: 4619         	mov	r1, r3
 8010e94: 6938         	ldr	r0, [r7, #0x10]
 8010e96: f00e f972    	bl	0x801f17e <sys_dlist_append> @ imm = #0xe2e4
; }
 8010e9a: bf00         	nop
; }
 8010e9c: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010e9e: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8010f84 <move_thread_to_end_of_prio_q+0x1dc>
 8010ea0: 689b         	ldr	r3, [r3, #0x8]
 8010ea2: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 8010ea4: 6a3b         	ldr	r3, [r7, #0x20]
; 	update_cache(thread == arch_current_thread());
 8010ea6: 687a         	ldr	r2, [r7, #0x4]
 8010ea8: 429a         	cmp	r2, r3
 8010eaa: bf0c         	ite	eq
 8010eac: 2301         	moveq	r3, #0x1
 8010eae: 2300         	movne	r3, #0x0
 8010eb0: b2db         	uxtb	r3, r3
 8010eb2: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 8010eb4: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8010f80 <move_thread_to_end_of_prio_q+0x1d8>
 8010eb6: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 8010eb8: 2300         	movs	r3, #0x0
 8010eba: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8010ebc: 6cf8         	ldr	r0, [r7, #0x4c]
 8010ebe: f00e f925    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xe24a
 8010ec2: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8010ec4: 6c7b         	ldr	r3, [r7, #0x44]
 8010ec6: 2b00         	cmp	r3, #0x0
 8010ec8: d001         	beq	0x8010ece <move_thread_to_end_of_prio_q+0x126> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8010eca: 6c7b         	ldr	r3, [r7, #0x44]
 8010ecc: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 8010ece: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 8010ed0: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8010ed2: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8010ed4: 6c3b         	ldr	r3, [r7, #0x40]
 8010ed6: 2b00         	cmp	r3, #0x0
 8010ed8: d102         	bne	0x8010ee0 <move_thread_to_end_of_prio_q+0x138> @ imm = #0x4
 8010eda: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8010f84 <move_thread_to_end_of_prio_q+0x1dc>
 8010edc: 68db         	ldr	r3, [r3, #0xc]
 8010ede: e000         	b	0x8010ee2 <move_thread_to_end_of_prio_q+0x13a> @ imm = #0x0
 8010ee0: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 8010ee2: 63fb         	str	r3, [r7, #0x3c]
 8010ee4: 6bfb         	ldr	r3, [r7, #0x3c]
 8010ee6: 63bb         	str	r3, [r7, #0x38]
 8010ee8: 6d3b         	ldr	r3, [r7, #0x50]
 8010eea: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 8010eec: 6b7b         	ldr	r3, [r7, #0x34]
 8010eee: 2b00         	cmp	r3, #0x0
 8010ef0: d001         	beq	0x8010ef6 <move_thread_to_end_of_prio_q+0x14e> @ imm = #0x2
; 		return true;
 8010ef2: 2301         	movs	r3, #0x1
 8010ef4: e026         	b	0x8010f44 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010ef6: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8010f84 <move_thread_to_end_of_prio_q+0x1dc>
 8010ef8: 689b         	ldr	r3, [r3, #0x8]
 8010efa: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 8010efc: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8010efe: 4618         	mov	r0, r3
 8010f00: f00e f9ee    	bl	0x801f2e0 <z_is_thread_prevented_from_running> @ imm = #0xe3dc
 8010f04: 4603         	mov	r3, r0
 8010f06: 2b00         	cmp	r3, #0x0
 8010f08: d001         	beq	0x8010f0e <move_thread_to_end_of_prio_q+0x166> @ imm = #0x2
; 		return true;
 8010f0a: 2301         	movs	r3, #0x1
 8010f0c: e01a         	b	0x8010f44 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010f0e: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8010f84 <move_thread_to_end_of_prio_q+0x1dc>
 8010f10: 689b         	ldr	r3, [r3, #0x8]
 8010f12: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 8010f14: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8010f16: 4618         	mov	r0, r3
 8010f18: f00e f9b3    	bl	0x801f282 <thread_is_preemptible> @ imm = #0xe366
 8010f1c: 4603         	mov	r3, r0
 8010f1e: 2b00         	cmp	r3, #0x0
 8010f20: d105         	bne	0x8010f2e <move_thread_to_end_of_prio_q+0x186> @ imm = #0xa
 8010f22: 6bb8         	ldr	r0, [r7, #0x38]
 8010f24: f00e f9be    	bl	0x801f2a4 <thread_is_metairq> @ imm = #0xe37c
 8010f28: 4603         	mov	r3, r0
 8010f2a: 2b00         	cmp	r3, #0x0
 8010f2c: d001         	beq	0x8010f32 <move_thread_to_end_of_prio_q+0x18a> @ imm = #0x2
; 		return true;
 8010f2e: 2301         	movs	r3, #0x1
 8010f30: e008         	b	0x8010f44 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8010f32: 6bb8         	ldr	r0, [r7, #0x38]
 8010f34: f00e f9e9    	bl	0x801f30a <z_is_thread_timeout_active> @ imm = #0xe3d2
 8010f38: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8010f3a: 2b00         	cmp	r3, #0x0
 8010f3c: d001         	beq	0x8010f42 <move_thread_to_end_of_prio_q+0x19a> @ imm = #0x2
; 		return true;
 8010f3e: 2301         	movs	r3, #0x1
 8010f40: e000         	b	0x8010f44 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x0
; 	return false;
 8010f42: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8010f44: 2b00         	cmp	r3, #0x0
 8010f46: d010         	beq	0x8010f6a <move_thread_to_end_of_prio_q+0x1c2> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010f48: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8010f84 <move_thread_to_end_of_prio_q+0x1dc>
 8010f4a: 689b         	ldr	r3, [r3, #0x8]
 8010f4c: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8010f4e: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 8010f50: 6bfa         	ldr	r2, [r7, #0x3c]
 8010f52: 429a         	cmp	r2, r3
 8010f54: d002         	beq	0x8010f5c <move_thread_to_end_of_prio_q+0x1b4> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8010f56: 6bf8         	ldr	r0, [r7, #0x3c]
 8010f58: f001 fbf8    	bl	0x801274c <z_reset_time_slice> @ imm = #0x17f0
; 		update_metairq_preempt(thread);
 8010f5c: 6bf8         	ldr	r0, [r7, #0x3c]
 8010f5e: f00e fb54    	bl	0x801f60a <update_metairq_preempt> @ imm = #0xe6a8
; 		_kernel.ready_q.cache = thread;
 8010f62: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8010f84 <move_thread_to_end_of_prio_q+0x1dc>
 8010f64: 6bfb         	ldr	r3, [r7, #0x3c]
 8010f66: 6213         	str	r3, [r2, #0x20]
; }
 8010f68: e005         	b	0x8010f76 <move_thread_to_end_of_prio_q+0x1ce> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8010f6a: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8010f84 <move_thread_to_end_of_prio_q+0x1dc>
 8010f6c: 689b         	ldr	r3, [r3, #0x8]
 8010f6e: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8010f70: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 8010f72: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8010f84 <move_thread_to_end_of_prio_q+0x1dc>
 8010f74: 6213         	str	r3, [r2, #0x20]
; }
 8010f76: bf00         	nop
; }
 8010f78: bf00         	nop
 8010f7a: 3768         	adds	r7, #0x68
 8010f7c: 46bd         	mov	sp, r7
 8010f7e: bd80         	pop	{r7, pc}

08010f80 <$d>:
 8010f80: 6c 1d 00 20  	.word	0x20001d6c
 8010f84: 48 1d 00 20  	.word	0x20001d48

08010f88 <ready_thread>:
; {
 8010f88: b580         	push	{r7, lr}
 8010f8a: b094         	sub	sp, #0x50
 8010f8c: af00         	add	r7, sp, #0x0
 8010f8e: 6078         	str	r0, [r7, #0x4]
; 	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 8010f90: 6878         	ldr	r0, [r7, #0x4]
 8010f92: f00e fa08    	bl	0x801f3a6 <z_is_thread_queued> @ imm = #0xe410
 8010f96: 4603         	mov	r3, r0
 8010f98: f083 0301    	eor	r3, r3, #0x1
 8010f9c: b2db         	uxtb	r3, r3
 8010f9e: 2b00         	cmp	r3, #0x0
 8010fa0: f000 80be    	beq.w	0x8011120 <ready_thread+0x198> @ imm = #0x17c
 8010fa4: 6878         	ldr	r0, [r7, #0x4]
 8010fa6: f00e f9c9    	bl	0x801f33c <z_is_thread_ready> @ imm = #0xe392
 8010faa: 4603         	mov	r3, r0
 8010fac: 2b00         	cmp	r3, #0x0
 8010fae: f000 80b7    	beq.w	0x8011120 <ready_thread+0x198> @ imm = #0x16e
 8010fb2: 687b         	ldr	r3, [r7, #0x4]
 8010fb4: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 8010fb6: 69fb         	ldr	r3, [r7, #0x1c]
 8010fb8: 7b5b         	ldrb	r3, [r3, #0xd]
 8010fba: f063 037f    	orn	r3, r3, #0x7f
 8010fbe: b2da         	uxtb	r2, r3
 8010fc0: 69fb         	ldr	r3, [r7, #0x1c]
 8010fc2: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8010fc4: 69f8         	ldr	r0, [r7, #0x1c]
 8010fc6: f00e fad9    	bl	0x801f57c <should_queue_thread> @ imm = #0xe5b2
 8010fca: 4603         	mov	r3, r0
 8010fcc: 2b00         	cmp	r3, #0x0
 8010fce: d042         	beq	0x8011056 <ready_thread+0xce> @ imm = #0x84
 8010fd0: 69fb         	ldr	r3, [r7, #0x1c]
 8010fd2: 61bb         	str	r3, [r7, #0x18]
 8010fd4: 69bb         	ldr	r3, [r7, #0x18]
 8010fd6: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 8010fd8: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8011128 <ready_thread+0x1a0>
 8010fda: 613b         	str	r3, [r7, #0x10]
 8010fdc: 69bb         	ldr	r3, [r7, #0x18]
 8010fde: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8010fe0: 6938         	ldr	r0, [r7, #0x10]
 8010fe2: f00e f893    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xe126
 8010fe6: 4603         	mov	r3, r0
 8010fe8: 2b00         	cmp	r3, #0x0
 8010fea: d004         	beq	0x8010ff6 <ready_thread+0x6e> @ imm = #0x8
 8010fec: 6938         	ldr	r0, [r7, #0x10]
 8010fee: f00e f88d    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xe11a
 8010ff2: 4603         	mov	r3, r0
 8010ff4: e000         	b	0x8010ff8 <ready_thread+0x70> @ imm = #0x0
 8010ff6: 2300         	movs	r3, #0x0
 8010ff8: 60bb         	str	r3, [r7, #0x8]
 8010ffa: e023         	b	0x8011044 <ready_thread+0xbc> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8010ffc: 68b9         	ldr	r1, [r7, #0x8]
 8010ffe: 68f8         	ldr	r0, [r7, #0xc]
 8011000: f00e faa0    	bl	0x801f544 <z_sched_prio_cmp> @ imm = #0xe540
 8011004: 4603         	mov	r3, r0
 8011006: 2b00         	cmp	r3, #0x0
 8011008: dd06         	ble	0x8011018 <ready_thread+0x90> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 801100a: 68bb         	ldr	r3, [r7, #0x8]
 801100c: 68fa         	ldr	r2, [r7, #0xc]
 801100e: 4611         	mov	r1, r2
 8011010: 4618         	mov	r0, r3
 8011012: f00e f8ce    	bl	0x801f1b2 <sys_dlist_insert> @ imm = #0xe19c
; 			return;
 8011016: e01d         	b	0x8011054 <ready_thread+0xcc> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8011018: 68bb         	ldr	r3, [r7, #0x8]
 801101a: 2b00         	cmp	r3, #0x0
 801101c: d010         	beq	0x8011040 <ready_thread+0xb8> @ imm = #0x20
 801101e: 68bb         	ldr	r3, [r7, #0x8]
 8011020: 4619         	mov	r1, r3
 8011022: 6938         	ldr	r0, [r7, #0x10]
 8011024: f00e f898    	bl	0x801f158 <sys_dlist_peek_next> @ imm = #0xe130
 8011028: 4603         	mov	r3, r0
 801102a: 2b00         	cmp	r3, #0x0
 801102c: d006         	beq	0x801103c <ready_thread+0xb4> @ imm = #0xc
 801102e: 68bb         	ldr	r3, [r7, #0x8]
 8011030: 4619         	mov	r1, r3
 8011032: 6938         	ldr	r0, [r7, #0x10]
 8011034: f00e f890    	bl	0x801f158 <sys_dlist_peek_next> @ imm = #0xe120
 8011038: 4603         	mov	r3, r0
 801103a: e002         	b	0x8011042 <ready_thread+0xba> @ imm = #0x4
 801103c: 2300         	movs	r3, #0x0
 801103e: e000         	b	0x8011042 <ready_thread+0xba> @ imm = #0x0
 8011040: 2300         	movs	r3, #0x0
 8011042: 60bb         	str	r3, [r7, #0x8]
 8011044: 68bb         	ldr	r3, [r7, #0x8]
 8011046: 2b00         	cmp	r3, #0x0
 8011048: d1d8         	bne	0x8010ffc <ready_thread+0x74> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 801104a: 68fb         	ldr	r3, [r7, #0xc]
 801104c: 4619         	mov	r1, r3
 801104e: 6938         	ldr	r0, [r7, #0x10]
 8011050: f00e f895    	bl	0x801f17e <sys_dlist_append> @ imm = #0xe12a
; }
 8011054: bf00         	nop
; }
 8011056: bf00         	nop
 8011058: 2300         	movs	r3, #0x0
 801105a: 64fb         	str	r3, [r7, #0x4c]
; 	return &_kernel.ready_q.runq;
 801105c: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8011128 <ready_thread+0x1a0>
 801105e: 64bb         	str	r3, [r7, #0x48]
; 	struct k_thread *thread = NULL;
 8011060: 2300         	movs	r3, #0x0
 8011062: 647b         	str	r3, [r7, #0x44]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8011064: 6cb8         	ldr	r0, [r7, #0x48]
 8011066: f00e f851    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xe0a2
 801106a: 6438         	str	r0, [r7, #0x40]
; 	if (n != NULL) {
 801106c: 6c3b         	ldr	r3, [r7, #0x40]
 801106e: 2b00         	cmp	r3, #0x0
 8011070: d001         	beq	0x8011076 <ready_thread+0xee> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8011072: 6c3b         	ldr	r3, [r7, #0x40]
 8011074: 647b         	str	r3, [r7, #0x44]
; 	return thread;
 8011076: 6c7b         	ldr	r3, [r7, #0x44]
; 	return _priq_run_best(curr_cpu_runq());
 8011078: bf00         	nop
; 	struct k_thread *thread = runq_best();
 801107a: 63fb         	str	r3, [r7, #0x3c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 801107c: 6bfb         	ldr	r3, [r7, #0x3c]
 801107e: 2b00         	cmp	r3, #0x0
 8011080: d102         	bne	0x8011088 <ready_thread+0x100> @ imm = #0x4
 8011082: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x801112c <ready_thread+0x1a4>
 8011084: 68db         	ldr	r3, [r3, #0xc]
 8011086: e000         	b	0x801108a <ready_thread+0x102> @ imm = #0x0
 8011088: 6bfb         	ldr	r3, [r7, #0x3c]
; 	struct k_thread *thread = next_up();
 801108a: 63bb         	str	r3, [r7, #0x38]
 801108c: 6bbb         	ldr	r3, [r7, #0x38]
 801108e: 637b         	str	r3, [r7, #0x34]
 8011090: 6cfb         	ldr	r3, [r7, #0x4c]
 8011092: 633b         	str	r3, [r7, #0x30]
; 	if (preempt_ok != 0) {
 8011094: 6b3b         	ldr	r3, [r7, #0x30]
 8011096: 2b00         	cmp	r3, #0x0
 8011098: d001         	beq	0x801109e <ready_thread+0x116> @ imm = #0x2
; 		return true;
 801109a: 2301         	movs	r3, #0x1
 801109c: e026         	b	0x80110ec <ready_thread+0x164> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801109e: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x801112c <ready_thread+0x1a4>
 80110a0: 689b         	ldr	r3, [r3, #0x8]
 80110a2: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 80110a4: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 80110a6: 4618         	mov	r0, r3
 80110a8: f00e f91a    	bl	0x801f2e0 <z_is_thread_prevented_from_running> @ imm = #0xe234
 80110ac: 4603         	mov	r3, r0
 80110ae: 2b00         	cmp	r3, #0x0
 80110b0: d001         	beq	0x80110b6 <ready_thread+0x12e> @ imm = #0x2
; 		return true;
 80110b2: 2301         	movs	r3, #0x1
 80110b4: e01a         	b	0x80110ec <ready_thread+0x164> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80110b6: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x801112c <ready_thread+0x1a4>
 80110b8: 689b         	ldr	r3, [r3, #0x8]
 80110ba: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 80110bc: 6abb         	ldr	r3, [r7, #0x28]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 80110be: 4618         	mov	r0, r3
 80110c0: f00e f8df    	bl	0x801f282 <thread_is_preemptible> @ imm = #0xe1be
 80110c4: 4603         	mov	r3, r0
 80110c6: 2b00         	cmp	r3, #0x0
 80110c8: d105         	bne	0x80110d6 <ready_thread+0x14e> @ imm = #0xa
 80110ca: 6b78         	ldr	r0, [r7, #0x34]
 80110cc: f00e f8ea    	bl	0x801f2a4 <thread_is_metairq> @ imm = #0xe1d4
 80110d0: 4603         	mov	r3, r0
 80110d2: 2b00         	cmp	r3, #0x0
 80110d4: d001         	beq	0x80110da <ready_thread+0x152> @ imm = #0x2
; 		return true;
 80110d6: 2301         	movs	r3, #0x1
 80110d8: e008         	b	0x80110ec <ready_thread+0x164> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 80110da: 6b78         	ldr	r0, [r7, #0x34]
 80110dc: f00e f915    	bl	0x801f30a <z_is_thread_timeout_active> @ imm = #0xe22a
 80110e0: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 80110e2: 2b00         	cmp	r3, #0x0
 80110e4: d001         	beq	0x80110ea <ready_thread+0x162> @ imm = #0x2
; 		return true;
 80110e6: 2301         	movs	r3, #0x1
 80110e8: e000         	b	0x80110ec <ready_thread+0x164> @ imm = #0x0
; 	return false;
 80110ea: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 80110ec: 2b00         	cmp	r3, #0x0
 80110ee: d010         	beq	0x8011112 <ready_thread+0x18a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80110f0: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x801112c <ready_thread+0x1a4>
 80110f2: 689b         	ldr	r3, [r3, #0x8]
 80110f4: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 80110f6: 6a7b         	ldr	r3, [r7, #0x24]
; 		if (thread != arch_current_thread()) {
 80110f8: 6bba         	ldr	r2, [r7, #0x38]
 80110fa: 429a         	cmp	r2, r3
 80110fc: d002         	beq	0x8011104 <ready_thread+0x17c> @ imm = #0x4
; 			z_reset_time_slice(thread);
 80110fe: 6bb8         	ldr	r0, [r7, #0x38]
 8011100: f001 fb24    	bl	0x801274c <z_reset_time_slice> @ imm = #0x1648
; 		update_metairq_preempt(thread);
 8011104: 6bb8         	ldr	r0, [r7, #0x38]
 8011106: f00e fa80    	bl	0x801f60a <update_metairq_preempt> @ imm = #0xe500
; 		_kernel.ready_q.cache = thread;
 801110a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x801112c <ready_thread+0x1a4>
 801110c: 6bbb         	ldr	r3, [r7, #0x38]
 801110e: 6213         	str	r3, [r2, #0x20]
; }
 8011110: e005         	b	0x801111e <ready_thread+0x196> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011112: 4b06         	ldr	r3, [pc, #0x18]         @ 0x801112c <ready_thread+0x1a4>
 8011114: 689b         	ldr	r3, [r3, #0x8]
 8011116: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 8011118: 6a3b         	ldr	r3, [r7, #0x20]
; 		_kernel.ready_q.cache = arch_current_thread();
 801111a: 4a04         	ldr	r2, [pc, #0x10]         @ 0x801112c <ready_thread+0x1a4>
 801111c: 6213         	str	r3, [r2, #0x20]
; }
 801111e: bf00         	nop
; }
 8011120: bf00         	nop
 8011122: 3750         	adds	r7, #0x50
 8011124: 46bd         	mov	sp, r7
 8011126: bd80         	pop	{r7, pc}

08011128 <$d>:
 8011128: 6c 1d 00 20  	.word	0x20001d6c
 801112c: 48 1d 00 20  	.word	0x20001d48

08011130 <z_ready_thread>:
; {
 8011130: b580         	push	{r7, lr}
 8011132: b090         	sub	sp, #0x40
 8011134: af00         	add	r7, sp, #0x0
 8011136: 6078         	str	r0, [r7, #0x4]
; 	K_SPINLOCK(&_sched_spinlock) {
 8011138: 2300         	movs	r3, #0x0
 801113a: 61bb         	str	r3, [r7, #0x18]
 801113c: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80111bc <z_ready_thread+0x8c>
 801113e: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8011140: f3ef 8311    	mrs	r3, basepri
 8011144: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 8011146: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 8011148: 637b         	str	r3, [r7, #0x34]
 801114a: 2310         	movs	r3, #0x10
 801114c: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801114e: 6b3b         	ldr	r3, [r7, #0x30]
 8011150: f383 8812    	msr	basepri_max, r3
; }
 8011154: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011156: f3bf 8f6f    	isb	sy
; }
 801115a: bf00         	nop
; 	return key;
 801115c: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 801115e: 60fb         	str	r3, [r7, #0xc]
 8011160: 6bfb         	ldr	r3, [r7, #0x3c]
 8011162: 62fb         	str	r3, [r7, #0x2c]
; }
 8011164: bf00         	nop
 8011166: 6bfb         	ldr	r3, [r7, #0x3c]
 8011168: 62bb         	str	r3, [r7, #0x28]
; }
 801116a: bf00         	nop
; 	return k;
 801116c: 68fb         	ldr	r3, [r7, #0xc]
 801116e: 617b         	str	r3, [r7, #0x14]
; 	K_SPINLOCK(&_sched_spinlock) {
 8011170: e01b         	b	0x80111aa <z_ready_thread+0x7a> @ imm = #0x36
; 		if (thread_active_elsewhere(thread) == NULL) {
 8011172: 6878         	ldr	r0, [r7, #0x4]
 8011174: f00e fa53    	bl	0x801f61e <thread_active_elsewhere> @ imm = #0xe4a6
 8011178: 4603         	mov	r3, r0
 801117a: 2b00         	cmp	r3, #0x0
 801117c: d102         	bne	0x8011184 <z_ready_thread+0x54> @ imm = #0x4
; 			ready_thread(thread);
 801117e: 6878         	ldr	r0, [r7, #0x4]
 8011180: f7ff ff02    	bl	0x8010f88 <ready_thread> @ imm = #-0x1fc
 8011184: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80111bc <z_ready_thread+0x8c>
 8011186: 627b         	str	r3, [r7, #0x24]
 8011188: 697b         	ldr	r3, [r7, #0x14]
 801118a: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 801118c: 693b         	ldr	r3, [r7, #0x10]
 801118e: 623b         	str	r3, [r7, #0x20]
 8011190: 6a3b         	ldr	r3, [r7, #0x20]
 8011192: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8011194: 69fb         	ldr	r3, [r7, #0x1c]
 8011196: f383 8811    	msr	basepri, r3
; }
 801119a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801119c: f3bf 8f6f    	isb	sy
; }
 80111a0: bf00         	nop
; }
 80111a2: bf00         	nop
; }
 80111a4: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 80111a6: 2301         	movs	r3, #0x1
 80111a8: 61bb         	str	r3, [r7, #0x18]
 80111aa: 69bb         	ldr	r3, [r7, #0x18]
 80111ac: 2b00         	cmp	r3, #0x0
 80111ae: d0e0         	beq	0x8011172 <z_ready_thread+0x42> @ imm = #-0x40
; }
 80111b0: bf00         	nop
 80111b2: bf00         	nop
 80111b4: 3740         	adds	r7, #0x40
 80111b6: 46bd         	mov	sp, r7
 80111b8: bd80         	pop	{r7, pc}
 80111ba: bf00         	nop

080111bc <$d>:
 80111bc: e0 27 00 20  	.word	0x200027e0

080111c0 <thread_halt_spin>:
; {
 80111c0: b590         	push	{r4, r7, lr}
 80111c2: b091         	sub	sp, #0x44
 80111c4: af00         	add	r7, sp, #0x0
 80111c6: 6078         	str	r0, [r7, #0x4]
 80111c8: 6039         	str	r1, [r7]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80111ca: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8011280 <thread_halt_spin+0xc0>
 80111cc: 689b         	ldr	r3, [r3, #0x8]
 80111ce: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 80111d0: 6bbb         	ldr	r3, [r7, #0x38]
; 	if (is_halting(arch_current_thread())) {
 80111d2: 4618         	mov	r0, r3
 80111d4: f00e f9f0    	bl	0x801f5b8 <is_halting>  @ imm = #0xe3e0
 80111d8: 4603         	mov	r3, r0
 80111da: 2b00         	cmp	r3, #0x0
 80111dc: d014         	beq	0x8011208 <thread_halt_spin+0x48> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80111de: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8011280 <thread_halt_spin+0xc0>
 80111e0: 689b         	ldr	r3, [r3, #0x8]
 80111e2: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 80111e4: 6b3c         	ldr	r4, [r7, #0x30]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80111e6: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8011280 <thread_halt_spin+0xc0>
 80111e8: 689b         	ldr	r3, [r3, #0x8]
 80111ea: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 80111ec: 6b7b         	ldr	r3, [r7, #0x34]
; 			    is_aborting(arch_current_thread()) ? _THREAD_DEAD : _THREAD_SUSPENDED);
 80111ee: 4618         	mov	r0, r3
 80111f0: f00e f9cf    	bl	0x801f592 <is_aborting> @ imm = #0xe39e
 80111f4: 4603         	mov	r3, r0
; 		halt_thread(arch_current_thread(),
 80111f6: 2b00         	cmp	r3, #0x0
 80111f8: d001         	beq	0x80111fe <thread_halt_spin+0x3e> @ imm = #0x2
 80111fa: 2308         	movs	r3, #0x8
 80111fc: e000         	b	0x8011200 <thread_halt_spin+0x40> @ imm = #0x0
 80111fe: 2310         	movs	r3, #0x10
 8011200: 4619         	mov	r1, r3
 8011202: 4620         	mov	r0, r4
 8011204: f001 f836    	bl	0x8012274 <halt_thread> @ imm = #0x106c
 8011208: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8011284 <thread_halt_spin+0xc4>
 801120a: 62fb         	str	r3, [r7, #0x2c]
 801120c: 683b         	ldr	r3, [r7]
 801120e: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8011210: 68fb         	ldr	r3, [r7, #0xc]
 8011212: 62bb         	str	r3, [r7, #0x28]
 8011214: 6abb         	ldr	r3, [r7, #0x28]
 8011216: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8011218: 6a7b         	ldr	r3, [r7, #0x24]
 801121a: f383 8811    	msr	basepri, r3
; }
 801121e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011220: f3bf 8f6f    	isb	sy
; }
 8011224: bf00         	nop
; }
 8011226: bf00         	nop
; }
 8011228: bf00         	nop
; 	while (is_halting(thread)) {
 801122a: e01d         	b	0x8011268 <thread_halt_spin+0xa8> @ imm = #0x3a
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801122c: f3ef 8311    	mrs	r3, basepri
 8011230: 61bb         	str	r3, [r7, #0x18]
;   return(result);
 8011232: 69bb         	ldr	r3, [r7, #0x18]
; 	key = __get_BASEPRI();
 8011234: 617b         	str	r3, [r7, #0x14]
 8011236: 2310         	movs	r3, #0x10
 8011238: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801123a: 693b         	ldr	r3, [r7, #0x10]
 801123c: f383 8812    	msr	basepri_max, r3
; }
 8011240: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011242: f3bf 8f6f    	isb	sy
; }
 8011246: bf00         	nop
; 	return key;
 8011248: 697b         	ldr	r3, [r7, #0x14]
; 		unsigned int k = arch_irq_lock();
 801124a: 63fb         	str	r3, [r7, #0x3c]
; 		arch_spin_relax(); /* Requires interrupts be masked */
 801124c: f00d f81c    	bl	0x801e288 <arch_spin_relax> @ imm = #0xd038
 8011250: 6bfb         	ldr	r3, [r7, #0x3c]
 8011252: 623b         	str	r3, [r7, #0x20]
 8011254: 6a3b         	ldr	r3, [r7, #0x20]
 8011256: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8011258: 69fb         	ldr	r3, [r7, #0x1c]
 801125a: f383 8811    	msr	basepri, r3
; }
 801125e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011260: f3bf 8f6f    	isb	sy
; }
 8011264: bf00         	nop
; }
 8011266: bf00         	nop
; 	while (is_halting(thread)) {
 8011268: 6878         	ldr	r0, [r7, #0x4]
 801126a: f00e f9a5    	bl	0x801f5b8 <is_halting>  @ imm = #0xe34a
 801126e: 4603         	mov	r3, r0
 8011270: 2b00         	cmp	r3, #0x0
 8011272: d1db         	bne	0x801122c <thread_halt_spin+0x6c> @ imm = #-0x4a
; }
 8011274: bf00         	nop
 8011276: bf00         	nop
 8011278: 3744         	adds	r7, #0x44
 801127a: 46bd         	mov	sp, r7
 801127c: bd90         	pop	{r4, r7, pc}
 801127e: bf00         	nop

08011280 <$d>:
 8011280: 48 1d 00 20  	.word	0x20001d48
 8011284: e0 27 00 20  	.word	0x200027e0

08011288 <z_thread_halt>:
; {
 8011288: b580         	push	{r7, lr}
 801128a: b094         	sub	sp, #0x50
 801128c: af00         	add	r7, sp, #0x0
 801128e: 60f8         	str	r0, [r7, #0xc]
 8011290: 60b9         	str	r1, [r7, #0x8]
 8011292: 4613         	mov	r3, r2
 8011294: 71fb         	strb	r3, [r7, #0x7]
; 	_wait_q_t *wq = &thread->join_queue;
 8011296: 68fb         	ldr	r3, [r7, #0xc]
 8011298: 3368         	adds	r3, #0x68
 801129a: 64fb         	str	r3, [r7, #0x4c]
; 	struct _cpu *cpu = thread_active_elsewhere(thread);
 801129c: 68f8         	ldr	r0, [r7, #0xc]
 801129e: f00e f9be    	bl	0x801f61e <thread_active_elsewhere> @ imm = #0xe37c
 80112a2: 64b8         	str	r0, [r7, #0x48]
; 	if (cpu != NULL) {
 80112a4: 6cbb         	ldr	r3, [r7, #0x48]
 80112a6: 2b00         	cmp	r3, #0x0
 80112a8: d02f         	beq	0x801130a <z_thread_halt+0x82> @ imm = #0x5e
; 		thread->base.thread_state |= (terminate ? _THREAD_ABORTING
 80112aa: 68fb         	ldr	r3, [r7, #0xc]
 80112ac: 7b5b         	ldrb	r3, [r3, #0xd]
 80112ae: 79fa         	ldrb	r2, [r7, #0x7]
 80112b0: 2a00         	cmp	r2, #0x0
 80112b2: d001         	beq	0x80112b8 <z_thread_halt+0x30> @ imm = #0x2
 80112b4: 2220         	movs	r2, #0x20
 80112b6: e000         	b	0x80112ba <z_thread_halt+0x32> @ imm = #0x0
 80112b8: 2240         	movs	r2, #0x40
 80112ba: 4313         	orrs	r3, r2
 80112bc: b2da         	uxtb	r2, r3
 80112be: 68fb         	ldr	r3, [r7, #0xc]
 80112c0: 735a         	strb	r2, [r3, #0xd]
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80112c2: f3ef 8305    	mrs	r3, ipsr
 80112c6: 647b         	str	r3, [r7, #0x44]
;   return(result);
 80112c8: 6c7b         	ldr	r3, [r7, #0x44]
; 	return (__get_IPSR()) ? (true) : (false);
 80112ca: 2b00         	cmp	r3, #0x0
 80112cc: bf14         	ite	ne
 80112ce: 2301         	movne	r3, #0x1
 80112d0: 2300         	moveq	r3, #0x0
 80112d2: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 80112d4: 2b00         	cmp	r3, #0x0
 80112d6: d004         	beq	0x80112e2 <z_thread_halt+0x5a> @ imm = #0x8
; 			thread_halt_spin(thread, key);
 80112d8: 68b9         	ldr	r1, [r7, #0x8]
 80112da: 68f8         	ldr	r0, [r7, #0xc]
 80112dc: f7ff ff70    	bl	0x80111c0 <thread_halt_spin> @ imm = #-0x120
; }
 80112e0: e04f         	b	0x8011382 <z_thread_halt+0xfa> @ imm = #0x9e
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80112e2: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x801138c <z_thread_halt+0x104>
 80112e4: 689b         	ldr	r3, [r3, #0x8]
 80112e6: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 80112e8: 6bbb         	ldr	r3, [r7, #0x38]
; 			add_to_waitq_locked(arch_current_thread(), wq);
 80112ea: 6cf9         	ldr	r1, [r7, #0x4c]
 80112ec: 4618         	mov	r0, r3
 80112ee: f00e f9a1    	bl	0x801f634 <add_to_waitq_locked> @ imm = #0xe342
 80112f2: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8011390 <z_thread_halt+0x108>
 80112f4: 643b         	str	r3, [r7, #0x40]
 80112f6: 68bb         	ldr	r3, [r7, #0x8]
 80112f8: 613b         	str	r3, [r7, #0x10]
 80112fa: 6c3b         	ldr	r3, [r7, #0x40]
 80112fc: 63fb         	str	r3, [r7, #0x3c]
; }
 80112fe: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8011300: 693b         	ldr	r3, [r7, #0x10]
 8011302: 4618         	mov	r0, r3
 8011304: f00e f8f3    	bl	0x801f4ee <z_swap_irqlock> @ imm = #0xe1e6
 8011308: e03b         	b	0x8011382 <z_thread_halt+0xfa> @ imm = #0x76
; 		halt_thread(thread, terminate ? _THREAD_DEAD : _THREAD_SUSPENDED);
 801130a: 79fb         	ldrb	r3, [r7, #0x7]
 801130c: 2b00         	cmp	r3, #0x0
 801130e: d001         	beq	0x8011314 <z_thread_halt+0x8c> @ imm = #0x2
 8011310: 2308         	movs	r3, #0x8
 8011312: e000         	b	0x8011316 <z_thread_halt+0x8e> @ imm = #0x0
 8011314: 2310         	movs	r3, #0x10
 8011316: 4619         	mov	r1, r3
 8011318: 68f8         	ldr	r0, [r7, #0xc]
 801131a: f000 ffab    	bl	0x8012274 <halt_thread> @ imm = #0xf56
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801131e: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x801138c <z_thread_halt+0x104>
 8011320: 689b         	ldr	r3, [r3, #0x8]
 8011322: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 8011324: 6b7b         	ldr	r3, [r7, #0x34]
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 8011326: 68fa         	ldr	r2, [r7, #0xc]
 8011328: 429a         	cmp	r2, r3
 801132a: d119         	bne	0x8011360 <z_thread_halt+0xd8> @ imm = #0x32
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801132c: f3ef 8305    	mrs	r3, ipsr
 8011330: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8011332: 6b3b         	ldr	r3, [r7, #0x30]
; 	return (__get_IPSR()) ? (true) : (false);
 8011334: 2b00         	cmp	r3, #0x0
 8011336: bf14         	ite	ne
 8011338: 2301         	movne	r3, #0x1
 801133a: 2300         	moveq	r3, #0x0
 801133c: b2db         	uxtb	r3, r3
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 801133e: f083 0301    	eor	r3, r3, #0x1
 8011342: b2db         	uxtb	r3, r3
 8011344: 2b00         	cmp	r3, #0x0
 8011346: d00b         	beq	0x8011360 <z_thread_halt+0xd8> @ imm = #0x16
 8011348: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8011390 <z_thread_halt+0x108>
 801134a: 62fb         	str	r3, [r7, #0x2c]
 801134c: 68bb         	ldr	r3, [r7, #0x8]
 801134e: 617b         	str	r3, [r7, #0x14]
 8011350: 6afb         	ldr	r3, [r7, #0x2c]
 8011352: 62bb         	str	r3, [r7, #0x28]
; }
 8011354: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8011356: 697b         	ldr	r3, [r7, #0x14]
 8011358: 4618         	mov	r0, r3
 801135a: f00e f8c8    	bl	0x801f4ee <z_swap_irqlock> @ imm = #0xe190
; 			z_swap(&_sched_spinlock, key);
 801135e: e010         	b	0x8011382 <z_thread_halt+0xfa> @ imm = #0x20
 8011360: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8011390 <z_thread_halt+0x108>
 8011362: 627b         	str	r3, [r7, #0x24]
 8011364: 68bb         	ldr	r3, [r7, #0x8]
 8011366: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8011368: 69bb         	ldr	r3, [r7, #0x18]
 801136a: 623b         	str	r3, [r7, #0x20]
 801136c: 6a3b         	ldr	r3, [r7, #0x20]
 801136e: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8011370: 69fb         	ldr	r3, [r7, #0x1c]
 8011372: f383 8811    	msr	basepri, r3
; }
 8011376: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011378: f3bf 8f6f    	isb	sy
; }
 801137c: bf00         	nop
; }
 801137e: bf00         	nop
; }
 8011380: bf00         	nop
; }
 8011382: bf00         	nop
 8011384: 3750         	adds	r7, #0x50
 8011386: 46bd         	mov	sp, r7
 8011388: bd80         	pop	{r7, pc}
 801138a: bf00         	nop

0801138c <$d>:
 801138c: 48 1d 00 20  	.word	0x20001d48
 8011390: e0 27 00 20  	.word	0x200027e0

08011394 <z_impl_k_thread_suspend>:
; {
 8011394: b580         	push	{r7, lr}
 8011396: b0ac         	sub	sp, #0xb0
 8011398: af00         	add	r7, sp, #0x0
 801139a: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801139c: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x80115d8 <z_impl_k_thread_suspend+0x244>
 801139e: 689b         	ldr	r3, [r3, #0x8]
 80113a0: f8c7 30ac    	str.w	r3, [r7, #0xac]
; 	return ret;
 80113a4: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 80113a8: 687a         	ldr	r2, [r7, #0x4]
 80113aa: 429a         	cmp	r2, r3
 80113ac: f040 80d7    	bne.w	0x801155e <z_impl_k_thread_suspend+0x1ca> @ imm = #0x1ae
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80113b0: f3ef 8305    	mrs	r3, ipsr
 80113b4: f8c7 30a8    	str.w	r3, [r7, #0xa8]
;   return(result);
 80113b8: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
; 	return (__get_IPSR()) ? (true) : (false);
 80113bc: 2b00         	cmp	r3, #0x0
 80113be: bf14         	ite	ne
 80113c0: 2301         	movne	r3, #0x1
 80113c2: 2300         	moveq	r3, #0x0
 80113c4: b2db         	uxtb	r3, r3
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 80113c6: f083 0301    	eor	r3, r3, #0x1
 80113ca: b2db         	uxtb	r3, r3
 80113cc: 2b00         	cmp	r3, #0x0
 80113ce: f000 80c6    	beq.w	0x801155e <z_impl_k_thread_suspend+0x1ca> @ imm = #0x18c
 80113d2: 4b82         	ldr	r3, [pc, #0x208]        @ 0x80115dc <z_impl_k_thread_suspend+0x248>
 80113d4: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80113d6: f3ef 8311    	mrs	r3, basepri
 80113da: 657b         	str	r3, [r7, #0x54]
;   return(result);
 80113dc: 6d7b         	ldr	r3, [r7, #0x54]
; 	key = __get_BASEPRI();
 80113de: 653b         	str	r3, [r7, #0x50]
 80113e0: 2310         	movs	r3, #0x10
 80113e2: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80113e4: 6cfb         	ldr	r3, [r7, #0x4c]
 80113e6: f383 8812    	msr	basepri_max, r3
; }
 80113ea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80113ec: f3bf 8f6f    	isb	sy
; }
 80113f0: bf00         	nop
; 	return key;
 80113f2: 6d3b         	ldr	r3, [r7, #0x50]
; 	k.key = arch_irq_lock();
 80113f4: 60fb         	str	r3, [r7, #0xc]
 80113f6: 6dbb         	ldr	r3, [r7, #0x58]
 80113f8: 64bb         	str	r3, [r7, #0x48]
; }
 80113fa: bf00         	nop
 80113fc: 6dbb         	ldr	r3, [r7, #0x58]
 80113fe: 647b         	str	r3, [r7, #0x44]
; }
 8011400: bf00         	nop
; 	return k;
 8011402: 68fb         	ldr	r3, [r7, #0xc]
 8011404: 613b         	str	r3, [r7, #0x10]
; 		z_mark_thread_as_suspended(thread);
 8011406: 6878         	ldr	r0, [r7, #0x4]
 8011408: f00d ffda    	bl	0x801f3c0 <z_mark_thread_as_suspended> @ imm = #0xdfb4
 801140c: 687b         	ldr	r3, [r7, #0x4]
 801140e: 66fb         	str	r3, [r7, #0x6c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8011410: 6efb         	ldr	r3, [r7, #0x6c]
 8011412: 7b5b         	ldrb	r3, [r3, #0xd]
 8011414: f003 037f    	and	r3, r3, #0x7f
 8011418: b2da         	uxtb	r2, r3
 801141a: 6efb         	ldr	r3, [r7, #0x6c]
 801141c: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 801141e: 6ef8         	ldr	r0, [r7, #0x6c]
 8011420: f00e f8ac    	bl	0x801f57c <should_queue_thread> @ imm = #0xe158
 8011424: 4603         	mov	r3, r0
 8011426: 2b00         	cmp	r3, #0x0
 8011428: d00d         	beq	0x8011446 <z_impl_k_thread_suspend+0xb2> @ imm = #0x1a
 801142a: 6efb         	ldr	r3, [r7, #0x6c]
 801142c: 66bb         	str	r3, [r7, #0x68]
 801142e: 6ebb         	ldr	r3, [r7, #0x68]
 8011430: 667b         	str	r3, [r7, #0x64]
; 	return &_kernel.ready_q.runq;
 8011432: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x80115e0 <z_impl_k_thread_suspend+0x24c>
 8011434: 663b         	str	r3, [r7, #0x60]
 8011436: 6ebb         	ldr	r3, [r7, #0x68]
 8011438: 65fb         	str	r3, [r7, #0x5c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801143a: 6dfb         	ldr	r3, [r7, #0x5c]
 801143c: 4618         	mov	r0, r3
 801143e: f00d fed2    	bl	0x801f1e6 <sys_dlist_remove> @ imm = #0xdda4
; }
 8011442: bf00         	nop
; }
 8011444: bf00         	nop
; }
 8011446: bf00         	nop
 8011448: 2301         	movs	r3, #0x1
 801144a: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	return &_kernel.ready_q.runq;
 801144e: 4b64         	ldr	r3, [pc, #0x190]        @ 0x80115e0 <z_impl_k_thread_suspend+0x24c>
 8011450: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	struct k_thread *thread = NULL;
 8011454: 2300         	movs	r3, #0x0
 8011456: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 801145a: f8d7 0098    	ldr.w	r0, [r7, #0x98]
 801145e: f00d fe55    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xdcaa
 8011462: f8c7 0090    	str.w	r0, [r7, #0x90]
; 	if (n != NULL) {
 8011466: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 801146a: 2b00         	cmp	r3, #0x0
 801146c: d003         	beq	0x8011476 <z_impl_k_thread_suspend+0xe2> @ imm = #0x6
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 801146e: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 8011472: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	return thread;
 8011476: f8d7 3094    	ldr.w	r3, [r7, #0x94]
; 	return _priq_run_best(curr_cpu_runq());
 801147a: bf00         	nop
; 	struct k_thread *thread = runq_best();
 801147c: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8011480: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8011484: 2b00         	cmp	r3, #0x0
 8011486: d102         	bne	0x801148e <z_impl_k_thread_suspend+0xfa> @ imm = #0x4
 8011488: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x80115d8 <z_impl_k_thread_suspend+0x244>
 801148a: 68db         	ldr	r3, [r3, #0xc]
 801148c: e001         	b	0x8011492 <z_impl_k_thread_suspend+0xfe> @ imm = #0x2
 801148e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	struct k_thread *thread = next_up();
 8011492: f8c7 3088    	str.w	r3, [r7, #0x88]
 8011496: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 801149a: f8c7 3084    	str.w	r3, [r7, #0x84]
 801149e: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 80114a2: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	if (preempt_ok != 0) {
 80114a6: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80114aa: 2b00         	cmp	r3, #0x0
 80114ac: d001         	beq	0x80114b2 <z_impl_k_thread_suspend+0x11e> @ imm = #0x2
; 		return true;
 80114ae: 2301         	movs	r3, #0x1
 80114b0: e028         	b	0x8011504 <z_impl_k_thread_suspend+0x170> @ imm = #0x50
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80114b2: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80115d8 <z_impl_k_thread_suspend+0x244>
 80114b4: 689b         	ldr	r3, [r3, #0x8]
 80114b6: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 80114b8: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 80114ba: 4618         	mov	r0, r3
 80114bc: f00d ff10    	bl	0x801f2e0 <z_is_thread_prevented_from_running> @ imm = #0xde20
 80114c0: 4603         	mov	r3, r0
 80114c2: 2b00         	cmp	r3, #0x0
 80114c4: d001         	beq	0x80114ca <z_impl_k_thread_suspend+0x136> @ imm = #0x2
; 		return true;
 80114c6: 2301         	movs	r3, #0x1
 80114c8: e01c         	b	0x8011504 <z_impl_k_thread_suspend+0x170> @ imm = #0x38
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80114ca: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x80115d8 <z_impl_k_thread_suspend+0x244>
 80114cc: 689b         	ldr	r3, [r3, #0x8]
 80114ce: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 80114d0: 6fbb         	ldr	r3, [r7, #0x78]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 80114d2: 4618         	mov	r0, r3
 80114d4: f00d fed5    	bl	0x801f282 <thread_is_preemptible> @ imm = #0xddaa
 80114d8: 4603         	mov	r3, r0
 80114da: 2b00         	cmp	r3, #0x0
 80114dc: d106         	bne	0x80114ec <z_impl_k_thread_suspend+0x158> @ imm = #0xc
 80114de: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 80114e2: f00d fedf    	bl	0x801f2a4 <thread_is_metairq> @ imm = #0xddbe
 80114e6: 4603         	mov	r3, r0
 80114e8: 2b00         	cmp	r3, #0x0
 80114ea: d001         	beq	0x80114f0 <z_impl_k_thread_suspend+0x15c> @ imm = #0x2
; 		return true;
 80114ec: 2301         	movs	r3, #0x1
 80114ee: e009         	b	0x8011504 <z_impl_k_thread_suspend+0x170> @ imm = #0x12
; 	    && z_is_thread_timeout_active(thread)) {
 80114f0: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 80114f4: f00d ff09    	bl	0x801f30a <z_is_thread_timeout_active> @ imm = #0xde12
 80114f8: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 80114fa: 2b00         	cmp	r3, #0x0
 80114fc: d001         	beq	0x8011502 <z_impl_k_thread_suspend+0x16e> @ imm = #0x2
; 		return true;
 80114fe: 2301         	movs	r3, #0x1
 8011500: e000         	b	0x8011504 <z_impl_k_thread_suspend+0x170> @ imm = #0x0
; 	return false;
 8011502: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8011504: 2b00         	cmp	r3, #0x0
 8011506: d014         	beq	0x8011532 <z_impl_k_thread_suspend+0x19e> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011508: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80115d8 <z_impl_k_thread_suspend+0x244>
 801150a: 689b         	ldr	r3, [r3, #0x8]
 801150c: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 801150e: 6f7b         	ldr	r3, [r7, #0x74]
; 		if (thread != arch_current_thread()) {
 8011510: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 8011514: 429a         	cmp	r2, r3
 8011516: d003         	beq	0x8011520 <z_impl_k_thread_suspend+0x18c> @ imm = #0x6
; 			z_reset_time_slice(thread);
 8011518: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 801151c: f001 f916    	bl	0x801274c <z_reset_time_slice> @ imm = #0x122c
; 		update_metairq_preempt(thread);
 8011520: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 8011524: f00e f871    	bl	0x801f60a <update_metairq_preempt> @ imm = #0xe0e2
; 		_kernel.ready_q.cache = thread;
 8011528: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x80115d8 <z_impl_k_thread_suspend+0x244>
 801152a: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 801152e: 6213         	str	r3, [r2, #0x20]
; }
 8011530: e005         	b	0x801153e <z_impl_k_thread_suspend+0x1aa> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011532: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80115d8 <z_impl_k_thread_suspend+0x244>
 8011534: 689b         	ldr	r3, [r3, #0x8]
 8011536: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 8011538: 6f3b         	ldr	r3, [r7, #0x70]
; 		_kernel.ready_q.cache = arch_current_thread();
 801153a: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x80115d8 <z_impl_k_thread_suspend+0x244>
 801153c: 6213         	str	r3, [r2, #0x20]
; }
 801153e: bf00         	nop
 8011540: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80115dc <z_impl_k_thread_suspend+0x248>
 8011542: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 8011546: 693b         	ldr	r3, [r7, #0x10]
 8011548: 60bb         	str	r3, [r7, #0x8]
 801154a: f8d7 30a4    	ldr.w	r3, [r7, #0xa4]
 801154e: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; }
 8011552: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8011554: 68bb         	ldr	r3, [r7, #0x8]
 8011556: 4618         	mov	r0, r3
 8011558: f00d ffc9    	bl	0x801f4ee <z_swap_irqlock> @ imm = #0xdf92
 801155c: e039         	b	0x80115d2 <z_impl_k_thread_suspend+0x23e> @ imm = #0x72
; 	(void)z_abort_thread_timeout(thread);
 801155e: 6878         	ldr	r0, [r7, #0x4]
 8011560: f00d fe81    	bl	0x801f266 <z_abort_thread_timeout> @ imm = #0xdd02
 8011564: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x80115dc <z_impl_k_thread_suspend+0x248>
 8011566: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8011568: f3ef 8311    	mrs	r3, basepri
 801156c: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 801156e: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 8011570: 63bb         	str	r3, [r7, #0x38]
 8011572: 2310         	movs	r3, #0x10
 8011574: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8011576: 6b7b         	ldr	r3, [r7, #0x34]
 8011578: f383 8812    	msr	basepri_max, r3
; }
 801157c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801157e: f3bf 8f6f    	isb	sy
; }
 8011582: bf00         	nop
; 	return key;
 8011584: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 8011586: 617b         	str	r3, [r7, #0x14]
 8011588: 6c3b         	ldr	r3, [r7, #0x40]
 801158a: 633b         	str	r3, [r7, #0x30]
; }
 801158c: bf00         	nop
 801158e: 6c3b         	ldr	r3, [r7, #0x40]
 8011590: 62fb         	str	r3, [r7, #0x2c]
; }
 8011592: bf00         	nop
; 	return k;
 8011594: 697b         	ldr	r3, [r7, #0x14]
 8011596: 61fb         	str	r3, [r7, #0x1c]
; 	if ((thread->base.thread_state & _THREAD_SUSPENDED) != 0U) {
 8011598: 687b         	ldr	r3, [r7, #0x4]
 801159a: 7b5b         	ldrb	r3, [r3, #0xd]
 801159c: f003 0310    	and	r3, r3, #0x10
 80115a0: 2b00         	cmp	r3, #0x0
 80115a2: d011         	beq	0x80115c8 <z_impl_k_thread_suspend+0x234> @ imm = #0x22
 80115a4: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80115dc <z_impl_k_thread_suspend+0x248>
 80115a6: 62bb         	str	r3, [r7, #0x28]
 80115a8: 69fb         	ldr	r3, [r7, #0x1c]
 80115aa: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 80115ac: 69bb         	ldr	r3, [r7, #0x18]
 80115ae: 627b         	str	r3, [r7, #0x24]
 80115b0: 6a7b         	ldr	r3, [r7, #0x24]
 80115b2: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80115b4: 6a3b         	ldr	r3, [r7, #0x20]
 80115b6: f383 8811    	msr	basepri, r3
; }
 80115ba: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80115bc: f3bf 8f6f    	isb	sy
; }
 80115c0: bf00         	nop
; }
 80115c2: bf00         	nop
; }
 80115c4: bf00         	nop
; 		return;
 80115c6: e004         	b	0x80115d2 <z_impl_k_thread_suspend+0x23e> @ imm = #0x8
; 	z_thread_halt(thread, key, false);
 80115c8: 2200         	movs	r2, #0x0
 80115ca: 69f9         	ldr	r1, [r7, #0x1c]
 80115cc: 6878         	ldr	r0, [r7, #0x4]
 80115ce: f7ff fe5b    	bl	0x8011288 <z_thread_halt> @ imm = #-0x34a
; }
 80115d2: 37b0         	adds	r7, #0xb0
 80115d4: 46bd         	mov	sp, r7
 80115d6: bd80         	pop	{r7, pc}

080115d8 <$d>:
 80115d8: 48 1d 00 20  	.word	0x20001d48
 80115dc: e0 27 00 20  	.word	0x200027e0
 80115e0: 6c 1d 00 20  	.word	0x20001d6c

080115e4 <z_impl_k_thread_resume>:
; {
 80115e4: b580         	push	{r7, lr}
 80115e6: b08e         	sub	sp, #0x38
 80115e8: af00         	add	r7, sp, #0x0
 80115ea: 6078         	str	r0, [r7, #0x4]
 80115ec: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8011670 <z_impl_k_thread_resume+0x8c>
 80115ee: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80115f0: f3ef 8311    	mrs	r3, basepri
 80115f4: 633b         	str	r3, [r7, #0x30]
;   return(result);
 80115f6: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 80115f8: 62fb         	str	r3, [r7, #0x2c]
 80115fa: 2310         	movs	r3, #0x10
 80115fc: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80115fe: 6abb         	ldr	r3, [r7, #0x28]
 8011600: f383 8812    	msr	basepri_max, r3
; }
 8011604: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011606: f3bf 8f6f    	isb	sy
; }
 801160a: bf00         	nop
; 	return key;
 801160c: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 801160e: 60bb         	str	r3, [r7, #0x8]
 8011610: 6b7b         	ldr	r3, [r7, #0x34]
 8011612: 627b         	str	r3, [r7, #0x24]
; }
 8011614: bf00         	nop
 8011616: 6b7b         	ldr	r3, [r7, #0x34]
 8011618: 623b         	str	r3, [r7, #0x20]
; }
 801161a: bf00         	nop
; 	return k;
 801161c: 68bb         	ldr	r3, [r7, #0x8]
 801161e: 613b         	str	r3, [r7, #0x10]
; 	if (!z_is_thread_suspended(thread)) {
 8011620: 6878         	ldr	r0, [r7, #0x4]
 8011622: f00d fe4a    	bl	0x801f2ba <z_is_thread_suspended> @ imm = #0xdc94
 8011626: 4603         	mov	r3, r0
 8011628: f083 0301    	eor	r3, r3, #0x1
 801162c: b2db         	uxtb	r3, r3
 801162e: 2b00         	cmp	r3, #0x0
 8011630: d010         	beq	0x8011654 <z_impl_k_thread_resume+0x70> @ imm = #0x20
 8011632: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8011670 <z_impl_k_thread_resume+0x8c>
 8011634: 61fb         	str	r3, [r7, #0x1c]
 8011636: 693b         	ldr	r3, [r7, #0x10]
 8011638: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 801163a: 68fb         	ldr	r3, [r7, #0xc]
 801163c: 61bb         	str	r3, [r7, #0x18]
 801163e: 69bb         	ldr	r3, [r7, #0x18]
 8011640: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8011642: 697b         	ldr	r3, [r7, #0x14]
 8011644: f383 8811    	msr	basepri, r3
; }
 8011648: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801164a: f3bf 8f6f    	isb	sy
; }
 801164e: bf00         	nop
; }
 8011650: bf00         	nop
; }
 8011652: e009         	b	0x8011668 <z_impl_k_thread_resume+0x84> @ imm = #0x12
; 	z_mark_thread_as_not_suspended(thread);
 8011654: 6878         	ldr	r0, [r7, #0x4]
 8011656: f00d fec4    	bl	0x801f3e2 <z_mark_thread_as_not_suspended> @ imm = #0xdd88
; 	ready_thread(thread);
 801165a: 6878         	ldr	r0, [r7, #0x4]
 801165c: f7ff fc94    	bl	0x8010f88 <ready_thread> @ imm = #-0x6d8
; 	z_reschedule(&_sched_spinlock, key);
 8011660: 6939         	ldr	r1, [r7, #0x10]
 8011662: 4803         	ldr	r0, [pc, #0xc]          @ 0x8011670 <z_impl_k_thread_resume+0x8c>
 8011664: f00e f89e    	bl	0x801f7a4 <z_reschedule> @ imm = #0xe13c
; }
 8011668: 3738         	adds	r7, #0x38
 801166a: 46bd         	mov	sp, r7
 801166c: bd80         	pop	{r7, pc}
 801166e: bf00         	nop

08011670 <$d>:
 8011670: e0 27 00 20  	.word	0x200027e0

08011674 <unready_thread>:
; {
 8011674: b580         	push	{r7, lr}
 8011676: b094         	sub	sp, #0x50
 8011678: af00         	add	r7, sp, #0x0
 801167a: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 801167c: 6878         	ldr	r0, [r7, #0x4]
 801167e: f00d fe92    	bl	0x801f3a6 <z_is_thread_queued> @ imm = #0xdd24
 8011682: 4603         	mov	r3, r0
 8011684: 2b00         	cmp	r3, #0x0
 8011686: d01d         	beq	0x80116c4 <unready_thread+0x50> @ imm = #0x3a
 8011688: 687b         	ldr	r3, [r7, #0x4]
 801168a: 64fb         	str	r3, [r7, #0x4c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 801168c: 6cfb         	ldr	r3, [r7, #0x4c]
 801168e: 7b5b         	ldrb	r3, [r3, #0xd]
 8011690: f003 037f    	and	r3, r3, #0x7f
 8011694: b2da         	uxtb	r2, r3
 8011696: 6cfb         	ldr	r3, [r7, #0x4c]
 8011698: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 801169a: 6cf8         	ldr	r0, [r7, #0x4c]
 801169c: f00d ff6e    	bl	0x801f57c <should_queue_thread> @ imm = #0xdedc
 80116a0: 4603         	mov	r3, r0
 80116a2: 2b00         	cmp	r3, #0x0
 80116a4: d00d         	beq	0x80116c2 <unready_thread+0x4e> @ imm = #0x1a
 80116a6: 6cfb         	ldr	r3, [r7, #0x4c]
 80116a8: 64bb         	str	r3, [r7, #0x48]
 80116aa: 6cbb         	ldr	r3, [r7, #0x48]
 80116ac: 647b         	str	r3, [r7, #0x44]
; 	return &_kernel.ready_q.runq;
 80116ae: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x80117a8 <unready_thread+0x134>
 80116b0: 643b         	str	r3, [r7, #0x40]
 80116b2: 6cbb         	ldr	r3, [r7, #0x48]
 80116b4: 63fb         	str	r3, [r7, #0x3c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 80116b6: 6bfb         	ldr	r3, [r7, #0x3c]
 80116b8: 4618         	mov	r0, r3
 80116ba: f00d fd94    	bl	0x801f1e6 <sys_dlist_remove> @ imm = #0xdb28
; }
 80116be: bf00         	nop
; }
 80116c0: bf00         	nop
; }
 80116c2: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80116c4: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x80117ac <unready_thread+0x138>
 80116c6: 689b         	ldr	r3, [r3, #0x8]
 80116c8: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 80116ca: 68bb         	ldr	r3, [r7, #0x8]
; 	update_cache(thread == arch_current_thread());
 80116cc: 687a         	ldr	r2, [r7, #0x4]
 80116ce: 429a         	cmp	r2, r3
 80116d0: bf0c         	ite	eq
 80116d2: 2301         	moveq	r3, #0x1
 80116d4: 2300         	movne	r3, #0x0
 80116d6: b2db         	uxtb	r3, r3
 80116d8: 63bb         	str	r3, [r7, #0x38]
; 	return &_kernel.ready_q.runq;
 80116da: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80117a8 <unready_thread+0x134>
 80116dc: 637b         	str	r3, [r7, #0x34]
; 	struct k_thread *thread = NULL;
 80116de: 2300         	movs	r3, #0x0
 80116e0: 633b         	str	r3, [r7, #0x30]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 80116e2: 6b78         	ldr	r0, [r7, #0x34]
 80116e4: f00d fd12    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xda24
 80116e8: 62f8         	str	r0, [r7, #0x2c]
; 	if (n != NULL) {
 80116ea: 6afb         	ldr	r3, [r7, #0x2c]
 80116ec: 2b00         	cmp	r3, #0x0
 80116ee: d001         	beq	0x80116f4 <unready_thread+0x80> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80116f0: 6afb         	ldr	r3, [r7, #0x2c]
 80116f2: 633b         	str	r3, [r7, #0x30]
; 	return thread;
 80116f4: 6b3b         	ldr	r3, [r7, #0x30]
; 	return _priq_run_best(curr_cpu_runq());
 80116f6: bf00         	nop
; 	struct k_thread *thread = runq_best();
 80116f8: 62bb         	str	r3, [r7, #0x28]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 80116fa: 6abb         	ldr	r3, [r7, #0x28]
 80116fc: 2b00         	cmp	r3, #0x0
 80116fe: d102         	bne	0x8011706 <unready_thread+0x92> @ imm = #0x4
 8011700: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80117ac <unready_thread+0x138>
 8011702: 68db         	ldr	r3, [r3, #0xc]
 8011704: e000         	b	0x8011708 <unready_thread+0x94> @ imm = #0x0
 8011706: 6abb         	ldr	r3, [r7, #0x28]
; 	struct k_thread *thread = next_up();
 8011708: 627b         	str	r3, [r7, #0x24]
 801170a: 6a7b         	ldr	r3, [r7, #0x24]
 801170c: 623b         	str	r3, [r7, #0x20]
 801170e: 6bbb         	ldr	r3, [r7, #0x38]
 8011710: 61fb         	str	r3, [r7, #0x1c]
; 	if (preempt_ok != 0) {
 8011712: 69fb         	ldr	r3, [r7, #0x1c]
 8011714: 2b00         	cmp	r3, #0x0
 8011716: d001         	beq	0x801171c <unready_thread+0xa8> @ imm = #0x2
; 		return true;
 8011718: 2301         	movs	r3, #0x1
 801171a: e026         	b	0x801176a <unready_thread+0xf6> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801171c: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x80117ac <unready_thread+0x138>
 801171e: 689b         	ldr	r3, [r3, #0x8]
 8011720: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 8011722: 69bb         	ldr	r3, [r7, #0x18]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8011724: 4618         	mov	r0, r3
 8011726: f00d fddb    	bl	0x801f2e0 <z_is_thread_prevented_from_running> @ imm = #0xdbb6
 801172a: 4603         	mov	r3, r0
 801172c: 2b00         	cmp	r3, #0x0
 801172e: d001         	beq	0x8011734 <unready_thread+0xc0> @ imm = #0x2
; 		return true;
 8011730: 2301         	movs	r3, #0x1
 8011732: e01a         	b	0x801176a <unready_thread+0xf6> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011734: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x80117ac <unready_thread+0x138>
 8011736: 689b         	ldr	r3, [r3, #0x8]
 8011738: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 801173a: 697b         	ldr	r3, [r7, #0x14]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 801173c: 4618         	mov	r0, r3
 801173e: f00d fda0    	bl	0x801f282 <thread_is_preemptible> @ imm = #0xdb40
 8011742: 4603         	mov	r3, r0
 8011744: 2b00         	cmp	r3, #0x0
 8011746: d105         	bne	0x8011754 <unready_thread+0xe0> @ imm = #0xa
 8011748: 6a38         	ldr	r0, [r7, #0x20]
 801174a: f00d fdab    	bl	0x801f2a4 <thread_is_metairq> @ imm = #0xdb56
 801174e: 4603         	mov	r3, r0
 8011750: 2b00         	cmp	r3, #0x0
 8011752: d001         	beq	0x8011758 <unready_thread+0xe4> @ imm = #0x2
; 		return true;
 8011754: 2301         	movs	r3, #0x1
 8011756: e008         	b	0x801176a <unready_thread+0xf6> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8011758: 6a38         	ldr	r0, [r7, #0x20]
 801175a: f00d fdd6    	bl	0x801f30a <z_is_thread_timeout_active> @ imm = #0xdbac
 801175e: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8011760: 2b00         	cmp	r3, #0x0
 8011762: d001         	beq	0x8011768 <unready_thread+0xf4> @ imm = #0x2
; 		return true;
 8011764: 2301         	movs	r3, #0x1
 8011766: e000         	b	0x801176a <unready_thread+0xf6> @ imm = #0x0
; 	return false;
 8011768: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 801176a: 2b00         	cmp	r3, #0x0
 801176c: d010         	beq	0x8011790 <unready_thread+0x11c> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801176e: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80117ac <unready_thread+0x138>
 8011770: 689b         	ldr	r3, [r3, #0x8]
 8011772: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8011774: 693b         	ldr	r3, [r7, #0x10]
; 		if (thread != arch_current_thread()) {
 8011776: 6a7a         	ldr	r2, [r7, #0x24]
 8011778: 429a         	cmp	r2, r3
 801177a: d002         	beq	0x8011782 <unready_thread+0x10e> @ imm = #0x4
; 			z_reset_time_slice(thread);
 801177c: 6a78         	ldr	r0, [r7, #0x24]
 801177e: f000 ffe5    	bl	0x801274c <z_reset_time_slice> @ imm = #0xfca
; 		update_metairq_preempt(thread);
 8011782: 6a78         	ldr	r0, [r7, #0x24]
 8011784: f00d ff41    	bl	0x801f60a <update_metairq_preempt> @ imm = #0xde82
; 		_kernel.ready_q.cache = thread;
 8011788: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80117ac <unready_thread+0x138>
 801178a: 6a7b         	ldr	r3, [r7, #0x24]
 801178c: 6213         	str	r3, [r2, #0x20]
; }
 801178e: e005         	b	0x801179c <unready_thread+0x128> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011790: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80117ac <unready_thread+0x138>
 8011792: 689b         	ldr	r3, [r3, #0x8]
 8011794: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8011796: 68fb         	ldr	r3, [r7, #0xc]
; 		_kernel.ready_q.cache = arch_current_thread();
 8011798: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80117ac <unready_thread+0x138>
 801179a: 6213         	str	r3, [r2, #0x20]
; }
 801179c: bf00         	nop
; }
 801179e: bf00         	nop
 80117a0: 3750         	adds	r7, #0x50
 80117a2: 46bd         	mov	sp, r7
 80117a4: bd80         	pop	{r7, pc}
 80117a6: bf00         	nop

080117a8 <$d>:
 80117a8: 6c 1d 00 20  	.word	0x20001d6c
 80117ac: 48 1d 00 20  	.word	0x20001d48

080117b0 <z_sched_wake_thread>:
; {
 80117b0: b580         	push	{r7, lr}
 80117b2: b090         	sub	sp, #0x40
 80117b4: af00         	add	r7, sp, #0x0
 80117b6: 6078         	str	r0, [r7, #0x4]
 80117b8: 460b         	mov	r3, r1
 80117ba: 70fb         	strb	r3, [r7, #0x3]
; 	K_SPINLOCK(&_sched_spinlock) {
 80117bc: 2300         	movs	r3, #0x0
 80117be: 617b         	str	r3, [r7, #0x14]
 80117c0: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x80118a4 <z_sched_wake_thread+0xf4>
 80117c2: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80117c4: f3ef 8311    	mrs	r3, basepri
 80117c8: 637b         	str	r3, [r7, #0x34]
;   return(result);
 80117ca: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 80117cc: 633b         	str	r3, [r7, #0x30]
 80117ce: 2310         	movs	r3, #0x10
 80117d0: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80117d2: 6afb         	ldr	r3, [r7, #0x2c]
 80117d4: f383 8812    	msr	basepri_max, r3
; }
 80117d8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80117da: f3bf 8f6f    	isb	sy
; }
 80117de: bf00         	nop
; 	return key;
 80117e0: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 80117e2: 60bb         	str	r3, [r7, #0x8]
 80117e4: 6bbb         	ldr	r3, [r7, #0x38]
 80117e6: 62bb         	str	r3, [r7, #0x28]
; }
 80117e8: bf00         	nop
 80117ea: 6bbb         	ldr	r3, [r7, #0x38]
 80117ec: 627b         	str	r3, [r7, #0x24]
; }
 80117ee: bf00         	nop
; 	return k;
 80117f0: 68bb         	ldr	r3, [r7, #0x8]
 80117f2: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 80117f4: e04d         	b	0x8011892 <z_sched_wake_thread+0xe2> @ imm = #0x9a
; 		bool killed = (thread->base.thread_state &
 80117f6: 687b         	ldr	r3, [r7, #0x4]
 80117f8: 7b5b         	ldrb	r3, [r3, #0xd]
 80117fa: f003 0328    	and	r3, r3, #0x28
 80117fe: 2b00         	cmp	r3, #0x0
 8011800: bf14         	ite	ne
 8011802: 2301         	movne	r3, #0x1
 8011804: 2300         	moveq	r3, #0x0
 8011806: f887 303f    	strb.w	r3, [r7, #0x3f]
; 		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
 801180a: 687b         	ldr	r3, [r7, #0x4]
 801180c: f893 307c    	ldrb.w	r3, [r3, #0x7c]
 8011810: 2b00         	cmp	r3, #0x0
 8011812: d004         	beq	0x801181e <z_sched_wake_thread+0x6e> @ imm = #0x8
 8011814: 78fb         	ldrb	r3, [r7, #0x3]
 8011816: 2b00         	cmp	r3, #0x0
 8011818: d001         	beq	0x801181e <z_sched_wake_thread+0x6e> @ imm = #0x2
 801181a: 2301         	movs	r3, #0x1
 801181c: e000         	b	0x8011820 <z_sched_wake_thread+0x70> @ imm = #0x0
 801181e: 2300         	movs	r3, #0x0
 8011820: f887 303e    	strb.w	r3, [r7, #0x3e]
 8011824: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 8011828: f003 0301    	and	r3, r3, #0x1
 801182c: f887 303e    	strb.w	r3, [r7, #0x3e]
; 		thread->no_wake_on_timeout = false;
 8011830: 687b         	ldr	r3, [r7, #0x4]
 8011832: 2200         	movs	r2, #0x0
 8011834: f883 207c    	strb.w	r2, [r3, #0x7c]
; 		if (do_nothing) {
 8011838: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 801183c: 2b00         	cmp	r3, #0x0
 801183e: d114         	bne	0x801186a <z_sched_wake_thread+0xba> @ imm = #0x28
; 		if (!killed) {
 8011840: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8011844: f083 0301    	eor	r3, r3, #0x1
 8011848: b2db         	uxtb	r3, r3
 801184a: 2b00         	cmp	r3, #0x0
 801184c: d00e         	beq	0x801186c <z_sched_wake_thread+0xbc> @ imm = #0x1c
; 			if (thread->base.pended_on != NULL) {
 801184e: 687b         	ldr	r3, [r7, #0x4]
 8011850: 689b         	ldr	r3, [r3, #0x8]
 8011852: 2b00         	cmp	r3, #0x0
 8011854: d002         	beq	0x801185c <z_sched_wake_thread+0xac> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 8011856: 6878         	ldr	r0, [r7, #0x4]
 8011858: f00d fe22    	bl	0x801f4a0 <unpend_thread_no_timeout> @ imm = #0xdc44
; 			z_mark_thread_as_not_suspended(thread);
 801185c: 6878         	ldr	r0, [r7, #0x4]
 801185e: f00d fdc0    	bl	0x801f3e2 <z_mark_thread_as_not_suspended> @ imm = #0xdb80
; 			ready_thread(thread);
 8011862: 6878         	ldr	r0, [r7, #0x4]
 8011864: f7ff fb90    	bl	0x8010f88 <ready_thread> @ imm = #-0x8e0
 8011868: e000         	b	0x801186c <z_sched_wake_thread+0xbc> @ imm = #0x0
; 			continue;
 801186a: bf00         	nop
 801186c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80118a4 <z_sched_wake_thread+0xf4>
 801186e: 623b         	str	r3, [r7, #0x20]
 8011870: 693b         	ldr	r3, [r7, #0x10]
 8011872: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8011874: 68fb         	ldr	r3, [r7, #0xc]
 8011876: 61fb         	str	r3, [r7, #0x1c]
 8011878: 69fb         	ldr	r3, [r7, #0x1c]
 801187a: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801187c: 69bb         	ldr	r3, [r7, #0x18]
 801187e: f383 8811    	msr	basepri, r3
; }
 8011882: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011884: f3bf 8f6f    	isb	sy
; }
 8011888: bf00         	nop
; }
 801188a: bf00         	nop
; }
 801188c: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 801188e: 2301         	movs	r3, #0x1
 8011890: 617b         	str	r3, [r7, #0x14]
 8011892: 697b         	ldr	r3, [r7, #0x14]
 8011894: 2b00         	cmp	r3, #0x0
 8011896: d0ae         	beq	0x80117f6 <z_sched_wake_thread+0x46> @ imm = #-0xa4
; }
 8011898: bf00         	nop
 801189a: bf00         	nop
 801189c: 3740         	adds	r7, #0x40
 801189e: 46bd         	mov	sp, r7
 80118a0: bd80         	pop	{r7, pc}
 80118a2: bf00         	nop

080118a4 <$d>:
 80118a4: e0 27 00 20  	.word	0x200027e0

080118a8 <z_pend_curr>:
; {
 80118a8: b580         	push	{r7, lr}
 80118aa: b092         	sub	sp, #0x48
 80118ac: af00         	add	r7, sp, #0x0
 80118ae: 60f8         	str	r0, [r7, #0xc]
 80118b0: 60b9         	str	r1, [r7, #0x8]
 80118b2: 607a         	str	r2, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80118b4: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8011928 <z_pend_curr+0x80>
 80118b6: 689b         	ldr	r3, [r3, #0x8]
 80118b8: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 80118ba: 69fb         	ldr	r3, [r7, #0x1c]
; 	pending_current = arch_current_thread();
 80118bc: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x801192c <z_pend_curr+0x84>
 80118be: 6013         	str	r3, [r2]
 80118c0: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8011930 <z_pend_curr+0x88>
 80118c2: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80118c4: f3ef 8311    	mrs	r3, basepri
 80118c8: 633b         	str	r3, [r7, #0x30]
;   return(result);
 80118ca: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 80118cc: 62fb         	str	r3, [r7, #0x2c]
 80118ce: 2310         	movs	r3, #0x10
 80118d0: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80118d2: 6abb         	ldr	r3, [r7, #0x28]
 80118d4: f383 8812    	msr	basepri_max, r3
; }
 80118d8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80118da: f3bf 8f6f    	isb	sy
; }
 80118de: bf00         	nop
; 	return key;
 80118e0: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 80118e2: 61bb         	str	r3, [r7, #0x18]
 80118e4: 6b7b         	ldr	r3, [r7, #0x34]
 80118e6: 627b         	str	r3, [r7, #0x24]
; }
 80118e8: bf00         	nop
 80118ea: 6b7b         	ldr	r3, [r7, #0x34]
 80118ec: 623b         	str	r3, [r7, #0x20]
; }
 80118ee: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80118f0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8011928 <z_pend_curr+0x80>
 80118f2: 689b         	ldr	r3, [r3, #0x8]
 80118f4: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 80118f6: 6bb8         	ldr	r0, [r7, #0x38]
; 	pend_locked(arch_current_thread(), wait_q, timeout);
 80118f8: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 80118fc: 6879         	ldr	r1, [r7, #0x4]
 80118fe: f00d ff06    	bl	0x801f70e <pend_locked> @ imm = #0xde0c
 8011902: 68fb         	ldr	r3, [r7, #0xc]
 8011904: 63fb         	str	r3, [r7, #0x3c]
; }
 8011906: bf00         	nop
 8011908: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8011930 <z_pend_curr+0x88>
 801190a: 647b         	str	r3, [r7, #0x44]
 801190c: 68bb         	ldr	r3, [r7, #0x8]
 801190e: 617b         	str	r3, [r7, #0x14]
 8011910: 6c7b         	ldr	r3, [r7, #0x44]
 8011912: 643b         	str	r3, [r7, #0x40]
 8011914: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8011916: 697b         	ldr	r3, [r7, #0x14]
 8011918: 4618         	mov	r0, r3
 801191a: f00d fde8    	bl	0x801f4ee <z_swap_irqlock> @ imm = #0xdbd0
 801191e: 4603         	mov	r3, r0
; }
 8011920: 4618         	mov	r0, r3
 8011922: 3748         	adds	r7, #0x48
 8011924: 46bd         	mov	sp, r7
 8011926: bd80         	pop	{r7, pc}

08011928 <$d>:
 8011928: 48 1d 00 20  	.word	0x20001d48
 801192c: ec 27 00 20  	.word	0x200027ec
 8011930: e0 27 00 20  	.word	0x200027e0

08011934 <z_thread_prio_set>:
; {
 8011934: b580         	push	{r7, lr}
 8011936: b0a8         	sub	sp, #0xa0
 8011938: af00         	add	r7, sp, #0x0
 801193a: 6078         	str	r0, [r7, #0x4]
 801193c: 6039         	str	r1, [r7]
; 	bool need_sched = 0;
 801193e: 2300         	movs	r3, #0x0
 8011940: f887 309f    	strb.w	r3, [r7, #0x9f]
; 	int old_prio = thread->base.prio;
 8011944: 687b         	ldr	r3, [r7, #0x4]
 8011946: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 801194a: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	K_SPINLOCK(&_sched_spinlock) {
 801194e: 2300         	movs	r3, #0x0
 8011950: 617b         	str	r3, [r7, #0x14]
 8011952: 4b95         	ldr	r3, [pc, #0x254]        @ 0x8011ba8 <z_thread_prio_set+0x274>
 8011954: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8011958: f3ef 8311    	mrs	r3, basepri
 801195c: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 8011960: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 8011964: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8011968: 2310         	movs	r3, #0x10
 801196a: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801196e: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8011972: f383 8812    	msr	basepri_max, r3
; }
 8011976: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011978: f3bf 8f6f    	isb	sy
; }
 801197c: bf00         	nop
; 	return key;
 801197e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 8011982: 60bb         	str	r3, [r7, #0x8]
 8011984: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 8011988: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 801198c: bf00         	nop
 801198e: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 8011992: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 8011996: bf00         	nop
; 	return k;
 8011998: 68bb         	ldr	r3, [r7, #0x8]
 801199a: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 801199c: e0fa         	b	0x8011b94 <z_thread_prio_set+0x260> @ imm = #0x1f4
; 		need_sched = z_is_thread_ready(thread);
 801199e: 6878         	ldr	r0, [r7, #0x4]
 80119a0: f00d fccc    	bl	0x801f33c <z_is_thread_ready> @ imm = #0xd998
 80119a4: 4603         	mov	r3, r0
 80119a6: f887 309f    	strb.w	r3, [r7, #0x9f]
; 		if (need_sched) {
 80119aa: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 80119ae: 2b00         	cmp	r3, #0x0
 80119b0: f000 80d9    	beq.w	0x8011b66 <z_thread_prio_set+0x232> @ imm = #0x1b2
 80119b4: 687b         	ldr	r3, [r7, #0x4]
 80119b6: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 80119b8: 6e7b         	ldr	r3, [r7, #0x64]
 80119ba: 7b5b         	ldrb	r3, [r3, #0xd]
 80119bc: f003 037f    	and	r3, r3, #0x7f
 80119c0: b2da         	uxtb	r2, r3
 80119c2: 6e7b         	ldr	r3, [r7, #0x64]
 80119c4: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 80119c6: 6e78         	ldr	r0, [r7, #0x64]
 80119c8: f00d fdd8    	bl	0x801f57c <should_queue_thread> @ imm = #0xdbb0
 80119cc: 4603         	mov	r3, r0
 80119ce: 2b00         	cmp	r3, #0x0
 80119d0: d00d         	beq	0x80119ee <z_thread_prio_set+0xba> @ imm = #0x1a
 80119d2: 6e7b         	ldr	r3, [r7, #0x64]
 80119d4: 663b         	str	r3, [r7, #0x60]
 80119d6: 6e3b         	ldr	r3, [r7, #0x60]
 80119d8: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 80119da: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8011bac <z_thread_prio_set+0x278>
 80119dc: 65bb         	str	r3, [r7, #0x58]
 80119de: 6e3b         	ldr	r3, [r7, #0x60]
 80119e0: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 80119e2: 6d7b         	ldr	r3, [r7, #0x54]
 80119e4: 4618         	mov	r0, r3
 80119e6: f00d fbfe    	bl	0x801f1e6 <sys_dlist_remove> @ imm = #0xd7fc
; }
 80119ea: bf00         	nop
; }
 80119ec: bf00         	nop
; }
 80119ee: bf00         	nop
; 				thread->base.prio = prio;
 80119f0: 683b         	ldr	r3, [r7]
 80119f2: b25a         	sxtb	r2, r3
 80119f4: 687b         	ldr	r3, [r7, #0x4]
 80119f6: 739a         	strb	r2, [r3, #0xe]
 80119f8: 687b         	ldr	r3, [r7, #0x4]
 80119fa: 67fb         	str	r3, [r7, #0x7c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 80119fc: 6ffb         	ldr	r3, [r7, #0x7c]
 80119fe: 7b5b         	ldrb	r3, [r3, #0xd]
 8011a00: f063 037f    	orn	r3, r3, #0x7f
 8011a04: b2da         	uxtb	r2, r3
 8011a06: 6ffb         	ldr	r3, [r7, #0x7c]
 8011a08: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8011a0a: 6ff8         	ldr	r0, [r7, #0x7c]
 8011a0c: f00d fdb6    	bl	0x801f57c <should_queue_thread> @ imm = #0xdb6c
 8011a10: 4603         	mov	r3, r0
 8011a12: 2b00         	cmp	r3, #0x0
 8011a14: d042         	beq	0x8011a9c <z_thread_prio_set+0x168> @ imm = #0x84
 8011a16: 6ffb         	ldr	r3, [r7, #0x7c]
 8011a18: 67bb         	str	r3, [r7, #0x78]
 8011a1a: 6fbb         	ldr	r3, [r7, #0x78]
 8011a1c: 677b         	str	r3, [r7, #0x74]
; 	return &_kernel.ready_q.runq;
 8011a1e: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8011bac <z_thread_prio_set+0x278>
 8011a20: 673b         	str	r3, [r7, #0x70]
 8011a22: 6fbb         	ldr	r3, [r7, #0x78]
 8011a24: 66fb         	str	r3, [r7, #0x6c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8011a26: 6f38         	ldr	r0, [r7, #0x70]
 8011a28: f00d fb70    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xd6e0
 8011a2c: 4603         	mov	r3, r0
 8011a2e: 2b00         	cmp	r3, #0x0
 8011a30: d004         	beq	0x8011a3c <z_thread_prio_set+0x108> @ imm = #0x8
 8011a32: 6f38         	ldr	r0, [r7, #0x70]
 8011a34: f00d fb6a    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xd6d4
 8011a38: 4603         	mov	r3, r0
 8011a3a: e000         	b	0x8011a3e <z_thread_prio_set+0x10a> @ imm = #0x0
 8011a3c: 2300         	movs	r3, #0x0
 8011a3e: 66bb         	str	r3, [r7, #0x68]
 8011a40: e023         	b	0x8011a8a <z_thread_prio_set+0x156> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8011a42: 6eb9         	ldr	r1, [r7, #0x68]
 8011a44: 6ef8         	ldr	r0, [r7, #0x6c]
 8011a46: f00d fd7d    	bl	0x801f544 <z_sched_prio_cmp> @ imm = #0xdafa
 8011a4a: 4603         	mov	r3, r0
 8011a4c: 2b00         	cmp	r3, #0x0
 8011a4e: dd06         	ble	0x8011a5e <z_thread_prio_set+0x12a> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8011a50: 6ebb         	ldr	r3, [r7, #0x68]
 8011a52: 6efa         	ldr	r2, [r7, #0x6c]
 8011a54: 4611         	mov	r1, r2
 8011a56: 4618         	mov	r0, r3
 8011a58: f00d fbab    	bl	0x801f1b2 <sys_dlist_insert> @ imm = #0xd756
; 			return;
 8011a5c: e01d         	b	0x8011a9a <z_thread_prio_set+0x166> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8011a5e: 6ebb         	ldr	r3, [r7, #0x68]
 8011a60: 2b00         	cmp	r3, #0x0
 8011a62: d010         	beq	0x8011a86 <z_thread_prio_set+0x152> @ imm = #0x20
 8011a64: 6ebb         	ldr	r3, [r7, #0x68]
 8011a66: 4619         	mov	r1, r3
 8011a68: 6f38         	ldr	r0, [r7, #0x70]
 8011a6a: f00d fb75    	bl	0x801f158 <sys_dlist_peek_next> @ imm = #0xd6ea
 8011a6e: 4603         	mov	r3, r0
 8011a70: 2b00         	cmp	r3, #0x0
 8011a72: d006         	beq	0x8011a82 <z_thread_prio_set+0x14e> @ imm = #0xc
 8011a74: 6ebb         	ldr	r3, [r7, #0x68]
 8011a76: 4619         	mov	r1, r3
 8011a78: 6f38         	ldr	r0, [r7, #0x70]
 8011a7a: f00d fb6d    	bl	0x801f158 <sys_dlist_peek_next> @ imm = #0xd6da
 8011a7e: 4603         	mov	r3, r0
 8011a80: e002         	b	0x8011a88 <z_thread_prio_set+0x154> @ imm = #0x4
 8011a82: 2300         	movs	r3, #0x0
 8011a84: e000         	b	0x8011a88 <z_thread_prio_set+0x154> @ imm = #0x0
 8011a86: 2300         	movs	r3, #0x0
 8011a88: 66bb         	str	r3, [r7, #0x68]
 8011a8a: 6ebb         	ldr	r3, [r7, #0x68]
 8011a8c: 2b00         	cmp	r3, #0x0
 8011a8e: d1d8         	bne	0x8011a42 <z_thread_prio_set+0x10e> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8011a90: 6efb         	ldr	r3, [r7, #0x6c]
 8011a92: 4619         	mov	r1, r3
 8011a94: 6f38         	ldr	r0, [r7, #0x70]
 8011a96: f00d fb72    	bl	0x801f17e <sys_dlist_append> @ imm = #0xd6e4
; }
 8011a9a: bf00         	nop
; }
 8011a9c: bf00         	nop
 8011a9e: 2301         	movs	r3, #0x1
 8011aa0: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 8011aa2: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8011bac <z_thread_prio_set+0x278>
 8011aa4: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 8011aa6: 2300         	movs	r3, #0x0
 8011aa8: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8011aaa: 6cf8         	ldr	r0, [r7, #0x4c]
 8011aac: f00d fb2e    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xd65c
 8011ab0: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8011ab2: 6c7b         	ldr	r3, [r7, #0x44]
 8011ab4: 2b00         	cmp	r3, #0x0
 8011ab6: d001         	beq	0x8011abc <z_thread_prio_set+0x188> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8011ab8: 6c7b         	ldr	r3, [r7, #0x44]
 8011aba: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 8011abc: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 8011abe: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8011ac0: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8011ac2: 6c3b         	ldr	r3, [r7, #0x40]
 8011ac4: 2b00         	cmp	r3, #0x0
 8011ac6: d102         	bne	0x8011ace <z_thread_prio_set+0x19a> @ imm = #0x4
 8011ac8: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8011bb0 <z_thread_prio_set+0x27c>
 8011aca: 68db         	ldr	r3, [r3, #0xc]
 8011acc: e000         	b	0x8011ad0 <z_thread_prio_set+0x19c> @ imm = #0x0
 8011ace: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 8011ad0: 63fb         	str	r3, [r7, #0x3c]
 8011ad2: 6bfb         	ldr	r3, [r7, #0x3c]
 8011ad4: 63bb         	str	r3, [r7, #0x38]
 8011ad6: 6d3b         	ldr	r3, [r7, #0x50]
 8011ad8: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 8011ada: 6b7b         	ldr	r3, [r7, #0x34]
 8011adc: 2b00         	cmp	r3, #0x0
 8011ade: d001         	beq	0x8011ae4 <z_thread_prio_set+0x1b0> @ imm = #0x2
; 		return true;
 8011ae0: 2301         	movs	r3, #0x1
 8011ae2: e026         	b	0x8011b32 <z_thread_prio_set+0x1fe> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011ae4: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8011bb0 <z_thread_prio_set+0x27c>
 8011ae6: 689b         	ldr	r3, [r3, #0x8]
 8011ae8: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 8011aea: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8011aec: 4618         	mov	r0, r3
 8011aee: f00d fbf7    	bl	0x801f2e0 <z_is_thread_prevented_from_running> @ imm = #0xd7ee
 8011af2: 4603         	mov	r3, r0
 8011af4: 2b00         	cmp	r3, #0x0
 8011af6: d001         	beq	0x8011afc <z_thread_prio_set+0x1c8> @ imm = #0x2
; 		return true;
 8011af8: 2301         	movs	r3, #0x1
 8011afa: e01a         	b	0x8011b32 <z_thread_prio_set+0x1fe> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011afc: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8011bb0 <z_thread_prio_set+0x27c>
 8011afe: 689b         	ldr	r3, [r3, #0x8]
 8011b00: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 8011b02: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8011b04: 4618         	mov	r0, r3
 8011b06: f00d fbbc    	bl	0x801f282 <thread_is_preemptible> @ imm = #0xd778
 8011b0a: 4603         	mov	r3, r0
 8011b0c: 2b00         	cmp	r3, #0x0
 8011b0e: d105         	bne	0x8011b1c <z_thread_prio_set+0x1e8> @ imm = #0xa
 8011b10: 6bb8         	ldr	r0, [r7, #0x38]
 8011b12: f00d fbc7    	bl	0x801f2a4 <thread_is_metairq> @ imm = #0xd78e
 8011b16: 4603         	mov	r3, r0
 8011b18: 2b00         	cmp	r3, #0x0
 8011b1a: d001         	beq	0x8011b20 <z_thread_prio_set+0x1ec> @ imm = #0x2
; 		return true;
 8011b1c: 2301         	movs	r3, #0x1
 8011b1e: e008         	b	0x8011b32 <z_thread_prio_set+0x1fe> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8011b20: 6bb8         	ldr	r0, [r7, #0x38]
 8011b22: f00d fbf2    	bl	0x801f30a <z_is_thread_timeout_active> @ imm = #0xd7e4
 8011b26: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8011b28: 2b00         	cmp	r3, #0x0
 8011b2a: d001         	beq	0x8011b30 <z_thread_prio_set+0x1fc> @ imm = #0x2
; 		return true;
 8011b2c: 2301         	movs	r3, #0x1
 8011b2e: e000         	b	0x8011b32 <z_thread_prio_set+0x1fe> @ imm = #0x0
; 	return false;
 8011b30: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8011b32: 2b00         	cmp	r3, #0x0
 8011b34: d010         	beq	0x8011b58 <z_thread_prio_set+0x224> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011b36: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8011bb0 <z_thread_prio_set+0x27c>
 8011b38: 689b         	ldr	r3, [r3, #0x8]
 8011b3a: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8011b3c: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 8011b3e: 6bfa         	ldr	r2, [r7, #0x3c]
 8011b40: 429a         	cmp	r2, r3
 8011b42: d002         	beq	0x8011b4a <z_thread_prio_set+0x216> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8011b44: 6bf8         	ldr	r0, [r7, #0x3c]
 8011b46: f000 fe01    	bl	0x801274c <z_reset_time_slice> @ imm = #0xc02
; 		update_metairq_preempt(thread);
 8011b4a: 6bf8         	ldr	r0, [r7, #0x3c]
 8011b4c: f00d fd5d    	bl	0x801f60a <update_metairq_preempt> @ imm = #0xdaba
; 		_kernel.ready_q.cache = thread;
 8011b50: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8011bb0 <z_thread_prio_set+0x27c>
 8011b52: 6bfb         	ldr	r3, [r7, #0x3c]
 8011b54: 6213         	str	r3, [r2, #0x20]
; }
 8011b56: e00a         	b	0x8011b6e <z_thread_prio_set+0x23a> @ imm = #0x14
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011b58: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8011bb0 <z_thread_prio_set+0x27c>
 8011b5a: 689b         	ldr	r3, [r3, #0x8]
 8011b5c: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8011b5e: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 8011b60: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x8011bb0 <z_thread_prio_set+0x27c>
 8011b62: 6213         	str	r3, [r2, #0x20]
; }
 8011b64: e003         	b	0x8011b6e <z_thread_prio_set+0x23a> @ imm = #0x6
; 			thread->base.prio = prio;
 8011b66: 683b         	ldr	r3, [r7]
 8011b68: b25a         	sxtb	r2, r3
 8011b6a: 687b         	ldr	r3, [r7, #0x4]
 8011b6c: 739a         	strb	r2, [r3, #0xe]
 8011b6e: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8011ba8 <z_thread_prio_set+0x274>
 8011b70: 623b         	str	r3, [r7, #0x20]
 8011b72: 693b         	ldr	r3, [r7, #0x10]
 8011b74: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8011b76: 68fb         	ldr	r3, [r7, #0xc]
 8011b78: 61fb         	str	r3, [r7, #0x1c]
 8011b7a: 69fb         	ldr	r3, [r7, #0x1c]
 8011b7c: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8011b7e: 69bb         	ldr	r3, [r7, #0x18]
 8011b80: f383 8811    	msr	basepri, r3
; }
 8011b84: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011b86: f3bf 8f6f    	isb	sy
; }
 8011b8a: bf00         	nop
; }
 8011b8c: bf00         	nop
; }
 8011b8e: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8011b90: 2301         	movs	r3, #0x1
 8011b92: 617b         	str	r3, [r7, #0x14]
 8011b94: 697b         	ldr	r3, [r7, #0x14]
 8011b96: 2b00         	cmp	r3, #0x0
 8011b98: f43f af01    	beq.w	0x801199e <z_thread_prio_set+0x6a> @ imm = #-0x1fe
; 	return need_sched;
 8011b9c: f897 309f    	ldrb.w	r3, [r7, #0x9f]
; }
 8011ba0: 4618         	mov	r0, r3
 8011ba2: 37a0         	adds	r7, #0xa0
 8011ba4: 46bd         	mov	sp, r7
 8011ba6: bd80         	pop	{r7, pc}

08011ba8 <$d>:
 8011ba8: e0 27 00 20  	.word	0x200027e0
 8011bac: 6c 1d 00 20  	.word	0x20001d6c
 8011bb0: 48 1d 00 20  	.word	0x20001d48

08011bb4 <need_swap>:
; {
 8011bb4: b480         	push	{r7}
 8011bb6: b083         	sub	sp, #0xc
 8011bb8: af00         	add	r7, sp, #0x0
; 	new_thread = _kernel.ready_q.cache;
 8011bba: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8011be0 <need_swap+0x2c>
 8011bbc: 6a1b         	ldr	r3, [r3, #0x20]
 8011bbe: 607b         	str	r3, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011bc0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8011be0 <need_swap+0x2c>
 8011bc2: 689b         	ldr	r3, [r3, #0x8]
 8011bc4: 603b         	str	r3, [r7]
; 	return ret;
 8011bc6: 683b         	ldr	r3, [r7]
; 	return new_thread != arch_current_thread();
 8011bc8: 687a         	ldr	r2, [r7, #0x4]
 8011bca: 429a         	cmp	r2, r3
 8011bcc: bf14         	ite	ne
 8011bce: 2301         	movne	r3, #0x1
 8011bd0: 2300         	moveq	r3, #0x0
 8011bd2: b2db         	uxtb	r3, r3
; }
 8011bd4: 4618         	mov	r0, r3
 8011bd6: 370c         	adds	r7, #0xc
 8011bd8: 46bd         	mov	sp, r7
 8011bda: f85d 7b04    	ldr	r7, [sp], #4
 8011bde: 4770         	bx	lr

08011be0 <$d>:
 8011be0: 48 1d 00 20  	.word	0x20001d48

08011be4 <k_sched_lock>:
; {
 8011be4: b580         	push	{r7, lr}
 8011be6: b08e         	sub	sp, #0x38
 8011be8: af00         	add	r7, sp, #0x0
; 	K_SPINLOCK(&_sched_spinlock) {
 8011bea: 2300         	movs	r3, #0x0
 8011bec: 613b         	str	r3, [r7, #0x10]
 8011bee: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8011c60 <k_sched_lock+0x7c>
 8011bf0: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8011bf2: f3ef 8311    	mrs	r3, basepri
 8011bf6: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8011bf8: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 8011bfa: 62fb         	str	r3, [r7, #0x2c]
 8011bfc: 2310         	movs	r3, #0x10
 8011bfe: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8011c00: 6abb         	ldr	r3, [r7, #0x28]
 8011c02: f383 8812    	msr	basepri_max, r3
; }
 8011c06: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011c08: f3bf 8f6f    	isb	sy
; }
 8011c0c: bf00         	nop
; 	return key;
 8011c0e: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 8011c10: 607b         	str	r3, [r7, #0x4]
 8011c12: 6b7b         	ldr	r3, [r7, #0x34]
 8011c14: 627b         	str	r3, [r7, #0x24]
; }
 8011c16: bf00         	nop
 8011c18: 6b7b         	ldr	r3, [r7, #0x34]
 8011c1a: 623b         	str	r3, [r7, #0x20]
; }
 8011c1c: bf00         	nop
; 	return k;
 8011c1e: 687b         	ldr	r3, [r7, #0x4]
 8011c20: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&_sched_spinlock) {
 8011c22: e014         	b	0x8011c4e <k_sched_lock+0x6a> @ imm = #0x28
; 		z_sched_lock();
 8011c24: f7ff f888    	bl	0x8010d38 <z_sched_lock> @ imm = #-0xef0
 8011c28: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8011c60 <k_sched_lock+0x7c>
 8011c2a: 61fb         	str	r3, [r7, #0x1c]
 8011c2c: 68fb         	ldr	r3, [r7, #0xc]
 8011c2e: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8011c30: 68bb         	ldr	r3, [r7, #0x8]
 8011c32: 61bb         	str	r3, [r7, #0x18]
 8011c34: 69bb         	ldr	r3, [r7, #0x18]
 8011c36: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8011c38: 697b         	ldr	r3, [r7, #0x14]
 8011c3a: f383 8811    	msr	basepri, r3
; }
 8011c3e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011c40: f3bf 8f6f    	isb	sy
; }
 8011c44: bf00         	nop
; }
 8011c46: bf00         	nop
; }
 8011c48: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8011c4a: 2301         	movs	r3, #0x1
 8011c4c: 613b         	str	r3, [r7, #0x10]
 8011c4e: 693b         	ldr	r3, [r7, #0x10]
 8011c50: 2b00         	cmp	r3, #0x0
 8011c52: d0e7         	beq	0x8011c24 <k_sched_lock+0x40> @ imm = #-0x32
; }
 8011c54: bf00         	nop
 8011c56: bf00         	nop
 8011c58: 3738         	adds	r7, #0x38
 8011c5a: 46bd         	mov	sp, r7
 8011c5c: bd80         	pop	{r7, pc}
 8011c5e: bf00         	nop

08011c60 <$d>:
 8011c60: e0 27 00 20  	.word	0x200027e0

08011c64 <k_sched_unlock>:
; {
 8011c64: b580         	push	{r7, lr}
 8011c66: b0a4         	sub	sp, #0x90
 8011c68: af06         	add	r7, sp, #0x18
; 	K_SPINLOCK(&_sched_spinlock) {
 8011c6a: 2300         	movs	r3, #0x0
 8011c6c: 60fb         	str	r3, [r7, #0xc]
 8011c6e: 4b66         	ldr	r3, [pc, #0x198]        @ 0x8011e08 <k_sched_unlock+0x1a4>
 8011c70: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8011c72: f3ef 8311    	mrs	r3, basepri
 8011c76: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 8011c78: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 8011c7a: 667b         	str	r3, [r7, #0x64]
 8011c7c: 2310         	movs	r3, #0x10
 8011c7e: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8011c80: 6e3b         	ldr	r3, [r7, #0x60]
 8011c82: f383 8812    	msr	basepri_max, r3
; }
 8011c86: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011c88: f3bf 8f6f    	isb	sy
; }
 8011c8c: bf00         	nop
; 	return key;
 8011c8e: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 8011c90: 603b         	str	r3, [r7]
 8011c92: 6efb         	ldr	r3, [r7, #0x6c]
 8011c94: 65fb         	str	r3, [r7, #0x5c]
; }
 8011c96: bf00         	nop
 8011c98: 6efb         	ldr	r3, [r7, #0x6c]
 8011c9a: 65bb         	str	r3, [r7, #0x58]
; }
 8011c9c: bf00         	nop
; 	return k;
 8011c9e: 683b         	ldr	r3, [r7]
 8011ca0: 60bb         	str	r3, [r7, #0x8]
; 	K_SPINLOCK(&_sched_spinlock) {
 8011ca2: e07e         	b	0x8011da2 <k_sched_unlock+0x13e> @ imm = #0xfc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011ca4: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8011e0c <k_sched_unlock+0x1a8>
 8011ca6: 689b         	ldr	r3, [r3, #0x8]
 8011ca8: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 8011caa: 69bb         	ldr	r3, [r7, #0x18]
; 		++arch_current_thread()->base.sched_locked;
 8011cac: 7bda         	ldrb	r2, [r3, #0xf]
 8011cae: 3201         	adds	r2, #0x1
 8011cb0: b2d2         	uxtb	r2, r2
 8011cb2: 73da         	strb	r2, [r3, #0xf]
 8011cb4: 2300         	movs	r3, #0x0
 8011cb6: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 8011cb8: 4b55         	ldr	r3, [pc, #0x154]        @ 0x8011e10 <k_sched_unlock+0x1ac>
 8011cba: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 8011cbc: 2300         	movs	r3, #0x0
 8011cbe: 643b         	str	r3, [r7, #0x40]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8011cc0: 6c78         	ldr	r0, [r7, #0x44]
 8011cc2: f00d fa23    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xd446
 8011cc6: 63f8         	str	r0, [r7, #0x3c]
; 	if (n != NULL) {
 8011cc8: 6bfb         	ldr	r3, [r7, #0x3c]
 8011cca: 2b00         	cmp	r3, #0x0
 8011ccc: d001         	beq	0x8011cd2 <k_sched_unlock+0x6e> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8011cce: 6bfb         	ldr	r3, [r7, #0x3c]
 8011cd0: 643b         	str	r3, [r7, #0x40]
; 	return thread;
 8011cd2: 6c3b         	ldr	r3, [r7, #0x40]
; 	return _priq_run_best(curr_cpu_runq());
 8011cd4: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8011cd6: 63bb         	str	r3, [r7, #0x38]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8011cd8: 6bbb         	ldr	r3, [r7, #0x38]
 8011cda: 2b00         	cmp	r3, #0x0
 8011cdc: d102         	bne	0x8011ce4 <k_sched_unlock+0x80> @ imm = #0x4
 8011cde: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8011e0c <k_sched_unlock+0x1a8>
 8011ce0: 68db         	ldr	r3, [r3, #0xc]
 8011ce2: e000         	b	0x8011ce6 <k_sched_unlock+0x82> @ imm = #0x0
 8011ce4: 6bbb         	ldr	r3, [r7, #0x38]
; 	struct k_thread *thread = next_up();
 8011ce6: 637b         	str	r3, [r7, #0x34]
 8011ce8: 6b7b         	ldr	r3, [r7, #0x34]
 8011cea: 633b         	str	r3, [r7, #0x30]
 8011cec: 6cbb         	ldr	r3, [r7, #0x48]
 8011cee: 62fb         	str	r3, [r7, #0x2c]
; 	if (preempt_ok != 0) {
 8011cf0: 6afb         	ldr	r3, [r7, #0x2c]
 8011cf2: 2b00         	cmp	r3, #0x0
 8011cf4: d001         	beq	0x8011cfa <k_sched_unlock+0x96> @ imm = #0x2
; 		return true;
 8011cf6: 2301         	movs	r3, #0x1
 8011cf8: e026         	b	0x8011d48 <k_sched_unlock+0xe4> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011cfa: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8011e0c <k_sched_unlock+0x1a8>
 8011cfc: 689b         	ldr	r3, [r3, #0x8]
 8011cfe: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8011d00: 6abb         	ldr	r3, [r7, #0x28]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8011d02: 4618         	mov	r0, r3
 8011d04: f00d faec    	bl	0x801f2e0 <z_is_thread_prevented_from_running> @ imm = #0xd5d8
 8011d08: 4603         	mov	r3, r0
 8011d0a: 2b00         	cmp	r3, #0x0
 8011d0c: d001         	beq	0x8011d12 <k_sched_unlock+0xae> @ imm = #0x2
; 		return true;
 8011d0e: 2301         	movs	r3, #0x1
 8011d10: e01a         	b	0x8011d48 <k_sched_unlock+0xe4> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011d12: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8011e0c <k_sched_unlock+0x1a8>
 8011d14: 689b         	ldr	r3, [r3, #0x8]
 8011d16: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8011d18: 6a7b         	ldr	r3, [r7, #0x24]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8011d1a: 4618         	mov	r0, r3
 8011d1c: f00d fab1    	bl	0x801f282 <thread_is_preemptible> @ imm = #0xd562
 8011d20: 4603         	mov	r3, r0
 8011d22: 2b00         	cmp	r3, #0x0
 8011d24: d105         	bne	0x8011d32 <k_sched_unlock+0xce> @ imm = #0xa
 8011d26: 6b38         	ldr	r0, [r7, #0x30]
 8011d28: f00d fabc    	bl	0x801f2a4 <thread_is_metairq> @ imm = #0xd578
 8011d2c: 4603         	mov	r3, r0
 8011d2e: 2b00         	cmp	r3, #0x0
 8011d30: d001         	beq	0x8011d36 <k_sched_unlock+0xd2> @ imm = #0x2
; 		return true;
 8011d32: 2301         	movs	r3, #0x1
 8011d34: e008         	b	0x8011d48 <k_sched_unlock+0xe4> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8011d36: 6b38         	ldr	r0, [r7, #0x30]
 8011d38: f00d fae7    	bl	0x801f30a <z_is_thread_timeout_active> @ imm = #0xd5ce
 8011d3c: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8011d3e: 2b00         	cmp	r3, #0x0
 8011d40: d001         	beq	0x8011d46 <k_sched_unlock+0xe2> @ imm = #0x2
; 		return true;
 8011d42: 2301         	movs	r3, #0x1
 8011d44: e000         	b	0x8011d48 <k_sched_unlock+0xe4> @ imm = #0x0
; 	return false;
 8011d46: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8011d48: 2b00         	cmp	r3, #0x0
 8011d4a: d010         	beq	0x8011d6e <k_sched_unlock+0x10a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011d4c: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8011e0c <k_sched_unlock+0x1a8>
 8011d4e: 689b         	ldr	r3, [r3, #0x8]
 8011d50: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 8011d52: 6a3b         	ldr	r3, [r7, #0x20]
; 		if (thread != arch_current_thread()) {
 8011d54: 6b7a         	ldr	r2, [r7, #0x34]
 8011d56: 429a         	cmp	r2, r3
 8011d58: d002         	beq	0x8011d60 <k_sched_unlock+0xfc> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8011d5a: 6b78         	ldr	r0, [r7, #0x34]
 8011d5c: f000 fcf6    	bl	0x801274c <z_reset_time_slice> @ imm = #0x9ec
; 		update_metairq_preempt(thread);
 8011d60: 6b78         	ldr	r0, [r7, #0x34]
 8011d62: f00d fc52    	bl	0x801f60a <update_metairq_preempt> @ imm = #0xd8a4
; 		_kernel.ready_q.cache = thread;
 8011d66: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x8011e0c <k_sched_unlock+0x1a8>
 8011d68: 6b7b         	ldr	r3, [r7, #0x34]
 8011d6a: 6213         	str	r3, [r2, #0x20]
; }
 8011d6c: e005         	b	0x8011d7a <k_sched_unlock+0x116> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011d6e: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8011e0c <k_sched_unlock+0x1a8>
 8011d70: 689b         	ldr	r3, [r3, #0x8]
 8011d72: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 8011d74: 69fb         	ldr	r3, [r7, #0x1c]
; 		_kernel.ready_q.cache = arch_current_thread();
 8011d76: 4a25         	ldr	r2, [pc, #0x94]         @ 0x8011e0c <k_sched_unlock+0x1a8>
 8011d78: 6213         	str	r3, [r2, #0x20]
; }
 8011d7a: bf00         	nop
 8011d7c: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8011e08 <k_sched_unlock+0x1a4>
 8011d7e: 657b         	str	r3, [r7, #0x54]
 8011d80: 68bb         	ldr	r3, [r7, #0x8]
 8011d82: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 8011d84: 687b         	ldr	r3, [r7, #0x4]
 8011d86: 653b         	str	r3, [r7, #0x50]
 8011d88: 6d3b         	ldr	r3, [r7, #0x50]
 8011d8a: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8011d8c: 6cfb         	ldr	r3, [r7, #0x4c]
 8011d8e: f383 8811    	msr	basepri, r3
; }
 8011d92: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011d94: f3bf 8f6f    	isb	sy
; }
 8011d98: bf00         	nop
; }
 8011d9a: bf00         	nop
; }
 8011d9c: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 8011d9e: 2301         	movs	r3, #0x1
 8011da0: 60fb         	str	r3, [r7, #0xc]
 8011da2: 68fb         	ldr	r3, [r7, #0xc]
 8011da4: 2b00         	cmp	r3, #0x0
 8011da6: f43f af7d    	beq.w	0x8011ca4 <k_sched_unlock+0x40> @ imm = #-0x106
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 8011daa: 2303         	movs	r3, #0x3
 8011dac: 2b03         	cmp	r3, #0x3
 8011dae: d925         	bls	0x8011dfc <k_sched_unlock+0x198> @ imm = #0x4a
 8011db0: 2301         	movs	r3, #0x1
 8011db2: f887 3077    	strb.w	r3, [r7, #0x77]
 8011db6: f897 3077    	ldrb.w	r3, [r7, #0x77]
 8011dba: f083 0301    	eor	r3, r3, #0x1
 8011dbe: b2db         	uxtb	r3, r3
 8011dc0: 2b00         	cmp	r3, #0x0
 8011dc2: d11b         	bne	0x8011dfc <k_sched_unlock+0x198> @ imm = #0x36
 8011dc4: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8011e14 <k_sched_unlock+0x1b0>
 8011dc6: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011dc8: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8011e0c <k_sched_unlock+0x1a8>
 8011dca: 689b         	ldr	r3, [r3, #0x8]
 8011dcc: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8011dce: 693b         	ldr	r3, [r7, #0x10]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011dd0: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8011e0c <k_sched_unlock+0x1a8>
 8011dd2: 6892         	ldr	r2, [r2, #0x8]
 8011dd4: 617a         	str	r2, [r7, #0x14]
; 	return ret;
 8011dd6: 697a         	ldr	r2, [r7, #0x14]
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 8011dd8: 7bd2         	ldrb	r2, [r2, #0xf]
 8011dda: 9205         	str	r2, [sp, #0x14]
 8011ddc: 9304         	str	r3, [sp, #0x10]
 8011dde: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8011e18 <k_sched_unlock+0x1b4>
 8011de0: 9303         	str	r3, [sp, #0xc]
 8011de2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8011e1c <k_sched_unlock+0x1b8>
 8011de4: 9302         	str	r3, [sp, #0x8]
 8011de6: 2308         	movs	r3, #0x8
 8011de8: 9301         	str	r3, [sp, #0x4]
 8011dea: 2300         	movs	r3, #0x0
 8011dec: 9300         	str	r3, [sp]
 8011dee: 2300         	movs	r3, #0x0
 8011df0: 2204         	movs	r2, #0x4
 8011df2: 2000         	movs	r0, #0x0
 8011df4: f00d fb88    	bl	0x801f508 <z_log_msg_runtime_create> @ imm = #0xd710
 8011df8: 2300         	movs	r3, #0x0
 8011dfa: 673b         	str	r3, [r7, #0x70]
; 	z_reschedule_unlocked();
 8011dfc: f00d fb37    	bl	0x801f46e <z_reschedule_unlocked> @ imm = #0xd66e
; }
 8011e00: bf00         	nop
 8011e02: 3778         	adds	r7, #0x78
 8011e04: 46bd         	mov	sp, r7
 8011e06: bd80         	pop	{r7, pc}

08011e08 <$d>:
 8011e08: e0 27 00 20  	.word	0x200027e0
 8011e0c: 48 1d 00 20  	.word	0x20001d48
 8011e10: 6c 1d 00 20  	.word	0x20001d6c
 8011e14: 14 06 00 20  	.word	0x20000614
 8011e18: f0 2e 02 08  	.word	0x08022ef0
 8011e1c: 30 22 02 08  	.word	0x08022230

08011e20 <z_sched_init>:
; {
 8011e20: b580         	push	{r7, lr}
 8011e22: af00         	add	r7, sp, #0x0
; 	init_ready_q(&_kernel.ready_q);
 8011e24: 4802         	ldr	r0, [pc, #0x8]          @ 0x8011e30 <z_sched_init+0x10>
 8011e26: f00d fd12    	bl	0x801f84e <init_ready_q> @ imm = #0xda24
; }
 8011e2a: bf00         	nop
 8011e2c: bd80         	pop	{r7, pc}
 8011e2e: bf00         	nop

08011e30 <$d>:
 8011e30: 68 1d 00 20  	.word	0x20001d68

08011e34 <z_impl_k_yield>:
; {
 8011e34: b580         	push	{r7, lr}
 8011e36: b0a4         	sub	sp, #0x90
 8011e38: af00         	add	r7, sp, #0x0
 8011e3a: 4b86         	ldr	r3, [pc, #0x218]        @ 0x8012054 <z_impl_k_yield+0x220>
 8011e3c: f8c7 308c    	str.w	r3, [r7, #0x8c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8011e40: f3ef 8311    	mrs	r3, basepri
 8011e44: f8c7 3088    	str.w	r3, [r7, #0x88]
;   return(result);
 8011e48: f8d7 3088    	ldr.w	r3, [r7, #0x88]
; 	key = __get_BASEPRI();
 8011e4c: f8c7 3084    	str.w	r3, [r7, #0x84]
 8011e50: 2310         	movs	r3, #0x10
 8011e52: f8c7 3080    	str.w	r3, [r7, #0x80]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8011e56: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8011e5a: f383 8812    	msr	basepri_max, r3
; }
 8011e5e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011e60: f3bf 8f6f    	isb	sy
; }
 8011e64: bf00         	nop
; 	return key;
 8011e66: f8d7 3084    	ldr.w	r3, [r7, #0x84]
; 	k.key = arch_irq_lock();
 8011e6a: 603b         	str	r3, [r7]
 8011e6c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8011e70: 67fb         	str	r3, [r7, #0x7c]
; }
 8011e72: bf00         	nop
 8011e74: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8011e78: 67bb         	str	r3, [r7, #0x78]
; }
 8011e7a: bf00         	nop
; 	return k;
 8011e7c: 683b         	ldr	r3, [r7]
 8011e7e: 60bb         	str	r3, [r7, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011e80: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x8012058 <z_impl_k_yield+0x224>
 8011e82: 689b         	ldr	r3, [r3, #0x8]
 8011e84: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8011e86: 68fb         	ldr	r3, [r7, #0xc]
 8011e88: 623b         	str	r3, [r7, #0x20]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 8011e8a: 6a3b         	ldr	r3, [r7, #0x20]
 8011e8c: 7b5b         	ldrb	r3, [r3, #0xd]
 8011e8e: f003 037f    	and	r3, r3, #0x7f
 8011e92: b2da         	uxtb	r2, r3
 8011e94: 6a3b         	ldr	r3, [r7, #0x20]
 8011e96: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8011e98: 6a38         	ldr	r0, [r7, #0x20]
 8011e9a: f00d fb6f    	bl	0x801f57c <should_queue_thread> @ imm = #0xd6de
 8011e9e: 4603         	mov	r3, r0
 8011ea0: 2b00         	cmp	r3, #0x0
 8011ea2: d00d         	beq	0x8011ec0 <z_impl_k_yield+0x8c> @ imm = #0x1a
 8011ea4: 6a3b         	ldr	r3, [r7, #0x20]
 8011ea6: 61fb         	str	r3, [r7, #0x1c]
 8011ea8: 69fb         	ldr	r3, [r7, #0x1c]
 8011eaa: 61bb         	str	r3, [r7, #0x18]
; 	return &_kernel.ready_q.runq;
 8011eac: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x801205c <z_impl_k_yield+0x228>
 8011eae: 617b         	str	r3, [r7, #0x14]
 8011eb0: 69fb         	ldr	r3, [r7, #0x1c]
 8011eb2: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8011eb4: 693b         	ldr	r3, [r7, #0x10]
 8011eb6: 4618         	mov	r0, r3
 8011eb8: f00d f995    	bl	0x801f1e6 <sys_dlist_remove> @ imm = #0xd32a
; }
 8011ebc: bf00         	nop
; }
 8011ebe: bf00         	nop
; }
 8011ec0: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011ec2: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8012058 <z_impl_k_yield+0x224>
 8011ec4: 689b         	ldr	r3, [r3, #0x8]
 8011ec6: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8011ec8: 6a7b         	ldr	r3, [r7, #0x24]
 8011eca: 63fb         	str	r3, [r7, #0x3c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 8011ecc: 6bfb         	ldr	r3, [r7, #0x3c]
 8011ece: 7b5b         	ldrb	r3, [r3, #0xd]
 8011ed0: f063 037f    	orn	r3, r3, #0x7f
 8011ed4: b2da         	uxtb	r2, r3
 8011ed6: 6bfb         	ldr	r3, [r7, #0x3c]
 8011ed8: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 8011eda: 6bf8         	ldr	r0, [r7, #0x3c]
 8011edc: f00d fb4e    	bl	0x801f57c <should_queue_thread> @ imm = #0xd69c
 8011ee0: 4603         	mov	r3, r0
 8011ee2: 2b00         	cmp	r3, #0x0
 8011ee4: d042         	beq	0x8011f6c <z_impl_k_yield+0x138> @ imm = #0x84
 8011ee6: 6bfb         	ldr	r3, [r7, #0x3c]
 8011ee8: 63bb         	str	r3, [r7, #0x38]
 8011eea: 6bbb         	ldr	r3, [r7, #0x38]
 8011eec: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 8011eee: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x801205c <z_impl_k_yield+0x228>
 8011ef0: 633b         	str	r3, [r7, #0x30]
 8011ef2: 6bbb         	ldr	r3, [r7, #0x38]
 8011ef4: 62fb         	str	r3, [r7, #0x2c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8011ef6: 6b38         	ldr	r0, [r7, #0x30]
 8011ef8: f00d f908    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xd210
 8011efc: 4603         	mov	r3, r0
 8011efe: 2b00         	cmp	r3, #0x0
 8011f00: d004         	beq	0x8011f0c <z_impl_k_yield+0xd8> @ imm = #0x8
 8011f02: 6b38         	ldr	r0, [r7, #0x30]
 8011f04: f00d f902    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xd204
 8011f08: 4603         	mov	r3, r0
 8011f0a: e000         	b	0x8011f0e <z_impl_k_yield+0xda> @ imm = #0x0
 8011f0c: 2300         	movs	r3, #0x0
 8011f0e: 62bb         	str	r3, [r7, #0x28]
 8011f10: e023         	b	0x8011f5a <z_impl_k_yield+0x126> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8011f12: 6ab9         	ldr	r1, [r7, #0x28]
 8011f14: 6af8         	ldr	r0, [r7, #0x2c]
 8011f16: f00d fb15    	bl	0x801f544 <z_sched_prio_cmp> @ imm = #0xd62a
 8011f1a: 4603         	mov	r3, r0
 8011f1c: 2b00         	cmp	r3, #0x0
 8011f1e: dd06         	ble	0x8011f2e <z_impl_k_yield+0xfa> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8011f20: 6abb         	ldr	r3, [r7, #0x28]
 8011f22: 6afa         	ldr	r2, [r7, #0x2c]
 8011f24: 4611         	mov	r1, r2
 8011f26: 4618         	mov	r0, r3
 8011f28: f00d f943    	bl	0x801f1b2 <sys_dlist_insert> @ imm = #0xd286
; 			return;
 8011f2c: e01d         	b	0x8011f6a <z_impl_k_yield+0x136> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8011f2e: 6abb         	ldr	r3, [r7, #0x28]
 8011f30: 2b00         	cmp	r3, #0x0
 8011f32: d010         	beq	0x8011f56 <z_impl_k_yield+0x122> @ imm = #0x20
 8011f34: 6abb         	ldr	r3, [r7, #0x28]
 8011f36: 4619         	mov	r1, r3
 8011f38: 6b38         	ldr	r0, [r7, #0x30]
 8011f3a: f00d f90d    	bl	0x801f158 <sys_dlist_peek_next> @ imm = #0xd21a
 8011f3e: 4603         	mov	r3, r0
 8011f40: 2b00         	cmp	r3, #0x0
 8011f42: d006         	beq	0x8011f52 <z_impl_k_yield+0x11e> @ imm = #0xc
 8011f44: 6abb         	ldr	r3, [r7, #0x28]
 8011f46: 4619         	mov	r1, r3
 8011f48: 6b38         	ldr	r0, [r7, #0x30]
 8011f4a: f00d f905    	bl	0x801f158 <sys_dlist_peek_next> @ imm = #0xd20a
 8011f4e: 4603         	mov	r3, r0
 8011f50: e002         	b	0x8011f58 <z_impl_k_yield+0x124> @ imm = #0x4
 8011f52: 2300         	movs	r3, #0x0
 8011f54: e000         	b	0x8011f58 <z_impl_k_yield+0x124> @ imm = #0x0
 8011f56: 2300         	movs	r3, #0x0
 8011f58: 62bb         	str	r3, [r7, #0x28]
 8011f5a: 6abb         	ldr	r3, [r7, #0x28]
 8011f5c: 2b00         	cmp	r3, #0x0
 8011f5e: d1d8         	bne	0x8011f12 <z_impl_k_yield+0xde> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8011f60: 6afb         	ldr	r3, [r7, #0x2c]
 8011f62: 4619         	mov	r1, r3
 8011f64: 6b38         	ldr	r0, [r7, #0x30]
 8011f66: f00d f90a    	bl	0x801f17e <sys_dlist_append> @ imm = #0xd214
; }
 8011f6a: bf00         	nop
; }
 8011f6c: bf00         	nop
 8011f6e: 2301         	movs	r3, #0x1
 8011f70: 66fb         	str	r3, [r7, #0x6c]
; 	return &_kernel.ready_q.runq;
 8011f72: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x801205c <z_impl_k_yield+0x228>
 8011f74: 66bb         	str	r3, [r7, #0x68]
; 	struct k_thread *thread = NULL;
 8011f76: 2300         	movs	r3, #0x0
 8011f78: 667b         	str	r3, [r7, #0x64]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8011f7a: 6eb8         	ldr	r0, [r7, #0x68]
 8011f7c: f00d f8c6    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xd18c
 8011f80: 6638         	str	r0, [r7, #0x60]
; 	if (n != NULL) {
 8011f82: 6e3b         	ldr	r3, [r7, #0x60]
 8011f84: 2b00         	cmp	r3, #0x0
 8011f86: d001         	beq	0x8011f8c <z_impl_k_yield+0x158> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8011f88: 6e3b         	ldr	r3, [r7, #0x60]
 8011f8a: 667b         	str	r3, [r7, #0x64]
; 	return thread;
 8011f8c: 6e7b         	ldr	r3, [r7, #0x64]
; 	return _priq_run_best(curr_cpu_runq());
 8011f8e: bf00         	nop
; 	struct k_thread *thread = runq_best();
 8011f90: 65fb         	str	r3, [r7, #0x5c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 8011f92: 6dfb         	ldr	r3, [r7, #0x5c]
 8011f94: 2b00         	cmp	r3, #0x0
 8011f96: d102         	bne	0x8011f9e <z_impl_k_yield+0x16a> @ imm = #0x4
 8011f98: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8012058 <z_impl_k_yield+0x224>
 8011f9a: 68db         	ldr	r3, [r3, #0xc]
 8011f9c: e000         	b	0x8011fa0 <z_impl_k_yield+0x16c> @ imm = #0x0
 8011f9e: 6dfb         	ldr	r3, [r7, #0x5c]
; 	struct k_thread *thread = next_up();
 8011fa0: 65bb         	str	r3, [r7, #0x58]
 8011fa2: 6dbb         	ldr	r3, [r7, #0x58]
 8011fa4: 657b         	str	r3, [r7, #0x54]
 8011fa6: 6efb         	ldr	r3, [r7, #0x6c]
 8011fa8: 653b         	str	r3, [r7, #0x50]
; 	if (preempt_ok != 0) {
 8011faa: 6d3b         	ldr	r3, [r7, #0x50]
 8011fac: 2b00         	cmp	r3, #0x0
 8011fae: d001         	beq	0x8011fb4 <z_impl_k_yield+0x180> @ imm = #0x2
; 		return true;
 8011fb0: 2301         	movs	r3, #0x1
 8011fb2: e026         	b	0x8012002 <z_impl_k_yield+0x1ce> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011fb4: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8012058 <z_impl_k_yield+0x224>
 8011fb6: 689b         	ldr	r3, [r3, #0x8]
 8011fb8: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 8011fba: 6cfb         	ldr	r3, [r7, #0x4c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8011fbc: 4618         	mov	r0, r3
 8011fbe: f00d f98f    	bl	0x801f2e0 <z_is_thread_prevented_from_running> @ imm = #0xd31e
 8011fc2: 4603         	mov	r3, r0
 8011fc4: 2b00         	cmp	r3, #0x0
 8011fc6: d001         	beq	0x8011fcc <z_impl_k_yield+0x198> @ imm = #0x2
; 		return true;
 8011fc8: 2301         	movs	r3, #0x1
 8011fca: e01a         	b	0x8012002 <z_impl_k_yield+0x1ce> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8011fcc: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8012058 <z_impl_k_yield+0x224>
 8011fce: 689b         	ldr	r3, [r3, #0x8]
 8011fd0: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 8011fd2: 6cbb         	ldr	r3, [r7, #0x48]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 8011fd4: 4618         	mov	r0, r3
 8011fd6: f00d f954    	bl	0x801f282 <thread_is_preemptible> @ imm = #0xd2a8
 8011fda: 4603         	mov	r3, r0
 8011fdc: 2b00         	cmp	r3, #0x0
 8011fde: d105         	bne	0x8011fec <z_impl_k_yield+0x1b8> @ imm = #0xa
 8011fe0: 6d78         	ldr	r0, [r7, #0x54]
 8011fe2: f00d f95f    	bl	0x801f2a4 <thread_is_metairq> @ imm = #0xd2be
 8011fe6: 4603         	mov	r3, r0
 8011fe8: 2b00         	cmp	r3, #0x0
 8011fea: d001         	beq	0x8011ff0 <z_impl_k_yield+0x1bc> @ imm = #0x2
; 		return true;
 8011fec: 2301         	movs	r3, #0x1
 8011fee: e008         	b	0x8012002 <z_impl_k_yield+0x1ce> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 8011ff0: 6d78         	ldr	r0, [r7, #0x54]
 8011ff2: f00d f98a    	bl	0x801f30a <z_is_thread_timeout_active> @ imm = #0xd314
 8011ff6: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 8011ff8: 2b00         	cmp	r3, #0x0
 8011ffa: d001         	beq	0x8012000 <z_impl_k_yield+0x1cc> @ imm = #0x2
; 		return true;
 8011ffc: 2301         	movs	r3, #0x1
 8011ffe: e000         	b	0x8012002 <z_impl_k_yield+0x1ce> @ imm = #0x0
; 	return false;
 8012000: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 8012002: 2b00         	cmp	r3, #0x0
 8012004: d010         	beq	0x8012028 <z_impl_k_yield+0x1f4> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8012006: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8012058 <z_impl_k_yield+0x224>
 8012008: 689b         	ldr	r3, [r3, #0x8]
 801200a: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 801200c: 6c7b         	ldr	r3, [r7, #0x44]
; 		if (thread != arch_current_thread()) {
 801200e: 6dba         	ldr	r2, [r7, #0x58]
 8012010: 429a         	cmp	r2, r3
 8012012: d002         	beq	0x801201a <z_impl_k_yield+0x1e6> @ imm = #0x4
; 			z_reset_time_slice(thread);
 8012014: 6db8         	ldr	r0, [r7, #0x58]
 8012016: f000 fb99    	bl	0x801274c <z_reset_time_slice> @ imm = #0x732
; 		update_metairq_preempt(thread);
 801201a: 6db8         	ldr	r0, [r7, #0x58]
 801201c: f00d faf5    	bl	0x801f60a <update_metairq_preempt> @ imm = #0xd5ea
; 		_kernel.ready_q.cache = thread;
 8012020: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8012058 <z_impl_k_yield+0x224>
 8012022: 6dbb         	ldr	r3, [r7, #0x58]
 8012024: 6213         	str	r3, [r2, #0x20]
; }
 8012026: e005         	b	0x8012034 <z_impl_k_yield+0x200> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8012028: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8012058 <z_impl_k_yield+0x224>
 801202a: 689b         	ldr	r3, [r3, #0x8]
 801202c: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 801202e: 6c3b         	ldr	r3, [r7, #0x40]
; 		_kernel.ready_q.cache = arch_current_thread();
 8012030: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8012058 <z_impl_k_yield+0x224>
 8012032: 6213         	str	r3, [r2, #0x20]
; }
 8012034: bf00         	nop
 8012036: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8012054 <z_impl_k_yield+0x220>
 8012038: 677b         	str	r3, [r7, #0x74]
 801203a: 68bb         	ldr	r3, [r7, #0x8]
 801203c: 607b         	str	r3, [r7, #0x4]
 801203e: 6f7b         	ldr	r3, [r7, #0x74]
 8012040: 673b         	str	r3, [r7, #0x70]
; }
 8012042: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8012044: 687b         	ldr	r3, [r7, #0x4]
 8012046: 4618         	mov	r0, r3
 8012048: f00d fa51    	bl	0x801f4ee <z_swap_irqlock> @ imm = #0xd4a2
; }
 801204c: bf00         	nop
 801204e: 3790         	adds	r7, #0x90
 8012050: 46bd         	mov	sp, r7
 8012052: bd80         	pop	{r7, pc}

08012054 <$d>:
 8012054: e0 27 00 20  	.word	0x200027e0
 8012058: 48 1d 00 20  	.word	0x20001d48
 801205c: 6c 1d 00 20  	.word	0x20001d6c

08012060 <z_tick_sleep>:
; {
 8012060: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8012064: b0a0         	sub	sp, #0x80
 8012066: af06         	add	r7, sp, #0x18
 8012068: e9c7 0100    	strd	r0, r1, [r7]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 801206c: 2303         	movs	r3, #0x3
 801206e: 2b03         	cmp	r3, #0x3
 8012070: d921         	bls	0x80120b6 <z_tick_sleep+0x56> @ imm = #0x42
 8012072: 2301         	movs	r3, #0x1
 8012074: f887 3067    	strb.w	r3, [r7, #0x67]
 8012078: f897 3067    	ldrb.w	r3, [r7, #0x67]
 801207c: f083 0301    	eor	r3, r3, #0x1
 8012080: b2db         	uxtb	r3, r3
 8012082: 2b00         	cmp	r3, #0x0
 8012084: d117         	bne	0x80120b6 <z_tick_sleep+0x56> @ imm = #0x2e
 8012086: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x80121b8 <z_tick_sleep+0x158>
 8012088: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801208a: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x80121bc <z_tick_sleep+0x15c>
 801208c: 689b         	ldr	r3, [r3, #0x8]
 801208e: 657b         	str	r3, [r7, #0x54]
; 	return ret;
 8012090: 6d7b         	ldr	r3, [r7, #0x54]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 8012092: 683a         	ldr	r2, [r7]
 8012094: 9205         	str	r2, [sp, #0x14]
 8012096: 9304         	str	r3, [sp, #0x10]
 8012098: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80121c0 <z_tick_sleep+0x160>
 801209a: 9303         	str	r3, [sp, #0xc]
 801209c: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80121c4 <z_tick_sleep+0x164>
 801209e: 9302         	str	r3, [sp, #0x8]
 80120a0: 2308         	movs	r3, #0x8
 80120a2: 9301         	str	r3, [sp, #0x4]
 80120a4: 2300         	movs	r3, #0x0
 80120a6: 9300         	str	r3, [sp]
 80120a8: 2300         	movs	r3, #0x0
 80120aa: 2204         	movs	r2, #0x4
 80120ac: 2000         	movs	r0, #0x0
 80120ae: f00d fa2b    	bl	0x801f508 <z_log_msg_runtime_create> @ imm = #0xd456
 80120b2: 2300         	movs	r3, #0x0
 80120b4: 65fb         	str	r3, [r7, #0x5c]
; 	if (ticks == 0) {
 80120b6: e9d7 2300    	ldrd	r2, r3, [r7]
 80120ba: 4313         	orrs	r3, r2
 80120bc: d103         	bne	0x80120c6 <z_tick_sleep+0x66> @ imm = #0x6
; 		k_yield();
 80120be: f00d f8a9    	bl	0x801f214 <k_yield>     @ imm = #0xd152
; 		return 0;
 80120c2: 2300         	movs	r3, #0x0
 80120c4: e073         	b	0x80121ae <z_tick_sleep+0x14e> @ imm = #0xe6
; 	if (Z_TICK_ABS(ticks) <= 0) {
 80120c6: e9d7 2300    	ldrd	r2, r3, [r7]
 80120ca: f06f 0001    	mvn	r0, #0x1
 80120ce: f04f 31ff    	mov.w	r1, #0xffffffff
 80120d2: 1a84         	subs	r4, r0, r2
 80120d4: eb61 0503    	sbc.w	r5, r1, r3
 80120d8: 2c01         	cmp	r4, #0x1
 80120da: f175 0300    	sbcs	r3, r5, #0x0
 80120de: da06         	bge	0x80120ee <z_tick_sleep+0x8e> @ imm = #0xc
; 		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 80120e0: f00d fd77    	bl	0x801fbd2 <sys_clock_tick_get_32> @ imm = #0xdaee
 80120e4: 4602         	mov	r2, r0
 80120e6: 683b         	ldr	r3, [r7]
 80120e8: 4413         	add	r3, r2
 80120ea: 663b         	str	r3, [r7, #0x60]
 80120ec: e004         	b	0x80120f8 <z_tick_sleep+0x98> @ imm = #0x8
; 		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 80120ee: 683a         	ldr	r2, [r7]
 80120f0: f06f 0301    	mvn	r3, #0x1
 80120f4: 1a9b         	subs	r3, r3, r2
 80120f6: 663b         	str	r3, [r7, #0x60]
; 	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
 80120f8: e9d7 2300    	ldrd	r2, r3, [r7]
 80120fc: e9c7 2306    	strd	r2, r3, [r7, #24]
 8012100: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80121c8 <z_tick_sleep+0x168>
 8012102: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8012104: f3ef 8311    	mrs	r3, basepri
 8012108: 637b         	str	r3, [r7, #0x34]
;   return(result);
 801210a: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 801210c: 633b         	str	r3, [r7, #0x30]
 801210e: 2310         	movs	r3, #0x10
 8012110: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8012112: 6afb         	ldr	r3, [r7, #0x2c]
 8012114: f383 8812    	msr	basepri_max, r3
; }
 8012118: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801211a: f3bf 8f6f    	isb	sy
; }
 801211e: bf00         	nop
; 	return key;
 8012120: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 8012122: 613b         	str	r3, [r7, #0x10]
 8012124: 6bbb         	ldr	r3, [r7, #0x38]
 8012126: 62bb         	str	r3, [r7, #0x28]
; }
 8012128: bf00         	nop
 801212a: 6bbb         	ldr	r3, [r7, #0x38]
 801212c: 627b         	str	r3, [r7, #0x24]
; }
 801212e: bf00         	nop
; 	return k;
 8012130: 693b         	ldr	r3, [r7, #0x10]
 8012132: 617b         	str	r3, [r7, #0x14]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8012134: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80121bc <z_tick_sleep+0x15c>
 8012136: 689b         	ldr	r3, [r3, #0x8]
 8012138: 63fb         	str	r3, [r7, #0x3c]
; 	return ret;
 801213a: 6bfb         	ldr	r3, [r7, #0x3c]
; 	pending_current = arch_current_thread();
 801213c: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x80121cc <z_tick_sleep+0x16c>
 801213e: 6013         	str	r3, [r2]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8012140: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80121bc <z_tick_sleep+0x15c>
 8012142: 689b         	ldr	r3, [r3, #0x8]
 8012144: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 8012146: 6c3b         	ldr	r3, [r7, #0x40]
; 	unready_thread(arch_current_thread());
 8012148: 4618         	mov	r0, r3
 801214a: f7ff fa93    	bl	0x8011674 <unready_thread> @ imm = #-0xada
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801214e: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x80121bc <z_tick_sleep+0x15c>
 8012150: 689b         	ldr	r3, [r3, #0x8]
 8012152: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 8012154: 6c79         	ldr	r1, [r7, #0x44]
; 	z_add_thread_timeout(arch_current_thread(), timeout);
 8012156: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 801215a: 4608         	mov	r0, r1
 801215c: f7fe fdd8    	bl	0x8010d10 <z_add_thread_timeout> @ imm = #-0x1450
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8012160: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80121bc <z_tick_sleep+0x15c>
 8012162: 689b         	ldr	r3, [r3, #0x8]
 8012164: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 8012166: 6cbb         	ldr	r3, [r7, #0x48]
; 	z_mark_thread_as_suspended(arch_current_thread());
 8012168: 4618         	mov	r0, r3
 801216a: f00d f929    	bl	0x801f3c0 <z_mark_thread_as_suspended> @ imm = #0xd252
 801216e: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80121c8 <z_tick_sleep+0x168>
 8012170: 653b         	str	r3, [r7, #0x50]
 8012172: 697b         	ldr	r3, [r7, #0x14]
 8012174: 60fb         	str	r3, [r7, #0xc]
 8012176: 6d3b         	ldr	r3, [r7, #0x50]
 8012178: 64fb         	str	r3, [r7, #0x4c]
; }
 801217a: bf00         	nop
; 	return z_swap_irqlock(key.key);
 801217c: 68fb         	ldr	r3, [r7, #0xc]
 801217e: 4618         	mov	r0, r3
 8012180: f00d f9b5    	bl	0x801f4ee <z_swap_irqlock> @ imm = #0xd36a
; 	uint32_t left_ticks = expected_wakeup_ticks - sys_clock_tick_get_32();
 8012184: f00d fd25    	bl	0x801fbd2 <sys_clock_tick_get_32> @ imm = #0xda4a
 8012188: 4602         	mov	r2, r0
 801218a: 6e3b         	ldr	r3, [r7, #0x60]
 801218c: 1a9b         	subs	r3, r3, r2
 801218e: 65bb         	str	r3, [r7, #0x58]
; 	ticks = (k_ticks_t)(int32_t)left_ticks;
 8012190: 6dbb         	ldr	r3, [r7, #0x58]
 8012192: 17da         	asrs	r2, r3, #0x1f
 8012194: 4698         	mov	r8, r3
 8012196: 4691         	mov	r9, r2
 8012198: e9c7 8900    	strd	r8, r9, [r7]
; 	if (ticks > 0) {
 801219c: e9d7 2300    	ldrd	r2, r3, [r7]
 80121a0: 2a01         	cmp	r2, #0x1
 80121a2: f173 0300    	sbcs	r3, r3, #0x0
 80121a6: db01         	blt	0x80121ac <z_tick_sleep+0x14c> @ imm = #0x2
; 		return ticks;
 80121a8: 683b         	ldr	r3, [r7]
 80121aa: e000         	b	0x80121ae <z_tick_sleep+0x14e> @ imm = #0x0
; 	return 0;
 80121ac: 2300         	movs	r3, #0x0
; }
 80121ae: 4618         	mov	r0, r3
 80121b0: 3768         	adds	r7, #0x68
 80121b2: 46bd         	mov	sp, r7
 80121b4: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

080121b8 <$d>:
 80121b8: 14 06 00 20  	.word	0x20000614
 80121bc: 48 1d 00 20  	.word	0x20001d48
 80121c0: 00 2f 02 08  	.word	0x08022f00
 80121c4: 50 22 02 08  	.word	0x08022250
 80121c8: e0 27 00 20  	.word	0x200027e0
 80121cc: ec 27 00 20  	.word	0x200027ec

080121d0 <z_impl_k_sleep>:
; {
 80121d0: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 80121d4: b086         	sub	sp, #0x18
 80121d6: af00         	add	r7, sp, #0x0
 80121d8: e9c7 0100    	strd	r0, r1, [r7]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 80121dc: e9d7 2300    	ldrd	r2, r3, [r7]
 80121e0: f04f 30ff    	mov.w	r0, #0xffffffff
 80121e4: f04f 31ff    	mov.w	r1, #0xffffffff
 80121e8: 428b         	cmp	r3, r1
 80121ea: bf08         	it	eq
 80121ec: 4282         	cmpeq	r2, r0
 80121ee: d109         	bne	0x8012204 <z_impl_k_sleep+0x34> @ imm = #0x12
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80121f0: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8012250 <z_impl_k_sleep+0x80>
 80121f2: 689b         	ldr	r3, [r3, #0x8]
 80121f4: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 80121f6: 68bb         	ldr	r3, [r7, #0x8]
; 		k_thread_suspend(arch_current_thread());
 80121f8: 4618         	mov	r0, r3
 80121fa: f00d f811    	bl	0x801f220 <k_thread_suspend> @ imm = #0xd022
; 		return (int32_t) K_TICKS_FOREVER;
 80121fe: f04f 33ff    	mov.w	r3, #0xffffffff
 8012202: e020         	b	0x8012246 <z_impl_k_sleep+0x76> @ imm = #0x40
; 	ticks = timeout.ticks;
 8012204: e9d7 2300    	ldrd	r2, r3, [r7]
 8012208: e9c7 2304    	strd	r2, r3, [r7, #16]
; 	ticks = z_tick_sleep(ticks);
 801220c: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 8012210: f7ff ff26    	bl	0x8012060 <z_tick_sleep> @ imm = #-0x1b4
 8012214: 4603         	mov	r3, r0
 8012216: 17da         	asrs	r2, r3, #0x1f
 8012218: 4698         	mov	r8, r3
 801221a: 4691         	mov	r9, r2
 801221c: e9c7 8904    	strd	r8, r9, [r7, #16]
; 	int32_t ret = k_ticks_to_ms_ceil64(ticks);
 8012220: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 8012224: f112 0409    	adds.w	r4, r2, #0x9
 8012228: f143 0500    	adc	r5, r3, #0x0
 801222c: f04f 020a    	mov.w	r2, #0xa
 8012230: f04f 0300    	mov.w	r3, #0x0
 8012234: 4620         	mov	r0, r4
 8012236: 4629         	mov	r1, r5
 8012238: f7ee fc14    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x117d8
 801223c: 4602         	mov	r2, r0
 801223e: 460b         	mov	r3, r1
 8012240: 4613         	mov	r3, r2
 8012242: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8012244: 68fb         	ldr	r3, [r7, #0xc]
; }
 8012246: 4618         	mov	r0, r3
 8012248: 3718         	adds	r7, #0x18
 801224a: 46bd         	mov	sp, r7
 801224c: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

08012250 <$d>:
 8012250: 48 1d 00 20  	.word	0x20001d48

08012254 <z_impl_k_sched_current_thread_query>:
; {
 8012254: b480         	push	{r7}
 8012256: b083         	sub	sp, #0xc
 8012258: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 801225a: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8012270 <z_impl_k_sched_current_thread_query+0x1c>
 801225c: 689b         	ldr	r3, [r3, #0x8]
 801225e: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 8012260: 687b         	ldr	r3, [r7, #0x4]
; }
 8012262: 4618         	mov	r0, r3
 8012264: 370c         	adds	r7, #0xc
 8012266: 46bd         	mov	sp, r7
 8012268: f85d 7b04    	ldr	r7, [sp], #4
 801226c: 4770         	bx	lr
 801226e: bf00         	nop

08012270 <$d>:
 8012270: 48 1d 00 20  	.word	0x20001d48

08012274 <halt_thread>:
; {
 8012274: b580         	push	{r7, lr}
 8012276: b096         	sub	sp, #0x58
 8012278: af00         	add	r7, sp, #0x0
 801227a: 6078         	str	r0, [r7, #0x4]
 801227c: 460b         	mov	r3, r1
 801227e: 70fb         	strb	r3, [r7, #0x3]
; 	bool dummify = false;
 8012280: 2300         	movs	r3, #0x0
 8012282: f887 3057    	strb.w	r3, [r7, #0x57]
; 	if ((thread->base.thread_state & new_state) == 0U) {
 8012286: 687b         	ldr	r3, [r7, #0x4]
 8012288: 7b5a         	ldrb	r2, [r3, #0xd]
 801228a: 78fb         	ldrb	r3, [r7, #0x3]
 801228c: 4013         	ands	r3, r2
 801228e: b2db         	uxtb	r3, r3
 8012290: 2b00         	cmp	r3, #0x0
 8012292: f040 80cd    	bne.w	0x8012430 <halt_thread+0x1bc> @ imm = #0x19a
; 		thread->base.thread_state |= new_state;
 8012296: 687b         	ldr	r3, [r7, #0x4]
 8012298: 7b5a         	ldrb	r2, [r3, #0xd]
 801229a: 78fb         	ldrb	r3, [r7, #0x3]
 801229c: 4313         	orrs	r3, r2
 801229e: b2da         	uxtb	r2, r3
 80122a0: 687b         	ldr	r3, [r7, #0x4]
 80122a2: 735a         	strb	r2, [r3, #0xd]
; 		if (z_is_thread_queued(thread)) {
 80122a4: 6878         	ldr	r0, [r7, #0x4]
 80122a6: f00d f87e    	bl	0x801f3a6 <z_is_thread_queued> @ imm = #0xd0fc
 80122aa: 4603         	mov	r3, r0
 80122ac: 2b00         	cmp	r3, #0x0
 80122ae: d01d         	beq	0x80122ec <halt_thread+0x78> @ imm = #0x3a
 80122b0: 687b         	ldr	r3, [r7, #0x4]
 80122b2: 653b         	str	r3, [r7, #0x50]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 80122b4: 6d3b         	ldr	r3, [r7, #0x50]
 80122b6: 7b5b         	ldrb	r3, [r3, #0xd]
 80122b8: f003 037f    	and	r3, r3, #0x7f
 80122bc: b2da         	uxtb	r2, r3
 80122be: 6d3b         	ldr	r3, [r7, #0x50]
 80122c0: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 80122c2: 6d38         	ldr	r0, [r7, #0x50]
 80122c4: f00d f95a    	bl	0x801f57c <should_queue_thread> @ imm = #0xd2b4
 80122c8: 4603         	mov	r3, r0
 80122ca: 2b00         	cmp	r3, #0x0
 80122cc: d00d         	beq	0x80122ea <halt_thread+0x76> @ imm = #0x1a
 80122ce: 6d3b         	ldr	r3, [r7, #0x50]
 80122d0: 64fb         	str	r3, [r7, #0x4c]
 80122d2: 6cfb         	ldr	r3, [r7, #0x4c]
 80122d4: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 80122d6: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8012438 <halt_thread+0x1c4>
 80122d8: 647b         	str	r3, [r7, #0x44]
 80122da: 6cfb         	ldr	r3, [r7, #0x4c]
 80122dc: 643b         	str	r3, [r7, #0x40]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 80122de: 6c3b         	ldr	r3, [r7, #0x40]
 80122e0: 4618         	mov	r0, r3
 80122e2: f00c ff80    	bl	0x801f1e6 <sys_dlist_remove> @ imm = #0xcf00
; }
 80122e6: bf00         	nop
; }
 80122e8: bf00         	nop
; }
 80122ea: bf00         	nop
; 		if (new_state == _THREAD_DEAD) {
 80122ec: 78fb         	ldrb	r3, [r7, #0x3]
 80122ee: 2b08         	cmp	r3, #0x8
 80122f0: d123         	bne	0x801233a <halt_thread+0xc6> @ imm = #0x46
; 			if (thread->base.pended_on != NULL) {
 80122f2: 687b         	ldr	r3, [r7, #0x4]
 80122f4: 689b         	ldr	r3, [r3, #0x8]
 80122f6: 2b00         	cmp	r3, #0x0
 80122f8: d002         	beq	0x8012300 <halt_thread+0x8c> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 80122fa: 6878         	ldr	r0, [r7, #0x4]
 80122fc: f00d f8d0    	bl	0x801f4a0 <unpend_thread_no_timeout> @ imm = #0xd1a0
; 			(void)z_abort_thread_timeout(thread);
 8012300: 6878         	ldr	r0, [r7, #0x4]
 8012302: f00c ffb0    	bl	0x801f266 <z_abort_thread_timeout> @ imm = #0xcf60
; 			unpend_all(&thread->join_queue);
 8012306: 687b         	ldr	r3, [r7, #0x4]
 8012308: 3368         	adds	r3, #0x68
 801230a: 4618         	mov	r0, r3
 801230c: f00d fadf    	bl	0x801f8ce <unpend_all>  @ imm = #0xd5be
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8012310: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x801243c <halt_thread+0x1c8>
 8012312: 689b         	ldr	r3, [r3, #0x8]
 8012314: 63fb         	str	r3, [r7, #0x3c]
; 	return ret;
 8012316: 6bfb         	ldr	r3, [r7, #0x3c]
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 8012318: 687a         	ldr	r2, [r7, #0x4]
 801231a: 429a         	cmp	r2, r3
 801231c: d10d         	bne	0x801233a <halt_thread+0xc6> @ imm = #0x1a
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801231e: f3ef 8305    	mrs	r3, ipsr
 8012322: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 8012324: 6bbb         	ldr	r3, [r7, #0x38]
; 	return (__get_IPSR()) ? (true) : (false);
 8012326: 2b00         	cmp	r3, #0x0
 8012328: bf14         	ite	ne
 801232a: 2301         	movne	r3, #0x1
 801232c: 2300         	moveq	r3, #0x0
 801232e: b2db         	uxtb	r3, r3
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 8012330: 2b00         	cmp	r3, #0x0
 8012332: d002         	beq	0x801233a <halt_thread+0xc6> @ imm = #0x4
; 				dummify = true;
 8012334: 2301         	movs	r3, #0x1
 8012336: f887 3057    	strb.w	r3, [r7, #0x57]
 801233a: 2301         	movs	r3, #0x1
 801233c: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 801233e: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8012438 <halt_thread+0x1c4>
 8012340: 633b         	str	r3, [r7, #0x30]
; 	struct k_thread *thread = NULL;
 8012342: 2300         	movs	r3, #0x0
 8012344: 62fb         	str	r3, [r7, #0x2c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8012346: 6b38         	ldr	r0, [r7, #0x30]
 8012348: f00c fee0    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xcdc0
 801234c: 62b8         	str	r0, [r7, #0x28]
; 	if (n != NULL) {
 801234e: 6abb         	ldr	r3, [r7, #0x28]
 8012350: 2b00         	cmp	r3, #0x0
 8012352: d001         	beq	0x8012358 <halt_thread+0xe4> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8012354: 6abb         	ldr	r3, [r7, #0x28]
 8012356: 62fb         	str	r3, [r7, #0x2c]
; 	return thread;
 8012358: 6afb         	ldr	r3, [r7, #0x2c]
; 	return _priq_run_best(curr_cpu_runq());
 801235a: bf00         	nop
; 	struct k_thread *thread = runq_best();
 801235c: 627b         	str	r3, [r7, #0x24]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 801235e: 6a7b         	ldr	r3, [r7, #0x24]
 8012360: 2b00         	cmp	r3, #0x0
 8012362: d102         	bne	0x801236a <halt_thread+0xf6> @ imm = #0x4
 8012364: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x801243c <halt_thread+0x1c8>
 8012366: 68db         	ldr	r3, [r3, #0xc]
 8012368: e000         	b	0x801236c <halt_thread+0xf8> @ imm = #0x0
 801236a: 6a7b         	ldr	r3, [r7, #0x24]
; 	struct k_thread *thread = next_up();
 801236c: 623b         	str	r3, [r7, #0x20]
 801236e: 6a3b         	ldr	r3, [r7, #0x20]
 8012370: 61fb         	str	r3, [r7, #0x1c]
 8012372: 6b7b         	ldr	r3, [r7, #0x34]
 8012374: 61bb         	str	r3, [r7, #0x18]
; 	if (preempt_ok != 0) {
 8012376: 69bb         	ldr	r3, [r7, #0x18]
 8012378: 2b00         	cmp	r3, #0x0
 801237a: d001         	beq	0x8012380 <halt_thread+0x10c> @ imm = #0x2
; 		return true;
 801237c: 2301         	movs	r3, #0x1
 801237e: e026         	b	0x80123ce <halt_thread+0x15a> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8012380: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x801243c <halt_thread+0x1c8>
 8012382: 689b         	ldr	r3, [r3, #0x8]
 8012384: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 8012386: 697b         	ldr	r3, [r7, #0x14]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 8012388: 4618         	mov	r0, r3
 801238a: f00c ffa9    	bl	0x801f2e0 <z_is_thread_prevented_from_running> @ imm = #0xcf52
 801238e: 4603         	mov	r3, r0
 8012390: 2b00         	cmp	r3, #0x0
 8012392: d001         	beq	0x8012398 <halt_thread+0x124> @ imm = #0x2
; 		return true;
 8012394: 2301         	movs	r3, #0x1
 8012396: e01a         	b	0x80123ce <halt_thread+0x15a> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8012398: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x801243c <halt_thread+0x1c8>
 801239a: 689b         	ldr	r3, [r3, #0x8]
 801239c: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 801239e: 693b         	ldr	r3, [r7, #0x10]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 80123a0: 4618         	mov	r0, r3
 80123a2: f00c ff6e    	bl	0x801f282 <thread_is_preemptible> @ imm = #0xcedc
 80123a6: 4603         	mov	r3, r0
 80123a8: 2b00         	cmp	r3, #0x0
 80123aa: d105         	bne	0x80123b8 <halt_thread+0x144> @ imm = #0xa
 80123ac: 69f8         	ldr	r0, [r7, #0x1c]
 80123ae: f00c ff79    	bl	0x801f2a4 <thread_is_metairq> @ imm = #0xcef2
 80123b2: 4603         	mov	r3, r0
 80123b4: 2b00         	cmp	r3, #0x0
 80123b6: d001         	beq	0x80123bc <halt_thread+0x148> @ imm = #0x2
; 		return true;
 80123b8: 2301         	movs	r3, #0x1
 80123ba: e008         	b	0x80123ce <halt_thread+0x15a> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 80123bc: 69f8         	ldr	r0, [r7, #0x1c]
 80123be: f00c ffa4    	bl	0x801f30a <z_is_thread_timeout_active> @ imm = #0xcf48
 80123c2: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 80123c4: 2b00         	cmp	r3, #0x0
 80123c6: d001         	beq	0x80123cc <halt_thread+0x158> @ imm = #0x2
; 		return true;
 80123c8: 2301         	movs	r3, #0x1
 80123ca: e000         	b	0x80123ce <halt_thread+0x15a> @ imm = #0x0
; 	return false;
 80123cc: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 80123ce: 2b00         	cmp	r3, #0x0
 80123d0: d010         	beq	0x80123f4 <halt_thread+0x180> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80123d2: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x801243c <halt_thread+0x1c8>
 80123d4: 689b         	ldr	r3, [r3, #0x8]
 80123d6: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 80123d8: 68fb         	ldr	r3, [r7, #0xc]
; 		if (thread != arch_current_thread()) {
 80123da: 6a3a         	ldr	r2, [r7, #0x20]
 80123dc: 429a         	cmp	r2, r3
 80123de: d002         	beq	0x80123e6 <halt_thread+0x172> @ imm = #0x4
; 			z_reset_time_slice(thread);
 80123e0: 6a38         	ldr	r0, [r7, #0x20]
 80123e2: f000 f9b3    	bl	0x801274c <z_reset_time_slice> @ imm = #0x366
; 		update_metairq_preempt(thread);
 80123e6: 6a38         	ldr	r0, [r7, #0x20]
 80123e8: f00d f90f    	bl	0x801f60a <update_metairq_preempt> @ imm = #0xd21e
; 		_kernel.ready_q.cache = thread;
 80123ec: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x801243c <halt_thread+0x1c8>
 80123ee: 6a3b         	ldr	r3, [r7, #0x20]
 80123f0: 6213         	str	r3, [r2, #0x20]
; }
 80123f2: e005         	b	0x8012400 <halt_thread+0x18c> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80123f4: 4b11         	ldr	r3, [pc, #0x44]         @ 0x801243c <halt_thread+0x1c8>
 80123f6: 689b         	ldr	r3, [r3, #0x8]
 80123f8: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 80123fa: 68bb         	ldr	r3, [r7, #0x8]
; 		_kernel.ready_q.cache = arch_current_thread();
 80123fc: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x801243c <halt_thread+0x1c8>
 80123fe: 6213         	str	r3, [r2, #0x20]
; }
 8012400: bf00         	nop
; 		if (new_state == _THREAD_SUSPENDED) {
 8012402: 78fb         	ldrb	r3, [r7, #0x3]
 8012404: 2b10         	cmp	r3, #0x10
 8012406: d103         	bne	0x8012410 <halt_thread+0x19c> @ imm = #0x6
; 			clear_halting(thread);
 8012408: 6878         	ldr	r0, [r7, #0x4]
 801240a: f00d f8e8    	bl	0x801f5de <clear_halting> @ imm = #0xd1d0
; 			return;
 801240e: e00f         	b	0x8012430 <halt_thread+0x1bc> @ imm = #0x1e
; 		arch_float_disable(thread);
 8012410: 6878         	ldr	r0, [r7, #0x4]
 8012412: f7f4 fe6f    	bl	0x80070f4 <arch_float_disable> @ imm = #-0xb322
; 		z_thread_monitor_exit(thread);
 8012416: 6878         	ldr	r0, [r7, #0x4]
 8012418: f000 fa4e    	bl	0x80128b8 <z_thread_monitor_exit> @ imm = #0x49c
; 		if (dummify && !IS_ENABLED(CONFIG_ARCH_POSIX)) {
 801241c: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8012420: 2b00         	cmp	r3, #0x0
 8012422: d002         	beq	0x801242a <halt_thread+0x1b6> @ imm = #0x4
; 			z_dummy_thread_init(&_thread_dummy);
 8012424: 4806         	ldr	r0, [pc, #0x18]         @ 0x8012440 <halt_thread+0x1cc>
 8012426: f7fe fc9b    	bl	0x8010d60 <z_dummy_thread_init> @ imm = #-0x16ca
; 		clear_halting(thread);
 801242a: 6878         	ldr	r0, [r7, #0x4]
 801242c: f00d f8d7    	bl	0x801f5de <clear_halting> @ imm = #0xd1ae
; }
 8012430: 3758         	adds	r7, #0x58
 8012432: 46bd         	mov	sp, r7
 8012434: bd80         	pop	{r7, pc}
 8012436: bf00         	nop

08012438 <$d>:
 8012438: 6c 1d 00 20  	.word	0x20001d6c
 801243c: 48 1d 00 20  	.word	0x20001d48
 8012440: c0 1f 00 20  	.word	0x20001fc0

08012444 <z_thread_abort>:
; {
 8012444: b580         	push	{r7, lr}
 8012446: b094         	sub	sp, #0x50
 8012448: af00         	add	r7, sp, #0x0
 801244a: 6078         	str	r0, [r7, #0x4]
 801244c: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x8012510 <z_thread_abort+0xcc>
 801244e: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8012450: f3ef 8311    	mrs	r3, basepri
 8012454: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 8012456: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 8012458: 647b         	str	r3, [r7, #0x44]
 801245a: 2310         	movs	r3, #0x10
 801245c: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801245e: 6c3b         	ldr	r3, [r7, #0x40]
 8012460: f383 8812    	msr	basepri_max, r3
; }
 8012464: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012466: f3bf 8f6f    	isb	sy
; }
 801246a: bf00         	nop
; 	return key;
 801246c: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 801246e: 60bb         	str	r3, [r7, #0x8]
 8012470: 6cfb         	ldr	r3, [r7, #0x4c]
 8012472: 63fb         	str	r3, [r7, #0x3c]
; }
 8012474: bf00         	nop
 8012476: 6cfb         	ldr	r3, [r7, #0x4c]
 8012478: 63bb         	str	r3, [r7, #0x38]
; }
 801247a: bf00         	nop
; 	return k;
 801247c: 68bb         	ldr	r3, [r7, #0x8]
 801247e: 617b         	str	r3, [r7, #0x14]
; 	if (z_is_thread_essential(thread)) {
 8012480: 6878         	ldr	r0, [r7, #0x4]
 8012482: f00c ffe1    	bl	0x801f448 <z_is_thread_essential> @ imm = #0xcfc2
 8012486: 4603         	mov	r3, r0
 8012488: 2b00         	cmp	r3, #0x0
 801248a: d020         	beq	0x80124ce <z_thread_abort+0x8a> @ imm = #0x40
 801248c: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8012510 <z_thread_abort+0xcc>
 801248e: 62fb         	str	r3, [r7, #0x2c]
 8012490: 697b         	ldr	r3, [r7, #0x14]
 8012492: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8012494: 68fb         	ldr	r3, [r7, #0xc]
 8012496: 62bb         	str	r3, [r7, #0x28]
 8012498: 6abb         	ldr	r3, [r7, #0x28]
 801249a: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801249c: 6a7b         	ldr	r3, [r7, #0x24]
 801249e: f383 8811    	msr	basepri, r3
; }
 80124a2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80124a4: f3bf 8f6f    	isb	sy
; }
 80124a8: bf00         	nop
; }
 80124aa: bf00         	nop
; }
 80124ac: bf00         	nop
 80124ae: 2300         	movs	r3, #0x0
 80124b0: 637b         	str	r3, [r7, #0x34]
 80124b2: 6b7b         	ldr	r3, [r7, #0x34]
 80124b4: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80124b6: 6b3b         	ldr	r3, [r7, #0x30]
 80124b8: f383 8811    	msr	basepri, r3
; }
 80124bc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80124be: f3bf 8f6f    	isb	sy
; }
 80124c2: bf00         	nop
; }
 80124c4: bf00         	nop
; 		k_panic();
 80124c6: 2304         	movs	r3, #0x4
 80124c8: 4618         	mov	r0, r3
 80124ca: df02         	svc	#0x2
; 		return;
 80124cc: e01c         	b	0x8012508 <z_thread_abort+0xc4> @ imm = #0x38
; 	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 80124ce: 687b         	ldr	r3, [r7, #0x4]
 80124d0: 7b5b         	ldrb	r3, [r3, #0xd]
 80124d2: f003 0308    	and	r3, r3, #0x8
 80124d6: 2b00         	cmp	r3, #0x0
 80124d8: d011         	beq	0x80124fe <z_thread_abort+0xba> @ imm = #0x22
 80124da: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8012510 <z_thread_abort+0xcc>
 80124dc: 623b         	str	r3, [r7, #0x20]
 80124de: 697b         	ldr	r3, [r7, #0x14]
 80124e0: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 80124e2: 693b         	ldr	r3, [r7, #0x10]
 80124e4: 61fb         	str	r3, [r7, #0x1c]
 80124e6: 69fb         	ldr	r3, [r7, #0x1c]
 80124e8: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80124ea: 69bb         	ldr	r3, [r7, #0x18]
 80124ec: f383 8811    	msr	basepri, r3
; }
 80124f0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80124f2: f3bf 8f6f    	isb	sy
; }
 80124f6: bf00         	nop
; }
 80124f8: bf00         	nop
; }
 80124fa: bf00         	nop
; 		return;
 80124fc: e004         	b	0x8012508 <z_thread_abort+0xc4> @ imm = #0x8
; 	z_thread_halt(thread, key, true);
 80124fe: 2201         	movs	r2, #0x1
 8012500: 6979         	ldr	r1, [r7, #0x14]
 8012502: 6878         	ldr	r0, [r7, #0x4]
 8012504: f7fe fec0    	bl	0x8011288 <z_thread_halt> @ imm = #-0x1280
; }
 8012508: 3750         	adds	r7, #0x50
 801250a: 46bd         	mov	sp, r7
 801250c: bd80         	pop	{r7, pc}
 801250e: bf00         	nop

08012510 <$d>:
 8012510: e0 27 00 20  	.word	0x200027e0

08012514 <z_sched_wake>:
; {
 8012514: b580         	push	{r7, lr}
 8012516: b09c         	sub	sp, #0x70
 8012518: af00         	add	r7, sp, #0x0
 801251a: 60f8         	str	r0, [r7, #0xc]
 801251c: 60b9         	str	r1, [r7, #0x8]
 801251e: 607a         	str	r2, [r7, #0x4]
; 	bool ret = false;
 8012520: 2300         	movs	r3, #0x0
 8012522: f887 306f    	strb.w	r3, [r7, #0x6f]
; 	K_SPINLOCK(&_sched_spinlock) {
 8012526: 2300         	movs	r3, #0x0
 8012528: 623b         	str	r3, [r7, #0x20]
 801252a: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x80125fc <z_sched_wake+0xe8>
 801252c: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801252e: f3ef 8311    	mrs	r3, basepri
 8012532: 663b         	str	r3, [r7, #0x60]
;   return(result);
 8012534: 6e3b         	ldr	r3, [r7, #0x60]
; 	key = __get_BASEPRI();
 8012536: 65fb         	str	r3, [r7, #0x5c]
 8012538: 2310         	movs	r3, #0x10
 801253a: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801253c: 6dbb         	ldr	r3, [r7, #0x58]
 801253e: f383 8812    	msr	basepri_max, r3
; }
 8012542: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012544: f3bf 8f6f    	isb	sy
; }
 8012548: bf00         	nop
; 	return key;
 801254a: 6dfb         	ldr	r3, [r7, #0x5c]
; 	k.key = arch_irq_lock();
 801254c: 617b         	str	r3, [r7, #0x14]
 801254e: 6e7b         	ldr	r3, [r7, #0x64]
 8012550: 657b         	str	r3, [r7, #0x54]
; }
 8012552: bf00         	nop
 8012554: 6e7b         	ldr	r3, [r7, #0x64]
 8012556: 653b         	str	r3, [r7, #0x50]
; }
 8012558: bf00         	nop
; 	return k;
 801255a: 697b         	ldr	r3, [r7, #0x14]
 801255c: 61fb         	str	r3, [r7, #0x1c]
; 	K_SPINLOCK(&_sched_spinlock) {
 801255e: e043         	b	0x80125e8 <z_sched_wake+0xd4> @ imm = #0x86
; 		thread = _priq_wait_best(&wait_q->waitq);
 8012560: 68fb         	ldr	r3, [r7, #0xc]
 8012562: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 8012564: 2300         	movs	r3, #0x0
 8012566: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8012568: 6cf8         	ldr	r0, [r7, #0x4c]
 801256a: f00c fdcf    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #0xcb9e
 801256e: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8012570: 6c7b         	ldr	r3, [r7, #0x44]
 8012572: 2b00         	cmp	r3, #0x0
 8012574: d001         	beq	0x801257a <z_sched_wake+0x66> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8012576: 6c7b         	ldr	r3, [r7, #0x44]
 8012578: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 801257a: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 801257c: 66bb         	str	r3, [r7, #0x68]
; 		if (thread != NULL) {
 801257e: 6ebb         	ldr	r3, [r7, #0x68]
 8012580: 2b00         	cmp	r3, #0x0
 8012582: d01e         	beq	0x80125c2 <z_sched_wake+0xae> @ imm = #0x3c
; 			z_thread_return_value_set_with_data(thread,
 8012584: 68bb         	ldr	r3, [r7, #0x8]
 8012586: 6eba         	ldr	r2, [r7, #0x68]
 8012588: 643a         	str	r2, [r7, #0x40]
 801258a: 63fb         	str	r3, [r7, #0x3c]
 801258c: 687b         	ldr	r3, [r7, #0x4]
 801258e: 63bb         	str	r3, [r7, #0x38]
 8012590: 6c3b         	ldr	r3, [r7, #0x40]
 8012592: 637b         	str	r3, [r7, #0x34]
 8012594: 6bfb         	ldr	r3, [r7, #0x3c]
 8012596: 633b         	str	r3, [r7, #0x30]
; 	thread->arch.swap_return_value = value;
 8012598: 6b7b         	ldr	r3, [r7, #0x34]
 801259a: 6b3a         	ldr	r2, [r7, #0x30]
 801259c: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 80125a0: bf00         	nop
; 	thread->base.swap_data = data;
 80125a2: 6c3b         	ldr	r3, [r7, #0x40]
 80125a4: 6bba         	ldr	r2, [r7, #0x38]
 80125a6: 615a         	str	r2, [r3, #0x14]
; }
 80125a8: bf00         	nop
; 			unpend_thread_no_timeout(thread);
 80125aa: 6eb8         	ldr	r0, [r7, #0x68]
 80125ac: f00c ff78    	bl	0x801f4a0 <unpend_thread_no_timeout> @ imm = #0xcef0
; 			(void)z_abort_thread_timeout(thread);
 80125b0: 6eb8         	ldr	r0, [r7, #0x68]
 80125b2: f00c fe58    	bl	0x801f266 <z_abort_thread_timeout> @ imm = #0xccb0
; 			ready_thread(thread);
 80125b6: 6eb8         	ldr	r0, [r7, #0x68]
 80125b8: f7fe fce6    	bl	0x8010f88 <ready_thread> @ imm = #-0x1634
; 			ret = true;
 80125bc: 2301         	movs	r3, #0x1
 80125be: f887 306f    	strb.w	r3, [r7, #0x6f]
 80125c2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80125fc <z_sched_wake+0xe8>
 80125c4: 62fb         	str	r3, [r7, #0x2c]
 80125c6: 69fb         	ldr	r3, [r7, #0x1c]
 80125c8: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 80125ca: 69bb         	ldr	r3, [r7, #0x18]
 80125cc: 62bb         	str	r3, [r7, #0x28]
 80125ce: 6abb         	ldr	r3, [r7, #0x28]
 80125d0: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80125d2: 6a7b         	ldr	r3, [r7, #0x24]
 80125d4: f383 8811    	msr	basepri, r3
; }
 80125d8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80125da: f3bf 8f6f    	isb	sy
; }
 80125de: bf00         	nop
; }
 80125e0: bf00         	nop
; }
 80125e2: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 80125e4: 2301         	movs	r3, #0x1
 80125e6: 623b         	str	r3, [r7, #0x20]
 80125e8: 6a3b         	ldr	r3, [r7, #0x20]
 80125ea: 2b00         	cmp	r3, #0x0
 80125ec: d0b8         	beq	0x8012560 <z_sched_wake+0x4c> @ imm = #-0x90
; 	return ret;
 80125ee: f897 306f    	ldrb.w	r3, [r7, #0x6f]
; }
 80125f2: 4618         	mov	r0, r3
 80125f4: 3770         	adds	r7, #0x70
 80125f6: 46bd         	mov	sp, r7
 80125f8: bd80         	pop	{r7, pc}
 80125fa: bf00         	nop

080125fc <$d>:
 80125fc: e0 27 00 20  	.word	0x200027e0

08012600 <z_sched_wait>:
; {
 8012600: b580         	push	{r7, lr}
 8012602: b088         	sub	sp, #0x20
 8012604: af02         	add	r7, sp, #0x8
 8012606: 60f8         	str	r0, [r7, #0xc]
 8012608: 60b9         	str	r1, [r7, #0x8]
 801260a: 607a         	str	r2, [r7, #0x4]
; 	int ret = z_pend_curr(lock, key, wait_q, timeout);
 801260c: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8012610: e9cd 2300    	strd	r2, r3, [sp]
 8012614: 687a         	ldr	r2, [r7, #0x4]
 8012616: 68b9         	ldr	r1, [r7, #0x8]
 8012618: 68f8         	ldr	r0, [r7, #0xc]
 801261a: f7ff f945    	bl	0x80118a8 <z_pend_curr> @ imm = #-0xd76
 801261e: 6178         	str	r0, [r7, #0x14]
; 	if (data != NULL) {
 8012620: 6abb         	ldr	r3, [r7, #0x28]
 8012622: 2b00         	cmp	r3, #0x0
 8012624: d006         	beq	0x8012634 <z_sched_wait+0x34> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8012626: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8012640 <z_sched_wait+0x40>
 8012628: 689b         	ldr	r3, [r3, #0x8]
 801262a: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 801262c: 693b         	ldr	r3, [r7, #0x10]
; 		*data = arch_current_thread()->base.swap_data;
 801262e: 695a         	ldr	r2, [r3, #0x14]
 8012630: 6abb         	ldr	r3, [r7, #0x28]
 8012632: 601a         	str	r2, [r3]
; 	return ret;
 8012634: 697b         	ldr	r3, [r7, #0x14]
; }
 8012636: 4618         	mov	r0, r3
 8012638: 3718         	adds	r7, #0x18
 801263a: 46bd         	mov	sp, r7
 801263c: bd80         	pop	{r7, pc}
 801263e: bf00         	nop

08012640 <$d>:
 8012640: 48 1d 00 20  	.word	0x20001d48

08012644 <z_is_idle_thread_object>:
; {
 8012644: b480         	push	{r7}
 8012646: b083         	sub	sp, #0xc
 8012648: af00         	add	r7, sp, #0x0
 801264a: 6078         	str	r0, [r7, #0x4]
; 	return thread == &z_idle_threads[0];
 801264c: 687b         	ldr	r3, [r7, #0x4]
 801264e: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8012668 <z_is_idle_thread_object+0x24>
 8012650: 4293         	cmp	r3, r2
 8012652: bf0c         	ite	eq
 8012654: 2301         	moveq	r3, #0x1
 8012656: 2300         	movne	r3, #0x0
 8012658: b2db         	uxtb	r3, r3
; }
 801265a: 4618         	mov	r0, r3
 801265c: 370c         	adds	r7, #0xc
 801265e: 46bd         	mov	sp, r7
 8012660: f85d 7b04    	ldr	r7, [sp], #4
 8012664: 4770         	bx	lr
 8012666: bf00         	nop

08012668 <$d>:
 8012668: a8 1e 00 20  	.word	0x20001ea8

0801266c <slice_time>:
; {
 801266c: b480         	push	{r7}
 801266e: b085         	sub	sp, #0x14
 8012670: af00         	add	r7, sp, #0x0
 8012672: 6078         	str	r0, [r7, #0x4]
; 	int ret = slice_ticks;
 8012674: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8012688 <slice_time+0x1c>
 8012676: 681b         	ldr	r3, [r3]
 8012678: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 801267a: 68fb         	ldr	r3, [r7, #0xc]
; }
 801267c: 4618         	mov	r0, r3
 801267e: 3714         	adds	r7, #0x14
 8012680: 46bd         	mov	sp, r7
 8012682: f85d 7b04    	ldr	r7, [sp], #4
 8012686: 4770         	bx	lr

08012688 <$d>:
 8012688: e0 27 00 20  	.word	0x200027e0

0801268c <thread_is_sliceable>:
; {
 801268c: b580         	push	{r7, lr}
 801268e: b084         	sub	sp, #0x10
 8012690: af00         	add	r7, sp, #0x0
 8012692: 6078         	str	r0, [r7, #0x4]
; 	bool ret = thread_is_preemptible(thread)
 8012694: 6878         	ldr	r0, [r7, #0x4]
 8012696: f00d f941    	bl	0x801f91c <thread_is_preemptible> @ imm = #0xd282
 801269a: 4603         	mov	r3, r0
; 		&& !z_is_idle_thread_object(thread);
 801269c: 2b00         	cmp	r3, #0x0
 801269e: d029         	beq	0x80126f4 <thread_is_sliceable+0x68> @ imm = #0x52
; 		&& slice_time(thread) != 0
 80126a0: 6878         	ldr	r0, [r7, #0x4]
 80126a2: f7ff ffe3    	bl	0x801266c <slice_time>  @ imm = #-0x3a
 80126a6: 4603         	mov	r3, r0
 80126a8: 2b00         	cmp	r3, #0x0
 80126aa: d023         	beq	0x80126f4 <thread_is_sliceable+0x68> @ imm = #0x46
; 		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 80126ac: 687b         	ldr	r3, [r7, #0x4]
 80126ae: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80126b2: 461a         	mov	r2, r3
 80126b4: 4b15         	ldr	r3, [pc, #0x54]         @ 0x801270c <thread_is_sliceable+0x80>
 80126b6: 681b         	ldr	r3, [r3]
 80126b8: 4619         	mov	r1, r3
 80126ba: 4610         	mov	r0, r2
 80126bc: f00d f966    	bl	0x801f98c <z_is_prio_higher> @ imm = #0xd2cc
 80126c0: 4603         	mov	r3, r0
 80126c2: f083 0301    	eor	r3, r3, #0x1
 80126c6: b2db         	uxtb	r3, r3
 80126c8: 2b00         	cmp	r3, #0x0
 80126ca: d013         	beq	0x80126f4 <thread_is_sliceable+0x68> @ imm = #0x26
; 		&& !z_is_thread_prevented_from_running(thread)
 80126cc: 6878         	ldr	r0, [r7, #0x4]
 80126ce: f00d f936    	bl	0x801f93e <z_is_thread_prevented_from_running> @ imm = #0xd26c
 80126d2: 4603         	mov	r3, r0
 80126d4: f083 0301    	eor	r3, r3, #0x1
 80126d8: b2db         	uxtb	r3, r3
 80126da: 2b00         	cmp	r3, #0x0
 80126dc: d00a         	beq	0x80126f4 <thread_is_sliceable+0x68> @ imm = #0x14
; 		&& !z_is_idle_thread_object(thread);
 80126de: 6878         	ldr	r0, [r7, #0x4]
 80126e0: f7ff ffb0    	bl	0x8012644 <z_is_idle_thread_object> @ imm = #-0xa0
 80126e4: 4603         	mov	r3, r0
 80126e6: f083 0301    	eor	r3, r3, #0x1
 80126ea: b2db         	uxtb	r3, r3
 80126ec: 2b00         	cmp	r3, #0x0
 80126ee: d001         	beq	0x80126f4 <thread_is_sliceable+0x68> @ imm = #0x2
 80126f0: 2301         	movs	r3, #0x1
 80126f2: e000         	b	0x80126f6 <thread_is_sliceable+0x6a> @ imm = #0x0
 80126f4: 2300         	movs	r3, #0x0
; 	bool ret = thread_is_preemptible(thread)
 80126f6: 73fb         	strb	r3, [r7, #0xf]
 80126f8: 7bfb         	ldrb	r3, [r7, #0xf]
 80126fa: f003 0301    	and	r3, r3, #0x1
 80126fe: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 8012700: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8012702: 4618         	mov	r0, r3
 8012704: 3710         	adds	r7, #0x10
 8012706: 46bd         	mov	sp, r7
 8012708: bd80         	pop	{r7, pc}
 801270a: bf00         	nop

0801270c <$d>:
 801270c: e4 27 00 20  	.word	0x200027e4

08012710 <slice_timeout>:
; {
 8012710: b480         	push	{r7}
 8012712: b085         	sub	sp, #0x14
 8012714: af00         	add	r7, sp, #0x0
 8012716: 6078         	str	r0, [r7, #0x4]
; 	int cpu = ARRAY_INDEX(slice_timeouts, timeout);
 8012718: 687b         	ldr	r3, [r7, #0x4]
 801271a: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8012740 <slice_timeout+0x30>
 801271c: 1a9b         	subs	r3, r3, r2
 801271e: 10db         	asrs	r3, r3, #0x3
 8012720: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8012744 <slice_timeout+0x34>
 8012722: fb02 f303    	mul	r3, r2, r3
 8012726: 60fb         	str	r3, [r7, #0xc]
; 	slice_expired[cpu] = true;
 8012728: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8012748 <slice_timeout+0x38>
 801272a: 68fb         	ldr	r3, [r7, #0xc]
 801272c: 4413         	add	r3, r2
 801272e: 2201         	movs	r2, #0x1
 8012730: 701a         	strb	r2, [r3]
; }
 8012732: bf00         	nop
 8012734: 3714         	adds	r7, #0x14
 8012736: 46bd         	mov	sp, r7
 8012738: f85d 7b04    	ldr	r7, [sp], #4
 801273c: 4770         	bx	lr
 801273e: bf00         	nop

08012740 <$d>:
 8012740: d8 20 00 20  	.word	0x200020d8
 8012744: ab aa aa aa  	.word	0xaaaaaaab
 8012748: e8 27 00 20  	.word	0x200027e8

0801274c <z_reset_time_slice>:
; {
 801274c: e92d 4390    	push.w	{r4, r7, r8, r9, lr}
 8012750: b085         	sub	sp, #0x14
 8012752: af00         	add	r7, sp, #0x0
 8012754: 6078         	str	r0, [r7, #0x4]
; 	int cpu = _current_cpu->id;
 8012756: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80127bc <z_reset_time_slice+0x70>
 8012758: 7c1b         	ldrb	r3, [r3, #0x10]
 801275a: 60fb         	str	r3, [r7, #0xc]
; 	z_abort_timeout(&slice_timeouts[cpu]);
 801275c: 68fa         	ldr	r2, [r7, #0xc]
 801275e: 4613         	mov	r3, r2
 8012760: 005b         	lsls	r3, r3, #0x1
 8012762: 4413         	add	r3, r2
 8012764: 00db         	lsls	r3, r3, #0x3
 8012766: 4a16         	ldr	r2, [pc, #0x58]         @ 0x80127c0 <z_reset_time_slice+0x74>
 8012768: 4413         	add	r3, r2
 801276a: 4618         	mov	r0, r3
 801276c: f000 fa48    	bl	0x8012c00 <z_abort_timeout> @ imm = #0x490
; 	slice_expired[cpu] = false;
 8012770: 4a14         	ldr	r2, [pc, #0x50]         @ 0x80127c4 <z_reset_time_slice+0x78>
 8012772: 68fb         	ldr	r3, [r7, #0xc]
 8012774: 4413         	add	r3, r2
 8012776: 2200         	movs	r2, #0x0
 8012778: 701a         	strb	r2, [r3]
; 	if (thread_is_sliceable(thread)) {
 801277a: 6878         	ldr	r0, [r7, #0x4]
 801277c: f7ff ff86    	bl	0x801268c <thread_is_sliceable> @ imm = #-0xf4
 8012780: 4603         	mov	r3, r0
 8012782: 2b00         	cmp	r3, #0x0
 8012784: d014         	beq	0x80127b0 <z_reset_time_slice+0x64> @ imm = #0x28
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 8012786: 68fa         	ldr	r2, [r7, #0xc]
 8012788: 4613         	mov	r3, r2
 801278a: 005b         	lsls	r3, r3, #0x1
 801278c: 4413         	add	r3, r2
 801278e: 00db         	lsls	r3, r3, #0x3
 8012790: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80127c0 <z_reset_time_slice+0x74>
 8012792: 189c         	adds	r4, r3, r2
; 			      K_TICKS(slice_time(thread) - 1));
 8012794: 6878         	ldr	r0, [r7, #0x4]
 8012796: f7ff ff69    	bl	0x801266c <slice_time>  @ imm = #-0x12e
 801279a: 4603         	mov	r3, r0
 801279c: 3b01         	subs	r3, #0x1
 801279e: 17da         	asrs	r2, r3, #0x1f
 80127a0: 4698         	mov	r8, r3
 80127a2: 4691         	mov	r9, r2
 80127a4: 4642         	mov	r2, r8
 80127a6: 464b         	mov	r3, r9
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 80127a8: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80127c8 <z_reset_time_slice+0x7c>
 80127aa: 4620         	mov	r0, r4
 80127ac: f000 f934    	bl	0x8012a18 <z_add_timeout> @ imm = #0x268
; }
 80127b0: bf00         	nop
 80127b2: 3714         	adds	r7, #0x14
 80127b4: 46bd         	mov	sp, r7
 80127b6: e8bd 8390    	pop.w	{r4, r7, r8, r9, pc}
 80127ba: bf00         	nop

080127bc <$d>:
 80127bc: 48 1d 00 20  	.word	0x20001d48
 80127c0: d8 20 00 20  	.word	0x200020d8
 80127c4: e8 27 00 20  	.word	0x200027e8
 80127c8: 11 27 01 08  	.word	0x08012711

080127cc <z_time_slice>:
; {
 80127cc: b580         	push	{r7, lr}
 80127ce: b092         	sub	sp, #0x48
 80127d0: af00         	add	r7, sp, #0x0
 80127d2: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80128a8 <z_time_slice+0xdc>
 80127d4: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80127d6: f3ef 8311    	mrs	r3, basepri
 80127da: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 80127dc: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 80127de: 637b         	str	r3, [r7, #0x34]
 80127e0: 2310         	movs	r3, #0x10
 80127e2: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80127e4: 6b3b         	ldr	r3, [r7, #0x30]
 80127e6: f383 8812    	msr	basepri_max, r3
; }
 80127ea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80127ec: f3bf 8f6f    	isb	sy
; }
 80127f0: bf00         	nop
; 	return key;
 80127f2: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 80127f4: 603b         	str	r3, [r7]
 80127f6: 6bfb         	ldr	r3, [r7, #0x3c]
 80127f8: 62fb         	str	r3, [r7, #0x2c]
; }
 80127fa: bf00         	nop
 80127fc: 6bfb         	ldr	r3, [r7, #0x3c]
 80127fe: 62bb         	str	r3, [r7, #0x28]
; }
 8012800: bf00         	nop
; 	return k;
 8012802: 683b         	ldr	r3, [r7]
 8012804: 60fb         	str	r3, [r7, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8012806: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80128ac <z_time_slice+0xe0>
 8012808: 689b         	ldr	r3, [r3, #0x8]
 801280a: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 801280c: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *curr = arch_current_thread();
 801280e: 647b         	str	r3, [r7, #0x44]
; 	if (pending_current == curr) {
 8012810: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x80128b0 <z_time_slice+0xe4>
 8012812: 681b         	ldr	r3, [r3]
 8012814: 6c7a         	ldr	r2, [r7, #0x44]
 8012816: 429a         	cmp	r2, r3
 8012818: d113         	bne	0x8012842 <z_time_slice+0x76> @ imm = #0x26
; 		z_reset_time_slice(curr);
 801281a: 6c78         	ldr	r0, [r7, #0x44]
 801281c: f7ff ff96    	bl	0x801274c <z_reset_time_slice> @ imm = #-0xd4
 8012820: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80128a8 <z_time_slice+0xdc>
 8012822: 627b         	str	r3, [r7, #0x24]
 8012824: 68fb         	ldr	r3, [r7, #0xc]
 8012826: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 8012828: 687b         	ldr	r3, [r7, #0x4]
 801282a: 623b         	str	r3, [r7, #0x20]
 801282c: 6a3b         	ldr	r3, [r7, #0x20]
 801282e: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012830: 69fb         	ldr	r3, [r7, #0x1c]
 8012832: f383 8811    	msr	basepri, r3
; }
 8012836: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012838: f3bf 8f6f    	isb	sy
; }
 801283c: bf00         	nop
; }
 801283e: bf00         	nop
; }
 8012840: e02f         	b	0x80128a2 <z_time_slice+0xd6> @ imm = #0x5e
; 	pending_current = NULL;
 8012842: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x80128b0 <z_time_slice+0xe4>
 8012844: 2200         	movs	r2, #0x0
 8012846: 601a         	str	r2, [r3]
; 	if (slice_expired[_current_cpu->id] && thread_is_sliceable(curr)) {
 8012848: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80128ac <z_time_slice+0xe0>
 801284a: 7c1b         	ldrb	r3, [r3, #0x10]
 801284c: 461a         	mov	r2, r3
 801284e: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80128b4 <z_time_slice+0xe8>
 8012850: 5c9b         	ldrb	r3, [r3, r2]
 8012852: 2b00         	cmp	r3, #0x0
 8012854: d014         	beq	0x8012880 <z_time_slice+0xb4> @ imm = #0x28
 8012856: 6c78         	ldr	r0, [r7, #0x44]
 8012858: f7ff ff18    	bl	0x801268c <thread_is_sliceable> @ imm = #-0x1d0
 801285c: 4603         	mov	r3, r0
 801285e: 2b00         	cmp	r3, #0x0
 8012860: d00e         	beq	0x8012880 <z_time_slice+0xb4> @ imm = #0x1c
; 		if (!z_is_thread_prevented_from_running(curr)) {
 8012862: 6c78         	ldr	r0, [r7, #0x44]
 8012864: f00d f86b    	bl	0x801f93e <z_is_thread_prevented_from_running> @ imm = #0xd0d6
 8012868: 4603         	mov	r3, r0
 801286a: f083 0301    	eor	r3, r3, #0x1
 801286e: b2db         	uxtb	r3, r3
 8012870: 2b00         	cmp	r3, #0x0
 8012872: d002         	beq	0x801287a <z_time_slice+0xae> @ imm = #0x4
; 			move_thread_to_end_of_prio_q(curr);
 8012874: 6c78         	ldr	r0, [r7, #0x44]
 8012876: f7fe fa97    	bl	0x8010da8 <move_thread_to_end_of_prio_q> @ imm = #-0x1ad2
; 		z_reset_time_slice(curr);
 801287a: 6c78         	ldr	r0, [r7, #0x44]
 801287c: f7ff ff66    	bl	0x801274c <z_reset_time_slice> @ imm = #-0x134
 8012880: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80128a8 <z_time_slice+0xdc>
 8012882: 61bb         	str	r3, [r7, #0x18]
 8012884: 68fb         	ldr	r3, [r7, #0xc]
 8012886: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8012888: 68bb         	ldr	r3, [r7, #0x8]
 801288a: 617b         	str	r3, [r7, #0x14]
 801288c: 697b         	ldr	r3, [r7, #0x14]
 801288e: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012890: 693b         	ldr	r3, [r7, #0x10]
 8012892: f383 8811    	msr	basepri, r3
; }
 8012896: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012898: f3bf 8f6f    	isb	sy
; }
 801289c: bf00         	nop
; }
 801289e: bf00         	nop
; }
 80128a0: bf00         	nop
; }
 80128a2: 3748         	adds	r7, #0x48
 80128a4: 46bd         	mov	sp, r7
 80128a6: bd80         	pop	{r7, pc}

080128a8 <$d>:
 80128a8: e0 27 00 20  	.word	0x200027e0
 80128ac: 48 1d 00 20  	.word	0x20001d48
 80128b0: ec 27 00 20  	.word	0x200027ec
 80128b4: e8 27 00 20  	.word	0x200027e8

080128b8 <z_thread_monitor_exit>:
; {
 80128b8: b480         	push	{r7}
 80128ba: b091         	sub	sp, #0x44
 80128bc: af00         	add	r7, sp, #0x0
 80128be: 6078         	str	r0, [r7, #0x4]
 80128c0: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8012970 <z_thread_monitor_exit+0xb8>
 80128c2: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80128c4: f3ef 8311    	mrs	r3, basepri
 80128c8: 637b         	str	r3, [r7, #0x34]
;   return(result);
 80128ca: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 80128cc: 633b         	str	r3, [r7, #0x30]
 80128ce: 2310         	movs	r3, #0x10
 80128d0: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80128d2: 6afb         	ldr	r3, [r7, #0x2c]
 80128d4: f383 8812    	msr	basepri_max, r3
; }
 80128d8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80128da: f3bf 8f6f    	isb	sy
; }
 80128de: bf00         	nop
; 	return key;
 80128e0: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 80128e2: 60fb         	str	r3, [r7, #0xc]
 80128e4: 6bbb         	ldr	r3, [r7, #0x38]
 80128e6: 62bb         	str	r3, [r7, #0x28]
; }
 80128e8: bf00         	nop
 80128ea: 6bbb         	ldr	r3, [r7, #0x38]
 80128ec: 627b         	str	r3, [r7, #0x24]
; }
 80128ee: bf00         	nop
; 	return k;
 80128f0: 68fb         	ldr	r3, [r7, #0xc]
 80128f2: 617b         	str	r3, [r7, #0x14]
; 	if (thread == _kernel.threads) {
 80128f4: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8012974 <z_thread_monitor_exit+0xbc>
 80128f6: 6b1b         	ldr	r3, [r3, #0x30]
 80128f8: 687a         	ldr	r2, [r7, #0x4]
 80128fa: 429a         	cmp	r2, r3
 80128fc: d106         	bne	0x801290c <z_thread_monitor_exit+0x54> @ imm = #0xc
; 		_kernel.threads = _kernel.threads->next_thread;
 80128fe: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8012974 <z_thread_monitor_exit+0xbc>
 8012900: 6b1b         	ldr	r3, [r3, #0x30]
 8012902: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 8012906: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8012974 <z_thread_monitor_exit+0xbc>
 8012908: 6313         	str	r3, [r2, #0x30]
 801290a: e019         	b	0x8012940 <z_thread_monitor_exit+0x88> @ imm = #0x32
; 		prev_thread = _kernel.threads;
 801290c: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8012974 <z_thread_monitor_exit+0xbc>
 801290e: 6b1b         	ldr	r3, [r3, #0x30]
 8012910: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 8012912: e003         	b	0x801291c <z_thread_monitor_exit+0x64> @ imm = #0x6
; 			prev_thread = prev_thread->next_thread;
 8012914: 6bfb         	ldr	r3, [r7, #0x3c]
 8012916: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 801291a: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 801291c: 6bfb         	ldr	r3, [r7, #0x3c]
 801291e: 2b00         	cmp	r3, #0x0
 8012920: d005         	beq	0x801292e <z_thread_monitor_exit+0x76> @ imm = #0xa
; 			(thread != prev_thread->next_thread)) {
 8012922: 6bfb         	ldr	r3, [r7, #0x3c]
 8012924: f8d3 3090    	ldr.w	r3, [r3, #0x90]
; 		while ((prev_thread != NULL) &&
 8012928: 687a         	ldr	r2, [r7, #0x4]
 801292a: 429a         	cmp	r2, r3
 801292c: d1f2         	bne	0x8012914 <z_thread_monitor_exit+0x5c> @ imm = #-0x1c
; 		if (prev_thread != NULL) {
 801292e: 6bfb         	ldr	r3, [r7, #0x3c]
 8012930: 2b00         	cmp	r3, #0x0
 8012932: d005         	beq	0x8012940 <z_thread_monitor_exit+0x88> @ imm = #0xa
; 			prev_thread->next_thread = thread->next_thread;
 8012934: 687b         	ldr	r3, [r7, #0x4]
 8012936: f8d3 2090    	ldr.w	r2, [r3, #0x90]
 801293a: 6bfb         	ldr	r3, [r7, #0x3c]
 801293c: f8c3 2090    	str.w	r2, [r3, #0x90]
 8012940: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8012970 <z_thread_monitor_exit+0xb8>
 8012942: 623b         	str	r3, [r7, #0x20]
 8012944: 697b         	ldr	r3, [r7, #0x14]
 8012946: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8012948: 693b         	ldr	r3, [r7, #0x10]
 801294a: 61fb         	str	r3, [r7, #0x1c]
 801294c: 69fb         	ldr	r3, [r7, #0x1c]
 801294e: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012950: 69bb         	ldr	r3, [r7, #0x18]
 8012952: f383 8811    	msr	basepri, r3
; }
 8012956: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012958: f3bf 8f6f    	isb	sy
; }
 801295c: bf00         	nop
; }
 801295e: bf00         	nop
; }
 8012960: bf00         	nop
; }
 8012962: bf00         	nop
 8012964: 3744         	adds	r7, #0x44
 8012966: 46bd         	mov	sp, r7
 8012968: f85d 7b04    	ldr	r7, [sp], #4
 801296c: 4770         	bx	lr
 801296e: bf00         	nop

08012970 <$d>:
 8012970: f0 27 00 20  	.word	0x200027f0
 8012974: 48 1d 00 20  	.word	0x20001d48

08012978 <z_data_copy>:
; {
 8012978: b580         	push	{r7, lr}
 801297a: af00         	add	r7, sp, #0x0
; 		       __data_region_end - __data_region_start);
 801297c: 4a08         	ldr	r2, [pc, #0x20]         @ 0x80129a0 <z_data_copy+0x28>
 801297e: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80129a4 <z_data_copy+0x2c>
 8012980: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__data_region_start, &__data_region_load_start,
 8012982: 461a         	mov	r2, r3
 8012984: 4908         	ldr	r1, [pc, #0x20]         @ 0x80129a8 <z_data_copy+0x30>
 8012986: 4807         	ldr	r0, [pc, #0x1c]         @ 0x80129a4 <z_data_copy+0x2c>
 8012988: f00b fc14    	bl	0x801e1b4 <z_early_memcpy> @ imm = #0xb828
; 		       __ramfunc_end - __ramfunc_region_start);
 801298c: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80129ac <z_data_copy+0x34>
 801298e: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80129b0 <z_data_copy+0x38>
 8012990: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__ramfunc_region_start, &__ramfunc_load_start,
 8012992: 461a         	mov	r2, r3
 8012994: 4907         	ldr	r1, [pc, #0x1c]         @ 0x80129b4 <z_data_copy+0x3c>
 8012996: 4806         	ldr	r0, [pc, #0x18]         @ 0x80129b0 <z_data_copy+0x38>
 8012998: f00b fc0c    	bl	0x801e1b4 <z_early_memcpy> @ imm = #0xb818
; }
 801299c: bf00         	nop
 801299e: bd80         	pop	{r7, pc}

080129a0 <$d>:
 80129a0: 88 06 00 20  	.word	0x20000688
 80129a4: 00 00 00 20  	.word	0x20000000
 80129a8: b8 34 02 08  	.word	0x080234b8
 80129ac: 00 00 00 20  	.word	0x20000000
 80129b0: 00 00 00 20  	.word	0x20000000
 80129b4: b8 34 02 08  	.word	0x080234b8

080129b8 <first>:
; {
 80129b8: b580         	push	{r7, lr}
 80129ba: b082         	sub	sp, #0x8
 80129bc: af00         	add	r7, sp, #0x0
; 	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);
 80129be: 4804         	ldr	r0, [pc, #0x10]         @ 0x80129d0 <first+0x18>
 80129c0: f00d f825    	bl	0x801fa0e <sys_dlist_peek_head> @ imm = #0xd04a
 80129c4: 6078         	str	r0, [r7, #0x4]
; 	return (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);
 80129c6: 687b         	ldr	r3, [r7, #0x4]
; }
 80129c8: 4618         	mov	r0, r3
 80129ca: 3708         	adds	r7, #0x8
 80129cc: 46bd         	mov	sp, r7
 80129ce: bd80         	pop	{r7, pc}

080129d0 <$d>:
 80129d0: 18 06 00 20  	.word	0x20000618

080129d4 <next>:
; {
 80129d4: b580         	push	{r7, lr}
 80129d6: b084         	sub	sp, #0x10
 80129d8: af00         	add	r7, sp, #0x0
 80129da: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);
 80129dc: 687b         	ldr	r3, [r7, #0x4]
 80129de: 4619         	mov	r1, r3
 80129e0: 4804         	ldr	r0, [pc, #0x10]         @ 0x80129f4 <next+0x20>
 80129e2: f00d f83a    	bl	0x801fa5a <sys_dlist_peek_next> @ imm = #0xd074
 80129e6: 60f8         	str	r0, [r7, #0xc]
; 	return (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);
 80129e8: 68fb         	ldr	r3, [r7, #0xc]
; }
 80129ea: 4618         	mov	r0, r3
 80129ec: 3710         	adds	r7, #0x10
 80129ee: 46bd         	mov	sp, r7
 80129f0: bd80         	pop	{r7, pc}
 80129f2: bf00         	nop

080129f4 <$d>:
 80129f4: 18 06 00 20  	.word	0x20000618

080129f8 <elapsed>:
; {
 80129f8: b580         	push	{r7, lr}
 80129fa: af00         	add	r7, sp, #0x0
; 	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 80129fc: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8012a14 <elapsed+0x1c>
 80129fe: 681b         	ldr	r3, [r3]
 8012a00: 2b00         	cmp	r3, #0x0
 8012a02: d103         	bne	0x8012a0c <elapsed+0x14> @ imm = #0x6
 8012a04: f7fb fcc4    	bl	0x800e390 <sys_clock_elapsed> @ imm = #-0x4678
 8012a08: 4603         	mov	r3, r0
 8012a0a: e000         	b	0x8012a0e <elapsed+0x16> @ imm = #0x0
 8012a0c: 2300         	movs	r3, #0x0
; }
 8012a0e: 4618         	mov	r0, r3
 8012a10: bd80         	pop	{r7, pc}
 8012a12: bf00         	nop

08012a14 <$d>:
 8012a14: f0 27 00 20  	.word	0x200027f0

08012a18 <z_add_timeout>:
; {
 8012a18: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8012a1c: b0a1         	sub	sp, #0x84
 8012a1e: af00         	add	r7, sp, #0x0
 8012a20: 6378         	str	r0, [r7, #0x34]
 8012a22: 6339         	str	r1, [r7, #0x30]
 8012a24: e9c7 230a    	strd	r2, r3, [r7, #40]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8012a28: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 8012a2c: f04f 32ff    	mov.w	r2, #0xffffffff
 8012a30: f04f 33ff    	mov.w	r3, #0xffffffff
 8012a34: 4299         	cmp	r1, r3
 8012a36: bf08         	it	eq
 8012a38: 4290         	cmpeq	r0, r2
 8012a3a: d100         	bne	0x8012a3e <z_add_timeout+0x26> @ imm = #0x0
 8012a3c: e0d4         	b	0x8012be8 <z_add_timeout+0x1d0> @ imm = #0x1a8
; 	to->fn = fn;
 8012a3e: 6b7a         	ldr	r2, [r7, #0x34]
 8012a40: 6b3b         	ldr	r3, [r7, #0x30]
 8012a42: 6093         	str	r3, [r2, #0x8]
; 	K_SPINLOCK(&timeout_lock) {
 8012a44: 2300         	movs	r3, #0x0
 8012a46: 64bb         	str	r3, [r7, #0x48]
 8012a48: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8012bf0 <z_add_timeout+0x1d8>
 8012a4a: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8012a4c: f3ef 8311    	mrs	r3, basepri
 8012a50: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 8012a52: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 8012a54: 667b         	str	r3, [r7, #0x64]
 8012a56: 2310         	movs	r3, #0x10
 8012a58: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8012a5a: 6e3b         	ldr	r3, [r7, #0x60]
 8012a5c: f383 8812    	msr	basepri_max, r3
; }
 8012a60: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012a62: f3bf 8f6f    	isb	sy
; }
 8012a66: bf00         	nop
; 	return key;
 8012a68: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 8012a6a: 63fb         	str	r3, [r7, #0x3c]
 8012a6c: 6efb         	ldr	r3, [r7, #0x6c]
 8012a6e: 65fb         	str	r3, [r7, #0x5c]
; }
 8012a70: bf00         	nop
 8012a72: 6efb         	ldr	r3, [r7, #0x6c]
 8012a74: 65bb         	str	r3, [r7, #0x58]
; }
 8012a76: bf00         	nop
; 	return k;
 8012a78: 6bfb         	ldr	r3, [r7, #0x3c]
 8012a7a: 647b         	str	r3, [r7, #0x44]
; 	K_SPINLOCK(&timeout_lock) {
 8012a7c: e0b0         	b	0x8012be0 <z_add_timeout+0x1c8> @ imm = #0x160
; 		    (Z_TICK_ABS(timeout.ticks) >= 0)) {
 8012a7e: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8012a82: f06f 0001    	mvn	r0, #0x1
 8012a86: f04f 31ff    	mov.w	r1, #0xffffffff
 8012a8a: 1a80         	subs	r0, r0, r2
 8012a8c: 6238         	str	r0, [r7, #0x20]
 8012a8e: eb61 0303    	sbc.w	r3, r1, r3
 8012a92: 627b         	str	r3, [r7, #0x24]
; 		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 8012a94: 6a7b         	ldr	r3, [r7, #0x24]
 8012a96: 2b00         	cmp	r3, #0x0
 8012a98: db24         	blt	0x8012ae4 <z_add_timeout+0xcc> @ imm = #0x48
; 			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 8012a9a: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8012a9e: 4610         	mov	r0, r2
 8012aa0: 4619         	mov	r1, r3
 8012aa2: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8012bf4 <z_add_timeout+0x1dc>
 8012aa4: e9d3 2300    	ldrd	r2, r3, [r3]
 8012aa8: 1884         	adds	r4, r0, r2
 8012aaa: eb41 0503    	adc.w	r5, r1, r3
 8012aae: f06f 0201    	mvn	r2, #0x1
 8012ab2: f04f 33ff    	mov.w	r3, #0xffffffff
 8012ab6: 1b12         	subs	r2, r2, r4
 8012ab8: 61ba         	str	r2, [r7, #0x18]
 8012aba: eb63 0305    	sbc.w	r3, r3, r5
 8012abe: 61fb         	str	r3, [r7, #0x1c]
 8012ac0: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8012ac4: e9c7 231c    	strd	r2, r3, [r7, #112]
; 			to->dticks = MAX(1, ticks);
 8012ac8: e9d7 231c    	ldrd	r2, r3, [r7, #112]
 8012acc: 2a01         	cmp	r2, #0x1
 8012ace: f173 0100    	sbcs	r1, r3, #0x0
 8012ad2: da03         	bge	0x8012adc <z_add_timeout+0xc4> @ imm = #0x6
 8012ad4: f04f 0201    	mov.w	r2, #0x1
 8012ad8: f04f 0300    	mov.w	r3, #0x0
 8012adc: 6b79         	ldr	r1, [r7, #0x34]
 8012ade: e9c1 2304    	strd	r2, r3, [r1, #16]
 8012ae2: e016         	b	0x8012b12 <z_add_timeout+0xfa> @ imm = #0x2c
; 			to->dticks = timeout.ticks + 1 + elapsed();
 8012ae4: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8012ae8: f112 0801    	adds.w	r8, r2, #0x1
 8012aec: f143 0900    	adc	r9, r3, #0x0
 8012af0: f7ff ff82    	bl	0x80129f8 <elapsed>     @ imm = #-0xfc
 8012af4: 4603         	mov	r3, r0
 8012af6: 17da         	asrs	r2, r3, #0x1f
 8012af8: 469a         	mov	r10, r3
 8012afa: 4693         	mov	r11, r2
 8012afc: eb18 030a    	adds.w	r3, r8, r10
 8012b00: 613b         	str	r3, [r7, #0x10]
 8012b02: eb49 030b    	adc.w	r3, r9, r11
 8012b06: 617b         	str	r3, [r7, #0x14]
 8012b08: 6b7b         	ldr	r3, [r7, #0x34]
 8012b0a: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 8012b0e: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 8012b12: f7ff ff51    	bl	0x80129b8 <first>       @ imm = #-0x15e
 8012b16: 67f8         	str	r0, [r7, #0x7c]
 8012b18: e033         	b	0x8012b82 <z_add_timeout+0x16a> @ imm = #0x66
; 			if (t->dticks > to->dticks) {
 8012b1a: 6ffb         	ldr	r3, [r7, #0x7c]
 8012b1c: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8012b20: 6b7b         	ldr	r3, [r7, #0x34]
 8012b22: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8012b26: 4282         	cmp	r2, r0
 8012b28: 418b         	sbcs	r3, r1
 8012b2a: da16         	bge	0x8012b5a <z_add_timeout+0x142> @ imm = #0x2c
; 				t->dticks -= to->dticks;
 8012b2c: 6ffb         	ldr	r3, [r7, #0x7c]
 8012b2e: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8012b32: 6b7b         	ldr	r3, [r7, #0x34]
 8012b34: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8012b38: 1a86         	subs	r6, r0, r2
 8012b3a: 60be         	str	r6, [r7, #0x8]
 8012b3c: eb61 0303    	sbc.w	r3, r1, r3
 8012b40: 60fb         	str	r3, [r7, #0xc]
 8012b42: 6ffb         	ldr	r3, [r7, #0x7c]
 8012b44: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 8012b48: e9c3 1204    	strd	r1, r2, [r3, #16]
; 				sys_dlist_insert(&t->node, &to->node);
 8012b4c: 6ffa         	ldr	r2, [r7, #0x7c]
 8012b4e: 6b7b         	ldr	r3, [r7, #0x34]
 8012b50: 4619         	mov	r1, r3
 8012b52: 4610         	mov	r0, r2
 8012b54: f00c ffae    	bl	0x801fab4 <sys_dlist_insert> @ imm = #0xcf5c
; 				break;
 8012b58: e016         	b	0x8012b88 <z_add_timeout+0x170> @ imm = #0x2c
; 			to->dticks -= t->dticks;
 8012b5a: 6b7b         	ldr	r3, [r7, #0x34]
 8012b5c: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8012b60: 6ffb         	ldr	r3, [r7, #0x7c]
 8012b62: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8012b66: 1a86         	subs	r6, r0, r2
 8012b68: 603e         	str	r6, [r7]
 8012b6a: eb61 0303    	sbc.w	r3, r1, r3
 8012b6e: 607b         	str	r3, [r7, #0x4]
 8012b70: 6b7b         	ldr	r3, [r7, #0x34]
 8012b72: e9d7 1200    	ldrd	r1, r2, [r7]
 8012b76: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 8012b7a: 6ff8         	ldr	r0, [r7, #0x7c]
 8012b7c: f7ff ff2a    	bl	0x80129d4 <next>        @ imm = #-0x1ac
 8012b80: 67f8         	str	r0, [r7, #0x7c]
 8012b82: 6ffb         	ldr	r3, [r7, #0x7c]
 8012b84: 2b00         	cmp	r3, #0x0
 8012b86: d1c8         	bne	0x8012b1a <z_add_timeout+0x102> @ imm = #-0x70
; 		if (t == NULL) {
 8012b88: 6ffb         	ldr	r3, [r7, #0x7c]
 8012b8a: 2b00         	cmp	r3, #0x0
 8012b8c: d104         	bne	0x8012b98 <z_add_timeout+0x180> @ imm = #0x8
; 			sys_dlist_append(&timeout_list, &to->node);
 8012b8e: 6b7b         	ldr	r3, [r7, #0x34]
 8012b90: 4619         	mov	r1, r3
 8012b92: 4819         	ldr	r0, [pc, #0x64]         @ 0x8012bf8 <z_add_timeout+0x1e0>
 8012b94: f00c ff74    	bl	0x801fa80 <sys_dlist_append> @ imm = #0xcee8
; 		if (to == first() && announce_remaining == 0) {
 8012b98: f7ff ff0e    	bl	0x80129b8 <first>       @ imm = #-0x1e4
 8012b9c: 4602         	mov	r2, r0
 8012b9e: 6b7b         	ldr	r3, [r7, #0x34]
 8012ba0: 4293         	cmp	r3, r2
 8012ba2: d10a         	bne	0x8012bba <z_add_timeout+0x1a2> @ imm = #0x14
 8012ba4: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8012bfc <z_add_timeout+0x1e4>
 8012ba6: 681b         	ldr	r3, [r3]
 8012ba8: 2b00         	cmp	r3, #0x0
 8012baa: d106         	bne	0x8012bba <z_add_timeout+0x1a2> @ imm = #0xc
; 			sys_clock_set_timeout(next_timeout(), false);
 8012bac: f00c ffd3    	bl	0x801fb56 <next_timeout> @ imm = #0xcfa6
 8012bb0: 4603         	mov	r3, r0
 8012bb2: 2100         	movs	r1, #0x0
 8012bb4: 4618         	mov	r0, r3
 8012bb6: f7fb fae7    	bl	0x800e188 <sys_clock_set_timeout> @ imm = #-0x4a32
 8012bba: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8012bf0 <z_add_timeout+0x1d8>
 8012bbc: 657b         	str	r3, [r7, #0x54]
 8012bbe: 6c7b         	ldr	r3, [r7, #0x44]
 8012bc0: 643b         	str	r3, [r7, #0x40]
; 	arch_irq_unlock(key.key);
 8012bc2: 6c3b         	ldr	r3, [r7, #0x40]
 8012bc4: 653b         	str	r3, [r7, #0x50]
 8012bc6: 6d3b         	ldr	r3, [r7, #0x50]
 8012bc8: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012bca: 6cfb         	ldr	r3, [r7, #0x4c]
 8012bcc: f383 8811    	msr	basepri, r3
; }
 8012bd0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012bd2: f3bf 8f6f    	isb	sy
; }
 8012bd6: bf00         	nop
; }
 8012bd8: bf00         	nop
; }
 8012bda: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 8012bdc: 2301         	movs	r3, #0x1
 8012bde: 64bb         	str	r3, [r7, #0x48]
 8012be0: 6cbb         	ldr	r3, [r7, #0x48]
 8012be2: 2b00         	cmp	r3, #0x0
 8012be4: f43f af4b    	beq.w	0x8012a7e <z_add_timeout+0x66> @ imm = #-0x16a
; }
 8012be8: 3784         	adds	r7, #0x84
 8012bea: 46bd         	mov	sp, r7
 8012bec: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}

08012bf0 <$d>:
 8012bf0: f0 27 00 20  	.word	0x200027f0
 8012bf4: f0 20 00 20  	.word	0x200020f0
 8012bf8: 18 06 00 20  	.word	0x20000618
 8012bfc: f0 27 00 20  	.word	0x200027f0

08012c00 <z_abort_timeout>:
; {
 8012c00: b580         	push	{r7, lr}
 8012c02: b090         	sub	sp, #0x40
 8012c04: af00         	add	r7, sp, #0x0
 8012c06: 6078         	str	r0, [r7, #0x4]
; 	int ret = -EINVAL;
 8012c08: f06f 0315    	mvn	r3, #0x15
 8012c0c: 63fb         	str	r3, [r7, #0x3c]
; 	K_SPINLOCK(&timeout_lock) {
 8012c0e: 2300         	movs	r3, #0x0
 8012c10: 617b         	str	r3, [r7, #0x14]
 8012c12: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8012c98 <z_abort_timeout+0x98>
 8012c14: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8012c16: f3ef 8311    	mrs	r3, basepri
 8012c1a: 637b         	str	r3, [r7, #0x34]
;   return(result);
 8012c1c: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 8012c1e: 633b         	str	r3, [r7, #0x30]
 8012c20: 2310         	movs	r3, #0x10
 8012c22: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8012c24: 6afb         	ldr	r3, [r7, #0x2c]
 8012c26: f383 8812    	msr	basepri_max, r3
; }
 8012c2a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012c2c: f3bf 8f6f    	isb	sy
; }
 8012c30: bf00         	nop
; 	return key;
 8012c32: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 8012c34: 60bb         	str	r3, [r7, #0x8]
 8012c36: 6bbb         	ldr	r3, [r7, #0x38]
 8012c38: 62bb         	str	r3, [r7, #0x28]
; }
 8012c3a: bf00         	nop
 8012c3c: 6bbb         	ldr	r3, [r7, #0x38]
 8012c3e: 627b         	str	r3, [r7, #0x24]
; }
 8012c40: bf00         	nop
; 	return k;
 8012c42: 68bb         	ldr	r3, [r7, #0x8]
 8012c44: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&timeout_lock) {
 8012c46: e01e         	b	0x8012c86 <z_abort_timeout+0x86> @ imm = #0x3c
; 		if (sys_dnode_is_linked(&to->node)) {
 8012c48: 687b         	ldr	r3, [r7, #0x4]
 8012c4a: 4618         	mov	r0, r3
 8012c4c: f00c febc    	bl	0x801f9c8 <sys_dnode_is_linked> @ imm = #0xcd78
 8012c50: 4603         	mov	r3, r0
 8012c52: 2b00         	cmp	r3, #0x0
 8012c54: d004         	beq	0x8012c60 <z_abort_timeout+0x60> @ imm = #0x8
; 			remove_timeout(to);
 8012c56: 6878         	ldr	r0, [r7, #0x4]
 8012c58: f00c ff5d    	bl	0x801fb16 <remove_timeout> @ imm = #0xceba
; 			ret = 0;
 8012c5c: 2300         	movs	r3, #0x0
 8012c5e: 63fb         	str	r3, [r7, #0x3c]
 8012c60: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8012c98 <z_abort_timeout+0x98>
 8012c62: 623b         	str	r3, [r7, #0x20]
 8012c64: 693b         	ldr	r3, [r7, #0x10]
 8012c66: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 8012c68: 68fb         	ldr	r3, [r7, #0xc]
 8012c6a: 61fb         	str	r3, [r7, #0x1c]
 8012c6c: 69fb         	ldr	r3, [r7, #0x1c]
 8012c6e: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012c70: 69bb         	ldr	r3, [r7, #0x18]
 8012c72: f383 8811    	msr	basepri, r3
; }
 8012c76: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012c78: f3bf 8f6f    	isb	sy
; }
 8012c7c: bf00         	nop
; }
 8012c7e: bf00         	nop
; }
 8012c80: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 8012c82: 2301         	movs	r3, #0x1
 8012c84: 617b         	str	r3, [r7, #0x14]
 8012c86: 697b         	ldr	r3, [r7, #0x14]
 8012c88: 2b00         	cmp	r3, #0x0
 8012c8a: d0dd         	beq	0x8012c48 <z_abort_timeout+0x48> @ imm = #-0x46
; 	return ret;
 8012c8c: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 8012c8e: 4618         	mov	r0, r3
 8012c90: 3740         	adds	r7, #0x40
 8012c92: 46bd         	mov	sp, r7
 8012c94: bd80         	pop	{r7, pc}
 8012c96: bf00         	nop

08012c98 <$d>:
 8012c98: f0 27 00 20  	.word	0x200027f0

08012c9c <sys_clock_announce>:
; {
 8012c9c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8012ca0: b0a4         	sub	sp, #0x90
 8012ca2: af00         	add	r7, sp, #0x0
 8012ca4: 6278         	str	r0, [r7, #0x24]
 8012ca6: 4b73         	ldr	r3, [pc, #0x1cc]        @ 0x8012e74 <sys_clock_announce+0x1d8>
 8012ca8: f8c7 3084    	str.w	r3, [r7, #0x84]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8012cac: f3ef 8311    	mrs	r3, basepri
 8012cb0: f8c7 3080    	str.w	r3, [r7, #0x80]
;   return(result);
 8012cb4: f8d7 3080    	ldr.w	r3, [r7, #0x80]
; 	key = __get_BASEPRI();
 8012cb8: 67fb         	str	r3, [r7, #0x7c]
 8012cba: 2310         	movs	r3, #0x10
 8012cbc: 67bb         	str	r3, [r7, #0x78]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8012cbe: 6fbb         	ldr	r3, [r7, #0x78]
 8012cc0: f383 8812    	msr	basepri_max, r3
; }
 8012cc4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012cc6: f3bf 8f6f    	isb	sy
; }
 8012cca: bf00         	nop
; 	return key;
 8012ccc: 6ffb         	ldr	r3, [r7, #0x7c]
; 	k.key = arch_irq_lock();
 8012cce: 637b         	str	r3, [r7, #0x34]
 8012cd0: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8012cd4: 677b         	str	r3, [r7, #0x74]
; }
 8012cd6: bf00         	nop
 8012cd8: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8012cdc: 673b         	str	r3, [r7, #0x70]
; }
 8012cde: bf00         	nop
; 	return k;
 8012ce0: 6b7b         	ldr	r3, [r7, #0x34]
 8012ce2: 63fb         	str	r3, [r7, #0x3c]
; 	announce_remaining = ticks;
 8012ce4: 4a64         	ldr	r2, [pc, #0x190]        @ 0x8012e78 <sys_clock_announce+0x1dc>
 8012ce6: 6a7b         	ldr	r3, [r7, #0x24]
 8012ce8: 6013         	str	r3, [r2]
; 	for (t = first();
 8012cea: f7ff fe65    	bl	0x80129b8 <first>       @ imm = #-0x336
 8012cee: f8c7 008c    	str.w	r0, [r7, #0x8c]
 8012cf2: e061         	b	0x8012db8 <sys_clock_announce+0x11c> @ imm = #0xc2
; 		int dt = t->dticks;
 8012cf4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8012cf8: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8012cfc: 4613         	mov	r3, r2
 8012cfe: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		curr_tick += dt;
 8012d02: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8012d06: 17da         	asrs	r2, r3, #0x1f
 8012d08: 469a         	mov	r10, r3
 8012d0a: 4693         	mov	r11, r2
 8012d0c: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x8012e7c <sys_clock_announce+0x1e0>
 8012d0e: e9d3 2300    	ldrd	r2, r3, [r3]
 8012d12: eb1a 0102    	adds.w	r1, r10, r2
 8012d16: 6139         	str	r1, [r7, #0x10]
 8012d18: eb4b 0303    	adc.w	r3, r11, r3
 8012d1c: 617b         	str	r3, [r7, #0x14]
 8012d1e: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8012e7c <sys_clock_announce+0x1e0>
 8012d20: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 8012d24: e9c3 1200    	strd	r1, r2, [r3]
; 		t->dticks = 0;
 8012d28: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8012d2c: f04f 0200    	mov.w	r2, #0x0
 8012d30: f04f 0300    	mov.w	r3, #0x0
 8012d34: e9c1 2304    	strd	r2, r3, [r1, #16]
; 		remove_timeout(t);
 8012d38: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 8012d3c: f00c feeb    	bl	0x801fb16 <remove_timeout> @ imm = #0xcdd6
 8012d40: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x8012e74 <sys_clock_announce+0x1d8>
 8012d42: 657b         	str	r3, [r7, #0x54]
 8012d44: 6bfb         	ldr	r3, [r7, #0x3c]
 8012d46: 633b         	str	r3, [r7, #0x30]
; 	arch_irq_unlock(key.key);
 8012d48: 6b3b         	ldr	r3, [r7, #0x30]
 8012d4a: 653b         	str	r3, [r7, #0x50]
 8012d4c: 6d3b         	ldr	r3, [r7, #0x50]
 8012d4e: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012d50: 6cfb         	ldr	r3, [r7, #0x4c]
 8012d52: f383 8811    	msr	basepri, r3
; }
 8012d56: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012d58: f3bf 8f6f    	isb	sy
; }
 8012d5c: bf00         	nop
; }
 8012d5e: bf00         	nop
; }
 8012d60: bf00         	nop
; 		t->fn(t);
 8012d62: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8012d66: 689b         	ldr	r3, [r3, #0x8]
 8012d68: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 8012d6c: 4798         	blx	r3
 8012d6e: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8012e74 <sys_clock_announce+0x1d8>
 8012d70: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8012d72: f3ef 8311    	mrs	r3, basepri
 8012d76: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 8012d78: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 8012d7a: 667b         	str	r3, [r7, #0x64]
 8012d7c: 2310         	movs	r3, #0x10
 8012d7e: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8012d80: 6e3b         	ldr	r3, [r7, #0x60]
 8012d82: f383 8812    	msr	basepri_max, r3
; }
 8012d86: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012d88: f3bf 8f6f    	isb	sy
; }
 8012d8c: bf00         	nop
; 	return key;
 8012d8e: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 8012d90: 62fb         	str	r3, [r7, #0x2c]
 8012d92: 6efb         	ldr	r3, [r7, #0x6c]
 8012d94: 65fb         	str	r3, [r7, #0x5c]
; }
 8012d96: bf00         	nop
 8012d98: 6efb         	ldr	r3, [r7, #0x6c]
 8012d9a: 65bb         	str	r3, [r7, #0x58]
; }
 8012d9c: bf00         	nop
; 	return k;
 8012d9e: 6afb         	ldr	r3, [r7, #0x2c]
 8012da0: 63fb         	str	r3, [r7, #0x3c]
; 		announce_remaining -= dt;
 8012da2: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8012e78 <sys_clock_announce+0x1dc>
 8012da4: 681a         	ldr	r2, [r3]
 8012da6: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8012daa: 1ad2         	subs	r2, r2, r3
 8012dac: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x8012e78 <sys_clock_announce+0x1dc>
 8012dae: 601a         	str	r2, [r3]
; 	     t = first()) {
 8012db0: f7ff fe02    	bl	0x80129b8 <first>       @ imm = #-0x3fc
 8012db4: f8c7 008c    	str.w	r0, [r7, #0x8c]
; 	     (t != NULL) && (t->dticks <= announce_remaining);
 8012db8: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8012dbc: 2b00         	cmp	r3, #0x0
 8012dbe: d00d         	beq	0x8012ddc <sys_clock_announce+0x140> @ imm = #0x1a
 8012dc0: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8012dc4: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 8012dc8: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8012e78 <sys_clock_announce+0x1dc>
 8012dca: 681b         	ldr	r3, [r3]
 8012dcc: 17da         	asrs	r2, r3, #0x1f
 8012dce: 61bb         	str	r3, [r7, #0x18]
 8012dd0: 61fa         	str	r2, [r7, #0x1c]
 8012dd2: 69bb         	ldr	r3, [r7, #0x18]
 8012dd4: 4283         	cmp	r3, r0
 8012dd6: 69fb         	ldr	r3, [r7, #0x1c]
 8012dd8: 418b         	sbcs	r3, r1
 8012dda: da8b         	bge	0x8012cf4 <sys_clock_announce+0x58> @ imm = #-0xea
; 	if (t != NULL) {
 8012ddc: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8012de0: 2b00         	cmp	r3, #0x0
 8012de2: d014         	beq	0x8012e0e <sys_clock_announce+0x172> @ imm = #0x28
; 		t->dticks -= announce_remaining;
 8012de4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8012de8: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8012dec: 4922         	ldr	r1, [pc, #0x88]         @ 0x8012e78 <sys_clock_announce+0x1dc>
 8012dee: 6809         	ldr	r1, [r1]
 8012df0: 17c8         	asrs	r0, r1, #0x1f
 8012df2: 4688         	mov	r8, r1
 8012df4: 4681         	mov	r9, r0
 8012df6: ebb2 0108    	subs.w	r1, r2, r8
 8012dfa: 60b9         	str	r1, [r7, #0x8]
 8012dfc: eb63 0309    	sbc.w	r3, r3, r9
 8012e00: 60fb         	str	r3, [r7, #0xc]
 8012e02: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8012e06: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 8012e0a: e9c3 1204    	strd	r1, r2, [r3, #16]
; 	curr_tick += announce_remaining;
 8012e0e: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8012e78 <sys_clock_announce+0x1dc>
 8012e10: 681b         	ldr	r3, [r3]
 8012e12: 17da         	asrs	r2, r3, #0x1f
 8012e14: 461c         	mov	r4, r3
 8012e16: 4615         	mov	r5, r2
 8012e18: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8012e7c <sys_clock_announce+0x1e0>
 8012e1a: e9d3 2300    	ldrd	r2, r3, [r3]
 8012e1e: 18a1         	adds	r1, r4, r2
 8012e20: 6039         	str	r1, [r7]
 8012e22: eb45 0303    	adc.w	r3, r5, r3
 8012e26: 607b         	str	r3, [r7, #0x4]
 8012e28: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8012e7c <sys_clock_announce+0x1e0>
 8012e2a: e9d7 1200    	ldrd	r1, r2, [r7]
 8012e2e: e9c3 1200    	strd	r1, r2, [r3]
; 	announce_remaining = 0;
 8012e32: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8012e78 <sys_clock_announce+0x1dc>
 8012e34: 2200         	movs	r2, #0x0
 8012e36: 601a         	str	r2, [r3]
; 	sys_clock_set_timeout(next_timeout(), false);
 8012e38: f00c fe8d    	bl	0x801fb56 <next_timeout> @ imm = #0xcd1a
 8012e3c: 4603         	mov	r3, r0
 8012e3e: 2100         	movs	r1, #0x0
 8012e40: 4618         	mov	r0, r3
 8012e42: f7fb f9a1    	bl	0x800e188 <sys_clock_set_timeout> @ imm = #-0x4cbe
 8012e46: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8012e74 <sys_clock_announce+0x1d8>
 8012e48: 64bb         	str	r3, [r7, #0x48]
 8012e4a: 6bfb         	ldr	r3, [r7, #0x3c]
 8012e4c: 63bb         	str	r3, [r7, #0x38]
; 	arch_irq_unlock(key.key);
 8012e4e: 6bbb         	ldr	r3, [r7, #0x38]
 8012e50: 647b         	str	r3, [r7, #0x44]
 8012e52: 6c7b         	ldr	r3, [r7, #0x44]
 8012e54: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012e56: 6c3b         	ldr	r3, [r7, #0x40]
 8012e58: f383 8811    	msr	basepri, r3
; }
 8012e5c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012e5e: f3bf 8f6f    	isb	sy
; }
 8012e62: bf00         	nop
; }
 8012e64: bf00         	nop
; }
 8012e66: bf00         	nop
; 	z_time_slice();
 8012e68: f7ff fcb0    	bl	0x80127cc <z_time_slice> @ imm = #-0x6a0
; }
 8012e6c: 3790         	adds	r7, #0x90
 8012e6e: 46bd         	mov	sp, r7
 8012e70: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08012e74 <$d>:
 8012e74: f0 27 00 20  	.word	0x200027f0
 8012e78: f0 27 00 20  	.word	0x200027f0
 8012e7c: f0 20 00 20  	.word	0x200020f0

08012e80 <sys_clock_tick_get>:
; {
 8012e80: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8012e84: b090         	sub	sp, #0x40
 8012e86: af00         	add	r7, sp, #0x0
; 	uint64_t t = 0U;
 8012e88: f04f 0200    	mov.w	r2, #0x0
 8012e8c: f04f 0300    	mov.w	r3, #0x0
 8012e90: e9c7 230e    	strd	r2, r3, [r7, #56]
; 	K_SPINLOCK(&timeout_lock) {
 8012e94: 2300         	movs	r3, #0x0
 8012e96: 613b         	str	r3, [r7, #0x10]
 8012e98: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8012f28 <sys_clock_tick_get+0xa8>
 8012e9a: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8012e9c: f3ef 8311    	mrs	r3, basepri
 8012ea0: 633b         	str	r3, [r7, #0x30]
;   return(result);
 8012ea2: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 8012ea4: 62fb         	str	r3, [r7, #0x2c]
 8012ea6: 2310         	movs	r3, #0x10
 8012ea8: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8012eaa: 6abb         	ldr	r3, [r7, #0x28]
 8012eac: f383 8812    	msr	basepri_max, r3
; }
 8012eb0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012eb2: f3bf 8f6f    	isb	sy
; }
 8012eb6: bf00         	nop
; 	return key;
 8012eb8: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 8012eba: 607b         	str	r3, [r7, #0x4]
 8012ebc: 6b7b         	ldr	r3, [r7, #0x34]
 8012ebe: 627b         	str	r3, [r7, #0x24]
; }
 8012ec0: bf00         	nop
 8012ec2: 6b7b         	ldr	r3, [r7, #0x34]
 8012ec4: 623b         	str	r3, [r7, #0x20]
; }
 8012ec6: bf00         	nop
; 	return k;
 8012ec8: 687b         	ldr	r3, [r7, #0x4]
 8012eca: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&timeout_lock) {
 8012ecc: e021         	b	0x8012f12 <sys_clock_tick_get+0x92> @ imm = #0x42
; 		t = curr_tick + elapsed();
 8012ece: f7ff fd93    	bl	0x80129f8 <elapsed>     @ imm = #-0x4da
 8012ed2: 4603         	mov	r3, r0
 8012ed4: 17da         	asrs	r2, r3, #0x1f
 8012ed6: 461c         	mov	r4, r3
 8012ed8: 4615         	mov	r5, r2
 8012eda: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8012f2c <sys_clock_tick_get+0xac>
 8012edc: e9d3 2300    	ldrd	r2, r3, [r3]
 8012ee0: eb14 0802    	adds.w	r8, r4, r2
 8012ee4: eb45 0903    	adc.w	r9, r5, r3
 8012ee8: e9c7 890e    	strd	r8, r9, [r7, #56]
 8012eec: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8012f28 <sys_clock_tick_get+0xa8>
 8012eee: 61fb         	str	r3, [r7, #0x1c]
 8012ef0: 68fb         	ldr	r3, [r7, #0xc]
 8012ef2: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8012ef4: 68bb         	ldr	r3, [r7, #0x8]
 8012ef6: 61bb         	str	r3, [r7, #0x18]
 8012ef8: 69bb         	ldr	r3, [r7, #0x18]
 8012efa: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012efc: 697b         	ldr	r3, [r7, #0x14]
 8012efe: f383 8811    	msr	basepri, r3
; }
 8012f02: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012f04: f3bf 8f6f    	isb	sy
; }
 8012f08: bf00         	nop
; }
 8012f0a: bf00         	nop
; }
 8012f0c: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 8012f0e: 2301         	movs	r3, #0x1
 8012f10: 613b         	str	r3, [r7, #0x10]
 8012f12: 693b         	ldr	r3, [r7, #0x10]
 8012f14: 2b00         	cmp	r3, #0x0
 8012f16: d0da         	beq	0x8012ece <sys_clock_tick_get+0x4e> @ imm = #-0x4c
; 	return t;
 8012f18: e9d7 230e    	ldrd	r2, r3, [r7, #56]
; }
 8012f1c: 4610         	mov	r0, r2
 8012f1e: 4619         	mov	r1, r3
 8012f20: 3740         	adds	r7, #0x40
 8012f22: 46bd         	mov	sp, r7
 8012f24: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

08012f28 <$d>:
 8012f28: f0 27 00 20  	.word	0x200027f0
 8012f2c: f0 20 00 20  	.word	0x200020f0

08012f30 <z_sched_usage_start>:
; {
 8012f30: b580         	push	{r7, lr}
 8012f32: b082         	sub	sp, #0x8
 8012f34: af00         	add	r7, sp, #0x0
 8012f36: 6078         	str	r0, [r7, #0x4]
; 	_current_cpu->usage0 = usage_now();
 8012f38: f00c fe6b    	bl	0x801fc12 <usage_now>   @ imm = #0xccd6
 8012f3c: 4603         	mov	r3, r0
 8012f3e: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8012f4c <z_sched_usage_start+0x1c>
 8012f40: 6193         	str	r3, [r2, #0x18]
; }
 8012f42: bf00         	nop
 8012f44: 3708         	adds	r7, #0x8
 8012f46: 46bd         	mov	sp, r7
 8012f48: bd80         	pop	{r7, pc}
 8012f4a: bf00         	nop

08012f4c <$d>:
 8012f4c: 48 1d 00 20  	.word	0x20001d48

08012f50 <z_sched_usage_stop>:
; {
 8012f50: b580         	push	{r7, lr}
 8012f52: b090         	sub	sp, #0x40
 8012f54: af00         	add	r7, sp, #0x0
 8012f56: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8012ff8 <z_sched_usage_stop+0xa8>
 8012f58: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8012f5a: f3ef 8311    	mrs	r3, basepri
 8012f5e: 62fb         	str	r3, [r7, #0x2c]
;   return(result);
 8012f60: 6afb         	ldr	r3, [r7, #0x2c]
; 	key = __get_BASEPRI();
 8012f62: 62bb         	str	r3, [r7, #0x28]
 8012f64: 2310         	movs	r3, #0x10
 8012f66: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8012f68: 6a7b         	ldr	r3, [r7, #0x24]
 8012f6a: f383 8812    	msr	basepri_max, r3
; }
 8012f6e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012f70: f3bf 8f6f    	isb	sy
; }
 8012f74: bf00         	nop
; 	return key;
 8012f76: 6abb         	ldr	r3, [r7, #0x28]
; 	k.key = arch_irq_lock();
 8012f78: 607b         	str	r3, [r7, #0x4]
 8012f7a: 6b3b         	ldr	r3, [r7, #0x30]
 8012f7c: 623b         	str	r3, [r7, #0x20]
; }
 8012f7e: bf00         	nop
 8012f80: 6b3b         	ldr	r3, [r7, #0x30]
 8012f82: 61fb         	str	r3, [r7, #0x1c]
; }
 8012f84: bf00         	nop
; 	return k;
 8012f86: 687b         	ldr	r3, [r7, #0x4]
 8012f88: 60fb         	str	r3, [r7, #0xc]
; 	struct _cpu     *cpu = _current_cpu;
 8012f8a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8012ffc <z_sched_usage_stop+0xac>
 8012f8c: 63fb         	str	r3, [r7, #0x3c]
; 	uint32_t u0 = cpu->usage0;
 8012f8e: 6bfb         	ldr	r3, [r7, #0x3c]
 8012f90: 699b         	ldr	r3, [r3, #0x18]
 8012f92: 63bb         	str	r3, [r7, #0x38]
; 	if (u0 != 0) {
 8012f94: 6bbb         	ldr	r3, [r7, #0x38]
 8012f96: 2b00         	cmp	r3, #0x0
 8012f98: d015         	beq	0x8012fc6 <z_sched_usage_stop+0x76> @ imm = #0x2a
; 		uint32_t cycles = usage_now() - u0;
 8012f9a: f00c fe3a    	bl	0x801fc12 <usage_now>   @ imm = #0xcc74
 8012f9e: 4602         	mov	r2, r0
 8012fa0: 6bbb         	ldr	r3, [r7, #0x38]
 8012fa2: 1ad3         	subs	r3, r2, r3
 8012fa4: 637b         	str	r3, [r7, #0x34]
; 		if (cpu->current->base.usage.track_usage) {
 8012fa6: 6bfb         	ldr	r3, [r7, #0x3c]
 8012fa8: 689b         	ldr	r3, [r3, #0x8]
 8012faa: f893 3038    	ldrb.w	r3, [r3, #0x38]
 8012fae: 2b00         	cmp	r3, #0x0
 8012fb0: d005         	beq	0x8012fbe <z_sched_usage_stop+0x6e> @ imm = #0xa
; 			sched_thread_update_usage(cpu->current, cycles);
 8012fb2: 6bfb         	ldr	r3, [r7, #0x3c]
 8012fb4: 689b         	ldr	r3, [r3, #0x8]
 8012fb6: 6b79         	ldr	r1, [r7, #0x34]
 8012fb8: 4618         	mov	r0, r3
 8012fba: f00c fe65    	bl	0x801fc88 <sched_thread_update_usage> @ imm = #0xccca
; 		sched_cpu_update_usage(cpu, cycles);
 8012fbe: 6b79         	ldr	r1, [r7, #0x34]
 8012fc0: 6bf8         	ldr	r0, [r7, #0x3c]
 8012fc2: f00c fe36    	bl	0x801fc32 <sched_cpu_update_usage> @ imm = #0xcc6c
; 	cpu->usage0 = 0;
 8012fc6: 6bfb         	ldr	r3, [r7, #0x3c]
 8012fc8: 2200         	movs	r2, #0x0
 8012fca: 619a         	str	r2, [r3, #0x18]
 8012fcc: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8012ff8 <z_sched_usage_stop+0xa8>
 8012fce: 61bb         	str	r3, [r7, #0x18]
 8012fd0: 68fb         	ldr	r3, [r7, #0xc]
 8012fd2: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 8012fd4: 68bb         	ldr	r3, [r7, #0x8]
 8012fd6: 617b         	str	r3, [r7, #0x14]
 8012fd8: 697b         	ldr	r3, [r7, #0x14]
 8012fda: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8012fdc: 693b         	ldr	r3, [r7, #0x10]
 8012fde: f383 8811    	msr	basepri, r3
; }
 8012fe2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012fe4: f3bf 8f6f    	isb	sy
; }
 8012fe8: bf00         	nop
; }
 8012fea: bf00         	nop
; }
 8012fec: bf00         	nop
; }
 8012fee: bf00         	nop
 8012ff0: 3740         	adds	r7, #0x40
 8012ff2: 46bd         	mov	sp, r7
 8012ff4: bd80         	pop	{r7, pc}
 8012ff6: bf00         	nop

08012ff8 <$d>:
 8012ff8: f4 27 00 20  	.word	0x200027f4
 8012ffc: 48 1d 00 20  	.word	0x20001d48

08013000 <boot_banner>:
; {
 8013000: b580         	push	{r7, lr}
 8013002: af00         	add	r7, sp, #0x0
; 	printk("*** " CONFIG_BOOT_BANNER_STRING " " BANNER_VERSION BANNER_POSTFIX " ***\n");
 8013004: 4802         	ldr	r0, [pc, #0x8]          @ 0x8013010 <boot_banner+0x10>
 8013006: f003 fc63    	bl	0x80168d0 <printk>      @ imm = #0x38c6
; }
 801300a: bf00         	nop
 801300c: bd80         	pop	{r7, pc}
 801300e: bf00         	nop

08013010 <$d>:
 8013010: 6c 22 02 08  	.word	0x0802226c

08013014 <k_sys_work_q_init>:
; {
 8013014: b580         	push	{r7, lr}
 8013016: b084         	sub	sp, #0x10
 8013018: af02         	add	r7, sp, #0x8
; 	struct k_work_queue_config cfg = {
 801301a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8013044 <k_sys_work_q_init+0x30>
 801301c: 463b         	mov	r3, r7
 801301e: e892 0003    	ldm.w	r2, {r0, r1}
 8013022: e883 0003    	stm.w	r3, {r0, r1}
; 	k_work_queue_start(&k_sys_work_q,
 8013026: 463b         	mov	r3, r7
 8013028: 9300         	str	r3, [sp]
 801302a: f04f 33ff    	mov.w	r3, #0xffffffff
 801302e: f44f 6280    	mov.w	r2, #0x400
 8013032: 4905         	ldr	r1, [pc, #0x14]         @ 0x8013048 <k_sys_work_q_init+0x34>
 8013034: 4805         	ldr	r0, [pc, #0x14]         @ 0x801304c <k_sys_work_q_init+0x38>
 8013036: f7fd fb8f    	bl	0x8010758 <k_work_queue_start> @ imm = #-0x28e2
; 	return 0;
 801303a: 2300         	movs	r3, #0x0
; }
 801303c: 4618         	mov	r0, r3
 801303e: 3708         	adds	r7, #0x8
 8013040: 46bd         	mov	sp, r7
 8013042: bd80         	pop	{r7, pc}

08013044 <$d>:
 8013044: b4 22 02 08  	.word	0x080222b4
 8013048: 40 4a 00 20  	.word	0x20004a40
 801304c: f8 20 00 20  	.word	0x200020f8

08013050 <skip_to_arg>:
 8013050: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 8013054: 2601         	movs	r6, #0x1
 8013056: 4607         	mov	r7, r0
 8013058: 42b2         	cmp	r2, r6
 801305a: dc01         	bgt	0x8013060 <skip_to_arg+0x10> @ imm = #0x2
 801305c: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 8013060: 463b         	mov	r3, r7
 8013062: 461f         	mov	r7, r3
 8013064: f813 4b01    	ldrb	r4, [r3], #1
 8013068: 2c00         	cmp	r4, #0x0
 801306a: d0f7         	beq	0x801305c <skip_to_arg+0xc> @ imm = #-0x12
 801306c: 2c25         	cmp	r4, #0x25
 801306e: d1f8         	bne	0x8013062 <skip_to_arg+0x12> @ imm = #-0x10
 8013070: 781c         	ldrb	r4, [r3]
 8013072: 2c25         	cmp	r4, #0x25
 8013074: f107 0702    	add.w	r7, r7, #0x2
 8013078: d0f2         	beq	0x8013060 <skip_to_arg+0x10> @ imm = #-0x1c
 801307a: 2300         	movs	r3, #0x0
 801307c: f8df 8104    	ldr.w	r8, [pc, #0x104]        @ 0x8013184 <skip_to_arg+0x134>
 8013080: 469c         	mov	r12, r3
 8013082: 461d         	mov	r5, r3
 8013084: 2d1f         	cmp	r5, #0x1f
 8013086: d818         	bhi	0x80130ba <skip_to_arg+0x6a> @ imm = #0x30
 8013088: f1a4 0e20    	sub.w	lr, r4, #0x20
 801308c: f1be 0f10    	cmp.w	lr, #0x10
 8013090: d909         	bls	0x80130a6 <skip_to_arg+0x56> @ imm = #0x12
 8013092: f1a4 0e30    	sub.w	lr, r4, #0x30
 8013096: f1be 0f09    	cmp.w	lr, #0x9
 801309a: d81e         	bhi	0x80130da <skip_to_arg+0x8a> @ imm = #0x3c
 801309c: 240a         	movs	r4, #0xa
 801309e: fb04 e303    	mla	r3, r4, r3, lr
 80130a2: 2520         	movs	r5, #0x20
 80130a4: e004         	b	0x80130b0 <skip_to_arg+0x60> @ imm = #0x8
 80130a6: fa28 fe0e    	lsr.w	lr, r8, lr
 80130aa: f01e 0f01    	tst.w	lr, #0x1
 80130ae: d006         	beq	0x80130be <skip_to_arg+0x6e> @ imm = #0xc
 80130b0: f817 4b01    	ldrb	r4, [r7], #1
 80130b4: 2c00         	cmp	r4, #0x0
 80130b6: d1e5         	bne	0x8013084 <skip_to_arg+0x34> @ imm = #-0x36
 80130b8: e028         	b	0x801310c <skip_to_arg+0xbc> @ imm = #0x50
 80130ba: 2d7f         	cmp	r5, #0x7f
 80130bc: d81c         	bhi	0x80130f8 <skip_to_arg+0xa8> @ imm = #0x38
 80130be: f1a4 0e30    	sub.w	lr, r4, #0x30
 80130c2: f1be 0f09    	cmp.w	lr, #0x9
 80130c6: d9e9         	bls	0x801309c <skip_to_arg+0x4c> @ imm = #-0x2e
 80130c8: 2c24         	cmp	r4, #0x24
 80130ca: d110         	bne	0x80130ee <skip_to_arg+0x9e> @ imm = #0x20
 80130cc: f1bc 0f00    	cmp.w	r12, #0x0
 80130d0: d046         	beq	0x8013160 <skip_to_arg+0x110> @ imm = #0x8c
 80130d2: 42b3         	cmp	r3, r6
 80130d4: d046         	beq	0x8013164 <skip_to_arg+0x114> @ imm = #0x8c
 80130d6: 2300         	movs	r3, #0x0
 80130d8: e7ea         	b	0x80130b0 <skip_to_arg+0x60> @ imm = #-0x2c
 80130da: f024 0e04    	bic	lr, r4, #0x4
 80130de: f1be 0f2a    	cmp.w	lr, #0x2a
 80130e2: d0f8         	beq	0x80130d6 <skip_to_arg+0x86> @ imm = #-0x10
 80130e4: 2c6c         	cmp	r4, #0x6c
 80130e6: d109         	bne	0x80130fc <skip_to_arg+0xac> @ imm = #0x12
 80130e8: f045 0580    	orr	r5, r5, #0x80
 80130ec: e7e0         	b	0x80130b0 <skip_to_arg+0x60> @ imm = #-0x40
 80130ee: f024 0e04    	bic	lr, r4, #0x4
 80130f2: f1be 0f2a    	cmp.w	lr, #0x2a
 80130f6: d0ee         	beq	0x80130d6 <skip_to_arg+0x86> @ imm = #-0x24
 80130f8: 2c6c         	cmp	r4, #0x6c
 80130fa: d022         	beq	0x8013142 <skip_to_arg+0xf2> @ imm = #0x44
 80130fc: 2c6c         	cmp	r4, #0x6c
 80130fe: d81b         	bhi	0x8013138 <skip_to_arg+0xe8> @ imm = #0x36
 8013100: 2c68         	cmp	r4, #0x68
 8013102: d023         	beq	0x801314c <skip_to_arg+0xfc> @ imm = #0x46
 8013104: 2c6a         	cmp	r4, #0x6a
 8013106: d028         	beq	0x801315a <skip_to_arg+0x10a> @ imm = #0x50
 8013108: 2c4c         	cmp	r4, #0x4c
 801310a: d026         	beq	0x801315a <skip_to_arg+0x10a> @ imm = #0x4c
 801310c: f1bc 0f00    	cmp.w	r12, #0x0
 8013110: d0a4         	beq	0x801305c <skip_to_arg+0xc> @ imm = #-0xb8
 8013112: 45b4         	cmp	r12, r6
 8013114: d1a0         	bne	0x8013058 <skip_to_arg+0x8> @ imm = #-0xc0
 8013116: f044 0720    	orr	r7, r4, #0x20
 801311a: f1a7 0c65    	sub.w	r12, r7, #0x65
 801311e: f1bc 0f02    	cmp.w	r12, #0x2
 8013122: 680b         	ldr	r3, [r1]
 8013124: d901         	bls	0x801312a <skip_to_arg+0xda> @ imm = #0x2
 8013126: 2f61         	cmp	r7, #0x61
 8013128: d11e         	bne	0x8013168 <skip_to_arg+0x118> @ imm = #0x3c
 801312a: 3307         	adds	r3, #0x7
 801312c: f023 0307    	bic	r3, r3, #0x7
 8013130: 3308         	adds	r3, #0x8
 8013132: 600b         	str	r3, [r1]
 8013134: 3601         	adds	r6, #0x1
 8013136: e78e         	b	0x8013056 <skip_to_arg+0x6> @ imm = #-0xe4
 8013138: 2c74         	cmp	r4, #0x74
 801313a: d0b9         	beq	0x80130b0 <skip_to_arg+0x60> @ imm = #-0x8e
 801313c: 2c7a         	cmp	r4, #0x7a
 801313e: d0b7         	beq	0x80130b0 <skip_to_arg+0x60> @ imm = #-0x92
 8013140: e7e4         	b	0x801310c <skip_to_arg+0xbc> @ imm = #-0x38
 8013142: 062c         	lsls	r4, r5, #0x18
 8013144: bf48         	it	mi
 8013146: f445 7500    	orrmi	r5, r5, #0x200
 801314a: e7cd         	b	0x80130e8 <skip_to_arg+0x98> @ imm = #-0x66
 801314c: 05ec         	lsls	r4, r5, #0x17
 801314e: bf48         	it	mi
 8013150: f445 7500    	orrmi	r5, r5, #0x200
 8013154: f445 7580    	orr	r5, r5, #0x100
 8013158: e7aa         	b	0x80130b0 <skip_to_arg+0x60> @ imm = #-0xac
 801315a: f445 7520    	orr	r5, r5, #0x280
 801315e: e7a7         	b	0x80130b0 <skip_to_arg+0x60> @ imm = #-0xb2
 8013160: 469c         	mov	r12, r3
 8013162: e7b8         	b	0x80130d6 <skip_to_arg+0x86> @ imm = #-0x90
 8013164: 2463         	movs	r4, #0x63
 8013166: e7d6         	b	0x8013116 <skip_to_arg+0xc6> @ imm = #-0x54
 8013168: 2c69         	cmp	r4, #0x69
 801316a: d002         	beq	0x8013172 <skip_to_arg+0x122> @ imm = #0x4
 801316c: d807         	bhi	0x801317e <skip_to_arg+0x12e> @ imm = #0xe
 801316e: 2c63         	cmp	r4, #0x63
 8013170: d003         	beq	0x801317a <skip_to_arg+0x12a> @ imm = #0x6
 8013172: 062f         	lsls	r7, r5, #0x18
 8013174: d501         	bpl	0x801317a <skip_to_arg+0x12a> @ imm = #0x2
 8013176: 05ac         	lsls	r4, r5, #0x16
 8013178: d4d7         	bmi	0x801312a <skip_to_arg+0xda> @ imm = #-0x52
 801317a: 3304         	adds	r3, #0x4
 801317c: e7d9         	b	0x8013132 <skip_to_arg+0xe2> @ imm = #-0x4e
 801317e: 2c73         	cmp	r4, #0x73
 8013180: e7f6         	b	0x8013170 <skip_to_arg+0x120> @ imm = #-0x14
 8013182: bf00         	nop

08013184 <$d>:
 8013184: 89 28 01 00  	.word	0x00012889

08013188 <vfprintf>:
 8013188: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 801318c: b093         	sub	sp, #0x4c
 801318e: 6843         	ldr	r3, [r0, #0x4]
 8013190: 9301         	str	r3, [sp, #0x4]
 8013192: 7883         	ldrb	r3, [r0, #0x2]
 8013194: 4680         	mov	r8, r0
 8013196: 0798         	lsls	r0, r3, #0x1e
 8013198: e9cd 1206    	strd	r1, r2, [sp, #24]
 801319c: d517         	bpl	0x80131ce <vfprintf+0x46> @ imm = #0x2e
 801319e: 920b         	str	r2, [sp, #0x2c]
 80131a0: 460b         	mov	r3, r1
 80131a2: 2500         	movs	r5, #0x0
 80131a4: 781f         	ldrb	r7, [r3]
 80131a6: b1a7         	cbz	r7, 0x80131d2 <vfprintf+0x4a> @ imm = #0x28
 80131a8: 2f25         	cmp	r7, #0x25
 80131aa: d016         	beq	0x80131da <vfprintf+0x52> @ imm = #0x2c
 80131ac: 3301         	adds	r3, #0x1
 80131ae: 9305         	str	r3, [sp, #0x14]
 80131b0: 9b01         	ldr	r3, [sp, #0x4]
 80131b2: 4641         	mov	r1, r8
 80131b4: 4638         	mov	r0, r7
 80131b6: 4798         	blx	r3
 80131b8: 2800         	cmp	r0, #0x0
 80131ba: f105 0501    	add.w	r5, r5, #0x1
 80131be: f280 8435    	bge.w	0x8013a2c <vfprintf+0x8a4> @ imm = #0x86a
 80131c2: f898 3002    	ldrb.w	r3, [r8, #0x2]
 80131c6: f043 0304    	orr	r3, r3, #0x4
 80131ca: f888 3002    	strb.w	r3, [r8, #0x2]
 80131ce: f04f 35ff    	mov.w	r5, #0xffffffff
 80131d2: 4628         	mov	r0, r5
 80131d4: b013         	add	sp, #0x4c
 80131d6: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80131da: 785f         	ldrb	r7, [r3, #0x1]
 80131dc: 1c9a         	adds	r2, r3, #0x2
 80131de: 2f25         	cmp	r7, #0x25
 80131e0: 9205         	str	r2, [sp, #0x14]
 80131e2: d0e5         	beq	0x80131b0 <vfprintf+0x28> @ imm = #-0x36
 80131e4: 2400         	movs	r4, #0x0
 80131e6: 4626         	mov	r6, r4
 80131e8: 46a2         	mov	r10, r4
 80131ea: 46a3         	mov	r11, r4
 80131ec: f1bb 0f1f    	cmp.w	r11, #0x1f
 80131f0: d832         	bhi	0x8013258 <vfprintf+0xd0> @ imm = #0x64
 80131f2: f1a7 0320    	sub.w	r3, r7, #0x20
 80131f6: 2b10         	cmp	r3, #0x10
 80131f8: d80a         	bhi	0x8013210 <vfprintf+0x88> @ imm = #0x14
 80131fa: e8df f003    	tbb	[pc, r3]

080131fe <$d>:
 80131fe: 24 09 09 2a  	.word	0x2a090924
 8013202: 09 09 09 1b  	.word	0x1b090909
 8013206: 09 09 09 22  	.word	0x22090909
 801320a: 09 27 09 09  	.word	0x09092709
 801320e: 19           	.byte	0x19

0801320f <$d>:
 801320f: 00           	.byte	0x00

08013210 <$t>:
 8013210: f1a7 0330    	sub.w	r3, r7, #0x30
 8013214: 2b09         	cmp	r3, #0x9
 8013216: d92d         	bls	0x8013274 <vfprintf+0xec> @ imm = #0x5a
 8013218: 2f2a         	cmp	r7, #0x2a
 801321a: d139         	bne	0x8013290 <vfprintf+0x108> @ imm = #0x72
 801321c: b954         	cbnz	r4, 0x8013234 <vfprintf+0xac> @ imm = #0x14
 801321e: 9b0b         	ldr	r3, [sp, #0x2c]
 8013220: f01b 0f40    	tst.w	r11, #0x40
 8013224: f853 2b04    	ldr	r2, [r3], #4
 8013228: 930b         	str	r3, [sp, #0x2c]
 801322a: d029         	beq	0x8013280 <vfprintf+0xf8> @ imm = #0x52
 801322c: 4616         	mov	r6, r2
 801322e: e001         	b	0x8013234 <vfprintf+0xac> @ imm = #0x2
 8013230: f04b 0b01    	orr	r11, r11, #0x1
 8013234: 9b05         	ldr	r3, [sp, #0x14]
 8013236: f813 7b01    	ldrb	r7, [r3], #1
 801323a: 9305         	str	r3, [sp, #0x14]
 801323c: 2f00         	cmp	r7, #0x0
 801323e: d1d5         	bne	0x80131ec <vfprintf+0x64> @ imm = #-0x56
 8013240: e05b         	b	0x80132fa <vfprintf+0x172> @ imm = #0xb6
 8013242: f04b 0b02    	orr	r11, r11, #0x2
 8013246: f04b 0b04    	orr	r11, r11, #0x4
 801324a: e7f3         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x1a
 801324c: f04b 0b08    	orr	r11, r11, #0x8
 8013250: e7f0         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x20
 8013252: f04b 0b10    	orr	r11, r11, #0x10
 8013256: e7ed         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x26
 8013258: f1bb 0f7f    	cmp.w	r11, #0x7f
 801325c: d83f         	bhi	0x80132de <vfprintf+0x156> @ imm = #0x7e
 801325e: f1a7 0330    	sub.w	r3, r7, #0x30
 8013262: 2b09         	cmp	r3, #0x9
 8013264: d8d8         	bhi	0x8013218 <vfprintf+0x90> @ imm = #-0x50
 8013266: f01b 0f40    	tst.w	r11, #0x40
 801326a: d003         	beq	0x8013274 <vfprintf+0xec> @ imm = #0x6
 801326c: 220a         	movs	r2, #0xa
 801326e: fb02 3606    	mla	r6, r2, r6, r3
 8013272: e7df         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x42
 8013274: 220a         	movs	r2, #0xa
 8013276: fb02 3a0a    	mla	r10, r2, r10, r3
 801327a: f04b 0b20    	orr	r11, r11, #0x20
 801327e: e7d9         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x4e
 8013280: f1b2 0a00    	subs.w	r10, r2, #0x0
 8013284: daf9         	bge	0x801327a <vfprintf+0xf2> @ imm = #-0xe
 8013286: f1ca 0a00    	rsb.w	r10, r10, #0x0
 801328a: f04b 0b28    	orr	r11, r11, #0x28
 801328e: e7d1         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x5e
 8013290: 2f2e         	cmp	r7, #0x2e
 8013292: d105         	bne	0x80132a0 <vfprintf+0x118> @ imm = #0xa
 8013294: f01b 0f40    	tst.w	r11, #0x40
 8013298: d19b         	bne	0x80131d2 <vfprintf+0x4a> @ imm = #-0xca
 801329a: f04b 0b40    	orr	r11, r11, #0x40
 801329e: e7c9         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x6e
 80132a0: 2f24         	cmp	r7, #0x24
 80132a2: d11c         	bne	0x80132de <vfprintf+0x156> @ imm = #0x38
 80132a4: 2c00         	cmp	r4, #0x0
 80132a6: f000 8141    	beq.w	0x801352c <vfprintf+0x3a4> @ imm = #0x282
 80132aa: 9b07         	ldr	r3, [sp, #0x1c]
 80132ac: 930b         	str	r3, [sp, #0x2c]
 80132ae: f01b 0f40    	tst.w	r11, #0x40
 80132b2: d10a         	bne	0x80132ca <vfprintf+0x142> @ imm = #0x14
 80132b4: 4652         	mov	r2, r10
 80132b6: 9806         	ldr	r0, [sp, #0x18]
 80132b8: a90b         	add	r1, sp, #0x2c
 80132ba: f7ff fec9    	bl	0x8013050 <skip_to_arg> @ imm = #-0x26e
 80132be: 9b0b         	ldr	r3, [sp, #0x2c]
 80132c0: 1d1a         	adds	r2, r3, #0x4
 80132c2: f8d3 a000    	ldr.w	r10, [r3]
 80132c6: 920b         	str	r2, [sp, #0x2c]
 80132c8: e7b4         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x98
 80132ca: 4632         	mov	r2, r6
 80132cc: 9806         	ldr	r0, [sp, #0x18]
 80132ce: a90b         	add	r1, sp, #0x2c
 80132d0: f7ff febe    	bl	0x8013050 <skip_to_arg> @ imm = #-0x284
 80132d4: 9b0b         	ldr	r3, [sp, #0x2c]
 80132d6: 1d1a         	adds	r2, r3, #0x4
 80132d8: 681e         	ldr	r6, [r3]
 80132da: 920b         	str	r2, [sp, #0x2c]
 80132dc: e7aa         	b	0x8013234 <vfprintf+0xac> @ imm = #-0xac
 80132de: 2f6c         	cmp	r7, #0x6c
 80132e0: f000 8111    	beq.w	0x8013506 <vfprintf+0x37e> @ imm = #0x222
 80132e4: f200 8108    	bhi.w	0x80134f8 <vfprintf+0x370> @ imm = #0x210
 80132e8: 2f68         	cmp	r7, #0x68
 80132ea: f000 8114    	beq.w	0x8013516 <vfprintf+0x38e> @ imm = #0x228
 80132ee: 2f6a         	cmp	r7, #0x6a
 80132f0: f000 8119    	beq.w	0x8013526 <vfprintf+0x39e> @ imm = #0x232
 80132f4: 2f4c         	cmp	r7, #0x4c
 80132f6: f000 8116    	beq.w	0x8013526 <vfprintf+0x39e> @ imm = #0x22c
 80132fa: b134         	cbz	r4, 0x801330a <vfprintf+0x182> @ imm = #0xc
 80132fc: 9b07         	ldr	r3, [sp, #0x1c]
 80132fe: 9806         	ldr	r0, [sp, #0x18]
 8013300: 930b         	str	r3, [sp, #0x2c]
 8013302: 4622         	mov	r2, r4
 8013304: a90b         	add	r1, sp, #0x2c
 8013306: f7ff fea3    	bl	0x8013050 <skip_to_arg> @ imm = #-0x2ba
 801330a: 2e00         	cmp	r6, #0x0
 801330c: f047 0920    	orr	r9, r7, #0x20
 8013310: bfb8         	it	lt
 8013312: f02b 0b40    	biclt	r11, r11, #0x40
 8013316: f1a9 0365    	sub.w	r3, r9, #0x65
 801331a: bfbc         	itt	lt
 801331c: fa1f fb8b    	uxthlt.w	r11, r11
 8013320: 2600         	movlt	r6, #0x0
 8013322: 2b02         	cmp	r3, #0x2
 8013324: f240 8107    	bls.w	0x8013536 <vfprintf+0x3ae> @ imm = #0x20e
 8013328: f1b9 0f61    	cmp.w	r9, #0x61
 801332c: f040 8264    	bne.w	0x80137f8 <vfprintf+0x670> @ imm = #0x4c8
 8013330: 43ff         	mvns	r7, r7
 8013332: f007 0320    	and	r3, r7, #0x20
 8013336: 9304         	str	r3, [sp, #0x10]
 8013338: 9b0b         	ldr	r3, [sp, #0x2c]
 801333a: 3307         	adds	r3, #0x7
 801333c: f023 0307    	bic	r3, r3, #0x7
 8013340: f01b 0f40    	tst.w	r11, #0x40
 8013344: f103 0208    	add.w	r2, r3, #0x8
 8013348: bf08         	it	eq
 801334a: f04f 36ff    	moveq.w	r6, #0xffffffff
 801334e: ed93 0b00    	vldr	d0, [r3]
 8013352: 920b         	str	r2, [sp, #0x2c]
 8013354: 4631         	mov	r1, r6
 8013356: 9a04         	ldr	r2, [sp, #0x10]
 8013358: a80c         	add	r0, sp, #0x30
 801335a: f00c fe00    	bl	0x801ff5e <__dtox_engine> @ imm = #0xcc00
 801335e: 3001         	adds	r0, #0x1
 8013360: b2c3         	uxtb	r3, r0
 8013362: 42b3         	cmp	r3, r6
 8013364: f44b 54c0    	orr	r4, r11, #0x1800
 8013368: 9302         	str	r3, [sp, #0x8]
 801336a: db01         	blt	0x8013370 <vfprintf+0x1e8> @ imm = #0x2
 801336c: 9b02         	ldr	r3, [sp, #0x8]
 801336e: 1e5e         	subs	r6, r3, #0x1
 8013370: 2301         	movs	r3, #0x1
 8013372: 9f0c         	ldr	r7, [sp, #0x30]
 8013374: 9303         	str	r3, [sp, #0xc]
 8013376: 46a3         	mov	r11, r4
 8013378: f04f 0970    	mov.w	r9, #0x70
 801337c: f107 0309    	add.w	r3, r7, #0x9
 8013380: 2b12         	cmp	r3, #0x12
 8013382: d90d         	bls	0x80133a0 <vfprintf+0x218> @ imm = #0x1a
 8013384: f107 0363    	add.w	r3, r7, #0x63
 8013388: 2bc6         	cmp	r3, #0xc6
 801338a: f240 810d    	bls.w	0x80135a8 <vfprintf+0x420> @ imm = #0x21a
 801338e: f207 33e7    	addw	r3, r7, #0x3e7
 8013392: f240 72ce    	movw	r2, #0x7ce
 8013396: 4293         	cmp	r3, r2
 8013398: bf94         	ite	ls
 801339a: 2303         	movls	r3, #0x3
 801339c: 2304         	movhi	r3, #0x4
 801339e: 9303         	str	r3, [sp, #0xc]
 80133a0: f89d 2034    	ldrb.w	r2, [sp, #0x34]
 80133a4: f002 030c    	and	r3, r2, #0xc
 80133a8: f012 0201    	ands	r2, r2, #0x1
 80133ac: f040 8117    	bne.w	0x80135de <vfprintf+0x456> @ imm = #0x22e
 80133b0: f01b 0f02    	tst.w	r11, #0x2
 80133b4: f040 8110    	bne.w	0x80135d8 <vfprintf+0x450> @ imm = #0x220
 80133b8: f01b 0404    	ands	r4, r11, #0x4
 80133bc: f000 80f6    	beq.w	0x80135ac <vfprintf+0x424> @ imm = #0x1ec
 80133c0: 2b00         	cmp	r3, #0x0
 80133c2: f040 810f    	bne.w	0x80135e4 <vfprintf+0x45c> @ imm = #0x21e
 80133c6: 2320         	movs	r3, #0x20
 80133c8: f41b 5f40    	tst.w	r11, #0x3000
 80133cc: d11f         	bne	0x801340e <vfprintf+0x286> @ imm = #0x3e
 80133ce: 9a02         	ldr	r2, [sp, #0x8]
 80133d0: 3248         	adds	r2, #0x48
 80133d2: 2e00         	cmp	r6, #0x0
 80133d4: 446a         	add	r2, sp, r2
 80133d6: bf08         	it	eq
 80133d8: 2601         	moveq	r6, #0x1
 80133da: 3a13         	subs	r2, #0x13
 80133dc: 9902         	ldr	r1, [sp, #0x8]
 80133de: b121         	cbz	r1, 0x80133ea <vfprintf+0x262> @ imm = #0x8
 80133e0: f812 1d01    	ldrb	r1, [r2, #-1]!
 80133e4: 2930         	cmp	r1, #0x30
 80133e6: f000 8134    	beq.w	0x8013652 <vfprintf+0x4ca> @ imm = #0x268
 80133ea: f01b 0f10    	tst.w	r11, #0x10
 80133ee: 9a02         	ldr	r2, [sp, #0x8]
 80133f0: bf18         	it	ne
 80133f2: 4632         	movne	r2, r6
 80133f4: 1d39         	adds	r1, r7, #0x4
 80133f6: f2c0 8131    	blt.w	0x801365c <vfprintf+0x4d4> @ imm = #0x262
 80133fa: 42b7         	cmp	r7, r6
 80133fc: f280 812e    	bge.w	0x801365c <vfprintf+0x4d4> @ imm = #0x25c
 8013400: 42ba         	cmp	r2, r7
 8013402: f44b 5b00    	orr	r11, r11, #0x2000
 8013406: f340 812b    	ble.w	0x8013660 <vfprintf+0x4d8> @ imm = #0x256
 801340a: 1c7e         	adds	r6, r7, #0x1
 801340c: 1b96         	subs	r6, r2, r6
 801340e: f41b 5200    	ands	r2, r11, #0x2000
 8013412: 9208         	str	r2, [sp, #0x20]
 8013414: f000 8126    	beq.w	0x8013664 <vfprintf+0x4dc> @ imm = #0x24c
 8013418: ea27 74e7    	bic.w	r4, r7, r7, asr #31
 801341c: 3401         	adds	r4, #0x1
 801341e: b103         	cbz	r3, 0x8013422 <vfprintf+0x29a> @ imm = #0x0
 8013420: 3401         	adds	r4, #0x1
 8013422: 2e00         	cmp	r6, #0x0
 8013424: f000 8126    	beq.w	0x8013674 <vfprintf+0x4ec> @ imm = #0x24c
 8013428: 1c72         	adds	r2, r6, #0x1
 801342a: 4414         	add	r4, r2
 801342c: 45a2         	cmp	r10, r4
 801342e: bfcc         	ite	gt
 8013430: ebaa 0404    	subgt.w	r4, r10, r4
 8013434: 2400         	movle	r4, #0x0
 8013436: f01b 0f09    	tst.w	r11, #0x9
 801343a: d104         	bne	0x8013446 <vfprintf+0x2be> @ imm = #0x8
 801343c: 442c         	add	r4, r5
 801343e: 42a5         	cmp	r5, r4
 8013440: f040 811d    	bne.w	0x801367e <vfprintf+0x4f6> @ imm = #0x23a
 8013444: 2400         	movs	r4, #0x0
 8013446: b143         	cbz	r3, 0x801345a <vfprintf+0x2d2> @ imm = #0x10
 8013448: 4618         	mov	r0, r3
 801344a: 4641         	mov	r1, r8
 801344c: 9b01         	ldr	r3, [sp, #0x4]
 801344e: 4798         	blx	r3
 8013450: 2800         	cmp	r0, #0x0
 8013452: f105 0501    	add.w	r5, r5, #0x1
 8013456: f6ff aeb4    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x298
 801345a: f41b 6f00    	tst.w	r11, #0x800
 801345e: d013         	beq	0x8013488 <vfprintf+0x300> @ imm = #0x26
 8013460: 9b01         	ldr	r3, [sp, #0x4]
 8013462: 4641         	mov	r1, r8
 8013464: 2030         	movs	r0, #0x30
 8013466: 4798         	blx	r3
 8013468: 2800         	cmp	r0, #0x0
 801346a: f6ff aeaa    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x2ac
 801346e: 9b04         	ldr	r3, [sp, #0x10]
 8013470: f1c3 0078    	rsb.w	r0, r3, #0x78
 8013474: 4641         	mov	r1, r8
 8013476: 9b01         	ldr	r3, [sp, #0x4]
 8013478: f000 00f8    	and	r0, r0, #0xf8
 801347c: 4798         	blx	r3
 801347e: 2800         	cmp	r0, #0x0
 8013480: f105 0502    	add.w	r5, r5, #0x2
 8013484: f6ff ae9d    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x2c6
 8013488: f01b 0f08    	tst.w	r11, #0x8
 801348c: d105         	bne	0x801349a <vfprintf+0x312> @ imm = #0xa
 801348e: 442c         	add	r4, r5
 8013490: 42ac         	cmp	r4, r5
 8013492: f040 8100    	bne.w	0x8013696 <vfprintf+0x50e> @ imm = #0x200
 8013496: 4625         	mov	r5, r4
 8013498: 2400         	movs	r4, #0x0
 801349a: 9b08         	ldr	r3, [sp, #0x20]
 801349c: 2b00         	cmp	r3, #0x0
 801349e: f000 811a    	beq.w	0x80136d6 <vfprintf+0x54e> @ imm = #0x234
 80134a2: ea27 7ae7    	bic.w	r10, r7, r7, asr #31
 80134a6: eba7 070a    	sub.w	r7, r7, r10
 80134aa: 4276         	rsbs	r6, r6, #0
 80134ac: 9b02         	ldr	r3, [sp, #0x8]
 80134ae: 42bb         	cmp	r3, r7
 80134b0: bf84         	itt	hi
 80134b2: ab0c         	addhi	r3, sp, #0x30
 80134b4: 18fb         	addhi	r3, r7, r3
 80134b6: f10a 3aff    	add.w	r10, r10, #0xffffffff
 80134ba: bf88         	it	hi
 80134bc: 7958         	ldrbhi	r0, [r3, #0x5]
 80134be: 9b01         	ldr	r3, [sp, #0x4]
 80134c0: bf98         	it	ls
 80134c2: 2030         	movls	r0, #0x30
 80134c4: 4556         	cmp	r6, r10
 80134c6: f105 0901    	add.w	r9, r5, #0x1
 80134ca: 4641         	mov	r1, r8
 80134cc: f300 80ed    	bgt.w	0x80136aa <vfprintf+0x522> @ imm = #0x1da
 80134d0: 4798         	blx	r3
 80134d2: 2800         	cmp	r0, #0x0
 80134d4: f107 0701    	add.w	r7, r7, #0x1
 80134d8: f6ff ae73    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x31a
 80134dc: f1ba 3fff    	cmp.w	r10, #0xffffffff
 80134e0: d108         	bne	0x80134f4 <vfprintf+0x36c> @ imm = #0x10
 80134e2: 9b01         	ldr	r3, [sp, #0x4]
 80134e4: 4641         	mov	r1, r8
 80134e6: 202e         	movs	r0, #0x2e
 80134e8: 4798         	blx	r3
 80134ea: 2800         	cmp	r0, #0x0
 80134ec: f6ff ae69    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x32e
 80134f0: f105 0902    	add.w	r9, r5, #0x2
 80134f4: 464d         	mov	r5, r9
 80134f6: e7d9         	b	0x80134ac <vfprintf+0x324> @ imm = #-0x4e
 80134f8: 2f74         	cmp	r7, #0x74
 80134fa: f43f ae9b    	beq.w	0x8013234 <vfprintf+0xac> @ imm = #-0x2ca
 80134fe: 2f7a         	cmp	r7, #0x7a
 8013500: f43f ae98    	beq.w	0x8013234 <vfprintf+0xac> @ imm = #-0x2d0
 8013504: e6f9         	b	0x80132fa <vfprintf+0x172> @ imm = #-0x20e
 8013506: f01b 0f80    	tst.w	r11, #0x80
 801350a: bf18         	it	ne
 801350c: f44b 7b00    	orrne	r11, r11, #0x200
 8013510: f04b 0b80    	orr	r11, r11, #0x80
 8013514: e68e         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x2e4
 8013516: f41b 7f80    	tst.w	r11, #0x100
 801351a: bf18         	it	ne
 801351c: f44b 7b00    	orrne	r11, r11, #0x200
 8013520: f44b 7b80    	orr	r11, r11, #0x100
 8013524: e686         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x2f4
 8013526: f44b 7b20    	orr	r11, r11, #0x280
 801352a: e683         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x2fa
 801352c: 4626         	mov	r6, r4
 801352e: 46b3         	mov	r11, r6
 8013530: 4654         	mov	r4, r10
 8013532: 46b2         	mov	r10, r6
 8013534: e67e         	b	0x8013234 <vfprintf+0xac> @ imm = #-0x304
 8013536: 43ff         	mvns	r7, r7
 8013538: f007 0320    	and	r3, r7, #0x20
 801353c: 9304         	str	r3, [sp, #0x10]
 801353e: 9b0b         	ldr	r3, [sp, #0x2c]
 8013540: 3307         	adds	r3, #0x7
 8013542: f023 0307    	bic	r3, r3, #0x7
 8013546: f01b 0f40    	tst.w	r11, #0x40
 801354a: f103 0208    	add.w	r2, r3, #0x8
 801354e: bf08         	it	eq
 8013550: 2606         	moveq	r6, #0x6
 8013552: f1b9 0f65    	cmp.w	r9, #0x65
 8013556: ed93 0b00    	vldr	d0, [r3]
 801355a: 920b         	str	r2, [sp, #0x2c]
 801355c: d111         	bne	0x8013582 <vfprintf+0x3fa> @ imm = #0x22
 801355e: 1c71         	adds	r1, r6, #0x1
 8013560: 2200         	movs	r2, #0x0
 8013562: b2c9         	uxtb	r1, r1
 8013564: f44b 5b80    	orr	r11, r11, #0x1000
 8013568: 4613         	mov	r3, r2
 801356a: 2911         	cmp	r1, #0x11
 801356c: bf28         	it	hs
 801356e: 2111         	movhs	r1, #0x11
 8013570: a80c         	add	r0, sp, #0x30
 8013572: f000 fafb    	bl	0x8013b6c <__dtoa_engine> @ imm = #0x5f6
 8013576: b2c3         	uxtb	r3, r0
 8013578: 9302         	str	r3, [sp, #0x8]
 801357a: 2302         	movs	r3, #0x2
 801357c: 9f0c         	ldr	r7, [sp, #0x30]
 801357e: 9303         	str	r3, [sp, #0xc]
 8013580: e6fc         	b	0x801337c <vfprintf+0x1f4> @ imm = #-0x208
 8013582: f1b9 0f66    	cmp.w	r9, #0x66
 8013586: d105         	bne	0x8013594 <vfprintf+0x40c> @ imm = #0xa
 8013588: f44b 5b00    	orr	r11, r11, #0x2000
 801358c: 4633         	mov	r3, r6
 801358e: 2201         	movs	r2, #0x1
 8013590: 2111         	movs	r1, #0x11
 8013592: e7ea         	b	0x801356a <vfprintf+0x3e2> @ imm = #-0x2c
 8013594: b2f1         	uxtb	r1, r6
 8013596: 2901         	cmp	r1, #0x1
 8013598: f04f 0200    	mov.w	r2, #0x0
 801359c: bf38         	it	lo
 801359e: 2101         	movlo	r1, #0x1
 80135a0: 4613         	mov	r3, r2
 80135a2: f04f 0965    	mov.w	r9, #0x65
 80135a6: e7e0         	b	0x801356a <vfprintf+0x3e2> @ imm = #-0x40
 80135a8: 2302         	movs	r3, #0x2
 80135aa: e6f8         	b	0x801339e <vfprintf+0x216> @ imm = #-0x210
 80135ac: 2b00         	cmp	r3, #0x0
 80135ae: f43f af0b    	beq.w	0x80133c8 <vfprintf+0x240> @ imm = #-0x1ea
 80135b2: f1ba 0f03    	cmp.w	r10, #0x3
 80135b6: dc3b         	bgt	0x8013630 <vfprintf+0x4a8> @ imm = #0x76
 80135b8: f89d 3034    	ldrb.w	r3, [sp, #0x34]
 80135bc: 4ea5         	ldr	r6, [pc, #0x294]        @ 0x8013854 <vfprintf+0x6cc>
 80135be: f013 0f08    	tst.w	r3, #0x8
 80135c2: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x8013858 <vfprintf+0x6d0>
 80135c4: bf08         	it	eq
 80135c6: 461e         	moveq	r6, r3
 80135c8: 4637         	mov	r7, r6
 80135ca: 46b9         	mov	r9, r7
 80135cc: f817 0b01    	ldrb	r0, [r7], #1
 80135d0: bbb0         	cbnz	r0, 0x8013640 <vfprintf+0x4b8> @ imm = #0x6c
 80135d2: 1bae         	subs	r6, r5, r6
 80135d4: 44b1         	add	r9, r6
 80135d6: e07b         	b	0x80136d0 <vfprintf+0x548> @ imm = #0xf6
 80135d8: bb33         	cbnz	r3, 0x8013628 <vfprintf+0x4a0> @ imm = #0x4c
 80135da: 232b         	movs	r3, #0x2b
 80135dc: e6f4         	b	0x80133c8 <vfprintf+0x240> @ imm = #-0x218
 80135de: bb2b         	cbnz	r3, 0x801362c <vfprintf+0x4a4> @ imm = #0x4a
 80135e0: 232d         	movs	r3, #0x2d
 80135e2: e6f1         	b	0x80133c8 <vfprintf+0x240> @ imm = #-0x21e
 80135e4: 2220         	movs	r2, #0x20
 80135e6: f1ba 0f04    	cmp.w	r10, #0x4
 80135ea: dd13         	ble	0x8013614 <vfprintf+0x48c> @ imm = #0x26
 80135ec: f01b 0f08    	tst.w	r11, #0x8
 80135f0: f1aa 0404    	sub.w	r4, r10, #0x4
 80135f4: d10f         	bne	0x8013616 <vfprintf+0x48e> @ imm = #0x1e
 80135f6: 442c         	add	r4, r5
 80135f8: 9b01         	ldr	r3, [sp, #0x4]
 80135fa: 9202         	str	r2, [sp, #0x8]
 80135fc: 4641         	mov	r1, r8
 80135fe: 2020         	movs	r0, #0x20
 8013600: 4798         	blx	r3
 8013602: 2800         	cmp	r0, #0x0
 8013604: f105 0501    	add.w	r5, r5, #0x1
 8013608: f6ff addb    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x44a
 801360c: 42a5         	cmp	r5, r4
 801360e: 9a02         	ldr	r2, [sp, #0x8]
 8013610: d1f2         	bne	0x80135f8 <vfprintf+0x470> @ imm = #-0x1c
 8013612: b19a         	cbz	r2, 0x801363c <vfprintf+0x4b4> @ imm = #0x26
 8013614: 2400         	movs	r4, #0x0
 8013616: 9b01         	ldr	r3, [sp, #0x4]
 8013618: 4641         	mov	r1, r8
 801361a: 4610         	mov	r0, r2
 801361c: 4798         	blx	r3
 801361e: 2800         	cmp	r0, #0x0
 8013620: f105 0501    	add.w	r5, r5, #0x1
 8013624: dac8         	bge	0x80135b8 <vfprintf+0x430> @ imm = #-0x70
 8013626: e5cc         	b	0x80131c2 <vfprintf+0x3a> @ imm = #-0x468
 8013628: 222b         	movs	r2, #0x2b
 801362a: e7dc         	b	0x80135e6 <vfprintf+0x45e> @ imm = #-0x48
 801362c: 222d         	movs	r2, #0x2d
 801362e: e7da         	b	0x80135e6 <vfprintf+0x45e> @ imm = #-0x4c
 8013630: f01b 0f08    	tst.w	r11, #0x8
 8013634: f1aa 0403    	sub.w	r4, r10, #0x3
 8013638: d1be         	bne	0x80135b8 <vfprintf+0x430> @ imm = #-0x84
 801363a: e7dc         	b	0x80135f6 <vfprintf+0x46e> @ imm = #-0x48
 801363c: 4614         	mov	r4, r2
 801363e: e7bb         	b	0x80135b8 <vfprintf+0x430> @ imm = #-0x8a
 8013640: 9b04         	ldr	r3, [sp, #0x10]
 8013642: 1ac0         	subs	r0, r0, r3
 8013644: 4641         	mov	r1, r8
 8013646: 9b01         	ldr	r3, [sp, #0x4]
 8013648: b2c0         	uxtb	r0, r0
 801364a: 4798         	blx	r3
 801364c: 2800         	cmp	r0, #0x0
 801364e: dabc         	bge	0x80135ca <vfprintf+0x442> @ imm = #-0x88
 8013650: e5b7         	b	0x80131c2 <vfprintf+0x3a> @ imm = #-0x492
 8013652: 9902         	ldr	r1, [sp, #0x8]
 8013654: 3901         	subs	r1, #0x1
 8013656: b2c9         	uxtb	r1, r1
 8013658: 9102         	str	r1, [sp, #0x8]
 801365a: e6bf         	b	0x80133dc <vfprintf+0x254> @ imm = #-0x282
 801365c: 1e56         	subs	r6, r2, #0x1
 801365e: e6d6         	b	0x801340e <vfprintf+0x286> @ imm = #-0x254
 8013660: 2600         	movs	r6, #0x0
 8013662: e6d4         	b	0x801340e <vfprintf+0x286> @ imm = #-0x258
 8013664: f41b 6f00    	tst.w	r11, #0x800
 8013668: 9a03         	ldr	r2, [sp, #0xc]
 801366a: bf0c         	ite	eq
 801366c: 2403         	moveq	r4, #0x3
 801366e: 2405         	movne	r4, #0x5
 8013670: 4414         	add	r4, r2
 8013672: e6d4         	b	0x801341e <vfprintf+0x296> @ imm = #-0x258
 8013674: f01b 0f10    	tst.w	r11, #0x10
 8013678: bf18         	it	ne
 801367a: 3401         	addne	r4, #0x1
 801367c: e6d6         	b	0x801342c <vfprintf+0x2a4> @ imm = #-0x254
 801367e: 9309         	str	r3, [sp, #0x24]
 8013680: 4641         	mov	r1, r8
 8013682: 9b01         	ldr	r3, [sp, #0x4]
 8013684: 2020         	movs	r0, #0x20
 8013686: 4798         	blx	r3
 8013688: 2800         	cmp	r0, #0x0
 801368a: 9b09         	ldr	r3, [sp, #0x24]
 801368c: f105 0501    	add.w	r5, r5, #0x1
 8013690: f6bf aed5    	bge.w	0x801343e <vfprintf+0x2b6> @ imm = #-0x256
 8013694: e595         	b	0x80131c2 <vfprintf+0x3a> @ imm = #-0x4d6
 8013696: 9b01         	ldr	r3, [sp, #0x4]
 8013698: 4641         	mov	r1, r8
 801369a: 2030         	movs	r0, #0x30
 801369c: 4798         	blx	r3
 801369e: 2800         	cmp	r0, #0x0
 80136a0: f105 0501    	add.w	r5, r5, #0x1
 80136a4: f6bf aef4    	bge.w	0x8013490 <vfprintf+0x308> @ imm = #-0x218
 80136a8: e58b         	b	0x80131c2 <vfprintf+0x3a> @ imm = #-0x4ea
 80136aa: 4798         	blx	r3
 80136ac: 2800         	cmp	r0, #0x0
 80136ae: f6ff ad88    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x4f0
 80136b2: f01b 0f10    	tst.w	r11, #0x10
 80136b6: d00b         	beq	0x80136d0 <vfprintf+0x548> @ imm = #0x16
 80136b8: f1ba 3fff    	cmp.w	r10, #0xffffffff
 80136bc: d108         	bne	0x80136d0 <vfprintf+0x548> @ imm = #0x10
 80136be: f105 0902    	add.w	r9, r5, #0x2
 80136c2: 4641         	mov	r1, r8
 80136c4: 202e         	movs	r0, #0x2e
 80136c6: 9b01         	ldr	r3, [sp, #0x4]
 80136c8: 4798         	blx	r3
 80136ca: 2800         	cmp	r0, #0x0
 80136cc: f6ff ad79    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x50e
 80136d0: 464d         	mov	r5, r9
 80136d2: 444c         	add	r4, r9
 80136d4: e232         	b	0x8013b3c <vfprintf+0x9b4> @ imm = #0x464
 80136d6: f89d 0035    	ldrb.w	r0, [sp, #0x35]
 80136da: 9b01         	ldr	r3, [sp, #0x4]
 80136dc: 4641         	mov	r1, r8
 80136de: 4798         	blx	r3
 80136e0: 2800         	cmp	r0, #0x0
 80136e2: f6ff ad6e    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x524
 80136e6: 2e00         	cmp	r6, #0x0
 80136e8: dd69         	ble	0x80137be <vfprintf+0x636> @ imm = #0xd2
 80136ea: 9b01         	ldr	r3, [sp, #0x4]
 80136ec: 4641         	mov	r1, r8
 80136ee: 202e         	movs	r0, #0x2e
 80136f0: 4798         	blx	r3
 80136f2: 2800         	cmp	r0, #0x0
 80136f4: f6ff ad65    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x536
 80136f8: f04f 0a01    	mov.w	r10, #0x1
 80136fc: 9b02         	ldr	r3, [sp, #0x8]
 80136fe: 459a         	cmp	r10, r3
 8013700: bfbb         	ittet	lt
 8013702: ab0c         	addlt	r3, sp, #0x30
 8013704: 4453         	addlt	r3, r10
 8013706: 2030         	movge	r0, #0x30
 8013708: 7958         	ldrblt	r0, [r3, #0x5]
 801370a: 9b01         	ldr	r3, [sp, #0x4]
 801370c: 4641         	mov	r1, r8
 801370e: 4798         	blx	r3
 8013710: 2800         	cmp	r0, #0x0
 8013712: 46d3         	mov	r11, r10
 8013714: f6ff ad55    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x556
 8013718: f10a 0a01    	add.w	r10, r10, #0x1
 801371c: 4556         	cmp	r6, r10
 801371e: daed         	bge	0x80136fc <vfprintf+0x574> @ imm = #-0x26
 8013720: 3502         	adds	r5, #0x2
 8013722: 445d         	add	r5, r11
 8013724: 9b04         	ldr	r3, [sp, #0x10]
 8013726: eba9 0003    	sub.w	r0, r9, r3
 801372a: 4641         	mov	r1, r8
 801372c: 9b01         	ldr	r3, [sp, #0x4]
 801372e: b2c0         	uxtb	r0, r0
 8013730: 4798         	blx	r3
 8013732: 2800         	cmp	r0, #0x0
 8013734: f6ff ad45    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x576
 8013738: 2f00         	cmp	r7, #0x0
 801373a: bfb4         	ite	lt
 801373c: 202d         	movlt	r0, #0x2d
 801373e: 202b         	movge	r0, #0x2b
 8013740: 9b01         	ldr	r3, [sp, #0x4]
 8013742: 4641         	mov	r1, r8
 8013744: bfb8         	it	lt
 8013746: 427f         	rsblt	r7, r7, #0
 8013748: 4798         	blx	r3
 801374a: 2800         	cmp	r0, #0x0
 801374c: f6ff ad39    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x58e
 8013750: 9b03         	ldr	r3, [sp, #0xc]
 8013752: 2b04         	cmp	r3, #0x4
 8013754: d141         	bne	0x80137da <vfprintf+0x652> @ imm = #0x82
 8013756: f44f 797a    	mov.w	r9, #0x3e8
 801375a: fbb7 f6f9    	udiv	r6, r7, r9
 801375e: f106 0030    	add.w	r0, r6, #0x30
 8013762: 9b01         	ldr	r3, [sp, #0x4]
 8013764: 4641         	mov	r1, r8
 8013766: b2c0         	uxtb	r0, r0
 8013768: 4798         	blx	r3
 801376a: 2800         	cmp	r0, #0x0
 801376c: f105 0503    	add.w	r5, r5, #0x3
 8013770: f6ff ad27    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x5b2
 8013774: fb09 7716    	mls	r7, r9, r6, r7
 8013778: f04f 0964    	mov.w	r9, #0x64
 801377c: fbb7 f6f9    	udiv	r6, r7, r9
 8013780: f106 0030    	add.w	r0, r6, #0x30
 8013784: 9b01         	ldr	r3, [sp, #0x4]
 8013786: 4641         	mov	r1, r8
 8013788: b2c0         	uxtb	r0, r0
 801378a: 4798         	blx	r3
 801378c: 2800         	cmp	r0, #0x0
 801378e: f105 0501    	add.w	r5, r5, #0x1
 8013792: f6ff ad16    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x5d4
 8013796: fb09 7716    	mls	r7, r9, r6, r7
 801379a: f04f 090a    	mov.w	r9, #0xa
 801379e: fbb7 f6f9    	udiv	r6, r7, r9
 80137a2: f106 0030    	add.w	r0, r6, #0x30
 80137a6: 9b01         	ldr	r3, [sp, #0x4]
 80137a8: 4641         	mov	r1, r8
 80137aa: b2c0         	uxtb	r0, r0
 80137ac: 4798         	blx	r3
 80137ae: 2800         	cmp	r0, #0x0
 80137b0: f105 0501    	add.w	r5, r5, #0x1
 80137b4: f6ff ad05    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x5f6
 80137b8: fb09 7716    	mls	r7, r9, r6, r7
 80137bc: e015         	b	0x80137ea <vfprintf+0x662> @ imm = #0x2a
 80137be: f01b 0f10    	tst.w	r11, #0x10
 80137c2: d101         	bne	0x80137c8 <vfprintf+0x640> @ imm = #0x2
 80137c4: 3501         	adds	r5, #0x1
 80137c6: e7ad         	b	0x8013724 <vfprintf+0x59c> @ imm = #-0xa6
 80137c8: 9b01         	ldr	r3, [sp, #0x4]
 80137ca: 4641         	mov	r1, r8
 80137cc: 202e         	movs	r0, #0x2e
 80137ce: 4798         	blx	r3
 80137d0: 2800         	cmp	r0, #0x0
 80137d2: f105 0502    	add.w	r5, r5, #0x2
 80137d6: daa5         	bge	0x8013724 <vfprintf+0x59c> @ imm = #-0xb6
 80137d8: e4f3         	b	0x80131c2 <vfprintf+0x3a> @ imm = #-0x61a
 80137da: 9b03         	ldr	r3, [sp, #0xc]
 80137dc: 2b03         	cmp	r3, #0x3
 80137de: f105 0502    	add.w	r5, r5, #0x2
 80137e2: d0c9         	beq	0x8013778 <vfprintf+0x5f0> @ imm = #-0x6e
 80137e4: 9b03         	ldr	r3, [sp, #0xc]
 80137e6: 2b01         	cmp	r3, #0x1
 80137e8: d1d7         	bne	0x801379a <vfprintf+0x612> @ imm = #-0x52
 80137ea: f107 0030    	add.w	r0, r7, #0x30
 80137ee: f105 0901    	add.w	r9, r5, #0x1
 80137f2: 4641         	mov	r1, r8
 80137f4: b2c0         	uxtb	r0, r0
 80137f6: e766         	b	0x80136c6 <vfprintf+0x53e> @ imm = #-0x134
 80137f8: f1a7 0363    	sub.w	r3, r7, #0x63
 80137fc: 2b12         	cmp	r3, #0x12
 80137fe: f200 80fe    	bhi.w	0x80139fe <vfprintf+0x876> @ imm = #0x1fc
 8013802: e8df f013    	tbh	[pc, r3, lsl #1]

08013806 <$d>:
 8013806: 13 00 56 00  	.word	0x00560013
 801380a: fc 00 fc 00  	.word	0x00fc00fc
 801380e: fc 00 fc 00  	.word	0x00fc00fc
 8013812: 56 00 fc 00  	.word	0x00fc0056
 8013816: fc 00 fc 00  	.word	0x00fc00fc
 801381a: fc 00 fc 00  	.word	0x00fc00fc
 801381e: 16 01 f7 00  	.word	0x00f70116
 8013822: fc 00 fc 00  	.word	0x00fc00fc
 8013826: 2b 00 fc 00  	.word	0x00fc002b
 801382a: b8 00        	.short	0x00b8

0801382c <$t>:
 801382c: 9b0b         	ldr	r3, [sp, #0x2c]
 801382e: 1d1a         	adds	r2, r3, #0x4
 8013830: 681b         	ldr	r3, [r3]
 8013832: 920b         	str	r2, [sp, #0x2c]
 8013834: f88d 3030    	strb.w	r3, [sp, #0x30]
 8013838: 2401         	movs	r4, #0x1
 801383a: af0c         	add	r7, sp, #0x30
 801383c: f01b 0f08    	tst.w	r11, #0x8
 8013840: d02d         	beq	0x801389e <vfprintf+0x716> @ imm = #0x5a
 8013842: 193e         	adds	r6, r7, r4
 8013844: 46b9         	mov	r9, r7
 8013846: 45b1         	cmp	r9, r6
 8013848: d12b         	bne	0x80138a2 <vfprintf+0x71a> @ imm = #0x56
 801384a: 1bef         	subs	r7, r5, r7
 801384c: 44b9         	add	r9, r7
 801384e: ebaa 0404    	sub.w	r4, r10, r4
 8013852: e73d         	b	0x80136d0 <vfprintf+0x548> @ imm = #-0x186

08013854 <$d>:
 8013854: ad 34 02 08  	.word	0x080234ad
 8013858: a9 34 02 08  	.word	0x080234a9

0801385c <$t>:
 801385c: 9b0b         	ldr	r3, [sp, #0x2c]
 801385e: 1d1a         	adds	r2, r3, #0x4
 8013860: 920b         	str	r2, [sp, #0x2c]
 8013862: 681f         	ldr	r7, [r3]
 8013864: 4bab         	ldr	r3, [pc, #0x2ac]        @ 0x8013b14 <vfprintf+0x98c>
 8013866: 2f00         	cmp	r7, #0x0
 8013868: bf08         	it	eq
 801386a: 461f         	moveq	r7, r3
 801386c: f01b 0f40    	tst.w	r11, #0x40
 8013870: bf14         	ite	ne
 8013872: 4631         	movne	r1, r6
 8013874: f04f 31ff    	moveq.w	r1, #0xffffffff
 8013878: 4638         	mov	r0, r7
 801387a: f00c fa45    	bl	0x801fd08 <strnlen>     @ imm = #0xc48a
 801387e: 4604         	mov	r4, r0
 8013880: e7dc         	b	0x801383c <vfprintf+0x6b4> @ imm = #-0x48
 8013882: 9b01         	ldr	r3, [sp, #0x4]
 8013884: 4641         	mov	r1, r8
 8013886: 2020         	movs	r0, #0x20
 8013888: 4798         	blx	r3
 801388a: 2800         	cmp	r0, #0x0
 801388c: f6ff ac99    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x6ce
 8013890: 3e01         	subs	r6, #0x1
 8013892: 42b4         	cmp	r4, r6
 8013894: d3f5         	blo	0x8013882 <vfprintf+0x6fa> @ imm = #-0x16
 8013896: 4455         	add	r5, r10
 8013898: 1bad         	subs	r5, r5, r6
 801389a: 46b2         	mov	r10, r6
 801389c: e7d1         	b	0x8013842 <vfprintf+0x6ba> @ imm = #-0x5e
 801389e: 4656         	mov	r6, r10
 80138a0: e7f7         	b	0x8013892 <vfprintf+0x70a> @ imm = #-0x12
 80138a2: f819 0b01    	ldrb	r0, [r9], #1
 80138a6: 9b01         	ldr	r3, [sp, #0x4]
 80138a8: 4641         	mov	r1, r8
 80138aa: 4798         	blx	r3
 80138ac: 2800         	cmp	r0, #0x0
 80138ae: daca         	bge	0x8013846 <vfprintf+0x6be> @ imm = #-0x6c
 80138b0: e487         	b	0x80131c2 <vfprintf+0x3a> @ imm = #-0x6f2
 80138b2: f01b 0f80    	tst.w	r11, #0x80
 80138b6: 9b0b         	ldr	r3, [sp, #0x2c]
 80138b8: d035         	beq	0x8013926 <vfprintf+0x79e> @ imm = #0x6a
 80138ba: f41b 7f00    	tst.w	r11, #0x200
 80138be: d02d         	beq	0x801391c <vfprintf+0x794> @ imm = #0x5a
 80138c0: 3307         	adds	r3, #0x7
 80138c2: f023 0307    	bic	r3, r3, #0x7
 80138c6: e9d3 0100    	ldrd	r0, r1, [r3]
 80138ca: f103 0208    	add.w	r2, r3, #0x8
 80138ce: 920b         	str	r2, [sp, #0x2c]
 80138d0: f02b 0910    	bic	r9, r11, #0x10
 80138d4: 2900         	cmp	r1, #0x0
 80138d6: fa1f f989    	uxth.w	r9, r9
 80138da: da36         	bge	0x801394a <vfprintf+0x7c2> @ imm = #0x6c
 80138dc: 4240         	rsbs	r0, r0, #0
 80138de: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 80138e2: f449 6980    	orr	r9, r9, #0x400
 80138e6: f10d 0b30    	add.w	r11, sp, #0x30
 80138ea: 230a         	movs	r3, #0xa
 80138ec: 465a         	mov	r2, r11
 80138ee: f00c fa17    	bl	0x801fd20 <__ultoa_invert> @ imm = #0xc42e
 80138f2: f019 0f40    	tst.w	r9, #0x40
 80138f6: eba0 0b0b    	sub.w	r11, r0, r11
 80138fa: d065         	beq	0x80139c8 <vfprintf+0x840> @ imm = #0xca
 80138fc: f029 0201    	bic	r2, r9, #0x1
 8013900: 455e         	cmp	r6, r11
 8013902: b292         	uxth	r2, r2
 8013904: f340 80b2    	ble.w	0x8013a6c <vfprintf+0x8e4> @ imm = #0x164
 8013908: 2f00         	cmp	r7, #0x0
 801390a: f000 80a9    	beq.w	0x8013a60 <vfprintf+0x8d8> @ imm = #0x152
 801390e: f019 0310    	ands	r3, r9, #0x10
 8013912: 4634         	mov	r4, r6
 8013914: 4691         	mov	r9, r2
 8013916: d026         	beq	0x8013966 <vfprintf+0x7de> @ imm = #0x4c
 8013918: 3402         	adds	r4, #0x2
 801391a: e05c         	b	0x80139d6 <vfprintf+0x84e> @ imm = #0xb8
 801391c: 1d1a         	adds	r2, r3, #0x4
 801391e: 6818         	ldr	r0, [r3]
 8013920: 920b         	str	r2, [sp, #0x2c]
 8013922: 17c1         	asrs	r1, r0, #0x1f
 8013924: e7d4         	b	0x80138d0 <vfprintf+0x748> @ imm = #-0x58
 8013926: 1d1a         	adds	r2, r3, #0x4
 8013928: f41b 7f80    	tst.w	r11, #0x100
 801392c: 6819         	ldr	r1, [r3]
 801392e: 920b         	str	r2, [sp, #0x2c]
 8013930: d101         	bne	0x8013936 <vfprintf+0x7ae> @ imm = #0x2
 8013932: 4608         	mov	r0, r1
 8013934: e7f5         	b	0x8013922 <vfprintf+0x79a> @ imm = #-0x16
 8013936: f41b 7f00    	tst.w	r11, #0x200
 801393a: bf15         	itete	ne
 801393c: b248         	sxtbne	r0, r1
 801393e: b208         	sxtheq	r0, r1
 8013940: f341 11c0    	sbfxne	r1, r1, #0x7, #0x1
 8013944: f341 31c0    	sbfxeq	r1, r1, #0xf, #0x1
 8013948: e7c2         	b	0x80138d0 <vfprintf+0x748> @ imm = #-0x7c
 801394a: ea50 0301    	orrs.w	r3, r0, r1
 801394e: d1ca         	bne	0x80138e6 <vfprintf+0x75e> @ imm = #-0x6c
 8013950: f01b 0f40    	tst.w	r11, #0x40
 8013954: d0c7         	beq	0x80138e6 <vfprintf+0x75e> @ imm = #-0x72
 8013956: 2e00         	cmp	r6, #0x0
 8013958: d1c5         	bne	0x80138e6 <vfprintf+0x75e> @ imm = #-0x76
 801395a: f02b 0b11    	bic	r11, r11, #0x11
 801395e: fa1f f98b    	uxth.w	r9, r11
 8013962: 4634         	mov	r4, r6
 8013964: 46b3         	mov	r11, r6
 8013966: f240 4306    	movw	r3, #0x406
 801396a: ea19 0303    	ands.w	r3, r9, r3
 801396e: bf1c         	itt	ne
 8013970: 3401         	addne	r4, #0x1
 8013972: 2300         	movne	r3, #0x0
 8013974: e02f         	b	0x80139d6 <vfprintf+0x84e> @ imm = #0x5e
 8013976: f02b 0b10    	bic	r11, r11, #0x10
 801397a: fa1f fb8b    	uxth.w	r11, r11
 801397e: 230a         	movs	r3, #0xa
 8013980: f01b 0480    	ands	r4, r11, #0x80
 8013984: 9a0b         	ldr	r2, [sp, #0x2c]
 8013986: d057         	beq	0x8013a38 <vfprintf+0x8b0> @ imm = #0xae
 8013988: f41b 7100    	ands	r1, r11, #0x200
 801398c: bf1d         	ittte	ne
 801398e: 3207         	addne	r2, #0x7
 8013990: f022 0207    	bicne	r2, r2, #0x7
 8013994: f102 0108    	addne.w	r1, r2, #0x8
 8013998: 1d10         	addeq	r0, r2, #0x4
 801399a: bf19         	ittee	ne
 801399c: 910b         	strne	r1, [sp, #0x2c]
 801399e: e9d2 0100    	ldrdne	r0, r1, [r2]
 80139a2: 900b         	streq	r0, [sp, #0x2c]
 80139a4: 6810         	ldreq	r0, [r2]
 80139a6: ea50 0201    	orrs.w	r2, r0, r1
 80139aa: d152         	bne	0x8013a52 <vfprintf+0x8ca> @ imm = #0xa4
 80139ac: f02b 0916    	bic	r9, r11, #0x16
 80139b0: f01b 0f40    	tst.w	r11, #0x40
 80139b4: fa1f f989    	uxth.w	r9, r9
 80139b8: d04f         	beq	0x8013a5a <vfprintf+0x8d2> @ imm = #0x9e
 80139ba: 2e00         	cmp	r6, #0x0
 80139bc: d14d         	bne	0x8013a5a <vfprintf+0x8d2> @ imm = #0x9a
 80139be: f02b 0b17    	bic	r11, r11, #0x17
 80139c2: fa1f f98b    	uxth.w	r9, r11
 80139c6: 46b3         	mov	r11, r6
 80139c8: f019 0310    	ands	r3, r9, #0x10
 80139cc: d052         	beq	0x8013a74 <vfprintf+0x8ec> @ imm = #0xa4
 80139ce: 2f00         	cmp	r7, #0x0
 80139d0: d14e         	bne	0x8013a70 <vfprintf+0x8e8> @ imm = #0x9c
 80139d2: f10b 0401    	add.w	r4, r11, #0x1
 80139d6: f019 0f08    	tst.w	r9, #0x8
 80139da: d15e         	bne	0x8013a9a <vfprintf+0x912> @ imm = #0xbc
 80139dc: f019 0f01    	tst.w	r9, #0x1
 80139e0: d006         	beq	0x80139f0 <vfprintf+0x868> @ imm = #0xc
 80139e2: 45a2         	cmp	r10, r4
 80139e4: dd6e         	ble	0x8013ac4 <vfprintf+0x93c> @ imm = #0xdc
 80139e6: ebaa 0404    	sub.w	r4, r10, r4
 80139ea: eb04 060b    	add.w	r6, r4, r11
 80139ee: 4654         	mov	r4, r10
 80139f0: 4622         	mov	r2, r4
 80139f2: e04d         	b	0x8013a90 <vfprintf+0x908> @ imm = #0x9a
 80139f4: f04b 0b10    	orr	r11, r11, #0x10
 80139f8: 2310         	movs	r3, #0x10
 80139fa: 2778         	movs	r7, #0x78
 80139fc: e7c0         	b	0x8013980 <vfprintf+0x7f8> @ imm = #-0x80
 80139fe: f1b9 0f78    	cmp.w	r9, #0x78
 8013a02: d104         	bne	0x8013a0e <vfprintf+0x886> @ imm = #0x8
 8013a04: f1c7 0378    	rsb.w	r3, r7, #0x78
 8013a08: f043 0310    	orr	r3, r3, #0x10
 8013a0c: e7b8         	b	0x8013980 <vfprintf+0x7f8> @ imm = #-0x90
 8013a0e: 9b01         	ldr	r3, [sp, #0x4]
 8013a10: 4641         	mov	r1, r8
 8013a12: 2025         	movs	r0, #0x25
 8013a14: 4798         	blx	r3
 8013a16: 2800         	cmp	r0, #0x0
 8013a18: f6ff abd3    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x85a
 8013a1c: 9b01         	ldr	r3, [sp, #0x4]
 8013a1e: 4641         	mov	r1, r8
 8013a20: 4638         	mov	r0, r7
 8013a22: 4798         	blx	r3
 8013a24: 2800         	cmp	r0, #0x0
 8013a26: f6ff abcc    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x868
 8013a2a: 3502         	adds	r5, #0x2
 8013a2c: 9b05         	ldr	r3, [sp, #0x14]
 8013a2e: f7ff bbb9    	b.w	0x80131a4 <vfprintf+0x1c> @ imm = #-0x88e
 8013a32: 2308         	movs	r3, #0x8
 8013a34: 2700         	movs	r7, #0x0
 8013a36: e7a3         	b	0x8013980 <vfprintf+0x7f8> @ imm = #-0xba
 8013a38: 1d11         	adds	r1, r2, #0x4
 8013a3a: 910b         	str	r1, [sp, #0x2c]
 8013a3c: f41b 7180    	ands	r1, r11, #0x100
 8013a40: 6810         	ldr	r0, [r2]
 8013a42: d0b0         	beq	0x80139a6 <vfprintf+0x81e> @ imm = #-0xa0
 8013a44: f41b 7100    	ands	r1, r11, #0x200
 8013a48: bf1a         	itte	ne
 8013a4a: b2c0         	uxtbne	r0, r0
 8013a4c: 4621         	movne	r1, r4
 8013a4e: b280         	uxtheq	r0, r0
 8013a50: e7a9         	b	0x80139a6 <vfprintf+0x81e> @ imm = #-0xae
 8013a52: f02b 0b06    	bic	r11, r11, #0x6
 8013a56: fa1f f98b    	uxth.w	r9, r11
 8013a5a: f10d 0b30    	add.w	r11, sp, #0x30
 8013a5e: e745         	b	0x80138ec <vfprintf+0x764> @ imm = #-0x176
 8013a60: f029 0911    	bic	r9, r9, #0x11
 8013a64: fa1f f989    	uxth.w	r9, r9
 8013a68: 4634         	mov	r4, r6
 8013a6a: e77c         	b	0x8013966 <vfprintf+0x7de> @ imm = #-0x108
 8013a6c: 4691         	mov	r9, r2
 8013a6e: e7ab         	b	0x80139c8 <vfprintf+0x840> @ imm = #-0xaa
 8013a70: 465c         	mov	r4, r11
 8013a72: e751         	b	0x8013918 <vfprintf+0x790> @ imm = #-0x15e
 8013a74: 465c         	mov	r4, r11
 8013a76: e776         	b	0x8013966 <vfprintf+0x7de> @ imm = #-0x114
 8013a78: e9cd 2302    	strd	r2, r3, [sp, #8]
 8013a7c: 4641         	mov	r1, r8
 8013a7e: 9b01         	ldr	r3, [sp, #0x4]
 8013a80: 2020         	movs	r0, #0x20
 8013a82: 4798         	blx	r3
 8013a84: 2800         	cmp	r0, #0x0
 8013a86: f6ff ab9c    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x8c8
 8013a8a: 9a02         	ldr	r2, [sp, #0x8]
 8013a8c: 9b03         	ldr	r3, [sp, #0xc]
 8013a8e: 3201         	adds	r2, #0x1
 8013a90: 4592         	cmp	r10, r2
 8013a92: dcf1         	bgt	0x8013a78 <vfprintf+0x8f0> @ imm = #-0x1e
 8013a94: 1b2c         	subs	r4, r5, r4
 8013a96: 18a5         	adds	r5, r4, r2
 8013a98: 4614         	mov	r4, r2
 8013a9a: b1f3         	cbz	r3, 0x8013ada <vfprintf+0x952> @ imm = #0x3c
 8013a9c: 9b01         	ldr	r3, [sp, #0x4]
 8013a9e: 4641         	mov	r1, r8
 8013aa0: 2030         	movs	r0, #0x30
 8013aa2: 4798         	blx	r3
 8013aa4: 2800         	cmp	r0, #0x0
 8013aa6: f6ff ab8c    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x8e8
 8013aaa: b96f         	cbnz	r7, 0x8013ac8 <vfprintf+0x940> @ imm = #0x1a
 8013aac: 3501         	adds	r5, #0x1
 8013aae: 46a9         	mov	r9, r5
 8013ab0: 442e         	add	r6, r5
 8013ab2: eba6 0309    	sub.w	r3, r6, r9
 8013ab6: 455b         	cmp	r3, r11
 8013ab8: dc21         	bgt	0x8013afe <vfprintf+0x976> @ imm = #0x42
 8013aba: 465d         	mov	r5, r11
 8013abc: ae0c         	add	r6, sp, #0x30
 8013abe: bb5d         	cbnz	r5, 0x8013b18 <vfprintf+0x990> @ imm = #0x56
 8013ac0: 44d9         	add	r9, r11
 8013ac2: e6c4         	b	0x801384e <vfprintf+0x6c6> @ imm = #-0x278
 8013ac4: 465e         	mov	r6, r11
 8013ac6: e793         	b	0x80139f0 <vfprintf+0x868> @ imm = #-0xda
 8013ac8: 3502         	adds	r5, #0x2
 8013aca: 4641         	mov	r1, r8
 8013acc: 4638         	mov	r0, r7
 8013ace: 9b01         	ldr	r3, [sp, #0x4]
 8013ad0: 4798         	blx	r3
 8013ad2: 2800         	cmp	r0, #0x0
 8013ad4: daeb         	bge	0x8013aae <vfprintf+0x926> @ imm = #-0x2a
 8013ad6: f7ff bb74    	b.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x918
 8013ada: f240 4306    	movw	r3, #0x406
 8013ade: ea19 0f03    	tst.w	r9, r3
 8013ae2: d0e4         	beq	0x8013aae <vfprintf+0x926> @ imm = #-0x38
 8013ae4: f019 0f02    	tst.w	r9, #0x2
 8013ae8: bf14         	ite	ne
 8013aea: 202b         	movne	r0, #0x2b
 8013aec: 2020         	moveq	r0, #0x20
 8013aee: f419 6f80    	tst.w	r9, #0x400
 8013af2: f105 0501    	add.w	r5, r5, #0x1
 8013af6: 4641         	mov	r1, r8
 8013af8: bf18         	it	ne
 8013afa: 202d         	movne	r0, #0x2d
 8013afc: e7e7         	b	0x8013ace <vfprintf+0x946> @ imm = #-0x32
 8013afe: 9b01         	ldr	r3, [sp, #0x4]
 8013b00: 4641         	mov	r1, r8
 8013b02: 2030         	movs	r0, #0x30
 8013b04: 4798         	blx	r3
 8013b06: 2800         	cmp	r0, #0x0
 8013b08: f109 0901    	add.w	r9, r9, #0x1
 8013b0c: dad1         	bge	0x8013ab2 <vfprintf+0x92a> @ imm = #-0x5e
 8013b0e: f7ff bb58    	b.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x950
 8013b12: bf00         	nop

08013b14 <$d>:
 8013b14: b1 34 02 08  	.word	0x080234b1

08013b18 <$t>:
 8013b18: 3d01         	subs	r5, #0x1
 8013b1a: 9b01         	ldr	r3, [sp, #0x4]
 8013b1c: 5d70         	ldrb	r0, [r6, r5]
 8013b1e: 4641         	mov	r1, r8
 8013b20: 4798         	blx	r3
 8013b22: 2800         	cmp	r0, #0x0
 8013b24: dacb         	bge	0x8013abe <vfprintf+0x936> @ imm = #-0x6a
 8013b26: f7ff bb4c    	b.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x968
 8013b2a: 9b01         	ldr	r3, [sp, #0x4]
 8013b2c: 4641         	mov	r1, r8
 8013b2e: 2020         	movs	r0, #0x20
 8013b30: 4798         	blx	r3
 8013b32: 2800         	cmp	r0, #0x0
 8013b34: f105 0501    	add.w	r5, r5, #0x1
 8013b38: f6ff ab43    	blt.w	0x80131c2 <vfprintf+0x3a> @ imm = #-0x97a
 8013b3c: 1b63         	subs	r3, r4, r5
 8013b3e: 2b00         	cmp	r3, #0x0
 8013b40: dcf3         	bgt	0x8013b2a <vfprintf+0x9a2> @ imm = #-0x1a
 8013b42: e773         	b	0x8013a2c <vfprintf+0x8a4> @ imm = #-0x11a

08013b44 <div10>:
 8013b44: b51f         	push	{r0, r1, r2, r3, r4, lr}
 8013b46: ab02         	add	r3, sp, #0x8
 8013b48: 9300         	str	r3, [sp]
 8013b4a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8013b68 <div10+0x24>
 8013b4c: f04f 33cc    	mov.w	r3, #0xcccccccc
 8013b50: f00c f9cb    	bl	0x801feea <__umul128>   @ imm = #0xc396
 8013b54: e9dd 0102    	ldrd	r0, r1, [sp, #8]
 8013b58: 08c0         	lsrs	r0, r0, #0x3
 8013b5a: ea40 7041    	orr.w	r0, r0, r1, lsl #29
 8013b5e: 08c9         	lsrs	r1, r1, #0x3
 8013b60: b005         	add	sp, #0x14
 8013b62: f85d fb04    	ldr	pc, [sp], #4
 8013b66: bf00         	nop

08013b68 <$d>:
 8013b68: cd cc cc cc  	.word	0xcccccccd

08013b6c <__dtoa_engine>:
 8013b6c: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8013b70: ec55 4b10    	vmov	r4, r5, d0
 8013b74: b09d         	sub	sp, #0x74
 8013b76: e9cd 320c    	strd	r3, r2, [sp, #48]
 8013b7a: 462a         	mov	r2, r5
 8013b7c: 910b         	str	r1, [sp, #0x2c]
 8013b7e: f3c5 0313    	ubfx	r3, r5, #0x0, #0x14
 8013b82: 0d29         	lsrs	r1, r5, #0x14
 8013b84: 0fd2         	lsrs	r2, r2, #0x1f
 8013b86: f3c5 550a    	ubfx	r5, r5, #0x14, #0xb
 8013b8a: 9007         	str	r0, [sp, #0x1c]
 8013b8c: ed8d 0a05    	vstr	s0, [sp, #20]
 8013b90: 920a         	str	r2, [sp, #0x28]
 8013b92: b975         	cbnz	r5, 0x8013bb2 <__dtoa_engine+0x46> @ imm = #0x1c
 8013b94: 4622         	mov	r2, r4
 8013b96: 431a         	orrs	r2, r3
 8013b98: d11b         	bne	0x8013bd2 <__dtoa_engine+0x66> @ imm = #0x36
 8013b9a: 2330         	movs	r3, #0x30
 8013b9c: 7143         	strb	r3, [r0, #0x5]
 8013b9e: 9b0a         	ldr	r3, [sp, #0x28]
 8013ba0: 6005         	str	r5, [r0]
 8013ba2: f043 0302    	orr	r3, r3, #0x2
 8013ba6: 7103         	strb	r3, [r0, #0x4]
 8013ba8: 2701         	movs	r7, #0x1
 8013baa: 4638         	mov	r0, r7
 8013bac: b01d         	add	sp, #0x74
 8013bae: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8013bb2: f240 72ff    	movw	r2, #0x7ff
 8013bb6: 4295         	cmp	r5, r2
 8013bb8: d14d         	bne	0x8013c56 <__dtoa_engine+0xea> @ imm = #0x9a
 8013bba: 9a05         	ldr	r2, [sp, #0x14]
 8013bbc: 4313         	orrs	r3, r2
 8013bbe: 9b0a         	ldr	r3, [sp, #0x28]
 8013bc0: 9a07         	ldr	r2, [sp, #0x1c]
 8013bc2: bf14         	ite	ne
 8013bc4: f043 0308    	orrne	r3, r3, #0x8
 8013bc8: f043 0304    	orreq	r3, r3, #0x4
 8013bcc: 7113         	strb	r3, [r2, #0x4]
 8013bce: 2700         	movs	r7, #0x0
 8013bd0: e7eb         	b	0x8013baa <__dtoa_engine+0x3e> @ imm = #-0x2a
 8013bd2: 9a05         	ldr	r2, [sp, #0x14]
 8013bd4: 4db2         	ldr	r5, [pc, #0x2c8]        @ 0x8013ea0 <__dtoa_engine+0x334>
 8013bd6: f002 0201    	and	r2, r2, #0x1
 8013bda: 9209         	str	r2, [sp, #0x24]
 8013bdc: 9a05         	ldr	r2, [sp, #0x14]
 8013bde: ea4f 0883    	lsl.w	r8, r3, #0x2
 8013be2: ea48 7892    	orr.w	r8, r8, r2, lsr #30
 8013be6: 0097         	lsls	r7, r2, #0x2
 8013be8: 2201         	movs	r2, #0x1
 8013bea: 469a         	mov	r10, r3
 8013bec: 4616         	mov	r6, r2
 8013bee: f1c5 0b00    	rsb.w	r11, r5, #0x0
 8013bf2: 4658         	mov	r0, r11
 8013bf4: 9208         	str	r2, [sp, #0x20]
 8013bf6: f000 fa17    	bl	0x8014028 <__log10Pow5> @ imm = #0x42e
 8013bfa: f1b5 3fff    	cmp.w	r5, #0xffffffff
 8013bfe: bfac         	ite	ge
 8013c00: 4681         	movge	r9, r0
 8013c02: f1a0 0901    	sublt.w	r9, r0, #0x1
 8013c06: ebab 0b09    	sub.w	r11, r11, r9
 8013c0a: eb09 0305    	add.w	r3, r9, r5
 8013c0e: 4658         	mov	r0, r11
 8013c10: 9306         	str	r3, [sp, #0x18]
 8013c12: f000 fa0f    	bl	0x8014034 <__pow5bits>  @ imm = #0x41e
 8013c16: a918         	add	r1, sp, #0x60
 8013c18: f1a0 057d    	sub.w	r5, r0, #0x7d
 8013c1c: 4658         	mov	r0, r11
 8013c1e: f000 fa29    	bl	0x8014074 <__double_computePow5> @ imm = #0x452
 8013c22: ab14         	add	r3, sp, #0x50
 8013c24: 9a08         	ldr	r2, [sp, #0x20]
 8013c26: 9301         	str	r3, [sp, #0x4]
 8013c28: eba9 0505    	sub.w	r5, r9, r5
 8013c2c: ab12         	add	r3, sp, #0x48
 8013c2e: 9202         	str	r2, [sp, #0x8]
 8013c30: 9300         	str	r3, [sp]
 8013c32: 9805         	ldr	r0, [sp, #0x14]
 8013c34: 462b         	mov	r3, r5
 8013c36: aa18         	add	r2, sp, #0x60
 8013c38: 4651         	mov	r1, r10
 8013c3a: f00c f899    	bl	0x801fd70 <mulShiftAll64> @ imm = #0xc132
 8013c3e: f1b9 0f01    	cmp.w	r9, #0x1
 8013c42: 4604         	mov	r4, r0
 8013c44: 460d         	mov	r5, r1
 8013c46: f200 80d8    	bhi.w	0x8013dfa <__dtoa_engine+0x28e> @ imm = #0x1b0
 8013c4a: 9b09         	ldr	r3, [sp, #0x24]
 8013c4c: 2b00         	cmp	r3, #0x0
 8013c4e: f040 80cb    	bne.w	0x8013de8 <__dtoa_engine+0x27c> @ imm = #0x196
 8013c52: 2701         	movs	r7, #0x1
 8013c54: e06f         	b	0x8013d36 <__dtoa_engine+0x1ca> @ imm = #0xde
 8013c56: 9a05         	ldr	r2, [sp, #0x14]
 8013c58: f002 0201    	and	r2, r2, #0x1
 8013c5c: 9209         	str	r2, [sp, #0x24]
 8013c5e: 9a05         	ldr	r2, [sp, #0x14]
 8013c60: f443 1a80    	orr	r10, r3, #0x100000
 8013c64: ea4f 088a    	lsl.w	r8, r10, #0x2
 8013c68: 4313         	orrs	r3, r2
 8013c6a: f2a5 4535    	subw	r5, r5, #0x435
 8013c6e: ea48 7892    	orr.w	r8, r8, r2, lsr #30
 8013c72: ea4f 0782    	lsl.w	r7, r2, #0x2
 8013c76: d14b         	bne	0x8013d10 <__dtoa_engine+0x1a4> @ imm = #0x96
 8013c78: f240 73fe    	movw	r3, #0x7fe
 8013c7c: 4219         	tst	r1, r3
 8013c7e: bf0c         	ite	eq
 8013c80: 2601         	moveq	r6, #0x1
 8013c82: 2600         	movne	r6, #0x0
 8013c84: 2d00         	cmp	r5, #0x0
 8013c86: 4632         	mov	r2, r6
 8013c88: dbb1         	blt	0x8013bee <__dtoa_engine+0x82> @ imm = #-0x9e
 8013c8a: 4628         	mov	r0, r5
 8013c8c: f000 f9c6    	bl	0x801401c <__log10Pow2> @ imm = #0x38c
 8013c90: 4603         	mov	r3, r0
 8013c92: 2d03         	cmp	r5, #0x3
 8013c94: bfc8         	it	gt
 8013c96: 3b01         	subgt	r3, #0x1
 8013c98: 4618         	mov	r0, r3
 8013c9a: 9306         	str	r3, [sp, #0x18]
 8013c9c: f000 f9ca    	bl	0x8014034 <__pow5bits>  @ imm = #0x394
 8013ca0: 9b06         	ldr	r3, [sp, #0x18]
 8013ca2: 307c         	adds	r0, #0x7c
 8013ca4: 1b5d         	subs	r5, r3, r5
 8013ca6: 4405         	add	r5, r0
 8013ca8: a918         	add	r1, sp, #0x60
 8013caa: 4618         	mov	r0, r3
 8013cac: f000 fa56    	bl	0x801415c <__double_computeInvPow5> @ imm = #0x4ac
 8013cb0: ab14         	add	r3, sp, #0x50
 8013cb2: 9301         	str	r3, [sp, #0x4]
 8013cb4: ab12         	add	r3, sp, #0x48
 8013cb6: 9300         	str	r3, [sp]
 8013cb8: 9805         	ldr	r0, [sp, #0x14]
 8013cba: 9602         	str	r6, [sp, #0x8]
 8013cbc: 462b         	mov	r3, r5
 8013cbe: aa18         	add	r2, sp, #0x60
 8013cc0: 4651         	mov	r1, r10
 8013cc2: f00c f855    	bl	0x801fd70 <mulShiftAll64> @ imm = #0xc0aa
 8013cc6: 9b06         	ldr	r3, [sp, #0x18]
 8013cc8: 2b15         	cmp	r3, #0x15
 8013cca: 4604         	mov	r4, r0
 8013ccc: 460d         	mov	r5, r1
 8013cce: f200 8088    	bhi.w	0x8013de2 <__dtoa_engine+0x276> @ imm = #0x110
 8013cd2: ab16         	add	r3, sp, #0x58
 8013cd4: 4a73         	ldr	r2, [pc, #0x1cc]        @ 0x8013ea4 <__dtoa_engine+0x338>
 8013cd6: 9300         	str	r3, [sp]
 8013cd8: 4638         	mov	r0, r7
 8013cda: f04f 33cc    	mov.w	r3, #0xcccccccc
 8013cde: 4641         	mov	r1, r8
 8013ce0: f00c f903    	bl	0x801feea <__umul128>   @ imm = #0xc206
 8013ce4: 9b16         	ldr	r3, [sp, #0x58]
 8013ce6: 9a17         	ldr	r2, [sp, #0x5c]
 8013ce8: 089b         	lsrs	r3, r3, #0x2
 8013cea: ea43 7382    	orr.w	r3, r3, r2, lsl #30
 8013cee: eb03 0383    	add.w	r3, r3, r3, lsl #2
 8013cf2: 42bb         	cmp	r3, r7
 8013cf4: e9dd 9a12    	ldrd	r9, r10, [sp, #72]
 8013cf8: d10c         	bne	0x8013d14 <__dtoa_engine+0x1a8> @ imm = #0x18
 8013cfa: 4638         	mov	r0, r7
 8013cfc: 4641         	mov	r1, r8
 8013cfe: f000 f9a1    	bl	0x8014044 <__pow5Factor> @ imm = #0x342
 8013d02: 9b06         	ldr	r3, [sp, #0x18]
 8013d04: 4283         	cmp	r3, r0
 8013d06: bf8c         	ite	hi
 8013d08: 2700         	movhi	r7, #0x0
 8013d0a: 2701         	movls	r7, #0x1
 8013d0c: 2600         	movs	r6, #0x0
 8013d0e: e012         	b	0x8013d36 <__dtoa_engine+0x1ca> @ imm = #0x24
 8013d10: 2601         	movs	r6, #0x1
 8013d12: e7b7         	b	0x8013c84 <__dtoa_engine+0x118> @ imm = #-0x92
 8013d14: 9b09         	ldr	r3, [sp, #0x24]
 8013d16: 2b00         	cmp	r3, #0x0
 8013d18: d153         	bne	0x8013dc2 <__dtoa_engine+0x256> @ imm = #0xa6
 8013d1a: 3f01         	subs	r7, #0x1
 8013d1c: f148 31ff    	adc	r1, r8, #0xffffffff
 8013d20: 1bb8         	subs	r0, r7, r6
 8013d22: f161 0100    	sbc	r1, r1, #0x0
 8013d26: f000 f98d    	bl	0x8014044 <__pow5Factor> @ imm = #0x31a
 8013d2a: 9b06         	ldr	r3, [sp, #0x18]
 8013d2c: 9f09         	ldr	r7, [sp, #0x24]
 8013d2e: 4283         	cmp	r3, r0
 8013d30: bf8c         	ite	hi
 8013d32: 2600         	movhi	r6, #0x0
 8013d34: 2601         	movls	r6, #0x1
 8013d36: 9b0d         	ldr	r3, [sp, #0x34]
 8013d38: 2b00         	cmp	r3, #0x0
 8013d3a: f040 8093    	bne.w	0x8013e64 <__dtoa_engine+0x2f8> @ imm = #0x126
 8013d3e: f8dd b02c    	ldr.w	r11, [sp, #0x2c]
 8013d42: f04f 0800    	mov.w	r8, #0x0
 8013d46: f8cd 8020    	str.w	r8, [sp, #0x20]
 8013d4a: f8cd 8014    	str.w	r8, [sp, #0x14]
 8013d4e: f04f 0a0a    	mov.w	r10, #0xa
 8013d52: e9dd 0112    	ldrd	r0, r1, [sp, #72]
 8013d56: f7ff fef5    	bl	0x8013b44 <div10>       @ imm = #-0x216
 8013d5a: 9b14         	ldr	r3, [sp, #0x50]
 8013d5c: 9310         	str	r3, [sp, #0x40]
 8013d5e: e9cd 010e    	strd	r0, r1, [sp, #56]
 8013d62: 4618         	mov	r0, r3
 8013d64: 9915         	ldr	r1, [sp, #0x54]
 8013d66: f7ff feed    	bl	0x8013b44 <div10>       @ imm = #-0x226
 8013d6a: 9b0e         	ldr	r3, [sp, #0x38]
 8013d6c: 9a0f         	ldr	r2, [sp, #0x3c]
 8013d6e: 9111         	str	r1, [sp, #0x44]
 8013d70: 4298         	cmp	r0, r3
 8013d72: 460b         	mov	r3, r1
 8013d74: 4193         	sbcs	r3, r2
 8013d76: 4681         	mov	r9, r0
 8013d78: f080 808e    	bhs.w	0x8013e98 <__dtoa_engine+0x32c> @ imm = #0x11c
 8013d7c: 4620         	mov	r0, r4
 8013d7e: 4629         	mov	r1, r5
 8013d80: f7ff fee0    	bl	0x8013b44 <div10>       @ imm = #-0x240
 8013d84: 9a10         	ldr	r2, [sp, #0x40]
 8013d86: fb0a f309    	mul	r3, r10, r9
 8013d8a: 4293         	cmp	r3, r2
 8013d8c: bf14         	ite	ne
 8013d8e: 2600         	movne	r6, #0x0
 8013d90: f006 0601    	andeq	r6, r6, #0x1
 8013d94: 9b0e         	ldr	r3, [sp, #0x38]
 8013d96: 9312         	str	r3, [sp, #0x48]
 8013d98: 9b0f         	ldr	r3, [sp, #0x3c]
 8013d9a: e9cd 3913    	strd	r3, r9, [sp, #76]
 8013d9e: 9b11         	ldr	r3, [sp, #0x44]
 8013da0: 9315         	str	r3, [sp, #0x54]
 8013da2: 9b08         	ldr	r3, [sp, #0x20]
 8013da4: f1b8 0f00    	cmp.w	r8, #0x0
 8013da8: bf14         	ite	ne
 8013daa: 2700         	movne	r7, #0x0
 8013dac: f007 0701    	andeq	r7, r7, #0x1
 8013db0: 3301         	adds	r3, #0x1
 8013db2: fb0a 4810    	mls	r8, r10, r0, r4
 8013db6: fa5f f888    	uxtb.w	r8, r8
 8013dba: 9308         	str	r3, [sp, #0x20]
 8013dbc: 4604         	mov	r4, r0
 8013dbe: 460d         	mov	r5, r1
 8013dc0: e7c7         	b	0x8013d52 <__dtoa_engine+0x1e6> @ imm = #-0x72
 8013dc2: 1cb8         	adds	r0, r7, #0x2
 8013dc4: f148 0100    	adc	r1, r8, #0x0
 8013dc8: f000 f93c    	bl	0x8014044 <__pow5Factor> @ imm = #0x278
 8013dcc: 9b06         	ldr	r3, [sp, #0x18]
 8013dce: 4283         	cmp	r3, r0
 8013dd0: bf8c         	ite	hi
 8013dd2: 2000         	movhi	r0, #0x0
 8013dd4: 2001         	movls	r0, #0x1
 8013dd6: ebb9 0000    	subs.w	r0, r9, r0
 8013dda: f16a 0200    	sbc	r2, r10, #0x0
 8013dde: e9cd 0212    	strd	r0, r2, [sp, #72]
 8013de2: 2700         	movs	r7, #0x0
 8013de4: 463e         	mov	r6, r7
 8013de6: e7a6         	b	0x8013d36 <__dtoa_engine+0x1ca> @ imm = #-0xb4
 8013de8: 9b12         	ldr	r3, [sp, #0x48]
 8013dea: 9a13         	ldr	r2, [sp, #0x4c]
 8013dec: 3b01         	subs	r3, #0x1
 8013dee: f142 32ff    	adc	r2, r2, #0xffffffff
 8013df2: e9cd 3212    	strd	r3, r2, [sp, #72]
 8013df6: 2701         	movs	r7, #0x1
 8013df8: e788         	b	0x8013d0c <__dtoa_engine+0x1a0> @ imm = #-0xf0
 8013dfa: f1b9 0f3e    	cmp.w	r9, #0x3e
 8013dfe: d8f0         	bhi	0x8013de2 <__dtoa_engine+0x276> @ imm = #-0x20
 8013e00: f04f 33ff    	mov.w	r3, #0xffffffff
 8013e04: f1a9 0020    	sub.w	r0, r9, #0x20
 8013e08: fa03 f209    	lsl.w	r2, r3, r9
 8013e0c: fa03 f000    	lsl.w	r0, r3, r0
 8013e10: f1c9 0120    	rsb.w	r1, r9, #0x20
 8013e14: fa23 f101    	lsr.w	r1, r3, r1
 8013e18: 4302         	orrs	r2, r0
 8013e1a: 430a         	orrs	r2, r1
 8013e1c: fa03 f309    	lsl.w	r3, r3, r9
 8013e20: ea27 0703    	bic.w	r7, r7, r3
 8013e24: ea28 0802    	bic.w	r8, r8, r2
 8013e28: ea57 0708    	orrs.w	r7, r7, r8
 8013e2c: bf0c         	ite	eq
 8013e2e: 2701         	moveq	r7, #0x1
 8013e30: 2700         	movne	r7, #0x0
 8013e32: e76b         	b	0x8013d0c <__dtoa_engine+0x1a0> @ imm = #-0x12a
 8013e34: fb00 fc02    	mul	r12, r0, r2
 8013e38: fba1 1200    	umull	r1, r2, r1, r0
 8013e3c: 3301         	adds	r3, #0x1
 8013e3e: 4462         	add	r2, r12
 8013e40: 428c         	cmp	r4, r1
 8013e42: eb75 0c02    	sbcs.w	r12, r5, r2
 8013e46: d2f5         	bhs	0x8013e34 <__dtoa_engine+0x2c8> @ imm = #-0x16
 8013e48: 9a06         	ldr	r2, [sp, #0x18]
 8013e4a: 4413         	add	r3, r2
 8013e4c: 9a0c         	ldr	r2, [sp, #0x30]
 8013e4e: 4413         	add	r3, r2
 8013e50: 0fd2         	lsrs	r2, r2, #0x1f
 8013e52: 4293         	cmp	r3, r2
 8013e54: bfb8         	it	lt
 8013e56: 4613         	movlt	r3, r2
 8013e58: 9a0b         	ldr	r2, [sp, #0x2c]
 8013e5a: 429a         	cmp	r2, r3
 8013e5c: bfa8         	it	ge
 8013e5e: 461a         	movge	r2, r3
 8013e60: 4693         	mov	r11, r2
 8013e62: e76e         	b	0x8013d42 <__dtoa_engine+0x1d6> @ imm = #-0x124
 8013e64: 210a         	movs	r1, #0xa
 8013e66: 2200         	movs	r2, #0x0
 8013e68: 2301         	movs	r3, #0x1
 8013e6a: 4608         	mov	r0, r1
 8013e6c: e7e8         	b	0x8013e40 <__dtoa_engine+0x2d4> @ imm = #-0x30
 8013e6e: fb0a f003    	mul	r0, r10, r3
 8013e72: fba2 230a    	umull	r2, r3, r2, r10
 8013e76: 3101         	adds	r1, #0x1
 8013e78: 4403         	add	r3, r0
 8013e7a: 4294         	cmp	r4, r2
 8013e7c: eb75 0003    	sbcs.w	r0, r5, r3
 8013e80: d2f5         	bhs	0x8013e6e <__dtoa_engine+0x302> @ imm = #-0x16
 8013e82: 4559         	cmp	r1, r11
 8013e84: dd10         	ble	0x8013ea8 <__dtoa_engine+0x33c> @ imm = #0x20
 8013e86: f1bb 0f00    	cmp.w	r11, #0x0
 8013e8a: d102         	bne	0x8013e92 <__dtoa_engine+0x326> @ imm = #0x4
 8013e8c: ea54 0305    	orrs.w	r3, r4, r5
 8013e90: d00a         	beq	0x8013ea8 <__dtoa_engine+0x33c> @ imm = #0x14
 8013e92: 2301         	movs	r3, #0x1
 8013e94: 9305         	str	r3, [sp, #0x14]
 8013e96: e771         	b	0x8013d7c <__dtoa_engine+0x210> @ imm = #-0x11e
 8013e98: 220a         	movs	r2, #0xa
 8013e9a: 2300         	movs	r3, #0x0
 8013e9c: 2101         	movs	r1, #0x1
 8013e9e: e7ec         	b	0x8013e7a <__dtoa_engine+0x30e> @ imm = #-0x28

08013ea0 <$d>:
 8013ea0: cc fb ff ff  	.word	0xfffffbcc
 8013ea4: cd cc cc cc  	.word	0xcccccccd

08013ea8 <$t>:
 8013ea8: b37e         	cbz	r6, 0x8013f0a <__dtoa_engine+0x39e> @ imm = #0x5e
 8013eaa: f04f 0a0a    	mov.w	r10, #0xa
 8013eae: 9b14         	ldr	r3, [sp, #0x50]
 8013eb0: 9915         	ldr	r1, [sp, #0x54]
 8013eb2: 930f         	str	r3, [sp, #0x3c]
 8013eb4: 4618         	mov	r0, r3
 8013eb6: f7ff fe45    	bl	0x8013b44 <div10>       @ imm = #-0x376
 8013eba: 9b0f         	ldr	r3, [sp, #0x3c]
 8013ebc: 910e         	str	r1, [sp, #0x38]
 8013ebe: fb0a f200    	mul	r2, r10, r0
 8013ec2: 429a         	cmp	r2, r3
 8013ec4: 4681         	mov	r9, r0
 8013ec6: d120         	bne	0x8013f0a <__dtoa_engine+0x39e> @ imm = #0x40
 8013ec8: e9dd 0112    	ldrd	r0, r1, [sp, #72]
 8013ecc: f7ff fe3a    	bl	0x8013b44 <div10>       @ imm = #-0x38c
 8013ed0: 9010         	str	r0, [sp, #0x40]
 8013ed2: 910f         	str	r1, [sp, #0x3c]
 8013ed4: 4620         	mov	r0, r4
 8013ed6: 4629         	mov	r1, r5
 8013ed8: f7ff fe34    	bl	0x8013b44 <div10>       @ imm = #-0x398
 8013edc: 9b0f         	ldr	r3, [sp, #0x3c]
 8013ede: 9a10         	ldr	r2, [sp, #0x40]
 8013ee0: 9212         	str	r2, [sp, #0x48]
 8013ee2: e9cd 3913    	strd	r3, r9, [sp, #76]
 8013ee6: 9b0e         	ldr	r3, [sp, #0x38]
 8013ee8: 9315         	str	r3, [sp, #0x54]
 8013eea: 9b08         	ldr	r3, [sp, #0x20]
 8013eec: f1b8 0f00    	cmp.w	r8, #0x0
 8013ef0: bf14         	ite	ne
 8013ef2: 2700         	movne	r7, #0x0
 8013ef4: f007 0701    	andeq	r7, r7, #0x1
 8013ef8: 3301         	adds	r3, #0x1
 8013efa: fb0a 4810    	mls	r8, r10, r0, r4
 8013efe: fa5f f888    	uxtb.w	r8, r8
 8013f02: 9308         	str	r3, [sp, #0x20]
 8013f04: 4604         	mov	r4, r0
 8013f06: 460d         	mov	r5, r1
 8013f08: e7d1         	b	0x8013eae <__dtoa_engine+0x342> @ imm = #-0x5e
 8013f0a: 9b06         	ldr	r3, [sp, #0x18]
 8013f0c: 9a08         	ldr	r2, [sp, #0x20]
 8013f0e: 4413         	add	r3, r2
 8013f10: 4699         	mov	r9, r3
 8013f12: 2f00         	cmp	r7, #0x0
 8013f14: d05a         	beq	0x8013fcc <__dtoa_engine+0x460> @ imm = #0xb4
 8013f16: f1b8 0f05    	cmp.w	r8, #0x5
 8013f1a: d157         	bne	0x8013fcc <__dtoa_engine+0x460> @ imm = #0xae
 8013f1c: f014 0301    	ands	r3, r4, #0x1
 8013f20: d14a         	bne	0x8013fb8 <__dtoa_engine+0x44c> @ imm = #0x94
 8013f22: 9a05         	ldr	r2, [sp, #0x14]
 8013f24: b932         	cbnz	r2, 0x8013f34 <__dtoa_engine+0x3c8> @ imm = #0xc
 8013f26: e9dd 2314    	ldrd	r2, r3, [sp, #80]
 8013f2a: 429d         	cmp	r5, r3
 8013f2c: bf08         	it	eq
 8013f2e: 4294         	cmpeq	r4, r2
 8013f30: d05f         	beq	0x8013ff2 <__dtoa_engine+0x486> @ imm = #0xbe
 8013f32: 9b05         	ldr	r3, [sp, #0x14]
 8013f34: 1918         	adds	r0, r3, r4
 8013f36: f04f 040a    	mov.w	r4, #0xa
 8013f3a: f145 0100    	adc	r1, r5, #0x0
 8013f3e: 2200         	movs	r2, #0x0
 8013f40: 2601         	movs	r6, #0x1
 8013f42: 4625         	mov	r5, r4
 8013f44: 42a0         	cmp	r0, r4
 8013f46: eb71 0702    	sbcs.w	r7, r1, r2
 8013f4a: d255         	bhs	0x8013ff8 <__dtoa_engine+0x48c> @ imm = #0xaa
 8013f4c: b1f3         	cbz	r3, 0x8013f8c <__dtoa_engine+0x420> @ imm = #0x3c
 8013f4e: 45b3         	cmp	r11, r6
 8013f50: da1c         	bge	0x8013f8c <__dtoa_engine+0x420> @ imm = #0x38
 8013f52: 9b0d         	ldr	r3, [sp, #0x34]
 8013f54: b173         	cbz	r3, 0x8013f74 <__dtoa_engine+0x408> @ imm = #0x1c
 8013f56: 9a0c         	ldr	r2, [sp, #0x30]
 8013f58: eb06 0309    	add.w	r3, r6, r9
 8013f5c: 441a         	add	r2, r3
 8013f5e: 4613         	mov	r3, r2
 8013f60: 2a01         	cmp	r2, #0x1
 8013f62: 9a0b         	ldr	r2, [sp, #0x2c]
 8013f64: bfb8         	it	lt
 8013f66: 2301         	movlt	r3, #0x1
 8013f68: 429a         	cmp	r2, r3
 8013f6a: bfa8         	it	ge
 8013f6c: 461a         	movge	r2, r3
 8013f6e: 4296         	cmp	r6, r2
 8013f70: 4693         	mov	r11, r2
 8013f72: dd0b         	ble	0x8013f8c <__dtoa_engine+0x420> @ imm = #0x16
 8013f74: 3005         	adds	r0, #0x5
 8013f76: f04f 020a    	mov.w	r2, #0xa
 8013f7a: f04f 0300    	mov.w	r3, #0x0
 8013f7e: f141 0100    	adc	r1, r1, #0x0
 8013f82: f7ec fd6f    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x13522
 8013f86: f109 0901    	add.w	r9, r9, #0x1
 8013f8a: 3e01         	subs	r6, #0x1
 8013f8c: 455e         	cmp	r6, r11
 8013f8e: bfa8         	it	ge
 8013f90: 465e         	movge	r6, r11
 8013f92: b237         	sxth	r7, r6
 8013f94: fa0f f989    	sxth.w	r9, r9
 8013f98: 9b07         	ldr	r3, [sp, #0x1c]
 8013f9a: fa09 f686    	sxtah	r6, r9, r6
 8013f9e: f107 0805    	add.w	r8, r7, #0x5
 8013fa2: 3e01         	subs	r6, #0x1
 8013fa4: 4498         	add	r8, r3
 8013fa6: f04f 0900    	mov.w	r9, #0x0
 8013faa: 45b9         	cmp	r9, r7
 8013fac: db2b         	blt	0x8014006 <__dtoa_engine+0x49a> @ imm = #0x56
 8013fae: 9b07         	ldr	r3, [sp, #0x1c]
 8013fb0: 9a0a         	ldr	r2, [sp, #0x28]
 8013fb2: 601e         	str	r6, [r3]
 8013fb4: 711a         	strb	r2, [r3, #0x4]
 8013fb6: e5f8         	b	0x8013baa <__dtoa_engine+0x3e> @ imm = #-0x410
 8013fb8: 9b05         	ldr	r3, [sp, #0x14]
 8013fba: b92b         	cbnz	r3, 0x8013fc8 <__dtoa_engine+0x45c> @ imm = #0xa
 8013fbc: e9dd 2314    	ldrd	r2, r3, [sp, #80]
 8013fc0: 429d         	cmp	r5, r3
 8013fc2: bf08         	it	eq
 8013fc4: 4294         	cmpeq	r4, r2
 8013fc6: d009         	beq	0x8013fdc <__dtoa_engine+0x470> @ imm = #0x12
 8013fc8: 2301         	movs	r3, #0x1
 8013fca: e7b3         	b	0x8013f34 <__dtoa_engine+0x3c8> @ imm = #-0x9a
 8013fcc: 9b05         	ldr	r3, [sp, #0x14]
 8013fce: b953         	cbnz	r3, 0x8013fe6 <__dtoa_engine+0x47a> @ imm = #0x14
 8013fd0: e9dd 2314    	ldrd	r2, r3, [sp, #80]
 8013fd4: 429d         	cmp	r5, r3
 8013fd6: bf08         	it	eq
 8013fd8: 4294         	cmpeq	r4, r2
 8013fda: d104         	bne	0x8013fe6 <__dtoa_engine+0x47a> @ imm = #0x8
 8013fdc: 9b09         	ldr	r3, [sp, #0x24]
 8013fde: 2b00         	cmp	r3, #0x0
 8013fe0: d1f2         	bne	0x8013fc8 <__dtoa_engine+0x45c> @ imm = #-0x1c
 8013fe2: 2e00         	cmp	r6, #0x0
 8013fe4: d0f0         	beq	0x8013fc8 <__dtoa_engine+0x45c> @ imm = #-0x20
 8013fe6: f1b8 0f04    	cmp.w	r8, #0x4
 8013fea: bf94         	ite	ls
 8013fec: 2300         	movls	r3, #0x0
 8013fee: 2301         	movhi	r3, #0x1
 8013ff0: e7a0         	b	0x8013f34 <__dtoa_engine+0x3c8> @ imm = #-0xc0
 8013ff2: f04f 0804    	mov.w	r8, #0x4
 8013ff6: e7f1         	b	0x8013fdc <__dtoa_engine+0x470> @ imm = #-0x1e
 8013ff8: fb05 f702    	mul	r7, r5, r2
 8013ffc: fba4 4205    	umull	r4, r2, r4, r5
 8014000: 3601         	adds	r6, #0x1
 8014002: 443a         	add	r2, r7
 8014004: e79e         	b	0x8013f44 <__dtoa_engine+0x3d8> @ imm = #-0xc4
 8014006: 220a         	movs	r2, #0xa
 8014008: 2300         	movs	r3, #0x0
 801400a: f7ec fd2b    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x135aa
 801400e: 3230         	adds	r2, #0x30
 8014010: f808 2d01    	strb	r2, [r8, #-1]!
 8014014: f109 0901    	add.w	r9, r9, #0x1
 8014018: e7c7         	b	0x8013faa <__dtoa_engine+0x43e> @ imm = #-0x72
 801401a: bf00         	nop

0801401c <__log10Pow2>:
 801401c: 4b01         	ldr	r3, [pc, #0x4]          @ 0x8014024 <__log10Pow2+0x8>
 801401e: 4358         	muls	r0, r3, r0
 8014020: 0c80         	lsrs	r0, r0, #0x12
 8014022: 4770         	bx	lr

08014024 <$d>:
 8014024: 41 34 01 00  	.word	0x00013441

08014028 <__log10Pow5>:
 8014028: 4b01         	ldr	r3, [pc, #0x4]          @ 0x8014030 <__log10Pow5+0x8>
 801402a: 4358         	muls	r0, r3, r0
 801402c: 0d00         	lsrs	r0, r0, #0x14
 801402e: 4770         	bx	lr

08014030 <$d>:
 8014030: fb 2e 0b 00  	.word	0x000b2efb

08014034 <__pow5bits>:
 8014034: 4b02         	ldr	r3, [pc, #0x8]          @ 0x8014040 <__pow5bits+0xc>
 8014036: 4358         	muls	r0, r3, r0
 8014038: 0cc0         	lsrs	r0, r0, #0x13
 801403a: 3001         	adds	r0, #0x1
 801403c: 4770         	bx	lr
 801403e: bf00         	nop

08014040 <$d>:
 8014040: 4f 93 12 00  	.word	0x0012934f

08014044 <__pow5Factor>:
 8014044: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8014070 <__pow5Factor+0x2c>
 8014046: b570         	push	{r4, r5, r6, lr}
 8014048: 4603         	mov	r3, r0
 801404a: f04f 36cc    	mov.w	r6, #0xcccccccc
 801404e: 2000         	movs	r0, #0x0
 8014050: f04f 3533    	mov.w	r5, #0x33333333
 8014054: fb06 f403    	mul	r4, r6, r3
 8014058: fb02 4401    	mla	r4, r2, r1, r4
 801405c: fba3 3102    	umull	r3, r1, r3, r2
 8014060: 4421         	add	r1, r4
 8014062: 429d         	cmp	r5, r3
 8014064: eb75 0401    	sbcs.w	r4, r5, r1
 8014068: d301         	blo	0x801406e <__pow5Factor+0x2a> @ imm = #0x2
 801406a: 3001         	adds	r0, #0x1
 801406c: e7f2         	b	0x8014054 <__pow5Factor+0x10> @ imm = #-0x1c
 801406e: bd70         	pop	{r4, r5, r6, pc}

08014070 <$d>:
 8014070: cd cc cc cc  	.word	0xcccccccd

08014074 <__double_computePow5>:
 8014074: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8014078: 231a         	movs	r3, #0x1a
 801407a: 4e35         	ldr	r6, [pc, #0xd4]         @ 0x8014150 <__double_computePow5+0xdc>
 801407c: fbb0 faf3    	udiv	r10, r0, r3
 8014080: fb03 031a    	mls	r3, r3, r10, r0
 8014084: b089         	sub	sp, #0x24
 8014086: 4604         	mov	r4, r0
 8014088: 460d         	mov	r5, r1
 801408a: eb06 160a    	add.w	r6, r6, r10, lsl #4
 801408e: b953         	cbnz	r3, 0x80140a6 <__double_computePow5+0x32> @ imm = #0x14
 8014090: e9d6 2300    	ldrd	r2, r3, [r6]
 8014094: e9c1 2300    	strd	r2, r3, [r1]
 8014098: e9d6 0102    	ldrd	r0, r1, [r6, #8]
 801409c: e9c5 0102    	strd	r0, r1, [r5, #8]
 80140a0: b009         	add	sp, #0x24
 80140a2: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80140a6: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x8014154 <__double_computePow5+0xe0>
 80140a8: eb02 03c3    	add.w	r3, r2, r3, lsl #3
 80140ac: e9d3 8900    	ldrd	r8, r9, [r3]
 80140b0: ab04         	add	r3, sp, #0x10
 80140b2: 9300         	str	r3, [sp]
 80140b4: e9d6 2302    	ldrd	r2, r3, [r6, #8]
 80140b8: 4640         	mov	r0, r8
 80140ba: 4649         	mov	r1, r9
 80140bc: f00b ff15    	bl	0x801feea <__umul128>   @ imm = #0xbe2a
 80140c0: ab06         	add	r3, sp, #0x18
 80140c2: 9300         	str	r3, [sp]
 80140c4: e9d6 2300    	ldrd	r2, r3, [r6]
 80140c8: 4683         	mov	r11, r0
 80140ca: 460f         	mov	r7, r1
 80140cc: 4640         	mov	r0, r8
 80140ce: 4649         	mov	r1, r9
 80140d0: f00b ff0b    	bl	0x801feea <__umul128>   @ imm = #0xbe16
 80140d4: e9dd 6206    	ldrd	r6, r2, [sp, #24]
 80140d8: eb16 060b    	adds.w	r6, r6, r11
 80140dc: eb52 0807    	adcs.w	r8, r2, r7
 80140e0: f04f 0300    	mov.w	r3, #0x0
 80140e4: bf28         	it	hs
 80140e6: 2301         	movhs	r3, #0x1
 80140e8: 4681         	mov	r9, r0
 80140ea: b133         	cbz	r3, 0x80140fa <__double_computePow5+0x86> @ imm = #0xc
 80140ec: 9b04         	ldr	r3, [sp, #0x10]
 80140ee: 9a05         	ldr	r2, [sp, #0x14]
 80140f0: 3301         	adds	r3, #0x1
 80140f2: f142 0200    	adc	r2, r2, #0x0
 80140f6: e9cd 3204    	strd	r3, r2, [sp, #16]
 80140fa: 4620         	mov	r0, r4
 80140fc: 9103         	str	r1, [sp, #0xc]
 80140fe: f7ff ff99    	bl	0x8014034 <__pow5bits>  @ imm = #-0xce
 8014102: 4607         	mov	r7, r0
 8014104: 201a         	movs	r0, #0x1a
 8014106: fb00 f00a    	mul	r0, r0, r10
 801410a: f7ff ff93    	bl	0x8014034 <__pow5bits>  @ imm = #-0xda
 801410e: 1a3f         	subs	r7, r7, r0
 8014110: 4632         	mov	r2, r6
 8014112: 4643         	mov	r3, r8
 8014114: 9903         	ldr	r1, [sp, #0xc]
 8014116: 9700         	str	r7, [sp]
 8014118: 4648         	mov	r0, r9
 801411a: f00b ff01    	bl	0x801ff20 <__shiftright128> @ imm = #0xbe02
 801411e: ea4f 1c14    	lsr.w	r12, r4, #0x4
 8014122: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8014158 <__double_computePow5+0xe4>
 8014124: 0064         	lsls	r4, r4, #0x1
 8014126: f004 031e    	and	r3, r4, #0x1e
 801412a: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 801412e: 40dc         	lsrs	r4, r3
 8014130: f004 0403    	and	r4, r4, #0x3
 8014134: 1824         	adds	r4, r4, r0
 8014136: f141 0100    	adc	r1, r1, #0x0
 801413a: e9c5 4100    	strd	r4, r1, [r5]
 801413e: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 8014142: 9700         	str	r7, [sp]
 8014144: 4630         	mov	r0, r6
 8014146: 4641         	mov	r1, r8
 8014148: f00b feea    	bl	0x801ff20 <__shiftright128> @ imm = #0xbdd4
 801414c: e7a6         	b	0x801409c <__double_computePow5+0x28> @ imm = #-0xb4
 801414e: bf00         	nop

08014150 <$d>:
 8014150: 90 23 02 08  	.word	0x08022390
 8014154: c0 22 02 08  	.word	0x080222c0
 8014158: 10 2f 02 08  	.word	0x08022f10

0801415c <__double_computeInvPow5>:
 801415c: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8014160: 271a         	movs	r7, #0x1a
 8014162: f8df a0ec    	ldr.w	r10, [pc, #0xec]        @ 0x8014250 <__double_computeInvPow5+0xf4>
 8014166: f100 0519    	add.w	r5, r0, #0x19
 801416a: fbb5 f5f7    	udiv	r5, r5, r7
 801416e: 436f         	muls	r7, r5, r7
 8014170: 1a3a         	subs	r2, r7, r0
 8014172: ea4f 1b05    	lsl.w	r11, r5, #0x4
 8014176: b089         	sub	sp, #0x24
 8014178: 4604         	mov	r4, r0
 801417a: 460e         	mov	r6, r1
 801417c: eb0a 1505    	add.w	r5, r10, r5, lsl #4
 8014180: d10a         	bne	0x8014198 <__double_computeInvPow5+0x3c> @ imm = #0x14
 8014182: e9d5 2300    	ldrd	r2, r3, [r5]
 8014186: e9c1 2300    	strd	r2, r3, [r1]
 801418a: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 801418e: e9c6 0102    	strd	r0, r1, [r6, #8]
 8014192: b009         	add	sp, #0x24
 8014194: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8014198: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8014248 <__double_computeInvPow5+0xec>
 801419a: eb03 03c2    	add.w	r3, r3, r2, lsl #3
 801419e: e9d3 8900    	ldrd	r8, r9, [r3]
 80141a2: ab04         	add	r3, sp, #0x10
 80141a4: 9300         	str	r3, [sp]
 80141a6: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 80141aa: 4640         	mov	r0, r8
 80141ac: 4649         	mov	r1, r9
 80141ae: f00b fe9c    	bl	0x801feea <__umul128>   @ imm = #0xbd38
 80141b2: f85a 200b    	ldr.w	r2, [r10, r11]
 80141b6: 686b         	ldr	r3, [r5, #0x4]
 80141b8: 3a01         	subs	r2, #0x1
 80141ba: e9cd 0102    	strd	r0, r1, [sp, #8]
 80141be: a906         	add	r1, sp, #0x18
 80141c0: f163 0300    	sbc	r3, r3, #0x0
 80141c4: 9100         	str	r1, [sp]
 80141c6: 4640         	mov	r0, r8
 80141c8: 4649         	mov	r1, r9
 80141ca: f00b fe8e    	bl	0x801feea <__umul128>   @ imm = #0xbd1c
 80141ce: e9dd 5206    	ldrd	r5, r2, [sp, #24]
 80141d2: 468a         	mov	r10, r1
 80141d4: 9902         	ldr	r1, [sp, #0x8]
 80141d6: 186d         	adds	r5, r5, r1
 80141d8: 9903         	ldr	r1, [sp, #0xc]
 80141da: eb52 0801    	adcs.w	r8, r2, r1
 80141de: f04f 0300    	mov.w	r3, #0x0
 80141e2: bf28         	it	hs
 80141e4: 2301         	movhs	r3, #0x1
 80141e6: 4681         	mov	r9, r0
 80141e8: b133         	cbz	r3, 0x80141f8 <__double_computeInvPow5+0x9c> @ imm = #0xc
 80141ea: 9b04         	ldr	r3, [sp, #0x10]
 80141ec: 9a05         	ldr	r2, [sp, #0x14]
 80141ee: 3301         	adds	r3, #0x1
 80141f0: f142 0200    	adc	r2, r2, #0x0
 80141f4: e9cd 3204    	strd	r3, r2, [sp, #16]
 80141f8: 4638         	mov	r0, r7
 80141fa: f7ff ff1b    	bl	0x8014034 <__pow5bits>  @ imm = #-0x1ca
 80141fe: 4607         	mov	r7, r0
 8014200: 4620         	mov	r0, r4
 8014202: f7ff ff17    	bl	0x8014034 <__pow5bits>  @ imm = #-0x1d2
 8014206: 1a3f         	subs	r7, r7, r0
 8014208: 462a         	mov	r2, r5
 801420a: 4643         	mov	r3, r8
 801420c: 9700         	str	r7, [sp]
 801420e: 4648         	mov	r0, r9
 8014210: 4651         	mov	r1, r10
 8014212: f00b fe85    	bl	0x801ff20 <__shiftright128> @ imm = #0xbd0a
 8014216: ea4f 1c14    	lsr.w	r12, r4, #0x4
 801421a: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x801424c <__double_computeInvPow5+0xf0>
 801421c: 0064         	lsls	r4, r4, #0x1
 801421e: f004 031e    	and	r3, r4, #0x1e
 8014222: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 8014226: 40dc         	lsrs	r4, r3
 8014228: f004 0403    	and	r4, r4, #0x3
 801422c: 3401         	adds	r4, #0x1
 801422e: 1824         	adds	r4, r4, r0
 8014230: f141 0100    	adc	r1, r1, #0x0
 8014234: e9c6 4100    	strd	r4, r1, [r6]
 8014238: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 801423c: 9700         	str	r7, [sp]
 801423e: 4628         	mov	r0, r5
 8014240: 4641         	mov	r1, r8
 8014242: f00b fe6d    	bl	0x801ff20 <__shiftright128> @ imm = #0xbcda
 8014246: e7a2         	b	0x801418e <__double_computeInvPow5+0x32> @ imm = #-0xbc

08014248 <$d>:
 8014248: c0 22 02 08  	.word	0x080222c0
 801424c: 64 2f 02 08  	.word	0x08022f64
 8014250: 60 24 02 08  	.word	0x08022460

08014254 <acosf>:
 8014254: ee10 3a10    	vmov	r3, s0
 8014258: f023 4200    	bic	r2, r3, #0x80000000
 801425c: f1b2 5f7e    	cmp.w	r2, #0x3f800000
 8014260: eef0 7a40    	vmov.f32	s15, s0
 8014264: d109         	bne	0x801427a <acosf+0x26>  @ imm = #0x12
 8014266: 2b00         	cmp	r3, #0x0
 8014268: f300 80c0    	bgt.w	0x80143ec <acosf+0x198> @ imm = #0x180
 801426c: eddf 7a61    	vldr	s15, [pc, #388]         @ 0x80143f4 <acosf+0x1a0>
 8014270: ed9f 0a61    	vldr	s0, [pc, #388]          @ 0x80143f8 <acosf+0x1a4>
 8014274: ee30 0a27    	vadd.f32	s0, s0, s15
 8014278: 4770         	bx	lr
 801427a: d901         	bls	0x8014280 <acosf+0x2c>  @ imm = #0x2
 801427c: f000 bc54    	b.w	0x8014b28 <__math_invalidf> @ imm = #0x8a8
 8014280: f1b2 5f7c    	cmp.w	r2, #0x3f000000
 8014284: d23e         	bhs	0x8014304 <acosf+0xb0>  @ imm = #0x7c
 8014286: f1b2 5f0c    	cmp.w	r2, #0x23000000
 801428a: ed9f 0a5c    	vldr	s0, [pc, #368]          @ 0x80143fc <acosf+0x1a8>
 801428e: eddf 6a5c    	vldr	s13, [pc, #368]         @ 0x8014400 <acosf+0x1ac>
 8014292: d802         	bhi	0x801429a <acosf+0x46>  @ imm = #0x4
 8014294: ee30 0a26    	vadd.f32	s0, s0, s13
 8014298: 4770         	bx	lr
 801429a: ee27 7aa7    	vmul.f32	s14, s15, s15
 801429e: eddf 5a59    	vldr	s11, [pc, #356]         @ 0x8014404 <acosf+0x1b0>
 80142a2: ed9f 6a59    	vldr	s12, [pc, #356]         @ 0x8014408 <acosf+0x1b4>
 80142a6: ed9f 5a59    	vldr	s10, [pc, #356]         @ 0x801440c <acosf+0x1b8>
 80142aa: ee07 6a25    	vmla.f32	s12, s14, s11
 80142ae: eddf 5a58    	vldr	s11, [pc, #352]         @ 0x8014410 <acosf+0x1bc>
 80142b2: ee56 5a07    	vnmls.f32	s11, s12, s14
 80142b6: ed9f 6a57    	vldr	s12, [pc, #348]         @ 0x8014414 <acosf+0x1c0>
 80142ba: ee05 6a87    	vmla.f32	s12, s11, s14
 80142be: eddf 5a56    	vldr	s11, [pc, #344]         @ 0x8014418 <acosf+0x1c4>
 80142c2: ee56 5a07    	vnmls.f32	s11, s12, s14
 80142c6: ed9f 6a55    	vldr	s12, [pc, #340]         @ 0x801441c <acosf+0x1c8>
 80142ca: ee05 6a87    	vmla.f32	s12, s11, s14
 80142ce: eddf 5a54    	vldr	s11, [pc, #336]         @ 0x8014420 <acosf+0x1cc>
 80142d2: ee17 5a25    	vnmls.f32	s10, s14, s11
 80142d6: eddf 5a53    	vldr	s11, [pc, #332]         @ 0x8014424 <acosf+0x1d0>
 80142da: ee45 5a07    	vmla.f32	s11, s10, s14
 80142de: ed9f 5a52    	vldr	s10, [pc, #328]         @ 0x8014428 <acosf+0x1d4>
 80142e2: ee15 5a87    	vnmls.f32	s10, s11, s14
 80142e6: eef7 5a00    	vmov.f32	s11, #1.000000e+00
 80142ea: ee45 5a07    	vmla.f32	s11, s10, s14
 80142ee: ee26 6a07    	vmul.f32	s12, s12, s14
 80142f2: ee86 7a25    	vdiv.f32	s14, s12, s11
 80142f6: ee47 6a67    	vmls.f32	s13, s14, s15
 80142fa: ee77 6ae6    	vsub.f32	s13, s15, s13
 80142fe: ee30 0a66    	vsub.f32	s0, s0, s13
 8014302: 4770         	bx	lr
 8014304: 2b00         	cmp	r3, #0x0
 8014306: ed9f 1a3f    	vldr	s2, [pc, #252]          @ 0x8014404 <acosf+0x1b0>
 801430a: eddf 2a3f    	vldr	s5, [pc, #252]          @ 0x8014408 <acosf+0x1b4>
 801430e: ed9f 3a40    	vldr	s6, [pc, #256]          @ 0x8014410 <acosf+0x1bc>
 8014312: eddf 3a40    	vldr	s7, [pc, #256]          @ 0x8014414 <acosf+0x1c0>
 8014316: ed9f 4a40    	vldr	s8, [pc, #256]          @ 0x8014418 <acosf+0x1c4>
 801431a: ed9f 7a40    	vldr	s14, [pc, #256]         @ 0x801441c <acosf+0x1c8>
 801431e: eddf 1a40    	vldr	s3, [pc, #256]          @ 0x8014420 <acosf+0x1cc>
 8014322: eddf 4a3a    	vldr	s9, [pc, #232]          @ 0x801440c <acosf+0x1b8>
 8014326: ed9f 5a3f    	vldr	s10, [pc, #252]         @ 0x8014424 <acosf+0x1d0>
 801432a: eddf 5a3f    	vldr	s11, [pc, #252]         @ 0x8014428 <acosf+0x1d4>
 801432e: eef7 6a00    	vmov.f32	s13, #1.000000e+00
 8014332: eeb6 6a00    	vmov.f32	s12, #5.000000e-01
 8014336: da28         	bge	0x801438a <acosf+0x136> @ imm = #0x50
 8014338: ee30 0a26    	vadd.f32	s0, s0, s13
 801433c: ee20 0a06    	vmul.f32	s0, s0, s12
 8014340: eeb1 6ac0    	vsqrt.f32	s12, s0
 8014344: ee40 2a01    	vmla.f32	s5, s0, s2
 8014348: ee50 4a21    	vnmls.f32	s9, s0, s3
 801434c: ee12 3a80    	vnmls.f32	s6, s5, s0
 8014350: ee04 5a80    	vmla.f32	s10, s9, s0
 8014354: ee43 3a00    	vmla.f32	s7, s6, s0
 8014358: ee55 5a00    	vnmls.f32	s11, s10, s0
 801435c: ee13 4a80    	vnmls.f32	s8, s7, s0
 8014360: ee45 6a80    	vmla.f32	s13, s11, s0
 8014364: ee04 7a00    	vmla.f32	s14, s8, s0
 8014368: eddf 7a25    	vldr	s15, [pc, #148]         @ 0x8014400 <acosf+0x1ac>
 801436c: ee27 7a00    	vmul.f32	s14, s14, s0
 8014370: ed9f 0a21    	vldr	s0, [pc, #132]          @ 0x80143f8 <acosf+0x1a4>
 8014374: eec7 5a26    	vdiv.f32	s11, s14, s13
 8014378: ee55 7a86    	vnmls.f32	s15, s11, s12
 801437c: ee77 7a86    	vadd.f32	s15, s15, s12
 8014380: ee77 7aa7    	vadd.f32	s15, s15, s15
 8014384: ee30 0a67    	vsub.f32	s0, s0, s15
 8014388: 4770         	bx	lr
 801438a: ee36 0ac0    	vsub.f32	s0, s13, s0
 801438e: ee20 0a06    	vmul.f32	s0, s0, s12
 8014392: eeb1 2ac0    	vsqrt.f32	s4, s0
 8014396: ee40 2a01    	vmla.f32	s5, s0, s2
 801439a: ee50 4a21    	vnmls.f32	s9, s0, s3
 801439e: ee12 3a80    	vnmls.f32	s6, s5, s0
 80143a2: ee04 5a80    	vmla.f32	s10, s9, s0
 80143a6: ee43 3a00    	vmla.f32	s7, s6, s0
 80143aa: ee55 5a00    	vnmls.f32	s11, s10, s0
 80143ae: ee13 4a80    	vnmls.f32	s8, s7, s0
 80143b2: ee12 3a10    	vmov	r3, s4
 80143b6: ee04 7a00    	vmla.f32	s14, s8, s0
 80143ba: f423 637f    	bic	r3, r3, #0xff0
 80143be: f023 030f    	bic	r3, r3, #0xf
 80143c2: ee06 3a10    	vmov	s12, r3
 80143c6: ee45 6a80    	vmla.f32	s13, s11, s0
 80143ca: ee27 7a00    	vmul.f32	s14, s14, s0
 80143ce: ee06 0a46    	vmls.f32	s0, s12, s12
 80143d2: eec7 5a26    	vdiv.f32	s11, s14, s13
 80143d6: ee36 7a02    	vadd.f32	s14, s12, s4
 80143da: eec0 7a07    	vdiv.f32	s15, s0, s14
 80143de: ee45 7a82    	vmla.f32	s15, s11, s4
 80143e2: ee37 0a86    	vadd.f32	s0, s15, s12
 80143e6: ee30 0a00    	vadd.f32	s0, s0, s0
 80143ea: 4770         	bx	lr
 80143ec: ed9f 0a0f    	vldr	s0, [pc, #60]           @ 0x801442c <acosf+0x1d8>
 80143f0: 4770         	bx	lr
 80143f2: bf00         	nop

080143f4 <$d>:
 80143f4: 68 21 22 34  	.word	0x34222168
 80143f8: da 0f 49 40  	.word	0x40490fda
 80143fc: da 0f c9 3f  	.word	0x3fc90fda
 8014400: 68 21 a2 33  	.word	0x33a22168
 8014404: 08 ef 11 38  	.word	0x3811ef08
 8014408: 04 7f 4f 3a  	.word	0x3a4f7f04
 801440c: 61 33 30 3f  	.word	0x3f303361
 8014410: 46 11 24 3d  	.word	0x3d241146
 8014414: a8 0a 4e 3e  	.word	0x3e4e0aa8
 8014418: 90 b0 a6 3e  	.word	0x3ea6b090
 801441c: ab aa 2a 3e  	.word	0x3e2aaaab
 8014420: 2e c6 9d 3d  	.word	0x3d9dc62e
 8014424: 2d 57 01 40  	.word	0x4001572d
 8014428: 39 d1 19 40  	.word	0x4019d139
 801442c: 00 00 00 00  	.word	0x00000000

08014430 <asinf>:
 8014430: ee10 2a10    	vmov	r2, s0
 8014434: f022 4300    	bic	r3, r2, #0x80000000
 8014438: f1b3 5f7e    	cmp.w	r3, #0x3f800000
 801443c: eef0 7a40    	vmov.f32	s15, s0
 8014440: d10c         	bne	0x801445c <asinf+0x2c>  @ imm = #0x18
 8014442: ed9f 7a5c    	vldr	s14, [pc, #368]         @ 0x80145b4 <asinf+0x184>
 8014446: eddf 6a5c    	vldr	s13, [pc, #368]         @ 0x80145b8 <asinf+0x188>
 801444a: ee20 7a07    	vmul.f32	s14, s0, s14
 801444e: ee00 7a26    	vmla.f32	s14, s0, s13
 8014452: eef0 7a47    	vmov.f32	s15, s14
 8014456: eeb0 0a67    	vmov.f32	s0, s15
 801445a: 4770         	bx	lr
 801445c: d901         	bls	0x8014462 <asinf+0x32>  @ imm = #0x2
 801445e: f000 bb63    	b.w	0x8014b28 <__math_invalidf> @ imm = #0x6c6
 8014462: f1b3 5f7c    	cmp.w	r3, #0x3f000000
 8014466: eef7 6a00    	vmov.f32	s13, #1.000000e+00
 801446a: d20b         	bhs	0x8014484 <asinf+0x54>  @ imm = #0x16
 801446c: f1b3 5f48    	cmp.w	r3, #0x32000000
 8014470: d250         	bhs	0x8014514 <asinf+0xe4>  @ imm = #0xa0
 8014472: ed9f 7a52    	vldr	s14, [pc, #328]         @ 0x80145bc <asinf+0x18c>
 8014476: ee30 7a07    	vadd.f32	s14, s0, s14
 801447a: eeb4 7ae6    	vcmpe.f32	s14, s13
 801447e: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8014482: dce8         	bgt	0x8014456 <asinf+0x26>  @ imm = #-0x30
 8014484: eef0 7ae7    	vabs.f32	s15, s15
 8014488: ee76 7ae7    	vsub.f32	s15, s13, s15
 801448c: eeb6 7a00    	vmov.f32	s14, #5.000000e-01
 8014490: ee67 7a87    	vmul.f32	s15, s15, s14
 8014494: ed9f 6a4a    	vldr	s12, [pc, #296]         @ 0x80145c0 <asinf+0x190>
 8014498: ed9f 7a4a    	vldr	s14, [pc, #296]         @ 0x80145c4 <asinf+0x194>
 801449c: eddf 5a4a    	vldr	s11, [pc, #296]         @ 0x80145c8 <asinf+0x198>
 80144a0: ee07 6a87    	vmla.f32	s12, s15, s14
 80144a4: ed9f 7a49    	vldr	s14, [pc, #292]         @ 0x80145cc <asinf+0x19c>
 80144a8: ee16 7a27    	vnmls.f32	s14, s12, s15
 80144ac: ed9f 6a48    	vldr	s12, [pc, #288]         @ 0x80145d0 <asinf+0x1a0>
 80144b0: ee07 6a27    	vmla.f32	s12, s14, s15
 80144b4: ed9f 7a47    	vldr	s14, [pc, #284]         @ 0x80145d4 <asinf+0x1a4>
 80144b8: ee16 7a27    	vnmls.f32	s14, s12, s15
 80144bc: ed9f 6a46    	vldr	s12, [pc, #280]         @ 0x80145d8 <asinf+0x1a8>
 80144c0: ee07 6a27    	vmla.f32	s12, s14, s15
 80144c4: ed9f 7a45    	vldr	s14, [pc, #276]         @ 0x80145dc <asinf+0x1ac>
 80144c8: ee17 7aa5    	vnmls.f32	s14, s15, s11
 80144cc: eddf 5a44    	vldr	s11, [pc, #272]         @ 0x80145e0 <asinf+0x1b0>
 80144d0: ee47 5a27    	vmla.f32	s11, s14, s15
 80144d4: ed9f 7a43    	vldr	s14, [pc, #268]         @ 0x80145e4 <asinf+0x1b4>
 80144d8: ee15 7aa7    	vnmls.f32	s14, s11, s15
 80144dc: ee26 6a27    	vmul.f32	s12, s12, s15
 80144e0: ee47 6a27    	vmla.f32	s13, s14, s15
 80144e4: eeb1 7ae7    	vsqrt.f32	s14, s15
 80144e8: 493f         	ldr	r1, [pc, #0xfc]         @ 0x80145e8 <asinf+0x1b8>
 80144ea: 428b         	cmp	r3, r1
 80144ec: eec6 5a26    	vdiv.f32	s11, s12, s13
 80144f0: d93f         	bls	0x8014572 <asinf+0x142> @ imm = #0x7e
 80144f2: ee05 7a87    	vmla.f32	s14, s11, s14
 80144f6: eddf 7a3d    	vldr	s15, [pc, #244]         @ 0x80145ec <asinf+0x1bc>
 80144fa: ee37 7a07    	vadd.f32	s14, s14, s14
 80144fe: ee37 7a27    	vadd.f32	s14, s14, s15
 8014502: eddf 7a2d    	vldr	s15, [pc, #180]         @ 0x80145b8 <asinf+0x188>
 8014506: ee77 7ac7    	vsub.f32	s15, s15, s14
 801450a: 2a00         	cmp	r2, #0x0
 801450c: bfd8         	it	le
 801450e: eef1 7a67    	vnegle.f32	s15, s15
 8014512: e7a0         	b	0x8014456 <asinf+0x26>  @ imm = #-0xc0
 8014514: ee20 7a00    	vmul.f32	s14, s0, s0
 8014518: eddf 5a2a    	vldr	s11, [pc, #168]         @ 0x80145c4 <asinf+0x194>
 801451c: ed9f 6a28    	vldr	s12, [pc, #160]         @ 0x80145c0 <asinf+0x190>
 8014520: ed9f 5a29    	vldr	s10, [pc, #164]         @ 0x80145c8 <asinf+0x198>
 8014524: ee07 6a25    	vmla.f32	s12, s14, s11
 8014528: eddf 5a28    	vldr	s11, [pc, #160]         @ 0x80145cc <asinf+0x19c>
 801452c: ee56 5a07    	vnmls.f32	s11, s12, s14
 8014530: ed9f 6a27    	vldr	s12, [pc, #156]         @ 0x80145d0 <asinf+0x1a0>
 8014534: ee05 6a87    	vmla.f32	s12, s11, s14
 8014538: eddf 5a26    	vldr	s11, [pc, #152]         @ 0x80145d4 <asinf+0x1a4>
 801453c: ee56 5a07    	vnmls.f32	s11, s12, s14
 8014540: ed9f 6a25    	vldr	s12, [pc, #148]         @ 0x80145d8 <asinf+0x1a8>
 8014544: ee05 6a87    	vmla.f32	s12, s11, s14
 8014548: eddf 5a24    	vldr	s11, [pc, #144]         @ 0x80145dc <asinf+0x1ac>
 801454c: ee57 5a05    	vnmls.f32	s11, s14, s10
 8014550: ed9f 5a23    	vldr	s10, [pc, #140]         @ 0x80145e0 <asinf+0x1b0>
 8014554: ee05 5a87    	vmla.f32	s10, s11, s14
 8014558: eddf 5a22    	vldr	s11, [pc, #136]         @ 0x80145e4 <asinf+0x1b4>
 801455c: ee55 5a07    	vnmls.f32	s11, s10, s14
 8014560: ee26 6a07    	vmul.f32	s12, s12, s14
 8014564: ee45 6a87    	vmla.f32	s13, s11, s14
 8014568: ee86 7a26    	vdiv.f32	s14, s12, s13
 801456c: ee47 7a00    	vmla.f32	s15, s14, s0
 8014570: e771         	b	0x8014456 <asinf+0x26>  @ imm = #-0x11e
 8014572: ee17 3a10    	vmov	r3, s14
 8014576: f423 637f    	bic	r3, r3, #0xff0
 801457a: f023 030f    	bic	r3, r3, #0xf
 801457e: ee06 3a90    	vmov	s13, r3
 8014582: ee46 7ae6    	vmls.f32	s15, s13, s13
 8014586: ee37 5a07    	vadd.f32	s10, s14, s14
 801458a: ee37 7a26    	vadd.f32	s14, s14, s13
 801458e: ee76 6aa6    	vadd.f32	s13, s13, s13
 8014592: ee87 6a87    	vdiv.f32	s12, s15, s14
 8014596: ed9f 7a07    	vldr	s14, [pc, #28]          @ 0x80145b4 <asinf+0x184>
 801459a: eddf 7a15    	vldr	s15, [pc, #84]          @ 0x80145f0 <asinf+0x1c0>
 801459e: ee36 6a06    	vadd.f32	s12, s12, s12
 80145a2: ee77 6ae6    	vsub.f32	s13, s15, s13
 80145a6: ee37 7a46    	vsub.f32	s14, s14, s12
 80145aa: ee15 7a25    	vnmls.f32	s14, s10, s11
 80145ae: ee37 7a66    	vsub.f32	s14, s14, s13
 80145b2: e7a8         	b	0x8014506 <asinf+0xd6>  @ imm = #-0xb0

080145b4 <$d>:
 80145b4: 2e bd 3b b3  	.word	0xb33bbd2e
 80145b8: db 0f c9 3f  	.word	0x3fc90fdb
 80145bc: ca f2 49 71  	.word	0x7149f2ca
 80145c0: 04 7f 4f 3a  	.word	0x3a4f7f04
 80145c4: 08 ef 11 38  	.word	0x3811ef08
 80145c8: 2e c6 9d 3d  	.word	0x3d9dc62e
 80145cc: 46 11 24 3d  	.word	0x3d241146
 80145d0: a8 0a 4e 3e  	.word	0x3e4e0aa8
 80145d4: 90 b0 a6 3e  	.word	0x3ea6b090
 80145d8: ab aa 2a 3e  	.word	0x3e2aaaab
 80145dc: 61 33 30 3f  	.word	0x3f303361
 80145e0: 2d 57 01 40  	.word	0x4001572d
 80145e4: 39 d1 19 40  	.word	0x4019d139
 80145e8: 99 99 79 3f  	.word	0x3f799999
 80145ec: 2e bd 3b 33  	.word	0x333bbd2e
 80145f0: db 0f 49 3f  	.word	0x3f490fdb

080145f4 <atan2f>:
 80145f4: ee10 2a90    	vmov	r2, s1
 80145f8: f022 4100    	bic	r1, r2, #0x80000000
 80145fc: f1b1 4fff    	cmp.w	r1, #0x7f800000
 8014600: b510         	push	{r4, lr}
 8014602: eef0 7a40    	vmov.f32	s15, s0
 8014606: d806         	bhi	0x8014616 <atan2f+0x22> @ imm = #0xc
 8014608: ee10 0a10    	vmov	r0, s0
 801460c: f020 4300    	bic	r3, r0, #0x80000000
 8014610: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8014614: d904         	bls	0x8014620 <atan2f+0x2c> @ imm = #0x8
 8014616: ee77 7aa0    	vadd.f32	s15, s15, s1
 801461a: eeb0 0a67    	vmov.f32	s0, s15
 801461e: bd10         	pop	{r4, pc}
 8014620: f1b2 5f7e    	cmp.w	r2, #0x3f800000
 8014624: d103         	bne	0x801462e <atan2f+0x3a> @ imm = #0x6
 8014626: e8bd 4010    	pop.w	{r4, lr}
 801462a: f000 bdaf    	b.w	0x801518c <atanf>       @ imm = #0xb5e
 801462e: 1794         	asrs	r4, r2, #0x1e
 8014630: f004 0402    	and	r4, r4, #0x2
 8014634: ea44 74d0    	orr.w	r4, r4, r0, lsr #31
 8014638: b98b         	cbnz	r3, 0x801465e <atan2f+0x6a> @ imm = #0x22
 801463a: 2c02         	cmp	r4, #0x2
 801463c: d008         	beq	0x8014650 <atan2f+0x5c> @ imm = #0x10
 801463e: 2c03         	cmp	r4, #0x3
 8014640: d1eb         	bne	0x801461a <atan2f+0x26> @ imm = #-0x2a
 8014642: eddf 7a41    	vldr	s15, [pc, #260]         @ 0x8014748 <atan2f+0x154>
 8014646: ed9f 7a41    	vldr	s14, [pc, #260]         @ 0x801474c <atan2f+0x158>
 801464a: ee77 7ac7    	vsub.f32	s15, s15, s14
 801464e: e7e4         	b	0x801461a <atan2f+0x26> @ imm = #-0x38
 8014650: eddf 7a3f    	vldr	s15, [pc, #252]         @ 0x8014750 <atan2f+0x15c>
 8014654: ed9f 7a3d    	vldr	s14, [pc, #244]         @ 0x801474c <atan2f+0x158>
 8014658: ee77 7a87    	vadd.f32	s15, s15, s14
 801465c: e7dd         	b	0x801461a <atan2f+0x26> @ imm = #-0x46
 801465e: b939         	cbnz	r1, 0x8014670 <atan2f+0x7c> @ imm = #0xe
 8014660: 2800         	cmp	r0, #0x0
 8014662: da02         	bge	0x801466a <atan2f+0x76> @ imm = #0x4
 8014664: eddf 7a3b    	vldr	s15, [pc, #236]         @ 0x8014754 <atan2f+0x160>
 8014668: e7ed         	b	0x8014646 <atan2f+0x52> @ imm = #-0x26
 801466a: eddf 7a3b    	vldr	s15, [pc, #236]         @ 0x8014758 <atan2f+0x164>
 801466e: e7f1         	b	0x8014654 <atan2f+0x60> @ imm = #-0x1e
 8014670: f1b1 4fff    	cmp.w	r1, #0x7f800000
 8014674: d12d         	bne	0x80146d2 <atan2f+0xde> @ imm = #0x5a
 8014676: f1b3 4fff    	cmp.w	r3, #0x7f800000
 801467a: d11d         	bne	0x80146b8 <atan2f+0xc4> @ imm = #0x3a
 801467c: 2c02         	cmp	r4, #0x2
 801467e: eddf 7a33    	vldr	s15, [pc, #204]         @ 0x801474c <atan2f+0x158>
 8014682: d00b         	beq	0x801469c <atan2f+0xa8> @ imm = #0x16
 8014684: 2c03         	cmp	r4, #0x3
 8014686: d010         	beq	0x80146aa <atan2f+0xb6> @ imm = #0x20
 8014688: 2c01         	cmp	r4, #0x1
 801468a: d002         	beq	0x8014692 <atan2f+0x9e> @ imm = #0x4
 801468c: ed9f 7a33    	vldr	s14, [pc, #204]         @ 0x801475c <atan2f+0x168>
 8014690: e7e2         	b	0x8014658 <atan2f+0x64> @ imm = #-0x3c
 8014692: ed9f 7a33    	vldr	s14, [pc, #204]         @ 0x8014760 <atan2f+0x16c>
 8014696: ee77 7a67    	vsub.f32	s15, s14, s15
 801469a: e7be         	b	0x801461a <atan2f+0x26> @ imm = #-0x84
 801469c: eddf 6a2f    	vldr	s13, [pc, #188]         @ 0x801475c <atan2f+0x168>
 80146a0: eeb0 7a08    	vmov.f32	s14, #3.000000e+00
 80146a4: ee46 7a87    	vmla.f32	s15, s13, s14
 80146a8: e7b7         	b	0x801461a <atan2f+0x26> @ imm = #-0x92
 80146aa: eddf 6a2c    	vldr	s13, [pc, #176]         @ 0x801475c <atan2f+0x168>
 80146ae: eeb8 7a08    	vmov.f32	s14, #-3.000000e+00
 80146b2: ee56 7a87    	vnmls.f32	s15, s13, s14
 80146b6: e7b0         	b	0x801461a <atan2f+0x26> @ imm = #-0xa0
 80146b8: 2c02         	cmp	r4, #0x2
 80146ba: d0c9         	beq	0x8014650 <atan2f+0x5c> @ imm = #-0x6e
 80146bc: 2c03         	cmp	r4, #0x3
 80146be: d0c0         	beq	0x8014642 <atan2f+0x4e> @ imm = #-0x80
 80146c0: eddf 7a28    	vldr	s15, [pc, #160]         @ 0x8014764 <atan2f+0x170>
 80146c4: ed9f 7a28    	vldr	s14, [pc, #160]         @ 0x8014768 <atan2f+0x174>
 80146c8: 2c01         	cmp	r4, #0x1
 80146ca: bf18         	it	ne
 80146cc: eef0 7a47    	vmovne.f32	s15, s14
 80146d0: e7a3         	b	0x801461a <atan2f+0x26> @ imm = #-0xba
 80146d2: f1b3 4fff    	cmp.w	r3, #0x7f800000
 80146d6: d0c3         	beq	0x8014660 <atan2f+0x6c> @ imm = #-0x7a
 80146d8: 1a5b         	subs	r3, r3, r1
 80146da: f1b3 5ff4    	cmp.w	r3, #0x1e800000
 80146de: ea4f 51e3    	asr.w	r1, r3, #0x17
 80146e2: db12         	blt	0x801470a <atan2f+0x116> @ imm = #0x24
 80146e4: eddf 7a1c    	vldr	s15, [pc, #112]         @ 0x8014758 <atan2f+0x164>
 80146e8: ed9f 7a20    	vldr	s14, [pc, #128]         @ 0x801476c <atan2f+0x178>
 80146ec: ee77 7ac7    	vsub.f32	s15, s15, s14
 80146f0: 2c01         	cmp	r4, #0x1
 80146f2: d01a         	beq	0x801472a <atan2f+0x136> @ imm = #0x34
 80146f4: 2c02         	cmp	r4, #0x2
 80146f6: d01f         	beq	0x8014738 <atan2f+0x144> @ imm = #0x3e
 80146f8: 2c00         	cmp	r4, #0x0
 80146fa: d08e         	beq	0x801461a <atan2f+0x26> @ imm = #-0xe4
 80146fc: ed9f 7a1c    	vldr	s14, [pc, #112]         @ 0x8014770 <atan2f+0x17c>
 8014700: ee77 7a87    	vadd.f32	s15, s15, s14
 8014704: ed9f 7a12    	vldr	s14, [pc, #72]          @ 0x8014750 <atan2f+0x15c>
 8014708: e79f         	b	0x801464a <atan2f+0x56> @ imm = #-0xc2
 801470a: 2a00         	cmp	r2, #0x0
 801470c: da01         	bge	0x8014712 <atan2f+0x11e> @ imm = #0x2
 801470e: 313c         	adds	r1, #0x3c
 8014710: db08         	blt	0x8014724 <atan2f+0x130> @ imm = #0x10
 8014712: ee87 0aa0    	vdiv.f32	s0, s15, s1
 8014716: eeb0 0ac0    	vabs.f32	s0, s0
 801471a: f000 fd37    	bl	0x801518c <atanf>       @ imm = #0xa6e
 801471e: eef0 7a40    	vmov.f32	s15, s0
 8014722: e7e5         	b	0x80146f0 <atan2f+0xfc> @ imm = #-0x36
 8014724: eddf 7a10    	vldr	s15, [pc, #64]          @ 0x8014768 <atan2f+0x174>
 8014728: e7e2         	b	0x80146f0 <atan2f+0xfc> @ imm = #-0x3c
 801472a: ee17 3a90    	vmov	r3, s15
 801472e: f103 4300    	add.w	r3, r3, #0x80000000
 8014732: ee07 3a90    	vmov	s15, r3
 8014736: e770         	b	0x801461a <atan2f+0x26> @ imm = #-0x120
 8014738: ed9f 7a0d    	vldr	s14, [pc, #52]          @ 0x8014770 <atan2f+0x17c>
 801473c: ee77 7a87    	vadd.f32	s15, s15, s14
 8014740: ed9f 7a03    	vldr	s14, [pc, #12]          @ 0x8014750 <atan2f+0x15c>
 8014744: e7a7         	b	0x8014696 <atan2f+0xa2> @ imm = #-0xb2
 8014746: bf00         	nop

08014748 <$d>:
 8014748: db 0f 49 c0  	.word	0xc0490fdb
 801474c: 60 42 a2 0d  	.word	0x0da24260
 8014750: db 0f 49 40  	.word	0x40490fdb
 8014754: db 0f c9 bf  	.word	0xbfc90fdb
 8014758: db 0f c9 3f  	.word	0x3fc90fdb
 801475c: db 0f 49 3f  	.word	0x3f490fdb
 8014760: db 0f 49 bf  	.word	0xbf490fdb
 8014764: 00 00 00 80  	.word	0x80000000
 8014768: 00 00 00 00  	.word	0x00000000
 801476c: 2e bd 3b 33  	.word	0x333bbd2e
 8014770: 2e bd bb 33  	.word	0x33bbbd2e

08014774 <cosf>:
 8014774: ee10 3a10    	vmov	r3, s0
 8014778: b507         	push	{r0, r1, r2, lr}
 801477a: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x80147f8 <cosf+0x84>
 801477c: f023 4300    	bic	r3, r3, #0x80000000
 8014780: 4293         	cmp	r3, r2
 8014782: d806         	bhi	0x8014792 <cosf+0x1e>   @ imm = #0xc
 8014784: eddf 0a1d    	vldr	s1, [pc, #116]          @ 0x80147fc <cosf+0x88>
 8014788: b003         	add	sp, #0xc
 801478a: f85d eb04    	ldr	lr, [sp], #4
 801478e: f000 b9df    	b.w	0x8014b50 <__kernel_cosf> @ imm = #0x3be
 8014792: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8014796: d304         	blo	0x80147a2 <cosf+0x2e>   @ imm = #0x8
 8014798: b003         	add	sp, #0xc
 801479a: f85d eb04    	ldr	lr, [sp], #4
 801479e: f000 b9c3    	b.w	0x8014b28 <__math_invalidf> @ imm = #0x386
 80147a2: 4668         	mov	r0, sp
 80147a4: f000 f82c    	bl	0x8014800 <__rem_pio2f> @ imm = #0x58
 80147a8: f000 0003    	and	r0, r0, #0x3
 80147ac: 2801         	cmp	r0, #0x1
 80147ae: d00b         	beq	0x80147c8 <cosf+0x54>   @ imm = #0x16
 80147b0: 2802         	cmp	r0, #0x2
 80147b2: d012         	beq	0x80147da <cosf+0x66>   @ imm = #0x24
 80147b4: b9c0         	cbnz	r0, 0x80147e8 <cosf+0x74> @ imm = #0x30
 80147b6: eddd 0a01    	vldr	s1, [sp, #4]
 80147ba: ed9d 0a00    	vldr	s0, [sp]
 80147be: f000 f9c7    	bl	0x8014b50 <__kernel_cosf> @ imm = #0x38e
 80147c2: b003         	add	sp, #0xc
 80147c4: f85d fb04    	ldr	pc, [sp], #4
 80147c8: eddd 0a01    	vldr	s1, [sp, #4]
 80147cc: ed9d 0a00    	vldr	s0, [sp]
 80147d0: f000 fc94    	bl	0x80150fc <__kernel_sinf> @ imm = #0x928
 80147d4: eeb1 0a40    	vneg.f32	s0, s0
 80147d8: e7f3         	b	0x80147c2 <cosf+0x4e>   @ imm = #-0x1a
 80147da: eddd 0a01    	vldr	s1, [sp, #4]
 80147de: ed9d 0a00    	vldr	s0, [sp]
 80147e2: f000 f9b5    	bl	0x8014b50 <__kernel_cosf> @ imm = #0x36a
 80147e6: e7f5         	b	0x80147d4 <cosf+0x60>   @ imm = #-0x16
 80147e8: eddd 0a01    	vldr	s1, [sp, #4]
 80147ec: ed9d 0a00    	vldr	s0, [sp]
 80147f0: 2001         	movs	r0, #0x1
 80147f2: f000 fc83    	bl	0x80150fc <__kernel_sinf> @ imm = #0x906
 80147f6: e7e4         	b	0x80147c2 <cosf+0x4e>   @ imm = #-0x38

080147f8 <$d>:
 80147f8: d8 0f 49 3f  	.word	0x3f490fd8
 80147fc: 00 00 00 00  	.word	0x00000000

08014800 <__rem_pio2f>:
 8014800: b5f0         	push	{r4, r5, r6, r7, lr}
 8014802: ee10 5a10    	vmov	r5, s0
 8014806: 4a86         	ldr	r2, [pc, #0x218]        @ 0x8014a20 <__rem_pio2f+0x220>
 8014808: f025 4300    	bic	r3, r5, #0x80000000
 801480c: 4293         	cmp	r3, r2
 801480e: b087         	sub	sp, #0x1c
 8014810: 4604         	mov	r4, r0
 8014812: d805         	bhi	0x8014820 <__rem_pio2f+0x20> @ imm = #0xa
 8014814: 2300         	movs	r3, #0x0
 8014816: ed80 0a00    	vstr	s0, [r0]
 801481a: 6043         	str	r3, [r0, #0x4]
 801481c: 2000         	movs	r0, #0x0
 801481e: e022         	b	0x8014866 <__rem_pio2f+0x66> @ imm = #0x44
 8014820: 4a80         	ldr	r2, [pc, #0x200]        @ 0x8014a24 <__rem_pio2f+0x224>
 8014822: 4293         	cmp	r3, r2
 8014824: d83a         	bhi	0x801489c <__rem_pio2f+0x9c> @ imm = #0x74
 8014826: f025 4300    	bic	r3, r5, #0x80000000
 801482a: 2d00         	cmp	r5, #0x0
 801482c: eddf 7a7e    	vldr	s15, [pc, #504]         @ 0x8014a28 <__rem_pio2f+0x228>
 8014830: 4a7e         	ldr	r2, [pc, #0x1f8]        @ 0x8014a2c <__rem_pio2f+0x22c>
 8014832: f023 030f    	bic	r3, r3, #0xf
 8014836: dd18         	ble	0x801486a <__rem_pio2f+0x6a> @ imm = #0x30
 8014838: 4293         	cmp	r3, r2
 801483a: ee30 0a67    	vsub.f32	s0, s0, s15
 801483e: bf09         	itett	eq
 8014840: eddf 7a7b    	vldreq	s15, [pc, #492]         @ 0x8014a30 <__rem_pio2f+0x230>
 8014844: ed9f 7a7b    	vldrne	s14, [pc, #492]         @ 0x8014a34 <__rem_pio2f+0x234>
 8014848: ed9f 7a7b    	vldreq	s14, [pc, #492]         @ 0x8014a38 <__rem_pio2f+0x238>
 801484c: ee30 0a67    	vsubeq.f32	s0, s0, s15
 8014850: ee70 7a47    	vsub.f32	s15, s0, s14
 8014854: ee30 0a67    	vsub.f32	s0, s0, s15
 8014858: edc0 7a00    	vstr	s15, [r0]
 801485c: ee30 0a47    	vsub.f32	s0, s0, s14
 8014860: ed80 0a01    	vstr	s0, [r0, #4]
 8014864: 2001         	movs	r0, #0x1
 8014866: b007         	add	sp, #0x1c
 8014868: bdf0         	pop	{r4, r5, r6, r7, pc}
 801486a: 4293         	cmp	r3, r2
 801486c: ee30 0a27    	vadd.f32	s0, s0, s15
 8014870: bf09         	itett	eq
 8014872: eddf 7a6f    	vldreq	s15, [pc, #444]         @ 0x8014a30 <__rem_pio2f+0x230>
 8014876: ed9f 7a6f    	vldrne	s14, [pc, #444]         @ 0x8014a34 <__rem_pio2f+0x234>
 801487a: ed9f 7a6f    	vldreq	s14, [pc, #444]         @ 0x8014a38 <__rem_pio2f+0x238>
 801487e: ee30 0a27    	vaddeq.f32	s0, s0, s15
 8014882: ee70 7a07    	vadd.f32	s15, s0, s14
 8014886: ee30 0a67    	vsub.f32	s0, s0, s15
 801488a: edc0 7a00    	vstr	s15, [r0]
 801488e: ee30 0a07    	vadd.f32	s0, s0, s14
 8014892: ed80 0a01    	vstr	s0, [r0, #4]
 8014896: f04f 30ff    	mov.w	r0, #0xffffffff
 801489a: e7e4         	b	0x8014866 <__rem_pio2f+0x66> @ imm = #-0x38
 801489c: 4a67         	ldr	r2, [pc, #0x19c]        @ 0x8014a3c <__rem_pio2f+0x23c>
 801489e: 4293         	cmp	r3, r2
 80148a0: d870         	bhi	0x8014984 <__rem_pio2f+0x184> @ imm = #0xe0
 80148a2: eeb0 0ac0    	vabs.f32	s0, s0
 80148a6: ed9f 7a66    	vldr	s14, [pc, #408]         @ 0x8014a40 <__rem_pio2f+0x240>
 80148aa: eef6 7a00    	vmov.f32	s15, #5.000000e-01
 80148ae: ee40 7a07    	vmla.f32	s15, s0, s14
 80148b2: eefd 7ae7    	vcvt.s32.f32	s15, s15
 80148b6: eef8 6ae7    	vcvt.f32.s32	s13, s15
 80148ba: ee17 0a90    	vmov	r0, s15
 80148be: eddf 7a5a    	vldr	s15, [pc, #360]         @ 0x8014a28 <__rem_pio2f+0x228>
 80148c2: ee06 0ae7    	vmls.f32	s0, s13, s15
 80148c6: 281f         	cmp	r0, #0x1f
 80148c8: eddf 7a5a    	vldr	s15, [pc, #360]         @ 0x8014a34 <__rem_pio2f+0x234>
 80148cc: ee66 7aa7    	vmul.f32	s15, s13, s15
 80148d0: ee30 7a67    	vsub.f32	s14, s0, s15
 80148d4: ee17 6a10    	vmov	r6, s14
 80148d8: dc09         	bgt	0x80148ee <__rem_pio2f+0xee> @ imm = #0x12
 80148da: 495a         	ldr	r1, [pc, #0x168]        @ 0x8014a44 <__rem_pio2f+0x244>
 80148dc: 1e47         	subs	r7, r0, #0x1
 80148de: f025 4200    	bic	r2, r5, #0x80000000
 80148e2: f851 1027    	ldr.w	r1, [r1, r7, lsl #2]
 80148e6: f022 02ff    	bic	r2, r2, #0xff
 80148ea: 428a         	cmp	r2, r1
 80148ec: d106         	bne	0x80148fc <__rem_pio2f+0xfc> @ imm = #0xc
 80148ee: f3c6 51c7    	ubfx	r1, r6, #0x17, #0x8
 80148f2: 15da         	asrs	r2, r3, #0x17
 80148f4: ebc1 53d3    	rsb	r3, r1, r3, lsr #23
 80148f8: 2b08         	cmp	r3, #0x8
 80148fa: dc14         	bgt	0x8014926 <__rem_pio2f+0x126> @ imm = #0x28
 80148fc: 6026         	str	r6, [r4]
 80148fe: ed94 7a00    	vldr	s14, [r4]
 8014902: ee30 0a47    	vsub.f32	s0, s0, s14
 8014906: 2d00         	cmp	r5, #0x0
 8014908: ee30 0a67    	vsub.f32	s0, s0, s15
 801490c: ed84 0a01    	vstr	s0, [r4, #4]
 8014910: daa9         	bge	0x8014866 <__rem_pio2f+0x66> @ imm = #-0xae
 8014912: eeb1 7a47    	vneg.f32	s14, s14
 8014916: eeb1 0a40    	vneg.f32	s0, s0
 801491a: ed84 7a00    	vstr	s14, [r4]
 801491e: ed84 0a01    	vstr	s0, [r4, #4]
 8014922: 4240         	rsbs	r0, r0, #0
 8014924: e79f         	b	0x8014866 <__rem_pio2f+0x66> @ imm = #-0xc2
 8014926: eddf 7a42    	vldr	s15, [pc, #264]         @ 0x8014a30 <__rem_pio2f+0x230>
 801492a: ed9f 6a43    	vldr	s12, [pc, #268]         @ 0x8014a38 <__rem_pio2f+0x238>
 801492e: ee66 7aa7    	vmul.f32	s15, s13, s15
 8014932: ee30 7a67    	vsub.f32	s14, s0, s15
 8014936: ee30 0a47    	vsub.f32	s0, s0, s14
 801493a: ee70 7a67    	vsub.f32	s15, s0, s15
 801493e: ee56 7a86    	vnmls.f32	s15, s13, s12
 8014942: ee37 6a67    	vsub.f32	s12, s14, s15
 8014946: ee16 1a10    	vmov	r1, s12
 801494a: f3c1 53c7    	ubfx	r3, r1, #0x17, #0x8
 801494e: 1ad3         	subs	r3, r2, r3
 8014950: 2b19         	cmp	r3, #0x19
 8014952: dc04         	bgt	0x801495e <__rem_pio2f+0x15e> @ imm = #0x8
 8014954: ed84 6a00    	vstr	s12, [r4]
 8014958: eeb0 0a47    	vmov.f32	s0, s14
 801495c: e7cf         	b	0x80148fe <__rem_pio2f+0xfe> @ imm = #-0x62
 801495e: eddf 7a3a    	vldr	s15, [pc, #232]         @ 0x8014a48 <__rem_pio2f+0x248>
 8014962: ee66 7aa7    	vmul.f32	s15, s13, s15
 8014966: ee37 0a67    	vsub.f32	s0, s14, s15
 801496a: ee37 7a40    	vsub.f32	s14, s14, s0
 801496e: ee77 7a67    	vsub.f32	s15, s14, s15
 8014972: ed9f 7a36    	vldr	s14, [pc, #216]         @ 0x8014a4c <__rem_pio2f+0x24c>
 8014976: ee56 7a87    	vnmls.f32	s15, s13, s14
 801497a: ee30 7a67    	vsub.f32	s14, s0, s15
 801497e: ed84 7a00    	vstr	s14, [r4]
 8014982: e7bc         	b	0x80148fe <__rem_pio2f+0xfe> @ imm = #-0x88
 8014984: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8014988: d306         	blo	0x8014998 <__rem_pio2f+0x198> @ imm = #0xc
 801498a: ee30 0a40    	vsub.f32	s0, s0, s0
 801498e: ed80 0a01    	vstr	s0, [r0, #4]
 8014992: ed80 0a00    	vstr	s0, [r0]
 8014996: e741         	b	0x801481c <__rem_pio2f+0x1c> @ imm = #-0x17e
 8014998: 15da         	asrs	r2, r3, #0x17
 801499a: 3a86         	subs	r2, #0x86
 801499c: eba3 53c2    	sub.w	r3, r3, r2, lsl #23
 80149a0: ee07 3a90    	vmov	s15, r3
 80149a4: eebd 7ae7    	vcvt.s32.f32	s14, s15
 80149a8: eddf 6a29    	vldr	s13, [pc, #164]         @ 0x8014a50 <__rem_pio2f+0x250>
 80149ac: eeb8 7ac7    	vcvt.f32.s32	s14, s14
 80149b0: ee77 7ac7    	vsub.f32	s15, s15, s14
 80149b4: ed8d 7a03    	vstr	s14, [sp, #12]
 80149b8: ee67 7aa6    	vmul.f32	s15, s15, s13
 80149bc: eebd 7ae7    	vcvt.s32.f32	s14, s15
 80149c0: eeb8 7ac7    	vcvt.f32.s32	s14, s14
 80149c4: ee77 7ac7    	vsub.f32	s15, s15, s14
 80149c8: ed8d 7a04    	vstr	s14, [sp, #16]
 80149cc: ee67 7aa6    	vmul.f32	s15, s15, s13
 80149d0: eef5 7a40    	vcmp.f32	s15, #0
 80149d4: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80149d8: edcd 7a05    	vstr	s15, [sp, #20]
 80149dc: d11e         	bne	0x8014a1c <__rem_pio2f+0x21c> @ imm = #0x3c
 80149de: eeb5 7a40    	vcmp.f32	s14, #0
 80149e2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80149e6: bf0c         	ite	eq
 80149e8: 2301         	moveq	r3, #0x1
 80149ea: 2302         	movne	r3, #0x2
 80149ec: 4919         	ldr	r1, [pc, #0x64]         @ 0x8014a54 <__rem_pio2f+0x254>
 80149ee: 9101         	str	r1, [sp, #0x4]
 80149f0: 2102         	movs	r1, #0x2
 80149f2: 9100         	str	r1, [sp]
 80149f4: a803         	add	r0, sp, #0xc
 80149f6: 4621         	mov	r1, r4
 80149f8: f000 f902    	bl	0x8014c00 <__kernel_rem_pio2f> @ imm = #0x204
 80149fc: 2d00         	cmp	r5, #0x0
 80149fe: f6bf af32    	bge.w	0x8014866 <__rem_pio2f+0x66> @ imm = #-0x19c
 8014a02: edd4 7a00    	vldr	s15, [r4]
 8014a06: eef1 7a67    	vneg.f32	s15, s15
 8014a0a: edc4 7a00    	vstr	s15, [r4]
 8014a0e: edd4 7a01    	vldr	s15, [r4, #4]
 8014a12: eef1 7a67    	vneg.f32	s15, s15
 8014a16: edc4 7a01    	vstr	s15, [r4, #4]
 8014a1a: e782         	b	0x8014922 <__rem_pio2f+0x122> @ imm = #-0xfc
 8014a1c: 2303         	movs	r3, #0x3
 8014a1e: e7e5         	b	0x80149ec <__rem_pio2f+0x1ec> @ imm = #-0x36

08014a20 <$d>:
 8014a20: d8 0f 49 3f  	.word	0x3f490fd8
 8014a24: e3 cb 16 40  	.word	0x4016cbe3
 8014a28: 80 0f c9 3f  	.word	0x3fc90f80
 8014a2c: d0 0f c9 3f  	.word	0x3fc90fd0
 8014a30: 00 44 35 37  	.word	0x37354400
 8014a34: 43 44 35 37  	.word	0x37354443
 8014a38: 08 a3 85 2e  	.word	0x2e85a308
 8014a3c: 80 0f 49 43  	.word	0x43490f80
 8014a40: 84 f9 22 3f  	.word	0x3f22f984
 8014a44: b8 2f 02 08  	.word	0x08022fb8
 8014a48: 00 a3 85 2e  	.word	0x2e85a300
 8014a4c: 32 31 8d 24  	.word	0x248d3132
 8014a50: 00 00 80 43  	.word	0x43800000
 8014a54: 38 30 02 08  	.word	0x08023038

08014a58 <sinf>:
 8014a58: ee10 3a10    	vmov	r3, s0
 8014a5c: b507         	push	{r0, r1, r2, lr}
 8014a5e: 4a20         	ldr	r2, [pc, #0x80]         @ 0x8014ae0 <sinf+0x88>
 8014a60: f023 4300    	bic	r3, r3, #0x80000000
 8014a64: 4293         	cmp	r3, r2
 8014a66: d807         	bhi	0x8014a78 <sinf+0x20>   @ imm = #0xe
 8014a68: eddf 0a1e    	vldr	s1, [pc, #120]          @ 0x8014ae4 <sinf+0x8c>
 8014a6c: 2000         	movs	r0, #0x0
 8014a6e: b003         	add	sp, #0xc
 8014a70: f85d eb04    	ldr	lr, [sp], #4
 8014a74: f000 bb42    	b.w	0x80150fc <__kernel_sinf> @ imm = #0x684
 8014a78: f1b3 4fff    	cmp.w	r3, #0x7f800000
 8014a7c: d304         	blo	0x8014a88 <sinf+0x30>   @ imm = #0x8
 8014a7e: b003         	add	sp, #0xc
 8014a80: f85d eb04    	ldr	lr, [sp], #4
 8014a84: f000 b850    	b.w	0x8014b28 <__math_invalidf> @ imm = #0xa0
 8014a88: 4668         	mov	r0, sp
 8014a8a: f7ff feb9    	bl	0x8014800 <__rem_pio2f> @ imm = #-0x28e
 8014a8e: f000 0003    	and	r0, r0, #0x3
 8014a92: 2801         	cmp	r0, #0x1
 8014a94: d00c         	beq	0x8014ab0 <sinf+0x58>   @ imm = #0x18
 8014a96: 2802         	cmp	r0, #0x2
 8014a98: d011         	beq	0x8014abe <sinf+0x66>   @ imm = #0x22
 8014a9a: b9d0         	cbnz	r0, 0x8014ad2 <sinf+0x7a> @ imm = #0x34
 8014a9c: eddd 0a01    	vldr	s1, [sp, #4]
 8014aa0: ed9d 0a00    	vldr	s0, [sp]
 8014aa4: 2001         	movs	r0, #0x1
 8014aa6: f000 fb29    	bl	0x80150fc <__kernel_sinf> @ imm = #0x652
 8014aaa: b003         	add	sp, #0xc
 8014aac: f85d fb04    	ldr	pc, [sp], #4
 8014ab0: eddd 0a01    	vldr	s1, [sp, #4]
 8014ab4: ed9d 0a00    	vldr	s0, [sp]
 8014ab8: f000 f84a    	bl	0x8014b50 <__kernel_cosf> @ imm = #0x94
 8014abc: e7f5         	b	0x8014aaa <sinf+0x52>   @ imm = #-0x16
 8014abe: eddd 0a01    	vldr	s1, [sp, #4]
 8014ac2: ed9d 0a00    	vldr	s0, [sp]
 8014ac6: 2001         	movs	r0, #0x1
 8014ac8: f000 fb18    	bl	0x80150fc <__kernel_sinf> @ imm = #0x630
 8014acc: eeb1 0a40    	vneg.f32	s0, s0
 8014ad0: e7eb         	b	0x8014aaa <sinf+0x52>   @ imm = #-0x2a
 8014ad2: eddd 0a01    	vldr	s1, [sp, #4]
 8014ad6: ed9d 0a00    	vldr	s0, [sp]
 8014ada: f000 f839    	bl	0x8014b50 <__kernel_cosf> @ imm = #0x72
 8014ade: e7f5         	b	0x8014acc <sinf+0x74>   @ imm = #-0x16

08014ae0 <$d>:
 8014ae0: d8 0f 49 3f  	.word	0x3f490fd8
 8014ae4: 00 00 00 00  	.word	0x00000000

08014ae8 <__math_uflowf>:
 8014ae8: ed9f 0a05    	vldr	s0, [pc, #20]           @ 0x8014b00 <__math_uflowf+0x18>
 8014aec: eddf 7a05    	vldr	s15, [pc, #20]          @ 0x8014b04 <__math_uflowf+0x1c>
 8014af0: 2800         	cmp	r0, #0x0
 8014af2: bf08         	it	eq
 8014af4: eef0 7a40    	vmoveq.f32	s15, s0
 8014af8: ee27 0a80    	vmul.f32	s0, s15, s0
 8014afc: 4770         	bx	lr
 8014afe: bf00         	nop

08014b00 <$d>:
 8014b00: 00 00 80 00  	.word	0x00800000
 8014b04: 00 00 80 80  	.word	0x80800000

08014b08 <__math_oflowf>:
 8014b08: ed9f 0a05    	vldr	s0, [pc, #20]           @ 0x8014b20 <__math_oflowf+0x18>
 8014b0c: eddf 7a05    	vldr	s15, [pc, #20]          @ 0x8014b24 <__math_oflowf+0x1c>
 8014b10: 2800         	cmp	r0, #0x0
 8014b12: bf08         	it	eq
 8014b14: eef0 7a40    	vmoveq.f32	s15, s0
 8014b18: ee27 0a80    	vmul.f32	s0, s15, s0
 8014b1c: 4770         	bx	lr
 8014b1e: bf00         	nop

08014b20 <$d>:
 8014b20: ff ff 7f 7f  	.word	0x7f7fffff
 8014b24: ff ff 7f ff  	.word	0xff7fffff

08014b28 <__math_invalidf>:
 8014b28: b508         	push	{r3, lr}
 8014b2a: ed2d 8b02    	vpush	{d8}
 8014b2e: eeb0 8a40    	vmov.f32	s16, s0
 8014b32: f000 fc55    	bl	0x80153e0 <__fpclassifyf> @ imm = #0x8aa
 8014b36: b920         	cbnz	r0, 0x8014b42 <__math_invalidf+0x1a> @ imm = #0x8
 8014b38: ee38 0a08    	vadd.f32	s0, s16, s16
 8014b3c: ecbd 8b02    	vpop	{d8}
 8014b40: bd08         	pop	{r3, pc}
 8014b42: eddf 7a02    	vldr	s15, [pc, #8]           @ 0x8014b4c <__math_invalidf+0x24>
 8014b46: ee87 0aa7    	vdiv.f32	s0, s15, s15
 8014b4a: e7f7         	b	0x8014b3c <__math_invalidf+0x14> @ imm = #-0x12

08014b4c <$d>:
 8014b4c: 00 00 00 00  	.word	0x00000000

08014b50 <__kernel_cosf>:
 8014b50: ee10 3a10    	vmov	r3, s0
 8014b54: f023 4300    	bic	r3, r3, #0x80000000
 8014b58: f1b3 5f48    	cmp.w	r3, #0x32000000
 8014b5c: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 8014b60: d33b         	blo	0x8014bda <__kernel_cosf+0x8a> @ imm = #0x76
 8014b62: ee60 6a00    	vmul.f32	s13, s0, s0
 8014b66: eddf 5a1e    	vldr	s11, [pc, #120]         @ 0x8014be0 <__kernel_cosf+0x90>
 8014b6a: ed9f 6a1e    	vldr	s12, [pc, #120]         @ 0x8014be4 <__kernel_cosf+0x94>
 8014b6e: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x8014be8 <__kernel_cosf+0x98>
 8014b70: ee06 6aa5    	vmla.f32	s12, s13, s11
 8014b74: 4293         	cmp	r3, r2
 8014b76: eddf 5a1d    	vldr	s11, [pc, #116]         @ 0x8014bec <__kernel_cosf+0x9c>
 8014b7a: ee56 5a26    	vnmls.f32	s11, s12, s13
 8014b7e: ed9f 6a1c    	vldr	s12, [pc, #112]         @ 0x8014bf0 <__kernel_cosf+0xa0>
 8014b82: ee05 6aa6    	vmla.f32	s12, s11, s13
 8014b86: eddf 5a1b    	vldr	s11, [pc, #108]         @ 0x8014bf4 <__kernel_cosf+0xa4>
 8014b8a: ee56 5a26    	vnmls.f32	s11, s12, s13
 8014b8e: ed9f 6a1a    	vldr	s12, [pc, #104]         @ 0x8014bf8 <__kernel_cosf+0xa8>
 8014b92: ee05 6aa6    	vmla.f32	s12, s11, s13
 8014b96: ee60 0a20    	vmul.f32	s1, s0, s1
 8014b9a: ee26 6a26    	vmul.f32	s12, s12, s13
 8014b9e: eef6 7a00    	vmov.f32	s15, #5.000000e-01
 8014ba2: ee56 0a26    	vnmls.f32	s1, s12, s13
 8014ba6: ee66 7aa7    	vmul.f32	s15, s13, s15
 8014baa: d804         	bhi	0x8014bb6 <__kernel_cosf+0x66> @ imm = #0x8
 8014bac: ee77 7ae0    	vsub.f32	s15, s15, s1
 8014bb0: ee37 0a67    	vsub.f32	s0, s14, s15
 8014bb4: 4770         	bx	lr
 8014bb6: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8014bfc <__kernel_cosf+0xac>
 8014bb8: 4293         	cmp	r3, r2
 8014bba: bf9a         	itte	ls
 8014bbc: f103 437f    	addls.w	r3, r3, #0xff000000
 8014bc0: ee06 3a90    	vmovls	s13, r3
 8014bc4: eef5 6a02    	vmovhi.f32	s13, #2.812500e-01
 8014bc8: ee77 7ae6    	vsub.f32	s15, s15, s13
 8014bcc: ee37 0a66    	vsub.f32	s0, s14, s13
 8014bd0: ee77 7ae0    	vsub.f32	s15, s15, s1
 8014bd4: ee30 0a67    	vsub.f32	s0, s0, s15
 8014bd8: 4770         	bx	lr
 8014bda: eeb0 0a47    	vmov.f32	s0, s14
 8014bde: 4770         	bx	lr

08014be0 <$d>:
 8014be0: 4e d7 47 ad  	.word	0xad47d74e
 8014be4: f6 74 0f 31  	.word	0x310f74f6
 8014be8: 99 99 99 3e  	.word	0x3e999999
 8014bec: 7c f2 93 34  	.word	0x3493f27c
 8014bf0: 01 0d d0 37  	.word	0x37d00d01
 8014bf4: 61 0b b6 3a  	.word	0x3ab60b61
 8014bf8: ab aa 2a 3d  	.word	0x3d2aaaab
 8014bfc: 00 00 48 3f  	.word	0x3f480000

08014c00 <__kernel_rem_pio2f>:
 8014c00: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8014c04: ed2d 8b04    	vpush	{d8, d9}
 8014c08: b0d9         	sub	sp, #0x164
 8014c0a: 4690         	mov	r8, r2
 8014c0c: 469b         	mov	r11, r3
 8014c0e: 9a66         	ldr	r2, [sp, #0x198]
 8014c10: 4bbe         	ldr	r3, [pc, #0x2f8]        @ 0x8014f0c <__kernel_rem_pio2f+0x30c>
 8014c12: f8dd c19c    	ldr.w	r12, [sp, #0x19c]
 8014c16: f853 a022    	ldr.w	r10, [r3, r2, lsl #2]
 8014c1a: 9001         	str	r0, [sp, #0x4]
 8014c1c: f118 0f04    	cmn.w	r8, #0x4
 8014c20: 460f         	mov	r7, r1
 8014c22: f10b 33ff    	add.w	r3, r11, #0xffffffff
 8014c26: db25         	blt	0x8014c74 <__kernel_rem_pio2f+0x74> @ imm = #0x4a
 8014c28: f1b8 0203    	subs.w	r2, r8, #0x3
 8014c2c: bf48         	it	mi
 8014c2e: f108 0204    	addmi.w	r2, r8, #0x4
 8014c32: 10d2         	asrs	r2, r2, #0x3
 8014c34: 1c55         	adds	r5, r2, #0x1
 8014c36: 00e9         	lsls	r1, r5, #0x3
 8014c38: 1ad4         	subs	r4, r2, r3
 8014c3a: ed9f 7ab8    	vldr	s14, [pc, #736]         @ 0x8014f1c <__kernel_rem_pio2f+0x31c>
 8014c3e: 9102         	str	r1, [sp, #0x8]
 8014c40: eba8 05c5    	sub.w	r5, r8, r5, lsl #3
 8014c44: eb0a 0603    	add.w	r6, r10, r3
 8014c48: f10d 0970    	add.w	r9, sp, #0x70
 8014c4c: eb0c 0e84    	add.w	lr, r12, r4, lsl #2
 8014c50: 2100         	movs	r1, #0x0
 8014c52: 42b1         	cmp	r1, r6
 8014c54: dd10         	ble	0x8014c78 <__kernel_rem_pio2f+0x78> @ imm = #0x20
 8014c56: a91c         	add	r1, sp, #0x70
 8014c58: eb01 018b    	add.w	r1, r1, r11, lsl #2
 8014c5c: f50d 7988    	add.w	r9, sp, #0x110
 8014c60: 2600         	movs	r6, #0x0
 8014c62: 4556         	cmp	r6, r10
 8014c64: dc26         	bgt	0x8014cb4 <__kernel_rem_pio2f+0xb4> @ imm = #0x4c
 8014c66: f8dd e004    	ldr.w	lr, [sp, #0x4]
 8014c6a: eddf 7aac    	vldr	s15, [pc, #688]         @ 0x8014f1c <__kernel_rem_pio2f+0x31c>
 8014c6e: 460c         	mov	r4, r1
 8014c70: 2000         	movs	r0, #0x0
 8014c72: e016         	b	0x8014ca2 <__kernel_rem_pio2f+0xa2> @ imm = #0x2c
 8014c74: 2200         	movs	r2, #0x0
 8014c76: e7dd         	b	0x8014c34 <__kernel_rem_pio2f+0x34> @ imm = #-0x46
 8014c78: 42cc         	cmn	r4, r1
 8014c7a: bf5d         	ittte	pl
 8014c7c: f85e 0021    	ldrpl.w	r0, [lr, r1, lsl #2]
 8014c80: ee07 0a90    	vmovpl	s15, r0
 8014c84: eef8 7ae7    	vcvtpl.f32.s32	s15, s15
 8014c88: eef0 7a47    	vmovmi.f32	s15, s14
 8014c8c: ece9 7a01    	vstmia	r9!, {s15}
 8014c90: 3101         	adds	r1, #0x1
 8014c92: e7de         	b	0x8014c52 <__kernel_rem_pio2f+0x52> @ imm = #-0x44
 8014c94: ecfe 6a01    	vldmia	lr!, {s13}
 8014c98: ed94 7a00    	vldr	s14, [r4]
 8014c9c: ee46 7a87    	vmla.f32	s15, s13, s14
 8014ca0: 3001         	adds	r0, #0x1
 8014ca2: 4298         	cmp	r0, r3
 8014ca4: f1a4 0404    	sub.w	r4, r4, #0x4
 8014ca8: ddf4         	ble	0x8014c94 <__kernel_rem_pio2f+0x94> @ imm = #-0x18
 8014caa: ece9 7a01    	vstmia	r9!, {s15}
 8014cae: 3601         	adds	r6, #0x1
 8014cb0: 3104         	adds	r1, #0x4
 8014cb2: e7d6         	b	0x8014c62 <__kernel_rem_pio2f+0x62> @ imm = #-0x54
 8014cb4: a908         	add	r1, sp, #0x20
 8014cb6: eb01 018a    	add.w	r1, r1, r10, lsl #2
 8014cba: eb0c 0282    	add.w	r2, r12, r2, lsl #2
 8014cbe: eddf 8a96    	vldr	s17, [pc, #600]         @ 0x8014f18 <__kernel_rem_pio2f+0x318>
 8014cc2: ed9f 9a94    	vldr	s18, [pc, #592]         @ 0x8014f14 <__kernel_rem_pio2f+0x314>
 8014cc6: 9104         	str	r1, [sp, #0x10]
 8014cc8: 9203         	str	r2, [sp, #0xc]
 8014cca: 4654         	mov	r4, r10
 8014ccc: 00a2         	lsls	r2, r4, #0x2
 8014cce: 9205         	str	r2, [sp, #0x14]
 8014cd0: aa58         	add	r2, sp, #0x160
 8014cd2: eb02 0284    	add.w	r2, r2, r4, lsl #2
 8014cd6: ed12 0a14    	vldr	s0, [r2, #-80]
 8014cda: a944         	add	r1, sp, #0x110
 8014cdc: aa08         	add	r2, sp, #0x20
 8014cde: eb01 0184    	add.w	r1, r1, r4, lsl #2
 8014ce2: 4616         	mov	r6, r2
 8014ce4: 4620         	mov	r0, r4
 8014ce6: 2800         	cmp	r0, #0x0
 8014ce8: f1a1 0104    	sub.w	r1, r1, #0x4
 8014cec: dc4e         	bgt	0x8014d8c <__kernel_rem_pio2f+0x18c> @ imm = #0x9c
 8014cee: 4628         	mov	r0, r5
 8014cf0: e9cd 3206    	strd	r3, r2, [sp, #24]
 8014cf4: f000 fb2e    	bl	0x8015354 <scalbnf>     @ imm = #0x65c
 8014cf8: eeb0 8a40    	vmov.f32	s16, s0
 8014cfc: eeb4 0a00    	vmov.f32	s0, #1.250000e-01
 8014d00: ee28 0a00    	vmul.f32	s0, s16, s0
 8014d04: f000 fb88    	bl	0x8015418 <floorf>      @ imm = #0x710
 8014d08: eef2 7a00    	vmov.f32	s15, #8.000000e+00
 8014d0c: ee00 8a67    	vmls.f32	s16, s0, s15
 8014d10: 2d00         	cmp	r5, #0x0
 8014d12: e9dd 3206    	ldrd	r3, r2, [sp, #24]
 8014d16: eefd 7ac8    	vcvt.s32.f32	s15, s16
 8014d1a: ee17 9a90    	vmov	r9, s15
 8014d1e: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8014d22: ee38 8a67    	vsub.f32	s16, s16, s15
 8014d26: dd43         	ble	0x8014db0 <__kernel_rem_pio2f+0x1b0> @ imm = #0x86
 8014d28: 1e60         	subs	r0, r4, #0x1
 8014d2a: a908         	add	r1, sp, #0x20
 8014d2c: f1c5 0c08    	rsb.w	r12, r5, #0x8
 8014d30: f851 6020    	ldr.w	r6, [r1, r0, lsl #2]
 8014d34: fa46 f10c    	asr.w	r1, r6, r12
 8014d38: 4489         	add	r9, r1
 8014d3a: fa01 f10c    	lsl.w	r1, r1, r12
 8014d3e: 1a76         	subs	r6, r6, r1
 8014d40: a908         	add	r1, sp, #0x20
 8014d42: f841 6020    	str.w	r6, [r1, r0, lsl #2]
 8014d46: f1c5 0107    	rsb.w	r1, r5, #0x7
 8014d4a: 410e         	asrs	r6, r1
 8014d4c: 2e00         	cmp	r6, #0x0
 8014d4e: dd3e         	ble	0x8014dce <__kernel_rem_pio2f+0x1ce> @ imm = #0x7c
 8014d50: f04f 0c00    	mov.w	r12, #0x0
 8014d54: f109 0901    	add.w	r9, r9, #0x1
 8014d58: 4660         	mov	r0, r12
 8014d5a: 4564         	cmp	r4, r12
 8014d5c: dc6a         	bgt	0x8014e34 <__kernel_rem_pio2f+0x234> @ imm = #0xd4
 8014d5e: 2d00         	cmp	r5, #0x0
 8014d60: dd05         	ble	0x8014d6e <__kernel_rem_pio2f+0x16e> @ imm = #0xa
 8014d62: 2d01         	cmp	r5, #0x1
 8014d64: f000 8083    	beq.w	0x8014e6e <__kernel_rem_pio2f+0x26e> @ imm = #0x106
 8014d68: 2d02         	cmp	r5, #0x2
 8014d6a: f000 808b    	beq.w	0x8014e84 <__kernel_rem_pio2f+0x284> @ imm = #0x116
 8014d6e: 2e02         	cmp	r6, #0x2
 8014d70: d12d         	bne	0x8014dce <__kernel_rem_pio2f+0x1ce> @ imm = #0x5a
 8014d72: eeb7 0a00    	vmov.f32	s0, #1.000000e+00
 8014d76: ee30 8a48    	vsub.f32	s16, s0, s16
 8014d7a: b340         	cbz	r0, 0x8014dce <__kernel_rem_pio2f+0x1ce> @ imm = #0x50
 8014d7c: 4628         	mov	r0, r5
 8014d7e: 9306         	str	r3, [sp, #0x18]
 8014d80: f000 fae8    	bl	0x8015354 <scalbnf>     @ imm = #0x5d0
 8014d84: 9b06         	ldr	r3, [sp, #0x18]
 8014d86: ee38 8a40    	vsub.f32	s16, s16, s0
 8014d8a: e020         	b	0x8014dce <__kernel_rem_pio2f+0x1ce> @ imm = #0x40
 8014d8c: ee60 7a28    	vmul.f32	s15, s0, s17
 8014d90: 3801         	subs	r0, #0x1
 8014d92: eefd 7ae7    	vcvt.s32.f32	s15, s15
 8014d96: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8014d9a: ee07 0ac9    	vmls.f32	s0, s15, s18
 8014d9e: eebd 0ac0    	vcvt.s32.f32	s0, s0
 8014da2: eca6 0a01    	vstmia	r6!, {s0}
 8014da6: ed91 0a00    	vldr	s0, [r1]
 8014daa: ee37 0a80    	vadd.f32	s0, s15, s0
 8014dae: e79a         	b	0x8014ce6 <__kernel_rem_pio2f+0xe6> @ imm = #-0xcc
 8014db0: d105         	bne	0x8014dbe <__kernel_rem_pio2f+0x1be> @ imm = #0xa
 8014db2: 1e61         	subs	r1, r4, #0x1
 8014db4: a808         	add	r0, sp, #0x20
 8014db6: f850 6021    	ldr.w	r6, [r0, r1, lsl #2]
 8014dba: 11f6         	asrs	r6, r6, #0x7
 8014dbc: e7c6         	b	0x8014d4c <__kernel_rem_pio2f+0x14c> @ imm = #-0x74
 8014dbe: eef6 7a00    	vmov.f32	s15, #5.000000e-01
 8014dc2: eeb4 8ae7    	vcmpe.f32	s16, s15
 8014dc6: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8014dca: da31         	bge	0x8014e30 <__kernel_rem_pio2f+0x230> @ imm = #0x62
 8014dcc: 2600         	movs	r6, #0x0
 8014dce: eeb5 8a40    	vcmp.f32	s16, #0
 8014dd2: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8014dd6: f040 80a3    	bne.w	0x8014f20 <__kernel_rem_pio2f+0x320> @ imm = #0x146
 8014dda: 1e61         	subs	r1, r4, #0x1
 8014ddc: 2000         	movs	r0, #0x0
 8014dde: 4551         	cmp	r1, r10
 8014de0: da57         	bge	0x8014e92 <__kernel_rem_pio2f+0x292> @ imm = #0xae
 8014de2: 2800         	cmp	r0, #0x0
 8014de4: d071         	beq	0x8014eca <__kernel_rem_pio2f+0x2ca> @ imm = #0xe2
 8014de6: 3c01         	subs	r4, #0x1
 8014de8: ab08         	add	r3, sp, #0x20
 8014dea: 3d08         	subs	r5, #0x8
 8014dec: f853 3024    	ldr.w	r3, [r3, r4, lsl #2]
 8014df0: 2b00         	cmp	r3, #0x0
 8014df2: d0f8         	beq	0x8014de6 <__kernel_rem_pio2f+0x1e6> @ imm = #-0x10
 8014df4: 4628         	mov	r0, r5
 8014df6: eeb7 0a00    	vmov.f32	s0, #1.000000e+00
 8014dfa: f000 faab    	bl	0x8015354 <scalbnf>     @ imm = #0x556
 8014dfe: 1c63         	adds	r3, r4, #0x1
 8014e00: aa44         	add	r2, sp, #0x110
 8014e02: ed9f 7a45    	vldr	s14, [pc, #276]         @ 0x8014f18 <__kernel_rem_pio2f+0x318>
 8014e06: 0099         	lsls	r1, r3, #0x2
 8014e08: eb02 0283    	add.w	r2, r2, r3, lsl #2
 8014e0c: 4623         	mov	r3, r4
 8014e0e: 2b00         	cmp	r3, #0x0
 8014e10: f280 80b4    	bge.w	0x8014f7c <__kernel_rem_pio2f+0x37c> @ imm = #0x168
 8014e14: 4623         	mov	r3, r4
 8014e16: 2b00         	cmp	r3, #0x0
 8014e18: f2c0 80d2    	blt.w	0x8014fc0 <__kernel_rem_pio2f+0x3c0> @ imm = #0x1a4
 8014e1c: aa44         	add	r2, sp, #0x110
 8014e1e: eb02 0583    	add.w	r5, r2, r3, lsl #2
 8014e22: f8df c0ec    	ldr.w	r12, [pc, #0xec]        @ 0x8014f10 <__kernel_rem_pio2f+0x310>
 8014e26: eddf 7a3d    	vldr	s15, [pc, #244]         @ 0x8014f1c <__kernel_rem_pio2f+0x31c>
 8014e2a: 2000         	movs	r0, #0x0
 8014e2c: 1ae2         	subs	r2, r4, r3
 8014e2e: e0bc         	b	0x8014faa <__kernel_rem_pio2f+0x3aa> @ imm = #0x178
 8014e30: 2602         	movs	r6, #0x2
 8014e32: e78d         	b	0x8014d50 <__kernel_rem_pio2f+0x150> @ imm = #-0xe6
 8014e34: 4696         	mov	lr, r2
 8014e36: f85e 1b04    	ldr	r1, [lr], #4
 8014e3a: b960         	cbnz	r0, 0x8014e56 <__kernel_rem_pio2f+0x256> @ imm = #0x18
 8014e3c: b181         	cbz	r1, 0x8014e60 <__kernel_rem_pio2f+0x260> @ imm = #0x20
 8014e3e: f10c 0c01    	add.w	r12, r12, #0x1
 8014e42: f5c1 7180    	rsb.w	r1, r1, #0x100
 8014e46: 4564         	cmp	r4, r12
 8014e48: f84e 1c04    	str	r1, [lr, #-4]
 8014e4c: dd0d         	ble	0x8014e6a <__kernel_rem_pio2f+0x26a> @ imm = #0x1a
 8014e4e: f8de 1000    	ldr.w	r1, [lr]
 8014e52: f102 0e08    	add.w	lr, r2, #0x8
 8014e56: f1c1 01ff    	rsb.w	r1, r1, #0xff
 8014e5a: f84e 1c04    	str	r1, [lr, #-4]
 8014e5e: 2101         	movs	r1, #0x1
 8014e60: f10c 0c01    	add.w	r12, r12, #0x1
 8014e64: 4672         	mov	r2, lr
 8014e66: 4608         	mov	r0, r1
 8014e68: e777         	b	0x8014d5a <__kernel_rem_pio2f+0x15a> @ imm = #-0x112
 8014e6a: 2001         	movs	r0, #0x1
 8014e6c: e777         	b	0x8014d5e <__kernel_rem_pio2f+0x15e> @ imm = #-0x112
 8014e6e: 1e61         	subs	r1, r4, #0x1
 8014e70: aa08         	add	r2, sp, #0x20
 8014e72: f852 2021    	ldr.w	r2, [r2, r1, lsl #2]
 8014e76: f002 027f    	and	r2, r2, #0x7f
 8014e7a: f10d 0c20    	add.w	r12, sp, #0x20
 8014e7e: f84c 2021    	str.w	r2, [r12, r1, lsl #2]
 8014e82: e774         	b	0x8014d6e <__kernel_rem_pio2f+0x16e> @ imm = #-0x118
 8014e84: 1e61         	subs	r1, r4, #0x1
 8014e86: aa08         	add	r2, sp, #0x20
 8014e88: f852 2021    	ldr.w	r2, [r2, r1, lsl #2]
 8014e8c: f002 023f    	and	r2, r2, #0x3f
 8014e90: e7f3         	b	0x8014e7a <__kernel_rem_pio2f+0x27a> @ imm = #-0x1a
 8014e92: aa08         	add	r2, sp, #0x20
 8014e94: f852 2021    	ldr.w	r2, [r2, r1, lsl #2]
 8014e98: 3901         	subs	r1, #0x1
 8014e9a: 4310         	orrs	r0, r2
 8014e9c: e79f         	b	0x8014dde <__kernel_rem_pio2f+0x1de> @ imm = #-0xc2
 8014e9e: 3201         	adds	r2, #0x1
 8014ea0: f851 0d04    	ldr	r0, [r1, #-4]!
 8014ea4: 2800         	cmp	r0, #0x0
 8014ea6: d0fa         	beq	0x8014e9e <__kernel_rem_pio2f+0x29e> @ imm = #-0xc
 8014ea8: 9905         	ldr	r1, [sp, #0x14]
 8014eaa: f501 71b0    	add.w	r1, r1, #0x160
 8014eae: 4469         	add	r1, sp, r1
 8014eb0: eb04 000b    	add.w	r0, r4, r11
 8014eb4: f10d 0c70    	add.w	r12, sp, #0x70
 8014eb8: 1c66         	adds	r6, r4, #0x1
 8014eba: 394c         	subs	r1, #0x4c
 8014ebc: eb0c 0080    	add.w	r0, r12, r0, lsl #2
 8014ec0: 4422         	add	r2, r4
 8014ec2: 42b2         	cmp	r2, r6
 8014ec4: da04         	bge	0x8014ed0 <__kernel_rem_pio2f+0x2d0> @ imm = #0x8
 8014ec6: 4614         	mov	r4, r2
 8014ec8: e700         	b	0x8014ccc <__kernel_rem_pio2f+0xcc> @ imm = #-0x200
 8014eca: 9904         	ldr	r1, [sp, #0x10]
 8014ecc: 2201         	movs	r2, #0x1
 8014ece: e7e7         	b	0x8014ea0 <__kernel_rem_pio2f+0x2a0> @ imm = #-0x32
 8014ed0: 9c03         	ldr	r4, [sp, #0xc]
 8014ed2: f8dd c004    	ldr.w	r12, [sp, #0x4]
 8014ed6: f854 4026    	ldr.w	r4, [r4, r6, lsl #2]
 8014eda: 9405         	str	r4, [sp, #0x14]
 8014edc: ee07 4a90    	vmov	s15, r4
 8014ee0: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8014ee4: 2400         	movs	r4, #0x0
 8014ee6: ece0 7a01    	vstmia	r0!, {s15}
 8014eea: eddf 7a0c    	vldr	s15, [pc, #48]          @ 0x8014f1c <__kernel_rem_pio2f+0x31c>
 8014eee: 4686         	mov	lr, r0
 8014ef0: 429c         	cmp	r4, r3
 8014ef2: dd03         	ble	0x8014efc <__kernel_rem_pio2f+0x2fc> @ imm = #0x6
 8014ef4: ece1 7a01    	vstmia	r1!, {s15}
 8014ef8: 3601         	adds	r6, #0x1
 8014efa: e7e2         	b	0x8014ec2 <__kernel_rem_pio2f+0x2c2> @ imm = #-0x3c
 8014efc: ecfc 6a01    	vldmia	r12!, {s13}
 8014f00: ed3e 7a01    	vldmdb	lr!, {s14}
 8014f04: 3401         	adds	r4, #0x1
 8014f06: ee46 7a87    	vmla.f32	s15, s13, s14
 8014f0a: e7f1         	b	0x8014ef0 <__kernel_rem_pio2f+0x2f0> @ imm = #-0x1e

08014f0c <$d>:
 8014f0c: 7c 33 02 08  	.word	0x0802337c
 8014f10: 50 33 02 08  	.word	0x08023350
 8014f14: 00 00 80 43  	.word	0x43800000
 8014f18: 00 00 80 3b  	.word	0x3b800000
 8014f1c: 00 00 00 00  	.word	0x00000000

08014f20 <$t>:
 8014f20: 9b02         	ldr	r3, [sp, #0x8]
 8014f22: eeb0 0a48    	vmov.f32	s0, s16
 8014f26: eba3 0008    	sub.w	r0, r3, r8
 8014f2a: f000 fa13    	bl	0x8015354 <scalbnf>     @ imm = #0x426
 8014f2e: ed1f 7a07    	vldr	s14, [pc, #-28]         @ 0x8014f14 <__kernel_rem_pio2f+0x314>
 8014f32: eeb4 0ac7    	vcmpe.f32	s0, s14
 8014f36: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 8014f3a: db19         	blt	0x8014f70 <__kernel_rem_pio2f+0x370> @ imm = #0x32
 8014f3c: ed5f 7a0a    	vldr	s15, [pc, #-40]         @ 0x8014f18 <__kernel_rem_pio2f+0x318>
 8014f40: ee60 7a27    	vmul.f32	s15, s0, s15
 8014f44: aa08         	add	r2, sp, #0x20
 8014f46: eefd 7ae7    	vcvt.s32.f32	s15, s15
 8014f4a: 3508         	adds	r5, #0x8
 8014f4c: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8014f50: ee07 0ac7    	vmls.f32	s0, s15, s14
 8014f54: eefd 7ae7    	vcvt.s32.f32	s15, s15
 8014f58: eebd 0ac0    	vcvt.s32.f32	s0, s0
 8014f5c: ee10 3a10    	vmov	r3, s0
 8014f60: f842 3024    	str.w	r3, [r2, r4, lsl #2]
 8014f64: ee17 3a90    	vmov	r3, s15
 8014f68: 3401         	adds	r4, #0x1
 8014f6a: f842 3024    	str.w	r3, [r2, r4, lsl #2]
 8014f6e: e741         	b	0x8014df4 <__kernel_rem_pio2f+0x1f4> @ imm = #-0x17e
 8014f70: eebd 0ac0    	vcvt.s32.f32	s0, s0
 8014f74: aa08         	add	r2, sp, #0x20
 8014f76: ee10 3a10    	vmov	r3, s0
 8014f7a: e7f6         	b	0x8014f6a <__kernel_rem_pio2f+0x36a> @ imm = #-0x14
 8014f7c: a808         	add	r0, sp, #0x20
 8014f7e: f850 0023    	ldr.w	r0, [r0, r3, lsl #2]
 8014f82: 9001         	str	r0, [sp, #0x4]
 8014f84: ee07 0a90    	vmov	s15, r0
 8014f88: eef8 7ae7    	vcvt.f32.s32	s15, s15
 8014f8c: 3b01         	subs	r3, #0x1
 8014f8e: ee67 7a80    	vmul.f32	s15, s15, s0
 8014f92: ee20 0a07    	vmul.f32	s0, s0, s14
 8014f96: ed62 7a01    	vstmdb	r2!, {s15}
 8014f9a: e738         	b	0x8014e0e <__kernel_rem_pio2f+0x20e> @ imm = #-0x190
 8014f9c: ecfc 6a01    	vldmia	r12!, {s13}
 8014fa0: ecb5 7a01    	vldmia	r5!, {s14}
 8014fa4: ee46 7a87    	vmla.f32	s15, s13, s14
 8014fa8: 3001         	adds	r0, #0x1
 8014faa: 4550         	cmp	r0, r10
 8014fac: dc01         	bgt	0x8014fb2 <__kernel_rem_pio2f+0x3b2> @ imm = #0x2
 8014fae: 4282         	cmp	r2, r0
 8014fb0: daf4         	bge	0x8014f9c <__kernel_rem_pio2f+0x39c> @ imm = #-0x18
 8014fb2: a858         	add	r0, sp, #0x160
 8014fb4: eb00 0282    	add.w	r2, r0, r2, lsl #2
 8014fb8: ed42 7a28    	vstr	s15, [r2, #-160]
 8014fbc: 3b01         	subs	r3, #0x1
 8014fbe: e72a         	b	0x8014e16 <__kernel_rem_pio2f+0x216> @ imm = #-0x1ac
 8014fc0: 9b66         	ldr	r3, [sp, #0x198]
 8014fc2: 2b02         	cmp	r3, #0x2
 8014fc4: dc09         	bgt	0x8014fda <__kernel_rem_pio2f+0x3da> @ imm = #0x12
 8014fc6: 2b00         	cmp	r3, #0x0
 8014fc8: dc2b         	bgt	0x8015022 <__kernel_rem_pio2f+0x422> @ imm = #0x56
 8014fca: d044         	beq	0x8015056 <__kernel_rem_pio2f+0x456> @ imm = #0x88
 8014fcc: f009 0007    	and	r0, r9, #0x7
 8014fd0: b059         	add	sp, #0x164
 8014fd2: ecbd 8b04    	vpop	{d8, d9}
 8014fd6: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 8014fda: 9b66         	ldr	r3, [sp, #0x198]
 8014fdc: 2b03         	cmp	r3, #0x3
 8014fde: d1f5         	bne	0x8014fcc <__kernel_rem_pio2f+0x3cc> @ imm = #-0x16
 8014fe0: aa30         	add	r2, sp, #0xc0
 8014fe2: 1f0b         	subs	r3, r1, #0x4
 8014fe4: 4413         	add	r3, r2
 8014fe6: 461a         	mov	r2, r3
 8014fe8: 4620         	mov	r0, r4
 8014fea: 2800         	cmp	r0, #0x0
 8014fec: f1a2 0204    	sub.w	r2, r2, #0x4
 8014ff0: dc52         	bgt	0x8015098 <__kernel_rem_pio2f+0x498> @ imm = #0xa4
 8014ff2: 4622         	mov	r2, r4
 8014ff4: 2a01         	cmp	r2, #0x1
 8014ff6: f1a3 0304    	sub.w	r3, r3, #0x4
 8014ffa: dc5d         	bgt	0x80150b8 <__kernel_rem_pio2f+0x4b8> @ imm = #0xba
 8014ffc: ab30         	add	r3, sp, #0xc0
 8014ffe: ed5f 7a39    	vldr	s15, [pc, #-228]        @ 0x8014f1c <__kernel_rem_pio2f+0x31c>
 8015002: 440b         	add	r3, r1
 8015004: 2c01         	cmp	r4, #0x1
 8015006: dc67         	bgt	0x80150d8 <__kernel_rem_pio2f+0x4d8> @ imm = #0xce
 8015008: eddd 6a30    	vldr	s13, [sp, #192]
 801500c: ed9d 7a31    	vldr	s14, [sp, #196]
 8015010: 2e00         	cmp	r6, #0x0
 8015012: d167         	bne	0x80150e4 <__kernel_rem_pio2f+0x4e4> @ imm = #0xce
 8015014: edc7 6a00    	vstr	s13, [r7]
 8015018: ed87 7a01    	vstr	s14, [r7, #4]
 801501c: edc7 7a02    	vstr	s15, [r7, #8]
 8015020: e7d4         	b	0x8014fcc <__kernel_rem_pio2f+0x3cc> @ imm = #-0x58
 8015022: ab30         	add	r3, sp, #0xc0
 8015024: ed1f 7a43    	vldr	s14, [pc, #-268]        @ 0x8014f1c <__kernel_rem_pio2f+0x31c>
 8015028: 440b         	add	r3, r1
 801502a: 4622         	mov	r2, r4
 801502c: 2a00         	cmp	r2, #0x0
 801502e: da24         	bge	0x801507a <__kernel_rem_pio2f+0x47a> @ imm = #0x48
 8015030: b34e         	cbz	r6, 0x8015086 <__kernel_rem_pio2f+0x486> @ imm = #0x52
 8015032: eef1 7a47    	vneg.f32	s15, s14
 8015036: edc7 7a00    	vstr	s15, [r7]
 801503a: eddd 7a30    	vldr	s15, [sp, #192]
 801503e: ee77 7ac7    	vsub.f32	s15, s15, s14
 8015042: aa31         	add	r2, sp, #0xc4
 8015044: 2301         	movs	r3, #0x1
 8015046: 429c         	cmp	r4, r3
 8015048: da20         	bge	0x801508c <__kernel_rem_pio2f+0x48c> @ imm = #0x40
 801504a: b10e         	cbz	r6, 0x8015050 <__kernel_rem_pio2f+0x450> @ imm = #0x2
 801504c: eef1 7a67    	vneg.f32	s15, s15
 8015050: edc7 7a01    	vstr	s15, [r7, #4]
 8015054: e7ba         	b	0x8014fcc <__kernel_rem_pio2f+0x3cc> @ imm = #-0x8c
 8015056: ab30         	add	r3, sp, #0xc0
 8015058: ed5f 7a50    	vldr	s15, [pc, #-320]        @ 0x8014f1c <__kernel_rem_pio2f+0x31c>
 801505c: 440b         	add	r3, r1
 801505e: 2c00         	cmp	r4, #0x0
 8015060: da05         	bge	0x801506e <__kernel_rem_pio2f+0x46e> @ imm = #0xa
 8015062: b10e         	cbz	r6, 0x8015068 <__kernel_rem_pio2f+0x468> @ imm = #0x2
 8015064: eef1 7a67    	vneg.f32	s15, s15
 8015068: edc7 7a00    	vstr	s15, [r7]
 801506c: e7ae         	b	0x8014fcc <__kernel_rem_pio2f+0x3cc> @ imm = #-0xa4
 801506e: ed33 7a01    	vldmdb	r3!, {s14}
 8015072: 3c01         	subs	r4, #0x1
 8015074: ee77 7a87    	vadd.f32	s15, s15, s14
 8015078: e7f1         	b	0x801505e <__kernel_rem_pio2f+0x45e> @ imm = #-0x1e
 801507a: ed73 7a01    	vldmdb	r3!, {s15}
 801507e: 3a01         	subs	r2, #0x1
 8015080: ee37 7a27    	vadd.f32	s14, s14, s15
 8015084: e7d2         	b	0x801502c <__kernel_rem_pio2f+0x42c> @ imm = #-0x5c
 8015086: eef0 7a47    	vmov.f32	s15, s14
 801508a: e7d4         	b	0x8015036 <__kernel_rem_pio2f+0x436> @ imm = #-0x58
 801508c: ecb2 7a01    	vldmia	r2!, {s14}
 8015090: 3301         	adds	r3, #0x1
 8015092: ee77 7a87    	vadd.f32	s15, s15, s14
 8015096: e7d6         	b	0x8015046 <__kernel_rem_pio2f+0x446> @ imm = #-0x54
 8015098: edd2 7a00    	vldr	s15, [r2]
 801509c: edd2 6a01    	vldr	s13, [r2, #4]
 80150a0: ee37 7aa6    	vadd.f32	s14, s15, s13
 80150a4: 3801         	subs	r0, #0x1
 80150a6: ee77 7ac7    	vsub.f32	s15, s15, s14
 80150aa: ed82 7a00    	vstr	s14, [r2]
 80150ae: ee77 7aa6    	vadd.f32	s15, s15, s13
 80150b2: edc2 7a01    	vstr	s15, [r2, #4]
 80150b6: e798         	b	0x8014fea <__kernel_rem_pio2f+0x3ea> @ imm = #-0xd0
 80150b8: edd3 7a00    	vldr	s15, [r3]
 80150bc: edd3 6a01    	vldr	s13, [r3, #4]
 80150c0: ee37 7aa6    	vadd.f32	s14, s15, s13
 80150c4: 3a01         	subs	r2, #0x1
 80150c6: ee77 7ac7    	vsub.f32	s15, s15, s14
 80150ca: ed83 7a00    	vstr	s14, [r3]
 80150ce: ee77 7aa6    	vadd.f32	s15, s15, s13
 80150d2: edc3 7a01    	vstr	s15, [r3, #4]
 80150d6: e78d         	b	0x8014ff4 <__kernel_rem_pio2f+0x3f4> @ imm = #-0xe6
 80150d8: ed33 7a01    	vldmdb	r3!, {s14}
 80150dc: 3c01         	subs	r4, #0x1
 80150de: ee77 7a87    	vadd.f32	s15, s15, s14
 80150e2: e78f         	b	0x8015004 <__kernel_rem_pio2f+0x404> @ imm = #-0xe2
 80150e4: eef1 6a66    	vneg.f32	s13, s13
 80150e8: eeb1 7a47    	vneg.f32	s14, s14
 80150ec: edc7 6a00    	vstr	s13, [r7]
 80150f0: ed87 7a01    	vstr	s14, [r7, #4]
 80150f4: eef1 7a67    	vneg.f32	s15, s15
 80150f8: e790         	b	0x801501c <__kernel_rem_pio2f+0x41c> @ imm = #-0xe0
 80150fa: bf00         	nop

080150fc <__kernel_sinf>:
 80150fc: ee10 3a10    	vmov	r3, s0
 8015100: f023 4300    	bic	r3, r3, #0x80000000
 8015104: f1b3 5f48    	cmp.w	r3, #0x32000000
 8015108: eef0 7a40    	vmov.f32	s15, s0
 801510c: d201         	bhs	0x8015112 <__kernel_sinf+0x16> @ imm = #0x2
 801510e: f000 b913    	b.w	0x8015338 <__math_inexactf> @ imm = #0x226
 8015112: ee60 6a00    	vmul.f32	s13, s0, s0
 8015116: ed9f 7a16    	vldr	s14, [pc, #88]          @ 0x8015170 <__kernel_sinf+0x74>
 801511a: eddf 5a16    	vldr	s11, [pc, #88]          @ 0x8015174 <__kernel_sinf+0x78>
 801511e: ee56 5a87    	vnmls.f32	s11, s13, s14
 8015122: ed9f 7a15    	vldr	s14, [pc, #84]          @ 0x8015178 <__kernel_sinf+0x7c>
 8015126: ee05 7aa6    	vmla.f32	s14, s11, s13
 801512a: eddf 5a14    	vldr	s11, [pc, #80]          @ 0x801517c <__kernel_sinf+0x80>
 801512e: ee57 5a26    	vnmls.f32	s11, s14, s13
 8015132: ed9f 7a13    	vldr	s14, [pc, #76]          @ 0x8015180 <__kernel_sinf+0x84>
 8015136: ee20 6a26    	vmul.f32	s12, s0, s13
 801513a: ee05 7aa6    	vmla.f32	s14, s11, s13
 801513e: b940         	cbnz	r0, 0x8015152 <__kernel_sinf+0x56> @ imm = #0x10
 8015140: eddf 5a10    	vldr	s11, [pc, #64]          @ 0x8015184 <__kernel_sinf+0x88>
 8015144: ee56 5a87    	vnmls.f32	s11, s13, s14
 8015148: ee45 7a86    	vmla.f32	s15, s11, s12
 801514c: eeb0 0a67    	vmov.f32	s0, s15
 8015150: 4770         	bx	lr
 8015152: ee26 7a07    	vmul.f32	s14, s12, s14
 8015156: eef6 5a00    	vmov.f32	s11, #5.000000e-01
 801515a: ee10 7aa5    	vnmls.f32	s14, s1, s11
 801515e: ee57 0a26    	vnmls.f32	s1, s14, s13
 8015162: ed9f 7a09    	vldr	s14, [pc, #36]          @ 0x8015188 <__kernel_sinf+0x8c>
 8015166: ee46 0a47    	vmls.f32	s1, s12, s14
 801516a: ee30 0a60    	vsub.f32	s0, s0, s1
 801516e: 4770         	bx	lr

08015170 <$d>:
 8015170: d3 c9 2e 2f  	.word	0x2f2ec9d3
 8015174: 34 2f d7 32  	.word	0x32d72f34
 8015178: 1b ef 38 36  	.word	0x3638ef1b
 801517c: 01 0d 50 39  	.word	0x39500d01
 8015180: 89 88 08 3c  	.word	0x3c088889
 8015184: ab aa 2a 3e  	.word	0x3e2aaaab
 8015188: ab aa 2a be  	.word	0xbe2aaaab

0801518c <atanf>:
 801518c: ee10 2a10    	vmov	r2, s0
 8015190: f022 4300    	bic	r3, r2, #0x80000000
 8015194: f1b3 4fa1    	cmp.w	r3, #0x50800000
 8015198: d312         	blo	0x80151c0 <atanf+0x34>  @ imm = #0x24
 801519a: f1b3 4fff    	cmp.w	r3, #0x7f800000
 801519e: d902         	bls	0x80151a6 <atanf+0x1a>  @ imm = #0x4
 80151a0: ee30 0a00    	vadd.f32	s0, s0, s0
 80151a4: 4770         	bx	lr
 80151a6: 2a00         	cmp	r2, #0x0
 80151a8: ed9f 0a4f    	vldr	s0, [pc, #316]          @ 0x80152e8 <atanf+0x15c>
 80151ac: bfcb         	itete	gt
 80151ae: eddf 7a4f    	vldrgt	s15, [pc, #316]         @ 0x80152ec <atanf+0x160>
 80151b2: eddf 7a4f    	vldrle	s15, [pc, #316]         @ 0x80152f0 <atanf+0x164>
 80151b6: ee37 0a80    	vaddgt.f32	s0, s15, s0
 80151ba: ee37 0ac0    	vsuble.f32	s0, s15, s0
 80151be: 4770         	bx	lr
 80151c0: 494c         	ldr	r1, [pc, #0x130]        @ 0x80152f4 <atanf+0x168>
 80151c2: 428b         	cmp	r3, r1
 80151c4: d811         	bhi	0x80151ea <atanf+0x5e>  @ imm = #0x22
 80151c6: f1b3 5f44    	cmp.w	r3, #0x31000000
 80151ca: d20b         	bhs	0x80151e4 <atanf+0x58>  @ imm = #0x16
 80151cc: eddf 7a4a    	vldr	s15, [pc, #296]         @ 0x80152f8 <atanf+0x16c>
 80151d0: ee70 7a27    	vadd.f32	s15, s0, s15
 80151d4: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 80151d8: eef4 7ac7    	vcmpe.f32	s15, s14
 80151dc: eef1 fa10    	vmrs	APSR_nzcv, fpscr
 80151e0: f300 8081    	bgt.w	0x80152e6 <atanf+0x15a> @ imm = #0x102
 80151e4: f04f 33ff    	mov.w	r3, #0xffffffff
 80151e8: e015         	b	0x8015216 <atanf+0x8a>  @ imm = #0x2a
 80151ea: 4944         	ldr	r1, [pc, #0x110]        @ 0x80152fc <atanf+0x170>
 80151ec: eef0 7ac0    	vabs.f32	s15, s0
 80151f0: 428b         	cmp	r3, r1
 80151f2: d84f         	bhi	0x8015294 <atanf+0x108> @ imm = #0x9e
 80151f4: f5a1 01d0    	sub.w	r1, r1, #0x680000
 80151f8: 428b         	cmp	r3, r1
 80151fa: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 80151fe: d841         	bhi	0x8015284 <atanf+0xf8>  @ imm = #0x82
 8015200: ee77 6aa7    	vadd.f32	s13, s15, s15
 8015204: 2300         	movs	r3, #0x0
 8015206: ee36 7ac7    	vsub.f32	s14, s13, s14
 801520a: eef0 6a00    	vmov.f32	s13, #2.000000e+00
 801520e: ee77 7aa6    	vadd.f32	s15, s15, s13
 8015212: ee87 0a27    	vdiv.f32	s0, s14, s15
 8015216: 1c59         	adds	r1, r3, #0x1
 8015218: ee60 6a00    	vmul.f32	s13, s0, s0
 801521c: eddf 7a38    	vldr	s15, [pc, #224]         @ 0x8015300 <atanf+0x174>
 8015220: ed9f 6a38    	vldr	s12, [pc, #224]         @ 0x8015304 <atanf+0x178>
 8015224: eddf 5a38    	vldr	s11, [pc, #224]         @ 0x8015308 <atanf+0x17c>
 8015228: ee26 7aa6    	vmul.f32	s14, s13, s13
 801522c: ee07 6a27    	vmla.f32	s12, s14, s15
 8015230: eddf 7a36    	vldr	s15, [pc, #216]         @ 0x801530c <atanf+0x180>
 8015234: ee46 7a07    	vmla.f32	s15, s12, s14
 8015238: ed9f 6a35    	vldr	s12, [pc, #212]         @ 0x8015310 <atanf+0x184>
 801523c: ee07 6a87    	vmla.f32	s12, s15, s14
 8015240: eddf 7a34    	vldr	s15, [pc, #208]         @ 0x8015314 <atanf+0x188>
 8015244: ee46 7a07    	vmla.f32	s15, s12, s14
 8015248: ed9f 6a33    	vldr	s12, [pc, #204]         @ 0x8015318 <atanf+0x18c>
 801524c: ee07 6a87    	vmla.f32	s12, s15, s14
 8015250: eddf 7a32    	vldr	s15, [pc, #200]         @ 0x801531c <atanf+0x190>
 8015254: ee57 5a27    	vnmls.f32	s11, s14, s15
 8015258: eddf 7a31    	vldr	s15, [pc, #196]         @ 0x8015320 <atanf+0x194>
 801525c: ee55 7a87    	vnmls.f32	s15, s11, s14
 8015260: eddf 5a30    	vldr	s11, [pc, #192]         @ 0x8015324 <atanf+0x198>
 8015264: ee57 5a87    	vnmls.f32	s11, s15, s14
 8015268: eddf 7a2f    	vldr	s15, [pc, #188]         @ 0x8015328 <atanf+0x19c>
 801526c: ee55 7a87    	vnmls.f32	s15, s11, s14
 8015270: ee67 7a87    	vmul.f32	s15, s15, s14
 8015274: ee46 7a26    	vmla.f32	s15, s12, s13
 8015278: ee67 7a80    	vmul.f32	s15, s15, s0
 801527c: d11f         	bne	0x80152be <atanf+0x132> @ imm = #0x3e
 801527e: ee30 0a67    	vsub.f32	s0, s0, s15
 8015282: 4770         	bx	lr
 8015284: ee77 6ac7    	vsub.f32	s13, s15, s14
 8015288: ee77 7a87    	vadd.f32	s15, s15, s14
 801528c: 2301         	movs	r3, #0x1
 801528e: ee86 0aa7    	vdiv.f32	s0, s13, s15
 8015292: e7c0         	b	0x8015216 <atanf+0x8a>  @ imm = #-0x80
 8015294: 4925         	ldr	r1, [pc, #0x94]         @ 0x801532c <atanf+0x1a0>
 8015296: 428b         	cmp	r3, r1
 8015298: d80b         	bhi	0x80152b2 <atanf+0x126> @ imm = #0x16
 801529a: eef7 6a08    	vmov.f32	s13, #1.500000e+00
 801529e: eeb7 7a00    	vmov.f32	s14, #1.000000e+00
 80152a2: ee07 7aa6    	vmla.f32	s14, s15, s13
 80152a6: 2302         	movs	r3, #0x2
 80152a8: ee37 6ae6    	vsub.f32	s12, s15, s13
 80152ac: ee86 0a07    	vdiv.f32	s0, s12, s14
 80152b0: e7b1         	b	0x8015216 <atanf+0x8a>  @ imm = #-0x9e
 80152b2: eebf 7a00    	vmov.f32	s14, #-1.000000e+00
 80152b6: ee87 0a27    	vdiv.f32	s0, s14, s15
 80152ba: 2303         	movs	r3, #0x3
 80152bc: e7ab         	b	0x8015216 <atanf+0x8a>  @ imm = #-0xaa
 80152be: 491c         	ldr	r1, [pc, #0x70]         @ 0x8015330 <atanf+0x1a4>
 80152c0: 481c         	ldr	r0, [pc, #0x70]         @ 0x8015334 <atanf+0x1a8>
 80152c2: eb01 0183    	add.w	r1, r1, r3, lsl #2
 80152c6: eb00 0383    	add.w	r3, r0, r3, lsl #2
 80152ca: ed93 7a00    	vldr	s14, [r3]
 80152ce: ee77 7ac7    	vsub.f32	s15, s15, s14
 80152d2: 2a00         	cmp	r2, #0x0
 80152d4: ee77 7ac0    	vsub.f32	s15, s15, s0
 80152d8: ed91 0a00    	vldr	s0, [r1]
 80152dc: ee30 0a67    	vsub.f32	s0, s0, s15
 80152e0: bfb8         	it	lt
 80152e2: eeb1 0a40    	vneglt.f32	s0, s0
 80152e6: 4770         	bx	lr

080152e8 <$d>:
 80152e8: 68 21 a2 33  	.word	0x33a22168
 80152ec: da 0f c9 3f  	.word	0x3fc90fda
 80152f0: da 0f c9 bf  	.word	0xbfc90fda
 80152f4: ff ff df 3e  	.word	0x3edfffff
 80152f8: ca f2 49 71  	.word	0x7149f2ca
 80152fc: ff ff 97 3f  	.word	0x3f97ffff
 8015300: d7 69 85 3c  	.word	0x3c8569d7
 8015304: 59 da 4b 3d  	.word	0x3d4bda59
 8015308: 6b f1 6e 3d  	.word	0x3d6ef16b
 801530c: 35 6b 88 3d  	.word	0x3d886b35
 8015310: 6e 2e ba 3d  	.word	0x3dba2e6e
 8015314: 25 49 12 3e  	.word	0x3e124925
 8015318: ab aa aa 3e  	.word	0x3eaaaaab
 801531c: 21 a2 15 bd  	.word	0xbd15a221
 8015320: 95 87 9d 3d  	.word	0x3d9d8795
 8015324: 38 8e e3 3d  	.word	0x3de38e38
 8015328: cd cc 4c 3e  	.word	0x3e4ccccd
 801532c: ff ff 1b 40  	.word	0x401bffff
 8015330: 98 33 02 08  	.word	0x08023398
 8015334: 88 33 02 08  	.word	0x08023388

08015338 <__math_inexactf>:
 8015338: ed9f 7a05    	vldr	s14, [pc, #20]          @ 0x8015350 <__math_inexactf+0x18>
 801533c: eef7 7a00    	vmov.f32	s15, #1.000000e+00
 8015340: ee77 7a87    	vadd.f32	s15, s15, s14
 8015344: b082         	sub	sp, #0x8
 8015346: edcd 7a01    	vstr	s15, [sp, #4]
 801534a: 9b01         	ldr	r3, [sp, #0x4]
 801534c: b002         	add	sp, #0x8
 801534e: 4770         	bx	lr

08015350 <$d>:
 8015350: 00 00 80 00  	.word	0x00800000

08015354 <scalbnf>:
 8015354: 4602         	mov	r2, r0
 8015356: ee10 0a10    	vmov	r0, s0
 801535a: f3c0 53c7    	ubfx	r3, r0, #0x17, #0x8
 801535e: f020 4100    	bic	r1, r0, #0x80000000
 8015362: b983         	cbnz	r3, 0x8015386 <scalbnf+0x32> @ imm = #0x20
 8015364: b3a9         	cbz	r1, 0x80153d2 <scalbnf+0x7e> @ imm = #0x6a
 8015366: eddf 7a1b    	vldr	s15, [pc, #108]         @ 0x80153d4 <scalbnf+0x80>
 801536a: 491b         	ldr	r1, [pc, #0x6c]         @ 0x80153d8 <scalbnf+0x84>
 801536c: ee60 7a27    	vmul.f32	s15, s0, s15
 8015370: 428a         	cmp	r2, r1
 8015372: ee17 0a90    	vmov	r0, s15
 8015376: f3c0 53c7    	ubfx	r3, r0, #0x17, #0x8
 801537a: f1a3 0319    	sub.w	r3, r3, #0x19
 801537e: da07         	bge	0x8015390 <scalbnf+0x3c> @ imm = #0xe
 8015380: 0fc0         	lsrs	r0, r0, #0x1f
 8015382: f7ff bbb1    	b.w	0x8014ae8 <__math_uflowf> @ imm = #-0x89e
 8015386: 2bff         	cmp	r3, #0xff
 8015388: d102         	bne	0x8015390 <scalbnf+0x3c> @ imm = #0x4
 801538a: ee30 0a00    	vadd.f32	s0, s0, s0
 801538e: 4770         	bx	lr
 8015390: f24c 3150    	movw	r1, #0xc350
 8015394: 428a         	cmp	r2, r1
 8015396: dd02         	ble	0x801539e <scalbnf+0x4a> @ imm = #0x4
 8015398: 0fc0         	lsrs	r0, r0, #0x1f
 801539a: f7ff bbb5    	b.w	0x8014b08 <__math_oflowf> @ imm = #-0x896
 801539e: 4413         	add	r3, r2
 80153a0: 2bfe         	cmp	r3, #0xfe
 80153a2: dcf9         	bgt	0x8015398 <scalbnf+0x44> @ imm = #-0xe
 80153a4: 2b00         	cmp	r3, #0x0
 80153a6: dd06         	ble	0x80153b6 <scalbnf+0x62> @ imm = #0xc
 80153a8: f020 40ff    	bic	r0, r0, #0x7f800000
 80153ac: ea40 53c3    	orr.w	r3, r0, r3, lsl #23
 80153b0: ee00 3a10    	vmov	s0, r3
 80153b4: 4770         	bx	lr
 80153b6: f113 0f18    	cmn.w	r3, #0x18
 80153ba: dbe1         	blt	0x8015380 <scalbnf+0x2c> @ imm = #-0x3e
 80153bc: 3319         	adds	r3, #0x19
 80153be: f020 40ff    	bic	r0, r0, #0x7f800000
 80153c2: ea40 50c3    	orr.w	r0, r0, r3, lsl #23
 80153c6: ed9f 0a05    	vldr	s0, [pc, #20]           @ 0x80153dc <scalbnf+0x88>
 80153ca: ee07 0a90    	vmov	s15, r0
 80153ce: ee27 0a80    	vmul.f32	s0, s15, s0
 80153d2: 4770         	bx	lr

080153d4 <$d>:
 80153d4: 00 00 00 4c  	.word	0x4c000000
 80153d8: b0 3c ff ff  	.word	0xffff3cb0
 80153dc: 00 00 00 33  	.word	0x33000000

080153e0 <__fpclassifyf>:
 80153e0: ee10 3a10    	vmov	r3, s0
 80153e4: f033 4000    	bics	r0, r3, #0x80000000
 80153e8: d00d         	beq	0x8015406 <__fpclassifyf+0x26> @ imm = #0x1a
 80153ea: f5a0 0300    	sub.w	r3, r0, #0x800000
 80153ee: f1b3 4ffe    	cmp.w	r3, #0x7f000000
 80153f2: d30a         	blo	0x801540a <__fpclassifyf+0x2a> @ imm = #0x14
 80153f4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8015414 <__fpclassifyf+0x34>
 80153f6: 1e42         	subs	r2, r0, #0x1
 80153f8: 429a         	cmp	r2, r3
 80153fa: d908         	bls	0x801540e <__fpclassifyf+0x2e> @ imm = #0x10
 80153fc: f1a0 43ff    	sub.w	r3, r0, #0x7f800000
 8015400: 4258         	rsbs	r0, r3, #0
 8015402: 4158         	adcs	r0, r3
 8015404: 4770         	bx	lr
 8015406: 2002         	movs	r0, #0x2
 8015408: 4770         	bx	lr
 801540a: 2004         	movs	r0, #0x4
 801540c: 4770         	bx	lr
 801540e: 2003         	movs	r0, #0x3
 8015410: 4770         	bx	lr
 8015412: bf00         	nop

08015414 <$d>:
 8015414: fe ff 7f 00  	.word	0x007ffffe

08015418 <floorf>:
 8015418: ee10 1a10    	vmov	r1, s0
 801541c: f3c1 53c7    	ubfx	r3, r1, #0x17, #0x8
 8015420: 3b7f         	subs	r3, #0x7f
 8015422: 2b16         	cmp	r3, #0x16
 8015424: f021 4000    	bic	r0, r1, #0x80000000
 8015428: dc1a         	bgt	0x8015460 <floorf+0x48> @ imm = #0x34
 801542a: 2b00         	cmp	r3, #0x0
 801542c: 460a         	mov	r2, r1
 801542e: da09         	bge	0x8015444 <floorf+0x2c> @ imm = #0x12
 8015430: 2900         	cmp	r1, #0x0
 8015432: da1b         	bge	0x801546c <floorf+0x54> @ imm = #0x36
 8015434: 2800         	cmp	r0, #0x0
 8015436: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8015470 <floorf+0x58>
 8015438: bf08         	it	eq
 801543a: f04f 4300    	moveq.w	r3, #0x80000000
 801543e: ee00 3a10    	vmov	s0, r3
 8015442: 4770         	bx	lr
 8015444: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8015474 <floorf+0x5c>
 8015446: 4119         	asrs	r1, r3
 8015448: 4211         	tst	r1, r2
 801544a: d0fa         	beq	0x8015442 <floorf+0x2a> @ imm = #-0xc
 801544c: 2a00         	cmp	r2, #0x0
 801544e: bfbe         	ittt	lt
 8015450: f44f 0000    	movlt.w	r0, #0x800000
 8015454: fa40 f303    	asrlt.w	r3, r0, r3
 8015458: 18d2         	addlt	r2, r2, r3
 801545a: ea22 0301    	bic.w	r3, r2, r1
 801545e: e7ee         	b	0x801543e <floorf+0x26> @ imm = #-0x24
 8015460: f1b0 4fff    	cmp.w	r0, #0x7f800000
 8015464: d3ed         	blo	0x8015442 <floorf+0x2a> @ imm = #-0x26
 8015466: ee30 0a00    	vadd.f32	s0, s0, s0
 801546a: 4770         	bx	lr
 801546c: 2300         	movs	r3, #0x0
 801546e: e7e6         	b	0x801543e <floorf+0x26> @ imm = #-0x34

08015470 <$d>:
 8015470: 00 00 80 bf  	.word	0xbf800000
 8015474: ff ff 7f 00  	.word	0x007fffff

08015478 <_OffsetAbsSyms>:
; GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
 8015478: b480         	push	{r7}
 801547a: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 801547c: bf00         	nop
 801547e: 46bd         	mov	sp, r7
 8015480: f85d 7b04    	ldr	r7, [sp], #4
 8015484: 4770         	bx	lr

08015486 <device_is_ready>:
; {
 8015486: b580         	push	{r7, lr}
 8015488: b082         	sub	sp, #0x8
 801548a: af00         	add	r7, sp, #0x0
 801548c: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801548e: 6878         	ldr	r0, [r7, #0x4]
 8015490: f008 fd9e    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x8b3c
 8015494: 4603         	mov	r3, r0
; }
 8015496: 4618         	mov	r0, r3
 8015498: 3708         	adds	r7, #0x8
 801549a: 46bd         	mov	sp, r7
 801549c: bd80         	pop	{r7, pc}

0801549e <arch_k_cycle_get_32>:
; {
 801549e: b580         	push	{r7, lr}
 80154a0: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 80154a2: f7f8 ffc5    	bl	0x800e430 <sys_clock_cycle_get_32> @ imm = #-0x7076
 80154a6: 4603         	mov	r3, r0
; }
 80154a8: 4618         	mov	r0, r3
 80154aa: bd80         	pop	{r7, pc}

080154ac <z_log_msg_runtime_create>:
; {
 80154ac: b580         	push	{r7, lr}
 80154ae: b08a         	sub	sp, #0x28
 80154b0: af04         	add	r7, sp, #0x10
 80154b2: 60b9         	str	r1, [r7, #0x8]
 80154b4: 607b         	str	r3, [r7, #0x4]
 80154b6: 4603         	mov	r3, r0
 80154b8: 73fb         	strb	r3, [r7, #0xf]
 80154ba: 4613         	mov	r3, r2
 80154bc: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80154be: f107 032c    	add.w	r3, r7, #0x2c
 80154c2: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80154c4: 7bba         	ldrb	r2, [r7, #0xe]
 80154c6: 7bf8         	ldrb	r0, [r7, #0xf]
 80154c8: 697b         	ldr	r3, [r7, #0x14]
 80154ca: 9303         	str	r3, [sp, #0xc]
 80154cc: 6abb         	ldr	r3, [r7, #0x28]
 80154ce: 9302         	str	r3, [sp, #0x8]
 80154d0: 6a7b         	ldr	r3, [r7, #0x24]
 80154d2: 9301         	str	r3, [sp, #0x4]
 80154d4: 6a3b         	ldr	r3, [r7, #0x20]
 80154d6: 9300         	str	r3, [sp]
 80154d8: 687b         	ldr	r3, [r7, #0x4]
 80154da: 68b9         	ldr	r1, [r7, #0x8]
 80154dc: f7f0 f84a    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0xff6c
; }
 80154e0: bf00         	nop
 80154e2: 3718         	adds	r7, #0x18
 80154e4: 46bd         	mov	sp, r7
 80154e6: bd80         	pop	{r7, pc}

080154e8 <k_msleep>:
; {
 80154e8: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 80154ec: b082         	sub	sp, #0x8
 80154ee: af00         	add	r7, sp, #0x0
 80154f0: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 80154f2: 6879         	ldr	r1, [r7, #0x4]
 80154f4: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 80154f8: 17c8         	asrs	r0, r1, #0x1f
 80154fa: 4688         	mov	r8, r1
 80154fc: 4681         	mov	r9, r0
 80154fe: 4640         	mov	r0, r8
 8015500: 4649         	mov	r1, r9
 8015502: f04f 0400    	mov.w	r4, #0x0
 8015506: f04f 0500    	mov.w	r5, #0x0
 801550a: 008d         	lsls	r5, r1, #0x2
 801550c: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 8015510: 0084         	lsls	r4, r0, #0x2
 8015512: 4620         	mov	r0, r4
 8015514: 4629         	mov	r1, r5
 8015516: eb10 0208    	adds.w	r2, r0, r8
 801551a: eb41 0309    	adc.w	r3, r1, r9
 801551e: eb12 0a02    	adds.w	r10, r2, r2
 8015522: eb43 0b03    	adc.w	r11, r3, r3
 8015526: 4652         	mov	r2, r10
 8015528: 465b         	mov	r3, r11
 801552a: 4610         	mov	r0, r2
 801552c: 4619         	mov	r1, r3
 801552e: f000 f82e    	bl	0x801558e <k_sleep>     @ imm = #0x5c
 8015532: 4601         	mov	r1, r0
 8015534: 460b         	mov	r3, r1
; }
 8015536: 4618         	mov	r0, r3
 8015538: 3708         	adds	r7, #0x8
 801553a: 46bd         	mov	sp, r7
 801553c: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08015540 <k_cycle_get_32>:
; {
 8015540: b580         	push	{r7, lr}
 8015542: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 8015544: f7ff ffab    	bl	0x801549e <arch_k_cycle_get_32> @ imm = #-0xaa
 8015548: 4603         	mov	r3, r0
; }
 801554a: 4618         	mov	r0, r3
 801554c: bd80         	pop	{r7, pc}

0801554e <k_thread_create>:
; {
 801554e: b580         	push	{r7, lr}
 8015550: b08c         	sub	sp, #0x30
 8015552: af08         	add	r7, sp, #0x20
 8015554: 60f8         	str	r0, [r7, #0xc]
 8015556: 60b9         	str	r1, [r7, #0x8]
 8015558: 607a         	str	r2, [r7, #0x4]
 801555a: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 801555c: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 8015560: e9cd 2306    	strd	r2, r3, [sp, #24]
 8015564: 6abb         	ldr	r3, [r7, #0x28]
 8015566: 9304         	str	r3, [sp, #0x10]
 8015568: 6a7b         	ldr	r3, [r7, #0x24]
 801556a: 9303         	str	r3, [sp, #0xc]
 801556c: 6a3b         	ldr	r3, [r7, #0x20]
 801556e: 9302         	str	r3, [sp, #0x8]
 8015570: 69fb         	ldr	r3, [r7, #0x1c]
 8015572: 9301         	str	r3, [sp, #0x4]
 8015574: 69bb         	ldr	r3, [r7, #0x18]
 8015576: 9300         	str	r3, [sp]
 8015578: 683b         	ldr	r3, [r7]
 801557a: 687a         	ldr	r2, [r7, #0x4]
 801557c: 68b9         	ldr	r1, [r7, #0x8]
 801557e: 68f8         	ldr	r0, [r7, #0xc]
 8015580: f009 fd2e    	bl	0x801efe0 <z_impl_k_thread_create> @ imm = #0x9a5c
 8015584: 4603         	mov	r3, r0
; }
 8015586: 4618         	mov	r0, r3
 8015588: 3710         	adds	r7, #0x10
 801558a: 46bd         	mov	sp, r7
 801558c: bd80         	pop	{r7, pc}

0801558e <k_sleep>:
; {
 801558e: b580         	push	{r7, lr}
 8015590: b082         	sub	sp, #0x8
 8015592: af00         	add	r7, sp, #0x0
 8015594: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8015598: e9d7 0100    	ldrd	r0, r1, [r7]
 801559c: f7fc fe18    	bl	0x80121d0 <z_impl_k_sleep> @ imm = #-0x33d0
 80155a0: 4603         	mov	r3, r0
; }
 80155a2: 4618         	mov	r0, r3
 80155a4: 3708         	adds	r7, #0x8
 80155a6: 46bd         	mov	sp, r7
 80155a8: bd80         	pop	{r7, pc}

080155aa <k_thread_abort>:
; {
 80155aa: b580         	push	{r7, lr}
 80155ac: b082         	sub	sp, #0x8
 80155ae: af00         	add	r7, sp, #0x0
 80155b0: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 80155b2: 6878         	ldr	r0, [r7, #0x4]
 80155b4: f7f1 fc04    	bl	0x8006dc0 <z_impl_k_thread_abort> @ imm = #-0xe7f8
; }
 80155b8: bf00         	nop
 80155ba: 3708         	adds	r7, #0x8
 80155bc: 46bd         	mov	sp, r7
 80155be: bd80         	pop	{r7, pc}

080155c0 <k_thread_name_set>:
; {
 80155c0: b580         	push	{r7, lr}
 80155c2: b082         	sub	sp, #0x8
 80155c4: af00         	add	r7, sp, #0x0
 80155c6: 6078         	str	r0, [r7, #0x4]
 80155c8: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 80155ca: 6839         	ldr	r1, [r7]
 80155cc: 6878         	ldr	r0, [r7, #0x4]
 80155ce: f7fb fa55    	bl	0x8010a7c <z_impl_k_thread_name_set> @ imm = #-0x4b56
 80155d2: 4603         	mov	r3, r0
; }
 80155d4: 4618         	mov	r0, r3
 80155d6: 3708         	adds	r7, #0x8
 80155d8: 46bd         	mov	sp, r7
 80155da: bd80         	pop	{r7, pc}

080155dc <sensor_trigger_set>:
; {
 80155dc: b580         	push	{r7, lr}
 80155de: b086         	sub	sp, #0x18
 80155e0: af00         	add	r7, sp, #0x0
 80155e2: 60f8         	str	r0, [r7, #0xc]
 80155e4: 60b9         	str	r1, [r7, #0x8]
 80155e6: 607a         	str	r2, [r7, #0x4]
; 	const struct sensor_driver_api *api =
 80155e8: 68fb         	ldr	r3, [r7, #0xc]
 80155ea: 689b         	ldr	r3, [r3, #0x8]
 80155ec: 617b         	str	r3, [r7, #0x14]
; 	if (api->trigger_set == NULL) {
 80155ee: 697b         	ldr	r3, [r7, #0x14]
 80155f0: 689b         	ldr	r3, [r3, #0x8]
 80155f2: 2b00         	cmp	r3, #0x0
 80155f4: d102         	bne	0x80155fc <sensor_trigger_set+0x20> @ imm = #0x4
; 		return -ENOSYS;
 80155f6: f06f 0357    	mvn	r3, #0x57
 80155fa: e006         	b	0x801560a <sensor_trigger_set+0x2e> @ imm = #0xc
; 	return api->trigger_set(dev, trig, handler);
 80155fc: 697b         	ldr	r3, [r7, #0x14]
 80155fe: 689b         	ldr	r3, [r3, #0x8]
 8015600: 687a         	ldr	r2, [r7, #0x4]
 8015602: 68b9         	ldr	r1, [r7, #0x8]
 8015604: 68f8         	ldr	r0, [r7, #0xc]
 8015606: 4798         	blx	r3
 8015608: 4603         	mov	r3, r0
; }
 801560a: 4618         	mov	r0, r3
 801560c: 3718         	adds	r7, #0x18
 801560e: 46bd         	mov	sp, r7
 8015610: bd80         	pop	{r7, pc}

08015612 <z_impl_sensor_sample_fetch>:
; {
 8015612: b580         	push	{r7, lr}
 8015614: b084         	sub	sp, #0x10
 8015616: af00         	add	r7, sp, #0x0
 8015618: 6078         	str	r0, [r7, #0x4]
; 	const struct sensor_driver_api *api =
 801561a: 687b         	ldr	r3, [r7, #0x4]
 801561c: 689b         	ldr	r3, [r3, #0x8]
 801561e: 60fb         	str	r3, [r7, #0xc]
; 	return api->sample_fetch(dev, SENSOR_CHAN_ALL);
 8015620: 68fb         	ldr	r3, [r7, #0xc]
 8015622: 68db         	ldr	r3, [r3, #0xc]
 8015624: 213c         	movs	r1, #0x3c
 8015626: 6878         	ldr	r0, [r7, #0x4]
 8015628: 4798         	blx	r3
 801562a: 4603         	mov	r3, r0
; }
 801562c: 4618         	mov	r0, r3
 801562e: 3710         	adds	r7, #0x10
 8015630: 46bd         	mov	sp, r7
 8015632: bd80         	pop	{r7, pc}

08015634 <z_impl_sensor_channel_get>:
; {
 8015634: b580         	push	{r7, lr}
 8015636: b086         	sub	sp, #0x18
 8015638: af00         	add	r7, sp, #0x0
 801563a: 60f8         	str	r0, [r7, #0xc]
 801563c: 460b         	mov	r3, r1
 801563e: 607a         	str	r2, [r7, #0x4]
 8015640: 817b         	strh	r3, [r7, #0xa]
; 	const struct sensor_driver_api *api =
 8015642: 68fb         	ldr	r3, [r7, #0xc]
 8015644: 689b         	ldr	r3, [r3, #0x8]
 8015646: 617b         	str	r3, [r7, #0x14]
; 	return api->channel_get(dev, chan, val);
 8015648: 697b         	ldr	r3, [r7, #0x14]
 801564a: 691b         	ldr	r3, [r3, #0x10]
 801564c: 8979         	ldrh	r1, [r7, #0xa]
 801564e: 687a         	ldr	r2, [r7, #0x4]
 8015650: 68f8         	ldr	r0, [r7, #0xc]
 8015652: 4798         	blx	r3
 8015654: 4603         	mov	r3, r0
; }
 8015656: 4618         	mov	r0, r3
 8015658: 3718         	adds	r7, #0x18
 801565a: 46bd         	mov	sp, r7
 801565c: bd80         	pop	{r7, pc}

0801565e <sensor_sample_fetch>:
; {
 801565e: b580         	push	{r7, lr}
 8015660: b082         	sub	sp, #0x8
 8015662: af00         	add	r7, sp, #0x0
 8015664: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_sensor_sample_fetch(dev);
 8015666: 6878         	ldr	r0, [r7, #0x4]
 8015668: f7ff ffd3    	bl	0x8015612 <z_impl_sensor_sample_fetch> @ imm = #-0x5a
 801566c: 4603         	mov	r3, r0
; }
 801566e: 4618         	mov	r0, r3
 8015670: 3708         	adds	r7, #0x8
 8015672: 46bd         	mov	sp, r7
 8015674: bd80         	pop	{r7, pc}

08015676 <sensor_channel_get>:
; {
 8015676: b580         	push	{r7, lr}
 8015678: b084         	sub	sp, #0x10
 801567a: af00         	add	r7, sp, #0x0
 801567c: 60f8         	str	r0, [r7, #0xc]
 801567e: 460b         	mov	r3, r1
 8015680: 607a         	str	r2, [r7, #0x4]
 8015682: 817b         	strh	r3, [r7, #0xa]
; 	return z_impl_sensor_channel_get(dev, chan, val);
 8015684: 897b         	ldrh	r3, [r7, #0xa]
 8015686: 687a         	ldr	r2, [r7, #0x4]
 8015688: 4619         	mov	r1, r3
 801568a: 68f8         	ldr	r0, [r7, #0xc]
 801568c: f7ff ffd2    	bl	0x8015634 <z_impl_sensor_channel_get> @ imm = #-0x5c
 8015690: 4603         	mov	r3, r0
; }
 8015692: 4618         	mov	r0, r3
 8015694: 3710         	adds	r7, #0x10
 8015696: 46bd         	mov	sp, r7
 8015698: bd80         	pop	{r7, pc}

0801569a <z_impl_uart_tx>:
; {
 801569a: b590         	push	{r4, r7, lr}
 801569c: b087         	sub	sp, #0x1c
 801569e: af00         	add	r7, sp, #0x0
 80156a0: 60f8         	str	r0, [r7, #0xc]
 80156a2: 60b9         	str	r1, [r7, #0x8]
 80156a4: 607a         	str	r2, [r7, #0x4]
 80156a6: 603b         	str	r3, [r7]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 80156a8: 68fb         	ldr	r3, [r7, #0xc]
 80156aa: 689b         	ldr	r3, [r3, #0x8]
 80156ac: 617b         	str	r3, [r7, #0x14]
; 	return api->tx(dev, buf, len, timeout);
 80156ae: 697b         	ldr	r3, [r7, #0x14]
 80156b0: 685c         	ldr	r4, [r3, #0x4]
 80156b2: 683b         	ldr	r3, [r7]
 80156b4: 687a         	ldr	r2, [r7, #0x4]
 80156b6: 68b9         	ldr	r1, [r7, #0x8]
 80156b8: 68f8         	ldr	r0, [r7, #0xc]
 80156ba: 47a0         	blx	r4
 80156bc: 4603         	mov	r3, r0
; }
 80156be: 4618         	mov	r0, r3
 80156c0: 371c         	adds	r7, #0x1c
 80156c2: 46bd         	mov	sp, r7
 80156c4: bd90         	pop	{r4, r7, pc}

080156c6 <uart_tx>:
; {
 80156c6: b580         	push	{r7, lr}
 80156c8: b084         	sub	sp, #0x10
 80156ca: af00         	add	r7, sp, #0x0
 80156cc: 60f8         	str	r0, [r7, #0xc]
 80156ce: 60b9         	str	r1, [r7, #0x8]
 80156d0: 607a         	str	r2, [r7, #0x4]
 80156d2: 603b         	str	r3, [r7]
; 	return z_impl_uart_tx(dev, buf, len, timeout);
 80156d4: 683b         	ldr	r3, [r7]
 80156d6: 687a         	ldr	r2, [r7, #0x4]
 80156d8: 68b9         	ldr	r1, [r7, #0x8]
 80156da: 68f8         	ldr	r0, [r7, #0xc]
 80156dc: f7ff ffdd    	bl	0x801569a <z_impl_uart_tx> @ imm = #-0x46
 80156e0: 4603         	mov	r3, r0
; }
 80156e2: 4618         	mov	r0, r3
 80156e4: 3710         	adds	r7, #0x10
 80156e6: 46bd         	mov	sp, r7
 80156e8: bd80         	pop	{r7, pc}

080156ea <Kalman_Filter_xhatMinusUpdate>:
; {
 80156ea: b580         	push	{r7, lr}
 80156ec: b082         	sub	sp, #0x8
 80156ee: af00         	add	r7, sp, #0x0
 80156f0: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq1) {
 80156f2: 687b         	ldr	r3, [r7, #0x4]
 80156f4: f893 3028    	ldrb.w	r3, [r3, #0x28]
 80156f8: 2b00         	cmp	r3, #0x0
 80156fa: d158         	bne	0x80157ae <Kalman_Filter_xhatMinusUpdate+0xc4> @ imm = #0xb0
; 		if (kf->uSize > 0) {
 80156fc: 687b         	ldr	r3, [r7, #0x4]
 80156fe: 7b5b         	ldrb	r3, [r3, #0xd]
 8015700: 2b00         	cmp	r3, #0x0
 8015702: d044         	beq	0x801578e <Kalman_Filter_xhatMinusUpdate+0xa4> @ imm = #0x88
; 			kf->temp_vector.numRows = kf->xhatSize;
 8015704: 687b         	ldr	r3, [r7, #0x4]
 8015706: 7b1b         	ldrb	r3, [r3, #0xc]
 8015708: 461a         	mov	r2, r3
 801570a: 687b         	ldr	r3, [r7, #0x4]
 801570c: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 			kf->temp_vector.numCols = 1;
 8015710: 687b         	ldr	r3, [r7, #0x4]
 8015712: 2201         	movs	r2, #0x1
 8015714: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 			kf->MatStatus = Matrix_Multiply(&kf->F, &kf->xhat, &kf->temp_vector);
 8015718: 687b         	ldr	r3, [r7, #0x4]
 801571a: f103 0060    	add.w	r0, r3, #0x60
 801571e: 687b         	ldr	r3, [r7, #0x4]
 8015720: f103 0130    	add.w	r1, r3, #0x30
 8015724: 687b         	ldr	r3, [r7, #0x4]
 8015726: 33b8         	adds	r3, #0xb8
 8015728: 461a         	mov	r2, r3
 801572a: f7f9 f885    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x6ef6
 801572e: 4603         	mov	r3, r0
 8015730: 461a         	mov	r2, r3
 8015732: 687b         	ldr	r3, [r7, #0x4]
 8015734: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 			kf->temp_vector1.numRows = kf->xhatSize;
 8015738: 687b         	ldr	r3, [r7, #0x4]
 801573a: 7b1b         	ldrb	r3, [r3, #0xc]
 801573c: 461a         	mov	r2, r3
 801573e: 687b         	ldr	r3, [r7, #0x4]
 8015740: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 			kf->temp_vector1.numCols = 1;
 8015744: 687b         	ldr	r3, [r7, #0x4]
 8015746: 2201         	movs	r2, #0x1
 8015748: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 			kf->MatStatus = Matrix_Multiply(&kf->B, &kf->u, &kf->temp_vector1);
 801574c: 687b         	ldr	r3, [r7, #0x4]
 801574e: f103 0070    	add.w	r0, r3, #0x70
 8015752: 687b         	ldr	r3, [r7, #0x4]
 8015754: f103 0140    	add.w	r1, r3, #0x40
 8015758: 687b         	ldr	r3, [r7, #0x4]
 801575a: 33c0         	adds	r3, #0xc0
 801575c: 461a         	mov	r2, r3
 801575e: f7f9 f86b    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x6f2a
 8015762: 4603         	mov	r3, r0
 8015764: 461a         	mov	r2, r3
 8015766: 687b         	ldr	r3, [r7, #0x4]
 8015768: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 				Matrix_Add(&kf->temp_vector, &kf->temp_vector1, &kf->xhatminus);
 801576c: 687b         	ldr	r3, [r7, #0x4]
 801576e: f103 00b8    	add.w	r0, r3, #0xb8
 8015772: 687b         	ldr	r3, [r7, #0x4]
 8015774: f103 01c0    	add.w	r1, r3, #0xc0
 8015778: 687b         	ldr	r3, [r7, #0x4]
 801577a: 3338         	adds	r3, #0x38
 801577c: 461a         	mov	r2, r3
 801577e: f7f8 febf    	bl	0x800e500 <arm_mat_add_f32> @ imm = #-0x7282
 8015782: 4603         	mov	r3, r0
 8015784: 461a         	mov	r2, r3
; 			kf->MatStatus =
 8015786: 687b         	ldr	r3, [r7, #0x4]
 8015788: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801578c: e00f         	b	0x80157ae <Kalman_Filter_xhatMinusUpdate+0xc4> @ imm = #0x1e
; 			kf->MatStatus = Matrix_Multiply(&kf->F, &kf->xhat, &kf->xhatminus);
 801578e: 687b         	ldr	r3, [r7, #0x4]
 8015790: f103 0060    	add.w	r0, r3, #0x60
 8015794: 687b         	ldr	r3, [r7, #0x4]
 8015796: f103 0130    	add.w	r1, r3, #0x30
 801579a: 687b         	ldr	r3, [r7, #0x4]
 801579c: 3338         	adds	r3, #0x38
 801579e: 461a         	mov	r2, r3
 80157a0: f7f9 f84a    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x6f6c
 80157a4: 4603         	mov	r3, r0
 80157a6: 461a         	mov	r2, r3
 80157a8: 687b         	ldr	r3, [r7, #0x4]
 80157aa: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 80157ae: bf00         	nop
 80157b0: 3708         	adds	r7, #0x8
 80157b2: 46bd         	mov	sp, r7
 80157b4: bd80         	pop	{r7, pc}

080157b6 <Kalman_Filter_PminusUpdate>:
; {
 80157b6: b580         	push	{r7, lr}
 80157b8: b082         	sub	sp, #0x8
 80157ba: af00         	add	r7, sp, #0x0
 80157bc: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq2) {
 80157be: 687b         	ldr	r3, [r7, #0x4]
 80157c0: f893 3029    	ldrb.w	r3, [r3, #0x29]
 80157c4: 2b00         	cmp	r3, #0x0
 80157c6: d149         	bne	0x801585c <Kalman_Filter_PminusUpdate+0xa6> @ imm = #0x92
; 		kf->MatStatus = Matrix_Transpose(&kf->F, &kf->FT);
 80157c8: 687b         	ldr	r3, [r7, #0x4]
 80157ca: f103 0260    	add.w	r2, r3, #0x60
 80157ce: 687b         	ldr	r3, [r7, #0x4]
 80157d0: 3368         	adds	r3, #0x68
 80157d2: 4619         	mov	r1, r3
 80157d4: 4610         	mov	r0, r2
 80157d6: f7f9 f89f    	bl	0x800e918 <arm_mat_trans_f32> @ imm = #-0x6ec2
 80157da: 4603         	mov	r3, r0
 80157dc: 461a         	mov	r2, r3
 80157de: 687b         	ldr	r3, [r7, #0x4]
 80157e0: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->F, &kf->P, &kf->Pminus);
 80157e4: 687b         	ldr	r3, [r7, #0x4]
 80157e6: f103 0060    	add.w	r0, r3, #0x60
 80157ea: 687b         	ldr	r3, [r7, #0x4]
 80157ec: f103 0150    	add.w	r1, r3, #0x50
 80157f0: 687b         	ldr	r3, [r7, #0x4]
 80157f2: 3358         	adds	r3, #0x58
 80157f4: 461a         	mov	r2, r3
 80157f6: f7f9 f81f    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x6fc2
 80157fa: 4603         	mov	r3, r0
 80157fc: 461a         	mov	r2, r3
 80157fe: 687b         	ldr	r3, [r7, #0x4]
 8015800: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->Pminus.numRows;
 8015804: 687b         	ldr	r3, [r7, #0x4]
 8015806: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 801580a: 687b         	ldr	r3, [r7, #0x4]
 801580c: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->FT.numCols;
 8015810: 687b         	ldr	r3, [r7, #0x4]
 8015812: f8b3 206a    	ldrh.w	r2, [r3, #0x6a]
 8015816: 687b         	ldr	r3, [r7, #0x4]
 8015818: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->Pminus, &kf->FT,
 801581c: 687b         	ldr	r3, [r7, #0x4]
 801581e: f103 0058    	add.w	r0, r3, #0x58
 8015822: 687b         	ldr	r3, [r7, #0x4]
 8015824: f103 0168    	add.w	r1, r3, #0x68
 8015828: 687b         	ldr	r3, [r7, #0x4]
 801582a: 33a8         	adds	r3, #0xa8
 801582c: 461a         	mov	r2, r3
 801582e: f7f9 f803    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x6ffa
 8015832: 4603         	mov	r3, r0
 8015834: 461a         	mov	r2, r3
 8015836: 687b         	ldr	r3, [r7, #0x4]
 8015838: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Add(&kf->temp_matrix, &kf->Q, &kf->Pminus);
 801583c: 687b         	ldr	r3, [r7, #0x4]
 801583e: f103 00a8    	add.w	r0, r3, #0xa8
 8015842: 687b         	ldr	r3, [r7, #0x4]
 8015844: f103 0188    	add.w	r1, r3, #0x88
 8015848: 687b         	ldr	r3, [r7, #0x4]
 801584a: 3358         	adds	r3, #0x58
 801584c: 461a         	mov	r2, r3
 801584e: f7f8 fe57    	bl	0x800e500 <arm_mat_add_f32> @ imm = #-0x7352
 8015852: 4603         	mov	r3, r0
 8015854: 461a         	mov	r2, r3
 8015856: 687b         	ldr	r3, [r7, #0x4]
 8015858: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 801585c: bf00         	nop
 801585e: 3708         	adds	r7, #0x8
 8015860: 46bd         	mov	sp, r7
 8015862: bd80         	pop	{r7, pc}

08015864 <Kalman_Filter_SetK>:
; {
 8015864: b580         	push	{r7, lr}
 8015866: b082         	sub	sp, #0x8
 8015868: af00         	add	r7, sp, #0x0
 801586a: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq3) {
 801586c: 687b         	ldr	r3, [r7, #0x4]
 801586e: f893 302a    	ldrb.w	r3, [r3, #0x2a]
 8015872: 2b00         	cmp	r3, #0x0
 8015874: f040 809c    	bne.w	0x80159b0 <Kalman_Filter_SetK+0x14c> @ imm = #0x138
; 		kf->MatStatus = Matrix_Transpose(&kf->H, &kf->HT); // z|x => x|z
 8015878: 687b         	ldr	r3, [r7, #0x4]
 801587a: f103 0278    	add.w	r2, r3, #0x78
 801587e: 687b         	ldr	r3, [r7, #0x4]
 8015880: 3380         	adds	r3, #0x80
 8015882: 4619         	mov	r1, r3
 8015884: 4610         	mov	r0, r2
 8015886: f7f9 f847    	bl	0x800e918 <arm_mat_trans_f32> @ imm = #-0x6f72
 801588a: 4603         	mov	r3, r0
 801588c: 461a         	mov	r2, r3
 801588e: 687b         	ldr	r3, [r7, #0x4]
 8015890: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->H.numRows;
 8015894: 687b         	ldr	r3, [r7, #0x4]
 8015896: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 801589a: 687b         	ldr	r3, [r7, #0x4]
 801589c: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->Pminus.numCols;
 80158a0: 687b         	ldr	r3, [r7, #0x4]
 80158a2: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 80158a6: 687b         	ldr	r3, [r7, #0x4]
 80158a8: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->H, &kf->Pminus,
 80158ac: 687b         	ldr	r3, [r7, #0x4]
 80158ae: f103 0078    	add.w	r0, r3, #0x78
 80158b2: 687b         	ldr	r3, [r7, #0x4]
 80158b4: f103 0158    	add.w	r1, r3, #0x58
 80158b8: 687b         	ldr	r3, [r7, #0x4]
 80158ba: 33a8         	adds	r3, #0xa8
 80158bc: 461a         	mov	r2, r3
 80158be: f7f8 ffbb    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x708a
 80158c2: 4603         	mov	r3, r0
 80158c4: 461a         	mov	r2, r3
 80158c6: 687b         	ldr	r3, [r7, #0x4]
 80158c8: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 80158cc: 687b         	ldr	r3, [r7, #0x4]
 80158ce: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 80158d2: 687b         	ldr	r3, [r7, #0x4]
 80158d4: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 		kf->temp_matrix1.numCols = kf->HT.numCols;
 80158d8: 687b         	ldr	r3, [r7, #0x4]
 80158da: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 80158de: 687b         	ldr	r3, [r7, #0x4]
 80158e0: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->HT,
 80158e4: 687b         	ldr	r3, [r7, #0x4]
 80158e6: f103 00a8    	add.w	r0, r3, #0xa8
 80158ea: 687b         	ldr	r3, [r7, #0x4]
 80158ec: f103 0180    	add.w	r1, r3, #0x80
 80158f0: 687b         	ldr	r3, [r7, #0x4]
 80158f2: 33b0         	adds	r3, #0xb0
 80158f4: 461a         	mov	r2, r3
 80158f6: f7f8 ff9f    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x70c2
 80158fa: 4603         	mov	r3, r0
 80158fc: 461a         	mov	r2, r3
 80158fe: 687b         	ldr	r3, [r7, #0x4]
 8015900: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->S.numRows = kf->R.numRows;
 8015904: 687b         	ldr	r3, [r7, #0x4]
 8015906: f8b3 2090    	ldrh.w	r2, [r3, #0x90]
 801590a: 687b         	ldr	r3, [r7, #0x4]
 801590c: f8a3 20a0    	strh.w	r2, [r3, #0xa0]
; 		kf->S.numCols = kf->R.numCols;
 8015910: 687b         	ldr	r3, [r7, #0x4]
 8015912: f8b3 2092    	ldrh.w	r2, [r3, #0x92]
 8015916: 687b         	ldr	r3, [r7, #0x4]
 8015918: f8a3 20a2    	strh.w	r2, [r3, #0xa2]
; 		kf->MatStatus = Matrix_Add(&kf->temp_matrix1, &kf->R, &kf->S); // S = H P'(k) HT + R
 801591c: 687b         	ldr	r3, [r7, #0x4]
 801591e: f103 00b0    	add.w	r0, r3, #0xb0
 8015922: 687b         	ldr	r3, [r7, #0x4]
 8015924: f103 0190    	add.w	r1, r3, #0x90
 8015928: 687b         	ldr	r3, [r7, #0x4]
 801592a: 33a0         	adds	r3, #0xa0
 801592c: 461a         	mov	r2, r3
 801592e: f7f8 fde7    	bl	0x800e500 <arm_mat_add_f32> @ imm = #-0x7432
 8015932: 4603         	mov	r3, r0
 8015934: 461a         	mov	r2, r3
 8015936: 687b         	ldr	r3, [r7, #0x4]
 8015938: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 			&kf->S, &kf->temp_matrix1); // temp_matrix1 = inv(H·P'(k)·HT + R)
 801593c: 687b         	ldr	r3, [r7, #0x4]
 801593e: f103 02a0    	add.w	r2, r3, #0xa0
; 		kf->MatStatus = Matrix_Inverse(
 8015942: 687b         	ldr	r3, [r7, #0x4]
 8015944: 33b0         	adds	r3, #0xb0
 8015946: 4619         	mov	r1, r3
 8015948: 4610         	mov	r0, r2
 801594a: f7f8 fdf3    	bl	0x800e534 <arm_mat_inverse_f32> @ imm = #-0x741a
 801594e: 4603         	mov	r3, r0
 8015950: 461a         	mov	r2, r3
 8015952: 687b         	ldr	r3, [r7, #0x4]
 8015954: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_matrix.numRows = kf->Pminus.numRows;
 8015958: 687b         	ldr	r3, [r7, #0x4]
 801595a: f8b3 2058    	ldrh.w	r2, [r3, #0x58]
 801595e: 687b         	ldr	r3, [r7, #0x4]
 8015960: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->HT.numCols;
 8015964: 687b         	ldr	r3, [r7, #0x4]
 8015966: f8b3 2082    	ldrh.w	r2, [r3, #0x82]
 801596a: 687b         	ldr	r3, [r7, #0x4]
 801596c: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->MatStatus = Matrix_Multiply(&kf->Pminus, &kf->HT,
 8015970: 687b         	ldr	r3, [r7, #0x4]
 8015972: f103 0058    	add.w	r0, r3, #0x58
 8015976: 687b         	ldr	r3, [r7, #0x4]
 8015978: f103 0180    	add.w	r1, r3, #0x80
 801597c: 687b         	ldr	r3, [r7, #0x4]
 801597e: 33a8         	adds	r3, #0xa8
 8015980: 461a         	mov	r2, r3
 8015982: f7f8 ff59    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x714e
 8015986: 4603         	mov	r3, r0
 8015988: 461a         	mov	r2, r3
 801598a: 687b         	ldr	r3, [r7, #0x4]
 801598c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->temp_matrix1, &kf->K);
 8015990: 687b         	ldr	r3, [r7, #0x4]
 8015992: f103 00a8    	add.w	r0, r3, #0xa8
 8015996: 687b         	ldr	r3, [r7, #0x4]
 8015998: f103 01b0    	add.w	r1, r3, #0xb0
 801599c: 687b         	ldr	r3, [r7, #0x4]
 801599e: 3398         	adds	r3, #0x98
 80159a0: 461a         	mov	r2, r3
 80159a2: f7f8 ff49    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x716e
 80159a6: 4603         	mov	r3, r0
 80159a8: 461a         	mov	r2, r3
 80159aa: 687b         	ldr	r3, [r7, #0x4]
 80159ac: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 80159b0: bf00         	nop
 80159b2: 3708         	adds	r7, #0x8
 80159b4: 46bd         	mov	sp, r7
 80159b6: bd80         	pop	{r7, pc}

080159b8 <Kalman_Filter_xhatUpdate>:
; {
 80159b8: b580         	push	{r7, lr}
 80159ba: b082         	sub	sp, #0x8
 80159bc: af00         	add	r7, sp, #0x0
 80159be: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq4) {
 80159c0: 687b         	ldr	r3, [r7, #0x4]
 80159c2: f893 302b    	ldrb.w	r3, [r3, #0x2b]
 80159c6: 2b00         	cmp	r3, #0x0
 80159c8: d15d         	bne	0x8015a86 <Kalman_Filter_xhatUpdate+0xce> @ imm = #0xba
; 		kf->temp_vector.numRows = kf->H.numRows;
 80159ca: 687b         	ldr	r3, [r7, #0x4]
 80159cc: f8b3 2078    	ldrh.w	r2, [r3, #0x78]
 80159d0: 687b         	ldr	r3, [r7, #0x4]
 80159d2: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 		kf->temp_vector.numCols = 1;
 80159d6: 687b         	ldr	r3, [r7, #0x4]
 80159d8: 2201         	movs	r2, #0x1
 80159da: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 		kf->MatStatus = Matrix_Multiply(&kf->H, &kf->xhatminus,
 80159de: 687b         	ldr	r3, [r7, #0x4]
 80159e0: f103 0078    	add.w	r0, r3, #0x78
 80159e4: 687b         	ldr	r3, [r7, #0x4]
 80159e6: f103 0138    	add.w	r1, r3, #0x38
 80159ea: 687b         	ldr	r3, [r7, #0x4]
 80159ec: 33b8         	adds	r3, #0xb8
 80159ee: 461a         	mov	r2, r3
 80159f0: f7f8 ff22    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x71bc
 80159f4: 4603         	mov	r3, r0
 80159f6: 461a         	mov	r2, r3
 80159f8: 687b         	ldr	r3, [r7, #0x4]
 80159fa: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_vector1.numRows = kf->z.numRows;
 80159fe: 687b         	ldr	r3, [r7, #0x4]
 8015a00: f8b3 2048    	ldrh.w	r2, [r3, #0x48]
 8015a04: 687b         	ldr	r3, [r7, #0x4]
 8015a06: f8a3 20c0    	strh.w	r2, [r3, #0xc0]
; 		kf->temp_vector1.numCols = 1;
 8015a0a: 687b         	ldr	r3, [r7, #0x4]
 8015a0c: 2201         	movs	r2, #0x1
 8015a0e: f8a3 20c2    	strh.w	r2, [r3, #0xc2]
; 			Matrix_Subtract(&kf->z, &kf->temp_vector,
 8015a12: 687b         	ldr	r3, [r7, #0x4]
 8015a14: f103 0048    	add.w	r0, r3, #0x48
 8015a18: 687b         	ldr	r3, [r7, #0x4]
 8015a1a: f103 01b8    	add.w	r1, r3, #0xb8
 8015a1e: 687b         	ldr	r3, [r7, #0x4]
 8015a20: 33c0         	adds	r3, #0xc0
 8015a22: 461a         	mov	r2, r3
 8015a24: f7f8 ff62    	bl	0x800e8ec <arm_mat_sub_f32> @ imm = #-0x713c
 8015a28: 4603         	mov	r3, r0
 8015a2a: 461a         	mov	r2, r3
; 		kf->MatStatus =
 8015a2c: 687b         	ldr	r3, [r7, #0x4]
 8015a2e: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->temp_vector.numRows = kf->K.numRows;
 8015a32: 687b         	ldr	r3, [r7, #0x4]
 8015a34: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 8015a38: 687b         	ldr	r3, [r7, #0x4]
 8015a3a: f8a3 20b8    	strh.w	r2, [r3, #0xb8]
; 		kf->temp_vector.numCols = 1;
 8015a3e: 687b         	ldr	r3, [r7, #0x4]
 8015a40: 2201         	movs	r2, #0x1
 8015a42: f8a3 20ba    	strh.w	r2, [r3, #0xba]
; 			Matrix_Multiply(&kf->K, &kf->temp_vector1,
 8015a46: 687b         	ldr	r3, [r7, #0x4]
 8015a48: f103 0098    	add.w	r0, r3, #0x98
 8015a4c: 687b         	ldr	r3, [r7, #0x4]
 8015a4e: f103 01c0    	add.w	r1, r3, #0xc0
 8015a52: 687b         	ldr	r3, [r7, #0x4]
 8015a54: 33b8         	adds	r3, #0xb8
 8015a56: 461a         	mov	r2, r3
 8015a58: f7f8 feee    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x7224
 8015a5c: 4603         	mov	r3, r0
 8015a5e: 461a         	mov	r2, r3
; 		kf->MatStatus =
 8015a60: 687b         	ldr	r3, [r7, #0x4]
 8015a62: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Add(&kf->xhatminus, &kf->temp_vector, &kf->xhat);
 8015a66: 687b         	ldr	r3, [r7, #0x4]
 8015a68: f103 0038    	add.w	r0, r3, #0x38
 8015a6c: 687b         	ldr	r3, [r7, #0x4]
 8015a6e: f103 01b8    	add.w	r1, r3, #0xb8
 8015a72: 687b         	ldr	r3, [r7, #0x4]
 8015a74: 3330         	adds	r3, #0x30
 8015a76: 461a         	mov	r2, r3
 8015a78: f7f8 fd42    	bl	0x800e500 <arm_mat_add_f32> @ imm = #-0x757c
 8015a7c: 4603         	mov	r3, r0
 8015a7e: 461a         	mov	r2, r3
 8015a80: 687b         	ldr	r3, [r7, #0x4]
 8015a82: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 8015a86: bf00         	nop
 8015a88: 3708         	adds	r7, #0x8
 8015a8a: 46bd         	mov	sp, r7
 8015a8c: bd80         	pop	{r7, pc}

08015a8e <Kalman_Filter_P_Update>:
; {
 8015a8e: b580         	push	{r7, lr}
 8015a90: b082         	sub	sp, #0x8
 8015a92: af00         	add	r7, sp, #0x0
 8015a94: 6078         	str	r0, [r7, #0x4]
; 	if (!kf->SkipEq5) {
 8015a96: 687b         	ldr	r3, [r7, #0x4]
 8015a98: f893 302c    	ldrb.w	r3, [r3, #0x2c]
 8015a9c: 2b00         	cmp	r3, #0x0
 8015a9e: d147         	bne	0x8015b30 <Kalman_Filter_P_Update+0xa2> @ imm = #0x8e
; 		kf->temp_matrix.numRows = kf->K.numRows;
 8015aa0: 687b         	ldr	r3, [r7, #0x4]
 8015aa2: f8b3 2098    	ldrh.w	r2, [r3, #0x98]
 8015aa6: 687b         	ldr	r3, [r7, #0x4]
 8015aa8: f8a3 20a8    	strh.w	r2, [r3, #0xa8]
; 		kf->temp_matrix.numCols = kf->H.numCols;
 8015aac: 687b         	ldr	r3, [r7, #0x4]
 8015aae: f8b3 207a    	ldrh.w	r2, [r3, #0x7a]
 8015ab2: 687b         	ldr	r3, [r7, #0x4]
 8015ab4: f8a3 20aa    	strh.w	r2, [r3, #0xaa]
; 		kf->temp_matrix1.numRows = kf->temp_matrix.numRows;
 8015ab8: 687b         	ldr	r3, [r7, #0x4]
 8015aba: f8b3 20a8    	ldrh.w	r2, [r3, #0xa8]
 8015abe: 687b         	ldr	r3, [r7, #0x4]
 8015ac0: f8a3 20b0    	strh.w	r2, [r3, #0xb0]
; 		kf->temp_matrix1.numCols = kf->Pminus.numCols;
 8015ac4: 687b         	ldr	r3, [r7, #0x4]
 8015ac6: f8b3 205a    	ldrh.w	r2, [r3, #0x5a]
 8015aca: 687b         	ldr	r3, [r7, #0x4]
 8015acc: f8a3 20b2    	strh.w	r2, [r3, #0xb2]
; 			Matrix_Multiply(&kf->K, &kf->H, &kf->temp_matrix); // temp_matrix = K(k)·H
 8015ad0: 687b         	ldr	r3, [r7, #0x4]
 8015ad2: f103 0098    	add.w	r0, r3, #0x98
 8015ad6: 687b         	ldr	r3, [r7, #0x4]
 8015ad8: f103 0178    	add.w	r1, r3, #0x78
 8015adc: 687b         	ldr	r3, [r7, #0x4]
 8015ade: 33a8         	adds	r3, #0xa8
 8015ae0: 461a         	mov	r2, r3
 8015ae2: f7f8 fea9    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x72ae
 8015ae6: 4603         	mov	r3, r0
 8015ae8: 461a         	mov	r2, r3
; 		kf->MatStatus =
 8015aea: 687b         	ldr	r3, [r7, #0x4]
 8015aec: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Multiply(&kf->temp_matrix, &kf->Pminus,
 8015af0: 687b         	ldr	r3, [r7, #0x4]
 8015af2: f103 00a8    	add.w	r0, r3, #0xa8
 8015af6: 687b         	ldr	r3, [r7, #0x4]
 8015af8: f103 0158    	add.w	r1, r3, #0x58
 8015afc: 687b         	ldr	r3, [r7, #0x4]
 8015afe: 33b0         	adds	r3, #0xb0
 8015b00: 461a         	mov	r2, r3
 8015b02: f7f8 fe99    	bl	0x800e838 <arm_mat_mult_f32> @ imm = #-0x72ce
 8015b06: 4603         	mov	r3, r0
 8015b08: 461a         	mov	r2, r3
 8015b0a: 687b         	ldr	r3, [r7, #0x4]
 8015b0c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; 		kf->MatStatus = Matrix_Subtract(&kf->Pminus, &kf->temp_matrix1, &kf->P);
 8015b10: 687b         	ldr	r3, [r7, #0x4]
 8015b12: f103 0058    	add.w	r0, r3, #0x58
 8015b16: 687b         	ldr	r3, [r7, #0x4]
 8015b18: f103 01b0    	add.w	r1, r3, #0xb0
 8015b1c: 687b         	ldr	r3, [r7, #0x4]
 8015b1e: 3350         	adds	r3, #0x50
 8015b20: 461a         	mov	r2, r3
 8015b22: f7f8 fee3    	bl	0x800e8ec <arm_mat_sub_f32> @ imm = #-0x723a
 8015b26: 4603         	mov	r3, r0
 8015b28: 461a         	mov	r2, r3
 8015b2a: 687b         	ldr	r3, [r7, #0x4]
 8015b2c: f883 20c8    	strb.w	r2, [r3, #0xc8]
; }
 8015b30: bf00         	nop
 8015b32: 3708         	adds	r7, #0x8
 8015b34: 46bd         	mov	sp, r7
 8015b36: bd80         	pop	{r7, pc}

08015b38 <pid_reg_input>:
; {
 8015b38: b480         	push	{r7}
 8015b3a: b085         	sub	sp, #0x14
 8015b3c: af00         	add	r7, sp, #0x0
 8015b3e: 60f8         	str	r0, [r7, #0xc]
 8015b40: 60b9         	str	r1, [r7, #0x8]
 8015b42: 607a         	str	r2, [r7, #0x4]
; 	if (data == NULL) {
 8015b44: 68fb         	ldr	r3, [r7, #0xc]
 8015b46: 2b00         	cmp	r3, #0x0
 8015b48: d006         	beq	0x8015b58 <pid_reg_input+0x20> @ imm = #0xc
; 	data->curr = curr;
 8015b4a: 68fb         	ldr	r3, [r7, #0xc]
 8015b4c: 68ba         	ldr	r2, [r7, #0x8]
 8015b4e: 605a         	str	r2, [r3, #0x4]
; 	data->ref = ref;
 8015b50: 68fb         	ldr	r3, [r7, #0xc]
 8015b52: 687a         	ldr	r2, [r7, #0x4]
 8015b54: 601a         	str	r2, [r3]
 8015b56: e000         	b	0x8015b5a <pid_reg_input+0x22> @ imm = #0x0
; 		return;
 8015b58: bf00         	nop
; }
 8015b5a: 3714         	adds	r7, #0x14
 8015b5c: 46bd         	mov	sp, r7
 8015b5e: f85d 7b04    	ldr	r7, [sp], #4
 8015b62: 4770         	bx	lr

08015b64 <pid_reg_output>:
; {
 8015b64: b480         	push	{r7}
 8015b66: b083         	sub	sp, #0xc
 8015b68: af00         	add	r7, sp, #0x0
 8015b6a: 6078         	str	r0, [r7, #0x4]
 8015b6c: 6039         	str	r1, [r7]
; 	if (data == NULL) {
 8015b6e: 687b         	ldr	r3, [r7, #0x4]
 8015b70: 2b00         	cmp	r3, #0x0
 8015b72: d003         	beq	0x8015b7c <pid_reg_output+0x18> @ imm = #0x6
; 	data->output = output;
 8015b74: 687b         	ldr	r3, [r7, #0x4]
 8015b76: 683a         	ldr	r2, [r7]
 8015b78: 629a         	str	r2, [r3, #0x28]
 8015b7a: e000         	b	0x8015b7e <pid_reg_output+0x1a> @ imm = #0x0
; 		return;
 8015b7c: bf00         	nop
; }
 8015b7e: 370c         	adds	r7, #0xc
 8015b80: 46bd         	mov	sp, r7
 8015b82: f85d 7b04    	ldr	r7, [sp], #4
 8015b86: 4770         	bx	lr

08015b88 <pid_reg_time>:
; {
 8015b88: b480         	push	{r7}
 8015b8a: b085         	sub	sp, #0x14
 8015b8c: af00         	add	r7, sp, #0x0
 8015b8e: 60f8         	str	r0, [r7, #0xc]
 8015b90: 60b9         	str	r1, [r7, #0x8]
 8015b92: 607a         	str	r2, [r7, #0x4]
; 	if (data == NULL) {
 8015b94: 68fb         	ldr	r3, [r7, #0xc]
 8015b96: 2b00         	cmp	r3, #0x0
 8015b98: d006         	beq	0x8015ba8 <pid_reg_time+0x20> @ imm = #0xc
; 	data->curr_time = curr_cyc;
 8015b9a: 68fb         	ldr	r3, [r7, #0xc]
 8015b9c: 68ba         	ldr	r2, [r7, #0x8]
 8015b9e: 621a         	str	r2, [r3, #0x20]
; 	data->prev_time = prev_cyc;
 8015ba0: 68fb         	ldr	r3, [r7, #0xc]
 8015ba2: 687a         	ldr	r2, [r7, #0x4]
 8015ba4: 625a         	str	r2, [r3, #0x24]
 8015ba6: e000         	b	0x8015baa <pid_reg_time+0x22> @ imm = #0x0
; 		return;
 8015ba8: bf00         	nop
; }
 8015baa: 3714         	adds	r7, #0x14
 8015bac: 46bd         	mov	sp, r7
 8015bae: f85d 7b04    	ldr	r7, [sp], #4
 8015bb2: 4770         	bx	lr

08015bb4 <z_impl_pwm_set_cycles>:
; {
 8015bb4: b590         	push	{r4, r7, lr}
 8015bb6: b089         	sub	sp, #0x24
 8015bb8: af02         	add	r7, sp, #0x8
 8015bba: 60f8         	str	r0, [r7, #0xc]
 8015bbc: 60b9         	str	r1, [r7, #0x8]
 8015bbe: 607a         	str	r2, [r7, #0x4]
 8015bc0: 603b         	str	r3, [r7]
; 	const struct pwm_driver_api *api =
 8015bc2: 68fb         	ldr	r3, [r7, #0xc]
 8015bc4: 689b         	ldr	r3, [r3, #0x8]
 8015bc6: 617b         	str	r3, [r7, #0x14]
; 	if (pulse > period) {
 8015bc8: 683a         	ldr	r2, [r7]
 8015bca: 687b         	ldr	r3, [r7, #0x4]
 8015bcc: 429a         	cmp	r2, r3
 8015bce: d902         	bls	0x8015bd6 <z_impl_pwm_set_cycles+0x22> @ imm = #0x4
; 		return -EINVAL;
 8015bd0: f06f 0315    	mvn	r3, #0x15
 8015bd4: e009         	b	0x8015bea <z_impl_pwm_set_cycles+0x36> @ imm = #0x12
; 	return api->set_cycles(dev, channel, period, pulse, flags);
 8015bd6: 697b         	ldr	r3, [r7, #0x14]
 8015bd8: 681c         	ldr	r4, [r3]
 8015bda: 8d3b         	ldrh	r3, [r7, #0x28]
 8015bdc: 9300         	str	r3, [sp]
 8015bde: 683b         	ldr	r3, [r7]
 8015be0: 687a         	ldr	r2, [r7, #0x4]
 8015be2: 68b9         	ldr	r1, [r7, #0x8]
 8015be4: 68f8         	ldr	r0, [r7, #0xc]
 8015be6: 47a0         	blx	r4
 8015be8: 4603         	mov	r3, r0
; }
 8015bea: 4618         	mov	r0, r3
 8015bec: 371c         	adds	r7, #0x1c
 8015bee: 46bd         	mov	sp, r7
 8015bf0: bd90         	pop	{r4, r7, pc}

08015bf2 <z_impl_pwm_get_cycles_per_sec>:
; {
 8015bf2: b580         	push	{r7, lr}
 8015bf4: b086         	sub	sp, #0x18
 8015bf6: af00         	add	r7, sp, #0x0
 8015bf8: 60f8         	str	r0, [r7, #0xc]
 8015bfa: 60b9         	str	r1, [r7, #0x8]
 8015bfc: 607a         	str	r2, [r7, #0x4]
; 	const struct pwm_driver_api *api =
 8015bfe: 68fb         	ldr	r3, [r7, #0xc]
 8015c00: 689b         	ldr	r3, [r3, #0x8]
 8015c02: 617b         	str	r3, [r7, #0x14]
; 	return api->get_cycles_per_sec(dev, channel, cycles);
 8015c04: 697b         	ldr	r3, [r7, #0x14]
 8015c06: 685b         	ldr	r3, [r3, #0x4]
 8015c08: 687a         	ldr	r2, [r7, #0x4]
 8015c0a: 68b9         	ldr	r1, [r7, #0x8]
 8015c0c: 68f8         	ldr	r0, [r7, #0xc]
 8015c0e: 4798         	blx	r3
 8015c10: 4603         	mov	r3, r0
; }
 8015c12: 4618         	mov	r0, r3
 8015c14: 3718         	adds	r7, #0x18
 8015c16: 46bd         	mov	sp, r7
 8015c18: bd80         	pop	{r7, pc}

08015c1a <pwm_set_pulse_dt>:
; {
 8015c1a: b580         	push	{r7, lr}
 8015c1c: b084         	sub	sp, #0x10
 8015c1e: af02         	add	r7, sp, #0x8
 8015c20: 6078         	str	r0, [r7, #0x4]
 8015c22: 6039         	str	r1, [r7]
; 	return pwm_set(spec->dev, spec->channel, spec->period, pulse,
 8015c24: 687b         	ldr	r3, [r7, #0x4]
 8015c26: 6818         	ldr	r0, [r3]
 8015c28: 687b         	ldr	r3, [r7, #0x4]
 8015c2a: 6859         	ldr	r1, [r3, #0x4]
 8015c2c: 687b         	ldr	r3, [r7, #0x4]
 8015c2e: 689a         	ldr	r2, [r3, #0x8]
; 		       spec->flags);
 8015c30: 687b         	ldr	r3, [r7, #0x4]
 8015c32: 899b         	ldrh	r3, [r3, #0xc]
; 	return pwm_set(spec->dev, spec->channel, spec->period, pulse,
 8015c34: 9300         	str	r3, [sp]
 8015c36: 683b         	ldr	r3, [r7]
 8015c38: f7eb f8b2    	bl	0x8000da0 <pwm_set>     @ imm = #-0x14e9c
 8015c3c: 4603         	mov	r3, r0
; }
 8015c3e: 4618         	mov	r0, r3
 8015c40: 3708         	adds	r7, #0x8
 8015c42: 46bd         	mov	sp, r7
 8015c44: bd80         	pop	{r7, pc}

08015c46 <pwm_is_ready_dt>:
; {
 8015c46: b580         	push	{r7, lr}
 8015c48: b082         	sub	sp, #0x8
 8015c4a: af00         	add	r7, sp, #0x0
 8015c4c: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->dev);
 8015c4e: 687b         	ldr	r3, [r7, #0x4]
 8015c50: 681b         	ldr	r3, [r3]
 8015c52: 4618         	mov	r0, r3
 8015c54: f7ff fc17    	bl	0x8015486 <device_is_ready> @ imm = #-0x7d2
 8015c58: 4603         	mov	r3, r0
; }
 8015c5a: 4618         	mov	r0, r3
 8015c5c: 3708         	adds	r7, #0x8
 8015c5e: 46bd         	mov	sp, r7
 8015c60: bd80         	pop	{r7, pc}

08015c62 <pwm_set_cycles>:
; {
 8015c62: b580         	push	{r7, lr}
 8015c64: b086         	sub	sp, #0x18
 8015c66: af02         	add	r7, sp, #0x8
 8015c68: 60f8         	str	r0, [r7, #0xc]
 8015c6a: 60b9         	str	r1, [r7, #0x8]
 8015c6c: 607a         	str	r2, [r7, #0x4]
 8015c6e: 603b         	str	r3, [r7]
; 	return z_impl_pwm_set_cycles(dev, channel, period, pulse, flags);
 8015c70: 8b3b         	ldrh	r3, [r7, #0x18]
 8015c72: 9300         	str	r3, [sp]
 8015c74: 683b         	ldr	r3, [r7]
 8015c76: 687a         	ldr	r2, [r7, #0x4]
 8015c78: 68b9         	ldr	r1, [r7, #0x8]
 8015c7a: 68f8         	ldr	r0, [r7, #0xc]
 8015c7c: f7ff ff9a    	bl	0x8015bb4 <z_impl_pwm_set_cycles> @ imm = #-0xcc
 8015c80: 4603         	mov	r3, r0
; }
 8015c82: 4618         	mov	r0, r3
 8015c84: 3710         	adds	r7, #0x10
 8015c86: 46bd         	mov	sp, r7
 8015c88: bd80         	pop	{r7, pc}

08015c8a <pwm_get_cycles_per_sec>:
; {
 8015c8a: b580         	push	{r7, lr}
 8015c8c: b084         	sub	sp, #0x10
 8015c8e: af00         	add	r7, sp, #0x0
 8015c90: 60f8         	str	r0, [r7, #0xc]
 8015c92: 60b9         	str	r1, [r7, #0x8]
 8015c94: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_pwm_get_cycles_per_sec(dev, channel, cycles);
 8015c96: 687a         	ldr	r2, [r7, #0x4]
 8015c98: 68b9         	ldr	r1, [r7, #0x8]
 8015c9a: 68f8         	ldr	r0, [r7, #0xc]
 8015c9c: f7ff ffa9    	bl	0x8015bf2 <z_impl_pwm_get_cycles_per_sec> @ imm = #-0xae
 8015ca0: 4603         	mov	r3, r0
; }
 8015ca2: 4618         	mov	r0, r3
 8015ca4: 3710         	adds	r7, #0x10
 8015ca6: 46bd         	mov	sp, r7
 8015ca8: bd80         	pop	{r7, pc}

08015caa <Norm3d>:
; {
 8015caa: b580         	push	{r7, lr}
 8015cac: b084         	sub	sp, #0x10
 8015cae: af00         	add	r7, sp, #0x0
 8015cb0: 6078         	str	r0, [r7, #0x4]
; 	float len = Sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
 8015cb2: 687b         	ldr	r3, [r7, #0x4]
 8015cb4: ed93 7a00    	vldr	s14, [r3]
 8015cb8: 687b         	ldr	r3, [r7, #0x4]
 8015cba: edd3 7a00    	vldr	s15, [r3]
 8015cbe: ee27 7a27    	vmul.f32	s14, s14, s15
 8015cc2: 687b         	ldr	r3, [r7, #0x4]
 8015cc4: 3304         	adds	r3, #0x4
 8015cc6: edd3 6a00    	vldr	s13, [r3]
 8015cca: 687b         	ldr	r3, [r7, #0x4]
 8015ccc: 3304         	adds	r3, #0x4
 8015cce: edd3 7a00    	vldr	s15, [r3]
 8015cd2: ee66 7aa7    	vmul.f32	s15, s13, s15
 8015cd6: ee37 7a27    	vadd.f32	s14, s14, s15
 8015cda: 687b         	ldr	r3, [r7, #0x4]
 8015cdc: 3308         	adds	r3, #0x8
 8015cde: edd3 6a00    	vldr	s13, [r3]
 8015ce2: 687b         	ldr	r3, [r7, #0x4]
 8015ce4: 3308         	adds	r3, #0x8
 8015ce6: edd3 7a00    	vldr	s15, [r3]
 8015cea: ee66 7aa7    	vmul.f32	s15, s13, s15
 8015cee: ee77 7a27    	vadd.f32	s15, s14, s15
 8015cf2: eeb0 0a67    	vmov.f32	s0, s15
 8015cf6: f7ee f841    	bl	0x8003d7c <Sqrt>        @ imm = #-0x11f7e
 8015cfa: ed87 0a03    	vstr	s0, [r7, #12]
; 	v[0] /= len;
 8015cfe: 687b         	ldr	r3, [r7, #0x4]
 8015d00: edd3 6a00    	vldr	s13, [r3]
 8015d04: ed97 7a03    	vldr	s14, [r7, #12]
 8015d08: eec6 7a87    	vdiv.f32	s15, s13, s14
 8015d0c: 687b         	ldr	r3, [r7, #0x4]
 8015d0e: edc3 7a00    	vstr	s15, [r3]
; 	v[1] /= len;
 8015d12: 687b         	ldr	r3, [r7, #0x4]
 8015d14: 3304         	adds	r3, #0x4
 8015d16: edd3 6a00    	vldr	s13, [r3]
 8015d1a: 687b         	ldr	r3, [r7, #0x4]
 8015d1c: 3304         	adds	r3, #0x4
 8015d1e: ed97 7a03    	vldr	s14, [r7, #12]
 8015d22: eec6 7a87    	vdiv.f32	s15, s13, s14
 8015d26: edc3 7a00    	vstr	s15, [r3]
; 	v[2] /= len;
 8015d2a: 687b         	ldr	r3, [r7, #0x4]
 8015d2c: 3308         	adds	r3, #0x8
 8015d2e: edd3 6a00    	vldr	s13, [r3]
 8015d32: 687b         	ldr	r3, [r7, #0x4]
 8015d34: 3308         	adds	r3, #0x8
 8015d36: ed97 7a03    	vldr	s14, [r7, #12]
 8015d3a: eec6 7a87    	vdiv.f32	s15, s13, s14
 8015d3e: edc3 7a00    	vstr	s15, [r3]
; 	return v;
 8015d42: 687b         	ldr	r3, [r7, #0x4]
; }
 8015d44: 4618         	mov	r0, r3
 8015d46: 3710         	adds	r7, #0x10
 8015d48: 46bd         	mov	sp, r7
 8015d4a: bd80         	pop	{r7, pc}

08015d4c <Cross3d>:
; {
 8015d4c: b480         	push	{r7}
 8015d4e: b085         	sub	sp, #0x14
 8015d50: af00         	add	r7, sp, #0x0
 8015d52: 60f8         	str	r0, [r7, #0xc]
 8015d54: 60b9         	str	r1, [r7, #0x8]
 8015d56: 607a         	str	r2, [r7, #0x4]
; 	res[0] = v1[1] * v2[2] - v1[2] * v2[1];
 8015d58: 68fb         	ldr	r3, [r7, #0xc]
 8015d5a: 3304         	adds	r3, #0x4
 8015d5c: ed93 7a00    	vldr	s14, [r3]
 8015d60: 68bb         	ldr	r3, [r7, #0x8]
 8015d62: 3308         	adds	r3, #0x8
 8015d64: edd3 7a00    	vldr	s15, [r3]
 8015d68: ee27 7a27    	vmul.f32	s14, s14, s15
 8015d6c: 68fb         	ldr	r3, [r7, #0xc]
 8015d6e: 3308         	adds	r3, #0x8
 8015d70: edd3 6a00    	vldr	s13, [r3]
 8015d74: 68bb         	ldr	r3, [r7, #0x8]
 8015d76: 3304         	adds	r3, #0x4
 8015d78: edd3 7a00    	vldr	s15, [r3]
 8015d7c: ee66 7aa7    	vmul.f32	s15, s13, s15
 8015d80: ee77 7a67    	vsub.f32	s15, s14, s15
 8015d84: 687b         	ldr	r3, [r7, #0x4]
 8015d86: edc3 7a00    	vstr	s15, [r3]
; 	res[1] = v1[2] * v2[0] - v1[0] * v2[2];
 8015d8a: 68fb         	ldr	r3, [r7, #0xc]
 8015d8c: 3308         	adds	r3, #0x8
 8015d8e: ed93 7a00    	vldr	s14, [r3]
 8015d92: 68bb         	ldr	r3, [r7, #0x8]
 8015d94: edd3 7a00    	vldr	s15, [r3]
 8015d98: ee27 7a27    	vmul.f32	s14, s14, s15
 8015d9c: 68fb         	ldr	r3, [r7, #0xc]
 8015d9e: edd3 6a00    	vldr	s13, [r3]
 8015da2: 68bb         	ldr	r3, [r7, #0x8]
 8015da4: 3308         	adds	r3, #0x8
 8015da6: edd3 7a00    	vldr	s15, [r3]
 8015daa: ee66 7aa7    	vmul.f32	s15, s13, s15
 8015dae: 687b         	ldr	r3, [r7, #0x4]
 8015db0: 3304         	adds	r3, #0x4
 8015db2: ee77 7a67    	vsub.f32	s15, s14, s15
 8015db6: edc3 7a00    	vstr	s15, [r3]
; 	res[2] = v1[0] * v2[1] - v1[1] * v2[0];
 8015dba: 68fb         	ldr	r3, [r7, #0xc]
 8015dbc: ed93 7a00    	vldr	s14, [r3]
 8015dc0: 68bb         	ldr	r3, [r7, #0x8]
 8015dc2: 3304         	adds	r3, #0x4
 8015dc4: edd3 7a00    	vldr	s15, [r3]
 8015dc8: ee27 7a27    	vmul.f32	s14, s14, s15
 8015dcc: 68fb         	ldr	r3, [r7, #0xc]
 8015dce: 3304         	adds	r3, #0x4
 8015dd0: edd3 6a00    	vldr	s13, [r3]
 8015dd4: 68bb         	ldr	r3, [r7, #0x8]
 8015dd6: edd3 7a00    	vldr	s15, [r3]
 8015dda: ee66 7aa7    	vmul.f32	s15, s13, s15
 8015dde: 687b         	ldr	r3, [r7, #0x4]
 8015de0: 3308         	adds	r3, #0x8
 8015de2: ee77 7a67    	vsub.f32	s15, s14, s15
 8015de6: edc3 7a00    	vstr	s15, [r3]
; }
 8015dea: bf00         	nop
 8015dec: 3714         	adds	r7, #0x14
 8015dee: 46bd         	mov	sp, r7
 8015df0: f85d 7b04    	ldr	r7, [sp], #4
 8015df4: 4770         	bx	lr

08015df6 <Dot3d>:
; {
 8015df6: b480         	push	{r7}
 8015df8: b083         	sub	sp, #0xc
 8015dfa: af00         	add	r7, sp, #0x0
 8015dfc: 6078         	str	r0, [r7, #0x4]
 8015dfe: 6039         	str	r1, [r7]
; 	return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
 8015e00: 687b         	ldr	r3, [r7, #0x4]
 8015e02: ed93 7a00    	vldr	s14, [r3]
 8015e06: 683b         	ldr	r3, [r7]
 8015e08: edd3 7a00    	vldr	s15, [r3]
 8015e0c: ee27 7a27    	vmul.f32	s14, s14, s15
 8015e10: 687b         	ldr	r3, [r7, #0x4]
 8015e12: 3304         	adds	r3, #0x4
 8015e14: edd3 6a00    	vldr	s13, [r3]
 8015e18: 683b         	ldr	r3, [r7]
 8015e1a: 3304         	adds	r3, #0x4
 8015e1c: edd3 7a00    	vldr	s15, [r3]
 8015e20: ee66 7aa7    	vmul.f32	s15, s13, s15
 8015e24: ee37 7a27    	vadd.f32	s14, s14, s15
 8015e28: 687b         	ldr	r3, [r7, #0x4]
 8015e2a: 3308         	adds	r3, #0x8
 8015e2c: edd3 6a00    	vldr	s13, [r3]
 8015e30: 683b         	ldr	r3, [r7]
 8015e32: 3308         	adds	r3, #0x8
 8015e34: edd3 7a00    	vldr	s15, [r3]
 8015e38: ee66 7aa7    	vmul.f32	s15, s13, s15
 8015e3c: ee77 7a27    	vadd.f32	s15, s14, s15
; }
 8015e40: eeb0 0a67    	vmov.f32	s0, s15
 8015e44: 370c         	adds	r7, #0xc
 8015e46: 46bd         	mov	sp, r7
 8015e48: f85d 7b04    	ldr	r7, [sp], #4
 8015e4c: 4770         	bx	lr

08015e4e <big_heap_chunks>:
; {
 8015e4e: b480         	push	{r7}
 8015e50: b083         	sub	sp, #0xc
 8015e52: af00         	add	r7, sp, #0x0
 8015e54: 6078         	str	r0, [r7, #0x4]
; 		return false;
 8015e56: 2300         	movs	r3, #0x0
; }
 8015e58: 4618         	mov	r0, r3
 8015e5a: 370c         	adds	r7, #0xc
 8015e5c: 46bd         	mov	sp, r7
 8015e5e: f85d 7b04    	ldr	r7, [sp], #4
 8015e62: 4770         	bx	lr

08015e64 <big_heap_bytes>:
; {
 8015e64: b580         	push	{r7, lr}
 8015e66: b082         	sub	sp, #0x8
 8015e68: af00         	add	r7, sp, #0x0
 8015e6a: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(bytes / CHUNK_UNIT);
 8015e6c: 687b         	ldr	r3, [r7, #0x4]
 8015e6e: 08db         	lsrs	r3, r3, #0x3
 8015e70: 4618         	mov	r0, r3
 8015e72: f7ff ffec    	bl	0x8015e4e <big_heap_chunks> @ imm = #-0x28
 8015e76: 4603         	mov	r3, r0
; }
 8015e78: 4618         	mov	r0, r3
 8015e7a: 3708         	adds	r7, #0x8
 8015e7c: 46bd         	mov	sp, r7
 8015e7e: bd80         	pop	{r7, pc}

08015e80 <big_heap>:
; {
 8015e80: b580         	push	{r7, lr}
 8015e82: b082         	sub	sp, #0x8
 8015e84: af00         	add	r7, sp, #0x0
 8015e86: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(h->end_chunk);
 8015e88: 687b         	ldr	r3, [r7, #0x4]
 8015e8a: 689b         	ldr	r3, [r3, #0x8]
 8015e8c: 4618         	mov	r0, r3
 8015e8e: f7ff ffde    	bl	0x8015e4e <big_heap_chunks> @ imm = #-0x44
 8015e92: 4603         	mov	r3, r0
; }
 8015e94: 4618         	mov	r0, r3
 8015e96: 3708         	adds	r7, #0x8
 8015e98: 46bd         	mov	sp, r7
 8015e9a: bd80         	pop	{r7, pc}

08015e9c <chunk_buf>:
; {
 8015e9c: b480         	push	{r7}
 8015e9e: b083         	sub	sp, #0xc
 8015ea0: af00         	add	r7, sp, #0x0
 8015ea2: 6078         	str	r0, [r7, #0x4]
; 	return (chunk_unit_t *)h;
 8015ea4: 687b         	ldr	r3, [r7, #0x4]
; }
 8015ea6: 4618         	mov	r0, r3
 8015ea8: 370c         	adds	r7, #0xc
 8015eaa: 46bd         	mov	sp, r7
 8015eac: f85d 7b04    	ldr	r7, [sp], #4
 8015eb0: 4770         	bx	lr

08015eb2 <chunk_field>:
; {
 8015eb2: b580         	push	{r7, lr}
 8015eb4: b086         	sub	sp, #0x18
 8015eb6: af00         	add	r7, sp, #0x0
 8015eb8: 60f8         	str	r0, [r7, #0xc]
 8015eba: 60b9         	str	r1, [r7, #0x8]
 8015ebc: 4613         	mov	r3, r2
 8015ebe: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 8015ec0: 68f8         	ldr	r0, [r7, #0xc]
 8015ec2: f7ff ffeb    	bl	0x8015e9c <chunk_buf>   @ imm = #-0x2a
 8015ec6: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 8015ec8: 68bb         	ldr	r3, [r7, #0x8]
 8015eca: 00db         	lsls	r3, r3, #0x3
 8015ecc: 697a         	ldr	r2, [r7, #0x14]
 8015ece: 4413         	add	r3, r2
 8015ed0: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 8015ed2: 68f8         	ldr	r0, [r7, #0xc]
 8015ed4: f7ff ffd4    	bl	0x8015e80 <big_heap>    @ imm = #-0x58
 8015ed8: 4603         	mov	r3, r0
 8015eda: 2b00         	cmp	r3, #0x0
 8015edc: d005         	beq	0x8015eea <chunk_field+0x38> @ imm = #0xa
; 		return ((uint32_t *)cmem)[f];
 8015ede: 79fb         	ldrb	r3, [r7, #0x7]
 8015ee0: 009b         	lsls	r3, r3, #0x2
 8015ee2: 693a         	ldr	r2, [r7, #0x10]
 8015ee4: 4413         	add	r3, r2
 8015ee6: 681b         	ldr	r3, [r3]
 8015ee8: e004         	b	0x8015ef4 <chunk_field+0x42> @ imm = #0x8
; 		return ((uint16_t *)cmem)[f];
 8015eea: 79fb         	ldrb	r3, [r7, #0x7]
 8015eec: 005b         	lsls	r3, r3, #0x1
 8015eee: 693a         	ldr	r2, [r7, #0x10]
 8015ef0: 4413         	add	r3, r2
 8015ef2: 881b         	ldrh	r3, [r3]
; }
 8015ef4: 4618         	mov	r0, r3
 8015ef6: 3718         	adds	r7, #0x18
 8015ef8: 46bd         	mov	sp, r7
 8015efa: bd80         	pop	{r7, pc}

08015efc <chunk_set>:
; {
 8015efc: b580         	push	{r7, lr}
 8015efe: b086         	sub	sp, #0x18
 8015f00: af00         	add	r7, sp, #0x0
 8015f02: 60f8         	str	r0, [r7, #0xc]
 8015f04: 60b9         	str	r1, [r7, #0x8]
 8015f06: 603b         	str	r3, [r7]
 8015f08: 4613         	mov	r3, r2
 8015f0a: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 8015f0c: 68f8         	ldr	r0, [r7, #0xc]
 8015f0e: f7ff ffc5    	bl	0x8015e9c <chunk_buf>   @ imm = #-0x76
 8015f12: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 8015f14: 68bb         	ldr	r3, [r7, #0x8]
 8015f16: 00db         	lsls	r3, r3, #0x3
 8015f18: 697a         	ldr	r2, [r7, #0x14]
 8015f1a: 4413         	add	r3, r2
 8015f1c: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 8015f1e: 68f8         	ldr	r0, [r7, #0xc]
 8015f20: f7ff ffae    	bl	0x8015e80 <big_heap>    @ imm = #-0xa4
 8015f24: 4603         	mov	r3, r0
 8015f26: 2b00         	cmp	r3, #0x0
 8015f28: d006         	beq	0x8015f38 <chunk_set+0x3c> @ imm = #0xc
; 		((uint32_t *)cmem)[f] = val;
 8015f2a: 79fb         	ldrb	r3, [r7, #0x7]
 8015f2c: 009b         	lsls	r3, r3, #0x2
 8015f2e: 693a         	ldr	r2, [r7, #0x10]
 8015f30: 4413         	add	r3, r2
 8015f32: 683a         	ldr	r2, [r7]
 8015f34: 601a         	str	r2, [r3]
; }
 8015f36: e006         	b	0x8015f46 <chunk_set+0x4a> @ imm = #0xc
; 		((uint16_t *)cmem)[f] = val;
 8015f38: 79fb         	ldrb	r3, [r7, #0x7]
 8015f3a: 005b         	lsls	r3, r3, #0x1
 8015f3c: 693a         	ldr	r2, [r7, #0x10]
 8015f3e: 4413         	add	r3, r2
 8015f40: 683a         	ldr	r2, [r7]
 8015f42: b292         	uxth	r2, r2
 8015f44: 801a         	strh	r2, [r3]
; }
 8015f46: bf00         	nop
 8015f48: 3718         	adds	r7, #0x18
 8015f4a: 46bd         	mov	sp, r7
 8015f4c: bd80         	pop	{r7, pc}

08015f4e <chunk_size>:
; {
 8015f4e: b580         	push	{r7, lr}
 8015f50: b082         	sub	sp, #0x8
 8015f52: af00         	add	r7, sp, #0x0
 8015f54: 6078         	str	r0, [r7, #0x4]
 8015f56: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, SIZE_AND_USED) >> 1;
 8015f58: 2201         	movs	r2, #0x1
 8015f5a: 6839         	ldr	r1, [r7]
 8015f5c: 6878         	ldr	r0, [r7, #0x4]
 8015f5e: f7ff ffa8    	bl	0x8015eb2 <chunk_field> @ imm = #-0xb0
 8015f62: 4603         	mov	r3, r0
 8015f64: 085b         	lsrs	r3, r3, #0x1
; }
 8015f66: 4618         	mov	r0, r3
 8015f68: 3708         	adds	r7, #0x8
 8015f6a: 46bd         	mov	sp, r7
 8015f6c: bd80         	pop	{r7, pc}

08015f6e <set_chunk_used>:
; {
 8015f6e: b580         	push	{r7, lr}
 8015f70: b086         	sub	sp, #0x18
 8015f72: af00         	add	r7, sp, #0x0
 8015f74: 60f8         	str	r0, [r7, #0xc]
 8015f76: 60b9         	str	r1, [r7, #0x8]
 8015f78: 4613         	mov	r3, r2
 8015f7a: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 8015f7c: 68f8         	ldr	r0, [r7, #0xc]
 8015f7e: f7ff ff8d    	bl	0x8015e9c <chunk_buf>   @ imm = #-0xe6
 8015f82: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 8015f84: 68bb         	ldr	r3, [r7, #0x8]
 8015f86: 00db         	lsls	r3, r3, #0x3
 8015f88: 697a         	ldr	r2, [r7, #0x14]
 8015f8a: 4413         	add	r3, r2
 8015f8c: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 8015f8e: 68f8         	ldr	r0, [r7, #0xc]
 8015f90: f7ff ff76    	bl	0x8015e80 <big_heap>    @ imm = #-0x114
 8015f94: 4603         	mov	r3, r0
 8015f96: 2b00         	cmp	r3, #0x0
 8015f98: d014         	beq	0x8015fc4 <set_chunk_used+0x56> @ imm = #0x28
; 		if (used) {
 8015f9a: 79fb         	ldrb	r3, [r7, #0x7]
 8015f9c: 2b00         	cmp	r3, #0x0
 8015f9e: d008         	beq	0x8015fb2 <set_chunk_used+0x44> @ imm = #0x10
; 			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
 8015fa0: 693b         	ldr	r3, [r7, #0x10]
 8015fa2: 3304         	adds	r3, #0x4
 8015fa4: 681a         	ldr	r2, [r3]
 8015fa6: 693b         	ldr	r3, [r7, #0x10]
 8015fa8: 3304         	adds	r3, #0x4
 8015faa: f042 0201    	orr	r2, r2, #0x1
 8015fae: 601a         	str	r2, [r3]
; }
 8015fb0: e01e         	b	0x8015ff0 <set_chunk_used+0x82> @ imm = #0x3c
; 			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
 8015fb2: 693b         	ldr	r3, [r7, #0x10]
 8015fb4: 3304         	adds	r3, #0x4
 8015fb6: 681a         	ldr	r2, [r3]
 8015fb8: 693b         	ldr	r3, [r7, #0x10]
 8015fba: 3304         	adds	r3, #0x4
 8015fbc: f022 0201    	bic	r2, r2, #0x1
 8015fc0: 601a         	str	r2, [r3]
; }
 8015fc2: e015         	b	0x8015ff0 <set_chunk_used+0x82> @ imm = #0x2a
; 		if (used) {
 8015fc4: 79fb         	ldrb	r3, [r7, #0x7]
 8015fc6: 2b00         	cmp	r3, #0x0
 8015fc8: d009         	beq	0x8015fde <set_chunk_used+0x70> @ imm = #0x12
; 			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 8015fca: 693b         	ldr	r3, [r7, #0x10]
 8015fcc: 3302         	adds	r3, #0x2
 8015fce: 881a         	ldrh	r2, [r3]
 8015fd0: 693b         	ldr	r3, [r7, #0x10]
 8015fd2: 3302         	adds	r3, #0x2
 8015fd4: f042 0201    	orr	r2, r2, #0x1
 8015fd8: b292         	uxth	r2, r2
 8015fda: 801a         	strh	r2, [r3]
; }
 8015fdc: e008         	b	0x8015ff0 <set_chunk_used+0x82> @ imm = #0x10
; 			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
 8015fde: 693b         	ldr	r3, [r7, #0x10]
 8015fe0: 3302         	adds	r3, #0x2
 8015fe2: 881a         	ldrh	r2, [r3]
 8015fe4: 693b         	ldr	r3, [r7, #0x10]
 8015fe6: 3302         	adds	r3, #0x2
 8015fe8: f022 0201    	bic	r2, r2, #0x1
 8015fec: b292         	uxth	r2, r2
 8015fee: 801a         	strh	r2, [r3]
; }
 8015ff0: bf00         	nop
 8015ff2: 3718         	adds	r7, #0x18
 8015ff4: 46bd         	mov	sp, r7
 8015ff6: bd80         	pop	{r7, pc}

08015ff8 <set_chunk_size>:
; {
 8015ff8: b580         	push	{r7, lr}
 8015ffa: b084         	sub	sp, #0x10
 8015ffc: af00         	add	r7, sp, #0x0
 8015ffe: 60f8         	str	r0, [r7, #0xc]
 8016000: 60b9         	str	r1, [r7, #0x8]
 8016002: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, SIZE_AND_USED, size << 1);
 8016004: 687b         	ldr	r3, [r7, #0x4]
 8016006: 005b         	lsls	r3, r3, #0x1
 8016008: 2201         	movs	r2, #0x1
 801600a: 68b9         	ldr	r1, [r7, #0x8]
 801600c: 68f8         	ldr	r0, [r7, #0xc]
 801600e: f7ff ff75    	bl	0x8015efc <chunk_set>   @ imm = #-0x116
; }
 8016012: bf00         	nop
 8016014: 3710         	adds	r7, #0x10
 8016016: 46bd         	mov	sp, r7
 8016018: bd80         	pop	{r7, pc}

0801601a <prev_free_chunk>:
; {
 801601a: b580         	push	{r7, lr}
 801601c: b082         	sub	sp, #0x8
 801601e: af00         	add	r7, sp, #0x0
 8016020: 6078         	str	r0, [r7, #0x4]
 8016022: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, FREE_PREV);
 8016024: 2202         	movs	r2, #0x2
 8016026: 6839         	ldr	r1, [r7]
 8016028: 6878         	ldr	r0, [r7, #0x4]
 801602a: f7ff ff42    	bl	0x8015eb2 <chunk_field> @ imm = #-0x17c
 801602e: 4603         	mov	r3, r0
; }
 8016030: 4618         	mov	r0, r3
 8016032: 3708         	adds	r7, #0x8
 8016034: 46bd         	mov	sp, r7
 8016036: bd80         	pop	{r7, pc}

08016038 <next_free_chunk>:
; {
 8016038: b580         	push	{r7, lr}
 801603a: b082         	sub	sp, #0x8
 801603c: af00         	add	r7, sp, #0x0
 801603e: 6078         	str	r0, [r7, #0x4]
 8016040: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, FREE_NEXT);
 8016042: 2203         	movs	r2, #0x3
 8016044: 6839         	ldr	r1, [r7]
 8016046: 6878         	ldr	r0, [r7, #0x4]
 8016048: f7ff ff33    	bl	0x8015eb2 <chunk_field> @ imm = #-0x19a
 801604c: 4603         	mov	r3, r0
; }
 801604e: 4618         	mov	r0, r3
 8016050: 3708         	adds	r7, #0x8
 8016052: 46bd         	mov	sp, r7
 8016054: bd80         	pop	{r7, pc}

08016056 <set_prev_free_chunk>:
; {
 8016056: b580         	push	{r7, lr}
 8016058: b084         	sub	sp, #0x10
 801605a: af00         	add	r7, sp, #0x0
 801605c: 60f8         	str	r0, [r7, #0xc]
 801605e: 60b9         	str	r1, [r7, #0x8]
 8016060: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_PREV, prev);
 8016062: 687b         	ldr	r3, [r7, #0x4]
 8016064: 2202         	movs	r2, #0x2
 8016066: 68b9         	ldr	r1, [r7, #0x8]
 8016068: 68f8         	ldr	r0, [r7, #0xc]
 801606a: f7ff ff47    	bl	0x8015efc <chunk_set>   @ imm = #-0x172
; }
 801606e: bf00         	nop
 8016070: 3710         	adds	r7, #0x10
 8016072: 46bd         	mov	sp, r7
 8016074: bd80         	pop	{r7, pc}

08016076 <set_next_free_chunk>:
; {
 8016076: b580         	push	{r7, lr}
 8016078: b084         	sub	sp, #0x10
 801607a: af00         	add	r7, sp, #0x0
 801607c: 60f8         	str	r0, [r7, #0xc]
 801607e: 60b9         	str	r1, [r7, #0x8]
 8016080: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_NEXT, next);
 8016082: 687b         	ldr	r3, [r7, #0x4]
 8016084: 2203         	movs	r2, #0x3
 8016086: 68b9         	ldr	r1, [r7, #0x8]
 8016088: 68f8         	ldr	r0, [r7, #0xc]
 801608a: f7ff ff37    	bl	0x8015efc <chunk_set>   @ imm = #-0x192
; }
 801608e: bf00         	nop
 8016090: 3710         	adds	r7, #0x10
 8016092: 46bd         	mov	sp, r7
 8016094: bd80         	pop	{r7, pc}

08016096 <right_chunk>:
; {
 8016096: b580         	push	{r7, lr}
 8016098: b082         	sub	sp, #0x8
 801609a: af00         	add	r7, sp, #0x0
 801609c: 6078         	str	r0, [r7, #0x4]
 801609e: 6039         	str	r1, [r7]
; 	return c + chunk_size(h, c);
 80160a0: 6839         	ldr	r1, [r7]
 80160a2: 6878         	ldr	r0, [r7, #0x4]
 80160a4: f7ff ff53    	bl	0x8015f4e <chunk_size>  @ imm = #-0x15a
 80160a8: 4602         	mov	r2, r0
 80160aa: 683b         	ldr	r3, [r7]
 80160ac: 4413         	add	r3, r2
; }
 80160ae: 4618         	mov	r0, r3
 80160b0: 3708         	adds	r7, #0x8
 80160b2: 46bd         	mov	sp, r7
 80160b4: bd80         	pop	{r7, pc}

080160b6 <set_left_chunk_size>:
; {
 80160b6: b580         	push	{r7, lr}
 80160b8: b084         	sub	sp, #0x10
 80160ba: af00         	add	r7, sp, #0x0
 80160bc: 60f8         	str	r0, [r7, #0xc]
 80160be: 60b9         	str	r1, [r7, #0x8]
 80160c0: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, LEFT_SIZE, size);
 80160c2: 687b         	ldr	r3, [r7, #0x4]
 80160c4: 2200         	movs	r2, #0x0
 80160c6: 68b9         	ldr	r1, [r7, #0x8]
 80160c8: 68f8         	ldr	r0, [r7, #0xc]
 80160ca: f7ff ff17    	bl	0x8015efc <chunk_set>   @ imm = #-0x1d2
; }
 80160ce: bf00         	nop
 80160d0: 3710         	adds	r7, #0x10
 80160d2: 46bd         	mov	sp, r7
 80160d4: bd80         	pop	{r7, pc}

080160d6 <solo_free_header>:
; {
 80160d6: b580         	push	{r7, lr}
 80160d8: b082         	sub	sp, #0x8
 80160da: af00         	add	r7, sp, #0x0
 80160dc: 6078         	str	r0, [r7, #0x4]
 80160de: 6039         	str	r1, [r7]
; 	return big_heap(h) && (chunk_size(h, c) == 1U);
 80160e0: 6878         	ldr	r0, [r7, #0x4]
 80160e2: f7ff fecd    	bl	0x8015e80 <big_heap>    @ imm = #-0x266
 80160e6: 4603         	mov	r3, r0
 80160e8: 2b00         	cmp	r3, #0x0
 80160ea: d008         	beq	0x80160fe <solo_free_header+0x28> @ imm = #0x10
 80160ec: 6839         	ldr	r1, [r7]
 80160ee: 6878         	ldr	r0, [r7, #0x4]
 80160f0: f7ff ff2d    	bl	0x8015f4e <chunk_size>  @ imm = #-0x1a6
 80160f4: 4603         	mov	r3, r0
 80160f6: 2b01         	cmp	r3, #0x1
 80160f8: d101         	bne	0x80160fe <solo_free_header+0x28> @ imm = #0x2
 80160fa: 2301         	movs	r3, #0x1
 80160fc: e000         	b	0x8016100 <solo_free_header+0x2a> @ imm = #0x0
 80160fe: 2300         	movs	r3, #0x0
 8016100: f003 0301    	and	r3, r3, #0x1
 8016104: b2db         	uxtb	r3, r3
; }
 8016106: 4618         	mov	r0, r3
 8016108: 3708         	adds	r7, #0x8
 801610a: 46bd         	mov	sp, r7
 801610c: bd80         	pop	{r7, pc}

0801610e <chunk_header_bytes>:
; {
 801610e: b580         	push	{r7, lr}
 8016110: b082         	sub	sp, #0x8
 8016112: af00         	add	r7, sp, #0x0
 8016114: 6078         	str	r0, [r7, #0x4]
; 	return big_heap(h) ? 8 : 4;
 8016116: 6878         	ldr	r0, [r7, #0x4]
 8016118: f7ff feb2    	bl	0x8015e80 <big_heap>    @ imm = #-0x29c
 801611c: 4603         	mov	r3, r0
 801611e: 2b00         	cmp	r3, #0x0
 8016120: d001         	beq	0x8016126 <chunk_header_bytes+0x18> @ imm = #0x2
 8016122: 2308         	movs	r3, #0x8
 8016124: e000         	b	0x8016128 <chunk_header_bytes+0x1a> @ imm = #0x0
 8016126: 2304         	movs	r3, #0x4
; }
 8016128: 4618         	mov	r0, r3
 801612a: 3708         	adds	r7, #0x8
 801612c: 46bd         	mov	sp, r7
 801612e: bd80         	pop	{r7, pc}

08016130 <heap_footer_bytes>:
; {
 8016130: b580         	push	{r7, lr}
 8016132: b082         	sub	sp, #0x8
 8016134: af00         	add	r7, sp, #0x0
 8016136: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_bytes(size) ? 8 : 4;
 8016138: 6878         	ldr	r0, [r7, #0x4]
 801613a: f7ff fe93    	bl	0x8015e64 <big_heap_bytes> @ imm = #-0x2da
 801613e: 4603         	mov	r3, r0
 8016140: 2b00         	cmp	r3, #0x0
 8016142: d001         	beq	0x8016148 <heap_footer_bytes+0x18> @ imm = #0x2
 8016144: 2308         	movs	r3, #0x8
 8016146: e000         	b	0x801614a <heap_footer_bytes+0x1a> @ imm = #0x0
 8016148: 2304         	movs	r3, #0x4
; }
 801614a: 4618         	mov	r0, r3
 801614c: 3708         	adds	r7, #0x8
 801614e: 46bd         	mov	sp, r7
 8016150: bd80         	pop	{r7, pc}

08016152 <chunksz>:
; {
 8016152: b480         	push	{r7}
 8016154: b083         	sub	sp, #0xc
 8016156: af00         	add	r7, sp, #0x0
 8016158: 6078         	str	r0, [r7, #0x4]
; 	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 801615a: 687b         	ldr	r3, [r7, #0x4]
 801615c: 3307         	adds	r3, #0x7
 801615e: 08db         	lsrs	r3, r3, #0x3
; }
 8016160: 4618         	mov	r0, r3
 8016162: 370c         	adds	r7, #0xc
 8016164: 46bd         	mov	sp, r7
 8016166: f85d 7b04    	ldr	r7, [sp], #4
 801616a: 4770         	bx	lr

0801616c <bytes_to_chunksz>:
; {
 801616c: b580         	push	{r7, lr}
 801616e: b082         	sub	sp, #0x8
 8016170: af00         	add	r7, sp, #0x0
 8016172: 6078         	str	r0, [r7, #0x4]
 8016174: 6039         	str	r1, [r7]
; 	return chunksz(chunk_header_bytes(h) + bytes);
 8016176: 6878         	ldr	r0, [r7, #0x4]
 8016178: f7ff ffc9    	bl	0x801610e <chunk_header_bytes> @ imm = #-0x6e
 801617c: 4602         	mov	r2, r0
 801617e: 683b         	ldr	r3, [r7]
 8016180: 4413         	add	r3, r2
 8016182: 4618         	mov	r0, r3
 8016184: f7ff ffe5    	bl	0x8016152 <chunksz>     @ imm = #-0x36
 8016188: 4603         	mov	r3, r0
; }
 801618a: 4618         	mov	r0, r3
 801618c: 3708         	adds	r7, #0x8
 801618e: 46bd         	mov	sp, r7
 8016190: bd80         	pop	{r7, pc}

08016192 <min_chunk_size>:
; {
 8016192: b580         	push	{r7, lr}
 8016194: b082         	sub	sp, #0x8
 8016196: af00         	add	r7, sp, #0x0
 8016198: 6078         	str	r0, [r7, #0x4]
; 	return bytes_to_chunksz(h, 1);
 801619a: 2101         	movs	r1, #0x1
 801619c: 6878         	ldr	r0, [r7, #0x4]
 801619e: f7ff ffe5    	bl	0x801616c <bytes_to_chunksz> @ imm = #-0x36
 80161a2: 4603         	mov	r3, r0
; }
 80161a4: 4618         	mov	r0, r3
 80161a6: 3708         	adds	r7, #0x8
 80161a8: 46bd         	mov	sp, r7
 80161aa: bd80         	pop	{r7, pc}

080161ac <bucket_idx>:
; {
 80161ac: b580         	push	{r7, lr}
 80161ae: b084         	sub	sp, #0x10
 80161b0: af00         	add	r7, sp, #0x0
 80161b2: 6078         	str	r0, [r7, #0x4]
 80161b4: 6039         	str	r1, [r7]
; 	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
 80161b6: 6878         	ldr	r0, [r7, #0x4]
 80161b8: f7ff ffeb    	bl	0x8016192 <min_chunk_size> @ imm = #-0x2a
 80161bc: 4602         	mov	r2, r0
 80161be: 683b         	ldr	r3, [r7]
 80161c0: 1a9b         	subs	r3, r3, r2
 80161c2: 3301         	adds	r3, #0x1
 80161c4: 60fb         	str	r3, [r7, #0xc]
; 	return 31 - __builtin_clz(usable_sz);
 80161c6: 68fb         	ldr	r3, [r7, #0xc]
 80161c8: fab3 f383    	clz	r3, r3
 80161cc: f1c3 031f    	rsb.w	r3, r3, #0x1f
; }
 80161d0: 4618         	mov	r0, r3
 80161d2: 3710         	adds	r7, #0x10
 80161d4: 46bd         	mov	sp, r7
 80161d6: bd80         	pop	{r7, pc}

080161d8 <size_too_big>:
; {
 80161d8: b480         	push	{r7}
 80161da: b083         	sub	sp, #0xc
 80161dc: af00         	add	r7, sp, #0x0
 80161de: 6078         	str	r0, [r7, #0x4]
 80161e0: 6039         	str	r1, [r7]
; 	return (bytes / CHUNK_UNIT) >= h->end_chunk;
 80161e2: 683b         	ldr	r3, [r7]
 80161e4: 08da         	lsrs	r2, r3, #0x3
 80161e6: 687b         	ldr	r3, [r7, #0x4]
 80161e8: 689b         	ldr	r3, [r3, #0x8]
 80161ea: 429a         	cmp	r2, r3
 80161ec: bf2c         	ite	hs
 80161ee: 2301         	movhs	r3, #0x1
 80161f0: 2300         	movlo	r3, #0x0
 80161f2: b2db         	uxtb	r3, r3
; }
 80161f4: 4618         	mov	r0, r3
 80161f6: 370c         	adds	r7, #0xc
 80161f8: 46bd         	mov	sp, r7
 80161fa: f85d 7b04    	ldr	r7, [sp], #4
 80161fe: 4770         	bx	lr

08016200 <chunk_mem>:
; {
 8016200: b590         	push	{r4, r7, lr}
 8016202: b085         	sub	sp, #0x14
 8016204: af00         	add	r7, sp, #0x0
 8016206: 6078         	str	r0, [r7, #0x4]
 8016208: 6039         	str	r1, [r7]
; 	chunk_unit_t *buf = chunk_buf(h);
 801620a: 6878         	ldr	r0, [r7, #0x4]
 801620c: f7ff fe46    	bl	0x8015e9c <chunk_buf>   @ imm = #-0x374
 8016210: 60f8         	str	r0, [r7, #0xc]
; 	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
 8016212: 683b         	ldr	r3, [r7]
 8016214: 00dc         	lsls	r4, r3, #0x3
 8016216: 6878         	ldr	r0, [r7, #0x4]
 8016218: f7ff ff79    	bl	0x801610e <chunk_header_bytes> @ imm = #-0x10e
 801621c: 4603         	mov	r3, r0
 801621e: 4423         	add	r3, r4
 8016220: 68fa         	ldr	r2, [r7, #0xc]
 8016222: 4413         	add	r3, r2
 8016224: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 8016226: 68bb         	ldr	r3, [r7, #0x8]
; }
 8016228: 4618         	mov	r0, r3
 801622a: 3714         	adds	r7, #0x14
 801622c: 46bd         	mov	sp, r7
 801622e: bd90         	pop	{r4, r7, pc}

08016230 <free_list_remove_bidx>:
; {
 8016230: b580         	push	{r7, lr}
 8016232: b088         	sub	sp, #0x20
 8016234: af00         	add	r7, sp, #0x0
 8016236: 60f8         	str	r0, [r7, #0xc]
 8016238: 60b9         	str	r1, [r7, #0x8]
 801623a: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap_bucket *b = &h->buckets[bidx];
 801623c: 687b         	ldr	r3, [r7, #0x4]
 801623e: 3304         	adds	r3, #0x4
 8016240: 009b         	lsls	r3, r3, #0x2
 8016242: 68fa         	ldr	r2, [r7, #0xc]
 8016244: 4413         	add	r3, r2
 8016246: 61fb         	str	r3, [r7, #0x1c]
; 	if (next_free_chunk(h, c) == c) {
 8016248: 68b9         	ldr	r1, [r7, #0x8]
 801624a: 68f8         	ldr	r0, [r7, #0xc]
 801624c: f7ff fef4    	bl	0x8016038 <next_free_chunk> @ imm = #-0x218
 8016250: 4602         	mov	r2, r0
 8016252: 68bb         	ldr	r3, [r7, #0x8]
 8016254: 4293         	cmp	r3, r2
 8016256: d10d         	bne	0x8016274 <free_list_remove_bidx+0x44> @ imm = #0x1a
; 		h->avail_buckets &= ~BIT(bidx);
 8016258: 68fb         	ldr	r3, [r7, #0xc]
 801625a: 68da         	ldr	r2, [r3, #0xc]
 801625c: 2101         	movs	r1, #0x1
 801625e: 687b         	ldr	r3, [r7, #0x4]
 8016260: fa01 f303    	lsl.w	r3, r1, r3
 8016264: 43db         	mvns	r3, r3
 8016266: 401a         	ands	r2, r3
 8016268: 68fb         	ldr	r3, [r7, #0xc]
 801626a: 60da         	str	r2, [r3, #0xc]
; 		b->next = 0;
 801626c: 69fb         	ldr	r3, [r7, #0x1c]
 801626e: 2200         	movs	r2, #0x0
 8016270: 601a         	str	r2, [r3]
; }
 8016272: e016         	b	0x80162a2 <free_list_remove_bidx+0x72> @ imm = #0x2c
; 		chunkid_t first = prev_free_chunk(h, c),
 8016274: 68b9         	ldr	r1, [r7, #0x8]
 8016276: 68f8         	ldr	r0, [r7, #0xc]
 8016278: f7ff fecf    	bl	0x801601a <prev_free_chunk> @ imm = #-0x262
 801627c: 61b8         	str	r0, [r7, #0x18]
; 			  second = next_free_chunk(h, c);
 801627e: 68b9         	ldr	r1, [r7, #0x8]
 8016280: 68f8         	ldr	r0, [r7, #0xc]
 8016282: f7ff fed9    	bl	0x8016038 <next_free_chunk> @ imm = #-0x24e
 8016286: 6178         	str	r0, [r7, #0x14]
; 		b->next = second;
 8016288: 69fb         	ldr	r3, [r7, #0x1c]
 801628a: 697a         	ldr	r2, [r7, #0x14]
 801628c: 601a         	str	r2, [r3]
; 		set_next_free_chunk(h, first, second);
 801628e: 697a         	ldr	r2, [r7, #0x14]
 8016290: 69b9         	ldr	r1, [r7, #0x18]
 8016292: 68f8         	ldr	r0, [r7, #0xc]
 8016294: f7ff feef    	bl	0x8016076 <set_next_free_chunk> @ imm = #-0x222
; 		set_prev_free_chunk(h, second, first);
 8016298: 69ba         	ldr	r2, [r7, #0x18]
 801629a: 6979         	ldr	r1, [r7, #0x14]
 801629c: 68f8         	ldr	r0, [r7, #0xc]
 801629e: f7ff feda    	bl	0x8016056 <set_prev_free_chunk> @ imm = #-0x24c
; }
 80162a2: bf00         	nop
 80162a4: 3720         	adds	r7, #0x20
 80162a6: 46bd         	mov	sp, r7
 80162a8: bd80         	pop	{r7, pc}

080162aa <free_list_add_bidx>:
; {
 80162aa: b580         	push	{r7, lr}
 80162ac: b088         	sub	sp, #0x20
 80162ae: af00         	add	r7, sp, #0x0
 80162b0: 60f8         	str	r0, [r7, #0xc]
 80162b2: 60b9         	str	r1, [r7, #0x8]
 80162b4: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap_bucket *b = &h->buckets[bidx];
 80162b6: 687b         	ldr	r3, [r7, #0x4]
 80162b8: 3304         	adds	r3, #0x4
 80162ba: 009b         	lsls	r3, r3, #0x2
 80162bc: 68fa         	ldr	r2, [r7, #0xc]
 80162be: 4413         	add	r3, r2
 80162c0: 61fb         	str	r3, [r7, #0x1c]
; 	if (b->next == 0U) {
 80162c2: 69fb         	ldr	r3, [r7, #0x1c]
 80162c4: 681b         	ldr	r3, [r3]
 80162c6: 2b00         	cmp	r3, #0x0
 80162c8: d116         	bne	0x80162f8 <free_list_add_bidx+0x4e> @ imm = #0x2c
; 		h->avail_buckets |= BIT(bidx);
 80162ca: 68fb         	ldr	r3, [r7, #0xc]
 80162cc: 68da         	ldr	r2, [r3, #0xc]
 80162ce: 2101         	movs	r1, #0x1
 80162d0: 687b         	ldr	r3, [r7, #0x4]
 80162d2: fa01 f303    	lsl.w	r3, r1, r3
 80162d6: 431a         	orrs	r2, r3
 80162d8: 68fb         	ldr	r3, [r7, #0xc]
 80162da: 60da         	str	r2, [r3, #0xc]
; 		b->next = c;
 80162dc: 69fb         	ldr	r3, [r7, #0x1c]
 80162de: 68ba         	ldr	r2, [r7, #0x8]
 80162e0: 601a         	str	r2, [r3]
; 		set_prev_free_chunk(h, c, c);
 80162e2: 68ba         	ldr	r2, [r7, #0x8]
 80162e4: 68b9         	ldr	r1, [r7, #0x8]
 80162e6: 68f8         	ldr	r0, [r7, #0xc]
 80162e8: f7ff feb5    	bl	0x8016056 <set_prev_free_chunk> @ imm = #-0x296
; 		set_next_free_chunk(h, c, c);
 80162ec: 68ba         	ldr	r2, [r7, #0x8]
 80162ee: 68b9         	ldr	r1, [r7, #0x8]
 80162f0: 68f8         	ldr	r0, [r7, #0xc]
 80162f2: f7ff fec0    	bl	0x8016076 <set_next_free_chunk> @ imm = #-0x280
; }
 80162f6: e01b         	b	0x8016330 <free_list_add_bidx+0x86> @ imm = #0x36
; 		chunkid_t second = b->next;
 80162f8: 69fb         	ldr	r3, [r7, #0x1c]
 80162fa: 681b         	ldr	r3, [r3]
 80162fc: 61bb         	str	r3, [r7, #0x18]
; 		chunkid_t first = prev_free_chunk(h, second);
 80162fe: 69b9         	ldr	r1, [r7, #0x18]
 8016300: 68f8         	ldr	r0, [r7, #0xc]
 8016302: f7ff fe8a    	bl	0x801601a <prev_free_chunk> @ imm = #-0x2ec
 8016306: 6178         	str	r0, [r7, #0x14]
; 		set_prev_free_chunk(h, c, first);
 8016308: 697a         	ldr	r2, [r7, #0x14]
 801630a: 68b9         	ldr	r1, [r7, #0x8]
 801630c: 68f8         	ldr	r0, [r7, #0xc]
 801630e: f7ff fea2    	bl	0x8016056 <set_prev_free_chunk> @ imm = #-0x2bc
; 		set_next_free_chunk(h, c, second);
 8016312: 69ba         	ldr	r2, [r7, #0x18]
 8016314: 68b9         	ldr	r1, [r7, #0x8]
 8016316: 68f8         	ldr	r0, [r7, #0xc]
 8016318: f7ff fead    	bl	0x8016076 <set_next_free_chunk> @ imm = #-0x2a6
; 		set_next_free_chunk(h, first, c);
 801631c: 68ba         	ldr	r2, [r7, #0x8]
 801631e: 6979         	ldr	r1, [r7, #0x14]
 8016320: 68f8         	ldr	r0, [r7, #0xc]
 8016322: f7ff fea8    	bl	0x8016076 <set_next_free_chunk> @ imm = #-0x2b0
; 		set_prev_free_chunk(h, second, c);
 8016326: 68ba         	ldr	r2, [r7, #0x8]
 8016328: 69b9         	ldr	r1, [r7, #0x18]
 801632a: 68f8         	ldr	r0, [r7, #0xc]
 801632c: f7ff fe93    	bl	0x8016056 <set_prev_free_chunk> @ imm = #-0x2da
; }
 8016330: bf00         	nop
 8016332: 3720         	adds	r7, #0x20
 8016334: 46bd         	mov	sp, r7
 8016336: bd80         	pop	{r7, pc}

08016338 <free_list_add>:
; {
 8016338: b580         	push	{r7, lr}
 801633a: b084         	sub	sp, #0x10
 801633c: af00         	add	r7, sp, #0x0
 801633e: 6078         	str	r0, [r7, #0x4]
 8016340: 6039         	str	r1, [r7]
; 	if (!solo_free_header(h, c)) {
 8016342: 6839         	ldr	r1, [r7]
 8016344: 6878         	ldr	r0, [r7, #0x4]
 8016346: f7ff fec6    	bl	0x80160d6 <solo_free_header> @ imm = #-0x274
 801634a: 4603         	mov	r3, r0
 801634c: f083 0301    	eor	r3, r3, #0x1
 8016350: b2db         	uxtb	r3, r3
 8016352: 2b00         	cmp	r3, #0x0
 8016354: d00e         	beq	0x8016374 <free_list_add+0x3c> @ imm = #0x1c
; 		int bidx = bucket_idx(h, chunk_size(h, c));
 8016356: 6839         	ldr	r1, [r7]
 8016358: 6878         	ldr	r0, [r7, #0x4]
 801635a: f7ff fdf8    	bl	0x8015f4e <chunk_size>  @ imm = #-0x410
 801635e: 4603         	mov	r3, r0
 8016360: 4619         	mov	r1, r3
 8016362: 6878         	ldr	r0, [r7, #0x4]
 8016364: f7ff ff22    	bl	0x80161ac <bucket_idx>  @ imm = #-0x1bc
 8016368: 60f8         	str	r0, [r7, #0xc]
; 		free_list_add_bidx(h, c, bidx);
 801636a: 68fa         	ldr	r2, [r7, #0xc]
 801636c: 6839         	ldr	r1, [r7]
 801636e: 6878         	ldr	r0, [r7, #0x4]
 8016370: f7ff ff9b    	bl	0x80162aa <free_list_add_bidx> @ imm = #-0xca
; }
 8016374: bf00         	nop
 8016376: 3710         	adds	r7, #0x10
 8016378: 46bd         	mov	sp, r7
 801637a: bd80         	pop	{r7, pc}

0801637c <split_chunks>:
; {
 801637c: b580         	push	{r7, lr}
 801637e: b088         	sub	sp, #0x20
 8016380: af00         	add	r7, sp, #0x0
 8016382: 60f8         	str	r0, [r7, #0xc]
 8016384: 60b9         	str	r1, [r7, #0x8]
 8016386: 607a         	str	r2, [r7, #0x4]
; 	chunksz_t sz0 = chunk_size(h, lc);
 8016388: 68b9         	ldr	r1, [r7, #0x8]
 801638a: 68f8         	ldr	r0, [r7, #0xc]
 801638c: f7ff fddf    	bl	0x8015f4e <chunk_size>  @ imm = #-0x442
 8016390: 61f8         	str	r0, [r7, #0x1c]
; 	chunksz_t lsz = rc - lc;
 8016392: 687a         	ldr	r2, [r7, #0x4]
 8016394: 68bb         	ldr	r3, [r7, #0x8]
 8016396: 1ad3         	subs	r3, r2, r3
 8016398: 61bb         	str	r3, [r7, #0x18]
; 	chunksz_t rsz = sz0 - lsz;
 801639a: 69fa         	ldr	r2, [r7, #0x1c]
 801639c: 69bb         	ldr	r3, [r7, #0x18]
 801639e: 1ad3         	subs	r3, r2, r3
 80163a0: 617b         	str	r3, [r7, #0x14]
; 	set_chunk_size(h, lc, lsz);
 80163a2: 69ba         	ldr	r2, [r7, #0x18]
 80163a4: 68b9         	ldr	r1, [r7, #0x8]
 80163a6: 68f8         	ldr	r0, [r7, #0xc]
 80163a8: f7ff fe26    	bl	0x8015ff8 <set_chunk_size> @ imm = #-0x3b4
; 	set_chunk_size(h, rc, rsz);
 80163ac: 697a         	ldr	r2, [r7, #0x14]
 80163ae: 6879         	ldr	r1, [r7, #0x4]
 80163b0: 68f8         	ldr	r0, [r7, #0xc]
 80163b2: f7ff fe21    	bl	0x8015ff8 <set_chunk_size> @ imm = #-0x3be
; 	set_left_chunk_size(h, rc, lsz);
 80163b6: 69ba         	ldr	r2, [r7, #0x18]
 80163b8: 6879         	ldr	r1, [r7, #0x4]
 80163ba: 68f8         	ldr	r0, [r7, #0xc]
 80163bc: f7ff fe7b    	bl	0x80160b6 <set_left_chunk_size> @ imm = #-0x30a
; 	set_left_chunk_size(h, right_chunk(h, rc), rsz);
 80163c0: 6879         	ldr	r1, [r7, #0x4]
 80163c2: 68f8         	ldr	r0, [r7, #0xc]
 80163c4: f7ff fe67    	bl	0x8016096 <right_chunk> @ imm = #-0x332
 80163c8: 4603         	mov	r3, r0
 80163ca: 697a         	ldr	r2, [r7, #0x14]
 80163cc: 4619         	mov	r1, r3
 80163ce: 68f8         	ldr	r0, [r7, #0xc]
 80163d0: f7ff fe71    	bl	0x80160b6 <set_left_chunk_size> @ imm = #-0x31e
; }
 80163d4: bf00         	nop
 80163d6: 3720         	adds	r7, #0x20
 80163d8: 46bd         	mov	sp, r7
 80163da: bd80         	pop	{r7, pc}

080163dc <mem_to_chunkid>:
; {
 80163dc: b580         	push	{r7, lr}
 80163de: b084         	sub	sp, #0x10
 80163e0: af00         	add	r7, sp, #0x0
 80163e2: 6078         	str	r0, [r7, #0x4]
 80163e4: 6039         	str	r1, [r7]
; 	uint8_t *mem = p, *base = (uint8_t *)chunk_buf(h);
 80163e6: 683b         	ldr	r3, [r7]
 80163e8: 60fb         	str	r3, [r7, #0xc]
 80163ea: 6878         	ldr	r0, [r7, #0x4]
 80163ec: f7ff fd56    	bl	0x8015e9c <chunk_buf>   @ imm = #-0x554
 80163f0: 60b8         	str	r0, [r7, #0x8]
; 	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
 80163f2: 6878         	ldr	r0, [r7, #0x4]
 80163f4: f7ff fe8b    	bl	0x801610e <chunk_header_bytes> @ imm = #-0x2ea
 80163f8: 4603         	mov	r3, r0
 80163fa: 425b         	rsbs	r3, r3, #0
 80163fc: 68fa         	ldr	r2, [r7, #0xc]
 80163fe: 441a         	add	r2, r3
 8016400: 68bb         	ldr	r3, [r7, #0x8]
 8016402: 1ad3         	subs	r3, r2, r3
 8016404: 08db         	lsrs	r3, r3, #0x3
; }
 8016406: 4618         	mov	r0, r3
 8016408: 3710         	adds	r7, #0x10
 801640a: 46bd         	mov	sp, r7
 801640c: bd80         	pop	{r7, pc}

0801640e <alloc_chunk>:
; {
 801640e: b580         	push	{r7, lr}
 8016410: b08a         	sub	sp, #0x28
 8016412: af00         	add	r7, sp, #0x0
 8016414: 6078         	str	r0, [r7, #0x4]
 8016416: 6039         	str	r1, [r7]
; 	int bi = bucket_idx(h, sz);
 8016418: 6839         	ldr	r1, [r7]
 801641a: 6878         	ldr	r0, [r7, #0x4]
 801641c: f7ff fec6    	bl	0x80161ac <bucket_idx>  @ imm = #-0x274
 8016420: 6238         	str	r0, [r7, #0x20]
; 	struct z_heap_bucket *b = &h->buckets[bi];
 8016422: 6a3b         	ldr	r3, [r7, #0x20]
 8016424: 3304         	adds	r3, #0x4
 8016426: 009b         	lsls	r3, r3, #0x2
 8016428: 687a         	ldr	r2, [r7, #0x4]
 801642a: 4413         	add	r3, r2
 801642c: 61fb         	str	r3, [r7, #0x1c]
; 	if (b->next != 0U) {
 801642e: 69fb         	ldr	r3, [r7, #0x1c]
 8016430: 681b         	ldr	r3, [r3]
 8016432: 2b00         	cmp	r3, #0x0
 8016434: d028         	beq	0x8016488 <alloc_chunk+0x7a> @ imm = #0x50
; 		chunkid_t first = b->next;
 8016436: 69fb         	ldr	r3, [r7, #0x1c]
 8016438: 681b         	ldr	r3, [r3]
 801643a: 61bb         	str	r3, [r7, #0x18]
; 		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
 801643c: 2303         	movs	r3, #0x3
 801643e: 627b         	str	r3, [r7, #0x24]
; 			chunkid_t c = b->next;
 8016440: 69fb         	ldr	r3, [r7, #0x1c]
 8016442: 681b         	ldr	r3, [r3]
 8016444: 617b         	str	r3, [r7, #0x14]
; 			if (chunk_size(h, c) >= sz) {
 8016446: 6979         	ldr	r1, [r7, #0x14]
 8016448: 6878         	ldr	r0, [r7, #0x4]
 801644a: f7ff fd80    	bl	0x8015f4e <chunk_size>  @ imm = #-0x500
 801644e: 4602         	mov	r2, r0
 8016450: 683b         	ldr	r3, [r7]
 8016452: 4293         	cmp	r3, r2
 8016454: d806         	bhi	0x8016464 <alloc_chunk+0x56> @ imm = #0xc
; 				free_list_remove_bidx(h, c, bi);
 8016456: 6a3a         	ldr	r2, [r7, #0x20]
 8016458: 6979         	ldr	r1, [r7, #0x14]
 801645a: 6878         	ldr	r0, [r7, #0x4]
 801645c: f7ff fee8    	bl	0x8016230 <free_list_remove_bidx> @ imm = #-0x230
; 				return c;
 8016460: 697b         	ldr	r3, [r7, #0x14]
 8016462: e032         	b	0x80164ca <alloc_chunk+0xbc> @ imm = #0x64
; 			b->next = next_free_chunk(h, c);
 8016464: 6979         	ldr	r1, [r7, #0x14]
 8016466: 6878         	ldr	r0, [r7, #0x4]
 8016468: f7ff fde6    	bl	0x8016038 <next_free_chunk> @ imm = #-0x434
 801646c: 4602         	mov	r2, r0
 801646e: 69fb         	ldr	r3, [r7, #0x1c]
 8016470: 601a         	str	r2, [r3]
; 		} while (--i && b->next != first);
 8016472: 6a7b         	ldr	r3, [r7, #0x24]
 8016474: 3b01         	subs	r3, #0x1
 8016476: 627b         	str	r3, [r7, #0x24]
 8016478: 6a7b         	ldr	r3, [r7, #0x24]
 801647a: 2b00         	cmp	r3, #0x0
 801647c: d004         	beq	0x8016488 <alloc_chunk+0x7a> @ imm = #0x8
 801647e: 69fb         	ldr	r3, [r7, #0x1c]
 8016480: 681b         	ldr	r3, [r3]
 8016482: 69ba         	ldr	r2, [r7, #0x18]
 8016484: 429a         	cmp	r2, r3
 8016486: d1db         	bne	0x8016440 <alloc_chunk+0x32> @ imm = #-0x4a
; 	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
 8016488: 687b         	ldr	r3, [r7, #0x4]
 801648a: 68da         	ldr	r2, [r3, #0xc]
 801648c: 6a3b         	ldr	r3, [r7, #0x20]
 801648e: 3301         	adds	r3, #0x1
 8016490: 2101         	movs	r1, #0x1
 8016492: fa01 f303    	lsl.w	r3, r1, r3
 8016496: 425b         	rsbs	r3, r3, #0
 8016498: 4013         	ands	r3, r2
 801649a: 613b         	str	r3, [r7, #0x10]
; 	if (bmask != 0U) {
 801649c: 693b         	ldr	r3, [r7, #0x10]
 801649e: 2b00         	cmp	r3, #0x0
 80164a0: d012         	beq	0x80164c8 <alloc_chunk+0xba> @ imm = #0x24
; 		int minbucket = __builtin_ctz(bmask);
 80164a2: 693b         	ldr	r3, [r7, #0x10]
 80164a4: fa93 f3a3    	rbit	r3, r3
 80164a8: fab3 f383    	clz	r3, r3
 80164ac: 60fb         	str	r3, [r7, #0xc]
; 		chunkid_t c = h->buckets[minbucket].next;
 80164ae: 687b         	ldr	r3, [r7, #0x4]
 80164b0: 68fa         	ldr	r2, [r7, #0xc]
 80164b2: 3204         	adds	r2, #0x4
 80164b4: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 80164b8: 60bb         	str	r3, [r7, #0x8]
; 		free_list_remove_bidx(h, c, minbucket);
 80164ba: 68fa         	ldr	r2, [r7, #0xc]
 80164bc: 68b9         	ldr	r1, [r7, #0x8]
 80164be: 6878         	ldr	r0, [r7, #0x4]
 80164c0: f7ff feb6    	bl	0x8016230 <free_list_remove_bidx> @ imm = #-0x294
; 		return c;
 80164c4: 68bb         	ldr	r3, [r7, #0x8]
 80164c6: e000         	b	0x80164ca <alloc_chunk+0xbc> @ imm = #0x0
; 	return 0;
 80164c8: 2300         	movs	r3, #0x0
; }
 80164ca: 4618         	mov	r0, r3
 80164cc: 3728         	adds	r7, #0x28
 80164ce: 46bd         	mov	sp, r7
 80164d0: bd80         	pop	{r7, pc}

080164d2 <sys_heap_alloc>:
; {
 80164d2: b580         	push	{r7, lr}
 80164d4: b086         	sub	sp, #0x18
 80164d6: af00         	add	r7, sp, #0x0
 80164d8: 6078         	str	r0, [r7, #0x4]
 80164da: 6039         	str	r1, [r7]
; 	struct z_heap *h = heap->heap;
 80164dc: 687b         	ldr	r3, [r7, #0x4]
 80164de: 681b         	ldr	r3, [r3]
 80164e0: 617b         	str	r3, [r7, #0x14]
; 	if ((bytes == 0U) || size_too_big(h, bytes)) {
 80164e2: 683b         	ldr	r3, [r7]
 80164e4: 2b00         	cmp	r3, #0x0
 80164e6: d006         	beq	0x80164f6 <sys_heap_alloc+0x24> @ imm = #0xc
 80164e8: 6839         	ldr	r1, [r7]
 80164ea: 6978         	ldr	r0, [r7, #0x14]
 80164ec: f7ff fe74    	bl	0x80161d8 <size_too_big> @ imm = #-0x318
 80164f0: 4603         	mov	r3, r0
 80164f2: 2b00         	cmp	r3, #0x0
 80164f4: d001         	beq	0x80164fa <sys_heap_alloc+0x28> @ imm = #0x2
; 		return NULL;
 80164f6: 2300         	movs	r3, #0x0
 80164f8: e030         	b	0x801655c <sys_heap_alloc+0x8a> @ imm = #0x60
; 	chunksz_t chunk_sz = bytes_to_chunksz(h, bytes);
 80164fa: 6839         	ldr	r1, [r7]
 80164fc: 6978         	ldr	r0, [r7, #0x14]
 80164fe: f7ff fe35    	bl	0x801616c <bytes_to_chunksz> @ imm = #-0x396
 8016502: 6138         	str	r0, [r7, #0x10]
; 	chunkid_t c = alloc_chunk(h, chunk_sz);
 8016504: 6939         	ldr	r1, [r7, #0x10]
 8016506: 6978         	ldr	r0, [r7, #0x14]
 8016508: f7ff ff81    	bl	0x801640e <alloc_chunk> @ imm = #-0xfe
 801650c: 60f8         	str	r0, [r7, #0xc]
; 	if (c == 0U) {
 801650e: 68fb         	ldr	r3, [r7, #0xc]
 8016510: 2b00         	cmp	r3, #0x0
 8016512: d101         	bne	0x8016518 <sys_heap_alloc+0x46> @ imm = #0x2
; 		return NULL;
 8016514: 2300         	movs	r3, #0x0
 8016516: e021         	b	0x801655c <sys_heap_alloc+0x8a> @ imm = #0x42
; 	if (chunk_size(h, c) > chunk_sz) {
 8016518: 68f9         	ldr	r1, [r7, #0xc]
 801651a: 6978         	ldr	r0, [r7, #0x14]
 801651c: f7ff fd17    	bl	0x8015f4e <chunk_size>  @ imm = #-0x5d2
 8016520: 4602         	mov	r2, r0
 8016522: 693b         	ldr	r3, [r7, #0x10]
 8016524: 4293         	cmp	r3, r2
 8016526: d20e         	bhs	0x8016546 <sys_heap_alloc+0x74> @ imm = #0x1c
; 		split_chunks(h, c, c + chunk_sz);
 8016528: 68fa         	ldr	r2, [r7, #0xc]
 801652a: 693b         	ldr	r3, [r7, #0x10]
 801652c: 4413         	add	r3, r2
 801652e: 461a         	mov	r2, r3
 8016530: 68f9         	ldr	r1, [r7, #0xc]
 8016532: 6978         	ldr	r0, [r7, #0x14]
 8016534: f7ff ff22    	bl	0x801637c <split_chunks> @ imm = #-0x1bc
; 		free_list_add(h, c + chunk_sz);
 8016538: 68fa         	ldr	r2, [r7, #0xc]
 801653a: 693b         	ldr	r3, [r7, #0x10]
 801653c: 4413         	add	r3, r2
 801653e: 4619         	mov	r1, r3
 8016540: 6978         	ldr	r0, [r7, #0x14]
 8016542: f7ff fef9    	bl	0x8016338 <free_list_add> @ imm = #-0x20e
; 	set_chunk_used(h, c, true);
 8016546: 2201         	movs	r2, #0x1
 8016548: 68f9         	ldr	r1, [r7, #0xc]
 801654a: 6978         	ldr	r0, [r7, #0x14]
 801654c: f7ff fd0f    	bl	0x8015f6e <set_chunk_used> @ imm = #-0x5e2
; 	mem = chunk_mem(h, c);
 8016550: 68f9         	ldr	r1, [r7, #0xc]
 8016552: 6978         	ldr	r0, [r7, #0x14]
 8016554: f7ff fe54    	bl	0x8016200 <chunk_mem>   @ imm = #-0x358
 8016558: 60b8         	str	r0, [r7, #0x8]
; 	return mem;
 801655a: 68bb         	ldr	r3, [r7, #0x8]
; }
 801655c: 4618         	mov	r0, r3
 801655e: 3718         	adds	r7, #0x18
 8016560: 46bd         	mov	sp, r7
 8016562: bd80         	pop	{r7, pc}

08016564 <sys_heap_aligned_alloc>:
; {
 8016564: b580         	push	{r7, lr}
 8016566: b08e         	sub	sp, #0x38
 8016568: af00         	add	r7, sp, #0x0
 801656a: 60f8         	str	r0, [r7, #0xc]
 801656c: 60b9         	str	r1, [r7, #0x8]
 801656e: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap *h = heap->heap;
 8016570: 68fb         	ldr	r3, [r7, #0xc]
 8016572: 681b         	ldr	r3, [r3]
 8016574: 62fb         	str	r3, [r7, #0x2c]
; 	rew = align & -align;
 8016576: 68bb         	ldr	r3, [r7, #0x8]
 8016578: 425b         	rsbs	r3, r3, #0
 801657a: 68ba         	ldr	r2, [r7, #0x8]
 801657c: 4013         	ands	r3, r2
 801657e: 633b         	str	r3, [r7, #0x30]
; 	if (align != rew) {
 8016580: 68ba         	ldr	r2, [r7, #0x8]
 8016582: 6b3b         	ldr	r3, [r7, #0x30]
 8016584: 429a         	cmp	r2, r3
 8016586: d012         	beq	0x80165ae <sys_heap_aligned_alloc+0x4a> @ imm = #0x24
; 		align -= rew;
 8016588: 68ba         	ldr	r2, [r7, #0x8]
 801658a: 6b3b         	ldr	r3, [r7, #0x30]
 801658c: 1ad3         	subs	r3, r2, r3
 801658e: 60bb         	str	r3, [r7, #0x8]
; 		gap = MIN(rew, chunk_header_bytes(h));
 8016590: 6af8         	ldr	r0, [r7, #0x2c]
 8016592: f7ff fdbc    	bl	0x801610e <chunk_header_bytes> @ imm = #-0x488
 8016596: 4602         	mov	r2, r0
 8016598: 6b3b         	ldr	r3, [r7, #0x30]
 801659a: 4293         	cmp	r3, r2
 801659c: d304         	blo	0x80165a8 <sys_heap_aligned_alloc+0x44> @ imm = #0x8
 801659e: 6af8         	ldr	r0, [r7, #0x2c]
 80165a0: f7ff fdb5    	bl	0x801610e <chunk_header_bytes> @ imm = #-0x496
 80165a4: 4603         	mov	r3, r0
 80165a6: e000         	b	0x80165aa <sys_heap_aligned_alloc+0x46> @ imm = #0x0
 80165a8: 6b3b         	ldr	r3, [r7, #0x30]
 80165aa: 637b         	str	r3, [r7, #0x34]
 80165ac: e012         	b	0x80165d4 <sys_heap_aligned_alloc+0x70> @ imm = #0x24
; 		if (align <= chunk_header_bytes(h)) {
 80165ae: 6af8         	ldr	r0, [r7, #0x2c]
 80165b0: f7ff fdad    	bl	0x801610e <chunk_header_bytes> @ imm = #-0x4a6
 80165b4: 4602         	mov	r2, r0
 80165b6: 68bb         	ldr	r3, [r7, #0x8]
 80165b8: 4293         	cmp	r3, r2
 80165ba: d805         	bhi	0x80165c8 <sys_heap_aligned_alloc+0x64> @ imm = #0xa
; 			return sys_heap_alloc(heap, bytes);
 80165bc: 6879         	ldr	r1, [r7, #0x4]
 80165be: 68f8         	ldr	r0, [r7, #0xc]
 80165c0: f7ff ff87    	bl	0x80164d2 <sys_heap_alloc> @ imm = #-0xf2
 80165c4: 4603         	mov	r3, r0
 80165c6: e072         	b	0x80166ae <sys_heap_aligned_alloc+0x14a> @ imm = #0xe4
; 		rew = 0;
 80165c8: 2300         	movs	r3, #0x0
 80165ca: 633b         	str	r3, [r7, #0x30]
; 		gap = chunk_header_bytes(h);
 80165cc: 6af8         	ldr	r0, [r7, #0x2c]
 80165ce: f7ff fd9e    	bl	0x801610e <chunk_header_bytes> @ imm = #-0x4c4
 80165d2: 6378         	str	r0, [r7, #0x34]
; 	if ((bytes == 0) || size_too_big(h, bytes)) {
 80165d4: 687b         	ldr	r3, [r7, #0x4]
 80165d6: 2b00         	cmp	r3, #0x0
 80165d8: d006         	beq	0x80165e8 <sys_heap_aligned_alloc+0x84> @ imm = #0xc
 80165da: 6879         	ldr	r1, [r7, #0x4]
 80165dc: 6af8         	ldr	r0, [r7, #0x2c]
 80165de: f7ff fdfb    	bl	0x80161d8 <size_too_big> @ imm = #-0x40a
 80165e2: 4603         	mov	r3, r0
 80165e4: 2b00         	cmp	r3, #0x0
 80165e6: d001         	beq	0x80165ec <sys_heap_aligned_alloc+0x88> @ imm = #0x2
; 		return NULL;
 80165e8: 2300         	movs	r3, #0x0
 80165ea: e060         	b	0x80166ae <sys_heap_aligned_alloc+0x14a> @ imm = #0xc0
; 	chunksz_t padded_sz = bytes_to_chunksz(h, bytes + align - gap);
 80165ec: 687a         	ldr	r2, [r7, #0x4]
 80165ee: 68bb         	ldr	r3, [r7, #0x8]
 80165f0: 441a         	add	r2, r3
 80165f2: 6b7b         	ldr	r3, [r7, #0x34]
 80165f4: 1ad3         	subs	r3, r2, r3
 80165f6: 4619         	mov	r1, r3
 80165f8: 6af8         	ldr	r0, [r7, #0x2c]
 80165fa: f7ff fdb7    	bl	0x801616c <bytes_to_chunksz> @ imm = #-0x492
 80165fe: 62b8         	str	r0, [r7, #0x28]
; 	chunkid_t c0 = alloc_chunk(h, padded_sz);
 8016600: 6ab9         	ldr	r1, [r7, #0x28]
 8016602: 6af8         	ldr	r0, [r7, #0x2c]
 8016604: f7ff ff03    	bl	0x801640e <alloc_chunk> @ imm = #-0x1fa
 8016608: 6278         	str	r0, [r7, #0x24]
; 	if (c0 == 0) {
 801660a: 6a7b         	ldr	r3, [r7, #0x24]
 801660c: 2b00         	cmp	r3, #0x0
 801660e: d101         	bne	0x8016614 <sys_heap_aligned_alloc+0xb0> @ imm = #0x2
; 		return NULL;
 8016610: 2300         	movs	r3, #0x0
 8016612: e04c         	b	0x80166ae <sys_heap_aligned_alloc+0x14a> @ imm = #0x98
; 	uint8_t *mem = chunk_mem(h, c0);
 8016614: 6a79         	ldr	r1, [r7, #0x24]
 8016616: 6af8         	ldr	r0, [r7, #0x2c]
 8016618: f7ff fdf2    	bl	0x8016200 <chunk_mem>   @ imm = #-0x41c
 801661c: 6238         	str	r0, [r7, #0x20]
; 	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
 801661e: 6a3a         	ldr	r2, [r7, #0x20]
 8016620: 6b3b         	ldr	r3, [r7, #0x30]
 8016622: 4413         	add	r3, r2
 8016624: 461a         	mov	r2, r3
 8016626: 68bb         	ldr	r3, [r7, #0x8]
 8016628: 4413         	add	r3, r2
 801662a: 1e5a         	subs	r2, r3, #0x1
 801662c: 68bb         	ldr	r3, [r7, #0x8]
 801662e: fbb2 f3f3    	udiv	r3, r2, r3
 8016632: 68ba         	ldr	r2, [r7, #0x8]
 8016634: fb03 f202    	mul	r2, r3, r2
 8016638: 6b3b         	ldr	r3, [r7, #0x30]
 801663a: 1ad3         	subs	r3, r2, r3
 801663c: 623b         	str	r3, [r7, #0x20]
; 	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
 801663e: 6a3a         	ldr	r2, [r7, #0x20]
 8016640: 687b         	ldr	r3, [r7, #0x4]
 8016642: 4413         	add	r3, r2
 8016644: 3307         	adds	r3, #0x7
 8016646: f023 0307    	bic	r3, r3, #0x7
 801664a: 61fb         	str	r3, [r7, #0x1c]
; 	chunkid_t c = mem_to_chunkid(h, mem);
 801664c: 6a39         	ldr	r1, [r7, #0x20]
 801664e: 6af8         	ldr	r0, [r7, #0x2c]
 8016650: f7ff fec4    	bl	0x80163dc <mem_to_chunkid> @ imm = #-0x278
 8016654: 61b8         	str	r0, [r7, #0x18]
; 	chunkid_t c_end = end - chunk_buf(h);
 8016656: 6af8         	ldr	r0, [r7, #0x2c]
 8016658: f7ff fc20    	bl	0x8015e9c <chunk_buf>   @ imm = #-0x7c0
 801665c: 4602         	mov	r2, r0
 801665e: 69fb         	ldr	r3, [r7, #0x1c]
 8016660: 1a9b         	subs	r3, r3, r2
 8016662: 10db         	asrs	r3, r3, #0x3
 8016664: 617b         	str	r3, [r7, #0x14]
; 	if (c > c0) {
 8016666: 69ba         	ldr	r2, [r7, #0x18]
 8016668: 6a7b         	ldr	r3, [r7, #0x24]
 801666a: 429a         	cmp	r2, r3
 801666c: d908         	bls	0x8016680 <sys_heap_aligned_alloc+0x11c> @ imm = #0x10
; 		split_chunks(h, c0, c);
 801666e: 69ba         	ldr	r2, [r7, #0x18]
 8016670: 6a79         	ldr	r1, [r7, #0x24]
 8016672: 6af8         	ldr	r0, [r7, #0x2c]
 8016674: f7ff fe82    	bl	0x801637c <split_chunks> @ imm = #-0x2fc
; 		free_list_add(h, c0);
 8016678: 6a79         	ldr	r1, [r7, #0x24]
 801667a: 6af8         	ldr	r0, [r7, #0x2c]
 801667c: f7ff fe5c    	bl	0x8016338 <free_list_add> @ imm = #-0x348
; 	if (right_chunk(h, c) > c_end) {
 8016680: 69b9         	ldr	r1, [r7, #0x18]
 8016682: 6af8         	ldr	r0, [r7, #0x2c]
 8016684: f7ff fd07    	bl	0x8016096 <right_chunk> @ imm = #-0x5f2
 8016688: 4602         	mov	r2, r0
 801668a: 697b         	ldr	r3, [r7, #0x14]
 801668c: 4293         	cmp	r3, r2
 801668e: d208         	bhs	0x80166a2 <sys_heap_aligned_alloc+0x13e> @ imm = #0x10
; 		split_chunks(h, c, c_end);
 8016690: 697a         	ldr	r2, [r7, #0x14]
 8016692: 69b9         	ldr	r1, [r7, #0x18]
 8016694: 6af8         	ldr	r0, [r7, #0x2c]
 8016696: f7ff fe71    	bl	0x801637c <split_chunks> @ imm = #-0x31e
; 		free_list_add(h, c_end);
 801669a: 6979         	ldr	r1, [r7, #0x14]
 801669c: 6af8         	ldr	r0, [r7, #0x2c]
 801669e: f7ff fe4b    	bl	0x8016338 <free_list_add> @ imm = #-0x36a
; 	set_chunk_used(h, c, true);
 80166a2: 2201         	movs	r2, #0x1
 80166a4: 69b9         	ldr	r1, [r7, #0x18]
 80166a6: 6af8         	ldr	r0, [r7, #0x2c]
 80166a8: f7ff fc61    	bl	0x8015f6e <set_chunk_used> @ imm = #-0x73e
; 	return mem;
 80166ac: 6a3b         	ldr	r3, [r7, #0x20]
; }
 80166ae: 4618         	mov	r0, r3
 80166b0: 3738         	adds	r7, #0x38
 80166b2: 46bd         	mov	sp, r7
 80166b4: bd80         	pop	{r7, pc}

080166b6 <sys_heap_init>:
; {
 80166b6: b580         	push	{r7, lr}
 80166b8: b08c         	sub	sp, #0x30
 80166ba: af00         	add	r7, sp, #0x0
 80166bc: 60f8         	str	r0, [r7, #0xc]
 80166be: 60b9         	str	r1, [r7, #0x8]
 80166c0: 607a         	str	r2, [r7, #0x4]
; 	bytes -= heap_footer_bytes(bytes);
 80166c2: 6878         	ldr	r0, [r7, #0x4]
 80166c4: f7ff fd34    	bl	0x8016130 <heap_footer_bytes> @ imm = #-0x598
 80166c8: 4602         	mov	r2, r0
 80166ca: 687b         	ldr	r3, [r7, #0x4]
 80166cc: 1a9b         	subs	r3, r3, r2
 80166ce: 607b         	str	r3, [r7, #0x4]
; 	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 80166d0: 68bb         	ldr	r3, [r7, #0x8]
 80166d2: 3307         	adds	r3, #0x7
 80166d4: f023 0307    	bic	r3, r3, #0x7
 80166d8: 62bb         	str	r3, [r7, #0x28]
; 	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 80166da: 68ba         	ldr	r2, [r7, #0x8]
 80166dc: 687b         	ldr	r3, [r7, #0x4]
 80166de: 4413         	add	r3, r2
 80166e0: f023 0307    	bic	r3, r3, #0x7
 80166e4: 627b         	str	r3, [r7, #0x24]
; 	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
 80166e6: 6a7a         	ldr	r2, [r7, #0x24]
 80166e8: 6abb         	ldr	r3, [r7, #0x28]
 80166ea: 1ad3         	subs	r3, r2, r3
 80166ec: 08db         	lsrs	r3, r3, #0x3
 80166ee: 623b         	str	r3, [r7, #0x20]
; 	struct z_heap *h = (struct z_heap *)addr;
 80166f0: 6abb         	ldr	r3, [r7, #0x28]
 80166f2: 61fb         	str	r3, [r7, #0x1c]
; 	heap->heap = h;
 80166f4: 68fb         	ldr	r3, [r7, #0xc]
 80166f6: 69fa         	ldr	r2, [r7, #0x1c]
 80166f8: 601a         	str	r2, [r3]
; 	h->end_chunk = heap_sz;
 80166fa: 69fb         	ldr	r3, [r7, #0x1c]
 80166fc: 6a3a         	ldr	r2, [r7, #0x20]
 80166fe: 609a         	str	r2, [r3, #0x8]
; 	h->avail_buckets = 0;
 8016700: 69fb         	ldr	r3, [r7, #0x1c]
 8016702: 2200         	movs	r2, #0x0
 8016704: 60da         	str	r2, [r3, #0xc]
; 	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 8016706: 6a39         	ldr	r1, [r7, #0x20]
 8016708: 69f8         	ldr	r0, [r7, #0x1c]
 801670a: f7ff fd4f    	bl	0x80161ac <bucket_idx>  @ imm = #-0x562
 801670e: 4603         	mov	r3, r0
 8016710: 3301         	adds	r3, #0x1
 8016712: 61bb         	str	r3, [r7, #0x18]
; 	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 8016714: 69bb         	ldr	r3, [r7, #0x18]
 8016716: 3304         	adds	r3, #0x4
 8016718: 009b         	lsls	r3, r3, #0x2
 801671a: 4618         	mov	r0, r3
 801671c: f7ff fd19    	bl	0x8016152 <chunksz>     @ imm = #-0x5ce
 8016720: 6178         	str	r0, [r7, #0x14]
; 	for (int i = 0; i < nb_buckets; i++) {
 8016722: 2300         	movs	r3, #0x0
 8016724: 62fb         	str	r3, [r7, #0x2c]
 8016726: e008         	b	0x801673a <sys_heap_init+0x84> @ imm = #0x10
; 		h->buckets[i].next = 0;
 8016728: 69fb         	ldr	r3, [r7, #0x1c]
 801672a: 6afa         	ldr	r2, [r7, #0x2c]
 801672c: 3204         	adds	r2, #0x4
 801672e: 2100         	movs	r1, #0x0
 8016730: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 	for (int i = 0; i < nb_buckets; i++) {
 8016734: 6afb         	ldr	r3, [r7, #0x2c]
 8016736: 3301         	adds	r3, #0x1
 8016738: 62fb         	str	r3, [r7, #0x2c]
 801673a: 6afa         	ldr	r2, [r7, #0x2c]
 801673c: 69bb         	ldr	r3, [r7, #0x18]
 801673e: 429a         	cmp	r2, r3
 8016740: dbf2         	blt	0x8016728 <sys_heap_init+0x72> @ imm = #-0x1c
; 	set_chunk_size(h, 0, chunk0_size);
 8016742: 697a         	ldr	r2, [r7, #0x14]
 8016744: 2100         	movs	r1, #0x0
 8016746: 69f8         	ldr	r0, [r7, #0x1c]
 8016748: f7ff fc56    	bl	0x8015ff8 <set_chunk_size> @ imm = #-0x754
; 	set_left_chunk_size(h, 0, 0);
 801674c: 2200         	movs	r2, #0x0
 801674e: 2100         	movs	r1, #0x0
 8016750: 69f8         	ldr	r0, [r7, #0x1c]
 8016752: f7ff fcb0    	bl	0x80160b6 <set_left_chunk_size> @ imm = #-0x6a0
; 	set_chunk_used(h, 0, true);
 8016756: 2201         	movs	r2, #0x1
 8016758: 2100         	movs	r1, #0x0
 801675a: 69f8         	ldr	r0, [r7, #0x1c]
 801675c: f7ff fc07    	bl	0x8015f6e <set_chunk_used> @ imm = #-0x7f2
; 	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
 8016760: 6a3a         	ldr	r2, [r7, #0x20]
 8016762: 697b         	ldr	r3, [r7, #0x14]
 8016764: 1ad3         	subs	r3, r2, r3
 8016766: 461a         	mov	r2, r3
 8016768: 6979         	ldr	r1, [r7, #0x14]
 801676a: 69f8         	ldr	r0, [r7, #0x1c]
 801676c: f7ff fc44    	bl	0x8015ff8 <set_chunk_size> @ imm = #-0x778
; 	set_left_chunk_size(h, chunk0_size, chunk0_size);
 8016770: 697a         	ldr	r2, [r7, #0x14]
 8016772: 6979         	ldr	r1, [r7, #0x14]
 8016774: 69f8         	ldr	r0, [r7, #0x1c]
 8016776: f7ff fc9e    	bl	0x80160b6 <set_left_chunk_size> @ imm = #-0x6c4
; 	set_chunk_size(h, heap_sz, 0);
 801677a: 2200         	movs	r2, #0x0
 801677c: 6a39         	ldr	r1, [r7, #0x20]
 801677e: 69f8         	ldr	r0, [r7, #0x1c]
 8016780: f7ff fc3a    	bl	0x8015ff8 <set_chunk_size> @ imm = #-0x78c
; 	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
 8016784: 6a3a         	ldr	r2, [r7, #0x20]
 8016786: 697b         	ldr	r3, [r7, #0x14]
 8016788: 1ad3         	subs	r3, r2, r3
 801678a: 461a         	mov	r2, r3
 801678c: 6a39         	ldr	r1, [r7, #0x20]
 801678e: 69f8         	ldr	r0, [r7, #0x1c]
 8016790: f7ff fc91    	bl	0x80160b6 <set_left_chunk_size> @ imm = #-0x6de
; 	set_chunk_used(h, heap_sz, true);
 8016794: 2201         	movs	r2, #0x1
 8016796: 6a39         	ldr	r1, [r7, #0x20]
 8016798: 69f8         	ldr	r0, [r7, #0x1c]
 801679a: f7ff fbe8    	bl	0x8015f6e <set_chunk_used> @ imm = #-0x830
; 	free_list_add(h, chunk0_size);
 801679e: 6979         	ldr	r1, [r7, #0x14]
 80167a0: 69f8         	ldr	r0, [r7, #0x1c]
 80167a2: f7ff fdc9    	bl	0x8016338 <free_list_add> @ imm = #-0x46e
; }
 80167a6: bf00         	nop
 80167a8: 3730         	adds	r7, #0x30
 80167aa: 46bd         	mov	sp, r7
 80167ac: bd80         	pop	{r7, pc}

080167ae <ptr_in_rodata>:
; {
 80167ae: b580         	push	{r7, lr}
 80167b0: b082         	sub	sp, #0x8
 80167b2: af00         	add	r7, sp, #0x0
 80167b4: 6078         	str	r0, [r7, #0x4]
; 	return linker_is_in_rodata(addr);
 80167b6: 6878         	ldr	r0, [r7, #0x4]
 80167b8: f7ee f826    	bl	0x8004808 <linker_is_in_rodata> @ imm = #-0x11fb4
 80167bc: 4603         	mov	r3, r0
; }
 80167be: 4618         	mov	r0, r3
 80167c0: 3708         	adds	r7, #0x8
 80167c2: 46bd         	mov	sp, r7
 80167c4: bd80         	pop	{r7, pc}

080167c6 <cbprintf_via_va_list>:
; {
 80167c6: b590         	push	{r4, r7, lr}
 80167c8: b087         	sub	sp, #0x1c
 80167ca: af00         	add	r7, sp, #0x0
 80167cc: 60f8         	str	r0, [r7, #0xc]
 80167ce: 60b9         	str	r1, [r7, #0x8]
 80167d0: 607a         	str	r2, [r7, #0x4]
 80167d2: 603b         	str	r3, [r7]
; 	u.ptr = buf;
 80167d4: 6abb         	ldr	r3, [r7, #0x28]
 80167d6: 617b         	str	r3, [r7, #0x14]
; 	return formatter(out, ctx, fmt, u.ap);
 80167d8: 68bc         	ldr	r4, [r7, #0x8]
 80167da: 697b         	ldr	r3, [r7, #0x14]
 80167dc: 683a         	ldr	r2, [r7]
 80167de: 6879         	ldr	r1, [r7, #0x4]
 80167e0: 68f8         	ldr	r0, [r7, #0xc]
 80167e2: 47a0         	blx	r4
 80167e4: 4603         	mov	r3, r0
; }
 80167e6: 4618         	mov	r0, r3
 80167e8: 371c         	adds	r7, #0x1c
 80167ea: 46bd         	mov	sp, r7
 80167ec: bd90         	pop	{r4, r7, pc}

080167ee <cbpprintf_external>:
; {
 80167ee: b580         	push	{r7, lr}
 80167f0: b090         	sub	sp, #0x40
 80167f2: af02         	add	r7, sp, #0x8
 80167f4: 60f8         	str	r0, [r7, #0xc]
 80167f6: 60b9         	str	r1, [r7, #0x8]
 80167f8: 607a         	str	r2, [r7, #0x4]
 80167fa: 603b         	str	r3, [r7]
; 	uint8_t *buf = packaged;
 80167fc: 683b         	ldr	r3, [r7]
 80167fe: 62fb         	str	r3, [r7, #0x2c]
; 	struct cbprintf_package_hdr_ext *hdr = packaged;
 8016800: 683b         	ldr	r3, [r7]
 8016802: 62bb         	str	r3, [r7, #0x28]
; 	if (buf == NULL) {
 8016804: 6afb         	ldr	r3, [r7, #0x2c]
 8016806: 2b00         	cmp	r3, #0x0
 8016808: d102         	bne	0x8016810 <cbpprintf_external+0x22> @ imm = #0x4
; 		return -EINVAL;
 801680a: f06f 0315    	mvn	r3, #0x15
 801680e: e043         	b	0x8016898 <cbpprintf_external+0xaa> @ imm = #0x86
; 	args_size = hdr->hdr.desc.len * sizeof(int);
 8016810: 6abb         	ldr	r3, [r7, #0x28]
 8016812: 781b         	ldrb	r3, [r3]
 8016814: 009b         	lsls	r3, r3, #0x2
 8016816: 627b         	str	r3, [r7, #0x24]
; 	s_nbr     = hdr->hdr.desc.str_cnt;
 8016818: 6abb         	ldr	r3, [r7, #0x28]
 801681a: 785b         	ldrb	r3, [r3, #0x1]
 801681c: 623b         	str	r3, [r7, #0x20]
; 	ros_nbr   = hdr->hdr.desc.ro_str_cnt;
 801681e: 6abb         	ldr	r3, [r7, #0x28]
 8016820: 789b         	ldrb	r3, [r3, #0x2]
 8016822: 61fb         	str	r3, [r7, #0x1c]
; 	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
 8016824: 6abb         	ldr	r3, [r7, #0x28]
 8016826: 78db         	ldrb	r3, [r3, #0x3]
 8016828: 61bb         	str	r3, [r7, #0x18]
; 	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
 801682a: 6a7a         	ldr	r2, [r7, #0x24]
 801682c: 69fb         	ldr	r3, [r7, #0x1c]
 801682e: 441a         	add	r2, r3
 8016830: 69bb         	ldr	r3, [r7, #0x18]
 8016832: 005b         	lsls	r3, r3, #0x1
 8016834: 4413         	add	r3, r2
 8016836: 6afa         	ldr	r2, [r7, #0x2c]
 8016838: 4413         	add	r3, r2
 801683a: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 801683c: 2300         	movs	r3, #0x0
 801683e: 633b         	str	r3, [r7, #0x30]
 8016840: e018         	b	0x8016874 <cbpprintf_external+0x86> @ imm = #0x30
; 		s_idx = *(uint8_t *)s;
 8016842: 6b7b         	ldr	r3, [r7, #0x34]
 8016844: 781b         	ldrb	r3, [r3]
 8016846: 617b         	str	r3, [r7, #0x14]
; 		++s;
 8016848: 6b7b         	ldr	r3, [r7, #0x34]
 801684a: 3301         	adds	r3, #0x1
 801684c: 637b         	str	r3, [r7, #0x34]
; 		ps = (char **)(buf + s_idx * sizeof(int));
 801684e: 697b         	ldr	r3, [r7, #0x14]
 8016850: 009b         	lsls	r3, r3, #0x2
 8016852: 6afa         	ldr	r2, [r7, #0x2c]
 8016854: 4413         	add	r3, r2
 8016856: 613b         	str	r3, [r7, #0x10]
; 		*ps = s;
 8016858: 693b         	ldr	r3, [r7, #0x10]
 801685a: 6b7a         	ldr	r2, [r7, #0x34]
 801685c: 601a         	str	r2, [r3]
; 		s += strlen(s) + 1;
 801685e: 6b78         	ldr	r0, [r7, #0x34]
 8016860: f7ea f91a    	bl	0x8000a98 <strlen>      @ imm = #-0x15dcc
 8016864: 4603         	mov	r3, r0
 8016866: 3301         	adds	r3, #0x1
 8016868: 6b7a         	ldr	r2, [r7, #0x34]
 801686a: 4413         	add	r3, r2
 801686c: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 801686e: 6b3b         	ldr	r3, [r7, #0x30]
 8016870: 3301         	adds	r3, #0x1
 8016872: 633b         	str	r3, [r7, #0x30]
 8016874: 6b3a         	ldr	r2, [r7, #0x30]
 8016876: 6a3b         	ldr	r3, [r7, #0x20]
 8016878: 429a         	cmp	r2, r3
 801687a: d3e2         	blo	0x8016842 <cbpprintf_external+0x54> @ imm = #-0x3c
; 	buf += sizeof(*hdr);
 801687c: 6afb         	ldr	r3, [r7, #0x2c]
 801687e: 3308         	adds	r3, #0x8
 8016880: 62fb         	str	r3, [r7, #0x2c]
; 	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
 8016882: 6abb         	ldr	r3, [r7, #0x28]
 8016884: 685a         	ldr	r2, [r3, #0x4]
 8016886: 6afb         	ldr	r3, [r7, #0x2c]
 8016888: 9300         	str	r3, [sp]
 801688a: 4613         	mov	r3, r2
 801688c: 687a         	ldr	r2, [r7, #0x4]
 801688e: 68b9         	ldr	r1, [r7, #0x8]
 8016890: 68f8         	ldr	r0, [r7, #0xc]
 8016892: f7ff ff98    	bl	0x80167c6 <cbprintf_via_va_list> @ imm = #-0xd0
 8016896: 4603         	mov	r3, r0
; }
 8016898: 4618         	mov	r0, r3
 801689a: 3738         	adds	r7, #0x38
 801689c: 46bd         	mov	sp, r7
 801689e: bd80         	pop	{r7, pc}

080168a0 <arch_printk_char_out>:
; {
 80168a0: b480         	push	{r7}
 80168a2: b083         	sub	sp, #0xc
 80168a4: af00         	add	r7, sp, #0x0
 80168a6: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80168a8: 2300         	movs	r3, #0x0
; }
 80168aa: 4618         	mov	r0, r3
 80168ac: 370c         	adds	r7, #0xc
 80168ae: 46bd         	mov	sp, r7
 80168b0: f85d 7b04    	ldr	r7, [sp], #4
 80168b4: 4770         	bx	lr

080168b6 <vprintk>:
; {
 80168b6: b580         	push	{r7, lr}
 80168b8: b08c         	sub	sp, #0x30
 80168ba: af00         	add	r7, sp, #0x0
 80168bc: 6078         	str	r0, [r7, #0x4]
 80168be: 6039         	str	r1, [r7]
; 		z_log_vprintk(fmt, ap);
 80168c0: 6839         	ldr	r1, [r7]
 80168c2: 6878         	ldr	r0, [r7, #0x4]
 80168c4: f000 f94d    	bl	0x8016b62 <z_log_vprintk> @ imm = #0x29a
; 		return;
 80168c8: bf00         	nop
; }
 80168ca: 3730         	adds	r7, #0x30
 80168cc: 46bd         	mov	sp, r7
 80168ce: bd80         	pop	{r7, pc}

080168d0 <printk>:
; {
 80168d0: b40f         	push	{r0, r1, r2, r3}
 80168d2: b580         	push	{r7, lr}
 80168d4: b082         	sub	sp, #0x8
 80168d6: af00         	add	r7, sp, #0x0
; 	va_start(ap, fmt);
 80168d8: f107 0314    	add.w	r3, r7, #0x14
 80168dc: 607b         	str	r3, [r7, #0x4]
; 	vprintk(fmt, ap);
 80168de: 6879         	ldr	r1, [r7, #0x4]
 80168e0: 6938         	ldr	r0, [r7, #0x10]
 80168e2: f7ff ffe8    	bl	0x80168b6 <vprintk>     @ imm = #-0x30
; }
 80168e6: bf00         	nop
 80168e8: 3708         	adds	r7, #0x8
 80168ea: 46bd         	mov	sp, r7
 80168ec: e8bd 4080    	pop.w	{r7, lr}
 80168f0: b004         	add	sp, #0x10
 80168f2: 4770         	bx	lr

080168f4 <k_sched_current_thread_query>:
; {
 80168f4: b580         	push	{r7, lr}
 80168f6: af00         	add	r7, sp, #0x0
; 	return z_impl_k_sched_current_thread_query();
 80168f8: f7fb fcac    	bl	0x8012254 <z_impl_k_sched_current_thread_query> @ imm = #-0x46a8
 80168fc: 4603         	mov	r3, r0
; }
 80168fe: 4618         	mov	r0, r3
 8016900: bd80         	pop	{r7, pc}

08016902 <k_thread_abort>:
; {
 8016902: b580         	push	{r7, lr}
 8016904: b082         	sub	sp, #0x8
 8016906: af00         	add	r7, sp, #0x0
 8016908: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 801690a: 6878         	ldr	r0, [r7, #0x4]
 801690c: f7f0 fa58    	bl	0x8006dc0 <z_impl_k_thread_abort> @ imm = #-0xfb50
; }
 8016910: bf00         	nop
 8016912: 3708         	adds	r7, #0x8
 8016914: 46bd         	mov	sp, r7
 8016916: bd80         	pop	{r7, pc}

08016918 <_ConfigAbsSyms>:
; GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
 8016918: b480         	push	{r7}
 801691a: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 801691c: bf00         	nop
 801691e: 46bd         	mov	sp, r7
 8016920: f85d 7b04    	ldr	r7, [sp], #4
 8016924: 4770         	bx	lr

08016926 <st_stm32_common_config>:
; {
 8016926: b580         	push	{r7, lr}
 8016928: af00         	add	r7, sp, #0x0
; 	LL_DBGMCU_DisableDBGStopMode();
 801692a: f7ee fb9d    	bl	0x8005068 <LL_DBGMCU_DisableDBGStopMode> @ imm = #-0x118c6
; 	return 0;
 801692e: 2300         	movs	r3, #0x0
; }
 8016930: 4618         	mov	r0, r3
 8016932: bd80         	pop	{r7, pc}

08016934 <atomic_add>:
; {
 8016934: b490         	push	{r4, r7}
 8016936: b082         	sub	sp, #0x8
 8016938: af00         	add	r7, sp, #0x0
 801693a: 6078         	str	r0, [r7, #0x4]
 801693c: 6039         	str	r1, [r7]
; 	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 801693e: 683a         	ldr	r2, [r7]
 8016940: 687b         	ldr	r3, [r7, #0x4]
 8016942: f3bf 8f5b    	dmb	ish
 8016946: e853 1f00    	ldrex	r1, [r3]
 801694a: eb01 0002    	add.w	r0, r1, r2
 801694e: e843 0400    	strex	r4, r0, [r3]
 8016952: 2c00         	cmp	r4, #0x0
 8016954: d1f7         	bne	0x8016946 <atomic_add+0x12> @ imm = #-0x12
 8016956: f3bf 8f5b    	dmb	ish
 801695a: 460b         	mov	r3, r1
; }
 801695c: 4618         	mov	r0, r3
 801695e: 3708         	adds	r7, #0x8
 8016960: 46bd         	mov	sp, r7
 8016962: bc90         	pop	{r4, r7}
 8016964: 4770         	bx	lr

08016966 <atomic_sub>:
; {
 8016966: b490         	push	{r4, r7}
 8016968: b082         	sub	sp, #0x8
 801696a: af00         	add	r7, sp, #0x0
 801696c: 6078         	str	r0, [r7, #0x4]
 801696e: 6039         	str	r1, [r7]
; 	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 8016970: 683a         	ldr	r2, [r7]
 8016972: 687b         	ldr	r3, [r7, #0x4]
 8016974: f3bf 8f5b    	dmb	ish
 8016978: e853 1f00    	ldrex	r1, [r3]
 801697c: eba1 0002    	sub.w	r0, r1, r2
 8016980: e843 0400    	strex	r4, r0, [r3]
 8016984: 2c00         	cmp	r4, #0x0
 8016986: d1f7         	bne	0x8016978 <atomic_sub+0x12> @ imm = #-0x12
 8016988: f3bf 8f5b    	dmb	ish
 801698c: 460b         	mov	r3, r1
; }
 801698e: 4618         	mov	r0, r3
 8016990: 3708         	adds	r7, #0x8
 8016992: 46bd         	mov	sp, r7
 8016994: bc90         	pop	{r4, r7}
 8016996: 4770         	bx	lr

08016998 <atomic_inc>:
; {
 8016998: b580         	push	{r7, lr}
 801699a: b082         	sub	sp, #0x8
 801699c: af00         	add	r7, sp, #0x0
 801699e: 6078         	str	r0, [r7, #0x4]
; 	return atomic_add(target, 1);
 80169a0: 2101         	movs	r1, #0x1
 80169a2: 6878         	ldr	r0, [r7, #0x4]
 80169a4: f7ff ffc6    	bl	0x8016934 <atomic_add>  @ imm = #-0x74
 80169a8: 4603         	mov	r3, r0
; }
 80169aa: 4618         	mov	r0, r3
 80169ac: 3708         	adds	r7, #0x8
 80169ae: 46bd         	mov	sp, r7
 80169b0: bd80         	pop	{r7, pc}

080169b2 <atomic_dec>:
; {
 80169b2: b580         	push	{r7, lr}
 80169b4: b082         	sub	sp, #0x8
 80169b6: af00         	add	r7, sp, #0x0
 80169b8: 6078         	str	r0, [r7, #0x4]
; 	return atomic_sub(target, 1);
 80169ba: 2101         	movs	r1, #0x1
 80169bc: 6878         	ldr	r0, [r7, #0x4]
 80169be: f7ff ffd2    	bl	0x8016966 <atomic_sub>  @ imm = #-0x5c
 80169c2: 4603         	mov	r3, r0
; }
 80169c4: 4618         	mov	r0, r3
 80169c6: 3708         	adds	r7, #0x8
 80169c8: 46bd         	mov	sp, r7
 80169ca: bd80         	pop	{r7, pc}

080169cc <z_log_item_is_msg>:
; {
 80169cc: b480         	push	{r7}
 80169ce: b083         	sub	sp, #0xc
 80169d0: af00         	add	r7, sp, #0x0
 80169d2: 6078         	str	r0, [r7, #0x4]
; 	return msg->generic.type == Z_LOG_MSG_LOG;
 80169d4: 687b         	ldr	r3, [r7, #0x4]
 80169d6: 781b         	ldrb	r3, [r3]
 80169d8: f003 0304    	and	r3, r3, #0x4
 80169dc: b2db         	uxtb	r3, r3
 80169de: 2b00         	cmp	r3, #0x0
 80169e0: bf0c         	ite	eq
 80169e2: 2301         	moveq	r3, #0x1
 80169e4: 2300         	movne	r3, #0x0
 80169e6: b2db         	uxtb	r3, r3
; }
 80169e8: 4618         	mov	r0, r3
 80169ea: 370c         	adds	r7, #0xc
 80169ec: 46bd         	mov	sp, r7
 80169ee: f85d 7b04    	ldr	r7, [sp], #4
 80169f2: 4770         	bx	lr

080169f4 <k_msleep>:
; {
 80169f4: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 80169f8: b082         	sub	sp, #0x8
 80169fa: af00         	add	r7, sp, #0x0
 80169fc: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 80169fe: 6879         	ldr	r1, [r7, #0x4]
 8016a00: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 8016a04: 17c8         	asrs	r0, r1, #0x1f
 8016a06: 4688         	mov	r8, r1
 8016a08: 4681         	mov	r9, r0
 8016a0a: 4640         	mov	r0, r8
 8016a0c: 4649         	mov	r1, r9
 8016a0e: f04f 0400    	mov.w	r4, #0x0
 8016a12: f04f 0500    	mov.w	r5, #0x0
 8016a16: 008d         	lsls	r5, r1, #0x2
 8016a18: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 8016a1c: 0084         	lsls	r4, r0, #0x2
 8016a1e: 4620         	mov	r0, r4
 8016a20: 4629         	mov	r1, r5
 8016a22: eb10 0208    	adds.w	r2, r0, r8
 8016a26: eb41 0309    	adc.w	r3, r1, r9
 8016a2a: eb12 0a02    	adds.w	r10, r2, r2
 8016a2e: eb43 0b03    	adc.w	r11, r3, r3
 8016a32: 4652         	mov	r2, r10
 8016a34: 465b         	mov	r3, r11
 8016a36: 4610         	mov	r0, r2
 8016a38: 4619         	mov	r1, r3
 8016a3a: f000 f823    	bl	0x8016a84 <k_sleep>     @ imm = #0x46
 8016a3e: 4601         	mov	r1, r0
 8016a40: 460b         	mov	r3, r1
; }
 8016a42: 4618         	mov	r0, r3
 8016a44: 3708         	adds	r7, #0x8
 8016a46: 46bd         	mov	sp, r7
 8016a48: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08016a4c <k_uptime_get>:
; {
 8016a4c: b580         	push	{r7, lr}
 8016a4e: af00         	add	r7, sp, #0x0
; 	return k_ticks_to_ms_floor64(k_uptime_ticks());
 8016a50: f000 f826    	bl	0x8016aa0 <k_uptime_ticks> @ imm = #0x4c
 8016a54: 4602         	mov	r2, r0
 8016a56: 460b         	mov	r3, r1
 8016a58: 4610         	mov	r0, r2
 8016a5a: 4619         	mov	r1, r3
 8016a5c: f04f 020a    	mov.w	r2, #0xa
 8016a60: f04f 0300    	mov.w	r3, #0x0
 8016a64: f7e9 fffe    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x16004
 8016a68: 4602         	mov	r2, r0
 8016a6a: 460b         	mov	r3, r1
; }
 8016a6c: 4610         	mov	r0, r2
 8016a6e: 4619         	mov	r1, r3
 8016a70: bd80         	pop	{r7, pc}

08016a72 <k_uptime_get_32>:
; {
 8016a72: b580         	push	{r7, lr}
 8016a74: af00         	add	r7, sp, #0x0
; 	return (uint32_t)k_uptime_get();
 8016a76: f7ff ffe9    	bl	0x8016a4c <k_uptime_get> @ imm = #-0x2e
 8016a7a: 4602         	mov	r2, r0
 8016a7c: 460b         	mov	r3, r1
 8016a7e: 4613         	mov	r3, r2
; }
 8016a80: 4618         	mov	r0, r3
 8016a82: bd80         	pop	{r7, pc}

08016a84 <k_sleep>:
; {
 8016a84: b580         	push	{r7, lr}
 8016a86: b082         	sub	sp, #0x8
 8016a88: af00         	add	r7, sp, #0x0
 8016a8a: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8016a8e: e9d7 0100    	ldrd	r0, r1, [r7]
 8016a92: f7fb fb9d    	bl	0x80121d0 <z_impl_k_sleep> @ imm = #-0x48c6
 8016a96: 4603         	mov	r3, r0
; }
 8016a98: 4618         	mov	r0, r3
 8016a9a: 3708         	adds	r7, #0x8
 8016a9c: 46bd         	mov	sp, r7
 8016a9e: bd80         	pop	{r7, pc}

08016aa0 <k_uptime_ticks>:
; {
 8016aa0: b580         	push	{r7, lr}
 8016aa2: af00         	add	r7, sp, #0x0
; 	return z_impl_k_uptime_ticks();
 8016aa4: f009 f89e    	bl	0x801fbe4 <z_impl_k_uptime_ticks> @ imm = #0x913c
 8016aa8: 4602         	mov	r2, r0
 8016aaa: 460b         	mov	r3, r1
; }
 8016aac: 4610         	mov	r0, r2
 8016aae: 4619         	mov	r1, r3
 8016ab0: bd80         	pop	{r7, pc}

08016ab2 <log_backend_init>:
; {
 8016ab2: b580         	push	{r7, lr}
 8016ab4: b082         	sub	sp, #0x8
 8016ab6: af00         	add	r7, sp, #0x0
 8016ab8: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->init) {
 8016aba: 687b         	ldr	r3, [r7, #0x4]
 8016abc: 681b         	ldr	r3, [r3]
 8016abe: 68db         	ldr	r3, [r3, #0xc]
 8016ac0: 2b00         	cmp	r3, #0x0
 8016ac2: d004         	beq	0x8016ace <log_backend_init+0x1c> @ imm = #0x8
; 		backend->api->init(backend);
 8016ac4: 687b         	ldr	r3, [r7, #0x4]
 8016ac6: 681b         	ldr	r3, [r3]
 8016ac8: 68db         	ldr	r3, [r3, #0xc]
 8016aca: 6878         	ldr	r0, [r7, #0x4]
 8016acc: 4798         	blx	r3
; }
 8016ace: bf00         	nop
 8016ad0: 3708         	adds	r7, #0x8
 8016ad2: 46bd         	mov	sp, r7
 8016ad4: bd80         	pop	{r7, pc}

08016ad6 <log_backend_is_ready>:
; {
 8016ad6: b580         	push	{r7, lr}
 8016ad8: b082         	sub	sp, #0x8
 8016ada: af00         	add	r7, sp, #0x0
 8016adc: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->is_ready != NULL) {
 8016ade: 687b         	ldr	r3, [r7, #0x4]
 8016ae0: 681b         	ldr	r3, [r3]
 8016ae2: 691b         	ldr	r3, [r3, #0x10]
 8016ae4: 2b00         	cmp	r3, #0x0
 8016ae6: d006         	beq	0x8016af6 <log_backend_is_ready+0x20> @ imm = #0xc
; 		return backend->api->is_ready(backend);
 8016ae8: 687b         	ldr	r3, [r7, #0x4]
 8016aea: 681b         	ldr	r3, [r3]
 8016aec: 691b         	ldr	r3, [r3, #0x10]
 8016aee: 6878         	ldr	r0, [r7, #0x4]
 8016af0: 4798         	blx	r3
 8016af2: 4603         	mov	r3, r0
 8016af4: e000         	b	0x8016af8 <log_backend_is_ready+0x22> @ imm = #0x0
; 	return 0;
 8016af6: 2300         	movs	r3, #0x0
; }
 8016af8: 4618         	mov	r0, r3
 8016afa: 3708         	adds	r7, #0x8
 8016afc: 46bd         	mov	sp, r7
 8016afe: bd80         	pop	{r7, pc}

08016b00 <log_backend_msg_process>:
; {
 8016b00: b580         	push	{r7, lr}
 8016b02: b082         	sub	sp, #0x8
 8016b04: af00         	add	r7, sp, #0x0
 8016b06: 6078         	str	r0, [r7, #0x4]
 8016b08: 6039         	str	r1, [r7]
; 	backend->api->process(backend, msg);
 8016b0a: 687b         	ldr	r3, [r7, #0x4]
 8016b0c: 681b         	ldr	r3, [r3]
 8016b0e: 681b         	ldr	r3, [r3]
 8016b10: 6839         	ldr	r1, [r7]
 8016b12: 6878         	ldr	r0, [r7, #0x4]
 8016b14: 4798         	blx	r3
; }
 8016b16: bf00         	nop
 8016b18: 3708         	adds	r7, #0x8
 8016b1a: 46bd         	mov	sp, r7
 8016b1c: bd80         	pop	{r7, pc}

08016b1e <log_backend_panic>:
; {
 8016b1e: b580         	push	{r7, lr}
 8016b20: b082         	sub	sp, #0x8
 8016b22: af00         	add	r7, sp, #0x0
 8016b24: 6078         	str	r0, [r7, #0x4]
; 	backend->api->panic(backend);
 8016b26: 687b         	ldr	r3, [r7, #0x4]
 8016b28: 681b         	ldr	r3, [r3]
 8016b2a: 689b         	ldr	r3, [r3, #0x8]
 8016b2c: 6878         	ldr	r0, [r7, #0x4]
 8016b2e: 4798         	blx	r3
; }
 8016b30: bf00         	nop
 8016b32: 3708         	adds	r7, #0x8
 8016b34: 46bd         	mov	sp, r7
 8016b36: bd80         	pop	{r7, pc}

08016b38 <log_backend_is_active>:
; {
 8016b38: b480         	push	{r7}
 8016b3a: b083         	sub	sp, #0xc
 8016b3c: af00         	add	r7, sp, #0x0
 8016b3e: 6078         	str	r0, [r7, #0x4]
; 	return backend->cb->active;
 8016b40: 687b         	ldr	r3, [r7, #0x4]
 8016b42: 685b         	ldr	r3, [r3, #0x4]
 8016b44: 795b         	ldrb	r3, [r3, #0x5]
; }
 8016b46: 4618         	mov	r0, r3
 8016b48: 370c         	adds	r7, #0xc
 8016b4a: 46bd         	mov	sp, r7
 8016b4c: f85d 7b04    	ldr	r7, [sp], #4
 8016b50: 4770         	bx	lr

08016b52 <dummy_timestamp>:
; {
 8016b52: b480         	push	{r7}
 8016b54: af00         	add	r7, sp, #0x0
; 	return 0;
 8016b56: 2300         	movs	r3, #0x0
; }
 8016b58: 4618         	mov	r0, r3
 8016b5a: 46bd         	mov	sp, r7
 8016b5c: f85d 7b04    	ldr	r7, [sp], #4
 8016b60: 4770         	bx	lr

08016b62 <z_log_vprintk>:
; {
 8016b62: b580         	push	{r7, lr}
 8016b64: b086         	sub	sp, #0x18
 8016b66: af04         	add	r7, sp, #0x10
 8016b68: 6078         	str	r0, [r7, #0x4]
 8016b6a: 6039         	str	r1, [r7]
; 	z_log_msg_runtime_vcreate(Z_LOG_LOCAL_DOMAIN_ID, NULL,
 8016b6c: 683b         	ldr	r3, [r7]
 8016b6e: 9303         	str	r3, [sp, #0xc]
 8016b70: 687b         	ldr	r3, [r7, #0x4]
 8016b72: 9302         	str	r3, [sp, #0x8]
 8016b74: 2300         	movs	r3, #0x0
 8016b76: 9301         	str	r3, [sp, #0x4]
 8016b78: 2300         	movs	r3, #0x0
 8016b7a: 9300         	str	r3, [sp]
 8016b7c: 2300         	movs	r3, #0x0
 8016b7e: 2200         	movs	r2, #0x0
 8016b80: 2100         	movs	r1, #0x0
 8016b82: 2000         	movs	r0, #0x0
 8016b84: f7ee fcf6    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x11614
; }
 8016b88: 3708         	adds	r7, #0x8
 8016b8a: 46bd         	mov	sp, r7
 8016b8c: bd80         	pop	{r7, pc}

08016b8e <default_lf_get_timestamp>:
; {
 8016b8e: b580         	push	{r7, lr}
 8016b90: af00         	add	r7, sp, #0x0
; 		k_uptime_get() : k_uptime_get_32();
 8016b92: f7ff ff6e    	bl	0x8016a72 <k_uptime_get_32> @ imm = #-0x124
 8016b96: 4603         	mov	r3, r0
; }
 8016b98: 4618         	mov	r0, r3
 8016b9a: bd80         	pop	{r7, pc}

08016b9c <activate_foreach_backend>:
; {
 8016b9c: b580         	push	{r7, lr}
 8016b9e: b086         	sub	sp, #0x18
 8016ba0: af00         	add	r7, sp, #0x0
 8016ba2: 6078         	str	r0, [r7, #0x4]
; 	uint32_t mask_cpy = mask;
 8016ba4: 687b         	ldr	r3, [r7, #0x4]
 8016ba6: 617b         	str	r3, [r7, #0x14]
; 	while (mask_cpy) {
 8016ba8: e02b         	b	0x8016c02 <activate_foreach_backend+0x66> @ imm = #0x56
; 		uint32_t i = __builtin_ctz(mask_cpy);
 8016baa: 697b         	ldr	r3, [r7, #0x14]
 8016bac: fa93 f3a3    	rbit	r3, r3
 8016bb0: fab3 f383    	clz	r3, r3
 8016bb4: 613b         	str	r3, [r7, #0x10]
; 		const struct log_backend *backend = log_backend_get(i);
 8016bb6: 6938         	ldr	r0, [r7, #0x10]
 8016bb8: f7ee faa8    	bl	0x800510c <log_backend_get> @ imm = #-0x11ab0
 8016bbc: 60f8         	str	r0, [r7, #0xc]
; 		mask_cpy &= ~BIT(i);
 8016bbe: 2201         	movs	r2, #0x1
 8016bc0: 693b         	ldr	r3, [r7, #0x10]
 8016bc2: fa02 f303    	lsl.w	r3, r2, r3
 8016bc6: 43db         	mvns	r3, r3
 8016bc8: 697a         	ldr	r2, [r7, #0x14]
 8016bca: 4013         	ands	r3, r2
 8016bcc: 617b         	str	r3, [r7, #0x14]
; 		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
 8016bce: 68fb         	ldr	r3, [r7, #0xc]
 8016bd0: 7b1b         	ldrb	r3, [r3, #0xc]
 8016bd2: 2b00         	cmp	r3, #0x0
 8016bd4: d015         	beq	0x8016c02 <activate_foreach_backend+0x66> @ imm = #0x2a
 8016bd6: 68f8         	ldr	r0, [r7, #0xc]
 8016bd8: f7ff ff7d    	bl	0x8016ad6 <log_backend_is_ready> @ imm = #-0x106
 8016bdc: 4603         	mov	r3, r0
 8016bde: 2b00         	cmp	r3, #0x0
 8016be0: d10f         	bne	0x8016c02 <activate_foreach_backend+0x66> @ imm = #0x1e
; 			mask &= ~BIT(i);
 8016be2: 2201         	movs	r2, #0x1
 8016be4: 693b         	ldr	r3, [r7, #0x10]
 8016be6: fa02 f303    	lsl.w	r3, r2, r3
 8016bea: 43db         	mvns	r3, r3
 8016bec: 687a         	ldr	r2, [r7, #0x4]
 8016bee: 4013         	ands	r3, r2
 8016bf0: 607b         	str	r3, [r7, #0x4]
; 					   backend->cb->ctx,
 8016bf2: 68fb         	ldr	r3, [r7, #0xc]
 8016bf4: 685b         	ldr	r3, [r3, #0x4]
; 			log_backend_enable(backend,
 8016bf6: 681b         	ldr	r3, [r3]
 8016bf8: 2204         	movs	r2, #0x4
 8016bfa: 4619         	mov	r1, r3
 8016bfc: 68f8         	ldr	r0, [r7, #0xc]
 8016bfe: f000 f8ce    	bl	0x8016d9e <log_backend_enable> @ imm = #0x19c
; 	while (mask_cpy) {
 8016c02: 697b         	ldr	r3, [r7, #0x14]
 8016c04: 2b00         	cmp	r3, #0x0
 8016c06: d1d0         	bne	0x8016baa <activate_foreach_backend+0xe> @ imm = #-0x60
; 	return mask;
 8016c08: 687b         	ldr	r3, [r7, #0x4]
; }
 8016c0a: 4618         	mov	r0, r3
 8016c0c: 3718         	adds	r7, #0x18
 8016c0e: 46bd         	mov	sp, r7
 8016c10: bd80         	pop	{r7, pc}

08016c12 <msg_filter_check>:
; {
 8016c12: b580         	push	{r7, lr}
 8016c14: b082         	sub	sp, #0x8
 8016c16: af00         	add	r7, sp, #0x0
 8016c18: 6078         	str	r0, [r7, #0x4]
 8016c1a: 6039         	str	r1, [r7]
; 	if (!z_log_item_is_msg(msg)) {
 8016c1c: 6838         	ldr	r0, [r7]
 8016c1e: f7ff fed5    	bl	0x80169cc <z_log_item_is_msg> @ imm = #-0x256
 8016c22: 4603         	mov	r3, r0
 8016c24: f083 0301    	eor	r3, r3, #0x1
 8016c28: b2db         	uxtb	r3, r3
 8016c2a: 2b00         	cmp	r3, #0x0
 8016c2c: d001         	beq	0x8016c32 <msg_filter_check+0x20> @ imm = #0x2
; 		return true;
 8016c2e: 2301         	movs	r3, #0x1
 8016c30: e000         	b	0x8016c34 <msg_filter_check+0x22> @ imm = #0x0
; 		return true;
 8016c32: 2301         	movs	r3, #0x1
; }
 8016c34: 4618         	mov	r0, r3
 8016c36: 3708         	adds	r7, #0x8
 8016c38: 46bd         	mov	sp, r7
 8016c3a: bd80         	pop	{r7, pc}

08016c3c <msg_commit>:
; {
 8016c3c: b580         	push	{r7, lr}
 8016c3e: b084         	sub	sp, #0x10
 8016c40: af00         	add	r7, sp, #0x0
 8016c42: 6078         	str	r0, [r7, #0x4]
 8016c44: 6039         	str	r1, [r7]
; 	union log_msg_generic *m = (union log_msg_generic *)msg;
 8016c46: 683b         	ldr	r3, [r7]
 8016c48: 60fb         	str	r3, [r7, #0xc]
; 		msg_process(m);
 8016c4a: 68f8         	ldr	r0, [r7, #0xc]
 8016c4c: f7ee fb4a    	bl	0x80052e4 <msg_process> @ imm = #-0x1196c
; }
 8016c50: 3710         	adds	r7, #0x10
 8016c52: 46bd         	mov	sp, r7
 8016c54: bd80         	pop	{r7, pc}

08016c56 <z_log_get_tag>:
; {
 8016c56: b480         	push	{r7}
 8016c58: af00         	add	r7, sp, #0x0
; 	return CONFIG_LOG_TAG_MAX_LEN > 0 ? tag : NULL;
 8016c5a: 2300         	movs	r3, #0x0
; }
 8016c5c: 4618         	mov	r0, r3
 8016c5e: 46bd         	mov	sp, r7
 8016c60: f85d 7b04    	ldr	r7, [sp], #4
 8016c64: 4770         	bx	lr

08016c66 <enable_logger>:
; {
 8016c66: b580         	push	{r7, lr}
 8016c68: af00         	add	r7, sp, #0x0
; 		(void)z_log_init(false, false);
 8016c6a: 2100         	movs	r1, #0x0
 8016c6c: 2000         	movs	r0, #0x0
 8016c6e: f7ee fa89    	bl	0x8005184 <z_log_init>  @ imm = #-0x11aee
; 	return 0;
 8016c72: 2300         	movs	r3, #0x0
; }
 8016c74: 4618         	mov	r0, r3
 8016c76: bd80         	pop	{r7, pc}

08016c78 <z_log_is_local_domain>:
; {
 8016c78: b480         	push	{r7}
 8016c7a: b083         	sub	sp, #0xc
 8016c7c: af00         	add	r7, sp, #0x0
 8016c7e: 4603         	mov	r3, r0
 8016c80: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 8016c82: 2301         	movs	r3, #0x1
; }
 8016c84: 4618         	mov	r0, r3
 8016c86: 370c         	adds	r7, #0xc
 8016c88: 46bd         	mov	sp, r7
 8016c8a: f85d 7b04    	ldr	r7, [sp], #4
 8016c8e: 4770         	bx	lr

08016c90 <log_backend_id_set>:
; {
 8016c90: b480         	push	{r7}
 8016c92: b083         	sub	sp, #0xc
 8016c94: af00         	add	r7, sp, #0x0
 8016c96: 6078         	str	r0, [r7, #0x4]
 8016c98: 460b         	mov	r3, r1
 8016c9a: 70fb         	strb	r3, [r7, #0x3]
; 	backend->cb->id = id;
 8016c9c: 687b         	ldr	r3, [r7, #0x4]
 8016c9e: 685b         	ldr	r3, [r3, #0x4]
 8016ca0: 78fa         	ldrb	r2, [r7, #0x3]
 8016ca2: 711a         	strb	r2, [r3, #0x4]
; }
 8016ca4: bf00         	nop
 8016ca6: 370c         	adds	r7, #0xc
 8016ca8: 46bd         	mov	sp, r7
 8016caa: f85d 7b04    	ldr	r7, [sp], #4
 8016cae: 4770         	bx	lr

08016cb0 <log_backend_activate>:
; {
 8016cb0: b480         	push	{r7}
 8016cb2: b083         	sub	sp, #0xc
 8016cb4: af00         	add	r7, sp, #0x0
 8016cb6: 6078         	str	r0, [r7, #0x4]
 8016cb8: 6039         	str	r1, [r7]
; 	backend->cb->ctx = ctx;
 8016cba: 687b         	ldr	r3, [r7, #0x4]
 8016cbc: 685b         	ldr	r3, [r3, #0x4]
 8016cbe: 683a         	ldr	r2, [r7]
 8016cc0: 601a         	str	r2, [r3]
; 	backend->cb->active = true;
 8016cc2: 687b         	ldr	r3, [r7, #0x4]
 8016cc4: 685b         	ldr	r3, [r3, #0x4]
 8016cc6: 2201         	movs	r2, #0x1
 8016cc8: 715a         	strb	r2, [r3, #0x5]
; }
 8016cca: bf00         	nop
 8016ccc: 370c         	adds	r7, #0xc
 8016cce: 46bd         	mov	sp, r7
 8016cd0: f85d 7b04    	ldr	r7, [sp], #4
 8016cd4: 4770         	bx	lr

08016cd6 <log_link_sources_count>:
; {
 8016cd6: b480         	push	{r7}
 8016cd8: b083         	sub	sp, #0xc
 8016cda: af00         	add	r7, sp, #0x0
 8016cdc: 6078         	str	r0, [r7, #0x4]
 8016cde: 6039         	str	r1, [r7]
; 	return link->ctrl_blk->source_cnt[domain_id];
 8016ce0: 687b         	ldr	r3, [r7, #0x4]
 8016ce2: 689a         	ldr	r2, [r3, #0x8]
 8016ce4: 683b         	ldr	r3, [r7]
 8016ce6: 005b         	lsls	r3, r3, #0x1
 8016ce8: 4413         	add	r3, r2
 8016cea: 889b         	ldrh	r3, [r3, #0x4]
; }
 8016cec: 4618         	mov	r0, r3
 8016cee: 370c         	adds	r7, #0xc
 8016cf0: 46bd         	mov	sp, r7
 8016cf2: f85d 7b04    	ldr	r7, [sp], #4
 8016cf6: 4770         	bx	lr

08016cf8 <log_link_get_source_name>:
; {
 8016cf8: b590         	push	{r4, r7, lr}
 8016cfa: b087         	sub	sp, #0x1c
 8016cfc: af02         	add	r7, sp, #0x8
 8016cfe: 60f8         	str	r0, [r7, #0xc]
 8016d00: 60b9         	str	r1, [r7, #0x8]
 8016d02: 603b         	str	r3, [r7]
 8016d04: 4613         	mov	r3, r2
 8016d06: 80fb         	strh	r3, [r7, #0x6]
; 	return link->api->get_source_name(link, domain_id, source_id,
 8016d08: 68fb         	ldr	r3, [r7, #0xc]
 8016d0a: 681b         	ldr	r3, [r3]
 8016d0c: 68dc         	ldr	r4, [r3, #0xc]
 8016d0e: 88fa         	ldrh	r2, [r7, #0x6]
 8016d10: 6a3b         	ldr	r3, [r7, #0x20]
 8016d12: 9300         	str	r3, [sp]
 8016d14: 683b         	ldr	r3, [r7]
 8016d16: 68b9         	ldr	r1, [r7, #0x8]
 8016d18: 68f8         	ldr	r0, [r7, #0xc]
 8016d1a: 47a0         	blx	r4
 8016d1c: 4603         	mov	r3, r0
; }
 8016d1e: 4618         	mov	r0, r3
 8016d20: 3714         	adds	r7, #0x14
 8016d22: 46bd         	mov	sp, r7
 8016d24: bd90         	pop	{r4, r7, pc}

08016d26 <link_source_count>:
; {
 8016d26: b580         	push	{r7, lr}
 8016d28: b084         	sub	sp, #0x10
 8016d2a: af00         	add	r7, sp, #0x0
 8016d2c: 4603         	mov	r3, r0
 8016d2e: 71fb         	strb	r3, [r7, #0x7]
; 	const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 8016d30: f107 020b    	add.w	r2, r7, #0xb
 8016d34: 79fb         	ldrb	r3, [r7, #0x7]
 8016d36: 4611         	mov	r1, r2
 8016d38: 4618         	mov	r0, r3
 8016d3a: f7ee fb65    	bl	0x8005408 <get_link_domain> @ imm = #-0x11936
 8016d3e: 60f8         	str	r0, [r7, #0xc]
; 	return log_link_sources_count(link, rel_domain_id);
 8016d40: 7afb         	ldrb	r3, [r7, #0xb]
 8016d42: 4619         	mov	r1, r3
 8016d44: 68f8         	ldr	r0, [r7, #0xc]
 8016d46: f7ff ffc6    	bl	0x8016cd6 <log_link_sources_count> @ imm = #-0x74
 8016d4a: 4603         	mov	r3, r0
; }
 8016d4c: 4618         	mov	r0, r3
 8016d4e: 3710         	adds	r7, #0x10
 8016d50: 46bd         	mov	sp, r7
 8016d52: bd80         	pop	{r7, pc}

08016d54 <log_src_cnt_get>:
; {
 8016d54: b580         	push	{r7, lr}
 8016d56: b082         	sub	sp, #0x8
 8016d58: af00         	add	r7, sp, #0x0
 8016d5a: 6078         	str	r0, [r7, #0x4]
; 	if (z_log_is_local_domain(domain_id)) {
 8016d5c: 687b         	ldr	r3, [r7, #0x4]
 8016d5e: b2db         	uxtb	r3, r3
 8016d60: 4618         	mov	r0, r3
 8016d62: f7ff ff89    	bl	0x8016c78 <z_log_is_local_domain> @ imm = #-0xee
 8016d66: 4603         	mov	r3, r0
 8016d68: 2b00         	cmp	r3, #0x0
 8016d6a: d003         	beq	0x8016d74 <log_src_cnt_get+0x20> @ imm = #0x6
; 		return z_log_sources_count();
 8016d6c: f7ee fb30    	bl	0x80053d0 <z_log_sources_count> @ imm = #-0x119a0
 8016d70: 4603         	mov	r3, r0
 8016d72: e005         	b	0x8016d80 <log_src_cnt_get+0x2c> @ imm = #0xa
; 	return link_source_count(domain_id);
 8016d74: 687b         	ldr	r3, [r7, #0x4]
 8016d76: b2db         	uxtb	r3, r3
 8016d78: 4618         	mov	r0, r3
 8016d7a: f7ff ffd4    	bl	0x8016d26 <link_source_count> @ imm = #-0x58
 8016d7e: 4603         	mov	r3, r0
; }
 8016d80: 4618         	mov	r0, r3
 8016d82: 3708         	adds	r7, #0x8
 8016d84: 46bd         	mov	sp, r7
 8016d86: bd80         	pop	{r7, pc}

08016d88 <backend_filter_set>:
; {
 8016d88: b480         	push	{r7}
 8016d8a: b083         	sub	sp, #0xc
 8016d8c: af00         	add	r7, sp, #0x0
 8016d8e: 6078         	str	r0, [r7, #0x4]
 8016d90: 6039         	str	r1, [r7]
; 		return;
 8016d92: bf00         	nop
; }
 8016d94: 370c         	adds	r7, #0xc
 8016d96: 46bd         	mov	sp, r7
 8016d98: f85d 7b04    	ldr	r7, [sp], #4
 8016d9c: 4770         	bx	lr

08016d9e <log_backend_enable>:
; {
 8016d9e: b580         	push	{r7, lr}
 8016da0: b086         	sub	sp, #0x18
 8016da2: af00         	add	r7, sp, #0x0
 8016da4: 60f8         	str	r0, [r7, #0xc]
 8016da6: 60b9         	str	r1, [r7, #0x8]
 8016da8: 607a         	str	r2, [r7, #0x4]
; 	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;
 8016daa: 2301         	movs	r3, #0x1
 8016dac: 617b         	str	r3, [r7, #0x14]
; 	id += backend - log_backend_get(0);
 8016dae: 2000         	movs	r0, #0x0
 8016db0: f7ee fb18    	bl	0x80053e4 <log_backend_get> @ imm = #-0x119d0
 8016db4: 4602         	mov	r2, r0
 8016db6: 68fb         	ldr	r3, [r7, #0xc]
 8016db8: 1a9b         	subs	r3, r3, r2
 8016dba: 111b         	asrs	r3, r3, #0x4
 8016dbc: 461a         	mov	r2, r3
 8016dbe: 697b         	ldr	r3, [r7, #0x14]
 8016dc0: 4413         	add	r3, r2
 8016dc2: 617b         	str	r3, [r7, #0x14]
; 	log_backend_id_set(backend, id);
 8016dc4: 697b         	ldr	r3, [r7, #0x14]
 8016dc6: b2db         	uxtb	r3, r3
 8016dc8: 4619         	mov	r1, r3
 8016dca: 68f8         	ldr	r0, [r7, #0xc]
 8016dcc: f7ff ff60    	bl	0x8016c90 <log_backend_id_set> @ imm = #-0x140
; 	backend->cb->level = level;
 8016dd0: 68fb         	ldr	r3, [r7, #0xc]
 8016dd2: 685b         	ldr	r3, [r3, #0x4]
 8016dd4: 687a         	ldr	r2, [r7, #0x4]
 8016dd6: b2d2         	uxtb	r2, r2
 8016dd8: 719a         	strb	r2, [r3, #0x6]
; 	backend_filter_set(backend, level);
 8016dda: 6879         	ldr	r1, [r7, #0x4]
 8016ddc: 68f8         	ldr	r0, [r7, #0xc]
 8016dde: f7ff ffd3    	bl	0x8016d88 <backend_filter_set> @ imm = #-0x5a
; 	log_backend_activate(backend, ctx);
 8016de2: 68b9         	ldr	r1, [r7, #0x8]
 8016de4: 68f8         	ldr	r0, [r7, #0xc]
 8016de6: f7ff ff63    	bl	0x8016cb0 <log_backend_activate> @ imm = #-0x13a
; 	z_log_notify_backend_enabled();
 8016dea: f7ee faa9    	bl	0x8005340 <z_log_notify_backend_enabled> @ imm = #-0x11aae
; }
 8016dee: bf00         	nop
 8016df0: 3718         	adds	r7, #0x18
 8016df2: 46bd         	mov	sp, r7
 8016df4: bd80         	pop	{r7, pc}

08016df6 <z_snode_next_peek>:
; {
 8016df6: b480         	push	{r7}
 8016df8: b083         	sub	sp, #0xc
 8016dfa: af00         	add	r7, sp, #0x0
 8016dfc: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 8016dfe: 687b         	ldr	r3, [r7, #0x4]
 8016e00: 681b         	ldr	r3, [r3]
; }
 8016e02: 4618         	mov	r0, r3
 8016e04: 370c         	adds	r7, #0xc
 8016e06: 46bd         	mov	sp, r7
 8016e08: f85d 7b04    	ldr	r7, [sp], #4
 8016e0c: 4770         	bx	lr

08016e0e <z_snode_next_set>:
; {
 8016e0e: b480         	push	{r7}
 8016e10: b083         	sub	sp, #0xc
 8016e12: af00         	add	r7, sp, #0x0
 8016e14: 6078         	str	r0, [r7, #0x4]
 8016e16: 6039         	str	r1, [r7]
; 	parent->next = child;
 8016e18: 687b         	ldr	r3, [r7, #0x4]
 8016e1a: 683a         	ldr	r2, [r7]
 8016e1c: 601a         	str	r2, [r3]
; }
 8016e1e: bf00         	nop
 8016e20: 370c         	adds	r7, #0xc
 8016e22: 46bd         	mov	sp, r7
 8016e24: f85d 7b04    	ldr	r7, [sp], #4
 8016e28: 4770         	bx	lr

08016e2a <z_slist_head_set>:
; {
 8016e2a: b480         	push	{r7}
 8016e2c: b083         	sub	sp, #0xc
 8016e2e: af00         	add	r7, sp, #0x0
 8016e30: 6078         	str	r0, [r7, #0x4]
 8016e32: 6039         	str	r1, [r7]
; 	list->head = node;
 8016e34: 687b         	ldr	r3, [r7, #0x4]
 8016e36: 683a         	ldr	r2, [r7]
 8016e38: 601a         	str	r2, [r3]
; }
 8016e3a: bf00         	nop
 8016e3c: 370c         	adds	r7, #0xc
 8016e3e: 46bd         	mov	sp, r7
 8016e40: f85d 7b04    	ldr	r7, [sp], #4
 8016e44: 4770         	bx	lr

08016e46 <z_slist_tail_set>:
; {
 8016e46: b480         	push	{r7}
 8016e48: b083         	sub	sp, #0xc
 8016e4a: af00         	add	r7, sp, #0x0
 8016e4c: 6078         	str	r0, [r7, #0x4]
 8016e4e: 6039         	str	r1, [r7]
; 	list->tail = node;
 8016e50: 687b         	ldr	r3, [r7, #0x4]
 8016e52: 683a         	ldr	r2, [r7]
 8016e54: 605a         	str	r2, [r3, #0x4]
; }
 8016e56: bf00         	nop
 8016e58: 370c         	adds	r7, #0xc
 8016e5a: 46bd         	mov	sp, r7
 8016e5c: f85d 7b04    	ldr	r7, [sp], #4
 8016e60: 4770         	bx	lr

08016e62 <sys_slist_peek_head>:
; {
 8016e62: b480         	push	{r7}
 8016e64: b083         	sub	sp, #0xc
 8016e66: af00         	add	r7, sp, #0x0
 8016e68: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 8016e6a: 687b         	ldr	r3, [r7, #0x4]
 8016e6c: 681b         	ldr	r3, [r3]
; }
 8016e6e: 4618         	mov	r0, r3
 8016e70: 370c         	adds	r7, #0xc
 8016e72: 46bd         	mov	sp, r7
 8016e74: f85d 7b04    	ldr	r7, [sp], #4
 8016e78: 4770         	bx	lr

08016e7a <sys_slist_peek_tail>:
; {
 8016e7a: b480         	push	{r7}
 8016e7c: b083         	sub	sp, #0xc
 8016e7e: af00         	add	r7, sp, #0x0
 8016e80: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 8016e82: 687b         	ldr	r3, [r7, #0x4]
 8016e84: 685b         	ldr	r3, [r3, #0x4]
; }
 8016e86: 4618         	mov	r0, r3
 8016e88: 370c         	adds	r7, #0xc
 8016e8a: 46bd         	mov	sp, r7
 8016e8c: f85d 7b04    	ldr	r7, [sp], #4
 8016e90: 4770         	bx	lr

08016e92 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 8016e92: b580         	push	{r7, lr}
 8016e94: b082         	sub	sp, #0x8
 8016e96: af00         	add	r7, sp, #0x0
 8016e98: 6078         	str	r0, [r7, #0x4]
 8016e9a: 6878         	ldr	r0, [r7, #0x4]
 8016e9c: f7ff ffe1    	bl	0x8016e62 <sys_slist_peek_head> @ imm = #-0x3e
 8016ea0: 4603         	mov	r3, r0
 8016ea2: 2b00         	cmp	r3, #0x0
 8016ea4: bf0c         	ite	eq
 8016ea6: 2301         	moveq	r3, #0x1
 8016ea8: 2300         	movne	r3, #0x0
 8016eaa: b2db         	uxtb	r3, r3
 8016eac: 4618         	mov	r0, r3
 8016eae: 3708         	adds	r7, #0x8
 8016eb0: 46bd         	mov	sp, r7
 8016eb2: bd80         	pop	{r7, pc}

08016eb4 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8016eb4: b580         	push	{r7, lr}
 8016eb6: b082         	sub	sp, #0x8
 8016eb8: af00         	add	r7, sp, #0x0
 8016eba: 6078         	str	r0, [r7, #0x4]
 8016ebc: 6878         	ldr	r0, [r7, #0x4]
 8016ebe: f7ff ff9a    	bl	0x8016df6 <z_snode_next_peek> @ imm = #-0xcc
 8016ec2: 4603         	mov	r3, r0
 8016ec4: 4618         	mov	r0, r3
 8016ec6: 3708         	adds	r7, #0x8
 8016ec8: 46bd         	mov	sp, r7
 8016eca: bd80         	pop	{r7, pc}

08016ecc <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 8016ecc: b580         	push	{r7, lr}
 8016ece: b082         	sub	sp, #0x8
 8016ed0: af00         	add	r7, sp, #0x0
 8016ed2: 6078         	str	r0, [r7, #0x4]
 8016ed4: 687b         	ldr	r3, [r7, #0x4]
 8016ed6: 2b00         	cmp	r3, #0x0
 8016ed8: d004         	beq	0x8016ee4 <sys_slist_peek_next+0x18> @ imm = #0x8
 8016eda: 6878         	ldr	r0, [r7, #0x4]
 8016edc: f7ff ffea    	bl	0x8016eb4 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 8016ee0: 4603         	mov	r3, r0
 8016ee2: e000         	b	0x8016ee6 <sys_slist_peek_next+0x1a> @ imm = #0x0
 8016ee4: 2300         	movs	r3, #0x0
 8016ee6: 4618         	mov	r0, r3
 8016ee8: 3708         	adds	r7, #0x8
 8016eea: 46bd         	mov	sp, r7
 8016eec: bd80         	pop	{r7, pc}

08016eee <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 8016eee: b580         	push	{r7, lr}
 8016ef0: b082         	sub	sp, #0x8
 8016ef2: af00         	add	r7, sp, #0x0
 8016ef4: 6078         	str	r0, [r7, #0x4]
 8016ef6: 6039         	str	r1, [r7]
 8016ef8: 6878         	ldr	r0, [r7, #0x4]
 8016efa: f7ff ffb2    	bl	0x8016e62 <sys_slist_peek_head> @ imm = #-0x9c
 8016efe: 4603         	mov	r3, r0
 8016f00: 4619         	mov	r1, r3
 8016f02: 6838         	ldr	r0, [r7]
 8016f04: f7ff ff83    	bl	0x8016e0e <z_snode_next_set> @ imm = #-0xfa
 8016f08: 6839         	ldr	r1, [r7]
 8016f0a: 6878         	ldr	r0, [r7, #0x4]
 8016f0c: f7ff ff8d    	bl	0x8016e2a <z_slist_head_set> @ imm = #-0xe6
 8016f10: 6878         	ldr	r0, [r7, #0x4]
 8016f12: f7ff ffb2    	bl	0x8016e7a <sys_slist_peek_tail> @ imm = #-0x9c
 8016f16: 4603         	mov	r3, r0
 8016f18: 2b00         	cmp	r3, #0x0
 8016f1a: d107         	bne	0x8016f2c <sys_slist_prepend+0x3e> @ imm = #0xe
 8016f1c: 6878         	ldr	r0, [r7, #0x4]
 8016f1e: f7ff ffa0    	bl	0x8016e62 <sys_slist_peek_head> @ imm = #-0xc0
 8016f22: 4603         	mov	r3, r0
 8016f24: 4619         	mov	r1, r3
 8016f26: 6878         	ldr	r0, [r7, #0x4]
 8016f28: f7ff ff8d    	bl	0x8016e46 <z_slist_tail_set> @ imm = #-0xe6
 8016f2c: 3708         	adds	r7, #0x8
 8016f2e: 46bd         	mov	sp, r7
 8016f30: bd80         	pop	{r7, pc}

08016f32 <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 8016f32: b580         	push	{r7, lr}
 8016f34: b084         	sub	sp, #0x10
 8016f36: af00         	add	r7, sp, #0x0
 8016f38: 6078         	str	r0, [r7, #0x4]
 8016f3a: 6878         	ldr	r0, [r7, #0x4]
 8016f3c: f7ff ff91    	bl	0x8016e62 <sys_slist_peek_head> @ imm = #-0xde
 8016f40: 60f8         	str	r0, [r7, #0xc]
 8016f42: 68f8         	ldr	r0, [r7, #0xc]
 8016f44: f7ff ff57    	bl	0x8016df6 <z_snode_next_peek> @ imm = #-0x152
 8016f48: 4603         	mov	r3, r0
 8016f4a: 4619         	mov	r1, r3
 8016f4c: 6878         	ldr	r0, [r7, #0x4]
 8016f4e: f7ff ff6c    	bl	0x8016e2a <z_slist_head_set> @ imm = #-0x128
 8016f52: 6878         	ldr	r0, [r7, #0x4]
 8016f54: f7ff ff91    	bl	0x8016e7a <sys_slist_peek_tail> @ imm = #-0xde
 8016f58: 4602         	mov	r2, r0
 8016f5a: 68fb         	ldr	r3, [r7, #0xc]
 8016f5c: 4293         	cmp	r3, r2
 8016f5e: d107         	bne	0x8016f70 <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 8016f60: 6878         	ldr	r0, [r7, #0x4]
 8016f62: f7ff ff7e    	bl	0x8016e62 <sys_slist_peek_head> @ imm = #-0x104
 8016f66: 4603         	mov	r3, r0
 8016f68: 4619         	mov	r1, r3
 8016f6a: 6878         	ldr	r0, [r7, #0x4]
 8016f6c: f7ff ff6b    	bl	0x8016e46 <z_slist_tail_set> @ imm = #-0x12a
 8016f70: 68fb         	ldr	r3, [r7, #0xc]
 8016f72: 4618         	mov	r0, r3
 8016f74: 3710         	adds	r7, #0x10
 8016f76: 46bd         	mov	sp, r7
 8016f78: bd80         	pop	{r7, pc}

08016f7a <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 8016f7a: b580         	push	{r7, lr}
 8016f7c: b082         	sub	sp, #0x8
 8016f7e: af00         	add	r7, sp, #0x0
 8016f80: 6078         	str	r0, [r7, #0x4]
 8016f82: 6878         	ldr	r0, [r7, #0x4]
 8016f84: f7ff ff85    	bl	0x8016e92 <sys_slist_is_empty> @ imm = #-0xf6
 8016f88: 4603         	mov	r3, r0
 8016f8a: 2b00         	cmp	r3, #0x0
 8016f8c: d104         	bne	0x8016f98 <sys_slist_get+0x1e> @ imm = #0x8
 8016f8e: 6878         	ldr	r0, [r7, #0x4]
 8016f90: f7ff ffcf    	bl	0x8016f32 <sys_slist_get_not_empty> @ imm = #-0x62
 8016f94: 4603         	mov	r3, r0
 8016f96: e000         	b	0x8016f9a <sys_slist_get+0x20> @ imm = #0x0
 8016f98: 2300         	movs	r3, #0x0
 8016f9a: 4618         	mov	r0, r3
 8016f9c: 3708         	adds	r7, #0x8
 8016f9e: 46bd         	mov	sp, r7
 8016fa0: bd80         	pop	{r7, pc}

08016fa2 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 8016fa2: b580         	push	{r7, lr}
 8016fa4: b084         	sub	sp, #0x10
 8016fa6: af00         	add	r7, sp, #0x0
 8016fa8: 60f8         	str	r0, [r7, #0xc]
 8016faa: 60b9         	str	r1, [r7, #0x8]
 8016fac: 607a         	str	r2, [r7, #0x4]
 8016fae: 68bb         	ldr	r3, [r7, #0x8]
 8016fb0: 2b00         	cmp	r3, #0x0
 8016fb2: d117         	bne	0x8016fe4 <sys_slist_remove+0x42> @ imm = #0x2e
 8016fb4: 6878         	ldr	r0, [r7, #0x4]
 8016fb6: f7ff ff1e    	bl	0x8016df6 <z_snode_next_peek> @ imm = #-0x1c4
 8016fba: 4603         	mov	r3, r0
 8016fbc: 4619         	mov	r1, r3
 8016fbe: 68f8         	ldr	r0, [r7, #0xc]
 8016fc0: f7ff ff33    	bl	0x8016e2a <z_slist_head_set> @ imm = #-0x19a
 8016fc4: 68f8         	ldr	r0, [r7, #0xc]
 8016fc6: f7ff ff58    	bl	0x8016e7a <sys_slist_peek_tail> @ imm = #-0x150
 8016fca: 4602         	mov	r2, r0
 8016fcc: 687b         	ldr	r3, [r7, #0x4]
 8016fce: 4293         	cmp	r3, r2
 8016fd0: d11b         	bne	0x801700a <sys_slist_remove+0x68> @ imm = #0x36
 8016fd2: 68f8         	ldr	r0, [r7, #0xc]
 8016fd4: f7ff ff45    	bl	0x8016e62 <sys_slist_peek_head> @ imm = #-0x176
 8016fd8: 4603         	mov	r3, r0
 8016fda: 4619         	mov	r1, r3
 8016fdc: 68f8         	ldr	r0, [r7, #0xc]
 8016fde: f7ff ff32    	bl	0x8016e46 <z_slist_tail_set> @ imm = #-0x19c
 8016fe2: e012         	b	0x801700a <sys_slist_remove+0x68> @ imm = #0x24
 8016fe4: 6878         	ldr	r0, [r7, #0x4]
 8016fe6: f7ff ff06    	bl	0x8016df6 <z_snode_next_peek> @ imm = #-0x1f4
 8016fea: 4603         	mov	r3, r0
 8016fec: 4619         	mov	r1, r3
 8016fee: 68b8         	ldr	r0, [r7, #0x8]
 8016ff0: f7ff ff0d    	bl	0x8016e0e <z_snode_next_set> @ imm = #-0x1e6
 8016ff4: 68f8         	ldr	r0, [r7, #0xc]
 8016ff6: f7ff ff40    	bl	0x8016e7a <sys_slist_peek_tail> @ imm = #-0x180
 8016ffa: 4602         	mov	r2, r0
 8016ffc: 687b         	ldr	r3, [r7, #0x4]
 8016ffe: 4293         	cmp	r3, r2
 8017000: d103         	bne	0x801700a <sys_slist_remove+0x68> @ imm = #0x6
 8017002: 68b9         	ldr	r1, [r7, #0x8]
 8017004: 68f8         	ldr	r0, [r7, #0xc]
 8017006: f7ff ff1e    	bl	0x8016e46 <z_slist_tail_set> @ imm = #-0x1c4
 801700a: 2100         	movs	r1, #0x0
 801700c: 6878         	ldr	r0, [r7, #0x4]
 801700e: f7ff fefe    	bl	0x8016e0e <z_snode_next_set> @ imm = #-0x204
 8017012: 3710         	adds	r7, #0x10
 8017014: 46bd         	mov	sp, r7
 8017016: bd80         	pop	{r7, pc}

08017018 <log_cache_get>:
; {
 8017018: b590         	push	{r4, r7, lr}
 801701a: b089         	sub	sp, #0x24
 801701c: af00         	add	r7, sp, #0x0
 801701e: 60f8         	str	r0, [r7, #0xc]
 8017020: 60b9         	str	r1, [r7, #0x8]
 8017022: 607a         	str	r2, [r7, #0x4]
; 	sys_snode_t *prev_node = NULL;
 8017024: 2300         	movs	r3, #0x0
 8017026: 61fb         	str	r3, [r7, #0x1c]
; 	bool hit = false;
 8017028: 2300         	movs	r3, #0x0
 801702a: 75fb         	strb	r3, [r7, #0x17]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 801702c: 68fb         	ldr	r3, [r7, #0xc]
 801702e: 4618         	mov	r0, r3
 8017030: f7ff ff17    	bl	0x8016e62 <sys_slist_peek_head> @ imm = #-0x1d2
 8017034: 4603         	mov	r3, r0
 8017036: 2b00         	cmp	r3, #0x0
 8017038: d005         	beq	0x8017046 <log_cache_get+0x2e> @ imm = #0xa
 801703a: 68fb         	ldr	r3, [r7, #0xc]
 801703c: 4618         	mov	r0, r3
 801703e: f7ff ff10    	bl	0x8016e62 <sys_slist_peek_head> @ imm = #-0x1e0
 8017042: 4603         	mov	r3, r0
 8017044: e000         	b	0x8017048 <log_cache_get+0x30> @ imm = #0x0
 8017046: 2300         	movs	r3, #0x0
 8017048: 61bb         	str	r3, [r7, #0x18]
 801704a: e02f         	b	0x80170ac <log_cache_get+0x94> @ imm = #0x5e
; 		if (cache->cmp(entry->id, id)) {
 801704c: 68fb         	ldr	r3, [r7, #0xc]
 801704e: 691b         	ldr	r3, [r3, #0x10]
 8017050: 69ba         	ldr	r2, [r7, #0x18]
 8017052: 6852         	ldr	r2, [r2, #0x4]
 8017054: 68b9         	ldr	r1, [r7, #0x8]
 8017056: 4610         	mov	r0, r2
 8017058: 4798         	blx	r3
 801705a: 4603         	mov	r3, r0
 801705c: 2b00         	cmp	r3, #0x0
 801705e: d007         	beq	0x8017070 <log_cache_get+0x58> @ imm = #0xe
; 			cache->hit++;
 8017060: 68fb         	ldr	r3, [r7, #0xc]
 8017062: 695b         	ldr	r3, [r3, #0x14]
 8017064: 1c5a         	adds	r2, r3, #0x1
 8017066: 68fb         	ldr	r3, [r7, #0xc]
 8017068: 615a         	str	r2, [r3, #0x14]
; 			hit = true;
 801706a: 2301         	movs	r3, #0x1
 801706c: 75fb         	strb	r3, [r7, #0x17]
; 			break;
 801706e: e022         	b	0x80170b6 <log_cache_get+0x9e> @ imm = #0x44
; 		if (&entry->node == sys_slist_peek_tail(&cache->active)) {
 8017070: 69bc         	ldr	r4, [r7, #0x18]
 8017072: 68fb         	ldr	r3, [r7, #0xc]
 8017074: 4618         	mov	r0, r3
 8017076: f7ff ff00    	bl	0x8016e7a <sys_slist_peek_tail> @ imm = #-0x200
 801707a: 4603         	mov	r3, r0
 801707c: 429c         	cmp	r4, r3
 801707e: d019         	beq	0x80170b4 <log_cache_get+0x9c> @ imm = #0x32
; 		prev_node = &entry->node;
 8017080: 69bb         	ldr	r3, [r7, #0x18]
 8017082: 61fb         	str	r3, [r7, #0x1c]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 8017084: 69bb         	ldr	r3, [r7, #0x18]
 8017086: 2b00         	cmp	r3, #0x0
 8017088: d00e         	beq	0x80170a8 <log_cache_get+0x90> @ imm = #0x1c
 801708a: 69bb         	ldr	r3, [r7, #0x18]
 801708c: 4618         	mov	r0, r3
 801708e: f7ff ff1d    	bl	0x8016ecc <sys_slist_peek_next> @ imm = #-0x1c6
 8017092: 4603         	mov	r3, r0
 8017094: 2b00         	cmp	r3, #0x0
 8017096: d005         	beq	0x80170a4 <log_cache_get+0x8c> @ imm = #0xa
 8017098: 69bb         	ldr	r3, [r7, #0x18]
 801709a: 4618         	mov	r0, r3
 801709c: f7ff ff16    	bl	0x8016ecc <sys_slist_peek_next> @ imm = #-0x1d4
 80170a0: 4603         	mov	r3, r0
 80170a2: e002         	b	0x80170aa <log_cache_get+0x92> @ imm = #0x4
 80170a4: 2300         	movs	r3, #0x0
 80170a6: e000         	b	0x80170aa <log_cache_get+0x92> @ imm = #0x0
 80170a8: 2300         	movs	r3, #0x0
 80170aa: 61bb         	str	r3, [r7, #0x18]
 80170ac: 69bb         	ldr	r3, [r7, #0x18]
 80170ae: 2b00         	cmp	r3, #0x0
 80170b0: d1cc         	bne	0x801704c <log_cache_get+0x34> @ imm = #-0x68
 80170b2: e000         	b	0x80170b6 <log_cache_get+0x9e> @ imm = #0x0
; 			break;
 80170b4: bf00         	nop
; 	if (hit) {
 80170b6: 7dfb         	ldrb	r3, [r7, #0x17]
 80170b8: 2b00         	cmp	r3, #0x0
 80170ba: d00c         	beq	0x80170d6 <log_cache_get+0xbe> @ imm = #0x18
; 		sys_slist_remove(&cache->active, prev_node, &entry->node);
 80170bc: 68fb         	ldr	r3, [r7, #0xc]
 80170be: 69ba         	ldr	r2, [r7, #0x18]
 80170c0: 69f9         	ldr	r1, [r7, #0x1c]
 80170c2: 4618         	mov	r0, r3
 80170c4: f7ff ff6d    	bl	0x8016fa2 <sys_slist_remove> @ imm = #-0x126
; 		sys_slist_prepend(&cache->active, &entry->node);
 80170c8: 68fb         	ldr	r3, [r7, #0xc]
 80170ca: 69ba         	ldr	r2, [r7, #0x18]
 80170cc: 4611         	mov	r1, r2
 80170ce: 4618         	mov	r0, r3
 80170d0: f7ff ff0d    	bl	0x8016eee <sys_slist_prepend> @ imm = #-0x1e6
 80170d4: e016         	b	0x8017104 <log_cache_get+0xec> @ imm = #0x2c
; 		cache->miss++;
 80170d6: 68fb         	ldr	r3, [r7, #0xc]
 80170d8: 699b         	ldr	r3, [r3, #0x18]
 80170da: 1c5a         	adds	r2, r3, #0x1
 80170dc: 68fb         	ldr	r3, [r7, #0xc]
 80170de: 619a         	str	r2, [r3, #0x18]
; 		sys_snode_t *from_idle = sys_slist_get(&cache->idle);
 80170e0: 68fb         	ldr	r3, [r7, #0xc]
 80170e2: 3308         	adds	r3, #0x8
 80170e4: 4618         	mov	r0, r3
 80170e6: f7ff ff48    	bl	0x8016f7a <sys_slist_get> @ imm = #-0x170
 80170ea: 6138         	str	r0, [r7, #0x10]
; 		if (from_idle) {
 80170ec: 693b         	ldr	r3, [r7, #0x10]
 80170ee: 2b00         	cmp	r3, #0x0
 80170f0: d002         	beq	0x80170f8 <log_cache_get+0xe0> @ imm = #0x4
; 			entry = CONTAINER_OF(from_idle, struct log_cache_entry, node);
 80170f2: 693b         	ldr	r3, [r7, #0x10]
 80170f4: 61bb         	str	r3, [r7, #0x18]
 80170f6: e005         	b	0x8017104 <log_cache_get+0xec> @ imm = #0xa
; 			sys_slist_remove(&cache->active, prev_node, &entry->node);
 80170f8: 68fb         	ldr	r3, [r7, #0xc]
 80170fa: 69ba         	ldr	r2, [r7, #0x18]
 80170fc: 69f9         	ldr	r1, [r7, #0x1c]
 80170fe: 4618         	mov	r0, r3
 8017100: f7ff ff4f    	bl	0x8016fa2 <sys_slist_remove> @ imm = #-0x162
; 	*data = entry->data;
 8017104: 69bb         	ldr	r3, [r7, #0x18]
 8017106: f103 0208    	add.w	r2, r3, #0x8
 801710a: 687b         	ldr	r3, [r7, #0x4]
 801710c: 601a         	str	r2, [r3]
; 	entry->id = id;
 801710e: 69bb         	ldr	r3, [r7, #0x18]
 8017110: 68ba         	ldr	r2, [r7, #0x8]
 8017112: 605a         	str	r2, [r3, #0x4]
; 	return hit;
 8017114: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 8017116: 4618         	mov	r0, r3
 8017118: 3724         	adds	r7, #0x24
 801711a: 46bd         	mov	sp, r7
 801711c: bd90         	pop	{r4, r7, pc}

0801711e <log_cache_put>:
; {
 801711e: b580         	push	{r7, lr}
 8017120: b084         	sub	sp, #0x10
 8017122: af00         	add	r7, sp, #0x0
 8017124: 6078         	str	r0, [r7, #0x4]
 8017126: 6039         	str	r1, [r7]
; 	struct log_cache_entry *entry = CONTAINER_OF(data, struct log_cache_entry, data[0]);
 8017128: 683b         	ldr	r3, [r7]
 801712a: 3b08         	subs	r3, #0x8
 801712c: 60fb         	str	r3, [r7, #0xc]
; 	sys_slist_prepend(&cache->active, &entry->node);
 801712e: 687b         	ldr	r3, [r7, #0x4]
 8017130: 68fa         	ldr	r2, [r7, #0xc]
 8017132: 4611         	mov	r1, r2
 8017134: 4618         	mov	r0, r3
 8017136: f7ff feda    	bl	0x8016eee <sys_slist_prepend> @ imm = #-0x24c
; }
 801713a: bf00         	nop
 801713c: 3710         	adds	r7, #0x10
 801713e: 46bd         	mov	sp, r7
 8017140: bd80         	pop	{r7, pc}

08017142 <z_log_msg_runtime_create>:
; {
 8017142: b580         	push	{r7, lr}
 8017144: b08a         	sub	sp, #0x28
 8017146: af04         	add	r7, sp, #0x10
 8017148: 60b9         	str	r1, [r7, #0x8]
 801714a: 607b         	str	r3, [r7, #0x4]
 801714c: 4603         	mov	r3, r0
 801714e: 73fb         	strb	r3, [r7, #0xf]
 8017150: 4613         	mov	r3, r2
 8017152: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8017154: f107 032c    	add.w	r3, r7, #0x2c
 8017158: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801715a: 7bba         	ldrb	r2, [r7, #0xe]
 801715c: 7bf8         	ldrb	r0, [r7, #0xf]
 801715e: 697b         	ldr	r3, [r7, #0x14]
 8017160: 9303         	str	r3, [sp, #0xc]
 8017162: 6abb         	ldr	r3, [r7, #0x28]
 8017164: 9302         	str	r3, [sp, #0x8]
 8017166: 6a7b         	ldr	r3, [r7, #0x24]
 8017168: 9301         	str	r3, [sp, #0x4]
 801716a: 6a3b         	ldr	r3, [r7, #0x20]
 801716c: 9300         	str	r3, [sp]
 801716e: 687b         	ldr	r3, [r7, #0x4]
 8017170: 68b9         	ldr	r1, [r7, #0x8]
 8017172: f7ee f9ff    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x11c02
; }
 8017176: bf00         	nop
 8017178: 3718         	adds	r7, #0x18
 801717a: 46bd         	mov	sp, r7
 801717c: bd80         	pop	{r7, pc}

0801717e <log_msg_get_domain>:
; {
 801717e: b480         	push	{r7}
 8017180: b083         	sub	sp, #0xc
 8017182: af00         	add	r7, sp, #0x0
 8017184: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 8017186: 687b         	ldr	r3, [r7, #0x4]
 8017188: 781b         	ldrb	r3, [r3]
 801718a: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 801718e: b2db         	uxtb	r3, r3
; }
 8017190: 4618         	mov	r0, r3
 8017192: 370c         	adds	r7, #0xc
 8017194: 46bd         	mov	sp, r7
 8017196: f85d 7b04    	ldr	r7, [sp], #4
 801719a: 4770         	bx	lr

0801719c <log_msg_get_source>:
; {
 801719c: b480         	push	{r7}
 801719e: b083         	sub	sp, #0xc
 80171a0: af00         	add	r7, sp, #0x0
 80171a2: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.source;
 80171a4: 687b         	ldr	r3, [r7, #0x4]
 80171a6: 685b         	ldr	r3, [r3, #0x4]
; }
 80171a8: 4618         	mov	r0, r3
 80171aa: 370c         	adds	r7, #0xc
 80171ac: 46bd         	mov	sp, r7
 80171ae: f85d 7b04    	ldr	r7, [sp], #4
 80171b2: 4770         	bx	lr

080171b4 <log_source_id>:
; {
 80171b4: b580         	push	{r7, lr}
 80171b6: b082         	sub	sp, #0x8
 80171b8: af00         	add	r7, sp, #0x0
 80171ba: 6078         	str	r0, [r7, #0x4]
; 		log_dynamic_source_id((struct log_source_dynamic_data *)source) :
 80171bc: 6878         	ldr	r0, [r7, #0x4]
 80171be: f7ee f9c9    	bl	0x8005554 <log_const_source_id> @ imm = #-0x11c6e
 80171c2: 4603         	mov	r3, r0
; }
 80171c4: 4618         	mov	r0, r3
 80171c6: 3708         	adds	r7, #0x8
 80171c8: 46bd         	mov	sp, r7
 80171ca: bd80         	pop	{r7, pc}

080171cc <z_log_is_local_domain>:
; {
 80171cc: b480         	push	{r7}
 80171ce: b083         	sub	sp, #0xc
 80171d0: af00         	add	r7, sp, #0x0
 80171d2: 4603         	mov	r3, r0
 80171d4: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 80171d6: 2301         	movs	r3, #0x1
; }
 80171d8: 4618         	mov	r0, r3
 80171da: 370c         	adds	r7, #0xc
 80171dc: 46bd         	mov	sp, r7
 80171de: f85d 7b04    	ldr	r7, [sp], #4
 80171e2: 4770         	bx	lr

080171e4 <z_log_msg_finalize>:
; {
 80171e4: b580         	push	{r7, lr}
 80171e6: b086         	sub	sp, #0x18
 80171e8: af00         	add	r7, sp, #0x0
 80171ea: 60f8         	str	r0, [r7, #0xc]
 80171ec: 60b9         	str	r1, [r7, #0x8]
 80171ee: 607a         	str	r2, [r7, #0x4]
 80171f0: 603b         	str	r3, [r7]
; 	if (!msg) {
 80171f2: 68fb         	ldr	r3, [r7, #0xc]
 80171f4: 2b00         	cmp	r3, #0x0
 80171f6: d103         	bne	0x8017200 <z_log_msg_finalize+0x1c> @ imm = #0x6
; 		z_log_dropped(false);
 80171f8: 2000         	movs	r0, #0x0
 80171fa: f7ee f8ad    	bl	0x8005358 <z_log_dropped> @ imm = #-0x11ea6
; 		return;
 80171fe: e01c         	b	0x801723a <z_log_msg_finalize+0x56> @ imm = #0x38
; 	if (data) {
 8017200: 683b         	ldr	r3, [r7]
 8017202: 2b00         	cmp	r3, #0x0
 8017204: d010         	beq	0x8017228 <z_log_msg_finalize+0x44> @ imm = #0x20
; 		uint8_t *d = msg->data + desc.package_len;
 8017206: 68fb         	ldr	r3, [r7, #0xc]
 8017208: 3310         	adds	r3, #0x10
 801720a: 687a         	ldr	r2, [r7, #0x4]
 801720c: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 8017210: b292         	uxth	r2, r2
 8017212: 4413         	add	r3, r2
 8017214: 617b         	str	r3, [r7, #0x14]
; 		memcpy(d, data, desc.data_len);
 8017216: 88fb         	ldrh	r3, [r7, #0x6]
 8017218: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 801721c: b29b         	uxth	r3, r3
 801721e: 461a         	mov	r2, r3
 8017220: 6839         	ldr	r1, [r7]
 8017222: 6978         	ldr	r0, [r7, #0x14]
 8017224: f008 fd4a    	bl	0x801fcbc <memcpy>      @ imm = #0x8a94
; 	msg->hdr.desc = desc;
 8017228: 68fb         	ldr	r3, [r7, #0xc]
 801722a: 687a         	ldr	r2, [r7, #0x4]
 801722c: 601a         	str	r2, [r3]
; 	msg->hdr.source = source;
 801722e: 68fb         	ldr	r3, [r7, #0xc]
 8017230: 68ba         	ldr	r2, [r7, #0x8]
 8017232: 605a         	str	r2, [r3, #0x4]
; 	z_log_msg_commit(msg);
 8017234: 68f8         	ldr	r0, [r7, #0xc]
 8017236: f7ee f8a5    	bl	0x8005384 <z_log_msg_commit> @ imm = #-0x11eb6
; }
 801723a: 3718         	adds	r7, #0x18
 801723c: 46bd         	mov	sp, r7
 801723e: bd80         	pop	{r7, pc}

08017240 <log_msg_get_source_id>:
; {
 8017240: b580         	push	{r7, lr}
 8017242: b084         	sub	sp, #0x10
 8017244: af00         	add	r7, sp, #0x0
 8017246: 6078         	str	r0, [r7, #0x4]
; 	if (!z_log_is_local_domain(log_msg_get_domain(msg))) {
 8017248: 6878         	ldr	r0, [r7, #0x4]
 801724a: f7ff ff98    	bl	0x801717e <log_msg_get_domain> @ imm = #-0xd0
 801724e: 4603         	mov	r3, r0
 8017250: 4618         	mov	r0, r3
 8017252: f7ff ffbb    	bl	0x80171cc <z_log_is_local_domain> @ imm = #-0x8a
 8017256: 4603         	mov	r3, r0
 8017258: f083 0301    	eor	r3, r3, #0x1
 801725c: b2db         	uxtb	r3, r3
 801725e: 2b00         	cmp	r3, #0x0
 8017260: d005         	beq	0x801726e <log_msg_get_source_id+0x2e> @ imm = #0xa
; 		return (int16_t)(uintptr_t)log_msg_get_source(msg);
 8017262: 6878         	ldr	r0, [r7, #0x4]
 8017264: f7ff ff9a    	bl	0x801719c <log_msg_get_source> @ imm = #-0xcc
 8017268: 4603         	mov	r3, r0
 801726a: b21b         	sxth	r3, r3
 801726c: e00e         	b	0x801728c <log_msg_get_source_id+0x4c> @ imm = #0x1c
; 	void *source = (void *)log_msg_get_source(msg);
 801726e: 6878         	ldr	r0, [r7, #0x4]
 8017270: f7ff ff94    	bl	0x801719c <log_msg_get_source> @ imm = #-0xd8
 8017274: 60f8         	str	r0, [r7, #0xc]
; 	if (source != NULL) {
 8017276: 68fb         	ldr	r3, [r7, #0xc]
 8017278: 2b00         	cmp	r3, #0x0
 801727a: d005         	beq	0x8017288 <log_msg_get_source_id+0x48> @ imm = #0xa
; 		return log_source_id(source);
 801727c: 68f8         	ldr	r0, [r7, #0xc]
 801727e: f7ff ff99    	bl	0x80171b4 <log_source_id> @ imm = #-0xce
 8017282: 4603         	mov	r3, r0
 8017284: b21b         	sxth	r3, r3
 8017286: e001         	b	0x801728c <log_msg_get_source_id+0x4c> @ imm = #0x2
; 	return -1;
 8017288: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 801728c: 4618         	mov	r0, r3
 801728e: 3710         	adds	r7, #0x10
 8017290: 46bd         	mov	sp, r7
 8017292: bd80         	pop	{r7, pc}

08017294 <log_msg_get_domain>:
; {
 8017294: b480         	push	{r7}
 8017296: b083         	sub	sp, #0xc
 8017298: af00         	add	r7, sp, #0x0
 801729a: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 801729c: 687b         	ldr	r3, [r7, #0x4]
 801729e: 781b         	ldrb	r3, [r3]
 80172a0: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 80172a4: b2db         	uxtb	r3, r3
; }
 80172a6: 4618         	mov	r0, r3
 80172a8: 370c         	adds	r7, #0xc
 80172aa: 46bd         	mov	sp, r7
 80172ac: f85d 7b04    	ldr	r7, [sp], #4
 80172b0: 4770         	bx	lr

080172b2 <log_msg_get_level>:
; {
 80172b2: b480         	push	{r7}
 80172b4: b083         	sub	sp, #0xc
 80172b6: af00         	add	r7, sp, #0x0
 80172b8: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.level;
 80172ba: 687b         	ldr	r3, [r7, #0x4]
 80172bc: 881b         	ldrh	r3, [r3]
 80172be: f3c3 1382    	ubfx	r3, r3, #0x6, #0x3
 80172c2: b2db         	uxtb	r3, r3
; }
 80172c4: 4618         	mov	r0, r3
 80172c6: 370c         	adds	r7, #0xc
 80172c8: 46bd         	mov	sp, r7
 80172ca: f85d 7b04    	ldr	r7, [sp], #4
 80172ce: 4770         	bx	lr

080172d0 <log_msg_get_timestamp>:
; {
 80172d0: b480         	push	{r7}
 80172d2: b083         	sub	sp, #0xc
 80172d4: af00         	add	r7, sp, #0x0
 80172d6: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.timestamp;
 80172d8: 687b         	ldr	r3, [r7, #0x4]
 80172da: 689b         	ldr	r3, [r3, #0x8]
; }
 80172dc: 4618         	mov	r0, r3
 80172de: 370c         	adds	r7, #0xc
 80172e0: 46bd         	mov	sp, r7
 80172e2: f85d 7b04    	ldr	r7, [sp], #4
 80172e6: 4770         	bx	lr

080172e8 <log_msg_get_tid>:
; {
 80172e8: b480         	push	{r7}
 80172ea: b083         	sub	sp, #0xc
 80172ec: af00         	add	r7, sp, #0x0
 80172ee: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 80172f0: 2300         	movs	r3, #0x0
; }
 80172f2: 4618         	mov	r0, r3
 80172f4: 370c         	adds	r7, #0xc
 80172f6: 46bd         	mov	sp, r7
 80172f8: f85d 7b04    	ldr	r7, [sp], #4
 80172fc: 4770         	bx	lr

080172fe <log_msg_get_data>:
; {
 80172fe: b480         	push	{r7}
 8017300: b083         	sub	sp, #0xc
 8017302: af00         	add	r7, sp, #0x0
 8017304: 6078         	str	r0, [r7, #0x4]
 8017306: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.data_len;
 8017308: 687b         	ldr	r3, [r7, #0x4]
 801730a: 885b         	ldrh	r3, [r3, #0x2]
 801730c: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 8017310: b29b         	uxth	r3, r3
 8017312: 461a         	mov	r2, r3
 8017314: 683b         	ldr	r3, [r7]
 8017316: 601a         	str	r2, [r3]
; 	return msg->data + msg->hdr.desc.package_len;
 8017318: 687b         	ldr	r3, [r7, #0x4]
 801731a: 3310         	adds	r3, #0x10
 801731c: 687a         	ldr	r2, [r7, #0x4]
 801731e: 6812         	ldr	r2, [r2]
 8017320: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 8017324: b292         	uxth	r2, r2
 8017326: 4413         	add	r3, r2
; }
 8017328: 4618         	mov	r0, r3
 801732a: 370c         	adds	r7, #0xc
 801732c: 46bd         	mov	sp, r7
 801732e: f85d 7b04    	ldr	r7, [sp], #4
 8017332: 4770         	bx	lr

08017334 <log_msg_get_package>:
; {
 8017334: b480         	push	{r7}
 8017336: b083         	sub	sp, #0xc
 8017338: af00         	add	r7, sp, #0x0
 801733a: 6078         	str	r0, [r7, #0x4]
 801733c: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.package_len;
 801733e: 687b         	ldr	r3, [r7, #0x4]
 8017340: 681b         	ldr	r3, [r3]
 8017342: f3c3 234a    	ubfx	r3, r3, #0x9, #0xb
 8017346: b29b         	uxth	r3, r3
 8017348: 461a         	mov	r2, r3
 801734a: 683b         	ldr	r3, [r7]
 801734c: 601a         	str	r2, [r3]
; 	return msg->data;
 801734e: 687b         	ldr	r3, [r7, #0x4]
 8017350: 3310         	adds	r3, #0x10
; }
 8017352: 4618         	mov	r0, r3
 8017354: 370c         	adds	r7, #0xc
 8017356: 46bd         	mov	sp, r7
 8017358: f85d 7b04    	ldr	r7, [sp], #4
 801735c: 4770         	bx	lr

0801735e <log_output_write>:
; {
 801735e: b580         	push	{r7, lr}
 8017360: b086         	sub	sp, #0x18
 8017362: af00         	add	r7, sp, #0x0
 8017364: 60f8         	str	r0, [r7, #0xc]
 8017366: 60b9         	str	r1, [r7, #0x8]
 8017368: 607a         	str	r2, [r7, #0x4]
 801736a: 603b         	str	r3, [r7]
; 	while (len != 0) {
 801736c: e00d         	b	0x801738a <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 801736e: 68fb         	ldr	r3, [r7, #0xc]
 8017370: 683a         	ldr	r2, [r7]
 8017372: 6879         	ldr	r1, [r7, #0x4]
 8017374: 68b8         	ldr	r0, [r7, #0x8]
 8017376: 4798         	blx	r3
 8017378: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 801737a: 697b         	ldr	r3, [r7, #0x14]
 801737c: 687a         	ldr	r2, [r7, #0x4]
 801737e: 1ad3         	subs	r3, r2, r3
 8017380: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 8017382: 697b         	ldr	r3, [r7, #0x14]
 8017384: 68ba         	ldr	r2, [r7, #0x8]
 8017386: 4413         	add	r3, r2
 8017388: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 801738a: 687b         	ldr	r3, [r7, #0x4]
 801738c: 2b00         	cmp	r3, #0x0
 801738e: d1ee         	bne	0x801736e <log_output_write+0x10> @ imm = #-0x24
; }
 8017390: bf00         	nop
 8017392: bf00         	nop
 8017394: 3718         	adds	r7, #0x18
 8017396: 46bd         	mov	sp, r7
 8017398: bd80         	pop	{r7, pc}

0801739a <log_output_flush>:
; {
 801739a: b580         	push	{r7, lr}
 801739c: b082         	sub	sp, #0x8
 801739e: af00         	add	r7, sp, #0x0
 80173a0: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 80173a2: 687b         	ldr	r3, [r7, #0x4]
 80173a4: 6818         	ldr	r0, [r3]
 80173a6: 687b         	ldr	r3, [r7, #0x4]
 80173a8: 6899         	ldr	r1, [r3, #0x8]
 80173aa: 687b         	ldr	r3, [r7, #0x4]
 80173ac: 685b         	ldr	r3, [r3, #0x4]
 80173ae: 681b         	ldr	r3, [r3]
 80173b0: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 80173b2: 687b         	ldr	r3, [r7, #0x4]
 80173b4: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 80173b6: 685b         	ldr	r3, [r3, #0x4]
 80173b8: f7ff ffd1    	bl	0x801735e <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 80173bc: 687b         	ldr	r3, [r7, #0x4]
 80173be: 685b         	ldr	r3, [r3, #0x4]
 80173c0: 2200         	movs	r2, #0x0
 80173c2: 601a         	str	r2, [r3]
; }
 80173c4: bf00         	nop
 80173c6: 3708         	adds	r7, #0x8
 80173c8: 46bd         	mov	sp, r7
 80173ca: bd80         	pop	{r7, pc}

080173cc <out_func>:
; {
 80173cc: b580         	push	{r7, lr}
 80173ce: b084         	sub	sp, #0x10
 80173d0: af00         	add	r7, sp, #0x0
 80173d2: 6078         	str	r0, [r7, #0x4]
 80173d4: 6039         	str	r1, [r7]
; 	const struct log_output *out_ctx = (const struct log_output *)ctx;
 80173d6: 683b         	ldr	r3, [r7]
 80173d8: 60fb         	str	r3, [r7, #0xc]
; 		char x = (char)c;
 80173da: 687b         	ldr	r3, [r7, #0x4]
 80173dc: b2db         	uxtb	r3, r3
 80173de: 72fb         	strb	r3, [r7, #0xb]
; 		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
 80173e0: 68fb         	ldr	r3, [r7, #0xc]
 80173e2: 681b         	ldr	r3, [r3]
 80173e4: 68fa         	ldr	r2, [r7, #0xc]
 80173e6: 6852         	ldr	r2, [r2, #0x4]
 80173e8: 6852         	ldr	r2, [r2, #0x4]
 80173ea: f107 000b    	add.w	r0, r7, #0xb
 80173ee: 2101         	movs	r1, #0x1
 80173f0: 4798         	blx	r3
; 		return 0;
 80173f2: 2300         	movs	r3, #0x0
; }
 80173f4: 4618         	mov	r0, r3
 80173f6: 3710         	adds	r7, #0x10
 80173f8: 46bd         	mov	sp, r7
 80173fa: bd80         	pop	{r7, pc}

080173fc <cr_out_func>:
; {
 80173fc: b580         	push	{r7, lr}
 80173fe: b082         	sub	sp, #0x8
 8017400: af00         	add	r7, sp, #0x0
 8017402: 6078         	str	r0, [r7, #0x4]
 8017404: 6039         	str	r1, [r7]
; 	if (c == '\n') {
 8017406: 687b         	ldr	r3, [r7, #0x4]
 8017408: 2b0a         	cmp	r3, #0xa
 801740a: d103         	bne	0x8017414 <cr_out_func+0x18> @ imm = #0x6
; 		out_func((int)'\r', ctx);
 801740c: 6839         	ldr	r1, [r7]
 801740e: 200d         	movs	r0, #0xd
 8017410: f7ff ffdc    	bl	0x80173cc <out_func>    @ imm = #-0x48
; 	out_func(c, ctx);
 8017414: 6839         	ldr	r1, [r7]
 8017416: 6878         	ldr	r0, [r7, #0x4]
 8017418: f7ff ffd8    	bl	0x80173cc <out_func>    @ imm = #-0x50
; 	return 0;
 801741c: 2300         	movs	r3, #0x0
; }
 801741e: 4618         	mov	r0, r3
 8017420: 3708         	adds	r7, #0x8
 8017422: 46bd         	mov	sp, r7
 8017424: bd80         	pop	{r7, pc}

08017426 <color_prefix>:
; {
 8017426: b580         	push	{r7, lr}
 8017428: b084         	sub	sp, #0x10
 801742a: af00         	add	r7, sp, #0x0
 801742c: 60f8         	str	r0, [r7, #0xc]
 801742e: 460b         	mov	r3, r1
 8017430: 607a         	str	r2, [r7, #0x4]
 8017432: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, true, level);
 8017434: 7af9         	ldrb	r1, [r7, #0xb]
 8017436: 687b         	ldr	r3, [r7, #0x4]
 8017438: 2201         	movs	r2, #0x1
 801743a: 68f8         	ldr	r0, [r7, #0xc]
 801743c: f7ee fa0c    	bl	0x8005858 <color_print> @ imm = #-0x11be8
; }
 8017440: bf00         	nop
 8017442: 3710         	adds	r7, #0x10
 8017444: 46bd         	mov	sp, r7
 8017446: bd80         	pop	{r7, pc}

08017448 <color_postfix>:
; {
 8017448: b580         	push	{r7, lr}
 801744a: b084         	sub	sp, #0x10
 801744c: af00         	add	r7, sp, #0x0
 801744e: 60f8         	str	r0, [r7, #0xc]
 8017450: 460b         	mov	r3, r1
 8017452: 607a         	str	r2, [r7, #0x4]
 8017454: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, false, level);
 8017456: 7af9         	ldrb	r1, [r7, #0xb]
 8017458: 687b         	ldr	r3, [r7, #0x4]
 801745a: 2200         	movs	r2, #0x0
 801745c: 68f8         	ldr	r0, [r7, #0xc]
 801745e: f7ee f9fb    	bl	0x8005858 <color_print> @ imm = #-0x11c0a
; }
 8017462: bf00         	nop
 8017464: 3710         	adds	r7, #0x10
 8017466: 46bd         	mov	sp, r7
 8017468: bd80         	pop	{r7, pc}

0801746a <log_msg_hexdump>:
; {
 801746a: b580         	push	{r7, lr}
 801746c: b088         	sub	sp, #0x20
 801746e: af02         	add	r7, sp, #0x8
 8017470: 60f8         	str	r0, [r7, #0xc]
 8017472: 60b9         	str	r1, [r7, #0x8]
 8017474: 607a         	str	r2, [r7, #0x4]
 8017476: 603b         	str	r3, [r7]
; 		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 8017478: 687b         	ldr	r3, [r7, #0x4]
 801747a: 2b10         	cmp	r3, #0x10
 801747c: bf28         	it	hs
 801747e: 2310         	movhs	r3, #0x10
 8017480: 617b         	str	r3, [r7, #0x14]
; 		hexdump_line_print(output, data, length,
 8017482: 6a3b         	ldr	r3, [r7, #0x20]
 8017484: 9300         	str	r3, [sp]
 8017486: 683b         	ldr	r3, [r7]
 8017488: 697a         	ldr	r2, [r7, #0x14]
 801748a: 68b9         	ldr	r1, [r7, #0x8]
 801748c: 68f8         	ldr	r0, [r7, #0xc]
 801748e: f7ee fa81    	bl	0x8005994 <hexdump_line_print> @ imm = #-0x11afe
; 		data += length;
 8017492: 68ba         	ldr	r2, [r7, #0x8]
 8017494: 697b         	ldr	r3, [r7, #0x14]
 8017496: 4413         	add	r3, r2
 8017498: 60bb         	str	r3, [r7, #0x8]
; 		len -= length;
 801749a: 687a         	ldr	r2, [r7, #0x4]
 801749c: 697b         	ldr	r3, [r7, #0x14]
 801749e: 1ad3         	subs	r3, r2, r3
 80174a0: 607b         	str	r3, [r7, #0x4]
; 	} while (len);
 80174a2: 687b         	ldr	r3, [r7, #0x4]
 80174a4: 2b00         	cmp	r3, #0x0
 80174a6: d1e7         	bne	0x8017478 <log_msg_hexdump+0xe> @ imm = #-0x32
; }
 80174a8: bf00         	nop
 80174aa: bf00         	nop
 80174ac: 3718         	adds	r7, #0x18
 80174ae: 46bd         	mov	sp, r7
 80174b0: bd80         	pop	{r7, pc}

080174b2 <postfix_print>:
; {
 80174b2: b580         	push	{r7, lr}
 80174b4: b084         	sub	sp, #0x10
 80174b6: af00         	add	r7, sp, #0x0
 80174b8: 60f8         	str	r0, [r7, #0xc]
 80174ba: 60b9         	str	r1, [r7, #0x8]
 80174bc: 4613         	mov	r3, r2
 80174be: 71fb         	strb	r3, [r7, #0x7]
; 	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
 80174c0: 68bb         	ldr	r3, [r7, #0x8]
 80174c2: f003 0301    	and	r3, r3, #0x1
 80174c6: 2b00         	cmp	r3, #0x0
 80174c8: bf14         	ite	ne
 80174ca: 2301         	movne	r3, #0x1
 80174cc: 2300         	moveq	r3, #0x0
 80174ce: b2db         	uxtb	r3, r3
 80174d0: 79fa         	ldrb	r2, [r7, #0x7]
 80174d2: 4619         	mov	r1, r3
 80174d4: 68f8         	ldr	r0, [r7, #0xc]
 80174d6: f7ff ffb7    	bl	0x8017448 <color_postfix> @ imm = #-0x92
; 	newline_print(output, flags);
 80174da: 68b9         	ldr	r1, [r7, #0x8]
 80174dc: 68f8         	ldr	r0, [r7, #0xc]
 80174de: f7ee fa37    	bl	0x8005950 <newline_print> @ imm = #-0x11b92
; }
 80174e2: bf00         	nop
 80174e4: 3710         	adds	r7, #0x10
 80174e6: 46bd         	mov	sp, r7
 80174e8: bd80         	pop	{r7, pc}

080174ea <log_output_msg_process>:
; {
 80174ea: b580         	push	{r7, lr}
 80174ec: b092         	sub	sp, #0x48
 80174ee: af06         	add	r7, sp, #0x18
 80174f0: 60f8         	str	r0, [r7, #0xc]
 80174f2: 60b9         	str	r1, [r7, #0x8]
 80174f4: 607a         	str	r2, [r7, #0x4]
; 	log_timestamp_t timestamp = log_msg_get_timestamp(msg);
 80174f6: 68b8         	ldr	r0, [r7, #0x8]
 80174f8: f7ff feea    	bl	0x80172d0 <log_msg_get_timestamp> @ imm = #-0x22c
 80174fc: 62f8         	str	r0, [r7, #0x2c]
; 	uint8_t level = log_msg_get_level(msg);
 80174fe: 68b8         	ldr	r0, [r7, #0x8]
 8017500: f7ff fed7    	bl	0x80172b2 <log_msg_get_level> @ imm = #-0x252
 8017504: 4603         	mov	r3, r0
 8017506: f887 302b    	strb.w	r3, [r7, #0x2b]
; 	uint8_t domain_id = log_msg_get_domain(msg);
 801750a: 68b8         	ldr	r0, [r7, #0x8]
 801750c: f7ff fec2    	bl	0x8017294 <log_msg_get_domain> @ imm = #-0x27c
 8017510: 4603         	mov	r3, r0
 8017512: f887 302a    	strb.w	r3, [r7, #0x2a]
; 	int16_t source_id = log_msg_get_source_id(msg);
 8017516: 68b8         	ldr	r0, [r7, #0x8]
 8017518: f7ff fe92    	bl	0x8017240 <log_msg_get_source_id> @ imm = #-0x2dc
 801751c: 4603         	mov	r3, r0
 801751e: 853b         	strh	r3, [r7, #0x28]
; 	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
 8017520: f9b7 3028    	ldrsh.w	r3, [r7, #0x28]
 8017524: 2b00         	cmp	r3, #0x0
 8017526: db09         	blt	0x801753c <log_output_msg_process+0x52> @ imm = #0x12
 8017528: f897 302a    	ldrb.w	r3, [r7, #0x2a]
 801752c: f9b7 2028    	ldrsh.w	r2, [r7, #0x28]
 8017530: 4611         	mov	r1, r2
 8017532: 4618         	mov	r0, r3
 8017534: f7ed ffe6    	bl	0x8005504 <log_source_name_get> @ imm = #-0x12034
 8017538: 4603         	mov	r3, r0
 801753a: e000         	b	0x801753e <log_output_msg_process+0x54> @ imm = #0x0
 801753c: 2300         	movs	r3, #0x0
 801753e: 627b         	str	r3, [r7, #0x24]
; 	uint8_t *package = log_msg_get_package(msg, &plen);
 8017540: f107 0318    	add.w	r3, r7, #0x18
 8017544: 4619         	mov	r1, r3
 8017546: 68b8         	ldr	r0, [r7, #0x8]
 8017548: f7ff fef4    	bl	0x8017334 <log_msg_get_package> @ imm = #-0x218
 801754c: 6238         	str	r0, [r7, #0x20]
; 	uint8_t *data = log_msg_get_data(msg, &dlen);
 801754e: f107 0314    	add.w	r3, r7, #0x14
 8017552: 4619         	mov	r1, r3
 8017554: 68b8         	ldr	r0, [r7, #0x8]
 8017556: f7ff fed2    	bl	0x80172fe <log_msg_get_data> @ imm = #-0x25c
 801755a: 61f8         	str	r0, [r7, #0x1c]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 801755c: 68b8         	ldr	r0, [r7, #0x8]
 801755e: f7ff fec3    	bl	0x80172e8 <log_msg_get_tid> @ imm = #-0x27a
; 			   plen > 0 ? package : NULL, data, dlen, flags);
 8017562: 69bb         	ldr	r3, [r7, #0x18]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 8017564: 2b00         	cmp	r3, #0x0
 8017566: d001         	beq	0x801756c <log_output_msg_process+0x82> @ imm = #0x2
 8017568: 6a3b         	ldr	r3, [r7, #0x20]
 801756a: e000         	b	0x801756e <log_output_msg_process+0x84> @ imm = #0x0
 801756c: 2300         	movs	r3, #0x0
 801756e: 697a         	ldr	r2, [r7, #0x14]
 8017570: 6879         	ldr	r1, [r7, #0x4]
 8017572: 9105         	str	r1, [sp, #0x14]
 8017574: 9204         	str	r2, [sp, #0x10]
 8017576: 69fa         	ldr	r2, [r7, #0x1c]
 8017578: 9203         	str	r2, [sp, #0xc]
 801757a: 9302         	str	r3, [sp, #0x8]
 801757c: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8017580: 9301         	str	r3, [sp, #0x4]
 8017582: 9000         	str	r0, [sp]
 8017584: 6a7b         	ldr	r3, [r7, #0x24]
 8017586: 2200         	movs	r2, #0x0
 8017588: 6af9         	ldr	r1, [r7, #0x2c]
 801758a: 68f8         	ldr	r0, [r7, #0xc]
 801758c: f7ee fafc    	bl	0x8005b88 <log_output_process> @ imm = #-0x11a08
; }
 8017590: bf00         	nop
 8017592: 3730         	adds	r7, #0x30
 8017594: 46bd         	mov	sp, r7
 8017596: bd80         	pop	{r7, pc}

08017598 <log_output_write>:
; {
 8017598: b580         	push	{r7, lr}
 801759a: b086         	sub	sp, #0x18
 801759c: af00         	add	r7, sp, #0x0
 801759e: 60f8         	str	r0, [r7, #0xc]
 80175a0: 60b9         	str	r1, [r7, #0x8]
 80175a2: 607a         	str	r2, [r7, #0x4]
 80175a4: 603b         	str	r3, [r7]
; 	while (len != 0) {
 80175a6: e00d         	b	0x80175c4 <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 80175a8: 68fb         	ldr	r3, [r7, #0xc]
 80175aa: 683a         	ldr	r2, [r7]
 80175ac: 6879         	ldr	r1, [r7, #0x4]
 80175ae: 68b8         	ldr	r0, [r7, #0x8]
 80175b0: 4798         	blx	r3
 80175b2: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 80175b4: 697b         	ldr	r3, [r7, #0x14]
 80175b6: 687a         	ldr	r2, [r7, #0x4]
 80175b8: 1ad3         	subs	r3, r2, r3
 80175ba: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 80175bc: 697b         	ldr	r3, [r7, #0x14]
 80175be: 68ba         	ldr	r2, [r7, #0x8]
 80175c0: 4413         	add	r3, r2
 80175c2: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 80175c4: 687b         	ldr	r3, [r7, #0x4]
 80175c6: 2b00         	cmp	r3, #0x0
 80175c8: d1ee         	bne	0x80175a8 <log_output_write+0x10> @ imm = #-0x24
; }
 80175ca: bf00         	nop
 80175cc: bf00         	nop
 80175ce: 3718         	adds	r7, #0x18
 80175d0: 46bd         	mov	sp, r7
 80175d2: bd80         	pop	{r7, pc}

080175d4 <log_output_flush>:
; {
 80175d4: b580         	push	{r7, lr}
 80175d6: b082         	sub	sp, #0x8
 80175d8: af00         	add	r7, sp, #0x0
 80175da: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 80175dc: 687b         	ldr	r3, [r7, #0x4]
 80175de: 6818         	ldr	r0, [r3]
 80175e0: 687b         	ldr	r3, [r7, #0x4]
 80175e2: 6899         	ldr	r1, [r3, #0x8]
 80175e4: 687b         	ldr	r3, [r7, #0x4]
 80175e6: 685b         	ldr	r3, [r3, #0x4]
 80175e8: 681b         	ldr	r3, [r3]
 80175ea: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 80175ec: 687b         	ldr	r3, [r7, #0x4]
 80175ee: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 80175f0: 685b         	ldr	r3, [r3, #0x4]
 80175f2: f7ff ffd1    	bl	0x8017598 <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 80175f6: 687b         	ldr	r3, [r7, #0x4]
 80175f8: 685b         	ldr	r3, [r3, #0x4]
 80175fa: 2200         	movs	r2, #0x0
 80175fc: 601a         	str	r2, [r3]
; }
 80175fe: bf00         	nop
 8017600: 3708         	adds	r7, #0x8
 8017602: 46bd         	mov	sp, r7
 8017604: bd80         	pop	{r7, pc}

08017606 <log_output_ctx_set>:
; {
 8017606: b480         	push	{r7}
 8017608: b083         	sub	sp, #0xc
 801760a: af00         	add	r7, sp, #0x0
 801760c: 6078         	str	r0, [r7, #0x4]
 801760e: 6039         	str	r1, [r7]
; 	output->control_block->ctx = ctx;
 8017610: 687b         	ldr	r3, [r7, #0x4]
 8017612: 685b         	ldr	r3, [r3, #0x4]
 8017614: 683a         	ldr	r2, [r7]
 8017616: 605a         	str	r2, [r3, #0x4]
; }
 8017618: bf00         	nop
 801761a: 370c         	adds	r7, #0xc
 801761c: 46bd         	mov	sp, r7
 801761e: f85d 7b04    	ldr	r7, [sp], #4
 8017622: 4770         	bx	lr

08017624 <log_backend_std_get_flags>:
; {
 8017624: b480         	push	{r7}
 8017626: b083         	sub	sp, #0xc
 8017628: af00         	add	r7, sp, #0x0
; 	uint32_t flags = (LOG_OUTPUT_FLAG_LEVEL | LOG_OUTPUT_FLAG_TIMESTAMP);
 801762a: 230a         	movs	r3, #0xa
 801762c: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_COLORS;
 801762e: 687b         	ldr	r3, [r7, #0x4]
 8017630: f043 0301    	orr	r3, r3, #0x1
 8017634: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP;
 8017636: 687b         	ldr	r3, [r7, #0x4]
 8017638: f043 0304    	orr	r3, r3, #0x4
 801763c: 607b         	str	r3, [r7, #0x4]
; 	return flags;
 801763e: 687b         	ldr	r3, [r7, #0x4]
; }
 8017640: 4618         	mov	r0, r3
 8017642: 370c         	adds	r7, #0xc
 8017644: 46bd         	mov	sp, r7
 8017646: f85d 7b04    	ldr	r7, [sp], #4
 801764a: 4770         	bx	lr

0801764c <log_backend_std_panic>:
; {
 801764c: b580         	push	{r7, lr}
 801764e: b082         	sub	sp, #0x8
 8017650: af00         	add	r7, sp, #0x0
 8017652: 6078         	str	r0, [r7, #0x4]
; 	log_output_flush(output);
 8017654: 6878         	ldr	r0, [r7, #0x4]
 8017656: f7ff ffbd    	bl	0x80175d4 <log_output_flush> @ imm = #-0x86
; }
 801765a: bf00         	nop
 801765c: 3708         	adds	r7, #0x8
 801765e: 46bd         	mov	sp, r7
 8017660: bd80         	pop	{r7, pc}

08017662 <z_impl_uart_poll_out>:
; {
 8017662: b580         	push	{r7, lr}
 8017664: b084         	sub	sp, #0x10
 8017666: af00         	add	r7, sp, #0x0
 8017668: 6078         	str	r0, [r7, #0x4]
 801766a: 460b         	mov	r3, r1
 801766c: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 801766e: 687b         	ldr	r3, [r7, #0x4]
 8017670: 689b         	ldr	r3, [r3, #0x8]
 8017672: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 8017674: 68fb         	ldr	r3, [r7, #0xc]
 8017676: 69db         	ldr	r3, [r3, #0x1c]
 8017678: 78fa         	ldrb	r2, [r7, #0x3]
 801767a: 4611         	mov	r1, r2
 801767c: 6878         	ldr	r0, [r7, #0x4]
 801767e: 4798         	blx	r3
; }
 8017680: bf00         	nop
 8017682: 3710         	adds	r7, #0x10
 8017684: 46bd         	mov	sp, r7
 8017686: bd80         	pop	{r7, pc}

08017688 <uart_poll_out>:
; {
 8017688: b580         	push	{r7, lr}
 801768a: b082         	sub	sp, #0x8
 801768c: af00         	add	r7, sp, #0x0
 801768e: 6078         	str	r0, [r7, #0x4]
 8017690: 460b         	mov	r3, r1
 8017692: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 8017694: 78fb         	ldrb	r3, [r7, #0x3]
 8017696: 4619         	mov	r1, r3
 8017698: 6878         	ldr	r0, [r7, #0x4]
 801769a: f7ff ffe2    	bl	0x8017662 <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 801769e: bf00         	nop
 80176a0: 3708         	adds	r7, #0x8
 80176a2: 46bd         	mov	sp, r7
 80176a4: bd80         	pop	{r7, pc}

080176a6 <pm_device_runtime_get>:
; {
 80176a6: b480         	push	{r7}
 80176a8: b083         	sub	sp, #0xc
 80176aa: af00         	add	r7, sp, #0x0
 80176ac: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80176ae: 2300         	movs	r3, #0x0
; }
 80176b0: 4618         	mov	r0, r3
 80176b2: 370c         	adds	r7, #0xc
 80176b4: 46bd         	mov	sp, r7
 80176b6: f85d 7b04    	ldr	r7, [sp], #4
 80176ba: 4770         	bx	lr

080176bc <pm_device_runtime_put_async>:
; {
 80176bc: b480         	push	{r7}
 80176be: b085         	sub	sp, #0x14
 80176c0: af00         	add	r7, sp, #0x0
 80176c2: 60f8         	str	r0, [r7, #0xc]
 80176c4: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 80176c8: 2300         	movs	r3, #0x0
; }
 80176ca: 4618         	mov	r0, r3
 80176cc: 3714         	adds	r7, #0x14
 80176ce: 46bd         	mov	sp, r7
 80176d0: f85d 7b04    	ldr	r7, [sp], #4
 80176d4: 4770         	bx	lr

080176d6 <process>:
; {
 80176d6: b580         	push	{r7, lr}
 80176d8: b086         	sub	sp, #0x18
 80176da: af00         	add	r7, sp, #0x0
 80176dc: 6078         	str	r0, [r7, #0x4]
 80176de: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 80176e0: 687b         	ldr	r3, [r7, #0x4]
 80176e2: 685b         	ldr	r3, [r3, #0x4]
 80176e4: 681b         	ldr	r3, [r3]
 80176e6: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 80176e8: 697b         	ldr	r3, [r7, #0x14]
 80176ea: 685b         	ldr	r3, [r3, #0x4]
 80176ec: 613b         	str	r3, [r7, #0x10]
; 	uint32_t flags = log_backend_std_get_flags();
 80176ee: f7ff ff99    	bl	0x8017624 <log_backend_std_get_flags> @ imm = #-0xce
 80176f2: 60f8         	str	r0, [r7, #0xc]
; 	log_format_func_t log_output_func = log_format_func_t_get(data->log_format_current);
 80176f4: 693b         	ldr	r3, [r7, #0x10]
 80176f6: 691b         	ldr	r3, [r3, #0x10]
 80176f8: 4618         	mov	r0, r3
 80176fa: f7ed fd19    	bl	0x8005130 <log_format_func_t_get> @ imm = #-0x125ce
 80176fe: 60b8         	str	r0, [r7, #0x8]
; 	log_output_func(ctx->output, &msg->log, flags);
 8017700: 697b         	ldr	r3, [r7, #0x14]
 8017702: 6818         	ldr	r0, [r3]
 8017704: 6839         	ldr	r1, [r7]
 8017706: 68bb         	ldr	r3, [r7, #0x8]
 8017708: 68fa         	ldr	r2, [r7, #0xc]
 801770a: 4798         	blx	r3
; }
 801770c: bf00         	nop
 801770e: 3718         	adds	r7, #0x18
 8017710: 46bd         	mov	sp, r7
 8017712: bd80         	pop	{r7, pc}

08017714 <format_set>:
; {
 8017714: b480         	push	{r7}
 8017716: b085         	sub	sp, #0x14
 8017718: af00         	add	r7, sp, #0x0
 801771a: 6078         	str	r0, [r7, #0x4]
 801771c: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 801771e: 687b         	ldr	r3, [r7, #0x4]
 8017720: 685b         	ldr	r3, [r3, #0x4]
 8017722: 681b         	ldr	r3, [r3]
 8017724: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 8017726: 68fb         	ldr	r3, [r7, #0xc]
 8017728: 685b         	ldr	r3, [r3, #0x4]
 801772a: 60bb         	str	r3, [r7, #0x8]
; 	data->log_format_current = log_type;
 801772c: 68bb         	ldr	r3, [r7, #0x8]
 801772e: 683a         	ldr	r2, [r7]
 8017730: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 8017732: 2300         	movs	r3, #0x0
; }
 8017734: 4618         	mov	r0, r3
 8017736: 3714         	adds	r7, #0x14
 8017738: 46bd         	mov	sp, r7
 801773a: f85d 7b04    	ldr	r7, [sp], #4
 801773e: 4770         	bx	lr

08017740 <z_log_msg_runtime_create>:
; {
 8017740: b580         	push	{r7, lr}
 8017742: b08a         	sub	sp, #0x28
 8017744: af04         	add	r7, sp, #0x10
 8017746: 60b9         	str	r1, [r7, #0x8]
 8017748: 607b         	str	r3, [r7, #0x4]
 801774a: 4603         	mov	r3, r0
 801774c: 73fb         	strb	r3, [r7, #0xf]
 801774e: 4613         	mov	r3, r2
 8017750: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8017752: f107 032c    	add.w	r3, r7, #0x2c
 8017756: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8017758: 7bba         	ldrb	r2, [r7, #0xe]
 801775a: 7bf8         	ldrb	r0, [r7, #0xf]
 801775c: 697b         	ldr	r3, [r7, #0x14]
 801775e: 9303         	str	r3, [sp, #0xc]
 8017760: 6abb         	ldr	r3, [r7, #0x28]
 8017762: 9302         	str	r3, [sp, #0x8]
 8017764: 6a7b         	ldr	r3, [r7, #0x24]
 8017766: 9301         	str	r3, [sp, #0x4]
 8017768: 6a3b         	ldr	r3, [r7, #0x20]
 801776a: 9300         	str	r3, [sp]
 801776c: 687b         	ldr	r3, [r7, #0x4]
 801776e: 68b9         	ldr	r1, [r7, #0x8]
 8017770: f7ed ff00    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x12200
; }
 8017774: bf00         	nop
 8017776: 3718         	adds	r7, #0x18
 8017778: 46bd         	mov	sp, r7
 801777a: bd80         	pop	{r7, pc}

0801777c <z_do_kernel_oops>:
; {
 801777c: b580         	push	{r7, lr}
 801777e: b088         	sub	sp, #0x20
 8017780: af00         	add	r7, sp, #0x0
 8017782: 60f8         	str	r0, [r7, #0xc]
 8017784: 60b9         	str	r1, [r7, #0x8]
 8017786: 607a         	str	r2, [r7, #0x4]
; 	unsigned int reason = esf->basic.r0;
 8017788: 68fb         	ldr	r3, [r7, #0xc]
 801778a: 681b         	ldr	r3, [r3]
 801778c: 61fb         	str	r3, [r7, #0x1c]
 801778e: 68fb         	ldr	r3, [r7, #0xc]
 8017790: 61bb         	str	r3, [r7, #0x18]
 8017792: 687b         	ldr	r3, [r7, #0x4]
 8017794: 617b         	str	r3, [r7, #0x14]
; }
 8017796: bf00         	nop
; 	z_arm_fatal_error(reason, esf);
 8017798: 68f9         	ldr	r1, [r7, #0xc]
 801779a: 69f8         	ldr	r0, [r7, #0x1c]
 801779c: f7ee fbec    	bl	0x8005f78 <z_arm_fatal_error> @ imm = #-0x11828
; }
 80177a0: bf00         	nop
 80177a2: 3720         	adds	r7, #0x20
 80177a4: 46bd         	mov	sp, r7
 80177a6: bd80         	pop	{r7, pc}

080177a8 <arch_tls_stack_setup>:
; {
 80177a8: b580         	push	{r7, lr}
 80177aa: b082         	sub	sp, #0x8
 80177ac: af00         	add	r7, sp, #0x0
 80177ae: 6078         	str	r0, [r7, #0x4]
 80177b0: 6039         	str	r1, [r7]
; 	stack_ptr -= z_tls_data_size();
 80177b2: f7ee fc2d    	bl	0x8006010 <z_tls_data_size> @ imm = #-0x117a6
 80177b6: 4603         	mov	r3, r0
 80177b8: 425b         	rsbs	r3, r3, #0
 80177ba: 683a         	ldr	r2, [r7]
 80177bc: 4413         	add	r3, r2
 80177be: 603b         	str	r3, [r7]
; 	z_tls_copy(stack_ptr);
 80177c0: 6838         	ldr	r0, [r7]
 80177c2: f7ee fc33    	bl	0x800602c <z_tls_copy>  @ imm = #-0x1179a
; 	stack_ptr -= sizeof(uintptr_t) * 2;
 80177c6: 683b         	ldr	r3, [r7]
 80177c8: 3b08         	subs	r3, #0x8
 80177ca: 603b         	str	r3, [r7]
; 	new_thread->tls = POINTER_TO_UINT(stack_ptr);
 80177cc: 683a         	ldr	r2, [r7]
 80177ce: 687b         	ldr	r3, [r7, #0x4]
 80177d0: f8c3 20c4    	str.w	r2, [r3, #0xc4]
; 	return (z_tls_data_size() + (sizeof(uintptr_t) * 2));
 80177d4: f7ee fc1c    	bl	0x8006010 <z_tls_data_size> @ imm = #-0x117c8
 80177d8: 4603         	mov	r3, r0
 80177da: 3308         	adds	r3, #0x8
; }
 80177dc: 4618         	mov	r0, r3
 80177de: 3708         	adds	r7, #0x8
 80177e0: 46bd         	mov	sp, r7
 80177e2: bd80         	pop	{r7, pc}

080177e4 <z_log_msg_runtime_create>:
; {
 80177e4: b580         	push	{r7, lr}
 80177e6: b08a         	sub	sp, #0x28
 80177e8: af04         	add	r7, sp, #0x10
 80177ea: 60b9         	str	r1, [r7, #0x8]
 80177ec: 607b         	str	r3, [r7, #0x4]
 80177ee: 4603         	mov	r3, r0
 80177f0: 73fb         	strb	r3, [r7, #0xf]
 80177f2: 4613         	mov	r3, r2
 80177f4: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80177f6: f107 032c    	add.w	r3, r7, #0x2c
 80177fa: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80177fc: 7bba         	ldrb	r2, [r7, #0xe]
 80177fe: 7bf8         	ldrb	r0, [r7, #0xf]
 8017800: 697b         	ldr	r3, [r7, #0x14]
 8017802: 9303         	str	r3, [sp, #0xc]
 8017804: 6abb         	ldr	r3, [r7, #0x28]
 8017806: 9302         	str	r3, [sp, #0x8]
 8017808: 6a7b         	ldr	r3, [r7, #0x24]
 801780a: 9301         	str	r3, [sp, #0x4]
 801780c: 6a3b         	ldr	r3, [r7, #0x20]
 801780e: 9300         	str	r3, [sp]
 8017810: 687b         	ldr	r3, [r7, #0x4]
 8017812: 68b9         	ldr	r1, [r7, #0x8]
 8017814: f7ed feae    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x122a4
; }
 8017818: bf00         	nop
 801781a: 3718         	adds	r7, #0x18
 801781c: 46bd         	mov	sp, r7
 801781e: bd80         	pop	{r7, pc}

08017820 <fault_show>:
; {
 8017820: b480         	push	{r7}
 8017822: b083         	sub	sp, #0xc
 8017824: af00         	add	r7, sp, #0x0
 8017826: 6078         	str	r0, [r7, #0x4]
 8017828: 6039         	str	r1, [r7]
; }
 801782a: bf00         	nop
 801782c: 370c         	adds	r7, #0xc
 801782e: 46bd         	mov	sp, r7
 8017830: f85d 7b04    	ldr	r7, [sp], #4
 8017834: 4770         	bx	lr

08017836 <memory_fault_recoverable>:
; {
 8017836: b480         	push	{r7}
 8017838: b083         	sub	sp, #0xc
 801783a: af00         	add	r7, sp, #0x0
 801783c: 6078         	str	r0, [r7, #0x4]
 801783e: 460b         	mov	r3, r1
 8017840: 70fb         	strb	r3, [r7, #0x3]
; 	return false;
 8017842: 2300         	movs	r3, #0x0
; }
 8017844: 4618         	mov	r0, r3
 8017846: 370c         	adds	r7, #0xc
 8017848: 46bd         	mov	sp, r7
 801784a: f85d 7b04    	ldr	r7, [sp], #4
 801784e: 4770         	bx	lr

08017850 <arch_irq_enable>:
; {
 8017850: b580         	push	{r7, lr}
 8017852: b082         	sub	sp, #0x8
 8017854: af00         	add	r7, sp, #0x0
 8017856: 6078         	str	r0, [r7, #0x4]
; 	NVIC_EnableIRQ((IRQn_Type)irq);
 8017858: 687b         	ldr	r3, [r7, #0x4]
 801785a: b25b         	sxtb	r3, r3
 801785c: 4618         	mov	r0, r3
 801785e: f7ef fb7b    	bl	0x8006f58 <__NVIC_EnableIRQ> @ imm = #-0x1090a
; }
 8017862: bf00         	nop
 8017864: 3708         	adds	r7, #0x8
 8017866: 46bd         	mov	sp, r7
 8017868: bd80         	pop	{r7, pc}

0801786a <z_arm_irq_priority_set>:
; {
 801786a: b580         	push	{r7, lr}
 801786c: b084         	sub	sp, #0x10
 801786e: af00         	add	r7, sp, #0x0
 8017870: 60f8         	str	r0, [r7, #0xc]
 8017872: 60b9         	str	r1, [r7, #0x8]
 8017874: 607a         	str	r2, [r7, #0x4]
; 		prio += _IRQ_PRIO_OFFSET;
 8017876: 68bb         	ldr	r3, [r7, #0x8]
 8017878: 3301         	adds	r3, #0x1
 801787a: 60bb         	str	r3, [r7, #0x8]
; 	NVIC_SetPriority((IRQn_Type)irq, prio);
 801787c: 68fb         	ldr	r3, [r7, #0xc]
 801787e: b25b         	sxtb	r3, r3
 8017880: 68b9         	ldr	r1, [r7, #0x8]
 8017882: 4618         	mov	r0, r3
 8017884: f7ef fb86    	bl	0x8006f94 <__NVIC_SetPriority> @ imm = #-0x108f4
; }
 8017888: bf00         	nop
 801788a: 3710         	adds	r7, #0x10
 801788c: 46bd         	mov	sp, r7
 801788e: bd80         	pop	{r7, pc}

08017890 <z_irq_spurious>:
; {
 8017890: b580         	push	{r7, lr}
 8017892: b082         	sub	sp, #0x8
 8017894: af00         	add	r7, sp, #0x0
 8017896: 6078         	str	r0, [r7, #0x4]
; 	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 8017898: 2100         	movs	r1, #0x0
 801789a: 2001         	movs	r0, #0x1
 801789c: f7ee fb6c    	bl	0x8005f78 <z_arm_fatal_error> @ imm = #-0x11928
; }
 80178a0: bf00         	nop
 80178a2: 3708         	adds	r7, #0x8
 80178a4: 46bd         	mov	sp, r7
 80178a6: bd80         	pop	{r7, pc}

080178a8 <z_prep_c>:
; {
 80178a8: b580         	push	{r7, lr}
 80178aa: af00         	add	r7, sp, #0x0
; 	relocate_vector_table();
 80178ac: f7ef fb9c    	bl	0x8006fe8 <relocate_vector_table> @ imm = #-0x108c8
; 	z_arm_floating_point_init();
 80178b0: f7ef fbb4    	bl	0x800701c <z_arm_floating_point_init> @ imm = #-0x10898
; 	z_bss_zero();
 80178b4: f7f7 ff56    	bl	0x800f764 <z_bss_zero>  @ imm = #-0x8154
; 	z_data_copy();
 80178b8: f7fb f85e    	bl	0x8012978 <z_data_copy> @ imm = #-0x4f44
; 	z_arm_interrupt_init();
 80178bc: f000 f85b    	bl	0x8017976 <z_arm_interrupt_init> @ imm = #0xb6
; 	z_cstart();
 80178c0: f7f8 f87a    	bl	0x800f9b8 <z_cstart>    @ imm = #-0x7f0c

080178c4 <z_arm_prepare_switch_to_main>:
; {
 80178c4: b480         	push	{r7}
 80178c6: b085         	sub	sp, #0x14
 80178c8: af00         	add	r7, sp, #0x0
 80178ca: 2300         	movs	r3, #0x0
 80178cc: 607b         	str	r3, [r7, #0x4]
;   __builtin_arm_set_fpscr(fpscr);
 80178ce: 687b         	ldr	r3, [r7, #0x4]
 80178d0: eee1 3a10    	vmsr	fpscr, r3
; }
 80178d4: bf00         	nop
;   __ASM volatile ("MRS %0, control" : "=r" (result) );
 80178d6: f3ef 8314    	mrs	r3, control
 80178da: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 80178dc: 68bb         	ldr	r3, [r7, #0x8]
; 	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
 80178de: f023 0304    	bic	r3, r3, #0x4
 80178e2: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 80178e4: 68fb         	ldr	r3, [r7, #0xc]
 80178e6: f383 8814    	msr	control, r3
;   __ASM volatile ("isb 0xF":::"memory");
 80178ea: f3bf 8f6f    	isb	sy
; }
 80178ee: bf00         	nop
; }
 80178f0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80178f2: f3bf 8f6f    	isb	sy
; }
 80178f6: bf00         	nop
; }
 80178f8: bf00         	nop
; }
 80178fa: bf00         	nop
; }
 80178fc: bf00         	nop
 80178fe: 3714         	adds	r7, #0x14
 8017900: 46bd         	mov	sp, r7
 8017902: f85d 7b04    	ldr	r7, [sp], #4
 8017906: 4770         	bx	lr

08017908 <arch_irq_unlock_outlined>:
; {
 8017908: b480         	push	{r7}
 801790a: b085         	sub	sp, #0x14
 801790c: af00         	add	r7, sp, #0x0
 801790e: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("cpsie f" : : : "memory");
 8017910: b661         	cpsie f
; }
 8017912: bf00         	nop
;   __ASM volatile ("cpsie i" : : : "memory");
 8017914: b662         	cpsie i
; }
 8017916: bf00         	nop
 8017918: 687b         	ldr	r3, [r7, #0x4]
 801791a: 60fb         	str	r3, [r7, #0xc]
 801791c: 68fb         	ldr	r3, [r7, #0xc]
 801791e: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8017920: 68bb         	ldr	r3, [r7, #0x8]
 8017922: f383 8811    	msr	basepri, r3
; }
 8017926: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017928: f3bf 8f6f    	isb	sy
; }
 801792c: bf00         	nop
; }
 801792e: bf00         	nop
; }
 8017930: bf00         	nop
 8017932: 3714         	adds	r7, #0x14
 8017934: 46bd         	mov	sp, r7
 8017936: f85d 7b04    	ldr	r7, [sp], #4
 801793a: 4770         	bx	lr

0801793c <arch_cpu_idle>:
; {
 801793c: b480         	push	{r7}
 801793e: b083         	sub	sp, #0xc
 8017940: af00         	add	r7, sp, #0x0
;   __ASM volatile ("cpsid i" : : : "memory");
 8017942: b672         	cpsid i
; }
 8017944: bf00         	nop
 8017946: 2300         	movs	r3, #0x0
 8017948: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801794a: 687b         	ldr	r3, [r7, #0x4]
 801794c: f383 8811    	msr	basepri, r3
; }
 8017950: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017952: f3bf 8f6f    	isb	sy
; }
 8017956: bf00         	nop
;   __ASM volatile ("dsb 0xF":::"memory");
 8017958: f3bf 8f4f    	dsb	sy
; }
 801795c: bf00         	nop
; 	SLEEP_IF_ALLOWED(__WFI);
 801795e: bf30         	wfi
;   __ASM volatile ("cpsie i" : : : "memory");
 8017960: b662         	cpsie i
; }
 8017962: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8017964: f3bf 8f6f    	isb	sy
; }
 8017968: bf00         	nop
; }
 801796a: bf00         	nop
 801796c: 370c         	adds	r7, #0xc
 801796e: 46bd         	mov	sp, r7
 8017970: f85d 7b04    	ldr	r7, [sp], #4
 8017974: 4770         	bx	lr

08017976 <z_arm_interrupt_init>:
; {
 8017976: b580         	push	{r7, lr}
 8017978: b082         	sub	sp, #0x8
 801797a: af00         	add	r7, sp, #0x0
; 	int irq = 0;
 801797c: 2300         	movs	r3, #0x0
 801797e: 607b         	str	r3, [r7, #0x4]
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 8017980: e008         	b	0x8017994 <z_arm_interrupt_init+0x1e> @ imm = #0x10
; 		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
 8017982: 687b         	ldr	r3, [r7, #0x4]
 8017984: b25b         	sxtb	r3, r3
 8017986: 2101         	movs	r1, #0x1
 8017988: 4618         	mov	r0, r3
 801798a: f7ef fc45    	bl	0x8007218 <__NVIC_SetPriority> @ imm = #-0x10776
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 801798e: 687b         	ldr	r3, [r7, #0x4]
 8017990: 3301         	adds	r3, #0x1
 8017992: 607b         	str	r3, [r7, #0x4]
 8017994: 687b         	ldr	r3, [r7, #0x4]
 8017996: 2b51         	cmp	r3, #0x51
 8017998: ddf3         	ble	0x8017982 <z_arm_interrupt_init+0xc> @ imm = #-0x1a
; }
 801799a: bf00         	nop
 801799c: bf00         	nop
 801799e: 3708         	adds	r7, #0x8
 80179a0: 46bd         	mov	sp, r7
 80179a2: bd80         	pop	{r7, pc}

080179a4 <cbputc>:
; {
 80179a4: b580         	push	{r7, lr}
 80179a6: b084         	sub	sp, #0x10
 80179a8: af00         	add	r7, sp, #0x0
 80179aa: 4603         	mov	r3, r0
 80179ac: 6039         	str	r1, [r7]
 80179ae: 71fb         	strb	r3, [r7, #0x7]
; 	struct cb_bits *s = (struct cb_bits *) _s;
 80179b0: 683b         	ldr	r3, [r7]
 80179b2: 60fb         	str	r3, [r7, #0xc]
; 	(*s->out) (c, s->ctx);
 80179b4: 68fb         	ldr	r3, [r7, #0xc]
 80179b6: 691b         	ldr	r3, [r3, #0x10]
 80179b8: 79f8         	ldrb	r0, [r7, #0x7]
 80179ba: 68fa         	ldr	r2, [r7, #0xc]
 80179bc: 6952         	ldr	r2, [r2, #0x14]
 80179be: 4611         	mov	r1, r2
 80179c0: 4798         	blx	r3
; 	return 0;
 80179c2: 2300         	movs	r3, #0x0
; }
 80179c4: 4618         	mov	r0, r3
 80179c6: 3710         	adds	r7, #0x10
 80179c8: 46bd         	mov	sp, r7
 80179ca: bd80         	pop	{r7, pc}

080179cc <zephyr_fputc>:
; {
 80179cc: b580         	push	{r7, lr}
 80179ce: b082         	sub	sp, #0x8
 80179d0: af00         	add	r7, sp, #0x0
 80179d2: 6078         	str	r0, [r7, #0x4]
 80179d4: 6039         	str	r1, [r7]
; 	return z_impl_zephyr_fputc(c, stream);
 80179d6: 6839         	ldr	r1, [r7]
 80179d8: 6878         	ldr	r0, [r7, #0x4]
 80179da: f7ef fc8b    	bl	0x80072f4 <z_impl_zephyr_fputc> @ imm = #-0x106ea
 80179de: 4603         	mov	r3, r0
; }
 80179e0: 4618         	mov	r0, r3
 80179e2: 3708         	adds	r7, #0x8
 80179e4: 46bd         	mov	sp, r7
 80179e6: bd80         	pop	{r7, pc}

080179e8 <picolibc_put>:
; {
 80179e8: b580         	push	{r7, lr}
 80179ea: b082         	sub	sp, #0x8
 80179ec: af00         	add	r7, sp, #0x0
 80179ee: 4603         	mov	r3, r0
 80179f0: 6039         	str	r1, [r7]
 80179f2: 71fb         	strb	r3, [r7, #0x7]
; 	zephyr_fputc(a, f);
 80179f4: 79fb         	ldrb	r3, [r7, #0x7]
 80179f6: 6839         	ldr	r1, [r7]
 80179f8: 4618         	mov	r0, r3
 80179fa: f7ff ffe7    	bl	0x80179cc <zephyr_fputc> @ imm = #-0x32
; 	return 0;
 80179fe: 2300         	movs	r3, #0x0
; }
 8017a00: 4618         	mov	r0, r3
 8017a02: 3708         	adds	r7, #0x8
 8017a04: 46bd         	mov	sp, r7
 8017a06: bd80         	pop	{r7, pc}

08017a08 <k_mutex_lock>:
; {
 8017a08: b580         	push	{r7, lr}
 8017a0a: b084         	sub	sp, #0x10
 8017a0c: af00         	add	r7, sp, #0x0
 8017a0e: 60f8         	str	r0, [r7, #0xc]
 8017a10: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_mutex_lock(mutex, timeout);
 8017a14: e9d7 2300    	ldrd	r2, r3, [r7]
 8017a18: 68f8         	ldr	r0, [r7, #0xc]
 8017a1a: f7f8 f88b    	bl	0x800fb34 <z_impl_k_mutex_lock> @ imm = #-0x7eea
 8017a1e: 4603         	mov	r3, r0
; }
 8017a20: 4618         	mov	r0, r3
 8017a22: 3710         	adds	r7, #0x10
 8017a24: 46bd         	mov	sp, r7
 8017a26: bd80         	pop	{r7, pc}

08017a28 <k_mutex_unlock>:
; {
 8017a28: b580         	push	{r7, lr}
 8017a2a: b082         	sub	sp, #0x8
 8017a2c: af00         	add	r7, sp, #0x0
 8017a2e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_unlock(mutex);
 8017a30: 6878         	ldr	r0, [r7, #0x4]
 8017a32: f7f8 fac9    	bl	0x800ffc8 <z_impl_k_mutex_unlock> @ imm = #-0x7a6e
 8017a36: 4603         	mov	r3, r0
; }
 8017a38: 4618         	mov	r0, r3
 8017a3a: 3708         	adds	r7, #0x8
 8017a3c: 46bd         	mov	sp, r7
 8017a3e: bd80         	pop	{r7, pc}

08017a40 <sys_mutex_lock>:
; {
 8017a40: b580         	push	{r7, lr}
 8017a42: b084         	sub	sp, #0x10
 8017a44: af00         	add	r7, sp, #0x0
 8017a46: 60f8         	str	r0, [r7, #0xc]
 8017a48: e9c7 2300    	strd	r2, r3, [r7]
; 	return k_mutex_lock(&mutex->kernel_mutex, timeout);
 8017a4c: 68f9         	ldr	r1, [r7, #0xc]
 8017a4e: e9d7 2300    	ldrd	r2, r3, [r7]
 8017a52: 4608         	mov	r0, r1
 8017a54: f7ff ffd8    	bl	0x8017a08 <k_mutex_lock> @ imm = #-0x50
 8017a58: 4603         	mov	r3, r0
; }
 8017a5a: 4618         	mov	r0, r3
 8017a5c: 3710         	adds	r7, #0x10
 8017a5e: 46bd         	mov	sp, r7
 8017a60: bd80         	pop	{r7, pc}

08017a62 <sys_mutex_unlock>:
; {
 8017a62: b580         	push	{r7, lr}
 8017a64: b082         	sub	sp, #0x8
 8017a66: af00         	add	r7, sp, #0x0
 8017a68: 6078         	str	r0, [r7, #0x4]
; 	return k_mutex_unlock(&mutex->kernel_mutex);
 8017a6a: 687b         	ldr	r3, [r7, #0x4]
 8017a6c: 4618         	mov	r0, r3
 8017a6e: f7ff ffdb    	bl	0x8017a28 <k_mutex_unlock> @ imm = #-0x4a
 8017a72: 4603         	mov	r3, r0
; }
 8017a74: 4618         	mov	r0, r3
 8017a76: 3708         	adds	r7, #0x8
 8017a78: 46bd         	mov	sp, r7
 8017a7a: bd80         	pop	{r7, pc}

08017a7c <clock_control_on>:
; {
 8017a7c: b580         	push	{r7, lr}
 8017a7e: b084         	sub	sp, #0x10
 8017a80: af00         	add	r7, sp, #0x0
 8017a82: 6078         	str	r0, [r7, #0x4]
 8017a84: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8017a86: 687b         	ldr	r3, [r7, #0x4]
 8017a88: 689b         	ldr	r3, [r3, #0x8]
 8017a8a: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8017a8c: 68fb         	ldr	r3, [r7, #0xc]
 8017a8e: 681b         	ldr	r3, [r3]
 8017a90: 6839         	ldr	r1, [r7]
 8017a92: 6878         	ldr	r0, [r7, #0x4]
 8017a94: 4798         	blx	r3
 8017a96: 4603         	mov	r3, r0
; }
 8017a98: 4618         	mov	r0, r3
 8017a9a: 3710         	adds	r7, #0x10
 8017a9c: 46bd         	mov	sp, r7
 8017a9e: bd80         	pop	{r7, pc}

08017aa0 <z_stm32_hsem_lock>:
; {
 8017aa0: b480         	push	{r7}
 8017aa2: b083         	sub	sp, #0xc
 8017aa4: af00         	add	r7, sp, #0x0
 8017aa6: 6078         	str	r0, [r7, #0x4]
 8017aa8: 6039         	str	r1, [r7]
; }
 8017aaa: bf00         	nop
 8017aac: 370c         	adds	r7, #0xc
 8017aae: 46bd         	mov	sp, r7
 8017ab0: f85d 7b04    	ldr	r7, [sp], #4
 8017ab4: 4770         	bx	lr

08017ab6 <z_stm32_hsem_unlock>:
; {
 8017ab6: b480         	push	{r7}
 8017ab8: b083         	sub	sp, #0xc
 8017aba: af00         	add	r7, sp, #0x0
 8017abc: 6078         	str	r0, [r7, #0x4]
; }
 8017abe: bf00         	nop
 8017ac0: 370c         	adds	r7, #0xc
 8017ac2: 46bd         	mov	sp, r7
 8017ac4: f85d 7b04    	ldr	r7, [sp], #4
 8017ac8: 4770         	bx	lr

08017aca <stm32_exti_linenum_to_src_cfg_line>:
; {
 8017aca: b480         	push	{r7}
 8017acc: b083         	sub	sp, #0xc
 8017ace: af00         	add	r7, sp, #0x0
 8017ad0: 4603         	mov	r3, r0
 8017ad2: 71fb         	strb	r3, [r7, #0x7]
; 	return (0xF << ((linenum % 4 * 4) + 16)) | (linenum / 4);
 8017ad4: 79fb         	ldrb	r3, [r7, #0x7]
 8017ad6: f003 0303    	and	r3, r3, #0x3
 8017ada: 3304         	adds	r3, #0x4
 8017adc: 009b         	lsls	r3, r3, #0x2
 8017ade: 220f         	movs	r2, #0xf
 8017ae0: fa02 f303    	lsl.w	r3, r2, r3
 8017ae4: 79fa         	ldrb	r2, [r7, #0x7]
 8017ae6: 0892         	lsrs	r2, r2, #0x2
 8017ae8: b2d2         	uxtb	r2, r2
 8017aea: 4313         	orrs	r3, r2
; }
 8017aec: 4618         	mov	r0, r3
 8017aee: 370c         	adds	r7, #0xc
 8017af0: 46bd         	mov	sp, r7
 8017af2: f85d 7b04    	ldr	r7, [sp], #4
 8017af6: 4770         	bx	lr

08017af8 <stm32_exti_is_pending>:
; {
 8017af8: b580         	push	{r7, lr}
 8017afa: b082         	sub	sp, #0x8
 8017afc: af00         	add	r7, sp, #0x0
 8017afe: 6078         	str	r0, [r7, #0x4]
; 	return LL_EXTI_IsActiveFlag_0_31(line);
 8017b00: 6878         	ldr	r0, [r7, #0x4]
 8017b02: f7ef fcf3    	bl	0x80074ec <LL_EXTI_IsActiveFlag_0_31> @ imm = #-0x1061a
 8017b06: 4603         	mov	r3, r0
; }
 8017b08: 4618         	mov	r0, r3
 8017b0a: 3708         	adds	r7, #0x8
 8017b0c: 46bd         	mov	sp, r7
 8017b0e: bd80         	pop	{r7, pc}

08017b10 <stm32_exti_clear_pending>:
; {
 8017b10: b580         	push	{r7, lr}
 8017b12: b082         	sub	sp, #0x8
 8017b14: af00         	add	r7, sp, #0x0
 8017b16: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_ClearFlag_0_31(line);
 8017b18: 6878         	ldr	r0, [r7, #0x4]
 8017b1a: f7ef fcfd    	bl	0x8007518 <LL_EXTI_ClearFlag_0_31> @ imm = #-0x10606
; }
 8017b1e: bf00         	nop
 8017b20: 3708         	adds	r7, #0x8
 8017b22: 46bd         	mov	sp, r7
 8017b24: bd80         	pop	{r7, pc}

08017b26 <linenum_to_ll_exti_line>:
; {
 8017b26: b480         	push	{r7}
 8017b28: b083         	sub	sp, #0xc
 8017b2a: af00         	add	r7, sp, #0x0
 8017b2c: 4603         	mov	r3, r0
 8017b2e: 71fb         	strb	r3, [r7, #0x7]
; 	return BIT(linenum);
 8017b30: 79fb         	ldrb	r3, [r7, #0x7]
 8017b32: 2201         	movs	r2, #0x1
 8017b34: fa02 f303    	lsl.w	r3, r2, r3
; }
 8017b38: 4618         	mov	r0, r3
 8017b3a: 370c         	adds	r7, #0xc
 8017b3c: 46bd         	mov	sp, r7
 8017b3e: f85d 7b04    	ldr	r7, [sp], #4
 8017b42: 4770         	bx	lr

08017b44 <ll_exti_line_to_linenum>:
; {
 8017b44: b480         	push	{r7}
 8017b46: b083         	sub	sp, #0xc
 8017b48: af00         	add	r7, sp, #0x0
 8017b4a: 6078         	str	r0, [r7, #0x4]
; 	return LOG2(line);
 8017b4c: 687b         	ldr	r3, [r7, #0x4]
 8017b4e: 2b00         	cmp	r3, #0x0
 8017b50: d007         	beq	0x8017b62 <ll_exti_line_to_linenum+0x1e> @ imm = #0xe
 8017b52: 687b         	ldr	r3, [r7, #0x4]
 8017b54: fab3 f383    	clz	r3, r3
 8017b58: b2db         	uxtb	r3, r3
 8017b5a: f1c3 031f    	rsb.w	r3, r3, #0x1f
 8017b5e: b2db         	uxtb	r3, r3
 8017b60: e000         	b	0x8017b64 <ll_exti_line_to_linenum+0x20> @ imm = #0x0
 8017b62: 23ff         	movs	r3, #0xff
; }
 8017b64: 4618         	mov	r0, r3
 8017b66: 370c         	adds	r7, #0xc
 8017b68: 46bd         	mov	sp, r7
 8017b6a: f85d 7b04    	ldr	r7, [sp], #4
 8017b6e: 4770         	bx	lr

08017b70 <stm32_gpio_intc_get_pin_irq_line>:
; {
 8017b70: b580         	push	{r7, lr}
 8017b72: b082         	sub	sp, #0x8
 8017b74: af00         	add	r7, sp, #0x0
 8017b76: 6078         	str	r0, [r7, #0x4]
 8017b78: 460b         	mov	r3, r1
 8017b7a: 70fb         	strb	r3, [r7, #0x3]
; 	return linenum_to_ll_exti_line(pin);
 8017b7c: 78fb         	ldrb	r3, [r7, #0x3]
 8017b7e: 4618         	mov	r0, r3
 8017b80: f7ff ffd1    	bl	0x8017b26 <linenum_to_ll_exti_line> @ imm = #-0x5e
 8017b84: 4603         	mov	r3, r0
; }
 8017b86: 4618         	mov	r0, r3
 8017b88: 3708         	adds	r7, #0x8
 8017b8a: 46bd         	mov	sp, r7
 8017b8c: bd80         	pop	{r7, pc}

08017b8e <stm32_gpio_intc_disable_line>:
; {
 8017b8e: b580         	push	{r7, lr}
 8017b90: b082         	sub	sp, #0x8
 8017b92: af00         	add	r7, sp, #0x0
 8017b94: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_DisableIT_0_31(line);
 8017b96: 6878         	ldr	r0, [r7, #0x4]
 8017b98: f7ef fc48    	bl	0x800742c <LL_EXTI_DisableIT_0_31> @ imm = #-0x10770
; }
 8017b9c: bf00         	nop
 8017b9e: 3708         	adds	r7, #0x8
 8017ba0: 46bd         	mov	sp, r7
 8017ba2: bd80         	pop	{r7, pc}

08017ba4 <stm32_exti_set_line_src_port>:
; {
 8017ba4: b580         	push	{r7, lr}
 8017ba6: b084         	sub	sp, #0x10
 8017ba8: af00         	add	r7, sp, #0x0
 8017baa: 4603         	mov	r3, r0
 8017bac: 6039         	str	r1, [r7]
 8017bae: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 8017bb0: 79fb         	ldrb	r3, [r7, #0x7]
 8017bb2: 4618         	mov	r0, r3
 8017bb4: f7ff ff89    	bl	0x8017aca <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0xee
 8017bb8: 60f8         	str	r0, [r7, #0xc]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8017bba: f44f 1180    	mov.w	r1, #0x100000
 8017bbe: 2000         	movs	r0, #0x0
 8017bc0: f7ff ff6e    	bl	0x8017aa0 <z_stm32_hsem_lock> @ imm = #-0x124
; 	LL_SYSCFG_SetEXTISource(port, ll_line);
 8017bc4: 68f9         	ldr	r1, [r7, #0xc]
 8017bc6: 6838         	ldr	r0, [r7]
 8017bc8: f7ef fcb6    	bl	0x8007538 <LL_SYSCFG_SetEXTISource> @ imm = #-0x10694
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 8017bcc: 2000         	movs	r0, #0x0
 8017bce: f7ff ff72    	bl	0x8017ab6 <z_stm32_hsem_unlock> @ imm = #-0x11c
; }
 8017bd2: bf00         	nop
 8017bd4: 3710         	adds	r7, #0x10
 8017bd6: 46bd         	mov	sp, r7
 8017bd8: bd80         	pop	{r7, pc}

08017bda <stm32_exti_get_line_src_port>:
; {
 8017bda: b580         	push	{r7, lr}
 8017bdc: b084         	sub	sp, #0x10
 8017bde: af00         	add	r7, sp, #0x0
 8017be0: 4603         	mov	r3, r0
 8017be2: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 8017be4: 79fb         	ldrb	r3, [r7, #0x7]
 8017be6: 4618         	mov	r0, r3
 8017be8: f7ff ff6f    	bl	0x8017aca <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0x122
 8017bec: 60f8         	str	r0, [r7, #0xc]
; 	port = LL_SYSCFG_GetEXTISource(ll_line);
 8017bee: 68f8         	ldr	r0, [r7, #0xc]
 8017bf0: f7ef fcd8    	bl	0x80075a4 <LL_SYSCFG_GetEXTISource> @ imm = #-0x10650
 8017bf4: 60b8         	str	r0, [r7, #0x8]
; 	return port;
 8017bf6: 68bb         	ldr	r3, [r7, #0x8]
; }
 8017bf8: 4618         	mov	r0, r3
 8017bfa: 3710         	adds	r7, #0x10
 8017bfc: 46bd         	mov	sp, r7
 8017bfe: bd80         	pop	{r7, pc}

08017c00 <stm32_clock_control_mco_init>:
; {
 8017c00: b480         	push	{r7}
 8017c02: af00         	add	r7, sp, #0x0
; }
 8017c04: bf00         	nop
 8017c06: 46bd         	mov	sp, r7
 8017c08: f85d 7b04    	ldr	r7, [sp], #4
 8017c0c: 4770         	bx	lr

08017c0e <get_pll_div_frequency>:
; {
 8017c0e: b480         	push	{r7}
 8017c10: b085         	sub	sp, #0x14
 8017c12: af00         	add	r7, sp, #0x0
 8017c14: 60f8         	str	r0, [r7, #0xc]
 8017c16: 60b9         	str	r1, [r7, #0x8]
 8017c18: 607a         	str	r2, [r7, #0x4]
 8017c1a: 603b         	str	r3, [r7]
; 	return pllsrc_freq / pllm_div * plln_mul / pllout_div;
 8017c1c: 68bb         	ldr	r3, [r7, #0x8]
 8017c1e: 68fa         	ldr	r2, [r7, #0xc]
 8017c20: fbb2 f3f3    	udiv	r3, r2, r3
 8017c24: 687a         	ldr	r2, [r7, #0x4]
 8017c26: fb03 f202    	mul	r2, r3, r2
 8017c2a: 683b         	ldr	r3, [r7]
 8017c2c: fbb2 f3f3    	udiv	r3, r2, r3
; }
 8017c30: 4618         	mov	r0, r3
 8017c32: 3714         	adds	r7, #0x14
 8017c34: 46bd         	mov	sp, r7
 8017c36: f85d 7b04    	ldr	r7, [sp], #4
 8017c3a: 4770         	bx	lr

08017c3c <get_bus_clock>:
; {
 8017c3c: b480         	push	{r7}
 8017c3e: b083         	sub	sp, #0xc
 8017c40: af00         	add	r7, sp, #0x0
 8017c42: 6078         	str	r0, [r7, #0x4]
 8017c44: 6039         	str	r1, [r7]
; 	return clock / prescaler;
 8017c46: 687a         	ldr	r2, [r7, #0x4]
 8017c48: 683b         	ldr	r3, [r7]
 8017c4a: fbb2 f3f3    	udiv	r3, r2, r3
; }
 8017c4e: 4618         	mov	r0, r3
 8017c50: 370c         	adds	r7, #0xc
 8017c52: 46bd         	mov	sp, r7
 8017c54: f85d 7b04    	ldr	r7, [sp], #4
 8017c58: 4770         	bx	lr

08017c5a <stm32_clock_control_on>:
; {
 8017c5a: b480         	push	{r7}
 8017c5c: b089         	sub	sp, #0x24
 8017c5e: af00         	add	r7, sp, #0x0
 8017c60: 6078         	str	r0, [r7, #0x4]
 8017c62: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8017c64: 683b         	ldr	r3, [r7]
 8017c66: 61fb         	str	r3, [r7, #0x1c]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 8017c68: 69fb         	ldr	r3, [r7, #0x1c]
 8017c6a: 681b         	ldr	r3, [r3]
 8017c6c: 2b2f         	cmp	r3, #0x2f
 8017c6e: d905         	bls	0x8017c7c <stm32_clock_control_on+0x22> @ imm = #0xa
 8017c70: 69fb         	ldr	r3, [r7, #0x1c]
 8017c72: 681b         	ldr	r3, [r3]
 8017c74: 2ba8         	cmp	r3, #0xa8
 8017c76: d801         	bhi	0x8017c7c <stm32_clock_control_on+0x22> @ imm = #0x2
 8017c78: 2301         	movs	r3, #0x1
 8017c7a: e000         	b	0x8017c7e <stm32_clock_control_on+0x24> @ imm = #0x0
 8017c7c: 2300         	movs	r3, #0x0
 8017c7e: 2b00         	cmp	r3, #0x0
 8017c80: d102         	bne	0x8017c88 <stm32_clock_control_on+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 8017c82: f06f 0385    	mvn	r3, #0x85
 8017c86: e01e         	b	0x8017cc6 <stm32_clock_control_on+0x6c> @ imm = #0x3c
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 8017c88: 69fb         	ldr	r3, [r7, #0x1c]
 8017c8a: 681b         	ldr	r3, [r3]
 8017c8c: f103 4380    	add.w	r3, r3, #0x40000000
 8017c90: f503 330e    	add.w	r3, r3, #0x23800
 8017c94: 69fa         	ldr	r2, [r7, #0x1c]
 8017c96: 6852         	ldr	r2, [r2, #0x4]
 8017c98: 617b         	str	r3, [r7, #0x14]
 8017c9a: 613a         	str	r2, [r7, #0x10]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8017c9c: 697b         	ldr	r3, [r7, #0x14]
 8017c9e: 681b         	ldr	r3, [r3]
 8017ca0: 60fb         	str	r3, [r7, #0xc]
; 	*(volatile uint32_t *)addr = temp | mask;
 8017ca2: 697b         	ldr	r3, [r7, #0x14]
 8017ca4: 6939         	ldr	r1, [r7, #0x10]
 8017ca6: 68fa         	ldr	r2, [r7, #0xc]
 8017ca8: 430a         	orrs	r2, r1
 8017caa: 601a         	str	r2, [r3]
; }
 8017cac: bf00         	nop
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 8017cae: 69fb         	ldr	r3, [r7, #0x1c]
 8017cb0: 681b         	ldr	r3, [r3]
 8017cb2: f103 4380    	add.w	r3, r3, #0x40000000
 8017cb6: f503 330e    	add.w	r3, r3, #0x23800
 8017cba: 61bb         	str	r3, [r7, #0x18]
; 	return *(volatile uint32_t *)addr;
 8017cbc: 69bb         	ldr	r3, [r7, #0x18]
 8017cbe: 681b         	ldr	r3, [r3]
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 8017cc0: 60bb         	str	r3, [r7, #0x8]
; 	UNUSED(temp);
 8017cc2: 68bb         	ldr	r3, [r7, #0x8]
; 	return 0;
 8017cc4: 2300         	movs	r3, #0x0
; }
 8017cc6: 4618         	mov	r0, r3
 8017cc8: 3724         	adds	r7, #0x24
 8017cca: 46bd         	mov	sp, r7
 8017ccc: f85d 7b04    	ldr	r7, [sp], #4
 8017cd0: 4770         	bx	lr

08017cd2 <stm32_clock_control_off>:
; {
 8017cd2: b480         	push	{r7}
 8017cd4: b087         	sub	sp, #0x1c
 8017cd6: af00         	add	r7, sp, #0x0
 8017cd8: 6078         	str	r0, [r7, #0x4]
 8017cda: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8017cdc: 683b         	ldr	r3, [r7]
 8017cde: 617b         	str	r3, [r7, #0x14]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 8017ce0: 697b         	ldr	r3, [r7, #0x14]
 8017ce2: 681b         	ldr	r3, [r3]
 8017ce4: 2b2f         	cmp	r3, #0x2f
 8017ce6: d905         	bls	0x8017cf4 <stm32_clock_control_off+0x22> @ imm = #0xa
 8017ce8: 697b         	ldr	r3, [r7, #0x14]
 8017cea: 681b         	ldr	r3, [r3]
 8017cec: 2ba8         	cmp	r3, #0xa8
 8017cee: d801         	bhi	0x8017cf4 <stm32_clock_control_off+0x22> @ imm = #0x2
 8017cf0: 2301         	movs	r3, #0x1
 8017cf2: e000         	b	0x8017cf6 <stm32_clock_control_off+0x24> @ imm = #0x0
 8017cf4: 2300         	movs	r3, #0x0
 8017cf6: 2b00         	cmp	r3, #0x0
 8017cf8: d102         	bne	0x8017d00 <stm32_clock_control_off+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 8017cfa: f06f 0385    	mvn	r3, #0x85
 8017cfe: e014         	b	0x8017d2a <stm32_clock_control_off+0x58> @ imm = #0x28
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 8017d00: 697b         	ldr	r3, [r7, #0x14]
 8017d02: 681b         	ldr	r3, [r3]
 8017d04: f103 4380    	add.w	r3, r3, #0x40000000
 8017d08: f503 330e    	add.w	r3, r3, #0x23800
 8017d0c: 697a         	ldr	r2, [r7, #0x14]
 8017d0e: 6852         	ldr	r2, [r2, #0x4]
 8017d10: 613b         	str	r3, [r7, #0x10]
 8017d12: 60fa         	str	r2, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8017d14: 693b         	ldr	r3, [r7, #0x10]
 8017d16: 681b         	ldr	r3, [r3]
 8017d18: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 8017d1a: 68fb         	ldr	r3, [r7, #0xc]
 8017d1c: 43d9         	mvns	r1, r3
 8017d1e: 693b         	ldr	r3, [r7, #0x10]
 8017d20: 68ba         	ldr	r2, [r7, #0x8]
 8017d22: 400a         	ands	r2, r1
 8017d24: 601a         	str	r2, [r3]
; }
 8017d26: bf00         	nop
; 	return 0;
 8017d28: 2300         	movs	r3, #0x0
; }
 8017d2a: 4618         	mov	r0, r3
 8017d2c: 371c         	adds	r7, #0x1c
 8017d2e: 46bd         	mov	sp, r7
 8017d30: f85d 7b04    	ldr	r7, [sp], #4
 8017d34: 4770         	bx	lr

08017d36 <stm32_clock_control_configure>:
; {
 8017d36: b580         	push	{r7, lr}
 8017d38: b08c         	sub	sp, #0x30
 8017d3a: af00         	add	r7, sp, #0x0
 8017d3c: 60f8         	str	r0, [r7, #0xc]
 8017d3e: 60b9         	str	r1, [r7, #0x8]
 8017d40: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 8017d42: 68bb         	ldr	r3, [r7, #0x8]
 8017d44: 62fb         	str	r3, [r7, #0x2c]
; 	err = enabled_clock(pclken->bus);
 8017d46: 6afb         	ldr	r3, [r7, #0x2c]
 8017d48: 681b         	ldr	r3, [r3]
 8017d4a: 4618         	mov	r0, r3
 8017d4c: f7ef ff26    	bl	0x8007b9c <enabled_clock> @ imm = #-0x101b4
 8017d50: 62b8         	str	r0, [r7, #0x28]
; 	if (err < 0) {
 8017d52: 6abb         	ldr	r3, [r7, #0x28]
 8017d54: 2b00         	cmp	r3, #0x0
 8017d56: da01         	bge	0x8017d5c <stm32_clock_control_configure+0x26> @ imm = #0x2
; 		return err;
 8017d58: 6abb         	ldr	r3, [r7, #0x28]
 8017d5a: e043         	b	0x8017de4 <stm32_clock_control_configure+0xae> @ imm = #0x86
; 	if (pclken->enr == NO_SEL) {
 8017d5c: 6afb         	ldr	r3, [r7, #0x2c]
 8017d5e: 685b         	ldr	r3, [r3, #0x4]
 8017d60: 2bff         	cmp	r3, #0xff
 8017d62: d101         	bne	0x8017d68 <stm32_clock_control_configure+0x32> @ imm = #0x2
; 		return 0;
 8017d64: 2300         	movs	r3, #0x0
 8017d66: e03d         	b	0x8017de4 <stm32_clock_control_configure+0xae> @ imm = #0x7a
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8017d68: 6afb         	ldr	r3, [r7, #0x2c]
 8017d6a: 685b         	ldr	r3, [r3, #0x4]
 8017d6c: b2db         	uxtb	r3, r3
 8017d6e: f103 4380    	add.w	r3, r3, #0x40000000
 8017d72: f503 330e    	add.w	r3, r3, #0x23800
; 		       STM32_CLOCK_MASK_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 8017d76: 6afa         	ldr	r2, [r7, #0x2c]
 8017d78: 6852         	ldr	r2, [r2, #0x4]
 8017d7a: 0b52         	lsrs	r2, r2, #0xd
 8017d7c: f002 0107    	and	r1, r2, #0x7
 8017d80: 6afa         	ldr	r2, [r7, #0x2c]
 8017d82: 6852         	ldr	r2, [r2, #0x4]
 8017d84: 0a12         	lsrs	r2, r2, #0x8
 8017d86: f002 021f    	and	r2, r2, #0x1f
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8017d8a: fa01 f202    	lsl.w	r2, r1, r2
 8017d8e: 61bb         	str	r3, [r7, #0x18]
 8017d90: 617a         	str	r2, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8017d92: 69bb         	ldr	r3, [r7, #0x18]
 8017d94: 681b         	ldr	r3, [r3]
 8017d96: 613b         	str	r3, [r7, #0x10]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 8017d98: 697b         	ldr	r3, [r7, #0x14]
 8017d9a: 43d9         	mvns	r1, r3
 8017d9c: 69bb         	ldr	r3, [r7, #0x18]
 8017d9e: 693a         	ldr	r2, [r7, #0x10]
 8017da0: 400a         	ands	r2, r1
 8017da2: 601a         	str	r2, [r3]
; }
 8017da4: bf00         	nop
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8017da6: 6afb         	ldr	r3, [r7, #0x2c]
 8017da8: 685b         	ldr	r3, [r3, #0x4]
 8017daa: b2db         	uxtb	r3, r3
 8017dac: f103 4380    	add.w	r3, r3, #0x40000000
 8017db0: f503 330e    	add.w	r3, r3, #0x23800
; 		     STM32_CLOCK_VAL_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 8017db4: 6afa         	ldr	r2, [r7, #0x2c]
 8017db6: 6852         	ldr	r2, [r2, #0x4]
 8017db8: 0c12         	lsrs	r2, r2, #0x10
 8017dba: f002 0107    	and	r1, r2, #0x7
 8017dbe: 6afa         	ldr	r2, [r7, #0x2c]
 8017dc0: 6852         	ldr	r2, [r2, #0x4]
 8017dc2: 0a12         	lsrs	r2, r2, #0x8
 8017dc4: f002 021f    	and	r2, r2, #0x1f
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 8017dc8: fa01 f202    	lsl.w	r2, r1, r2
 8017dcc: 627b         	str	r3, [r7, #0x24]
 8017dce: 623a         	str	r2, [r7, #0x20]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8017dd0: 6a7b         	ldr	r3, [r7, #0x24]
 8017dd2: 681b         	ldr	r3, [r3]
 8017dd4: 61fb         	str	r3, [r7, #0x1c]
; 	*(volatile uint32_t *)addr = temp | mask;
 8017dd6: 6a7b         	ldr	r3, [r7, #0x24]
 8017dd8: 6a39         	ldr	r1, [r7, #0x20]
 8017dda: 69fa         	ldr	r2, [r7, #0x1c]
 8017ddc: 430a         	orrs	r2, r1
 8017dde: 601a         	str	r2, [r3]
; }
 8017de0: bf00         	nop
; 	return 0;
 8017de2: 2300         	movs	r3, #0x0
; }
 8017de4: 4618         	mov	r0, r3
 8017de6: 3730         	adds	r7, #0x30
 8017de8: 46bd         	mov	sp, r7
 8017dea: bd80         	pop	{r7, pc}

08017dec <stm32_clock_control_get_status>:
; {
 8017dec: b580         	push	{r7, lr}
 8017dee: b084         	sub	sp, #0x10
 8017df0: af00         	add	r7, sp, #0x0
 8017df2: 6078         	str	r0, [r7, #0x4]
 8017df4: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)sub_system;
 8017df6: 683b         	ldr	r3, [r7]
 8017df8: 60fb         	str	r3, [r7, #0xc]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == true) {
 8017dfa: 68fb         	ldr	r3, [r7, #0xc]
 8017dfc: 681b         	ldr	r3, [r3]
 8017dfe: 2b2f         	cmp	r3, #0x2f
 8017e00: d905         	bls	0x8017e0e <stm32_clock_control_get_status+0x22> @ imm = #0xa
 8017e02: 68fb         	ldr	r3, [r7, #0xc]
 8017e04: 681b         	ldr	r3, [r3]
 8017e06: 2ba8         	cmp	r3, #0xa8
 8017e08: d801         	bhi	0x8017e0e <stm32_clock_control_get_status+0x22> @ imm = #0x2
 8017e0a: 2301         	movs	r3, #0x1
 8017e0c: e000         	b	0x8017e10 <stm32_clock_control_get_status+0x24> @ imm = #0x0
 8017e0e: 2300         	movs	r3, #0x0
 8017e10: 2b01         	cmp	r3, #0x1
 8017e12: d113         	bne	0x8017e3c <stm32_clock_control_get_status+0x50> @ imm = #0x26
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 8017e14: 68fb         	ldr	r3, [r7, #0xc]
 8017e16: 681b         	ldr	r3, [r3]
 8017e18: f103 4380    	add.w	r3, r3, #0x40000000
 8017e1c: f503 330e    	add.w	r3, r3, #0x23800
 8017e20: 60bb         	str	r3, [r7, #0x8]
; 	return *(volatile uint32_t *)addr;
 8017e22: 68bb         	ldr	r3, [r7, #0x8]
 8017e24: 681a         	ldr	r2, [r3]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 8017e26: 68fb         	ldr	r3, [r7, #0xc]
 8017e28: 685b         	ldr	r3, [r3, #0x4]
 8017e2a: 401a         	ands	r2, r3
; 		    == pclken->enr) {
 8017e2c: 68fb         	ldr	r3, [r7, #0xc]
 8017e2e: 685b         	ldr	r3, [r3, #0x4]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 8017e30: 429a         	cmp	r2, r3
 8017e32: d101         	bne	0x8017e38 <stm32_clock_control_get_status+0x4c> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 8017e34: 2302         	movs	r3, #0x2
 8017e36: e00c         	b	0x8017e52 <stm32_clock_control_get_status+0x66> @ imm = #0x18
; 			return CLOCK_CONTROL_STATUS_OFF;
 8017e38: 2301         	movs	r3, #0x1
 8017e3a: e00a         	b	0x8017e52 <stm32_clock_control_get_status+0x66> @ imm = #0x14
; 		if (enabled_clock(pclken->bus) == 0) {
 8017e3c: 68fb         	ldr	r3, [r7, #0xc]
 8017e3e: 681b         	ldr	r3, [r3]
 8017e40: 4618         	mov	r0, r3
 8017e42: f7ef feab    	bl	0x8007b9c <enabled_clock> @ imm = #-0x102aa
 8017e46: 4603         	mov	r3, r0
 8017e48: 2b00         	cmp	r3, #0x0
 8017e4a: d101         	bne	0x8017e50 <stm32_clock_control_get_status+0x64> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 8017e4c: 2302         	movs	r3, #0x2
 8017e4e: e000         	b	0x8017e52 <stm32_clock_control_get_status+0x66> @ imm = #0x0
; 			return CLOCK_CONTROL_STATUS_OFF;
 8017e50: 2301         	movs	r3, #0x1
; }
 8017e52: 4618         	mov	r0, r3
 8017e54: 3710         	adds	r7, #0x10
 8017e56: 46bd         	mov	sp, r7
 8017e58: bd80         	pop	{r7, pc}

08017e5a <stm32_clock_switch_to_hsi>:
; {
 8017e5a: b580         	push	{r7, lr}
 8017e5c: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_HSI_IsReady() != 1) {
 8017e5e: f7ef fdc9    	bl	0x80079f4 <LL_RCC_HSI_IsReady> @ imm = #-0x1046e
 8017e62: 4603         	mov	r3, r0
 8017e64: 2b01         	cmp	r3, #0x1
 8017e66: d007         	beq	0x8017e78 <stm32_clock_switch_to_hsi+0x1e> @ imm = #0xe
; 		LL_RCC_HSI_Enable();
 8017e68: f7ef fdb4    	bl	0x80079d4 <LL_RCC_HSI_Enable> @ imm = #-0x10498
; 		while (LL_RCC_HSI_IsReady() != 1) {
 8017e6c: bf00         	nop
 8017e6e: f7ef fdc1    	bl	0x80079f4 <LL_RCC_HSI_IsReady> @ imm = #-0x1047e
 8017e72: 4603         	mov	r3, r0
 8017e74: 2b01         	cmp	r3, #0x1
 8017e76: d1fa         	bne	0x8017e6e <stm32_clock_switch_to_hsi+0x14> @ imm = #-0xc
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);
 8017e78: 2000         	movs	r0, #0x0
 8017e7a: f7ef fdef    	bl	0x8007a5c <LL_RCC_SetSysClkSource> @ imm = #-0x10422
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI) {
 8017e7e: bf00         	nop
 8017e80: f7ef fe00    	bl	0x8007a84 <LL_RCC_GetSysClkSource> @ imm = #-0x10400
 8017e84: 4603         	mov	r3, r0
 8017e86: 2b00         	cmp	r3, #0x0
 8017e88: d1fa         	bne	0x8017e80 <stm32_clock_switch_to_hsi+0x26> @ imm = #-0xc
; }
 8017e8a: bf00         	nop
 8017e8c: bf00         	nop
 8017e8e: bd80         	pop	{r7, pc}

08017e90 <set_up_fixed_clock_sources>:
; {
 8017e90: b580         	push	{r7, lr}
 8017e92: af00         	add	r7, sp, #0x0
; 			LL_RCC_HSE_DisableBypass();
 8017e94: f7ef fd6a    	bl	0x800796c <LL_RCC_HSE_DisableBypass> @ imm = #-0x1052c
; 		LL_RCC_HSE_Enable();
 8017e98: f7ef fd78    	bl	0x800798c <LL_RCC_HSE_Enable> @ imm = #-0x10510
; 		while (LL_RCC_HSE_IsReady() != 1) {
 8017e9c: bf00         	nop
 8017e9e: f7ef fd85    	bl	0x80079ac <LL_RCC_HSE_IsReady> @ imm = #-0x104f6
 8017ea2: 4603         	mov	r3, r0
 8017ea4: 2b01         	cmp	r3, #0x1
 8017ea6: d1fa         	bne	0x8017e9e <set_up_fixed_clock_sources+0xe> @ imm = #-0xc
; 		LL_RCC_LSI_Enable();
 8017ea8: f7ef fdb6    	bl	0x8007a18 <LL_RCC_LSI_Enable> @ imm = #-0x10494
; 		while (LL_RCC_LSI_IsReady() != 1) {
 8017eac: bf00         	nop
 8017eae: f7ef fdc3    	bl	0x8007a38 <LL_RCC_LSI_IsReady> @ imm = #-0x1047a
 8017eb2: 4603         	mov	r3, r0
 8017eb4: 2b01         	cmp	r3, #0x1
 8017eb6: d1fa         	bne	0x8017eae <set_up_fixed_clock_sources+0x1e> @ imm = #-0xc
; }
 8017eb8: bf00         	nop
 8017eba: bf00         	nop
 8017ebc: bd80         	pop	{r7, pc}

08017ebe <config_regulator_voltage>:
; void __weak config_regulator_voltage(uint32_t hclk_freq) {}
 8017ebe: b480         	push	{r7}
 8017ec0: b083         	sub	sp, #0xc
 8017ec2: af00         	add	r7, sp, #0x0
 8017ec4: 6078         	str	r0, [r7, #0x4]
 8017ec6: bf00         	nop
 8017ec8: 370c         	adds	r7, #0xc
 8017eca: 46bd         	mov	sp, r7
 8017ecc: f85d 7b04    	ldr	r7, [sp], #4
 8017ed0: 4770         	bx	lr

08017ed2 <get_pll_source>:
; {
 8017ed2: b480         	push	{r7}
 8017ed4: af00         	add	r7, sp, #0x0
; 		return LL_RCC_PLLSOURCE_HSE;
 8017ed6: f44f 0380    	mov.w	r3, #0x400000
; }
 8017eda: 4618         	mov	r0, r3
 8017edc: 46bd         	mov	sp, r7
 8017ede: f85d 7b04    	ldr	r7, [sp], #4
 8017ee2: 4770         	bx	lr

08017ee4 <config_pll_sysclock>:
; {
 8017ee4: b580         	push	{r7, lr}
 8017ee6: af00         	add	r7, sp, #0x0
; 	LL_RCC_PLL_ConfigDomain_SYS(get_pll_source(),
 8017ee8: f7ff fff3    	bl	0x8017ed2 <get_pll_source> @ imm = #-0x1a
 8017eec: 2300         	movs	r3, #0x0
 8017eee: 22a8         	movs	r2, #0xa8
 8017ef0: 2106         	movs	r1, #0x6
 8017ef2: f7f0 f825    	bl	0x8007f40 <LL_RCC_PLL_ConfigDomain_SYS> @ imm = #-0xffb6
; }
 8017ef6: bf00         	nop
 8017ef8: bd80         	pop	{r7, pc}

08017efa <config_enable_default_clocks>:
; {
 8017efa: b580         	push	{r7, lr}
 8017efc: af00         	add	r7, sp, #0x0
; 	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
 8017efe: f04f 5080    	mov.w	r0, #0x10000000
 8017f02: f7f0 f805    	bl	0x8007f10 <LL_APB1_GRP1_EnableClock> @ imm = #-0xfff6
; }
 8017f06: bf00         	nop
 8017f08: bd80         	pop	{r7, pc}

08017f0a <device_is_ready>:
; {
 8017f0a: b580         	push	{r7, lr}
 8017f0c: b082         	sub	sp, #0x8
 8017f0e: af00         	add	r7, sp, #0x0
 8017f10: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8017f12: 6878         	ldr	r0, [r7, #0x4]
 8017f14: f006 f85c    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x60b8
 8017f18: 4603         	mov	r3, r0
; }
 8017f1a: 4618         	mov	r0, r3
 8017f1c: 3708         	adds	r7, #0x8
 8017f1e: 46bd         	mov	sp, r7
 8017f20: bd80         	pop	{r7, pc}

08017f22 <z_impl_uart_poll_out>:
; {
 8017f22: b580         	push	{r7, lr}
 8017f24: b084         	sub	sp, #0x10
 8017f26: af00         	add	r7, sp, #0x0
 8017f28: 6078         	str	r0, [r7, #0x4]
 8017f2a: 460b         	mov	r3, r1
 8017f2c: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 8017f2e: 687b         	ldr	r3, [r7, #0x4]
 8017f30: 689b         	ldr	r3, [r3, #0x8]
 8017f32: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 8017f34: 68fb         	ldr	r3, [r7, #0xc]
 8017f36: 69db         	ldr	r3, [r3, #0x1c]
 8017f38: 78fa         	ldrb	r2, [r7, #0x3]
 8017f3a: 4611         	mov	r1, r2
 8017f3c: 6878         	ldr	r0, [r7, #0x4]
 8017f3e: 4798         	blx	r3
; }
 8017f40: bf00         	nop
 8017f42: 3710         	adds	r7, #0x10
 8017f44: 46bd         	mov	sp, r7
 8017f46: bd80         	pop	{r7, pc}

08017f48 <uart_poll_out>:
; {
 8017f48: b580         	push	{r7, lr}
 8017f4a: b082         	sub	sp, #0x8
 8017f4c: af00         	add	r7, sp, #0x0
 8017f4e: 6078         	str	r0, [r7, #0x4]
 8017f50: 460b         	mov	r3, r1
 8017f52: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 8017f54: 78fb         	ldrb	r3, [r7, #0x3]
 8017f56: 4619         	mov	r1, r3
 8017f58: 6878         	ldr	r0, [r7, #0x4]
 8017f5a: f7ff ffe2    	bl	0x8017f22 <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 8017f5e: bf00         	nop
 8017f60: 3708         	adds	r7, #0x8
 8017f62: 46bd         	mov	sp, r7
 8017f64: bd80         	pop	{r7, pc}

08017f66 <pm_device_runtime_get>:
; {
 8017f66: b480         	push	{r7}
 8017f68: b083         	sub	sp, #0xc
 8017f6a: af00         	add	r7, sp, #0x0
 8017f6c: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8017f6e: 2300         	movs	r3, #0x0
; }
 8017f70: 4618         	mov	r0, r3
 8017f72: 370c         	adds	r7, #0xc
 8017f74: 46bd         	mov	sp, r7
 8017f76: f85d 7b04    	ldr	r7, [sp], #4
 8017f7a: 4770         	bx	lr

08017f7c <pm_device_runtime_put_async>:
; {
 8017f7c: b480         	push	{r7}
 8017f7e: b085         	sub	sp, #0x14
 8017f80: af00         	add	r7, sp, #0x0
 8017f82: 60f8         	str	r0, [r7, #0xc]
 8017f84: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 8017f88: 2300         	movs	r3, #0x0
; }
 8017f8a: 4618         	mov	r0, r3
 8017f8c: 3714         	adds	r7, #0x14
 8017f8e: 46bd         	mov	sp, r7
 8017f90: f85d 7b04    	ldr	r7, [sp], #4
 8017f94: 4770         	bx	lr

08017f96 <device_is_ready>:
; {
 8017f96: b580         	push	{r7, lr}
 8017f98: b082         	sub	sp, #0x8
 8017f9a: af00         	add	r7, sp, #0x0
 8017f9c: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8017f9e: 6878         	ldr	r0, [r7, #0x4]
 8017fa0: f006 f816    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x602c
 8017fa4: 4603         	mov	r3, r0
; }
 8017fa6: 4618         	mov	r0, r3
 8017fa8: 3708         	adds	r7, #0x8
 8017faa: 46bd         	mov	sp, r7
 8017fac: bd80         	pop	{r7, pc}

08017fae <k_sleep>:
; {
 8017fae: b580         	push	{r7, lr}
 8017fb0: b082         	sub	sp, #0x8
 8017fb2: af00         	add	r7, sp, #0x0
 8017fb4: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 8017fb8: e9d7 0100    	ldrd	r0, r1, [r7]
 8017fbc: f7fa f908    	bl	0x80121d0 <z_impl_k_sleep> @ imm = #-0x5df0
 8017fc0: 4603         	mov	r3, r0
; }
 8017fc2: 4618         	mov	r0, r3
 8017fc4: 3708         	adds	r7, #0x8
 8017fc6: 46bd         	mov	sp, r7
 8017fc8: bd80         	pop	{r7, pc}

08017fca <clock_control_on>:
; {
 8017fca: b580         	push	{r7, lr}
 8017fcc: b084         	sub	sp, #0x10
 8017fce: af00         	add	r7, sp, #0x0
 8017fd0: 6078         	str	r0, [r7, #0x4]
 8017fd2: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8017fd4: 687b         	ldr	r3, [r7, #0x4]
 8017fd6: 689b         	ldr	r3, [r3, #0x8]
 8017fd8: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8017fda: 68fb         	ldr	r3, [r7, #0xc]
 8017fdc: 681b         	ldr	r3, [r3]
 8017fde: 6839         	ldr	r1, [r7]
 8017fe0: 6878         	ldr	r0, [r7, #0x4]
 8017fe2: 4798         	blx	r3
 8017fe4: 4603         	mov	r3, r0
; }
 8017fe6: 4618         	mov	r0, r3
 8017fe8: 3710         	adds	r7, #0x10
 8017fea: 46bd         	mov	sp, r7
 8017fec: bd80         	pop	{r7, pc}

08017fee <z_log_msg_runtime_create>:
; {
 8017fee: b580         	push	{r7, lr}
 8017ff0: b08a         	sub	sp, #0x28
 8017ff2: af04         	add	r7, sp, #0x10
 8017ff4: 60b9         	str	r1, [r7, #0x8]
 8017ff6: 607b         	str	r3, [r7, #0x4]
 8017ff8: 4603         	mov	r3, r0
 8017ffa: 73fb         	strb	r3, [r7, #0xf]
 8017ffc: 4613         	mov	r3, r2
 8017ffe: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8018000: f107 032c    	add.w	r3, r7, #0x2c
 8018004: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8018006: 7bba         	ldrb	r2, [r7, #0xe]
 8018008: 7bf8         	ldrb	r0, [r7, #0xf]
 801800a: 697b         	ldr	r3, [r7, #0x14]
 801800c: 9303         	str	r3, [sp, #0xc]
 801800e: 6abb         	ldr	r3, [r7, #0x28]
 8018010: 9302         	str	r3, [sp, #0x8]
 8018012: 6a7b         	ldr	r3, [r7, #0x24]
 8018014: 9301         	str	r3, [sp, #0x4]
 8018016: 6a3b         	ldr	r3, [r7, #0x20]
 8018018: 9300         	str	r3, [sp]
 801801a: 687b         	ldr	r3, [r7, #0x4]
 801801c: 68b9         	ldr	r1, [r7, #0x8]
 801801e: f7ed faa9    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x12aae
; }
 8018022: bf00         	nop
 8018024: 3718         	adds	r7, #0x18
 8018026: 46bd         	mov	sp, r7
 8018028: bd80         	pop	{r7, pc}

0801802a <dma_stm32_dump_stream_irq>:
; {
 801802a: b580         	push	{r7, lr}
 801802c: b084         	sub	sp, #0x10
 801802e: af00         	add	r7, sp, #0x0
 8018030: 6078         	str	r0, [r7, #0x4]
 8018032: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8018034: 687b         	ldr	r3, [r7, #0x4]
 8018036: 685b         	ldr	r3, [r3, #0x4]
 8018038: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801803a: 68fb         	ldr	r3, [r7, #0xc]
 801803c: 691b         	ldr	r3, [r3, #0x10]
 801803e: 60bb         	str	r3, [r7, #0x8]
; 	stm32_dma_dump_stream_irq(dma, id);
 8018040: 6839         	ldr	r1, [r7]
 8018042: 68b8         	ldr	r0, [r7, #0x8]
 8018044: f7f1 f9de    	bl	0x8009404 <stm32_dma_dump_stream_irq> @ imm = #-0xec44
; }
 8018048: bf00         	nop
 801804a: 3710         	adds	r7, #0x10
 801804c: 46bd         	mov	sp, r7
 801804e: bd80         	pop	{r7, pc}

08018050 <dma_stm32_clear_stream_irq>:
; {
 8018050: b580         	push	{r7, lr}
 8018052: b084         	sub	sp, #0x10
 8018054: af00         	add	r7, sp, #0x0
 8018056: 6078         	str	r0, [r7, #0x4]
 8018058: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 801805a: 687b         	ldr	r3, [r7, #0x4]
 801805c: 685b         	ldr	r3, [r3, #0x4]
 801805e: 60fb         	str	r3, [r7, #0xc]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 8018060: 68fb         	ldr	r3, [r7, #0xc]
 8018062: 691b         	ldr	r3, [r3, #0x10]
 8018064: 60bb         	str	r3, [r7, #0x8]
; 	dma_stm32_clear_tc(dma, id);
 8018066: 6839         	ldr	r1, [r7]
 8018068: 68b8         	ldr	r0, [r7, #0x8]
 801806a: f7f1 f90b    	bl	0x8009284 <dma_stm32_clear_tc> @ imm = #-0xedea
; 	dma_stm32_clear_ht(dma, id);
 801806e: 6839         	ldr	r1, [r7]
 8018070: 68b8         	ldr	r0, [r7, #0x8]
 8018072: f7f1 f8f5    	bl	0x8009260 <dma_stm32_clear_ht> @ imm = #-0xee16
; 	stm32_dma_clear_stream_irq(dma, id);
 8018076: 6839         	ldr	r1, [r7]
 8018078: 68b8         	ldr	r0, [r7, #0x8]
 801807a: f001 f843    	bl	0x8019104 <stm32_dma_clear_stream_irq> @ imm = #0x1086
; }
 801807e: bf00         	nop
 8018080: 3710         	adds	r7, #0x10
 8018082: 46bd         	mov	sp, r7
 8018084: bd80         	pop	{r7, pc}

08018086 <dma_stm32_disable_stream>:
; {
 8018086: b580         	push	{r7, lr}
 8018088: b084         	sub	sp, #0x10
 801808a: af00         	add	r7, sp, #0x0
 801808c: 6078         	str	r0, [r7, #0x4]
 801808e: 6039         	str	r1, [r7]
; 	int count = 0;
 8018090: 2300         	movs	r3, #0x0
 8018092: 60fb         	str	r3, [r7, #0xc]
; 		if (stm32_dma_disable_stream(dma, id) == 0) {
 8018094: 6839         	ldr	r1, [r7]
 8018096: 6878         	ldr	r0, [r7, #0x4]
 8018098: f001 f871    	bl	0x801917e <stm32_dma_disable_stream> @ imm = #0x10e2
 801809c: 4603         	mov	r3, r0
 801809e: 2b00         	cmp	r3, #0x0
 80180a0: d101         	bne	0x80180a6 <dma_stm32_disable_stream+0x20> @ imm = #0x2
; 			return 0;
 80180a2: 2100         	movs	r1, #0x0
 80180a4: e012         	b	0x80180cc <dma_stm32_disable_stream+0x46> @ imm = #0x24
; 		if (count++ > (5 * 1000)) {
 80180a6: 68fb         	ldr	r3, [r7, #0xc]
 80180a8: 1c5a         	adds	r2, r3, #0x1
 80180aa: 60fa         	str	r2, [r7, #0xc]
 80180ac: f241 3288    	movw	r2, #0x1388
 80180b0: 4293         	cmp	r3, r2
 80180b2: dd02         	ble	0x80180ba <dma_stm32_disable_stream+0x34> @ imm = #0x4
; 			return -EBUSY;
 80180b4: f06f 010f    	mvn	r1, #0xf
 80180b8: e008         	b	0x80180cc <dma_stm32_disable_stream+0x46> @ imm = #0x10
; 		k_sleep(K_MSEC(1));
 80180ba: f04f 020a    	mov.w	r2, #0xa
 80180be: f04f 0300    	mov.w	r3, #0x0
 80180c2: 4610         	mov	r0, r2
 80180c4: 4619         	mov	r1, r3
 80180c6: f7ff ff72    	bl	0x8017fae <k_sleep>     @ imm = #-0x11c
; 	for (;;) {
 80180ca: e7e3         	b	0x8018094 <dma_stm32_disable_stream+0xe> @ imm = #-0x3a
; }
 80180cc: 460b         	mov	r3, r1
 80180ce: 4618         	mov	r0, r3
 80180d0: 3710         	adds	r7, #0x10
 80180d2: 46bd         	mov	sp, r7
 80180d4: bd80         	pop	{r7, pc}

080180d6 <dma_stm32_reload>:
; {
 80180d6: b580         	push	{r7, lr}
 80180d8: b088         	sub	sp, #0x20
 80180da: af00         	add	r7, sp, #0x0
 80180dc: 60f8         	str	r0, [r7, #0xc]
 80180de: 60b9         	str	r1, [r7, #0x8]
 80180e0: 607a         	str	r2, [r7, #0x4]
 80180e2: 603b         	str	r3, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 80180e4: 68fb         	ldr	r3, [r7, #0xc]
 80180e6: 685b         	ldr	r3, [r3, #0x4]
 80180e8: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 80180ea: 69fb         	ldr	r3, [r7, #0x1c]
 80180ec: 691b         	ldr	r3, [r3, #0x10]
 80180ee: 61bb         	str	r3, [r7, #0x18]
; 	if (id >= config->max_streams) {
 80180f0: 69fb         	ldr	r3, [r7, #0x1c]
 80180f2: 695b         	ldr	r3, [r3, #0x14]
 80180f4: 68ba         	ldr	r2, [r7, #0x8]
 80180f6: 429a         	cmp	r2, r3
 80180f8: d302         	blo	0x8018100 <dma_stm32_reload+0x2a> @ imm = #0x4
; 		return -EINVAL;
 80180fa: f06f 0315    	mvn	r3, #0x15
 80180fe: e06c         	b	0x80181da <dma_stm32_reload+0x104> @ imm = #0xd8
; 	stream = &config->streams[id];
 8018100: 69fb         	ldr	r3, [r7, #0x1c]
 8018102: 6999         	ldr	r1, [r3, #0x18]
 8018104: 68ba         	ldr	r2, [r7, #0x8]
 8018106: 4613         	mov	r3, r2
 8018108: 00db         	lsls	r3, r3, #0x3
 801810a: 1a9b         	subs	r3, r3, r2
 801810c: 009b         	lsls	r3, r3, #0x2
 801810e: 440b         	add	r3, r1
 8018110: 617b         	str	r3, [r7, #0x14]
; 	if (dma_stm32_disable_stream(dma, id) != 0) {
 8018112: 68b9         	ldr	r1, [r7, #0x8]
 8018114: 69b8         	ldr	r0, [r7, #0x18]
 8018116: f7ff ffb6    	bl	0x8018086 <dma_stm32_disable_stream> @ imm = #-0x94
 801811a: 4603         	mov	r3, r0
 801811c: 2b00         	cmp	r3, #0x0
 801811e: d002         	beq	0x8018126 <dma_stm32_reload+0x50> @ imm = #0x4
; 		return -EBUSY;
 8018120: f06f 030f    	mvn	r3, #0xf
 8018124: e059         	b	0x80181da <dma_stm32_reload+0x104> @ imm = #0xb2
; 	switch (stream->direction) {
 8018126: 697b         	ldr	r3, [r7, #0x14]
 8018128: 681b         	ldr	r3, [r3]
 801812a: 2b02         	cmp	r3, #0x2
 801812c: d018         	beq	0x8018160 <dma_stm32_reload+0x8a> @ imm = #0x30
 801812e: 2b02         	cmp	r3, #0x2
 8018130: d829         	bhi	0x8018186 <dma_stm32_reload+0xb0> @ imm = #0x52
 8018132: 2b00         	cmp	r3, #0x0
 8018134: d014         	beq	0x8018160 <dma_stm32_reload+0x8a> @ imm = #0x28
 8018136: 2b01         	cmp	r3, #0x1
 8018138: d125         	bne	0x8018186 <dma_stm32_reload+0xb0> @ imm = #0x4a
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), src);
 801813a: 68b8         	ldr	r0, [r7, #0x8]
 801813c: f7f1 f870    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xef20
 8018140: 4603         	mov	r3, r0
 8018142: 687a         	ldr	r2, [r7, #0x4]
 8018144: 4619         	mov	r1, r3
 8018146: 69b8         	ldr	r0, [r7, #0x18]
 8018148: f7ef fff2    	bl	0x8008130 <LL_DMA_SetMemoryAddress> @ imm = #-0x1001c
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), dst);
 801814c: 68b8         	ldr	r0, [r7, #0x8]
 801814e: f7f1 f867    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xef32
 8018152: 4603         	mov	r3, r0
 8018154: 683a         	ldr	r2, [r7]
 8018156: 4619         	mov	r1, r3
 8018158: 69b8         	ldr	r0, [r7, #0x18]
 801815a: f7f0 f801    	bl	0x8008160 <LL_DMA_SetPeriphAddress> @ imm = #-0xfffe
; 		break;
 801815e: e015         	b	0x801818c <dma_stm32_reload+0xb6> @ imm = #0x2a
; 		LL_DMA_SetPeriphAddress(dma, dma_stm32_id_to_stream(id), src);
 8018160: 68b8         	ldr	r0, [r7, #0x8]
 8018162: f7f1 f85d    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xef46
 8018166: 4603         	mov	r3, r0
 8018168: 687a         	ldr	r2, [r7, #0x4]
 801816a: 4619         	mov	r1, r3
 801816c: 69b8         	ldr	r0, [r7, #0x18]
 801816e: f7ef fff7    	bl	0x8008160 <LL_DMA_SetPeriphAddress> @ imm = #-0x10012
; 		LL_DMA_SetMemoryAddress(dma, dma_stm32_id_to_stream(id), dst);
 8018172: 68b8         	ldr	r0, [r7, #0x8]
 8018174: f7f1 f854    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xef58
 8018178: 4603         	mov	r3, r0
 801817a: 683a         	ldr	r2, [r7]
 801817c: 4619         	mov	r1, r3
 801817e: 69b8         	ldr	r0, [r7, #0x18]
 8018180: f7ef ffd6    	bl	0x8008130 <LL_DMA_SetMemoryAddress> @ imm = #-0x10054
; 		break;
 8018184: e002         	b	0x801818c <dma_stm32_reload+0xb6> @ imm = #0x4
; 		return -EINVAL;
 8018186: f06f 0315    	mvn	r3, #0x15
 801818a: e026         	b	0x80181da <dma_stm32_reload+0x104> @ imm = #0x4c
; 	if (stream->source_periph) {
 801818c: 697b         	ldr	r3, [r7, #0x14]
 801818e: 791b         	ldrb	r3, [r3, #0x4]
 8018190: 2b00         	cmp	r3, #0x0
 8018192: d00d         	beq	0x80181b0 <dma_stm32_reload+0xda> @ imm = #0x1a
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 8018194: 68b8         	ldr	r0, [r7, #0x8]
 8018196: f7f1 f843    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xef7a
 801819a: 4601         	mov	r1, r0
; 				     size / stream->src_size);
 801819c: 697b         	ldr	r3, [r7, #0x14]
 801819e: 689b         	ldr	r3, [r3, #0x8]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 80181a0: 6aba         	ldr	r2, [r7, #0x28]
 80181a2: fbb2 f3f3    	udiv	r3, r2, r3
 80181a6: 461a         	mov	r2, r3
 80181a8: 69b8         	ldr	r0, [r7, #0x18]
 80181aa: f7ef ff47    	bl	0x800803c <LL_DMA_SetDataLength> @ imm = #-0x10172
 80181ae: e00c         	b	0x80181ca <dma_stm32_reload+0xf4> @ imm = #0x18
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 80181b0: 68b8         	ldr	r0, [r7, #0x8]
 80181b2: f7f1 f835    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xef96
 80181b6: 4601         	mov	r1, r0
; 				     size / stream->dst_size);
 80181b8: 697b         	ldr	r3, [r7, #0x14]
 80181ba: 68db         	ldr	r3, [r3, #0xc]
; 		LL_DMA_SetDataLength(dma, dma_stm32_id_to_stream(id),
 80181bc: 6aba         	ldr	r2, [r7, #0x28]
 80181be: fbb2 f3f3    	udiv	r3, r2, r3
 80181c2: 461a         	mov	r2, r3
 80181c4: 69b8         	ldr	r0, [r7, #0x18]
 80181c6: f7ef ff39    	bl	0x800803c <LL_DMA_SetDataLength> @ imm = #-0x1018e
; 	stream->busy = true;
 80181ca: 697b         	ldr	r3, [r7, #0x14]
 80181cc: 2201         	movs	r2, #0x1
 80181ce: 719a         	strb	r2, [r3, #0x6]
; 	stm32_dma_enable_stream(dma, id);
 80181d0: 68b9         	ldr	r1, [r7, #0x8]
 80181d2: 69b8         	ldr	r0, [r7, #0x18]
 80181d4: f000 ffab    	bl	0x801912e <stm32_dma_enable_stream> @ imm = #0xf56
; 	return 0;
 80181d8: 2300         	movs	r3, #0x0
; }
 80181da: 4618         	mov	r0, r3
 80181dc: 3720         	adds	r7, #0x20
 80181de: 46bd         	mov	sp, r7
 80181e0: bd80         	pop	{r7, pc}

080181e2 <dma_stm32_start>:
; {
 80181e2: b580         	push	{r7, lr}
 80181e4: b086         	sub	sp, #0x18
 80181e6: af00         	add	r7, sp, #0x0
 80181e8: 6078         	str	r0, [r7, #0x4]
 80181ea: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 80181ec: 687b         	ldr	r3, [r7, #0x4]
 80181ee: 685b         	ldr	r3, [r3, #0x4]
 80181f0: 617b         	str	r3, [r7, #0x14]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 80181f2: 697b         	ldr	r3, [r7, #0x14]
 80181f4: 691b         	ldr	r3, [r3, #0x10]
 80181f6: 613b         	str	r3, [r7, #0x10]
; 	if (id >= config->max_streams) {
 80181f8: 697b         	ldr	r3, [r7, #0x14]
 80181fa: 695b         	ldr	r3, [r3, #0x14]
 80181fc: 683a         	ldr	r2, [r7]
 80181fe: 429a         	cmp	r2, r3
 8018200: d302         	blo	0x8018208 <dma_stm32_start+0x26> @ imm = #0x4
; 		return -EINVAL;
 8018202: f06f 0315    	mvn	r3, #0x15
 8018206: e01d         	b	0x8018244 <dma_stm32_start+0x62> @ imm = #0x3a
; 	if (stm32_dma_is_enabled_stream(dma, id)) {
 8018208: 6839         	ldr	r1, [r7]
 801820a: 6938         	ldr	r0, [r7, #0x10]
 801820c: f000 ffa0    	bl	0x8019150 <stm32_dma_is_enabled_stream> @ imm = #0xf40
 8018210: 4603         	mov	r3, r0
 8018212: 2b00         	cmp	r3, #0x0
 8018214: d001         	beq	0x801821a <dma_stm32_start+0x38> @ imm = #0x2
; 		return 0;
 8018216: 2300         	movs	r3, #0x0
 8018218: e014         	b	0x8018244 <dma_stm32_start+0x62> @ imm = #0x28
; 	stream = &config->streams[id];
 801821a: 697b         	ldr	r3, [r7, #0x14]
 801821c: 6999         	ldr	r1, [r3, #0x18]
 801821e: 683a         	ldr	r2, [r7]
 8018220: 4613         	mov	r3, r2
 8018222: 00db         	lsls	r3, r3, #0x3
 8018224: 1a9b         	subs	r3, r3, r2
 8018226: 009b         	lsls	r3, r3, #0x2
 8018228: 440b         	add	r3, r1
 801822a: 60fb         	str	r3, [r7, #0xc]
; 	stream->busy = true;
 801822c: 68fb         	ldr	r3, [r7, #0xc]
 801822e: 2201         	movs	r2, #0x1
 8018230: 719a         	strb	r2, [r3, #0x6]
; 	dma_stm32_clear_stream_irq(dev, id);
 8018232: 6839         	ldr	r1, [r7]
 8018234: 6878         	ldr	r0, [r7, #0x4]
 8018236: f7ff ff0b    	bl	0x8018050 <dma_stm32_clear_stream_irq> @ imm = #-0x1ea
; 	stm32_dma_enable_stream(dma, id);
 801823a: 6839         	ldr	r1, [r7]
 801823c: 6938         	ldr	r0, [r7, #0x10]
 801823e: f000 ff76    	bl	0x801912e <stm32_dma_enable_stream> @ imm = #0xeec
; 	return 0;
 8018242: 2300         	movs	r3, #0x0
; }
 8018244: 4618         	mov	r0, r3
 8018246: 3718         	adds	r7, #0x18
 8018248: 46bd         	mov	sp, r7
 801824a: bd80         	pop	{r7, pc}

0801824c <dma_stm32_stop>:
; {
 801824c: b580         	push	{r7, lr}
 801824e: b086         	sub	sp, #0x18
 8018250: af00         	add	r7, sp, #0x0
 8018252: 6078         	str	r0, [r7, #0x4]
 8018254: 6039         	str	r1, [r7]
; 	const struct dma_stm32_config *config = dev->config;
 8018256: 687b         	ldr	r3, [r7, #0x4]
 8018258: 685b         	ldr	r3, [r3, #0x4]
 801825a: 617b         	str	r3, [r7, #0x14]
; 	struct dma_stm32_stream *stream = &config->streams[id - STM32_DMA_STREAM_OFFSET];
 801825c: 697b         	ldr	r3, [r7, #0x14]
 801825e: 6999         	ldr	r1, [r3, #0x18]
 8018260: 683a         	ldr	r2, [r7]
 8018262: 4613         	mov	r3, r2
 8018264: 00db         	lsls	r3, r3, #0x3
 8018266: 1a9b         	subs	r3, r3, r2
 8018268: 009b         	lsls	r3, r3, #0x2
 801826a: 440b         	add	r3, r1
 801826c: 613b         	str	r3, [r7, #0x10]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 801826e: 697b         	ldr	r3, [r7, #0x14]
 8018270: 691b         	ldr	r3, [r3, #0x10]
 8018272: 60fb         	str	r3, [r7, #0xc]
; 	if (id >= config->max_streams) {
 8018274: 697b         	ldr	r3, [r7, #0x14]
 8018276: 695b         	ldr	r3, [r3, #0x14]
 8018278: 683a         	ldr	r2, [r7]
 801827a: 429a         	cmp	r2, r3
 801827c: d302         	blo	0x8018284 <dma_stm32_stop+0x38> @ imm = #0x4
; 		return -EINVAL;
 801827e: f06f 0315    	mvn	r3, #0x15
 8018282: e02c         	b	0x80182de <dma_stm32_stop+0x92> @ imm = #0x58
; 	if (stream->hal_override) {
 8018284: 693b         	ldr	r3, [r7, #0x10]
 8018286: 795b         	ldrb	r3, [r3, #0x5]
 8018288: 2b00         	cmp	r3, #0x0
 801828a: d004         	beq	0x8018296 <dma_stm32_stop+0x4a> @ imm = #0x8
; 		stream->busy = false;
 801828c: 693b         	ldr	r3, [r7, #0x10]
 801828e: 2200         	movs	r2, #0x0
 8018290: 719a         	strb	r2, [r3, #0x6]
; 		return 0;
 8018292: 2300         	movs	r3, #0x0
 8018294: e023         	b	0x80182de <dma_stm32_stop+0x92> @ imm = #0x46
; 	if (!stm32_dma_is_enabled_stream(dma, id)) {
 8018296: 6839         	ldr	r1, [r7]
 8018298: 68f8         	ldr	r0, [r7, #0xc]
 801829a: f000 ff59    	bl	0x8019150 <stm32_dma_is_enabled_stream> @ imm = #0xeb2
 801829e: 4603         	mov	r3, r0
 80182a0: f083 0301    	eor	r3, r3, #0x1
 80182a4: b2db         	uxtb	r3, r3
 80182a6: 2b00         	cmp	r3, #0x0
 80182a8: d001         	beq	0x80182ae <dma_stm32_stop+0x62> @ imm = #0x2
; 		return 0;
 80182aa: 2300         	movs	r3, #0x0
 80182ac: e017         	b	0x80182de <dma_stm32_stop+0x92> @ imm = #0x2e
; 	LL_DMA_DisableIT_TC(dma, dma_stm32_id_to_stream(id));
 80182ae: 6838         	ldr	r0, [r7]
 80182b0: f7f0 ffb6    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xf094
 80182b4: 4603         	mov	r3, r0
 80182b6: 4619         	mov	r1, r3
 80182b8: 68f8         	ldr	r0, [r7, #0xc]
 80182ba: f7ef ffc9    	bl	0x8008250 <LL_DMA_DisableIT_TC> @ imm = #-0x1006e
; 	stm32_dma_disable_fifo_irq(dma, id);
 80182be: 6839         	ldr	r1, [r7]
 80182c0: 68f8         	ldr	r0, [r7, #0xc]
 80182c2: f000 ff7a    	bl	0x80191ba <stm32_dma_disable_fifo_irq> @ imm = #0xef4
; 	dma_stm32_clear_stream_irq(dev, id);
 80182c6: 6839         	ldr	r1, [r7]
 80182c8: 6878         	ldr	r0, [r7, #0x4]
 80182ca: f7ff fec1    	bl	0x8018050 <dma_stm32_clear_stream_irq> @ imm = #-0x27e
; 	dma_stm32_disable_stream(dma, id);
 80182ce: 6839         	ldr	r1, [r7]
 80182d0: 68f8         	ldr	r0, [r7, #0xc]
 80182d2: f7ff fed8    	bl	0x8018086 <dma_stm32_disable_stream> @ imm = #-0x250
; 	stream->busy = false;
 80182d6: 693b         	ldr	r3, [r7, #0x10]
 80182d8: 2200         	movs	r2, #0x0
 80182da: 719a         	strb	r2, [r3, #0x6]
; 	return 0;
 80182dc: 2300         	movs	r3, #0x0
; }
 80182de: 4618         	mov	r0, r3
 80182e0: 3718         	adds	r7, #0x18
 80182e2: 46bd         	mov	sp, r7
 80182e4: bd80         	pop	{r7, pc}

080182e6 <dma_stm32_get_status>:
; {
 80182e6: b580         	push	{r7, lr}
 80182e8: b088         	sub	sp, #0x20
 80182ea: af00         	add	r7, sp, #0x0
 80182ec: 60f8         	str	r0, [r7, #0xc]
 80182ee: 60b9         	str	r1, [r7, #0x8]
 80182f0: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_stm32_config *config = dev->config;
 80182f2: 68fb         	ldr	r3, [r7, #0xc]
 80182f4: 685b         	ldr	r3, [r3, #0x4]
 80182f6: 61fb         	str	r3, [r7, #0x1c]
; 	DMA_TypeDef *dma = (DMA_TypeDef *)(config->base);
 80182f8: 69fb         	ldr	r3, [r7, #0x1c]
 80182fa: 691b         	ldr	r3, [r3, #0x10]
 80182fc: 61bb         	str	r3, [r7, #0x18]
; 	if (id >= config->max_streams) {
 80182fe: 69fb         	ldr	r3, [r7, #0x1c]
 8018300: 695b         	ldr	r3, [r3, #0x14]
 8018302: 68ba         	ldr	r2, [r7, #0x8]
 8018304: 429a         	cmp	r2, r3
 8018306: d302         	blo	0x801830e <dma_stm32_get_status+0x28> @ imm = #0x4
; 		return -EINVAL;
 8018308: f06f 0315    	mvn	r3, #0x15
 801830c: e01e         	b	0x801834c <dma_stm32_get_status+0x66> @ imm = #0x3c
; 	stream = &config->streams[id];
 801830e: 69fb         	ldr	r3, [r7, #0x1c]
 8018310: 6999         	ldr	r1, [r3, #0x18]
 8018312: 68ba         	ldr	r2, [r7, #0x8]
 8018314: 4613         	mov	r3, r2
 8018316: 00db         	lsls	r3, r3, #0x3
 8018318: 1a9b         	subs	r3, r3, r2
 801831a: 009b         	lsls	r3, r3, #0x2
 801831c: 440b         	add	r3, r1
 801831e: 617b         	str	r3, [r7, #0x14]
; 	stat->pending_length = LL_DMA_GetDataLength(dma, dma_stm32_id_to_stream(id));
 8018320: 68b8         	ldr	r0, [r7, #0x8]
 8018322: f7f0 ff7d    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xf106
 8018326: 4603         	mov	r3, r0
 8018328: 4619         	mov	r1, r3
 801832a: 69b8         	ldr	r0, [r7, #0x18]
 801832c: f7ef feaa    	bl	0x8008084 <LL_DMA_GetDataLength> @ imm = #-0x102ac
 8018330: 4602         	mov	r2, r0
 8018332: 687b         	ldr	r3, [r7, #0x4]
 8018334: 605a         	str	r2, [r3, #0x4]
; 	stat->dir = stream->direction;
 8018336: 697b         	ldr	r3, [r7, #0x14]
 8018338: 681b         	ldr	r3, [r3]
 801833a: b2da         	uxtb	r2, r3
 801833c: 687b         	ldr	r3, [r7, #0x4]
 801833e: 705a         	strb	r2, [r3, #0x1]
; 	stat->busy = stream->busy;
 8018340: 697b         	ldr	r3, [r7, #0x14]
 8018342: 799b         	ldrb	r3, [r3, #0x6]
 8018344: b2da         	uxtb	r2, r3
 8018346: 687b         	ldr	r3, [r7, #0x4]
 8018348: 701a         	strb	r2, [r3]
; 	return 0;
 801834a: 2300         	movs	r3, #0x0
; }
 801834c: 4618         	mov	r0, r3
 801834e: 3720         	adds	r7, #0x20
 8018350: 46bd         	mov	sp, r7
 8018352: bd80         	pop	{r7, pc}

08018354 <dma_stm32_irq_0_0>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 0);
 8018354: b580         	push	{r7, lr}
 8018356: b082         	sub	sp, #0x8
 8018358: af00         	add	r7, sp, #0x0
 801835a: 6078         	str	r0, [r7, #0x4]
 801835c: 2100         	movs	r1, #0x0
 801835e: 6878         	ldr	r0, [r7, #0x4]
 8018360: f7ef ffb6    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x10094
 8018364: 3708         	adds	r7, #0x8
 8018366: 46bd         	mov	sp, r7
 8018368: bd80         	pop	{r7, pc}

0801836a <dma_stm32_irq_0_1>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 1);
 801836a: b580         	push	{r7, lr}
 801836c: b082         	sub	sp, #0x8
 801836e: af00         	add	r7, sp, #0x0
 8018370: 6078         	str	r0, [r7, #0x4]
 8018372: 2101         	movs	r1, #0x1
 8018374: 6878         	ldr	r0, [r7, #0x4]
 8018376: f7ef ffab    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x100aa
 801837a: 3708         	adds	r7, #0x8
 801837c: 46bd         	mov	sp, r7
 801837e: bd80         	pop	{r7, pc}

08018380 <dma_stm32_irq_0_2>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 2);
 8018380: b580         	push	{r7, lr}
 8018382: b082         	sub	sp, #0x8
 8018384: af00         	add	r7, sp, #0x0
 8018386: 6078         	str	r0, [r7, #0x4]
 8018388: 2102         	movs	r1, #0x2
 801838a: 6878         	ldr	r0, [r7, #0x4]
 801838c: f7ef ffa0    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x100c0
 8018390: 3708         	adds	r7, #0x8
 8018392: 46bd         	mov	sp, r7
 8018394: bd80         	pop	{r7, pc}

08018396 <dma_stm32_irq_0_3>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 3);
 8018396: b580         	push	{r7, lr}
 8018398: b082         	sub	sp, #0x8
 801839a: af00         	add	r7, sp, #0x0
 801839c: 6078         	str	r0, [r7, #0x4]
 801839e: 2103         	movs	r1, #0x3
 80183a0: 6878         	ldr	r0, [r7, #0x4]
 80183a2: f7ef ff95    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x100d6
 80183a6: 3708         	adds	r7, #0x8
 80183a8: 46bd         	mov	sp, r7
 80183aa: bd80         	pop	{r7, pc}

080183ac <dma_stm32_irq_0_4>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 4);
 80183ac: b580         	push	{r7, lr}
 80183ae: b082         	sub	sp, #0x8
 80183b0: af00         	add	r7, sp, #0x0
 80183b2: 6078         	str	r0, [r7, #0x4]
 80183b4: 2104         	movs	r1, #0x4
 80183b6: 6878         	ldr	r0, [r7, #0x4]
 80183b8: f7ef ff8a    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x100ec
 80183bc: 3708         	adds	r7, #0x8
 80183be: 46bd         	mov	sp, r7
 80183c0: bd80         	pop	{r7, pc}

080183c2 <dma_stm32_irq_0_5>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 5);
 80183c2: b580         	push	{r7, lr}
 80183c4: b082         	sub	sp, #0x8
 80183c6: af00         	add	r7, sp, #0x0
 80183c8: 6078         	str	r0, [r7, #0x4]
 80183ca: 2105         	movs	r1, #0x5
 80183cc: 6878         	ldr	r0, [r7, #0x4]
 80183ce: f7ef ff7f    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x10102
 80183d2: 3708         	adds	r7, #0x8
 80183d4: 46bd         	mov	sp, r7
 80183d6: bd80         	pop	{r7, pc}

080183d8 <dma_stm32_irq_0_6>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 6);
 80183d8: b580         	push	{r7, lr}
 80183da: b082         	sub	sp, #0x8
 80183dc: af00         	add	r7, sp, #0x0
 80183de: 6078         	str	r0, [r7, #0x4]
 80183e0: 2106         	movs	r1, #0x6
 80183e2: 6878         	ldr	r0, [r7, #0x4]
 80183e4: f7ef ff74    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x10118
 80183e8: 3708         	adds	r7, #0x8
 80183ea: 46bd         	mov	sp, r7
 80183ec: bd80         	pop	{r7, pc}

080183ee <dma_stm32_irq_0_7>:
; DMA_STM32_DEFINE_IRQ_HANDLER(0, 7);
 80183ee: b580         	push	{r7, lr}
 80183f0: b082         	sub	sp, #0x8
 80183f2: af00         	add	r7, sp, #0x0
 80183f4: 6078         	str	r0, [r7, #0x4]
 80183f6: 2107         	movs	r1, #0x7
 80183f8: 6878         	ldr	r0, [r7, #0x4]
 80183fa: f7ef ff69    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x1012e
 80183fe: 3708         	adds	r7, #0x8
 8018400: 46bd         	mov	sp, r7
 8018402: bd80         	pop	{r7, pc}

08018404 <dma_stm32_config_irq_0>:
; {
 8018404: b580         	push	{r7, lr}
 8018406: b082         	sub	sp, #0x8
 8018408: af00         	add	r7, sp, #0x0
 801840a: 6078         	str	r0, [r7, #0x4]
; 	LISTIFY(
 801840c: 2200         	movs	r2, #0x0
 801840e: 2100         	movs	r1, #0x0
 8018410: 200b         	movs	r0, #0xb
 8018412: f7ff fa2a    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xbac
 8018416: 200b         	movs	r0, #0xb
 8018418: f7ff fa1a    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xbcc
 801841c: 2200         	movs	r2, #0x0
 801841e: 2100         	movs	r1, #0x0
 8018420: 200c         	movs	r0, #0xc
 8018422: f7ff fa22    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xbbc
 8018426: 200c         	movs	r0, #0xc
 8018428: f7ff fa12    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xbdc
 801842c: 2200         	movs	r2, #0x0
 801842e: 2100         	movs	r1, #0x0
 8018430: 200d         	movs	r0, #0xd
 8018432: f7ff fa1a    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xbcc
 8018436: 200d         	movs	r0, #0xd
 8018438: f7ff fa0a    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xbec
 801843c: 2200         	movs	r2, #0x0
 801843e: 2100         	movs	r1, #0x0
 8018440: 200e         	movs	r0, #0xe
 8018442: f7ff fa12    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xbdc
 8018446: 200e         	movs	r0, #0xe
 8018448: f7ff fa02    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xbfc
 801844c: 2200         	movs	r2, #0x0
 801844e: 2100         	movs	r1, #0x0
 8018450: 200f         	movs	r0, #0xf
 8018452: f7ff fa0a    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xbec
 8018456: 200f         	movs	r0, #0xf
 8018458: f7ff f9fa    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xc0c
 801845c: 2200         	movs	r2, #0x0
 801845e: 2100         	movs	r1, #0x0
 8018460: 2010         	movs	r0, #0x10
 8018462: f7ff fa02    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xbfc
 8018466: 2010         	movs	r0, #0x10
 8018468: f7ff f9f2    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xc1c
 801846c: 2200         	movs	r2, #0x0
 801846e: 2100         	movs	r1, #0x0
 8018470: 2011         	movs	r0, #0x11
 8018472: f7ff f9fa    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xc0c
 8018476: 2011         	movs	r0, #0x11
 8018478: f7ff f9ea    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xc2c
 801847c: 2200         	movs	r2, #0x0
 801847e: 2100         	movs	r1, #0x0
 8018480: 202f         	movs	r0, #0x2f
 8018482: f7ff f9f2    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xc1c
 8018486: 202f         	movs	r0, #0x2f
 8018488: f7ff f9e2    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xc3c
; }
 801848c: bf00         	nop
 801848e: 3708         	adds	r7, #0x8
 8018490: 46bd         	mov	sp, r7
 8018492: bd80         	pop	{r7, pc}

08018494 <dma_stm32_irq_1_0>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 0);
 8018494: b580         	push	{r7, lr}
 8018496: b082         	sub	sp, #0x8
 8018498: af00         	add	r7, sp, #0x0
 801849a: 6078         	str	r0, [r7, #0x4]
 801849c: 2100         	movs	r1, #0x0
 801849e: 6878         	ldr	r0, [r7, #0x4]
 80184a0: f7ef ff16    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x101d4
 80184a4: 3708         	adds	r7, #0x8
 80184a6: 46bd         	mov	sp, r7
 80184a8: bd80         	pop	{r7, pc}

080184aa <dma_stm32_irq_1_1>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 1);
 80184aa: b580         	push	{r7, lr}
 80184ac: b082         	sub	sp, #0x8
 80184ae: af00         	add	r7, sp, #0x0
 80184b0: 6078         	str	r0, [r7, #0x4]
 80184b2: 2101         	movs	r1, #0x1
 80184b4: 6878         	ldr	r0, [r7, #0x4]
 80184b6: f7ef ff0b    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x101ea
 80184ba: 3708         	adds	r7, #0x8
 80184bc: 46bd         	mov	sp, r7
 80184be: bd80         	pop	{r7, pc}

080184c0 <dma_stm32_irq_1_2>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 2);
 80184c0: b580         	push	{r7, lr}
 80184c2: b082         	sub	sp, #0x8
 80184c4: af00         	add	r7, sp, #0x0
 80184c6: 6078         	str	r0, [r7, #0x4]
 80184c8: 2102         	movs	r1, #0x2
 80184ca: 6878         	ldr	r0, [r7, #0x4]
 80184cc: f7ef ff00    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x10200
 80184d0: 3708         	adds	r7, #0x8
 80184d2: 46bd         	mov	sp, r7
 80184d4: bd80         	pop	{r7, pc}

080184d6 <dma_stm32_irq_1_3>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 3);
 80184d6: b580         	push	{r7, lr}
 80184d8: b082         	sub	sp, #0x8
 80184da: af00         	add	r7, sp, #0x0
 80184dc: 6078         	str	r0, [r7, #0x4]
 80184de: 2103         	movs	r1, #0x3
 80184e0: 6878         	ldr	r0, [r7, #0x4]
 80184e2: f7ef fef5    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x10216
 80184e6: 3708         	adds	r7, #0x8
 80184e8: 46bd         	mov	sp, r7
 80184ea: bd80         	pop	{r7, pc}

080184ec <dma_stm32_irq_1_4>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 4);
 80184ec: b580         	push	{r7, lr}
 80184ee: b082         	sub	sp, #0x8
 80184f0: af00         	add	r7, sp, #0x0
 80184f2: 6078         	str	r0, [r7, #0x4]
 80184f4: 2104         	movs	r1, #0x4
 80184f6: 6878         	ldr	r0, [r7, #0x4]
 80184f8: f7ef feea    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x1022c
 80184fc: 3708         	adds	r7, #0x8
 80184fe: 46bd         	mov	sp, r7
 8018500: bd80         	pop	{r7, pc}

08018502 <dma_stm32_irq_1_5>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 5);
 8018502: b580         	push	{r7, lr}
 8018504: b082         	sub	sp, #0x8
 8018506: af00         	add	r7, sp, #0x0
 8018508: 6078         	str	r0, [r7, #0x4]
 801850a: 2105         	movs	r1, #0x5
 801850c: 6878         	ldr	r0, [r7, #0x4]
 801850e: f7ef fedf    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x10242
 8018512: 3708         	adds	r7, #0x8
 8018514: 46bd         	mov	sp, r7
 8018516: bd80         	pop	{r7, pc}

08018518 <dma_stm32_irq_1_6>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 6);
 8018518: b580         	push	{r7, lr}
 801851a: b082         	sub	sp, #0x8
 801851c: af00         	add	r7, sp, #0x0
 801851e: 6078         	str	r0, [r7, #0x4]
 8018520: 2106         	movs	r1, #0x6
 8018522: 6878         	ldr	r0, [r7, #0x4]
 8018524: f7ef fed4    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x10258
 8018528: 3708         	adds	r7, #0x8
 801852a: 46bd         	mov	sp, r7
 801852c: bd80         	pop	{r7, pc}

0801852e <dma_stm32_irq_1_7>:
; DMA_STM32_DEFINE_IRQ_HANDLER(1, 7);
 801852e: b580         	push	{r7, lr}
 8018530: b082         	sub	sp, #0x8
 8018532: af00         	add	r7, sp, #0x0
 8018534: 6078         	str	r0, [r7, #0x4]
 8018536: 2107         	movs	r1, #0x7
 8018538: 6878         	ldr	r0, [r7, #0x4]
 801853a: f7ef fec9    	bl	0x80082d0 <dma_stm32_irq_handler> @ imm = #-0x1026e
 801853e: 3708         	adds	r7, #0x8
 8018540: 46bd         	mov	sp, r7
 8018542: bd80         	pop	{r7, pc}

08018544 <dma_stm32_config_irq_1>:
; {
 8018544: b580         	push	{r7, lr}
 8018546: b082         	sub	sp, #0x8
 8018548: af00         	add	r7, sp, #0x0
 801854a: 6078         	str	r0, [r7, #0x4]
; 	LISTIFY(
 801854c: 2200         	movs	r2, #0x0
 801854e: 2100         	movs	r1, #0x0
 8018550: 2038         	movs	r0, #0x38
 8018552: f7ff f98a    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xcec
 8018556: 2038         	movs	r0, #0x38
 8018558: f7ff f97a    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xd0c
 801855c: 2200         	movs	r2, #0x0
 801855e: 2100         	movs	r1, #0x0
 8018560: 2039         	movs	r0, #0x39
 8018562: f7ff f982    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xcfc
 8018566: 2039         	movs	r0, #0x39
 8018568: f7ff f972    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xd1c
 801856c: 2200         	movs	r2, #0x0
 801856e: 2100         	movs	r1, #0x0
 8018570: 203a         	movs	r0, #0x3a
 8018572: f7ff f97a    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xd0c
 8018576: 203a         	movs	r0, #0x3a
 8018578: f7ff f96a    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xd2c
 801857c: 2200         	movs	r2, #0x0
 801857e: 2100         	movs	r1, #0x0
 8018580: 203b         	movs	r0, #0x3b
 8018582: f7ff f972    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xd1c
 8018586: 203b         	movs	r0, #0x3b
 8018588: f7ff f962    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xd3c
 801858c: 2200         	movs	r2, #0x0
 801858e: 2100         	movs	r1, #0x0
 8018590: 203c         	movs	r0, #0x3c
 8018592: f7ff f96a    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xd2c
 8018596: 203c         	movs	r0, #0x3c
 8018598: f7ff f95a    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xd4c
 801859c: 2200         	movs	r2, #0x0
 801859e: 2100         	movs	r1, #0x0
 80185a0: 2044         	movs	r0, #0x44
 80185a2: f7ff f962    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xd3c
 80185a6: 2044         	movs	r0, #0x44
 80185a8: f7ff f952    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xd5c
 80185ac: 2200         	movs	r2, #0x0
 80185ae: 2100         	movs	r1, #0x0
 80185b0: 2045         	movs	r0, #0x45
 80185b2: f7ff f95a    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xd4c
 80185b6: 2045         	movs	r0, #0x45
 80185b8: f7ff f94a    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xd6c
 80185bc: 2200         	movs	r2, #0x0
 80185be: 2100         	movs	r1, #0x0
 80185c0: 2046         	movs	r0, #0x46
 80185c2: f7ff f952    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0xd5c
 80185c6: 2046         	movs	r0, #0x46
 80185c8: f7ff f942    	bl	0x8017850 <arch_irq_enable> @ imm = #-0xd7c
; }
 80185cc: bf00         	nop
 80185ce: 3708         	adds	r7, #0x8
 80185d0: 46bd         	mov	sp, r7
 80185d2: bd80         	pop	{r7, pc}

080185d4 <LL_DMA_IsActiveFlag_HT0>:
; {
 80185d4: b480         	push	{r7}
 80185d6: b083         	sub	sp, #0xc
 80185d8: af00         	add	r7, sp, #0x0
 80185da: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF0)==(DMA_LISR_HTIF0));
 80185dc: 687b         	ldr	r3, [r7, #0x4]
 80185de: 681b         	ldr	r3, [r3]
 80185e0: f003 0310    	and	r3, r3, #0x10
 80185e4: 2b10         	cmp	r3, #0x10
 80185e6: bf0c         	ite	eq
 80185e8: 2301         	moveq	r3, #0x1
 80185ea: 2300         	movne	r3, #0x0
 80185ec: b2db         	uxtb	r3, r3
; }
 80185ee: 4618         	mov	r0, r3
 80185f0: 370c         	adds	r7, #0xc
 80185f2: 46bd         	mov	sp, r7
 80185f4: f85d 7b04    	ldr	r7, [sp], #4
 80185f8: 4770         	bx	lr

080185fa <LL_DMA_IsActiveFlag_HT1>:
; {
 80185fa: b480         	push	{r7}
 80185fc: b083         	sub	sp, #0xc
 80185fe: af00         	add	r7, sp, #0x0
 8018600: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF1)==(DMA_LISR_HTIF1));
 8018602: 687b         	ldr	r3, [r7, #0x4]
 8018604: 681b         	ldr	r3, [r3]
 8018606: f403 6380    	and	r3, r3, #0x400
 801860a: f5b3 6f80    	cmp.w	r3, #0x400
 801860e: bf0c         	ite	eq
 8018610: 2301         	moveq	r3, #0x1
 8018612: 2300         	movne	r3, #0x0
 8018614: b2db         	uxtb	r3, r3
; }
 8018616: 4618         	mov	r0, r3
 8018618: 370c         	adds	r7, #0xc
 801861a: 46bd         	mov	sp, r7
 801861c: f85d 7b04    	ldr	r7, [sp], #4
 8018620: 4770         	bx	lr

08018622 <LL_DMA_IsActiveFlag_HT2>:
; {
 8018622: b480         	push	{r7}
 8018624: b083         	sub	sp, #0xc
 8018626: af00         	add	r7, sp, #0x0
 8018628: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF2)==(DMA_LISR_HTIF2));
 801862a: 687b         	ldr	r3, [r7, #0x4]
 801862c: 681b         	ldr	r3, [r3]
 801862e: f403 1380    	and	r3, r3, #0x100000
 8018632: f5b3 1f80    	cmp.w	r3, #0x100000
 8018636: bf0c         	ite	eq
 8018638: 2301         	moveq	r3, #0x1
 801863a: 2300         	movne	r3, #0x0
 801863c: b2db         	uxtb	r3, r3
; }
 801863e: 4618         	mov	r0, r3
 8018640: 370c         	adds	r7, #0xc
 8018642: 46bd         	mov	sp, r7
 8018644: f85d 7b04    	ldr	r7, [sp], #4
 8018648: 4770         	bx	lr

0801864a <LL_DMA_IsActiveFlag_HT3>:
; {
 801864a: b480         	push	{r7}
 801864c: b083         	sub	sp, #0xc
 801864e: af00         	add	r7, sp, #0x0
 8018650: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_HTIF3)==(DMA_LISR_HTIF3));
 8018652: 687b         	ldr	r3, [r7, #0x4]
 8018654: 681b         	ldr	r3, [r3]
 8018656: f003 6380    	and	r3, r3, #0x4000000
 801865a: f1b3 6f80    	cmp.w	r3, #0x4000000
 801865e: bf0c         	ite	eq
 8018660: 2301         	moveq	r3, #0x1
 8018662: 2300         	movne	r3, #0x0
 8018664: b2db         	uxtb	r3, r3
; }
 8018666: 4618         	mov	r0, r3
 8018668: 370c         	adds	r7, #0xc
 801866a: 46bd         	mov	sp, r7
 801866c: f85d 7b04    	ldr	r7, [sp], #4
 8018670: 4770         	bx	lr

08018672 <LL_DMA_IsActiveFlag_HT4>:
; {
 8018672: b480         	push	{r7}
 8018674: b083         	sub	sp, #0xc
 8018676: af00         	add	r7, sp, #0x0
 8018678: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF4)==(DMA_HISR_HTIF4));
 801867a: 687b         	ldr	r3, [r7, #0x4]
 801867c: 685b         	ldr	r3, [r3, #0x4]
 801867e: f003 0310    	and	r3, r3, #0x10
 8018682: 2b10         	cmp	r3, #0x10
 8018684: bf0c         	ite	eq
 8018686: 2301         	moveq	r3, #0x1
 8018688: 2300         	movne	r3, #0x0
 801868a: b2db         	uxtb	r3, r3
; }
 801868c: 4618         	mov	r0, r3
 801868e: 370c         	adds	r7, #0xc
 8018690: 46bd         	mov	sp, r7
 8018692: f85d 7b04    	ldr	r7, [sp], #4
 8018696: 4770         	bx	lr

08018698 <LL_DMA_IsActiveFlag_HT5>:
; {
 8018698: b480         	push	{r7}
 801869a: b083         	sub	sp, #0xc
 801869c: af00         	add	r7, sp, #0x0
 801869e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF5)==(DMA_HISR_HTIF5));
 80186a0: 687b         	ldr	r3, [r7, #0x4]
 80186a2: 685b         	ldr	r3, [r3, #0x4]
 80186a4: f403 6380    	and	r3, r3, #0x400
 80186a8: f5b3 6f80    	cmp.w	r3, #0x400
 80186ac: bf0c         	ite	eq
 80186ae: 2301         	moveq	r3, #0x1
 80186b0: 2300         	movne	r3, #0x0
 80186b2: b2db         	uxtb	r3, r3
; }
 80186b4: 4618         	mov	r0, r3
 80186b6: 370c         	adds	r7, #0xc
 80186b8: 46bd         	mov	sp, r7
 80186ba: f85d 7b04    	ldr	r7, [sp], #4
 80186be: 4770         	bx	lr

080186c0 <LL_DMA_IsActiveFlag_HT6>:
; {
 80186c0: b480         	push	{r7}
 80186c2: b083         	sub	sp, #0xc
 80186c4: af00         	add	r7, sp, #0x0
 80186c6: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF6)==(DMA_HISR_HTIF6));
 80186c8: 687b         	ldr	r3, [r7, #0x4]
 80186ca: 685b         	ldr	r3, [r3, #0x4]
 80186cc: f403 1380    	and	r3, r3, #0x100000
 80186d0: f5b3 1f80    	cmp.w	r3, #0x100000
 80186d4: bf0c         	ite	eq
 80186d6: 2301         	moveq	r3, #0x1
 80186d8: 2300         	movne	r3, #0x0
 80186da: b2db         	uxtb	r3, r3
; }
 80186dc: 4618         	mov	r0, r3
 80186de: 370c         	adds	r7, #0xc
 80186e0: 46bd         	mov	sp, r7
 80186e2: f85d 7b04    	ldr	r7, [sp], #4
 80186e6: 4770         	bx	lr

080186e8 <LL_DMA_IsActiveFlag_HT7>:
; {
 80186e8: b480         	push	{r7}
 80186ea: b083         	sub	sp, #0xc
 80186ec: af00         	add	r7, sp, #0x0
 80186ee: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_HTIF7)==(DMA_HISR_HTIF7));
 80186f0: 687b         	ldr	r3, [r7, #0x4]
 80186f2: 685b         	ldr	r3, [r3, #0x4]
 80186f4: f003 6380    	and	r3, r3, #0x4000000
 80186f8: f1b3 6f80    	cmp.w	r3, #0x4000000
 80186fc: bf0c         	ite	eq
 80186fe: 2301         	moveq	r3, #0x1
 8018700: 2300         	movne	r3, #0x0
 8018702: b2db         	uxtb	r3, r3
; }
 8018704: 4618         	mov	r0, r3
 8018706: 370c         	adds	r7, #0xc
 8018708: 46bd         	mov	sp, r7
 801870a: f85d 7b04    	ldr	r7, [sp], #4
 801870e: 4770         	bx	lr

08018710 <LL_DMA_IsActiveFlag_TC0>:
; {
 8018710: b480         	push	{r7}
 8018712: b083         	sub	sp, #0xc
 8018714: af00         	add	r7, sp, #0x0
 8018716: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF0)==(DMA_LISR_TCIF0));
 8018718: 687b         	ldr	r3, [r7, #0x4]
 801871a: 681b         	ldr	r3, [r3]
 801871c: f003 0320    	and	r3, r3, #0x20
 8018720: 2b20         	cmp	r3, #0x20
 8018722: bf0c         	ite	eq
 8018724: 2301         	moveq	r3, #0x1
 8018726: 2300         	movne	r3, #0x0
 8018728: b2db         	uxtb	r3, r3
; }
 801872a: 4618         	mov	r0, r3
 801872c: 370c         	adds	r7, #0xc
 801872e: 46bd         	mov	sp, r7
 8018730: f85d 7b04    	ldr	r7, [sp], #4
 8018734: 4770         	bx	lr

08018736 <LL_DMA_IsActiveFlag_TC1>:
; {
 8018736: b480         	push	{r7}
 8018738: b083         	sub	sp, #0xc
 801873a: af00         	add	r7, sp, #0x0
 801873c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF1)==(DMA_LISR_TCIF1));
 801873e: 687b         	ldr	r3, [r7, #0x4]
 8018740: 681b         	ldr	r3, [r3]
 8018742: f403 6300    	and	r3, r3, #0x800
 8018746: f5b3 6f00    	cmp.w	r3, #0x800
 801874a: bf0c         	ite	eq
 801874c: 2301         	moveq	r3, #0x1
 801874e: 2300         	movne	r3, #0x0
 8018750: b2db         	uxtb	r3, r3
; }
 8018752: 4618         	mov	r0, r3
 8018754: 370c         	adds	r7, #0xc
 8018756: 46bd         	mov	sp, r7
 8018758: f85d 7b04    	ldr	r7, [sp], #4
 801875c: 4770         	bx	lr

0801875e <LL_DMA_IsActiveFlag_TC2>:
; {
 801875e: b480         	push	{r7}
 8018760: b083         	sub	sp, #0xc
 8018762: af00         	add	r7, sp, #0x0
 8018764: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF2)==(DMA_LISR_TCIF2));
 8018766: 687b         	ldr	r3, [r7, #0x4]
 8018768: 681b         	ldr	r3, [r3]
 801876a: f403 1300    	and	r3, r3, #0x200000
 801876e: f5b3 1f00    	cmp.w	r3, #0x200000
 8018772: bf0c         	ite	eq
 8018774: 2301         	moveq	r3, #0x1
 8018776: 2300         	movne	r3, #0x0
 8018778: b2db         	uxtb	r3, r3
; }
 801877a: 4618         	mov	r0, r3
 801877c: 370c         	adds	r7, #0xc
 801877e: 46bd         	mov	sp, r7
 8018780: f85d 7b04    	ldr	r7, [sp], #4
 8018784: 4770         	bx	lr

08018786 <LL_DMA_IsActiveFlag_TC3>:
; {
 8018786: b480         	push	{r7}
 8018788: b083         	sub	sp, #0xc
 801878a: af00         	add	r7, sp, #0x0
 801878c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TCIF3)==(DMA_LISR_TCIF3));
 801878e: 687b         	ldr	r3, [r7, #0x4]
 8018790: 681b         	ldr	r3, [r3]
 8018792: f003 6300    	and	r3, r3, #0x8000000
 8018796: f1b3 6f00    	cmp.w	r3, #0x8000000
 801879a: bf0c         	ite	eq
 801879c: 2301         	moveq	r3, #0x1
 801879e: 2300         	movne	r3, #0x0
 80187a0: b2db         	uxtb	r3, r3
; }
 80187a2: 4618         	mov	r0, r3
 80187a4: 370c         	adds	r7, #0xc
 80187a6: 46bd         	mov	sp, r7
 80187a8: f85d 7b04    	ldr	r7, [sp], #4
 80187ac: 4770         	bx	lr

080187ae <LL_DMA_IsActiveFlag_TC4>:
; {
 80187ae: b480         	push	{r7}
 80187b0: b083         	sub	sp, #0xc
 80187b2: af00         	add	r7, sp, #0x0
 80187b4: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF4)==(DMA_HISR_TCIF4));
 80187b6: 687b         	ldr	r3, [r7, #0x4]
 80187b8: 685b         	ldr	r3, [r3, #0x4]
 80187ba: f003 0320    	and	r3, r3, #0x20
 80187be: 2b20         	cmp	r3, #0x20
 80187c0: bf0c         	ite	eq
 80187c2: 2301         	moveq	r3, #0x1
 80187c4: 2300         	movne	r3, #0x0
 80187c6: b2db         	uxtb	r3, r3
; }
 80187c8: 4618         	mov	r0, r3
 80187ca: 370c         	adds	r7, #0xc
 80187cc: 46bd         	mov	sp, r7
 80187ce: f85d 7b04    	ldr	r7, [sp], #4
 80187d2: 4770         	bx	lr

080187d4 <LL_DMA_IsActiveFlag_TC5>:
; {
 80187d4: b480         	push	{r7}
 80187d6: b083         	sub	sp, #0xc
 80187d8: af00         	add	r7, sp, #0x0
 80187da: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF5)==(DMA_HISR_TCIF5));
 80187dc: 687b         	ldr	r3, [r7, #0x4]
 80187de: 685b         	ldr	r3, [r3, #0x4]
 80187e0: f403 6300    	and	r3, r3, #0x800
 80187e4: f5b3 6f00    	cmp.w	r3, #0x800
 80187e8: bf0c         	ite	eq
 80187ea: 2301         	moveq	r3, #0x1
 80187ec: 2300         	movne	r3, #0x0
 80187ee: b2db         	uxtb	r3, r3
; }
 80187f0: 4618         	mov	r0, r3
 80187f2: 370c         	adds	r7, #0xc
 80187f4: 46bd         	mov	sp, r7
 80187f6: f85d 7b04    	ldr	r7, [sp], #4
 80187fa: 4770         	bx	lr

080187fc <LL_DMA_IsActiveFlag_TC6>:
; {
 80187fc: b480         	push	{r7}
 80187fe: b083         	sub	sp, #0xc
 8018800: af00         	add	r7, sp, #0x0
 8018802: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF6)==(DMA_HISR_TCIF6));
 8018804: 687b         	ldr	r3, [r7, #0x4]
 8018806: 685b         	ldr	r3, [r3, #0x4]
 8018808: f403 1300    	and	r3, r3, #0x200000
 801880c: f5b3 1f00    	cmp.w	r3, #0x200000
 8018810: bf0c         	ite	eq
 8018812: 2301         	moveq	r3, #0x1
 8018814: 2300         	movne	r3, #0x0
 8018816: b2db         	uxtb	r3, r3
; }
 8018818: 4618         	mov	r0, r3
 801881a: 370c         	adds	r7, #0xc
 801881c: 46bd         	mov	sp, r7
 801881e: f85d 7b04    	ldr	r7, [sp], #4
 8018822: 4770         	bx	lr

08018824 <LL_DMA_IsActiveFlag_TC7>:
; {
 8018824: b480         	push	{r7}
 8018826: b083         	sub	sp, #0xc
 8018828: af00         	add	r7, sp, #0x0
 801882a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TCIF7)==(DMA_HISR_TCIF7));
 801882c: 687b         	ldr	r3, [r7, #0x4]
 801882e: 685b         	ldr	r3, [r3, #0x4]
 8018830: f003 6300    	and	r3, r3, #0x8000000
 8018834: f1b3 6f00    	cmp.w	r3, #0x8000000
 8018838: bf0c         	ite	eq
 801883a: 2301         	moveq	r3, #0x1
 801883c: 2300         	movne	r3, #0x0
 801883e: b2db         	uxtb	r3, r3
; }
 8018840: 4618         	mov	r0, r3
 8018842: 370c         	adds	r7, #0xc
 8018844: 46bd         	mov	sp, r7
 8018846: f85d 7b04    	ldr	r7, [sp], #4
 801884a: 4770         	bx	lr

0801884c <LL_DMA_IsActiveFlag_TE0>:
; {
 801884c: b480         	push	{r7}
 801884e: b083         	sub	sp, #0xc
 8018850: af00         	add	r7, sp, #0x0
 8018852: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF0)==(DMA_LISR_TEIF0));
 8018854: 687b         	ldr	r3, [r7, #0x4]
 8018856: 681b         	ldr	r3, [r3]
 8018858: f003 0308    	and	r3, r3, #0x8
 801885c: 2b08         	cmp	r3, #0x8
 801885e: bf0c         	ite	eq
 8018860: 2301         	moveq	r3, #0x1
 8018862: 2300         	movne	r3, #0x0
 8018864: b2db         	uxtb	r3, r3
; }
 8018866: 4618         	mov	r0, r3
 8018868: 370c         	adds	r7, #0xc
 801886a: 46bd         	mov	sp, r7
 801886c: f85d 7b04    	ldr	r7, [sp], #4
 8018870: 4770         	bx	lr

08018872 <LL_DMA_IsActiveFlag_TE1>:
; {
 8018872: b480         	push	{r7}
 8018874: b083         	sub	sp, #0xc
 8018876: af00         	add	r7, sp, #0x0
 8018878: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF1)==(DMA_LISR_TEIF1));
 801887a: 687b         	ldr	r3, [r7, #0x4]
 801887c: 681b         	ldr	r3, [r3]
 801887e: f403 7300    	and	r3, r3, #0x200
 8018882: f5b3 7f00    	cmp.w	r3, #0x200
 8018886: bf0c         	ite	eq
 8018888: 2301         	moveq	r3, #0x1
 801888a: 2300         	movne	r3, #0x0
 801888c: b2db         	uxtb	r3, r3
; }
 801888e: 4618         	mov	r0, r3
 8018890: 370c         	adds	r7, #0xc
 8018892: 46bd         	mov	sp, r7
 8018894: f85d 7b04    	ldr	r7, [sp], #4
 8018898: 4770         	bx	lr

0801889a <LL_DMA_IsActiveFlag_TE2>:
; {
 801889a: b480         	push	{r7}
 801889c: b083         	sub	sp, #0xc
 801889e: af00         	add	r7, sp, #0x0
 80188a0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF2)==(DMA_LISR_TEIF2));
 80188a2: 687b         	ldr	r3, [r7, #0x4]
 80188a4: 681b         	ldr	r3, [r3]
 80188a6: f403 2300    	and	r3, r3, #0x80000
 80188aa: f5b3 2f00    	cmp.w	r3, #0x80000
 80188ae: bf0c         	ite	eq
 80188b0: 2301         	moveq	r3, #0x1
 80188b2: 2300         	movne	r3, #0x0
 80188b4: b2db         	uxtb	r3, r3
; }
 80188b6: 4618         	mov	r0, r3
 80188b8: 370c         	adds	r7, #0xc
 80188ba: 46bd         	mov	sp, r7
 80188bc: f85d 7b04    	ldr	r7, [sp], #4
 80188c0: 4770         	bx	lr

080188c2 <LL_DMA_IsActiveFlag_TE3>:
; {
 80188c2: b480         	push	{r7}
 80188c4: b083         	sub	sp, #0xc
 80188c6: af00         	add	r7, sp, #0x0
 80188c8: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_TEIF3)==(DMA_LISR_TEIF3));
 80188ca: 687b         	ldr	r3, [r7, #0x4]
 80188cc: 681b         	ldr	r3, [r3]
 80188ce: f003 7300    	and	r3, r3, #0x2000000
 80188d2: f1b3 7f00    	cmp.w	r3, #0x2000000
 80188d6: bf0c         	ite	eq
 80188d8: 2301         	moveq	r3, #0x1
 80188da: 2300         	movne	r3, #0x0
 80188dc: b2db         	uxtb	r3, r3
; }
 80188de: 4618         	mov	r0, r3
 80188e0: 370c         	adds	r7, #0xc
 80188e2: 46bd         	mov	sp, r7
 80188e4: f85d 7b04    	ldr	r7, [sp], #4
 80188e8: 4770         	bx	lr

080188ea <LL_DMA_IsActiveFlag_TE4>:
; {
 80188ea: b480         	push	{r7}
 80188ec: b083         	sub	sp, #0xc
 80188ee: af00         	add	r7, sp, #0x0
 80188f0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF4)==(DMA_HISR_TEIF4));
 80188f2: 687b         	ldr	r3, [r7, #0x4]
 80188f4: 685b         	ldr	r3, [r3, #0x4]
 80188f6: f003 0308    	and	r3, r3, #0x8
 80188fa: 2b08         	cmp	r3, #0x8
 80188fc: bf0c         	ite	eq
 80188fe: 2301         	moveq	r3, #0x1
 8018900: 2300         	movne	r3, #0x0
 8018902: b2db         	uxtb	r3, r3
; }
 8018904: 4618         	mov	r0, r3
 8018906: 370c         	adds	r7, #0xc
 8018908: 46bd         	mov	sp, r7
 801890a: f85d 7b04    	ldr	r7, [sp], #4
 801890e: 4770         	bx	lr

08018910 <LL_DMA_IsActiveFlag_TE5>:
; {
 8018910: b480         	push	{r7}
 8018912: b083         	sub	sp, #0xc
 8018914: af00         	add	r7, sp, #0x0
 8018916: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF5)==(DMA_HISR_TEIF5));
 8018918: 687b         	ldr	r3, [r7, #0x4]
 801891a: 685b         	ldr	r3, [r3, #0x4]
 801891c: f403 7300    	and	r3, r3, #0x200
 8018920: f5b3 7f00    	cmp.w	r3, #0x200
 8018924: bf0c         	ite	eq
 8018926: 2301         	moveq	r3, #0x1
 8018928: 2300         	movne	r3, #0x0
 801892a: b2db         	uxtb	r3, r3
; }
 801892c: 4618         	mov	r0, r3
 801892e: 370c         	adds	r7, #0xc
 8018930: 46bd         	mov	sp, r7
 8018932: f85d 7b04    	ldr	r7, [sp], #4
 8018936: 4770         	bx	lr

08018938 <LL_DMA_IsActiveFlag_TE6>:
; {
 8018938: b480         	push	{r7}
 801893a: b083         	sub	sp, #0xc
 801893c: af00         	add	r7, sp, #0x0
 801893e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF6)==(DMA_HISR_TEIF6));
 8018940: 687b         	ldr	r3, [r7, #0x4]
 8018942: 685b         	ldr	r3, [r3, #0x4]
 8018944: f403 2300    	and	r3, r3, #0x80000
 8018948: f5b3 2f00    	cmp.w	r3, #0x80000
 801894c: bf0c         	ite	eq
 801894e: 2301         	moveq	r3, #0x1
 8018950: 2300         	movne	r3, #0x0
 8018952: b2db         	uxtb	r3, r3
; }
 8018954: 4618         	mov	r0, r3
 8018956: 370c         	adds	r7, #0xc
 8018958: 46bd         	mov	sp, r7
 801895a: f85d 7b04    	ldr	r7, [sp], #4
 801895e: 4770         	bx	lr

08018960 <LL_DMA_IsActiveFlag_TE7>:
; {
 8018960: b480         	push	{r7}
 8018962: b083         	sub	sp, #0xc
 8018964: af00         	add	r7, sp, #0x0
 8018966: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_TEIF7)==(DMA_HISR_TEIF7));
 8018968: 687b         	ldr	r3, [r7, #0x4]
 801896a: 685b         	ldr	r3, [r3, #0x4]
 801896c: f003 7300    	and	r3, r3, #0x2000000
 8018970: f1b3 7f00    	cmp.w	r3, #0x2000000
 8018974: bf0c         	ite	eq
 8018976: 2301         	moveq	r3, #0x1
 8018978: 2300         	movne	r3, #0x0
 801897a: b2db         	uxtb	r3, r3
; }
 801897c: 4618         	mov	r0, r3
 801897e: 370c         	adds	r7, #0xc
 8018980: 46bd         	mov	sp, r7
 8018982: f85d 7b04    	ldr	r7, [sp], #4
 8018986: 4770         	bx	lr

08018988 <LL_DMA_IsActiveFlag_DME0>:
; {
 8018988: b480         	push	{r7}
 801898a: b083         	sub	sp, #0xc
 801898c: af00         	add	r7, sp, #0x0
 801898e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF0)==(DMA_LISR_DMEIF0));
 8018990: 687b         	ldr	r3, [r7, #0x4]
 8018992: 681b         	ldr	r3, [r3]
 8018994: f003 0304    	and	r3, r3, #0x4
 8018998: 2b04         	cmp	r3, #0x4
 801899a: bf0c         	ite	eq
 801899c: 2301         	moveq	r3, #0x1
 801899e: 2300         	movne	r3, #0x0
 80189a0: b2db         	uxtb	r3, r3
; }
 80189a2: 4618         	mov	r0, r3
 80189a4: 370c         	adds	r7, #0xc
 80189a6: 46bd         	mov	sp, r7
 80189a8: f85d 7b04    	ldr	r7, [sp], #4
 80189ac: 4770         	bx	lr

080189ae <LL_DMA_IsActiveFlag_DME1>:
; {
 80189ae: b480         	push	{r7}
 80189b0: b083         	sub	sp, #0xc
 80189b2: af00         	add	r7, sp, #0x0
 80189b4: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF1)==(DMA_LISR_DMEIF1));
 80189b6: 687b         	ldr	r3, [r7, #0x4]
 80189b8: 681b         	ldr	r3, [r3]
 80189ba: f403 7380    	and	r3, r3, #0x100
 80189be: f5b3 7f80    	cmp.w	r3, #0x100
 80189c2: bf0c         	ite	eq
 80189c4: 2301         	moveq	r3, #0x1
 80189c6: 2300         	movne	r3, #0x0
 80189c8: b2db         	uxtb	r3, r3
; }
 80189ca: 4618         	mov	r0, r3
 80189cc: 370c         	adds	r7, #0xc
 80189ce: 46bd         	mov	sp, r7
 80189d0: f85d 7b04    	ldr	r7, [sp], #4
 80189d4: 4770         	bx	lr

080189d6 <LL_DMA_IsActiveFlag_DME2>:
; {
 80189d6: b480         	push	{r7}
 80189d8: b083         	sub	sp, #0xc
 80189da: af00         	add	r7, sp, #0x0
 80189dc: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF2)==(DMA_LISR_DMEIF2));
 80189de: 687b         	ldr	r3, [r7, #0x4]
 80189e0: 681b         	ldr	r3, [r3]
 80189e2: f403 2380    	and	r3, r3, #0x40000
 80189e6: f5b3 2f80    	cmp.w	r3, #0x40000
 80189ea: bf0c         	ite	eq
 80189ec: 2301         	moveq	r3, #0x1
 80189ee: 2300         	movne	r3, #0x0
 80189f0: b2db         	uxtb	r3, r3
; }
 80189f2: 4618         	mov	r0, r3
 80189f4: 370c         	adds	r7, #0xc
 80189f6: 46bd         	mov	sp, r7
 80189f8: f85d 7b04    	ldr	r7, [sp], #4
 80189fc: 4770         	bx	lr

080189fe <LL_DMA_IsActiveFlag_DME3>:
; {
 80189fe: b480         	push	{r7}
 8018a00: b083         	sub	sp, #0xc
 8018a02: af00         	add	r7, sp, #0x0
 8018a04: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_DMEIF3)==(DMA_LISR_DMEIF3));
 8018a06: 687b         	ldr	r3, [r7, #0x4]
 8018a08: 681b         	ldr	r3, [r3]
 8018a0a: f003 7380    	and	r3, r3, #0x1000000
 8018a0e: f1b3 7f80    	cmp.w	r3, #0x1000000
 8018a12: bf0c         	ite	eq
 8018a14: 2301         	moveq	r3, #0x1
 8018a16: 2300         	movne	r3, #0x0
 8018a18: b2db         	uxtb	r3, r3
; }
 8018a1a: 4618         	mov	r0, r3
 8018a1c: 370c         	adds	r7, #0xc
 8018a1e: 46bd         	mov	sp, r7
 8018a20: f85d 7b04    	ldr	r7, [sp], #4
 8018a24: 4770         	bx	lr

08018a26 <LL_DMA_IsActiveFlag_DME4>:
; {
 8018a26: b480         	push	{r7}
 8018a28: b083         	sub	sp, #0xc
 8018a2a: af00         	add	r7, sp, #0x0
 8018a2c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF4)==(DMA_HISR_DMEIF4));
 8018a2e: 687b         	ldr	r3, [r7, #0x4]
 8018a30: 685b         	ldr	r3, [r3, #0x4]
 8018a32: f003 0304    	and	r3, r3, #0x4
 8018a36: 2b04         	cmp	r3, #0x4
 8018a38: bf0c         	ite	eq
 8018a3a: 2301         	moveq	r3, #0x1
 8018a3c: 2300         	movne	r3, #0x0
 8018a3e: b2db         	uxtb	r3, r3
; }
 8018a40: 4618         	mov	r0, r3
 8018a42: 370c         	adds	r7, #0xc
 8018a44: 46bd         	mov	sp, r7
 8018a46: f85d 7b04    	ldr	r7, [sp], #4
 8018a4a: 4770         	bx	lr

08018a4c <LL_DMA_IsActiveFlag_DME5>:
; {
 8018a4c: b480         	push	{r7}
 8018a4e: b083         	sub	sp, #0xc
 8018a50: af00         	add	r7, sp, #0x0
 8018a52: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF5)==(DMA_HISR_DMEIF5));
 8018a54: 687b         	ldr	r3, [r7, #0x4]
 8018a56: 685b         	ldr	r3, [r3, #0x4]
 8018a58: f403 7380    	and	r3, r3, #0x100
 8018a5c: f5b3 7f80    	cmp.w	r3, #0x100
 8018a60: bf0c         	ite	eq
 8018a62: 2301         	moveq	r3, #0x1
 8018a64: 2300         	movne	r3, #0x0
 8018a66: b2db         	uxtb	r3, r3
; }
 8018a68: 4618         	mov	r0, r3
 8018a6a: 370c         	adds	r7, #0xc
 8018a6c: 46bd         	mov	sp, r7
 8018a6e: f85d 7b04    	ldr	r7, [sp], #4
 8018a72: 4770         	bx	lr

08018a74 <LL_DMA_IsActiveFlag_DME6>:
; {
 8018a74: b480         	push	{r7}
 8018a76: b083         	sub	sp, #0xc
 8018a78: af00         	add	r7, sp, #0x0
 8018a7a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF6)==(DMA_HISR_DMEIF6));
 8018a7c: 687b         	ldr	r3, [r7, #0x4]
 8018a7e: 685b         	ldr	r3, [r3, #0x4]
 8018a80: f403 2380    	and	r3, r3, #0x40000
 8018a84: f5b3 2f80    	cmp.w	r3, #0x40000
 8018a88: bf0c         	ite	eq
 8018a8a: 2301         	moveq	r3, #0x1
 8018a8c: 2300         	movne	r3, #0x0
 8018a8e: b2db         	uxtb	r3, r3
; }
 8018a90: 4618         	mov	r0, r3
 8018a92: 370c         	adds	r7, #0xc
 8018a94: 46bd         	mov	sp, r7
 8018a96: f85d 7b04    	ldr	r7, [sp], #4
 8018a9a: 4770         	bx	lr

08018a9c <LL_DMA_IsActiveFlag_DME7>:
; {
 8018a9c: b480         	push	{r7}
 8018a9e: b083         	sub	sp, #0xc
 8018aa0: af00         	add	r7, sp, #0x0
 8018aa2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_DMEIF7)==(DMA_HISR_DMEIF7));
 8018aa4: 687b         	ldr	r3, [r7, #0x4]
 8018aa6: 685b         	ldr	r3, [r3, #0x4]
 8018aa8: f003 7380    	and	r3, r3, #0x1000000
 8018aac: f1b3 7f80    	cmp.w	r3, #0x1000000
 8018ab0: bf0c         	ite	eq
 8018ab2: 2301         	moveq	r3, #0x1
 8018ab4: 2300         	movne	r3, #0x0
 8018ab6: b2db         	uxtb	r3, r3
; }
 8018ab8: 4618         	mov	r0, r3
 8018aba: 370c         	adds	r7, #0xc
 8018abc: 46bd         	mov	sp, r7
 8018abe: f85d 7b04    	ldr	r7, [sp], #4
 8018ac2: 4770         	bx	lr

08018ac4 <LL_DMA_IsActiveFlag_FE0>:
; {
 8018ac4: b480         	push	{r7}
 8018ac6: b083         	sub	sp, #0xc
 8018ac8: af00         	add	r7, sp, #0x0
 8018aca: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF0)==(DMA_LISR_FEIF0));
 8018acc: 687b         	ldr	r3, [r7, #0x4]
 8018ace: 681b         	ldr	r3, [r3]
 8018ad0: f003 0301    	and	r3, r3, #0x1
 8018ad4: 2b01         	cmp	r3, #0x1
 8018ad6: bf0c         	ite	eq
 8018ad8: 2301         	moveq	r3, #0x1
 8018ada: 2300         	movne	r3, #0x0
 8018adc: b2db         	uxtb	r3, r3
; }
 8018ade: 4618         	mov	r0, r3
 8018ae0: 370c         	adds	r7, #0xc
 8018ae2: 46bd         	mov	sp, r7
 8018ae4: f85d 7b04    	ldr	r7, [sp], #4
 8018ae8: 4770         	bx	lr

08018aea <LL_DMA_IsActiveFlag_FE1>:
; {
 8018aea: b480         	push	{r7}
 8018aec: b083         	sub	sp, #0xc
 8018aee: af00         	add	r7, sp, #0x0
 8018af0: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF1)==(DMA_LISR_FEIF1));
 8018af2: 687b         	ldr	r3, [r7, #0x4]
 8018af4: 681b         	ldr	r3, [r3]
 8018af6: f003 0340    	and	r3, r3, #0x40
 8018afa: 2b40         	cmp	r3, #0x40
 8018afc: bf0c         	ite	eq
 8018afe: 2301         	moveq	r3, #0x1
 8018b00: 2300         	movne	r3, #0x0
 8018b02: b2db         	uxtb	r3, r3
; }
 8018b04: 4618         	mov	r0, r3
 8018b06: 370c         	adds	r7, #0xc
 8018b08: 46bd         	mov	sp, r7
 8018b0a: f85d 7b04    	ldr	r7, [sp], #4
 8018b0e: 4770         	bx	lr

08018b10 <LL_DMA_IsActiveFlag_FE2>:
; {
 8018b10: b480         	push	{r7}
 8018b12: b083         	sub	sp, #0xc
 8018b14: af00         	add	r7, sp, #0x0
 8018b16: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF2)==(DMA_LISR_FEIF2));
 8018b18: 687b         	ldr	r3, [r7, #0x4]
 8018b1a: 681b         	ldr	r3, [r3]
 8018b1c: f403 3380    	and	r3, r3, #0x10000
 8018b20: f5b3 3f80    	cmp.w	r3, #0x10000
 8018b24: bf0c         	ite	eq
 8018b26: 2301         	moveq	r3, #0x1
 8018b28: 2300         	movne	r3, #0x0
 8018b2a: b2db         	uxtb	r3, r3
; }
 8018b2c: 4618         	mov	r0, r3
 8018b2e: 370c         	adds	r7, #0xc
 8018b30: 46bd         	mov	sp, r7
 8018b32: f85d 7b04    	ldr	r7, [sp], #4
 8018b36: 4770         	bx	lr

08018b38 <LL_DMA_IsActiveFlag_FE3>:
; {
 8018b38: b480         	push	{r7}
 8018b3a: b083         	sub	sp, #0xc
 8018b3c: af00         	add	r7, sp, #0x0
 8018b3e: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->LISR ,DMA_LISR_FEIF3)==(DMA_LISR_FEIF3));
 8018b40: 687b         	ldr	r3, [r7, #0x4]
 8018b42: 681b         	ldr	r3, [r3]
 8018b44: f403 0380    	and	r3, r3, #0x400000
 8018b48: f5b3 0f80    	cmp.w	r3, #0x400000
 8018b4c: bf0c         	ite	eq
 8018b4e: 2301         	moveq	r3, #0x1
 8018b50: 2300         	movne	r3, #0x0
 8018b52: b2db         	uxtb	r3, r3
; }
 8018b54: 4618         	mov	r0, r3
 8018b56: 370c         	adds	r7, #0xc
 8018b58: 46bd         	mov	sp, r7
 8018b5a: f85d 7b04    	ldr	r7, [sp], #4
 8018b5e: 4770         	bx	lr

08018b60 <LL_DMA_IsActiveFlag_FE4>:
; {
 8018b60: b480         	push	{r7}
 8018b62: b083         	sub	sp, #0xc
 8018b64: af00         	add	r7, sp, #0x0
 8018b66: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF4)==(DMA_HISR_FEIF4));
 8018b68: 687b         	ldr	r3, [r7, #0x4]
 8018b6a: 685b         	ldr	r3, [r3, #0x4]
 8018b6c: f003 0301    	and	r3, r3, #0x1
 8018b70: 2b01         	cmp	r3, #0x1
 8018b72: bf0c         	ite	eq
 8018b74: 2301         	moveq	r3, #0x1
 8018b76: 2300         	movne	r3, #0x0
 8018b78: b2db         	uxtb	r3, r3
; }
 8018b7a: 4618         	mov	r0, r3
 8018b7c: 370c         	adds	r7, #0xc
 8018b7e: 46bd         	mov	sp, r7
 8018b80: f85d 7b04    	ldr	r7, [sp], #4
 8018b84: 4770         	bx	lr

08018b86 <LL_DMA_IsActiveFlag_FE5>:
; {
 8018b86: b480         	push	{r7}
 8018b88: b083         	sub	sp, #0xc
 8018b8a: af00         	add	r7, sp, #0x0
 8018b8c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF5)==(DMA_HISR_FEIF5));
 8018b8e: 687b         	ldr	r3, [r7, #0x4]
 8018b90: 685b         	ldr	r3, [r3, #0x4]
 8018b92: f003 0340    	and	r3, r3, #0x40
 8018b96: 2b40         	cmp	r3, #0x40
 8018b98: bf0c         	ite	eq
 8018b9a: 2301         	moveq	r3, #0x1
 8018b9c: 2300         	movne	r3, #0x0
 8018b9e: b2db         	uxtb	r3, r3
; }
 8018ba0: 4618         	mov	r0, r3
 8018ba2: 370c         	adds	r7, #0xc
 8018ba4: 46bd         	mov	sp, r7
 8018ba6: f85d 7b04    	ldr	r7, [sp], #4
 8018baa: 4770         	bx	lr

08018bac <LL_DMA_IsActiveFlag_FE6>:
; {
 8018bac: b480         	push	{r7}
 8018bae: b083         	sub	sp, #0xc
 8018bb0: af00         	add	r7, sp, #0x0
 8018bb2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF6)==(DMA_HISR_FEIF6));
 8018bb4: 687b         	ldr	r3, [r7, #0x4]
 8018bb6: 685b         	ldr	r3, [r3, #0x4]
 8018bb8: f403 3380    	and	r3, r3, #0x10000
 8018bbc: f5b3 3f80    	cmp.w	r3, #0x10000
 8018bc0: bf0c         	ite	eq
 8018bc2: 2301         	moveq	r3, #0x1
 8018bc4: 2300         	movne	r3, #0x0
 8018bc6: b2db         	uxtb	r3, r3
; }
 8018bc8: 4618         	mov	r0, r3
 8018bca: 370c         	adds	r7, #0xc
 8018bcc: 46bd         	mov	sp, r7
 8018bce: f85d 7b04    	ldr	r7, [sp], #4
 8018bd2: 4770         	bx	lr

08018bd4 <LL_DMA_IsActiveFlag_FE7>:
; {
 8018bd4: b480         	push	{r7}
 8018bd6: b083         	sub	sp, #0xc
 8018bd8: af00         	add	r7, sp, #0x0
 8018bda: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(DMAx->HISR ,DMA_HISR_FEIF7)==(DMA_HISR_FEIF7));
 8018bdc: 687b         	ldr	r3, [r7, #0x4]
 8018bde: 685b         	ldr	r3, [r3, #0x4]
 8018be0: f403 0380    	and	r3, r3, #0x400000
 8018be4: f5b3 0f80    	cmp.w	r3, #0x400000
 8018be8: bf0c         	ite	eq
 8018bea: 2301         	moveq	r3, #0x1
 8018bec: 2300         	movne	r3, #0x0
 8018bee: b2db         	uxtb	r3, r3
; }
 8018bf0: 4618         	mov	r0, r3
 8018bf2: 370c         	adds	r7, #0xc
 8018bf4: 46bd         	mov	sp, r7
 8018bf6: f85d 7b04    	ldr	r7, [sp], #4
 8018bfa: 4770         	bx	lr

08018bfc <LL_DMA_ClearFlag_HT0>:
; {
 8018bfc: b480         	push	{r7}
 8018bfe: b083         	sub	sp, #0xc
 8018c00: af00         	add	r7, sp, #0x0
 8018c02: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF0);
 8018c04: 687b         	ldr	r3, [r7, #0x4]
 8018c06: 2210         	movs	r2, #0x10
 8018c08: 609a         	str	r2, [r3, #0x8]
; }
 8018c0a: bf00         	nop
 8018c0c: 370c         	adds	r7, #0xc
 8018c0e: 46bd         	mov	sp, r7
 8018c10: f85d 7b04    	ldr	r7, [sp], #4
 8018c14: 4770         	bx	lr

08018c16 <LL_DMA_ClearFlag_HT1>:
; {
 8018c16: b480         	push	{r7}
 8018c18: b083         	sub	sp, #0xc
 8018c1a: af00         	add	r7, sp, #0x0
 8018c1c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF1);
 8018c1e: 687b         	ldr	r3, [r7, #0x4]
 8018c20: f44f 6280    	mov.w	r2, #0x400
 8018c24: 609a         	str	r2, [r3, #0x8]
; }
 8018c26: bf00         	nop
 8018c28: 370c         	adds	r7, #0xc
 8018c2a: 46bd         	mov	sp, r7
 8018c2c: f85d 7b04    	ldr	r7, [sp], #4
 8018c30: 4770         	bx	lr

08018c32 <LL_DMA_ClearFlag_HT2>:
; {
 8018c32: b480         	push	{r7}
 8018c34: b083         	sub	sp, #0xc
 8018c36: af00         	add	r7, sp, #0x0
 8018c38: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF2);
 8018c3a: 687b         	ldr	r3, [r7, #0x4]
 8018c3c: f44f 1280    	mov.w	r2, #0x100000
 8018c40: 609a         	str	r2, [r3, #0x8]
; }
 8018c42: bf00         	nop
 8018c44: 370c         	adds	r7, #0xc
 8018c46: 46bd         	mov	sp, r7
 8018c48: f85d 7b04    	ldr	r7, [sp], #4
 8018c4c: 4770         	bx	lr

08018c4e <LL_DMA_ClearFlag_HT3>:
; {
 8018c4e: b480         	push	{r7}
 8018c50: b083         	sub	sp, #0xc
 8018c52: af00         	add	r7, sp, #0x0
 8018c54: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CHTIF3);
 8018c56: 687b         	ldr	r3, [r7, #0x4]
 8018c58: f04f 6280    	mov.w	r2, #0x4000000
 8018c5c: 609a         	str	r2, [r3, #0x8]
; }
 8018c5e: bf00         	nop
 8018c60: 370c         	adds	r7, #0xc
 8018c62: 46bd         	mov	sp, r7
 8018c64: f85d 7b04    	ldr	r7, [sp], #4
 8018c68: 4770         	bx	lr

08018c6a <LL_DMA_ClearFlag_HT4>:
; {
 8018c6a: b480         	push	{r7}
 8018c6c: b083         	sub	sp, #0xc
 8018c6e: af00         	add	r7, sp, #0x0
 8018c70: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF4);
 8018c72: 687b         	ldr	r3, [r7, #0x4]
 8018c74: 2210         	movs	r2, #0x10
 8018c76: 60da         	str	r2, [r3, #0xc]
; }
 8018c78: bf00         	nop
 8018c7a: 370c         	adds	r7, #0xc
 8018c7c: 46bd         	mov	sp, r7
 8018c7e: f85d 7b04    	ldr	r7, [sp], #4
 8018c82: 4770         	bx	lr

08018c84 <LL_DMA_ClearFlag_HT5>:
; {
 8018c84: b480         	push	{r7}
 8018c86: b083         	sub	sp, #0xc
 8018c88: af00         	add	r7, sp, #0x0
 8018c8a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF5);
 8018c8c: 687b         	ldr	r3, [r7, #0x4]
 8018c8e: f44f 6280    	mov.w	r2, #0x400
 8018c92: 60da         	str	r2, [r3, #0xc]
; }
 8018c94: bf00         	nop
 8018c96: 370c         	adds	r7, #0xc
 8018c98: 46bd         	mov	sp, r7
 8018c9a: f85d 7b04    	ldr	r7, [sp], #4
 8018c9e: 4770         	bx	lr

08018ca0 <LL_DMA_ClearFlag_HT6>:
; {
 8018ca0: b480         	push	{r7}
 8018ca2: b083         	sub	sp, #0xc
 8018ca4: af00         	add	r7, sp, #0x0
 8018ca6: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF6);
 8018ca8: 687b         	ldr	r3, [r7, #0x4]
 8018caa: f44f 1280    	mov.w	r2, #0x100000
 8018cae: 60da         	str	r2, [r3, #0xc]
; }
 8018cb0: bf00         	nop
 8018cb2: 370c         	adds	r7, #0xc
 8018cb4: 46bd         	mov	sp, r7
 8018cb6: f85d 7b04    	ldr	r7, [sp], #4
 8018cba: 4770         	bx	lr

08018cbc <LL_DMA_ClearFlag_HT7>:
; {
 8018cbc: b480         	push	{r7}
 8018cbe: b083         	sub	sp, #0xc
 8018cc0: af00         	add	r7, sp, #0x0
 8018cc2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CHTIF7);
 8018cc4: 687b         	ldr	r3, [r7, #0x4]
 8018cc6: f04f 6280    	mov.w	r2, #0x4000000
 8018cca: 60da         	str	r2, [r3, #0xc]
; }
 8018ccc: bf00         	nop
 8018cce: 370c         	adds	r7, #0xc
 8018cd0: 46bd         	mov	sp, r7
 8018cd2: f85d 7b04    	ldr	r7, [sp], #4
 8018cd6: 4770         	bx	lr

08018cd8 <LL_DMA_ClearFlag_TC0>:
; {
 8018cd8: b480         	push	{r7}
 8018cda: b083         	sub	sp, #0xc
 8018cdc: af00         	add	r7, sp, #0x0
 8018cde: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF0);
 8018ce0: 687b         	ldr	r3, [r7, #0x4]
 8018ce2: 2220         	movs	r2, #0x20
 8018ce4: 609a         	str	r2, [r3, #0x8]
; }
 8018ce6: bf00         	nop
 8018ce8: 370c         	adds	r7, #0xc
 8018cea: 46bd         	mov	sp, r7
 8018cec: f85d 7b04    	ldr	r7, [sp], #4
 8018cf0: 4770         	bx	lr

08018cf2 <LL_DMA_ClearFlag_TC1>:
; {
 8018cf2: b480         	push	{r7}
 8018cf4: b083         	sub	sp, #0xc
 8018cf6: af00         	add	r7, sp, #0x0
 8018cf8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF1);
 8018cfa: 687b         	ldr	r3, [r7, #0x4]
 8018cfc: f44f 6200    	mov.w	r2, #0x800
 8018d00: 609a         	str	r2, [r3, #0x8]
; }
 8018d02: bf00         	nop
 8018d04: 370c         	adds	r7, #0xc
 8018d06: 46bd         	mov	sp, r7
 8018d08: f85d 7b04    	ldr	r7, [sp], #4
 8018d0c: 4770         	bx	lr

08018d0e <LL_DMA_ClearFlag_TC2>:
; {
 8018d0e: b480         	push	{r7}
 8018d10: b083         	sub	sp, #0xc
 8018d12: af00         	add	r7, sp, #0x0
 8018d14: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF2);
 8018d16: 687b         	ldr	r3, [r7, #0x4]
 8018d18: f44f 1200    	mov.w	r2, #0x200000
 8018d1c: 609a         	str	r2, [r3, #0x8]
; }
 8018d1e: bf00         	nop
 8018d20: 370c         	adds	r7, #0xc
 8018d22: 46bd         	mov	sp, r7
 8018d24: f85d 7b04    	ldr	r7, [sp], #4
 8018d28: 4770         	bx	lr

08018d2a <LL_DMA_ClearFlag_TC3>:
; {
 8018d2a: b480         	push	{r7}
 8018d2c: b083         	sub	sp, #0xc
 8018d2e: af00         	add	r7, sp, #0x0
 8018d30: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTCIF3);
 8018d32: 687b         	ldr	r3, [r7, #0x4]
 8018d34: f04f 6200    	mov.w	r2, #0x8000000
 8018d38: 609a         	str	r2, [r3, #0x8]
; }
 8018d3a: bf00         	nop
 8018d3c: 370c         	adds	r7, #0xc
 8018d3e: 46bd         	mov	sp, r7
 8018d40: f85d 7b04    	ldr	r7, [sp], #4
 8018d44: 4770         	bx	lr

08018d46 <LL_DMA_ClearFlag_TC4>:
; {
 8018d46: b480         	push	{r7}
 8018d48: b083         	sub	sp, #0xc
 8018d4a: af00         	add	r7, sp, #0x0
 8018d4c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF4);
 8018d4e: 687b         	ldr	r3, [r7, #0x4]
 8018d50: 2220         	movs	r2, #0x20
 8018d52: 60da         	str	r2, [r3, #0xc]
; }
 8018d54: bf00         	nop
 8018d56: 370c         	adds	r7, #0xc
 8018d58: 46bd         	mov	sp, r7
 8018d5a: f85d 7b04    	ldr	r7, [sp], #4
 8018d5e: 4770         	bx	lr

08018d60 <LL_DMA_ClearFlag_TC5>:
; {
 8018d60: b480         	push	{r7}
 8018d62: b083         	sub	sp, #0xc
 8018d64: af00         	add	r7, sp, #0x0
 8018d66: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF5);
 8018d68: 687b         	ldr	r3, [r7, #0x4]
 8018d6a: f44f 6200    	mov.w	r2, #0x800
 8018d6e: 60da         	str	r2, [r3, #0xc]
; }
 8018d70: bf00         	nop
 8018d72: 370c         	adds	r7, #0xc
 8018d74: 46bd         	mov	sp, r7
 8018d76: f85d 7b04    	ldr	r7, [sp], #4
 8018d7a: 4770         	bx	lr

08018d7c <LL_DMA_ClearFlag_TC6>:
; {
 8018d7c: b480         	push	{r7}
 8018d7e: b083         	sub	sp, #0xc
 8018d80: af00         	add	r7, sp, #0x0
 8018d82: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF6);
 8018d84: 687b         	ldr	r3, [r7, #0x4]
 8018d86: f44f 1200    	mov.w	r2, #0x200000
 8018d8a: 60da         	str	r2, [r3, #0xc]
; }
 8018d8c: bf00         	nop
 8018d8e: 370c         	adds	r7, #0xc
 8018d90: 46bd         	mov	sp, r7
 8018d92: f85d 7b04    	ldr	r7, [sp], #4
 8018d96: 4770         	bx	lr

08018d98 <LL_DMA_ClearFlag_TC7>:
; {
 8018d98: b480         	push	{r7}
 8018d9a: b083         	sub	sp, #0xc
 8018d9c: af00         	add	r7, sp, #0x0
 8018d9e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTCIF7);
 8018da0: 687b         	ldr	r3, [r7, #0x4]
 8018da2: f04f 6200    	mov.w	r2, #0x8000000
 8018da6: 60da         	str	r2, [r3, #0xc]
; }
 8018da8: bf00         	nop
 8018daa: 370c         	adds	r7, #0xc
 8018dac: 46bd         	mov	sp, r7
 8018dae: f85d 7b04    	ldr	r7, [sp], #4
 8018db2: 4770         	bx	lr

08018db4 <LL_DMA_ClearFlag_TE0>:
; {
 8018db4: b480         	push	{r7}
 8018db6: b083         	sub	sp, #0xc
 8018db8: af00         	add	r7, sp, #0x0
 8018dba: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF0);
 8018dbc: 687b         	ldr	r3, [r7, #0x4]
 8018dbe: 2208         	movs	r2, #0x8
 8018dc0: 609a         	str	r2, [r3, #0x8]
; }
 8018dc2: bf00         	nop
 8018dc4: 370c         	adds	r7, #0xc
 8018dc6: 46bd         	mov	sp, r7
 8018dc8: f85d 7b04    	ldr	r7, [sp], #4
 8018dcc: 4770         	bx	lr

08018dce <LL_DMA_ClearFlag_TE1>:
; {
 8018dce: b480         	push	{r7}
 8018dd0: b083         	sub	sp, #0xc
 8018dd2: af00         	add	r7, sp, #0x0
 8018dd4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF1);
 8018dd6: 687b         	ldr	r3, [r7, #0x4]
 8018dd8: f44f 7200    	mov.w	r2, #0x200
 8018ddc: 609a         	str	r2, [r3, #0x8]
; }
 8018dde: bf00         	nop
 8018de0: 370c         	adds	r7, #0xc
 8018de2: 46bd         	mov	sp, r7
 8018de4: f85d 7b04    	ldr	r7, [sp], #4
 8018de8: 4770         	bx	lr

08018dea <LL_DMA_ClearFlag_TE2>:
; {
 8018dea: b480         	push	{r7}
 8018dec: b083         	sub	sp, #0xc
 8018dee: af00         	add	r7, sp, #0x0
 8018df0: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF2);
 8018df2: 687b         	ldr	r3, [r7, #0x4]
 8018df4: f44f 2200    	mov.w	r2, #0x80000
 8018df8: 609a         	str	r2, [r3, #0x8]
; }
 8018dfa: bf00         	nop
 8018dfc: 370c         	adds	r7, #0xc
 8018dfe: 46bd         	mov	sp, r7
 8018e00: f85d 7b04    	ldr	r7, [sp], #4
 8018e04: 4770         	bx	lr

08018e06 <LL_DMA_ClearFlag_TE3>:
; {
 8018e06: b480         	push	{r7}
 8018e08: b083         	sub	sp, #0xc
 8018e0a: af00         	add	r7, sp, #0x0
 8018e0c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CTEIF3);
 8018e0e: 687b         	ldr	r3, [r7, #0x4]
 8018e10: f04f 7200    	mov.w	r2, #0x2000000
 8018e14: 609a         	str	r2, [r3, #0x8]
; }
 8018e16: bf00         	nop
 8018e18: 370c         	adds	r7, #0xc
 8018e1a: 46bd         	mov	sp, r7
 8018e1c: f85d 7b04    	ldr	r7, [sp], #4
 8018e20: 4770         	bx	lr

08018e22 <LL_DMA_ClearFlag_TE4>:
; {
 8018e22: b480         	push	{r7}
 8018e24: b083         	sub	sp, #0xc
 8018e26: af00         	add	r7, sp, #0x0
 8018e28: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF4);
 8018e2a: 687b         	ldr	r3, [r7, #0x4]
 8018e2c: 2208         	movs	r2, #0x8
 8018e2e: 60da         	str	r2, [r3, #0xc]
; }
 8018e30: bf00         	nop
 8018e32: 370c         	adds	r7, #0xc
 8018e34: 46bd         	mov	sp, r7
 8018e36: f85d 7b04    	ldr	r7, [sp], #4
 8018e3a: 4770         	bx	lr

08018e3c <LL_DMA_ClearFlag_TE5>:
; {
 8018e3c: b480         	push	{r7}
 8018e3e: b083         	sub	sp, #0xc
 8018e40: af00         	add	r7, sp, #0x0
 8018e42: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF5);
 8018e44: 687b         	ldr	r3, [r7, #0x4]
 8018e46: f44f 7200    	mov.w	r2, #0x200
 8018e4a: 60da         	str	r2, [r3, #0xc]
; }
 8018e4c: bf00         	nop
 8018e4e: 370c         	adds	r7, #0xc
 8018e50: 46bd         	mov	sp, r7
 8018e52: f85d 7b04    	ldr	r7, [sp], #4
 8018e56: 4770         	bx	lr

08018e58 <LL_DMA_ClearFlag_TE6>:
; {
 8018e58: b480         	push	{r7}
 8018e5a: b083         	sub	sp, #0xc
 8018e5c: af00         	add	r7, sp, #0x0
 8018e5e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF6);
 8018e60: 687b         	ldr	r3, [r7, #0x4]
 8018e62: f44f 2200    	mov.w	r2, #0x80000
 8018e66: 60da         	str	r2, [r3, #0xc]
; }
 8018e68: bf00         	nop
 8018e6a: 370c         	adds	r7, #0xc
 8018e6c: 46bd         	mov	sp, r7
 8018e6e: f85d 7b04    	ldr	r7, [sp], #4
 8018e72: 4770         	bx	lr

08018e74 <LL_DMA_ClearFlag_TE7>:
; {
 8018e74: b480         	push	{r7}
 8018e76: b083         	sub	sp, #0xc
 8018e78: af00         	add	r7, sp, #0x0
 8018e7a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CTEIF7);
 8018e7c: 687b         	ldr	r3, [r7, #0x4]
 8018e7e: f04f 7200    	mov.w	r2, #0x2000000
 8018e82: 60da         	str	r2, [r3, #0xc]
; }
 8018e84: bf00         	nop
 8018e86: 370c         	adds	r7, #0xc
 8018e88: 46bd         	mov	sp, r7
 8018e8a: f85d 7b04    	ldr	r7, [sp], #4
 8018e8e: 4770         	bx	lr

08018e90 <LL_DMA_ClearFlag_DME0>:
; {
 8018e90: b480         	push	{r7}
 8018e92: b083         	sub	sp, #0xc
 8018e94: af00         	add	r7, sp, #0x0
 8018e96: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF0);
 8018e98: 687b         	ldr	r3, [r7, #0x4]
 8018e9a: 2204         	movs	r2, #0x4
 8018e9c: 609a         	str	r2, [r3, #0x8]
; }
 8018e9e: bf00         	nop
 8018ea0: 370c         	adds	r7, #0xc
 8018ea2: 46bd         	mov	sp, r7
 8018ea4: f85d 7b04    	ldr	r7, [sp], #4
 8018ea8: 4770         	bx	lr

08018eaa <LL_DMA_ClearFlag_DME1>:
; {
 8018eaa: b480         	push	{r7}
 8018eac: b083         	sub	sp, #0xc
 8018eae: af00         	add	r7, sp, #0x0
 8018eb0: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF1);
 8018eb2: 687b         	ldr	r3, [r7, #0x4]
 8018eb4: f44f 7280    	mov.w	r2, #0x100
 8018eb8: 609a         	str	r2, [r3, #0x8]
; }
 8018eba: bf00         	nop
 8018ebc: 370c         	adds	r7, #0xc
 8018ebe: 46bd         	mov	sp, r7
 8018ec0: f85d 7b04    	ldr	r7, [sp], #4
 8018ec4: 4770         	bx	lr

08018ec6 <LL_DMA_ClearFlag_DME2>:
; {
 8018ec6: b480         	push	{r7}
 8018ec8: b083         	sub	sp, #0xc
 8018eca: af00         	add	r7, sp, #0x0
 8018ecc: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF2);
 8018ece: 687b         	ldr	r3, [r7, #0x4]
 8018ed0: f44f 2280    	mov.w	r2, #0x40000
 8018ed4: 609a         	str	r2, [r3, #0x8]
; }
 8018ed6: bf00         	nop
 8018ed8: 370c         	adds	r7, #0xc
 8018eda: 46bd         	mov	sp, r7
 8018edc: f85d 7b04    	ldr	r7, [sp], #4
 8018ee0: 4770         	bx	lr

08018ee2 <LL_DMA_ClearFlag_DME3>:
; {
 8018ee2: b480         	push	{r7}
 8018ee4: b083         	sub	sp, #0xc
 8018ee6: af00         	add	r7, sp, #0x0
 8018ee8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CDMEIF3);
 8018eea: 687b         	ldr	r3, [r7, #0x4]
 8018eec: f04f 7280    	mov.w	r2, #0x1000000
 8018ef0: 609a         	str	r2, [r3, #0x8]
; }
 8018ef2: bf00         	nop
 8018ef4: 370c         	adds	r7, #0xc
 8018ef6: 46bd         	mov	sp, r7
 8018ef8: f85d 7b04    	ldr	r7, [sp], #4
 8018efc: 4770         	bx	lr

08018efe <LL_DMA_ClearFlag_DME4>:
; {
 8018efe: b480         	push	{r7}
 8018f00: b083         	sub	sp, #0xc
 8018f02: af00         	add	r7, sp, #0x0
 8018f04: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF4);
 8018f06: 687b         	ldr	r3, [r7, #0x4]
 8018f08: 2204         	movs	r2, #0x4
 8018f0a: 60da         	str	r2, [r3, #0xc]
; }
 8018f0c: bf00         	nop
 8018f0e: 370c         	adds	r7, #0xc
 8018f10: 46bd         	mov	sp, r7
 8018f12: f85d 7b04    	ldr	r7, [sp], #4
 8018f16: 4770         	bx	lr

08018f18 <LL_DMA_ClearFlag_DME5>:
; {
 8018f18: b480         	push	{r7}
 8018f1a: b083         	sub	sp, #0xc
 8018f1c: af00         	add	r7, sp, #0x0
 8018f1e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF5);
 8018f20: 687b         	ldr	r3, [r7, #0x4]
 8018f22: f44f 7280    	mov.w	r2, #0x100
 8018f26: 60da         	str	r2, [r3, #0xc]
; }
 8018f28: bf00         	nop
 8018f2a: 370c         	adds	r7, #0xc
 8018f2c: 46bd         	mov	sp, r7
 8018f2e: f85d 7b04    	ldr	r7, [sp], #4
 8018f32: 4770         	bx	lr

08018f34 <LL_DMA_ClearFlag_DME6>:
; {
 8018f34: b480         	push	{r7}
 8018f36: b083         	sub	sp, #0xc
 8018f38: af00         	add	r7, sp, #0x0
 8018f3a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF6);
 8018f3c: 687b         	ldr	r3, [r7, #0x4]
 8018f3e: f44f 2280    	mov.w	r2, #0x40000
 8018f42: 60da         	str	r2, [r3, #0xc]
; }
 8018f44: bf00         	nop
 8018f46: 370c         	adds	r7, #0xc
 8018f48: 46bd         	mov	sp, r7
 8018f4a: f85d 7b04    	ldr	r7, [sp], #4
 8018f4e: 4770         	bx	lr

08018f50 <LL_DMA_ClearFlag_DME7>:
; {
 8018f50: b480         	push	{r7}
 8018f52: b083         	sub	sp, #0xc
 8018f54: af00         	add	r7, sp, #0x0
 8018f56: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CDMEIF7);
 8018f58: 687b         	ldr	r3, [r7, #0x4]
 8018f5a: f04f 7280    	mov.w	r2, #0x1000000
 8018f5e: 60da         	str	r2, [r3, #0xc]
; }
 8018f60: bf00         	nop
 8018f62: 370c         	adds	r7, #0xc
 8018f64: 46bd         	mov	sp, r7
 8018f66: f85d 7b04    	ldr	r7, [sp], #4
 8018f6a: 4770         	bx	lr

08018f6c <LL_DMA_ClearFlag_FE0>:
; {
 8018f6c: b480         	push	{r7}
 8018f6e: b083         	sub	sp, #0xc
 8018f70: af00         	add	r7, sp, #0x0
 8018f72: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF0);
 8018f74: 687b         	ldr	r3, [r7, #0x4]
 8018f76: 2201         	movs	r2, #0x1
 8018f78: 609a         	str	r2, [r3, #0x8]
; }
 8018f7a: bf00         	nop
 8018f7c: 370c         	adds	r7, #0xc
 8018f7e: 46bd         	mov	sp, r7
 8018f80: f85d 7b04    	ldr	r7, [sp], #4
 8018f84: 4770         	bx	lr

08018f86 <LL_DMA_ClearFlag_FE1>:
; {
 8018f86: b480         	push	{r7}
 8018f88: b083         	sub	sp, #0xc
 8018f8a: af00         	add	r7, sp, #0x0
 8018f8c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF1);
 8018f8e: 687b         	ldr	r3, [r7, #0x4]
 8018f90: 2240         	movs	r2, #0x40
 8018f92: 609a         	str	r2, [r3, #0x8]
; }
 8018f94: bf00         	nop
 8018f96: 370c         	adds	r7, #0xc
 8018f98: 46bd         	mov	sp, r7
 8018f9a: f85d 7b04    	ldr	r7, [sp], #4
 8018f9e: 4770         	bx	lr

08018fa0 <LL_DMA_ClearFlag_FE2>:
; {
 8018fa0: b480         	push	{r7}
 8018fa2: b083         	sub	sp, #0xc
 8018fa4: af00         	add	r7, sp, #0x0
 8018fa6: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF2);
 8018fa8: 687b         	ldr	r3, [r7, #0x4]
 8018faa: f44f 3280    	mov.w	r2, #0x10000
 8018fae: 609a         	str	r2, [r3, #0x8]
; }
 8018fb0: bf00         	nop
 8018fb2: 370c         	adds	r7, #0xc
 8018fb4: 46bd         	mov	sp, r7
 8018fb6: f85d 7b04    	ldr	r7, [sp], #4
 8018fba: 4770         	bx	lr

08018fbc <LL_DMA_ClearFlag_FE3>:
; {
 8018fbc: b480         	push	{r7}
 8018fbe: b083         	sub	sp, #0xc
 8018fc0: af00         	add	r7, sp, #0x0
 8018fc2: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->LIFCR , DMA_LIFCR_CFEIF3);
 8018fc4: 687b         	ldr	r3, [r7, #0x4]
 8018fc6: f44f 0280    	mov.w	r2, #0x400000
 8018fca: 609a         	str	r2, [r3, #0x8]
; }
 8018fcc: bf00         	nop
 8018fce: 370c         	adds	r7, #0xc
 8018fd0: 46bd         	mov	sp, r7
 8018fd2: f85d 7b04    	ldr	r7, [sp], #4
 8018fd6: 4770         	bx	lr

08018fd8 <LL_DMA_ClearFlag_FE4>:
; {
 8018fd8: b480         	push	{r7}
 8018fda: b083         	sub	sp, #0xc
 8018fdc: af00         	add	r7, sp, #0x0
 8018fde: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF4);
 8018fe0: 687b         	ldr	r3, [r7, #0x4]
 8018fe2: 2201         	movs	r2, #0x1
 8018fe4: 60da         	str	r2, [r3, #0xc]
; }
 8018fe6: bf00         	nop
 8018fe8: 370c         	adds	r7, #0xc
 8018fea: 46bd         	mov	sp, r7
 8018fec: f85d 7b04    	ldr	r7, [sp], #4
 8018ff0: 4770         	bx	lr

08018ff2 <LL_DMA_ClearFlag_FE5>:
; {
 8018ff2: b480         	push	{r7}
 8018ff4: b083         	sub	sp, #0xc
 8018ff6: af00         	add	r7, sp, #0x0
 8018ff8: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF5);
 8018ffa: 687b         	ldr	r3, [r7, #0x4]
 8018ffc: 2240         	movs	r2, #0x40
 8018ffe: 60da         	str	r2, [r3, #0xc]
; }
 8019000: bf00         	nop
 8019002: 370c         	adds	r7, #0xc
 8019004: 46bd         	mov	sp, r7
 8019006: f85d 7b04    	ldr	r7, [sp], #4
 801900a: 4770         	bx	lr

0801900c <LL_DMA_ClearFlag_FE6>:
; {
 801900c: b480         	push	{r7}
 801900e: b083         	sub	sp, #0xc
 8019010: af00         	add	r7, sp, #0x0
 8019012: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF6);
 8019014: 687b         	ldr	r3, [r7, #0x4]
 8019016: f44f 3280    	mov.w	r2, #0x10000
 801901a: 60da         	str	r2, [r3, #0xc]
; }
 801901c: bf00         	nop
 801901e: 370c         	adds	r7, #0xc
 8019020: 46bd         	mov	sp, r7
 8019022: f85d 7b04    	ldr	r7, [sp], #4
 8019026: 4770         	bx	lr

08019028 <LL_DMA_ClearFlag_FE7>:
; {
 8019028: b480         	push	{r7}
 801902a: b083         	sub	sp, #0xc
 801902c: af00         	add	r7, sp, #0x0
 801902e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(DMAx->HIFCR , DMA_HIFCR_CFEIF7);
 8019030: 687b         	ldr	r3, [r7, #0x4]
 8019032: f44f 0280    	mov.w	r2, #0x400000
 8019036: 60da         	str	r2, [r3, #0xc]
; }
 8019038: bf00         	nop
 801903a: 370c         	adds	r7, #0xc
 801903c: 46bd         	mov	sp, r7
 801903e: f85d 7b04    	ldr	r7, [sp], #4
 8019042: 4770         	bx	lr

08019044 <z_log_msg_runtime_create>:
; {
 8019044: b580         	push	{r7, lr}
 8019046: b08a         	sub	sp, #0x28
 8019048: af04         	add	r7, sp, #0x10
 801904a: 60b9         	str	r1, [r7, #0x8]
 801904c: 607b         	str	r3, [r7, #0x4]
 801904e: 4603         	mov	r3, r0
 8019050: 73fb         	strb	r3, [r7, #0xf]
 8019052: 4613         	mov	r3, r2
 8019054: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8019056: f107 032c    	add.w	r3, r7, #0x2c
 801905a: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801905c: 7bba         	ldrb	r2, [r7, #0xe]
 801905e: 7bf8         	ldrb	r0, [r7, #0xf]
 8019060: 697b         	ldr	r3, [r7, #0x14]
 8019062: 9303         	str	r3, [sp, #0xc]
 8019064: 6abb         	ldr	r3, [r7, #0x28]
 8019066: 9302         	str	r3, [sp, #0x8]
 8019068: 6a7b         	ldr	r3, [r7, #0x24]
 801906a: 9301         	str	r3, [sp, #0x4]
 801906c: 6a3b         	ldr	r3, [r7, #0x20]
 801906e: 9300         	str	r3, [sp]
 8019070: 687b         	ldr	r3, [r7, #0x4]
 8019072: 68b9         	ldr	r1, [r7, #0x8]
 8019074: f7ec fa7e    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x13b04
; }
 8019078: bf00         	nop
 801907a: 3718         	adds	r7, #0x18
 801907c: 46bd         	mov	sp, r7
 801907e: bd80         	pop	{r7, pc}

08019080 <stm32_dma_is_tc_irq_active>:
; {
 8019080: b580         	push	{r7, lr}
 8019082: b082         	sub	sp, #0x8
 8019084: af00         	add	r7, sp, #0x0
 8019086: 6078         	str	r0, [r7, #0x4]
 8019088: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 801908a: 6838         	ldr	r0, [r7]
 801908c: f7f0 f8c8    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xfe70
 8019090: 4603         	mov	r3, r0
 8019092: 4619         	mov	r1, r3
 8019094: 6878         	ldr	r0, [r7, #0x4]
 8019096: f7f0 f88b    	bl	0x80091b0 <LL_DMA_IsEnabledIT_TC> @ imm = #-0xfeea
 801909a: 4603         	mov	r3, r0
 801909c: 2b00         	cmp	r3, #0x0
 801909e: d008         	beq	0x80190b2 <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_tc_active(dma, id);
 80190a0: 6839         	ldr	r1, [r7]
 80190a2: 6878         	ldr	r0, [r7, #0x4]
 80190a4: f7f0 f918    	bl	0x80092d8 <dma_stm32_is_tc_active> @ imm = #-0xfdd0
 80190a8: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_TC(dma, dma_stm32_id_to_stream(id)) &&
 80190aa: 2b00         	cmp	r3, #0x0
 80190ac: d001         	beq	0x80190b2 <stm32_dma_is_tc_irq_active+0x32> @ imm = #0x2
 80190ae: 2301         	movs	r3, #0x1
 80190b0: e000         	b	0x80190b4 <stm32_dma_is_tc_irq_active+0x34> @ imm = #0x0
 80190b2: 2300         	movs	r3, #0x0
 80190b4: f003 0301    	and	r3, r3, #0x1
 80190b8: b2db         	uxtb	r3, r3
; }
 80190ba: 4618         	mov	r0, r3
 80190bc: 3708         	adds	r7, #0x8
 80190be: 46bd         	mov	sp, r7
 80190c0: bd80         	pop	{r7, pc}

080190c2 <stm32_dma_is_ht_irq_active>:
; {
 80190c2: b580         	push	{r7, lr}
 80190c4: b082         	sub	sp, #0x8
 80190c6: af00         	add	r7, sp, #0x0
 80190c8: 6078         	str	r0, [r7, #0x4]
 80190ca: 6039         	str	r1, [r7]
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 80190cc: 6838         	ldr	r0, [r7]
 80190ce: f7f0 f8a7    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xfeb2
 80190d2: 4603         	mov	r3, r0
 80190d4: 4619         	mov	r1, r3
 80190d6: 6878         	ldr	r0, [r7, #0x4]
 80190d8: f7f0 f84e    	bl	0x8009178 <LL_DMA_IsEnabledIT_HT> @ imm = #-0xff64
 80190dc: 4603         	mov	r3, r0
 80190de: 2b00         	cmp	r3, #0x0
 80190e0: d008         	beq	0x80190f4 <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x10
; 	       dma_stm32_is_ht_active(dma, id);
 80190e2: 6839         	ldr	r1, [r7]
 80190e4: 6878         	ldr	r0, [r7, #0x4]
 80190e6: f7f0 f8df    	bl	0x80092a8 <dma_stm32_is_ht_active> @ imm = #-0xfe42
 80190ea: 4603         	mov	r3, r0
; 	return LL_DMA_IsEnabledIT_HT(dma, dma_stm32_id_to_stream(id)) &&
 80190ec: 2b00         	cmp	r3, #0x0
 80190ee: d001         	beq	0x80190f4 <stm32_dma_is_ht_irq_active+0x32> @ imm = #0x2
 80190f0: 2301         	movs	r3, #0x1
 80190f2: e000         	b	0x80190f6 <stm32_dma_is_ht_irq_active+0x34> @ imm = #0x0
 80190f4: 2300         	movs	r3, #0x0
 80190f6: f003 0301    	and	r3, r3, #0x1
 80190fa: b2db         	uxtb	r3, r3
; }
 80190fc: 4618         	mov	r0, r3
 80190fe: 3708         	adds	r7, #0x8
 8019100: 46bd         	mov	sp, r7
 8019102: bd80         	pop	{r7, pc}

08019104 <stm32_dma_clear_stream_irq>:
; {
 8019104: b580         	push	{r7, lr}
 8019106: b082         	sub	sp, #0x8
 8019108: af00         	add	r7, sp, #0x0
 801910a: 6078         	str	r0, [r7, #0x4]
 801910c: 6039         	str	r1, [r7]
; 	dma_stm32_clear_te(dma, id);
 801910e: 6839         	ldr	r1, [r7]
 8019110: 6878         	ldr	r0, [r7, #0x4]
 8019112: f7f0 f8f9    	bl	0x8009308 <dma_stm32_clear_te> @ imm = #-0xfe0e
; 	dma_stm32_clear_dme(dma, id);
 8019116: 6839         	ldr	r1, [r7]
 8019118: 6878         	ldr	r0, [r7, #0x4]
 801911a: f7f0 f907    	bl	0x800932c <dma_stm32_clear_dme> @ imm = #-0xfdf2
; 	dma_stm32_clear_fe(dma, id);
 801911e: 6839         	ldr	r1, [r7]
 8019120: 6878         	ldr	r0, [r7, #0x4]
 8019122: f7f0 f915    	bl	0x8009350 <dma_stm32_clear_fe> @ imm = #-0xfdd6
; }
 8019126: bf00         	nop
 8019128: 3708         	adds	r7, #0x8
 801912a: 46bd         	mov	sp, r7
 801912c: bd80         	pop	{r7, pc}

0801912e <stm32_dma_enable_stream>:
; {
 801912e: b580         	push	{r7, lr}
 8019130: b082         	sub	sp, #0x8
 8019132: af00         	add	r7, sp, #0x0
 8019134: 6078         	str	r0, [r7, #0x4]
 8019136: 6039         	str	r1, [r7]
; 	LL_DMA_EnableStream(dma, dma_stm32_id_to_stream(id));
 8019138: 6838         	ldr	r0, [r7]
 801913a: f7f0 f871    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xff1e
 801913e: 4603         	mov	r3, r0
 8019140: 4619         	mov	r1, r3
 8019142: 6878         	ldr	r0, [r7, #0x4]
 8019144: f7ef ff9c    	bl	0x8009080 <LL_DMA_EnableStream> @ imm = #-0x100c8
; }
 8019148: bf00         	nop
 801914a: 3708         	adds	r7, #0x8
 801914c: 46bd         	mov	sp, r7
 801914e: bd80         	pop	{r7, pc}

08019150 <stm32_dma_is_enabled_stream>:
; {
 8019150: b580         	push	{r7, lr}
 8019152: b082         	sub	sp, #0x8
 8019154: af00         	add	r7, sp, #0x0
 8019156: 6078         	str	r0, [r7, #0x4]
 8019158: 6039         	str	r1, [r7]
; 	if (LL_DMA_IsEnabledStream(dma, dma_stm32_id_to_stream(id)) == 1) {
 801915a: 6838         	ldr	r0, [r7]
 801915c: f7f0 f860    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xff40
 8019160: 4603         	mov	r3, r0
 8019162: 4619         	mov	r1, r3
 8019164: 6878         	ldr	r0, [r7, #0x4]
 8019166: f7ef ffcb    	bl	0x8009100 <LL_DMA_IsEnabledStream> @ imm = #-0x1006a
 801916a: 4603         	mov	r3, r0
 801916c: 2b01         	cmp	r3, #0x1
 801916e: d101         	bne	0x8019174 <stm32_dma_is_enabled_stream+0x24> @ imm = #0x2
; 		return true;
 8019170: 2301         	movs	r3, #0x1
 8019172: e000         	b	0x8019176 <stm32_dma_is_enabled_stream+0x26> @ imm = #0x0
; 	return false;
 8019174: 2300         	movs	r3, #0x0
; }
 8019176: 4618         	mov	r0, r3
 8019178: 3708         	adds	r7, #0x8
 801917a: 46bd         	mov	sp, r7
 801917c: bd80         	pop	{r7, pc}

0801917e <stm32_dma_disable_stream>:
; {
 801917e: b580         	push	{r7, lr}
 8019180: b082         	sub	sp, #0x8
 8019182: af00         	add	r7, sp, #0x0
 8019184: 6078         	str	r0, [r7, #0x4]
 8019186: 6039         	str	r1, [r7]
; 	LL_DMA_DisableStream(dma, dma_stm32_id_to_stream(id));
 8019188: 6838         	ldr	r0, [r7]
 801918a: f7f0 f849    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xff6e
 801918e: 4603         	mov	r3, r0
 8019190: 4619         	mov	r1, r3
 8019192: 6878         	ldr	r0, [r7, #0x4]
 8019194: f7ef ff94    	bl	0x80090c0 <LL_DMA_DisableStream> @ imm = #-0x100d8
; 	while (stm32_dma_is_enabled_stream(dma, id)) {
 8019198: bf00         	nop
 801919a: 6839         	ldr	r1, [r7]
 801919c: 6878         	ldr	r0, [r7, #0x4]
 801919e: f7ff ffd7    	bl	0x8019150 <stm32_dma_is_enabled_stream> @ imm = #-0x52
 80191a2: 4603         	mov	r3, r0
 80191a4: 2b00         	cmp	r3, #0x0
 80191a6: d1f8         	bne	0x801919a <stm32_dma_disable_stream+0x1c> @ imm = #-0x10
; 	dma_stm32_clear_tc(dma, id);
 80191a8: 6839         	ldr	r1, [r7]
 80191aa: 6878         	ldr	r0, [r7, #0x4]
 80191ac: f7f0 f86a    	bl	0x8009284 <dma_stm32_clear_tc> @ imm = #-0xff2c
; 	return 0;
 80191b0: 2300         	movs	r3, #0x0
; }
 80191b2: 4618         	mov	r0, r3
 80191b4: 3708         	adds	r7, #0x8
 80191b6: 46bd         	mov	sp, r7
 80191b8: bd80         	pop	{r7, pc}

080191ba <stm32_dma_disable_fifo_irq>:
; {
 80191ba: b580         	push	{r7, lr}
 80191bc: b082         	sub	sp, #0x8
 80191be: af00         	add	r7, sp, #0x0
 80191c0: 6078         	str	r0, [r7, #0x4]
 80191c2: 6039         	str	r1, [r7]
; 	LL_DMA_DisableIT_FE(dma, dma_stm32_id_to_stream(id));
 80191c4: 6838         	ldr	r0, [r7]
 80191c6: f7f0 f82b    	bl	0x8009220 <dma_stm32_id_to_stream> @ imm = #-0xffaa
 80191ca: 4603         	mov	r3, r0
 80191cc: 4619         	mov	r1, r3
 80191ce: 6878         	ldr	r0, [r7, #0x4]
 80191d0: f7ef ffb2    	bl	0x8009138 <LL_DMA_DisableIT_FE> @ imm = #-0x1009c
; }
 80191d4: bf00         	nop
 80191d6: 3708         	adds	r7, #0x8
 80191d8: 46bd         	mov	sp, r7
 80191da: bd80         	pop	{r7, pc}

080191dc <stm32_dma_check_fifo_mburst>:
; {
 80191dc: b480         	push	{r7}
 80191de: b087         	sub	sp, #0x1c
 80191e0: af00         	add	r7, sp, #0x0
 80191e2: 6078         	str	r0, [r7, #0x4]
; 	uint32_t msize = DMAx->MemoryOrM2MDstDataSize;
 80191e4: 687b         	ldr	r3, [r7, #0x4]
 80191e6: 69db         	ldr	r3, [r3, #0x1c]
 80191e8: 617b         	str	r3, [r7, #0x14]
; 	uint32_t fifo_level = DMAx->FIFOThreshold;
 80191ea: 687b         	ldr	r3, [r7, #0x4]
 80191ec: 6b1b         	ldr	r3, [r3, #0x30]
 80191ee: 613b         	str	r3, [r7, #0x10]
; 	uint32_t mburst = DMAx->MemBurst;
 80191f0: 687b         	ldr	r3, [r7, #0x4]
 80191f2: 6b5b         	ldr	r3, [r3, #0x34]
 80191f4: 60fb         	str	r3, [r7, #0xc]
; 	switch (msize) {
 80191f6: 697b         	ldr	r3, [r7, #0x14]
 80191f8: f5b3 4f80    	cmp.w	r3, #0x4000
 80191fc: d049         	beq	0x8019292 <stm32_dma_check_fifo_mburst+0xb6> @ imm = #0x92
 80191fe: 697b         	ldr	r3, [r7, #0x14]
 8019200: f5b3 4f80    	cmp.w	r3, #0x4000
 8019204: d84f         	bhi	0x80192a6 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x9e
 8019206: 697b         	ldr	r3, [r7, #0x14]
 8019208: 2b00         	cmp	r3, #0x0
 801920a: d004         	beq	0x8019216 <stm32_dma_check_fifo_mburst+0x3a> @ imm = #0x8
 801920c: 697b         	ldr	r3, [r7, #0x14]
 801920e: f5b3 5f00    	cmp.w	r3, #0x2000
 8019212: d024         	beq	0x801925e <stm32_dma_check_fifo_mburst+0x82> @ imm = #0x48
 8019214: e047         	b	0x80192a6 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x8e
 8019216: 68fb         	ldr	r3, [r7, #0xc]
 8019218: f1b3 7fc0    	cmp.w	r3, #0x1800000
 801921c: d016         	beq	0x801924c <stm32_dma_check_fifo_mburst+0x70> @ imm = #0x2c
 801921e: 68fb         	ldr	r3, [r7, #0xc]
 8019220: f1b3 7fc0    	cmp.w	r3, #0x1800000
 8019224: d83e         	bhi	0x80192a4 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x7c
 8019226: 68fb         	ldr	r3, [r7, #0xc]
 8019228: f5b3 0f00    	cmp.w	r3, #0x800000
 801922c: d004         	beq	0x8019238 <stm32_dma_check_fifo_mburst+0x5c> @ imm = #0x8
 801922e: 68fb         	ldr	r3, [r7, #0xc]
 8019230: f1b3 7f80    	cmp.w	r3, #0x1000000
 8019234: d002         	beq	0x801923c <stm32_dma_check_fifo_mburst+0x60> @ imm = #0x4
; 		break;
 8019236: e035         	b	0x80192a4 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x6a
; 			return true;
 8019238: 2301         	movs	r3, #0x1
 801923a: e035         	b	0x80192a8 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x6a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 801923c: 693b         	ldr	r3, [r7, #0x10]
 801923e: 2b01         	cmp	r3, #0x1
 8019240: d002         	beq	0x8019248 <stm32_dma_check_fifo_mburst+0x6c> @ imm = #0x4
 8019242: 693b         	ldr	r3, [r7, #0x10]
 8019244: 2b03         	cmp	r3, #0x3
 8019246: d106         	bne	0x8019256 <stm32_dma_check_fifo_mburst+0x7a> @ imm = #0xc
; 				return true;
 8019248: 2301         	movs	r3, #0x1
 801924a: e02d         	b	0x80192a8 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x5a
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 801924c: 693b         	ldr	r3, [r7, #0x10]
 801924e: 2b03         	cmp	r3, #0x3
 8019250: d103         	bne	0x801925a <stm32_dma_check_fifo_mburst+0x7e> @ imm = #0x6
; 				return true;
 8019252: 2301         	movs	r3, #0x1
 8019254: e028         	b	0x80192a8 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x50
; 			break;
 8019256: bf00         	nop
 8019258: e024         	b	0x80192a4 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x48
; 			break;
 801925a: bf00         	nop
; 		break;
 801925c: e022         	b	0x80192a4 <stm32_dma_check_fifo_mburst+0xc8> @ imm = #0x44
 801925e: 68fb         	ldr	r3, [r7, #0xc]
 8019260: f5b3 0f00    	cmp.w	r3, #0x800000
 8019264: d004         	beq	0x8019270 <stm32_dma_check_fifo_mburst+0x94> @ imm = #0x8
 8019266: 68fb         	ldr	r3, [r7, #0xc]
 8019268: f1b3 7f80    	cmp.w	r3, #0x1000000
 801926c: d008         	beq	0x8019280 <stm32_dma_check_fifo_mburst+0xa4> @ imm = #0x10
; 		break;
 801926e: e01a         	b	0x80192a6 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x34
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_1_2 ||
 8019270: 693b         	ldr	r3, [r7, #0x10]
 8019272: 2b01         	cmp	r3, #0x1
 8019274: d002         	beq	0x801927c <stm32_dma_check_fifo_mburst+0xa0> @ imm = #0x4
 8019276: 693b         	ldr	r3, [r7, #0x10]
 8019278: 2b03         	cmp	r3, #0x3
 801927a: d106         	bne	0x801928a <stm32_dma_check_fifo_mburst+0xae> @ imm = #0xc
; 				return true;
 801927c: 2301         	movs	r3, #0x1
 801927e: e013         	b	0x80192a8 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x26
; 			if (fifo_level == LL_DMA_FIFOTHRESHOLD_FULL) {
 8019280: 693b         	ldr	r3, [r7, #0x10]
 8019282: 2b03         	cmp	r3, #0x3
 8019284: d103         	bne	0x801928e <stm32_dma_check_fifo_mburst+0xb2> @ imm = #0x6
; 				return true;
 8019286: 2301         	movs	r3, #0x1
 8019288: e00e         	b	0x80192a8 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x1c
; 			break;
 801928a: bf00         	nop
 801928c: e00b         	b	0x80192a6 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x16
; 			break;
 801928e: bf00         	nop
; 		break;
 8019290: e009         	b	0x80192a6 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x12
; 		if (mburst == LL_DMA_MBURST_INC4 &&
 8019292: 68fb         	ldr	r3, [r7, #0xc]
 8019294: f5b3 0f00    	cmp.w	r3, #0x800000
 8019298: d105         	bne	0x80192a6 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0xa
 801929a: 693b         	ldr	r3, [r7, #0x10]
 801929c: 2b03         	cmp	r3, #0x3
 801929e: d102         	bne	0x80192a6 <stm32_dma_check_fifo_mburst+0xca> @ imm = #0x4
; 			return true;
 80192a0: 2301         	movs	r3, #0x1
 80192a2: e001         	b	0x80192a8 <stm32_dma_check_fifo_mburst+0xcc> @ imm = #0x2
; 		break;
 80192a4: bf00         	nop
; 	return false;
 80192a6: 2300         	movs	r3, #0x0
; }
 80192a8: 4618         	mov	r0, r3
 80192aa: 371c         	adds	r7, #0x1c
 80192ac: 46bd         	mov	sp, r7
 80192ae: f85d 7b04    	ldr	r7, [sp], #4
 80192b2: 4770         	bx	lr

080192b4 <z_snode_next_peek>:
; {
 80192b4: b480         	push	{r7}
 80192b6: b083         	sub	sp, #0xc
 80192b8: af00         	add	r7, sp, #0x0
 80192ba: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 80192bc: 687b         	ldr	r3, [r7, #0x4]
 80192be: 681b         	ldr	r3, [r3]
; }
 80192c0: 4618         	mov	r0, r3
 80192c2: 370c         	adds	r7, #0xc
 80192c4: 46bd         	mov	sp, r7
 80192c6: f85d 7b04    	ldr	r7, [sp], #4
 80192ca: 4770         	bx	lr

080192cc <z_snode_next_set>:
; {
 80192cc: b480         	push	{r7}
 80192ce: b083         	sub	sp, #0xc
 80192d0: af00         	add	r7, sp, #0x0
 80192d2: 6078         	str	r0, [r7, #0x4]
 80192d4: 6039         	str	r1, [r7]
; 	parent->next = child;
 80192d6: 687b         	ldr	r3, [r7, #0x4]
 80192d8: 683a         	ldr	r2, [r7]
 80192da: 601a         	str	r2, [r3]
; }
 80192dc: bf00         	nop
 80192de: 370c         	adds	r7, #0xc
 80192e0: 46bd         	mov	sp, r7
 80192e2: f85d 7b04    	ldr	r7, [sp], #4
 80192e6: 4770         	bx	lr

080192e8 <z_slist_head_set>:
; {
 80192e8: b480         	push	{r7}
 80192ea: b083         	sub	sp, #0xc
 80192ec: af00         	add	r7, sp, #0x0
 80192ee: 6078         	str	r0, [r7, #0x4]
 80192f0: 6039         	str	r1, [r7]
; 	list->head = node;
 80192f2: 687b         	ldr	r3, [r7, #0x4]
 80192f4: 683a         	ldr	r2, [r7]
 80192f6: 601a         	str	r2, [r3]
; }
 80192f8: bf00         	nop
 80192fa: 370c         	adds	r7, #0xc
 80192fc: 46bd         	mov	sp, r7
 80192fe: f85d 7b04    	ldr	r7, [sp], #4
 8019302: 4770         	bx	lr

08019304 <z_slist_tail_set>:
; {
 8019304: b480         	push	{r7}
 8019306: b083         	sub	sp, #0xc
 8019308: af00         	add	r7, sp, #0x0
 801930a: 6078         	str	r0, [r7, #0x4]
 801930c: 6039         	str	r1, [r7]
; 	list->tail = node;
 801930e: 687b         	ldr	r3, [r7, #0x4]
 8019310: 683a         	ldr	r2, [r7]
 8019312: 605a         	str	r2, [r3, #0x4]
; }
 8019314: bf00         	nop
 8019316: 370c         	adds	r7, #0xc
 8019318: 46bd         	mov	sp, r7
 801931a: f85d 7b04    	ldr	r7, [sp], #4
 801931e: 4770         	bx	lr

08019320 <sys_slist_peek_head>:
; {
 8019320: b480         	push	{r7}
 8019322: b083         	sub	sp, #0xc
 8019324: af00         	add	r7, sp, #0x0
 8019326: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 8019328: 687b         	ldr	r3, [r7, #0x4]
 801932a: 681b         	ldr	r3, [r3]
; }
 801932c: 4618         	mov	r0, r3
 801932e: 370c         	adds	r7, #0xc
 8019330: 46bd         	mov	sp, r7
 8019332: f85d 7b04    	ldr	r7, [sp], #4
 8019336: 4770         	bx	lr

08019338 <sys_slist_peek_tail>:
; {
 8019338: b480         	push	{r7}
 801933a: b083         	sub	sp, #0xc
 801933c: af00         	add	r7, sp, #0x0
 801933e: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 8019340: 687b         	ldr	r3, [r7, #0x4]
 8019342: 685b         	ldr	r3, [r3, #0x4]
; }
 8019344: 4618         	mov	r0, r3
 8019346: 370c         	adds	r7, #0xc
 8019348: 46bd         	mov	sp, r7
 801934a: f85d 7b04    	ldr	r7, [sp], #4
 801934e: 4770         	bx	lr

08019350 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 8019350: b580         	push	{r7, lr}
 8019352: b082         	sub	sp, #0x8
 8019354: af00         	add	r7, sp, #0x0
 8019356: 6078         	str	r0, [r7, #0x4]
 8019358: 6878         	ldr	r0, [r7, #0x4]
 801935a: f7ff ffe1    	bl	0x8019320 <sys_slist_peek_head> @ imm = #-0x3e
 801935e: 4603         	mov	r3, r0
 8019360: 2b00         	cmp	r3, #0x0
 8019362: bf0c         	ite	eq
 8019364: 2301         	moveq	r3, #0x1
 8019366: 2300         	movne	r3, #0x0
 8019368: b2db         	uxtb	r3, r3
 801936a: 4618         	mov	r0, r3
 801936c: 3708         	adds	r7, #0x8
 801936e: 46bd         	mov	sp, r7
 8019370: bd80         	pop	{r7, pc}

08019372 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8019372: b580         	push	{r7, lr}
 8019374: b082         	sub	sp, #0x8
 8019376: af00         	add	r7, sp, #0x0
 8019378: 6078         	str	r0, [r7, #0x4]
 801937a: 6878         	ldr	r0, [r7, #0x4]
 801937c: f7ff ff9a    	bl	0x80192b4 <z_snode_next_peek> @ imm = #-0xcc
 8019380: 4603         	mov	r3, r0
 8019382: 4618         	mov	r0, r3
 8019384: 3708         	adds	r7, #0x8
 8019386: 46bd         	mov	sp, r7
 8019388: bd80         	pop	{r7, pc}

0801938a <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801938a: b580         	push	{r7, lr}
 801938c: b082         	sub	sp, #0x8
 801938e: af00         	add	r7, sp, #0x0
 8019390: 6078         	str	r0, [r7, #0x4]
 8019392: 687b         	ldr	r3, [r7, #0x4]
 8019394: 2b00         	cmp	r3, #0x0
 8019396: d004         	beq	0x80193a2 <sys_slist_peek_next+0x18> @ imm = #0x8
 8019398: 6878         	ldr	r0, [r7, #0x4]
 801939a: f7ff ffea    	bl	0x8019372 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 801939e: 4603         	mov	r3, r0
 80193a0: e000         	b	0x80193a4 <sys_slist_peek_next+0x1a> @ imm = #0x0
 80193a2: 2300         	movs	r3, #0x0
 80193a4: 4618         	mov	r0, r3
 80193a6: 3708         	adds	r7, #0x8
 80193a8: 46bd         	mov	sp, r7
 80193aa: bd80         	pop	{r7, pc}

080193ac <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 80193ac: b580         	push	{r7, lr}
 80193ae: b082         	sub	sp, #0x8
 80193b0: af00         	add	r7, sp, #0x0
 80193b2: 6078         	str	r0, [r7, #0x4]
 80193b4: 6039         	str	r1, [r7]
 80193b6: 6878         	ldr	r0, [r7, #0x4]
 80193b8: f7ff ffb2    	bl	0x8019320 <sys_slist_peek_head> @ imm = #-0x9c
 80193bc: 4603         	mov	r3, r0
 80193be: 4619         	mov	r1, r3
 80193c0: 6838         	ldr	r0, [r7]
 80193c2: f7ff ff83    	bl	0x80192cc <z_snode_next_set> @ imm = #-0xfa
 80193c6: 6839         	ldr	r1, [r7]
 80193c8: 6878         	ldr	r0, [r7, #0x4]
 80193ca: f7ff ff8d    	bl	0x80192e8 <z_slist_head_set> @ imm = #-0xe6
 80193ce: 6878         	ldr	r0, [r7, #0x4]
 80193d0: f7ff ffb2    	bl	0x8019338 <sys_slist_peek_tail> @ imm = #-0x9c
 80193d4: 4603         	mov	r3, r0
 80193d6: 2b00         	cmp	r3, #0x0
 80193d8: d107         	bne	0x80193ea <sys_slist_prepend+0x3e> @ imm = #0xe
 80193da: 6878         	ldr	r0, [r7, #0x4]
 80193dc: f7ff ffa0    	bl	0x8019320 <sys_slist_peek_head> @ imm = #-0xc0
 80193e0: 4603         	mov	r3, r0
 80193e2: 4619         	mov	r1, r3
 80193e4: 6878         	ldr	r0, [r7, #0x4]
 80193e6: f7ff ff8d    	bl	0x8019304 <z_slist_tail_set> @ imm = #-0xe6
 80193ea: 3708         	adds	r7, #0x8
 80193ec: 46bd         	mov	sp, r7
 80193ee: bd80         	pop	{r7, pc}

080193f0 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 80193f0: b580         	push	{r7, lr}
 80193f2: b084         	sub	sp, #0x10
 80193f4: af00         	add	r7, sp, #0x0
 80193f6: 60f8         	str	r0, [r7, #0xc]
 80193f8: 60b9         	str	r1, [r7, #0x8]
 80193fa: 607a         	str	r2, [r7, #0x4]
 80193fc: 68bb         	ldr	r3, [r7, #0x8]
 80193fe: 2b00         	cmp	r3, #0x0
 8019400: d117         	bne	0x8019432 <sys_slist_remove+0x42> @ imm = #0x2e
 8019402: 6878         	ldr	r0, [r7, #0x4]
 8019404: f7ff ff56    	bl	0x80192b4 <z_snode_next_peek> @ imm = #-0x154
 8019408: 4603         	mov	r3, r0
 801940a: 4619         	mov	r1, r3
 801940c: 68f8         	ldr	r0, [r7, #0xc]
 801940e: f7ff ff6b    	bl	0x80192e8 <z_slist_head_set> @ imm = #-0x12a
 8019412: 68f8         	ldr	r0, [r7, #0xc]
 8019414: f7ff ff90    	bl	0x8019338 <sys_slist_peek_tail> @ imm = #-0xe0
 8019418: 4602         	mov	r2, r0
 801941a: 687b         	ldr	r3, [r7, #0x4]
 801941c: 4293         	cmp	r3, r2
 801941e: d11b         	bne	0x8019458 <sys_slist_remove+0x68> @ imm = #0x36
 8019420: 68f8         	ldr	r0, [r7, #0xc]
 8019422: f7ff ff7d    	bl	0x8019320 <sys_slist_peek_head> @ imm = #-0x106
 8019426: 4603         	mov	r3, r0
 8019428: 4619         	mov	r1, r3
 801942a: 68f8         	ldr	r0, [r7, #0xc]
 801942c: f7ff ff6a    	bl	0x8019304 <z_slist_tail_set> @ imm = #-0x12c
 8019430: e012         	b	0x8019458 <sys_slist_remove+0x68> @ imm = #0x24
 8019432: 6878         	ldr	r0, [r7, #0x4]
 8019434: f7ff ff3e    	bl	0x80192b4 <z_snode_next_peek> @ imm = #-0x184
 8019438: 4603         	mov	r3, r0
 801943a: 4619         	mov	r1, r3
 801943c: 68b8         	ldr	r0, [r7, #0x8]
 801943e: f7ff ff45    	bl	0x80192cc <z_snode_next_set> @ imm = #-0x176
 8019442: 68f8         	ldr	r0, [r7, #0xc]
 8019444: f7ff ff78    	bl	0x8019338 <sys_slist_peek_tail> @ imm = #-0x110
 8019448: 4602         	mov	r2, r0
 801944a: 687b         	ldr	r3, [r7, #0x4]
 801944c: 4293         	cmp	r3, r2
 801944e: d103         	bne	0x8019458 <sys_slist_remove+0x68> @ imm = #0x6
 8019450: 68b9         	ldr	r1, [r7, #0x8]
 8019452: 68f8         	ldr	r0, [r7, #0xc]
 8019454: f7ff ff56    	bl	0x8019304 <z_slist_tail_set> @ imm = #-0x154
 8019458: 2100         	movs	r1, #0x0
 801945a: 6878         	ldr	r0, [r7, #0x4]
 801945c: f7ff ff36    	bl	0x80192cc <z_snode_next_set> @ imm = #-0x194
 8019460: 3710         	adds	r7, #0x10
 8019462: 46bd         	mov	sp, r7
 8019464: bd80         	pop	{r7, pc}

08019466 <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8019466: b580         	push	{r7, lr}
 8019468: b084         	sub	sp, #0x10
 801946a: af00         	add	r7, sp, #0x0
 801946c: 6078         	str	r0, [r7, #0x4]
 801946e: 6039         	str	r1, [r7]
 8019470: 2300         	movs	r3, #0x0
 8019472: 60fb         	str	r3, [r7, #0xc]
 8019474: 6878         	ldr	r0, [r7, #0x4]
 8019476: f7ff ff53    	bl	0x8019320 <sys_slist_peek_head> @ imm = #-0x15a
 801947a: 60b8         	str	r0, [r7, #0x8]
 801947c: e010         	b	0x80194a0 <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 801947e: 68ba         	ldr	r2, [r7, #0x8]
 8019480: 683b         	ldr	r3, [r7]
 8019482: 429a         	cmp	r2, r3
 8019484: d106         	bne	0x8019494 <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 8019486: 683a         	ldr	r2, [r7]
 8019488: 68f9         	ldr	r1, [r7, #0xc]
 801948a: 6878         	ldr	r0, [r7, #0x4]
 801948c: f7ff ffb0    	bl	0x80193f0 <sys_slist_remove> @ imm = #-0xa0
 8019490: 2301         	movs	r3, #0x1
 8019492: e009         	b	0x80194a8 <sys_slist_find_and_remove+0x42> @ imm = #0x12
 8019494: 68bb         	ldr	r3, [r7, #0x8]
 8019496: 60fb         	str	r3, [r7, #0xc]
 8019498: 68b8         	ldr	r0, [r7, #0x8]
 801949a: f7ff ff76    	bl	0x801938a <sys_slist_peek_next> @ imm = #-0x114
 801949e: 60b8         	str	r0, [r7, #0x8]
 80194a0: 68bb         	ldr	r3, [r7, #0x8]
 80194a2: 2b00         	cmp	r3, #0x0
 80194a4: d1eb         	bne	0x801947e <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 80194a6: 2300         	movs	r3, #0x0
 80194a8: 4618         	mov	r0, r3
 80194aa: 3710         	adds	r7, #0x10
 80194ac: 46bd         	mov	sp, r7
 80194ae: bd80         	pop	{r7, pc}

080194b0 <device_is_ready>:
; {
 80194b0: b580         	push	{r7, lr}
 80194b2: b082         	sub	sp, #0x8
 80194b4: af00         	add	r7, sp, #0x0
 80194b6: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 80194b8: 6878         	ldr	r0, [r7, #0x4]
 80194ba: f004 fd89    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x4b12
 80194be: 4603         	mov	r3, r0
; }
 80194c0: 4618         	mov	r0, r3
 80194c2: 3708         	adds	r7, #0x8
 80194c4: 46bd         	mov	sp, r7
 80194c6: bd80         	pop	{r7, pc}

080194c8 <LL_GPIO_SetPinMode>:
; {
 80194c8: b480         	push	{r7}
 80194ca: b08b         	sub	sp, #0x2c
 80194cc: af00         	add	r7, sp, #0x0
 80194ce: 60f8         	str	r0, [r7, #0xc]
 80194d0: 60b9         	str	r1, [r7, #0x8]
 80194d2: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 80194d4: 68fb         	ldr	r3, [r7, #0xc]
 80194d6: 681a         	ldr	r2, [r3]
 80194d8: 68bb         	ldr	r3, [r7, #0x8]
 80194da: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80194dc: 697b         	ldr	r3, [r7, #0x14]
 80194de: fa93 f3a3    	rbit	r3, r3
 80194e2: 613b         	str	r3, [r7, #0x10]
;   return result;
 80194e4: 693b         	ldr	r3, [r7, #0x10]
 80194e6: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 80194e8: 69bb         	ldr	r3, [r7, #0x18]
 80194ea: 2b00         	cmp	r3, #0x0
 80194ec: d101         	bne	0x80194f2 <LL_GPIO_SetPinMode+0x2a> @ imm = #0x2
;     return 32U;
 80194ee: 2320         	movs	r3, #0x20
 80194f0: e003         	b	0x80194fa <LL_GPIO_SetPinMode+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 80194f2: 69bb         	ldr	r3, [r7, #0x18]
 80194f4: fab3 f383    	clz	r3, r3
 80194f8: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 80194fa: 005b         	lsls	r3, r3, #0x1
 80194fc: 2103         	movs	r1, #0x3
 80194fe: fa01 f303    	lsl.w	r3, r1, r3
 8019502: 43db         	mvns	r3, r3
 8019504: 401a         	ands	r2, r3
 8019506: 68bb         	ldr	r3, [r7, #0x8]
 8019508: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801950a: 6a3b         	ldr	r3, [r7, #0x20]
 801950c: fa93 f3a3    	rbit	r3, r3
 8019510: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 8019512: 69fb         	ldr	r3, [r7, #0x1c]
 8019514: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 8019516: 6a7b         	ldr	r3, [r7, #0x24]
 8019518: 2b00         	cmp	r3, #0x0
 801951a: d101         	bne	0x8019520 <LL_GPIO_SetPinMode+0x58> @ imm = #0x2
;     return 32U;
 801951c: 2320         	movs	r3, #0x20
 801951e: e003         	b	0x8019528 <LL_GPIO_SetPinMode+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 8019520: 6a7b         	ldr	r3, [r7, #0x24]
 8019522: fab3 f383    	clz	r3, r3
 8019526: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8019528: 005b         	lsls	r3, r3, #0x1
 801952a: 6879         	ldr	r1, [r7, #0x4]
 801952c: fa01 f303    	lsl.w	r3, r1, r3
 8019530: 431a         	orrs	r2, r3
 8019532: 68fb         	ldr	r3, [r7, #0xc]
 8019534: 601a         	str	r2, [r3]
; }
 8019536: bf00         	nop
 8019538: 372c         	adds	r7, #0x2c
 801953a: 46bd         	mov	sp, r7
 801953c: f85d 7b04    	ldr	r7, [sp], #4
 8019540: 4770         	bx	lr

08019542 <LL_GPIO_SetPinOutputType>:
; {
 8019542: b480         	push	{r7}
 8019544: b085         	sub	sp, #0x14
 8019546: af00         	add	r7, sp, #0x0
 8019548: 60f8         	str	r0, [r7, #0xc]
 801954a: 60b9         	str	r1, [r7, #0x8]
 801954c: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 801954e: 68fb         	ldr	r3, [r7, #0xc]
 8019550: 685a         	ldr	r2, [r3, #0x4]
 8019552: 68bb         	ldr	r3, [r7, #0x8]
 8019554: 43db         	mvns	r3, r3
 8019556: 401a         	ands	r2, r3
 8019558: 68bb         	ldr	r3, [r7, #0x8]
 801955a: 6879         	ldr	r1, [r7, #0x4]
 801955c: fb01 f303    	mul	r3, r1, r3
 8019560: 431a         	orrs	r2, r3
 8019562: 68fb         	ldr	r3, [r7, #0xc]
 8019564: 605a         	str	r2, [r3, #0x4]
; }
 8019566: bf00         	nop
 8019568: 3714         	adds	r7, #0x14
 801956a: 46bd         	mov	sp, r7
 801956c: f85d 7b04    	ldr	r7, [sp], #4
 8019570: 4770         	bx	lr

08019572 <LL_GPIO_SetPinSpeed>:
; {
 8019572: b480         	push	{r7}
 8019574: b08b         	sub	sp, #0x2c
 8019576: af00         	add	r7, sp, #0x0
 8019578: 60f8         	str	r0, [r7, #0xc]
 801957a: 60b9         	str	r1, [r7, #0x8]
 801957c: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 801957e: 68fb         	ldr	r3, [r7, #0xc]
 8019580: 689a         	ldr	r2, [r3, #0x8]
 8019582: 68bb         	ldr	r3, [r7, #0x8]
 8019584: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8019586: 697b         	ldr	r3, [r7, #0x14]
 8019588: fa93 f3a3    	rbit	r3, r3
 801958c: 613b         	str	r3, [r7, #0x10]
;   return result;
 801958e: 693b         	ldr	r3, [r7, #0x10]
 8019590: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8019592: 69bb         	ldr	r3, [r7, #0x18]
 8019594: 2b00         	cmp	r3, #0x0
 8019596: d101         	bne	0x801959c <LL_GPIO_SetPinSpeed+0x2a> @ imm = #0x2
;     return 32U;
 8019598: 2320         	movs	r3, #0x20
 801959a: e003         	b	0x80195a4 <LL_GPIO_SetPinSpeed+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 801959c: 69bb         	ldr	r3, [r7, #0x18]
 801959e: fab3 f383    	clz	r3, r3
 80195a2: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 80195a4: 005b         	lsls	r3, r3, #0x1
 80195a6: 2103         	movs	r1, #0x3
 80195a8: fa01 f303    	lsl.w	r3, r1, r3
 80195ac: 43db         	mvns	r3, r3
 80195ae: 401a         	ands	r2, r3
 80195b0: 68bb         	ldr	r3, [r7, #0x8]
 80195b2: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80195b4: 6a3b         	ldr	r3, [r7, #0x20]
 80195b6: fa93 f3a3    	rbit	r3, r3
 80195ba: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 80195bc: 69fb         	ldr	r3, [r7, #0x1c]
 80195be: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 80195c0: 6a7b         	ldr	r3, [r7, #0x24]
 80195c2: 2b00         	cmp	r3, #0x0
 80195c4: d101         	bne	0x80195ca <LL_GPIO_SetPinSpeed+0x58> @ imm = #0x2
;     return 32U;
 80195c6: 2320         	movs	r3, #0x20
 80195c8: e003         	b	0x80195d2 <LL_GPIO_SetPinSpeed+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 80195ca: 6a7b         	ldr	r3, [r7, #0x24]
 80195cc: fab3 f383    	clz	r3, r3
 80195d0: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 80195d2: 005b         	lsls	r3, r3, #0x1
 80195d4: 6879         	ldr	r1, [r7, #0x4]
 80195d6: fa01 f303    	lsl.w	r3, r1, r3
 80195da: 431a         	orrs	r2, r3
 80195dc: 68fb         	ldr	r3, [r7, #0xc]
 80195de: 609a         	str	r2, [r3, #0x8]
; }
 80195e0: bf00         	nop
 80195e2: 372c         	adds	r7, #0x2c
 80195e4: 46bd         	mov	sp, r7
 80195e6: f85d 7b04    	ldr	r7, [sp], #4
 80195ea: 4770         	bx	lr

080195ec <LL_GPIO_SetPinPull>:
; {
 80195ec: b480         	push	{r7}
 80195ee: b08b         	sub	sp, #0x2c
 80195f0: af00         	add	r7, sp, #0x0
 80195f2: 60f8         	str	r0, [r7, #0xc]
 80195f4: 60b9         	str	r1, [r7, #0x8]
 80195f6: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 80195f8: 68fb         	ldr	r3, [r7, #0xc]
 80195fa: 68da         	ldr	r2, [r3, #0xc]
 80195fc: 68bb         	ldr	r3, [r7, #0x8]
 80195fe: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8019600: 697b         	ldr	r3, [r7, #0x14]
 8019602: fa93 f3a3    	rbit	r3, r3
 8019606: 613b         	str	r3, [r7, #0x10]
;   return result;
 8019608: 693b         	ldr	r3, [r7, #0x10]
 801960a: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 801960c: 69bb         	ldr	r3, [r7, #0x18]
 801960e: 2b00         	cmp	r3, #0x0
 8019610: d101         	bne	0x8019616 <LL_GPIO_SetPinPull+0x2a> @ imm = #0x2
;     return 32U;
 8019612: 2320         	movs	r3, #0x20
 8019614: e003         	b	0x801961e <LL_GPIO_SetPinPull+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 8019616: 69bb         	ldr	r3, [r7, #0x18]
 8019618: fab3 f383    	clz	r3, r3
 801961c: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 801961e: 005b         	lsls	r3, r3, #0x1
 8019620: 2103         	movs	r1, #0x3
 8019622: fa01 f303    	lsl.w	r3, r1, r3
 8019626: 43db         	mvns	r3, r3
 8019628: 401a         	ands	r2, r3
 801962a: 68bb         	ldr	r3, [r7, #0x8]
 801962c: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801962e: 6a3b         	ldr	r3, [r7, #0x20]
 8019630: fa93 f3a3    	rbit	r3, r3
 8019634: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 8019636: 69fb         	ldr	r3, [r7, #0x1c]
 8019638: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801963a: 6a7b         	ldr	r3, [r7, #0x24]
 801963c: 2b00         	cmp	r3, #0x0
 801963e: d101         	bne	0x8019644 <LL_GPIO_SetPinPull+0x58> @ imm = #0x2
;     return 32U;
 8019640: 2320         	movs	r3, #0x20
 8019642: e003         	b	0x801964c <LL_GPIO_SetPinPull+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 8019644: 6a7b         	ldr	r3, [r7, #0x24]
 8019646: fab3 f383    	clz	r3, r3
 801964a: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 801964c: 005b         	lsls	r3, r3, #0x1
 801964e: 6879         	ldr	r1, [r7, #0x4]
 8019650: fa01 f303    	lsl.w	r3, r1, r3
 8019654: 431a         	orrs	r2, r3
 8019656: 68fb         	ldr	r3, [r7, #0xc]
 8019658: 60da         	str	r2, [r3, #0xc]
; }
 801965a: bf00         	nop
 801965c: 372c         	adds	r7, #0x2c
 801965e: 46bd         	mov	sp, r7
 8019660: f85d 7b04    	ldr	r7, [sp], #4
 8019664: 4770         	bx	lr

08019666 <LL_GPIO_SetAFPin_0_7>:
; {
 8019666: b480         	push	{r7}
 8019668: b08b         	sub	sp, #0x2c
 801966a: af00         	add	r7, sp, #0x0
 801966c: 60f8         	str	r0, [r7, #0xc]
 801966e: 60b9         	str	r1, [r7, #0x8]
 8019670: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8019672: 68fb         	ldr	r3, [r7, #0xc]
 8019674: 6a1a         	ldr	r2, [r3, #0x20]
 8019676: 68bb         	ldr	r3, [r7, #0x8]
 8019678: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801967a: 697b         	ldr	r3, [r7, #0x14]
 801967c: fa93 f3a3    	rbit	r3, r3
 8019680: 613b         	str	r3, [r7, #0x10]
;   return result;
 8019682: 693b         	ldr	r3, [r7, #0x10]
 8019684: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8019686: 69bb         	ldr	r3, [r7, #0x18]
 8019688: 2b00         	cmp	r3, #0x0
 801968a: d101         	bne	0x8019690 <LL_GPIO_SetAFPin_0_7+0x2a> @ imm = #0x2
;     return 32U;
 801968c: 2320         	movs	r3, #0x20
 801968e: e003         	b	0x8019698 <LL_GPIO_SetAFPin_0_7+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 8019690: 69bb         	ldr	r3, [r7, #0x18]
 8019692: fab3 f383    	clz	r3, r3
 8019696: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8019698: 009b         	lsls	r3, r3, #0x2
 801969a: 210f         	movs	r1, #0xf
 801969c: fa01 f303    	lsl.w	r3, r1, r3
 80196a0: 43db         	mvns	r3, r3
 80196a2: 401a         	ands	r2, r3
 80196a4: 68bb         	ldr	r3, [r7, #0x8]
 80196a6: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80196a8: 6a3b         	ldr	r3, [r7, #0x20]
 80196aa: fa93 f3a3    	rbit	r3, r3
 80196ae: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 80196b0: 69fb         	ldr	r3, [r7, #0x1c]
 80196b2: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 80196b4: 6a7b         	ldr	r3, [r7, #0x24]
 80196b6: 2b00         	cmp	r3, #0x0
 80196b8: d101         	bne	0x80196be <LL_GPIO_SetAFPin_0_7+0x58> @ imm = #0x2
;     return 32U;
 80196ba: 2320         	movs	r3, #0x20
 80196bc: e003         	b	0x80196c6 <LL_GPIO_SetAFPin_0_7+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 80196be: 6a7b         	ldr	r3, [r7, #0x24]
 80196c0: fab3 f383    	clz	r3, r3
 80196c4: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 80196c6: 009b         	lsls	r3, r3, #0x2
 80196c8: 6879         	ldr	r1, [r7, #0x4]
 80196ca: fa01 f303    	lsl.w	r3, r1, r3
 80196ce: 431a         	orrs	r2, r3
 80196d0: 68fb         	ldr	r3, [r7, #0xc]
 80196d2: 621a         	str	r2, [r3, #0x20]
; }
 80196d4: bf00         	nop
 80196d6: 372c         	adds	r7, #0x2c
 80196d8: 46bd         	mov	sp, r7
 80196da: f85d 7b04    	ldr	r7, [sp], #4
 80196de: 4770         	bx	lr

080196e0 <LL_GPIO_SetAFPin_8_15>:
; {
 80196e0: b480         	push	{r7}
 80196e2: b08b         	sub	sp, #0x2c
 80196e4: af00         	add	r7, sp, #0x0
 80196e6: 60f8         	str	r0, [r7, #0xc]
 80196e8: 60b9         	str	r1, [r7, #0x8]
 80196ea: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 80196ec: 68fb         	ldr	r3, [r7, #0xc]
 80196ee: 6a5a         	ldr	r2, [r3, #0x24]
 80196f0: 68bb         	ldr	r3, [r7, #0x8]
 80196f2: 0a1b         	lsrs	r3, r3, #0x8
 80196f4: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80196f6: 697b         	ldr	r3, [r7, #0x14]
 80196f8: fa93 f3a3    	rbit	r3, r3
 80196fc: 613b         	str	r3, [r7, #0x10]
;   return result;
 80196fe: 693b         	ldr	r3, [r7, #0x10]
 8019700: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8019702: 69bb         	ldr	r3, [r7, #0x18]
 8019704: 2b00         	cmp	r3, #0x0
 8019706: d101         	bne	0x801970c <LL_GPIO_SetAFPin_8_15+0x2c> @ imm = #0x2
;     return 32U;
 8019708: 2320         	movs	r3, #0x20
 801970a: e003         	b	0x8019714 <LL_GPIO_SetAFPin_8_15+0x34> @ imm = #0x6
;   return __builtin_clz(value);
 801970c: 69bb         	ldr	r3, [r7, #0x18]
 801970e: fab3 f383    	clz	r3, r3
 8019712: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8019714: 009b         	lsls	r3, r3, #0x2
 8019716: 210f         	movs	r1, #0xf
 8019718: fa01 f303    	lsl.w	r3, r1, r3
 801971c: 43db         	mvns	r3, r3
 801971e: 401a         	ands	r2, r3
 8019720: 68bb         	ldr	r3, [r7, #0x8]
 8019722: 0a1b         	lsrs	r3, r3, #0x8
 8019724: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8019726: 6a3b         	ldr	r3, [r7, #0x20]
 8019728: fa93 f3a3    	rbit	r3, r3
 801972c: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 801972e: 69fb         	ldr	r3, [r7, #0x1c]
 8019730: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 8019732: 6a7b         	ldr	r3, [r7, #0x24]
 8019734: 2b00         	cmp	r3, #0x0
 8019736: d101         	bne	0x801973c <LL_GPIO_SetAFPin_8_15+0x5c> @ imm = #0x2
;     return 32U;
 8019738: 2320         	movs	r3, #0x20
 801973a: e003         	b	0x8019744 <LL_GPIO_SetAFPin_8_15+0x64> @ imm = #0x6
;   return __builtin_clz(value);
 801973c: 6a7b         	ldr	r3, [r7, #0x24]
 801973e: fab3 f383    	clz	r3, r3
 8019742: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8019744: 009b         	lsls	r3, r3, #0x2
 8019746: 6879         	ldr	r1, [r7, #0x4]
 8019748: fa01 f303    	lsl.w	r3, r1, r3
 801974c: 431a         	orrs	r2, r3
 801974e: 68fb         	ldr	r3, [r7, #0xc]
 8019750: 625a         	str	r2, [r3, #0x24]
; }
 8019752: bf00         	nop
 8019754: 372c         	adds	r7, #0x2c
 8019756: 46bd         	mov	sp, r7
 8019758: f85d 7b04    	ldr	r7, [sp], #4
 801975c: 4770         	bx	lr

0801975e <LL_GPIO_ReadInputPort>:
; {
 801975e: b480         	push	{r7}
 8019760: b083         	sub	sp, #0xc
 8019762: af00         	add	r7, sp, #0x0
 8019764: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->IDR));
 8019766: 687b         	ldr	r3, [r7, #0x4]
 8019768: 691b         	ldr	r3, [r3, #0x10]
; }
 801976a: 4618         	mov	r0, r3
 801976c: 370c         	adds	r7, #0xc
 801976e: 46bd         	mov	sp, r7
 8019770: f85d 7b04    	ldr	r7, [sp], #4
 8019774: 4770         	bx	lr

08019776 <LL_GPIO_WriteOutputPort>:
; {
 8019776: b480         	push	{r7}
 8019778: b083         	sub	sp, #0xc
 801977a: af00         	add	r7, sp, #0x0
 801977c: 6078         	str	r0, [r7, #0x4]
 801977e: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->ODR, PortValue);
 8019780: 687b         	ldr	r3, [r7, #0x4]
 8019782: 683a         	ldr	r2, [r7]
 8019784: 615a         	str	r2, [r3, #0x14]
; }
 8019786: bf00         	nop
 8019788: 370c         	adds	r7, #0xc
 801978a: 46bd         	mov	sp, r7
 801978c: f85d 7b04    	ldr	r7, [sp], #4
 8019790: 4770         	bx	lr

08019792 <LL_GPIO_ReadOutputPort>:
; {
 8019792: b480         	push	{r7}
 8019794: b083         	sub	sp, #0xc
 8019796: af00         	add	r7, sp, #0x0
 8019798: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->ODR));
 801979a: 687b         	ldr	r3, [r7, #0x4]
 801979c: 695b         	ldr	r3, [r3, #0x14]
; }
 801979e: 4618         	mov	r0, r3
 80197a0: 370c         	adds	r7, #0xc
 80197a2: 46bd         	mov	sp, r7
 80197a4: f85d 7b04    	ldr	r7, [sp], #4
 80197a8: 4770         	bx	lr

080197aa <LL_GPIO_ResetOutputPin>:
; {
 80197aa: b480         	push	{r7}
 80197ac: b083         	sub	sp, #0xc
 80197ae: af00         	add	r7, sp, #0x0
 80197b0: 6078         	str	r0, [r7, #0x4]
 80197b2: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->BSRR, (PinMask << 16));
 80197b4: 683b         	ldr	r3, [r7]
 80197b6: 041a         	lsls	r2, r3, #0x10
 80197b8: 687b         	ldr	r3, [r7, #0x4]
 80197ba: 619a         	str	r2, [r3, #0x18]
; }
 80197bc: bf00         	nop
 80197be: 370c         	adds	r7, #0xc
 80197c0: 46bd         	mov	sp, r7
 80197c2: f85d 7b04    	ldr	r7, [sp], #4
 80197c6: 4770         	bx	lr

080197c8 <clock_control_on>:
; {
 80197c8: b580         	push	{r7, lr}
 80197ca: b084         	sub	sp, #0x10
 80197cc: af00         	add	r7, sp, #0x0
 80197ce: 6078         	str	r0, [r7, #0x4]
 80197d0: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 80197d2: 687b         	ldr	r3, [r7, #0x4]
 80197d4: 689b         	ldr	r3, [r3, #0x8]
 80197d6: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 80197d8: 68fb         	ldr	r3, [r7, #0xc]
 80197da: 681b         	ldr	r3, [r3]
 80197dc: 6839         	ldr	r1, [r7]
 80197de: 6878         	ldr	r0, [r7, #0x4]
 80197e0: 4798         	blx	r3
 80197e2: 4603         	mov	r3, r0
; }
 80197e4: 4618         	mov	r0, r3
 80197e6: 3710         	adds	r7, #0x10
 80197e8: 46bd         	mov	sp, r7
 80197ea: bd80         	pop	{r7, pc}

080197ec <clock_control_off>:
; {
 80197ec: b580         	push	{r7, lr}
 80197ee: b084         	sub	sp, #0x10
 80197f0: af00         	add	r7, sp, #0x0
 80197f2: 6078         	str	r0, [r7, #0x4]
 80197f4: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 80197f6: 687b         	ldr	r3, [r7, #0x4]
 80197f8: 689b         	ldr	r3, [r3, #0x8]
 80197fa: 60fb         	str	r3, [r7, #0xc]
; 	return api->off(dev, sys);
 80197fc: 68fb         	ldr	r3, [r7, #0xc]
 80197fe: 685b         	ldr	r3, [r3, #0x4]
 8019800: 6839         	ldr	r1, [r7]
 8019802: 6878         	ldr	r0, [r7, #0x4]
 8019804: 4798         	blx	r3
 8019806: 4603         	mov	r3, r0
; }
 8019808: 4618         	mov	r0, r3
 801980a: 3710         	adds	r7, #0x10
 801980c: 46bd         	mov	sp, r7
 801980e: bd80         	pop	{r7, pc}

08019810 <pm_device_runtime_enable>:
; {
 8019810: b480         	push	{r7}
 8019812: b083         	sub	sp, #0xc
 8019814: af00         	add	r7, sp, #0x0
 8019816: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8019818: 2300         	movs	r3, #0x0
; }
 801981a: 4618         	mov	r0, r3
 801981c: 370c         	adds	r7, #0xc
 801981e: 46bd         	mov	sp, r7
 8019820: f85d 7b04    	ldr	r7, [sp], #4
 8019824: 4770         	bx	lr

08019826 <pm_device_runtime_get>:
; {
 8019826: b480         	push	{r7}
 8019828: b083         	sub	sp, #0xc
 801982a: af00         	add	r7, sp, #0x0
 801982c: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801982e: 2300         	movs	r3, #0x0
; }
 8019830: 4618         	mov	r0, r3
 8019832: 370c         	adds	r7, #0xc
 8019834: 46bd         	mov	sp, r7
 8019836: f85d 7b04    	ldr	r7, [sp], #4
 801983a: 4770         	bx	lr

0801983c <pm_device_runtime_put>:
; {
 801983c: b480         	push	{r7}
 801983e: b083         	sub	sp, #0xc
 8019840: af00         	add	r7, sp, #0x0
 8019842: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8019844: 2300         	movs	r3, #0x0
; }
 8019846: 4618         	mov	r0, r3
 8019848: 370c         	adds	r7, #0xc
 801984a: 46bd         	mov	sp, r7
 801984c: f85d 7b04    	ldr	r7, [sp], #4
 8019850: 4770         	bx	lr

08019852 <z_stm32_hsem_lock>:
; {
 8019852: b480         	push	{r7}
 8019854: b083         	sub	sp, #0xc
 8019856: af00         	add	r7, sp, #0x0
 8019858: 6078         	str	r0, [r7, #0x4]
 801985a: 6039         	str	r1, [r7]
; }
 801985c: bf00         	nop
 801985e: 370c         	adds	r7, #0xc
 8019860: 46bd         	mov	sp, r7
 8019862: f85d 7b04    	ldr	r7, [sp], #4
 8019866: 4770         	bx	lr

08019868 <z_stm32_hsem_unlock>:
; {
 8019868: b480         	push	{r7}
 801986a: b083         	sub	sp, #0xc
 801986c: af00         	add	r7, sp, #0x0
 801986e: 6078         	str	r0, [r7, #0x4]
; }
 8019870: bf00         	nop
 8019872: 370c         	adds	r7, #0xc
 8019874: 46bd         	mov	sp, r7
 8019876: f85d 7b04    	ldr	r7, [sp], #4
 801987a: 4770         	bx	lr

0801987c <gpio_manage_callback>:
; {
 801987c: b580         	push	{r7, lr}
 801987e: b084         	sub	sp, #0x10
 8019880: af00         	add	r7, sp, #0x0
 8019882: 60f8         	str	r0, [r7, #0xc]
 8019884: 60b9         	str	r1, [r7, #0x8]
 8019886: 4613         	mov	r3, r2
 8019888: 71fb         	strb	r3, [r7, #0x7]
; 	if (!sys_slist_is_empty(callbacks)) {
 801988a: 68f8         	ldr	r0, [r7, #0xc]
 801988c: f7ff fd60    	bl	0x8019350 <sys_slist_is_empty> @ imm = #-0x540
 8019890: 4603         	mov	r3, r0
 8019892: f083 0301    	eor	r3, r3, #0x1
 8019896: b2db         	uxtb	r3, r3
 8019898: 2b00         	cmp	r3, #0x0
 801989a: d013         	beq	0x80198c4 <gpio_manage_callback+0x48> @ imm = #0x26
; 		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
 801989c: 68bb         	ldr	r3, [r7, #0x8]
 801989e: 4619         	mov	r1, r3
 80198a0: 68f8         	ldr	r0, [r7, #0xc]
 80198a2: f7ff fde0    	bl	0x8019466 <sys_slist_find_and_remove> @ imm = #-0x440
 80198a6: 4603         	mov	r3, r0
 80198a8: f083 0301    	eor	r3, r3, #0x1
 80198ac: b2db         	uxtb	r3, r3
 80198ae: 2b00         	cmp	r3, #0x0
 80198b0: d011         	beq	0x80198d6 <gpio_manage_callback+0x5a> @ imm = #0x22
; 			if (!set) {
 80198b2: 79fb         	ldrb	r3, [r7, #0x7]
 80198b4: f083 0301    	eor	r3, r3, #0x1
 80198b8: b2db         	uxtb	r3, r3
 80198ba: 2b00         	cmp	r3, #0x0
 80198bc: d00b         	beq	0x80198d6 <gpio_manage_callback+0x5a> @ imm = #0x16
; 				return -EINVAL;
 80198be: f06f 0315    	mvn	r3, #0x15
 80198c2: e011         	b	0x80198e8 <gpio_manage_callback+0x6c> @ imm = #0x22
; 	} else if (!set) {
 80198c4: 79fb         	ldrb	r3, [r7, #0x7]
 80198c6: f083 0301    	eor	r3, r3, #0x1
 80198ca: b2db         	uxtb	r3, r3
 80198cc: 2b00         	cmp	r3, #0x0
 80198ce: d002         	beq	0x80198d6 <gpio_manage_callback+0x5a> @ imm = #0x4
; 		return -EINVAL;
 80198d0: f06f 0315    	mvn	r3, #0x15
 80198d4: e008         	b	0x80198e8 <gpio_manage_callback+0x6c> @ imm = #0x10
; 	if (set) {
 80198d6: 79fb         	ldrb	r3, [r7, #0x7]
 80198d8: 2b00         	cmp	r3, #0x0
 80198da: d004         	beq	0x80198e6 <gpio_manage_callback+0x6a> @ imm = #0x8
; 		sys_slist_prepend(callbacks, &callback->node);
 80198dc: 68bb         	ldr	r3, [r7, #0x8]
 80198de: 4619         	mov	r1, r3
 80198e0: 68f8         	ldr	r0, [r7, #0xc]
 80198e2: f7ff fd63    	bl	0x80193ac <sys_slist_prepend> @ imm = #-0x53a
; 	return 0;
 80198e6: 2300         	movs	r3, #0x0
; }
 80198e8: 4618         	mov	r0, r3
 80198ea: 3710         	adds	r7, #0x10
 80198ec: 46bd         	mov	sp, r7
 80198ee: bd80         	pop	{r7, pc}

080198f0 <gpio_fire_callbacks>:
; {
 80198f0: b580         	push	{r7, lr}
 80198f2: b086         	sub	sp, #0x18
 80198f4: af00         	add	r7, sp, #0x0
 80198f6: 60f8         	str	r0, [r7, #0xc]
 80198f8: 60b9         	str	r1, [r7, #0x8]
 80198fa: 607a         	str	r2, [r7, #0x4]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 80198fc: 68f8         	ldr	r0, [r7, #0xc]
 80198fe: f7ff fd0f    	bl	0x8019320 <sys_slist_peek_head> @ imm = #-0x5e2
 8019902: 4603         	mov	r3, r0
 8019904: 2b00         	cmp	r3, #0x0
 8019906: d004         	beq	0x8019912 <gpio_fire_callbacks+0x22> @ imm = #0x8
 8019908: 68f8         	ldr	r0, [r7, #0xc]
 801990a: f7ff fd09    	bl	0x8019320 <sys_slist_peek_head> @ imm = #-0x5ee
 801990e: 4603         	mov	r3, r0
 8019910: e000         	b	0x8019914 <gpio_fire_callbacks+0x24> @ imm = #0x0
 8019912: 2300         	movs	r3, #0x0
 8019914: 617b         	str	r3, [r7, #0x14]
 8019916: 697b         	ldr	r3, [r7, #0x14]
 8019918: 2b00         	cmp	r3, #0x0
 801991a: d00e         	beq	0x801993a <gpio_fire_callbacks+0x4a> @ imm = #0x1c
 801991c: 697b         	ldr	r3, [r7, #0x14]
 801991e: 4618         	mov	r0, r3
 8019920: f7ff fd33    	bl	0x801938a <sys_slist_peek_next> @ imm = #-0x59a
 8019924: 4603         	mov	r3, r0
 8019926: 2b00         	cmp	r3, #0x0
 8019928: d005         	beq	0x8019936 <gpio_fire_callbacks+0x46> @ imm = #0xa
 801992a: 697b         	ldr	r3, [r7, #0x14]
 801992c: 4618         	mov	r0, r3
 801992e: f7ff fd2c    	bl	0x801938a <sys_slist_peek_next> @ imm = #-0x5a8
 8019932: 4603         	mov	r3, r0
 8019934: e002         	b	0x801993c <gpio_fire_callbacks+0x4c> @ imm = #0x4
 8019936: 2300         	movs	r3, #0x0
 8019938: e000         	b	0x801993c <gpio_fire_callbacks+0x4c> @ imm = #0x0
 801993a: 2300         	movs	r3, #0x0
 801993c: 613b         	str	r3, [r7, #0x10]
 801993e: e024         	b	0x801998a <gpio_fire_callbacks+0x9a> @ imm = #0x48
; 		if (cb->pin_mask & pins) {
 8019940: 697b         	ldr	r3, [r7, #0x14]
 8019942: 689a         	ldr	r2, [r3, #0x8]
 8019944: 687b         	ldr	r3, [r7, #0x4]
 8019946: 4013         	ands	r3, r2
 8019948: 2b00         	cmp	r3, #0x0
 801994a: d008         	beq	0x801995e <gpio_fire_callbacks+0x6e> @ imm = #0x10
; 			cb->handler(port, cb, cb->pin_mask & pins);
 801994c: 697b         	ldr	r3, [r7, #0x14]
 801994e: 685b         	ldr	r3, [r3, #0x4]
 8019950: 697a         	ldr	r2, [r7, #0x14]
 8019952: 6891         	ldr	r1, [r2, #0x8]
 8019954: 687a         	ldr	r2, [r7, #0x4]
 8019956: 400a         	ands	r2, r1
 8019958: 6979         	ldr	r1, [r7, #0x14]
 801995a: 68b8         	ldr	r0, [r7, #0x8]
 801995c: 4798         	blx	r3
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 801995e: 693b         	ldr	r3, [r7, #0x10]
 8019960: 617b         	str	r3, [r7, #0x14]
 8019962: 697b         	ldr	r3, [r7, #0x14]
 8019964: 2b00         	cmp	r3, #0x0
 8019966: d00e         	beq	0x8019986 <gpio_fire_callbacks+0x96> @ imm = #0x1c
 8019968: 697b         	ldr	r3, [r7, #0x14]
 801996a: 4618         	mov	r0, r3
 801996c: f7ff fd0d    	bl	0x801938a <sys_slist_peek_next> @ imm = #-0x5e6
 8019970: 4603         	mov	r3, r0
 8019972: 2b00         	cmp	r3, #0x0
 8019974: d005         	beq	0x8019982 <gpio_fire_callbacks+0x92> @ imm = #0xa
 8019976: 697b         	ldr	r3, [r7, #0x14]
 8019978: 4618         	mov	r0, r3
 801997a: f7ff fd06    	bl	0x801938a <sys_slist_peek_next> @ imm = #-0x5f4
 801997e: 4603         	mov	r3, r0
 8019980: e002         	b	0x8019988 <gpio_fire_callbacks+0x98> @ imm = #0x4
 8019982: 2300         	movs	r3, #0x0
 8019984: e000         	b	0x8019988 <gpio_fire_callbacks+0x98> @ imm = #0x0
 8019986: 2300         	movs	r3, #0x0
 8019988: 613b         	str	r3, [r7, #0x10]
 801998a: 697b         	ldr	r3, [r7, #0x14]
 801998c: 2b00         	cmp	r3, #0x0
 801998e: d1d7         	bne	0x8019940 <gpio_fire_callbacks+0x50> @ imm = #-0x52
; }
 8019990: bf00         	nop
 8019992: bf00         	nop
 8019994: 3718         	adds	r7, #0x18
 8019996: 46bd         	mov	sp, r7
 8019998: bd80         	pop	{r7, pc}

0801999a <gpio_stm32_isr>:
; {
 801999a: b580         	push	{r7, lr}
 801999c: b084         	sub	sp, #0x10
 801999e: af00         	add	r7, sp, #0x0
 80199a0: 6078         	str	r0, [r7, #0x4]
 80199a2: 6039         	str	r1, [r7]
; 	struct gpio_stm32_data *data = arg;
 80199a4: 683b         	ldr	r3, [r7]
 80199a6: 60fb         	str	r3, [r7, #0xc]
; 	gpio_fire_callbacks(&data->cb, data->dev, pin);
 80199a8: 68fb         	ldr	r3, [r7, #0xc]
 80199aa: f103 0008    	add.w	r0, r3, #0x8
 80199ae: 68fb         	ldr	r3, [r7, #0xc]
 80199b0: 685b         	ldr	r3, [r3, #0x4]
 80199b2: 687a         	ldr	r2, [r7, #0x4]
 80199b4: 4619         	mov	r1, r3
 80199b6: f7ff ff9b    	bl	0x80198f0 <gpio_fire_callbacks> @ imm = #-0xca
; }
 80199ba: bf00         	nop
 80199bc: 3710         	adds	r7, #0x10
 80199be: 46bd         	mov	sp, r7
 80199c0: bd80         	pop	{r7, pc}

080199c2 <gpio_stm32_flags_to_conf>:
; {
 80199c2: b480         	push	{r7}
 80199c4: b083         	sub	sp, #0xc
 80199c6: af00         	add	r7, sp, #0x0
 80199c8: 6078         	str	r0, [r7, #0x4]
 80199ca: 6039         	str	r1, [r7]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 80199cc: 687b         	ldr	r3, [r7, #0x4]
 80199ce: f403 3300    	and	r3, r3, #0x20000
 80199d2: 2b00         	cmp	r3, #0x0
 80199d4: d032         	beq	0x8019a3c <gpio_stm32_flags_to_conf+0x7a> @ imm = #0x64
; 		*pincfg = STM32_PINCFG_MODE_OUTPUT;
 80199d6: 683b         	ldr	r3, [r7]
 80199d8: 2210         	movs	r2, #0x10
 80199da: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_SINGLE_ENDED) != 0) {
 80199dc: 687b         	ldr	r3, [r7, #0x4]
 80199de: f003 0302    	and	r3, r3, #0x2
 80199e2: 2b00         	cmp	r3, #0x0
 80199e4: d00e         	beq	0x8019a04 <gpio_stm32_flags_to_conf+0x42> @ imm = #0x1c
; 			if (flags & GPIO_LINE_OPEN_DRAIN) {
 80199e6: 687b         	ldr	r3, [r7, #0x4]
 80199e8: f003 0304    	and	r3, r3, #0x4
 80199ec: 2b00         	cmp	r3, #0x0
 80199ee: d006         	beq	0x80199fe <gpio_stm32_flags_to_conf+0x3c> @ imm = #0xc
; 				*pincfg |= STM32_PINCFG_OPEN_DRAIN;
 80199f0: 683b         	ldr	r3, [r7]
 80199f2: 681b         	ldr	r3, [r3]
 80199f4: f043 0240    	orr	r2, r3, #0x40
 80199f8: 683b         	ldr	r3, [r7]
 80199fa: 601a         	str	r2, [r3]
 80199fc: e006         	b	0x8019a0c <gpio_stm32_flags_to_conf+0x4a> @ imm = #0xc
; 				return -ENOTSUP;
 80199fe: f06f 0385    	mvn	r3, #0x85
 8019a02: e044         	b	0x8019a8e <gpio_stm32_flags_to_conf+0xcc> @ imm = #0x88
; 			*pincfg |= STM32_PINCFG_PUSH_PULL;
 8019a04: 683b         	ldr	r3, [r7]
 8019a06: 681a         	ldr	r2, [r3]
 8019a08: 683b         	ldr	r3, [r7]
 8019a0a: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 8019a0c: 687b         	ldr	r3, [r7, #0x4]
 8019a0e: f003 0310    	and	r3, r3, #0x10
 8019a12: 2b00         	cmp	r3, #0x0
 8019a14: d006         	beq	0x8019a24 <gpio_stm32_flags_to_conf+0x62> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 8019a16: 683b         	ldr	r3, [r7]
 8019a18: 681b         	ldr	r3, [r3]
 8019a1a: f443 7200    	orr	r2, r3, #0x200
 8019a1e: 683b         	ldr	r3, [r7]
 8019a20: 601a         	str	r2, [r3]
 8019a22: e033         	b	0x8019a8c <gpio_stm32_flags_to_conf+0xca> @ imm = #0x66
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 8019a24: 687b         	ldr	r3, [r7, #0x4]
 8019a26: f003 0320    	and	r3, r3, #0x20
 8019a2a: 2b00         	cmp	r3, #0x0
 8019a2c: d02e         	beq	0x8019a8c <gpio_stm32_flags_to_conf+0xca> @ imm = #0x5c
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 8019a2e: 683b         	ldr	r3, [r7]
 8019a30: 681b         	ldr	r3, [r3]
 8019a32: f443 6280    	orr	r2, r3, #0x400
 8019a36: 683b         	ldr	r3, [r7]
 8019a38: 601a         	str	r2, [r3]
 8019a3a: e027         	b	0x8019a8c <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4e
; 	} else if  ((flags & GPIO_INPUT) != 0) {
 8019a3c: 687b         	ldr	r3, [r7, #0x4]
 8019a3e: f403 3380    	and	r3, r3, #0x10000
 8019a42: 2b00         	cmp	r3, #0x0
 8019a44: d01f         	beq	0x8019a86 <gpio_stm32_flags_to_conf+0xc4> @ imm = #0x3e
; 		*pincfg = STM32_PINCFG_MODE_INPUT;
 8019a46: 683b         	ldr	r3, [r7]
 8019a48: 2200         	movs	r2, #0x0
 8019a4a: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 8019a4c: 687b         	ldr	r3, [r7, #0x4]
 8019a4e: f003 0310    	and	r3, r3, #0x10
 8019a52: 2b00         	cmp	r3, #0x0
 8019a54: d006         	beq	0x8019a64 <gpio_stm32_flags_to_conf+0xa2> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 8019a56: 683b         	ldr	r3, [r7]
 8019a58: 681b         	ldr	r3, [r3]
 8019a5a: f443 7200    	orr	r2, r3, #0x200
 8019a5e: 683b         	ldr	r3, [r7]
 8019a60: 601a         	str	r2, [r3]
 8019a62: e013         	b	0x8019a8c <gpio_stm32_flags_to_conf+0xca> @ imm = #0x26
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 8019a64: 687b         	ldr	r3, [r7, #0x4]
 8019a66: f003 0320    	and	r3, r3, #0x20
 8019a6a: 2b00         	cmp	r3, #0x0
 8019a6c: d006         	beq	0x8019a7c <gpio_stm32_flags_to_conf+0xba> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 8019a6e: 683b         	ldr	r3, [r7]
 8019a70: 681b         	ldr	r3, [r3]
 8019a72: f443 6280    	orr	r2, r3, #0x400
 8019a76: 683b         	ldr	r3, [r7]
 8019a78: 601a         	str	r2, [r3]
 8019a7a: e007         	b	0x8019a8c <gpio_stm32_flags_to_conf+0xca> @ imm = #0xe
; 			*pincfg |= STM32_PINCFG_FLOATING;
 8019a7c: 683b         	ldr	r3, [r7]
 8019a7e: 681a         	ldr	r2, [r3]
 8019a80: 683b         	ldr	r3, [r7]
 8019a82: 601a         	str	r2, [r3]
 8019a84: e002         	b	0x8019a8c <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4
; 		*pincfg = STM32_PINCFG_MODE_ANALOG;
 8019a86: 683b         	ldr	r3, [r7]
 8019a88: 2230         	movs	r2, #0x30
 8019a8a: 601a         	str	r2, [r3]
; 	return 0;
 8019a8c: 2300         	movs	r3, #0x0
; }
 8019a8e: 4618         	mov	r0, r3
 8019a90: 370c         	adds	r7, #0xc
 8019a92: 46bd         	mov	sp, r7
 8019a94: f85d 7b04    	ldr	r7, [sp], #4
 8019a98: 4770         	bx	lr

08019a9a <stm32_pinval_get>:
; {
 8019a9a: b480         	push	{r7}
 8019a9c: b085         	sub	sp, #0x14
 8019a9e: af00         	add	r7, sp, #0x0
 8019aa0: 4603         	mov	r3, r0
 8019aa2: 71fb         	strb	r3, [r7, #0x7]
; 	pinval = 1 << pin;
 8019aa4: 79fb         	ldrb	r3, [r7, #0x7]
 8019aa6: 2201         	movs	r2, #0x1
 8019aa8: fa02 f303    	lsl.w	r3, r2, r3
 8019aac: 60fb         	str	r3, [r7, #0xc]
; 	return pinval;
 8019aae: 68fb         	ldr	r3, [r7, #0xc]
; }
 8019ab0: 4618         	mov	r0, r3
 8019ab2: 3714         	adds	r7, #0x14
 8019ab4: 46bd         	mov	sp, r7
 8019ab6: f85d 7b04    	ldr	r7, [sp], #4
 8019aba: 4770         	bx	lr

08019abc <ll_gpio_set_pin_pull>:
; {
 8019abc: b580         	push	{r7, lr}
 8019abe: b084         	sub	sp, #0x10
 8019ac0: af00         	add	r7, sp, #0x0
 8019ac2: 60f8         	str	r0, [r7, #0xc]
 8019ac4: 60b9         	str	r1, [r7, #0x8]
 8019ac6: 607a         	str	r2, [r7, #0x4]
; 	LL_GPIO_SetPinPull(GPIOx, Pin, Pull);
 8019ac8: 687a         	ldr	r2, [r7, #0x4]
 8019aca: 68b9         	ldr	r1, [r7, #0x8]
 8019acc: 68f8         	ldr	r0, [r7, #0xc]
 8019ace: f7ff fd8d    	bl	0x80195ec <LL_GPIO_SetPinPull> @ imm = #-0x4e6
; }
 8019ad2: bf00         	nop
 8019ad4: 3710         	adds	r7, #0x10
 8019ad6: 46bd         	mov	sp, r7
 8019ad8: bd80         	pop	{r7, pc}

08019ada <gpio_stm32_disable_pin_irqs>:
; {
 8019ada: b580         	push	{r7, lr}
 8019adc: b084         	sub	sp, #0x10
 8019ade: af00         	add	r7, sp, #0x0
 8019ae0: 6078         	str	r0, [r7, #0x4]
 8019ae2: 460b         	mov	r3, r1
 8019ae4: 70fb         	strb	r3, [r7, #0x3]
; 	if (port != stm32_exti_get_line_src_port(pin)) {
 8019ae6: 78fb         	ldrb	r3, [r7, #0x3]
 8019ae8: 4618         	mov	r0, r3
 8019aea: f7fe f876    	bl	0x8017bda <stm32_exti_get_line_src_port> @ imm = #-0x1f14
 8019aee: 4602         	mov	r2, r0
 8019af0: 687b         	ldr	r3, [r7, #0x4]
 8019af2: 4293         	cmp	r3, r2
 8019af4: d110         	bne	0x8019b18 <gpio_stm32_disable_pin_irqs+0x3e> @ imm = #0x20
; 	stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(port, pin);
 8019af6: 78fb         	ldrb	r3, [r7, #0x3]
 8019af8: 4619         	mov	r1, r3
 8019afa: 6878         	ldr	r0, [r7, #0x4]
 8019afc: f7fe f838    	bl	0x8017b70 <stm32_gpio_intc_get_pin_irq_line> @ imm = #-0x1f90
 8019b00: 60f8         	str	r0, [r7, #0xc]
; 	stm32_gpio_intc_disable_line(irq_line);
 8019b02: 68f8         	ldr	r0, [r7, #0xc]
 8019b04: f7fe f843    	bl	0x8017b8e <stm32_gpio_intc_disable_line> @ imm = #-0x1f7a
; 	stm32_gpio_intc_remove_irq_callback(irq_line);
 8019b08: 68f8         	ldr	r0, [r7, #0xc]
 8019b0a: f7ed ff0f    	bl	0x800792c <stm32_gpio_intc_remove_irq_callback> @ imm = #-0x121e2
; 	stm32_gpio_intc_select_line_trigger(irq_line, STM32_GPIO_IRQ_TRIG_NONE);
 8019b0e: 2100         	movs	r1, #0x0
 8019b10: 68f8         	ldr	r0, [r7, #0xc]
 8019b12: f7ed fe93    	bl	0x800783c <stm32_gpio_intc_select_line_trigger> @ imm = #-0x122da
 8019b16: e000         	b	0x8019b1a <gpio_stm32_disable_pin_irqs+0x40> @ imm = #0x0
; 		return;
 8019b18: bf00         	nop
; }
 8019b1a: 3710         	adds	r7, #0x10
 8019b1c: 46bd         	mov	sp, r7
 8019b1e: bd80         	pop	{r7, pc}

08019b20 <gpio_stm32_configure_raw>:
; {
 8019b20: b580         	push	{r7, lr}
 8019b22: b08c         	sub	sp, #0x30
 8019b24: af00         	add	r7, sp, #0x0
 8019b26: 60f8         	str	r0, [r7, #0xc]
 8019b28: 607a         	str	r2, [r7, #0x4]
 8019b2a: 603b         	str	r3, [r7]
 8019b2c: 460b         	mov	r3, r1
 8019b2e: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8019b30: 68fb         	ldr	r3, [r7, #0xc]
 8019b32: 685b         	ldr	r3, [r3, #0x4]
 8019b34: 62fb         	str	r3, [r7, #0x2c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8019b36: 6afb         	ldr	r3, [r7, #0x2c]
 8019b38: 685b         	ldr	r3, [r3, #0x4]
 8019b3a: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pin_ll = stm32_pinval_get(pin);
 8019b3c: 7afb         	ldrb	r3, [r7, #0xb]
 8019b3e: 4618         	mov	r0, r3
 8019b40: f7ff ffab    	bl	0x8019a9a <stm32_pinval_get> @ imm = #-0xaa
 8019b44: 6278         	str	r0, [r7, #0x24]
; 	mode = conf & (STM32_MODER_MASK << STM32_MODER_SHIFT);
 8019b46: 687b         	ldr	r3, [r7, #0x4]
 8019b48: f003 0330    	and	r3, r3, #0x30
 8019b4c: 623b         	str	r3, [r7, #0x20]
; 	otype = conf & (STM32_OTYPER_MASK << STM32_OTYPER_SHIFT);
 8019b4e: 687b         	ldr	r3, [r7, #0x4]
 8019b50: f003 0340    	and	r3, r3, #0x40
 8019b54: 61fb         	str	r3, [r7, #0x1c]
; 	ospeed = conf & (STM32_OSPEEDR_MASK << STM32_OSPEEDR_SHIFT);
 8019b56: 687b         	ldr	r3, [r7, #0x4]
 8019b58: f403 73c0    	and	r3, r3, #0x180
 8019b5c: 61bb         	str	r3, [r7, #0x18]
; 	pupd = conf & (STM32_PUPDR_MASK << STM32_PUPDR_SHIFT);
 8019b5e: 687b         	ldr	r3, [r7, #0x4]
 8019b60: f403 63c0    	and	r3, r3, #0x600
 8019b64: 617b         	str	r3, [r7, #0x14]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8019b66: f44f 1180    	mov.w	r1, #0x100000
 8019b6a: 2000         	movs	r0, #0x0
 8019b6c: f7ff fe71    	bl	0x8019852 <z_stm32_hsem_lock> @ imm = #-0x31e
; 	LL_GPIO_SetPinOutputType(gpio, pin_ll, otype >> STM32_OTYPER_SHIFT);
 8019b70: 69fb         	ldr	r3, [r7, #0x1c]
 8019b72: 099b         	lsrs	r3, r3, #0x6
 8019b74: 461a         	mov	r2, r3
 8019b76: 6a79         	ldr	r1, [r7, #0x24]
 8019b78: 6ab8         	ldr	r0, [r7, #0x28]
 8019b7a: f7ff fce2    	bl	0x8019542 <LL_GPIO_SetPinOutputType> @ imm = #-0x63c
; 	LL_GPIO_SetPinSpeed(gpio, pin_ll, ospeed >> STM32_OSPEEDR_SHIFT);
 8019b7e: 69bb         	ldr	r3, [r7, #0x18]
 8019b80: 09db         	lsrs	r3, r3, #0x7
 8019b82: 461a         	mov	r2, r3
 8019b84: 6a79         	ldr	r1, [r7, #0x24]
 8019b86: 6ab8         	ldr	r0, [r7, #0x28]
 8019b88: f7ff fcf3    	bl	0x8019572 <LL_GPIO_SetPinSpeed> @ imm = #-0x61a
; 	ll_gpio_set_pin_pull(gpio, pin_ll, pupd >> STM32_PUPDR_SHIFT);
 8019b8c: 697b         	ldr	r3, [r7, #0x14]
 8019b8e: 0a5b         	lsrs	r3, r3, #0x9
 8019b90: 461a         	mov	r2, r3
 8019b92: 6a79         	ldr	r1, [r7, #0x24]
 8019b94: 6ab8         	ldr	r0, [r7, #0x28]
 8019b96: f7ff ff91    	bl	0x8019abc <ll_gpio_set_pin_pull> @ imm = #-0xde
; 	if (mode == STM32_MODER_ALT_MODE) {
 8019b9a: 6a3b         	ldr	r3, [r7, #0x20]
 8019b9c: 2b20         	cmp	r3, #0x20
 8019b9e: d10d         	bne	0x8019bbc <gpio_stm32_configure_raw+0x9c> @ imm = #0x1a
; 		if (pin < 8) {
 8019ba0: 7afb         	ldrb	r3, [r7, #0xb]
 8019ba2: 2b07         	cmp	r3, #0x7
 8019ba4: d805         	bhi	0x8019bb2 <gpio_stm32_configure_raw+0x92> @ imm = #0xa
; 			LL_GPIO_SetAFPin_0_7(gpio, pin_ll, func);
 8019ba6: 683a         	ldr	r2, [r7]
 8019ba8: 6a79         	ldr	r1, [r7, #0x24]
 8019baa: 6ab8         	ldr	r0, [r7, #0x28]
 8019bac: f7ff fd5b    	bl	0x8019666 <LL_GPIO_SetAFPin_0_7> @ imm = #-0x54a
 8019bb0: e004         	b	0x8019bbc <gpio_stm32_configure_raw+0x9c> @ imm = #0x8
; 			LL_GPIO_SetAFPin_8_15(gpio, pin_ll, func);
 8019bb2: 683a         	ldr	r2, [r7]
 8019bb4: 6a79         	ldr	r1, [r7, #0x24]
 8019bb6: 6ab8         	ldr	r0, [r7, #0x28]
 8019bb8: f7ff fd92    	bl	0x80196e0 <LL_GPIO_SetAFPin_8_15> @ imm = #-0x4dc
; 	LL_GPIO_SetPinMode(gpio, pin_ll, mode >> STM32_MODER_SHIFT);
 8019bbc: 6a3b         	ldr	r3, [r7, #0x20]
 8019bbe: 091b         	lsrs	r3, r3, #0x4
 8019bc0: 461a         	mov	r2, r3
 8019bc2: 6a79         	ldr	r1, [r7, #0x24]
 8019bc4: 6ab8         	ldr	r0, [r7, #0x28]
 8019bc6: f7ff fc7f    	bl	0x80194c8 <LL_GPIO_SetPinMode> @ imm = #-0x702
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8019bca: 2000         	movs	r0, #0x0
 8019bcc: f7ff fe4c    	bl	0x8019868 <z_stm32_hsem_unlock> @ imm = #-0x368
; }
 8019bd0: bf00         	nop
 8019bd2: 3730         	adds	r7, #0x30
 8019bd4: 46bd         	mov	sp, r7
 8019bd6: bd80         	pop	{r7, pc}

08019bd8 <gpio_stm32_port_get_raw>:
; {
 8019bd8: b580         	push	{r7, lr}
 8019bda: b084         	sub	sp, #0x10
 8019bdc: af00         	add	r7, sp, #0x0
 8019bde: 6078         	str	r0, [r7, #0x4]
 8019be0: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8019be2: 687b         	ldr	r3, [r7, #0x4]
 8019be4: 685b         	ldr	r3, [r3, #0x4]
 8019be6: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8019be8: 68fb         	ldr	r3, [r7, #0xc]
 8019bea: 685b         	ldr	r3, [r3, #0x4]
 8019bec: 60bb         	str	r3, [r7, #0x8]
; 	*value = LL_GPIO_ReadInputPort(gpio);
 8019bee: 68b8         	ldr	r0, [r7, #0x8]
 8019bf0: f7ff fdb5    	bl	0x801975e <LL_GPIO_ReadInputPort> @ imm = #-0x496
 8019bf4: 4602         	mov	r2, r0
 8019bf6: 683b         	ldr	r3, [r7]
 8019bf8: 601a         	str	r2, [r3]
; 	return 0;
 8019bfa: 2300         	movs	r3, #0x0
; }
 8019bfc: 4618         	mov	r0, r3
 8019bfe: 3710         	adds	r7, #0x10
 8019c00: 46bd         	mov	sp, r7
 8019c02: bd80         	pop	{r7, pc}

08019c04 <gpio_stm32_port_set_masked_raw>:
; {
 8019c04: b580         	push	{r7, lr}
 8019c06: b088         	sub	sp, #0x20
 8019c08: af00         	add	r7, sp, #0x0
 8019c0a: 60f8         	str	r0, [r7, #0xc]
 8019c0c: 60b9         	str	r1, [r7, #0x8]
 8019c0e: 607a         	str	r2, [r7, #0x4]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8019c10: 68fb         	ldr	r3, [r7, #0xc]
 8019c12: 685b         	ldr	r3, [r3, #0x4]
 8019c14: 61fb         	str	r3, [r7, #0x1c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8019c16: 69fb         	ldr	r3, [r7, #0x1c]
 8019c18: 685b         	ldr	r3, [r3, #0x4]
 8019c1a: 61bb         	str	r3, [r7, #0x18]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8019c1c: f44f 1180    	mov.w	r1, #0x100000
 8019c20: 2000         	movs	r0, #0x0
 8019c22: f7ff fe16    	bl	0x8019852 <z_stm32_hsem_lock> @ imm = #-0x3d4
; 	port_value = LL_GPIO_ReadOutputPort(gpio);
 8019c26: 69b8         	ldr	r0, [r7, #0x18]
 8019c28: f7ff fdb3    	bl	0x8019792 <LL_GPIO_ReadOutputPort> @ imm = #-0x49a
 8019c2c: 6178         	str	r0, [r7, #0x14]
; 	LL_GPIO_WriteOutputPort(gpio, (port_value & ~mask) | (mask & value));
 8019c2e: 68bb         	ldr	r3, [r7, #0x8]
 8019c30: 43da         	mvns	r2, r3
 8019c32: 697b         	ldr	r3, [r7, #0x14]
 8019c34: 401a         	ands	r2, r3
 8019c36: 68b9         	ldr	r1, [r7, #0x8]
 8019c38: 687b         	ldr	r3, [r7, #0x4]
 8019c3a: 400b         	ands	r3, r1
 8019c3c: 4313         	orrs	r3, r2
 8019c3e: 4619         	mov	r1, r3
 8019c40: 69b8         	ldr	r0, [r7, #0x18]
 8019c42: f7ff fd98    	bl	0x8019776 <LL_GPIO_WriteOutputPort> @ imm = #-0x4d0
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8019c46: 2000         	movs	r0, #0x0
 8019c48: f7ff fe0e    	bl	0x8019868 <z_stm32_hsem_unlock> @ imm = #-0x3e4
; 	return 0;
 8019c4c: 2300         	movs	r3, #0x0
; }
 8019c4e: 4618         	mov	r0, r3
 8019c50: 3720         	adds	r7, #0x20
 8019c52: 46bd         	mov	sp, r7
 8019c54: bd80         	pop	{r7, pc}

08019c56 <gpio_stm32_port_set_bits_raw>:
; {
 8019c56: b480         	push	{r7}
 8019c58: b085         	sub	sp, #0x14
 8019c5a: af00         	add	r7, sp, #0x0
 8019c5c: 6078         	str	r0, [r7, #0x4]
 8019c5e: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8019c60: 687b         	ldr	r3, [r7, #0x4]
 8019c62: 685b         	ldr	r3, [r3, #0x4]
 8019c64: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8019c66: 68fb         	ldr	r3, [r7, #0xc]
 8019c68: 685b         	ldr	r3, [r3, #0x4]
 8019c6a: 60bb         	str	r3, [r7, #0x8]
; 	WRITE_REG(gpio->BSRR, pins);
 8019c6c: 68bb         	ldr	r3, [r7, #0x8]
 8019c6e: 683a         	ldr	r2, [r7]
 8019c70: 619a         	str	r2, [r3, #0x18]
; 	return 0;
 8019c72: 2300         	movs	r3, #0x0
; }
 8019c74: 4618         	mov	r0, r3
 8019c76: 3714         	adds	r7, #0x14
 8019c78: 46bd         	mov	sp, r7
 8019c7a: f85d 7b04    	ldr	r7, [sp], #4
 8019c7e: 4770         	bx	lr

08019c80 <gpio_stm32_port_clear_bits_raw>:
; {
 8019c80: b580         	push	{r7, lr}
 8019c82: b084         	sub	sp, #0x10
 8019c84: af00         	add	r7, sp, #0x0
 8019c86: 6078         	str	r0, [r7, #0x4]
 8019c88: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8019c8a: 687b         	ldr	r3, [r7, #0x4]
 8019c8c: 685b         	ldr	r3, [r3, #0x4]
 8019c8e: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8019c90: 68fb         	ldr	r3, [r7, #0xc]
 8019c92: 685b         	ldr	r3, [r3, #0x4]
 8019c94: 60bb         	str	r3, [r7, #0x8]
; 	LL_GPIO_ResetOutputPin(gpio, pins);
 8019c96: 6839         	ldr	r1, [r7]
 8019c98: 68b8         	ldr	r0, [r7, #0x8]
 8019c9a: f7ff fd86    	bl	0x80197aa <LL_GPIO_ResetOutputPin> @ imm = #-0x4f4
; 	return 0;
 8019c9e: 2300         	movs	r3, #0x0
; }
 8019ca0: 4618         	mov	r0, r3
 8019ca2: 3710         	adds	r7, #0x10
 8019ca4: 46bd         	mov	sp, r7
 8019ca6: bd80         	pop	{r7, pc}

08019ca8 <gpio_stm32_port_toggle_bits>:
; {
 8019ca8: b580         	push	{r7, lr}
 8019caa: b084         	sub	sp, #0x10
 8019cac: af00         	add	r7, sp, #0x0
 8019cae: 6078         	str	r0, [r7, #0x4]
 8019cb0: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8019cb2: 687b         	ldr	r3, [r7, #0x4]
 8019cb4: 685b         	ldr	r3, [r3, #0x4]
 8019cb6: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8019cb8: 68fb         	ldr	r3, [r7, #0xc]
 8019cba: 685b         	ldr	r3, [r3, #0x4]
 8019cbc: 60bb         	str	r3, [r7, #0x8]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8019cbe: f44f 1180    	mov.w	r1, #0x100000
 8019cc2: 2000         	movs	r0, #0x0
 8019cc4: f7ff fdc5    	bl	0x8019852 <z_stm32_hsem_lock> @ imm = #-0x476
; 	WRITE_REG(gpio->ODR, READ_REG(gpio->ODR) ^ pins);
 8019cc8: 68bb         	ldr	r3, [r7, #0x8]
 8019cca: 695a         	ldr	r2, [r3, #0x14]
 8019ccc: 683b         	ldr	r3, [r7]
 8019cce: 405a         	eors	r2, r3
 8019cd0: 68bb         	ldr	r3, [r7, #0x8]
 8019cd2: 615a         	str	r2, [r3, #0x14]
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8019cd4: 2000         	movs	r0, #0x0
 8019cd6: f7ff fdc7    	bl	0x8019868 <z_stm32_hsem_unlock> @ imm = #-0x472
; 	return 0;
 8019cda: 2300         	movs	r3, #0x0
; }
 8019cdc: 4618         	mov	r0, r3
 8019cde: 3710         	adds	r7, #0x10
 8019ce0: 46bd         	mov	sp, r7
 8019ce2: bd80         	pop	{r7, pc}

08019ce4 <gpio_stm32_configure>:
; {
 8019ce4: b580         	push	{r7, lr}
 8019ce6: b086         	sub	sp, #0x18
 8019ce8: af00         	add	r7, sp, #0x0
 8019cea: 60f8         	str	r0, [r7, #0xc]
 8019cec: 607a         	str	r2, [r7, #0x4]
 8019cee: 603b         	str	r3, [r7]
 8019cf0: 460b         	mov	r3, r1
 8019cf2: 72fb         	strb	r3, [r7, #0xb]
; 	ret = pm_device_runtime_get(dev);
 8019cf4: 68f8         	ldr	r0, [r7, #0xc]
 8019cf6: f7ff fd96    	bl	0x8019826 <pm_device_runtime_get> @ imm = #-0x4d4
 8019cfa: 6178         	str	r0, [r7, #0x14]
; 	if (ret < 0) {
 8019cfc: 697b         	ldr	r3, [r7, #0x14]
 8019cfe: 2b00         	cmp	r3, #0x0
 8019d00: da01         	bge	0x8019d06 <gpio_stm32_configure+0x22> @ imm = #0x2
; 		return ret;
 8019d02: 697b         	ldr	r3, [r7, #0x14]
 8019d04: e028         	b	0x8019d58 <gpio_stm32_configure+0x74> @ imm = #0x50
; 	gpio_stm32_configure_raw(dev, pin, conf, func);
 8019d06: 7af9         	ldrb	r1, [r7, #0xb]
 8019d08: 683b         	ldr	r3, [r7]
 8019d0a: 687a         	ldr	r2, [r7, #0x4]
 8019d0c: 68f8         	ldr	r0, [r7, #0xc]
 8019d0e: f7ff ff07    	bl	0x8019b20 <gpio_stm32_configure_raw> @ imm = #-0x1f2
; 	if (func == IS_GPIO_OUT) {
 8019d12: 683b         	ldr	r3, [r7]
 8019d14: 2b11         	cmp	r3, #0x11
 8019d16: d11b         	bne	0x8019d50 <gpio_stm32_configure+0x6c> @ imm = #0x36
; 		uint32_t gpio_out = conf & (STM32_ODR_MASK << STM32_ODR_SHIFT);
 8019d18: 687b         	ldr	r3, [r7, #0x4]
 8019d1a: f403 6300    	and	r3, r3, #0x800
 8019d1e: 613b         	str	r3, [r7, #0x10]
; 		if (gpio_out == STM32_ODR_1) {
 8019d20: 693b         	ldr	r3, [r7, #0x10]
 8019d22: f5b3 6f00    	cmp.w	r3, #0x800
 8019d26: d108         	bne	0x8019d3a <gpio_stm32_configure+0x56> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 8019d28: 7afb         	ldrb	r3, [r7, #0xb]
 8019d2a: 2201         	movs	r2, #0x1
 8019d2c: fa02 f303    	lsl.w	r3, r2, r3
 8019d30: 4619         	mov	r1, r3
 8019d32: 68f8         	ldr	r0, [r7, #0xc]
 8019d34: f7ff ff8f    	bl	0x8019c56 <gpio_stm32_port_set_bits_raw> @ imm = #-0xe2
 8019d38: e00a         	b	0x8019d50 <gpio_stm32_configure+0x6c> @ imm = #0x14
; 		} else if (gpio_out == STM32_ODR_0) {
 8019d3a: 693b         	ldr	r3, [r7, #0x10]
 8019d3c: 2b00         	cmp	r3, #0x0
 8019d3e: d107         	bne	0x8019d50 <gpio_stm32_configure+0x6c> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 8019d40: 7afb         	ldrb	r3, [r7, #0xb]
 8019d42: 2201         	movs	r2, #0x1
 8019d44: fa02 f303    	lsl.w	r3, r2, r3
 8019d48: 4619         	mov	r1, r3
 8019d4a: 68f8         	ldr	r0, [r7, #0xc]
 8019d4c: f7ff ff98    	bl	0x8019c80 <gpio_stm32_port_clear_bits_raw> @ imm = #-0xd0
; 	return pm_device_runtime_put(dev);
 8019d50: 68f8         	ldr	r0, [r7, #0xc]
 8019d52: f7ff fd73    	bl	0x801983c <pm_device_runtime_put> @ imm = #-0x51a
 8019d56: 4603         	mov	r3, r0
; }
 8019d58: 4618         	mov	r0, r3
 8019d5a: 3718         	adds	r7, #0x18
 8019d5c: 46bd         	mov	sp, r7
 8019d5e: bd80         	pop	{r7, pc}

08019d60 <gpio_stm32_config>:
; {
 8019d60: b580         	push	{r7, lr}
 8019d62: b088         	sub	sp, #0x20
 8019d64: af00         	add	r7, sp, #0x0
 8019d66: 60f8         	str	r0, [r7, #0xc]
 8019d68: 460b         	mov	r3, r1
 8019d6a: 607a         	str	r2, [r7, #0x4]
 8019d6c: 72fb         	strb	r3, [r7, #0xb]
; 	struct gpio_stm32_data *data = dev->data;
 8019d6e: 68fb         	ldr	r3, [r7, #0xc]
 8019d70: 691b         	ldr	r3, [r3, #0x10]
 8019d72: 61fb         	str	r3, [r7, #0x1c]
; 	err = gpio_stm32_flags_to_conf(flags, &pincfg);
 8019d74: f107 0314    	add.w	r3, r7, #0x14
 8019d78: 4619         	mov	r1, r3
 8019d7a: 6878         	ldr	r0, [r7, #0x4]
 8019d7c: f7ff fe21    	bl	0x80199c2 <gpio_stm32_flags_to_conf> @ imm = #-0x3be
 8019d80: 61b8         	str	r0, [r7, #0x18]
; 	if (err != 0) {
 8019d82: 69bb         	ldr	r3, [r7, #0x18]
 8019d84: 2b00         	cmp	r3, #0x0
 8019d86: d001         	beq	0x8019d8c <gpio_stm32_config+0x2c> @ imm = #0x2
; 		return err;
 8019d88: 69bb         	ldr	r3, [r7, #0x18]
 8019d8a: e071         	b	0x8019e70 <gpio_stm32_config+0x110> @ imm = #0xe2
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 8019d8c: 687b         	ldr	r3, [r7, #0x4]
 8019d8e: f403 3300    	and	r3, r3, #0x20000
 8019d92: 2b00         	cmp	r3, #0x0
 8019d94: d104         	bne	0x8019da0 <gpio_stm32_config+0x40> @ imm = #0x8
 8019d96: 687b         	ldr	r3, [r7, #0x4]
 8019d98: f403 3380    	and	r3, r3, #0x10000
 8019d9c: 2b00         	cmp	r3, #0x0
 8019d9e: d01a         	beq	0x8019dd6 <gpio_stm32_config+0x76> @ imm = #0x34
; 	    !(data->pin_has_clock_enabled & BIT(pin))) {
 8019da0: 69fb         	ldr	r3, [r7, #0x1c]
 8019da2: 691a         	ldr	r2, [r3, #0x10]
 8019da4: 7afb         	ldrb	r3, [r7, #0xb]
 8019da6: fa22 f303    	lsr.w	r3, r2, r3
 8019daa: f003 0301    	and	r3, r3, #0x1
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 8019dae: 2b00         	cmp	r3, #0x0
 8019db0: d111         	bne	0x8019dd6 <gpio_stm32_config+0x76> @ imm = #0x22
; 		err = pm_device_runtime_get(dev);
 8019db2: 68f8         	ldr	r0, [r7, #0xc]
 8019db4: f7ff fd37    	bl	0x8019826 <pm_device_runtime_get> @ imm = #-0x592
 8019db8: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 8019dba: 69bb         	ldr	r3, [r7, #0x18]
 8019dbc: 2b00         	cmp	r3, #0x0
 8019dbe: da01         	bge	0x8019dc4 <gpio_stm32_config+0x64> @ imm = #0x2
; 			return err;
 8019dc0: 69bb         	ldr	r3, [r7, #0x18]
 8019dc2: e055         	b	0x8019e70 <gpio_stm32_config+0x110> @ imm = #0xaa
; 		data->pin_has_clock_enabled |= BIT(pin);
 8019dc4: 69fb         	ldr	r3, [r7, #0x1c]
 8019dc6: 691a         	ldr	r2, [r3, #0x10]
 8019dc8: 7afb         	ldrb	r3, [r7, #0xb]
 8019dca: 2101         	movs	r1, #0x1
 8019dcc: fa01 f303    	lsl.w	r3, r1, r3
 8019dd0: 431a         	orrs	r2, r3
 8019dd2: 69fb         	ldr	r3, [r7, #0x1c]
 8019dd4: 611a         	str	r2, [r3, #0x10]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 8019dd6: 687b         	ldr	r3, [r7, #0x4]
 8019dd8: f403 3300    	and	r3, r3, #0x20000
 8019ddc: 2b00         	cmp	r3, #0x0
 8019dde: d01a         	beq	0x8019e16 <gpio_stm32_config+0xb6> @ imm = #0x34
; 		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 8019de0: 687b         	ldr	r3, [r7, #0x4]
 8019de2: f403 2300    	and	r3, r3, #0x80000
 8019de6: 2b00         	cmp	r3, #0x0
 8019de8: d008         	beq	0x8019dfc <gpio_stm32_config+0x9c> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 8019dea: 7afb         	ldrb	r3, [r7, #0xb]
 8019dec: 2201         	movs	r2, #0x1
 8019dee: fa02 f303    	lsl.w	r3, r2, r3
 8019df2: 4619         	mov	r1, r3
 8019df4: 68f8         	ldr	r0, [r7, #0xc]
 8019df6: f7ff ff2e    	bl	0x8019c56 <gpio_stm32_port_set_bits_raw> @ imm = #-0x1a4
 8019dfa: e00c         	b	0x8019e16 <gpio_stm32_config+0xb6> @ imm = #0x18
; 		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
 8019dfc: 687b         	ldr	r3, [r7, #0x4]
 8019dfe: f403 2380    	and	r3, r3, #0x40000
 8019e02: 2b00         	cmp	r3, #0x0
 8019e04: d007         	beq	0x8019e16 <gpio_stm32_config+0xb6> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 8019e06: 7afb         	ldrb	r3, [r7, #0xb]
 8019e08: 2201         	movs	r2, #0x1
 8019e0a: fa02 f303    	lsl.w	r3, r2, r3
 8019e0e: 4619         	mov	r1, r3
 8019e10: 68f8         	ldr	r0, [r7, #0xc]
 8019e12: f7ff ff35    	bl	0x8019c80 <gpio_stm32_port_clear_bits_raw> @ imm = #-0x196
; 	gpio_stm32_configure_raw(dev, pin, pincfg, 0);
 8019e16: 697a         	ldr	r2, [r7, #0x14]
 8019e18: 7af9         	ldrb	r1, [r7, #0xb]
 8019e1a: 2300         	movs	r3, #0x0
 8019e1c: 68f8         	ldr	r0, [r7, #0xc]
 8019e1e: f7ff fe7f    	bl	0x8019b20 <gpio_stm32_configure_raw> @ imm = #-0x302
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 8019e22: 687b         	ldr	r3, [r7, #0x4]
 8019e24: f403 3300    	and	r3, r3, #0x20000
 8019e28: 2b00         	cmp	r3, #0x0
 8019e2a: d120         	bne	0x8019e6e <gpio_stm32_config+0x10e> @ imm = #0x40
 8019e2c: 687b         	ldr	r3, [r7, #0x4]
 8019e2e: f403 3380    	and	r3, r3, #0x10000
 8019e32: 2b00         	cmp	r3, #0x0
 8019e34: d11b         	bne	0x8019e6e <gpio_stm32_config+0x10e> @ imm = #0x36
; 	    (data->pin_has_clock_enabled & BIT(pin))) {
 8019e36: 69fb         	ldr	r3, [r7, #0x1c]
 8019e38: 691a         	ldr	r2, [r3, #0x10]
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 8019e3a: 7afb         	ldrb	r3, [r7, #0xb]
 8019e3c: fa22 f303    	lsr.w	r3, r2, r3
 8019e40: f003 0301    	and	r3, r3, #0x1
 8019e44: 2b00         	cmp	r3, #0x0
 8019e46: d012         	beq	0x8019e6e <gpio_stm32_config+0x10e> @ imm = #0x24
; 		err = pm_device_runtime_put(dev);
 8019e48: 68f8         	ldr	r0, [r7, #0xc]
 8019e4a: f7ff fcf7    	bl	0x801983c <pm_device_runtime_put> @ imm = #-0x612
 8019e4e: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 8019e50: 69bb         	ldr	r3, [r7, #0x18]
 8019e52: 2b00         	cmp	r3, #0x0
 8019e54: da01         	bge	0x8019e5a <gpio_stm32_config+0xfa> @ imm = #0x2
; 			return err;
 8019e56: 69bb         	ldr	r3, [r7, #0x18]
 8019e58: e00a         	b	0x8019e70 <gpio_stm32_config+0x110> @ imm = #0x14
; 		data->pin_has_clock_enabled &= ~BIT(pin);
 8019e5a: 69fb         	ldr	r3, [r7, #0x1c]
 8019e5c: 691a         	ldr	r2, [r3, #0x10]
 8019e5e: 7afb         	ldrb	r3, [r7, #0xb]
 8019e60: 2101         	movs	r1, #0x1
 8019e62: fa01 f303    	lsl.w	r3, r1, r3
 8019e66: 43db         	mvns	r3, r3
 8019e68: 401a         	ands	r2, r3
 8019e6a: 69fb         	ldr	r3, [r7, #0x1c]
 8019e6c: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 8019e6e: 2300         	movs	r3, #0x0
; }
 8019e70: 4618         	mov	r0, r3
 8019e72: 3720         	adds	r7, #0x20
 8019e74: 46bd         	mov	sp, r7
 8019e76: bd80         	pop	{r7, pc}

08019e78 <gpio_stm32_manage_callback>:
; {
 8019e78: b580         	push	{r7, lr}
 8019e7a: b086         	sub	sp, #0x18
 8019e7c: af00         	add	r7, sp, #0x0
 8019e7e: 60f8         	str	r0, [r7, #0xc]
 8019e80: 60b9         	str	r1, [r7, #0x8]
 8019e82: 4613         	mov	r3, r2
 8019e84: 71fb         	strb	r3, [r7, #0x7]
; 	struct gpio_stm32_data *data = dev->data;
 8019e86: 68fb         	ldr	r3, [r7, #0xc]
 8019e88: 691b         	ldr	r3, [r3, #0x10]
 8019e8a: 617b         	str	r3, [r7, #0x14]
; 	return gpio_manage_callback(&data->cb, callback, set);
 8019e8c: 697b         	ldr	r3, [r7, #0x14]
 8019e8e: 3308         	adds	r3, #0x8
 8019e90: 79fa         	ldrb	r2, [r7, #0x7]
 8019e92: 68b9         	ldr	r1, [r7, #0x8]
 8019e94: 4618         	mov	r0, r3
 8019e96: f7ff fcf1    	bl	0x801987c <gpio_manage_callback> @ imm = #-0x61e
 8019e9a: 4603         	mov	r3, r0
; }
 8019e9c: 4618         	mov	r0, r3
 8019e9e: 3718         	adds	r7, #0x18
 8019ea0: 46bd         	mov	sp, r7
 8019ea2: bd80         	pop	{r7, pc}

08019ea4 <pinctrl_lookup_state>:
; {
 8019ea4: b480         	push	{r7}
 8019ea6: b085         	sub	sp, #0x14
 8019ea8: af00         	add	r7, sp, #0x0
 8019eaa: 60f8         	str	r0, [r7, #0xc]
 8019eac: 460b         	mov	r3, r1
 8019eae: 607a         	str	r2, [r7, #0x4]
 8019eb0: 72fb         	strb	r3, [r7, #0xb]
; 	*state = &config->states[0];
 8019eb2: 68fb         	ldr	r3, [r7, #0xc]
 8019eb4: 681a         	ldr	r2, [r3]
 8019eb6: 687b         	ldr	r3, [r7, #0x4]
 8019eb8: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 8019eba: e00d         	b	0x8019ed8 <pinctrl_lookup_state+0x34> @ imm = #0x1a
; 		if (id == (*state)->id) {
 8019ebc: 687b         	ldr	r3, [r7, #0x4]
 8019ebe: 681b         	ldr	r3, [r3]
 8019ec0: 795b         	ldrb	r3, [r3, #0x5]
 8019ec2: 7afa         	ldrb	r2, [r7, #0xb]
 8019ec4: 429a         	cmp	r2, r3
 8019ec6: d101         	bne	0x8019ecc <pinctrl_lookup_state+0x28> @ imm = #0x2
; 			return 0;
 8019ec8: 2300         	movs	r3, #0x0
 8019eca: e011         	b	0x8019ef0 <pinctrl_lookup_state+0x4c> @ imm = #0x22
; 		(*state)++;
 8019ecc: 687b         	ldr	r3, [r7, #0x4]
 8019ece: 681b         	ldr	r3, [r3]
 8019ed0: f103 0208    	add.w	r2, r3, #0x8
 8019ed4: 687b         	ldr	r3, [r7, #0x4]
 8019ed6: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 8019ed8: 687b         	ldr	r3, [r7, #0x4]
 8019eda: 681a         	ldr	r2, [r3]
 8019edc: 68fb         	ldr	r3, [r7, #0xc]
 8019ede: 6819         	ldr	r1, [r3]
 8019ee0: 68fb         	ldr	r3, [r7, #0xc]
 8019ee2: 791b         	ldrb	r3, [r3, #0x4]
 8019ee4: 00db         	lsls	r3, r3, #0x3
 8019ee6: 440b         	add	r3, r1
 8019ee8: 429a         	cmp	r2, r3
 8019eea: d3e7         	blo	0x8019ebc <pinctrl_lookup_state+0x18> @ imm = #-0x32
; 	return -ENOENT;
 8019eec: f06f 0301    	mvn	r3, #0x1
; }
 8019ef0: 4618         	mov	r0, r3
 8019ef2: 3714         	adds	r7, #0x14
 8019ef4: 46bd         	mov	sp, r7
 8019ef6: f85d 7b04    	ldr	r7, [sp], #4
 8019efa: 4770         	bx	lr

08019efc <device_is_ready>:
; {
 8019efc: b580         	push	{r7, lr}
 8019efe: b082         	sub	sp, #0x8
 8019f00: af00         	add	r7, sp, #0x0
 8019f02: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8019f04: 6878         	ldr	r0, [r7, #0x4]
 8019f06: f004 f863    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x40c6
 8019f0a: 4603         	mov	r3, r0
; }
 8019f0c: 4618         	mov	r0, r3
 8019f0e: 3708         	adds	r7, #0x8
 8019f10: 46bd         	mov	sp, r7
 8019f12: bd80         	pop	{r7, pc}

08019f14 <pinctrl_configure_pins>:
; {
 8019f14: b580         	push	{r7, lr}
 8019f16: b08a         	sub	sp, #0x28
 8019f18: af00         	add	r7, sp, #0x0
 8019f1a: 60f8         	str	r0, [r7, #0xc]
 8019f1c: 460b         	mov	r3, r1
 8019f1e: 607a         	str	r2, [r7, #0x4]
 8019f20: 72fb         	strb	r3, [r7, #0xb]
; 	uint32_t pin_cgf = 0;
 8019f22: 2300         	movs	r3, #0x0
 8019f24: 627b         	str	r3, [r7, #0x24]
; 	int ret = 0;
 8019f26: 2300         	movs	r3, #0x0
 8019f28: 61fb         	str	r3, [r7, #0x1c]
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 8019f2a: 2300         	movs	r3, #0x0
 8019f2c: f887 3023    	strb.w	r3, [r7, #0x23]
 8019f30: e047         	b	0x8019fc2 <pinctrl_configure_pins+0xae> @ imm = #0x8e
; 		mux = pins[i].pinmux;
 8019f32: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8019f36: 00db         	lsls	r3, r3, #0x3
 8019f38: 68fa         	ldr	r2, [r7, #0xc]
 8019f3a: 4413         	add	r3, r2
 8019f3c: 681b         	ldr	r3, [r3]
 8019f3e: 61bb         	str	r3, [r7, #0x18]
; 		if (STM32_DT_PINMUX_FUNC(mux) < STM32_ANALOG) {
 8019f40: 69bb         	ldr	r3, [r7, #0x18]
 8019f42: f003 0310    	and	r3, r3, #0x10
 8019f46: 2b00         	cmp	r3, #0x0
 8019f48: d109         	bne	0x8019f5e <pinctrl_configure_pins+0x4a> @ imm = #0x12
; 			pin_cgf = pins[i].pincfg | STM32_MODER_ALT_MODE;
 8019f4a: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8019f4e: 00db         	lsls	r3, r3, #0x3
 8019f50: 68fa         	ldr	r2, [r7, #0xc]
 8019f52: 4413         	add	r3, r2
 8019f54: 685b         	ldr	r3, [r3, #0x4]
 8019f56: f043 0320    	orr	r3, r3, #0x20
 8019f5a: 627b         	str	r3, [r7, #0x24]
 8019f5c: e013         	b	0x8019f86 <pinctrl_configure_pins+0x72> @ imm = #0x26
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_ANALOG) {
 8019f5e: 69bb         	ldr	r3, [r7, #0x18]
 8019f60: f003 031f    	and	r3, r3, #0x1f
 8019f64: 2b10         	cmp	r3, #0x10
 8019f66: d102         	bne	0x8019f6e <pinctrl_configure_pins+0x5a> @ imm = #0x4
; 			pin_cgf = STM32_MODER_ANALOG_MODE;
 8019f68: 2330         	movs	r3, #0x30
 8019f6a: 627b         	str	r3, [r7, #0x24]
 8019f6c: e00b         	b	0x8019f86 <pinctrl_configure_pins+0x72> @ imm = #0x16
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_GPIO) {
 8019f6e: 69bb         	ldr	r3, [r7, #0x18]
 8019f70: f003 031f    	and	r3, r3, #0x1f
 8019f74: 2b11         	cmp	r3, #0x11
 8019f76: d106         	bne	0x8019f86 <pinctrl_configure_pins+0x72> @ imm = #0xc
; 			pin_cgf = pins[i].pincfg;
 8019f78: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8019f7c: 00db         	lsls	r3, r3, #0x3
 8019f7e: 68fa         	ldr	r2, [r7, #0xc]
 8019f80: 4413         	add	r3, r2
 8019f82: 685b         	ldr	r3, [r3, #0x4]
 8019f84: 627b         	str	r3, [r7, #0x24]
; 		pin = STM32PIN(STM32_DT_PINMUX_PORT(mux),
 8019f86: 69bb         	ldr	r3, [r7, #0x18]
 8019f88: 0a5b         	lsrs	r3, r3, #0x9
 8019f8a: 011b         	lsls	r3, r3, #0x4
 8019f8c: f403 72f8    	and	r2, r3, #0x1f0
 8019f90: 69bb         	ldr	r3, [r7, #0x18]
 8019f92: 095b         	lsrs	r3, r3, #0x5
 8019f94: f003 030f    	and	r3, r3, #0xf
 8019f98: 4313         	orrs	r3, r2
 8019f9a: 617b         	str	r3, [r7, #0x14]
; 		ret = stm32_pin_configure(pin, pin_cgf, STM32_DT_PINMUX_FUNC(mux));
 8019f9c: 69bb         	ldr	r3, [r7, #0x18]
 8019f9e: f003 031f    	and	r3, r3, #0x1f
 8019fa2: 461a         	mov	r2, r3
 8019fa4: 6a79         	ldr	r1, [r7, #0x24]
 8019fa6: 6978         	ldr	r0, [r7, #0x14]
 8019fa8: f7ef fc88    	bl	0x80098bc <stm32_pin_configure> @ imm = #-0x106f0
 8019fac: 61f8         	str	r0, [r7, #0x1c]
; 		if (ret < 0) {
 8019fae: 69fb         	ldr	r3, [r7, #0x1c]
 8019fb0: 2b00         	cmp	r3, #0x0
 8019fb2: da01         	bge	0x8019fb8 <pinctrl_configure_pins+0xa4> @ imm = #0x2
; 			return ret;
 8019fb4: 69fb         	ldr	r3, [r7, #0x1c]
 8019fb6: e00a         	b	0x8019fce <pinctrl_configure_pins+0xba> @ imm = #0x14
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 8019fb8: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8019fbc: 3301         	adds	r3, #0x1
 8019fbe: f887 3023    	strb.w	r3, [r7, #0x23]
 8019fc2: f897 2023    	ldrb.w	r2, [r7, #0x23]
 8019fc6: 7afb         	ldrb	r3, [r7, #0xb]
 8019fc8: 429a         	cmp	r2, r3
 8019fca: d3b2         	blo	0x8019f32 <pinctrl_configure_pins+0x1e> @ imm = #-0x9c
; 	return 0;
 8019fcc: 2300         	movs	r3, #0x0
; }
 8019fce: 4618         	mov	r0, r3
 8019fd0: 3728         	adds	r7, #0x28
 8019fd2: 46bd         	mov	sp, r7
 8019fd4: bd80         	pop	{r7, pc}

08019fd6 <LL_TIM_EnableCounter>:
; {
 8019fd6: b480         	push	{r7}
 8019fd8: b083         	sub	sp, #0xc
 8019fda: af00         	add	r7, sp, #0x0
 8019fdc: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 8019fde: 687b         	ldr	r3, [r7, #0x4]
 8019fe0: 681b         	ldr	r3, [r3]
 8019fe2: f043 0201    	orr	r2, r3, #0x1
 8019fe6: 687b         	ldr	r3, [r7, #0x4]
 8019fe8: 601a         	str	r2, [r3]
; }
 8019fea: bf00         	nop
 8019fec: 370c         	adds	r7, #0xc
 8019fee: 46bd         	mov	sp, r7
 8019ff0: f85d 7b04    	ldr	r7, [sp], #4
 8019ff4: 4770         	bx	lr

08019ff6 <LL_TIM_EnableARRPreload>:
; {
 8019ff6: b480         	push	{r7}
 8019ff8: b083         	sub	sp, #0xc
 8019ffa: af00         	add	r7, sp, #0x0
 8019ffc: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(TIMx->CR1, TIM_CR1_ARPE);
 8019ffe: 687b         	ldr	r3, [r7, #0x4]
 801a000: 681b         	ldr	r3, [r3]
 801a002: f043 0280    	orr	r2, r3, #0x80
 801a006: 687b         	ldr	r3, [r7, #0x4]
 801a008: 601a         	str	r2, [r3]
; }
 801a00a: bf00         	nop
 801a00c: 370c         	adds	r7, #0xc
 801a00e: 46bd         	mov	sp, r7
 801a010: f85d 7b04    	ldr	r7, [sp], #4
 801a014: 4770         	bx	lr

0801a016 <LL_TIM_SetAutoReload>:
; {
 801a016: b480         	push	{r7}
 801a018: b083         	sub	sp, #0xc
 801a01a: af00         	add	r7, sp, #0x0
 801a01c: 6078         	str	r0, [r7, #0x4]
 801a01e: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->ARR, AutoReload);
 801a020: 687b         	ldr	r3, [r7, #0x4]
 801a022: 683a         	ldr	r2, [r7]
 801a024: 62da         	str	r2, [r3, #0x2c]
; }
 801a026: bf00         	nop
 801a028: 370c         	adds	r7, #0xc
 801a02a: 46bd         	mov	sp, r7
 801a02c: f85d 7b04    	ldr	r7, [sp], #4
 801a030: 4770         	bx	lr

0801a032 <LL_TIM_CC_DisableChannel>:
; {
 801a032: b480         	push	{r7}
 801a034: b083         	sub	sp, #0xc
 801a036: af00         	add	r7, sp, #0x0
 801a038: 6078         	str	r0, [r7, #0x4]
 801a03a: 6039         	str	r1, [r7]
;   CLEAR_BIT(TIMx->CCER, Channels);
 801a03c: 687b         	ldr	r3, [r7, #0x4]
 801a03e: 6a1a         	ldr	r2, [r3, #0x20]
 801a040: 683b         	ldr	r3, [r7]
 801a042: 43db         	mvns	r3, r3
 801a044: 401a         	ands	r2, r3
 801a046: 687b         	ldr	r3, [r7, #0x4]
 801a048: 621a         	str	r2, [r3, #0x20]
; }
 801a04a: bf00         	nop
 801a04c: 370c         	adds	r7, #0xc
 801a04e: 46bd         	mov	sp, r7
 801a050: f85d 7b04    	ldr	r7, [sp], #4
 801a054: 4770         	bx	lr

0801a056 <LL_TIM_CC_IsEnabledChannel>:
; {
 801a056: b480         	push	{r7}
 801a058: b083         	sub	sp, #0xc
 801a05a: af00         	add	r7, sp, #0x0
 801a05c: 6078         	str	r0, [r7, #0x4]
 801a05e: 6039         	str	r1, [r7]
;   return ((READ_BIT(TIMx->CCER, Channels) == (Channels)) ? 1UL : 0UL);
 801a060: 687b         	ldr	r3, [r7, #0x4]
 801a062: 6a1a         	ldr	r2, [r3, #0x20]
 801a064: 683b         	ldr	r3, [r7]
 801a066: 4013         	ands	r3, r2
 801a068: 683a         	ldr	r2, [r7]
 801a06a: 429a         	cmp	r2, r3
 801a06c: d101         	bne	0x801a072 <LL_TIM_CC_IsEnabledChannel+0x1c> @ imm = #0x2
 801a06e: 2301         	movs	r3, #0x1
 801a070: e000         	b	0x801a074 <LL_TIM_CC_IsEnabledChannel+0x1e> @ imm = #0x0
 801a072: 2300         	movs	r3, #0x0
; }
 801a074: 4618         	mov	r0, r3
 801a076: 370c         	adds	r7, #0xc
 801a078: 46bd         	mov	sp, r7
 801a07a: f85d 7b04    	ldr	r7, [sp], #4
 801a07e: 4770         	bx	lr

0801a080 <LL_TIM_OC_SetCompareCH1>:
; {
 801a080: b480         	push	{r7}
 801a082: b083         	sub	sp, #0xc
 801a084: af00         	add	r7, sp, #0x0
 801a086: 6078         	str	r0, [r7, #0x4]
 801a088: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->CCR1, CompareValue);
 801a08a: 687b         	ldr	r3, [r7, #0x4]
 801a08c: 683a         	ldr	r2, [r7]
 801a08e: 635a         	str	r2, [r3, #0x34]
; }
 801a090: bf00         	nop
 801a092: 370c         	adds	r7, #0xc
 801a094: 46bd         	mov	sp, r7
 801a096: f85d 7b04    	ldr	r7, [sp], #4
 801a09a: 4770         	bx	lr

0801a09c <LL_TIM_OC_SetCompareCH2>:
; {
 801a09c: b480         	push	{r7}
 801a09e: b083         	sub	sp, #0xc
 801a0a0: af00         	add	r7, sp, #0x0
 801a0a2: 6078         	str	r0, [r7, #0x4]
 801a0a4: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->CCR2, CompareValue);
 801a0a6: 687b         	ldr	r3, [r7, #0x4]
 801a0a8: 683a         	ldr	r2, [r7]
 801a0aa: 639a         	str	r2, [r3, #0x38]
; }
 801a0ac: bf00         	nop
 801a0ae: 370c         	adds	r7, #0xc
 801a0b0: 46bd         	mov	sp, r7
 801a0b2: f85d 7b04    	ldr	r7, [sp], #4
 801a0b6: 4770         	bx	lr

0801a0b8 <LL_TIM_OC_SetCompareCH3>:
; {
 801a0b8: b480         	push	{r7}
 801a0ba: b083         	sub	sp, #0xc
 801a0bc: af00         	add	r7, sp, #0x0
 801a0be: 6078         	str	r0, [r7, #0x4]
 801a0c0: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->CCR3, CompareValue);
 801a0c2: 687b         	ldr	r3, [r7, #0x4]
 801a0c4: 683a         	ldr	r2, [r7]
 801a0c6: 63da         	str	r2, [r3, #0x3c]
; }
 801a0c8: bf00         	nop
 801a0ca: 370c         	adds	r7, #0xc
 801a0cc: 46bd         	mov	sp, r7
 801a0ce: f85d 7b04    	ldr	r7, [sp], #4
 801a0d2: 4770         	bx	lr

0801a0d4 <LL_TIM_OC_SetCompareCH4>:
; {
 801a0d4: b480         	push	{r7}
 801a0d6: b083         	sub	sp, #0xc
 801a0d8: af00         	add	r7, sp, #0x0
 801a0da: 6078         	str	r0, [r7, #0x4]
 801a0dc: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->CCR4, CompareValue);
 801a0de: 687b         	ldr	r3, [r7, #0x4]
 801a0e0: 683a         	ldr	r2, [r7]
 801a0e2: 641a         	str	r2, [r3, #0x40]
; }
 801a0e4: bf00         	nop
 801a0e6: 370c         	adds	r7, #0xc
 801a0e8: 46bd         	mov	sp, r7
 801a0ea: f85d 7b04    	ldr	r7, [sp], #4
 801a0ee: 4770         	bx	lr

0801a0f0 <LL_TIM_EnableAllOutputs>:
; {
 801a0f0: b480         	push	{r7}
 801a0f2: b083         	sub	sp, #0xc
 801a0f4: af00         	add	r7, sp, #0x0
 801a0f6: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(TIMx->BDTR, TIM_BDTR_MOE);
 801a0f8: 687b         	ldr	r3, [r7, #0x4]
 801a0fa: 6c5b         	ldr	r3, [r3, #0x44]
 801a0fc: f443 4200    	orr	r2, r3, #0x8000
 801a100: 687b         	ldr	r3, [r7, #0x4]
 801a102: 645a         	str	r2, [r3, #0x44]
; }
 801a104: bf00         	nop
 801a106: 370c         	adds	r7, #0xc
 801a108: 46bd         	mov	sp, r7
 801a10a: f85d 7b04    	ldr	r7, [sp], #4
 801a10e: 4770         	bx	lr

0801a110 <LL_TIM_GenerateEvent_UPDATE>:
; {
 801a110: b480         	push	{r7}
 801a112: b083         	sub	sp, #0xc
 801a114: af00         	add	r7, sp, #0x0
 801a116: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(TIMx->EGR, TIM_EGR_UG);
 801a118: 687b         	ldr	r3, [r7, #0x4]
 801a11a: 695b         	ldr	r3, [r3, #0x14]
 801a11c: f043 0201    	orr	r2, r3, #0x1
 801a120: 687b         	ldr	r3, [r7, #0x4]
 801a122: 615a         	str	r2, [r3, #0x14]
; }
 801a124: bf00         	nop
 801a126: 370c         	adds	r7, #0xc
 801a128: 46bd         	mov	sp, r7
 801a12a: f85d 7b04    	ldr	r7, [sp], #4
 801a12e: 4770         	bx	lr

0801a130 <device_is_ready>:
; {
 801a130: b580         	push	{r7, lr}
 801a132: b082         	sub	sp, #0x8
 801a134: af00         	add	r7, sp, #0x0
 801a136: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801a138: 6878         	ldr	r0, [r7, #0x4]
 801a13a: f003 ff49    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x3e92
 801a13e: 4603         	mov	r3, r0
; }
 801a140: 4618         	mov	r0, r3
 801a142: 3708         	adds	r7, #0x8
 801a144: 46bd         	mov	sp, r7
 801a146: bd80         	pop	{r7, pc}

0801a148 <pinctrl_apply_state_direct>:
; {
 801a148: b580         	push	{r7, lr}
 801a14a: b084         	sub	sp, #0x10
 801a14c: af00         	add	r7, sp, #0x0
 801a14e: 6078         	str	r0, [r7, #0x4]
 801a150: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 801a152: 2300         	movs	r3, #0x0
 801a154: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 801a156: 683b         	ldr	r3, [r7]
 801a158: 6818         	ldr	r0, [r3]
 801a15a: 683b         	ldr	r3, [r7]
 801a15c: 791b         	ldrb	r3, [r3, #0x4]
 801a15e: 68fa         	ldr	r2, [r7, #0xc]
 801a160: 4619         	mov	r1, r3
 801a162: f7ff fed7    	bl	0x8019f14 <pinctrl_configure_pins> @ imm = #-0x252
 801a166: 4603         	mov	r3, r0
; }
 801a168: 4618         	mov	r0, r3
 801a16a: 3710         	adds	r7, #0x10
 801a16c: 46bd         	mov	sp, r7
 801a16e: bd80         	pop	{r7, pc}

0801a170 <pinctrl_apply_state>:
; {
 801a170: b580         	push	{r7, lr}
 801a172: b084         	sub	sp, #0x10
 801a174: af00         	add	r7, sp, #0x0
 801a176: 6078         	str	r0, [r7, #0x4]
 801a178: 460b         	mov	r3, r1
 801a17a: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 801a17c: f107 0208    	add.w	r2, r7, #0x8
 801a180: 78fb         	ldrb	r3, [r7, #0x3]
 801a182: 4619         	mov	r1, r3
 801a184: 6878         	ldr	r0, [r7, #0x4]
 801a186: f7ff fe8d    	bl	0x8019ea4 <pinctrl_lookup_state> @ imm = #-0x2e6
 801a18a: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 801a18c: 68fb         	ldr	r3, [r7, #0xc]
 801a18e: 2b00         	cmp	r3, #0x0
 801a190: da01         	bge	0x801a196 <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 801a192: 68fb         	ldr	r3, [r7, #0xc]
 801a194: e005         	b	0x801a1a2 <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 801a196: 68bb         	ldr	r3, [r7, #0x8]
 801a198: 4619         	mov	r1, r3
 801a19a: 6878         	ldr	r0, [r7, #0x4]
 801a19c: f7ff ffd4    	bl	0x801a148 <pinctrl_apply_state_direct> @ imm = #-0x58
 801a1a0: 4603         	mov	r3, r0
; }
 801a1a2: 4618         	mov	r0, r3
 801a1a4: 3710         	adds	r7, #0x10
 801a1a6: 46bd         	mov	sp, r7
 801a1a8: bd80         	pop	{r7, pc}

0801a1aa <z_impl_reset_line_toggle>:
; {
 801a1aa: b580         	push	{r7, lr}
 801a1ac: b084         	sub	sp, #0x10
 801a1ae: af00         	add	r7, sp, #0x0
 801a1b0: 6078         	str	r0, [r7, #0x4]
 801a1b2: 6039         	str	r1, [r7]
; 	const struct reset_driver_api *api = (const struct reset_driver_api *)dev->api;
 801a1b4: 687b         	ldr	r3, [r7, #0x4]
 801a1b6: 689b         	ldr	r3, [r3, #0x8]
 801a1b8: 60fb         	str	r3, [r7, #0xc]
; 	if (api->line_toggle == NULL) {
 801a1ba: 68fb         	ldr	r3, [r7, #0xc]
 801a1bc: 68db         	ldr	r3, [r3, #0xc]
 801a1be: 2b00         	cmp	r3, #0x0
 801a1c0: d102         	bne	0x801a1c8 <z_impl_reset_line_toggle+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 801a1c2: f06f 0357    	mvn	r3, #0x57
 801a1c6: e005         	b	0x801a1d4 <z_impl_reset_line_toggle+0x2a> @ imm = #0xa
; 	return api->line_toggle(dev, id);
 801a1c8: 68fb         	ldr	r3, [r7, #0xc]
 801a1ca: 68db         	ldr	r3, [r3, #0xc]
 801a1cc: 6839         	ldr	r1, [r7]
 801a1ce: 6878         	ldr	r0, [r7, #0x4]
 801a1d0: 4798         	blx	r3
 801a1d2: 4603         	mov	r3, r0
; }
 801a1d4: 4618         	mov	r0, r3
 801a1d6: 3710         	adds	r7, #0x10
 801a1d8: 46bd         	mov	sp, r7
 801a1da: bd80         	pop	{r7, pc}

0801a1dc <reset_line_toggle_dt>:
; {
 801a1dc: b580         	push	{r7, lr}
 801a1de: b082         	sub	sp, #0x8
 801a1e0: af00         	add	r7, sp, #0x0
 801a1e2: 6078         	str	r0, [r7, #0x4]
; 	return reset_line_toggle(spec->dev, spec->id);
 801a1e4: 687b         	ldr	r3, [r7, #0x4]
 801a1e6: 681a         	ldr	r2, [r3]
 801a1e8: 687b         	ldr	r3, [r7, #0x4]
 801a1ea: 685b         	ldr	r3, [r3, #0x4]
 801a1ec: 4619         	mov	r1, r3
 801a1ee: 4610         	mov	r0, r2
 801a1f0: f000 f805    	bl	0x801a1fe <reset_line_toggle> @ imm = #0xa
 801a1f4: 4603         	mov	r3, r0
; }
 801a1f6: 4618         	mov	r0, r3
 801a1f8: 3708         	adds	r7, #0x8
 801a1fa: 46bd         	mov	sp, r7
 801a1fc: bd80         	pop	{r7, pc}

0801a1fe <reset_line_toggle>:
; {
 801a1fe: b580         	push	{r7, lr}
 801a200: b082         	sub	sp, #0x8
 801a202: af00         	add	r7, sp, #0x0
 801a204: 6078         	str	r0, [r7, #0x4]
 801a206: 6039         	str	r1, [r7]
; 	return z_impl_reset_line_toggle(dev, id);
 801a208: 6839         	ldr	r1, [r7]
 801a20a: 6878         	ldr	r0, [r7, #0x4]
 801a20c: f7ff ffcd    	bl	0x801a1aa <z_impl_reset_line_toggle> @ imm = #-0x66
 801a210: 4603         	mov	r3, r0
; }
 801a212: 4618         	mov	r0, r3
 801a214: 3708         	adds	r7, #0x8
 801a216: 46bd         	mov	sp, r7
 801a218: bd80         	pop	{r7, pc}

0801a21a <clock_control_on>:
; {
 801a21a: b580         	push	{r7, lr}
 801a21c: b084         	sub	sp, #0x10
 801a21e: af00         	add	r7, sp, #0x0
 801a220: 6078         	str	r0, [r7, #0x4]
 801a222: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801a224: 687b         	ldr	r3, [r7, #0x4]
 801a226: 689b         	ldr	r3, [r3, #0x8]
 801a228: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801a22a: 68fb         	ldr	r3, [r7, #0xc]
 801a22c: 681b         	ldr	r3, [r3]
 801a22e: 6839         	ldr	r1, [r7]
 801a230: 6878         	ldr	r0, [r7, #0x4]
 801a232: 4798         	blx	r3
 801a234: 4603         	mov	r3, r0
; }
 801a236: 4618         	mov	r0, r3
 801a238: 3710         	adds	r7, #0x10
 801a23a: 46bd         	mov	sp, r7
 801a23c: bd80         	pop	{r7, pc}

0801a23e <clock_control_get_rate>:
; {
 801a23e: b580         	push	{r7, lr}
 801a240: b086         	sub	sp, #0x18
 801a242: af00         	add	r7, sp, #0x0
 801a244: 60f8         	str	r0, [r7, #0xc]
 801a246: 60b9         	str	r1, [r7, #0x8]
 801a248: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 801a24a: 68fb         	ldr	r3, [r7, #0xc]
 801a24c: 689b         	ldr	r3, [r3, #0x8]
 801a24e: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 801a250: 697b         	ldr	r3, [r7, #0x14]
 801a252: 68db         	ldr	r3, [r3, #0xc]
 801a254: 2b00         	cmp	r3, #0x0
 801a256: d102         	bne	0x801a25e <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 801a258: f06f 0357    	mvn	r3, #0x57
 801a25c: e006         	b	0x801a26c <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 801a25e: 697b         	ldr	r3, [r7, #0x14]
 801a260: 68db         	ldr	r3, [r3, #0xc]
 801a262: 687a         	ldr	r2, [r7, #0x4]
 801a264: 68b9         	ldr	r1, [r7, #0x8]
 801a266: 68f8         	ldr	r0, [r7, #0xc]
 801a268: 4798         	blx	r3
 801a26a: 4603         	mov	r3, r0
; }
 801a26c: 4618         	mov	r0, r3
 801a26e: 3718         	adds	r7, #0x18
 801a270: 46bd         	mov	sp, r7
 801a272: bd80         	pop	{r7, pc}

0801a274 <z_log_msg_runtime_create>:
; {
 801a274: b580         	push	{r7, lr}
 801a276: b08a         	sub	sp, #0x28
 801a278: af04         	add	r7, sp, #0x10
 801a27a: 60b9         	str	r1, [r7, #0x8]
 801a27c: 607b         	str	r3, [r7, #0x4]
 801a27e: 4603         	mov	r3, r0
 801a280: 73fb         	strb	r3, [r7, #0xf]
 801a282: 4613         	mov	r3, r2
 801a284: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801a286: f107 032c    	add.w	r3, r7, #0x2c
 801a28a: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801a28c: 7bba         	ldrb	r2, [r7, #0xe]
 801a28e: 7bf8         	ldrb	r0, [r7, #0xf]
 801a290: 697b         	ldr	r3, [r7, #0x14]
 801a292: 9303         	str	r3, [sp, #0xc]
 801a294: 6abb         	ldr	r3, [r7, #0x28]
 801a296: 9302         	str	r3, [sp, #0x8]
 801a298: 6a7b         	ldr	r3, [r7, #0x24]
 801a29a: 9301         	str	r3, [sp, #0x4]
 801a29c: 6a3b         	ldr	r3, [r7, #0x20]
 801a29e: 9300         	str	r3, [sp]
 801a2a0: 687b         	ldr	r3, [r7, #0x4]
 801a2a2: 68b9         	ldr	r1, [r7, #0x8]
 801a2a4: f7eb f966    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x14d34
; }
 801a2a8: bf00         	nop
 801a2aa: 3718         	adds	r7, #0x18
 801a2ac: 46bd         	mov	sp, r7
 801a2ae: bd80         	pop	{r7, pc}

0801a2b0 <get_polarity>:
; {
 801a2b0: b480         	push	{r7}
 801a2b2: b083         	sub	sp, #0xc
 801a2b4: af00         	add	r7, sp, #0x0
 801a2b6: 4603         	mov	r3, r0
 801a2b8: 80fb         	strh	r3, [r7, #0x6]
; 	if ((flags & PWM_POLARITY_MASK) == PWM_POLARITY_NORMAL) {
 801a2ba: 88fb         	ldrh	r3, [r7, #0x6]
 801a2bc: f003 0301    	and	r3, r3, #0x1
 801a2c0: 2b00         	cmp	r3, #0x0
 801a2c2: d101         	bne	0x801a2c8 <get_polarity+0x18> @ imm = #0x2
; 		return LL_TIM_OCPOLARITY_HIGH;
 801a2c4: 2300         	movs	r3, #0x0
 801a2c6: e000         	b	0x801a2ca <get_polarity+0x1a> @ imm = #0x0
; 	return LL_TIM_OCPOLARITY_LOW;
 801a2c8: 2302         	movs	r3, #0x2
; }
 801a2ca: 4618         	mov	r0, r3
 801a2cc: 370c         	adds	r7, #0xc
 801a2ce: 46bd         	mov	sp, r7
 801a2d0: f85d 7b04    	ldr	r7, [sp], #4
 801a2d4: 4770         	bx	lr

0801a2d6 <is_center_aligned>:
; {
 801a2d6: b480         	push	{r7}
 801a2d8: b083         	sub	sp, #0xc
 801a2da: af00         	add	r7, sp, #0x0
 801a2dc: 6078         	str	r0, [r7, #0x4]
; 		(ll_countermode == LL_TIM_COUNTERMODE_CENTER_UP) ||
 801a2de: 687b         	ldr	r3, [r7, #0x4]
 801a2e0: 2b20         	cmp	r3, #0x20
 801a2e2: d005         	beq	0x801a2f0 <is_center_aligned+0x1a> @ imm = #0xa
; 	return ((ll_countermode == LL_TIM_COUNTERMODE_CENTER_DOWN) ||
 801a2e4: 687b         	ldr	r3, [r7, #0x4]
 801a2e6: 2b40         	cmp	r3, #0x40
 801a2e8: d002         	beq	0x801a2f0 <is_center_aligned+0x1a> @ imm = #0x4
; 		(ll_countermode == LL_TIM_COUNTERMODE_CENTER_UP) ||
 801a2ea: 687b         	ldr	r3, [r7, #0x4]
 801a2ec: 2b60         	cmp	r3, #0x60
 801a2ee: d101         	bne	0x801a2f4 <is_center_aligned+0x1e> @ imm = #0x2
 801a2f0: 2301         	movs	r3, #0x1
 801a2f2: e000         	b	0x801a2f6 <is_center_aligned+0x20> @ imm = #0x0
 801a2f4: 2300         	movs	r3, #0x0
 801a2f6: f003 0301    	and	r3, r3, #0x1
 801a2fa: b2db         	uxtb	r3, r3
; }
 801a2fc: 4618         	mov	r0, r3
 801a2fe: 370c         	adds	r7, #0xc
 801a300: 46bd         	mov	sp, r7
 801a302: f85d 7b04    	ldr	r7, [sp], #4
 801a306: 4770         	bx	lr

0801a308 <pwm_stm32_get_cycles_per_sec>:
; {
 801a308: b4b0         	push	{r4, r5, r7}
 801a30a: b087         	sub	sp, #0x1c
 801a30c: af00         	add	r7, sp, #0x0
 801a30e: 60f8         	str	r0, [r7, #0xc]
 801a310: 60b9         	str	r1, [r7, #0x8]
 801a312: 607a         	str	r2, [r7, #0x4]
; 	struct pwm_stm32_data *data = dev->data;
 801a314: 68fb         	ldr	r3, [r7, #0xc]
 801a316: 691b         	ldr	r3, [r3, #0x10]
 801a318: 617b         	str	r3, [r7, #0x14]
; 	const struct pwm_stm32_config *cfg = dev->config;
 801a31a: 68fb         	ldr	r3, [r7, #0xc]
 801a31c: 685b         	ldr	r3, [r3, #0x4]
 801a31e: 613b         	str	r3, [r7, #0x10]
; 	*cycles = (uint64_t)(data->tim_clk / (cfg->prescaler + 1));
 801a320: 697b         	ldr	r3, [r7, #0x14]
 801a322: 681a         	ldr	r2, [r3]
 801a324: 693b         	ldr	r3, [r7, #0x10]
 801a326: 685b         	ldr	r3, [r3, #0x4]
 801a328: 3301         	adds	r3, #0x1
 801a32a: fbb2 f3f3    	udiv	r3, r2, r3
 801a32e: 2200         	movs	r2, #0x0
 801a330: 461c         	mov	r4, r3
 801a332: 4615         	mov	r5, r2
 801a334: 687b         	ldr	r3, [r7, #0x4]
 801a336: e9c3 4500    	strd	r4, r5, [r3]
; 	return 0;
 801a33a: 2300         	movs	r3, #0x0
; }
 801a33c: 4618         	mov	r0, r3
 801a33e: 371c         	adds	r7, #0x1c
 801a340: 46bd         	mov	sp, r7
 801a342: bcb0         	pop	{r4, r5, r7}
 801a344: 4770         	bx	lr

0801a346 <reset_stm32_status>:
; {
 801a346: b480         	push	{r7}
 801a348: b089         	sub	sp, #0x24
 801a34a: af00         	add	r7, sp, #0x0
 801a34c: 60f8         	str	r0, [r7, #0xc]
 801a34e: 60b9         	str	r1, [r7, #0x8]
 801a350: 607a         	str	r2, [r7, #0x4]
; 	const struct reset_stm32_config *config = dev->config;
 801a352: 68fb         	ldr	r3, [r7, #0xc]
 801a354: 685b         	ldr	r3, [r3, #0x4]
 801a356: 61fb         	str	r3, [r7, #0x1c]
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 801a358: 69fb         	ldr	r3, [r7, #0x1c]
 801a35a: 681a         	ldr	r2, [r3]
 801a35c: 68bb         	ldr	r3, [r7, #0x8]
 801a35e: 095b         	lsrs	r3, r3, #0x5
 801a360: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 801a364: 441a         	add	r2, r3
 801a366: 68bb         	ldr	r3, [r7, #0x8]
 801a368: f003 031f    	and	r3, r3, #0x1f
 801a36c: 61ba         	str	r2, [r7, #0x18]
 801a36e: 617b         	str	r3, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801a370: 69bb         	ldr	r3, [r7, #0x18]
 801a372: 681b         	ldr	r3, [r3]
 801a374: 613b         	str	r3, [r7, #0x10]
; 	return temp & (1 << bit);
 801a376: 2201         	movs	r2, #0x1
 801a378: 697b         	ldr	r3, [r7, #0x14]
 801a37a: fa02 f303    	lsl.w	r3, r2, r3
 801a37e: 461a         	mov	r2, r3
 801a380: 693b         	ldr	r3, [r7, #0x10]
 801a382: 4013         	ands	r3, r2
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 801a384: 2b00         	cmp	r3, #0x0
 801a386: bf14         	ite	ne
 801a388: 2301         	movne	r3, #0x1
 801a38a: 2300         	moveq	r3, #0x0
 801a38c: b2db         	uxtb	r3, r3
 801a38e: 461a         	mov	r2, r3
 801a390: 687b         	ldr	r3, [r7, #0x4]
 801a392: 701a         	strb	r2, [r3]
; 	return 0;
 801a394: 2300         	movs	r3, #0x0
; }
 801a396: 4618         	mov	r0, r3
 801a398: 3724         	adds	r7, #0x24
 801a39a: 46bd         	mov	sp, r7
 801a39c: f85d 7b04    	ldr	r7, [sp], #4
 801a3a0: 4770         	bx	lr

0801a3a2 <reset_stm32_line_assert>:
; {
 801a3a2: b480         	push	{r7}
 801a3a4: b087         	sub	sp, #0x1c
 801a3a6: af00         	add	r7, sp, #0x0
 801a3a8: 6078         	str	r0, [r7, #0x4]
 801a3aa: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 801a3ac: 687b         	ldr	r3, [r7, #0x4]
 801a3ae: 685b         	ldr	r3, [r3, #0x4]
 801a3b0: 617b         	str	r3, [r7, #0x14]
; 	sys_set_bit(config->base + STM32_RESET_SET_OFFSET(id),
 801a3b2: 697b         	ldr	r3, [r7, #0x14]
 801a3b4: 681a         	ldr	r2, [r3]
 801a3b6: 683b         	ldr	r3, [r7]
 801a3b8: 095b         	lsrs	r3, r3, #0x5
 801a3ba: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 801a3be: 441a         	add	r2, r3
 801a3c0: 683b         	ldr	r3, [r7]
 801a3c2: f003 031f    	and	r3, r3, #0x1f
 801a3c6: 613a         	str	r2, [r7, #0x10]
 801a3c8: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801a3ca: 693b         	ldr	r3, [r7, #0x10]
 801a3cc: 681b         	ldr	r3, [r3]
 801a3ce: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp | (1 << bit);
 801a3d0: 2201         	movs	r2, #0x1
 801a3d2: 68fb         	ldr	r3, [r7, #0xc]
 801a3d4: fa02 f303    	lsl.w	r3, r2, r3
 801a3d8: 4619         	mov	r1, r3
 801a3da: 693b         	ldr	r3, [r7, #0x10]
 801a3dc: 68ba         	ldr	r2, [r7, #0x8]
 801a3de: 430a         	orrs	r2, r1
 801a3e0: 601a         	str	r2, [r3]
; }
 801a3e2: bf00         	nop
; 	return 0;
 801a3e4: 2300         	movs	r3, #0x0
; }
 801a3e6: 4618         	mov	r0, r3
 801a3e8: 371c         	adds	r7, #0x1c
 801a3ea: 46bd         	mov	sp, r7
 801a3ec: f85d 7b04    	ldr	r7, [sp], #4
 801a3f0: 4770         	bx	lr

0801a3f2 <reset_stm32_line_deassert>:
; {
 801a3f2: b480         	push	{r7}
 801a3f4: b087         	sub	sp, #0x1c
 801a3f6: af00         	add	r7, sp, #0x0
 801a3f8: 6078         	str	r0, [r7, #0x4]
 801a3fa: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 801a3fc: 687b         	ldr	r3, [r7, #0x4]
 801a3fe: 685b         	ldr	r3, [r3, #0x4]
 801a400: 617b         	str	r3, [r7, #0x14]
; 	sys_clear_bit(config->base + STM32_RESET_SET_OFFSET(id),
 801a402: 697b         	ldr	r3, [r7, #0x14]
 801a404: 681a         	ldr	r2, [r3]
 801a406: 683b         	ldr	r3, [r7]
 801a408: 095b         	lsrs	r3, r3, #0x5
 801a40a: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 801a40e: 441a         	add	r2, r3
 801a410: 683b         	ldr	r3, [r7]
 801a412: f003 031f    	and	r3, r3, #0x1f
 801a416: 613a         	str	r2, [r7, #0x10]
 801a418: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 801a41a: 693b         	ldr	r3, [r7, #0x10]
 801a41c: 681b         	ldr	r3, [r3]
 801a41e: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~(1 << bit);
 801a420: 2201         	movs	r2, #0x1
 801a422: 68fb         	ldr	r3, [r7, #0xc]
 801a424: fa02 f303    	lsl.w	r3, r2, r3
 801a428: 43db         	mvns	r3, r3
 801a42a: 4619         	mov	r1, r3
 801a42c: 693b         	ldr	r3, [r7, #0x10]
 801a42e: 68ba         	ldr	r2, [r7, #0x8]
 801a430: 400a         	ands	r2, r1
 801a432: 601a         	str	r2, [r3]
; }
 801a434: bf00         	nop
; 	return 0;
 801a436: 2300         	movs	r3, #0x0
; }
 801a438: 4618         	mov	r0, r3
 801a43a: 371c         	adds	r7, #0x1c
 801a43c: 46bd         	mov	sp, r7
 801a43e: f85d 7b04    	ldr	r7, [sp], #4
 801a442: 4770         	bx	lr

0801a444 <reset_stm32_line_toggle>:
; {
 801a444: b580         	push	{r7, lr}
 801a446: b082         	sub	sp, #0x8
 801a448: af00         	add	r7, sp, #0x0
 801a44a: 6078         	str	r0, [r7, #0x4]
 801a44c: 6039         	str	r1, [r7]
; 	reset_stm32_line_assert(dev, id);
 801a44e: 6839         	ldr	r1, [r7]
 801a450: 6878         	ldr	r0, [r7, #0x4]
 801a452: f7ff ffa6    	bl	0x801a3a2 <reset_stm32_line_assert> @ imm = #-0xb4
; 	reset_stm32_line_deassert(dev, id);
 801a456: 6839         	ldr	r1, [r7]
 801a458: 6878         	ldr	r0, [r7, #0x4]
 801a45a: f7ff ffca    	bl	0x801a3f2 <reset_stm32_line_deassert> @ imm = #-0x6c
; 	return 0;
 801a45e: 2300         	movs	r3, #0x0
; }
 801a460: 4618         	mov	r0, r3
 801a462: 3708         	adds	r7, #0x8
 801a464: 46bd         	mov	sp, r7
 801a466: bd80         	pop	{r7, pc}

0801a468 <device_is_ready>:
; {
 801a468: b580         	push	{r7, lr}
 801a46a: b082         	sub	sp, #0x8
 801a46c: af00         	add	r7, sp, #0x0
 801a46e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801a470: 6878         	ldr	r0, [r7, #0x4]
 801a472: f003 fdad    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x3b5a
 801a476: 4603         	mov	r3, r0
; }
 801a478: 4618         	mov	r0, r3
 801a47a: 3708         	adds	r7, #0x8
 801a47c: 46bd         	mov	sp, r7
 801a47e: bd80         	pop	{r7, pc}

0801a480 <k_msleep>:
; {
 801a480: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801a484: b082         	sub	sp, #0x8
 801a486: af00         	add	r7, sp, #0x0
 801a488: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 801a48a: 6879         	ldr	r1, [r7, #0x4]
 801a48c: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 801a490: 17c8         	asrs	r0, r1, #0x1f
 801a492: 4688         	mov	r8, r1
 801a494: 4681         	mov	r9, r0
 801a496: 4640         	mov	r0, r8
 801a498: 4649         	mov	r1, r9
 801a49a: f04f 0400    	mov.w	r4, #0x0
 801a49e: f04f 0500    	mov.w	r5, #0x0
 801a4a2: 008d         	lsls	r5, r1, #0x2
 801a4a4: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 801a4a8: 0084         	lsls	r4, r0, #0x2
 801a4aa: 4620         	mov	r0, r4
 801a4ac: 4629         	mov	r1, r5
 801a4ae: eb10 0208    	adds.w	r2, r0, r8
 801a4b2: eb41 0309    	adc.w	r3, r1, r9
 801a4b6: eb12 0a02    	adds.w	r10, r2, r2
 801a4ba: eb43 0b03    	adc.w	r11, r3, r3
 801a4be: 4652         	mov	r2, r10
 801a4c0: 465b         	mov	r3, r11
 801a4c2: 4610         	mov	r0, r2
 801a4c4: 4619         	mov	r1, r3
 801a4c6: f000 f807    	bl	0x801a4d8 <k_sleep>     @ imm = #0xe
 801a4ca: 4601         	mov	r1, r0
 801a4cc: 460b         	mov	r3, r1
; }
 801a4ce: 4618         	mov	r0, r3
 801a4d0: 3708         	adds	r7, #0x8
 801a4d2: 46bd         	mov	sp, r7
 801a4d4: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801a4d8 <k_sleep>:
; {
 801a4d8: b580         	push	{r7, lr}
 801a4da: b082         	sub	sp, #0x8
 801a4dc: af00         	add	r7, sp, #0x0
 801a4de: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 801a4e2: e9d7 0100    	ldrd	r0, r1, [r7]
 801a4e6: f7f7 fe73    	bl	0x80121d0 <z_impl_k_sleep> @ imm = #-0x831a
 801a4ea: 4603         	mov	r3, r0
; }
 801a4ec: 4618         	mov	r0, r3
 801a4ee: 3708         	adds	r7, #0x8
 801a4f0: 46bd         	mov	sp, r7
 801a4f2: bd80         	pop	{r7, pc}

0801a4f4 <k_usleep>:
; {
 801a4f4: b580         	push	{r7, lr}
 801a4f6: b082         	sub	sp, #0x8
 801a4f8: af00         	add	r7, sp, #0x0
 801a4fa: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_usleep(us);
 801a4fc: 6878         	ldr	r0, [r7, #0x4]
 801a4fe: f005 f9b5    	bl	0x801f86c <z_impl_k_usleep> @ imm = #0x536a
 801a502: 4603         	mov	r3, r0
; }
 801a504: 4618         	mov	r0, r3
 801a506: 3708         	adds	r7, #0x8
 801a508: 46bd         	mov	sp, r7
 801a50a: bd80         	pop	{r7, pc}

0801a50c <pm_device_busy_set>:
; {
 801a50c: b480         	push	{r7}
 801a50e: b083         	sub	sp, #0xc
 801a510: af00         	add	r7, sp, #0x0
 801a512: 6078         	str	r0, [r7, #0x4]
; }
 801a514: bf00         	nop
 801a516: 370c         	adds	r7, #0xc
 801a518: 46bd         	mov	sp, r7
 801a51a: f85d 7b04    	ldr	r7, [sp], #4
 801a51e: 4770         	bx	lr

0801a520 <pm_device_busy_clear>:
; {
 801a520: b480         	push	{r7}
 801a522: b083         	sub	sp, #0xc
 801a524: af00         	add	r7, sp, #0x0
 801a526: 6078         	str	r0, [r7, #0x4]
; }
 801a528: bf00         	nop
 801a52a: 370c         	adds	r7, #0xc
 801a52c: 46bd         	mov	sp, r7
 801a52e: f85d 7b04    	ldr	r7, [sp], #4
 801a532: 4770         	bx	lr

0801a534 <z_log_msg_runtime_create>:
; {
 801a534: b580         	push	{r7, lr}
 801a536: b08a         	sub	sp, #0x28
 801a538: af04         	add	r7, sp, #0x10
 801a53a: 60b9         	str	r1, [r7, #0x8]
 801a53c: 607b         	str	r3, [r7, #0x4]
 801a53e: 4603         	mov	r3, r0
 801a540: 73fb         	strb	r3, [r7, #0xf]
 801a542: 4613         	mov	r3, r2
 801a544: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801a546: f107 032c    	add.w	r3, r7, #0x2c
 801a54a: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801a54c: 7bba         	ldrb	r2, [r7, #0xe]
 801a54e: 7bf8         	ldrb	r0, [r7, #0xf]
 801a550: 697b         	ldr	r3, [r7, #0x14]
 801a552: 9303         	str	r3, [sp, #0xc]
 801a554: 6abb         	ldr	r3, [r7, #0x28]
 801a556: 9302         	str	r3, [sp, #0x8]
 801a558: 6a7b         	ldr	r3, [r7, #0x24]
 801a55a: 9301         	str	r3, [sp, #0x4]
 801a55c: 6a3b         	ldr	r3, [r7, #0x20]
 801a55e: 9300         	str	r3, [sp]
 801a560: 687b         	ldr	r3, [r7, #0x4]
 801a562: 68b9         	ldr	r1, [r7, #0x8]
 801a564: f7eb f806    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x14ff4
; }
 801a568: bf00         	nop
 801a56a: 3718         	adds	r7, #0x18
 801a56c: 46bd         	mov	sp, r7
 801a56e: bd80         	pop	{r7, pc}

0801a570 <gpio_is_ready_dt>:
; {
 801a570: b580         	push	{r7, lr}
 801a572: b082         	sub	sp, #0x8
 801a574: af00         	add	r7, sp, #0x0
 801a576: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 801a578: 687b         	ldr	r3, [r7, #0x4]
 801a57a: 681b         	ldr	r3, [r3]
 801a57c: 4618         	mov	r0, r3
 801a57e: f7ff ff73    	bl	0x801a468 <device_is_ready> @ imm = #-0x11a
 801a582: 4603         	mov	r3, r0
; }
 801a584: 4618         	mov	r0, r3
 801a586: 3708         	adds	r7, #0x8
 801a588: 46bd         	mov	sp, r7
 801a58a: bd80         	pop	{r7, pc}

0801a58c <spi_cs_is_gpio>:
; {
 801a58c: b480         	push	{r7}
 801a58e: b083         	sub	sp, #0xc
 801a590: af00         	add	r7, sp, #0x0
 801a592: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 801a594: 687b         	ldr	r3, [r7, #0x4]
 801a596: 689b         	ldr	r3, [r3, #0x8]
 801a598: 2b00         	cmp	r3, #0x0
 801a59a: bf14         	ite	ne
 801a59c: 2301         	movne	r3, #0x1
 801a59e: 2300         	moveq	r3, #0x0
 801a5a0: b2db         	uxtb	r3, r3
; }
 801a5a2: 4618         	mov	r0, r3
 801a5a4: 370c         	adds	r7, #0xc
 801a5a6: 46bd         	mov	sp, r7
 801a5a8: f85d 7b04    	ldr	r7, [sp], #4
 801a5ac: 4770         	bx	lr

0801a5ae <spi_cs_is_gpio_dt>:
; {
 801a5ae: b580         	push	{r7, lr}
 801a5b0: b082         	sub	sp, #0x8
 801a5b2: af00         	add	r7, sp, #0x0
 801a5b4: 6078         	str	r0, [r7, #0x4]
; 	return spi_cs_is_gpio(&spec->config);
 801a5b6: 687b         	ldr	r3, [r7, #0x4]
 801a5b8: 3304         	adds	r3, #0x4
 801a5ba: 4618         	mov	r0, r3
 801a5bc: f7ff ffe6    	bl	0x801a58c <spi_cs_is_gpio> @ imm = #-0x34
 801a5c0: 4603         	mov	r3, r0
; }
 801a5c2: 4618         	mov	r0, r3
 801a5c4: 3708         	adds	r7, #0x8
 801a5c6: 46bd         	mov	sp, r7
 801a5c8: bd80         	pop	{r7, pc}

0801a5ca <spi_is_ready_dt>:
; {
 801a5ca: b580         	push	{r7, lr}
 801a5cc: b082         	sub	sp, #0x8
 801a5ce: af00         	add	r7, sp, #0x0
 801a5d0: 6078         	str	r0, [r7, #0x4]
; 	if (!device_is_ready(spec->bus)) {
 801a5d2: 687b         	ldr	r3, [r7, #0x4]
 801a5d4: 681b         	ldr	r3, [r3]
 801a5d6: 4618         	mov	r0, r3
 801a5d8: f7ff ff46    	bl	0x801a468 <device_is_ready> @ imm = #-0x174
 801a5dc: 4603         	mov	r3, r0
 801a5de: f083 0301    	eor	r3, r3, #0x1
 801a5e2: b2db         	uxtb	r3, r3
 801a5e4: 2b00         	cmp	r3, #0x0
 801a5e6: d001         	beq	0x801a5ec <spi_is_ready_dt+0x22> @ imm = #0x2
; 		return false;
 801a5e8: 2300         	movs	r3, #0x0
 801a5ea: e013         	b	0x801a614 <spi_is_ready_dt+0x4a> @ imm = #0x26
; 	if (spi_cs_is_gpio_dt(spec) &&
 801a5ec: 6878         	ldr	r0, [r7, #0x4]
 801a5ee: f7ff ffde    	bl	0x801a5ae <spi_cs_is_gpio_dt> @ imm = #-0x44
 801a5f2: 4603         	mov	r3, r0
 801a5f4: 2b00         	cmp	r3, #0x0
 801a5f6: d00c         	beq	0x801a612 <spi_is_ready_dt+0x48> @ imm = #0x18
; 	    !gpio_is_ready_dt(&spec->config.cs.gpio)) {
 801a5f8: 687b         	ldr	r3, [r7, #0x4]
 801a5fa: 330c         	adds	r3, #0xc
 801a5fc: 4618         	mov	r0, r3
 801a5fe: f7ff ffb7    	bl	0x801a570 <gpio_is_ready_dt> @ imm = #-0x92
 801a602: 4603         	mov	r3, r0
 801a604: f083 0301    	eor	r3, r3, #0x1
 801a608: b2db         	uxtb	r3, r3
; 	if (spi_cs_is_gpio_dt(spec) &&
 801a60a: 2b00         	cmp	r3, #0x0
 801a60c: d001         	beq	0x801a612 <spi_is_ready_dt+0x48> @ imm = #0x2
; 		return false;
 801a60e: 2300         	movs	r3, #0x0
 801a610: e000         	b	0x801a614 <spi_is_ready_dt+0x4a> @ imm = #0x0
; 	return true;
 801a612: 2301         	movs	r3, #0x1
; }
 801a614: 4618         	mov	r0, r3
 801a616: 3708         	adds	r7, #0x8
 801a618: 46bd         	mov	sp, r7
 801a61a: bd80         	pop	{r7, pc}

0801a61c <z_impl_spi_transceive>:
; {
 801a61c: b590         	push	{r4, r7, lr}
 801a61e: b087         	sub	sp, #0x1c
 801a620: af00         	add	r7, sp, #0x0
 801a622: 60f8         	str	r0, [r7, #0xc]
 801a624: 60b9         	str	r1, [r7, #0x8]
 801a626: 607a         	str	r2, [r7, #0x4]
 801a628: 603b         	str	r3, [r7]
; 	const struct spi_driver_api *api =
 801a62a: 68fb         	ldr	r3, [r7, #0xc]
 801a62c: 689b         	ldr	r3, [r3, #0x8]
 801a62e: 617b         	str	r3, [r7, #0x14]
; 	ret = api->transceive(dev, config, tx_bufs, rx_bufs);
 801a630: 697b         	ldr	r3, [r7, #0x14]
 801a632: 681c         	ldr	r4, [r3]
 801a634: 683b         	ldr	r3, [r7]
 801a636: 687a         	ldr	r2, [r7, #0x4]
 801a638: 68b9         	ldr	r1, [r7, #0x8]
 801a63a: 68f8         	ldr	r0, [r7, #0xc]
 801a63c: 47a0         	blx	r4
 801a63e: 6138         	str	r0, [r7, #0x10]
; 	return ret;
 801a640: 693b         	ldr	r3, [r7, #0x10]
; }
 801a642: 4618         	mov	r0, r3
 801a644: 371c         	adds	r7, #0x1c
 801a646: 46bd         	mov	sp, r7
 801a648: bd90         	pop	{r4, r7, pc}

0801a64a <spi_transceive_dt>:
; {
 801a64a: b580         	push	{r7, lr}
 801a64c: b084         	sub	sp, #0x10
 801a64e: af00         	add	r7, sp, #0x0
 801a650: 60f8         	str	r0, [r7, #0xc]
 801a652: 60b9         	str	r1, [r7, #0x8]
 801a654: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(spec->bus, &spec->config, tx_bufs, rx_bufs);
 801a656: 68fb         	ldr	r3, [r7, #0xc]
 801a658: 6818         	ldr	r0, [r3]
 801a65a: 68fb         	ldr	r3, [r7, #0xc]
 801a65c: 1d19         	adds	r1, r3, #0x4
 801a65e: 687b         	ldr	r3, [r7, #0x4]
 801a660: 68ba         	ldr	r2, [r7, #0x8]
 801a662: f000 f828    	bl	0x801a6b6 <spi_transceive> @ imm = #0x50
 801a666: 4603         	mov	r3, r0
; }
 801a668: 4618         	mov	r0, r3
 801a66a: 3710         	adds	r7, #0x10
 801a66c: 46bd         	mov	sp, r7
 801a66e: bd80         	pop	{r7, pc}

0801a670 <spi_write>:
; {
 801a670: b580         	push	{r7, lr}
 801a672: b084         	sub	sp, #0x10
 801a674: af00         	add	r7, sp, #0x0
 801a676: 60f8         	str	r0, [r7, #0xc]
 801a678: 60b9         	str	r1, [r7, #0x8]
 801a67a: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(dev, config, tx_bufs, NULL);
 801a67c: 2300         	movs	r3, #0x0
 801a67e: 687a         	ldr	r2, [r7, #0x4]
 801a680: 68b9         	ldr	r1, [r7, #0x8]
 801a682: 68f8         	ldr	r0, [r7, #0xc]
 801a684: f000 f817    	bl	0x801a6b6 <spi_transceive> @ imm = #0x2e
 801a688: 4603         	mov	r3, r0
; }
 801a68a: 4618         	mov	r0, r3
 801a68c: 3710         	adds	r7, #0x10
 801a68e: 46bd         	mov	sp, r7
 801a690: bd80         	pop	{r7, pc}

0801a692 <spi_write_dt>:
; {
 801a692: b580         	push	{r7, lr}
 801a694: b082         	sub	sp, #0x8
 801a696: af00         	add	r7, sp, #0x0
 801a698: 6078         	str	r0, [r7, #0x4]
 801a69a: 6039         	str	r1, [r7]
; 	return spi_write(spec->bus, &spec->config, tx_bufs);
 801a69c: 687b         	ldr	r3, [r7, #0x4]
 801a69e: 6818         	ldr	r0, [r3]
 801a6a0: 687b         	ldr	r3, [r7, #0x4]
 801a6a2: 3304         	adds	r3, #0x4
 801a6a4: 683a         	ldr	r2, [r7]
 801a6a6: 4619         	mov	r1, r3
 801a6a8: f7ff ffe2    	bl	0x801a670 <spi_write>   @ imm = #-0x3c
 801a6ac: 4603         	mov	r3, r0
; }
 801a6ae: 4618         	mov	r0, r3
 801a6b0: 3708         	adds	r7, #0x8
 801a6b2: 46bd         	mov	sp, r7
 801a6b4: bd80         	pop	{r7, pc}

0801a6b6 <spi_transceive>:
; {
 801a6b6: b580         	push	{r7, lr}
 801a6b8: b084         	sub	sp, #0x10
 801a6ba: af00         	add	r7, sp, #0x0
 801a6bc: 60f8         	str	r0, [r7, #0xc]
 801a6be: 60b9         	str	r1, [r7, #0x8]
 801a6c0: 607a         	str	r2, [r7, #0x4]
 801a6c2: 603b         	str	r3, [r7]
; 	return z_impl_spi_transceive(dev, config, tx_bufs, rx_bufs);
 801a6c4: 683b         	ldr	r3, [r7]
 801a6c6: 687a         	ldr	r2, [r7, #0x4]
 801a6c8: 68b9         	ldr	r1, [r7, #0x8]
 801a6ca: 68f8         	ldr	r0, [r7, #0xc]
 801a6cc: f7ff ffa6    	bl	0x801a61c <z_impl_spi_transceive> @ imm = #-0xb4
 801a6d0: 4603         	mov	r3, r0
; }
 801a6d2: 4618         	mov	r0, r3
 801a6d4: 3710         	adds	r7, #0x10
 801a6d6: 46bd         	mov	sp, r7
 801a6d8: bd80         	pop	{r7, pc}

0801a6da <bmi08x_accel_transceive_spi>:
; {
 801a6da: b580         	push	{r7, lr}
 801a6dc: b092         	sub	sp, #0x48
 801a6de: af00         	add	r7, sp, #0x0
 801a6e0: 60f8         	str	r0, [r7, #0xc]
 801a6e2: 607b         	str	r3, [r7, #0x4]
 801a6e4: 460b         	mov	r3, r1
 801a6e6: 72fb         	strb	r3, [r7, #0xb]
 801a6e8: 4613         	mov	r3, r2
 801a6ea: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_accel_config *bmi08x = dev->config;
 801a6ec: 68fb         	ldr	r3, [r7, #0xc]
 801a6ee: 685b         	ldr	r3, [r3, #0x4]
 801a6f0: 647b         	str	r3, [r7, #0x44]
; 	const struct spi_buf tx_buf[2] = {{.buf = &reg, .len = 1}, {.buf = data, .len = length}};
 801a6f2: f107 030b    	add.w	r3, r7, #0xb
 801a6f6: 637b         	str	r3, [r7, #0x34]
 801a6f8: 2301         	movs	r3, #0x1
 801a6fa: 63bb         	str	r3, [r7, #0x38]
 801a6fc: 687b         	ldr	r3, [r7, #0x4]
 801a6fe: 63fb         	str	r3, [r7, #0x3c]
 801a700: 6d3b         	ldr	r3, [r7, #0x50]
 801a702: 643b         	str	r3, [r7, #0x40]
; 	const struct spi_buf_set tx = {.buffers = tx_buf, .count = write ? 2 : 1};
 801a704: f107 0334    	add.w	r3, r7, #0x34
 801a708: 62fb         	str	r3, [r7, #0x2c]
 801a70a: 7abb         	ldrb	r3, [r7, #0xa]
 801a70c: 2b00         	cmp	r3, #0x0
 801a70e: d001         	beq	0x801a714 <bmi08x_accel_transceive_spi+0x3a> @ imm = #0x2
 801a710: 2302         	movs	r3, #0x2
 801a712: e000         	b	0x801a716 <bmi08x_accel_transceive_spi+0x3c> @ imm = #0x0
 801a714: 2301         	movs	r3, #0x1
 801a716: 633b         	str	r3, [r7, #0x30]
; 	if (!write) {
 801a718: 7abb         	ldrb	r3, [r7, #0xa]
 801a71a: f083 0301    	eor	r3, r3, #0x1
 801a71e: b2db         	uxtb	r3, r3
 801a720: 2b00         	cmp	r3, #0x0
 801a722: d017         	beq	0x801a754 <bmi08x_accel_transceive_spi+0x7a> @ imm = #0x2e
; 		const struct spi_buf rx_buf[2] = {{.buf = &dummy, .len = 2},
 801a724: f107 032a    	add.w	r3, r7, #0x2a
 801a728: 61bb         	str	r3, [r7, #0x18]
 801a72a: 2302         	movs	r3, #0x2
 801a72c: 61fb         	str	r3, [r7, #0x1c]
 801a72e: 687b         	ldr	r3, [r7, #0x4]
 801a730: 623b         	str	r3, [r7, #0x20]
 801a732: 6d3b         	ldr	r3, [r7, #0x50]
 801a734: 627b         	str	r3, [r7, #0x24]
; 		const struct spi_buf_set rx = {.buffers = rx_buf, .count = 2};
 801a736: f107 0318    	add.w	r3, r7, #0x18
 801a73a: 613b         	str	r3, [r7, #0x10]
 801a73c: 2302         	movs	r3, #0x2
 801a73e: 617b         	str	r3, [r7, #0x14]
; 		return spi_transceive_dt(&bmi08x->bus.spi, &tx, &rx);
 801a740: 6c7b         	ldr	r3, [r7, #0x44]
 801a742: f107 0210    	add.w	r2, r7, #0x10
 801a746: f107 012c    	add.w	r1, r7, #0x2c
 801a74a: 4618         	mov	r0, r3
 801a74c: f7ff ff7d    	bl	0x801a64a <spi_transceive_dt> @ imm = #-0x106
 801a750: 4603         	mov	r3, r0
 801a752: e007         	b	0x801a764 <bmi08x_accel_transceive_spi+0x8a> @ imm = #0xe
; 	return spi_write_dt(&bmi08x->bus.spi, &tx);
 801a754: 6c7b         	ldr	r3, [r7, #0x44]
 801a756: f107 022c    	add.w	r2, r7, #0x2c
 801a75a: 4611         	mov	r1, r2
 801a75c: 4618         	mov	r0, r3
 801a75e: f7ff ff98    	bl	0x801a692 <spi_write_dt> @ imm = #-0xd0
 801a762: 4603         	mov	r3, r0
; }
 801a764: 4618         	mov	r0, r3
 801a766: 3748         	adds	r7, #0x48
 801a768: 46bd         	mov	sp, r7
 801a76a: bd80         	pop	{r7, pc}

0801a76c <bmi08x_bus_check_spi>:
; {
 801a76c: b580         	push	{r7, lr}
 801a76e: b082         	sub	sp, #0x8
 801a770: af00         	add	r7, sp, #0x0
 801a772: 6078         	str	r0, [r7, #0x4]
; 	return spi_is_ready_dt(&bus->spi) ? 0 : -ENODEV;
 801a774: 687b         	ldr	r3, [r7, #0x4]
 801a776: 4618         	mov	r0, r3
 801a778: f7ff ff27    	bl	0x801a5ca <spi_is_ready_dt> @ imm = #-0x1b2
 801a77c: 4603         	mov	r3, r0
 801a77e: 2b00         	cmp	r3, #0x0
 801a780: d001         	beq	0x801a786 <bmi08x_bus_check_spi+0x1a> @ imm = #0x2
 801a782: 2300         	movs	r3, #0x0
 801a784: e001         	b	0x801a78a <bmi08x_bus_check_spi+0x1e> @ imm = #0x2
 801a786: f06f 0312    	mvn	r3, #0x12
; }
 801a78a: 4618         	mov	r0, r3
 801a78c: 3708         	adds	r7, #0x8
 801a78e: 46bd         	mov	sp, r7
 801a790: bd80         	pop	{r7, pc}

0801a792 <bmi08x_bus_check>:
; {
 801a792: b580         	push	{r7, lr}
 801a794: b084         	sub	sp, #0x10
 801a796: af00         	add	r7, sp, #0x0
 801a798: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 801a79a: 687b         	ldr	r3, [r7, #0x4]
 801a79c: 685b         	ldr	r3, [r3, #0x4]
 801a79e: 60fb         	str	r3, [r7, #0xc]
; 	return config->api->check(&config->bus);
 801a7a0: 68fb         	ldr	r3, [r7, #0xc]
 801a7a2: 699b         	ldr	r3, [r3, #0x18]
 801a7a4: 681b         	ldr	r3, [r3]
 801a7a6: 68fa         	ldr	r2, [r7, #0xc]
 801a7a8: 4610         	mov	r0, r2
 801a7aa: 4798         	blx	r3
 801a7ac: 4603         	mov	r3, r0
; }
 801a7ae: 4618         	mov	r0, r3
 801a7b0: 3710         	adds	r7, #0x10
 801a7b2: 46bd         	mov	sp, r7
 801a7b4: bd80         	pop	{r7, pc}

0801a7b6 <bmi08x_bus_init>:
; {
 801a7b6: b580         	push	{r7, lr}
 801a7b8: b084         	sub	sp, #0x10
 801a7ba: af00         	add	r7, sp, #0x0
 801a7bc: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_accel_config *config = dev->config;
 801a7be: 687b         	ldr	r3, [r7, #0x4]
 801a7c0: 685b         	ldr	r3, [r3, #0x4]
 801a7c2: 60fb         	str	r3, [r7, #0xc]
; 	if (config->api->bus_init) {
 801a7c4: 68fb         	ldr	r3, [r7, #0xc]
 801a7c6: 699b         	ldr	r3, [r3, #0x18]
 801a7c8: 685b         	ldr	r3, [r3, #0x4]
 801a7ca: 2b00         	cmp	r3, #0x0
 801a7cc: d006         	beq	0x801a7dc <bmi08x_bus_init+0x26> @ imm = #0xc
; 		return config->api->bus_init(dev);
 801a7ce: 68fb         	ldr	r3, [r7, #0xc]
 801a7d0: 699b         	ldr	r3, [r3, #0x18]
 801a7d2: 685b         	ldr	r3, [r3, #0x4]
 801a7d4: 6878         	ldr	r0, [r7, #0x4]
 801a7d6: 4798         	blx	r3
 801a7d8: 4603         	mov	r3, r0
 801a7da: e000         	b	0x801a7de <bmi08x_bus_init+0x28> @ imm = #0x0
; 	return 0;
 801a7dc: 2300         	movs	r3, #0x0
; }
 801a7de: 4618         	mov	r0, r3
 801a7e0: 3710         	adds	r7, #0x10
 801a7e2: 46bd         	mov	sp, r7
 801a7e4: bd80         	pop	{r7, pc}

0801a7e6 <bmi08x_accel_transceive>:
; {
 801a7e6: b590         	push	{r4, r7, lr}
 801a7e8: b089         	sub	sp, #0x24
 801a7ea: af02         	add	r7, sp, #0x8
 801a7ec: 60f8         	str	r0, [r7, #0xc]
 801a7ee: 607b         	str	r3, [r7, #0x4]
 801a7f0: 460b         	mov	r3, r1
 801a7f2: 72fb         	strb	r3, [r7, #0xb]
 801a7f4: 4613         	mov	r3, r2
 801a7f6: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_accel_config *config = dev->config;
 801a7f8: 68fb         	ldr	r3, [r7, #0xc]
 801a7fa: 685b         	ldr	r3, [r3, #0x4]
 801a7fc: 617b         	str	r3, [r7, #0x14]
; 	return config->api->transceive(dev, reg, write, data, length);
 801a7fe: 697b         	ldr	r3, [r7, #0x14]
 801a800: 699b         	ldr	r3, [r3, #0x18]
 801a802: 689c         	ldr	r4, [r3, #0x8]
 801a804: 7aba         	ldrb	r2, [r7, #0xa]
 801a806: 7af9         	ldrb	r1, [r7, #0xb]
 801a808: 6abb         	ldr	r3, [r7, #0x28]
 801a80a: 9300         	str	r3, [sp]
 801a80c: 687b         	ldr	r3, [r7, #0x4]
 801a80e: 68f8         	ldr	r0, [r7, #0xc]
 801a810: 47a0         	blx	r4
 801a812: 4603         	mov	r3, r0
; }
 801a814: 4618         	mov	r0, r3
 801a816: 371c         	adds	r7, #0x1c
 801a818: 46bd         	mov	sp, r7
 801a81a: bd90         	pop	{r4, r7, pc}

0801a81c <bmi08x_accel_read>:
; {
 801a81c: b580         	push	{r7, lr}
 801a81e: b086         	sub	sp, #0x18
 801a820: af02         	add	r7, sp, #0x8
 801a822: 60f8         	str	r0, [r7, #0xc]
 801a824: 607a         	str	r2, [r7, #0x4]
 801a826: 461a         	mov	r2, r3
 801a828: 460b         	mov	r3, r1
 801a82a: 72fb         	strb	r3, [r7, #0xb]
 801a82c: 4613         	mov	r3, r2
 801a82e: 72bb         	strb	r3, [r7, #0xa]
; 	return bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, data, len);
 801a830: 7afb         	ldrb	r3, [r7, #0xb]
 801a832: f063 037f    	orn	r3, r3, #0x7f
 801a836: b2d9         	uxtb	r1, r3
 801a838: 7abb         	ldrb	r3, [r7, #0xa]
 801a83a: 9300         	str	r3, [sp]
 801a83c: 687b         	ldr	r3, [r7, #0x4]
 801a83e: 2200         	movs	r2, #0x0
 801a840: 68f8         	ldr	r0, [r7, #0xc]
 801a842: f7ff ffd0    	bl	0x801a7e6 <bmi08x_accel_transceive> @ imm = #-0x60
 801a846: 4603         	mov	r3, r0
; }
 801a848: 4618         	mov	r0, r3
 801a84a: 3710         	adds	r7, #0x10
 801a84c: 46bd         	mov	sp, r7
 801a84e: bd80         	pop	{r7, pc}

0801a850 <bmi08x_accel_byte_read>:
; {
 801a850: b580         	push	{r7, lr}
 801a852: b086         	sub	sp, #0x18
 801a854: af02         	add	r7, sp, #0x8
 801a856: 60f8         	str	r0, [r7, #0xc]
 801a858: 460b         	mov	r3, r1
 801a85a: 607a         	str	r2, [r7, #0x4]
 801a85c: 72fb         	strb	r3, [r7, #0xb]
; 	return bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, byte, 1);
 801a85e: 7afb         	ldrb	r3, [r7, #0xb]
 801a860: f063 037f    	orn	r3, r3, #0x7f
 801a864: b2d9         	uxtb	r1, r3
 801a866: 2301         	movs	r3, #0x1
 801a868: 9300         	str	r3, [sp]
 801a86a: 687b         	ldr	r3, [r7, #0x4]
 801a86c: 2200         	movs	r2, #0x0
 801a86e: 68f8         	ldr	r0, [r7, #0xc]
 801a870: f7ff ffb9    	bl	0x801a7e6 <bmi08x_accel_transceive> @ imm = #-0x8e
 801a874: 4603         	mov	r3, r0
; }
 801a876: 4618         	mov	r0, r3
 801a878: 3710         	adds	r7, #0x10
 801a87a: 46bd         	mov	sp, r7
 801a87c: bd80         	pop	{r7, pc}

0801a87e <bmi08x_accel_word_read>:
; {
 801a87e: b580         	push	{r7, lr}
 801a880: b088         	sub	sp, #0x20
 801a882: af02         	add	r7, sp, #0x8
 801a884: 60f8         	str	r0, [r7, #0xc]
 801a886: 460b         	mov	r3, r1
 801a888: 607a         	str	r2, [r7, #0x4]
 801a88a: 72fb         	strb	r3, [r7, #0xb]
; 	ret = bmi08x_accel_transceive(dev, reg_addr | BIT(7), false, word, 2);
 801a88c: 7afb         	ldrb	r3, [r7, #0xb]
 801a88e: f063 037f    	orn	r3, r3, #0x7f
 801a892: b2d9         	uxtb	r1, r3
 801a894: 2302         	movs	r3, #0x2
 801a896: 9300         	str	r3, [sp]
 801a898: 687b         	ldr	r3, [r7, #0x4]
 801a89a: 2200         	movs	r2, #0x0
 801a89c: 68f8         	ldr	r0, [r7, #0xc]
 801a89e: f7ff ffa2    	bl	0x801a7e6 <bmi08x_accel_transceive> @ imm = #-0xbc
 801a8a2: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 801a8a4: 697b         	ldr	r3, [r7, #0x14]
 801a8a6: 2b00         	cmp	r3, #0x0
 801a8a8: d001         	beq	0x801a8ae <bmi08x_accel_word_read+0x30> @ imm = #0x2
; 		return ret;
 801a8aa: 697b         	ldr	r3, [r7, #0x14]
 801a8ac: e004         	b	0x801a8b8 <bmi08x_accel_word_read+0x3a> @ imm = #0x8
; 	*word = sys_le16_to_cpu(*word);
 801a8ae: 687b         	ldr	r3, [r7, #0x4]
 801a8b0: 881a         	ldrh	r2, [r3]
 801a8b2: 687b         	ldr	r3, [r7, #0x4]
 801a8b4: 801a         	strh	r2, [r3]
; 	return ret;
 801a8b6: 697b         	ldr	r3, [r7, #0x14]
; }
 801a8b8: 4618         	mov	r0, r3
 801a8ba: 3718         	adds	r7, #0x18
 801a8bc: 46bd         	mov	sp, r7
 801a8be: bd80         	pop	{r7, pc}

0801a8c0 <bmi08x_accel_byte_write>:
; {
 801a8c0: b580         	push	{r7, lr}
 801a8c2: b084         	sub	sp, #0x10
 801a8c4: af02         	add	r7, sp, #0x8
 801a8c6: 6078         	str	r0, [r7, #0x4]
 801a8c8: 460b         	mov	r3, r1
 801a8ca: 70fb         	strb	r3, [r7, #0x3]
 801a8cc: 4613         	mov	r3, r2
 801a8ce: 70bb         	strb	r3, [r7, #0x2]
; 	return bmi08x_accel_transceive(dev, reg_addr & 0x7F, true, &byte, 1);
 801a8d0: 78fb         	ldrb	r3, [r7, #0x3]
 801a8d2: f003 037f    	and	r3, r3, #0x7f
 801a8d6: b2d9         	uxtb	r1, r3
 801a8d8: 1cbb         	adds	r3, r7, #0x2
 801a8da: 2201         	movs	r2, #0x1
 801a8dc: 9200         	str	r2, [sp]
 801a8de: 2201         	movs	r2, #0x1
 801a8e0: 6878         	ldr	r0, [r7, #0x4]
 801a8e2: f7ff ff80    	bl	0x801a7e6 <bmi08x_accel_transceive> @ imm = #-0x100
 801a8e6: 4603         	mov	r3, r0
; }
 801a8e8: 4618         	mov	r0, r3
 801a8ea: 3708         	adds	r7, #0x8
 801a8ec: 46bd         	mov	sp, r7
 801a8ee: bd80         	pop	{r7, pc}

0801a8f0 <bmi08x_accel_reg_field_update>:
; {
 801a8f0: b580         	push	{r7, lr}
 801a8f2: b084         	sub	sp, #0x10
 801a8f4: af00         	add	r7, sp, #0x0
 801a8f6: 6078         	str	r0, [r7, #0x4]
 801a8f8: 4608         	mov	r0, r1
 801a8fa: 4611         	mov	r1, r2
 801a8fc: 461a         	mov	r2, r3
 801a8fe: 4603         	mov	r3, r0
 801a900: 70fb         	strb	r3, [r7, #0x3]
 801a902: 460b         	mov	r3, r1
 801a904: 70bb         	strb	r3, [r7, #0x2]
 801a906: 4613         	mov	r3, r2
 801a908: 707b         	strb	r3, [r7, #0x1]
; 	ret = bmi08x_accel_byte_read(dev, reg_addr, &old_val);
 801a90a: f107 020b    	add.w	r2, r7, #0xb
 801a90e: 78fb         	ldrb	r3, [r7, #0x3]
 801a910: 4619         	mov	r1, r3
 801a912: 6878         	ldr	r0, [r7, #0x4]
 801a914: f7ff ff9c    	bl	0x801a850 <bmi08x_accel_byte_read> @ imm = #-0xc8
 801a918: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 801a91a: 68fb         	ldr	r3, [r7, #0xc]
 801a91c: 2b00         	cmp	r3, #0x0
 801a91e: da01         	bge	0x801a924 <bmi08x_accel_reg_field_update+0x34> @ imm = #0x2
; 		return ret;
 801a920: 68fb         	ldr	r3, [r7, #0xc]
 801a922: e019         	b	0x801a958 <bmi08x_accel_reg_field_update+0x68> @ imm = #0x32
; 	return bmi08x_accel_byte_write(dev, reg_addr, (old_val & ~mask) | ((val << pos) & mask));
 801a924: f997 3001    	ldrsb.w	r3, [r7, #0x1]
 801a928: 43db         	mvns	r3, r3
 801a92a: b25a         	sxtb	r2, r3
 801a92c: 7afb         	ldrb	r3, [r7, #0xb]
 801a92e: b25b         	sxtb	r3, r3
 801a930: 4013         	ands	r3, r2
 801a932: b25a         	sxtb	r2, r3
 801a934: 7e39         	ldrb	r1, [r7, #0x18]
 801a936: 78bb         	ldrb	r3, [r7, #0x2]
 801a938: fa01 f303    	lsl.w	r3, r1, r3
 801a93c: b259         	sxtb	r1, r3
 801a93e: f997 3001    	ldrsb.w	r3, [r7, #0x1]
 801a942: 400b         	ands	r3, r1
 801a944: b25b         	sxtb	r3, r3
 801a946: 4313         	orrs	r3, r2
 801a948: b25b         	sxtb	r3, r3
 801a94a: b2da         	uxtb	r2, r3
 801a94c: 78fb         	ldrb	r3, [r7, #0x3]
 801a94e: 4619         	mov	r1, r3
 801a950: 6878         	ldr	r0, [r7, #0x4]
 801a952: f7ff ffb5    	bl	0x801a8c0 <bmi08x_accel_byte_write> @ imm = #-0x96
 801a956: 4603         	mov	r3, r0
; }
 801a958: 4618         	mov	r0, r3
 801a95a: 3710         	adds	r7, #0x10
 801a95c: 46bd         	mov	sp, r7
 801a95e: bd80         	pop	{r7, pc}

0801a960 <bmi08x_acc_odr_set>:
; {
 801a960: b580         	push	{r7, lr}
 801a962: b086         	sub	sp, #0x18
 801a964: af02         	add	r7, sp, #0x8
 801a966: 6078         	str	r0, [r7, #0x4]
 801a968: 460b         	mov	r3, r1
 801a96a: 807b         	strh	r3, [r7, #0x2]
 801a96c: 4613         	mov	r3, r2
 801a96e: 803b         	strh	r3, [r7]
; 	int odr = bmi08x_freq_to_odr_val(freq_int, freq_milli);
 801a970: 883a         	ldrh	r2, [r7]
 801a972: 887b         	ldrh	r3, [r7, #0x2]
 801a974: 4611         	mov	r1, r2
 801a976: 4618         	mov	r0, r3
 801a978: f7f0 fbc8    	bl	0x800b10c <bmi08x_freq_to_odr_val> @ imm = #-0xf870
 801a97c: 60f8         	str	r0, [r7, #0xc]
; 	if (odr < BMI08X_ACCEL_ODR_12_5_HZ) {
 801a97e: 68fb         	ldr	r3, [r7, #0xc]
 801a980: 2b04         	cmp	r3, #0x4
 801a982: dc01         	bgt	0x801a988 <bmi08x_acc_odr_set+0x28> @ imm = #0x2
; 		return odr;
 801a984: 68fb         	ldr	r3, [r7, #0xc]
 801a986: e009         	b	0x801a99c <bmi08x_acc_odr_set+0x3c> @ imm = #0x12
; 	return bmi08x_accel_reg_field_update(dev, BMI08X_REG_ACCEL_CONF, 0, BMI08X_ACCEL_ODR_MASK,
 801a988: 68fb         	ldr	r3, [r7, #0xc]
 801a98a: b2db         	uxtb	r3, r3
 801a98c: 9300         	str	r3, [sp]
 801a98e: 230f         	movs	r3, #0xf
 801a990: 2200         	movs	r2, #0x0
 801a992: 2140         	movs	r1, #0x40
 801a994: 6878         	ldr	r0, [r7, #0x4]
 801a996: f7ff ffab    	bl	0x801a8f0 <bmi08x_accel_reg_field_update> @ imm = #-0xaa
 801a99a: 4603         	mov	r3, r0
; }
 801a99c: 4618         	mov	r0, r3
 801a99e: 3710         	adds	r7, #0x10
 801a9a0: 46bd         	mov	sp, r7
 801a9a2: bd80         	pop	{r7, pc}

0801a9a4 <bmi08x_channel_convert>:
; {
 801a9a4: b580         	push	{r7, lr}
 801a9a6: b086         	sub	sp, #0x18
 801a9a8: af00         	add	r7, sp, #0x0
 801a9aa: 60ba         	str	r2, [r7, #0x8]
 801a9ac: 607b         	str	r3, [r7, #0x4]
 801a9ae: 4603         	mov	r3, r0
 801a9b0: 81fb         	strh	r3, [r7, #0xe]
 801a9b2: 460b         	mov	r3, r1
 801a9b4: 81bb         	strh	r3, [r7, #0xc]
; 	switch (chan) {
 801a9b6: 89fb         	ldrh	r3, [r7, #0xe]
 801a9b8: 2b02         	cmp	r3, #0x2
 801a9ba: d010         	beq	0x801a9de <bmi08x_channel_convert+0x3a> @ imm = #0x20
 801a9bc: 2b02         	cmp	r3, #0x2
 801a9be: dc13         	bgt	0x801a9e8 <bmi08x_channel_convert+0x44> @ imm = #0x26
 801a9c0: 2b00         	cmp	r3, #0x0
 801a9c2: d002         	beq	0x801a9ca <bmi08x_channel_convert+0x26> @ imm = #0x4
 801a9c4: 2b01         	cmp	r3, #0x1
 801a9c6: d005         	beq	0x801a9d4 <bmi08x_channel_convert+0x30> @ imm = #0xa
 801a9c8: e00e         	b	0x801a9e8 <bmi08x_channel_convert+0x44> @ imm = #0x1c
; 		ofs_start = ofs_stop = 0U;
 801a9ca: 2300         	movs	r3, #0x0
 801a9cc: 74bb         	strb	r3, [r7, #0x12]
 801a9ce: 7cbb         	ldrb	r3, [r7, #0x12]
 801a9d0: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 801a9d2: e00e         	b	0x801a9f2 <bmi08x_channel_convert+0x4e> @ imm = #0x1c
; 		ofs_start = ofs_stop = 1U;
 801a9d4: 2301         	movs	r3, #0x1
 801a9d6: 74bb         	strb	r3, [r7, #0x12]
 801a9d8: 7cbb         	ldrb	r3, [r7, #0x12]
 801a9da: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 801a9dc: e009         	b	0x801a9f2 <bmi08x_channel_convert+0x4e> @ imm = #0x12
; 		ofs_start = ofs_stop = 2U;
 801a9de: 2302         	movs	r3, #0x2
 801a9e0: 74bb         	strb	r3, [r7, #0x12]
 801a9e2: 7cbb         	ldrb	r3, [r7, #0x12]
 801a9e4: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 801a9e6: e004         	b	0x801a9f2 <bmi08x_channel_convert+0x4e> @ imm = #0x8
; 		ofs_start = 0U;
 801a9e8: 2300         	movs	r3, #0x0
 801a9ea: 74fb         	strb	r3, [r7, #0x13]
; 		ofs_stop = 2U;
 801a9ec: 2302         	movs	r3, #0x2
 801a9ee: 74bb         	strb	r3, [r7, #0x12]
; 		break;
 801a9f0: bf00         	nop
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 801a9f2: 7cfb         	ldrb	r3, [r7, #0x13]
 801a9f4: 617b         	str	r3, [r7, #0x14]
 801a9f6: e010         	b	0x801aa1a <bmi08x_channel_convert+0x76> @ imm = #0x20
; 		bmi08x_to_fixed_point(raw_xyz[i], scale, val);
 801a9f8: 697b         	ldr	r3, [r7, #0x14]
 801a9fa: 005b         	lsls	r3, r3, #0x1
 801a9fc: 68ba         	ldr	r2, [r7, #0x8]
 801a9fe: 4413         	add	r3, r2
 801aa00: 881b         	ldrh	r3, [r3]
 801aa02: b21b         	sxth	r3, r3
 801aa04: 89b9         	ldrh	r1, [r7, #0xc]
 801aa06: 687a         	ldr	r2, [r7, #0x4]
 801aa08: 4618         	mov	r0, r3
 801aa0a: f7ef fcdb    	bl	0x800a3c4 <bmi08x_to_fixed_point> @ imm = #-0x1064a
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 801aa0e: 697b         	ldr	r3, [r7, #0x14]
 801aa10: 3301         	adds	r3, #0x1
 801aa12: 617b         	str	r3, [r7, #0x14]
 801aa14: 687b         	ldr	r3, [r7, #0x4]
 801aa16: 3308         	adds	r3, #0x8
 801aa18: 607b         	str	r3, [r7, #0x4]
 801aa1a: 7cbb         	ldrb	r3, [r7, #0x12]
 801aa1c: 697a         	ldr	r2, [r7, #0x14]
 801aa1e: 429a         	cmp	r2, r3
 801aa20: ddea         	ble	0x801a9f8 <bmi08x_channel_convert+0x54> @ imm = #-0x2c
; }
 801aa22: bf00         	nop
 801aa24: bf00         	nop
 801aa26: 3718         	adds	r7, #0x18
 801aa28: 46bd         	mov	sp, r7
 801aa2a: bd80         	pop	{r7, pc}

0801aa2c <bmi08x_acc_channel_get>:
; {
 801aa2c: b580         	push	{r7, lr}
 801aa2e: b086         	sub	sp, #0x18
 801aa30: af00         	add	r7, sp, #0x0
 801aa32: 60f8         	str	r0, [r7, #0xc]
 801aa34: 460b         	mov	r3, r1
 801aa36: 607a         	str	r2, [r7, #0x4]
 801aa38: 817b         	strh	r3, [r7, #0xa]
; 	struct bmi08x_accel_data *data = dev->data;
 801aa3a: 68fb         	ldr	r3, [r7, #0xc]
 801aa3c: 691b         	ldr	r3, [r3, #0x10]
 801aa3e: 617b         	str	r3, [r7, #0x14]
; 	bmi08x_channel_convert(chan, data->scale, data->acc_sample, val);
 801aa40: 697b         	ldr	r3, [r7, #0x14]
 801aa42: 8a59         	ldrh	r1, [r3, #0x12]
 801aa44: 697b         	ldr	r3, [r7, #0x14]
 801aa46: f103 020c    	add.w	r2, r3, #0xc
 801aa4a: 8978         	ldrh	r0, [r7, #0xa]
 801aa4c: 687b         	ldr	r3, [r7, #0x4]
 801aa4e: f7ff ffa9    	bl	0x801a9a4 <bmi08x_channel_convert> @ imm = #-0xae
; }
 801aa52: bf00         	nop
 801aa54: 3718         	adds	r7, #0x18
 801aa56: 46bd         	mov	sp, r7
 801aa58: bd80         	pop	{r7, pc}

0801aa5a <device_is_ready>:
; {
 801aa5a: b580         	push	{r7, lr}
 801aa5c: b082         	sub	sp, #0x8
 801aa5e: af00         	add	r7, sp, #0x0
 801aa60: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801aa62: 6878         	ldr	r0, [r7, #0x4]
 801aa64: f003 fab4    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x3568
 801aa68: 4603         	mov	r3, r0
; }
 801aa6a: 4618         	mov	r0, r3
 801aa6c: 3708         	adds	r7, #0x8
 801aa6e: 46bd         	mov	sp, r7
 801aa70: bd80         	pop	{r7, pc}

0801aa72 <k_msleep>:
; {
 801aa72: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801aa76: b082         	sub	sp, #0x8
 801aa78: af00         	add	r7, sp, #0x0
 801aa7a: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 801aa7c: 6879         	ldr	r1, [r7, #0x4]
 801aa7e: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 801aa82: 17c8         	asrs	r0, r1, #0x1f
 801aa84: 4688         	mov	r8, r1
 801aa86: 4681         	mov	r9, r0
 801aa88: 4640         	mov	r0, r8
 801aa8a: 4649         	mov	r1, r9
 801aa8c: f04f 0400    	mov.w	r4, #0x0
 801aa90: f04f 0500    	mov.w	r5, #0x0
 801aa94: 008d         	lsls	r5, r1, #0x2
 801aa96: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 801aa9a: 0084         	lsls	r4, r0, #0x2
 801aa9c: 4620         	mov	r0, r4
 801aa9e: 4629         	mov	r1, r5
 801aaa0: eb10 0208    	adds.w	r2, r0, r8
 801aaa4: eb41 0309    	adc.w	r3, r1, r9
 801aaa8: eb12 0a02    	adds.w	r10, r2, r2
 801aaac: eb43 0b03    	adc.w	r11, r3, r3
 801aab0: 4652         	mov	r2, r10
 801aab2: 465b         	mov	r3, r11
 801aab4: 4610         	mov	r0, r2
 801aab6: 4619         	mov	r1, r3
 801aab8: f000 f807    	bl	0x801aaca <k_sleep>     @ imm = #0xe
 801aabc: 4601         	mov	r1, r0
 801aabe: 460b         	mov	r3, r1
; }
 801aac0: 4618         	mov	r0, r3
 801aac2: 3708         	adds	r7, #0x8
 801aac4: 46bd         	mov	sp, r7
 801aac6: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801aaca <k_sleep>:
; {
 801aaca: b580         	push	{r7, lr}
 801aacc: b082         	sub	sp, #0x8
 801aace: af00         	add	r7, sp, #0x0
 801aad0: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 801aad4: e9d7 0100    	ldrd	r0, r1, [r7]
 801aad8: f7f7 fb7a    	bl	0x80121d0 <z_impl_k_sleep> @ imm = #-0x890c
 801aadc: 4603         	mov	r3, r0
; }
 801aade: 4618         	mov	r0, r3
 801aae0: 3708         	adds	r7, #0x8
 801aae2: 46bd         	mov	sp, r7
 801aae4: bd80         	pop	{r7, pc}

0801aae6 <z_log_msg_runtime_create>:
; {
 801aae6: b580         	push	{r7, lr}
 801aae8: b08a         	sub	sp, #0x28
 801aaea: af04         	add	r7, sp, #0x10
 801aaec: 60b9         	str	r1, [r7, #0x8]
 801aaee: 607b         	str	r3, [r7, #0x4]
 801aaf0: 4603         	mov	r3, r0
 801aaf2: 73fb         	strb	r3, [r7, #0xf]
 801aaf4: 4613         	mov	r3, r2
 801aaf6: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801aaf8: f107 032c    	add.w	r3, r7, #0x2c
 801aafc: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801aafe: 7bba         	ldrb	r2, [r7, #0xe]
 801ab00: 7bf8         	ldrb	r0, [r7, #0xf]
 801ab02: 697b         	ldr	r3, [r7, #0x14]
 801ab04: 9303         	str	r3, [sp, #0xc]
 801ab06: 6abb         	ldr	r3, [r7, #0x28]
 801ab08: 9302         	str	r3, [sp, #0x8]
 801ab0a: 6a7b         	ldr	r3, [r7, #0x24]
 801ab0c: 9301         	str	r3, [sp, #0x4]
 801ab0e: 6a3b         	ldr	r3, [r7, #0x20]
 801ab10: 9300         	str	r3, [sp]
 801ab12: 687b         	ldr	r3, [r7, #0x4]
 801ab14: 68b9         	ldr	r1, [r7, #0x8]
 801ab16: f7ea fd2d    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x155a6
; }
 801ab1a: bf00         	nop
 801ab1c: 3718         	adds	r7, #0x18
 801ab1e: 46bd         	mov	sp, r7
 801ab20: bd80         	pop	{r7, pc}

0801ab22 <gpio_is_ready_dt>:
; {
 801ab22: b580         	push	{r7, lr}
 801ab24: b082         	sub	sp, #0x8
 801ab26: af00         	add	r7, sp, #0x0
 801ab28: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 801ab2a: 687b         	ldr	r3, [r7, #0x4]
 801ab2c: 681b         	ldr	r3, [r3]
 801ab2e: 4618         	mov	r0, r3
 801ab30: f7ff ff93    	bl	0x801aa5a <device_is_ready> @ imm = #-0xda
 801ab34: 4603         	mov	r3, r0
; }
 801ab36: 4618         	mov	r0, r3
 801ab38: 3708         	adds	r7, #0x8
 801ab3a: 46bd         	mov	sp, r7
 801ab3c: bd80         	pop	{r7, pc}

0801ab3e <spi_cs_is_gpio>:
; {
 801ab3e: b480         	push	{r7}
 801ab40: b083         	sub	sp, #0xc
 801ab42: af00         	add	r7, sp, #0x0
 801ab44: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 801ab46: 687b         	ldr	r3, [r7, #0x4]
 801ab48: 689b         	ldr	r3, [r3, #0x8]
 801ab4a: 2b00         	cmp	r3, #0x0
 801ab4c: bf14         	ite	ne
 801ab4e: 2301         	movne	r3, #0x1
 801ab50: 2300         	moveq	r3, #0x0
 801ab52: b2db         	uxtb	r3, r3
; }
 801ab54: 4618         	mov	r0, r3
 801ab56: 370c         	adds	r7, #0xc
 801ab58: 46bd         	mov	sp, r7
 801ab5a: f85d 7b04    	ldr	r7, [sp], #4
 801ab5e: 4770         	bx	lr

0801ab60 <spi_cs_is_gpio_dt>:
; {
 801ab60: b580         	push	{r7, lr}
 801ab62: b082         	sub	sp, #0x8
 801ab64: af00         	add	r7, sp, #0x0
 801ab66: 6078         	str	r0, [r7, #0x4]
; 	return spi_cs_is_gpio(&spec->config);
 801ab68: 687b         	ldr	r3, [r7, #0x4]
 801ab6a: 3304         	adds	r3, #0x4
 801ab6c: 4618         	mov	r0, r3
 801ab6e: f7ff ffe6    	bl	0x801ab3e <spi_cs_is_gpio> @ imm = #-0x34
 801ab72: 4603         	mov	r3, r0
; }
 801ab74: 4618         	mov	r0, r3
 801ab76: 3708         	adds	r7, #0x8
 801ab78: 46bd         	mov	sp, r7
 801ab7a: bd80         	pop	{r7, pc}

0801ab7c <spi_is_ready_dt>:
; {
 801ab7c: b580         	push	{r7, lr}
 801ab7e: b082         	sub	sp, #0x8
 801ab80: af00         	add	r7, sp, #0x0
 801ab82: 6078         	str	r0, [r7, #0x4]
; 	if (!device_is_ready(spec->bus)) {
 801ab84: 687b         	ldr	r3, [r7, #0x4]
 801ab86: 681b         	ldr	r3, [r3]
 801ab88: 4618         	mov	r0, r3
 801ab8a: f7ff ff66    	bl	0x801aa5a <device_is_ready> @ imm = #-0x134
 801ab8e: 4603         	mov	r3, r0
 801ab90: f083 0301    	eor	r3, r3, #0x1
 801ab94: b2db         	uxtb	r3, r3
 801ab96: 2b00         	cmp	r3, #0x0
 801ab98: d001         	beq	0x801ab9e <spi_is_ready_dt+0x22> @ imm = #0x2
; 		return false;
 801ab9a: 2300         	movs	r3, #0x0
 801ab9c: e013         	b	0x801abc6 <spi_is_ready_dt+0x4a> @ imm = #0x26
; 	if (spi_cs_is_gpio_dt(spec) &&
 801ab9e: 6878         	ldr	r0, [r7, #0x4]
 801aba0: f7ff ffde    	bl	0x801ab60 <spi_cs_is_gpio_dt> @ imm = #-0x44
 801aba4: 4603         	mov	r3, r0
 801aba6: 2b00         	cmp	r3, #0x0
 801aba8: d00c         	beq	0x801abc4 <spi_is_ready_dt+0x48> @ imm = #0x18
; 	    !gpio_is_ready_dt(&spec->config.cs.gpio)) {
 801abaa: 687b         	ldr	r3, [r7, #0x4]
 801abac: 330c         	adds	r3, #0xc
 801abae: 4618         	mov	r0, r3
 801abb0: f7ff ffb7    	bl	0x801ab22 <gpio_is_ready_dt> @ imm = #-0x92
 801abb4: 4603         	mov	r3, r0
 801abb6: f083 0301    	eor	r3, r3, #0x1
 801abba: b2db         	uxtb	r3, r3
; 	if (spi_cs_is_gpio_dt(spec) &&
 801abbc: 2b00         	cmp	r3, #0x0
 801abbe: d001         	beq	0x801abc4 <spi_is_ready_dt+0x48> @ imm = #0x2
; 		return false;
 801abc0: 2300         	movs	r3, #0x0
 801abc2: e000         	b	0x801abc6 <spi_is_ready_dt+0x4a> @ imm = #0x0
; 	return true;
 801abc4: 2301         	movs	r3, #0x1
; }
 801abc6: 4618         	mov	r0, r3
 801abc8: 3708         	adds	r7, #0x8
 801abca: 46bd         	mov	sp, r7
 801abcc: bd80         	pop	{r7, pc}

0801abce <z_impl_spi_transceive>:
; {
 801abce: b590         	push	{r4, r7, lr}
 801abd0: b087         	sub	sp, #0x1c
 801abd2: af00         	add	r7, sp, #0x0
 801abd4: 60f8         	str	r0, [r7, #0xc]
 801abd6: 60b9         	str	r1, [r7, #0x8]
 801abd8: 607a         	str	r2, [r7, #0x4]
 801abda: 603b         	str	r3, [r7]
; 	const struct spi_driver_api *api =
 801abdc: 68fb         	ldr	r3, [r7, #0xc]
 801abde: 689b         	ldr	r3, [r3, #0x8]
 801abe0: 617b         	str	r3, [r7, #0x14]
; 	ret = api->transceive(dev, config, tx_bufs, rx_bufs);
 801abe2: 697b         	ldr	r3, [r7, #0x14]
 801abe4: 681c         	ldr	r4, [r3]
 801abe6: 683b         	ldr	r3, [r7]
 801abe8: 687a         	ldr	r2, [r7, #0x4]
 801abea: 68b9         	ldr	r1, [r7, #0x8]
 801abec: 68f8         	ldr	r0, [r7, #0xc]
 801abee: 47a0         	blx	r4
 801abf0: 6138         	str	r0, [r7, #0x10]
; 	return ret;
 801abf2: 693b         	ldr	r3, [r7, #0x10]
; }
 801abf4: 4618         	mov	r0, r3
 801abf6: 371c         	adds	r7, #0x1c
 801abf8: 46bd         	mov	sp, r7
 801abfa: bd90         	pop	{r4, r7, pc}

0801abfc <spi_transceive_dt>:
; {
 801abfc: b580         	push	{r7, lr}
 801abfe: b084         	sub	sp, #0x10
 801ac00: af00         	add	r7, sp, #0x0
 801ac02: 60f8         	str	r0, [r7, #0xc]
 801ac04: 60b9         	str	r1, [r7, #0x8]
 801ac06: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(spec->bus, &spec->config, tx_bufs, rx_bufs);
 801ac08: 68fb         	ldr	r3, [r7, #0xc]
 801ac0a: 6818         	ldr	r0, [r3]
 801ac0c: 68fb         	ldr	r3, [r7, #0xc]
 801ac0e: 1d19         	adds	r1, r3, #0x4
 801ac10: 687b         	ldr	r3, [r7, #0x4]
 801ac12: 68ba         	ldr	r2, [r7, #0x8]
 801ac14: f000 f828    	bl	0x801ac68 <spi_transceive> @ imm = #0x50
 801ac18: 4603         	mov	r3, r0
; }
 801ac1a: 4618         	mov	r0, r3
 801ac1c: 3710         	adds	r7, #0x10
 801ac1e: 46bd         	mov	sp, r7
 801ac20: bd80         	pop	{r7, pc}

0801ac22 <spi_write>:
; {
 801ac22: b580         	push	{r7, lr}
 801ac24: b084         	sub	sp, #0x10
 801ac26: af00         	add	r7, sp, #0x0
 801ac28: 60f8         	str	r0, [r7, #0xc]
 801ac2a: 60b9         	str	r1, [r7, #0x8]
 801ac2c: 607a         	str	r2, [r7, #0x4]
; 	return spi_transceive(dev, config, tx_bufs, NULL);
 801ac2e: 2300         	movs	r3, #0x0
 801ac30: 687a         	ldr	r2, [r7, #0x4]
 801ac32: 68b9         	ldr	r1, [r7, #0x8]
 801ac34: 68f8         	ldr	r0, [r7, #0xc]
 801ac36: f000 f817    	bl	0x801ac68 <spi_transceive> @ imm = #0x2e
 801ac3a: 4603         	mov	r3, r0
; }
 801ac3c: 4618         	mov	r0, r3
 801ac3e: 3710         	adds	r7, #0x10
 801ac40: 46bd         	mov	sp, r7
 801ac42: bd80         	pop	{r7, pc}

0801ac44 <spi_write_dt>:
; {
 801ac44: b580         	push	{r7, lr}
 801ac46: b082         	sub	sp, #0x8
 801ac48: af00         	add	r7, sp, #0x0
 801ac4a: 6078         	str	r0, [r7, #0x4]
 801ac4c: 6039         	str	r1, [r7]
; 	return spi_write(spec->bus, &spec->config, tx_bufs);
 801ac4e: 687b         	ldr	r3, [r7, #0x4]
 801ac50: 6818         	ldr	r0, [r3]
 801ac52: 687b         	ldr	r3, [r7, #0x4]
 801ac54: 3304         	adds	r3, #0x4
 801ac56: 683a         	ldr	r2, [r7]
 801ac58: 4619         	mov	r1, r3
 801ac5a: f7ff ffe2    	bl	0x801ac22 <spi_write>   @ imm = #-0x3c
 801ac5e: 4603         	mov	r3, r0
; }
 801ac60: 4618         	mov	r0, r3
 801ac62: 3708         	adds	r7, #0x8
 801ac64: 46bd         	mov	sp, r7
 801ac66: bd80         	pop	{r7, pc}

0801ac68 <spi_transceive>:
; {
 801ac68: b580         	push	{r7, lr}
 801ac6a: b084         	sub	sp, #0x10
 801ac6c: af00         	add	r7, sp, #0x0
 801ac6e: 60f8         	str	r0, [r7, #0xc]
 801ac70: 60b9         	str	r1, [r7, #0x8]
 801ac72: 607a         	str	r2, [r7, #0x4]
 801ac74: 603b         	str	r3, [r7]
; 	return z_impl_spi_transceive(dev, config, tx_bufs, rx_bufs);
 801ac76: 683b         	ldr	r3, [r7]
 801ac78: 687a         	ldr	r2, [r7, #0x4]
 801ac7a: 68b9         	ldr	r1, [r7, #0x8]
 801ac7c: 68f8         	ldr	r0, [r7, #0xc]
 801ac7e: f7ff ffa6    	bl	0x801abce <z_impl_spi_transceive> @ imm = #-0xb4
 801ac82: 4603         	mov	r3, r0
; }
 801ac84: 4618         	mov	r0, r3
 801ac86: 3710         	adds	r7, #0x10
 801ac88: 46bd         	mov	sp, r7
 801ac8a: bd80         	pop	{r7, pc}

0801ac8c <bmi08x_gyro_transceive_spi>:
; {
 801ac8c: b580         	push	{r7, lr}
 801ac8e: b092         	sub	sp, #0x48
 801ac90: af00         	add	r7, sp, #0x0
 801ac92: 60f8         	str	r0, [r7, #0xc]
 801ac94: 607b         	str	r3, [r7, #0x4]
 801ac96: 460b         	mov	r3, r1
 801ac98: 72fb         	strb	r3, [r7, #0xb]
 801ac9a: 4613         	mov	r3, r2
 801ac9c: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_gyro_config *bmi08x = dev->config;
 801ac9e: 68fb         	ldr	r3, [r7, #0xc]
 801aca0: 685b         	ldr	r3, [r3, #0x4]
 801aca2: 647b         	str	r3, [r7, #0x44]
; 	const struct spi_buf tx_buf[2] = {{.buf = &reg, .len = 1}, {.buf = data, .len = length}};
 801aca4: f107 030b    	add.w	r3, r7, #0xb
 801aca8: 637b         	str	r3, [r7, #0x34]
 801acaa: 2301         	movs	r3, #0x1
 801acac: 63bb         	str	r3, [r7, #0x38]
 801acae: 687b         	ldr	r3, [r7, #0x4]
 801acb0: 63fb         	str	r3, [r7, #0x3c]
 801acb2: 6d3b         	ldr	r3, [r7, #0x50]
 801acb4: 643b         	str	r3, [r7, #0x40]
; 	const struct spi_buf_set tx = {.buffers = tx_buf, .count = write ? 2 : 1};
 801acb6: f107 0334    	add.w	r3, r7, #0x34
 801acba: 62fb         	str	r3, [r7, #0x2c]
 801acbc: 7abb         	ldrb	r3, [r7, #0xa]
 801acbe: 2b00         	cmp	r3, #0x0
 801acc0: d001         	beq	0x801acc6 <bmi08x_gyro_transceive_spi+0x3a> @ imm = #0x2
 801acc2: 2302         	movs	r3, #0x2
 801acc4: e000         	b	0x801acc8 <bmi08x_gyro_transceive_spi+0x3c> @ imm = #0x0
 801acc6: 2301         	movs	r3, #0x1
 801acc8: 633b         	str	r3, [r7, #0x30]
; 	if (!write) {
 801acca: 7abb         	ldrb	r3, [r7, #0xa]
 801accc: f083 0301    	eor	r3, r3, #0x1
 801acd0: b2db         	uxtb	r3, r3
 801acd2: 2b00         	cmp	r3, #0x0
 801acd4: d017         	beq	0x801ad06 <bmi08x_gyro_transceive_spi+0x7a> @ imm = #0x2e
; 		const struct spi_buf rx_buf[2] = {{.buf = &dummy, .len = 1},
 801acd6: f107 032a    	add.w	r3, r7, #0x2a
 801acda: 61bb         	str	r3, [r7, #0x18]
 801acdc: 2301         	movs	r3, #0x1
 801acde: 61fb         	str	r3, [r7, #0x1c]
 801ace0: 687b         	ldr	r3, [r7, #0x4]
 801ace2: 623b         	str	r3, [r7, #0x20]
 801ace4: 6d3b         	ldr	r3, [r7, #0x50]
 801ace6: 627b         	str	r3, [r7, #0x24]
; 		const struct spi_buf_set rx = {.buffers = rx_buf, .count = 2};
 801ace8: f107 0318    	add.w	r3, r7, #0x18
 801acec: 613b         	str	r3, [r7, #0x10]
 801acee: 2302         	movs	r3, #0x2
 801acf0: 617b         	str	r3, [r7, #0x14]
; 		return spi_transceive_dt(&bmi08x->bus.spi, &tx, &rx);
 801acf2: 6c7b         	ldr	r3, [r7, #0x44]
 801acf4: f107 0210    	add.w	r2, r7, #0x10
 801acf8: f107 012c    	add.w	r1, r7, #0x2c
 801acfc: 4618         	mov	r0, r3
 801acfe: f7ff ff7d    	bl	0x801abfc <spi_transceive_dt> @ imm = #-0x106
 801ad02: 4603         	mov	r3, r0
 801ad04: e007         	b	0x801ad16 <bmi08x_gyro_transceive_spi+0x8a> @ imm = #0xe
; 	return spi_write_dt(&bmi08x->bus.spi, &tx);
 801ad06: 6c7b         	ldr	r3, [r7, #0x44]
 801ad08: f107 022c    	add.w	r2, r7, #0x2c
 801ad0c: 4611         	mov	r1, r2
 801ad0e: 4618         	mov	r0, r3
 801ad10: f7ff ff98    	bl	0x801ac44 <spi_write_dt> @ imm = #-0xd0
 801ad14: 4603         	mov	r3, r0
; }
 801ad16: 4618         	mov	r0, r3
 801ad18: 3748         	adds	r7, #0x48
 801ad1a: 46bd         	mov	sp, r7
 801ad1c: bd80         	pop	{r7, pc}

0801ad1e <bmi08x_bus_check_spi>:
; {
 801ad1e: b580         	push	{r7, lr}
 801ad20: b082         	sub	sp, #0x8
 801ad22: af00         	add	r7, sp, #0x0
 801ad24: 6078         	str	r0, [r7, #0x4]
; 	return spi_is_ready_dt(&bus->spi) ? 0 : -ENODEV;
 801ad26: 687b         	ldr	r3, [r7, #0x4]
 801ad28: 4618         	mov	r0, r3
 801ad2a: f7ff ff27    	bl	0x801ab7c <spi_is_ready_dt> @ imm = #-0x1b2
 801ad2e: 4603         	mov	r3, r0
 801ad30: 2b00         	cmp	r3, #0x0
 801ad32: d001         	beq	0x801ad38 <bmi08x_bus_check_spi+0x1a> @ imm = #0x2
 801ad34: 2300         	movs	r3, #0x0
 801ad36: e001         	b	0x801ad3c <bmi08x_bus_check_spi+0x1e> @ imm = #0x2
 801ad38: f06f 0312    	mvn	r3, #0x12
; }
 801ad3c: 4618         	mov	r0, r3
 801ad3e: 3708         	adds	r7, #0x8
 801ad40: 46bd         	mov	sp, r7
 801ad42: bd80         	pop	{r7, pc}

0801ad44 <bmi08x_bus_check>:
; {
 801ad44: b580         	push	{r7, lr}
 801ad46: b084         	sub	sp, #0x10
 801ad48: af00         	add	r7, sp, #0x0
 801ad4a: 6078         	str	r0, [r7, #0x4]
; 	const struct bmi08x_gyro_config *config = dev->config;
 801ad4c: 687b         	ldr	r3, [r7, #0x4]
 801ad4e: 685b         	ldr	r3, [r3, #0x4]
 801ad50: 60fb         	str	r3, [r7, #0xc]
; 	return config->api->check(&config->bus);
 801ad52: 68fb         	ldr	r3, [r7, #0xc]
 801ad54: 699b         	ldr	r3, [r3, #0x18]
 801ad56: 681b         	ldr	r3, [r3]
 801ad58: 68fa         	ldr	r2, [r7, #0xc]
 801ad5a: 4610         	mov	r0, r2
 801ad5c: 4798         	blx	r3
 801ad5e: 4603         	mov	r3, r0
; }
 801ad60: 4618         	mov	r0, r3
 801ad62: 3710         	adds	r7, #0x10
 801ad64: 46bd         	mov	sp, r7
 801ad66: bd80         	pop	{r7, pc}

0801ad68 <bmi08x_gyro_transceive>:
; {
 801ad68: b590         	push	{r4, r7, lr}
 801ad6a: b089         	sub	sp, #0x24
 801ad6c: af02         	add	r7, sp, #0x8
 801ad6e: 60f8         	str	r0, [r7, #0xc]
 801ad70: 607b         	str	r3, [r7, #0x4]
 801ad72: 460b         	mov	r3, r1
 801ad74: 72fb         	strb	r3, [r7, #0xb]
 801ad76: 4613         	mov	r3, r2
 801ad78: 72bb         	strb	r3, [r7, #0xa]
; 	const struct bmi08x_gyro_config *cfg = dev->config;
 801ad7a: 68fb         	ldr	r3, [r7, #0xc]
 801ad7c: 685b         	ldr	r3, [r3, #0x4]
 801ad7e: 617b         	str	r3, [r7, #0x14]
; 	return cfg->api->transceive(dev, reg, write, data, length);
 801ad80: 697b         	ldr	r3, [r7, #0x14]
 801ad82: 699b         	ldr	r3, [r3, #0x18]
 801ad84: 685c         	ldr	r4, [r3, #0x4]
 801ad86: 7aba         	ldrb	r2, [r7, #0xa]
 801ad88: 7af9         	ldrb	r1, [r7, #0xb]
 801ad8a: 6abb         	ldr	r3, [r7, #0x28]
 801ad8c: 9300         	str	r3, [sp]
 801ad8e: 687b         	ldr	r3, [r7, #0x4]
 801ad90: 68f8         	ldr	r0, [r7, #0xc]
 801ad92: 47a0         	blx	r4
 801ad94: 4603         	mov	r3, r0
; }
 801ad96: 4618         	mov	r0, r3
 801ad98: 371c         	adds	r7, #0x1c
 801ad9a: 46bd         	mov	sp, r7
 801ad9c: bd90         	pop	{r4, r7, pc}

0801ad9e <bmi08x_gyro_read>:
; {
 801ad9e: b580         	push	{r7, lr}
 801ada0: b086         	sub	sp, #0x18
 801ada2: af02         	add	r7, sp, #0x8
 801ada4: 60f8         	str	r0, [r7, #0xc]
 801ada6: 607a         	str	r2, [r7, #0x4]
 801ada8: 461a         	mov	r2, r3
 801adaa: 460b         	mov	r3, r1
 801adac: 72fb         	strb	r3, [r7, #0xb]
 801adae: 4613         	mov	r3, r2
 801adb0: 72bb         	strb	r3, [r7, #0xa]
; 	return bmi08x_gyro_transceive(dev, reg_addr | BIT(7), false, data, len);
 801adb2: 7afb         	ldrb	r3, [r7, #0xb]
 801adb4: f063 037f    	orn	r3, r3, #0x7f
 801adb8: b2d9         	uxtb	r1, r3
 801adba: 7abb         	ldrb	r3, [r7, #0xa]
 801adbc: 9300         	str	r3, [sp]
 801adbe: 687b         	ldr	r3, [r7, #0x4]
 801adc0: 2200         	movs	r2, #0x0
 801adc2: 68f8         	ldr	r0, [r7, #0xc]
 801adc4: f7ff ffd0    	bl	0x801ad68 <bmi08x_gyro_transceive> @ imm = #-0x60
 801adc8: 4603         	mov	r3, r0
; }
 801adca: 4618         	mov	r0, r3
 801adcc: 3710         	adds	r7, #0x10
 801adce: 46bd         	mov	sp, r7
 801add0: bd80         	pop	{r7, pc}

0801add2 <bmi08x_gyro_byte_read>:
; {
 801add2: b580         	push	{r7, lr}
 801add4: b086         	sub	sp, #0x18
 801add6: af02         	add	r7, sp, #0x8
 801add8: 60f8         	str	r0, [r7, #0xc]
 801adda: 460b         	mov	r3, r1
 801addc: 607a         	str	r2, [r7, #0x4]
 801adde: 72fb         	strb	r3, [r7, #0xb]
; 	return bmi08x_gyro_transceive(dev, reg_addr | BIT(7), false, byte, 1);
 801ade0: 7afb         	ldrb	r3, [r7, #0xb]
 801ade2: f063 037f    	orn	r3, r3, #0x7f
 801ade6: b2d9         	uxtb	r1, r3
 801ade8: 2301         	movs	r3, #0x1
 801adea: 9300         	str	r3, [sp]
 801adec: 687b         	ldr	r3, [r7, #0x4]
 801adee: 2200         	movs	r2, #0x0
 801adf0: 68f8         	ldr	r0, [r7, #0xc]
 801adf2: f7ff ffb9    	bl	0x801ad68 <bmi08x_gyro_transceive> @ imm = #-0x8e
 801adf6: 4603         	mov	r3, r0
; }
 801adf8: 4618         	mov	r0, r3
 801adfa: 3710         	adds	r7, #0x10
 801adfc: 46bd         	mov	sp, r7
 801adfe: bd80         	pop	{r7, pc}

0801ae00 <bmi08x_gyro_byte_write>:
; {
 801ae00: b580         	push	{r7, lr}
 801ae02: b084         	sub	sp, #0x10
 801ae04: af02         	add	r7, sp, #0x8
 801ae06: 6078         	str	r0, [r7, #0x4]
 801ae08: 460b         	mov	r3, r1
 801ae0a: 70fb         	strb	r3, [r7, #0x3]
 801ae0c: 4613         	mov	r3, r2
 801ae0e: 70bb         	strb	r3, [r7, #0x2]
; 	return bmi08x_gyro_transceive(dev, reg_addr & 0x7F, true, &byte, 1);
 801ae10: 78fb         	ldrb	r3, [r7, #0x3]
 801ae12: f003 037f    	and	r3, r3, #0x7f
 801ae16: b2d9         	uxtb	r1, r3
 801ae18: 1cbb         	adds	r3, r7, #0x2
 801ae1a: 2201         	movs	r2, #0x1
 801ae1c: 9200         	str	r2, [sp]
 801ae1e: 2201         	movs	r2, #0x1
 801ae20: 6878         	ldr	r0, [r7, #0x4]
 801ae22: f7ff ffa1    	bl	0x801ad68 <bmi08x_gyro_transceive> @ imm = #-0xbe
 801ae26: 4603         	mov	r3, r0
; }
 801ae28: 4618         	mov	r0, r3
 801ae2a: 3708         	adds	r7, #0x8
 801ae2c: 46bd         	mov	sp, r7
 801ae2e: bd80         	pop	{r7, pc}

0801ae30 <bmi08x_gyr_odr_set>:
; {
 801ae30: b580         	push	{r7, lr}
 801ae32: b084         	sub	sp, #0x10
 801ae34: af00         	add	r7, sp, #0x0
 801ae36: 6078         	str	r0, [r7, #0x4]
 801ae38: 460b         	mov	r3, r1
 801ae3a: 807b         	strh	r3, [r7, #0x2]
 801ae3c: 4613         	mov	r3, r2
 801ae3e: 803b         	strh	r3, [r7]
; 	int odr = bmi08x_freq_to_odr_val(freq_int, freq_milli);
 801ae40: 883a         	ldrh	r2, [r7]
 801ae42: 887b         	ldrh	r3, [r7, #0x2]
 801ae44: 4611         	mov	r1, r2
 801ae46: 4618         	mov	r0, r3
 801ae48: f7f0 f960    	bl	0x800b10c <bmi08x_freq_to_odr_val> @ imm = #-0xfd40
 801ae4c: 60f8         	str	r0, [r7, #0xc]
; 	if (odr < 0) {
 801ae4e: 68fb         	ldr	r3, [r7, #0xc]
 801ae50: 2b00         	cmp	r3, #0x0
 801ae52: da01         	bge	0x801ae58 <bmi08x_gyr_odr_set+0x28> @ imm = #0x2
; 		return odr;
 801ae54: 68fb         	ldr	r3, [r7, #0xc]
 801ae56: e010         	b	0x801ae7a <bmi08x_gyr_odr_set+0x4a> @ imm = #0x20
; 	if (odr < BMI08X_GYRO_BW_532_ODR_2000_HZ || odr > BMI08X_GYRO_BW_32_ODR_100_HZ) {
 801ae58: 68fb         	ldr	r3, [r7, #0xc]
 801ae5a: 2b00         	cmp	r3, #0x0
 801ae5c: db02         	blt	0x801ae64 <bmi08x_gyr_odr_set+0x34> @ imm = #0x4
 801ae5e: 68fb         	ldr	r3, [r7, #0xc]
 801ae60: 2b07         	cmp	r3, #0x7
 801ae62: dd02         	ble	0x801ae6a <bmi08x_gyr_odr_set+0x3a> @ imm = #0x4
; 		return -ENOTSUP;
 801ae64: f06f 0385    	mvn	r3, #0x85
 801ae68: e007         	b	0x801ae7a <bmi08x_gyr_odr_set+0x4a> @ imm = #0xe
; 	return bmi08x_gyro_byte_write(dev, BMI08X_REG_GYRO_BANDWIDTH, (uint8_t)odr);
 801ae6a: 68fb         	ldr	r3, [r7, #0xc]
 801ae6c: b2db         	uxtb	r3, r3
 801ae6e: 461a         	mov	r2, r3
 801ae70: 2110         	movs	r1, #0x10
 801ae72: 6878         	ldr	r0, [r7, #0x4]
 801ae74: f7ff ffc4    	bl	0x801ae00 <bmi08x_gyro_byte_write> @ imm = #-0x78
 801ae78: 4603         	mov	r3, r0
; }
 801ae7a: 4618         	mov	r0, r3
 801ae7c: 3710         	adds	r7, #0x10
 801ae7e: 46bd         	mov	sp, r7
 801ae80: bd80         	pop	{r7, pc}

0801ae82 <bmi08x_channel_convert>:
; {
 801ae82: b580         	push	{r7, lr}
 801ae84: b086         	sub	sp, #0x18
 801ae86: af00         	add	r7, sp, #0x0
 801ae88: 60ba         	str	r2, [r7, #0x8]
 801ae8a: 607b         	str	r3, [r7, #0x4]
 801ae8c: 4603         	mov	r3, r0
 801ae8e: 81fb         	strh	r3, [r7, #0xe]
 801ae90: 460b         	mov	r3, r1
 801ae92: 81bb         	strh	r3, [r7, #0xc]
; 	switch (chan) {
 801ae94: 89fb         	ldrh	r3, [r7, #0xe]
 801ae96: 2b06         	cmp	r3, #0x6
 801ae98: d010         	beq	0x801aebc <bmi08x_channel_convert+0x3a> @ imm = #0x20
 801ae9a: 2b06         	cmp	r3, #0x6
 801ae9c: dc13         	bgt	0x801aec6 <bmi08x_channel_convert+0x44> @ imm = #0x26
 801ae9e: 2b04         	cmp	r3, #0x4
 801aea0: d002         	beq	0x801aea8 <bmi08x_channel_convert+0x26> @ imm = #0x4
 801aea2: 2b05         	cmp	r3, #0x5
 801aea4: d005         	beq	0x801aeb2 <bmi08x_channel_convert+0x30> @ imm = #0xa
 801aea6: e00e         	b	0x801aec6 <bmi08x_channel_convert+0x44> @ imm = #0x1c
; 		ofs_start = ofs_stop = 0U;
 801aea8: 2300         	movs	r3, #0x0
 801aeaa: 74bb         	strb	r3, [r7, #0x12]
 801aeac: 7cbb         	ldrb	r3, [r7, #0x12]
 801aeae: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 801aeb0: e00e         	b	0x801aed0 <bmi08x_channel_convert+0x4e> @ imm = #0x1c
; 		ofs_start = ofs_stop = 1U;
 801aeb2: 2301         	movs	r3, #0x1
 801aeb4: 74bb         	strb	r3, [r7, #0x12]
 801aeb6: 7cbb         	ldrb	r3, [r7, #0x12]
 801aeb8: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 801aeba: e009         	b	0x801aed0 <bmi08x_channel_convert+0x4e> @ imm = #0x12
; 		ofs_start = ofs_stop = 2U;
 801aebc: 2302         	movs	r3, #0x2
 801aebe: 74bb         	strb	r3, [r7, #0x12]
 801aec0: 7cbb         	ldrb	r3, [r7, #0x12]
 801aec2: 74fb         	strb	r3, [r7, #0x13]
; 		break;
 801aec4: e004         	b	0x801aed0 <bmi08x_channel_convert+0x4e> @ imm = #0x8
; 		ofs_start = 0U;
 801aec6: 2300         	movs	r3, #0x0
 801aec8: 74fb         	strb	r3, [r7, #0x13]
; 		ofs_stop = 2U;
 801aeca: 2302         	movs	r3, #0x2
 801aecc: 74bb         	strb	r3, [r7, #0x12]
; 		break;
 801aece: bf00         	nop
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 801aed0: 7cfb         	ldrb	r3, [r7, #0x13]
 801aed2: 617b         	str	r3, [r7, #0x14]
 801aed4: e010         	b	0x801aef8 <bmi08x_channel_convert+0x76> @ imm = #0x20
; 		bmi08x_to_fixed_point(raw_xyz[i], scale, val);
 801aed6: 697b         	ldr	r3, [r7, #0x14]
 801aed8: 005b         	lsls	r3, r3, #0x1
 801aeda: 68ba         	ldr	r2, [r7, #0x8]
 801aedc: 4413         	add	r3, r2
 801aede: 881b         	ldrh	r3, [r3]
 801aee0: b21b         	sxth	r3, r3
 801aee2: 89b9         	ldrh	r1, [r7, #0xc]
 801aee4: 687a         	ldr	r2, [r7, #0x4]
 801aee6: 4618         	mov	r0, r3
 801aee8: f7ef fef4    	bl	0x800acd4 <bmi08x_to_fixed_point> @ imm = #-0x10218
; 	for (i = ofs_start; i <= ofs_stop; i++, val++) {
 801aeec: 697b         	ldr	r3, [r7, #0x14]
 801aeee: 3301         	adds	r3, #0x1
 801aef0: 617b         	str	r3, [r7, #0x14]
 801aef2: 687b         	ldr	r3, [r7, #0x4]
 801aef4: 3308         	adds	r3, #0x8
 801aef6: 607b         	str	r3, [r7, #0x4]
 801aef8: 7cbb         	ldrb	r3, [r7, #0x12]
 801aefa: 697a         	ldr	r2, [r7, #0x14]
 801aefc: 429a         	cmp	r2, r3
 801aefe: ddea         	ble	0x801aed6 <bmi08x_channel_convert+0x54> @ imm = #-0x2c
; }
 801af00: bf00         	nop
 801af02: bf00         	nop
 801af04: 3718         	adds	r7, #0x18
 801af06: 46bd         	mov	sp, r7
 801af08: bd80         	pop	{r7, pc}

0801af0a <bmi08x_gyr_channel_get>:
; {
 801af0a: b580         	push	{r7, lr}
 801af0c: b086         	sub	sp, #0x18
 801af0e: af00         	add	r7, sp, #0x0
 801af10: 60f8         	str	r0, [r7, #0xc]
 801af12: 460b         	mov	r3, r1
 801af14: 607a         	str	r2, [r7, #0x4]
 801af16: 817b         	strh	r3, [r7, #0xa]
; 	struct bmi08x_gyro_data *bmi08x = dev->data;
 801af18: 68fb         	ldr	r3, [r7, #0xc]
 801af1a: 691b         	ldr	r3, [r3, #0x10]
 801af1c: 617b         	str	r3, [r7, #0x14]
; 	bmi08x_channel_convert(chan, bmi08x->scale, bmi08x->gyr_sample, val);
 801af1e: 697b         	ldr	r3, [r7, #0x14]
 801af20: 8a59         	ldrh	r1, [r3, #0x12]
 801af22: 697b         	ldr	r3, [r7, #0x14]
 801af24: f103 020c    	add.w	r2, r3, #0xc
 801af28: 8978         	ldrh	r0, [r7, #0xa]
 801af2a: 687b         	ldr	r3, [r7, #0x4]
 801af2c: f7ff ffa9    	bl	0x801ae82 <bmi08x_channel_convert> @ imm = #-0xae
; }
 801af30: bf00         	nop
 801af32: 3718         	adds	r7, #0x18
 801af34: 46bd         	mov	sp, r7
 801af36: bd80         	pop	{r7, pc}

0801af38 <bmi08x_range_to_reg_val>:
; {
 801af38: b480         	push	{r7}
 801af3a: b085         	sub	sp, #0x14
 801af3c: af00         	add	r7, sp, #0x0
 801af3e: 4603         	mov	r3, r0
 801af40: 6039         	str	r1, [r7]
 801af42: 80fb         	strh	r3, [r7, #0x6]
 801af44: 4613         	mov	r3, r2
 801af46: 80bb         	strh	r3, [r7, #0x4]
; 	for (i = 0; i < range_map_size; i++) {
 801af48: 2300         	movs	r3, #0x0
 801af4a: 60fb         	str	r3, [r7, #0xc]
 801af4c: e010         	b	0x801af70 <bmi08x_range_to_reg_val+0x38> @ imm = #0x20
; 		if (range <= range_map[i].range) {
 801af4e: 68fb         	ldr	r3, [r7, #0xc]
 801af50: 009b         	lsls	r3, r3, #0x2
 801af52: 683a         	ldr	r2, [r7]
 801af54: 4413         	add	r3, r2
 801af56: 881b         	ldrh	r3, [r3]
 801af58: 88fa         	ldrh	r2, [r7, #0x6]
 801af5a: 429a         	cmp	r2, r3
 801af5c: d805         	bhi	0x801af6a <bmi08x_range_to_reg_val+0x32> @ imm = #0xa
; 			return range_map[i].reg_val;
 801af5e: 68fb         	ldr	r3, [r7, #0xc]
 801af60: 009b         	lsls	r3, r3, #0x2
 801af62: 683a         	ldr	r2, [r7]
 801af64: 4413         	add	r3, r2
 801af66: 789b         	ldrb	r3, [r3, #0x2]
 801af68: e008         	b	0x801af7c <bmi08x_range_to_reg_val+0x44> @ imm = #0x10
; 	for (i = 0; i < range_map_size; i++) {
 801af6a: 68fb         	ldr	r3, [r7, #0xc]
 801af6c: 3301         	adds	r3, #0x1
 801af6e: 60fb         	str	r3, [r7, #0xc]
 801af70: 88bb         	ldrh	r3, [r7, #0x4]
 801af72: 68fa         	ldr	r2, [r7, #0xc]
 801af74: 429a         	cmp	r2, r3
 801af76: dbea         	blt	0x801af4e <bmi08x_range_to_reg_val+0x16> @ imm = #-0x2c
; 	return -EINVAL;
 801af78: f06f 0315    	mvn	r3, #0x15
; }
 801af7c: 4618         	mov	r0, r3
 801af7e: 3714         	adds	r7, #0x14
 801af80: 46bd         	mov	sp, r7
 801af82: f85d 7b04    	ldr	r7, [sp], #4
 801af86: 4770         	bx	lr

0801af88 <device_is_ready>:
; {
 801af88: b580         	push	{r7, lr}
 801af8a: b082         	sub	sp, #0x8
 801af8c: af00         	add	r7, sp, #0x0
 801af8e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801af90: 6878         	ldr	r0, [r7, #0x4]
 801af92: f003 f81d    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x303a
 801af96: 4603         	mov	r3, r0
; }
 801af98: 4618         	mov	r0, r3
 801af9a: 3708         	adds	r7, #0x8
 801af9c: 46bd         	mov	sp, r7
 801af9e: bd80         	pop	{r7, pc}

0801afa0 <gpio_is_ready_dt>:
; {
 801afa0: b580         	push	{r7, lr}
 801afa2: b082         	sub	sp, #0x8
 801afa4: af00         	add	r7, sp, #0x0
 801afa6: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 801afa8: 687b         	ldr	r3, [r7, #0x4]
 801afaa: 681b         	ldr	r3, [r3]
 801afac: 4618         	mov	r0, r3
 801afae: f7ff ffeb    	bl	0x801af88 <device_is_ready> @ imm = #-0x2a
 801afb2: 4603         	mov	r3, r0
; }
 801afb4: 4618         	mov	r0, r3
 801afb6: 3708         	adds	r7, #0x8
 801afb8: 46bd         	mov	sp, r7
 801afba: bd80         	pop	{r7, pc}

0801afbc <gpio_pin_interrupt_configure_dt>:
; {
 801afbc: b580         	push	{r7, lr}
 801afbe: b082         	sub	sp, #0x8
 801afc0: af00         	add	r7, sp, #0x0
 801afc2: 6078         	str	r0, [r7, #0x4]
 801afc4: 6039         	str	r1, [r7]
; 	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
 801afc6: 687b         	ldr	r3, [r7, #0x4]
 801afc8: 6818         	ldr	r0, [r3]
 801afca: 687b         	ldr	r3, [r7, #0x4]
 801afcc: 791b         	ldrb	r3, [r3, #0x4]
 801afce: 683a         	ldr	r2, [r7]
 801afd0: 4619         	mov	r1, r3
 801afd2: f000 f892    	bl	0x801b0fa <gpio_pin_interrupt_configure> @ imm = #0x124
 801afd6: 4603         	mov	r3, r0
; }
 801afd8: 4618         	mov	r0, r3
 801afda: 3708         	adds	r7, #0x8
 801afdc: 46bd         	mov	sp, r7
 801afde: bd80         	pop	{r7, pc}

0801afe0 <z_impl_gpio_pin_configure>:
; {
 801afe0: b580         	push	{r7, lr}
 801afe2: b088         	sub	sp, #0x20
 801afe4: af00         	add	r7, sp, #0x0
 801afe6: 60f8         	str	r0, [r7, #0xc]
 801afe8: 460b         	mov	r3, r1
 801afea: 607a         	str	r2, [r7, #0x4]
 801afec: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 801afee: 68fb         	ldr	r3, [r7, #0xc]
 801aff0: 689b         	ldr	r3, [r3, #0x8]
 801aff2: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 801aff4: 68fb         	ldr	r3, [r7, #0xc]
 801aff6: 685b         	ldr	r3, [r3, #0x4]
 801aff8: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 801affa: 68fb         	ldr	r3, [r7, #0xc]
 801affc: 691b         	ldr	r3, [r3, #0x10]
 801affe: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 801b000: 687b         	ldr	r3, [r7, #0x4]
 801b002: f403 1380    	and	r3, r3, #0x100000
 801b006: 2b00         	cmp	r3, #0x0
 801b008: d00d         	beq	0x801b026 <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 801b00a: 687b         	ldr	r3, [r7, #0x4]
 801b00c: f403 2340    	and	r3, r3, #0xc0000
 801b010: 2b00         	cmp	r3, #0x0
 801b012: d008         	beq	0x801b026 <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 801b014: 687b         	ldr	r3, [r7, #0x4]
 801b016: f003 0301    	and	r3, r3, #0x1
 801b01a: 2b00         	cmp	r3, #0x0
 801b01c: d003         	beq	0x801b026 <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 801b01e: 687b         	ldr	r3, [r7, #0x4]
 801b020: f483 2340    	eor	r3, r3, #0xc0000
 801b024: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 801b026: 687b         	ldr	r3, [r7, #0x4]
 801b028: f423 1380    	bic	r3, r3, #0x100000
 801b02c: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 801b02e: 687b         	ldr	r3, [r7, #0x4]
 801b030: f003 0301    	and	r3, r3, #0x1
 801b034: 2b00         	cmp	r3, #0x0
 801b036: d009         	beq	0x801b04c <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 801b038: 697b         	ldr	r3, [r7, #0x14]
 801b03a: 681a         	ldr	r2, [r3]
 801b03c: 7afb         	ldrb	r3, [r7, #0xb]
 801b03e: 2101         	movs	r1, #0x1
 801b040: fa01 f303    	lsl.w	r3, r1, r3
 801b044: 431a         	orrs	r2, r3
 801b046: 697b         	ldr	r3, [r7, #0x14]
 801b048: 601a         	str	r2, [r3]
 801b04a: e009         	b	0x801b060 <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 801b04c: 697b         	ldr	r3, [r7, #0x14]
 801b04e: 681a         	ldr	r2, [r3]
 801b050: 7afb         	ldrb	r3, [r7, #0xb]
 801b052: 2101         	movs	r1, #0x1
 801b054: fa01 f303    	lsl.w	r3, r1, r3
 801b058: 43db         	mvns	r3, r3
 801b05a: 401a         	ands	r2, r3
 801b05c: 697b         	ldr	r3, [r7, #0x14]
 801b05e: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 801b060: 69fb         	ldr	r3, [r7, #0x1c]
 801b062: 681b         	ldr	r3, [r3]
 801b064: 7af9         	ldrb	r1, [r7, #0xb]
 801b066: 687a         	ldr	r2, [r7, #0x4]
 801b068: 68f8         	ldr	r0, [r7, #0xc]
 801b06a: 4798         	blx	r3
 801b06c: 4603         	mov	r3, r0
; }
 801b06e: 4618         	mov	r0, r3
 801b070: 3720         	adds	r7, #0x20
 801b072: 46bd         	mov	sp, r7
 801b074: bd80         	pop	{r7, pc}

0801b076 <gpio_pin_configure_dt>:
; {
 801b076: b580         	push	{r7, lr}
 801b078: b082         	sub	sp, #0x8
 801b07a: af00         	add	r7, sp, #0x0
 801b07c: 6078         	str	r0, [r7, #0x4]
 801b07e: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 801b080: 687b         	ldr	r3, [r7, #0x4]
 801b082: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 801b084: 687b         	ldr	r3, [r7, #0x4]
 801b086: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 801b088: 687b         	ldr	r3, [r7, #0x4]
 801b08a: 88db         	ldrh	r3, [r3, #0x6]
 801b08c: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 801b08e: 683b         	ldr	r3, [r7]
 801b090: 4313         	orrs	r3, r2
 801b092: 461a         	mov	r2, r3
 801b094: f000 f843    	bl	0x801b11e <gpio_pin_configure> @ imm = #0x86
 801b098: 4603         	mov	r3, r0
; }
 801b09a: 4618         	mov	r0, r3
 801b09c: 3708         	adds	r7, #0x8
 801b09e: 46bd         	mov	sp, r7
 801b0a0: bd80         	pop	{r7, pc}

0801b0a2 <gpio_init_callback>:
; {
 801b0a2: b480         	push	{r7}
 801b0a4: b085         	sub	sp, #0x14
 801b0a6: af00         	add	r7, sp, #0x0
 801b0a8: 60f8         	str	r0, [r7, #0xc]
 801b0aa: 60b9         	str	r1, [r7, #0x8]
 801b0ac: 607a         	str	r2, [r7, #0x4]
; 	callback->handler = handler;
 801b0ae: 68fb         	ldr	r3, [r7, #0xc]
 801b0b0: 68ba         	ldr	r2, [r7, #0x8]
 801b0b2: 605a         	str	r2, [r3, #0x4]
; 	callback->pin_mask = pin_mask;
 801b0b4: 68fb         	ldr	r3, [r7, #0xc]
 801b0b6: 687a         	ldr	r2, [r7, #0x4]
 801b0b8: 609a         	str	r2, [r3, #0x8]
; }
 801b0ba: bf00         	nop
 801b0bc: 3714         	adds	r7, #0x14
 801b0be: 46bd         	mov	sp, r7
 801b0c0: f85d 7b04    	ldr	r7, [sp], #4
 801b0c4: 4770         	bx	lr

0801b0c6 <gpio_add_callback>:
; {
 801b0c6: b580         	push	{r7, lr}
 801b0c8: b084         	sub	sp, #0x10
 801b0ca: af00         	add	r7, sp, #0x0
 801b0cc: 6078         	str	r0, [r7, #0x4]
 801b0ce: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 801b0d0: 687b         	ldr	r3, [r7, #0x4]
 801b0d2: 689b         	ldr	r3, [r3, #0x8]
 801b0d4: 60fb         	str	r3, [r7, #0xc]
; 	if (api->manage_callback == NULL) {
 801b0d6: 68fb         	ldr	r3, [r7, #0xc]
 801b0d8: 69db         	ldr	r3, [r3, #0x1c]
 801b0da: 2b00         	cmp	r3, #0x0
 801b0dc: d102         	bne	0x801b0e4 <gpio_add_callback+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 801b0de: f06f 0357    	mvn	r3, #0x57
 801b0e2: e006         	b	0x801b0f2 <gpio_add_callback+0x2c> @ imm = #0xc
; 	return api->manage_callback(port, callback, true);
 801b0e4: 68fb         	ldr	r3, [r7, #0xc]
 801b0e6: 69db         	ldr	r3, [r3, #0x1c]
 801b0e8: 2201         	movs	r2, #0x1
 801b0ea: 6839         	ldr	r1, [r7]
 801b0ec: 6878         	ldr	r0, [r7, #0x4]
 801b0ee: 4798         	blx	r3
 801b0f0: 4603         	mov	r3, r0
; }
 801b0f2: 4618         	mov	r0, r3
 801b0f4: 3710         	adds	r7, #0x10
 801b0f6: 46bd         	mov	sp, r7
 801b0f8: bd80         	pop	{r7, pc}

0801b0fa <gpio_pin_interrupt_configure>:
; {
 801b0fa: b580         	push	{r7, lr}
 801b0fc: b084         	sub	sp, #0x10
 801b0fe: af00         	add	r7, sp, #0x0
 801b100: 60f8         	str	r0, [r7, #0xc]
 801b102: 460b         	mov	r3, r1
 801b104: 607a         	str	r2, [r7, #0x4]
 801b106: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_interrupt_configure(port, pin, flags);
 801b108: 7afb         	ldrb	r3, [r7, #0xb]
 801b10a: 687a         	ldr	r2, [r7, #0x4]
 801b10c: 4619         	mov	r1, r3
 801b10e: 68f8         	ldr	r0, [r7, #0xc]
 801b110: f7f0 f838    	bl	0x800b184 <z_impl_gpio_pin_interrupt_configure> @ imm = #-0xff90
 801b114: 4603         	mov	r3, r0
; }
 801b116: 4618         	mov	r0, r3
 801b118: 3710         	adds	r7, #0x10
 801b11a: 46bd         	mov	sp, r7
 801b11c: bd80         	pop	{r7, pc}

0801b11e <gpio_pin_configure>:
; {
 801b11e: b580         	push	{r7, lr}
 801b120: b084         	sub	sp, #0x10
 801b122: af00         	add	r7, sp, #0x0
 801b124: 60f8         	str	r0, [r7, #0xc]
 801b126: 460b         	mov	r3, r1
 801b128: 607a         	str	r2, [r7, #0x4]
 801b12a: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 801b12c: 7afb         	ldrb	r3, [r7, #0xb]
 801b12e: 687a         	ldr	r2, [r7, #0x4]
 801b130: 4619         	mov	r1, r3
 801b132: 68f8         	ldr	r0, [r7, #0xc]
 801b134: f7ff ff54    	bl	0x801afe0 <z_impl_gpio_pin_configure> @ imm = #-0x158
 801b138: 4603         	mov	r3, r0
; }
 801b13a: 4618         	mov	r0, r3
 801b13c: 3710         	adds	r7, #0x10
 801b13e: 46bd         	mov	sp, r7
 801b140: bd80         	pop	{r7, pc}

0801b142 <k_thread_create>:
; {
 801b142: b580         	push	{r7, lr}
 801b144: b08c         	sub	sp, #0x30
 801b146: af08         	add	r7, sp, #0x20
 801b148: 60f8         	str	r0, [r7, #0xc]
 801b14a: 60b9         	str	r1, [r7, #0x8]
 801b14c: 607a         	str	r2, [r7, #0x4]
 801b14e: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 801b150: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801b154: e9cd 2306    	strd	r2, r3, [sp, #24]
 801b158: 6abb         	ldr	r3, [r7, #0x28]
 801b15a: 9304         	str	r3, [sp, #0x10]
 801b15c: 6a7b         	ldr	r3, [r7, #0x24]
 801b15e: 9303         	str	r3, [sp, #0xc]
 801b160: 6a3b         	ldr	r3, [r7, #0x20]
 801b162: 9302         	str	r3, [sp, #0x8]
 801b164: 69fb         	ldr	r3, [r7, #0x1c]
 801b166: 9301         	str	r3, [sp, #0x4]
 801b168: 69bb         	ldr	r3, [r7, #0x18]
 801b16a: 9300         	str	r3, [sp]
 801b16c: 683b         	ldr	r3, [r7]
 801b16e: 687a         	ldr	r2, [r7, #0x4]
 801b170: 68b9         	ldr	r1, [r7, #0x8]
 801b172: 68f8         	ldr	r0, [r7, #0xc]
 801b174: f003 ff34    	bl	0x801efe0 <z_impl_k_thread_create> @ imm = #0x3e68
 801b178: 4603         	mov	r3, r0
; }
 801b17a: 4618         	mov	r0, r3
 801b17c: 3710         	adds	r7, #0x10
 801b17e: 46bd         	mov	sp, r7
 801b180: bd80         	pop	{r7, pc}

0801b182 <k_thread_name_set>:
; {
 801b182: b580         	push	{r7, lr}
 801b184: b082         	sub	sp, #0x8
 801b186: af00         	add	r7, sp, #0x0
 801b188: 6078         	str	r0, [r7, #0x4]
 801b18a: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 801b18c: 6839         	ldr	r1, [r7]
 801b18e: 6878         	ldr	r0, [r7, #0x4]
 801b190: f7f5 fc74    	bl	0x8010a7c <z_impl_k_thread_name_set> @ imm = #-0xa718
 801b194: 4603         	mov	r3, r0
; }
 801b196: 4618         	mov	r0, r3
 801b198: 3708         	adds	r7, #0x8
 801b19a: 46bd         	mov	sp, r7
 801b19c: bd80         	pop	{r7, pc}

0801b19e <k_sem_init>:
; {
 801b19e: b580         	push	{r7, lr}
 801b1a0: b084         	sub	sp, #0x10
 801b1a2: af00         	add	r7, sp, #0x0
 801b1a4: 60f8         	str	r0, [r7, #0xc]
 801b1a6: 60b9         	str	r1, [r7, #0x8]
 801b1a8: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 801b1aa: 687a         	ldr	r2, [r7, #0x4]
 801b1ac: 68b9         	ldr	r1, [r7, #0x8]
 801b1ae: 68f8         	ldr	r0, [r7, #0xc]
 801b1b0: f003 fa9f    	bl	0x801e6f2 <z_impl_k_sem_init> @ imm = #0x353e
 801b1b4: 4603         	mov	r3, r0
; }
 801b1b6: 4618         	mov	r0, r3
 801b1b8: 3710         	adds	r7, #0x10
 801b1ba: 46bd         	mov	sp, r7
 801b1bc: bd80         	pop	{r7, pc}

0801b1be <k_sem_take>:
; {
 801b1be: b580         	push	{r7, lr}
 801b1c0: b084         	sub	sp, #0x10
 801b1c2: af00         	add	r7, sp, #0x0
 801b1c4: 60f8         	str	r0, [r7, #0xc]
 801b1c6: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 801b1ca: e9d7 2300    	ldrd	r2, r3, [r7]
 801b1ce: 68f8         	ldr	r0, [r7, #0xc]
 801b1d0: f7f5 f882    	bl	0x80102d8 <z_impl_k_sem_take> @ imm = #-0xaefc
 801b1d4: 4603         	mov	r3, r0
; }
 801b1d6: 4618         	mov	r0, r3
 801b1d8: 3710         	adds	r7, #0x10
 801b1da: 46bd         	mov	sp, r7
 801b1dc: bd80         	pop	{r7, pc}

0801b1de <k_sem_give>:
; {
 801b1de: b580         	push	{r7, lr}
 801b1e0: b082         	sub	sp, #0x8
 801b1e2: af00         	add	r7, sp, #0x0
 801b1e4: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801b1e6: 6878         	ldr	r0, [r7, #0x4]
 801b1e8: f7f4 ffe8    	bl	0x80101bc <z_impl_k_sem_give> @ imm = #-0xb030
; }
 801b1ec: bf00         	nop
 801b1ee: 3708         	adds	r7, #0x8
 801b1f0: 46bd         	mov	sp, r7
 801b1f2: bd80         	pop	{r7, pc}

0801b1f4 <z_log_msg_runtime_create>:
; {
 801b1f4: b580         	push	{r7, lr}
 801b1f6: b08a         	sub	sp, #0x28
 801b1f8: af04         	add	r7, sp, #0x10
 801b1fa: 60b9         	str	r1, [r7, #0x8]
 801b1fc: 607b         	str	r3, [r7, #0x4]
 801b1fe: 4603         	mov	r3, r0
 801b200: 73fb         	strb	r3, [r7, #0xf]
 801b202: 4613         	mov	r3, r2
 801b204: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801b206: f107 032c    	add.w	r3, r7, #0x2c
 801b20a: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801b20c: 7bba         	ldrb	r2, [r7, #0xe]
 801b20e: 7bf8         	ldrb	r0, [r7, #0xf]
 801b210: 697b         	ldr	r3, [r7, #0x14]
 801b212: 9303         	str	r3, [sp, #0xc]
 801b214: 6abb         	ldr	r3, [r7, #0x28]
 801b216: 9302         	str	r3, [sp, #0x8]
 801b218: 6a7b         	ldr	r3, [r7, #0x24]
 801b21a: 9301         	str	r3, [sp, #0x4]
 801b21c: 6a3b         	ldr	r3, [r7, #0x20]
 801b21e: 9300         	str	r3, [sp]
 801b220: 687b         	ldr	r3, [r7, #0x4]
 801b222: 68b9         	ldr	r1, [r7, #0x8]
 801b224: f7ea f9a6    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x15cb4
; }
 801b228: bf00         	nop
 801b22a: 3718         	adds	r7, #0x18
 801b22c: 46bd         	mov	sp, r7
 801b22e: bd80         	pop	{r7, pc}

0801b230 <bmi08x_handle_drdy_acc>:
; {
 801b230: b580         	push	{r7, lr}
 801b232: b084         	sub	sp, #0x10
 801b234: af00         	add	r7, sp, #0x0
 801b236: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 801b238: 687b         	ldr	r3, [r7, #0x4]
 801b23a: 691b         	ldr	r3, [r3, #0x10]
 801b23c: 60fb         	str	r3, [r7, #0xc]
; 	if (data->handler_drdy_acc) {
 801b23e: 68fb         	ldr	r3, [r7, #0xc]
 801b240: f8d3 3940    	ldr.w	r3, [r3, #0x940]
 801b244: 2b00         	cmp	r3, #0x0
 801b246: d008         	beq	0x801b25a <bmi08x_handle_drdy_acc+0x2a> @ imm = #0x10
; 		data->handler_drdy_acc(dev, data->drdy_trig_acc);
 801b248: 68fb         	ldr	r3, [r7, #0xc]
 801b24a: f8d3 3940    	ldr.w	r3, [r3, #0x940]
 801b24e: 68fa         	ldr	r2, [r7, #0xc]
 801b250: f8d2 2944    	ldr.w	r2, [r2, #0x944]
 801b254: 4611         	mov	r1, r2
 801b256: 6878         	ldr	r0, [r7, #0x4]
 801b258: 4798         	blx	r3
; }
 801b25a: bf00         	nop
 801b25c: 3710         	adds	r7, #0x10
 801b25e: 46bd         	mov	sp, r7
 801b260: bd80         	pop	{r7, pc}

0801b262 <bmi08x_handle_interrupts_acc>:
; {
 801b262: b580         	push	{r7, lr}
 801b264: b084         	sub	sp, #0x10
 801b266: af00         	add	r7, sp, #0x0
 801b268: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = (const struct device *)arg;
 801b26a: 687b         	ldr	r3, [r7, #0x4]
 801b26c: 60fb         	str	r3, [r7, #0xc]
; 	bmi08x_handle_drdy_acc(dev);
 801b26e: 68f8         	ldr	r0, [r7, #0xc]
 801b270: f7ff ffde    	bl	0x801b230 <bmi08x_handle_drdy_acc> @ imm = #-0x44
; }
 801b274: bf00         	nop
 801b276: 3710         	adds	r7, #0x10
 801b278: 46bd         	mov	sp, r7
 801b27a: bd80         	pop	{r7, pc}

0801b27c <bmi08x_acc_gpio_callback>:
; {
 801b27c: b580         	push	{r7, lr}
 801b27e: b086         	sub	sp, #0x18
 801b280: af00         	add	r7, sp, #0x0
 801b282: 60f8         	str	r0, [r7, #0xc]
 801b284: 60b9         	str	r1, [r7, #0x8]
 801b286: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_accel_data *data = CONTAINER_OF(cb, struct bmi08x_accel_data, gpio_cb);
 801b288: 68bb         	ldr	r3, [r7, #0x8]
 801b28a: 617b         	str	r3, [r7, #0x14]
; 	k_sem_give(&data->sem);
 801b28c: 697b         	ldr	r3, [r7, #0x14]
 801b28e: f503 6313    	add.w	r3, r3, #0x930
 801b292: 4618         	mov	r0, r3
 801b294: f7ff ffa3    	bl	0x801b1de <k_sem_give>  @ imm = #-0xba
; }
 801b298: bf00         	nop
 801b29a: 3718         	adds	r7, #0x18
 801b29c: 46bd         	mov	sp, r7
 801b29e: bd80         	pop	{r7, pc}

0801b2a0 <bmi08x_trigger_set_acc>:
; {
 801b2a0: b480         	push	{r7}
 801b2a2: b087         	sub	sp, #0x1c
 801b2a4: af00         	add	r7, sp, #0x0
 801b2a6: 60f8         	str	r0, [r7, #0xc]
 801b2a8: 60b9         	str	r1, [r7, #0x8]
 801b2aa: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_accel_data *data = dev->data;
 801b2ac: 68fb         	ldr	r3, [r7, #0xc]
 801b2ae: 691b         	ldr	r3, [r3, #0x10]
 801b2b0: 617b         	str	r3, [r7, #0x14]
; 	if ((trig->chan == SENSOR_CHAN_ACCEL_XYZ) && (trig->type == SENSOR_TRIG_DATA_READY)) {
 801b2b2: 68bb         	ldr	r3, [r7, #0x8]
 801b2b4: 885b         	ldrh	r3, [r3, #0x2]
 801b2b6: 2b03         	cmp	r3, #0x3
 801b2b8: d10d         	bne	0x801b2d6 <bmi08x_trigger_set_acc+0x36> @ imm = #0x1a
 801b2ba: 68bb         	ldr	r3, [r7, #0x8]
 801b2bc: 881b         	ldrh	r3, [r3]
 801b2be: 2b01         	cmp	r3, #0x1
 801b2c0: d109         	bne	0x801b2d6 <bmi08x_trigger_set_acc+0x36> @ imm = #0x12
; 		data->drdy_trig_acc = trig;
 801b2c2: 697b         	ldr	r3, [r7, #0x14]
 801b2c4: 68ba         	ldr	r2, [r7, #0x8]
 801b2c6: f8c3 2944    	str.w	r2, [r3, #0x944]
; 		data->handler_drdy_acc = handler;
 801b2ca: 697b         	ldr	r3, [r7, #0x14]
 801b2cc: 687a         	ldr	r2, [r7, #0x4]
 801b2ce: f8c3 2940    	str.w	r2, [r3, #0x940]
; 		return 0;
 801b2d2: 2300         	movs	r3, #0x0
 801b2d4: e001         	b	0x801b2da <bmi08x_trigger_set_acc+0x3a> @ imm = #0x2
; 	return -ENOTSUP;
 801b2d6: f06f 0385    	mvn	r3, #0x85
; }
 801b2da: 4618         	mov	r0, r3
 801b2dc: 371c         	adds	r7, #0x1c
 801b2de: 46bd         	mov	sp, r7
 801b2e0: f85d 7b04    	ldr	r7, [sp], #4
 801b2e4: 4770         	bx	lr

0801b2e6 <device_is_ready>:
; {
 801b2e6: b580         	push	{r7, lr}
 801b2e8: b082         	sub	sp, #0x8
 801b2ea: af00         	add	r7, sp, #0x0
 801b2ec: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801b2ee: 6878         	ldr	r0, [r7, #0x4]
 801b2f0: f002 fe6e    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x2cdc
 801b2f4: 4603         	mov	r3, r0
; }
 801b2f6: 4618         	mov	r0, r3
 801b2f8: 3708         	adds	r7, #0x8
 801b2fa: 46bd         	mov	sp, r7
 801b2fc: bd80         	pop	{r7, pc}

0801b2fe <gpio_is_ready_dt>:
; {
 801b2fe: b580         	push	{r7, lr}
 801b300: b082         	sub	sp, #0x8
 801b302: af00         	add	r7, sp, #0x0
 801b304: 6078         	str	r0, [r7, #0x4]
; 	return device_is_ready(spec->port);
 801b306: 687b         	ldr	r3, [r7, #0x4]
 801b308: 681b         	ldr	r3, [r3]
 801b30a: 4618         	mov	r0, r3
 801b30c: f7ff ffeb    	bl	0x801b2e6 <device_is_ready> @ imm = #-0x2a
 801b310: 4603         	mov	r3, r0
; }
 801b312: 4618         	mov	r0, r3
 801b314: 3708         	adds	r7, #0x8
 801b316: 46bd         	mov	sp, r7
 801b318: bd80         	pop	{r7, pc}

0801b31a <gpio_pin_interrupt_configure_dt>:
; {
 801b31a: b580         	push	{r7, lr}
 801b31c: b082         	sub	sp, #0x8
 801b31e: af00         	add	r7, sp, #0x0
 801b320: 6078         	str	r0, [r7, #0x4]
 801b322: 6039         	str	r1, [r7]
; 	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
 801b324: 687b         	ldr	r3, [r7, #0x4]
 801b326: 6818         	ldr	r0, [r3]
 801b328: 687b         	ldr	r3, [r7, #0x4]
 801b32a: 791b         	ldrb	r3, [r3, #0x4]
 801b32c: 683a         	ldr	r2, [r7]
 801b32e: 4619         	mov	r1, r3
 801b330: f000 f892    	bl	0x801b458 <gpio_pin_interrupt_configure> @ imm = #0x124
 801b334: 4603         	mov	r3, r0
; }
 801b336: 4618         	mov	r0, r3
 801b338: 3708         	adds	r7, #0x8
 801b33a: 46bd         	mov	sp, r7
 801b33c: bd80         	pop	{r7, pc}

0801b33e <z_impl_gpio_pin_configure>:
; {
 801b33e: b580         	push	{r7, lr}
 801b340: b088         	sub	sp, #0x20
 801b342: af00         	add	r7, sp, #0x0
 801b344: 60f8         	str	r0, [r7, #0xc]
 801b346: 460b         	mov	r3, r1
 801b348: 607a         	str	r2, [r7, #0x4]
 801b34a: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 801b34c: 68fb         	ldr	r3, [r7, #0xc]
 801b34e: 689b         	ldr	r3, [r3, #0x8]
 801b350: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 801b352: 68fb         	ldr	r3, [r7, #0xc]
 801b354: 685b         	ldr	r3, [r3, #0x4]
 801b356: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 801b358: 68fb         	ldr	r3, [r7, #0xc]
 801b35a: 691b         	ldr	r3, [r3, #0x10]
 801b35c: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 801b35e: 687b         	ldr	r3, [r7, #0x4]
 801b360: f403 1380    	and	r3, r3, #0x100000
 801b364: 2b00         	cmp	r3, #0x0
 801b366: d00d         	beq	0x801b384 <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 801b368: 687b         	ldr	r3, [r7, #0x4]
 801b36a: f403 2340    	and	r3, r3, #0xc0000
 801b36e: 2b00         	cmp	r3, #0x0
 801b370: d008         	beq	0x801b384 <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 801b372: 687b         	ldr	r3, [r7, #0x4]
 801b374: f003 0301    	and	r3, r3, #0x1
 801b378: 2b00         	cmp	r3, #0x0
 801b37a: d003         	beq	0x801b384 <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 801b37c: 687b         	ldr	r3, [r7, #0x4]
 801b37e: f483 2340    	eor	r3, r3, #0xc0000
 801b382: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 801b384: 687b         	ldr	r3, [r7, #0x4]
 801b386: f423 1380    	bic	r3, r3, #0x100000
 801b38a: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 801b38c: 687b         	ldr	r3, [r7, #0x4]
 801b38e: f003 0301    	and	r3, r3, #0x1
 801b392: 2b00         	cmp	r3, #0x0
 801b394: d009         	beq	0x801b3aa <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 801b396: 697b         	ldr	r3, [r7, #0x14]
 801b398: 681a         	ldr	r2, [r3]
 801b39a: 7afb         	ldrb	r3, [r7, #0xb]
 801b39c: 2101         	movs	r1, #0x1
 801b39e: fa01 f303    	lsl.w	r3, r1, r3
 801b3a2: 431a         	orrs	r2, r3
 801b3a4: 697b         	ldr	r3, [r7, #0x14]
 801b3a6: 601a         	str	r2, [r3]
 801b3a8: e009         	b	0x801b3be <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 801b3aa: 697b         	ldr	r3, [r7, #0x14]
 801b3ac: 681a         	ldr	r2, [r3]
 801b3ae: 7afb         	ldrb	r3, [r7, #0xb]
 801b3b0: 2101         	movs	r1, #0x1
 801b3b2: fa01 f303    	lsl.w	r3, r1, r3
 801b3b6: 43db         	mvns	r3, r3
 801b3b8: 401a         	ands	r2, r3
 801b3ba: 697b         	ldr	r3, [r7, #0x14]
 801b3bc: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 801b3be: 69fb         	ldr	r3, [r7, #0x1c]
 801b3c0: 681b         	ldr	r3, [r3]
 801b3c2: 7af9         	ldrb	r1, [r7, #0xb]
 801b3c4: 687a         	ldr	r2, [r7, #0x4]
 801b3c6: 68f8         	ldr	r0, [r7, #0xc]
 801b3c8: 4798         	blx	r3
 801b3ca: 4603         	mov	r3, r0
; }
 801b3cc: 4618         	mov	r0, r3
 801b3ce: 3720         	adds	r7, #0x20
 801b3d0: 46bd         	mov	sp, r7
 801b3d2: bd80         	pop	{r7, pc}

0801b3d4 <gpio_pin_configure_dt>:
; {
 801b3d4: b580         	push	{r7, lr}
 801b3d6: b082         	sub	sp, #0x8
 801b3d8: af00         	add	r7, sp, #0x0
 801b3da: 6078         	str	r0, [r7, #0x4]
 801b3dc: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 801b3de: 687b         	ldr	r3, [r7, #0x4]
 801b3e0: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 801b3e2: 687b         	ldr	r3, [r7, #0x4]
 801b3e4: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 801b3e6: 687b         	ldr	r3, [r7, #0x4]
 801b3e8: 88db         	ldrh	r3, [r3, #0x6]
 801b3ea: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 801b3ec: 683b         	ldr	r3, [r7]
 801b3ee: 4313         	orrs	r3, r2
 801b3f0: 461a         	mov	r2, r3
 801b3f2: f000 f843    	bl	0x801b47c <gpio_pin_configure> @ imm = #0x86
 801b3f6: 4603         	mov	r3, r0
; }
 801b3f8: 4618         	mov	r0, r3
 801b3fa: 3708         	adds	r7, #0x8
 801b3fc: 46bd         	mov	sp, r7
 801b3fe: bd80         	pop	{r7, pc}

0801b400 <gpio_init_callback>:
; {
 801b400: b480         	push	{r7}
 801b402: b085         	sub	sp, #0x14
 801b404: af00         	add	r7, sp, #0x0
 801b406: 60f8         	str	r0, [r7, #0xc]
 801b408: 60b9         	str	r1, [r7, #0x8]
 801b40a: 607a         	str	r2, [r7, #0x4]
; 	callback->handler = handler;
 801b40c: 68fb         	ldr	r3, [r7, #0xc]
 801b40e: 68ba         	ldr	r2, [r7, #0x8]
 801b410: 605a         	str	r2, [r3, #0x4]
; 	callback->pin_mask = pin_mask;
 801b412: 68fb         	ldr	r3, [r7, #0xc]
 801b414: 687a         	ldr	r2, [r7, #0x4]
 801b416: 609a         	str	r2, [r3, #0x8]
; }
 801b418: bf00         	nop
 801b41a: 3714         	adds	r7, #0x14
 801b41c: 46bd         	mov	sp, r7
 801b41e: f85d 7b04    	ldr	r7, [sp], #4
 801b422: 4770         	bx	lr

0801b424 <gpio_add_callback>:
; {
 801b424: b580         	push	{r7, lr}
 801b426: b084         	sub	sp, #0x10
 801b428: af00         	add	r7, sp, #0x0
 801b42a: 6078         	str	r0, [r7, #0x4]
 801b42c: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 801b42e: 687b         	ldr	r3, [r7, #0x4]
 801b430: 689b         	ldr	r3, [r3, #0x8]
 801b432: 60fb         	str	r3, [r7, #0xc]
; 	if (api->manage_callback == NULL) {
 801b434: 68fb         	ldr	r3, [r7, #0xc]
 801b436: 69db         	ldr	r3, [r3, #0x1c]
 801b438: 2b00         	cmp	r3, #0x0
 801b43a: d102         	bne	0x801b442 <gpio_add_callback+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 801b43c: f06f 0357    	mvn	r3, #0x57
 801b440: e006         	b	0x801b450 <gpio_add_callback+0x2c> @ imm = #0xc
; 	return api->manage_callback(port, callback, true);
 801b442: 68fb         	ldr	r3, [r7, #0xc]
 801b444: 69db         	ldr	r3, [r3, #0x1c]
 801b446: 2201         	movs	r2, #0x1
 801b448: 6839         	ldr	r1, [r7]
 801b44a: 6878         	ldr	r0, [r7, #0x4]
 801b44c: 4798         	blx	r3
 801b44e: 4603         	mov	r3, r0
; }
 801b450: 4618         	mov	r0, r3
 801b452: 3710         	adds	r7, #0x10
 801b454: 46bd         	mov	sp, r7
 801b456: bd80         	pop	{r7, pc}

0801b458 <gpio_pin_interrupt_configure>:
; {
 801b458: b580         	push	{r7, lr}
 801b45a: b084         	sub	sp, #0x10
 801b45c: af00         	add	r7, sp, #0x0
 801b45e: 60f8         	str	r0, [r7, #0xc]
 801b460: 460b         	mov	r3, r1
 801b462: 607a         	str	r2, [r7, #0x4]
 801b464: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_interrupt_configure(port, pin, flags);
 801b466: 7afb         	ldrb	r3, [r7, #0xb]
 801b468: 687a         	ldr	r2, [r7, #0x4]
 801b46a: 4619         	mov	r1, r3
 801b46c: 68f8         	ldr	r0, [r7, #0xc]
 801b46e: f7f0 f821    	bl	0x800b4b4 <z_impl_gpio_pin_interrupt_configure> @ imm = #-0xffbe
 801b472: 4603         	mov	r3, r0
; }
 801b474: 4618         	mov	r0, r3
 801b476: 3710         	adds	r7, #0x10
 801b478: 46bd         	mov	sp, r7
 801b47a: bd80         	pop	{r7, pc}

0801b47c <gpio_pin_configure>:
; {
 801b47c: b580         	push	{r7, lr}
 801b47e: b084         	sub	sp, #0x10
 801b480: af00         	add	r7, sp, #0x0
 801b482: 60f8         	str	r0, [r7, #0xc]
 801b484: 460b         	mov	r3, r1
 801b486: 607a         	str	r2, [r7, #0x4]
 801b488: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 801b48a: 7afb         	ldrb	r3, [r7, #0xb]
 801b48c: 687a         	ldr	r2, [r7, #0x4]
 801b48e: 4619         	mov	r1, r3
 801b490: 68f8         	ldr	r0, [r7, #0xc]
 801b492: f7ff ff54    	bl	0x801b33e <z_impl_gpio_pin_configure> @ imm = #-0x158
 801b496: 4603         	mov	r3, r0
; }
 801b498: 4618         	mov	r0, r3
 801b49a: 3710         	adds	r7, #0x10
 801b49c: 46bd         	mov	sp, r7
 801b49e: bd80         	pop	{r7, pc}

0801b4a0 <k_thread_create>:
; {
 801b4a0: b580         	push	{r7, lr}
 801b4a2: b08c         	sub	sp, #0x30
 801b4a4: af08         	add	r7, sp, #0x20
 801b4a6: 60f8         	str	r0, [r7, #0xc]
 801b4a8: 60b9         	str	r1, [r7, #0x8]
 801b4aa: 607a         	str	r2, [r7, #0x4]
 801b4ac: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 801b4ae: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801b4b2: e9cd 2306    	strd	r2, r3, [sp, #24]
 801b4b6: 6abb         	ldr	r3, [r7, #0x28]
 801b4b8: 9304         	str	r3, [sp, #0x10]
 801b4ba: 6a7b         	ldr	r3, [r7, #0x24]
 801b4bc: 9303         	str	r3, [sp, #0xc]
 801b4be: 6a3b         	ldr	r3, [r7, #0x20]
 801b4c0: 9302         	str	r3, [sp, #0x8]
 801b4c2: 69fb         	ldr	r3, [r7, #0x1c]
 801b4c4: 9301         	str	r3, [sp, #0x4]
 801b4c6: 69bb         	ldr	r3, [r7, #0x18]
 801b4c8: 9300         	str	r3, [sp]
 801b4ca: 683b         	ldr	r3, [r7]
 801b4cc: 687a         	ldr	r2, [r7, #0x4]
 801b4ce: 68b9         	ldr	r1, [r7, #0x8]
 801b4d0: 68f8         	ldr	r0, [r7, #0xc]
 801b4d2: f003 fd85    	bl	0x801efe0 <z_impl_k_thread_create> @ imm = #0x3b0a
 801b4d6: 4603         	mov	r3, r0
; }
 801b4d8: 4618         	mov	r0, r3
 801b4da: 3710         	adds	r7, #0x10
 801b4dc: 46bd         	mov	sp, r7
 801b4de: bd80         	pop	{r7, pc}

0801b4e0 <k_thread_name_set>:
; {
 801b4e0: b580         	push	{r7, lr}
 801b4e2: b082         	sub	sp, #0x8
 801b4e4: af00         	add	r7, sp, #0x0
 801b4e6: 6078         	str	r0, [r7, #0x4]
 801b4e8: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 801b4ea: 6839         	ldr	r1, [r7]
 801b4ec: 6878         	ldr	r0, [r7, #0x4]
 801b4ee: f7f5 fac5    	bl	0x8010a7c <z_impl_k_thread_name_set> @ imm = #-0xaa76
 801b4f2: 4603         	mov	r3, r0
; }
 801b4f4: 4618         	mov	r0, r3
 801b4f6: 3708         	adds	r7, #0x8
 801b4f8: 46bd         	mov	sp, r7
 801b4fa: bd80         	pop	{r7, pc}

0801b4fc <k_sem_init>:
; {
 801b4fc: b580         	push	{r7, lr}
 801b4fe: b084         	sub	sp, #0x10
 801b500: af00         	add	r7, sp, #0x0
 801b502: 60f8         	str	r0, [r7, #0xc]
 801b504: 60b9         	str	r1, [r7, #0x8]
 801b506: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 801b508: 687a         	ldr	r2, [r7, #0x4]
 801b50a: 68b9         	ldr	r1, [r7, #0x8]
 801b50c: 68f8         	ldr	r0, [r7, #0xc]
 801b50e: f003 f8f0    	bl	0x801e6f2 <z_impl_k_sem_init> @ imm = #0x31e0
 801b512: 4603         	mov	r3, r0
; }
 801b514: 4618         	mov	r0, r3
 801b516: 3710         	adds	r7, #0x10
 801b518: 46bd         	mov	sp, r7
 801b51a: bd80         	pop	{r7, pc}

0801b51c <k_sem_take>:
; {
 801b51c: b580         	push	{r7, lr}
 801b51e: b084         	sub	sp, #0x10
 801b520: af00         	add	r7, sp, #0x0
 801b522: 60f8         	str	r0, [r7, #0xc]
 801b524: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 801b528: e9d7 2300    	ldrd	r2, r3, [r7]
 801b52c: 68f8         	ldr	r0, [r7, #0xc]
 801b52e: f7f4 fed3    	bl	0x80102d8 <z_impl_k_sem_take> @ imm = #-0xb25a
 801b532: 4603         	mov	r3, r0
; }
 801b534: 4618         	mov	r0, r3
 801b536: 3710         	adds	r7, #0x10
 801b538: 46bd         	mov	sp, r7
 801b53a: bd80         	pop	{r7, pc}

0801b53c <k_sem_give>:
; {
 801b53c: b580         	push	{r7, lr}
 801b53e: b082         	sub	sp, #0x8
 801b540: af00         	add	r7, sp, #0x0
 801b542: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801b544: 6878         	ldr	r0, [r7, #0x4]
 801b546: f7f4 fe39    	bl	0x80101bc <z_impl_k_sem_give> @ imm = #-0xb38e
; }
 801b54a: bf00         	nop
 801b54c: 3708         	adds	r7, #0x8
 801b54e: 46bd         	mov	sp, r7
 801b550: bd80         	pop	{r7, pc}

0801b552 <z_log_msg_runtime_create>:
; {
 801b552: b580         	push	{r7, lr}
 801b554: b08a         	sub	sp, #0x28
 801b556: af04         	add	r7, sp, #0x10
 801b558: 60b9         	str	r1, [r7, #0x8]
 801b55a: 607b         	str	r3, [r7, #0x4]
 801b55c: 4603         	mov	r3, r0
 801b55e: 73fb         	strb	r3, [r7, #0xf]
 801b560: 4613         	mov	r3, r2
 801b562: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801b564: f107 032c    	add.w	r3, r7, #0x2c
 801b568: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801b56a: 7bba         	ldrb	r2, [r7, #0xe]
 801b56c: 7bf8         	ldrb	r0, [r7, #0xf]
 801b56e: 697b         	ldr	r3, [r7, #0x14]
 801b570: 9303         	str	r3, [sp, #0xc]
 801b572: 6abb         	ldr	r3, [r7, #0x28]
 801b574: 9302         	str	r3, [sp, #0x8]
 801b576: 6a7b         	ldr	r3, [r7, #0x24]
 801b578: 9301         	str	r3, [sp, #0x4]
 801b57a: 6a3b         	ldr	r3, [r7, #0x20]
 801b57c: 9300         	str	r3, [sp]
 801b57e: 687b         	ldr	r3, [r7, #0x4]
 801b580: 68b9         	ldr	r1, [r7, #0x8]
 801b582: f7e9 fff7    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x16012
; }
 801b586: bf00         	nop
 801b588: 3718         	adds	r7, #0x18
 801b58a: 46bd         	mov	sp, r7
 801b58c: bd80         	pop	{r7, pc}

0801b58e <bmi08x_handle_drdy_gyr>:
; {
 801b58e: b580         	push	{r7, lr}
 801b590: b084         	sub	sp, #0x10
 801b592: af00         	add	r7, sp, #0x0
 801b594: 6078         	str	r0, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 801b596: 687b         	ldr	r3, [r7, #0x4]
 801b598: 691b         	ldr	r3, [r3, #0x10]
 801b59a: 60fb         	str	r3, [r7, #0xc]
; 	if (data->handler_drdy_gyr) {
 801b59c: 68fb         	ldr	r3, [r7, #0xc]
 801b59e: f8d3 3940    	ldr.w	r3, [r3, #0x940]
 801b5a2: 2b00         	cmp	r3, #0x0
 801b5a4: d008         	beq	0x801b5b8 <bmi08x_handle_drdy_gyr+0x2a> @ imm = #0x10
; 		data->handler_drdy_gyr(dev, data->drdy_trig_gyr);
 801b5a6: 68fb         	ldr	r3, [r7, #0xc]
 801b5a8: f8d3 3940    	ldr.w	r3, [r3, #0x940]
 801b5ac: 68fa         	ldr	r2, [r7, #0xc]
 801b5ae: f8d2 2944    	ldr.w	r2, [r2, #0x944]
 801b5b2: 4611         	mov	r1, r2
 801b5b4: 6878         	ldr	r0, [r7, #0x4]
 801b5b6: 4798         	blx	r3
; }
 801b5b8: bf00         	nop
 801b5ba: 3710         	adds	r7, #0x10
 801b5bc: 46bd         	mov	sp, r7
 801b5be: bd80         	pop	{r7, pc}

0801b5c0 <bmi08x_handle_interrupts_gyr>:
; {
 801b5c0: b580         	push	{r7, lr}
 801b5c2: b084         	sub	sp, #0x10
 801b5c4: af00         	add	r7, sp, #0x0
 801b5c6: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = (const struct device *)arg;
 801b5c8: 687b         	ldr	r3, [r7, #0x4]
 801b5ca: 60fb         	str	r3, [r7, #0xc]
; 	bmi08x_handle_drdy_gyr(dev);
 801b5cc: 68f8         	ldr	r0, [r7, #0xc]
 801b5ce: f7ff ffde    	bl	0x801b58e <bmi08x_handle_drdy_gyr> @ imm = #-0x44
; }
 801b5d2: bf00         	nop
 801b5d4: 3710         	adds	r7, #0x10
 801b5d6: 46bd         	mov	sp, r7
 801b5d8: bd80         	pop	{r7, pc}

0801b5da <bmi08x_gyr_gpio_callback>:
; {
 801b5da: b580         	push	{r7, lr}
 801b5dc: b086         	sub	sp, #0x18
 801b5de: af00         	add	r7, sp, #0x0
 801b5e0: 60f8         	str	r0, [r7, #0xc]
 801b5e2: 60b9         	str	r1, [r7, #0x8]
 801b5e4: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = CONTAINER_OF(cb, struct bmi08x_gyro_data, gpio_cb);
 801b5e6: 68bb         	ldr	r3, [r7, #0x8]
 801b5e8: 617b         	str	r3, [r7, #0x14]
; 	k_sem_give(&data->sem);
 801b5ea: 697b         	ldr	r3, [r7, #0x14]
 801b5ec: f503 6313    	add.w	r3, r3, #0x930
 801b5f0: 4618         	mov	r0, r3
 801b5f2: f7ff ffa3    	bl	0x801b53c <k_sem_give>  @ imm = #-0xba
; }
 801b5f6: bf00         	nop
 801b5f8: 3718         	adds	r7, #0x18
 801b5fa: 46bd         	mov	sp, r7
 801b5fc: bd80         	pop	{r7, pc}

0801b5fe <bmi08x_trigger_set_gyr>:
; {
 801b5fe: b480         	push	{r7}
 801b600: b087         	sub	sp, #0x1c
 801b602: af00         	add	r7, sp, #0x0
 801b604: 60f8         	str	r0, [r7, #0xc]
 801b606: 60b9         	str	r1, [r7, #0x8]
 801b608: 607a         	str	r2, [r7, #0x4]
; 	struct bmi08x_gyro_data *data = dev->data;
 801b60a: 68fb         	ldr	r3, [r7, #0xc]
 801b60c: 691b         	ldr	r3, [r3, #0x10]
 801b60e: 617b         	str	r3, [r7, #0x14]
; 	if ((trig->chan == SENSOR_CHAN_GYRO_XYZ) && (trig->type == SENSOR_TRIG_DATA_READY)) {
 801b610: 68bb         	ldr	r3, [r7, #0x8]
 801b612: 885b         	ldrh	r3, [r3, #0x2]
 801b614: 2b07         	cmp	r3, #0x7
 801b616: d10d         	bne	0x801b634 <bmi08x_trigger_set_gyr+0x36> @ imm = #0x1a
 801b618: 68bb         	ldr	r3, [r7, #0x8]
 801b61a: 881b         	ldrh	r3, [r3]
 801b61c: 2b01         	cmp	r3, #0x1
 801b61e: d109         	bne	0x801b634 <bmi08x_trigger_set_gyr+0x36> @ imm = #0x12
; 		data->drdy_trig_gyr = trig;
 801b620: 697b         	ldr	r3, [r7, #0x14]
 801b622: 68ba         	ldr	r2, [r7, #0x8]
 801b624: f8c3 2944    	str.w	r2, [r3, #0x944]
; 		data->handler_drdy_gyr = handler;
 801b628: 697b         	ldr	r3, [r7, #0x14]
 801b62a: 687a         	ldr	r2, [r7, #0x4]
 801b62c: f8c3 2940    	str.w	r2, [r3, #0x940]
; 		return 0;
 801b630: 2300         	movs	r3, #0x0
 801b632: e001         	b	0x801b638 <bmi08x_trigger_set_gyr+0x3a> @ imm = #0x2
; 	return -ENOTSUP;
 801b634: f06f 0385    	mvn	r3, #0x85
; }
 801b638: 4618         	mov	r0, r3
 801b63a: 371c         	adds	r7, #0x1c
 801b63c: 46bd         	mov	sp, r7
 801b63e: f85d 7b04    	ldr	r7, [sp], #4
 801b642: 4770         	bx	lr

0801b644 <device_is_ready>:
; {
 801b644: b580         	push	{r7, lr}
 801b646: b082         	sub	sp, #0x8
 801b648: af00         	add	r7, sp, #0x0
 801b64a: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801b64c: 6878         	ldr	r0, [r7, #0x4]
 801b64e: f002 fcbf    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x297e
 801b652: 4603         	mov	r3, r0
; }
 801b654: 4618         	mov	r0, r3
 801b656: 3708         	adds	r7, #0x8
 801b658: 46bd         	mov	sp, r7
 801b65a: bd80         	pop	{r7, pc}

0801b65c <k_work_delayable_from_work>:
; {
 801b65c: b480         	push	{r7}
 801b65e: b083         	sub	sp, #0xc
 801b660: af00         	add	r7, sp, #0x0
 801b662: 6078         	str	r0, [r7, #0x4]
; 	return CONTAINER_OF(work, struct k_work_delayable, work);
 801b664: 687b         	ldr	r3, [r7, #0x4]
; }
 801b666: 4618         	mov	r0, r3
 801b668: 370c         	adds	r7, #0xc
 801b66a: 46bd         	mov	sp, r7
 801b66c: f85d 7b04    	ldr	r7, [sp], #4
 801b670: 4770         	bx	lr

0801b672 <clock_control_on>:
; {
 801b672: b580         	push	{r7, lr}
 801b674: b084         	sub	sp, #0x10
 801b676: af00         	add	r7, sp, #0x0
 801b678: 6078         	str	r0, [r7, #0x4]
 801b67a: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801b67c: 687b         	ldr	r3, [r7, #0x4]
 801b67e: 689b         	ldr	r3, [r3, #0x8]
 801b680: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801b682: 68fb         	ldr	r3, [r7, #0xc]
 801b684: 681b         	ldr	r3, [r3]
 801b686: 6839         	ldr	r1, [r7]
 801b688: 6878         	ldr	r0, [r7, #0x4]
 801b68a: 4798         	blx	r3
 801b68c: 4603         	mov	r3, r0
; }
 801b68e: 4618         	mov	r0, r3
 801b690: 3710         	adds	r7, #0x10
 801b692: 46bd         	mov	sp, r7
 801b694: bd80         	pop	{r7, pc}

0801b696 <clock_control_get_rate>:
; {
 801b696: b580         	push	{r7, lr}
 801b698: b086         	sub	sp, #0x18
 801b69a: af00         	add	r7, sp, #0x0
 801b69c: 60f8         	str	r0, [r7, #0xc]
 801b69e: 60b9         	str	r1, [r7, #0x8]
 801b6a0: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 801b6a2: 68fb         	ldr	r3, [r7, #0xc]
 801b6a4: 689b         	ldr	r3, [r3, #0x8]
 801b6a6: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 801b6a8: 697b         	ldr	r3, [r7, #0x14]
 801b6aa: 68db         	ldr	r3, [r3, #0xc]
 801b6ac: 2b00         	cmp	r3, #0x0
 801b6ae: d102         	bne	0x801b6b6 <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 801b6b0: f06f 0357    	mvn	r3, #0x57
 801b6b4: e006         	b	0x801b6c4 <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 801b6b6: 697b         	ldr	r3, [r7, #0x14]
 801b6b8: 68db         	ldr	r3, [r3, #0xc]
 801b6ba: 687a         	ldr	r2, [r7, #0x4]
 801b6bc: 68b9         	ldr	r1, [r7, #0x8]
 801b6be: 68f8         	ldr	r0, [r7, #0xc]
 801b6c0: 4798         	blx	r3
 801b6c2: 4603         	mov	r3, r0
; }
 801b6c4: 4618         	mov	r0, r3
 801b6c6: 3718         	adds	r7, #0x18
 801b6c8: 46bd         	mov	sp, r7
 801b6ca: bd80         	pop	{r7, pc}

0801b6cc <dma_config>:
; {
 801b6cc: b580         	push	{r7, lr}
 801b6ce: b086         	sub	sp, #0x18
 801b6d0: af00         	add	r7, sp, #0x0
 801b6d2: 60f8         	str	r0, [r7, #0xc]
 801b6d4: 60b9         	str	r1, [r7, #0x8]
 801b6d6: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 801b6d8: 68fb         	ldr	r3, [r7, #0xc]
 801b6da: 689b         	ldr	r3, [r3, #0x8]
 801b6dc: 617b         	str	r3, [r7, #0x14]
; 	return api->config(dev, channel, config);
 801b6de: 697b         	ldr	r3, [r7, #0x14]
 801b6e0: 681b         	ldr	r3, [r3]
 801b6e2: 687a         	ldr	r2, [r7, #0x4]
 801b6e4: 68b9         	ldr	r1, [r7, #0x8]
 801b6e6: 68f8         	ldr	r0, [r7, #0xc]
 801b6e8: 4798         	blx	r3
 801b6ea: 4603         	mov	r3, r0
; }
 801b6ec: 4618         	mov	r0, r3
 801b6ee: 3718         	adds	r7, #0x18
 801b6f0: 46bd         	mov	sp, r7
 801b6f2: bd80         	pop	{r7, pc}

0801b6f4 <dma_reload>:
; {
 801b6f4: b590         	push	{r4, r7, lr}
 801b6f6: b089         	sub	sp, #0x24
 801b6f8: af02         	add	r7, sp, #0x8
 801b6fa: 60f8         	str	r0, [r7, #0xc]
 801b6fc: 60b9         	str	r1, [r7, #0x8]
 801b6fe: 607a         	str	r2, [r7, #0x4]
 801b700: 603b         	str	r3, [r7]
; 	const struct dma_driver_api *api =
 801b702: 68fb         	ldr	r3, [r7, #0xc]
 801b704: 689b         	ldr	r3, [r3, #0x8]
 801b706: 617b         	str	r3, [r7, #0x14]
; 	if (api->reload) {
 801b708: 697b         	ldr	r3, [r7, #0x14]
 801b70a: 685b         	ldr	r3, [r3, #0x4]
 801b70c: 2b00         	cmp	r3, #0x0
 801b70e: d00a         	beq	0x801b726 <dma_reload+0x32> @ imm = #0x14
; 		return api->reload(dev, channel, src, dst, size);
 801b710: 697b         	ldr	r3, [r7, #0x14]
 801b712: 685c         	ldr	r4, [r3, #0x4]
 801b714: 6abb         	ldr	r3, [r7, #0x28]
 801b716: 9300         	str	r3, [sp]
 801b718: 683b         	ldr	r3, [r7]
 801b71a: 687a         	ldr	r2, [r7, #0x4]
 801b71c: 68b9         	ldr	r1, [r7, #0x8]
 801b71e: 68f8         	ldr	r0, [r7, #0xc]
 801b720: 47a0         	blx	r4
 801b722: 4603         	mov	r3, r0
 801b724: e001         	b	0x801b72a <dma_reload+0x36> @ imm = #0x2
; 	return -ENOSYS;
 801b726: f06f 0357    	mvn	r3, #0x57
; }
 801b72a: 4618         	mov	r0, r3
 801b72c: 371c         	adds	r7, #0x1c
 801b72e: 46bd         	mov	sp, r7
 801b730: bd90         	pop	{r4, r7, pc}

0801b732 <z_impl_dma_start>:
; {
 801b732: b580         	push	{r7, lr}
 801b734: b084         	sub	sp, #0x10
 801b736: af00         	add	r7, sp, #0x0
 801b738: 6078         	str	r0, [r7, #0x4]
 801b73a: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 801b73c: 687b         	ldr	r3, [r7, #0x4]
 801b73e: 689b         	ldr	r3, [r3, #0x8]
 801b740: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev, channel);
 801b742: 68fb         	ldr	r3, [r7, #0xc]
 801b744: 689b         	ldr	r3, [r3, #0x8]
 801b746: 6839         	ldr	r1, [r7]
 801b748: 6878         	ldr	r0, [r7, #0x4]
 801b74a: 4798         	blx	r3
 801b74c: 4603         	mov	r3, r0
; }
 801b74e: 4618         	mov	r0, r3
 801b750: 3710         	adds	r7, #0x10
 801b752: 46bd         	mov	sp, r7
 801b754: bd80         	pop	{r7, pc}

0801b756 <z_impl_dma_stop>:
; {
 801b756: b580         	push	{r7, lr}
 801b758: b084         	sub	sp, #0x10
 801b75a: af00         	add	r7, sp, #0x0
 801b75c: 6078         	str	r0, [r7, #0x4]
 801b75e: 6039         	str	r1, [r7]
; 	const struct dma_driver_api *api =
 801b760: 687b         	ldr	r3, [r7, #0x4]
 801b762: 689b         	ldr	r3, [r3, #0x8]
 801b764: 60fb         	str	r3, [r7, #0xc]
; 	return api->stop(dev, channel);
 801b766: 68fb         	ldr	r3, [r7, #0xc]
 801b768: 68db         	ldr	r3, [r3, #0xc]
 801b76a: 6839         	ldr	r1, [r7]
 801b76c: 6878         	ldr	r0, [r7, #0x4]
 801b76e: 4798         	blx	r3
 801b770: 4603         	mov	r3, r0
; }
 801b772: 4618         	mov	r0, r3
 801b774: 3710         	adds	r7, #0x10
 801b776: 46bd         	mov	sp, r7
 801b778: bd80         	pop	{r7, pc}

0801b77a <dma_get_status>:
; {
 801b77a: b580         	push	{r7, lr}
 801b77c: b086         	sub	sp, #0x18
 801b77e: af00         	add	r7, sp, #0x0
 801b780: 60f8         	str	r0, [r7, #0xc]
 801b782: 60b9         	str	r1, [r7, #0x8]
 801b784: 607a         	str	r2, [r7, #0x4]
; 	const struct dma_driver_api *api =
 801b786: 68fb         	ldr	r3, [r7, #0xc]
 801b788: 689b         	ldr	r3, [r3, #0x8]
 801b78a: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_status) {
 801b78c: 697b         	ldr	r3, [r7, #0x14]
 801b78e: 699b         	ldr	r3, [r3, #0x18]
 801b790: 2b00         	cmp	r3, #0x0
 801b792: d007         	beq	0x801b7a4 <dma_get_status+0x2a> @ imm = #0xe
; 		return api->get_status(dev, channel, stat);
 801b794: 697b         	ldr	r3, [r7, #0x14]
 801b796: 699b         	ldr	r3, [r3, #0x18]
 801b798: 687a         	ldr	r2, [r7, #0x4]
 801b79a: 68b9         	ldr	r1, [r7, #0x8]
 801b79c: 68f8         	ldr	r0, [r7, #0xc]
 801b79e: 4798         	blx	r3
 801b7a0: 4603         	mov	r3, r0
 801b7a2: e001         	b	0x801b7a8 <dma_get_status+0x2e> @ imm = #0x2
; 	return -ENOSYS;
 801b7a4: f06f 0357    	mvn	r3, #0x57
; }
 801b7a8: 4618         	mov	r0, r3
 801b7aa: 3718         	adds	r7, #0x18
 801b7ac: 46bd         	mov	sp, r7
 801b7ae: bd80         	pop	{r7, pc}

0801b7b0 <dma_start>:
; {
 801b7b0: b580         	push	{r7, lr}
 801b7b2: b082         	sub	sp, #0x8
 801b7b4: af00         	add	r7, sp, #0x0
 801b7b6: 6078         	str	r0, [r7, #0x4]
 801b7b8: 6039         	str	r1, [r7]
; 	return z_impl_dma_start(dev, channel);
 801b7ba: 6839         	ldr	r1, [r7]
 801b7bc: 6878         	ldr	r0, [r7, #0x4]
 801b7be: f7ff ffb8    	bl	0x801b732 <z_impl_dma_start> @ imm = #-0x90
 801b7c2: 4603         	mov	r3, r0
; }
 801b7c4: 4618         	mov	r0, r3
 801b7c6: 3708         	adds	r7, #0x8
 801b7c8: 46bd         	mov	sp, r7
 801b7ca: bd80         	pop	{r7, pc}

0801b7cc <dma_stop>:
; {
 801b7cc: b580         	push	{r7, lr}
 801b7ce: b082         	sub	sp, #0x8
 801b7d0: af00         	add	r7, sp, #0x0
 801b7d2: 6078         	str	r0, [r7, #0x4]
 801b7d4: 6039         	str	r1, [r7]
; 	return z_impl_dma_stop(dev, channel);
 801b7d6: 6839         	ldr	r1, [r7]
 801b7d8: 6878         	ldr	r0, [r7, #0x4]
 801b7da: f7ff ffbc    	bl	0x801b756 <z_impl_dma_stop> @ imm = #-0x88
 801b7de: 4603         	mov	r3, r0
; }
 801b7e0: 4618         	mov	r0, r3
 801b7e2: 3708         	adds	r7, #0x8
 801b7e4: 46bd         	mov	sp, r7
 801b7e6: bd80         	pop	{r7, pc}

0801b7e8 <pinctrl_apply_state_direct>:
; {
 801b7e8: b580         	push	{r7, lr}
 801b7ea: b084         	sub	sp, #0x10
 801b7ec: af00         	add	r7, sp, #0x0
 801b7ee: 6078         	str	r0, [r7, #0x4]
 801b7f0: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 801b7f2: 2300         	movs	r3, #0x0
 801b7f4: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 801b7f6: 683b         	ldr	r3, [r7]
 801b7f8: 6818         	ldr	r0, [r3]
 801b7fa: 683b         	ldr	r3, [r7]
 801b7fc: 791b         	ldrb	r3, [r3, #0x4]
 801b7fe: 68fa         	ldr	r2, [r7, #0xc]
 801b800: 4619         	mov	r1, r3
 801b802: f7fe fb87    	bl	0x8019f14 <pinctrl_configure_pins> @ imm = #-0x18f2
 801b806: 4603         	mov	r3, r0
; }
 801b808: 4618         	mov	r0, r3
 801b80a: 3710         	adds	r7, #0x10
 801b80c: 46bd         	mov	sp, r7
 801b80e: bd80         	pop	{r7, pc}

0801b810 <pinctrl_apply_state>:
; {
 801b810: b580         	push	{r7, lr}
 801b812: b084         	sub	sp, #0x10
 801b814: af00         	add	r7, sp, #0x0
 801b816: 6078         	str	r0, [r7, #0x4]
 801b818: 460b         	mov	r3, r1
 801b81a: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 801b81c: f107 0208    	add.w	r2, r7, #0x8
 801b820: 78fb         	ldrb	r3, [r7, #0x3]
 801b822: 4619         	mov	r1, r3
 801b824: 6878         	ldr	r0, [r7, #0x4]
 801b826: f7fe fb3d    	bl	0x8019ea4 <pinctrl_lookup_state> @ imm = #-0x1986
 801b82a: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 801b82c: 68fb         	ldr	r3, [r7, #0xc]
 801b82e: 2b00         	cmp	r3, #0x0
 801b830: da01         	bge	0x801b836 <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 801b832: 68fb         	ldr	r3, [r7, #0xc]
 801b834: e005         	b	0x801b842 <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 801b836: 68bb         	ldr	r3, [r7, #0x8]
 801b838: 4619         	mov	r1, r3
 801b83a: 6878         	ldr	r0, [r7, #0x4]
 801b83c: f7ff ffd4    	bl	0x801b7e8 <pinctrl_apply_state_direct> @ imm = #-0x58
 801b840: 4603         	mov	r3, r0
; }
 801b842: 4618         	mov	r0, r3
 801b844: 3710         	adds	r7, #0x10
 801b846: 46bd         	mov	sp, r7
 801b848: bd80         	pop	{r7, pc}

0801b84a <z_impl_reset_line_toggle>:
; {
 801b84a: b580         	push	{r7, lr}
 801b84c: b084         	sub	sp, #0x10
 801b84e: af00         	add	r7, sp, #0x0
 801b850: 6078         	str	r0, [r7, #0x4]
 801b852: 6039         	str	r1, [r7]
; 	const struct reset_driver_api *api = (const struct reset_driver_api *)dev->api;
 801b854: 687b         	ldr	r3, [r7, #0x4]
 801b856: 689b         	ldr	r3, [r3, #0x8]
 801b858: 60fb         	str	r3, [r7, #0xc]
; 	if (api->line_toggle == NULL) {
 801b85a: 68fb         	ldr	r3, [r7, #0xc]
 801b85c: 68db         	ldr	r3, [r3, #0xc]
 801b85e: 2b00         	cmp	r3, #0x0
 801b860: d102         	bne	0x801b868 <z_impl_reset_line_toggle+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 801b862: f06f 0357    	mvn	r3, #0x57
 801b866: e005         	b	0x801b874 <z_impl_reset_line_toggle+0x2a> @ imm = #0xa
; 	return api->line_toggle(dev, id);
 801b868: 68fb         	ldr	r3, [r7, #0xc]
 801b86a: 68db         	ldr	r3, [r3, #0xc]
 801b86c: 6839         	ldr	r1, [r7]
 801b86e: 6878         	ldr	r0, [r7, #0x4]
 801b870: 4798         	blx	r3
 801b872: 4603         	mov	r3, r0
; }
 801b874: 4618         	mov	r0, r3
 801b876: 3710         	adds	r7, #0x10
 801b878: 46bd         	mov	sp, r7
 801b87a: bd80         	pop	{r7, pc}

0801b87c <reset_line_toggle_dt>:
; {
 801b87c: b580         	push	{r7, lr}
 801b87e: b082         	sub	sp, #0x8
 801b880: af00         	add	r7, sp, #0x0
 801b882: 6078         	str	r0, [r7, #0x4]
; 	return reset_line_toggle(spec->dev, spec->id);
 801b884: 687b         	ldr	r3, [r7, #0x4]
 801b886: 681a         	ldr	r2, [r3]
 801b888: 687b         	ldr	r3, [r7, #0x4]
 801b88a: 685b         	ldr	r3, [r3, #0x4]
 801b88c: 4619         	mov	r1, r3
 801b88e: 4610         	mov	r0, r2
 801b890: f000 f805    	bl	0x801b89e <reset_line_toggle> @ imm = #0xa
 801b894: 4603         	mov	r3, r0
; }
 801b896: 4618         	mov	r0, r3
 801b898: 3708         	adds	r7, #0x8
 801b89a: 46bd         	mov	sp, r7
 801b89c: bd80         	pop	{r7, pc}

0801b89e <reset_line_toggle>:
; {
 801b89e: b580         	push	{r7, lr}
 801b8a0: b082         	sub	sp, #0x8
 801b8a2: af00         	add	r7, sp, #0x0
 801b8a4: 6078         	str	r0, [r7, #0x4]
 801b8a6: 6039         	str	r1, [r7]
; 	return z_impl_reset_line_toggle(dev, id);
 801b8a8: 6839         	ldr	r1, [r7]
 801b8aa: 6878         	ldr	r0, [r7, #0x4]
 801b8ac: f7ff ffcd    	bl	0x801b84a <z_impl_reset_line_toggle> @ imm = #-0x66
 801b8b0: 4603         	mov	r3, r0
; }
 801b8b2: 4618         	mov	r0, r3
 801b8b4: 3708         	adds	r7, #0x8
 801b8b6: 46bd         	mov	sp, r7
 801b8b8: bd80         	pop	{r7, pc}

0801b8ba <LL_USART_Enable>:
; {
 801b8ba: b480         	push	{r7}
 801b8bc: b083         	sub	sp, #0xc
 801b8be: af00         	add	r7, sp, #0x0
 801b8c0: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR1, USART_CR1_UE);
 801b8c2: 687b         	ldr	r3, [r7, #0x4]
 801b8c4: 68db         	ldr	r3, [r3, #0xc]
 801b8c6: f443 5200    	orr	r2, r3, #0x2000
 801b8ca: 687b         	ldr	r3, [r7, #0x4]
 801b8cc: 60da         	str	r2, [r3, #0xc]
; }
 801b8ce: bf00         	nop
 801b8d0: 370c         	adds	r7, #0xc
 801b8d2: 46bd         	mov	sp, r7
 801b8d4: f85d 7b04    	ldr	r7, [sp], #4
 801b8d8: 4770         	bx	lr

0801b8da <LL_USART_Disable>:
; {
 801b8da: b480         	push	{r7}
 801b8dc: b083         	sub	sp, #0xc
 801b8de: af00         	add	r7, sp, #0x0
 801b8e0: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
 801b8e2: 687b         	ldr	r3, [r7, #0x4]
 801b8e4: 68db         	ldr	r3, [r3, #0xc]
 801b8e6: f423 5200    	bic	r2, r3, #0x2000
 801b8ea: 687b         	ldr	r3, [r7, #0x4]
 801b8ec: 60da         	str	r2, [r3, #0xc]
; }
 801b8ee: bf00         	nop
 801b8f0: 370c         	adds	r7, #0xc
 801b8f2: 46bd         	mov	sp, r7
 801b8f4: f85d 7b04    	ldr	r7, [sp], #4
 801b8f8: 4770         	bx	lr

0801b8fa <LL_USART_SetTransferDirection>:
; {
 801b8fa: b480         	push	{r7}
 801b8fc: b089         	sub	sp, #0x24
 801b8fe: af00         	add	r7, sp, #0x0
 801b900: 6078         	str	r0, [r7, #0x4]
 801b902: 6039         	str	r1, [r7]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 801b904: 687b         	ldr	r3, [r7, #0x4]
 801b906: 330c         	adds	r3, #0xc
 801b908: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801b90a: 68fb         	ldr	r3, [r7, #0xc]
 801b90c: e853 3f00    	ldrex	r3, [r3]
 801b910: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801b912: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 801b914: f023 030c    	bic	r3, r3, #0xc
 801b918: 683a         	ldr	r2, [r7]
 801b91a: 4313         	orrs	r3, r2
 801b91c: 61fb         	str	r3, [r7, #0x1c]
 801b91e: 687b         	ldr	r3, [r7, #0x4]
 801b920: 330c         	adds	r3, #0xc
 801b922: 69fa         	ldr	r2, [r7, #0x1c]
 801b924: 61ba         	str	r2, [r7, #0x18]
 801b926: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801b928: 6979         	ldr	r1, [r7, #0x14]
 801b92a: 69ba         	ldr	r2, [r7, #0x18]
 801b92c: e841 2300    	strex	r3, r2, [r1]
 801b930: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801b932: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 801b934: 2b00         	cmp	r3, #0x0
 801b936: d1e5         	bne	0x801b904 <LL_USART_SetTransferDirection+0xa> @ imm = #-0x36
; }
 801b938: bf00         	nop
 801b93a: bf00         	nop
 801b93c: 3724         	adds	r7, #0x24
 801b93e: 46bd         	mov	sp, r7
 801b940: f85d 7b04    	ldr	r7, [sp], #4
 801b944: 4770         	bx	lr

0801b946 <LL_USART_SetParity>:
; {
 801b946: b480         	push	{r7}
 801b948: b083         	sub	sp, #0xc
 801b94a: af00         	add	r7, sp, #0x0
 801b94c: 6078         	str	r0, [r7, #0x4]
 801b94e: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
 801b950: 687b         	ldr	r3, [r7, #0x4]
 801b952: 68db         	ldr	r3, [r3, #0xc]
 801b954: f423 62c0    	bic	r2, r3, #0x600
 801b958: 683b         	ldr	r3, [r7]
 801b95a: 431a         	orrs	r2, r3
 801b95c: 687b         	ldr	r3, [r7, #0x4]
 801b95e: 60da         	str	r2, [r3, #0xc]
; }
 801b960: bf00         	nop
 801b962: 370c         	adds	r7, #0xc
 801b964: 46bd         	mov	sp, r7
 801b966: f85d 7b04    	ldr	r7, [sp], #4
 801b96a: 4770         	bx	lr

0801b96c <LL_USART_GetParity>:
; {
 801b96c: b480         	push	{r7}
 801b96e: b083         	sub	sp, #0xc
 801b970: af00         	add	r7, sp, #0x0
 801b972: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
 801b974: 687b         	ldr	r3, [r7, #0x4]
 801b976: 68db         	ldr	r3, [r3, #0xc]
 801b978: f403 63c0    	and	r3, r3, #0x600
; }
 801b97c: 4618         	mov	r0, r3
 801b97e: 370c         	adds	r7, #0xc
 801b980: 46bd         	mov	sp, r7
 801b982: f85d 7b04    	ldr	r7, [sp], #4
 801b986: 4770         	bx	lr

0801b988 <LL_USART_SetDataWidth>:
; {
 801b988: b480         	push	{r7}
 801b98a: b083         	sub	sp, #0xc
 801b98c: af00         	add	r7, sp, #0x0
 801b98e: 6078         	str	r0, [r7, #0x4]
 801b990: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
 801b992: 687b         	ldr	r3, [r7, #0x4]
 801b994: 68db         	ldr	r3, [r3, #0xc]
 801b996: f423 5280    	bic	r2, r3, #0x1000
 801b99a: 683b         	ldr	r3, [r7]
 801b99c: 431a         	orrs	r2, r3
 801b99e: 687b         	ldr	r3, [r7, #0x4]
 801b9a0: 60da         	str	r2, [r3, #0xc]
; }
 801b9a2: bf00         	nop
 801b9a4: 370c         	adds	r7, #0xc
 801b9a6: 46bd         	mov	sp, r7
 801b9a8: f85d 7b04    	ldr	r7, [sp], #4
 801b9ac: 4770         	bx	lr

0801b9ae <LL_USART_GetDataWidth>:
; {
 801b9ae: b480         	push	{r7}
 801b9b0: b083         	sub	sp, #0xc
 801b9b2: af00         	add	r7, sp, #0x0
 801b9b4: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
 801b9b6: 687b         	ldr	r3, [r7, #0x4]
 801b9b8: 68db         	ldr	r3, [r3, #0xc]
 801b9ba: f403 5380    	and	r3, r3, #0x1000
; }
 801b9be: 4618         	mov	r0, r3
 801b9c0: 370c         	adds	r7, #0xc
 801b9c2: 46bd         	mov	sp, r7
 801b9c4: f85d 7b04    	ldr	r7, [sp], #4
 801b9c8: 4770         	bx	lr

0801b9ca <LL_USART_SetOverSampling>:
; {
 801b9ca: b480         	push	{r7}
 801b9cc: b083         	sub	sp, #0xc
 801b9ce: af00         	add	r7, sp, #0x0
 801b9d0: 6078         	str	r0, [r7, #0x4]
 801b9d2: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
 801b9d4: 687b         	ldr	r3, [r7, #0x4]
 801b9d6: 68db         	ldr	r3, [r3, #0xc]
 801b9d8: f423 4200    	bic	r2, r3, #0x8000
 801b9dc: 683b         	ldr	r3, [r7]
 801b9de: 431a         	orrs	r2, r3
 801b9e0: 687b         	ldr	r3, [r7, #0x4]
 801b9e2: 60da         	str	r2, [r3, #0xc]
; }
 801b9e4: bf00         	nop
 801b9e6: 370c         	adds	r7, #0xc
 801b9e8: 46bd         	mov	sp, r7
 801b9ea: f85d 7b04    	ldr	r7, [sp], #4
 801b9ee: 4770         	bx	lr

0801b9f0 <LL_USART_SetStopBitsLength>:
; {
 801b9f0: b480         	push	{r7}
 801b9f2: b083         	sub	sp, #0xc
 801b9f4: af00         	add	r7, sp, #0x0
 801b9f6: 6078         	str	r0, [r7, #0x4]
 801b9f8: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 801b9fa: 687b         	ldr	r3, [r7, #0x4]
 801b9fc: 691b         	ldr	r3, [r3, #0x10]
 801b9fe: f423 5240    	bic	r2, r3, #0x3000
 801ba02: 683b         	ldr	r3, [r7]
 801ba04: 431a         	orrs	r2, r3
 801ba06: 687b         	ldr	r3, [r7, #0x4]
 801ba08: 611a         	str	r2, [r3, #0x10]
; }
 801ba0a: bf00         	nop
 801ba0c: 370c         	adds	r7, #0xc
 801ba0e: 46bd         	mov	sp, r7
 801ba10: f85d 7b04    	ldr	r7, [sp], #4
 801ba14: 4770         	bx	lr

0801ba16 <LL_USART_GetStopBitsLength>:
; {
 801ba16: b480         	push	{r7}
 801ba18: b083         	sub	sp, #0xc
 801ba1a: af00         	add	r7, sp, #0x0
 801ba1c: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
 801ba1e: 687b         	ldr	r3, [r7, #0x4]
 801ba20: 691b         	ldr	r3, [r3, #0x10]
 801ba22: f403 5340    	and	r3, r3, #0x3000
; }
 801ba26: 4618         	mov	r0, r3
 801ba28: 370c         	adds	r7, #0xc
 801ba2a: 46bd         	mov	sp, r7
 801ba2c: f85d 7b04    	ldr	r7, [sp], #4
 801ba30: 4770         	bx	lr

0801ba32 <LL_USART_ConfigCharacter>:
; {
 801ba32: b480         	push	{r7}
 801ba34: b085         	sub	sp, #0x14
 801ba36: af00         	add	r7, sp, #0x0
 801ba38: 60f8         	str	r0, [r7, #0xc]
 801ba3a: 60b9         	str	r1, [r7, #0x8]
 801ba3c: 607a         	str	r2, [r7, #0x4]
 801ba3e: 603b         	str	r3, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
 801ba40: 68fb         	ldr	r3, [r7, #0xc]
 801ba42: 68db         	ldr	r3, [r3, #0xc]
 801ba44: f423 52b0    	bic	r2, r3, #0x1600
 801ba48: 6879         	ldr	r1, [r7, #0x4]
 801ba4a: 68bb         	ldr	r3, [r7, #0x8]
 801ba4c: 430b         	orrs	r3, r1
 801ba4e: 431a         	orrs	r2, r3
 801ba50: 68fb         	ldr	r3, [r7, #0xc]
 801ba52: 60da         	str	r2, [r3, #0xc]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 801ba54: 68fb         	ldr	r3, [r7, #0xc]
 801ba56: 691b         	ldr	r3, [r3, #0x10]
 801ba58: f423 5240    	bic	r2, r3, #0x3000
 801ba5c: 683b         	ldr	r3, [r7]
 801ba5e: 431a         	orrs	r2, r3
 801ba60: 68fb         	ldr	r3, [r7, #0xc]
 801ba62: 611a         	str	r2, [r3, #0x10]
; }
 801ba64: bf00         	nop
 801ba66: 3714         	adds	r7, #0x14
 801ba68: 46bd         	mov	sp, r7
 801ba6a: f85d 7b04    	ldr	r7, [sp], #4
 801ba6e: 4770         	bx	lr

0801ba70 <LL_USART_SetHWFlowCtrl>:
; {
 801ba70: b480         	push	{r7}
 801ba72: b083         	sub	sp, #0xc
 801ba74: af00         	add	r7, sp, #0x0
 801ba76: 6078         	str	r0, [r7, #0x4]
 801ba78: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 801ba7a: 687b         	ldr	r3, [r7, #0x4]
 801ba7c: 695b         	ldr	r3, [r3, #0x14]
 801ba7e: f423 7240    	bic	r2, r3, #0x300
 801ba82: 683b         	ldr	r3, [r7]
 801ba84: 431a         	orrs	r2, r3
 801ba86: 687b         	ldr	r3, [r7, #0x4]
 801ba88: 615a         	str	r2, [r3, #0x14]
; }
 801ba8a: bf00         	nop
 801ba8c: 370c         	adds	r7, #0xc
 801ba8e: 46bd         	mov	sp, r7
 801ba90: f85d 7b04    	ldr	r7, [sp], #4
 801ba94: 4770         	bx	lr

0801ba96 <LL_USART_GetHWFlowCtrl>:
; {
 801ba96: b480         	push	{r7}
 801ba98: b083         	sub	sp, #0xc
 801ba9a: af00         	add	r7, sp, #0x0
 801ba9c: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
 801ba9e: 687b         	ldr	r3, [r7, #0x4]
 801baa0: 695b         	ldr	r3, [r3, #0x14]
 801baa2: f403 7340    	and	r3, r3, #0x300
; }
 801baa6: 4618         	mov	r0, r3
 801baa8: 370c         	adds	r7, #0xc
 801baaa: 46bd         	mov	sp, r7
 801baac: f85d 7b04    	ldr	r7, [sp], #4
 801bab0: 4770         	bx	lr

0801bab2 <LL_USART_EnableHalfDuplex>:
; {
 801bab2: b480         	push	{r7}
 801bab4: b083         	sub	sp, #0xc
 801bab6: af00         	add	r7, sp, #0x0
 801bab8: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
 801baba: 687b         	ldr	r3, [r7, #0x4]
 801babc: 695b         	ldr	r3, [r3, #0x14]
 801babe: f043 0208    	orr	r2, r3, #0x8
 801bac2: 687b         	ldr	r3, [r7, #0x4]
 801bac4: 615a         	str	r2, [r3, #0x14]
; }
 801bac6: bf00         	nop
 801bac8: 370c         	adds	r7, #0xc
 801baca: 46bd         	mov	sp, r7
 801bacc: f85d 7b04    	ldr	r7, [sp], #4
 801bad0: 4770         	bx	lr

0801bad2 <LL_USART_IsActiveFlag_PE>:
; {
 801bad2: b480         	push	{r7}
 801bad4: b083         	sub	sp, #0xc
 801bad6: af00         	add	r7, sp, #0x0
 801bad8: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_PE) == (USART_SR_PE));
 801bada: 687b         	ldr	r3, [r7, #0x4]
 801badc: 681b         	ldr	r3, [r3]
 801bade: f003 0301    	and	r3, r3, #0x1
 801bae2: 2b01         	cmp	r3, #0x1
 801bae4: bf0c         	ite	eq
 801bae6: 2301         	moveq	r3, #0x1
 801bae8: 2300         	movne	r3, #0x0
 801baea: b2db         	uxtb	r3, r3
; }
 801baec: 4618         	mov	r0, r3
 801baee: 370c         	adds	r7, #0xc
 801baf0: 46bd         	mov	sp, r7
 801baf2: f85d 7b04    	ldr	r7, [sp], #4
 801baf6: 4770         	bx	lr

0801baf8 <LL_USART_IsActiveFlag_FE>:
; {
 801baf8: b480         	push	{r7}
 801bafa: b083         	sub	sp, #0xc
 801bafc: af00         	add	r7, sp, #0x0
 801bafe: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_FE) == (USART_SR_FE));
 801bb00: 687b         	ldr	r3, [r7, #0x4]
 801bb02: 681b         	ldr	r3, [r3]
 801bb04: f003 0302    	and	r3, r3, #0x2
 801bb08: 2b02         	cmp	r3, #0x2
 801bb0a: bf0c         	ite	eq
 801bb0c: 2301         	moveq	r3, #0x1
 801bb0e: 2300         	movne	r3, #0x0
 801bb10: b2db         	uxtb	r3, r3
; }
 801bb12: 4618         	mov	r0, r3
 801bb14: 370c         	adds	r7, #0xc
 801bb16: 46bd         	mov	sp, r7
 801bb18: f85d 7b04    	ldr	r7, [sp], #4
 801bb1c: 4770         	bx	lr

0801bb1e <LL_USART_IsActiveFlag_NE>:
; {
 801bb1e: b480         	push	{r7}
 801bb20: b083         	sub	sp, #0xc
 801bb22: af00         	add	r7, sp, #0x0
 801bb24: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_NE) == (USART_SR_NE));
 801bb26: 687b         	ldr	r3, [r7, #0x4]
 801bb28: 681b         	ldr	r3, [r3]
 801bb2a: f003 0304    	and	r3, r3, #0x4
 801bb2e: 2b04         	cmp	r3, #0x4
 801bb30: bf0c         	ite	eq
 801bb32: 2301         	moveq	r3, #0x1
 801bb34: 2300         	movne	r3, #0x0
 801bb36: b2db         	uxtb	r3, r3
; }
 801bb38: 4618         	mov	r0, r3
 801bb3a: 370c         	adds	r7, #0xc
 801bb3c: 46bd         	mov	sp, r7
 801bb3e: f85d 7b04    	ldr	r7, [sp], #4
 801bb42: 4770         	bx	lr

0801bb44 <LL_USART_IsActiveFlag_ORE>:
; {
 801bb44: b480         	push	{r7}
 801bb46: b083         	sub	sp, #0xc
 801bb48: af00         	add	r7, sp, #0x0
 801bb4a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_ORE) == (USART_SR_ORE));
 801bb4c: 687b         	ldr	r3, [r7, #0x4]
 801bb4e: 681b         	ldr	r3, [r3]
 801bb50: f003 0308    	and	r3, r3, #0x8
 801bb54: 2b08         	cmp	r3, #0x8
 801bb56: bf0c         	ite	eq
 801bb58: 2301         	moveq	r3, #0x1
 801bb5a: 2300         	movne	r3, #0x0
 801bb5c: b2db         	uxtb	r3, r3
; }
 801bb5e: 4618         	mov	r0, r3
 801bb60: 370c         	adds	r7, #0xc
 801bb62: 46bd         	mov	sp, r7
 801bb64: f85d 7b04    	ldr	r7, [sp], #4
 801bb68: 4770         	bx	lr

0801bb6a <LL_USART_IsActiveFlag_IDLE>:
; {
 801bb6a: b480         	push	{r7}
 801bb6c: b083         	sub	sp, #0xc
 801bb6e: af00         	add	r7, sp, #0x0
 801bb70: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_IDLE) == (USART_SR_IDLE));
 801bb72: 687b         	ldr	r3, [r7, #0x4]
 801bb74: 681b         	ldr	r3, [r3]
 801bb76: f003 0310    	and	r3, r3, #0x10
 801bb7a: 2b10         	cmp	r3, #0x10
 801bb7c: bf0c         	ite	eq
 801bb7e: 2301         	moveq	r3, #0x1
 801bb80: 2300         	movne	r3, #0x0
 801bb82: b2db         	uxtb	r3, r3
; }
 801bb84: 4618         	mov	r0, r3
 801bb86: 370c         	adds	r7, #0xc
 801bb88: 46bd         	mov	sp, r7
 801bb8a: f85d 7b04    	ldr	r7, [sp], #4
 801bb8e: 4770         	bx	lr

0801bb90 <LL_USART_IsActiveFlag_RXNE>:
; {
 801bb90: b480         	push	{r7}
 801bb92: b083         	sub	sp, #0xc
 801bb94: af00         	add	r7, sp, #0x0
 801bb96: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
 801bb98: 687b         	ldr	r3, [r7, #0x4]
 801bb9a: 681b         	ldr	r3, [r3]
 801bb9c: f003 0320    	and	r3, r3, #0x20
 801bba0: 2b20         	cmp	r3, #0x20
 801bba2: bf0c         	ite	eq
 801bba4: 2301         	moveq	r3, #0x1
 801bba6: 2300         	movne	r3, #0x0
 801bba8: b2db         	uxtb	r3, r3
; }
 801bbaa: 4618         	mov	r0, r3
 801bbac: 370c         	adds	r7, #0xc
 801bbae: 46bd         	mov	sp, r7
 801bbb0: f85d 7b04    	ldr	r7, [sp], #4
 801bbb4: 4770         	bx	lr

0801bbb6 <LL_USART_IsActiveFlag_TC>:
; {
 801bbb6: b480         	push	{r7}
 801bbb8: b083         	sub	sp, #0xc
 801bbba: af00         	add	r7, sp, #0x0
 801bbbc: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_TC) == (USART_SR_TC));
 801bbbe: 687b         	ldr	r3, [r7, #0x4]
 801bbc0: 681b         	ldr	r3, [r3]
 801bbc2: f003 0340    	and	r3, r3, #0x40
 801bbc6: 2b40         	cmp	r3, #0x40
 801bbc8: bf0c         	ite	eq
 801bbca: 2301         	moveq	r3, #0x1
 801bbcc: 2300         	movne	r3, #0x0
 801bbce: b2db         	uxtb	r3, r3
; }
 801bbd0: 4618         	mov	r0, r3
 801bbd2: 370c         	adds	r7, #0xc
 801bbd4: 46bd         	mov	sp, r7
 801bbd6: f85d 7b04    	ldr	r7, [sp], #4
 801bbda: 4770         	bx	lr

0801bbdc <LL_USART_IsActiveFlag_TXE>:
; {
 801bbdc: b480         	push	{r7}
 801bbde: b083         	sub	sp, #0xc
 801bbe0: af00         	add	r7, sp, #0x0
 801bbe2: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_TXE) == (USART_SR_TXE));
 801bbe4: 687b         	ldr	r3, [r7, #0x4]
 801bbe6: 681b         	ldr	r3, [r3]
 801bbe8: f003 0380    	and	r3, r3, #0x80
 801bbec: 2b80         	cmp	r3, #0x80
 801bbee: bf0c         	ite	eq
 801bbf0: 2301         	moveq	r3, #0x1
 801bbf2: 2300         	movne	r3, #0x0
 801bbf4: b2db         	uxtb	r3, r3
; }
 801bbf6: 4618         	mov	r0, r3
 801bbf8: 370c         	adds	r7, #0xc
 801bbfa: 46bd         	mov	sp, r7
 801bbfc: f85d 7b04    	ldr	r7, [sp], #4
 801bc00: 4770         	bx	lr

0801bc02 <LL_USART_IsActiveFlag_LBD>:
; {
 801bc02: b480         	push	{r7}
 801bc04: b083         	sub	sp, #0xc
 801bc06: af00         	add	r7, sp, #0x0
 801bc08: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_LBD) == (USART_SR_LBD));
 801bc0a: 687b         	ldr	r3, [r7, #0x4]
 801bc0c: 681b         	ldr	r3, [r3]
 801bc0e: f403 7380    	and	r3, r3, #0x100
 801bc12: f5b3 7f80    	cmp.w	r3, #0x100
 801bc16: bf0c         	ite	eq
 801bc18: 2301         	moveq	r3, #0x1
 801bc1a: 2300         	movne	r3, #0x0
 801bc1c: b2db         	uxtb	r3, r3
; }
 801bc1e: 4618         	mov	r0, r3
 801bc20: 370c         	adds	r7, #0xc
 801bc22: 46bd         	mov	sp, r7
 801bc24: f85d 7b04    	ldr	r7, [sp], #4
 801bc28: 4770         	bx	lr

0801bc2a <LL_USART_ClearFlag_PE>:
; {
 801bc2a: b480         	push	{r7}
 801bc2c: b085         	sub	sp, #0x14
 801bc2e: af00         	add	r7, sp, #0x0
 801bc30: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 801bc32: 687b         	ldr	r3, [r7, #0x4]
 801bc34: 681b         	ldr	r3, [r3]
 801bc36: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801bc38: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 801bc3a: 687b         	ldr	r3, [r7, #0x4]
 801bc3c: 685b         	ldr	r3, [r3, #0x4]
 801bc3e: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801bc40: 68fb         	ldr	r3, [r7, #0xc]
; }
 801bc42: bf00         	nop
 801bc44: 3714         	adds	r7, #0x14
 801bc46: 46bd         	mov	sp, r7
 801bc48: f85d 7b04    	ldr	r7, [sp], #4
 801bc4c: 4770         	bx	lr

0801bc4e <LL_USART_ClearFlag_FE>:
; {
 801bc4e: b480         	push	{r7}
 801bc50: b085         	sub	sp, #0x14
 801bc52: af00         	add	r7, sp, #0x0
 801bc54: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 801bc56: 687b         	ldr	r3, [r7, #0x4]
 801bc58: 681b         	ldr	r3, [r3]
 801bc5a: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801bc5c: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 801bc5e: 687b         	ldr	r3, [r7, #0x4]
 801bc60: 685b         	ldr	r3, [r3, #0x4]
 801bc62: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801bc64: 68fb         	ldr	r3, [r7, #0xc]
; }
 801bc66: bf00         	nop
 801bc68: 3714         	adds	r7, #0x14
 801bc6a: 46bd         	mov	sp, r7
 801bc6c: f85d 7b04    	ldr	r7, [sp], #4
 801bc70: 4770         	bx	lr

0801bc72 <LL_USART_ClearFlag_NE>:
; {
 801bc72: b480         	push	{r7}
 801bc74: b085         	sub	sp, #0x14
 801bc76: af00         	add	r7, sp, #0x0
 801bc78: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 801bc7a: 687b         	ldr	r3, [r7, #0x4]
 801bc7c: 681b         	ldr	r3, [r3]
 801bc7e: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801bc80: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 801bc82: 687b         	ldr	r3, [r7, #0x4]
 801bc84: 685b         	ldr	r3, [r3, #0x4]
 801bc86: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801bc88: 68fb         	ldr	r3, [r7, #0xc]
; }
 801bc8a: bf00         	nop
 801bc8c: 3714         	adds	r7, #0x14
 801bc8e: 46bd         	mov	sp, r7
 801bc90: f85d 7b04    	ldr	r7, [sp], #4
 801bc94: 4770         	bx	lr

0801bc96 <LL_USART_ClearFlag_ORE>:
; {
 801bc96: b480         	push	{r7}
 801bc98: b085         	sub	sp, #0x14
 801bc9a: af00         	add	r7, sp, #0x0
 801bc9c: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 801bc9e: 687b         	ldr	r3, [r7, #0x4]
 801bca0: 681b         	ldr	r3, [r3]
 801bca2: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801bca4: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 801bca6: 687b         	ldr	r3, [r7, #0x4]
 801bca8: 685b         	ldr	r3, [r3, #0x4]
 801bcaa: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801bcac: 68fb         	ldr	r3, [r7, #0xc]
; }
 801bcae: bf00         	nop
 801bcb0: 3714         	adds	r7, #0x14
 801bcb2: 46bd         	mov	sp, r7
 801bcb4: f85d 7b04    	ldr	r7, [sp], #4
 801bcb8: 4770         	bx	lr

0801bcba <LL_USART_ClearFlag_IDLE>:
; {
 801bcba: b480         	push	{r7}
 801bcbc: b085         	sub	sp, #0x14
 801bcbe: af00         	add	r7, sp, #0x0
 801bcc0: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 801bcc2: 687b         	ldr	r3, [r7, #0x4]
 801bcc4: 681b         	ldr	r3, [r3]
 801bcc6: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801bcc8: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 801bcca: 687b         	ldr	r3, [r7, #0x4]
 801bccc: 685b         	ldr	r3, [r3, #0x4]
 801bcce: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801bcd0: 68fb         	ldr	r3, [r7, #0xc]
; }
 801bcd2: bf00         	nop
 801bcd4: 3714         	adds	r7, #0x14
 801bcd6: 46bd         	mov	sp, r7
 801bcd8: f85d 7b04    	ldr	r7, [sp], #4
 801bcdc: 4770         	bx	lr

0801bcde <LL_USART_ClearFlag_TC>:
; {
 801bcde: b480         	push	{r7}
 801bce0: b083         	sub	sp, #0xc
 801bce2: af00         	add	r7, sp, #0x0
 801bce4: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_TC));
 801bce6: 687b         	ldr	r3, [r7, #0x4]
 801bce8: f06f 0240    	mvn	r2, #0x40
 801bcec: 601a         	str	r2, [r3]
; }
 801bcee: bf00         	nop
 801bcf0: 370c         	adds	r7, #0xc
 801bcf2: 46bd         	mov	sp, r7
 801bcf4: f85d 7b04    	ldr	r7, [sp], #4
 801bcf8: 4770         	bx	lr

0801bcfa <LL_USART_ClearFlag_RXNE>:
; {
 801bcfa: b480         	push	{r7}
 801bcfc: b083         	sub	sp, #0xc
 801bcfe: af00         	add	r7, sp, #0x0
 801bd00: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_RXNE));
 801bd02: 687b         	ldr	r3, [r7, #0x4]
 801bd04: f06f 0220    	mvn	r2, #0x20
 801bd08: 601a         	str	r2, [r3]
; }
 801bd0a: bf00         	nop
 801bd0c: 370c         	adds	r7, #0xc
 801bd0e: 46bd         	mov	sp, r7
 801bd10: f85d 7b04    	ldr	r7, [sp], #4
 801bd14: 4770         	bx	lr

0801bd16 <LL_USART_ClearFlag_LBD>:
; {
 801bd16: b480         	push	{r7}
 801bd18: b083         	sub	sp, #0xc
 801bd1a: af00         	add	r7, sp, #0x0
 801bd1c: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_LBD));
 801bd1e: 687b         	ldr	r3, [r7, #0x4]
 801bd20: f46f 7280    	mvn	r2, #0x100
 801bd24: 601a         	str	r2, [r3]
; }
 801bd26: bf00         	nop
 801bd28: 370c         	adds	r7, #0xc
 801bd2a: 46bd         	mov	sp, r7
 801bd2c: f85d 7b04    	ldr	r7, [sp], #4
 801bd30: 4770         	bx	lr

0801bd32 <LL_USART_EnableIT_IDLE>:
; {
 801bd32: b480         	push	{r7}
 801bd34: b089         	sub	sp, #0x24
 801bd36: af00         	add	r7, sp, #0x0
 801bd38: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 801bd3a: 687b         	ldr	r3, [r7, #0x4]
 801bd3c: 330c         	adds	r3, #0xc
 801bd3e: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801bd40: 68fb         	ldr	r3, [r7, #0xc]
 801bd42: e853 3f00    	ldrex	r3, [r3]
 801bd46: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801bd48: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 801bd4a: f043 0310    	orr	r3, r3, #0x10
 801bd4e: 61fb         	str	r3, [r7, #0x1c]
 801bd50: 687b         	ldr	r3, [r7, #0x4]
 801bd52: 330c         	adds	r3, #0xc
 801bd54: 69fa         	ldr	r2, [r7, #0x1c]
 801bd56: 61ba         	str	r2, [r7, #0x18]
 801bd58: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801bd5a: 6979         	ldr	r1, [r7, #0x14]
 801bd5c: 69ba         	ldr	r2, [r7, #0x18]
 801bd5e: e841 2300    	strex	r3, r2, [r1]
 801bd62: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801bd64: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 801bd66: 2b00         	cmp	r3, #0x0
 801bd68: d1e7         	bne	0x801bd3a <LL_USART_EnableIT_IDLE+0x8> @ imm = #-0x32
; }
 801bd6a: bf00         	nop
 801bd6c: bf00         	nop
 801bd6e: 3724         	adds	r7, #0x24
 801bd70: 46bd         	mov	sp, r7
 801bd72: f85d 7b04    	ldr	r7, [sp], #4
 801bd76: 4770         	bx	lr

0801bd78 <LL_USART_EnableIT_RXNE>:
; {
 801bd78: b480         	push	{r7}
 801bd7a: b089         	sub	sp, #0x24
 801bd7c: af00         	add	r7, sp, #0x0
 801bd7e: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 801bd80: 687b         	ldr	r3, [r7, #0x4]
 801bd82: 330c         	adds	r3, #0xc
 801bd84: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801bd86: 68fb         	ldr	r3, [r7, #0xc]
 801bd88: e853 3f00    	ldrex	r3, [r3]
 801bd8c: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801bd8e: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 801bd90: f043 0320    	orr	r3, r3, #0x20
 801bd94: 61fb         	str	r3, [r7, #0x1c]
 801bd96: 687b         	ldr	r3, [r7, #0x4]
 801bd98: 330c         	adds	r3, #0xc
 801bd9a: 69fa         	ldr	r2, [r7, #0x1c]
 801bd9c: 61ba         	str	r2, [r7, #0x18]
 801bd9e: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801bda0: 6979         	ldr	r1, [r7, #0x14]
 801bda2: 69ba         	ldr	r2, [r7, #0x18]
 801bda4: e841 2300    	strex	r3, r2, [r1]
 801bda8: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801bdaa: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 801bdac: 2b00         	cmp	r3, #0x0
 801bdae: d1e7         	bne	0x801bd80 <LL_USART_EnableIT_RXNE+0x8> @ imm = #-0x32
; }
 801bdb0: bf00         	nop
 801bdb2: bf00         	nop
 801bdb4: 3724         	adds	r7, #0x24
 801bdb6: 46bd         	mov	sp, r7
 801bdb8: f85d 7b04    	ldr	r7, [sp], #4
 801bdbc: 4770         	bx	lr

0801bdbe <LL_USART_EnableIT_TC>:
; {
 801bdbe: b480         	push	{r7}
 801bdc0: b089         	sub	sp, #0x24
 801bdc2: af00         	add	r7, sp, #0x0
 801bdc4: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 801bdc6: 687b         	ldr	r3, [r7, #0x4]
 801bdc8: 330c         	adds	r3, #0xc
 801bdca: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801bdcc: 68fb         	ldr	r3, [r7, #0xc]
 801bdce: e853 3f00    	ldrex	r3, [r3]
 801bdd2: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801bdd4: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 801bdd6: f043 0340    	orr	r3, r3, #0x40
 801bdda: 61fb         	str	r3, [r7, #0x1c]
 801bddc: 687b         	ldr	r3, [r7, #0x4]
 801bdde: 330c         	adds	r3, #0xc
 801bde0: 69fa         	ldr	r2, [r7, #0x1c]
 801bde2: 61ba         	str	r2, [r7, #0x18]
 801bde4: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801bde6: 6979         	ldr	r1, [r7, #0x14]
 801bde8: 69ba         	ldr	r2, [r7, #0x18]
 801bdea: e841 2300    	strex	r3, r2, [r1]
 801bdee: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801bdf0: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 801bdf2: 2b00         	cmp	r3, #0x0
 801bdf4: d1e7         	bne	0x801bdc6 <LL_USART_EnableIT_TC+0x8> @ imm = #-0x32
; }
 801bdf6: bf00         	nop
 801bdf8: bf00         	nop
 801bdfa: 3724         	adds	r7, #0x24
 801bdfc: 46bd         	mov	sp, r7
 801bdfe: f85d 7b04    	ldr	r7, [sp], #4
 801be02: 4770         	bx	lr

0801be04 <LL_USART_EnableIT_PE>:
; {
 801be04: b480         	push	{r7}
 801be06: b089         	sub	sp, #0x24
 801be08: af00         	add	r7, sp, #0x0
 801be0a: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 801be0c: 687b         	ldr	r3, [r7, #0x4]
 801be0e: 330c         	adds	r3, #0xc
 801be10: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801be12: 68fb         	ldr	r3, [r7, #0xc]
 801be14: e853 3f00    	ldrex	r3, [r3]
 801be18: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801be1a: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 801be1c: f443 7380    	orr	r3, r3, #0x100
 801be20: 61fb         	str	r3, [r7, #0x1c]
 801be22: 687b         	ldr	r3, [r7, #0x4]
 801be24: 330c         	adds	r3, #0xc
 801be26: 69fa         	ldr	r2, [r7, #0x1c]
 801be28: 61ba         	str	r2, [r7, #0x18]
 801be2a: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801be2c: 6979         	ldr	r1, [r7, #0x14]
 801be2e: 69ba         	ldr	r2, [r7, #0x18]
 801be30: e841 2300    	strex	r3, r2, [r1]
 801be34: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801be36: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_PEIE);
 801be38: 2b00         	cmp	r3, #0x0
 801be3a: d1e7         	bne	0x801be0c <LL_USART_EnableIT_PE+0x8> @ imm = #-0x32
; }
 801be3c: bf00         	nop
 801be3e: bf00         	nop
 801be40: 3724         	adds	r7, #0x24
 801be42: 46bd         	mov	sp, r7
 801be44: f85d 7b04    	ldr	r7, [sp], #4
 801be48: 4770         	bx	lr

0801be4a <LL_USART_EnableIT_LBD>:
; {
 801be4a: b480         	push	{r7}
 801be4c: b083         	sub	sp, #0xc
 801be4e: af00         	add	r7, sp, #0x0
 801be50: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR2, USART_CR2_LBDIE);
 801be52: 687b         	ldr	r3, [r7, #0x4]
 801be54: 691b         	ldr	r3, [r3, #0x10]
 801be56: f043 0240    	orr	r2, r3, #0x40
 801be5a: 687b         	ldr	r3, [r7, #0x4]
 801be5c: 611a         	str	r2, [r3, #0x10]
; }
 801be5e: bf00         	nop
 801be60: 370c         	adds	r7, #0xc
 801be62: 46bd         	mov	sp, r7
 801be64: f85d 7b04    	ldr	r7, [sp], #4
 801be68: 4770         	bx	lr

0801be6a <LL_USART_EnableIT_ERROR>:
; {
 801be6a: b480         	push	{r7}
 801be6c: b089         	sub	sp, #0x24
 801be6e: af00         	add	r7, sp, #0x0
 801be70: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 801be72: 687b         	ldr	r3, [r7, #0x4]
 801be74: 3314         	adds	r3, #0x14
 801be76: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801be78: 68fb         	ldr	r3, [r7, #0xc]
 801be7a: e853 3f00    	ldrex	r3, [r3]
 801be7e: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801be80: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 801be82: f043 0301    	orr	r3, r3, #0x1
 801be86: 61fb         	str	r3, [r7, #0x1c]
 801be88: 687b         	ldr	r3, [r7, #0x4]
 801be8a: 3314         	adds	r3, #0x14
 801be8c: 69fa         	ldr	r2, [r7, #0x1c]
 801be8e: 61ba         	str	r2, [r7, #0x18]
 801be90: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801be92: 6979         	ldr	r1, [r7, #0x14]
 801be94: 69ba         	ldr	r2, [r7, #0x18]
 801be96: e841 2300    	strex	r3, r2, [r1]
 801be9a: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801be9c: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 801be9e: 2b00         	cmp	r3, #0x0
 801bea0: d1e7         	bne	0x801be72 <LL_USART_EnableIT_ERROR+0x8> @ imm = #-0x32
; }
 801bea2: bf00         	nop
 801bea4: bf00         	nop
 801bea6: 3724         	adds	r7, #0x24
 801bea8: 46bd         	mov	sp, r7
 801beaa: f85d 7b04    	ldr	r7, [sp], #4
 801beae: 4770         	bx	lr

0801beb0 <LL_USART_DisableIT_IDLE>:
; {
 801beb0: b480         	push	{r7}
 801beb2: b089         	sub	sp, #0x24
 801beb4: af00         	add	r7, sp, #0x0
 801beb6: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 801beb8: 687b         	ldr	r3, [r7, #0x4]
 801beba: 330c         	adds	r3, #0xc
 801bebc: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801bebe: 68fb         	ldr	r3, [r7, #0xc]
 801bec0: e853 3f00    	ldrex	r3, [r3]
 801bec4: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801bec6: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 801bec8: f023 0310    	bic	r3, r3, #0x10
 801becc: 61fb         	str	r3, [r7, #0x1c]
 801bece: 687b         	ldr	r3, [r7, #0x4]
 801bed0: 330c         	adds	r3, #0xc
 801bed2: 69fa         	ldr	r2, [r7, #0x1c]
 801bed4: 61ba         	str	r2, [r7, #0x18]
 801bed6: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801bed8: 6979         	ldr	r1, [r7, #0x14]
 801beda: 69ba         	ldr	r2, [r7, #0x18]
 801bedc: e841 2300    	strex	r3, r2, [r1]
 801bee0: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801bee2: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_IDLEIE);
 801bee4: 2b00         	cmp	r3, #0x0
 801bee6: d1e7         	bne	0x801beb8 <LL_USART_DisableIT_IDLE+0x8> @ imm = #-0x32
; }
 801bee8: bf00         	nop
 801beea: bf00         	nop
 801beec: 3724         	adds	r7, #0x24
 801beee: 46bd         	mov	sp, r7
 801bef0: f85d 7b04    	ldr	r7, [sp], #4
 801bef4: 4770         	bx	lr

0801bef6 <LL_USART_DisableIT_RXNE>:
; {
 801bef6: b480         	push	{r7}
 801bef8: b089         	sub	sp, #0x24
 801befa: af00         	add	r7, sp, #0x0
 801befc: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 801befe: 687b         	ldr	r3, [r7, #0x4]
 801bf00: 330c         	adds	r3, #0xc
 801bf02: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801bf04: 68fb         	ldr	r3, [r7, #0xc]
 801bf06: e853 3f00    	ldrex	r3, [r3]
 801bf0a: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801bf0c: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 801bf0e: f023 0320    	bic	r3, r3, #0x20
 801bf12: 61fb         	str	r3, [r7, #0x1c]
 801bf14: 687b         	ldr	r3, [r7, #0x4]
 801bf16: 330c         	adds	r3, #0xc
 801bf18: 69fa         	ldr	r2, [r7, #0x1c]
 801bf1a: 61ba         	str	r2, [r7, #0x18]
 801bf1c: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801bf1e: 6979         	ldr	r1, [r7, #0x14]
 801bf20: 69ba         	ldr	r2, [r7, #0x18]
 801bf22: e841 2300    	strex	r3, r2, [r1]
 801bf26: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801bf28: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 801bf2a: 2b00         	cmp	r3, #0x0
 801bf2c: d1e7         	bne	0x801befe <LL_USART_DisableIT_RXNE+0x8> @ imm = #-0x32
; }
 801bf2e: bf00         	nop
 801bf30: bf00         	nop
 801bf32: 3724         	adds	r7, #0x24
 801bf34: 46bd         	mov	sp, r7
 801bf36: f85d 7b04    	ldr	r7, [sp], #4
 801bf3a: 4770         	bx	lr

0801bf3c <LL_USART_DisableIT_TC>:
; {
 801bf3c: b480         	push	{r7}
 801bf3e: b089         	sub	sp, #0x24
 801bf40: af00         	add	r7, sp, #0x0
 801bf42: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 801bf44: 687b         	ldr	r3, [r7, #0x4]
 801bf46: 330c         	adds	r3, #0xc
 801bf48: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801bf4a: 68fb         	ldr	r3, [r7, #0xc]
 801bf4c: e853 3f00    	ldrex	r3, [r3]
 801bf50: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801bf52: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 801bf54: f023 0340    	bic	r3, r3, #0x40
 801bf58: 61fb         	str	r3, [r7, #0x1c]
 801bf5a: 687b         	ldr	r3, [r7, #0x4]
 801bf5c: 330c         	adds	r3, #0xc
 801bf5e: 69fa         	ldr	r2, [r7, #0x1c]
 801bf60: 61ba         	str	r2, [r7, #0x18]
 801bf62: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801bf64: 6979         	ldr	r1, [r7, #0x14]
 801bf66: 69ba         	ldr	r2, [r7, #0x18]
 801bf68: e841 2300    	strex	r3, r2, [r1]
 801bf6c: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801bf6e: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 801bf70: 2b00         	cmp	r3, #0x0
 801bf72: d1e7         	bne	0x801bf44 <LL_USART_DisableIT_TC+0x8> @ imm = #-0x32
; }
 801bf74: bf00         	nop
 801bf76: bf00         	nop
 801bf78: 3724         	adds	r7, #0x24
 801bf7a: 46bd         	mov	sp, r7
 801bf7c: f85d 7b04    	ldr	r7, [sp], #4
 801bf80: 4770         	bx	lr

0801bf82 <LL_USART_DisableIT_PE>:
; {
 801bf82: b480         	push	{r7}
 801bf84: b089         	sub	sp, #0x24
 801bf86: af00         	add	r7, sp, #0x0
 801bf88: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 801bf8a: 687b         	ldr	r3, [r7, #0x4]
 801bf8c: 330c         	adds	r3, #0xc
 801bf8e: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801bf90: 68fb         	ldr	r3, [r7, #0xc]
 801bf92: e853 3f00    	ldrex	r3, [r3]
 801bf96: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801bf98: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 801bf9a: f423 7380    	bic	r3, r3, #0x100
 801bf9e: 61fb         	str	r3, [r7, #0x1c]
 801bfa0: 687b         	ldr	r3, [r7, #0x4]
 801bfa2: 330c         	adds	r3, #0xc
 801bfa4: 69fa         	ldr	r2, [r7, #0x1c]
 801bfa6: 61ba         	str	r2, [r7, #0x18]
 801bfa8: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801bfaa: 6979         	ldr	r1, [r7, #0x14]
 801bfac: 69ba         	ldr	r2, [r7, #0x18]
 801bfae: e841 2300    	strex	r3, r2, [r1]
 801bfb2: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801bfb4: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_PEIE);
 801bfb6: 2b00         	cmp	r3, #0x0
 801bfb8: d1e7         	bne	0x801bf8a <LL_USART_DisableIT_PE+0x8> @ imm = #-0x32
; }
 801bfba: bf00         	nop
 801bfbc: bf00         	nop
 801bfbe: 3724         	adds	r7, #0x24
 801bfc0: 46bd         	mov	sp, r7
 801bfc2: f85d 7b04    	ldr	r7, [sp], #4
 801bfc6: 4770         	bx	lr

0801bfc8 <LL_USART_DisableIT_LBD>:
; {
 801bfc8: b480         	push	{r7}
 801bfca: b083         	sub	sp, #0xc
 801bfcc: af00         	add	r7, sp, #0x0
 801bfce: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR2, USART_CR2_LBDIE);
 801bfd0: 687b         	ldr	r3, [r7, #0x4]
 801bfd2: 691b         	ldr	r3, [r3, #0x10]
 801bfd4: f023 0240    	bic	r2, r3, #0x40
 801bfd8: 687b         	ldr	r3, [r7, #0x4]
 801bfda: 611a         	str	r2, [r3, #0x10]
; }
 801bfdc: bf00         	nop
 801bfde: 370c         	adds	r7, #0xc
 801bfe0: 46bd         	mov	sp, r7
 801bfe2: f85d 7b04    	ldr	r7, [sp], #4
 801bfe6: 4770         	bx	lr

0801bfe8 <LL_USART_DisableIT_ERROR>:
; {
 801bfe8: b480         	push	{r7}
 801bfea: b089         	sub	sp, #0x24
 801bfec: af00         	add	r7, sp, #0x0
 801bfee: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 801bff0: 687b         	ldr	r3, [r7, #0x4]
 801bff2: 3314         	adds	r3, #0x14
 801bff4: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801bff6: 68fb         	ldr	r3, [r7, #0xc]
 801bff8: e853 3f00    	ldrex	r3, [r3]
 801bffc: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801bffe: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 801c000: f023 0301    	bic	r3, r3, #0x1
 801c004: 61fb         	str	r3, [r7, #0x1c]
 801c006: 687b         	ldr	r3, [r7, #0x4]
 801c008: 3314         	adds	r3, #0x14
 801c00a: 69fa         	ldr	r2, [r7, #0x1c]
 801c00c: 61ba         	str	r2, [r7, #0x18]
 801c00e: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801c010: 6979         	ldr	r1, [r7, #0x14]
 801c012: 69ba         	ldr	r2, [r7, #0x18]
 801c014: e841 2300    	strex	r3, r2, [r1]
 801c018: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801c01a: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_EIE);
 801c01c: 2b00         	cmp	r3, #0x0
 801c01e: d1e7         	bne	0x801bff0 <LL_USART_DisableIT_ERROR+0x8> @ imm = #-0x32
; }
 801c020: bf00         	nop
 801c022: bf00         	nop
 801c024: 3724         	adds	r7, #0x24
 801c026: 46bd         	mov	sp, r7
 801c028: f85d 7b04    	ldr	r7, [sp], #4
 801c02c: 4770         	bx	lr

0801c02e <LL_USART_IsEnabledIT_IDLE>:
; {
 801c02e: b480         	push	{r7}
 801c030: b083         	sub	sp, #0xc
 801c032: af00         	add	r7, sp, #0x0
 801c034: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_IDLEIE) == (USART_CR1_IDLEIE));
 801c036: 687b         	ldr	r3, [r7, #0x4]
 801c038: 68db         	ldr	r3, [r3, #0xc]
 801c03a: f003 0310    	and	r3, r3, #0x10
 801c03e: 2b10         	cmp	r3, #0x10
 801c040: bf0c         	ite	eq
 801c042: 2301         	moveq	r3, #0x1
 801c044: 2300         	movne	r3, #0x0
 801c046: b2db         	uxtb	r3, r3
; }
 801c048: 4618         	mov	r0, r3
 801c04a: 370c         	adds	r7, #0xc
 801c04c: 46bd         	mov	sp, r7
 801c04e: f85d 7b04    	ldr	r7, [sp], #4
 801c052: 4770         	bx	lr

0801c054 <LL_USART_IsEnabledIT_RXNE>:
; {
 801c054: b480         	push	{r7}
 801c056: b083         	sub	sp, #0xc
 801c058: af00         	add	r7, sp, #0x0
 801c05a: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE));
 801c05c: 687b         	ldr	r3, [r7, #0x4]
 801c05e: 68db         	ldr	r3, [r3, #0xc]
 801c060: f003 0320    	and	r3, r3, #0x20
 801c064: 2b20         	cmp	r3, #0x20
 801c066: bf0c         	ite	eq
 801c068: 2301         	moveq	r3, #0x1
 801c06a: 2300         	movne	r3, #0x0
 801c06c: b2db         	uxtb	r3, r3
; }
 801c06e: 4618         	mov	r0, r3
 801c070: 370c         	adds	r7, #0xc
 801c072: 46bd         	mov	sp, r7
 801c074: f85d 7b04    	ldr	r7, [sp], #4
 801c078: 4770         	bx	lr

0801c07a <LL_USART_IsEnabledIT_TC>:
; {
 801c07a: b480         	push	{r7}
 801c07c: b083         	sub	sp, #0xc
 801c07e: af00         	add	r7, sp, #0x0
 801c080: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->CR1, USART_CR1_TCIE) == (USART_CR1_TCIE));
 801c082: 687b         	ldr	r3, [r7, #0x4]
 801c084: 68db         	ldr	r3, [r3, #0xc]
 801c086: f003 0340    	and	r3, r3, #0x40
 801c08a: 2b40         	cmp	r3, #0x40
 801c08c: bf0c         	ite	eq
 801c08e: 2301         	moveq	r3, #0x1
 801c090: 2300         	movne	r3, #0x0
 801c092: b2db         	uxtb	r3, r3
; }
 801c094: 4618         	mov	r0, r3
 801c096: 370c         	adds	r7, #0xc
 801c098: 46bd         	mov	sp, r7
 801c09a: f85d 7b04    	ldr	r7, [sp], #4
 801c09e: 4770         	bx	lr

0801c0a0 <LL_USART_EnableDMAReq_RX>:
; {
 801c0a0: b480         	push	{r7}
 801c0a2: b089         	sub	sp, #0x24
 801c0a4: af00         	add	r7, sp, #0x0
 801c0a6: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 801c0a8: 687b         	ldr	r3, [r7, #0x4]
 801c0aa: 3314         	adds	r3, #0x14
 801c0ac: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801c0ae: 68fb         	ldr	r3, [r7, #0xc]
 801c0b0: e853 3f00    	ldrex	r3, [r3]
 801c0b4: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801c0b6: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 801c0b8: f043 0340    	orr	r3, r3, #0x40
 801c0bc: 61fb         	str	r3, [r7, #0x1c]
 801c0be: 687b         	ldr	r3, [r7, #0x4]
 801c0c0: 3314         	adds	r3, #0x14
 801c0c2: 69fa         	ldr	r2, [r7, #0x1c]
 801c0c4: 61ba         	str	r2, [r7, #0x18]
 801c0c6: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801c0c8: 6979         	ldr	r1, [r7, #0x14]
 801c0ca: 69ba         	ldr	r2, [r7, #0x18]
 801c0cc: e841 2300    	strex	r3, r2, [r1]
 801c0d0: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801c0d2: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAR);
 801c0d4: 2b00         	cmp	r3, #0x0
 801c0d6: d1e7         	bne	0x801c0a8 <LL_USART_EnableDMAReq_RX+0x8> @ imm = #-0x32
; }
 801c0d8: bf00         	nop
 801c0da: bf00         	nop
 801c0dc: 3724         	adds	r7, #0x24
 801c0de: 46bd         	mov	sp, r7
 801c0e0: f85d 7b04    	ldr	r7, [sp], #4
 801c0e4: 4770         	bx	lr

0801c0e6 <LL_USART_EnableDMAReq_TX>:
; {
 801c0e6: b480         	push	{r7}
 801c0e8: b089         	sub	sp, #0x24
 801c0ea: af00         	add	r7, sp, #0x0
 801c0ec: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 801c0ee: 687b         	ldr	r3, [r7, #0x4]
 801c0f0: 3314         	adds	r3, #0x14
 801c0f2: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801c0f4: 68fb         	ldr	r3, [r7, #0xc]
 801c0f6: e853 3f00    	ldrex	r3, [r3]
 801c0fa: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801c0fc: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 801c0fe: f043 0380    	orr	r3, r3, #0x80
 801c102: 61fb         	str	r3, [r7, #0x1c]
 801c104: 687b         	ldr	r3, [r7, #0x4]
 801c106: 3314         	adds	r3, #0x14
 801c108: 69fa         	ldr	r2, [r7, #0x1c]
 801c10a: 61ba         	str	r2, [r7, #0x18]
 801c10c: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801c10e: 6979         	ldr	r1, [r7, #0x14]
 801c110: 69ba         	ldr	r2, [r7, #0x18]
 801c112: e841 2300    	strex	r3, r2, [r1]
 801c116: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801c118: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_DMAT);
 801c11a: 2b00         	cmp	r3, #0x0
 801c11c: d1e7         	bne	0x801c0ee <LL_USART_EnableDMAReq_TX+0x8> @ imm = #-0x32
; }
 801c11e: bf00         	nop
 801c120: bf00         	nop
 801c122: 3724         	adds	r7, #0x24
 801c124: 46bd         	mov	sp, r7
 801c126: f85d 7b04    	ldr	r7, [sp], #4
 801c12a: 4770         	bx	lr

0801c12c <LL_USART_DisableDMAReq_TX>:
; {
 801c12c: b480         	push	{r7}
 801c12e: b089         	sub	sp, #0x24
 801c130: af00         	add	r7, sp, #0x0
 801c132: 6078         	str	r0, [r7, #0x4]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 801c134: 687b         	ldr	r3, [r7, #0x4]
 801c136: 3314         	adds	r3, #0x14
 801c138: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801c13a: 68fb         	ldr	r3, [r7, #0xc]
 801c13c: e853 3f00    	ldrex	r3, [r3]
 801c140: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 801c142: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 801c144: f023 0380    	bic	r3, r3, #0x80
 801c148: 61fb         	str	r3, [r7, #0x1c]
 801c14a: 687b         	ldr	r3, [r7, #0x4]
 801c14c: 3314         	adds	r3, #0x14
 801c14e: 69fa         	ldr	r2, [r7, #0x1c]
 801c150: 61ba         	str	r2, [r7, #0x18]
 801c152: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801c154: 6979         	ldr	r1, [r7, #0x14]
 801c156: 69ba         	ldr	r2, [r7, #0x18]
 801c158: e841 2300    	strex	r3, r2, [r1]
 801c15c: 613b         	str	r3, [r7, #0x10]
;    return(result);
 801c15e: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_CLEAR_BIT(USARTx->CR3, USART_CR3_DMAT);
 801c160: 2b00         	cmp	r3, #0x0
 801c162: d1e7         	bne	0x801c134 <LL_USART_DisableDMAReq_TX+0x8> @ imm = #-0x32
; }
 801c164: bf00         	nop
 801c166: bf00         	nop
 801c168: 3724         	adds	r7, #0x24
 801c16a: 46bd         	mov	sp, r7
 801c16c: f85d 7b04    	ldr	r7, [sp], #4
 801c170: 4770         	bx	lr

0801c172 <LL_USART_DMA_GetRegAddr>:
; {
 801c172: b480         	push	{r7}
 801c174: b083         	sub	sp, #0xc
 801c176: af00         	add	r7, sp, #0x0
 801c178: 6078         	str	r0, [r7, #0x4]
;   return ((uint32_t) &(USARTx->DR));
 801c17a: 687b         	ldr	r3, [r7, #0x4]
 801c17c: 3304         	adds	r3, #0x4
; }
 801c17e: 4618         	mov	r0, r3
 801c180: 370c         	adds	r7, #0xc
 801c182: 46bd         	mov	sp, r7
 801c184: f85d 7b04    	ldr	r7, [sp], #4
 801c188: 4770         	bx	lr

0801c18a <LL_USART_ReceiveData8>:
; {
 801c18a: b480         	push	{r7}
 801c18c: b083         	sub	sp, #0xc
 801c18e: af00         	add	r7, sp, #0x0
 801c190: 6078         	str	r0, [r7, #0x4]
;   return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
 801c192: 687b         	ldr	r3, [r7, #0x4]
 801c194: 685b         	ldr	r3, [r3, #0x4]
 801c196: b2db         	uxtb	r3, r3
; }
 801c198: 4618         	mov	r0, r3
 801c19a: 370c         	adds	r7, #0xc
 801c19c: 46bd         	mov	sp, r7
 801c19e: f85d 7b04    	ldr	r7, [sp], #4
 801c1a2: 4770         	bx	lr

0801c1a4 <LL_USART_TransmitData8>:
; {
 801c1a4: b480         	push	{r7}
 801c1a6: b083         	sub	sp, #0xc
 801c1a8: af00         	add	r7, sp, #0x0
 801c1aa: 6078         	str	r0, [r7, #0x4]
 801c1ac: 460b         	mov	r3, r1
 801c1ae: 70fb         	strb	r3, [r7, #0x3]
;   USARTx->DR = Value;
 801c1b0: 78fa         	ldrb	r2, [r7, #0x3]
 801c1b2: 687b         	ldr	r3, [r7, #0x4]
 801c1b4: 605a         	str	r2, [r3, #0x4]
; }
 801c1b6: bf00         	nop
 801c1b8: 370c         	adds	r7, #0xc
 801c1ba: 46bd         	mov	sp, r7
 801c1bc: f85d 7b04    	ldr	r7, [sp], #4
 801c1c0: 4770         	bx	lr

0801c1c2 <z_log_msg_runtime_create>:
; {
 801c1c2: b580         	push	{r7, lr}
 801c1c4: b08a         	sub	sp, #0x28
 801c1c6: af04         	add	r7, sp, #0x10
 801c1c8: 60b9         	str	r1, [r7, #0x8]
 801c1ca: 607b         	str	r3, [r7, #0x4]
 801c1cc: 4603         	mov	r3, r0
 801c1ce: 73fb         	strb	r3, [r7, #0xf]
 801c1d0: 4613         	mov	r3, r2
 801c1d2: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801c1d4: f107 032c    	add.w	r3, r7, #0x2c
 801c1d8: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801c1da: 7bba         	ldrb	r2, [r7, #0xe]
 801c1dc: 7bf8         	ldrb	r0, [r7, #0xf]
 801c1de: 697b         	ldr	r3, [r7, #0x14]
 801c1e0: 9303         	str	r3, [sp, #0xc]
 801c1e2: 6abb         	ldr	r3, [r7, #0x28]
 801c1e4: 9302         	str	r3, [sp, #0x8]
 801c1e6: 6a7b         	ldr	r3, [r7, #0x24]
 801c1e8: 9301         	str	r3, [sp, #0x4]
 801c1ea: 6a3b         	ldr	r3, [r7, #0x20]
 801c1ec: 9300         	str	r3, [sp]
 801c1ee: 687b         	ldr	r3, [r7, #0x4]
 801c1f0: 68b9         	ldr	r1, [r7, #0x8]
 801c1f2: f7e9 f9bf    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x16c82
; }
 801c1f6: bf00         	nop
 801c1f8: 3718         	adds	r7, #0x18
 801c1fa: 46bd         	mov	sp, r7
 801c1fc: bd80         	pop	{r7, pc}

0801c1fe <uart_stm32_set_parity>:
; {
 801c1fe: b580         	push	{r7, lr}
 801c200: b084         	sub	sp, #0x10
 801c202: af00         	add	r7, sp, #0x0
 801c204: 6078         	str	r0, [r7, #0x4]
 801c206: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801c208: 687b         	ldr	r3, [r7, #0x4]
 801c20a: 685b         	ldr	r3, [r3, #0x4]
 801c20c: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetParity(config->usart, parity);
 801c20e: 68fb         	ldr	r3, [r7, #0xc]
 801c210: 681b         	ldr	r3, [r3]
 801c212: 6839         	ldr	r1, [r7]
 801c214: 4618         	mov	r0, r3
 801c216: f7ff fb96    	bl	0x801b946 <LL_USART_SetParity> @ imm = #-0x8d4
; }
 801c21a: bf00         	nop
 801c21c: 3710         	adds	r7, #0x10
 801c21e: 46bd         	mov	sp, r7
 801c220: bd80         	pop	{r7, pc}

0801c222 <uart_stm32_get_parity>:
; {
 801c222: b580         	push	{r7, lr}
 801c224: b084         	sub	sp, #0x10
 801c226: af00         	add	r7, sp, #0x0
 801c228: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801c22a: 687b         	ldr	r3, [r7, #0x4]
 801c22c: 685b         	ldr	r3, [r3, #0x4]
 801c22e: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetParity(config->usart);
 801c230: 68fb         	ldr	r3, [r7, #0xc]
 801c232: 681b         	ldr	r3, [r3]
 801c234: 4618         	mov	r0, r3
 801c236: f7ff fb99    	bl	0x801b96c <LL_USART_GetParity> @ imm = #-0x8ce
 801c23a: 4603         	mov	r3, r0
; }
 801c23c: 4618         	mov	r0, r3
 801c23e: 3710         	adds	r7, #0x10
 801c240: 46bd         	mov	sp, r7
 801c242: bd80         	pop	{r7, pc}

0801c244 <uart_stm32_set_stopbits>:
; {
 801c244: b580         	push	{r7, lr}
 801c246: b084         	sub	sp, #0x10
 801c248: af00         	add	r7, sp, #0x0
 801c24a: 6078         	str	r0, [r7, #0x4]
 801c24c: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801c24e: 687b         	ldr	r3, [r7, #0x4]
 801c250: 685b         	ldr	r3, [r3, #0x4]
 801c252: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetStopBitsLength(config->usart, stopbits);
 801c254: 68fb         	ldr	r3, [r7, #0xc]
 801c256: 681b         	ldr	r3, [r3]
 801c258: 6839         	ldr	r1, [r7]
 801c25a: 4618         	mov	r0, r3
 801c25c: f7ff fbc8    	bl	0x801b9f0 <LL_USART_SetStopBitsLength> @ imm = #-0x870
; }
 801c260: bf00         	nop
 801c262: 3710         	adds	r7, #0x10
 801c264: 46bd         	mov	sp, r7
 801c266: bd80         	pop	{r7, pc}

0801c268 <uart_stm32_get_stopbits>:
; {
 801c268: b580         	push	{r7, lr}
 801c26a: b084         	sub	sp, #0x10
 801c26c: af00         	add	r7, sp, #0x0
 801c26e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801c270: 687b         	ldr	r3, [r7, #0x4]
 801c272: 685b         	ldr	r3, [r3, #0x4]
 801c274: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetStopBitsLength(config->usart);
 801c276: 68fb         	ldr	r3, [r7, #0xc]
 801c278: 681b         	ldr	r3, [r3]
 801c27a: 4618         	mov	r0, r3
 801c27c: f7ff fbcb    	bl	0x801ba16 <LL_USART_GetStopBitsLength> @ imm = #-0x86a
 801c280: 4603         	mov	r3, r0
; }
 801c282: 4618         	mov	r0, r3
 801c284: 3710         	adds	r7, #0x10
 801c286: 46bd         	mov	sp, r7
 801c288: bd80         	pop	{r7, pc}

0801c28a <uart_stm32_set_databits>:
; {
 801c28a: b580         	push	{r7, lr}
 801c28c: b084         	sub	sp, #0x10
 801c28e: af00         	add	r7, sp, #0x0
 801c290: 6078         	str	r0, [r7, #0x4]
 801c292: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801c294: 687b         	ldr	r3, [r7, #0x4]
 801c296: 685b         	ldr	r3, [r3, #0x4]
 801c298: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetDataWidth(config->usart, databits);
 801c29a: 68fb         	ldr	r3, [r7, #0xc]
 801c29c: 681b         	ldr	r3, [r3]
 801c29e: 6839         	ldr	r1, [r7]
 801c2a0: 4618         	mov	r0, r3
 801c2a2: f7ff fb71    	bl	0x801b988 <LL_USART_SetDataWidth> @ imm = #-0x91e
; }
 801c2a6: bf00         	nop
 801c2a8: 3710         	adds	r7, #0x10
 801c2aa: 46bd         	mov	sp, r7
 801c2ac: bd80         	pop	{r7, pc}

0801c2ae <uart_stm32_get_databits>:
; {
 801c2ae: b580         	push	{r7, lr}
 801c2b0: b084         	sub	sp, #0x10
 801c2b2: af00         	add	r7, sp, #0x0
 801c2b4: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801c2b6: 687b         	ldr	r3, [r7, #0x4]
 801c2b8: 685b         	ldr	r3, [r3, #0x4]
 801c2ba: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetDataWidth(config->usart);
 801c2bc: 68fb         	ldr	r3, [r7, #0xc]
 801c2be: 681b         	ldr	r3, [r3]
 801c2c0: 4618         	mov	r0, r3
 801c2c2: f7ff fb74    	bl	0x801b9ae <LL_USART_GetDataWidth> @ imm = #-0x918
 801c2c6: 4603         	mov	r3, r0
; }
 801c2c8: 4618         	mov	r0, r3
 801c2ca: 3710         	adds	r7, #0x10
 801c2cc: 46bd         	mov	sp, r7
 801c2ce: bd80         	pop	{r7, pc}

0801c2d0 <uart_stm32_set_hwctrl>:
; {
 801c2d0: b580         	push	{r7, lr}
 801c2d2: b084         	sub	sp, #0x10
 801c2d4: af00         	add	r7, sp, #0x0
 801c2d6: 6078         	str	r0, [r7, #0x4]
 801c2d8: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801c2da: 687b         	ldr	r3, [r7, #0x4]
 801c2dc: 685b         	ldr	r3, [r3, #0x4]
 801c2de: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetHWFlowCtrl(config->usart, hwctrl);
 801c2e0: 68fb         	ldr	r3, [r7, #0xc]
 801c2e2: 681b         	ldr	r3, [r3]
 801c2e4: 6839         	ldr	r1, [r7]
 801c2e6: 4618         	mov	r0, r3
 801c2e8: f7ff fbc2    	bl	0x801ba70 <LL_USART_SetHWFlowCtrl> @ imm = #-0x87c
; }
 801c2ec: bf00         	nop
 801c2ee: 3710         	adds	r7, #0x10
 801c2f0: 46bd         	mov	sp, r7
 801c2f2: bd80         	pop	{r7, pc}

0801c2f4 <uart_stm32_get_hwctrl>:
; {
 801c2f4: b580         	push	{r7, lr}
 801c2f6: b084         	sub	sp, #0x10
 801c2f8: af00         	add	r7, sp, #0x0
 801c2fa: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801c2fc: 687b         	ldr	r3, [r7, #0x4]
 801c2fe: 685b         	ldr	r3, [r3, #0x4]
 801c300: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetHWFlowCtrl(config->usart);
 801c302: 68fb         	ldr	r3, [r7, #0xc]
 801c304: 681b         	ldr	r3, [r3]
 801c306: 4618         	mov	r0, r3
 801c308: f7ff fbc5    	bl	0x801ba96 <LL_USART_GetHWFlowCtrl> @ imm = #-0x876
 801c30c: 4603         	mov	r3, r0
; }
 801c30e: 4618         	mov	r0, r3
 801c310: 3710         	adds	r7, #0x10
 801c312: 46bd         	mov	sp, r7
 801c314: bd80         	pop	{r7, pc}

0801c316 <uart_stm32_cfg2ll_parity>:
; {
 801c316: b480         	push	{r7}
 801c318: b083         	sub	sp, #0xc
 801c31a: af00         	add	r7, sp, #0x0
 801c31c: 4603         	mov	r3, r0
 801c31e: 71fb         	strb	r3, [r7, #0x7]
; 	switch (parity) {
 801c320: 79fb         	ldrb	r3, [r7, #0x7]
 801c322: 2b01         	cmp	r3, #0x1
 801c324: d002         	beq	0x801c32c <uart_stm32_cfg2ll_parity+0x16> @ imm = #0x4
 801c326: 2b02         	cmp	r3, #0x2
 801c328: d003         	beq	0x801c332 <uart_stm32_cfg2ll_parity+0x1c> @ imm = #0x6
 801c32a: e005         	b	0x801c338 <uart_stm32_cfg2ll_parity+0x22> @ imm = #0xa
; 		return LL_USART_PARITY_ODD;
 801c32c: f44f 63c0    	mov.w	r3, #0x600
 801c330: e003         	b	0x801c33a <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x6
; 		return LL_USART_PARITY_EVEN;
 801c332: f44f 6380    	mov.w	r3, #0x400
 801c336: e000         	b	0x801c33a <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x0
; 		return LL_USART_PARITY_NONE;
 801c338: 2300         	movs	r3, #0x0
; }
 801c33a: 4618         	mov	r0, r3
 801c33c: 370c         	adds	r7, #0xc
 801c33e: 46bd         	mov	sp, r7
 801c340: f85d 7b04    	ldr	r7, [sp], #4
 801c344: 4770         	bx	lr

0801c346 <uart_stm32_ll2cfg_parity>:
; {
 801c346: b480         	push	{r7}
 801c348: b083         	sub	sp, #0xc
 801c34a: af00         	add	r7, sp, #0x0
 801c34c: 6078         	str	r0, [r7, #0x4]
; 	switch (parity) {
 801c34e: 687b         	ldr	r3, [r7, #0x4]
 801c350: f5b3 6f80    	cmp.w	r3, #0x400
 801c354: d005         	beq	0x801c362 <uart_stm32_ll2cfg_parity+0x1c> @ imm = #0xa
 801c356: 687b         	ldr	r3, [r7, #0x4]
 801c358: f5b3 6fc0    	cmp.w	r3, #0x600
 801c35c: d103         	bne	0x801c366 <uart_stm32_ll2cfg_parity+0x20> @ imm = #0x6
; 		return UART_CFG_PARITY_ODD;
 801c35e: 2301         	movs	r3, #0x1
 801c360: e002         	b	0x801c368 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x4
; 		return UART_CFG_PARITY_EVEN;
 801c362: 2302         	movs	r3, #0x2
 801c364: e000         	b	0x801c368 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x0
; 		return UART_CFG_PARITY_NONE;
 801c366: 2300         	movs	r3, #0x0
; }
 801c368: 4618         	mov	r0, r3
 801c36a: 370c         	adds	r7, #0xc
 801c36c: 46bd         	mov	sp, r7
 801c36e: f85d 7b04    	ldr	r7, [sp], #4
 801c372: 4770         	bx	lr

0801c374 <uart_stm32_cfg2ll_stopbits>:
; {
 801c374: b480         	push	{r7}
 801c376: b083         	sub	sp, #0xc
 801c378: af00         	add	r7, sp, #0x0
 801c37a: 6078         	str	r0, [r7, #0x4]
 801c37c: 460b         	mov	r3, r1
 801c37e: 70fb         	strb	r3, [r7, #0x3]
; 	switch (sb) {
 801c380: 78fb         	ldrb	r3, [r7, #0x3]
 801c382: 2b02         	cmp	r3, #0x2
 801c384: d00b         	beq	0x801c39e <uart_stm32_cfg2ll_stopbits+0x2a> @ imm = #0x16
 801c386: 2b02         	cmp	r3, #0x2
 801c388: dc0c         	bgt	0x801c3a4 <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0x18
 801c38a: 2b00         	cmp	r3, #0x0
 801c38c: d002         	beq	0x801c394 <uart_stm32_cfg2ll_stopbits+0x20> @ imm = #0x4
 801c38e: 2b01         	cmp	r3, #0x1
 801c390: d003         	beq	0x801c39a <uart_stm32_cfg2ll_stopbits+0x26> @ imm = #0x6
 801c392: e007         	b	0x801c3a4 <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0xe
; 		return LL_USART_STOPBITS_0_5;
 801c394: f44f 5380    	mov.w	r3, #0x1000
 801c398: e006         	b	0x801c3a8 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0xc
; 		return LL_USART_STOPBITS_1;
 801c39a: 2300         	movs	r3, #0x0
 801c39c: e004         	b	0x801c3a8 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x8
; 		return LL_USART_STOPBITS_1_5;
 801c39e: f44f 5340    	mov.w	r3, #0x3000
 801c3a2: e001         	b	0x801c3a8 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x2
; 		return LL_USART_STOPBITS_2;
 801c3a4: f44f 5300    	mov.w	r3, #0x2000
; }
 801c3a8: 4618         	mov	r0, r3
 801c3aa: 370c         	adds	r7, #0xc
 801c3ac: 46bd         	mov	sp, r7
 801c3ae: f85d 7b04    	ldr	r7, [sp], #4
 801c3b2: 4770         	bx	lr

0801c3b4 <uart_stm32_ll2cfg_stopbits>:
; {
 801c3b4: b480         	push	{r7}
 801c3b6: b083         	sub	sp, #0xc
 801c3b8: af00         	add	r7, sp, #0x0
 801c3ba: 6078         	str	r0, [r7, #0x4]
; 	switch (sb) {
 801c3bc: 687b         	ldr	r3, [r7, #0x4]
 801c3be: f5b3 5f40    	cmp.w	r3, #0x3000
 801c3c2: d00e         	beq	0x801c3e2 <uart_stm32_ll2cfg_stopbits+0x2e> @ imm = #0x1c
 801c3c4: 687b         	ldr	r3, [r7, #0x4]
 801c3c6: f5b3 5f40    	cmp.w	r3, #0x3000
 801c3ca: d80c         	bhi	0x801c3e6 <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0x18
 801c3cc: 687b         	ldr	r3, [r7, #0x4]
 801c3ce: 2b00         	cmp	r3, #0x0
 801c3d0: d005         	beq	0x801c3de <uart_stm32_ll2cfg_stopbits+0x2a> @ imm = #0xa
 801c3d2: 687b         	ldr	r3, [r7, #0x4]
 801c3d4: f5b3 5f80    	cmp.w	r3, #0x1000
 801c3d8: d105         	bne	0x801c3e6 <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0xa
; 		return UART_CFG_STOP_BITS_0_5;
 801c3da: 2300         	movs	r3, #0x0
 801c3dc: e004         	b	0x801c3e8 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x8
; 		return UART_CFG_STOP_BITS_1;
 801c3de: 2301         	movs	r3, #0x1
 801c3e0: e002         	b	0x801c3e8 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x4
; 		return UART_CFG_STOP_BITS_1_5;
 801c3e2: 2302         	movs	r3, #0x2
 801c3e4: e000         	b	0x801c3e8 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x0
; 		return UART_CFG_STOP_BITS_2;
 801c3e6: 2303         	movs	r3, #0x3
; }
 801c3e8: 4618         	mov	r0, r3
 801c3ea: 370c         	adds	r7, #0xc
 801c3ec: 46bd         	mov	sp, r7
 801c3ee: f85d 7b04    	ldr	r7, [sp], #4
 801c3f2: 4770         	bx	lr

0801c3f4 <uart_stm32_cfg2ll_databits>:
; {
 801c3f4: b480         	push	{r7}
 801c3f6: b083         	sub	sp, #0xc
 801c3f8: af00         	add	r7, sp, #0x0
 801c3fa: 4603         	mov	r3, r0
 801c3fc: 460a         	mov	r2, r1
 801c3fe: 71fb         	strb	r3, [r7, #0x7]
 801c400: 4613         	mov	r3, r2
 801c402: 71bb         	strb	r3, [r7, #0x6]
; 	switch (db) {
 801c404: 79fb         	ldrb	r3, [r7, #0x7]
 801c406: 2b04         	cmp	r3, #0x4
 801c408: d102         	bne	0x801c410 <uart_stm32_cfg2ll_databits+0x1c> @ imm = #0x4
; 		return LL_USART_DATAWIDTH_9B;
 801c40a: f44f 5380    	mov.w	r3, #0x1000
 801c40e: e006         	b	0x801c41e <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0xc
; 		if (p == UART_CFG_PARITY_NONE) {
 801c410: 79bb         	ldrb	r3, [r7, #0x6]
 801c412: 2b00         	cmp	r3, #0x0
 801c414: d101         	bne	0x801c41a <uart_stm32_cfg2ll_databits+0x26> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_8B;
 801c416: 2300         	movs	r3, #0x0
 801c418: e001         	b	0x801c41e <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_9B;
 801c41a: f44f 5380    	mov.w	r3, #0x1000
; }
 801c41e: 4618         	mov	r0, r3
 801c420: 370c         	adds	r7, #0xc
 801c422: 46bd         	mov	sp, r7
 801c424: f85d 7b04    	ldr	r7, [sp], #4
 801c428: 4770         	bx	lr

0801c42a <uart_stm32_ll2cfg_databits>:
; {
 801c42a: b480         	push	{r7}
 801c42c: b083         	sub	sp, #0xc
 801c42e: af00         	add	r7, sp, #0x0
 801c430: 6078         	str	r0, [r7, #0x4]
 801c432: 6039         	str	r1, [r7]
; 	switch (db) {
 801c434: 687b         	ldr	r3, [r7, #0x4]
 801c436: f5b3 5f80    	cmp.w	r3, #0x1000
 801c43a: d106         	bne	0x801c44a <uart_stm32_ll2cfg_databits+0x20> @ imm = #0xc
; 		if (p == LL_USART_PARITY_NONE) {
 801c43c: 683b         	ldr	r3, [r7]
 801c43e: 2b00         	cmp	r3, #0x0
 801c440: d101         	bne	0x801c446 <uart_stm32_ll2cfg_databits+0x1c> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_9;
 801c442: 2304         	movs	r3, #0x4
 801c444: e007         	b	0x801c456 <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xe
; 			return UART_CFG_DATA_BITS_8;
 801c446: 2303         	movs	r3, #0x3
 801c448: e005         	b	0x801c456 <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xa
; 		if (p == LL_USART_PARITY_NONE) {
 801c44a: 683b         	ldr	r3, [r7]
 801c44c: 2b00         	cmp	r3, #0x0
 801c44e: d101         	bne	0x801c454 <uart_stm32_ll2cfg_databits+0x2a> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_8;
 801c450: 2303         	movs	r3, #0x3
 801c452: e000         	b	0x801c456 <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0x0
; 			return UART_CFG_DATA_BITS_7;
 801c454: 2302         	movs	r3, #0x2
; }
 801c456: 4618         	mov	r0, r3
 801c458: 370c         	adds	r7, #0xc
 801c45a: 46bd         	mov	sp, r7
 801c45c: f85d 7b04    	ldr	r7, [sp], #4
 801c460: 4770         	bx	lr

0801c462 <uart_stm32_cfg2ll_hwctrl>:
; {
 801c462: b480         	push	{r7}
 801c464: b083         	sub	sp, #0xc
 801c466: af00         	add	r7, sp, #0x0
 801c468: 4603         	mov	r3, r0
 801c46a: 71fb         	strb	r3, [r7, #0x7]
; 	if (fc == UART_CFG_FLOW_CTRL_RTS_CTS) {
 801c46c: 79fb         	ldrb	r3, [r7, #0x7]
 801c46e: 2b01         	cmp	r3, #0x1
 801c470: d102         	bne	0x801c478 <uart_stm32_cfg2ll_hwctrl+0x16> @ imm = #0x4
; 		return LL_USART_HWCONTROL_RTS_CTS;
 801c472: f44f 7340    	mov.w	r3, #0x300
 801c476: e005         	b	0x801c484 <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0xa
; 	} else if (fc == UART_CFG_FLOW_CTRL_RS485) {
 801c478: 79fb         	ldrb	r3, [r7, #0x7]
 801c47a: 2b03         	cmp	r3, #0x3
 801c47c: d101         	bne	0x801c482 <uart_stm32_cfg2ll_hwctrl+0x20> @ imm = #0x2
; 		return LL_USART_HWCONTROL_NONE;
 801c47e: 2300         	movs	r3, #0x0
 801c480: e000         	b	0x801c484 <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0x0
; 	return LL_USART_HWCONTROL_NONE;
 801c482: 2300         	movs	r3, #0x0
; }
 801c484: 4618         	mov	r0, r3
 801c486: 370c         	adds	r7, #0xc
 801c488: 46bd         	mov	sp, r7
 801c48a: f85d 7b04    	ldr	r7, [sp], #4
 801c48e: 4770         	bx	lr

0801c490 <uart_stm32_ll2cfg_hwctrl>:
; {
 801c490: b480         	push	{r7}
 801c492: b083         	sub	sp, #0xc
 801c494: af00         	add	r7, sp, #0x0
 801c496: 6078         	str	r0, [r7, #0x4]
; 	if (fc == LL_USART_HWCONTROL_RTS_CTS) {
 801c498: 687b         	ldr	r3, [r7, #0x4]
 801c49a: f5b3 7f40    	cmp.w	r3, #0x300
 801c49e: d101         	bne	0x801c4a4 <uart_stm32_ll2cfg_hwctrl+0x14> @ imm = #0x2
; 		return UART_CFG_FLOW_CTRL_RTS_CTS;
 801c4a0: 2301         	movs	r3, #0x1
 801c4a2: e000         	b	0x801c4a6 <uart_stm32_ll2cfg_hwctrl+0x16> @ imm = #0x0
; 	return UART_CFG_FLOW_CTRL_NONE;
 801c4a4: 2300         	movs	r3, #0x0
; }
 801c4a6: 4618         	mov	r0, r3
 801c4a8: 370c         	adds	r7, #0xc
 801c4aa: 46bd         	mov	sp, r7
 801c4ac: f85d 7b04    	ldr	r7, [sp], #4
 801c4b0: 4770         	bx	lr

0801c4b2 <uart_stm32_parameters_set>:
; {
 801c4b2: b580         	push	{r7, lr}
 801c4b4: b08a         	sub	sp, #0x28
 801c4b6: af00         	add	r7, sp, #0x0
 801c4b8: 6078         	str	r0, [r7, #0x4]
 801c4ba: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801c4bc: 687b         	ldr	r3, [r7, #0x4]
 801c4be: 685b         	ldr	r3, [r3, #0x4]
 801c4c0: 627b         	str	r3, [r7, #0x24]
; 	struct uart_stm32_data *data = dev->data;
 801c4c2: 687b         	ldr	r3, [r7, #0x4]
 801c4c4: 691b         	ldr	r3, [r3, #0x10]
 801c4c6: 623b         	str	r3, [r7, #0x20]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 801c4c8: 6a3b         	ldr	r3, [r7, #0x20]
 801c4ca: 685b         	ldr	r3, [r3, #0x4]
 801c4cc: 61fb         	str	r3, [r7, #0x1c]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 801c4ce: 683b         	ldr	r3, [r7]
 801c4d0: 791b         	ldrb	r3, [r3, #0x4]
 801c4d2: 4618         	mov	r0, r3
 801c4d4: f7ff ff1f    	bl	0x801c316 <uart_stm32_cfg2ll_parity> @ imm = #-0x1c2
 801c4d8: 61b8         	str	r0, [r7, #0x18]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 801c4da: 683b         	ldr	r3, [r7]
 801c4dc: 795b         	ldrb	r3, [r3, #0x5]
 801c4de: 4619         	mov	r1, r3
 801c4e0: 6a78         	ldr	r0, [r7, #0x24]
 801c4e2: f7ff ff47    	bl	0x801c374 <uart_stm32_cfg2ll_stopbits> @ imm = #-0x172
 801c4e6: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 801c4e8: 683b         	ldr	r3, [r7]
 801c4ea: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 801c4ec: 683b         	ldr	r3, [r7]
 801c4ee: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 801c4f0: 4619         	mov	r1, r3
 801c4f2: 4610         	mov	r0, r2
 801c4f4: f7ff ff7e    	bl	0x801c3f4 <uart_stm32_cfg2ll_databits> @ imm = #-0x104
 801c4f8: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t flowctrl = uart_stm32_cfg2ll_hwctrl(cfg->flow_ctrl);
 801c4fa: 683b         	ldr	r3, [r7]
 801c4fc: 79db         	ldrb	r3, [r3, #0x7]
 801c4fe: 4618         	mov	r0, r3
 801c500: f7ff ffaf    	bl	0x801c462 <uart_stm32_cfg2ll_hwctrl> @ imm = #-0xa2
 801c504: 60f8         	str	r0, [r7, #0xc]
; 	if (cfg == uart_cfg) {
 801c506: 683a         	ldr	r2, [r7]
 801c508: 69fb         	ldr	r3, [r7, #0x1c]
 801c50a: 429a         	cmp	r2, r3
 801c50c: d111         	bne	0x801c532 <uart_stm32_parameters_set+0x80> @ imm = #0x22
; 		LL_USART_ConfigCharacter(config->usart,
 801c50e: 6a7b         	ldr	r3, [r7, #0x24]
 801c510: 6818         	ldr	r0, [r3]
 801c512: 697b         	ldr	r3, [r7, #0x14]
 801c514: 69ba         	ldr	r2, [r7, #0x18]
 801c516: 6939         	ldr	r1, [r7, #0x10]
 801c518: f7ff fa8b    	bl	0x801ba32 <LL_USART_ConfigCharacter> @ imm = #-0xaea
; 		uart_stm32_set_hwctrl(dev, flowctrl);
 801c51c: 68f9         	ldr	r1, [r7, #0xc]
 801c51e: 6878         	ldr	r0, [r7, #0x4]
 801c520: f7ff fed6    	bl	0x801c2d0 <uart_stm32_set_hwctrl> @ imm = #-0x254
; 		uart_stm32_set_baudrate(dev, cfg->baudrate);
 801c524: 683b         	ldr	r3, [r7]
 801c526: 681b         	ldr	r3, [r3]
 801c528: 4619         	mov	r1, r3
 801c52a: 6878         	ldr	r0, [r7, #0x4]
 801c52c: f7ef faf8    	bl	0x800bb20 <uart_stm32_set_baudrate> @ imm = #-0x10a10
; }
 801c530: e03b         	b	0x801c5aa <uart_stm32_parameters_set+0xf8> @ imm = #0x76
; 		if (parity != uart_stm32_get_parity(dev)) {
 801c532: 6878         	ldr	r0, [r7, #0x4]
 801c534: f7ff fe75    	bl	0x801c222 <uart_stm32_get_parity> @ imm = #-0x316
 801c538: 4602         	mov	r2, r0
 801c53a: 69bb         	ldr	r3, [r7, #0x18]
 801c53c: 4293         	cmp	r3, r2
 801c53e: d003         	beq	0x801c548 <uart_stm32_parameters_set+0x96> @ imm = #0x6
; 			uart_stm32_set_parity(dev, parity);
 801c540: 69b9         	ldr	r1, [r7, #0x18]
 801c542: 6878         	ldr	r0, [r7, #0x4]
 801c544: f7ff fe5b    	bl	0x801c1fe <uart_stm32_set_parity> @ imm = #-0x34a
; 		if (stopbits != uart_stm32_get_stopbits(dev)) {
 801c548: 6878         	ldr	r0, [r7, #0x4]
 801c54a: f7ff fe8d    	bl	0x801c268 <uart_stm32_get_stopbits> @ imm = #-0x2e6
 801c54e: 4602         	mov	r2, r0
 801c550: 697b         	ldr	r3, [r7, #0x14]
 801c552: 4293         	cmp	r3, r2
 801c554: d003         	beq	0x801c55e <uart_stm32_parameters_set+0xac> @ imm = #0x6
; 			uart_stm32_set_stopbits(dev, stopbits);
 801c556: 6979         	ldr	r1, [r7, #0x14]
 801c558: 6878         	ldr	r0, [r7, #0x4]
 801c55a: f7ff fe73    	bl	0x801c244 <uart_stm32_set_stopbits> @ imm = #-0x31a
; 		if (databits != uart_stm32_get_databits(dev)) {
 801c55e: 6878         	ldr	r0, [r7, #0x4]
 801c560: f7ff fea5    	bl	0x801c2ae <uart_stm32_get_databits> @ imm = #-0x2b6
 801c564: 4602         	mov	r2, r0
 801c566: 693b         	ldr	r3, [r7, #0x10]
 801c568: 4293         	cmp	r3, r2
 801c56a: d003         	beq	0x801c574 <uart_stm32_parameters_set+0xc2> @ imm = #0x6
; 			uart_stm32_set_databits(dev, databits);
 801c56c: 6939         	ldr	r1, [r7, #0x10]
 801c56e: 6878         	ldr	r0, [r7, #0x4]
 801c570: f7ff fe8b    	bl	0x801c28a <uart_stm32_set_databits> @ imm = #-0x2ea
; 		if (flowctrl != uart_stm32_get_hwctrl(dev)) {
 801c574: 6878         	ldr	r0, [r7, #0x4]
 801c576: f7ff febd    	bl	0x801c2f4 <uart_stm32_get_hwctrl> @ imm = #-0x286
 801c57a: 4602         	mov	r2, r0
 801c57c: 68fb         	ldr	r3, [r7, #0xc]
 801c57e: 4293         	cmp	r3, r2
 801c580: d003         	beq	0x801c58a <uart_stm32_parameters_set+0xd8> @ imm = #0x6
; 			uart_stm32_set_hwctrl(dev, flowctrl);
 801c582: 68f9         	ldr	r1, [r7, #0xc]
 801c584: 6878         	ldr	r0, [r7, #0x4]
 801c586: f7ff fea3    	bl	0x801c2d0 <uart_stm32_set_hwctrl> @ imm = #-0x2ba
; 		if (cfg->baudrate != uart_cfg->baudrate) {
 801c58a: 683b         	ldr	r3, [r7]
 801c58c: 681a         	ldr	r2, [r3]
 801c58e: 69fb         	ldr	r3, [r7, #0x1c]
 801c590: 681b         	ldr	r3, [r3]
 801c592: 429a         	cmp	r2, r3
 801c594: d009         	beq	0x801c5aa <uart_stm32_parameters_set+0xf8> @ imm = #0x12
; 			uart_stm32_set_baudrate(dev, cfg->baudrate);
 801c596: 683b         	ldr	r3, [r7]
 801c598: 681b         	ldr	r3, [r3]
 801c59a: 4619         	mov	r1, r3
 801c59c: 6878         	ldr	r0, [r7, #0x4]
 801c59e: f7ef fabf    	bl	0x800bb20 <uart_stm32_set_baudrate> @ imm = #-0x10a82
; 			uart_cfg->baudrate = cfg->baudrate;
 801c5a2: 683b         	ldr	r3, [r7]
 801c5a4: 681a         	ldr	r2, [r3]
 801c5a6: 69fb         	ldr	r3, [r7, #0x1c]
 801c5a8: 601a         	str	r2, [r3]
; }
 801c5aa: bf00         	nop
 801c5ac: 3728         	adds	r7, #0x28
 801c5ae: 46bd         	mov	sp, r7
 801c5b0: bd80         	pop	{r7, pc}

0801c5b2 <uart_stm32_config_get>:
; {
 801c5b2: b590         	push	{r4, r7, lr}
 801c5b4: b085         	sub	sp, #0x14
 801c5b6: af00         	add	r7, sp, #0x0
 801c5b8: 6078         	str	r0, [r7, #0x4]
 801c5ba: 6039         	str	r1, [r7]
; 	struct uart_stm32_data *data = dev->data;
 801c5bc: 687b         	ldr	r3, [r7, #0x4]
 801c5be: 691b         	ldr	r3, [r3, #0x10]
 801c5c0: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 801c5c2: 68fb         	ldr	r3, [r7, #0xc]
 801c5c4: 685b         	ldr	r3, [r3, #0x4]
 801c5c6: 60bb         	str	r3, [r7, #0x8]
; 	cfg->baudrate = uart_cfg->baudrate;
 801c5c8: 68bb         	ldr	r3, [r7, #0x8]
 801c5ca: 681a         	ldr	r2, [r3]
 801c5cc: 683b         	ldr	r3, [r7]
 801c5ce: 601a         	str	r2, [r3]
; 	cfg->parity = uart_stm32_ll2cfg_parity(uart_stm32_get_parity(dev));
 801c5d0: 6878         	ldr	r0, [r7, #0x4]
 801c5d2: f7ff fe26    	bl	0x801c222 <uart_stm32_get_parity> @ imm = #-0x3b4
 801c5d6: 4603         	mov	r3, r0
 801c5d8: 4618         	mov	r0, r3
 801c5da: f7ff feb4    	bl	0x801c346 <uart_stm32_ll2cfg_parity> @ imm = #-0x298
 801c5de: 4603         	mov	r3, r0
 801c5e0: 461a         	mov	r2, r3
 801c5e2: 683b         	ldr	r3, [r7]
 801c5e4: 711a         	strb	r2, [r3, #0x4]
; 	cfg->stop_bits = uart_stm32_ll2cfg_stopbits(
 801c5e6: 6878         	ldr	r0, [r7, #0x4]
 801c5e8: f7ff fe3e    	bl	0x801c268 <uart_stm32_get_stopbits> @ imm = #-0x384
 801c5ec: 4603         	mov	r3, r0
 801c5ee: 4618         	mov	r0, r3
 801c5f0: f7ff fee0    	bl	0x801c3b4 <uart_stm32_ll2cfg_stopbits> @ imm = #-0x240
 801c5f4: 4603         	mov	r3, r0
 801c5f6: 461a         	mov	r2, r3
 801c5f8: 683b         	ldr	r3, [r7]
 801c5fa: 715a         	strb	r2, [r3, #0x5]
; 	cfg->data_bits = uart_stm32_ll2cfg_databits(
 801c5fc: 6878         	ldr	r0, [r7, #0x4]
 801c5fe: f7ff fe56    	bl	0x801c2ae <uart_stm32_get_databits> @ imm = #-0x354
 801c602: 4604         	mov	r4, r0
 801c604: 6878         	ldr	r0, [r7, #0x4]
 801c606: f7ff fe0c    	bl	0x801c222 <uart_stm32_get_parity> @ imm = #-0x3e8
 801c60a: 4603         	mov	r3, r0
 801c60c: 4619         	mov	r1, r3
 801c60e: 4620         	mov	r0, r4
 801c610: f7ff ff0b    	bl	0x801c42a <uart_stm32_ll2cfg_databits> @ imm = #-0x1ea
 801c614: 4603         	mov	r3, r0
 801c616: 461a         	mov	r2, r3
 801c618: 683b         	ldr	r3, [r7]
 801c61a: 719a         	strb	r2, [r3, #0x6]
; 	cfg->flow_ctrl = uart_stm32_ll2cfg_hwctrl(
 801c61c: 6878         	ldr	r0, [r7, #0x4]
 801c61e: f7ff fe69    	bl	0x801c2f4 <uart_stm32_get_hwctrl> @ imm = #-0x32e
 801c622: 4603         	mov	r3, r0
 801c624: 4618         	mov	r0, r3
 801c626: f7ff ff33    	bl	0x801c490 <uart_stm32_ll2cfg_hwctrl> @ imm = #-0x19a
 801c62a: 4603         	mov	r3, r0
 801c62c: 461a         	mov	r2, r3
 801c62e: 683b         	ldr	r3, [r7]
 801c630: 71da         	strb	r2, [r3, #0x7]
; 	return 0;
 801c632: 2300         	movs	r3, #0x0
; }
 801c634: 4618         	mov	r0, r3
 801c636: 3714         	adds	r7, #0x14
 801c638: 46bd         	mov	sp, r7
 801c63a: bd90         	pop	{r4, r7, pc}

0801c63c <uart_stm32_poll_in_visitor>:
; {
 801c63c: b580         	push	{r7, lr}
 801c63e: b086         	sub	sp, #0x18
 801c640: af00         	add	r7, sp, #0x0
 801c642: 60f8         	str	r0, [r7, #0xc]
 801c644: 60b9         	str	r1, [r7, #0x8]
 801c646: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801c648: 68fb         	ldr	r3, [r7, #0xc]
 801c64a: 685b         	ldr	r3, [r3, #0x4]
 801c64c: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 801c64e: 697b         	ldr	r3, [r7, #0x14]
 801c650: 681b         	ldr	r3, [r3]
 801c652: 613b         	str	r3, [r7, #0x10]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 801c654: 6938         	ldr	r0, [r7, #0x10]
 801c656: f7ff fa75    	bl	0x801bb44 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xb16
 801c65a: 4603         	mov	r3, r0
 801c65c: 2b00         	cmp	r3, #0x0
 801c65e: d002         	beq	0x801c666 <uart_stm32_poll_in_visitor+0x2a> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 801c660: 6938         	ldr	r0, [r7, #0x10]
 801c662: f7ff fb18    	bl	0x801bc96 <LL_USART_ClearFlag_ORE> @ imm = #-0x9d0
; 	if (!LL_USART_IsActiveFlag_RXNE(usart)) {
 801c666: 6938         	ldr	r0, [r7, #0x10]
 801c668: f7ff fa92    	bl	0x801bb90 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xadc
 801c66c: 4603         	mov	r3, r0
 801c66e: 2b00         	cmp	r3, #0x0
 801c670: d102         	bne	0x801c678 <uart_stm32_poll_in_visitor+0x3c> @ imm = #0x4
; 		return -1;
 801c672: f04f 33ff    	mov.w	r3, #0xffffffff
 801c676: e004         	b	0x801c682 <uart_stm32_poll_in_visitor+0x46> @ imm = #0x8
; 	get_fn(usart, in);
 801c678: 687b         	ldr	r3, [r7, #0x4]
 801c67a: 68b9         	ldr	r1, [r7, #0x8]
 801c67c: 6938         	ldr	r0, [r7, #0x10]
 801c67e: 4798         	blx	r3
; 	return 0;
 801c680: 2300         	movs	r3, #0x0
; }
 801c682: 4618         	mov	r0, r3
 801c684: 3718         	adds	r7, #0x18
 801c686: 46bd         	mov	sp, r7
 801c688: bd80         	pop	{r7, pc}

0801c68a <uart_stm32_poll_out_visitor>:
; {
 801c68a: b580         	push	{r7, lr}
 801c68c: b08e         	sub	sp, #0x38
 801c68e: af00         	add	r7, sp, #0x0
 801c690: 60f8         	str	r0, [r7, #0xc]
 801c692: 460b         	mov	r3, r1
 801c694: 607a         	str	r2, [r7, #0x4]
 801c696: 817b         	strh	r3, [r7, #0xa]
; 	const struct uart_stm32_config *config = dev->config;
 801c698: 68fb         	ldr	r3, [r7, #0xc]
 801c69a: 685b         	ldr	r3, [r3, #0x4]
 801c69c: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 801c69e: 6b7b         	ldr	r3, [r7, #0x34]
 801c6a0: 681b         	ldr	r3, [r3]
 801c6a2: 633b         	str	r3, [r7, #0x30]
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 801c6a4: 6b38         	ldr	r0, [r7, #0x30]
 801c6a6: f7ff fa99    	bl	0x801bbdc <LL_USART_IsActiveFlag_TXE> @ imm = #-0xace
 801c6aa: 4603         	mov	r3, r0
 801c6ac: 2b00         	cmp	r3, #0x0
 801c6ae: d0f9         	beq	0x801c6a4 <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0xe
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801c6b0: f3ef 8311    	mrs	r3, basepri
 801c6b4: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 801c6b6: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 801c6b8: 627b         	str	r3, [r7, #0x24]
 801c6ba: 2310         	movs	r3, #0x10
 801c6bc: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801c6be: 6a3b         	ldr	r3, [r7, #0x20]
 801c6c0: f383 8812    	msr	basepri_max, r3
; }
 801c6c4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801c6c6: f3bf 8f6f    	isb	sy
; }
 801c6ca: bf00         	nop
; 	return key;
 801c6cc: 6a7b         	ldr	r3, [r7, #0x24]
; 			key = irq_lock();
 801c6ce: 62fb         	str	r3, [r7, #0x2c]
; 			if (LL_USART_IsActiveFlag_TXE(usart)) {
 801c6d0: 6b38         	ldr	r0, [r7, #0x30]
 801c6d2: f7ff fa83    	bl	0x801bbdc <LL_USART_IsActiveFlag_TXE> @ imm = #-0xafa
 801c6d6: 4603         	mov	r3, r0
 801c6d8: 2b00         	cmp	r3, #0x0
 801c6da: d10c         	bne	0x801c6f6 <uart_stm32_poll_out_visitor+0x6c> @ imm = #0x18
 801c6dc: 6afb         	ldr	r3, [r7, #0x2c]
 801c6de: 61fb         	str	r3, [r7, #0x1c]
 801c6e0: 69fb         	ldr	r3, [r7, #0x1c]
 801c6e2: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801c6e4: 69bb         	ldr	r3, [r7, #0x18]
 801c6e6: f383 8811    	msr	basepri, r3
; }
 801c6ea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801c6ec: f3bf 8f6f    	isb	sy
; }
 801c6f0: bf00         	nop
; }
 801c6f2: bf00         	nop
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 801c6f4: e7d6         	b	0x801c6a4 <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0x54
; 				break;
 801c6f6: bf00         	nop
; 	set_fn(usart, out);
 801c6f8: 897a         	ldrh	r2, [r7, #0xa]
 801c6fa: 687b         	ldr	r3, [r7, #0x4]
 801c6fc: 4611         	mov	r1, r2
 801c6fe: 6b38         	ldr	r0, [r7, #0x30]
 801c700: 4798         	blx	r3
 801c702: 6afb         	ldr	r3, [r7, #0x2c]
 801c704: 617b         	str	r3, [r7, #0x14]
 801c706: 697b         	ldr	r3, [r7, #0x14]
 801c708: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801c70a: 693b         	ldr	r3, [r7, #0x10]
 801c70c: f383 8811    	msr	basepri, r3
; }
 801c710: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801c712: f3bf 8f6f    	isb	sy
; }
 801c716: bf00         	nop
; }
 801c718: bf00         	nop
; }
 801c71a: bf00         	nop
 801c71c: 3738         	adds	r7, #0x38
 801c71e: 46bd         	mov	sp, r7
 801c720: bd80         	pop	{r7, pc}

0801c722 <poll_in_u8>:
; {
 801c722: b580         	push	{r7, lr}
 801c724: b082         	sub	sp, #0x8
 801c726: af00         	add	r7, sp, #0x0
 801c728: 6078         	str	r0, [r7, #0x4]
 801c72a: 6039         	str	r1, [r7]
; 	*((unsigned char *)in) = (unsigned char)LL_USART_ReceiveData8(usart);
 801c72c: 6878         	ldr	r0, [r7, #0x4]
 801c72e: f7ff fd2c    	bl	0x801c18a <LL_USART_ReceiveData8> @ imm = #-0x5a8
 801c732: 4603         	mov	r3, r0
 801c734: 461a         	mov	r2, r3
 801c736: 683b         	ldr	r3, [r7]
 801c738: 701a         	strb	r2, [r3]
; }
 801c73a: bf00         	nop
 801c73c: 3708         	adds	r7, #0x8
 801c73e: 46bd         	mov	sp, r7
 801c740: bd80         	pop	{r7, pc}

0801c742 <poll_out_u8>:
; {
 801c742: b580         	push	{r7, lr}
 801c744: b082         	sub	sp, #0x8
 801c746: af00         	add	r7, sp, #0x0
 801c748: 6078         	str	r0, [r7, #0x4]
 801c74a: 460b         	mov	r3, r1
 801c74c: 807b         	strh	r3, [r7, #0x2]
; 	LL_USART_TransmitData8(usart, (uint8_t)out);
 801c74e: 887b         	ldrh	r3, [r7, #0x2]
 801c750: b2db         	uxtb	r3, r3
 801c752: 4619         	mov	r1, r3
 801c754: 6878         	ldr	r0, [r7, #0x4]
 801c756: f7ff fd25    	bl	0x801c1a4 <LL_USART_TransmitData8> @ imm = #-0x5b6
; }
 801c75a: bf00         	nop
 801c75c: 3708         	adds	r7, #0x8
 801c75e: 46bd         	mov	sp, r7
 801c760: bd80         	pop	{r7, pc}

0801c762 <uart_stm32_err_check>:
; {
 801c762: b580         	push	{r7, lr}
 801c764: b086         	sub	sp, #0x18
 801c766: af00         	add	r7, sp, #0x0
 801c768: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801c76a: 687b         	ldr	r3, [r7, #0x4]
 801c76c: 685b         	ldr	r3, [r3, #0x4]
 801c76e: 613b         	str	r3, [r7, #0x10]
; 	USART_TypeDef *usart = config->usart;
 801c770: 693b         	ldr	r3, [r7, #0x10]
 801c772: 681b         	ldr	r3, [r3]
 801c774: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t err = 0U;
 801c776: 2300         	movs	r3, #0x0
 801c778: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 801c77a: 68f8         	ldr	r0, [r7, #0xc]
 801c77c: f7ff f9e2    	bl	0x801bb44 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xc3c
 801c780: 4603         	mov	r3, r0
 801c782: 2b00         	cmp	r3, #0x0
 801c784: d003         	beq	0x801c78e <uart_stm32_err_check+0x2c> @ imm = #0x6
; 		err |= UART_ERROR_OVERRUN;
 801c786: 697b         	ldr	r3, [r7, #0x14]
 801c788: f043 0301    	orr	r3, r3, #0x1
 801c78c: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_PE(usart)) {
 801c78e: 68f8         	ldr	r0, [r7, #0xc]
 801c790: f7ff f99f    	bl	0x801bad2 <LL_USART_IsActiveFlag_PE> @ imm = #-0xcc2
 801c794: 4603         	mov	r3, r0
 801c796: 2b00         	cmp	r3, #0x0
 801c798: d003         	beq	0x801c7a2 <uart_stm32_err_check+0x40> @ imm = #0x6
; 		err |= UART_ERROR_PARITY;
 801c79a: 697b         	ldr	r3, [r7, #0x14]
 801c79c: f043 0302    	orr	r3, r3, #0x2
 801c7a0: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_FE(usart)) {
 801c7a2: 68f8         	ldr	r0, [r7, #0xc]
 801c7a4: f7ff f9a8    	bl	0x801baf8 <LL_USART_IsActiveFlag_FE> @ imm = #-0xcb0
 801c7a8: 4603         	mov	r3, r0
 801c7aa: 2b00         	cmp	r3, #0x0
 801c7ac: d003         	beq	0x801c7b6 <uart_stm32_err_check+0x54> @ imm = #0x6
; 		err |= UART_ERROR_FRAMING;
 801c7ae: 697b         	ldr	r3, [r7, #0x14]
 801c7b0: f043 0304    	orr	r3, r3, #0x4
 801c7b4: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_NE(usart)) {
 801c7b6: 68f8         	ldr	r0, [r7, #0xc]
 801c7b8: f7ff f9b1    	bl	0x801bb1e <LL_USART_IsActiveFlag_NE> @ imm = #-0xc9e
 801c7bc: 4603         	mov	r3, r0
 801c7be: 2b00         	cmp	r3, #0x0
 801c7c0: d003         	beq	0x801c7ca <uart_stm32_err_check+0x68> @ imm = #0x6
; 		err |= UART_ERROR_NOISE;
 801c7c2: 697b         	ldr	r3, [r7, #0x14]
 801c7c4: f043 0320    	orr	r3, r3, #0x20
 801c7c8: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_LBD(usart)) {
 801c7ca: 68f8         	ldr	r0, [r7, #0xc]
 801c7cc: f7ff fa19    	bl	0x801bc02 <LL_USART_IsActiveFlag_LBD> @ imm = #-0xbce
 801c7d0: 4603         	mov	r3, r0
 801c7d2: 2b00         	cmp	r3, #0x0
 801c7d4: d003         	beq	0x801c7de <uart_stm32_err_check+0x7c> @ imm = #0x6
; 		err |= UART_BREAK;
 801c7d6: 697b         	ldr	r3, [r7, #0x14]
 801c7d8: f043 0308    	orr	r3, r3, #0x8
 801c7dc: 617b         	str	r3, [r7, #0x14]
; 	if (err & UART_BREAK) {
 801c7de: 697b         	ldr	r3, [r7, #0x14]
 801c7e0: f003 0308    	and	r3, r3, #0x8
 801c7e4: 2b00         	cmp	r3, #0x0
 801c7e6: d002         	beq	0x801c7ee <uart_stm32_err_check+0x8c> @ imm = #0x4
; 		LL_USART_ClearFlag_LBD(usart);
 801c7e8: 68f8         	ldr	r0, [r7, #0xc]
 801c7ea: f7ff fa94    	bl	0x801bd16 <LL_USART_ClearFlag_LBD> @ imm = #-0xad8
; 	if (err & UART_ERROR_OVERRUN) {
 801c7ee: 697b         	ldr	r3, [r7, #0x14]
 801c7f0: f003 0301    	and	r3, r3, #0x1
 801c7f4: 2b00         	cmp	r3, #0x0
 801c7f6: d002         	beq	0x801c7fe <uart_stm32_err_check+0x9c> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 801c7f8: 68f8         	ldr	r0, [r7, #0xc]
 801c7fa: f7ff fa4c    	bl	0x801bc96 <LL_USART_ClearFlag_ORE> @ imm = #-0xb68
; 	if (err & UART_ERROR_PARITY) {
 801c7fe: 697b         	ldr	r3, [r7, #0x14]
 801c800: f003 0302    	and	r3, r3, #0x2
 801c804: 2b00         	cmp	r3, #0x0
 801c806: d002         	beq	0x801c80e <uart_stm32_err_check+0xac> @ imm = #0x4
; 		LL_USART_ClearFlag_PE(usart);
 801c808: 68f8         	ldr	r0, [r7, #0xc]
 801c80a: f7ff fa0e    	bl	0x801bc2a <LL_USART_ClearFlag_PE> @ imm = #-0xbe4
; 	if (err & UART_ERROR_FRAMING) {
 801c80e: 697b         	ldr	r3, [r7, #0x14]
 801c810: f003 0304    	and	r3, r3, #0x4
 801c814: 2b00         	cmp	r3, #0x0
 801c816: d002         	beq	0x801c81e <uart_stm32_err_check+0xbc> @ imm = #0x4
; 		LL_USART_ClearFlag_FE(usart);
 801c818: 68f8         	ldr	r0, [r7, #0xc]
 801c81a: f7ff fa18    	bl	0x801bc4e <LL_USART_ClearFlag_FE> @ imm = #-0xbd0
; 	if (err & UART_ERROR_NOISE) {
 801c81e: 697b         	ldr	r3, [r7, #0x14]
 801c820: f003 0320    	and	r3, r3, #0x20
 801c824: 2b00         	cmp	r3, #0x0
 801c826: d002         	beq	0x801c82e <uart_stm32_err_check+0xcc> @ imm = #0x4
; 		LL_USART_ClearFlag_NE(usart);
 801c828: 68f8         	ldr	r0, [r7, #0xc]
 801c82a: f7ff fa22    	bl	0x801bc72 <LL_USART_ClearFlag_NE> @ imm = #-0xbbc
; 	return err;
 801c82e: 697b         	ldr	r3, [r7, #0x14]
; }
 801c830: 4618         	mov	r0, r3
 801c832: 3718         	adds	r7, #0x18
 801c834: 46bd         	mov	sp, r7
 801c836: bd80         	pop	{r7, pc}

0801c838 <uart_stm32_fifo_fill_visitor>:
; {
 801c838: b580         	push	{r7, lr}
 801c83a: b08e         	sub	sp, #0x38
 801c83c: af00         	add	r7, sp, #0x0
 801c83e: 60f8         	str	r0, [r7, #0xc]
 801c840: 60b9         	str	r1, [r7, #0x8]
 801c842: 607a         	str	r2, [r7, #0x4]
 801c844: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801c846: 68fb         	ldr	r3, [r7, #0xc]
 801c848: 685b         	ldr	r3, [r3, #0x4]
 801c84a: 633b         	str	r3, [r7, #0x30]
; 	USART_TypeDef *usart = config->usart;
 801c84c: 6b3b         	ldr	r3, [r7, #0x30]
 801c84e: 681b         	ldr	r3, [r3]
 801c850: 62fb         	str	r3, [r7, #0x2c]
; 	int num_tx = 0U;
 801c852: 2300         	movs	r3, #0x0
 801c854: 637b         	str	r3, [r7, #0x34]
; 	if (!LL_USART_IsActiveFlag_TXE(usart)) {
 801c856: 6af8         	ldr	r0, [r7, #0x2c]
 801c858: f7ff f9c0    	bl	0x801bbdc <LL_USART_IsActiveFlag_TXE> @ imm = #-0xc80
 801c85c: 4603         	mov	r3, r0
 801c85e: 2b00         	cmp	r3, #0x0
 801c860: d101         	bne	0x801c866 <uart_stm32_fifo_fill_visitor+0x2e> @ imm = #0x2
; 		return num_tx;
 801c862: 6b7b         	ldr	r3, [r7, #0x34]
 801c864: e030         	b	0x801c8c8 <uart_stm32_fifo_fill_visitor+0x90> @ imm = #0x60
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801c866: f3ef 8311    	mrs	r3, basepri
 801c86a: 627b         	str	r3, [r7, #0x24]
;   return(result);
 801c86c: 6a7b         	ldr	r3, [r7, #0x24]
; 	key = __get_BASEPRI();
 801c86e: 623b         	str	r3, [r7, #0x20]
 801c870: 2310         	movs	r3, #0x10
 801c872: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801c874: 69fb         	ldr	r3, [r7, #0x1c]
 801c876: f383 8812    	msr	basepri_max, r3
; }
 801c87a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801c87c: f3bf 8f6f    	isb	sy
; }
 801c880: bf00         	nop
; 	return key;
 801c882: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = irq_lock();
 801c884: 62bb         	str	r3, [r7, #0x28]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 801c886: e007         	b	0x801c898 <uart_stm32_fifo_fill_visitor+0x60> @ imm = #0xe
; 		fill_fn(usart, tx_data, num_tx);
 801c888: 683b         	ldr	r3, [r7]
 801c88a: 6b7a         	ldr	r2, [r7, #0x34]
 801c88c: 68b9         	ldr	r1, [r7, #0x8]
 801c88e: 6af8         	ldr	r0, [r7, #0x2c]
 801c890: 4798         	blx	r3
; 		num_tx++;
 801c892: 6b7b         	ldr	r3, [r7, #0x34]
 801c894: 3301         	adds	r3, #0x1
 801c896: 637b         	str	r3, [r7, #0x34]
; 	while ((size - num_tx > 0) && LL_USART_IsActiveFlag_TXE(usart)) {
 801c898: 687a         	ldr	r2, [r7, #0x4]
 801c89a: 6b7b         	ldr	r3, [r7, #0x34]
 801c89c: 1ad3         	subs	r3, r2, r3
 801c89e: 2b00         	cmp	r3, #0x0
 801c8a0: dd05         	ble	0x801c8ae <uart_stm32_fifo_fill_visitor+0x76> @ imm = #0xa
 801c8a2: 6af8         	ldr	r0, [r7, #0x2c]
 801c8a4: f7ff f99a    	bl	0x801bbdc <LL_USART_IsActiveFlag_TXE> @ imm = #-0xccc
 801c8a8: 4603         	mov	r3, r0
 801c8aa: 2b00         	cmp	r3, #0x0
 801c8ac: d1ec         	bne	0x801c888 <uart_stm32_fifo_fill_visitor+0x50> @ imm = #-0x28
 801c8ae: 6abb         	ldr	r3, [r7, #0x28]
 801c8b0: 61bb         	str	r3, [r7, #0x18]
 801c8b2: 69bb         	ldr	r3, [r7, #0x18]
 801c8b4: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801c8b6: 697b         	ldr	r3, [r7, #0x14]
 801c8b8: f383 8811    	msr	basepri, r3
; }
 801c8bc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801c8be: f3bf 8f6f    	isb	sy
; }
 801c8c2: bf00         	nop
; }
 801c8c4: bf00         	nop
; 	return num_tx;
 801c8c6: 6b7b         	ldr	r3, [r7, #0x34]
; }
 801c8c8: 4618         	mov	r0, r3
 801c8ca: 3738         	adds	r7, #0x38
 801c8cc: 46bd         	mov	sp, r7
 801c8ce: bd80         	pop	{r7, pc}

0801c8d0 <fifo_fill_with_u8>:
; {
 801c8d0: b580         	push	{r7, lr}
 801c8d2: b086         	sub	sp, #0x18
 801c8d4: af00         	add	r7, sp, #0x0
 801c8d6: 60f8         	str	r0, [r7, #0xc]
 801c8d8: 60b9         	str	r1, [r7, #0x8]
 801c8da: 607a         	str	r2, [r7, #0x4]
; 	const uint8_t *data = (const uint8_t *)tx_data;
 801c8dc: 68bb         	ldr	r3, [r7, #0x8]
 801c8de: 617b         	str	r3, [r7, #0x14]
; 	LL_USART_TransmitData8(usart, data[offset]);
 801c8e0: 687b         	ldr	r3, [r7, #0x4]
 801c8e2: 697a         	ldr	r2, [r7, #0x14]
 801c8e4: 4413         	add	r3, r2
 801c8e6: 781b         	ldrb	r3, [r3]
 801c8e8: 4619         	mov	r1, r3
 801c8ea: 68f8         	ldr	r0, [r7, #0xc]
 801c8ec: f7ff fc5a    	bl	0x801c1a4 <LL_USART_TransmitData8> @ imm = #-0x74c
; }
 801c8f0: bf00         	nop
 801c8f2: 3718         	adds	r7, #0x18
 801c8f4: 46bd         	mov	sp, r7
 801c8f6: bd80         	pop	{r7, pc}

0801c8f8 <uart_stm32_fifo_read_visitor>:
; {
 801c8f8: b580         	push	{r7, lr}
 801c8fa: b088         	sub	sp, #0x20
 801c8fc: af00         	add	r7, sp, #0x0
 801c8fe: 60f8         	str	r0, [r7, #0xc]
 801c900: 60b9         	str	r1, [r7, #0x8]
 801c902: 607a         	str	r2, [r7, #0x4]
 801c904: 603b         	str	r3, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801c906: 68fb         	ldr	r3, [r7, #0xc]
 801c908: 685b         	ldr	r3, [r3, #0x4]
 801c90a: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 801c90c: 69bb         	ldr	r3, [r7, #0x18]
 801c90e: 681b         	ldr	r3, [r3]
 801c910: 617b         	str	r3, [r7, #0x14]
; 	int num_rx = 0U;
 801c912: 2300         	movs	r3, #0x0
 801c914: 61fb         	str	r3, [r7, #0x1c]
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 801c916: e010         	b	0x801c93a <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x20
; 		read_fn(usart, rx_data, num_rx);
 801c918: 683b         	ldr	r3, [r7]
 801c91a: 69fa         	ldr	r2, [r7, #0x1c]
 801c91c: 68b9         	ldr	r1, [r7, #0x8]
 801c91e: 6978         	ldr	r0, [r7, #0x14]
 801c920: 4798         	blx	r3
; 		num_rx++;
 801c922: 69fb         	ldr	r3, [r7, #0x1c]
 801c924: 3301         	adds	r3, #0x1
 801c926: 61fb         	str	r3, [r7, #0x1c]
; 		if (LL_USART_IsActiveFlag_ORE(usart)) {
 801c928: 6978         	ldr	r0, [r7, #0x14]
 801c92a: f7ff f90b    	bl	0x801bb44 <LL_USART_IsActiveFlag_ORE> @ imm = #-0xdea
 801c92e: 4603         	mov	r3, r0
 801c930: 2b00         	cmp	r3, #0x0
 801c932: d002         	beq	0x801c93a <uart_stm32_fifo_read_visitor+0x42> @ imm = #0x4
; 			LL_USART_ClearFlag_ORE(usart);
 801c934: 6978         	ldr	r0, [r7, #0x14]
 801c936: f7ff f9ae    	bl	0x801bc96 <LL_USART_ClearFlag_ORE> @ imm = #-0xca4
; 	while ((size - num_rx > 0) && LL_USART_IsActiveFlag_RXNE(usart)) {
 801c93a: 687a         	ldr	r2, [r7, #0x4]
 801c93c: 69fb         	ldr	r3, [r7, #0x1c]
 801c93e: 1ad3         	subs	r3, r2, r3
 801c940: 2b00         	cmp	r3, #0x0
 801c942: dd05         	ble	0x801c950 <uart_stm32_fifo_read_visitor+0x58> @ imm = #0xa
 801c944: 6978         	ldr	r0, [r7, #0x14]
 801c946: f7ff f923    	bl	0x801bb90 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xdba
 801c94a: 4603         	mov	r3, r0
 801c94c: 2b00         	cmp	r3, #0x0
 801c94e: d1e3         	bne	0x801c918 <uart_stm32_fifo_read_visitor+0x20> @ imm = #-0x3a
; 	return num_rx;
 801c950: 69fb         	ldr	r3, [r7, #0x1c]
; }
 801c952: 4618         	mov	r0, r3
 801c954: 3720         	adds	r7, #0x20
 801c956: 46bd         	mov	sp, r7
 801c958: bd80         	pop	{r7, pc}

0801c95a <fifo_read_with_u8>:
; {
 801c95a: b590         	push	{r4, r7, lr}
 801c95c: b087         	sub	sp, #0x1c
 801c95e: af00         	add	r7, sp, #0x0
 801c960: 60f8         	str	r0, [r7, #0xc]
 801c962: 60b9         	str	r1, [r7, #0x8]
 801c964: 607a         	str	r2, [r7, #0x4]
; 	uint8_t *data = (uint8_t *)rx_data;
 801c966: 68bb         	ldr	r3, [r7, #0x8]
 801c968: 617b         	str	r3, [r7, #0x14]
; 	data[offset] = LL_USART_ReceiveData8(usart);
 801c96a: 687b         	ldr	r3, [r7, #0x4]
 801c96c: 697a         	ldr	r2, [r7, #0x14]
 801c96e: 18d4         	adds	r4, r2, r3
 801c970: 68f8         	ldr	r0, [r7, #0xc]
 801c972: f7ff fc0a    	bl	0x801c18a <LL_USART_ReceiveData8> @ imm = #-0x7ec
 801c976: 4603         	mov	r3, r0
 801c978: 7023         	strb	r3, [r4]
; }
 801c97a: bf00         	nop
 801c97c: 371c         	adds	r7, #0x1c
 801c97e: 46bd         	mov	sp, r7
 801c980: bd90         	pop	{r4, r7, pc}

0801c982 <uart_stm32_irq_tx_enable>:
; {
 801c982: b580         	push	{r7, lr}
 801c984: b084         	sub	sp, #0x10
 801c986: af00         	add	r7, sp, #0x0
 801c988: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801c98a: 687b         	ldr	r3, [r7, #0x4]
 801c98c: 685b         	ldr	r3, [r3, #0x4]
 801c98e: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_TC(config->usart);
 801c990: 68fb         	ldr	r3, [r7, #0xc]
 801c992: 681b         	ldr	r3, [r3]
 801c994: 4618         	mov	r0, r3
 801c996: f7ff fa12    	bl	0x801bdbe <LL_USART_EnableIT_TC> @ imm = #-0xbdc
; }
 801c99a: bf00         	nop
 801c99c: 3710         	adds	r7, #0x10
 801c99e: 46bd         	mov	sp, r7
 801c9a0: bd80         	pop	{r7, pc}

0801c9a2 <uart_stm32_irq_tx_disable>:
; {
 801c9a2: b580         	push	{r7, lr}
 801c9a4: b084         	sub	sp, #0x10
 801c9a6: af00         	add	r7, sp, #0x0
 801c9a8: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801c9aa: 687b         	ldr	r3, [r7, #0x4]
 801c9ac: 685b         	ldr	r3, [r3, #0x4]
 801c9ae: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_TC(config->usart);
 801c9b0: 68fb         	ldr	r3, [r7, #0xc]
 801c9b2: 681b         	ldr	r3, [r3]
 801c9b4: 4618         	mov	r0, r3
 801c9b6: f7ff fac1    	bl	0x801bf3c <LL_USART_DisableIT_TC> @ imm = #-0xa7e
; }
 801c9ba: bf00         	nop
 801c9bc: 3710         	adds	r7, #0x10
 801c9be: 46bd         	mov	sp, r7
 801c9c0: bd80         	pop	{r7, pc}

0801c9c2 <uart_stm32_irq_tx_ready>:
; {
 801c9c2: b580         	push	{r7, lr}
 801c9c4: b084         	sub	sp, #0x10
 801c9c6: af00         	add	r7, sp, #0x0
 801c9c8: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801c9ca: 687b         	ldr	r3, [r7, #0x4]
 801c9cc: 685b         	ldr	r3, [r3, #0x4]
 801c9ce: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 801c9d0: 68fb         	ldr	r3, [r7, #0xc]
 801c9d2: 681b         	ldr	r3, [r3]
 801c9d4: 4618         	mov	r0, r3
 801c9d6: f7ff f901    	bl	0x801bbdc <LL_USART_IsActiveFlag_TXE> @ imm = #-0xdfe
 801c9da: 4603         	mov	r3, r0
 801c9dc: 2b00         	cmp	r3, #0x0
 801c9de: d009         	beq	0x801c9f4 <uart_stm32_irq_tx_ready+0x32> @ imm = #0x12
; 		LL_USART_IsEnabledIT_TC(config->usart);
 801c9e0: 68fb         	ldr	r3, [r7, #0xc]
 801c9e2: 681b         	ldr	r3, [r3]
 801c9e4: 4618         	mov	r0, r3
 801c9e6: f7ff fb48    	bl	0x801c07a <LL_USART_IsEnabledIT_TC> @ imm = #-0x970
 801c9ea: 4603         	mov	r3, r0
; 	return LL_USART_IsActiveFlag_TXE(config->usart) &&
 801c9ec: 2b00         	cmp	r3, #0x0
 801c9ee: d001         	beq	0x801c9f4 <uart_stm32_irq_tx_ready+0x32> @ imm = #0x2
 801c9f0: 2301         	movs	r3, #0x1
 801c9f2: e000         	b	0x801c9f6 <uart_stm32_irq_tx_ready+0x34> @ imm = #0x0
 801c9f4: 2300         	movs	r3, #0x0
; }
 801c9f6: 4618         	mov	r0, r3
 801c9f8: 3710         	adds	r7, #0x10
 801c9fa: 46bd         	mov	sp, r7
 801c9fc: bd80         	pop	{r7, pc}

0801c9fe <uart_stm32_irq_tx_complete>:
; {
 801c9fe: b580         	push	{r7, lr}
 801ca00: b084         	sub	sp, #0x10
 801ca02: af00         	add	r7, sp, #0x0
 801ca04: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801ca06: 687b         	ldr	r3, [r7, #0x4]
 801ca08: 685b         	ldr	r3, [r3, #0x4]
 801ca0a: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_TC(config->usart);
 801ca0c: 68fb         	ldr	r3, [r7, #0xc]
 801ca0e: 681b         	ldr	r3, [r3]
 801ca10: 4618         	mov	r0, r3
 801ca12: f7ff f8d0    	bl	0x801bbb6 <LL_USART_IsActiveFlag_TC> @ imm = #-0xe60
 801ca16: 4603         	mov	r3, r0
; }
 801ca18: 4618         	mov	r0, r3
 801ca1a: 3710         	adds	r7, #0x10
 801ca1c: 46bd         	mov	sp, r7
 801ca1e: bd80         	pop	{r7, pc}

0801ca20 <uart_stm32_irq_rx_enable>:
; {
 801ca20: b580         	push	{r7, lr}
 801ca22: b084         	sub	sp, #0x10
 801ca24: af00         	add	r7, sp, #0x0
 801ca26: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801ca28: 687b         	ldr	r3, [r7, #0x4]
 801ca2a: 685b         	ldr	r3, [r3, #0x4]
 801ca2c: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableIT_RXNE(config->usart);
 801ca2e: 68fb         	ldr	r3, [r7, #0xc]
 801ca30: 681b         	ldr	r3, [r3]
 801ca32: 4618         	mov	r0, r3
 801ca34: f7ff f9a0    	bl	0x801bd78 <LL_USART_EnableIT_RXNE> @ imm = #-0xcc0
; }
 801ca38: bf00         	nop
 801ca3a: 3710         	adds	r7, #0x10
 801ca3c: 46bd         	mov	sp, r7
 801ca3e: bd80         	pop	{r7, pc}

0801ca40 <uart_stm32_irq_rx_disable>:
; {
 801ca40: b580         	push	{r7, lr}
 801ca42: b084         	sub	sp, #0x10
 801ca44: af00         	add	r7, sp, #0x0
 801ca46: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801ca48: 687b         	ldr	r3, [r7, #0x4]
 801ca4a: 685b         	ldr	r3, [r3, #0x4]
 801ca4c: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableIT_RXNE(config->usart);
 801ca4e: 68fb         	ldr	r3, [r7, #0xc]
 801ca50: 681b         	ldr	r3, [r3]
 801ca52: 4618         	mov	r0, r3
 801ca54: f7ff fa4f    	bl	0x801bef6 <LL_USART_DisableIT_RXNE> @ imm = #-0xb62
; }
 801ca58: bf00         	nop
 801ca5a: 3710         	adds	r7, #0x10
 801ca5c: 46bd         	mov	sp, r7
 801ca5e: bd80         	pop	{r7, pc}

0801ca60 <uart_stm32_irq_rx_ready>:
; {
 801ca60: b580         	push	{r7, lr}
 801ca62: b084         	sub	sp, #0x10
 801ca64: af00         	add	r7, sp, #0x0
 801ca66: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801ca68: 687b         	ldr	r3, [r7, #0x4]
 801ca6a: 685b         	ldr	r3, [r3, #0x4]
 801ca6c: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_IsActiveFlag_RXNE(config->usart);
 801ca6e: 68fb         	ldr	r3, [r7, #0xc]
 801ca70: 681b         	ldr	r3, [r3]
 801ca72: 4618         	mov	r0, r3
 801ca74: f7ff f88c    	bl	0x801bb90 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xee8
 801ca78: 4603         	mov	r3, r0
; }
 801ca7a: 4618         	mov	r0, r3
 801ca7c: 3710         	adds	r7, #0x10
 801ca7e: 46bd         	mov	sp, r7
 801ca80: bd80         	pop	{r7, pc}

0801ca82 <uart_stm32_irq_is_pending>:
; {
 801ca82: b580         	push	{r7, lr}
 801ca84: b084         	sub	sp, #0x10
 801ca86: af00         	add	r7, sp, #0x0
 801ca88: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801ca8a: 687b         	ldr	r3, [r7, #0x4]
 801ca8c: 685b         	ldr	r3, [r3, #0x4]
 801ca8e: 60fb         	str	r3, [r7, #0xc]
; 	USART_TypeDef *usart = config->usart;
 801ca90: 68fb         	ldr	r3, [r7, #0xc]
 801ca92: 681b         	ldr	r3, [r3]
 801ca94: 60bb         	str	r3, [r7, #0x8]
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 801ca96: 68b8         	ldr	r0, [r7, #0x8]
 801ca98: f7ff f87a    	bl	0x801bb90 <LL_USART_IsActiveFlag_RXNE> @ imm = #-0xf0c
 801ca9c: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 801ca9e: 2b00         	cmp	r3, #0x0
 801caa0: d005         	beq	0x801caae <uart_stm32_irq_is_pending+0x2c> @ imm = #0xa
 801caa2: 68b8         	ldr	r0, [r7, #0x8]
 801caa4: f7ff fad6    	bl	0x801c054 <LL_USART_IsEnabledIT_RXNE> @ imm = #-0xa54
 801caa8: 4603         	mov	r3, r0
; 	return ((LL_USART_IsActiveFlag_RXNE(usart) &&
 801caaa: 2b00         	cmp	r3, #0x0
 801caac: d10b         	bne	0x801cac6 <uart_stm32_irq_is_pending+0x44> @ imm = #0x16
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 801caae: 68b8         	ldr	r0, [r7, #0x8]
 801cab0: f7ff f881    	bl	0x801bbb6 <LL_USART_IsActiveFlag_TC> @ imm = #-0xefe
 801cab4: 4603         	mov	r3, r0
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 801cab6: 2b00         	cmp	r3, #0x0
 801cab8: d007         	beq	0x801caca <uart_stm32_irq_is_pending+0x48> @ imm = #0xe
; 		 LL_USART_IsEnabledIT_TC(usart)));
 801caba: 68b8         	ldr	r0, [r7, #0x8]
 801cabc: f7ff fadd    	bl	0x801c07a <LL_USART_IsEnabledIT_TC> @ imm = #-0xa46
 801cac0: 4603         	mov	r3, r0
; 		(LL_USART_IsActiveFlag_TC(usart) &&
 801cac2: 2b00         	cmp	r3, #0x0
 801cac4: d001         	beq	0x801caca <uart_stm32_irq_is_pending+0x48> @ imm = #0x2
; 		 LL_USART_IsEnabledIT_RXNE(usart)) ||
 801cac6: 2301         	movs	r3, #0x1
 801cac8: e000         	b	0x801cacc <uart_stm32_irq_is_pending+0x4a> @ imm = #0x0
 801caca: 2300         	movs	r3, #0x0
; }
 801cacc: 4618         	mov	r0, r3
 801cace: 3710         	adds	r7, #0x10
 801cad0: 46bd         	mov	sp, r7
 801cad2: bd80         	pop	{r7, pc}

0801cad4 <uart_stm32_irq_update>:
; {
 801cad4: b480         	push	{r7}
 801cad6: b083         	sub	sp, #0xc
 801cad8: af00         	add	r7, sp, #0x0
 801cada: 6078         	str	r0, [r7, #0x4]
; 	return 1;
 801cadc: 2301         	movs	r3, #0x1
; }
 801cade: 4618         	mov	r0, r3
 801cae0: 370c         	adds	r7, #0xc
 801cae2: 46bd         	mov	sp, r7
 801cae4: f85d 7b04    	ldr	r7, [sp], #4
 801cae8: 4770         	bx	lr

0801caea <uart_stm32_irq_callback_set>:
; {
 801caea: b480         	push	{r7}
 801caec: b087         	sub	sp, #0x1c
 801caee: af00         	add	r7, sp, #0x0
 801caf0: 60f8         	str	r0, [r7, #0xc]
 801caf2: 60b9         	str	r1, [r7, #0x8]
 801caf4: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801caf6: 68fb         	ldr	r3, [r7, #0xc]
 801caf8: 691b         	ldr	r3, [r3, #0x10]
 801cafa: 617b         	str	r3, [r7, #0x14]
; 	data->user_cb = cb;
 801cafc: 697b         	ldr	r3, [r7, #0x14]
 801cafe: 68ba         	ldr	r2, [r7, #0x8]
 801cb00: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = cb_data;
 801cb02: 697b         	ldr	r3, [r7, #0x14]
 801cb04: 687a         	ldr	r2, [r7, #0x4]
 801cb06: 60da         	str	r2, [r3, #0xc]
; 	data->async_cb = NULL;
 801cb08: 697b         	ldr	r3, [r7, #0x14]
 801cb0a: 2200         	movs	r2, #0x0
 801cb0c: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = NULL;
 801cb0e: 697b         	ldr	r3, [r7, #0x14]
 801cb10: 2200         	movs	r2, #0x0
 801cb12: 619a         	str	r2, [r3, #0x18]
; }
 801cb14: bf00         	nop
 801cb16: 371c         	adds	r7, #0x1c
 801cb18: 46bd         	mov	sp, r7
 801cb1a: f85d 7b04    	ldr	r7, [sp], #4
 801cb1e: 4770         	bx	lr

0801cb20 <async_user_callback>:
; {
 801cb20: b580         	push	{r7, lr}
 801cb22: b082         	sub	sp, #0x8
 801cb24: af00         	add	r7, sp, #0x0
 801cb26: 6078         	str	r0, [r7, #0x4]
 801cb28: 6039         	str	r1, [r7]
; 	if (data->async_cb) {
 801cb2a: 687b         	ldr	r3, [r7, #0x4]
 801cb2c: 695b         	ldr	r3, [r3, #0x14]
 801cb2e: 2b00         	cmp	r3, #0x0
 801cb30: d007         	beq	0x801cb42 <async_user_callback+0x22> @ imm = #0xe
; 		data->async_cb(data->uart_dev, event, data->async_user_data);
 801cb32: 687b         	ldr	r3, [r7, #0x4]
 801cb34: 695b         	ldr	r3, [r3, #0x14]
 801cb36: 687a         	ldr	r2, [r7, #0x4]
 801cb38: 6910         	ldr	r0, [r2, #0x10]
 801cb3a: 687a         	ldr	r2, [r7, #0x4]
 801cb3c: 6992         	ldr	r2, [r2, #0x18]
 801cb3e: 6839         	ldr	r1, [r7]
 801cb40: 4798         	blx	r3
; }
 801cb42: bf00         	nop
 801cb44: 3708         	adds	r7, #0x8
 801cb46: 46bd         	mov	sp, r7
 801cb48: bd80         	pop	{r7, pc}

0801cb4a <async_evt_rx_buf_request>:
; {
 801cb4a: b580         	push	{r7, lr}
 801cb4c: b088         	sub	sp, #0x20
 801cb4e: af00         	add	r7, sp, #0x0
 801cb50: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 801cb52: f107 030c    	add.w	r3, r7, #0xc
 801cb56: 2200         	movs	r2, #0x0
 801cb58: 601a         	str	r2, [r3]
 801cb5a: 605a         	str	r2, [r3, #0x4]
 801cb5c: 609a         	str	r2, [r3, #0x8]
 801cb5e: 60da         	str	r2, [r3, #0xc]
 801cb60: 611a         	str	r2, [r3, #0x10]
 801cb62: 2303         	movs	r3, #0x3
 801cb64: 733b         	strb	r3, [r7, #0xc]
; 	async_user_callback(data, &evt);
 801cb66: f107 030c    	add.w	r3, r7, #0xc
 801cb6a: 4619         	mov	r1, r3
 801cb6c: 6878         	ldr	r0, [r7, #0x4]
 801cb6e: f7ff ffd7    	bl	0x801cb20 <async_user_callback> @ imm = #-0x52
; }
 801cb72: bf00         	nop
 801cb74: 3720         	adds	r7, #0x20
 801cb76: 46bd         	mov	sp, r7
 801cb78: bd80         	pop	{r7, pc}

0801cb7a <async_evt_rx_buf_release>:
; {
 801cb7a: b580         	push	{r7, lr}
 801cb7c: b088         	sub	sp, #0x20
 801cb7e: af00         	add	r7, sp, #0x0
 801cb80: 6078         	str	r0, [r7, #0x4]
; 	struct uart_event evt = {
 801cb82: f107 030c    	add.w	r3, r7, #0xc
 801cb86: 2200         	movs	r2, #0x0
 801cb88: 601a         	str	r2, [r3]
 801cb8a: 605a         	str	r2, [r3, #0x4]
 801cb8c: 609a         	str	r2, [r3, #0x8]
 801cb8e: 60da         	str	r2, [r3, #0xc]
 801cb90: 611a         	str	r2, [r3, #0x10]
 801cb92: 2304         	movs	r3, #0x4
 801cb94: 733b         	strb	r3, [r7, #0xc]
; 		.data.rx_buf.buf = data->dma_rx.buffer,
 801cb96: 687b         	ldr	r3, [r7, #0x4]
 801cb98: 6edb         	ldr	r3, [r3, #0x6c]
; 	struct uart_event evt = {
 801cb9a: 613b         	str	r3, [r7, #0x10]
; 	async_user_callback(data, &evt);
 801cb9c: f107 030c    	add.w	r3, r7, #0xc
 801cba0: 4619         	mov	r1, r3
 801cba2: 6878         	ldr	r0, [r7, #0x4]
 801cba4: f7ff ffbc    	bl	0x801cb20 <async_user_callback> @ imm = #-0x88
; }
 801cba8: bf00         	nop
 801cbaa: 3720         	adds	r7, #0x20
 801cbac: 46bd         	mov	sp, r7
 801cbae: bd80         	pop	{r7, pc}

0801cbb0 <uart_stm32_dma_rx_flush>:
; {
 801cbb0: b580         	push	{r7, lr}
 801cbb2: b08c         	sub	sp, #0x30
 801cbb4: af00         	add	r7, sp, #0x0
 801cbb6: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801cbb8: 687b         	ldr	r3, [r7, #0x4]
 801cbba: 691b         	ldr	r3, [r3, #0x10]
 801cbbc: 62fb         	str	r3, [r7, #0x2c]
; 	if (dma_get_status(data->dma_rx.dma_dev,
 801cbbe: 6afb         	ldr	r3, [r7, #0x2c]
 801cbc0: 6a18         	ldr	r0, [r3, #0x20]
 801cbc2: 6afb         	ldr	r3, [r7, #0x2c]
 801cbc4: 6a5b         	ldr	r3, [r3, #0x24]
 801cbc6: f107 0208    	add.w	r2, r7, #0x8
 801cbca: 4619         	mov	r1, r3
 801cbcc: f7fe fdd5    	bl	0x801b77a <dma_get_status> @ imm = #-0x1456
 801cbd0: 4603         	mov	r3, r0
 801cbd2: 2b00         	cmp	r3, #0x0
 801cbd4: d10f         	bne	0x801cbf6 <uart_stm32_dma_rx_flush+0x46> @ imm = #0x1e
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 801cbd6: 6afb         	ldr	r3, [r7, #0x2c]
 801cbd8: 6f1a         	ldr	r2, [r3, #0x70]
; 					stat.pending_length;
 801cbda: 68fb         	ldr	r3, [r7, #0xc]
; 		size_t rx_rcv_len = data->dma_rx.buffer_length -
 801cbdc: 1ad3         	subs	r3, r2, r3
 801cbde: 62bb         	str	r3, [r7, #0x28]
; 		if (rx_rcv_len > data->dma_rx.offset) {
 801cbe0: 6afb         	ldr	r3, [r7, #0x2c]
 801cbe2: 6f5b         	ldr	r3, [r3, #0x74]
 801cbe4: 6aba         	ldr	r2, [r7, #0x28]
 801cbe6: 429a         	cmp	r2, r3
 801cbe8: d905         	bls	0x801cbf6 <uart_stm32_dma_rx_flush+0x46> @ imm = #0xa
; 			data->dma_rx.counter = rx_rcv_len;
 801cbea: 6afb         	ldr	r3, [r7, #0x2c]
 801cbec: 6aba         	ldr	r2, [r7, #0x28]
 801cbee: 679a         	str	r2, [r3, #0x78]
; 			async_evt_rx_rdy(data);
 801cbf0: 6af8         	ldr	r0, [r7, #0x2c]
 801cbf2: f7ef f967    	bl	0x800bec4 <async_evt_rx_rdy> @ imm = #-0x10d32
; }
 801cbf6: bf00         	nop
 801cbf8: 3730         	adds	r7, #0x30
 801cbfa: 46bd         	mov	sp, r7
 801cbfc: bd80         	pop	{r7, pc}

0801cbfe <uart_stm32_async_callback_set>:
; {
 801cbfe: b480         	push	{r7}
 801cc00: b087         	sub	sp, #0x1c
 801cc02: af00         	add	r7, sp, #0x0
 801cc04: 60f8         	str	r0, [r7, #0xc]
 801cc06: 60b9         	str	r1, [r7, #0x8]
 801cc08: 607a         	str	r2, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801cc0a: 68fb         	ldr	r3, [r7, #0xc]
 801cc0c: 691b         	ldr	r3, [r3, #0x10]
 801cc0e: 617b         	str	r3, [r7, #0x14]
; 	data->async_cb = callback;
 801cc10: 697b         	ldr	r3, [r7, #0x14]
 801cc12: 68ba         	ldr	r2, [r7, #0x8]
 801cc14: 615a         	str	r2, [r3, #0x14]
; 	data->async_user_data = user_data;
 801cc16: 697b         	ldr	r3, [r7, #0x14]
 801cc18: 687a         	ldr	r2, [r7, #0x4]
 801cc1a: 619a         	str	r2, [r3, #0x18]
; 	data->user_cb = NULL;
 801cc1c: 697b         	ldr	r3, [r7, #0x14]
 801cc1e: 2200         	movs	r2, #0x0
 801cc20: 609a         	str	r2, [r3, #0x8]
; 	data->user_data = NULL;
 801cc22: 697b         	ldr	r3, [r7, #0x14]
 801cc24: 2200         	movs	r2, #0x0
 801cc26: 60da         	str	r2, [r3, #0xc]
; 	return 0;
 801cc28: 2300         	movs	r3, #0x0
; }
 801cc2a: 4618         	mov	r0, r3
 801cc2c: 371c         	adds	r7, #0x1c
 801cc2e: 46bd         	mov	sp, r7
 801cc30: f85d 7b04    	ldr	r7, [sp], #4
 801cc34: 4770         	bx	lr

0801cc36 <uart_stm32_dma_tx_enable>:
; {
 801cc36: b580         	push	{r7, lr}
 801cc38: b084         	sub	sp, #0x10
 801cc3a: af00         	add	r7, sp, #0x0
 801cc3c: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801cc3e: 687b         	ldr	r3, [r7, #0x4]
 801cc40: 685b         	ldr	r3, [r3, #0x4]
 801cc42: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_EnableDMAReq_TX(config->usart);
 801cc44: 68fb         	ldr	r3, [r7, #0xc]
 801cc46: 681b         	ldr	r3, [r3]
 801cc48: 4618         	mov	r0, r3
 801cc4a: f7ff fa4c    	bl	0x801c0e6 <LL_USART_EnableDMAReq_TX> @ imm = #-0xb68
; }
 801cc4e: bf00         	nop
 801cc50: 3710         	adds	r7, #0x10
 801cc52: 46bd         	mov	sp, r7
 801cc54: bd80         	pop	{r7, pc}

0801cc56 <uart_stm32_dma_tx_disable>:
; {
 801cc56: b580         	push	{r7, lr}
 801cc58: b084         	sub	sp, #0x10
 801cc5a: af00         	add	r7, sp, #0x0
 801cc5c: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801cc5e: 687b         	ldr	r3, [r7, #0x4]
 801cc60: 685b         	ldr	r3, [r3, #0x4]
 801cc62: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_DisableDMAReq_TX(config->usart);
 801cc64: 68fb         	ldr	r3, [r7, #0xc]
 801cc66: 681b         	ldr	r3, [r3]
 801cc68: 4618         	mov	r0, r3
 801cc6a: f7ff fa5f    	bl	0x801c12c <LL_USART_DisableDMAReq_TX> @ imm = #-0xb42
; }
 801cc6e: bf00         	nop
 801cc70: 3710         	adds	r7, #0x10
 801cc72: 46bd         	mov	sp, r7
 801cc74: bd80         	pop	{r7, pc}

0801cc76 <uart_stm32_dma_rx_enable>:
; {
 801cc76: b580         	push	{r7, lr}
 801cc78: b084         	sub	sp, #0x10
 801cc7a: af00         	add	r7, sp, #0x0
 801cc7c: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801cc7e: 687b         	ldr	r3, [r7, #0x4]
 801cc80: 685b         	ldr	r3, [r3, #0x4]
 801cc82: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_stm32_data *data = dev->data;
 801cc84: 687b         	ldr	r3, [r7, #0x4]
 801cc86: 691b         	ldr	r3, [r3, #0x10]
 801cc88: 60bb         	str	r3, [r7, #0x8]
; 	LL_USART_EnableDMAReq_RX(config->usart);
 801cc8a: 68fb         	ldr	r3, [r7, #0xc]
 801cc8c: 681b         	ldr	r3, [r3]
 801cc8e: 4618         	mov	r0, r3
 801cc90: f7ff fa06    	bl	0x801c0a0 <LL_USART_EnableDMAReq_RX> @ imm = #-0xbf4
; 	data->dma_rx.enabled = true;
 801cc94: 68bb         	ldr	r3, [r7, #0x8]
 801cc96: 2201         	movs	r2, #0x1
 801cc98: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 801cc9c: bf00         	nop
 801cc9e: 3710         	adds	r7, #0x10
 801cca0: 46bd         	mov	sp, r7
 801cca2: bd80         	pop	{r7, pc}

0801cca4 <uart_stm32_dma_rx_disable>:
; {
 801cca4: b480         	push	{r7}
 801cca6: b085         	sub	sp, #0x14
 801cca8: af00         	add	r7, sp, #0x0
 801ccaa: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801ccac: 687b         	ldr	r3, [r7, #0x4]
 801ccae: 691b         	ldr	r3, [r3, #0x10]
 801ccb0: 60fb         	str	r3, [r7, #0xc]
; 	data->dma_rx.enabled = false;
 801ccb2: 68fb         	ldr	r3, [r7, #0xc]
 801ccb4: 2200         	movs	r2, #0x0
 801ccb6: f883 20b0    	strb.w	r2, [r3, #0xb0]
; }
 801ccba: bf00         	nop
 801ccbc: 3714         	adds	r7, #0x14
 801ccbe: 46bd         	mov	sp, r7
 801ccc0: f85d 7b04    	ldr	r7, [sp], #4
 801ccc4: 4770         	bx	lr

0801ccc6 <uart_stm32_dma_tx_cb>:
; {
 801ccc6: b580         	push	{r7, lr}
 801ccc8: b094         	sub	sp, #0x50
 801ccca: af00         	add	r7, sp, #0x0
 801cccc: 60f8         	str	r0, [r7, #0xc]
 801ccce: 60b9         	str	r1, [r7, #0x8]
 801ccd0: 607a         	str	r2, [r7, #0x4]
 801ccd2: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 801ccd4: 68bb         	ldr	r3, [r7, #0x8]
 801ccd6: 64fb         	str	r3, [r7, #0x4c]
; 	struct uart_stm32_data *data = uart_dev->data;
 801ccd8: 6cfb         	ldr	r3, [r7, #0x4c]
 801ccda: 691b         	ldr	r3, [r3, #0x10]
 801ccdc: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801ccde: f3ef 8311    	mrs	r3, basepri
 801cce2: 643b         	str	r3, [r7, #0x40]
;   return(result);
 801cce4: 6c3b         	ldr	r3, [r7, #0x40]
; 	key = __get_BASEPRI();
 801cce6: 63fb         	str	r3, [r7, #0x3c]
 801cce8: 2310         	movs	r3, #0x10
 801ccea: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801ccec: 6bbb         	ldr	r3, [r7, #0x38]
 801ccee: f383 8812    	msr	basepri_max, r3
; }
 801ccf2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801ccf4: f3bf 8f6f    	isb	sy
; }
 801ccf8: bf00         	nop
; 	return key;
 801ccfa: 6bfb         	ldr	r3, [r7, #0x3c]
; 	unsigned int key = irq_lock();
 801ccfc: 647b         	str	r3, [r7, #0x44]
; 	uart_stm32_dma_tx_disable(uart_dev);
 801ccfe: 6cf8         	ldr	r0, [r7, #0x4c]
 801cd00: f7ff ffa9    	bl	0x801cc56 <uart_stm32_dma_tx_disable> @ imm = #-0xae
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 801cd04: 6cbb         	ldr	r3, [r7, #0x48]
 801cd06: f503 738c    	add.w	r3, r3, #0x118
 801cd0a: 4618         	mov	r0, r3
 801cd0c: f7f3 fe68    	bl	0x80109e0 <k_work_cancel_delayable> @ imm = #-0xc330
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 801cd10: 6cbb         	ldr	r3, [r7, #0x48]
 801cd12: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 801cd16: 6cbb         	ldr	r3, [r7, #0x48]
 801cd18: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 801cd1c: f107 0210    	add.w	r2, r7, #0x10
 801cd20: 4619         	mov	r1, r3
 801cd22: f7fe fd2a    	bl	0x801b77a <dma_get_status> @ imm = #-0x15ac
 801cd26: 4603         	mov	r3, r0
 801cd28: 2b00         	cmp	r3, #0x0
 801cd2a: d107         	bne	0x801cd3c <uart_stm32_dma_tx_cb+0x76> @ imm = #0xe
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 801cd2c: 6cbb         	ldr	r3, [r7, #0x48]
 801cd2e: f8d3 2108    	ldr.w	r2, [r3, #0x108]
; 					stat.pending_length;
 801cd32: 697b         	ldr	r3, [r7, #0x14]
; 		data->dma_tx.counter = data->dma_tx.buffer_length -
 801cd34: 1ad2         	subs	r2, r2, r3
 801cd36: 6cbb         	ldr	r3, [r7, #0x48]
 801cd38: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	data->dma_tx.buffer_length = 0;
 801cd3c: 6cbb         	ldr	r3, [r7, #0x48]
 801cd3e: 2200         	movs	r2, #0x0
 801cd40: f8c3 2108    	str.w	r2, [r3, #0x108]
 801cd44: 6c7b         	ldr	r3, [r7, #0x44]
 801cd46: 637b         	str	r3, [r7, #0x34]
 801cd48: 6b7b         	ldr	r3, [r7, #0x34]
 801cd4a: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801cd4c: 6b3b         	ldr	r3, [r7, #0x30]
 801cd4e: f383 8811    	msr	basepri, r3
; }
 801cd52: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801cd54: f3bf 8f6f    	isb	sy
; }
 801cd58: bf00         	nop
; }
 801cd5a: bf00         	nop
; }
 801cd5c: bf00         	nop
 801cd5e: 3750         	adds	r7, #0x50
 801cd60: 46bd         	mov	sp, r7
 801cd62: bd80         	pop	{r7, pc}

0801cd64 <uart_stm32_dma_rx_cb>:
; {
 801cd64: b580         	push	{r7, lr}
 801cd66: b086         	sub	sp, #0x18
 801cd68: af00         	add	r7, sp, #0x0
 801cd6a: 60f8         	str	r0, [r7, #0xc]
 801cd6c: 60b9         	str	r1, [r7, #0x8]
 801cd6e: 607a         	str	r2, [r7, #0x4]
 801cd70: 603b         	str	r3, [r7]
; 	const struct device *uart_dev = user_data;
 801cd72: 68bb         	ldr	r3, [r7, #0x8]
 801cd74: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = uart_dev->data;
 801cd76: 697b         	ldr	r3, [r7, #0x14]
 801cd78: 691b         	ldr	r3, [r3, #0x10]
 801cd7a: 613b         	str	r3, [r7, #0x10]
; 	if (status < 0) {
 801cd7c: 683b         	ldr	r3, [r7]
 801cd7e: 2b00         	cmp	r3, #0x0
 801cd80: da04         	bge	0x801cd8c <uart_stm32_dma_rx_cb+0x28> @ imm = #0x8
; 		async_evt_rx_err(data, status);
 801cd82: 6839         	ldr	r1, [r7]
 801cd84: 6938         	ldr	r0, [r7, #0x10]
 801cd86: f7ef f8f3    	bl	0x800bf70 <async_evt_rx_err> @ imm = #-0x10e1a
; 		return;
 801cd8a: e021         	b	0x801cdd0 <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x42
; 	(void)k_work_cancel_delayable(&data->dma_rx.timeout_work);
 801cd8c: 693b         	ldr	r3, [r7, #0x10]
 801cd8e: 3380         	adds	r3, #0x80
 801cd90: 4618         	mov	r0, r3
 801cd92: f7f3 fe25    	bl	0x80109e0 <k_work_cancel_delayable> @ imm = #-0xc3b6
; 	data->dma_rx.counter = data->dma_rx.buffer_length;
 801cd96: 693b         	ldr	r3, [r7, #0x10]
 801cd98: 6f1a         	ldr	r2, [r3, #0x70]
 801cd9a: 693b         	ldr	r3, [r7, #0x10]
 801cd9c: 679a         	str	r2, [r3, #0x78]
; 	async_evt_rx_rdy(data);
 801cd9e: 6938         	ldr	r0, [r7, #0x10]
 801cda0: f7ef f890    	bl	0x800bec4 <async_evt_rx_rdy> @ imm = #-0x10ee0
; 	if (data->rx_next_buffer != NULL) {
 801cda4: 693b         	ldr	r3, [r7, #0x10]
 801cda6: f8d3 3150    	ldr.w	r3, [r3, #0x150]
 801cdaa: 2b00         	cmp	r3, #0x0
 801cdac: d006         	beq	0x801cdbc <uart_stm32_dma_rx_cb+0x58> @ imm = #0xc
; 		async_evt_rx_buf_release(data);
 801cdae: 6938         	ldr	r0, [r7, #0x10]
 801cdb0: f7ff fee3    	bl	0x801cb7a <async_evt_rx_buf_release> @ imm = #-0x23a
; 		uart_stm32_dma_replace_buffer(uart_dev);
 801cdb4: 6978         	ldr	r0, [r7, #0x14]
 801cdb6: f7ef fb23    	bl	0x800c400 <uart_stm32_dma_replace_buffer> @ imm = #-0x109ba
 801cdba: e009         	b	0x801cdd0 <uart_stm32_dma_rx_cb+0x6c> @ imm = #0x12
; 		k_work_reschedule(&data->dma_rx.timeout_work, K_TICKS(1));
 801cdbc: 693b         	ldr	r3, [r7, #0x10]
 801cdbe: f103 0180    	add.w	r1, r3, #0x80
 801cdc2: f04f 0201    	mov.w	r2, #0x1
 801cdc6: f04f 0300    	mov.w	r3, #0x0
 801cdca: 4608         	mov	r0, r1
 801cdcc: f7f3 fdf4    	bl	0x80109b8 <k_work_reschedule> @ imm = #-0xc418
; }
 801cdd0: 3718         	adds	r7, #0x18
 801cdd2: 46bd         	mov	sp, r7
 801cdd4: bd80         	pop	{r7, pc}

0801cdd6 <uart_stm32_async_tx_abort>:
; {
 801cdd6: b580         	push	{r7, lr}
 801cdd8: b08c         	sub	sp, #0x30
 801cdda: af00         	add	r7, sp, #0x0
 801cddc: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 801cdde: 687b         	ldr	r3, [r7, #0x4]
 801cde0: 691b         	ldr	r3, [r3, #0x10]
 801cde2: 62fb         	str	r3, [r7, #0x2c]
; 	size_t tx_buffer_length = data->dma_tx.buffer_length;
 801cde4: 6afb         	ldr	r3, [r7, #0x2c]
 801cde6: f8d3 3108    	ldr.w	r3, [r3, #0x108]
 801cdea: 62bb         	str	r3, [r7, #0x28]
; 	if (tx_buffer_length == 0) {
 801cdec: 6abb         	ldr	r3, [r7, #0x28]
 801cdee: 2b00         	cmp	r3, #0x0
 801cdf0: d102         	bne	0x801cdf8 <uart_stm32_async_tx_abort+0x22> @ imm = #0x4
; 		return -EFAULT;
 801cdf2: f06f 030d    	mvn	r3, #0xd
 801cdf6: e027         	b	0x801ce48 <uart_stm32_async_tx_abort+0x72> @ imm = #0x4e
; 	(void)k_work_cancel_delayable(&data->dma_tx.timeout_work);
 801cdf8: 6afb         	ldr	r3, [r7, #0x2c]
 801cdfa: f503 738c    	add.w	r3, r3, #0x118
 801cdfe: 4618         	mov	r0, r3
 801ce00: f7f3 fdee    	bl	0x80109e0 <k_work_cancel_delayable> @ imm = #-0xc424
; 	if (!dma_get_status(data->dma_tx.dma_dev,
 801ce04: 6afb         	ldr	r3, [r7, #0x2c]
 801ce06: f8d3 00b8    	ldr.w	r0, [r3, #0xb8]
 801ce0a: 6afb         	ldr	r3, [r7, #0x2c]
 801ce0c: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 801ce10: f107 0208    	add.w	r2, r7, #0x8
 801ce14: 4619         	mov	r1, r3
 801ce16: f7fe fcb0    	bl	0x801b77a <dma_get_status> @ imm = #-0x16a0
 801ce1a: 4603         	mov	r3, r0
 801ce1c: 2b00         	cmp	r3, #0x0
 801ce1e: d105         	bne	0x801ce2c <uart_stm32_async_tx_abort+0x56> @ imm = #0xa
; 		data->dma_tx.counter = tx_buffer_length - stat.pending_length;
 801ce20: 68fb         	ldr	r3, [r7, #0xc]
 801ce22: 6aba         	ldr	r2, [r7, #0x28]
 801ce24: 1ad2         	subs	r2, r2, r3
 801ce26: 6afb         	ldr	r3, [r7, #0x2c]
 801ce28: f8c3 2110    	str.w	r2, [r3, #0x110]
; 	dma_stop(data->dma_tx.dma_dev, data->dma_tx.dma_channel);
 801ce2c: 6afb         	ldr	r3, [r7, #0x2c]
 801ce2e: f8d3 20b8    	ldr.w	r2, [r3, #0xb8]
 801ce32: 6afb         	ldr	r3, [r7, #0x2c]
 801ce34: f8d3 30bc    	ldr.w	r3, [r3, #0xbc]
 801ce38: 4619         	mov	r1, r3
 801ce3a: 4610         	mov	r0, r2
 801ce3c: f7fe fcc6    	bl	0x801b7cc <dma_stop>    @ imm = #-0x1674
; 	async_evt_tx_abort(data);
 801ce40: 6af8         	ldr	r0, [r7, #0x2c]
 801ce42: f7ef f925    	bl	0x800c090 <async_evt_tx_abort> @ imm = #-0x10db6
; 	return 0;
 801ce46: 2300         	movs	r3, #0x0
; }
 801ce48: 4618         	mov	r0, r3
 801ce4a: 3730         	adds	r7, #0x30
 801ce4c: 46bd         	mov	sp, r7
 801ce4e: bd80         	pop	{r7, pc}

0801ce50 <uart_stm32_init>:
; {
 801ce50: b580         	push	{r7, lr}
 801ce52: b084         	sub	sp, #0x10
 801ce54: af00         	add	r7, sp, #0x0
 801ce56: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801ce58: 687b         	ldr	r3, [r7, #0x4]
 801ce5a: 685b         	ldr	r3, [r3, #0x4]
 801ce5c: 60fb         	str	r3, [r7, #0xc]
; 	err = uart_stm32_clocks_enable(dev);
 801ce5e: 6878         	ldr	r0, [r7, #0x4]
 801ce60: f7ef fef8    	bl	0x800cc54 <uart_stm32_clocks_enable> @ imm = #-0x10210
 801ce64: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 801ce66: 68bb         	ldr	r3, [r7, #0x8]
 801ce68: 2b00         	cmp	r3, #0x0
 801ce6a: da01         	bge	0x801ce70 <uart_stm32_init+0x20> @ imm = #0x2
; 		return err;
 801ce6c: 68bb         	ldr	r3, [r7, #0x8]
 801ce6e: e01c         	b	0x801ceaa <uart_stm32_init+0x5a> @ imm = #0x38
; 	err = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
 801ce70: 68fb         	ldr	r3, [r7, #0xc]
 801ce72: 6a1b         	ldr	r3, [r3, #0x20]
 801ce74: 2100         	movs	r1, #0x0
 801ce76: 4618         	mov	r0, r3
 801ce78: f7fe fcca    	bl	0x801b810 <pinctrl_apply_state> @ imm = #-0x166c
 801ce7c: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 801ce7e: 68bb         	ldr	r3, [r7, #0x8]
 801ce80: 2b00         	cmp	r3, #0x0
 801ce82: da01         	bge	0x801ce88 <uart_stm32_init+0x38> @ imm = #0x2
; 		return err;
 801ce84: 68bb         	ldr	r3, [r7, #0x8]
 801ce86: e010         	b	0x801ceaa <uart_stm32_init+0x5a> @ imm = #0x20
; 	err = uart_stm32_registers_configure(dev);
 801ce88: 6878         	ldr	r0, [r7, #0x4]
 801ce8a: f7ef ff4b    	bl	0x800cd24 <uart_stm32_registers_configure> @ imm = #-0x1016a
 801ce8e: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 801ce90: 68bb         	ldr	r3, [r7, #0x8]
 801ce92: 2b00         	cmp	r3, #0x0
 801ce94: da01         	bge	0x801ce9a <uart_stm32_init+0x4a> @ imm = #0x2
; 		return err;
 801ce96: 68bb         	ldr	r3, [r7, #0x8]
 801ce98: e007         	b	0x801ceaa <uart_stm32_init+0x5a> @ imm = #0xe
; 	config->irq_config_func(dev);
 801ce9a: 68fb         	ldr	r3, [r7, #0xc]
 801ce9c: 6a5b         	ldr	r3, [r3, #0x24]
 801ce9e: 6878         	ldr	r0, [r7, #0x4]
 801cea0: 4798         	blx	r3
; 	return uart_stm32_async_init(dev);
 801cea2: 6878         	ldr	r0, [r7, #0x4]
 801cea4: f7ef fdcc    	bl	0x800ca40 <uart_stm32_async_init> @ imm = #-0x10468
 801cea8: 4603         	mov	r3, r0
; }
 801ceaa: 4618         	mov	r0, r3
 801ceac: 3710         	adds	r7, #0x10
 801ceae: 46bd         	mov	sp, r7
 801ceb0: bd80         	pop	{r7, pc}

0801ceb2 <uart_stm32_irq_config_func_0>:
; DT_INST_FOREACH_STATUS_OKAY(STM32_UART_INIT)
 801ceb2: b580         	push	{r7, lr}
 801ceb4: b082         	sub	sp, #0x8
 801ceb6: af00         	add	r7, sp, #0x0
 801ceb8: 6078         	str	r0, [r7, #0x4]
 801ceba: 2200         	movs	r2, #0x0
 801cebc: 2100         	movs	r1, #0x0
 801cebe: 2025         	movs	r0, #0x25
 801cec0: f7fa fcd3    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0x565a
 801cec4: 2025         	movs	r0, #0x25
 801cec6: f7fa fcc3    	bl	0x8017850 <arch_irq_enable> @ imm = #-0x567a
 801ceca: 3708         	adds	r7, #0x8
 801cecc: 46bd         	mov	sp, r7
 801cece: bd80         	pop	{r7, pc}

0801ced0 <uart_stm32_irq_config_func_1>:
 801ced0: b580         	push	{r7, lr}
 801ced2: b082         	sub	sp, #0x8
 801ced4: af00         	add	r7, sp, #0x0
 801ced6: 6078         	str	r0, [r7, #0x4]
 801ced8: 2200         	movs	r2, #0x0
 801ceda: 2100         	movs	r1, #0x0
 801cedc: 2047         	movs	r0, #0x47
 801cede: f7fa fcc4    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0x5678
 801cee2: 2047         	movs	r0, #0x47
 801cee4: f7fa fcb4    	bl	0x8017850 <arch_irq_enable> @ imm = #-0x5698
 801cee8: 3708         	adds	r7, #0x8
 801ceea: 46bd         	mov	sp, r7
 801ceec: bd80         	pop	{r7, pc}

0801ceee <uart_stm32_irq_config_func_2>:
 801ceee: b580         	push	{r7, lr}
 801cef0: b082         	sub	sp, #0x8
 801cef2: af00         	add	r7, sp, #0x0
 801cef4: 6078         	str	r0, [r7, #0x4]
 801cef6: 2200         	movs	r2, #0x0
 801cef8: 2100         	movs	r1, #0x0
 801cefa: 2027         	movs	r0, #0x27
 801cefc: f7fa fcb5    	bl	0x801786a <z_arm_irq_priority_set> @ imm = #-0x5696
 801cf00: 2027         	movs	r0, #0x27
 801cf02: f7fa fca5    	bl	0x8017850 <arch_irq_enable> @ imm = #-0x56b6
 801cf06: 3708         	adds	r7, #0x8
 801cf08: 46bd         	mov	sp, r7
 801cf0a: bd80         	pop	{r7, pc}

0801cf0c <device_is_ready>:
; {
 801cf0c: b580         	push	{r7, lr}
 801cf0e: b082         	sub	sp, #0x8
 801cf10: af00         	add	r7, sp, #0x0
 801cf12: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801cf14: 6878         	ldr	r0, [r7, #0x4]
 801cf16: f001 f85b    	bl	0x801dfd0 <z_impl_device_is_ready> @ imm = #0x10b6
 801cf1a: 4603         	mov	r3, r0
; }
 801cf1c: 4618         	mov	r0, r3
 801cf1e: 3708         	adds	r7, #0x8
 801cf20: 46bd         	mov	sp, r7
 801cf22: bd80         	pop	{r7, pc}

0801cf24 <z_log_msg_runtime_create>:
; {
 801cf24: b580         	push	{r7, lr}
 801cf26: b08a         	sub	sp, #0x28
 801cf28: af04         	add	r7, sp, #0x10
 801cf2a: 60b9         	str	r1, [r7, #0x8]
 801cf2c: 607b         	str	r3, [r7, #0x4]
 801cf2e: 4603         	mov	r3, r0
 801cf30: 73fb         	strb	r3, [r7, #0xf]
 801cf32: 4613         	mov	r3, r2
 801cf34: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801cf36: f107 032c    	add.w	r3, r7, #0x2c
 801cf3a: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801cf3c: 7bba         	ldrb	r2, [r7, #0xe]
 801cf3e: 7bf8         	ldrb	r0, [r7, #0xf]
 801cf40: 697b         	ldr	r3, [r7, #0x14]
 801cf42: 9303         	str	r3, [sp, #0xc]
 801cf44: 6abb         	ldr	r3, [r7, #0x28]
 801cf46: 9302         	str	r3, [sp, #0x8]
 801cf48: 6a7b         	ldr	r3, [r7, #0x24]
 801cf4a: 9301         	str	r3, [sp, #0x4]
 801cf4c: 6a3b         	ldr	r3, [r7, #0x20]
 801cf4e: 9300         	str	r3, [sp]
 801cf50: 687b         	ldr	r3, [r7, #0x4]
 801cf52: 68b9         	ldr	r1, [r7, #0x8]
 801cf54: f7e8 fb0e    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x179e4
; }
 801cf58: bf00         	nop
 801cf5a: 3718         	adds	r7, #0x18
 801cf5c: 46bd         	mov	sp, r7
 801cf5e: bd80         	pop	{r7, pc}

0801cf60 <z_impl_k_sem_count_get>:
; {
 801cf60: b480         	push	{r7}
 801cf62: b083         	sub	sp, #0xc
 801cf64: af00         	add	r7, sp, #0x0
 801cf66: 6078         	str	r0, [r7, #0x4]
; 	return sem->count;
 801cf68: 687b         	ldr	r3, [r7, #0x4]
 801cf6a: 689b         	ldr	r3, [r3, #0x8]
; }
 801cf6c: 4618         	mov	r0, r3
 801cf6e: 370c         	adds	r7, #0xc
 801cf70: 46bd         	mov	sp, r7
 801cf72: f85d 7b04    	ldr	r7, [sp], #4
 801cf76: 4770         	bx	lr

0801cf78 <k_busy_wait>:
; {
 801cf78: b580         	push	{r7, lr}
 801cf7a: b082         	sub	sp, #0x8
 801cf7c: af00         	add	r7, sp, #0x0
 801cf7e: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_busy_wait(usec_to_wait);
 801cf80: 6878         	ldr	r0, [r7, #0x4]
 801cf82: f000 fffc    	bl	0x801df7e <z_impl_k_busy_wait> @ imm = #0xff8
; }
 801cf86: bf00         	nop
 801cf88: 3708         	adds	r7, #0x8
 801cf8a: 46bd         	mov	sp, r7
 801cf8c: bd80         	pop	{r7, pc}

0801cf8e <k_sem_take>:
; {
 801cf8e: b580         	push	{r7, lr}
 801cf90: b084         	sub	sp, #0x10
 801cf92: af00         	add	r7, sp, #0x0
 801cf94: 60f8         	str	r0, [r7, #0xc]
 801cf96: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 801cf9a: e9d7 2300    	ldrd	r2, r3, [r7]
 801cf9e: 68f8         	ldr	r0, [r7, #0xc]
 801cfa0: f7f3 f99a    	bl	0x80102d8 <z_impl_k_sem_take> @ imm = #-0xcccc
 801cfa4: 4603         	mov	r3, r0
; }
 801cfa6: 4618         	mov	r0, r3
 801cfa8: 3710         	adds	r7, #0x10
 801cfaa: 46bd         	mov	sp, r7
 801cfac: bd80         	pop	{r7, pc}

0801cfae <k_sem_give>:
; {
 801cfae: b580         	push	{r7, lr}
 801cfb0: b082         	sub	sp, #0x8
 801cfb2: af00         	add	r7, sp, #0x0
 801cfb4: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801cfb6: 6878         	ldr	r0, [r7, #0x4]
 801cfb8: f7f3 f900    	bl	0x80101bc <z_impl_k_sem_give> @ imm = #-0xce00
; }
 801cfbc: bf00         	nop
 801cfbe: 3708         	adds	r7, #0x8
 801cfc0: 46bd         	mov	sp, r7
 801cfc2: bd80         	pop	{r7, pc}

0801cfc4 <k_sem_count_get>:
; {
 801cfc4: b580         	push	{r7, lr}
 801cfc6: b082         	sub	sp, #0x8
 801cfc8: af00         	add	r7, sp, #0x0
 801cfca: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_sem_count_get(sem);
 801cfcc: 6878         	ldr	r0, [r7, #0x4]
 801cfce: f7ff ffc7    	bl	0x801cf60 <z_impl_k_sem_count_get> @ imm = #-0x72
 801cfd2: 4603         	mov	r3, r0
; }
 801cfd4: 4618         	mov	r0, r3
 801cfd6: 3708         	adds	r7, #0x8
 801cfd8: 46bd         	mov	sp, r7
 801cfda: bd80         	pop	{r7, pc}

0801cfdc <LL_SPI_Enable>:
; {
 801cfdc: b480         	push	{r7}
 801cfde: b083         	sub	sp, #0xc
 801cfe0: af00         	add	r7, sp, #0x0
 801cfe2: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(SPIx->CR1, SPI_CR1_SPE);
 801cfe4: 687b         	ldr	r3, [r7, #0x4]
 801cfe6: 681b         	ldr	r3, [r3]
 801cfe8: f043 0240    	orr	r2, r3, #0x40
 801cfec: 687b         	ldr	r3, [r7, #0x4]
 801cfee: 601a         	str	r2, [r3]
; }
 801cff0: bf00         	nop
 801cff2: 370c         	adds	r7, #0xc
 801cff4: 46bd         	mov	sp, r7
 801cff6: f85d 7b04    	ldr	r7, [sp], #4
 801cffa: 4770         	bx	lr

0801cffc <LL_SPI_Disable>:
; {
 801cffc: b480         	push	{r7}
 801cffe: b083         	sub	sp, #0xc
 801d000: af00         	add	r7, sp, #0x0
 801d002: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 801d004: 687b         	ldr	r3, [r7, #0x4]
 801d006: 681b         	ldr	r3, [r3]
 801d008: f023 0240    	bic	r2, r3, #0x40
 801d00c: 687b         	ldr	r3, [r7, #0x4]
 801d00e: 601a         	str	r2, [r3]
; }
 801d010: bf00         	nop
 801d012: 370c         	adds	r7, #0xc
 801d014: 46bd         	mov	sp, r7
 801d016: f85d 7b04    	ldr	r7, [sp], #4
 801d01a: 4770         	bx	lr

0801d01c <LL_SPI_IsEnabled>:
; {
 801d01c: b480         	push	{r7}
 801d01e: b083         	sub	sp, #0xc
 801d020: af00         	add	r7, sp, #0x0
 801d022: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->CR1, SPI_CR1_SPE) == (SPI_CR1_SPE)) ? 1UL : 0UL);
 801d024: 687b         	ldr	r3, [r7, #0x4]
 801d026: 681b         	ldr	r3, [r3]
 801d028: f003 0340    	and	r3, r3, #0x40
 801d02c: 2b40         	cmp	r3, #0x40
 801d02e: d101         	bne	0x801d034 <LL_SPI_IsEnabled+0x18> @ imm = #0x2
 801d030: 2301         	movs	r3, #0x1
 801d032: e000         	b	0x801d036 <LL_SPI_IsEnabled+0x1a> @ imm = #0x0
 801d034: 2300         	movs	r3, #0x0
; }
 801d036: 4618         	mov	r0, r3
 801d038: 370c         	adds	r7, #0xc
 801d03a: 46bd         	mov	sp, r7
 801d03c: f85d 7b04    	ldr	r7, [sp], #4
 801d040: 4770         	bx	lr

0801d042 <LL_SPI_SetMode>:
; {
 801d042: b480         	push	{r7}
 801d044: b083         	sub	sp, #0xc
 801d046: af00         	add	r7, sp, #0x0
 801d048: 6078         	str	r0, [r7, #0x4]
 801d04a: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI, Mode);
 801d04c: 687b         	ldr	r3, [r7, #0x4]
 801d04e: 681b         	ldr	r3, [r3]
 801d050: f423 7282    	bic	r2, r3, #0x104
 801d054: 683b         	ldr	r3, [r7]
 801d056: 431a         	orrs	r2, r3
 801d058: 687b         	ldr	r3, [r7, #0x4]
 801d05a: 601a         	str	r2, [r3]
; }
 801d05c: bf00         	nop
 801d05e: 370c         	adds	r7, #0xc
 801d060: 46bd         	mov	sp, r7
 801d062: f85d 7b04    	ldr	r7, [sp], #4
 801d066: 4770         	bx	lr

0801d068 <LL_SPI_GetMode>:
; {
 801d068: b480         	push	{r7}
 801d06a: b083         	sub	sp, #0xc
 801d06c: af00         	add	r7, sp, #0x0
 801d06e: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI));
 801d070: 687b         	ldr	r3, [r7, #0x4]
 801d072: 681b         	ldr	r3, [r3]
 801d074: f403 7382    	and	r3, r3, #0x104
; }
 801d078: 4618         	mov	r0, r3
 801d07a: 370c         	adds	r7, #0xc
 801d07c: 46bd         	mov	sp, r7
 801d07e: f85d 7b04    	ldr	r7, [sp], #4
 801d082: 4770         	bx	lr

0801d084 <LL_SPI_SetStandard>:
; {
 801d084: b480         	push	{r7}
 801d086: b083         	sub	sp, #0xc
 801d088: af00         	add	r7, sp, #0x0
 801d08a: 6078         	str	r0, [r7, #0x4]
 801d08c: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR2, SPI_CR2_FRF, Standard);
 801d08e: 687b         	ldr	r3, [r7, #0x4]
 801d090: 685b         	ldr	r3, [r3, #0x4]
 801d092: f023 0210    	bic	r2, r3, #0x10
 801d096: 683b         	ldr	r3, [r7]
 801d098: 431a         	orrs	r2, r3
 801d09a: 687b         	ldr	r3, [r7, #0x4]
 801d09c: 605a         	str	r2, [r3, #0x4]
; }
 801d09e: bf00         	nop
 801d0a0: 370c         	adds	r7, #0xc
 801d0a2: 46bd         	mov	sp, r7
 801d0a4: f85d 7b04    	ldr	r7, [sp], #4
 801d0a8: 4770         	bx	lr

0801d0aa <LL_SPI_SetClockPhase>:
; {
 801d0aa: b480         	push	{r7}
 801d0ac: b083         	sub	sp, #0xc
 801d0ae: af00         	add	r7, sp, #0x0
 801d0b0: 6078         	str	r0, [r7, #0x4]
 801d0b2: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_CPHA, ClockPhase);
 801d0b4: 687b         	ldr	r3, [r7, #0x4]
 801d0b6: 681b         	ldr	r3, [r3]
 801d0b8: f023 0201    	bic	r2, r3, #0x1
 801d0bc: 683b         	ldr	r3, [r7]
 801d0be: 431a         	orrs	r2, r3
 801d0c0: 687b         	ldr	r3, [r7, #0x4]
 801d0c2: 601a         	str	r2, [r3]
; }
 801d0c4: bf00         	nop
 801d0c6: 370c         	adds	r7, #0xc
 801d0c8: 46bd         	mov	sp, r7
 801d0ca: f85d 7b04    	ldr	r7, [sp], #4
 801d0ce: 4770         	bx	lr

0801d0d0 <LL_SPI_SetClockPolarity>:
; {
 801d0d0: b480         	push	{r7}
 801d0d2: b083         	sub	sp, #0xc
 801d0d4: af00         	add	r7, sp, #0x0
 801d0d6: 6078         	str	r0, [r7, #0x4]
 801d0d8: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_CPOL, ClockPolarity);
 801d0da: 687b         	ldr	r3, [r7, #0x4]
 801d0dc: 681b         	ldr	r3, [r3]
 801d0de: f023 0202    	bic	r2, r3, #0x2
 801d0e2: 683b         	ldr	r3, [r7]
 801d0e4: 431a         	orrs	r2, r3
 801d0e6: 687b         	ldr	r3, [r7, #0x4]
 801d0e8: 601a         	str	r2, [r3]
; }
 801d0ea: bf00         	nop
 801d0ec: 370c         	adds	r7, #0xc
 801d0ee: 46bd         	mov	sp, r7
 801d0f0: f85d 7b04    	ldr	r7, [sp], #4
 801d0f4: 4770         	bx	lr

0801d0f6 <LL_SPI_SetBaudRatePrescaler>:
; {
 801d0f6: b480         	push	{r7}
 801d0f8: b083         	sub	sp, #0xc
 801d0fa: af00         	add	r7, sp, #0x0
 801d0fc: 6078         	str	r0, [r7, #0x4]
 801d0fe: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_BR, BaudRate);
 801d100: 687b         	ldr	r3, [r7, #0x4]
 801d102: 681b         	ldr	r3, [r3]
 801d104: f023 0238    	bic	r2, r3, #0x38
 801d108: 683b         	ldr	r3, [r7]
 801d10a: 431a         	orrs	r2, r3
 801d10c: 687b         	ldr	r3, [r7, #0x4]
 801d10e: 601a         	str	r2, [r3]
; }
 801d110: bf00         	nop
 801d112: 370c         	adds	r7, #0xc
 801d114: 46bd         	mov	sp, r7
 801d116: f85d 7b04    	ldr	r7, [sp], #4
 801d11a: 4770         	bx	lr

0801d11c <LL_SPI_SetTransferBitOrder>:
; {
 801d11c: b480         	push	{r7}
 801d11e: b083         	sub	sp, #0xc
 801d120: af00         	add	r7, sp, #0x0
 801d122: 6078         	str	r0, [r7, #0x4]
 801d124: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_LSBFIRST, BitOrder);
 801d126: 687b         	ldr	r3, [r7, #0x4]
 801d128: 681b         	ldr	r3, [r3]
 801d12a: f023 0280    	bic	r2, r3, #0x80
 801d12e: 683b         	ldr	r3, [r7]
 801d130: 431a         	orrs	r2, r3
 801d132: 687b         	ldr	r3, [r7, #0x4]
 801d134: 601a         	str	r2, [r3]
; }
 801d136: bf00         	nop
 801d138: 370c         	adds	r7, #0xc
 801d13a: 46bd         	mov	sp, r7
 801d13c: f85d 7b04    	ldr	r7, [sp], #4
 801d140: 4770         	bx	lr

0801d142 <LL_SPI_SetTransferDirection>:
; {
 801d142: b480         	push	{r7}
 801d144: b083         	sub	sp, #0xc
 801d146: af00         	add	r7, sp, #0x0
 801d148: 6078         	str	r0, [r7, #0x4]
 801d14a: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_RXONLY | SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE, TransferDirection);
 801d14c: 687b         	ldr	r3, [r7, #0x4]
 801d14e: 681b         	ldr	r3, [r3]
 801d150: f423 4244    	bic	r2, r3, #0xc400
 801d154: 683b         	ldr	r3, [r7]
 801d156: 431a         	orrs	r2, r3
 801d158: 687b         	ldr	r3, [r7, #0x4]
 801d15a: 601a         	str	r2, [r3]
; }
 801d15c: bf00         	nop
 801d15e: 370c         	adds	r7, #0xc
 801d160: 46bd         	mov	sp, r7
 801d162: f85d 7b04    	ldr	r7, [sp], #4
 801d166: 4770         	bx	lr

0801d168 <LL_SPI_SetDataWidth>:
; {
 801d168: b480         	push	{r7}
 801d16a: b083         	sub	sp, #0xc
 801d16c: af00         	add	r7, sp, #0x0
 801d16e: 6078         	str	r0, [r7, #0x4]
 801d170: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_DFF, DataWidth);
 801d172: 687b         	ldr	r3, [r7, #0x4]
 801d174: 681b         	ldr	r3, [r3]
 801d176: f423 6200    	bic	r2, r3, #0x800
 801d17a: 683b         	ldr	r3, [r7]
 801d17c: 431a         	orrs	r2, r3
 801d17e: 687b         	ldr	r3, [r7, #0x4]
 801d180: 601a         	str	r2, [r3]
; }
 801d182: bf00         	nop
 801d184: 370c         	adds	r7, #0xc
 801d186: 46bd         	mov	sp, r7
 801d188: f85d 7b04    	ldr	r7, [sp], #4
 801d18c: 4770         	bx	lr

0801d18e <LL_SPI_DisableCRC>:
; {
 801d18e: b480         	push	{r7}
 801d190: b083         	sub	sp, #0xc
 801d192: af00         	add	r7, sp, #0x0
 801d194: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_CRCEN);
 801d196: 687b         	ldr	r3, [r7, #0x4]
 801d198: 681b         	ldr	r3, [r3]
 801d19a: f423 5200    	bic	r2, r3, #0x2000
 801d19e: 687b         	ldr	r3, [r7, #0x4]
 801d1a0: 601a         	str	r2, [r3]
; }
 801d1a2: bf00         	nop
 801d1a4: 370c         	adds	r7, #0xc
 801d1a6: 46bd         	mov	sp, r7
 801d1a8: f85d 7b04    	ldr	r7, [sp], #4
 801d1ac: 4770         	bx	lr

0801d1ae <LL_SPI_SetNSSMode>:
; {
 801d1ae: b480         	push	{r7}
 801d1b0: b083         	sub	sp, #0xc
 801d1b2: af00         	add	r7, sp, #0x0
 801d1b4: 6078         	str	r0, [r7, #0x4]
 801d1b6: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_SSM,  NSS);
 801d1b8: 687b         	ldr	r3, [r7, #0x4]
 801d1ba: 681b         	ldr	r3, [r3]
 801d1bc: f423 7200    	bic	r2, r3, #0x200
 801d1c0: 683b         	ldr	r3, [r7]
 801d1c2: 431a         	orrs	r2, r3
 801d1c4: 687b         	ldr	r3, [r7, #0x4]
 801d1c6: 601a         	str	r2, [r3]
;   MODIFY_REG(SPIx->CR2, SPI_CR2_SSOE, ((uint32_t)(NSS >> 16U)));
 801d1c8: 687b         	ldr	r3, [r7, #0x4]
 801d1ca: 685b         	ldr	r3, [r3, #0x4]
 801d1cc: f023 0204    	bic	r2, r3, #0x4
 801d1d0: 683b         	ldr	r3, [r7]
 801d1d2: 0c1b         	lsrs	r3, r3, #0x10
 801d1d4: 431a         	orrs	r2, r3
 801d1d6: 687b         	ldr	r3, [r7, #0x4]
 801d1d8: 605a         	str	r2, [r3, #0x4]
; }
 801d1da: bf00         	nop
 801d1dc: 370c         	adds	r7, #0xc
 801d1de: 46bd         	mov	sp, r7
 801d1e0: f85d 7b04    	ldr	r7, [sp], #4
 801d1e4: 4770         	bx	lr

0801d1e6 <LL_SPI_IsActiveFlag_RXNE>:
; {
 801d1e6: b480         	push	{r7}
 801d1e8: b083         	sub	sp, #0xc
 801d1ea: af00         	add	r7, sp, #0x0
 801d1ec: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_RXNE) == (SPI_SR_RXNE)) ? 1UL : 0UL);
 801d1ee: 687b         	ldr	r3, [r7, #0x4]
 801d1f0: 689b         	ldr	r3, [r3, #0x8]
 801d1f2: f003 0301    	and	r3, r3, #0x1
 801d1f6: 2b01         	cmp	r3, #0x1
 801d1f8: d101         	bne	0x801d1fe <LL_SPI_IsActiveFlag_RXNE+0x18> @ imm = #0x2
 801d1fa: 2301         	movs	r3, #0x1
 801d1fc: e000         	b	0x801d200 <LL_SPI_IsActiveFlag_RXNE+0x1a> @ imm = #0x0
 801d1fe: 2300         	movs	r3, #0x0
; }
 801d200: 4618         	mov	r0, r3
 801d202: 370c         	adds	r7, #0xc
 801d204: 46bd         	mov	sp, r7
 801d206: f85d 7b04    	ldr	r7, [sp], #4
 801d20a: 4770         	bx	lr

0801d20c <LL_SPI_IsActiveFlag_TXE>:
; {
 801d20c: b480         	push	{r7}
 801d20e: b083         	sub	sp, #0xc
 801d210: af00         	add	r7, sp, #0x0
 801d212: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_TXE) == (SPI_SR_TXE)) ? 1UL : 0UL);
 801d214: 687b         	ldr	r3, [r7, #0x4]
 801d216: 689b         	ldr	r3, [r3, #0x8]
 801d218: f003 0302    	and	r3, r3, #0x2
 801d21c: 2b02         	cmp	r3, #0x2
 801d21e: d101         	bne	0x801d224 <LL_SPI_IsActiveFlag_TXE+0x18> @ imm = #0x2
 801d220: 2301         	movs	r3, #0x1
 801d222: e000         	b	0x801d226 <LL_SPI_IsActiveFlag_TXE+0x1a> @ imm = #0x0
 801d224: 2300         	movs	r3, #0x0
; }
 801d226: 4618         	mov	r0, r3
 801d228: 370c         	adds	r7, #0xc
 801d22a: 46bd         	mov	sp, r7
 801d22c: f85d 7b04    	ldr	r7, [sp], #4
 801d230: 4770         	bx	lr

0801d232 <LL_SPI_IsActiveFlag_MODF>:
; {
 801d232: b480         	push	{r7}
 801d234: b083         	sub	sp, #0xc
 801d236: af00         	add	r7, sp, #0x0
 801d238: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_MODF) == (SPI_SR_MODF)) ? 1UL : 0UL);
 801d23a: 687b         	ldr	r3, [r7, #0x4]
 801d23c: 689b         	ldr	r3, [r3, #0x8]
 801d23e: f003 0320    	and	r3, r3, #0x20
 801d242: 2b20         	cmp	r3, #0x20
 801d244: d101         	bne	0x801d24a <LL_SPI_IsActiveFlag_MODF+0x18> @ imm = #0x2
 801d246: 2301         	movs	r3, #0x1
 801d248: e000         	b	0x801d24c <LL_SPI_IsActiveFlag_MODF+0x1a> @ imm = #0x0
 801d24a: 2300         	movs	r3, #0x0
; }
 801d24c: 4618         	mov	r0, r3
 801d24e: 370c         	adds	r7, #0xc
 801d250: 46bd         	mov	sp, r7
 801d252: f85d 7b04    	ldr	r7, [sp], #4
 801d256: 4770         	bx	lr

0801d258 <LL_SPI_IsActiveFlag_OVR>:
; {
 801d258: b480         	push	{r7}
 801d25a: b083         	sub	sp, #0xc
 801d25c: af00         	add	r7, sp, #0x0
 801d25e: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_OVR) == (SPI_SR_OVR)) ? 1UL : 0UL);
 801d260: 687b         	ldr	r3, [r7, #0x4]
 801d262: 689b         	ldr	r3, [r3, #0x8]
 801d264: f003 0340    	and	r3, r3, #0x40
 801d268: 2b40         	cmp	r3, #0x40
 801d26a: d101         	bne	0x801d270 <LL_SPI_IsActiveFlag_OVR+0x18> @ imm = #0x2
 801d26c: 2301         	movs	r3, #0x1
 801d26e: e000         	b	0x801d272 <LL_SPI_IsActiveFlag_OVR+0x1a> @ imm = #0x0
 801d270: 2300         	movs	r3, #0x0
; }
 801d272: 4618         	mov	r0, r3
 801d274: 370c         	adds	r7, #0xc
 801d276: 46bd         	mov	sp, r7
 801d278: f85d 7b04    	ldr	r7, [sp], #4
 801d27c: 4770         	bx	lr

0801d27e <LL_SPI_IsActiveFlag_BSY>:
; {
 801d27e: b480         	push	{r7}
 801d280: b083         	sub	sp, #0xc
 801d282: af00         	add	r7, sp, #0x0
 801d284: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_BSY) == (SPI_SR_BSY)) ? 1UL : 0UL);
 801d286: 687b         	ldr	r3, [r7, #0x4]
 801d288: 689b         	ldr	r3, [r3, #0x8]
 801d28a: f003 0380    	and	r3, r3, #0x80
 801d28e: 2b80         	cmp	r3, #0x80
 801d290: d101         	bne	0x801d296 <LL_SPI_IsActiveFlag_BSY+0x18> @ imm = #0x2
 801d292: 2301         	movs	r3, #0x1
 801d294: e000         	b	0x801d298 <LL_SPI_IsActiveFlag_BSY+0x1a> @ imm = #0x0
 801d296: 2300         	movs	r3, #0x0
; }
 801d298: 4618         	mov	r0, r3
 801d29a: 370c         	adds	r7, #0xc
 801d29c: 46bd         	mov	sp, r7
 801d29e: f85d 7b04    	ldr	r7, [sp], #4
 801d2a2: 4770         	bx	lr

0801d2a4 <LL_SPI_ClearFlag_MODF>:
; {
 801d2a4: b480         	push	{r7}
 801d2a6: b085         	sub	sp, #0x14
 801d2a8: af00         	add	r7, sp, #0x0
 801d2aa: 6078         	str	r0, [r7, #0x4]
;   tmpreg_sr = SPIx->SR;
 801d2ac: 687b         	ldr	r3, [r7, #0x4]
 801d2ae: 689b         	ldr	r3, [r3, #0x8]
 801d2b0: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg_sr;
 801d2b2: 68fb         	ldr	r3, [r7, #0xc]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 801d2b4: 687b         	ldr	r3, [r7, #0x4]
 801d2b6: 681b         	ldr	r3, [r3]
 801d2b8: f023 0240    	bic	r2, r3, #0x40
 801d2bc: 687b         	ldr	r3, [r7, #0x4]
 801d2be: 601a         	str	r2, [r3]
; }
 801d2c0: bf00         	nop
 801d2c2: 3714         	adds	r7, #0x14
 801d2c4: 46bd         	mov	sp, r7
 801d2c6: f85d 7b04    	ldr	r7, [sp], #4
 801d2ca: 4770         	bx	lr

0801d2cc <LL_SPI_ClearFlag_OVR>:
; {
 801d2cc: b480         	push	{r7}
 801d2ce: b085         	sub	sp, #0x14
 801d2d0: af00         	add	r7, sp, #0x0
 801d2d2: 6078         	str	r0, [r7, #0x4]
;   tmpreg = SPIx->DR;
 801d2d4: 687b         	ldr	r3, [r7, #0x4]
 801d2d6: 68db         	ldr	r3, [r3, #0xc]
 801d2d8: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801d2da: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = SPIx->SR;
 801d2dc: 687b         	ldr	r3, [r7, #0x4]
 801d2de: 689b         	ldr	r3, [r3, #0x8]
 801d2e0: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801d2e2: 68fb         	ldr	r3, [r7, #0xc]
; }
 801d2e4: bf00         	nop
 801d2e6: 3714         	adds	r7, #0x14
 801d2e8: 46bd         	mov	sp, r7
 801d2ea: f85d 7b04    	ldr	r7, [sp], #4
 801d2ee: 4770         	bx	lr

0801d2f0 <LL_SPI_DisableIT_TXE>:
; {
 801d2f0: b480         	push	{r7}
 801d2f2: b083         	sub	sp, #0xc
 801d2f4: af00         	add	r7, sp, #0x0
 801d2f6: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR2, SPI_CR2_TXEIE);
 801d2f8: 687b         	ldr	r3, [r7, #0x4]
 801d2fa: 685b         	ldr	r3, [r3, #0x4]
 801d2fc: f023 0280    	bic	r2, r3, #0x80
 801d300: 687b         	ldr	r3, [r7, #0x4]
 801d302: 605a         	str	r2, [r3, #0x4]
; }
 801d304: bf00         	nop
 801d306: 370c         	adds	r7, #0xc
 801d308: 46bd         	mov	sp, r7
 801d30a: f85d 7b04    	ldr	r7, [sp], #4
 801d30e: 4770         	bx	lr

0801d310 <LL_SPI_ReceiveData8>:
; {
 801d310: b480         	push	{r7}
 801d312: b083         	sub	sp, #0xc
 801d314: af00         	add	r7, sp, #0x0
 801d316: 6078         	str	r0, [r7, #0x4]
;   return (*((__IO uint8_t *)&SPIx->DR));
 801d318: 687b         	ldr	r3, [r7, #0x4]
 801d31a: 330c         	adds	r3, #0xc
 801d31c: 781b         	ldrb	r3, [r3]
 801d31e: b2db         	uxtb	r3, r3
; }
 801d320: 4618         	mov	r0, r3
 801d322: 370c         	adds	r7, #0xc
 801d324: 46bd         	mov	sp, r7
 801d326: f85d 7b04    	ldr	r7, [sp], #4
 801d32a: 4770         	bx	lr

0801d32c <LL_SPI_ReceiveData16>:
; {
 801d32c: b480         	push	{r7}
 801d32e: b083         	sub	sp, #0xc
 801d330: af00         	add	r7, sp, #0x0
 801d332: 6078         	str	r0, [r7, #0x4]
;   return (uint16_t)(READ_REG(SPIx->DR));
 801d334: 687b         	ldr	r3, [r7, #0x4]
 801d336: 68db         	ldr	r3, [r3, #0xc]
 801d338: b29b         	uxth	r3, r3
; }
 801d33a: 4618         	mov	r0, r3
 801d33c: 370c         	adds	r7, #0xc
 801d33e: 46bd         	mov	sp, r7
 801d340: f85d 7b04    	ldr	r7, [sp], #4
 801d344: 4770         	bx	lr

0801d346 <LL_SPI_TransmitData8>:
; {
 801d346: b480         	push	{r7}
 801d348: b085         	sub	sp, #0x14
 801d34a: af00         	add	r7, sp, #0x0
 801d34c: 6078         	str	r0, [r7, #0x4]
 801d34e: 460b         	mov	r3, r1
 801d350: 70fb         	strb	r3, [r7, #0x3]
;   __IO uint8_t *spidr = ((__IO uint8_t *)&SPIx->DR);
 801d352: 687b         	ldr	r3, [r7, #0x4]
 801d354: 330c         	adds	r3, #0xc
 801d356: 60fb         	str	r3, [r7, #0xc]
;   *spidr = TxData;
 801d358: 68fb         	ldr	r3, [r7, #0xc]
 801d35a: 78fa         	ldrb	r2, [r7, #0x3]
 801d35c: 701a         	strb	r2, [r3]
; }
 801d35e: bf00         	nop
 801d360: 3714         	adds	r7, #0x14
 801d362: 46bd         	mov	sp, r7
 801d364: f85d 7b04    	ldr	r7, [sp], #4
 801d368: 4770         	bx	lr

0801d36a <LL_SPI_TransmitData16>:
; {
 801d36a: b480         	push	{r7}
 801d36c: b085         	sub	sp, #0x14
 801d36e: af00         	add	r7, sp, #0x0
 801d370: 6078         	str	r0, [r7, #0x4]
 801d372: 460b         	mov	r3, r1
 801d374: 807b         	strh	r3, [r7, #0x2]
;   __IO uint16_t *spidr = ((__IO uint16_t *)&SPIx->DR);
 801d376: 687b         	ldr	r3, [r7, #0x4]
 801d378: 330c         	adds	r3, #0xc
 801d37a: 60fb         	str	r3, [r7, #0xc]
;   *spidr = TxData;
 801d37c: 68fb         	ldr	r3, [r7, #0xc]
 801d37e: 887a         	ldrh	r2, [r7, #0x2]
 801d380: 801a         	strh	r2, [r3]
; }
 801d382: bf00         	nop
 801d384: 3714         	adds	r7, #0x14
 801d386: 46bd         	mov	sp, r7
 801d388: f85d 7b04    	ldr	r7, [sp], #4
 801d38c: 4770         	bx	lr

0801d38e <z_impl_gpio_pin_configure>:
; {
 801d38e: b580         	push	{r7, lr}
 801d390: b088         	sub	sp, #0x20
 801d392: af00         	add	r7, sp, #0x0
 801d394: 60f8         	str	r0, [r7, #0xc]
 801d396: 460b         	mov	r3, r1
 801d398: 607a         	str	r2, [r7, #0x4]
 801d39a: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 801d39c: 68fb         	ldr	r3, [r7, #0xc]
 801d39e: 689b         	ldr	r3, [r3, #0x8]
 801d3a0: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 801d3a2: 68fb         	ldr	r3, [r7, #0xc]
 801d3a4: 685b         	ldr	r3, [r3, #0x4]
 801d3a6: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 801d3a8: 68fb         	ldr	r3, [r7, #0xc]
 801d3aa: 691b         	ldr	r3, [r3, #0x10]
 801d3ac: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 801d3ae: 687b         	ldr	r3, [r7, #0x4]
 801d3b0: f403 1380    	and	r3, r3, #0x100000
 801d3b4: 2b00         	cmp	r3, #0x0
 801d3b6: d00d         	beq	0x801d3d4 <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 801d3b8: 687b         	ldr	r3, [r7, #0x4]
 801d3ba: f403 2340    	and	r3, r3, #0xc0000
 801d3be: 2b00         	cmp	r3, #0x0
 801d3c0: d008         	beq	0x801d3d4 <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 801d3c2: 687b         	ldr	r3, [r7, #0x4]
 801d3c4: f003 0301    	and	r3, r3, #0x1
 801d3c8: 2b00         	cmp	r3, #0x0
 801d3ca: d003         	beq	0x801d3d4 <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 801d3cc: 687b         	ldr	r3, [r7, #0x4]
 801d3ce: f483 2340    	eor	r3, r3, #0xc0000
 801d3d2: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 801d3d4: 687b         	ldr	r3, [r7, #0x4]
 801d3d6: f423 1380    	bic	r3, r3, #0x100000
 801d3da: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 801d3dc: 687b         	ldr	r3, [r7, #0x4]
 801d3de: f003 0301    	and	r3, r3, #0x1
 801d3e2: 2b00         	cmp	r3, #0x0
 801d3e4: d009         	beq	0x801d3fa <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 801d3e6: 697b         	ldr	r3, [r7, #0x14]
 801d3e8: 681a         	ldr	r2, [r3]
 801d3ea: 7afb         	ldrb	r3, [r7, #0xb]
 801d3ec: 2101         	movs	r1, #0x1
 801d3ee: fa01 f303    	lsl.w	r3, r1, r3
 801d3f2: 431a         	orrs	r2, r3
 801d3f4: 697b         	ldr	r3, [r7, #0x14]
 801d3f6: 601a         	str	r2, [r3]
 801d3f8: e009         	b	0x801d40e <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 801d3fa: 697b         	ldr	r3, [r7, #0x14]
 801d3fc: 681a         	ldr	r2, [r3]
 801d3fe: 7afb         	ldrb	r3, [r7, #0xb]
 801d400: 2101         	movs	r1, #0x1
 801d402: fa01 f303    	lsl.w	r3, r1, r3
 801d406: 43db         	mvns	r3, r3
 801d408: 401a         	ands	r2, r3
 801d40a: 697b         	ldr	r3, [r7, #0x14]
 801d40c: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 801d40e: 69fb         	ldr	r3, [r7, #0x1c]
 801d410: 681b         	ldr	r3, [r3]
 801d412: 7af9         	ldrb	r1, [r7, #0xb]
 801d414: 687a         	ldr	r2, [r7, #0x4]
 801d416: 68f8         	ldr	r0, [r7, #0xc]
 801d418: 4798         	blx	r3
 801d41a: 4603         	mov	r3, r0
; }
 801d41c: 4618         	mov	r0, r3
 801d41e: 3720         	adds	r7, #0x20
 801d420: 46bd         	mov	sp, r7
 801d422: bd80         	pop	{r7, pc}

0801d424 <gpio_pin_configure_dt>:
; {
 801d424: b580         	push	{r7, lr}
 801d426: b082         	sub	sp, #0x8
 801d428: af00         	add	r7, sp, #0x0
 801d42a: 6078         	str	r0, [r7, #0x4]
 801d42c: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 801d42e: 687b         	ldr	r3, [r7, #0x4]
 801d430: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 801d432: 687b         	ldr	r3, [r7, #0x4]
 801d434: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 801d436: 687b         	ldr	r3, [r7, #0x4]
 801d438: 88db         	ldrh	r3, [r3, #0x6]
 801d43a: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 801d43c: 683b         	ldr	r3, [r7]
 801d43e: 4313         	orrs	r3, r2
 801d440: 461a         	mov	r2, r3
 801d442: f000 f888    	bl	0x801d556 <gpio_pin_configure> @ imm = #0x110
 801d446: 4603         	mov	r3, r0
; }
 801d448: 4618         	mov	r0, r3
 801d44a: 3708         	adds	r7, #0x8
 801d44c: 46bd         	mov	sp, r7
 801d44e: bd80         	pop	{r7, pc}

0801d450 <z_impl_gpio_port_set_bits_raw>:
; {
 801d450: b580         	push	{r7, lr}
 801d452: b084         	sub	sp, #0x10
 801d454: af00         	add	r7, sp, #0x0
 801d456: 6078         	str	r0, [r7, #0x4]
 801d458: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 801d45a: 687b         	ldr	r3, [r7, #0x4]
 801d45c: 689b         	ldr	r3, [r3, #0x8]
 801d45e: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_set_bits_raw(port, pins);
 801d460: 68fb         	ldr	r3, [r7, #0xc]
 801d462: 68db         	ldr	r3, [r3, #0xc]
 801d464: 6839         	ldr	r1, [r7]
 801d466: 6878         	ldr	r0, [r7, #0x4]
 801d468: 4798         	blx	r3
 801d46a: 4603         	mov	r3, r0
; }
 801d46c: 4618         	mov	r0, r3
 801d46e: 3710         	adds	r7, #0x10
 801d470: 46bd         	mov	sp, r7
 801d472: bd80         	pop	{r7, pc}

0801d474 <z_impl_gpio_port_clear_bits_raw>:
; {
 801d474: b580         	push	{r7, lr}
 801d476: b084         	sub	sp, #0x10
 801d478: af00         	add	r7, sp, #0x0
 801d47a: 6078         	str	r0, [r7, #0x4]
 801d47c: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 801d47e: 687b         	ldr	r3, [r7, #0x4]
 801d480: 689b         	ldr	r3, [r3, #0x8]
 801d482: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_clear_bits_raw(port, pins);
 801d484: 68fb         	ldr	r3, [r7, #0xc]
 801d486: 691b         	ldr	r3, [r3, #0x10]
 801d488: 6839         	ldr	r1, [r7]
 801d48a: 6878         	ldr	r0, [r7, #0x4]
 801d48c: 4798         	blx	r3
 801d48e: 4603         	mov	r3, r0
; }
 801d490: 4618         	mov	r0, r3
 801d492: 3710         	adds	r7, #0x10
 801d494: 46bd         	mov	sp, r7
 801d496: bd80         	pop	{r7, pc}

0801d498 <gpio_pin_set_raw>:
; {
 801d498: b580         	push	{r7, lr}
 801d49a: b086         	sub	sp, #0x18
 801d49c: af00         	add	r7, sp, #0x0
 801d49e: 60f8         	str	r0, [r7, #0xc]
 801d4a0: 460b         	mov	r3, r1
 801d4a2: 607a         	str	r2, [r7, #0x4]
 801d4a4: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 801d4a6: 68fb         	ldr	r3, [r7, #0xc]
 801d4a8: 685b         	ldr	r3, [r3, #0x4]
 801d4aa: 613b         	str	r3, [r7, #0x10]
; 	if (value != 0)	{
 801d4ac: 687b         	ldr	r3, [r7, #0x4]
 801d4ae: 2b00         	cmp	r3, #0x0
 801d4b0: d009         	beq	0x801d4c6 <gpio_pin_set_raw+0x2e> @ imm = #0x12
; 		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 801d4b2: 7afb         	ldrb	r3, [r7, #0xb]
 801d4b4: 2201         	movs	r2, #0x1
 801d4b6: fa02 f303    	lsl.w	r3, r2, r3
 801d4ba: 4619         	mov	r1, r3
 801d4bc: 68f8         	ldr	r0, [r7, #0xc]
 801d4be: f000 f85c    	bl	0x801d57a <gpio_port_set_bits_raw> @ imm = #0xb8
 801d4c2: 6178         	str	r0, [r7, #0x14]
 801d4c4: e008         	b	0x801d4d8 <gpio_pin_set_raw+0x40> @ imm = #0x10
; 		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 801d4c6: 7afb         	ldrb	r3, [r7, #0xb]
 801d4c8: 2201         	movs	r2, #0x1
 801d4ca: fa02 f303    	lsl.w	r3, r2, r3
 801d4ce: 4619         	mov	r1, r3
 801d4d0: 68f8         	ldr	r0, [r7, #0xc]
 801d4d2: f000 f860    	bl	0x801d596 <gpio_port_clear_bits_raw> @ imm = #0xc0
 801d4d6: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 801d4d8: 697b         	ldr	r3, [r7, #0x14]
; }
 801d4da: 4618         	mov	r0, r3
 801d4dc: 3718         	adds	r7, #0x18
 801d4de: 46bd         	mov	sp, r7
 801d4e0: bd80         	pop	{r7, pc}

0801d4e2 <gpio_pin_set>:
; {
 801d4e2: b580         	push	{r7, lr}
 801d4e4: b086         	sub	sp, #0x18
 801d4e6: af00         	add	r7, sp, #0x0
 801d4e8: 60f8         	str	r0, [r7, #0xc]
 801d4ea: 460b         	mov	r3, r1
 801d4ec: 607a         	str	r2, [r7, #0x4]
 801d4ee: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 801d4f0: 68fb         	ldr	r3, [r7, #0xc]
 801d4f2: 685b         	ldr	r3, [r3, #0x4]
 801d4f4: 617b         	str	r3, [r7, #0x14]
; 	const struct gpio_driver_data *const data =
 801d4f6: 68fb         	ldr	r3, [r7, #0xc]
 801d4f8: 691b         	ldr	r3, [r3, #0x10]
 801d4fa: 613b         	str	r3, [r7, #0x10]
; 	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
 801d4fc: 693b         	ldr	r3, [r7, #0x10]
 801d4fe: 681a         	ldr	r2, [r3]
 801d500: 7afb         	ldrb	r3, [r7, #0xb]
 801d502: 2101         	movs	r1, #0x1
 801d504: fa01 f303    	lsl.w	r3, r1, r3
 801d508: 4013         	ands	r3, r2
 801d50a: 2b00         	cmp	r3, #0x0
 801d50c: d006         	beq	0x801d51c <gpio_pin_set+0x3a> @ imm = #0xc
; 		value = (value != 0) ? 0 : 1;
 801d50e: 687b         	ldr	r3, [r7, #0x4]
 801d510: 2b00         	cmp	r3, #0x0
 801d512: bf0c         	ite	eq
 801d514: 2301         	moveq	r3, #0x1
 801d516: 2300         	movne	r3, #0x0
 801d518: b2db         	uxtb	r3, r3
 801d51a: 607b         	str	r3, [r7, #0x4]
; 	return gpio_pin_set_raw(port, pin, value);
 801d51c: 7afb         	ldrb	r3, [r7, #0xb]
 801d51e: 687a         	ldr	r2, [r7, #0x4]
 801d520: 4619         	mov	r1, r3
 801d522: 68f8         	ldr	r0, [r7, #0xc]
 801d524: f7ff ffb8    	bl	0x801d498 <gpio_pin_set_raw> @ imm = #-0x90
 801d528: 4603         	mov	r3, r0
; }
 801d52a: 4618         	mov	r0, r3
 801d52c: 3718         	adds	r7, #0x18
 801d52e: 46bd         	mov	sp, r7
 801d530: bd80         	pop	{r7, pc}

0801d532 <gpio_pin_set_dt>:
; {
 801d532: b580         	push	{r7, lr}
 801d534: b082         	sub	sp, #0x8
 801d536: af00         	add	r7, sp, #0x0
 801d538: 6078         	str	r0, [r7, #0x4]
 801d53a: 6039         	str	r1, [r7]
; 	return gpio_pin_set(spec->port, spec->pin, value);
 801d53c: 687b         	ldr	r3, [r7, #0x4]
 801d53e: 6818         	ldr	r0, [r3]
 801d540: 687b         	ldr	r3, [r7, #0x4]
 801d542: 791b         	ldrb	r3, [r3, #0x4]
 801d544: 683a         	ldr	r2, [r7]
 801d546: 4619         	mov	r1, r3
 801d548: f7ff ffcb    	bl	0x801d4e2 <gpio_pin_set> @ imm = #-0x6a
 801d54c: 4603         	mov	r3, r0
; }
 801d54e: 4618         	mov	r0, r3
 801d550: 3708         	adds	r7, #0x8
 801d552: 46bd         	mov	sp, r7
 801d554: bd80         	pop	{r7, pc}

0801d556 <gpio_pin_configure>:
; {
 801d556: b580         	push	{r7, lr}
 801d558: b084         	sub	sp, #0x10
 801d55a: af00         	add	r7, sp, #0x0
 801d55c: 60f8         	str	r0, [r7, #0xc]
 801d55e: 460b         	mov	r3, r1
 801d560: 607a         	str	r2, [r7, #0x4]
 801d562: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 801d564: 7afb         	ldrb	r3, [r7, #0xb]
 801d566: 687a         	ldr	r2, [r7, #0x4]
 801d568: 4619         	mov	r1, r3
 801d56a: 68f8         	ldr	r0, [r7, #0xc]
 801d56c: f7ff ff0f    	bl	0x801d38e <z_impl_gpio_pin_configure> @ imm = #-0x1e2
 801d570: 4603         	mov	r3, r0
; }
 801d572: 4618         	mov	r0, r3
 801d574: 3710         	adds	r7, #0x10
 801d576: 46bd         	mov	sp, r7
 801d578: bd80         	pop	{r7, pc}

0801d57a <gpio_port_set_bits_raw>:
; {
 801d57a: b580         	push	{r7, lr}
 801d57c: b082         	sub	sp, #0x8
 801d57e: af00         	add	r7, sp, #0x0
 801d580: 6078         	str	r0, [r7, #0x4]
 801d582: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_set_bits_raw(port, pins);
 801d584: 6839         	ldr	r1, [r7]
 801d586: 6878         	ldr	r0, [r7, #0x4]
 801d588: f7ff ff62    	bl	0x801d450 <z_impl_gpio_port_set_bits_raw> @ imm = #-0x13c
 801d58c: 4603         	mov	r3, r0
; }
 801d58e: 4618         	mov	r0, r3
 801d590: 3708         	adds	r7, #0x8
 801d592: 46bd         	mov	sp, r7
 801d594: bd80         	pop	{r7, pc}

0801d596 <gpio_port_clear_bits_raw>:
; {
 801d596: b580         	push	{r7, lr}
 801d598: b082         	sub	sp, #0x8
 801d59a: af00         	add	r7, sp, #0x0
 801d59c: 6078         	str	r0, [r7, #0x4]
 801d59e: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_clear_bits_raw(port, pins);
 801d5a0: 6839         	ldr	r1, [r7]
 801d5a2: 6878         	ldr	r0, [r7, #0x4]
 801d5a4: f7ff ff66    	bl	0x801d474 <z_impl_gpio_port_clear_bits_raw> @ imm = #-0x134
 801d5a8: 4603         	mov	r3, r0
; }
 801d5aa: 4618         	mov	r0, r3
 801d5ac: 3708         	adds	r7, #0x8
 801d5ae: 46bd         	mov	sp, r7
 801d5b0: bd80         	pop	{r7, pc}

0801d5b2 <spi_cs_is_gpio>:
; {
 801d5b2: b480         	push	{r7}
 801d5b4: b083         	sub	sp, #0xc
 801d5b6: af00         	add	r7, sp, #0x0
 801d5b8: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 801d5ba: 687b         	ldr	r3, [r7, #0x4]
 801d5bc: 689b         	ldr	r3, [r3, #0x8]
 801d5be: 2b00         	cmp	r3, #0x0
 801d5c0: bf14         	ite	ne
 801d5c2: 2301         	movne	r3, #0x1
 801d5c4: 2300         	moveq	r3, #0x0
 801d5c6: b2db         	uxtb	r3, r3
; }
 801d5c8: 4618         	mov	r0, r3
 801d5ca: 370c         	adds	r7, #0xc
 801d5cc: 46bd         	mov	sp, r7
 801d5ce: f85d 7b04    	ldr	r7, [sp], #4
 801d5d2: 4770         	bx	lr

0801d5d4 <pinctrl_apply_state_direct>:
; {
 801d5d4: b580         	push	{r7, lr}
 801d5d6: b084         	sub	sp, #0x10
 801d5d8: af00         	add	r7, sp, #0x0
 801d5da: 6078         	str	r0, [r7, #0x4]
 801d5dc: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 801d5de: 2300         	movs	r3, #0x0
 801d5e0: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 801d5e2: 683b         	ldr	r3, [r7]
 801d5e4: 6818         	ldr	r0, [r3]
 801d5e6: 683b         	ldr	r3, [r7]
 801d5e8: 791b         	ldrb	r3, [r3, #0x4]
 801d5ea: 68fa         	ldr	r2, [r7, #0xc]
 801d5ec: 4619         	mov	r1, r3
 801d5ee: f7fc fc91    	bl	0x8019f14 <pinctrl_configure_pins> @ imm = #-0x36de
 801d5f2: 4603         	mov	r3, r0
; }
 801d5f4: 4618         	mov	r0, r3
 801d5f6: 3710         	adds	r7, #0x10
 801d5f8: 46bd         	mov	sp, r7
 801d5fa: bd80         	pop	{r7, pc}

0801d5fc <pinctrl_apply_state>:
; {
 801d5fc: b580         	push	{r7, lr}
 801d5fe: b084         	sub	sp, #0x10
 801d600: af00         	add	r7, sp, #0x0
 801d602: 6078         	str	r0, [r7, #0x4]
 801d604: 460b         	mov	r3, r1
 801d606: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 801d608: f107 0208    	add.w	r2, r7, #0x8
 801d60c: 78fb         	ldrb	r3, [r7, #0x3]
 801d60e: 4619         	mov	r1, r3
 801d610: 6878         	ldr	r0, [r7, #0x4]
 801d612: f7fc fc47    	bl	0x8019ea4 <pinctrl_lookup_state> @ imm = #-0x3772
 801d616: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 801d618: 68fb         	ldr	r3, [r7, #0xc]
 801d61a: 2b00         	cmp	r3, #0x0
 801d61c: da01         	bge	0x801d622 <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 801d61e: 68fb         	ldr	r3, [r7, #0xc]
 801d620: e005         	b	0x801d62e <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 801d622: 68bb         	ldr	r3, [r7, #0x8]
 801d624: 4619         	mov	r1, r3
 801d626: 6878         	ldr	r0, [r7, #0x4]
 801d628: f7ff ffd4    	bl	0x801d5d4 <pinctrl_apply_state_direct> @ imm = #-0x58
 801d62c: 4603         	mov	r3, r0
; }
 801d62e: 4618         	mov	r0, r3
 801d630: 3710         	adds	r7, #0x10
 801d632: 46bd         	mov	sp, r7
 801d634: bd80         	pop	{r7, pc}

0801d636 <pm_device_runtime_enable>:
; {
 801d636: b480         	push	{r7}
 801d638: b083         	sub	sp, #0xc
 801d63a: af00         	add	r7, sp, #0x0
 801d63c: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801d63e: 2300         	movs	r3, #0x0
; }
 801d640: 4618         	mov	r0, r3
 801d642: 370c         	adds	r7, #0xc
 801d644: 46bd         	mov	sp, r7
 801d646: f85d 7b04    	ldr	r7, [sp], #4
 801d64a: 4770         	bx	lr

0801d64c <clock_control_on>:
; {
 801d64c: b580         	push	{r7, lr}
 801d64e: b084         	sub	sp, #0x10
 801d650: af00         	add	r7, sp, #0x0
 801d652: 6078         	str	r0, [r7, #0x4]
 801d654: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801d656: 687b         	ldr	r3, [r7, #0x4]
 801d658: 689b         	ldr	r3, [r3, #0x8]
 801d65a: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 801d65c: 68fb         	ldr	r3, [r7, #0xc]
 801d65e: 681b         	ldr	r3, [r3]
 801d660: 6839         	ldr	r1, [r7]
 801d662: 6878         	ldr	r0, [r7, #0x4]
 801d664: 4798         	blx	r3
 801d666: 4603         	mov	r3, r0
; }
 801d668: 4618         	mov	r0, r3
 801d66a: 3710         	adds	r7, #0x10
 801d66c: 46bd         	mov	sp, r7
 801d66e: bd80         	pop	{r7, pc}

0801d670 <clock_control_get_rate>:
; {
 801d670: b580         	push	{r7, lr}
 801d672: b086         	sub	sp, #0x18
 801d674: af00         	add	r7, sp, #0x0
 801d676: 60f8         	str	r0, [r7, #0xc]
 801d678: 60b9         	str	r1, [r7, #0x8]
 801d67a: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 801d67c: 68fb         	ldr	r3, [r7, #0xc]
 801d67e: 689b         	ldr	r3, [r3, #0x8]
 801d680: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 801d682: 697b         	ldr	r3, [r7, #0x14]
 801d684: 68db         	ldr	r3, [r3, #0xc]
 801d686: 2b00         	cmp	r3, #0x0
 801d688: d102         	bne	0x801d690 <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 801d68a: f06f 0357    	mvn	r3, #0x57
 801d68e: e006         	b	0x801d69e <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 801d690: 697b         	ldr	r3, [r7, #0x14]
 801d692: 68db         	ldr	r3, [r3, #0xc]
 801d694: 687a         	ldr	r2, [r7, #0x4]
 801d696: 68b9         	ldr	r1, [r7, #0x8]
 801d698: 68f8         	ldr	r0, [r7, #0xc]
 801d69a: 4798         	blx	r3
 801d69c: 4603         	mov	r3, r0
; }
 801d69e: 4618         	mov	r0, r3
 801d6a0: 3718         	adds	r7, #0x18
 801d6a2: 46bd         	mov	sp, r7
 801d6a4: bd80         	pop	{r7, pc}

0801d6a6 <spi_context_configured>:
; {
 801d6a6: b480         	push	{r7}
 801d6a8: b083         	sub	sp, #0xc
 801d6aa: af00         	add	r7, sp, #0x0
 801d6ac: 6078         	str	r0, [r7, #0x4]
 801d6ae: 6039         	str	r1, [r7]
; 	return !!(ctx->config == config);
 801d6b0: 687b         	ldr	r3, [r7, #0x4]
 801d6b2: 681b         	ldr	r3, [r3]
 801d6b4: 683a         	ldr	r2, [r7]
 801d6b6: 429a         	cmp	r2, r3
 801d6b8: bf0c         	ite	eq
 801d6ba: 2301         	moveq	r3, #0x1
 801d6bc: 2300         	movne	r3, #0x0
 801d6be: b2db         	uxtb	r3, r3
; }
 801d6c0: 4618         	mov	r0, r3
 801d6c2: 370c         	adds	r7, #0xc
 801d6c4: 46bd         	mov	sp, r7
 801d6c6: f85d 7b04    	ldr	r7, [sp], #4
 801d6ca: 4770         	bx	lr

0801d6cc <spi_context_lock>:
; {
 801d6cc: b580         	push	{r7, lr}
 801d6ce: b084         	sub	sp, #0x10
 801d6d0: af00         	add	r7, sp, #0x0
 801d6d2: 60f8         	str	r0, [r7, #0xc]
 801d6d4: 607a         	str	r2, [r7, #0x4]
 801d6d6: 603b         	str	r3, [r7]
 801d6d8: 460b         	mov	r3, r1
 801d6da: 72fb         	strb	r3, [r7, #0xb]
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 801d6dc: 69bb         	ldr	r3, [r7, #0x18]
 801d6de: 889b         	ldrh	r3, [r3, #0x4]
 801d6e0: f403 5300    	and	r3, r3, #0x2000
 801d6e4: 2b00         	cmp	r3, #0x0
 801d6e6: d00d         	beq	0x801d704 <spi_context_lock+0x38> @ imm = #0x1a
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 801d6e8: 68fb         	ldr	r3, [r7, #0xc]
 801d6ea: 3310         	adds	r3, #0x10
 801d6ec: 4618         	mov	r0, r3
 801d6ee: f7ff fc69    	bl	0x801cfc4 <k_sem_count_get> @ imm = #-0x72e
 801d6f2: 4603         	mov	r3, r0
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 801d6f4: 2b00         	cmp	r3, #0x0
 801d6f6: d105         	bne	0x801d704 <spi_context_lock+0x38> @ imm = #0xa
; 		(ctx->owner == spi_cfg)) {
 801d6f8: 68fb         	ldr	r3, [r7, #0xc]
 801d6fa: 685b         	ldr	r3, [r3, #0x4]
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 801d6fc: 69ba         	ldr	r2, [r7, #0x18]
 801d6fe: 429a         	cmp	r2, r3
 801d700: d100         	bne	0x801d704 <spi_context_lock+0x38> @ imm = #0x0
 801d702: e00c         	b	0x801d71e <spi_context_lock+0x52> @ imm = #0x18
; 	k_sem_take(&ctx->lock, K_FOREVER);
 801d704: 68fb         	ldr	r3, [r7, #0xc]
 801d706: f103 0110    	add.w	r1, r3, #0x10
 801d70a: f04f 32ff    	mov.w	r2, #0xffffffff
 801d70e: f04f 33ff    	mov.w	r3, #0xffffffff
 801d712: 4608         	mov	r0, r1
 801d714: f7ff fc3b    	bl	0x801cf8e <k_sem_take>  @ imm = #-0x78a
; 	ctx->owner = spi_cfg;
 801d718: 68fb         	ldr	r3, [r7, #0xc]
 801d71a: 69ba         	ldr	r2, [r7, #0x18]
 801d71c: 605a         	str	r2, [r3, #0x4]
; }
 801d71e: 3710         	adds	r7, #0x10
 801d720: 46bd         	mov	sp, r7
 801d722: bd80         	pop	{r7, pc}

0801d724 <spi_context_release>:
; {
 801d724: b580         	push	{r7, lr}
 801d726: b082         	sub	sp, #0x8
 801d728: af00         	add	r7, sp, #0x0
 801d72a: 6078         	str	r0, [r7, #0x4]
 801d72c: 6039         	str	r1, [r7]
; 	if (!(ctx->config->operation & SPI_LOCK_ON)) {
 801d72e: 687b         	ldr	r3, [r7, #0x4]
 801d730: 681b         	ldr	r3, [r3]
 801d732: 889b         	ldrh	r3, [r3, #0x4]
 801d734: f403 5300    	and	r3, r3, #0x2000
 801d738: 2b00         	cmp	r3, #0x0
 801d73a: d107         	bne	0x801d74c <spi_context_release+0x28> @ imm = #0xe
; 		ctx->owner = NULL;
 801d73c: 687b         	ldr	r3, [r7, #0x4]
 801d73e: 2200         	movs	r2, #0x0
 801d740: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 801d742: 687b         	ldr	r3, [r7, #0x4]
 801d744: 3310         	adds	r3, #0x10
 801d746: 4618         	mov	r0, r3
 801d748: f7ff fc31    	bl	0x801cfae <k_sem_give>  @ imm = #-0x79e
; }
 801d74c: bf00         	nop
 801d74e: 3708         	adds	r7, #0x8
 801d750: 46bd         	mov	sp, r7
 801d752: bd80         	pop	{r7, pc}

0801d754 <_spi_context_cs_control>:
; {
 801d754: b580         	push	{r7, lr}
 801d756: b082         	sub	sp, #0x8
 801d758: af00         	add	r7, sp, #0x0
 801d75a: 6078         	str	r0, [r7, #0x4]
 801d75c: 460b         	mov	r3, r1
 801d75e: 70fb         	strb	r3, [r7, #0x3]
 801d760: 4613         	mov	r3, r2
 801d762: 70bb         	strb	r3, [r7, #0x2]
; 	if (ctx->config && spi_cs_is_gpio(ctx->config)) {
 801d764: 687b         	ldr	r3, [r7, #0x4]
 801d766: 681b         	ldr	r3, [r3]
 801d768: 2b00         	cmp	r3, #0x0
 801d76a: d034         	beq	0x801d7d6 <_spi_context_cs_control+0x82> @ imm = #0x68
 801d76c: 687b         	ldr	r3, [r7, #0x4]
 801d76e: 681b         	ldr	r3, [r3]
 801d770: 4618         	mov	r0, r3
 801d772: f7ff ff1e    	bl	0x801d5b2 <spi_cs_is_gpio> @ imm = #-0x1c4
 801d776: 4603         	mov	r3, r0
 801d778: 2b00         	cmp	r3, #0x0
 801d77a: d02c         	beq	0x801d7d6 <_spi_context_cs_control+0x82> @ imm = #0x58
; 		if (on) {
 801d77c: 78fb         	ldrb	r3, [r7, #0x3]
 801d77e: 2b00         	cmp	r3, #0x0
 801d780: d00d         	beq	0x801d79e <_spi_context_cs_control+0x4a> @ imm = #0x1a
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 1);
 801d782: 687b         	ldr	r3, [r7, #0x4]
 801d784: 681b         	ldr	r3, [r3]
 801d786: 3308         	adds	r3, #0x8
 801d788: 2101         	movs	r1, #0x1
 801d78a: 4618         	mov	r0, r3
 801d78c: f7ff fed1    	bl	0x801d532 <gpio_pin_set_dt> @ imm = #-0x25e
; 			k_busy_wait(ctx->config->cs.delay);
 801d790: 687b         	ldr	r3, [r7, #0x4]
 801d792: 681b         	ldr	r3, [r3]
 801d794: 691b         	ldr	r3, [r3, #0x10]
 801d796: 4618         	mov	r0, r3
 801d798: f7ff fbee    	bl	0x801cf78 <k_busy_wait> @ imm = #-0x824
 801d79c: e01b         	b	0x801d7d6 <_spi_context_cs_control+0x82> @ imm = #0x36
; 			if (!force_off &&
 801d79e: 78bb         	ldrb	r3, [r7, #0x2]
 801d7a0: f083 0301    	eor	r3, r3, #0x1
 801d7a4: b2db         	uxtb	r3, r3
 801d7a6: 2b00         	cmp	r3, #0x0
 801d7a8: d006         	beq	0x801d7b8 <_spi_context_cs_control+0x64> @ imm = #0xc
; 			    ctx->config->operation & SPI_HOLD_ON_CS) {
 801d7aa: 687b         	ldr	r3, [r7, #0x4]
 801d7ac: 681b         	ldr	r3, [r3]
 801d7ae: 889b         	ldrh	r3, [r3, #0x4]
 801d7b0: f403 5380    	and	r3, r3, #0x1000
; 			if (!force_off &&
 801d7b4: 2b00         	cmp	r3, #0x0
 801d7b6: d10d         	bne	0x801d7d4 <_spi_context_cs_control+0x80> @ imm = #0x1a
; 			k_busy_wait(ctx->config->cs.delay);
 801d7b8: 687b         	ldr	r3, [r7, #0x4]
 801d7ba: 681b         	ldr	r3, [r3]
 801d7bc: 691b         	ldr	r3, [r3, #0x10]
 801d7be: 4618         	mov	r0, r3
 801d7c0: f7ff fbda    	bl	0x801cf78 <k_busy_wait> @ imm = #-0x84c
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 0);
 801d7c4: 687b         	ldr	r3, [r7, #0x4]
 801d7c6: 681b         	ldr	r3, [r3]
 801d7c8: 3308         	adds	r3, #0x8
 801d7ca: 2100         	movs	r1, #0x0
 801d7cc: 4618         	mov	r0, r3
 801d7ce: f7ff feb0    	bl	0x801d532 <gpio_pin_set_dt> @ imm = #-0x2a0
 801d7d2: e000         	b	0x801d7d6 <_spi_context_cs_control+0x82> @ imm = #0x0
; 				return;
 801d7d4: bf00         	nop
; }
 801d7d6: 3708         	adds	r7, #0x8
 801d7d8: 46bd         	mov	sp, r7
 801d7da: bd80         	pop	{r7, pc}

0801d7dc <spi_context_cs_control>:
; {
 801d7dc: b580         	push	{r7, lr}
 801d7de: b082         	sub	sp, #0x8
 801d7e0: af00         	add	r7, sp, #0x0
 801d7e2: 6078         	str	r0, [r7, #0x4]
 801d7e4: 460b         	mov	r3, r1
 801d7e6: 70fb         	strb	r3, [r7, #0x3]
; 	_spi_context_cs_control(ctx, on, false);
 801d7e8: 78fb         	ldrb	r3, [r7, #0x3]
 801d7ea: 2200         	movs	r2, #0x0
 801d7ec: 4619         	mov	r1, r3
 801d7ee: 6878         	ldr	r0, [r7, #0x4]
 801d7f0: f7ff ffb0    	bl	0x801d754 <_spi_context_cs_control> @ imm = #-0xa0
; }
 801d7f4: bf00         	nop
 801d7f6: 3708         	adds	r7, #0x8
 801d7f8: 46bd         	mov	sp, r7
 801d7fa: bd80         	pop	{r7, pc}

0801d7fc <spi_context_unlock_unconditionally>:
; {
 801d7fc: b580         	push	{r7, lr}
 801d7fe: b082         	sub	sp, #0x8
 801d800: af00         	add	r7, sp, #0x0
 801d802: 6078         	str	r0, [r7, #0x4]
; 	_spi_context_cs_control(ctx, false, true);
 801d804: 2201         	movs	r2, #0x1
 801d806: 2100         	movs	r1, #0x0
 801d808: 6878         	ldr	r0, [r7, #0x4]
 801d80a: f7ff ffa3    	bl	0x801d754 <_spi_context_cs_control> @ imm = #-0xba
; 	if (!k_sem_count_get(&ctx->lock)) {
 801d80e: 687b         	ldr	r3, [r7, #0x4]
 801d810: 3310         	adds	r3, #0x10
 801d812: 4618         	mov	r0, r3
 801d814: f7ff fbd6    	bl	0x801cfc4 <k_sem_count_get> @ imm = #-0x854
 801d818: 4603         	mov	r3, r0
 801d81a: 2b00         	cmp	r3, #0x0
 801d81c: d107         	bne	0x801d82e <spi_context_unlock_unconditionally+0x32> @ imm = #0xe
; 		ctx->owner = NULL;
 801d81e: 687b         	ldr	r3, [r7, #0x4]
 801d820: 2200         	movs	r2, #0x0
 801d822: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 801d824: 687b         	ldr	r3, [r7, #0x4]
 801d826: 3310         	adds	r3, #0x10
 801d828: 4618         	mov	r0, r3
 801d82a: f7ff fbc0    	bl	0x801cfae <k_sem_give>  @ imm = #-0x880
; }
 801d82e: bf00         	nop
 801d830: 3708         	adds	r7, #0x8
 801d832: 46bd         	mov	sp, r7
 801d834: bd80         	pop	{r7, pc}

0801d836 <spi_context_get_next_buf>:
; {
 801d836: b480         	push	{r7}
 801d838: b085         	sub	sp, #0x14
 801d83a: af00         	add	r7, sp, #0x0
 801d83c: 60f8         	str	r0, [r7, #0xc]
 801d83e: 60b9         	str	r1, [r7, #0x8]
 801d840: 607a         	str	r2, [r7, #0x4]
 801d842: 70fb         	strb	r3, [r7, #0x3]
; 	while (*count) {
 801d844: e01c         	b	0x801d880 <spi_context_get_next_buf+0x4a> @ imm = #0x38
; 		if (((*current)->len / dfs) != 0) {
 801d846: 68fb         	ldr	r3, [r7, #0xc]
 801d848: 681b         	ldr	r3, [r3]
 801d84a: 685a         	ldr	r2, [r3, #0x4]
 801d84c: 78fb         	ldrb	r3, [r7, #0x3]
 801d84e: 429a         	cmp	r2, r3
 801d850: d30b         	blo	0x801d86a <spi_context_get_next_buf+0x34> @ imm = #0x16
; 			*buf_len = (*current)->len / dfs;
 801d852: 68fb         	ldr	r3, [r7, #0xc]
 801d854: 681b         	ldr	r3, [r3]
 801d856: 685a         	ldr	r2, [r3, #0x4]
 801d858: 78fb         	ldrb	r3, [r7, #0x3]
 801d85a: fbb2 f2f3    	udiv	r2, r2, r3
 801d85e: 687b         	ldr	r3, [r7, #0x4]
 801d860: 601a         	str	r2, [r3]
; 			return (*current)->buf;
 801d862: 68fb         	ldr	r3, [r7, #0xc]
 801d864: 681b         	ldr	r3, [r3]
 801d866: 681b         	ldr	r3, [r3]
 801d868: e012         	b	0x801d890 <spi_context_get_next_buf+0x5a> @ imm = #0x24
; 		++(*current);
 801d86a: 68fb         	ldr	r3, [r7, #0xc]
 801d86c: 681b         	ldr	r3, [r3]
 801d86e: f103 0208    	add.w	r2, r3, #0x8
 801d872: 68fb         	ldr	r3, [r7, #0xc]
 801d874: 601a         	str	r2, [r3]
; 		--(*count);
 801d876: 68bb         	ldr	r3, [r7, #0x8]
 801d878: 681b         	ldr	r3, [r3]
 801d87a: 1e5a         	subs	r2, r3, #0x1
 801d87c: 68bb         	ldr	r3, [r7, #0x8]
 801d87e: 601a         	str	r2, [r3]
; 	while (*count) {
 801d880: 68bb         	ldr	r3, [r7, #0x8]
 801d882: 681b         	ldr	r3, [r3]
 801d884: 2b00         	cmp	r3, #0x0
 801d886: d1de         	bne	0x801d846 <spi_context_get_next_buf+0x10> @ imm = #-0x44
; 	*buf_len = 0;
 801d888: 687b         	ldr	r3, [r7, #0x4]
 801d88a: 2200         	movs	r2, #0x0
 801d88c: 601a         	str	r2, [r3]
; 	return NULL;
 801d88e: 2300         	movs	r3, #0x0
; }
 801d890: 4618         	mov	r0, r3
 801d892: 3714         	adds	r7, #0x14
 801d894: 46bd         	mov	sp, r7
 801d896: f85d 7b04    	ldr	r7, [sp], #4
 801d89a: 4770         	bx	lr

0801d89c <ll_func_tx_is_not_full>:
; {
 801d89c: b580         	push	{r7, lr}
 801d89e: b082         	sub	sp, #0x8
 801d8a0: af00         	add	r7, sp, #0x0
 801d8a2: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_TXE(spi);
 801d8a4: 6878         	ldr	r0, [r7, #0x4]
 801d8a6: f7ff fcb1    	bl	0x801d20c <LL_SPI_IsActiveFlag_TXE> @ imm = #-0x69e
 801d8aa: 4603         	mov	r3, r0
; }
 801d8ac: 4618         	mov	r0, r3
 801d8ae: 3708         	adds	r7, #0x8
 801d8b0: 46bd         	mov	sp, r7
 801d8b2: bd80         	pop	{r7, pc}

0801d8b4 <ll_func_rx_is_not_empty>:
; {
 801d8b4: b580         	push	{r7, lr}
 801d8b6: b082         	sub	sp, #0x8
 801d8b8: af00         	add	r7, sp, #0x0
 801d8ba: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_RXNE(spi);
 801d8bc: 6878         	ldr	r0, [r7, #0x4]
 801d8be: f7ff fc92    	bl	0x801d1e6 <LL_SPI_IsActiveFlag_RXNE> @ imm = #-0x6dc
 801d8c2: 4603         	mov	r3, r0
; }
 801d8c4: 4618         	mov	r0, r3
 801d8c6: 3708         	adds	r7, #0x8
 801d8c8: 46bd         	mov	sp, r7
 801d8ca: bd80         	pop	{r7, pc}

0801d8cc <ll_func_disable_int_tx_empty>:
; {
 801d8cc: b580         	push	{r7, lr}
 801d8ce: b082         	sub	sp, #0x8
 801d8d0: af00         	add	r7, sp, #0x0
 801d8d2: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_DisableIT_TXE(spi);
 801d8d4: 6878         	ldr	r0, [r7, #0x4]
 801d8d6: f7ff fd0b    	bl	0x801d2f0 <LL_SPI_DisableIT_TXE> @ imm = #-0x5ea
; }
 801d8da: bf00         	nop
 801d8dc: 3708         	adds	r7, #0x8
 801d8de: 46bd         	mov	sp, r7
 801d8e0: bd80         	pop	{r7, pc}

0801d8e2 <ll_func_spi_is_busy>:
; {
 801d8e2: b580         	push	{r7, lr}
 801d8e4: b082         	sub	sp, #0x8
 801d8e6: af00         	add	r7, sp, #0x0
 801d8e8: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_BSY(spi);
 801d8ea: 6878         	ldr	r0, [r7, #0x4]
 801d8ec: f7ff fcc7    	bl	0x801d27e <LL_SPI_IsActiveFlag_BSY> @ imm = #-0x672
 801d8f0: 4603         	mov	r3, r0
; }
 801d8f2: 4618         	mov	r0, r3
 801d8f4: 3708         	adds	r7, #0x8
 801d8f6: 46bd         	mov	sp, r7
 801d8f8: bd80         	pop	{r7, pc}

0801d8fa <ll_func_disable_spi>:
; {
 801d8fa: b580         	push	{r7, lr}
 801d8fc: b082         	sub	sp, #0x8
 801d8fe: af00         	add	r7, sp, #0x0
 801d900: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_Disable(spi);
 801d902: 6878         	ldr	r0, [r7, #0x4]
 801d904: f7ff fb7a    	bl	0x801cffc <LL_SPI_Disable> @ imm = #-0x90c
; 	while (LL_SPI_IsEnabled(spi)) {
 801d908: bf00         	nop
 801d90a: 6878         	ldr	r0, [r7, #0x4]
 801d90c: f7ff fb86    	bl	0x801d01c <LL_SPI_IsEnabled> @ imm = #-0x8f4
 801d910: 4603         	mov	r3, r0
 801d912: 2b00         	cmp	r3, #0x0
 801d914: d1f9         	bne	0x801d90a <ll_func_disable_spi+0x10> @ imm = #-0xe
; }
 801d916: bf00         	nop
 801d918: bf00         	nop
 801d91a: 3708         	adds	r7, #0x8
 801d91c: 46bd         	mov	sp, r7
 801d91e: bd80         	pop	{r7, pc}

0801d920 <spi_stm32_pm_policy_state_lock_get>:
; {
 801d920: b480         	push	{r7}
 801d922: b083         	sub	sp, #0xc
 801d924: af00         	add	r7, sp, #0x0
 801d926: 6078         	str	r0, [r7, #0x4]
; }
 801d928: bf00         	nop
 801d92a: 370c         	adds	r7, #0xc
 801d92c: 46bd         	mov	sp, r7
 801d92e: f85d 7b04    	ldr	r7, [sp], #4
 801d932: 4770         	bx	lr

0801d934 <spi_stm32_pm_policy_state_lock_put>:
; {
 801d934: b480         	push	{r7}
 801d936: b083         	sub	sp, #0xc
 801d938: af00         	add	r7, sp, #0x0
 801d93a: 6078         	str	r0, [r7, #0x4]
; }
 801d93c: bf00         	nop
 801d93e: 370c         	adds	r7, #0xc
 801d940: 46bd         	mov	sp, r7
 801d942: f85d 7b04    	ldr	r7, [sp], #4
 801d946: 4770         	bx	lr

0801d948 <spi_stm32_transfer_ongoing>:
; {
 801d948: b480         	push	{r7}
 801d94a: b085         	sub	sp, #0x14
 801d94c: af00         	add	r7, sp, #0x0
 801d94e: 6078         	str	r0, [r7, #0x4]
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 801d950: 687b         	ldr	r3, [r7, #0x4]
 801d952: 60fb         	str	r3, [r7, #0xc]
; 	return !!(ctx->tx_len);
 801d954: 68fb         	ldr	r3, [r7, #0xc]
 801d956: 6c9b         	ldr	r3, [r3, #0x48]
 801d958: 2b00         	cmp	r3, #0x0
 801d95a: bf14         	ite	ne
 801d95c: 2301         	movne	r3, #0x1
 801d95e: 2300         	moveq	r3, #0x0
 801d960: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 801d962: 2b00         	cmp	r3, #0x0
 801d964: d10a         	bne	0x801d97c <spi_stm32_transfer_ongoing+0x34> @ imm = #0x14
 801d966: 687b         	ldr	r3, [r7, #0x4]
 801d968: 60bb         	str	r3, [r7, #0x8]
; 	return !!(ctx->rx_len);
 801d96a: 68bb         	ldr	r3, [r7, #0x8]
 801d96c: 6d1b         	ldr	r3, [r3, #0x50]
 801d96e: 2b00         	cmp	r3, #0x0
 801d970: bf14         	ite	ne
 801d972: 2301         	movne	r3, #0x1
 801d974: 2300         	moveq	r3, #0x0
 801d976: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 801d978: 2b00         	cmp	r3, #0x0
 801d97a: d001         	beq	0x801d980 <spi_stm32_transfer_ongoing+0x38> @ imm = #0x2
 801d97c: 2301         	movs	r3, #0x1
 801d97e: e000         	b	0x801d982 <spi_stm32_transfer_ongoing+0x3a> @ imm = #0x0
 801d980: 2300         	movs	r3, #0x0
 801d982: f003 0301    	and	r3, r3, #0x1
 801d986: b2db         	uxtb	r3, r3
; }
 801d988: 4618         	mov	r0, r3
 801d98a: 3714         	adds	r7, #0x14
 801d98c: 46bd         	mov	sp, r7
 801d98e: f85d 7b04    	ldr	r7, [sp], #4
 801d992: 4770         	bx	lr

0801d994 <spi_stm32_shift_fifo>:
; {
 801d994: b580         	push	{r7, lr}
 801d996: b082         	sub	sp, #0x8
 801d998: af00         	add	r7, sp, #0x0
 801d99a: 6078         	str	r0, [r7, #0x4]
 801d99c: 6039         	str	r1, [r7]
; 	if (ll_func_rx_is_not_empty(spi)) {
 801d99e: 6878         	ldr	r0, [r7, #0x4]
 801d9a0: f7ff ff88    	bl	0x801d8b4 <ll_func_rx_is_not_empty> @ imm = #-0xf0
 801d9a4: 4603         	mov	r3, r0
 801d9a6: 2b00         	cmp	r3, #0x0
 801d9a8: d003         	beq	0x801d9b2 <spi_stm32_shift_fifo+0x1e> @ imm = #0x6
; 		spi_stm32_read_next_frame(spi, data);
 801d9aa: 6839         	ldr	r1, [r7]
 801d9ac: 6878         	ldr	r0, [r7, #0x4]
 801d9ae: f7ef fc93    	bl	0x800d2d8 <spi_stm32_read_next_frame> @ imm = #-0x106da
; 	if (ll_func_tx_is_not_full(spi)) {
 801d9b2: 6878         	ldr	r0, [r7, #0x4]
 801d9b4: f7ff ff72    	bl	0x801d89c <ll_func_tx_is_not_full> @ imm = #-0x11c
 801d9b8: 4603         	mov	r3, r0
 801d9ba: 2b00         	cmp	r3, #0x0
 801d9bc: d003         	beq	0x801d9c6 <spi_stm32_shift_fifo+0x32> @ imm = #0x6
; 		spi_stm32_send_next_frame(spi, data);
 801d9be: 6839         	ldr	r1, [r7]
 801d9c0: 6878         	ldr	r0, [r7, #0x4]
 801d9c2: f7ef fb1d    	bl	0x800d000 <spi_stm32_send_next_frame> @ imm = #-0x109c6
; }
 801d9c6: bf00         	nop
 801d9c8: 3708         	adds	r7, #0x8
 801d9ca: 46bd         	mov	sp, r7
 801d9cc: bd80         	pop	{r7, pc}

0801d9ce <spi_stm32_shift_m>:
; {
 801d9ce: b580         	push	{r7, lr}
 801d9d0: b082         	sub	sp, #0x8
 801d9d2: af00         	add	r7, sp, #0x0
 801d9d4: 6078         	str	r0, [r7, #0x4]
 801d9d6: 6039         	str	r1, [r7]
; 	if (cfg->fifo_enabled) {
 801d9d8: 687b         	ldr	r3, [r7, #0x4]
 801d9da: 7c1b         	ldrb	r3, [r3, #0x10]
 801d9dc: 2b00         	cmp	r3, #0x0
 801d9de: d006         	beq	0x801d9ee <spi_stm32_shift_m+0x20> @ imm = #0xc
; 		spi_stm32_shift_fifo(cfg->spi, data);
 801d9e0: 687b         	ldr	r3, [r7, #0x4]
 801d9e2: 681b         	ldr	r3, [r3]
 801d9e4: 6839         	ldr	r1, [r7]
 801d9e6: 4618         	mov	r0, r3
 801d9e8: f7ff ffd4    	bl	0x801d994 <spi_stm32_shift_fifo> @ imm = #-0x58
; }
 801d9ec: e01d         	b	0x801da2a <spi_stm32_shift_m+0x5c> @ imm = #0x3a
; 		while (!ll_func_tx_is_not_full(cfg->spi)) {
 801d9ee: bf00         	nop
 801d9f0: 687b         	ldr	r3, [r7, #0x4]
 801d9f2: 681b         	ldr	r3, [r3]
 801d9f4: 4618         	mov	r0, r3
 801d9f6: f7ff ff51    	bl	0x801d89c <ll_func_tx_is_not_full> @ imm = #-0x15e
 801d9fa: 4603         	mov	r3, r0
 801d9fc: 2b00         	cmp	r3, #0x0
 801d9fe: d0f7         	beq	0x801d9f0 <spi_stm32_shift_m+0x22> @ imm = #-0x12
; 		spi_stm32_send_next_frame(cfg->spi, data);
 801da00: 687b         	ldr	r3, [r7, #0x4]
 801da02: 681b         	ldr	r3, [r3]
 801da04: 6839         	ldr	r1, [r7]
 801da06: 4618         	mov	r0, r3
 801da08: f7ef fafa    	bl	0x800d000 <spi_stm32_send_next_frame> @ imm = #-0x10a0c
; 		while (!ll_func_rx_is_not_empty(cfg->spi)) {
 801da0c: bf00         	nop
 801da0e: 687b         	ldr	r3, [r7, #0x4]
 801da10: 681b         	ldr	r3, [r3]
 801da12: 4618         	mov	r0, r3
 801da14: f7ff ff4e    	bl	0x801d8b4 <ll_func_rx_is_not_empty> @ imm = #-0x164
 801da18: 4603         	mov	r3, r0
 801da1a: 2b00         	cmp	r3, #0x0
 801da1c: d0f7         	beq	0x801da0e <spi_stm32_shift_m+0x40> @ imm = #-0x12
; 		spi_stm32_read_next_frame(cfg->spi, data);
 801da1e: 687b         	ldr	r3, [r7, #0x4]
 801da20: 681b         	ldr	r3, [r3]
 801da22: 6839         	ldr	r1, [r7]
 801da24: 4618         	mov	r0, r3
 801da26: f7ef fc57    	bl	0x800d2d8 <spi_stm32_read_next_frame> @ imm = #-0x10752
; }
 801da2a: bf00         	nop
 801da2c: 3708         	adds	r7, #0x8
 801da2e: 46bd         	mov	sp, r7
 801da30: bd80         	pop	{r7, pc}

0801da32 <spi_stm32_shift_frames>:
; {
 801da32: b580         	push	{r7, lr}
 801da34: b084         	sub	sp, #0x10
 801da36: af00         	add	r7, sp, #0x0
 801da38: 6078         	str	r0, [r7, #0x4]
 801da3a: 6039         	str	r1, [r7]
; 	uint16_t operation = data->ctx.config->operation;
 801da3c: 683b         	ldr	r3, [r7]
 801da3e: 681b         	ldr	r3, [r3]
 801da40: 889b         	ldrh	r3, [r3, #0x4]
 801da42: 81fb         	strh	r3, [r7, #0xe]
; 	if (SPI_OP_MODE_GET(operation) == SPI_OP_MODE_MASTER) {
 801da44: 89fb         	ldrh	r3, [r7, #0xe]
 801da46: f003 0301    	and	r3, r3, #0x1
 801da4a: 2b00         	cmp	r3, #0x0
 801da4c: d104         	bne	0x801da58 <spi_stm32_shift_frames+0x26> @ imm = #0x8
; 		spi_stm32_shift_m(cfg, data);
 801da4e: 6839         	ldr	r1, [r7]
 801da50: 6878         	ldr	r0, [r7, #0x4]
 801da52: f7ff ffbc    	bl	0x801d9ce <spi_stm32_shift_m> @ imm = #-0x88
 801da56: e005         	b	0x801da64 <spi_stm32_shift_frames+0x32> @ imm = #0xa
; 		spi_stm32_shift_s(cfg->spi, data);
 801da58: 687b         	ldr	r3, [r7, #0x4]
 801da5a: 681b         	ldr	r3, [r3]
 801da5c: 6839         	ldr	r1, [r7]
 801da5e: 4618         	mov	r0, r3
 801da60: f7ef fde8    	bl	0x800d634 <spi_stm32_shift_s> @ imm = #-0x10430
; 	return spi_stm32_get_err(cfg->spi);
 801da64: 687b         	ldr	r3, [r7, #0x4]
 801da66: 681b         	ldr	r3, [r3]
 801da68: 4618         	mov	r0, r3
 801da6a: f7ef fd9f    	bl	0x800d5ac <spi_stm32_get_err> @ imm = #-0x104c2
 801da6e: 4603         	mov	r3, r0
; }
 801da70: 4618         	mov	r0, r3
 801da72: 3710         	adds	r7, #0x10
 801da74: 46bd         	mov	sp, r7
 801da76: bd80         	pop	{r7, pc}

0801da78 <spi_stm32_cs_control>:
; {
 801da78: b580         	push	{r7, lr}
 801da7a: b084         	sub	sp, #0x10
 801da7c: af00         	add	r7, sp, #0x0
 801da7e: 6078         	str	r0, [r7, #0x4]
 801da80: 460b         	mov	r3, r1
 801da82: 70fb         	strb	r3, [r7, #0x3]
; 	struct spi_stm32_data *data = dev->data;
 801da84: 687b         	ldr	r3, [r7, #0x4]
 801da86: 691b         	ldr	r3, [r3, #0x10]
 801da88: 60fb         	str	r3, [r7, #0xc]
; 	spi_context_cs_control(&data->ctx, on);
 801da8a: 68fb         	ldr	r3, [r7, #0xc]
 801da8c: 78fa         	ldrb	r2, [r7, #0x3]
 801da8e: 4611         	mov	r1, r2
 801da90: 4618         	mov	r0, r3
 801da92: f7ff fea3    	bl	0x801d7dc <spi_context_cs_control> @ imm = #-0x2ba
; }
 801da96: bf00         	nop
 801da98: 3710         	adds	r7, #0x10
 801da9a: 46bd         	mov	sp, r7
 801da9c: bd80         	pop	{r7, pc}

0801da9e <spi_stm32_complete>:
; {
 801da9e: b580         	push	{r7, lr}
 801daa0: b086         	sub	sp, #0x18
 801daa2: af00         	add	r7, sp, #0x0
 801daa4: 6078         	str	r0, [r7, #0x4]
 801daa6: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 801daa8: 687b         	ldr	r3, [r7, #0x4]
 801daaa: 685b         	ldr	r3, [r3, #0x4]
 801daac: 617b         	str	r3, [r7, #0x14]
; 	SPI_TypeDef *spi = cfg->spi;
 801daae: 697b         	ldr	r3, [r7, #0x14]
 801dab0: 681b         	ldr	r3, [r3]
 801dab2: 613b         	str	r3, [r7, #0x10]
; 	struct spi_stm32_data *data = dev->data;
 801dab4: 687b         	ldr	r3, [r7, #0x4]
 801dab6: 691b         	ldr	r3, [r3, #0x10]
 801dab8: 60fb         	str	r3, [r7, #0xc]
; 	if (LL_SPI_GetMode(spi) == LL_SPI_MODE_MASTER) {
 801daba: 6938         	ldr	r0, [r7, #0x10]
 801dabc: f7ff fad4    	bl	0x801d068 <LL_SPI_GetMode> @ imm = #-0xa58
 801dac0: 4603         	mov	r3, r0
 801dac2: f5b3 7f82    	cmp.w	r3, #0x104
 801dac6: d10a         	bne	0x801dade <spi_stm32_complete+0x40> @ imm = #0x14
; 		while (ll_func_spi_is_busy(spi)) {
 801dac8: bf00         	nop
 801daca: 6938         	ldr	r0, [r7, #0x10]
 801dacc: f7ff ff09    	bl	0x801d8e2 <ll_func_spi_is_busy> @ imm = #-0x1ee
 801dad0: 4603         	mov	r3, r0
 801dad2: 2b00         	cmp	r3, #0x0
 801dad4: d1f9         	bne	0x801daca <spi_stm32_complete+0x2c> @ imm = #-0xe
; 		spi_stm32_cs_control(dev, false);
 801dad6: 2100         	movs	r1, #0x0
 801dad8: 6878         	ldr	r0, [r7, #0x4]
 801dada: f7ff ffcd    	bl	0x801da78 <spi_stm32_cs_control> @ imm = #-0x66
; 	if (LL_SPI_IsActiveFlag_MODF(spi)) {
 801dade: 6938         	ldr	r0, [r7, #0x10]
 801dae0: f7ff fba7    	bl	0x801d232 <LL_SPI_IsActiveFlag_MODF> @ imm = #-0x8b2
 801dae4: 4603         	mov	r3, r0
 801dae6: 2b00         	cmp	r3, #0x0
 801dae8: d002         	beq	0x801daf0 <spi_stm32_complete+0x52> @ imm = #0x4
; 		LL_SPI_ClearFlag_MODF(spi);
 801daea: 6938         	ldr	r0, [r7, #0x10]
 801daec: f7ff fbda    	bl	0x801d2a4 <LL_SPI_ClearFlag_MODF> @ imm = #-0x84c
; 	if (!(data->ctx.config->operation & SPI_HOLD_ON_CS)) {
 801daf0: 68fb         	ldr	r3, [r7, #0xc]
 801daf2: 681b         	ldr	r3, [r3]
 801daf4: 889b         	ldrh	r3, [r3, #0x4]
 801daf6: f403 5380    	and	r3, r3, #0x1000
 801dafa: 2b00         	cmp	r3, #0x0
 801dafc: d102         	bne	0x801db04 <spi_stm32_complete+0x66> @ imm = #0x4
; 		ll_func_disable_spi(spi);
 801dafe: 6938         	ldr	r0, [r7, #0x10]
 801db00: f7ff fefb    	bl	0x801d8fa <ll_func_disable_spi> @ imm = #-0x20a
; 	spi_stm32_pm_policy_state_lock_put(dev);
 801db04: 6878         	ldr	r0, [r7, #0x4]
 801db06: f7ff ff15    	bl	0x801d934 <spi_stm32_pm_policy_state_lock_put> @ imm = #-0x1d6
; }
 801db0a: bf00         	nop
 801db0c: 3718         	adds	r7, #0x18
 801db0e: 46bd         	mov	sp, r7
 801db10: bd80         	pop	{r7, pc}

0801db12 <spi_stm32_release>:
; {
 801db12: b580         	push	{r7, lr}
 801db14: b084         	sub	sp, #0x10
 801db16: af00         	add	r7, sp, #0x0
 801db18: 6078         	str	r0, [r7, #0x4]
 801db1a: 6039         	str	r1, [r7]
; 	struct spi_stm32_data *data = dev->data;
 801db1c: 687b         	ldr	r3, [r7, #0x4]
 801db1e: 691b         	ldr	r3, [r3, #0x10]
 801db20: 60fb         	str	r3, [r7, #0xc]
; 	const struct spi_stm32_config *cfg = dev->config;
 801db22: 687b         	ldr	r3, [r7, #0x4]
 801db24: 685b         	ldr	r3, [r3, #0x4]
 801db26: 60bb         	str	r3, [r7, #0x8]
; 	spi_context_unlock_unconditionally(&data->ctx);
 801db28: 68fb         	ldr	r3, [r7, #0xc]
 801db2a: 4618         	mov	r0, r3
 801db2c: f7ff fe66    	bl	0x801d7fc <spi_context_unlock_unconditionally> @ imm = #-0x334
; 	ll_func_disable_spi(cfg->spi);
 801db30: 68bb         	ldr	r3, [r7, #0x8]
 801db32: 681b         	ldr	r3, [r3]
 801db34: 4618         	mov	r0, r3
 801db36: f7ff fee0    	bl	0x801d8fa <ll_func_disable_spi> @ imm = #-0x240
; 	return 0;
 801db3a: 2300         	movs	r3, #0x0
; }
 801db3c: 4618         	mov	r0, r3
 801db3e: 3710         	adds	r7, #0x10
 801db40: 46bd         	mov	sp, r7
 801db42: bd80         	pop	{r7, pc}

0801db44 <transceive>:
; {
 801db44: b580         	push	{r7, lr}
 801db46: b08a         	sub	sp, #0x28
 801db48: af02         	add	r7, sp, #0x8
 801db4a: 60f8         	str	r0, [r7, #0xc]
 801db4c: 60b9         	str	r1, [r7, #0x8]
 801db4e: 607a         	str	r2, [r7, #0x4]
 801db50: 603b         	str	r3, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 801db52: 68fb         	ldr	r3, [r7, #0xc]
 801db54: 685b         	ldr	r3, [r3, #0x4]
 801db56: 61bb         	str	r3, [r7, #0x18]
; 	struct spi_stm32_data *data = dev->data;
 801db58: 68fb         	ldr	r3, [r7, #0xc]
 801db5a: 691b         	ldr	r3, [r3, #0x10]
 801db5c: 617b         	str	r3, [r7, #0x14]
; 	SPI_TypeDef *spi = cfg->spi;
 801db5e: 69bb         	ldr	r3, [r7, #0x18]
 801db60: 681b         	ldr	r3, [r3]
 801db62: 613b         	str	r3, [r7, #0x10]
; 	if (!tx_bufs && !rx_bufs) {
 801db64: 687b         	ldr	r3, [r7, #0x4]
 801db66: 2b00         	cmp	r3, #0x0
 801db68: d104         	bne	0x801db74 <transceive+0x30> @ imm = #0x8
 801db6a: 683b         	ldr	r3, [r7]
 801db6c: 2b00         	cmp	r3, #0x0
 801db6e: d101         	bne	0x801db74 <transceive+0x30> @ imm = #0x2
; 		return 0;
 801db70: 2300         	movs	r3, #0x0
 801db72: e04f         	b	0x801dc14 <transceive+0xd0> @ imm = #0x9e
; 	if (asynchronous) {
 801db74: f897 3028    	ldrb.w	r3, [r7, #0x28]
 801db78: 2b00         	cmp	r3, #0x0
 801db7a: d002         	beq	0x801db82 <transceive+0x3e> @ imm = #0x4
; 		return -ENOTSUP;
 801db7c: f06f 0385    	mvn	r3, #0x85
 801db80: e048         	b	0x801dc14 <transceive+0xd0> @ imm = #0x90
; 	spi_context_lock(&data->ctx, asynchronous, cb, userdata, config);
 801db82: 6978         	ldr	r0, [r7, #0x14]
 801db84: f897 1028    	ldrb.w	r1, [r7, #0x28]
 801db88: 68bb         	ldr	r3, [r7, #0x8]
 801db8a: 9300         	str	r3, [sp]
 801db8c: 6b3b         	ldr	r3, [r7, #0x30]
 801db8e: 6afa         	ldr	r2, [r7, #0x2c]
 801db90: f7ff fd9c    	bl	0x801d6cc <spi_context_lock> @ imm = #-0x4c8
; 	spi_stm32_pm_policy_state_lock_get(dev);
 801db94: 68f8         	ldr	r0, [r7, #0xc]
 801db96: f7ff fec3    	bl	0x801d920 <spi_stm32_pm_policy_state_lock_get> @ imm = #-0x27a
; 	ret = spi_stm32_configure(dev, config);
 801db9a: 68b9         	ldr	r1, [r7, #0x8]
 801db9c: 68f8         	ldr	r0, [r7, #0xc]
 801db9e: f7f0 f805    	bl	0x800dbac <spi_stm32_configure> @ imm = #-0xfff6
 801dba2: 61f8         	str	r0, [r7, #0x1c]
; 	if (ret) {
 801dba4: 69fb         	ldr	r3, [r7, #0x1c]
 801dba6: 2b00         	cmp	r3, #0x0
 801dba8: d12d         	bne	0x801dc06 <transceive+0xc2> @ imm = #0x5a
; 	if (SPI_WORD_SIZE_GET(config->operation) == 8) {
 801dbaa: 68bb         	ldr	r3, [r7, #0x8]
 801dbac: 889b         	ldrh	r3, [r3, #0x4]
 801dbae: 095b         	lsrs	r3, r3, #0x5
 801dbb0: f003 033f    	and	r3, r3, #0x3f
 801dbb4: 2b08         	cmp	r3, #0x8
 801dbb6: d106         	bne	0x801dbc6 <transceive+0x82> @ imm = #0xc
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 1);
 801dbb8: 6978         	ldr	r0, [r7, #0x14]
 801dbba: 2301         	movs	r3, #0x1
 801dbbc: 683a         	ldr	r2, [r7]
 801dbbe: 6879         	ldr	r1, [r7, #0x4]
 801dbc0: f7ef f964    	bl	0x800ce8c <spi_context_buffers_setup> @ imm = #-0x10d38
 801dbc4: e005         	b	0x801dbd2 <transceive+0x8e> @ imm = #0xa
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 2);
 801dbc6: 6978         	ldr	r0, [r7, #0x14]
 801dbc8: 2302         	movs	r3, #0x2
 801dbca: 683a         	ldr	r2, [r7]
 801dbcc: 6879         	ldr	r1, [r7, #0x4]
 801dbce: f7ef f95d    	bl	0x800ce8c <spi_context_buffers_setup> @ imm = #-0x10d46
; 	LL_SPI_Enable(spi);
 801dbd2: 6938         	ldr	r0, [r7, #0x10]
 801dbd4: f7ff fa02    	bl	0x801cfdc <LL_SPI_Enable> @ imm = #-0xbfc
; 	spi_stm32_cs_control(dev, true);
 801dbd8: 2101         	movs	r1, #0x1
 801dbda: 68f8         	ldr	r0, [r7, #0xc]
 801dbdc: f7ff ff4c    	bl	0x801da78 <spi_stm32_cs_control> @ imm = #-0x168
; 		ret = spi_stm32_shift_frames(cfg, data);
 801dbe0: 6979         	ldr	r1, [r7, #0x14]
 801dbe2: 69b8         	ldr	r0, [r7, #0x18]
 801dbe4: f7ff ff25    	bl	0x801da32 <spi_stm32_shift_frames> @ imm = #-0x1b6
 801dbe8: 61f8         	str	r0, [r7, #0x1c]
; 	} while (!ret && spi_stm32_transfer_ongoing(data));
 801dbea: 69fb         	ldr	r3, [r7, #0x1c]
 801dbec: 2b00         	cmp	r3, #0x0
 801dbee: d105         	bne	0x801dbfc <transceive+0xb8> @ imm = #0xa
 801dbf0: 6978         	ldr	r0, [r7, #0x14]
 801dbf2: f7ff fea9    	bl	0x801d948 <spi_stm32_transfer_ongoing> @ imm = #-0x2ae
 801dbf6: 4603         	mov	r3, r0
 801dbf8: 2b00         	cmp	r3, #0x0
 801dbfa: d1f1         	bne	0x801dbe0 <transceive+0x9c> @ imm = #-0x1e
; 	spi_stm32_complete(dev, ret);
 801dbfc: 69f9         	ldr	r1, [r7, #0x1c]
 801dbfe: 68f8         	ldr	r0, [r7, #0xc]
 801dc00: f7ff ff4d    	bl	0x801da9e <spi_stm32_complete> @ imm = #-0x166
 801dc04: e000         	b	0x801dc08 <transceive+0xc4> @ imm = #0x0
; 		goto end;
 801dc06: bf00         	nop
; 	spi_context_release(&data->ctx, ret);
 801dc08: 697b         	ldr	r3, [r7, #0x14]
 801dc0a: 69f9         	ldr	r1, [r7, #0x1c]
 801dc0c: 4618         	mov	r0, r3
 801dc0e: f7ff fd89    	bl	0x801d724 <spi_context_release> @ imm = #-0x4ee
; 	return ret;
 801dc12: 69fb         	ldr	r3, [r7, #0x1c]
; }
 801dc14: 4618         	mov	r0, r3
 801dc16: 3720         	adds	r7, #0x20
 801dc18: 46bd         	mov	sp, r7
 801dc1a: bd80         	pop	{r7, pc}

0801dc1c <spi_stm32_transceive>:
; {
 801dc1c: b580         	push	{r7, lr}
 801dc1e: b088         	sub	sp, #0x20
 801dc20: af04         	add	r7, sp, #0x10
 801dc22: 60f8         	str	r0, [r7, #0xc]
 801dc24: 60b9         	str	r1, [r7, #0x8]
 801dc26: 607a         	str	r2, [r7, #0x4]
 801dc28: 603b         	str	r3, [r7]
; 	return transceive(dev, config, tx_bufs, rx_bufs, false, NULL, NULL);
 801dc2a: 2300         	movs	r3, #0x0
 801dc2c: 9302         	str	r3, [sp, #0x8]
 801dc2e: 2300         	movs	r3, #0x0
 801dc30: 9301         	str	r3, [sp, #0x4]
 801dc32: 2300         	movs	r3, #0x0
 801dc34: 9300         	str	r3, [sp]
 801dc36: 683b         	ldr	r3, [r7]
 801dc38: 687a         	ldr	r2, [r7, #0x4]
 801dc3a: 68b9         	ldr	r1, [r7, #0x8]
 801dc3c: 68f8         	ldr	r0, [r7, #0xc]
 801dc3e: f7ff ff81    	bl	0x801db44 <transceive>  @ imm = #-0xfe
 801dc42: 4603         	mov	r3, r0
; }
 801dc44: 4618         	mov	r0, r3
 801dc46: 3710         	adds	r7, #0x10
 801dc48: 46bd         	mov	sp, r7
 801dc4a: bd80         	pop	{r7, pc}

0801dc4c <spi_stm32_is_subghzspi>:
; {
 801dc4c: b480         	push	{r7}
 801dc4e: b083         	sub	sp, #0xc
 801dc50: af00         	add	r7, sp, #0x0
 801dc52: 6078         	str	r0, [r7, #0x4]
; 	return false;
 801dc54: 2300         	movs	r3, #0x0
; }
 801dc56: 4618         	mov	r0, r3
 801dc58: 370c         	adds	r7, #0xc
 801dc5a: 46bd         	mov	sp, r7
 801dc5c: f85d 7b04    	ldr	r7, [sp], #4
 801dc60: 4770         	bx	lr

0801dc62 <LL_DMA_Init>:
; {
 801dc62: b580         	push	{r7, lr}
 801dc64: b084         	sub	sp, #0x10
 801dc66: af00         	add	r7, sp, #0x0
 801dc68: 60f8         	str	r0, [r7, #0xc]
 801dc6a: 60b9         	str	r1, [r7, #0x8]
 801dc6c: 607a         	str	r2, [r7, #0x4]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 801dc6e: 687b         	ldr	r3, [r7, #0x4]
 801dc70: 689a         	ldr	r2, [r3, #0x8]
;                         DMA_InitStruct->Mode                    | \
 801dc72: 687b         	ldr	r3, [r7, #0x4]
 801dc74: 68db         	ldr	r3, [r3, #0xc]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 801dc76: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 801dc78: 687b         	ldr	r3, [r7, #0x4]
 801dc7a: 691b         	ldr	r3, [r3, #0x10]
;                         DMA_InitStruct->Mode                    | \
 801dc7c: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 801dc7e: 687b         	ldr	r3, [r7, #0x4]
 801dc80: 695b         	ldr	r3, [r3, #0x14]
;                         DMA_InitStruct->PeriphOrM2MSrcIncMode   | \
 801dc82: 431a         	orrs	r2, r3
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 801dc84: 687b         	ldr	r3, [r7, #0x4]
 801dc86: 699b         	ldr	r3, [r3, #0x18]
;                         DMA_InitStruct->MemoryOrM2MDstIncMode   | \
 801dc88: 431a         	orrs	r2, r3
;                         DMA_InitStruct->MemoryOrM2MDstDataSize  | \
 801dc8a: 687b         	ldr	r3, [r7, #0x4]
 801dc8c: 69db         	ldr	r3, [r3, #0x1c]
;                         DMA_InitStruct->PeriphOrM2MSrcDataSize  | \
 801dc8e: 431a         	orrs	r2, r3
;                         DMA_InitStruct->Priority
 801dc90: 687b         	ldr	r3, [r7, #0x4]
 801dc92: 6a9b         	ldr	r3, [r3, #0x28]
;   LL_DMA_ConfigTransfer(DMAx, Stream, DMA_InitStruct->Direction | \
 801dc94: 4313         	orrs	r3, r2
 801dc96: 461a         	mov	r2, r3
 801dc98: 68b9         	ldr	r1, [r7, #0x8]
 801dc9a: 68f8         	ldr	r0, [r7, #0xc]
 801dc9c: f7f0 ff30    	bl	0x800eb00 <LL_DMA_ConfigTransfer> @ imm = #-0xf1a0
;   if(DMA_InitStruct->FIFOMode != LL_DMA_FIFOMODE_DISABLE)
 801dca0: 687b         	ldr	r3, [r7, #0x4]
 801dca2: 6adb         	ldr	r3, [r3, #0x2c]
 801dca4: 2b00         	cmp	r3, #0x0
 801dca6: d015         	beq	0x801dcd4 <LL_DMA_Init+0x72> @ imm = #0x2a
;     LL_DMA_ConfigFifo(DMAx, Stream, DMA_InitStruct->FIFOMode, DMA_InitStruct->FIFOThreshold);
 801dca8: 687b         	ldr	r3, [r7, #0x4]
 801dcaa: 6ada         	ldr	r2, [r3, #0x2c]
 801dcac: 687b         	ldr	r3, [r7, #0x4]
 801dcae: 6b1b         	ldr	r3, [r3, #0x30]
 801dcb0: 68b9         	ldr	r1, [r7, #0x8]
 801dcb2: 68f8         	ldr	r0, [r7, #0xc]
 801dcb4: f7f0 ffda    	bl	0x800ec6c <LL_DMA_ConfigFifo> @ imm = #-0xf04c
;     LL_DMA_SetMemoryBurstxfer(DMAx,Stream,DMA_InitStruct->MemBurst);
 801dcb8: 687b         	ldr	r3, [r7, #0x4]
 801dcba: 6b5b         	ldr	r3, [r3, #0x34]
 801dcbc: 461a         	mov	r2, r3
 801dcbe: 68b9         	ldr	r1, [r7, #0x8]
 801dcc0: 68f8         	ldr	r0, [r7, #0xc]
 801dcc2: f7f0 ff8b    	bl	0x800ebdc <LL_DMA_SetMemoryBurstxfer> @ imm = #-0xf0ea
;     LL_DMA_SetPeriphBurstxfer(DMAx,Stream,DMA_InitStruct->PeriphBurst);
 801dcc6: 687b         	ldr	r3, [r7, #0x4]
 801dcc8: 6b9b         	ldr	r3, [r3, #0x38]
 801dcca: 461a         	mov	r2, r3
 801dccc: 68b9         	ldr	r1, [r7, #0x8]
 801dcce: 68f8         	ldr	r0, [r7, #0xc]
 801dcd0: f7f0 ffa8    	bl	0x800ec24 <LL_DMA_SetPeriphBurstxfer> @ imm = #-0xf0b0
;   LL_DMA_SetMemoryAddress(DMAx, Stream, DMA_InitStruct->MemoryOrM2MDstAddress);
 801dcd4: 687b         	ldr	r3, [r7, #0x4]
 801dcd6: 685b         	ldr	r3, [r3, #0x4]
 801dcd8: 461a         	mov	r2, r3
 801dcda: 68b9         	ldr	r1, [r7, #0x8]
 801dcdc: 68f8         	ldr	r0, [r7, #0xc]
 801dcde: f7f0 ffeb    	bl	0x800ecb8 <LL_DMA_SetMemoryAddress> @ imm = #-0xf02a
;   LL_DMA_SetPeriphAddress(DMAx, Stream, DMA_InitStruct->PeriphOrM2MSrcAddress);
 801dce2: 687b         	ldr	r3, [r7, #0x4]
 801dce4: 681b         	ldr	r3, [r3]
 801dce6: 461a         	mov	r2, r3
 801dce8: 68b9         	ldr	r1, [r7, #0x8]
 801dcea: 68f8         	ldr	r0, [r7, #0xc]
 801dcec: f7f0 fffc    	bl	0x800ece8 <LL_DMA_SetPeriphAddress> @ imm = #-0xf008
;   LL_DMA_SetDataLength(DMAx, Stream, DMA_InitStruct->NbData);
 801dcf0: 687b         	ldr	r3, [r7, #0x4]
 801dcf2: 6a1b         	ldr	r3, [r3, #0x20]
 801dcf4: 461a         	mov	r2, r3
 801dcf6: 68b9         	ldr	r1, [r7, #0x8]
 801dcf8: 68f8         	ldr	r0, [r7, #0xc]
 801dcfa: f7f0 ff27    	bl	0x800eb4c <LL_DMA_SetDataLength> @ imm = #-0xf1b2
;   LL_DMA_SetChannelSelection(DMAx, Stream, DMA_InitStruct->Channel);
 801dcfe: 687b         	ldr	r3, [r7, #0x4]
 801dd00: 6a5b         	ldr	r3, [r3, #0x24]
 801dd02: 461a         	mov	r2, r3
 801dd04: 68b9         	ldr	r1, [r7, #0x8]
 801dd06: 68f8         	ldr	r0, [r7, #0xc]
 801dd08: f7f0 ff44    	bl	0x800eb94 <LL_DMA_SetChannelSelection> @ imm = #-0xf178
;   return SUCCESS;
 801dd0c: 2300         	movs	r3, #0x0
; }
 801dd0e: 4618         	mov	r0, r3
 801dd10: 3710         	adds	r7, #0x10
 801dd12: 46bd         	mov	sp, r7
 801dd14: bd80         	pop	{r7, pc}

0801dd16 <LL_DMA_StructInit>:
; {
 801dd16: b480         	push	{r7}
 801dd18: b083         	sub	sp, #0xc
 801dd1a: af00         	add	r7, sp, #0x0
 801dd1c: 6078         	str	r0, [r7, #0x4]
;   DMA_InitStruct->PeriphOrM2MSrcAddress  = 0x00000000U;
 801dd1e: 687b         	ldr	r3, [r7, #0x4]
 801dd20: 2200         	movs	r2, #0x0
 801dd22: 601a         	str	r2, [r3]
;   DMA_InitStruct->MemoryOrM2MDstAddress  = 0x00000000U;
 801dd24: 687b         	ldr	r3, [r7, #0x4]
 801dd26: 2200         	movs	r2, #0x0
 801dd28: 605a         	str	r2, [r3, #0x4]
;   DMA_InitStruct->Direction              = LL_DMA_DIRECTION_PERIPH_TO_MEMORY;
 801dd2a: 687b         	ldr	r3, [r7, #0x4]
 801dd2c: 2200         	movs	r2, #0x0
 801dd2e: 609a         	str	r2, [r3, #0x8]
;   DMA_InitStruct->Mode                   = LL_DMA_MODE_NORMAL;
 801dd30: 687b         	ldr	r3, [r7, #0x4]
 801dd32: 2200         	movs	r2, #0x0
 801dd34: 60da         	str	r2, [r3, #0xc]
;   DMA_InitStruct->PeriphOrM2MSrcIncMode  = LL_DMA_PERIPH_NOINCREMENT;
 801dd36: 687b         	ldr	r3, [r7, #0x4]
 801dd38: 2200         	movs	r2, #0x0
 801dd3a: 611a         	str	r2, [r3, #0x10]
;   DMA_InitStruct->MemoryOrM2MDstIncMode  = LL_DMA_MEMORY_NOINCREMENT;
 801dd3c: 687b         	ldr	r3, [r7, #0x4]
 801dd3e: 2200         	movs	r2, #0x0
 801dd40: 615a         	str	r2, [r3, #0x14]
;   DMA_InitStruct->PeriphOrM2MSrcDataSize = LL_DMA_PDATAALIGN_BYTE;
 801dd42: 687b         	ldr	r3, [r7, #0x4]
 801dd44: 2200         	movs	r2, #0x0
 801dd46: 619a         	str	r2, [r3, #0x18]
;   DMA_InitStruct->MemoryOrM2MDstDataSize = LL_DMA_MDATAALIGN_BYTE;
 801dd48: 687b         	ldr	r3, [r7, #0x4]
 801dd4a: 2200         	movs	r2, #0x0
 801dd4c: 61da         	str	r2, [r3, #0x1c]
;   DMA_InitStruct->NbData                 = 0x00000000U;
 801dd4e: 687b         	ldr	r3, [r7, #0x4]
 801dd50: 2200         	movs	r2, #0x0
 801dd52: 621a         	str	r2, [r3, #0x20]
;   DMA_InitStruct->Channel                = LL_DMA_CHANNEL_0;
 801dd54: 687b         	ldr	r3, [r7, #0x4]
 801dd56: 2200         	movs	r2, #0x0
 801dd58: 625a         	str	r2, [r3, #0x24]
;   DMA_InitStruct->Priority               = LL_DMA_PRIORITY_LOW;
 801dd5a: 687b         	ldr	r3, [r7, #0x4]
 801dd5c: 2200         	movs	r2, #0x0
 801dd5e: 629a         	str	r2, [r3, #0x28]
;   DMA_InitStruct->FIFOMode               = LL_DMA_FIFOMODE_DISABLE;
 801dd60: 687b         	ldr	r3, [r7, #0x4]
 801dd62: 2200         	movs	r2, #0x0
 801dd64: 62da         	str	r2, [r3, #0x2c]
;   DMA_InitStruct->FIFOThreshold          = LL_DMA_FIFOTHRESHOLD_1_4;
 801dd66: 687b         	ldr	r3, [r7, #0x4]
 801dd68: 2200         	movs	r2, #0x0
 801dd6a: 631a         	str	r2, [r3, #0x30]
;   DMA_InitStruct->MemBurst               = LL_DMA_MBURST_SINGLE;
 801dd6c: 687b         	ldr	r3, [r7, #0x4]
 801dd6e: 2200         	movs	r2, #0x0
 801dd70: 635a         	str	r2, [r3, #0x34]
;   DMA_InitStruct->PeriphBurst            = LL_DMA_PBURST_SINGLE;
 801dd72: 687b         	ldr	r3, [r7, #0x4]
 801dd74: 2200         	movs	r2, #0x0
 801dd76: 639a         	str	r2, [r3, #0x38]
; }
 801dd78: bf00         	nop
 801dd7a: 370c         	adds	r7, #0xc
 801dd7c: 46bd         	mov	sp, r7
 801dd7e: f85d 7b04    	ldr	r7, [sp], #4
 801dd82: 4770         	bx	lr

0801dd84 <LL_TIM_SetPrescaler>:
; {
 801dd84: b480         	push	{r7}
 801dd86: b083         	sub	sp, #0xc
 801dd88: af00         	add	r7, sp, #0x0
 801dd8a: 6078         	str	r0, [r7, #0x4]
 801dd8c: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->PSC, Prescaler);
 801dd8e: 687b         	ldr	r3, [r7, #0x4]
 801dd90: 683a         	ldr	r2, [r7]
 801dd92: 629a         	str	r2, [r3, #0x28]
; }
 801dd94: bf00         	nop
 801dd96: 370c         	adds	r7, #0xc
 801dd98: 46bd         	mov	sp, r7
 801dd9a: f85d 7b04    	ldr	r7, [sp], #4
 801dd9e: 4770         	bx	lr

0801dda0 <LL_TIM_SetAutoReload>:
; {
 801dda0: b480         	push	{r7}
 801dda2: b083         	sub	sp, #0xc
 801dda4: af00         	add	r7, sp, #0x0
 801dda6: 6078         	str	r0, [r7, #0x4]
 801dda8: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->ARR, AutoReload);
 801ddaa: 687b         	ldr	r3, [r7, #0x4]
 801ddac: 683a         	ldr	r2, [r7]
 801ddae: 62da         	str	r2, [r3, #0x2c]
; }
 801ddb0: bf00         	nop
 801ddb2: 370c         	adds	r7, #0xc
 801ddb4: 46bd         	mov	sp, r7
 801ddb6: f85d 7b04    	ldr	r7, [sp], #4
 801ddba: 4770         	bx	lr

0801ddbc <LL_TIM_SetRepetitionCounter>:
; {
 801ddbc: b480         	push	{r7}
 801ddbe: b083         	sub	sp, #0xc
 801ddc0: af00         	add	r7, sp, #0x0
 801ddc2: 6078         	str	r0, [r7, #0x4]
 801ddc4: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->RCR, RepetitionCounter);
 801ddc6: 687b         	ldr	r3, [r7, #0x4]
 801ddc8: 683a         	ldr	r2, [r7]
 801ddca: 631a         	str	r2, [r3, #0x30]
; }
 801ddcc: bf00         	nop
 801ddce: 370c         	adds	r7, #0xc
 801ddd0: 46bd         	mov	sp, r7
 801ddd2: f85d 7b04    	ldr	r7, [sp], #4
 801ddd6: 4770         	bx	lr

0801ddd8 <LL_TIM_OC_SetCompareCH1>:
; {
 801ddd8: b480         	push	{r7}
 801ddda: b083         	sub	sp, #0xc
 801dddc: af00         	add	r7, sp, #0x0
 801ddde: 6078         	str	r0, [r7, #0x4]
 801dde0: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->CCR1, CompareValue);
 801dde2: 687b         	ldr	r3, [r7, #0x4]
 801dde4: 683a         	ldr	r2, [r7]
 801dde6: 635a         	str	r2, [r3, #0x34]
; }
 801dde8: bf00         	nop
 801ddea: 370c         	adds	r7, #0xc
 801ddec: 46bd         	mov	sp, r7
 801ddee: f85d 7b04    	ldr	r7, [sp], #4
 801ddf2: 4770         	bx	lr

0801ddf4 <LL_TIM_OC_SetCompareCH2>:
; {
 801ddf4: b480         	push	{r7}
 801ddf6: b083         	sub	sp, #0xc
 801ddf8: af00         	add	r7, sp, #0x0
 801ddfa: 6078         	str	r0, [r7, #0x4]
 801ddfc: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->CCR2, CompareValue);
 801ddfe: 687b         	ldr	r3, [r7, #0x4]
 801de00: 683a         	ldr	r2, [r7]
 801de02: 639a         	str	r2, [r3, #0x38]
; }
 801de04: bf00         	nop
 801de06: 370c         	adds	r7, #0xc
 801de08: 46bd         	mov	sp, r7
 801de0a: f85d 7b04    	ldr	r7, [sp], #4
 801de0e: 4770         	bx	lr

0801de10 <LL_TIM_OC_SetCompareCH3>:
; {
 801de10: b480         	push	{r7}
 801de12: b083         	sub	sp, #0xc
 801de14: af00         	add	r7, sp, #0x0
 801de16: 6078         	str	r0, [r7, #0x4]
 801de18: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->CCR3, CompareValue);
 801de1a: 687b         	ldr	r3, [r7, #0x4]
 801de1c: 683a         	ldr	r2, [r7]
 801de1e: 63da         	str	r2, [r3, #0x3c]
; }
 801de20: bf00         	nop
 801de22: 370c         	adds	r7, #0xc
 801de24: 46bd         	mov	sp, r7
 801de26: f85d 7b04    	ldr	r7, [sp], #4
 801de2a: 4770         	bx	lr

0801de2c <LL_TIM_OC_SetCompareCH4>:
; {
 801de2c: b480         	push	{r7}
 801de2e: b083         	sub	sp, #0xc
 801de30: af00         	add	r7, sp, #0x0
 801de32: 6078         	str	r0, [r7, #0x4]
 801de34: 6039         	str	r1, [r7]
;   WRITE_REG(TIMx->CCR4, CompareValue);
 801de36: 687b         	ldr	r3, [r7, #0x4]
 801de38: 683a         	ldr	r2, [r7]
 801de3a: 641a         	str	r2, [r3, #0x40]
; }
 801de3c: bf00         	nop
 801de3e: 370c         	adds	r7, #0xc
 801de40: 46bd         	mov	sp, r7
 801de42: f85d 7b04    	ldr	r7, [sp], #4
 801de46: 4770         	bx	lr

0801de48 <LL_TIM_GenerateEvent_UPDATE>:
; {
 801de48: b480         	push	{r7}
 801de4a: b083         	sub	sp, #0xc
 801de4c: af00         	add	r7, sp, #0x0
 801de4e: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(TIMx->EGR, TIM_EGR_UG);
 801de50: 687b         	ldr	r3, [r7, #0x4]
 801de52: 695b         	ldr	r3, [r3, #0x14]
 801de54: f043 0201    	orr	r2, r3, #0x1
 801de58: 687b         	ldr	r3, [r7, #0x4]
 801de5a: 615a         	str	r2, [r3, #0x14]
; }
 801de5c: bf00         	nop
 801de5e: 370c         	adds	r7, #0xc
 801de60: 46bd         	mov	sp, r7
 801de62: f85d 7b04    	ldr	r7, [sp], #4
 801de66: 4770         	bx	lr

0801de68 <LL_TIM_StructInit>:
; {
 801de68: b480         	push	{r7}
 801de6a: b083         	sub	sp, #0xc
 801de6c: af00         	add	r7, sp, #0x0
 801de6e: 6078         	str	r0, [r7, #0x4]
;   TIM_InitStruct->Prescaler         = (uint16_t)0x0000;
 801de70: 687b         	ldr	r3, [r7, #0x4]
 801de72: 2200         	movs	r2, #0x0
 801de74: 801a         	strh	r2, [r3]
;   TIM_InitStruct->CounterMode       = LL_TIM_COUNTERMODE_UP;
 801de76: 687b         	ldr	r3, [r7, #0x4]
 801de78: 2200         	movs	r2, #0x0
 801de7a: 605a         	str	r2, [r3, #0x4]
;   TIM_InitStruct->Autoreload        = 0xFFFFFFFFU;
 801de7c: 687b         	ldr	r3, [r7, #0x4]
 801de7e: f04f 32ff    	mov.w	r2, #0xffffffff
 801de82: 609a         	str	r2, [r3, #0x8]
;   TIM_InitStruct->ClockDivision     = LL_TIM_CLOCKDIVISION_DIV1;
 801de84: 687b         	ldr	r3, [r7, #0x4]
 801de86: 2200         	movs	r2, #0x0
 801de88: 60da         	str	r2, [r3, #0xc]
;   TIM_InitStruct->RepetitionCounter = 0x00000000U;
 801de8a: 687b         	ldr	r3, [r7, #0x4]
 801de8c: 2200         	movs	r2, #0x0
 801de8e: 611a         	str	r2, [r3, #0x10]
; }
 801de90: bf00         	nop
 801de92: 370c         	adds	r7, #0xc
 801de94: 46bd         	mov	sp, r7
 801de96: f85d 7b04    	ldr	r7, [sp], #4
 801de9a: 4770         	bx	lr

0801de9c <LL_TIM_OC_StructInit>:
; {
 801de9c: b480         	push	{r7}
 801de9e: b083         	sub	sp, #0xc
 801dea0: af00         	add	r7, sp, #0x0
 801dea2: 6078         	str	r0, [r7, #0x4]
;   TIM_OC_InitStruct->OCMode       = LL_TIM_OCMODE_FROZEN;
 801dea4: 687b         	ldr	r3, [r7, #0x4]
 801dea6: 2200         	movs	r2, #0x0
 801dea8: 601a         	str	r2, [r3]
;   TIM_OC_InitStruct->OCState      = LL_TIM_OCSTATE_DISABLE;
 801deaa: 687b         	ldr	r3, [r7, #0x4]
 801deac: 2200         	movs	r2, #0x0
 801deae: 605a         	str	r2, [r3, #0x4]
;   TIM_OC_InitStruct->OCNState     = LL_TIM_OCSTATE_DISABLE;
 801deb0: 687b         	ldr	r3, [r7, #0x4]
 801deb2: 2200         	movs	r2, #0x0
 801deb4: 609a         	str	r2, [r3, #0x8]
;   TIM_OC_InitStruct->CompareValue = 0x00000000U;
 801deb6: 687b         	ldr	r3, [r7, #0x4]
 801deb8: 2200         	movs	r2, #0x0
 801deba: 60da         	str	r2, [r3, #0xc]
;   TIM_OC_InitStruct->OCPolarity   = LL_TIM_OCPOLARITY_HIGH;
 801debc: 687b         	ldr	r3, [r7, #0x4]
 801debe: 2200         	movs	r2, #0x0
 801dec0: 611a         	str	r2, [r3, #0x10]
;   TIM_OC_InitStruct->OCNPolarity  = LL_TIM_OCPOLARITY_HIGH;
 801dec2: 687b         	ldr	r3, [r7, #0x4]
 801dec4: 2200         	movs	r2, #0x0
 801dec6: 615a         	str	r2, [r3, #0x14]
;   TIM_OC_InitStruct->OCIdleState  = LL_TIM_OCIDLESTATE_LOW;
 801dec8: 687b         	ldr	r3, [r7, #0x4]
 801deca: 2200         	movs	r2, #0x0
 801decc: 619a         	str	r2, [r3, #0x18]
;   TIM_OC_InitStruct->OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
 801dece: 687b         	ldr	r3, [r7, #0x4]
 801ded0: 2200         	movs	r2, #0x0
 801ded2: 61da         	str	r2, [r3, #0x1c]
; }
 801ded4: bf00         	nop
 801ded6: 370c         	adds	r7, #0xc
 801ded8: 46bd         	mov	sp, r7
 801deda: f85d 7b04    	ldr	r7, [sp], #4
 801dede: 4770         	bx	lr

0801dee0 <LL_TIM_OC_Init>:
; {
 801dee0: b580         	push	{r7, lr}
 801dee2: b086         	sub	sp, #0x18
 801dee4: af00         	add	r7, sp, #0x0
 801dee6: 60f8         	str	r0, [r7, #0xc]
 801dee8: 60b9         	str	r1, [r7, #0x8]
 801deea: 607a         	str	r2, [r7, #0x4]
;   ErrorStatus result = ERROR;
 801deec: 2301         	movs	r3, #0x1
 801deee: 75fb         	strb	r3, [r7, #0x17]
;   switch (Channel)
 801def0: 68bb         	ldr	r3, [r7, #0x8]
 801def2: f5b3 5f80    	cmp.w	r3, #0x1000
 801def6: d027         	beq	0x801df48 <LL_TIM_OC_Init+0x68> @ imm = #0x4e
 801def8: 68bb         	ldr	r3, [r7, #0x8]
 801defa: f5b3 5f80    	cmp.w	r3, #0x1000
 801defe: d82a         	bhi	0x801df56 <LL_TIM_OC_Init+0x76> @ imm = #0x54
 801df00: 68bb         	ldr	r3, [r7, #0x8]
 801df02: f5b3 7f80    	cmp.w	r3, #0x100
 801df06: d018         	beq	0x801df3a <LL_TIM_OC_Init+0x5a> @ imm = #0x30
 801df08: 68bb         	ldr	r3, [r7, #0x8]
 801df0a: f5b3 7f80    	cmp.w	r3, #0x100
 801df0e: d822         	bhi	0x801df56 <LL_TIM_OC_Init+0x76> @ imm = #0x44
 801df10: 68bb         	ldr	r3, [r7, #0x8]
 801df12: 2b01         	cmp	r3, #0x1
 801df14: d003         	beq	0x801df1e <LL_TIM_OC_Init+0x3e> @ imm = #0x6
 801df16: 68bb         	ldr	r3, [r7, #0x8]
 801df18: 2b10         	cmp	r3, #0x10
 801df1a: d007         	beq	0x801df2c <LL_TIM_OC_Init+0x4c> @ imm = #0xe
;       break;
 801df1c: e01b         	b	0x801df56 <LL_TIM_OC_Init+0x76> @ imm = #0x36
;       result = OC1Config(TIMx, TIM_OC_InitStruct);
 801df1e: 6879         	ldr	r1, [r7, #0x4]
 801df20: 68f8         	ldr	r0, [r7, #0xc]
 801df22: f7f0 ff93    	bl	0x800ee4c <OC1Config>   @ imm = #-0xf0da
 801df26: 4603         	mov	r3, r0
 801df28: 75fb         	strb	r3, [r7, #0x17]
;       break;
 801df2a: e015         	b	0x801df58 <LL_TIM_OC_Init+0x78> @ imm = #0x2a
;       result = OC2Config(TIMx, TIM_OC_InitStruct);
 801df2c: 6879         	ldr	r1, [r7, #0x4]
 801df2e: 68f8         	ldr	r0, [r7, #0xc]
 801df30: f7f0 fff8    	bl	0x800ef24 <OC2Config>   @ imm = #-0xf010
 801df34: 4603         	mov	r3, r0
 801df36: 75fb         	strb	r3, [r7, #0x17]
;       break;
 801df38: e00e         	b	0x801df58 <LL_TIM_OC_Init+0x78> @ imm = #0x1c
;       result = OC3Config(TIMx, TIM_OC_InitStruct);
 801df3a: 6879         	ldr	r1, [r7, #0x4]
 801df3c: 68f8         	ldr	r0, [r7, #0xc]
 801df3e: f7f1 f861    	bl	0x800f004 <OC3Config>   @ imm = #-0xef3e
 801df42: 4603         	mov	r3, r0
 801df44: 75fb         	strb	r3, [r7, #0x17]
;       break;
 801df46: e007         	b	0x801df58 <LL_TIM_OC_Init+0x78> @ imm = #0xe
;       result = OC4Config(TIMx, TIM_OC_InitStruct);
 801df48: 6879         	ldr	r1, [r7, #0x4]
 801df4a: 68f8         	ldr	r0, [r7, #0xc]
 801df4c: f7f1 f8ca    	bl	0x800f0e4 <OC4Config>   @ imm = #-0xee6c
 801df50: 4603         	mov	r3, r0
 801df52: 75fb         	strb	r3, [r7, #0x17]
;       break;
 801df54: e000         	b	0x801df58 <LL_TIM_OC_Init+0x78> @ imm = #0x0
;       break;
 801df56: bf00         	nop
;   return result;
 801df58: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 801df5a: 4618         	mov	r0, r3
 801df5c: 3718         	adds	r7, #0x18
 801df5e: 46bd         	mov	sp, r7
 801df60: bd80         	pop	{r7, pc}

0801df62 <arch_k_cycle_get_32>:
; {
 801df62: b580         	push	{r7, lr}
 801df64: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 801df66: f7f0 fa63    	bl	0x800e430 <sys_clock_cycle_get_32> @ imm = #-0xfb3a
 801df6a: 4603         	mov	r3, r0
; }
 801df6c: 4618         	mov	r0, r3
 801df6e: bd80         	pop	{r7, pc}

0801df70 <k_cycle_get_32>:
; {
 801df70: b580         	push	{r7, lr}
 801df72: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 801df74: f7ff fff5    	bl	0x801df62 <arch_k_cycle_get_32> @ imm = #-0x16
 801df78: 4603         	mov	r3, r0
; }
 801df7a: 4618         	mov	r0, r3
 801df7c: bd80         	pop	{r7, pc}

0801df7e <z_impl_k_busy_wait>:
; {
 801df7e: b580         	push	{r7, lr}
 801df80: b086         	sub	sp, #0x18
 801df82: af00         	add	r7, sp, #0x0
 801df84: 6078         	str	r0, [r7, #0x4]
; 	if (usec_to_wait == 0U) {
 801df86: 687b         	ldr	r3, [r7, #0x4]
 801df88: 2b00         	cmp	r3, #0x0
 801df8a: d011         	beq	0x801dfb0 <z_impl_k_busy_wait+0x32> @ imm = #0x22
; 	uint32_t start_cycles = k_cycle_get_32();
 801df8c: f7ff fff0    	bl	0x801df70 <k_cycle_get_32> @ imm = #-0x20
 801df90: 6178         	str	r0, [r7, #0x14]
; 	uint32_t cycles_to_wait = k_us_to_cyc_ceil32(usec_to_wait);
 801df92: 687b         	ldr	r3, [r7, #0x4]
 801df94: 22a8         	movs	r2, #0xa8
 801df96: fb02 f303    	mul	r3, r2, r3
 801df9a: 613b         	str	r3, [r7, #0x10]
; 		uint32_t current_cycles = k_cycle_get_32();
 801df9c: f7ff ffe8    	bl	0x801df70 <k_cycle_get_32> @ imm = #-0x30
 801dfa0: 60f8         	str	r0, [r7, #0xc]
; 		if ((current_cycles - start_cycles) >= cycles_to_wait) {
 801dfa2: 68fa         	ldr	r2, [r7, #0xc]
 801dfa4: 697b         	ldr	r3, [r7, #0x14]
 801dfa6: 1ad3         	subs	r3, r2, r3
 801dfa8: 693a         	ldr	r2, [r7, #0x10]
 801dfaa: 429a         	cmp	r2, r3
 801dfac: d902         	bls	0x801dfb4 <z_impl_k_busy_wait+0x36> @ imm = #0x4
; 	for (;;) {
 801dfae: e7f5         	b	0x801df9c <z_impl_k_busy_wait+0x1e> @ imm = #-0x16
; 		return;
 801dfb0: bf00         	nop
 801dfb2: e000         	b	0x801dfb6 <z_impl_k_busy_wait+0x38> @ imm = #0x0
; 			break;
 801dfb4: bf00         	nop
; }
 801dfb6: 3718         	adds	r7, #0x18
 801dfb8: 46bd         	mov	sp, r7
 801dfba: bd80         	pop	{r7, pc}

0801dfbc <k_object_init>:
; {
 801dfbc: b480         	push	{r7}
 801dfbe: b083         	sub	sp, #0xc
 801dfc0: af00         	add	r7, sp, #0x0
 801dfc2: 6078         	str	r0, [r7, #0x4]
; }
 801dfc4: bf00         	nop
 801dfc6: 370c         	adds	r7, #0xc
 801dfc8: 46bd         	mov	sp, r7
 801dfca: f85d 7b04    	ldr	r7, [sp], #4
 801dfce: 4770         	bx	lr

0801dfd0 <z_impl_device_is_ready>:
; {
 801dfd0: b480         	push	{r7}
 801dfd2: b083         	sub	sp, #0xc
 801dfd4: af00         	add	r7, sp, #0x0
 801dfd6: 6078         	str	r0, [r7, #0x4]
; 	if (dev == NULL) {
 801dfd8: 687b         	ldr	r3, [r7, #0x4]
 801dfda: 2b00         	cmp	r3, #0x0
 801dfdc: d101         	bne	0x801dfe2 <z_impl_device_is_ready+0x12> @ imm = #0x2
; 		return false;
 801dfde: 2300         	movs	r3, #0x0
 801dfe0: e012         	b	0x801e008 <z_impl_device_is_ready+0x38> @ imm = #0x24
; 	return dev->state->initialized && (dev->state->init_res == 0U);
 801dfe2: 687b         	ldr	r3, [r7, #0x4]
 801dfe4: 68db         	ldr	r3, [r3, #0xc]
 801dfe6: 785b         	ldrb	r3, [r3, #0x1]
 801dfe8: f003 0301    	and	r3, r3, #0x1
 801dfec: b2db         	uxtb	r3, r3
 801dfee: 2b00         	cmp	r3, #0x0
 801dff0: d006         	beq	0x801e000 <z_impl_device_is_ready+0x30> @ imm = #0xc
 801dff2: 687b         	ldr	r3, [r7, #0x4]
 801dff4: 68db         	ldr	r3, [r3, #0xc]
 801dff6: 781b         	ldrb	r3, [r3]
 801dff8: 2b00         	cmp	r3, #0x0
 801dffa: d101         	bne	0x801e000 <z_impl_device_is_ready+0x30> @ imm = #0x2
 801dffc: 2301         	movs	r3, #0x1
 801dffe: e000         	b	0x801e002 <z_impl_device_is_ready+0x32> @ imm = #0x0
 801e000: 2300         	movs	r3, #0x0
 801e002: f003 0301    	and	r3, r3, #0x1
 801e006: b2db         	uxtb	r3, r3
; }
 801e008: 4618         	mov	r0, r3
 801e00a: 370c         	adds	r7, #0xc
 801e00c: 46bd         	mov	sp, r7
 801e00e: f85d 7b04    	ldr	r7, [sp], #4
 801e012: 4770         	bx	lr

0801e014 <k_thread_abort>:
; {
 801e014: b580         	push	{r7, lr}
 801e016: b082         	sub	sp, #0x8
 801e018: af00         	add	r7, sp, #0x0
 801e01a: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 801e01c: 6878         	ldr	r0, [r7, #0x4]
 801e01e: f7e8 fecf    	bl	0x8006dc0 <z_impl_k_thread_abort> @ imm = #-0x17262
; }
 801e022: bf00         	nop
 801e024: 3708         	adds	r7, #0x8
 801e026: 46bd         	mov	sp, r7
 801e028: bd80         	pop	{r7, pc}

0801e02a <z_log_msg_runtime_create>:
; {
 801e02a: b580         	push	{r7, lr}
 801e02c: b08a         	sub	sp, #0x28
 801e02e: af04         	add	r7, sp, #0x10
 801e030: 60b9         	str	r1, [r7, #0x8]
 801e032: 607b         	str	r3, [r7, #0x4]
 801e034: 4603         	mov	r3, r0
 801e036: 73fb         	strb	r3, [r7, #0xf]
 801e038: 4613         	mov	r3, r2
 801e03a: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801e03c: f107 032c    	add.w	r3, r7, #0x2c
 801e040: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801e042: 7bba         	ldrb	r2, [r7, #0xe]
 801e044: 7bf8         	ldrb	r0, [r7, #0xf]
 801e046: 697b         	ldr	r3, [r7, #0x14]
 801e048: 9303         	str	r3, [sp, #0xc]
 801e04a: 6abb         	ldr	r3, [r7, #0x28]
 801e04c: 9302         	str	r3, [sp, #0x8]
 801e04e: 6a7b         	ldr	r3, [r7, #0x24]
 801e050: 9301         	str	r3, [sp, #0x4]
 801e052: 6a3b         	ldr	r3, [r7, #0x20]
 801e054: 9300         	str	r3, [sp]
 801e056: 687b         	ldr	r3, [r7, #0x4]
 801e058: 68b9         	ldr	r1, [r7, #0x8]
 801e05a: f7e7 fa8b    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x18aea
; }
 801e05e: bf00         	nop
 801e060: 3718         	adds	r7, #0x18
 801e062: 46bd         	mov	sp, r7
 801e064: bd80         	pop	{r7, pc}

0801e066 <log_panic>:
; {
 801e066: b580         	push	{r7, lr}
 801e068: af00         	add	r7, sp, #0x0
; 	z_impl_log_panic();
 801e06a: f7e7 f909    	bl	0x8005280 <z_impl_log_panic> @ imm = #-0x18dee
; }
 801e06e: bf00         	nop
 801e070: bd80         	pop	{r7, pc}

0801e072 <coredump>:
; {
 801e072: b480         	push	{r7}
 801e074: b085         	sub	sp, #0x14
 801e076: af00         	add	r7, sp, #0x0
 801e078: 60f8         	str	r0, [r7, #0xc]
 801e07a: 60b9         	str	r1, [r7, #0x8]
 801e07c: 607a         	str	r2, [r7, #0x4]
; }
 801e07e: bf00         	nop
 801e080: 3714         	adds	r7, #0x14
 801e082: 46bd         	mov	sp, r7
 801e084: f85d 7b04    	ldr	r7, [sp], #4
 801e088: 4770         	bx	lr

0801e08a <arch_system_halt>:
; {
 801e08a: b480         	push	{r7}
 801e08c: b087         	sub	sp, #0x1c
 801e08e: af00         	add	r7, sp, #0x0
 801e090: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801e092: f3ef 8311    	mrs	r3, basepri
 801e096: 617b         	str	r3, [r7, #0x14]
;   return(result);
 801e098: 697b         	ldr	r3, [r7, #0x14]
; 	key = __get_BASEPRI();
 801e09a: 613b         	str	r3, [r7, #0x10]
 801e09c: 2310         	movs	r3, #0x10
 801e09e: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801e0a0: 68fb         	ldr	r3, [r7, #0xc]
 801e0a2: f383 8812    	msr	basepri_max, r3
; }
 801e0a6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801e0a8: f3bf 8f6f    	isb	sy
; }
 801e0ac: bf00         	nop
; 	for (;;) {
 801e0ae: bf00         	nop
 801e0b0: e7fd         	b	0x801e0ae <arch_system_halt+0x24> @ imm = #-0x6

0801e0b2 <K_KERNEL_STACK_BUFFER>:
; {
 801e0b2: b480         	push	{r7}
 801e0b4: b083         	sub	sp, #0xc
 801e0b6: af00         	add	r7, sp, #0x0
 801e0b8: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 801e0ba: 687b         	ldr	r3, [r7, #0x4]
; }
 801e0bc: 4618         	mov	r0, r3
 801e0be: 370c         	adds	r7, #0xc
 801e0c0: 46bd         	mov	sp, r7
 801e0c2: f85d 7b04    	ldr	r7, [sp], #4
 801e0c6: 4770         	bx	lr

0801e0c8 <k_thread_start>:
; {
 801e0c8: b580         	push	{r7, lr}
 801e0ca: b082         	sub	sp, #0x8
 801e0cc: af00         	add	r7, sp, #0x0
 801e0ce: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 801e0d0: 6878         	ldr	r0, [r7, #0x4]
 801e0d2: f000 f804    	bl	0x801e0de <k_thread_resume> @ imm = #0x8
; }
 801e0d6: bf00         	nop
 801e0d8: 3708         	adds	r7, #0x8
 801e0da: 46bd         	mov	sp, r7
 801e0dc: bd80         	pop	{r7, pc}

0801e0de <k_thread_resume>:
; {
 801e0de: b580         	push	{r7, lr}
 801e0e0: b082         	sub	sp, #0x8
 801e0e2: af00         	add	r7, sp, #0x0
 801e0e4: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 801e0e6: 6878         	ldr	r0, [r7, #0x4]
 801e0e8: f7f3 fa7c    	bl	0x80115e4 <z_impl_k_thread_resume> @ imm = #-0xcb08
; }
 801e0ec: bf00         	nop
 801e0ee: 3708         	adds	r7, #0x8
 801e0f0: 46bd         	mov	sp, r7
 801e0f2: bd80         	pop	{r7, pc}

0801e0f4 <thread_schedule_new>:
; {
 801e0f4: b580         	push	{r7, lr}
 801e0f6: b084         	sub	sp, #0x10
 801e0f8: af00         	add	r7, sp, #0x0
 801e0fa: 60f8         	str	r0, [r7, #0xc]
 801e0fc: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 801e100: e9d7 2300    	ldrd	r2, r3, [r7]
 801e104: f04f 0000    	mov.w	r0, #0x0
 801e108: f04f 0100    	mov.w	r1, #0x0
 801e10c: 428b         	cmp	r3, r1
 801e10e: bf08         	it	eq
 801e110: 4282         	cmpeq	r2, r0
 801e112: d103         	bne	0x801e11c <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 801e114: 68f8         	ldr	r0, [r7, #0xc]
 801e116: f7ff ffd7    	bl	0x801e0c8 <k_thread_start> @ imm = #-0x52
 801e11a: e004         	b	0x801e126 <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 801e11c: e9d7 2300    	ldrd	r2, r3, [r7]
 801e120: 68f8         	ldr	r0, [r7, #0xc]
 801e122: f7f1 fa7d    	bl	0x800f620 <z_add_thread_timeout> @ imm = #-0xeb06
; }
 801e126: bf00         	nop
 801e128: 3710         	adds	r7, #0x10
 801e12a: 46bd         	mov	sp, r7
 801e12c: bd80         	pop	{r7, pc}

0801e12e <z_mark_thread_as_not_suspended>:
; {
 801e12e: b480         	push	{r7}
 801e130: b083         	sub	sp, #0xc
 801e132: af00         	add	r7, sp, #0x0
 801e134: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 801e136: 687b         	ldr	r3, [r7, #0x4]
 801e138: 7b5b         	ldrb	r3, [r3, #0xd]
 801e13a: f023 0310    	bic	r3, r3, #0x10
 801e13e: b2da         	uxtb	r2, r3
 801e140: 687b         	ldr	r3, [r7, #0x4]
 801e142: 735a         	strb	r2, [r3, #0xd]
; }
 801e144: bf00         	nop
 801e146: 370c         	adds	r7, #0xc
 801e148: 46bd         	mov	sp, r7
 801e14a: f85d 7b04    	ldr	r7, [sp], #4
 801e14e: 4770         	bx	lr

0801e150 <z_thread_essential_clear>:
; {
 801e150: b480         	push	{r7}
 801e152: b083         	sub	sp, #0xc
 801e154: af00         	add	r7, sp, #0x0
 801e156: 6078         	str	r0, [r7, #0x4]
; 	thread->base.user_options &= ~K_ESSENTIAL;
 801e158: 687b         	ldr	r3, [r7, #0x4]
 801e15a: 7b1b         	ldrb	r3, [r3, #0xc]
 801e15c: f023 0301    	bic	r3, r3, #0x1
 801e160: b2da         	uxtb	r2, r3
 801e162: 687b         	ldr	r3, [r7, #0x4]
 801e164: 731a         	strb	r2, [r3, #0xc]
; }
 801e166: bf00         	nop
 801e168: 370c         	adds	r7, #0xc
 801e16a: 46bd         	mov	sp, r7
 801e16c: f85d 7b04    	ldr	r7, [sp], #4
 801e170: 4770         	bx	lr

0801e172 <gcov_static_init>:
; static inline void gcov_static_init(void) { }
 801e172: b480         	push	{r7}
 801e174: af00         	add	r7, sp, #0x0
 801e176: bf00         	nop
 801e178: 46bd         	mov	sp, r7
 801e17a: f85d 7b04    	ldr	r7, [sp], #4
 801e17e: 4770         	bx	lr

0801e180 <pm_device_runtime_auto_enable>:
; {
 801e180: b480         	push	{r7}
 801e182: b083         	sub	sp, #0xc
 801e184: af00         	add	r7, sp, #0x0
 801e186: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801e188: 2300         	movs	r3, #0x0
; }
 801e18a: 4618         	mov	r0, r3
 801e18c: 370c         	adds	r7, #0xc
 801e18e: 46bd         	mov	sp, r7
 801e190: f85d 7b04    	ldr	r7, [sp], #4
 801e194: 4770         	bx	lr

0801e196 <z_early_memset>:
; {
 801e196: b580         	push	{r7, lr}
 801e198: b084         	sub	sp, #0x10
 801e19a: af00         	add	r7, sp, #0x0
 801e19c: 60f8         	str	r0, [r7, #0xc]
 801e19e: 60b9         	str	r1, [r7, #0x8]
 801e1a0: 607a         	str	r2, [r7, #0x4]
; 	(void) memset(dst, c, n);
 801e1a2: 687a         	ldr	r2, [r7, #0x4]
 801e1a4: 68b9         	ldr	r1, [r7, #0x8]
 801e1a6: 68f8         	ldr	r0, [r7, #0xc]
 801e1a8: f001 fd96    	bl	0x801fcd8 <memset>      @ imm = #0x1b2c
; }
 801e1ac: bf00         	nop
 801e1ae: 3710         	adds	r7, #0x10
 801e1b0: 46bd         	mov	sp, r7
 801e1b2: bd80         	pop	{r7, pc}

0801e1b4 <z_early_memcpy>:
; {
 801e1b4: b580         	push	{r7, lr}
 801e1b6: b084         	sub	sp, #0x10
 801e1b8: af00         	add	r7, sp, #0x0
 801e1ba: 60f8         	str	r0, [r7, #0xc]
 801e1bc: 60b9         	str	r1, [r7, #0x8]
 801e1be: 607a         	str	r2, [r7, #0x4]
; 	(void) memcpy(dst, src, n);
 801e1c0: 687a         	ldr	r2, [r7, #0x4]
 801e1c2: 68b9         	ldr	r1, [r7, #0x8]
 801e1c4: 68f8         	ldr	r0, [r7, #0xc]
 801e1c6: f001 fd79    	bl	0x801fcbc <memcpy>      @ imm = #0x1af2
; }
 801e1ca: bf00         	nop
 801e1cc: 3710         	adds	r7, #0x10
 801e1ce: 46bd         	mov	sp, r7
 801e1d0: bd80         	pop	{r7, pc}

0801e1d2 <do_device_init>:
; {
 801e1d2: b580         	push	{r7, lr}
 801e1d4: b084         	sub	sp, #0x10
 801e1d6: af00         	add	r7, sp, #0x0
 801e1d8: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = entry->dev;
 801e1da: 687b         	ldr	r3, [r7, #0x4]
 801e1dc: 685b         	ldr	r3, [r3, #0x4]
 801e1de: 60bb         	str	r3, [r7, #0x8]
; 	int rc = 0;
 801e1e0: 2300         	movs	r3, #0x0
 801e1e2: 60fb         	str	r3, [r7, #0xc]
; 	if (entry->init_fn.dev != NULL) {
 801e1e4: 687b         	ldr	r3, [r7, #0x4]
 801e1e6: 681b         	ldr	r3, [r3]
 801e1e8: 2b00         	cmp	r3, #0x0
 801e1ea: d017         	beq	0x801e21c <do_device_init+0x4a> @ imm = #0x2e
; 		rc = entry->init_fn.dev(dev);
 801e1ec: 687b         	ldr	r3, [r7, #0x4]
 801e1ee: 681b         	ldr	r3, [r3]
 801e1f0: 68b8         	ldr	r0, [r7, #0x8]
 801e1f2: 4798         	blx	r3
 801e1f4: 60f8         	str	r0, [r7, #0xc]
; 		if (rc != 0) {
 801e1f6: 68fb         	ldr	r3, [r7, #0xc]
 801e1f8: 2b00         	cmp	r3, #0x0
 801e1fa: d00f         	beq	0x801e21c <do_device_init+0x4a> @ imm = #0x1e
; 			if (rc < 0) {
 801e1fc: 68fb         	ldr	r3, [r7, #0xc]
 801e1fe: 2b00         	cmp	r3, #0x0
 801e200: da02         	bge	0x801e208 <do_device_init+0x36> @ imm = #0x4
; 				rc = -rc;
 801e202: 68fb         	ldr	r3, [r7, #0xc]
 801e204: 425b         	rsbs	r3, r3, #0
 801e206: 60fb         	str	r3, [r7, #0xc]
; 			if (rc > UINT8_MAX) {
 801e208: 68fb         	ldr	r3, [r7, #0xc]
 801e20a: 2bff         	cmp	r3, #0xff
 801e20c: dd01         	ble	0x801e212 <do_device_init+0x40> @ imm = #0x2
; 				rc = UINT8_MAX;
 801e20e: 23ff         	movs	r3, #0xff
 801e210: 60fb         	str	r3, [r7, #0xc]
; 			dev->state->init_res = rc;
 801e212: 68bb         	ldr	r3, [r7, #0x8]
 801e214: 68db         	ldr	r3, [r3, #0xc]
 801e216: 68fa         	ldr	r2, [r7, #0xc]
 801e218: b2d2         	uxtb	r2, r2
 801e21a: 701a         	strb	r2, [r3]
; 	dev->state->initialized = true;
 801e21c: 68bb         	ldr	r3, [r7, #0x8]
 801e21e: 68da         	ldr	r2, [r3, #0xc]
 801e220: 7853         	ldrb	r3, [r2, #0x1]
 801e222: f043 0301    	orr	r3, r3, #0x1
 801e226: 7053         	strb	r3, [r2, #0x1]
; 	if (rc == 0) {
 801e228: 68fb         	ldr	r3, [r7, #0xc]
 801e22a: 2b00         	cmp	r3, #0x0
 801e22c: d102         	bne	0x801e234 <do_device_init+0x62> @ imm = #0x4
; 		(void)pm_device_runtime_auto_enable(dev);
 801e22e: 68b8         	ldr	r0, [r7, #0x8]
 801e230: f7ff ffa6    	bl	0x801e180 <pm_device_runtime_auto_enable> @ imm = #-0xb4
; 	return rc;
 801e234: 68fb         	ldr	r3, [r7, #0xc]
; }
 801e236: 4618         	mov	r0, r3
 801e238: 3710         	adds	r7, #0x10
 801e23a: 46bd         	mov	sp, r7
 801e23c: bd80         	pop	{r7, pc}

0801e23e <z_init_static>:
; {
 801e23e: b480         	push	{r7}
 801e240: af00         	add	r7, sp, #0x0
; }
 801e242: bf00         	nop
 801e244: 46bd         	mov	sp, r7
 801e246: f85d 7b04    	ldr	r7, [sp], #4
 801e24a: 4770         	bx	lr

0801e24c <k_cpu_idle>:
; {
 801e24c: b580         	push	{r7, lr}
 801e24e: af00         	add	r7, sp, #0x0
; 	arch_cpu_idle();
 801e250: f7f9 fb74    	bl	0x801793c <arch_cpu_idle> @ imm = #-0x6918
; }
 801e254: bf00         	nop
 801e256: bd80         	pop	{r7, pc}

0801e258 <idle>:
; {
 801e258: b580         	push	{r7, lr}
 801e25a: b088         	sub	sp, #0x20
 801e25c: af00         	add	r7, sp, #0x0
 801e25e: 60f8         	str	r0, [r7, #0xc]
 801e260: 60b9         	str	r1, [r7, #0x8]
 801e262: 607a         	str	r2, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801e264: f3ef 8311    	mrs	r3, basepri
 801e268: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 801e26a: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 801e26c: 61bb         	str	r3, [r7, #0x18]
 801e26e: 2310         	movs	r3, #0x10
 801e270: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801e272: 697b         	ldr	r3, [r7, #0x14]
 801e274: f383 8812    	msr	basepri_max, r3
; }
 801e278: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801e27a: f3bf 8f6f    	isb	sy
; }
 801e27e: bf00         	nop
; 	return key;
 801e280: bf00         	nop
; 		k_cpu_idle();
 801e282: f7ff ffe3    	bl	0x801e24c <k_cpu_idle>  @ imm = #-0x3a
; 		if (IS_ENABLED(CONFIG_SMP) && !IS_ENABLED(CONFIG_SCHED_IPI_SUPPORTED)) {
 801e286: e7ed         	b	0x801e264 <idle+0xc>    @ imm = #-0x26

0801e288 <arch_spin_relax>:
; {
 801e288: b480         	push	{r7}
 801e28a: af00         	add	r7, sp, #0x0
; 	__asm__ volatile("nop");
 801e28c: bf00         	nop
; }
 801e28e: bf00         	nop
; }
 801e290: bf00         	nop
 801e292: 46bd         	mov	sp, r7
 801e294: f85d 7b04    	ldr	r7, [sp], #4
 801e298: 4770         	bx	lr

0801e29a <sys_dnode_init>:
; {
 801e29a: b480         	push	{r7}
 801e29c: b083         	sub	sp, #0xc
 801e29e: af00         	add	r7, sp, #0x0
 801e2a0: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801e2a2: 687b         	ldr	r3, [r7, #0x4]
 801e2a4: 2200         	movs	r2, #0x0
 801e2a6: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801e2a8: 687b         	ldr	r3, [r7, #0x4]
 801e2aa: 2200         	movs	r2, #0x0
 801e2ac: 605a         	str	r2, [r3, #0x4]
; }
 801e2ae: bf00         	nop
 801e2b0: 370c         	adds	r7, #0xc
 801e2b2: 46bd         	mov	sp, r7
 801e2b4: f85d 7b04    	ldr	r7, [sp], #4
 801e2b8: 4770         	bx	lr

0801e2ba <sys_dnode_is_linked>:
; {
 801e2ba: b480         	push	{r7}
 801e2bc: b083         	sub	sp, #0xc
 801e2be: af00         	add	r7, sp, #0x0
 801e2c0: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 801e2c2: 687b         	ldr	r3, [r7, #0x4]
 801e2c4: 681b         	ldr	r3, [r3]
 801e2c6: 2b00         	cmp	r3, #0x0
 801e2c8: bf14         	ite	ne
 801e2ca: 2301         	movne	r3, #0x1
 801e2cc: 2300         	moveq	r3, #0x0
 801e2ce: b2db         	uxtb	r3, r3
; }
 801e2d0: 4618         	mov	r0, r3
 801e2d2: 370c         	adds	r7, #0xc
 801e2d4: 46bd         	mov	sp, r7
 801e2d6: f85d 7b04    	ldr	r7, [sp], #4
 801e2da: 4770         	bx	lr

0801e2dc <sys_dlist_is_empty>:
; {
 801e2dc: b480         	push	{r7}
 801e2de: b083         	sub	sp, #0xc
 801e2e0: af00         	add	r7, sp, #0x0
 801e2e2: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801e2e4: 687b         	ldr	r3, [r7, #0x4]
 801e2e6: 681b         	ldr	r3, [r3]
 801e2e8: 687a         	ldr	r2, [r7, #0x4]
 801e2ea: 429a         	cmp	r2, r3
 801e2ec: bf0c         	ite	eq
 801e2ee: 2301         	moveq	r3, #0x1
 801e2f0: 2300         	movne	r3, #0x0
 801e2f2: b2db         	uxtb	r3, r3
; }
 801e2f4: 4618         	mov	r0, r3
 801e2f6: 370c         	adds	r7, #0xc
 801e2f8: 46bd         	mov	sp, r7
 801e2fa: f85d 7b04    	ldr	r7, [sp], #4
 801e2fe: 4770         	bx	lr

0801e300 <sys_dlist_peek_head>:
; {
 801e300: b580         	push	{r7, lr}
 801e302: b082         	sub	sp, #0x8
 801e304: af00         	add	r7, sp, #0x0
 801e306: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801e308: 6878         	ldr	r0, [r7, #0x4]
 801e30a: f7ff ffe7    	bl	0x801e2dc <sys_dlist_is_empty> @ imm = #-0x32
 801e30e: 4603         	mov	r3, r0
 801e310: 2b00         	cmp	r3, #0x0
 801e312: d102         	bne	0x801e31a <sys_dlist_peek_head+0x1a> @ imm = #0x4
 801e314: 687b         	ldr	r3, [r7, #0x4]
 801e316: 681b         	ldr	r3, [r3]
 801e318: e000         	b	0x801e31c <sys_dlist_peek_head+0x1c> @ imm = #0x0
 801e31a: 2300         	movs	r3, #0x0
; }
 801e31c: 4618         	mov	r0, r3
 801e31e: 3708         	adds	r7, #0x8
 801e320: 46bd         	mov	sp, r7
 801e322: bd80         	pop	{r7, pc}

0801e324 <sys_dlist_remove>:
; {
 801e324: b580         	push	{r7, lr}
 801e326: b084         	sub	sp, #0x10
 801e328: af00         	add	r7, sp, #0x0
 801e32a: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801e32c: 687b         	ldr	r3, [r7, #0x4]
 801e32e: 685b         	ldr	r3, [r3, #0x4]
 801e330: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 801e332: 687b         	ldr	r3, [r7, #0x4]
 801e334: 681b         	ldr	r3, [r3]
 801e336: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 801e338: 68fb         	ldr	r3, [r7, #0xc]
 801e33a: 68ba         	ldr	r2, [r7, #0x8]
 801e33c: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801e33e: 68bb         	ldr	r3, [r7, #0x8]
 801e340: 68fa         	ldr	r2, [r7, #0xc]
 801e342: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 801e344: 6878         	ldr	r0, [r7, #0x4]
 801e346: f7ff ffa8    	bl	0x801e29a <sys_dnode_init> @ imm = #-0xb0
; }
 801e34a: bf00         	nop
 801e34c: 3710         	adds	r7, #0x10
 801e34e: 46bd         	mov	sp, r7
 801e350: bd80         	pop	{r7, pc}

0801e352 <z_is_inactive_timeout>:
; {
 801e352: b580         	push	{r7, lr}
 801e354: b082         	sub	sp, #0x8
 801e356: af00         	add	r7, sp, #0x0
 801e358: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 801e35a: 687b         	ldr	r3, [r7, #0x4]
 801e35c: 4618         	mov	r0, r3
 801e35e: f7ff ffac    	bl	0x801e2ba <sys_dnode_is_linked> @ imm = #-0xa8
 801e362: 4603         	mov	r3, r0
 801e364: 2b00         	cmp	r3, #0x0
 801e366: bf14         	ite	ne
 801e368: 2301         	movne	r3, #0x1
 801e36a: 2300         	moveq	r3, #0x0
 801e36c: b2db         	uxtb	r3, r3
 801e36e: f083 0301    	eor	r3, r3, #0x1
 801e372: b2db         	uxtb	r3, r3
 801e374: f003 0301    	and	r3, r3, #0x1
 801e378: b2db         	uxtb	r3, r3
; }
 801e37a: 4618         	mov	r0, r3
 801e37c: 3708         	adds	r7, #0x8
 801e37e: 46bd         	mov	sp, r7
 801e380: bd80         	pop	{r7, pc}

0801e382 <z_abort_thread_timeout>:
; {
 801e382: b580         	push	{r7, lr}
 801e384: b082         	sub	sp, #0x8
 801e386: af00         	add	r7, sp, #0x0
 801e388: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 801e38a: 687b         	ldr	r3, [r7, #0x4]
 801e38c: 3318         	adds	r3, #0x18
 801e38e: 4618         	mov	r0, r3
 801e390: f7f4 fc36    	bl	0x8012c00 <z_abort_timeout> @ imm = #-0xb794
 801e394: 4603         	mov	r3, r0
; }
 801e396: 4618         	mov	r0, r3
 801e398: 3708         	adds	r7, #0x8
 801e39a: 46bd         	mov	sp, r7
 801e39c: bd80         	pop	{r7, pc}

0801e39e <z_is_thread_prevented_from_running>:
; {
 801e39e: b480         	push	{r7}
 801e3a0: b085         	sub	sp, #0x14
 801e3a2: af00         	add	r7, sp, #0x0
 801e3a4: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 801e3a6: 687b         	ldr	r3, [r7, #0x4]
 801e3a8: 7b5b         	ldrb	r3, [r3, #0xd]
 801e3aa: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 801e3ac: 7bfb         	ldrb	r3, [r7, #0xf]
 801e3ae: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 801e3b2: 2b00         	cmp	r3, #0x0
 801e3b4: bf14         	ite	ne
 801e3b6: 2301         	movne	r3, #0x1
 801e3b8: 2300         	moveq	r3, #0x0
 801e3ba: b2db         	uxtb	r3, r3
; }
 801e3bc: 4618         	mov	r0, r3
 801e3be: 3714         	adds	r7, #0x14
 801e3c0: 46bd         	mov	sp, r7
 801e3c2: f85d 7b04    	ldr	r7, [sp], #4
 801e3c6: 4770         	bx	lr

0801e3c8 <z_is_thread_timeout_active>:
; {
 801e3c8: b580         	push	{r7, lr}
 801e3ca: b082         	sub	sp, #0x8
 801e3cc: af00         	add	r7, sp, #0x0
 801e3ce: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 801e3d0: 687b         	ldr	r3, [r7, #0x4]
 801e3d2: 3318         	adds	r3, #0x18
 801e3d4: 4618         	mov	r0, r3
 801e3d6: f7ff ffbc    	bl	0x801e352 <z_is_inactive_timeout> @ imm = #-0x88
 801e3da: 4603         	mov	r3, r0
 801e3dc: 2b00         	cmp	r3, #0x0
 801e3de: bf14         	ite	ne
 801e3e0: 2301         	movne	r3, #0x1
 801e3e2: 2300         	moveq	r3, #0x0
 801e3e4: b2db         	uxtb	r3, r3
 801e3e6: f083 0301    	eor	r3, r3, #0x1
 801e3ea: b2db         	uxtb	r3, r3
 801e3ec: f003 0301    	and	r3, r3, #0x1
 801e3f0: b2db         	uxtb	r3, r3
; }
 801e3f2: 4618         	mov	r0, r3
 801e3f4: 3708         	adds	r7, #0x8
 801e3f6: 46bd         	mov	sp, r7
 801e3f8: bd80         	pop	{r7, pc}

0801e3fa <z_is_thread_ready>:
; {
 801e3fa: b580         	push	{r7, lr}
 801e3fc: b082         	sub	sp, #0x8
 801e3fe: af00         	add	r7, sp, #0x0
 801e400: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 801e402: 6878         	ldr	r0, [r7, #0x4]
 801e404: f7ff ffcb    	bl	0x801e39e <z_is_thread_prevented_from_running> @ imm = #-0x6a
 801e408: 4603         	mov	r3, r0
 801e40a: f083 0301    	eor	r3, r3, #0x1
 801e40e: b2db         	uxtb	r3, r3
 801e410: 2b00         	cmp	r3, #0x0
 801e412: d00a         	beq	0x801e42a <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 801e414: 6878         	ldr	r0, [r7, #0x4]
 801e416: f7ff ffd7    	bl	0x801e3c8 <z_is_thread_timeout_active> @ imm = #-0x52
 801e41a: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 801e41c: f083 0301    	eor	r3, r3, #0x1
 801e420: b2db         	uxtb	r3, r3
 801e422: 2b00         	cmp	r3, #0x0
 801e424: d001         	beq	0x801e42a <z_is_thread_ready+0x30> @ imm = #0x2
 801e426: 2301         	movs	r3, #0x1
 801e428: e000         	b	0x801e42c <z_is_thread_ready+0x32> @ imm = #0x0
 801e42a: 2300         	movs	r3, #0x0
 801e42c: f003 0301    	and	r3, r3, #0x1
 801e430: b2db         	uxtb	r3, r3
; }
 801e432: 4618         	mov	r0, r3
 801e434: 3708         	adds	r7, #0x8
 801e436: 46bd         	mov	sp, r7
 801e438: bd80         	pop	{r7, pc}

0801e43a <z_mark_thread_as_not_pending>:
; {
 801e43a: b480         	push	{r7}
 801e43c: b083         	sub	sp, #0xc
 801e43e: af00         	add	r7, sp, #0x0
 801e440: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 801e442: 687b         	ldr	r3, [r7, #0x4]
 801e444: 7b5b         	ldrb	r3, [r3, #0xd]
 801e446: f023 0302    	bic	r3, r3, #0x2
 801e44a: b2da         	uxtb	r2, r3
 801e44c: 687b         	ldr	r3, [r7, #0x4]
 801e44e: 735a         	strb	r2, [r3, #0xd]
; }
 801e450: bf00         	nop
 801e452: 370c         	adds	r7, #0xc
 801e454: 46bd         	mov	sp, r7
 801e456: f85d 7b04    	ldr	r7, [sp], #4
 801e45a: 4770         	bx	lr

0801e45c <z_is_under_prio_ceiling>:
; {
 801e45c: b480         	push	{r7}
 801e45e: b083         	sub	sp, #0xc
 801e460: af00         	add	r7, sp, #0x0
 801e462: 6078         	str	r0, [r7, #0x4]
; 	return prio >= CONFIG_PRIORITY_CEILING;
 801e464: 687b         	ldr	r3, [r7, #0x4]
 801e466: f113 0f7f    	cmn.w	r3, #0x7f
 801e46a: bfac         	ite	ge
 801e46c: 2301         	movge	r3, #0x1
 801e46e: 2300         	movlt	r3, #0x0
 801e470: b2db         	uxtb	r3, r3
; }
 801e472: 4618         	mov	r0, r3
 801e474: 370c         	adds	r7, #0xc
 801e476: 46bd         	mov	sp, r7
 801e478: f85d 7b04    	ldr	r7, [sp], #4
 801e47c: 4770         	bx	lr

0801e47e <z_get_new_prio_with_ceiling>:
; {
 801e47e: b580         	push	{r7, lr}
 801e480: b082         	sub	sp, #0x8
 801e482: af00         	add	r7, sp, #0x0
 801e484: 6078         	str	r0, [r7, #0x4]
; 	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
 801e486: 6878         	ldr	r0, [r7, #0x4]
 801e488: f7ff ffe8    	bl	0x801e45c <z_is_under_prio_ceiling> @ imm = #-0x30
 801e48c: 4603         	mov	r3, r0
 801e48e: 2b00         	cmp	r3, #0x0
 801e490: d001         	beq	0x801e496 <z_get_new_prio_with_ceiling+0x18> @ imm = #0x2
 801e492: 687b         	ldr	r3, [r7, #0x4]
 801e494: e001         	b	0x801e49a <z_get_new_prio_with_ceiling+0x1c> @ imm = #0x2
 801e496: f06f 037e    	mvn	r3, #0x7e
; }
 801e49a: 4618         	mov	r0, r3
 801e49c: 3708         	adds	r7, #0x8
 801e49e: 46bd         	mov	sp, r7
 801e4a0: bd80         	pop	{r7, pc}

0801e4a2 <z_is_prio1_higher_than_prio2>:
; {
 801e4a2: b480         	push	{r7}
 801e4a4: b083         	sub	sp, #0xc
 801e4a6: af00         	add	r7, sp, #0x0
 801e4a8: 6078         	str	r0, [r7, #0x4]
 801e4aa: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 801e4ac: 687a         	ldr	r2, [r7, #0x4]
 801e4ae: 683b         	ldr	r3, [r7]
 801e4b0: 429a         	cmp	r2, r3
 801e4b2: bfb4         	ite	lt
 801e4b4: 2301         	movlt	r3, #0x1
 801e4b6: 2300         	movge	r3, #0x0
 801e4b8: b2db         	uxtb	r3, r3
; }
 801e4ba: 4618         	mov	r0, r3
 801e4bc: 370c         	adds	r7, #0xc
 801e4be: 46bd         	mov	sp, r7
 801e4c0: f85d 7b04    	ldr	r7, [sp], #4
 801e4c4: 4770         	bx	lr

0801e4c6 <z_is_prio_higher>:
; {
 801e4c6: b580         	push	{r7, lr}
 801e4c8: b082         	sub	sp, #0x8
 801e4ca: af00         	add	r7, sp, #0x0
 801e4cc: 6078         	str	r0, [r7, #0x4]
 801e4ce: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 801e4d0: 6839         	ldr	r1, [r7]
 801e4d2: 6878         	ldr	r0, [r7, #0x4]
 801e4d4: f7ff ffe5    	bl	0x801e4a2 <z_is_prio1_higher_than_prio2> @ imm = #-0x36
 801e4d8: 4603         	mov	r3, r0
; }
 801e4da: 4618         	mov	r0, r3
 801e4dc: 3708         	adds	r7, #0x8
 801e4de: 46bd         	mov	sp, r7
 801e4e0: bd80         	pop	{r7, pc}

0801e4e2 <unpend_thread_no_timeout>:
; {
 801e4e2: b580         	push	{r7, lr}
 801e4e4: b086         	sub	sp, #0x18
 801e4e6: af00         	add	r7, sp, #0x0
 801e4e8: 6078         	str	r0, [r7, #0x4]
 801e4ea: 687b         	ldr	r3, [r7, #0x4]
 801e4ec: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 801e4ee: 68fb         	ldr	r3, [r7, #0xc]
 801e4f0: 689b         	ldr	r3, [r3, #0x8]
 801e4f2: 617b         	str	r3, [r7, #0x14]
 801e4f4: 687b         	ldr	r3, [r7, #0x4]
 801e4f6: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801e4f8: 693b         	ldr	r3, [r7, #0x10]
 801e4fa: 4618         	mov	r0, r3
 801e4fc: f7ff ff12    	bl	0x801e324 <sys_dlist_remove> @ imm = #-0x1dc
; }
 801e500: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 801e502: 6878         	ldr	r0, [r7, #0x4]
 801e504: f7ff ff99    	bl	0x801e43a <z_mark_thread_as_not_pending> @ imm = #-0xce
; 	thread->base.pended_on = NULL;
 801e508: 687b         	ldr	r3, [r7, #0x4]
 801e50a: 2200         	movs	r2, #0x0
 801e50c: 609a         	str	r2, [r3, #0x8]
; }
 801e50e: bf00         	nop
 801e510: 3718         	adds	r7, #0x18
 801e512: 46bd         	mov	sp, r7
 801e514: bd80         	pop	{r7, pc}

0801e516 <z_waitq_head>:
; {
 801e516: b580         	push	{r7, lr}
 801e518: b082         	sub	sp, #0x8
 801e51a: af00         	add	r7, sp, #0x0
 801e51c: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 801e51e: 687b         	ldr	r3, [r7, #0x4]
 801e520: 4618         	mov	r0, r3
 801e522: f7ff feed    	bl	0x801e300 <sys_dlist_peek_head> @ imm = #-0x226
 801e526: 4603         	mov	r3, r0
; }
 801e528: 4618         	mov	r0, r3
 801e52a: 3708         	adds	r7, #0x8
 801e52c: 46bd         	mov	sp, r7
 801e52e: bd80         	pop	{r7, pc}

0801e530 <z_log_msg_runtime_create>:
; {
 801e530: b580         	push	{r7, lr}
 801e532: b08a         	sub	sp, #0x28
 801e534: af04         	add	r7, sp, #0x10
 801e536: 60b9         	str	r1, [r7, #0x8]
 801e538: 607b         	str	r3, [r7, #0x4]
 801e53a: 4603         	mov	r3, r0
 801e53c: 73fb         	strb	r3, [r7, #0xf]
 801e53e: 4613         	mov	r3, r2
 801e540: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801e542: f107 032c    	add.w	r3, r7, #0x2c
 801e546: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801e548: 7bba         	ldrb	r2, [r7, #0xe]
 801e54a: 7bf8         	ldrb	r0, [r7, #0xf]
 801e54c: 697b         	ldr	r3, [r7, #0x14]
 801e54e: 9303         	str	r3, [sp, #0xc]
 801e550: 6abb         	ldr	r3, [r7, #0x28]
 801e552: 9302         	str	r3, [sp, #0x8]
 801e554: 6a7b         	ldr	r3, [r7, #0x24]
 801e556: 9301         	str	r3, [sp, #0x4]
 801e558: 6a3b         	ldr	r3, [r7, #0x20]
 801e55a: 9300         	str	r3, [sp]
 801e55c: 687b         	ldr	r3, [r7, #0x4]
 801e55e: 68b9         	ldr	r1, [r7, #0x8]
 801e560: f7e7 f808    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x18ff0
; }
 801e564: bf00         	nop
 801e566: 3718         	adds	r7, #0x18
 801e568: 46bd         	mov	sp, r7
 801e56a: bd80         	pop	{r7, pc}

0801e56c <new_prio_for_inheritance>:
; {
 801e56c: b580         	push	{r7, lr}
 801e56e: b084         	sub	sp, #0x10
 801e570: af00         	add	r7, sp, #0x0
 801e572: 6078         	str	r0, [r7, #0x4]
 801e574: 6039         	str	r1, [r7]
; 	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
 801e576: 6839         	ldr	r1, [r7]
 801e578: 6878         	ldr	r0, [r7, #0x4]
 801e57a: f7ff ffa4    	bl	0x801e4c6 <z_is_prio_higher> @ imm = #-0xb8
 801e57e: 4603         	mov	r3, r0
 801e580: 2b00         	cmp	r3, #0x0
 801e582: d001         	beq	0x801e588 <new_prio_for_inheritance+0x1c> @ imm = #0x2
 801e584: 687b         	ldr	r3, [r7, #0x4]
 801e586: e000         	b	0x801e58a <new_prio_for_inheritance+0x1e> @ imm = #0x0
 801e588: 683b         	ldr	r3, [r7]
 801e58a: 60fb         	str	r3, [r7, #0xc]
; 	new_prio = z_get_new_prio_with_ceiling(new_prio);
 801e58c: 68f8         	ldr	r0, [r7, #0xc]
 801e58e: f7ff ff76    	bl	0x801e47e <z_get_new_prio_with_ceiling> @ imm = #-0x114
 801e592: 60f8         	str	r0, [r7, #0xc]
; 	return new_prio;
 801e594: 68fb         	ldr	r3, [r7, #0xc]
; }
 801e596: 4618         	mov	r0, r3
 801e598: 3710         	adds	r7, #0x10
 801e59a: 46bd         	mov	sp, r7
 801e59c: bd80         	pop	{r7, pc}

0801e59e <sys_dlist_init>:
; {
 801e59e: b480         	push	{r7}
 801e5a0: b083         	sub	sp, #0xc
 801e5a2: af00         	add	r7, sp, #0x0
 801e5a4: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801e5a6: 687b         	ldr	r3, [r7, #0x4]
 801e5a8: 687a         	ldr	r2, [r7, #0x4]
 801e5aa: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 801e5ac: 687b         	ldr	r3, [r7, #0x4]
 801e5ae: 687a         	ldr	r2, [r7, #0x4]
 801e5b0: 605a         	str	r2, [r3, #0x4]
; }
 801e5b2: bf00         	nop
 801e5b4: 370c         	adds	r7, #0xc
 801e5b6: 46bd         	mov	sp, r7
 801e5b8: f85d 7b04    	ldr	r7, [sp], #4
 801e5bc: 4770         	bx	lr

0801e5be <sys_dnode_init>:
; {
 801e5be: b480         	push	{r7}
 801e5c0: b083         	sub	sp, #0xc
 801e5c2: af00         	add	r7, sp, #0x0
 801e5c4: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801e5c6: 687b         	ldr	r3, [r7, #0x4]
 801e5c8: 2200         	movs	r2, #0x0
 801e5ca: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801e5cc: 687b         	ldr	r3, [r7, #0x4]
 801e5ce: 2200         	movs	r2, #0x0
 801e5d0: 605a         	str	r2, [r3, #0x4]
; }
 801e5d2: bf00         	nop
 801e5d4: 370c         	adds	r7, #0xc
 801e5d6: 46bd         	mov	sp, r7
 801e5d8: f85d 7b04    	ldr	r7, [sp], #4
 801e5dc: 4770         	bx	lr

0801e5de <sys_dlist_is_empty>:
; {
 801e5de: b480         	push	{r7}
 801e5e0: b083         	sub	sp, #0xc
 801e5e2: af00         	add	r7, sp, #0x0
 801e5e4: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801e5e6: 687b         	ldr	r3, [r7, #0x4]
 801e5e8: 681b         	ldr	r3, [r3]
 801e5ea: 687a         	ldr	r2, [r7, #0x4]
 801e5ec: 429a         	cmp	r2, r3
 801e5ee: bf0c         	ite	eq
 801e5f0: 2301         	moveq	r3, #0x1
 801e5f2: 2300         	movne	r3, #0x0
 801e5f4: b2db         	uxtb	r3, r3
; }
 801e5f6: 4618         	mov	r0, r3
 801e5f8: 370c         	adds	r7, #0xc
 801e5fa: 46bd         	mov	sp, r7
 801e5fc: f85d 7b04    	ldr	r7, [sp], #4
 801e600: 4770         	bx	lr

0801e602 <sys_dlist_peek_head>:
; {
 801e602: b580         	push	{r7, lr}
 801e604: b082         	sub	sp, #0x8
 801e606: af00         	add	r7, sp, #0x0
 801e608: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801e60a: 6878         	ldr	r0, [r7, #0x4]
 801e60c: f7ff ffe7    	bl	0x801e5de <sys_dlist_is_empty> @ imm = #-0x32
 801e610: 4603         	mov	r3, r0
 801e612: 2b00         	cmp	r3, #0x0
 801e614: d102         	bne	0x801e61c <sys_dlist_peek_head+0x1a> @ imm = #0x4
 801e616: 687b         	ldr	r3, [r7, #0x4]
 801e618: 681b         	ldr	r3, [r3]
 801e61a: e000         	b	0x801e61e <sys_dlist_peek_head+0x1c> @ imm = #0x0
 801e61c: 2300         	movs	r3, #0x0
; }
 801e61e: 4618         	mov	r0, r3
 801e620: 3708         	adds	r7, #0x8
 801e622: 46bd         	mov	sp, r7
 801e624: bd80         	pop	{r7, pc}

0801e626 <sys_dlist_remove>:
; {
 801e626: b580         	push	{r7, lr}
 801e628: b084         	sub	sp, #0x10
 801e62a: af00         	add	r7, sp, #0x0
 801e62c: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801e62e: 687b         	ldr	r3, [r7, #0x4]
 801e630: 685b         	ldr	r3, [r3, #0x4]
 801e632: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 801e634: 687b         	ldr	r3, [r7, #0x4]
 801e636: 681b         	ldr	r3, [r3]
 801e638: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 801e63a: 68fb         	ldr	r3, [r7, #0xc]
 801e63c: 68ba         	ldr	r2, [r7, #0x8]
 801e63e: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801e640: 68bb         	ldr	r3, [r7, #0x8]
 801e642: 68fa         	ldr	r2, [r7, #0xc]
 801e644: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 801e646: 6878         	ldr	r0, [r7, #0x4]
 801e648: f7ff ffb9    	bl	0x801e5be <sys_dnode_init> @ imm = #-0x8e
; }
 801e64c: bf00         	nop
 801e64e: 3710         	adds	r7, #0x10
 801e650: 46bd         	mov	sp, r7
 801e652: bd80         	pop	{r7, pc}

0801e654 <k_object_init>:
; {
 801e654: b480         	push	{r7}
 801e656: b083         	sub	sp, #0xc
 801e658: af00         	add	r7, sp, #0x0
 801e65a: 6078         	str	r0, [r7, #0x4]
; }
 801e65c: bf00         	nop
 801e65e: 370c         	adds	r7, #0xc
 801e660: 46bd         	mov	sp, r7
 801e662: f85d 7b04    	ldr	r7, [sp], #4
 801e666: 4770         	bx	lr

0801e668 <z_abort_thread_timeout>:
; {
 801e668: b580         	push	{r7, lr}
 801e66a: b082         	sub	sp, #0x8
 801e66c: af00         	add	r7, sp, #0x0
 801e66e: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 801e670: 687b         	ldr	r3, [r7, #0x4]
 801e672: 3318         	adds	r3, #0x18
 801e674: 4618         	mov	r0, r3
 801e676: f7f4 fac3    	bl	0x8012c00 <z_abort_timeout> @ imm = #-0xba7a
 801e67a: 4603         	mov	r3, r0
; }
 801e67c: 4618         	mov	r0, r3
 801e67e: 3708         	adds	r7, #0x8
 801e680: 46bd         	mov	sp, r7
 801e682: bd80         	pop	{r7, pc}

0801e684 <z_waitq_init>:
; {
 801e684: b580         	push	{r7, lr}
 801e686: b082         	sub	sp, #0x8
 801e688: af00         	add	r7, sp, #0x0
 801e68a: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 801e68c: 687b         	ldr	r3, [r7, #0x4]
 801e68e: 4618         	mov	r0, r3
 801e690: f7ff ff85    	bl	0x801e59e <sys_dlist_init> @ imm = #-0xf6
; }
 801e694: bf00         	nop
 801e696: 3708         	adds	r7, #0x8
 801e698: 46bd         	mov	sp, r7
 801e69a: bd80         	pop	{r7, pc}

0801e69c <z_mark_thread_as_not_pending>:
; {
 801e69c: b480         	push	{r7}
 801e69e: b083         	sub	sp, #0xc
 801e6a0: af00         	add	r7, sp, #0x0
 801e6a2: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 801e6a4: 687b         	ldr	r3, [r7, #0x4]
 801e6a6: 7b5b         	ldrb	r3, [r3, #0xd]
 801e6a8: f023 0302    	bic	r3, r3, #0x2
 801e6ac: b2da         	uxtb	r2, r3
 801e6ae: 687b         	ldr	r3, [r7, #0x4]
 801e6b0: 735a         	strb	r2, [r3, #0xd]
; }
 801e6b2: bf00         	nop
 801e6b4: 370c         	adds	r7, #0xc
 801e6b6: 46bd         	mov	sp, r7
 801e6b8: f85d 7b04    	ldr	r7, [sp], #4
 801e6bc: 4770         	bx	lr

0801e6be <unpend_thread_no_timeout>:
; {
 801e6be: b580         	push	{r7, lr}
 801e6c0: b086         	sub	sp, #0x18
 801e6c2: af00         	add	r7, sp, #0x0
 801e6c4: 6078         	str	r0, [r7, #0x4]
 801e6c6: 687b         	ldr	r3, [r7, #0x4]
 801e6c8: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 801e6ca: 68fb         	ldr	r3, [r7, #0xc]
 801e6cc: 689b         	ldr	r3, [r3, #0x8]
 801e6ce: 617b         	str	r3, [r7, #0x14]
 801e6d0: 687b         	ldr	r3, [r7, #0x4]
 801e6d2: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801e6d4: 693b         	ldr	r3, [r7, #0x10]
 801e6d6: 4618         	mov	r0, r3
 801e6d8: f7ff ffa5    	bl	0x801e626 <sys_dlist_remove> @ imm = #-0xb6
; }
 801e6dc: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 801e6de: 6878         	ldr	r0, [r7, #0x4]
 801e6e0: f7ff ffdc    	bl	0x801e69c <z_mark_thread_as_not_pending> @ imm = #-0x48
; 	thread->base.pended_on = NULL;
 801e6e4: 687b         	ldr	r3, [r7, #0x4]
 801e6e6: 2200         	movs	r2, #0x0
 801e6e8: 609a         	str	r2, [r3, #0x8]
; }
 801e6ea: bf00         	nop
 801e6ec: 3718         	adds	r7, #0x18
 801e6ee: 46bd         	mov	sp, r7
 801e6f0: bd80         	pop	{r7, pc}

0801e6f2 <z_impl_k_sem_init>:
; {
 801e6f2: b580         	push	{r7, lr}
 801e6f4: b084         	sub	sp, #0x10
 801e6f6: af00         	add	r7, sp, #0x0
 801e6f8: 60f8         	str	r0, [r7, #0xc]
 801e6fa: 60b9         	str	r1, [r7, #0x8]
 801e6fc: 607a         	str	r2, [r7, #0x4]
; 	CHECKIF(limit == 0U || initial_count > limit) {
 801e6fe: 687b         	ldr	r3, [r7, #0x4]
 801e700: 2b00         	cmp	r3, #0x0
 801e702: d003         	beq	0x801e70c <z_impl_k_sem_init+0x1a> @ imm = #0x6
 801e704: 68ba         	ldr	r2, [r7, #0x8]
 801e706: 687b         	ldr	r3, [r7, #0x4]
 801e708: 429a         	cmp	r2, r3
 801e70a: d902         	bls	0x801e712 <z_impl_k_sem_init+0x20> @ imm = #0x4
; 		return -EINVAL;
 801e70c: f06f 0315    	mvn	r3, #0x15
 801e710: e00d         	b	0x801e72e <z_impl_k_sem_init+0x3c> @ imm = #0x1a
; 	sem->count = initial_count;
 801e712: 68fb         	ldr	r3, [r7, #0xc]
 801e714: 68ba         	ldr	r2, [r7, #0x8]
 801e716: 609a         	str	r2, [r3, #0x8]
; 	sem->limit = limit;
 801e718: 68fb         	ldr	r3, [r7, #0xc]
 801e71a: 687a         	ldr	r2, [r7, #0x4]
 801e71c: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&sem->wait_q);
 801e71e: 68fb         	ldr	r3, [r7, #0xc]
 801e720: 4618         	mov	r0, r3
 801e722: f7ff ffaf    	bl	0x801e684 <z_waitq_init> @ imm = #-0xa2
; 	k_object_init(sem);
 801e726: 68f8         	ldr	r0, [r7, #0xc]
 801e728: f7ff ff94    	bl	0x801e654 <k_object_init> @ imm = #-0xd8
; 	return 0;
 801e72c: 2300         	movs	r3, #0x0
; }
 801e72e: 4618         	mov	r0, r3
 801e730: 3710         	adds	r7, #0x10
 801e732: 46bd         	mov	sp, r7
 801e734: bd80         	pop	{r7, pc}

0801e736 <handle_poll_events>:
; {
 801e736: b480         	push	{r7}
 801e738: b083         	sub	sp, #0xc
 801e73a: af00         	add	r7, sp, #0x0
 801e73c: 6078         	str	r0, [r7, #0x4]
; 	return false;
 801e73e: 2300         	movs	r3, #0x0
; }
 801e740: 4618         	mov	r0, r3
 801e742: 370c         	adds	r7, #0xc
 801e744: 46bd         	mov	sp, r7
 801e746: f85d 7b04    	ldr	r7, [sp], #4
 801e74a: 4770         	bx	lr

0801e74c <sys_dlist_init>:
; {
 801e74c: b480         	push	{r7}
 801e74e: b083         	sub	sp, #0xc
 801e750: af00         	add	r7, sp, #0x0
 801e752: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801e754: 687b         	ldr	r3, [r7, #0x4]
 801e756: 687a         	ldr	r2, [r7, #0x4]
 801e758: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 801e75a: 687b         	ldr	r3, [r7, #0x4]
 801e75c: 687a         	ldr	r2, [r7, #0x4]
 801e75e: 605a         	str	r2, [r3, #0x4]
; }
 801e760: bf00         	nop
 801e762: 370c         	adds	r7, #0xc
 801e764: 46bd         	mov	sp, r7
 801e766: f85d 7b04    	ldr	r7, [sp], #4
 801e76a: 4770         	bx	lr

0801e76c <sys_dnode_init>:
; {
 801e76c: b480         	push	{r7}
 801e76e: b083         	sub	sp, #0xc
 801e770: af00         	add	r7, sp, #0x0
 801e772: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801e774: 687b         	ldr	r3, [r7, #0x4]
 801e776: 2200         	movs	r2, #0x0
 801e778: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801e77a: 687b         	ldr	r3, [r7, #0x4]
 801e77c: 2200         	movs	r2, #0x0
 801e77e: 605a         	str	r2, [r3, #0x4]
; }
 801e780: bf00         	nop
 801e782: 370c         	adds	r7, #0xc
 801e784: 46bd         	mov	sp, r7
 801e786: f85d 7b04    	ldr	r7, [sp], #4
 801e78a: 4770         	bx	lr

0801e78c <sys_slist_init>:
; {
 801e78c: b480         	push	{r7}
 801e78e: b083         	sub	sp, #0xc
 801e790: af00         	add	r7, sp, #0x0
 801e792: 6078         	str	r0, [r7, #0x4]
; 	list->head = NULL;
 801e794: 687b         	ldr	r3, [r7, #0x4]
 801e796: 2200         	movs	r2, #0x0
 801e798: 601a         	str	r2, [r3]
; 	list->tail = NULL;
 801e79a: 687b         	ldr	r3, [r7, #0x4]
 801e79c: 2200         	movs	r2, #0x0
 801e79e: 605a         	str	r2, [r3, #0x4]
; }
 801e7a0: bf00         	nop
 801e7a2: 370c         	adds	r7, #0xc
 801e7a4: 46bd         	mov	sp, r7
 801e7a6: f85d 7b04    	ldr	r7, [sp], #4
 801e7aa: 4770         	bx	lr

0801e7ac <z_snode_next_peek>:
; {
 801e7ac: b480         	push	{r7}
 801e7ae: b083         	sub	sp, #0xc
 801e7b0: af00         	add	r7, sp, #0x0
 801e7b2: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 801e7b4: 687b         	ldr	r3, [r7, #0x4]
 801e7b6: 681b         	ldr	r3, [r3]
; }
 801e7b8: 4618         	mov	r0, r3
 801e7ba: 370c         	adds	r7, #0xc
 801e7bc: 46bd         	mov	sp, r7
 801e7be: f85d 7b04    	ldr	r7, [sp], #4
 801e7c2: 4770         	bx	lr

0801e7c4 <z_snode_next_set>:
; {
 801e7c4: b480         	push	{r7}
 801e7c6: b083         	sub	sp, #0xc
 801e7c8: af00         	add	r7, sp, #0x0
 801e7ca: 6078         	str	r0, [r7, #0x4]
 801e7cc: 6039         	str	r1, [r7]
; 	parent->next = child;
 801e7ce: 687b         	ldr	r3, [r7, #0x4]
 801e7d0: 683a         	ldr	r2, [r7]
 801e7d2: 601a         	str	r2, [r3]
; }
 801e7d4: bf00         	nop
 801e7d6: 370c         	adds	r7, #0xc
 801e7d8: 46bd         	mov	sp, r7
 801e7da: f85d 7b04    	ldr	r7, [sp], #4
 801e7de: 4770         	bx	lr

0801e7e0 <z_slist_head_set>:
; {
 801e7e0: b480         	push	{r7}
 801e7e2: b083         	sub	sp, #0xc
 801e7e4: af00         	add	r7, sp, #0x0
 801e7e6: 6078         	str	r0, [r7, #0x4]
 801e7e8: 6039         	str	r1, [r7]
; 	list->head = node;
 801e7ea: 687b         	ldr	r3, [r7, #0x4]
 801e7ec: 683a         	ldr	r2, [r7]
 801e7ee: 601a         	str	r2, [r3]
; }
 801e7f0: bf00         	nop
 801e7f2: 370c         	adds	r7, #0xc
 801e7f4: 46bd         	mov	sp, r7
 801e7f6: f85d 7b04    	ldr	r7, [sp], #4
 801e7fa: 4770         	bx	lr

0801e7fc <z_slist_tail_set>:
; {
 801e7fc: b480         	push	{r7}
 801e7fe: b083         	sub	sp, #0xc
 801e800: af00         	add	r7, sp, #0x0
 801e802: 6078         	str	r0, [r7, #0x4]
 801e804: 6039         	str	r1, [r7]
; 	list->tail = node;
 801e806: 687b         	ldr	r3, [r7, #0x4]
 801e808: 683a         	ldr	r2, [r7]
 801e80a: 605a         	str	r2, [r3, #0x4]
; }
 801e80c: bf00         	nop
 801e80e: 370c         	adds	r7, #0xc
 801e810: 46bd         	mov	sp, r7
 801e812: f85d 7b04    	ldr	r7, [sp], #4
 801e816: 4770         	bx	lr

0801e818 <sys_slist_peek_head>:
; {
 801e818: b480         	push	{r7}
 801e81a: b083         	sub	sp, #0xc
 801e81c: af00         	add	r7, sp, #0x0
 801e81e: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 801e820: 687b         	ldr	r3, [r7, #0x4]
 801e822: 681b         	ldr	r3, [r3]
; }
 801e824: 4618         	mov	r0, r3
 801e826: 370c         	adds	r7, #0xc
 801e828: 46bd         	mov	sp, r7
 801e82a: f85d 7b04    	ldr	r7, [sp], #4
 801e82e: 4770         	bx	lr

0801e830 <sys_slist_peek_tail>:
; {
 801e830: b480         	push	{r7}
 801e832: b083         	sub	sp, #0xc
 801e834: af00         	add	r7, sp, #0x0
 801e836: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 801e838: 687b         	ldr	r3, [r7, #0x4]
 801e83a: 685b         	ldr	r3, [r3, #0x4]
; }
 801e83c: 4618         	mov	r0, r3
 801e83e: 370c         	adds	r7, #0xc
 801e840: 46bd         	mov	sp, r7
 801e842: f85d 7b04    	ldr	r7, [sp], #4
 801e846: 4770         	bx	lr

0801e848 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 801e848: b580         	push	{r7, lr}
 801e84a: b082         	sub	sp, #0x8
 801e84c: af00         	add	r7, sp, #0x0
 801e84e: 6078         	str	r0, [r7, #0x4]
 801e850: 6878         	ldr	r0, [r7, #0x4]
 801e852: f7ff ffe1    	bl	0x801e818 <sys_slist_peek_head> @ imm = #-0x3e
 801e856: 4603         	mov	r3, r0
 801e858: 2b00         	cmp	r3, #0x0
 801e85a: bf0c         	ite	eq
 801e85c: 2301         	moveq	r3, #0x1
 801e85e: 2300         	movne	r3, #0x0
 801e860: b2db         	uxtb	r3, r3
 801e862: 4618         	mov	r0, r3
 801e864: 3708         	adds	r7, #0x8
 801e866: 46bd         	mov	sp, r7
 801e868: bd80         	pop	{r7, pc}

0801e86a <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 801e86a: b580         	push	{r7, lr}
 801e86c: b082         	sub	sp, #0x8
 801e86e: af00         	add	r7, sp, #0x0
 801e870: 6078         	str	r0, [r7, #0x4]
 801e872: 6878         	ldr	r0, [r7, #0x4]
 801e874: f7ff ff9a    	bl	0x801e7ac <z_snode_next_peek> @ imm = #-0xcc
 801e878: 4603         	mov	r3, r0
 801e87a: 4618         	mov	r0, r3
 801e87c: 3708         	adds	r7, #0x8
 801e87e: 46bd         	mov	sp, r7
 801e880: bd80         	pop	{r7, pc}

0801e882 <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801e882: b580         	push	{r7, lr}
 801e884: b082         	sub	sp, #0x8
 801e886: af00         	add	r7, sp, #0x0
 801e888: 6078         	str	r0, [r7, #0x4]
 801e88a: 687b         	ldr	r3, [r7, #0x4]
 801e88c: 2b00         	cmp	r3, #0x0
 801e88e: d004         	beq	0x801e89a <sys_slist_peek_next+0x18> @ imm = #0x8
 801e890: 6878         	ldr	r0, [r7, #0x4]
 801e892: f7ff ffea    	bl	0x801e86a <sys_slist_peek_next_no_check> @ imm = #-0x2c
 801e896: 4603         	mov	r3, r0
 801e898: e000         	b	0x801e89c <sys_slist_peek_next+0x1a> @ imm = #0x0
 801e89a: 2300         	movs	r3, #0x0
 801e89c: 4618         	mov	r0, r3
 801e89e: 3708         	adds	r7, #0x8
 801e8a0: 46bd         	mov	sp, r7
 801e8a2: bd80         	pop	{r7, pc}

0801e8a4 <sys_slist_append>:
; Z_GENLIST_APPEND(slist, snode)
 801e8a4: b580         	push	{r7, lr}
 801e8a6: b082         	sub	sp, #0x8
 801e8a8: af00         	add	r7, sp, #0x0
 801e8aa: 6078         	str	r0, [r7, #0x4]
 801e8ac: 6039         	str	r1, [r7]
 801e8ae: 2100         	movs	r1, #0x0
 801e8b0: 6838         	ldr	r0, [r7]
 801e8b2: f7ff ff87    	bl	0x801e7c4 <z_snode_next_set> @ imm = #-0xf2
 801e8b6: 6878         	ldr	r0, [r7, #0x4]
 801e8b8: f7ff ffba    	bl	0x801e830 <sys_slist_peek_tail> @ imm = #-0x8c
 801e8bc: 4603         	mov	r3, r0
 801e8be: 2b00         	cmp	r3, #0x0
 801e8c0: d108         	bne	0x801e8d4 <sys_slist_append+0x30> @ imm = #0x10
 801e8c2: 6839         	ldr	r1, [r7]
 801e8c4: 6878         	ldr	r0, [r7, #0x4]
 801e8c6: f7ff ff99    	bl	0x801e7fc <z_slist_tail_set> @ imm = #-0xce
 801e8ca: 6839         	ldr	r1, [r7]
 801e8cc: 6878         	ldr	r0, [r7, #0x4]
 801e8ce: f7ff ff87    	bl	0x801e7e0 <z_slist_head_set> @ imm = #-0xf2
 801e8d2: e00b         	b	0x801e8ec <sys_slist_append+0x48> @ imm = #0x16
 801e8d4: 6878         	ldr	r0, [r7, #0x4]
 801e8d6: f7ff ffab    	bl	0x801e830 <sys_slist_peek_tail> @ imm = #-0xaa
 801e8da: 4603         	mov	r3, r0
 801e8dc: 6839         	ldr	r1, [r7]
 801e8de: 4618         	mov	r0, r3
 801e8e0: f7ff ff70    	bl	0x801e7c4 <z_snode_next_set> @ imm = #-0x120
 801e8e4: 6839         	ldr	r1, [r7]
 801e8e6: 6878         	ldr	r0, [r7, #0x4]
 801e8e8: f7ff ff88    	bl	0x801e7fc <z_slist_tail_set> @ imm = #-0xf0
 801e8ec: 3708         	adds	r7, #0x8
 801e8ee: 46bd         	mov	sp, r7
 801e8f0: bd80         	pop	{r7, pc}

0801e8f2 <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 801e8f2: b580         	push	{r7, lr}
 801e8f4: b084         	sub	sp, #0x10
 801e8f6: af00         	add	r7, sp, #0x0
 801e8f8: 6078         	str	r0, [r7, #0x4]
 801e8fa: 6878         	ldr	r0, [r7, #0x4]
 801e8fc: f7ff ff8c    	bl	0x801e818 <sys_slist_peek_head> @ imm = #-0xe8
 801e900: 60f8         	str	r0, [r7, #0xc]
 801e902: 68f8         	ldr	r0, [r7, #0xc]
 801e904: f7ff ff52    	bl	0x801e7ac <z_snode_next_peek> @ imm = #-0x15c
 801e908: 4603         	mov	r3, r0
 801e90a: 4619         	mov	r1, r3
 801e90c: 6878         	ldr	r0, [r7, #0x4]
 801e90e: f7ff ff67    	bl	0x801e7e0 <z_slist_head_set> @ imm = #-0x132
 801e912: 6878         	ldr	r0, [r7, #0x4]
 801e914: f7ff ff8c    	bl	0x801e830 <sys_slist_peek_tail> @ imm = #-0xe8
 801e918: 4602         	mov	r2, r0
 801e91a: 68fb         	ldr	r3, [r7, #0xc]
 801e91c: 4293         	cmp	r3, r2
 801e91e: d107         	bne	0x801e930 <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 801e920: 6878         	ldr	r0, [r7, #0x4]
 801e922: f7ff ff79    	bl	0x801e818 <sys_slist_peek_head> @ imm = #-0x10e
 801e926: 4603         	mov	r3, r0
 801e928: 4619         	mov	r1, r3
 801e92a: 6878         	ldr	r0, [r7, #0x4]
 801e92c: f7ff ff66    	bl	0x801e7fc <z_slist_tail_set> @ imm = #-0x134
 801e930: 68fb         	ldr	r3, [r7, #0xc]
 801e932: 4618         	mov	r0, r3
 801e934: 3710         	adds	r7, #0x10
 801e936: 46bd         	mov	sp, r7
 801e938: bd80         	pop	{r7, pc}

0801e93a <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 801e93a: b580         	push	{r7, lr}
 801e93c: b082         	sub	sp, #0x8
 801e93e: af00         	add	r7, sp, #0x0
 801e940: 6078         	str	r0, [r7, #0x4]
 801e942: 6878         	ldr	r0, [r7, #0x4]
 801e944: f7ff ff80    	bl	0x801e848 <sys_slist_is_empty> @ imm = #-0x100
 801e948: 4603         	mov	r3, r0
 801e94a: 2b00         	cmp	r3, #0x0
 801e94c: d104         	bne	0x801e958 <sys_slist_get+0x1e> @ imm = #0x8
 801e94e: 6878         	ldr	r0, [r7, #0x4]
 801e950: f7ff ffcf    	bl	0x801e8f2 <sys_slist_get_not_empty> @ imm = #-0x62
 801e954: 4603         	mov	r3, r0
 801e956: e000         	b	0x801e95a <sys_slist_get+0x20> @ imm = #0x0
 801e958: 2300         	movs	r3, #0x0
 801e95a: 4618         	mov	r0, r3
 801e95c: 3708         	adds	r7, #0x8
 801e95e: 46bd         	mov	sp, r7
 801e960: bd80         	pop	{r7, pc}

0801e962 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 801e962: b580         	push	{r7, lr}
 801e964: b084         	sub	sp, #0x10
 801e966: af00         	add	r7, sp, #0x0
 801e968: 60f8         	str	r0, [r7, #0xc]
 801e96a: 60b9         	str	r1, [r7, #0x8]
 801e96c: 607a         	str	r2, [r7, #0x4]
 801e96e: 68bb         	ldr	r3, [r7, #0x8]
 801e970: 2b00         	cmp	r3, #0x0
 801e972: d117         	bne	0x801e9a4 <sys_slist_remove+0x42> @ imm = #0x2e
 801e974: 6878         	ldr	r0, [r7, #0x4]
 801e976: f7ff ff19    	bl	0x801e7ac <z_snode_next_peek> @ imm = #-0x1ce
 801e97a: 4603         	mov	r3, r0
 801e97c: 4619         	mov	r1, r3
 801e97e: 68f8         	ldr	r0, [r7, #0xc]
 801e980: f7ff ff2e    	bl	0x801e7e0 <z_slist_head_set> @ imm = #-0x1a4
 801e984: 68f8         	ldr	r0, [r7, #0xc]
 801e986: f7ff ff53    	bl	0x801e830 <sys_slist_peek_tail> @ imm = #-0x15a
 801e98a: 4602         	mov	r2, r0
 801e98c: 687b         	ldr	r3, [r7, #0x4]
 801e98e: 4293         	cmp	r3, r2
 801e990: d11b         	bne	0x801e9ca <sys_slist_remove+0x68> @ imm = #0x36
 801e992: 68f8         	ldr	r0, [r7, #0xc]
 801e994: f7ff ff40    	bl	0x801e818 <sys_slist_peek_head> @ imm = #-0x180
 801e998: 4603         	mov	r3, r0
 801e99a: 4619         	mov	r1, r3
 801e99c: 68f8         	ldr	r0, [r7, #0xc]
 801e99e: f7ff ff2d    	bl	0x801e7fc <z_slist_tail_set> @ imm = #-0x1a6
 801e9a2: e012         	b	0x801e9ca <sys_slist_remove+0x68> @ imm = #0x24
 801e9a4: 6878         	ldr	r0, [r7, #0x4]
 801e9a6: f7ff ff01    	bl	0x801e7ac <z_snode_next_peek> @ imm = #-0x1fe
 801e9aa: 4603         	mov	r3, r0
 801e9ac: 4619         	mov	r1, r3
 801e9ae: 68b8         	ldr	r0, [r7, #0x8]
 801e9b0: f7ff ff08    	bl	0x801e7c4 <z_snode_next_set> @ imm = #-0x1f0
 801e9b4: 68f8         	ldr	r0, [r7, #0xc]
 801e9b6: f7ff ff3b    	bl	0x801e830 <sys_slist_peek_tail> @ imm = #-0x18a
 801e9ba: 4602         	mov	r2, r0
 801e9bc: 687b         	ldr	r3, [r7, #0x4]
 801e9be: 4293         	cmp	r3, r2
 801e9c0: d103         	bne	0x801e9ca <sys_slist_remove+0x68> @ imm = #0x6
 801e9c2: 68b9         	ldr	r1, [r7, #0x8]
 801e9c4: 68f8         	ldr	r0, [r7, #0xc]
 801e9c6: f7ff ff19    	bl	0x801e7fc <z_slist_tail_set> @ imm = #-0x1ce
 801e9ca: 2100         	movs	r1, #0x0
 801e9cc: 6878         	ldr	r0, [r7, #0x4]
 801e9ce: f7ff fef9    	bl	0x801e7c4 <z_snode_next_set> @ imm = #-0x20e
 801e9d2: 3710         	adds	r7, #0x10
 801e9d4: 46bd         	mov	sp, r7
 801e9d6: bd80         	pop	{r7, pc}

0801e9d8 <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 801e9d8: b580         	push	{r7, lr}
 801e9da: b084         	sub	sp, #0x10
 801e9dc: af00         	add	r7, sp, #0x0
 801e9de: 6078         	str	r0, [r7, #0x4]
 801e9e0: 6039         	str	r1, [r7]
 801e9e2: 2300         	movs	r3, #0x0
 801e9e4: 60fb         	str	r3, [r7, #0xc]
 801e9e6: 6878         	ldr	r0, [r7, #0x4]
 801e9e8: f7ff ff16    	bl	0x801e818 <sys_slist_peek_head> @ imm = #-0x1d4
 801e9ec: 60b8         	str	r0, [r7, #0x8]
 801e9ee: e010         	b	0x801ea12 <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 801e9f0: 68ba         	ldr	r2, [r7, #0x8]
 801e9f2: 683b         	ldr	r3, [r7]
 801e9f4: 429a         	cmp	r2, r3
 801e9f6: d106         	bne	0x801ea06 <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 801e9f8: 683a         	ldr	r2, [r7]
 801e9fa: 68f9         	ldr	r1, [r7, #0xc]
 801e9fc: 6878         	ldr	r0, [r7, #0x4]
 801e9fe: f7ff ffb0    	bl	0x801e962 <sys_slist_remove> @ imm = #-0xa0
 801ea02: 2301         	movs	r3, #0x1
 801ea04: e009         	b	0x801ea1a <sys_slist_find_and_remove+0x42> @ imm = #0x12
 801ea06: 68bb         	ldr	r3, [r7, #0x8]
 801ea08: 60fb         	str	r3, [r7, #0xc]
 801ea0a: 68b8         	ldr	r0, [r7, #0x8]
 801ea0c: f7ff ff39    	bl	0x801e882 <sys_slist_peek_next> @ imm = #-0x18e
 801ea10: 60b8         	str	r0, [r7, #0x8]
 801ea12: 68bb         	ldr	r3, [r7, #0x8]
 801ea14: 2b00         	cmp	r3, #0x0
 801ea16: d1eb         	bne	0x801e9f0 <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 801ea18: 2300         	movs	r3, #0x0
 801ea1a: 4618         	mov	r0, r3
 801ea1c: 3710         	adds	r7, #0x10
 801ea1e: 46bd         	mov	sp, r7
 801ea20: bd80         	pop	{r7, pc}

0801ea22 <k_thread_start>:
; {
 801ea22: b580         	push	{r7, lr}
 801ea24: b082         	sub	sp, #0x8
 801ea26: af00         	add	r7, sp, #0x0
 801ea28: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 801ea2a: 6878         	ldr	r0, [r7, #0x4]
 801ea2c: f000 f82a    	bl	0x801ea84 <k_thread_resume> @ imm = #0x54
; }
 801ea30: bf00         	nop
 801ea32: 3708         	adds	r7, #0x8
 801ea34: 46bd         	mov	sp, r7
 801ea36: bd80         	pop	{r7, pc}

0801ea38 <k_thread_create>:
; {
 801ea38: b580         	push	{r7, lr}
 801ea3a: b08c         	sub	sp, #0x30
 801ea3c: af08         	add	r7, sp, #0x20
 801ea3e: 60f8         	str	r0, [r7, #0xc]
 801ea40: 60b9         	str	r1, [r7, #0x8]
 801ea42: 607a         	str	r2, [r7, #0x4]
 801ea44: 603b         	str	r3, [r7]
; 	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 801ea46: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801ea4a: e9cd 2306    	strd	r2, r3, [sp, #24]
 801ea4e: 6abb         	ldr	r3, [r7, #0x28]
 801ea50: 9304         	str	r3, [sp, #0x10]
 801ea52: 6a7b         	ldr	r3, [r7, #0x24]
 801ea54: 9303         	str	r3, [sp, #0xc]
 801ea56: 6a3b         	ldr	r3, [r7, #0x20]
 801ea58: 9302         	str	r3, [sp, #0x8]
 801ea5a: 69fb         	ldr	r3, [r7, #0x1c]
 801ea5c: 9301         	str	r3, [sp, #0x4]
 801ea5e: 69bb         	ldr	r3, [r7, #0x18]
 801ea60: 9300         	str	r3, [sp]
 801ea62: 683b         	ldr	r3, [r7]
 801ea64: 687a         	ldr	r2, [r7, #0x4]
 801ea66: 68b9         	ldr	r1, [r7, #0x8]
 801ea68: 68f8         	ldr	r0, [r7, #0xc]
 801ea6a: f000 fab9    	bl	0x801efe0 <z_impl_k_thread_create> @ imm = #0x572
 801ea6e: 4603         	mov	r3, r0
; }
 801ea70: 4618         	mov	r0, r3
 801ea72: 3710         	adds	r7, #0x10
 801ea74: 46bd         	mov	sp, r7
 801ea76: bd80         	pop	{r7, pc}

0801ea78 <k_yield>:
; {
 801ea78: b580         	push	{r7, lr}
 801ea7a: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 801ea7c: f7f3 f9da    	bl	0x8011e34 <z_impl_k_yield> @ imm = #-0xcc4c
; }
 801ea80: bf00         	nop
 801ea82: bd80         	pop	{r7, pc}

0801ea84 <k_thread_resume>:
; {
 801ea84: b580         	push	{r7, lr}
 801ea86: b082         	sub	sp, #0x8
 801ea88: af00         	add	r7, sp, #0x0
 801ea8a: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 801ea8c: 6878         	ldr	r0, [r7, #0x4]
 801ea8e: f7f2 fda9    	bl	0x80115e4 <z_impl_k_thread_resume> @ imm = #-0xd4ae
; }
 801ea92: bf00         	nop
 801ea94: 3708         	adds	r7, #0x8
 801ea96: 46bd         	mov	sp, r7
 801ea98: bd80         	pop	{r7, pc}

0801ea9a <k_thread_name_set>:
; {
 801ea9a: b580         	push	{r7, lr}
 801ea9c: b082         	sub	sp, #0x8
 801ea9e: af00         	add	r7, sp, #0x0
 801eaa0: 6078         	str	r0, [r7, #0x4]
 801eaa2: 6039         	str	r1, [r7]
; 	return z_impl_k_thread_name_set(thread, str);
 801eaa4: 6839         	ldr	r1, [r7]
 801eaa6: 6878         	ldr	r0, [r7, #0x4]
 801eaa8: f7f1 ffe8    	bl	0x8010a7c <z_impl_k_thread_name_set> @ imm = #-0xe030
 801eaac: 4603         	mov	r3, r0
; }
 801eaae: 4618         	mov	r0, r3
 801eab0: 3708         	adds	r7, #0x8
 801eab2: 46bd         	mov	sp, r7
 801eab4: bd80         	pop	{r7, pc}

0801eab6 <k_sem_give>:
; {
 801eab6: b580         	push	{r7, lr}
 801eab8: b082         	sub	sp, #0x8
 801eaba: af00         	add	r7, sp, #0x0
 801eabc: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 801eabe: 6878         	ldr	r0, [r7, #0x4]
 801eac0: f7f1 fb7c    	bl	0x80101bc <z_impl_k_sem_give> @ imm = #-0xe908
; }
 801eac4: bf00         	nop
 801eac6: 3708         	adds	r7, #0x8
 801eac8: 46bd         	mov	sp, r7
 801eaca: bd80         	pop	{r7, pc}

0801eacc <z_init_timeout>:
; {
 801eacc: b580         	push	{r7, lr}
 801eace: b082         	sub	sp, #0x8
 801ead0: af00         	add	r7, sp, #0x0
 801ead2: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 801ead4: 687b         	ldr	r3, [r7, #0x4]
 801ead6: 4618         	mov	r0, r3
 801ead8: f7ff fe48    	bl	0x801e76c <sys_dnode_init> @ imm = #-0x370
; }
 801eadc: bf00         	nop
 801eade: 3708         	adds	r7, #0x8
 801eae0: 46bd         	mov	sp, r7
 801eae2: bd80         	pop	{r7, pc}

0801eae4 <z_waitq_init>:
; {
 801eae4: b580         	push	{r7, lr}
 801eae6: b082         	sub	sp, #0x8
 801eae8: af00         	add	r7, sp, #0x0
 801eaea: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 801eaec: 687b         	ldr	r3, [r7, #0x4]
 801eaee: 4618         	mov	r0, r3
 801eaf0: f7ff fe2c    	bl	0x801e74c <sys_dlist_init> @ imm = #-0x3a8
; }
 801eaf4: bf00         	nop
 801eaf6: 3708         	adds	r7, #0x8
 801eaf8: 46bd         	mov	sp, r7
 801eafa: bd80         	pop	{r7, pc}

0801eafc <z_sched_wake_all>:
; {
 801eafc: b580         	push	{r7, lr}
 801eafe: b086         	sub	sp, #0x18
 801eb00: af00         	add	r7, sp, #0x0
 801eb02: 60f8         	str	r0, [r7, #0xc]
 801eb04: 60b9         	str	r1, [r7, #0x8]
 801eb06: 607a         	str	r2, [r7, #0x4]
; 	bool woken = false;
 801eb08: 2300         	movs	r3, #0x0
 801eb0a: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 801eb0c: e001         	b	0x801eb12 <z_sched_wake_all+0x16> @ imm = #0x2
; 		woken = true;
 801eb0e: 2301         	movs	r3, #0x1
 801eb10: 75fb         	strb	r3, [r7, #0x17]
; 	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
 801eb12: 687a         	ldr	r2, [r7, #0x4]
 801eb14: 68b9         	ldr	r1, [r7, #0x8]
 801eb16: 68f8         	ldr	r0, [r7, #0xc]
 801eb18: f7f3 fcfc    	bl	0x8012514 <z_sched_wake> @ imm = #-0xc608
 801eb1c: 4603         	mov	r3, r0
 801eb1e: 2b00         	cmp	r3, #0x0
 801eb20: d1f5         	bne	0x801eb0e <z_sched_wake_all+0x12> @ imm = #-0x16
; 	return woken;
 801eb22: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 801eb24: 4618         	mov	r0, r3
 801eb26: 3718         	adds	r7, #0x18
 801eb28: 46bd         	mov	sp, r7
 801eb2a: bd80         	pop	{r7, pc}

0801eb2c <flag_clear>:
; {
 801eb2c: b480         	push	{r7}
 801eb2e: b083         	sub	sp, #0xc
 801eb30: af00         	add	r7, sp, #0x0
 801eb32: 6078         	str	r0, [r7, #0x4]
 801eb34: 6039         	str	r1, [r7]
; 	*flagp &= ~BIT(bit);
 801eb36: 687b         	ldr	r3, [r7, #0x4]
 801eb38: 681a         	ldr	r2, [r3]
 801eb3a: 2101         	movs	r1, #0x1
 801eb3c: 683b         	ldr	r3, [r7]
 801eb3e: fa01 f303    	lsl.w	r3, r1, r3
 801eb42: 43db         	mvns	r3, r3
 801eb44: 401a         	ands	r2, r3
 801eb46: 687b         	ldr	r3, [r7, #0x4]
 801eb48: 601a         	str	r2, [r3]
; }
 801eb4a: bf00         	nop
 801eb4c: 370c         	adds	r7, #0xc
 801eb4e: 46bd         	mov	sp, r7
 801eb50: f85d 7b04    	ldr	r7, [sp], #4
 801eb54: 4770         	bx	lr

0801eb56 <flag_set>:
; {
 801eb56: b480         	push	{r7}
 801eb58: b083         	sub	sp, #0xc
 801eb5a: af00         	add	r7, sp, #0x0
 801eb5c: 6078         	str	r0, [r7, #0x4]
 801eb5e: 6039         	str	r1, [r7]
; 	*flagp |= BIT(bit);
 801eb60: 687b         	ldr	r3, [r7, #0x4]
 801eb62: 681a         	ldr	r2, [r3]
 801eb64: 2101         	movs	r1, #0x1
 801eb66: 683b         	ldr	r3, [r7]
 801eb68: fa01 f303    	lsl.w	r3, r1, r3
 801eb6c: 431a         	orrs	r2, r3
 801eb6e: 687b         	ldr	r3, [r7, #0x4]
 801eb70: 601a         	str	r2, [r3]
; }
 801eb72: bf00         	nop
 801eb74: 370c         	adds	r7, #0xc
 801eb76: 46bd         	mov	sp, r7
 801eb78: f85d 7b04    	ldr	r7, [sp], #4
 801eb7c: 4770         	bx	lr

0801eb7e <flag_test>:
; {
 801eb7e: b480         	push	{r7}
 801eb80: b083         	sub	sp, #0xc
 801eb82: af00         	add	r7, sp, #0x0
 801eb84: 6078         	str	r0, [r7, #0x4]
 801eb86: 6039         	str	r1, [r7]
; 	return (*flagp & BIT(bit)) != 0U;
 801eb88: 687b         	ldr	r3, [r7, #0x4]
 801eb8a: 681a         	ldr	r2, [r3]
 801eb8c: 683b         	ldr	r3, [r7]
 801eb8e: fa22 f303    	lsr.w	r3, r2, r3
 801eb92: f003 0301    	and	r3, r3, #0x1
 801eb96: 2b00         	cmp	r3, #0x0
 801eb98: bf14         	ite	ne
 801eb9a: 2301         	movne	r3, #0x1
 801eb9c: 2300         	moveq	r3, #0x0
 801eb9e: b2db         	uxtb	r3, r3
; }
 801eba0: 4618         	mov	r0, r3
 801eba2: 370c         	adds	r7, #0xc
 801eba4: 46bd         	mov	sp, r7
 801eba6: f85d 7b04    	ldr	r7, [sp], #4
 801ebaa: 4770         	bx	lr

0801ebac <flag_test_and_clear>:
; {
 801ebac: b580         	push	{r7, lr}
 801ebae: b084         	sub	sp, #0x10
 801ebb0: af00         	add	r7, sp, #0x0
 801ebb2: 6078         	str	r0, [r7, #0x4]
 801ebb4: 6039         	str	r1, [r7]
; 	bool ret = flag_test(flagp, bit);
 801ebb6: 683b         	ldr	r3, [r7]
 801ebb8: 4619         	mov	r1, r3
 801ebba: 6878         	ldr	r0, [r7, #0x4]
 801ebbc: f7ff ffdf    	bl	0x801eb7e <flag_test>   @ imm = #-0x42
 801ebc0: 4603         	mov	r3, r0
 801ebc2: 73fb         	strb	r3, [r7, #0xf]
; 	flag_clear(flagp, bit);
 801ebc4: 683b         	ldr	r3, [r7]
 801ebc6: 4619         	mov	r1, r3
 801ebc8: 6878         	ldr	r0, [r7, #0x4]
 801ebca: f7ff ffaf    	bl	0x801eb2c <flag_clear>  @ imm = #-0xa2
; 	return ret;
 801ebce: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 801ebd0: 4618         	mov	r0, r3
 801ebd2: 3710         	adds	r7, #0x10
 801ebd4: 46bd         	mov	sp, r7
 801ebd6: bd80         	pop	{r7, pc}

0801ebd8 <flags_set>:
; {
 801ebd8: b480         	push	{r7}
 801ebda: b083         	sub	sp, #0xc
 801ebdc: af00         	add	r7, sp, #0x0
 801ebde: 6078         	str	r0, [r7, #0x4]
 801ebe0: 6039         	str	r1, [r7]
; 	*flagp = flags;
 801ebe2: 687b         	ldr	r3, [r7, #0x4]
 801ebe4: 683a         	ldr	r2, [r7]
 801ebe6: 601a         	str	r2, [r3]
; }
 801ebe8: bf00         	nop
 801ebea: 370c         	adds	r7, #0xc
 801ebec: 46bd         	mov	sp, r7
 801ebee: f85d 7b04    	ldr	r7, [sp], #4
 801ebf2: 4770         	bx	lr

0801ebf4 <flags_get>:
; {
 801ebf4: b480         	push	{r7}
 801ebf6: b083         	sub	sp, #0xc
 801ebf8: af00         	add	r7, sp, #0x0
 801ebfa: 6078         	str	r0, [r7, #0x4]
; 	return *flagp;
 801ebfc: 687b         	ldr	r3, [r7, #0x4]
 801ebfe: 681b         	ldr	r3, [r3]
; }
 801ec00: 4618         	mov	r0, r3
 801ec02: 370c         	adds	r7, #0xc
 801ec04: 46bd         	mov	sp, r7
 801ec06: f85d 7b04    	ldr	r7, [sp], #4
 801ec0a: 4770         	bx	lr

0801ec0c <finalize_flush_locked>:
; {
 801ec0c: b580         	push	{r7, lr}
 801ec0e: b084         	sub	sp, #0x10
 801ec10: af00         	add	r7, sp, #0x0
 801ec12: 6078         	str	r0, [r7, #0x4]
; 	struct z_work_flusher *flusher = CONTAINER_OF(work, struct z_work_flusher, work);
 801ec14: 687b         	ldr	r3, [r7, #0x4]
 801ec16: 60fb         	str	r3, [r7, #0xc]
; 	flag_clear(&work->flags, K_WORK_FLUSHING_BIT);
 801ec18: 687b         	ldr	r3, [r7, #0x4]
 801ec1a: 330c         	adds	r3, #0xc
 801ec1c: 2104         	movs	r1, #0x4
 801ec1e: 4618         	mov	r0, r3
 801ec20: f7ff ff84    	bl	0x801eb2c <flag_clear>  @ imm = #-0xf8
; 	k_sem_give(&flusher->sem);
 801ec24: 68fb         	ldr	r3, [r7, #0xc]
 801ec26: 3310         	adds	r3, #0x10
 801ec28: 4618         	mov	r0, r3
 801ec2a: f7ff ff44    	bl	0x801eab6 <k_sem_give>  @ imm = #-0x178
; };
 801ec2e: bf00         	nop
 801ec30: 3710         	adds	r7, #0x10
 801ec32: 46bd         	mov	sp, r7
 801ec34: bd80         	pop	{r7, pc}

0801ec36 <work_busy_get_locked>:
; {
 801ec36: b580         	push	{r7, lr}
 801ec38: b082         	sub	sp, #0x8
 801ec3a: af00         	add	r7, sp, #0x0
 801ec3c: 6078         	str	r0, [r7, #0x4]
; 	return flags_get(&work->flags) & K_WORK_MASK;
 801ec3e: 687b         	ldr	r3, [r7, #0x4]
 801ec40: 330c         	adds	r3, #0xc
 801ec42: 4618         	mov	r0, r3
 801ec44: f7ff ffd6    	bl	0x801ebf4 <flags_get>   @ imm = #-0x54
 801ec48: 4603         	mov	r3, r0
 801ec4a: f003 031f    	and	r3, r3, #0x1f
; }
 801ec4e: 4618         	mov	r0, r3
 801ec50: 3708         	adds	r7, #0x8
 801ec52: 46bd         	mov	sp, r7
 801ec54: bd80         	pop	{r7, pc}

0801ec56 <queue_remove_locked>:
; {
 801ec56: b580         	push	{r7, lr}
 801ec58: b082         	sub	sp, #0x8
 801ec5a: af00         	add	r7, sp, #0x0
 801ec5c: 6078         	str	r0, [r7, #0x4]
 801ec5e: 6039         	str	r1, [r7]
; 	if (flag_test_and_clear(&work->flags, K_WORK_QUEUED_BIT)) {
 801ec60: 683b         	ldr	r3, [r7]
 801ec62: 330c         	adds	r3, #0xc
 801ec64: 2102         	movs	r1, #0x2
 801ec66: 4618         	mov	r0, r3
 801ec68: f7ff ffa0    	bl	0x801ebac <flag_test_and_clear> @ imm = #-0xc0
 801ec6c: 4603         	mov	r3, r0
 801ec6e: 2b00         	cmp	r3, #0x0
 801ec70: d007         	beq	0x801ec82 <queue_remove_locked+0x2c> @ imm = #0xe
; 		(void)sys_slist_find_and_remove(&queue->pending, &work->node);
 801ec72: 687b         	ldr	r3, [r7, #0x4]
 801ec74: f503 738c    	add.w	r3, r3, #0x118
 801ec78: 683a         	ldr	r2, [r7]
 801ec7a: 4611         	mov	r1, r2
 801ec7c: 4618         	mov	r0, r3
 801ec7e: f7ff feab    	bl	0x801e9d8 <sys_slist_find_and_remove> @ imm = #-0x2aa
; }
 801ec82: bf00         	nop
 801ec84: 3708         	adds	r7, #0x8
 801ec86: 46bd         	mov	sp, r7
 801ec88: bd80         	pop	{r7, pc}

0801ec8a <notify_queue_locked>:
; {
 801ec8a: b580         	push	{r7, lr}
 801ec8c: b084         	sub	sp, #0x10
 801ec8e: af00         	add	r7, sp, #0x0
 801ec90: 6078         	str	r0, [r7, #0x4]
; 	bool rv = false;
 801ec92: 2300         	movs	r3, #0x0
 801ec94: 73fb         	strb	r3, [r7, #0xf]
; 	if (queue != NULL) {
 801ec96: 687b         	ldr	r3, [r7, #0x4]
 801ec98: 2b00         	cmp	r3, #0x0
 801ec9a: d009         	beq	0x801ecb0 <notify_queue_locked+0x26> @ imm = #0x12
; 		rv = z_sched_wake(&queue->notifyq, 0, NULL);
 801ec9c: 687b         	ldr	r3, [r7, #0x4]
 801ec9e: f503 7390    	add.w	r3, r3, #0x120
 801eca2: 2200         	movs	r2, #0x0
 801eca4: 2100         	movs	r1, #0x0
 801eca6: 4618         	mov	r0, r3
 801eca8: f7f3 fc34    	bl	0x8012514 <z_sched_wake> @ imm = #-0xc798
 801ecac: 4603         	mov	r3, r0
 801ecae: 73fb         	strb	r3, [r7, #0xf]
; 	return rv;
 801ecb0: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 801ecb2: 4618         	mov	r0, r3
 801ecb4: 3710         	adds	r7, #0x10
 801ecb6: 46bd         	mov	sp, r7
 801ecb8: bd80         	pop	{r7, pc}

0801ecba <submit_to_queue_locked>:
; {
 801ecba: b580         	push	{r7, lr}
 801ecbc: b084         	sub	sp, #0x10
 801ecbe: af00         	add	r7, sp, #0x0
 801ecc0: 6078         	str	r0, [r7, #0x4]
 801ecc2: 6039         	str	r1, [r7]
; 	int ret = 0;
 801ecc4: 2300         	movs	r3, #0x0
 801ecc6: 60fb         	str	r3, [r7, #0xc]
; 	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 801ecc8: 687b         	ldr	r3, [r7, #0x4]
 801ecca: 330c         	adds	r3, #0xc
 801eccc: 2101         	movs	r1, #0x1
 801ecce: 4618         	mov	r0, r3
 801ecd0: f7ff ff55    	bl	0x801eb7e <flag_test>   @ imm = #-0x156
 801ecd4: 4603         	mov	r3, r0
 801ecd6: 2b00         	cmp	r3, #0x0
 801ecd8: d003         	beq	0x801ece2 <submit_to_queue_locked+0x28> @ imm = #0x6
; 		ret = -EBUSY;
 801ecda: f06f 030f    	mvn	r3, #0xf
 801ecde: 60fb         	str	r3, [r7, #0xc]
 801ece0: e03b         	b	0x801ed5a <submit_to_queue_locked+0xa0> @ imm = #0x76
; 	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
 801ece2: 687b         	ldr	r3, [r7, #0x4]
 801ece4: 330c         	adds	r3, #0xc
 801ece6: 2102         	movs	r1, #0x2
 801ece8: 4618         	mov	r0, r3
 801ecea: f7ff ff48    	bl	0x801eb7e <flag_test>   @ imm = #-0x170
 801ecee: 4603         	mov	r3, r0
 801ecf0: f083 0301    	eor	r3, r3, #0x1
 801ecf4: b2db         	uxtb	r3, r3
 801ecf6: 2b00         	cmp	r3, #0x0
 801ecf8: d02f         	beq	0x801ed5a <submit_to_queue_locked+0xa0> @ imm = #0x5e
; 		ret = 1;
 801ecfa: 2301         	movs	r3, #0x1
 801ecfc: 60fb         	str	r3, [r7, #0xc]
; 		if (*queuep == NULL) {
 801ecfe: 683b         	ldr	r3, [r7]
 801ed00: 681b         	ldr	r3, [r3]
 801ed02: 2b00         	cmp	r3, #0x0
 801ed04: d103         	bne	0x801ed0e <submit_to_queue_locked+0x54> @ imm = #0x6
; 			*queuep = work->queue;
 801ed06: 687b         	ldr	r3, [r7, #0x4]
 801ed08: 689a         	ldr	r2, [r3, #0x8]
 801ed0a: 683b         	ldr	r3, [r7]
 801ed0c: 601a         	str	r2, [r3]
; 		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
 801ed0e: 687b         	ldr	r3, [r7, #0x4]
 801ed10: 330c         	adds	r3, #0xc
 801ed12: 2100         	movs	r1, #0x0
 801ed14: 4618         	mov	r0, r3
 801ed16: f7ff ff32    	bl	0x801eb7e <flag_test>   @ imm = #-0x19c
 801ed1a: 4603         	mov	r3, r0
 801ed1c: 2b00         	cmp	r3, #0x0
 801ed1e: d005         	beq	0x801ed2c <submit_to_queue_locked+0x72> @ imm = #0xa
; 			*queuep = work->queue;
 801ed20: 687b         	ldr	r3, [r7, #0x4]
 801ed22: 689a         	ldr	r2, [r3, #0x8]
 801ed24: 683b         	ldr	r3, [r7]
 801ed26: 601a         	str	r2, [r3]
; 			ret = 2;
 801ed28: 2302         	movs	r3, #0x2
 801ed2a: 60fb         	str	r3, [r7, #0xc]
; 		int rc = queue_submit_locked(*queuep, work);
 801ed2c: 683b         	ldr	r3, [r7]
 801ed2e: 681b         	ldr	r3, [r3]
 801ed30: 6879         	ldr	r1, [r7, #0x4]
 801ed32: 4618         	mov	r0, r3
 801ed34: f7f1 fba6    	bl	0x8010484 <queue_submit_locked> @ imm = #-0xe8b4
 801ed38: 60b8         	str	r0, [r7, #0x8]
; 		if (rc < 0) {
 801ed3a: 68bb         	ldr	r3, [r7, #0x8]
 801ed3c: 2b00         	cmp	r3, #0x0
 801ed3e: da02         	bge	0x801ed46 <submit_to_queue_locked+0x8c> @ imm = #0x4
; 			ret = rc;
 801ed40: 68bb         	ldr	r3, [r7, #0x8]
 801ed42: 60fb         	str	r3, [r7, #0xc]
 801ed44: e009         	b	0x801ed5a <submit_to_queue_locked+0xa0> @ imm = #0x12
; 			flag_set(&work->flags, K_WORK_QUEUED_BIT);
 801ed46: 687b         	ldr	r3, [r7, #0x4]
 801ed48: 330c         	adds	r3, #0xc
 801ed4a: 2102         	movs	r1, #0x2
 801ed4c: 4618         	mov	r0, r3
 801ed4e: f7ff ff02    	bl	0x801eb56 <flag_set>    @ imm = #-0x1fc
; 			work->queue = *queuep;
 801ed52: 683b         	ldr	r3, [r7]
 801ed54: 681a         	ldr	r2, [r3]
 801ed56: 687b         	ldr	r3, [r7, #0x4]
 801ed58: 609a         	str	r2, [r3, #0x8]
; 	if (ret <= 0) {
 801ed5a: 68fb         	ldr	r3, [r7, #0xc]
 801ed5c: 2b00         	cmp	r3, #0x0
 801ed5e: dc02         	bgt	0x801ed66 <submit_to_queue_locked+0xac> @ imm = #0x4
; 		*queuep = NULL;
 801ed60: 683b         	ldr	r3, [r7]
 801ed62: 2200         	movs	r2, #0x0
 801ed64: 601a         	str	r2, [r3]
; 	return ret;
 801ed66: 68fb         	ldr	r3, [r7, #0xc]
; }
 801ed68: 4618         	mov	r0, r3
 801ed6a: 3710         	adds	r7, #0x10
 801ed6c: 46bd         	mov	sp, r7
 801ed6e: bd80         	pop	{r7, pc}

0801ed70 <cancel_async_locked>:
; {
 801ed70: b580         	push	{r7, lr}
 801ed72: b084         	sub	sp, #0x10
 801ed74: af00         	add	r7, sp, #0x0
 801ed76: 6078         	str	r0, [r7, #0x4]
; 	if (!flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
 801ed78: 687b         	ldr	r3, [r7, #0x4]
 801ed7a: 330c         	adds	r3, #0xc
 801ed7c: 2101         	movs	r1, #0x1
 801ed7e: 4618         	mov	r0, r3
 801ed80: f7ff fefd    	bl	0x801eb7e <flag_test>   @ imm = #-0x206
 801ed84: 4603         	mov	r3, r0
 801ed86: f083 0301    	eor	r3, r3, #0x1
 801ed8a: b2db         	uxtb	r3, r3
 801ed8c: 2b00         	cmp	r3, #0x0
 801ed8e: d005         	beq	0x801ed9c <cancel_async_locked+0x2c> @ imm = #0xa
; 		queue_remove_locked(work->queue, work);
 801ed90: 687b         	ldr	r3, [r7, #0x4]
 801ed92: 689b         	ldr	r3, [r3, #0x8]
 801ed94: 6879         	ldr	r1, [r7, #0x4]
 801ed96: 4618         	mov	r0, r3
 801ed98: f7ff ff5d    	bl	0x801ec56 <queue_remove_locked> @ imm = #-0x146
; 	int ret = work_busy_get_locked(work);
 801ed9c: 6878         	ldr	r0, [r7, #0x4]
 801ed9e: f7ff ff4a    	bl	0x801ec36 <work_busy_get_locked> @ imm = #-0x16c
 801eda2: 60f8         	str	r0, [r7, #0xc]
; 	if (ret != 0) {
 801eda4: 68fb         	ldr	r3, [r7, #0xc]
 801eda6: 2b00         	cmp	r3, #0x0
 801eda8: d009         	beq	0x801edbe <cancel_async_locked+0x4e> @ imm = #0x12
; 		flag_set(&work->flags, K_WORK_CANCELING_BIT);
 801edaa: 687b         	ldr	r3, [r7, #0x4]
 801edac: 330c         	adds	r3, #0xc
 801edae: 2101         	movs	r1, #0x1
 801edb0: 4618         	mov	r0, r3
 801edb2: f7ff fed0    	bl	0x801eb56 <flag_set>    @ imm = #-0x260
; 		ret = work_busy_get_locked(work);
 801edb6: 6878         	ldr	r0, [r7, #0x4]
 801edb8: f7ff ff3d    	bl	0x801ec36 <work_busy_get_locked> @ imm = #-0x186
 801edbc: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 801edbe: 68fb         	ldr	r3, [r7, #0xc]
; }
 801edc0: 4618         	mov	r0, r3
 801edc2: 3710         	adds	r7, #0x10
 801edc4: 46bd         	mov	sp, r7
 801edc6: bd80         	pop	{r7, pc}

0801edc8 <k_work_init_delayable>:
; {
 801edc8: b580         	push	{r7, lr}
 801edca: b08e         	sub	sp, #0x38
 801edcc: af00         	add	r7, sp, #0x0
 801edce: 6078         	str	r0, [r7, #0x4]
 801edd0: 6039         	str	r1, [r7]
; 	*dwork = (struct k_work_delayable){
 801edd2: 687b         	ldr	r3, [r7, #0x4]
 801edd4: 4618         	mov	r0, r3
 801edd6: 2330         	movs	r3, #0x30
 801edd8: 461a         	mov	r2, r3
 801edda: 2100         	movs	r1, #0x0
 801eddc: f000 ff7c    	bl	0x801fcd8 <memset>      @ imm = #0xef8
 801ede0: 687b         	ldr	r3, [r7, #0x4]
 801ede2: 683a         	ldr	r2, [r7]
 801ede4: 605a         	str	r2, [r3, #0x4]
 801ede6: 687b         	ldr	r3, [r7, #0x4]
 801ede8: f44f 7280    	mov.w	r2, #0x100
 801edec: 60da         	str	r2, [r3, #0xc]
; 	z_init_timeout(&dwork->timeout);
 801edee: 687b         	ldr	r3, [r7, #0x4]
 801edf0: 3310         	adds	r3, #0x10
 801edf2: 4618         	mov	r0, r3
 801edf4: f7ff fe6a    	bl	0x801eacc <z_init_timeout> @ imm = #-0x32c
; }
 801edf8: bf00         	nop
 801edfa: 3738         	adds	r7, #0x38
 801edfc: 46bd         	mov	sp, r7
 801edfe: bd80         	pop	{r7, pc}

0801ee00 <unschedule_locked>:
; {
 801ee00: b580         	push	{r7, lr}
 801ee02: b084         	sub	sp, #0x10
 801ee04: af00         	add	r7, sp, #0x0
 801ee06: 6078         	str	r0, [r7, #0x4]
; 	bool ret = false;
 801ee08: 2300         	movs	r3, #0x0
 801ee0a: 73fb         	strb	r3, [r7, #0xf]
; 	struct k_work *work = &dwork->work;
 801ee0c: 687b         	ldr	r3, [r7, #0x4]
 801ee0e: 60bb         	str	r3, [r7, #0x8]
; 	if (flag_test_and_clear(&work->flags, K_WORK_DELAYED_BIT)) {
 801ee10: 68bb         	ldr	r3, [r7, #0x8]
 801ee12: 330c         	adds	r3, #0xc
 801ee14: 2103         	movs	r1, #0x3
 801ee16: 4618         	mov	r0, r3
 801ee18: f7ff fec8    	bl	0x801ebac <flag_test_and_clear> @ imm = #-0x270
 801ee1c: 4603         	mov	r3, r0
 801ee1e: 2b00         	cmp	r3, #0x0
 801ee20: d00a         	beq	0x801ee38 <unschedule_locked+0x38> @ imm = #0x14
; 		ret = z_abort_timeout(&dwork->timeout) == 0;
 801ee22: 687b         	ldr	r3, [r7, #0x4]
 801ee24: 3310         	adds	r3, #0x10
 801ee26: 4618         	mov	r0, r3
 801ee28: f7f3 feea    	bl	0x8012c00 <z_abort_timeout> @ imm = #-0xc22c
 801ee2c: 4603         	mov	r3, r0
 801ee2e: 2b00         	cmp	r3, #0x0
 801ee30: bf0c         	ite	eq
 801ee32: 2301         	moveq	r3, #0x1
 801ee34: 2300         	movne	r3, #0x0
 801ee36: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 801ee38: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 801ee3a: 4618         	mov	r0, r3
 801ee3c: 3710         	adds	r7, #0x10
 801ee3e: 46bd         	mov	sp, r7
 801ee40: bd80         	pop	{r7, pc}

0801ee42 <cancel_delayable_async_locked>:
; {
 801ee42: b580         	push	{r7, lr}
 801ee44: b082         	sub	sp, #0x8
 801ee46: af00         	add	r7, sp, #0x0
 801ee48: 6078         	str	r0, [r7, #0x4]
; 	(void)unschedule_locked(dwork);
 801ee4a: 6878         	ldr	r0, [r7, #0x4]
 801ee4c: f7ff ffd8    	bl	0x801ee00 <unschedule_locked> @ imm = #-0x50
; 	return cancel_async_locked(&dwork->work);
 801ee50: 687b         	ldr	r3, [r7, #0x4]
 801ee52: 4618         	mov	r0, r3
 801ee54: f7ff ff8c    	bl	0x801ed70 <cancel_async_locked> @ imm = #-0xe8
 801ee58: 4603         	mov	r3, r0
; }
 801ee5a: 4618         	mov	r0, r3
 801ee5c: 3708         	adds	r7, #0x8
 801ee5e: 46bd         	mov	sp, r7
 801ee60: bd80         	pop	{r7, pc}

0801ee62 <sys_dlist_init>:
; {
 801ee62: b480         	push	{r7}
 801ee64: b083         	sub	sp, #0xc
 801ee66: af00         	add	r7, sp, #0x0
 801ee68: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801ee6a: 687b         	ldr	r3, [r7, #0x4]
 801ee6c: 687a         	ldr	r2, [r7, #0x4]
 801ee6e: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 801ee70: 687b         	ldr	r3, [r7, #0x4]
 801ee72: 687a         	ldr	r2, [r7, #0x4]
 801ee74: 605a         	str	r2, [r3, #0x4]
; }
 801ee76: bf00         	nop
 801ee78: 370c         	adds	r7, #0xc
 801ee7a: 46bd         	mov	sp, r7
 801ee7c: f85d 7b04    	ldr	r7, [sp], #4
 801ee80: 4770         	bx	lr

0801ee82 <sys_dnode_init>:
; {
 801ee82: b480         	push	{r7}
 801ee84: b083         	sub	sp, #0xc
 801ee86: af00         	add	r7, sp, #0x0
 801ee88: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801ee8a: 687b         	ldr	r3, [r7, #0x4]
 801ee8c: 2200         	movs	r2, #0x0
 801ee8e: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801ee90: 687b         	ldr	r3, [r7, #0x4]
 801ee92: 2200         	movs	r2, #0x0
 801ee94: 605a         	str	r2, [r3, #0x4]
; }
 801ee96: bf00         	nop
 801ee98: 370c         	adds	r7, #0xc
 801ee9a: 46bd         	mov	sp, r7
 801ee9c: f85d 7b04    	ldr	r7, [sp], #4
 801eea0: 4770         	bx	lr

0801eea2 <K_KERNEL_STACK_BUFFER>:
; {
 801eea2: b480         	push	{r7}
 801eea4: b083         	sub	sp, #0xc
 801eea6: af00         	add	r7, sp, #0x0
 801eea8: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 801eeaa: 687b         	ldr	r3, [r7, #0x4]
; }
 801eeac: 4618         	mov	r0, r3
 801eeae: 370c         	adds	r7, #0xc
 801eeb0: 46bd         	mov	sp, r7
 801eeb2: f85d 7b04    	ldr	r7, [sp], #4
 801eeb6: 4770         	bx	lr

0801eeb8 <k_thread_start>:
; {
 801eeb8: b580         	push	{r7, lr}
 801eeba: b082         	sub	sp, #0x8
 801eebc: af00         	add	r7, sp, #0x0
 801eebe: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 801eec0: 6878         	ldr	r0, [r7, #0x4]
 801eec2: f000 f804    	bl	0x801eece <k_thread_resume> @ imm = #0x8
; }
 801eec6: bf00         	nop
 801eec8: 3708         	adds	r7, #0x8
 801eeca: 46bd         	mov	sp, r7
 801eecc: bd80         	pop	{r7, pc}

0801eece <k_thread_resume>:
; {
 801eece: b580         	push	{r7, lr}
 801eed0: b082         	sub	sp, #0x8
 801eed2: af00         	add	r7, sp, #0x0
 801eed4: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 801eed6: 6878         	ldr	r0, [r7, #0x4]
 801eed8: f7f2 fb84    	bl	0x80115e4 <z_impl_k_thread_resume> @ imm = #-0xd8f8
; }
 801eedc: bf00         	nop
 801eede: 3708         	adds	r7, #0x8
 801eee0: 46bd         	mov	sp, r7
 801eee2: bd80         	pop	{r7, pc}

0801eee4 <z_init_timeout>:
; {
 801eee4: b580         	push	{r7, lr}
 801eee6: b082         	sub	sp, #0x8
 801eee8: af00         	add	r7, sp, #0x0
 801eeea: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 801eeec: 687b         	ldr	r3, [r7, #0x4]
 801eeee: 4618         	mov	r0, r3
 801eef0: f7ff ffc7    	bl	0x801ee82 <sys_dnode_init> @ imm = #-0x72
; }
 801eef4: bf00         	nop
 801eef6: 3708         	adds	r7, #0x8
 801eef8: 46bd         	mov	sp, r7
 801eefa: bd80         	pop	{r7, pc}

0801eefc <z_init_thread_timeout>:
; {
 801eefc: b580         	push	{r7, lr}
 801eefe: b082         	sub	sp, #0x8
 801ef00: af00         	add	r7, sp, #0x0
 801ef02: 6078         	str	r0, [r7, #0x4]
; 	z_init_timeout(&thread_base->timeout);
 801ef04: 687b         	ldr	r3, [r7, #0x4]
 801ef06: 3318         	adds	r3, #0x18
 801ef08: 4618         	mov	r0, r3
 801ef0a: f7ff ffeb    	bl	0x801eee4 <z_init_timeout> @ imm = #-0x2a
; }
 801ef0e: bf00         	nop
 801ef10: 3708         	adds	r7, #0x8
 801ef12: 46bd         	mov	sp, r7
 801ef14: bd80         	pop	{r7, pc}

0801ef16 <thread_schedule_new>:
; {
 801ef16: b580         	push	{r7, lr}
 801ef18: b084         	sub	sp, #0x10
 801ef1a: af00         	add	r7, sp, #0x0
 801ef1c: 60f8         	str	r0, [r7, #0xc]
 801ef1e: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 801ef22: e9d7 2300    	ldrd	r2, r3, [r7]
 801ef26: f04f 0000    	mov.w	r0, #0x0
 801ef2a: f04f 0100    	mov.w	r1, #0x0
 801ef2e: 428b         	cmp	r3, r1
 801ef30: bf08         	it	eq
 801ef32: 4282         	cmpeq	r2, r0
 801ef34: d103         	bne	0x801ef3e <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 801ef36: 68f8         	ldr	r0, [r7, #0xc]
 801ef38: f7ff ffbe    	bl	0x801eeb8 <k_thread_start> @ imm = #-0x84
 801ef3c: e004         	b	0x801ef48 <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 801ef3e: e9d7 2300    	ldrd	r2, r3, [r7]
 801ef42: 68f8         	ldr	r0, [r7, #0xc]
 801ef44: f7f1 fd86    	bl	0x8010a54 <z_add_thread_timeout> @ imm = #-0xe4f4
; }
 801ef48: bf00         	nop
 801ef4a: 3710         	adds	r7, #0x10
 801ef4c: 46bd         	mov	sp, r7
 801ef4e: bd80         	pop	{r7, pc}

0801ef50 <z_waitq_init>:
; {
 801ef50: b580         	push	{r7, lr}
 801ef52: b082         	sub	sp, #0x8
 801ef54: af00         	add	r7, sp, #0x0
 801ef56: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 801ef58: 687b         	ldr	r3, [r7, #0x4]
 801ef5a: 4618         	mov	r0, r3
 801ef5c: f7ff ff81    	bl	0x801ee62 <sys_dlist_init> @ imm = #-0xfe
; }
 801ef60: bf00         	nop
 801ef62: 3708         	adds	r7, #0x8
 801ef64: 46bd         	mov	sp, r7
 801ef66: bd80         	pop	{r7, pc}

0801ef68 <z_log_msg_runtime_create>:
; {
 801ef68: b580         	push	{r7, lr}
 801ef6a: b08a         	sub	sp, #0x28
 801ef6c: af04         	add	r7, sp, #0x10
 801ef6e: 60b9         	str	r1, [r7, #0x8]
 801ef70: 607b         	str	r3, [r7, #0x4]
 801ef72: 4603         	mov	r3, r0
 801ef74: 73fb         	strb	r3, [r7, #0xf]
 801ef76: 4613         	mov	r3, r2
 801ef78: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801ef7a: f107 032c    	add.w	r3, r7, #0x2c
 801ef7e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801ef80: 7bba         	ldrb	r2, [r7, #0xe]
 801ef82: 7bf8         	ldrb	r0, [r7, #0xf]
 801ef84: 697b         	ldr	r3, [r7, #0x14]
 801ef86: 9303         	str	r3, [sp, #0xc]
 801ef88: 6abb         	ldr	r3, [r7, #0x28]
 801ef8a: 9302         	str	r3, [sp, #0x8]
 801ef8c: 6a7b         	ldr	r3, [r7, #0x24]
 801ef8e: 9301         	str	r3, [sp, #0x4]
 801ef90: 6a3b         	ldr	r3, [r7, #0x20]
 801ef92: 9300         	str	r3, [sp]
 801ef94: 687b         	ldr	r3, [r7, #0x4]
 801ef96: 68b9         	ldr	r1, [r7, #0x8]
 801ef98: f7e6 faec    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x19a28
; }
 801ef9c: bf00         	nop
 801ef9e: 3718         	adds	r7, #0x18
 801efa0: 46bd         	mov	sp, r7
 801efa2: bd80         	pop	{r7, pc}

0801efa4 <k_is_in_isr>:
; {
 801efa4: b480         	push	{r7}
 801efa6: b083         	sub	sp, #0xc
 801efa8: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801efaa: f3ef 8305    	mrs	r3, ipsr
 801efae: 607b         	str	r3, [r7, #0x4]
;   return(result);
 801efb0: 687b         	ldr	r3, [r7, #0x4]
; 	return (__get_IPSR()) ? (true) : (false);
 801efb2: 2b00         	cmp	r3, #0x0
 801efb4: bf14         	ite	ne
 801efb6: 2301         	movne	r3, #0x1
 801efb8: 2300         	moveq	r3, #0x0
 801efba: b2db         	uxtb	r3, r3
; }
 801efbc: 4618         	mov	r0, r3
 801efbe: 370c         	adds	r7, #0xc
 801efc0: 46bd         	mov	sp, r7
 801efc2: f85d 7b04    	ldr	r7, [sp], #4
 801efc6: 4770         	bx	lr

0801efc8 <k_thread_name_get>:
; {
 801efc8: b480         	push	{r7}
 801efca: b083         	sub	sp, #0xc
 801efcc: af00         	add	r7, sp, #0x0
 801efce: 6078         	str	r0, [r7, #0x4]
; 	return (const char *)thread->name;
 801efd0: 687b         	ldr	r3, [r7, #0x4]
 801efd2: 3394         	adds	r3, #0x94
; }
 801efd4: 4618         	mov	r0, r3
 801efd6: 370c         	adds	r7, #0xc
 801efd8: 46bd         	mov	sp, r7
 801efda: f85d 7b04    	ldr	r7, [sp], #4
 801efde: 4770         	bx	lr

0801efe0 <z_impl_k_thread_create>:
; {
 801efe0: b580         	push	{r7, lr}
 801efe2: b08a         	sub	sp, #0x28
 801efe4: af06         	add	r7, sp, #0x18
 801efe6: 60f8         	str	r0, [r7, #0xc]
 801efe8: 60b9         	str	r1, [r7, #0x8]
 801efea: 607a         	str	r2, [r7, #0x4]
 801efec: 603b         	str	r3, [r7]
; 	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 801efee: 2300         	movs	r3, #0x0
 801eff0: 9305         	str	r3, [sp, #0x14]
 801eff2: 6abb         	ldr	r3, [r7, #0x28]
 801eff4: 9304         	str	r3, [sp, #0x10]
 801eff6: 6a7b         	ldr	r3, [r7, #0x24]
 801eff8: 9303         	str	r3, [sp, #0xc]
 801effa: 6a3b         	ldr	r3, [r7, #0x20]
 801effc: 9302         	str	r3, [sp, #0x8]
 801effe: 69fb         	ldr	r3, [r7, #0x1c]
 801f000: 9301         	str	r3, [sp, #0x4]
 801f002: 69bb         	ldr	r3, [r7, #0x18]
 801f004: 9300         	str	r3, [sp]
 801f006: 683b         	ldr	r3, [r7]
 801f008: 687a         	ldr	r2, [r7, #0x4]
 801f00a: 68b9         	ldr	r1, [r7, #0x8]
 801f00c: 68f8         	ldr	r0, [r7, #0xc]
 801f00e: f7f1 fdc5    	bl	0x8010b9c <z_setup_new_thread> @ imm = #-0xe476
; 	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
 801f012: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801f016: f04f 30ff    	mov.w	r0, #0xffffffff
 801f01a: f04f 31ff    	mov.w	r1, #0xffffffff
 801f01e: 428b         	cmp	r3, r1
 801f020: bf08         	it	eq
 801f022: 4282         	cmpeq	r2, r0
 801f024: d004         	beq	0x801f030 <z_impl_k_thread_create+0x50> @ imm = #0x8
; 		thread_schedule_new(new_thread, delay);
 801f026: e9d7 230c    	ldrd	r2, r3, [r7, #48]
 801f02a: 68f8         	ldr	r0, [r7, #0xc]
 801f02c: f7ff ff73    	bl	0x801ef16 <thread_schedule_new> @ imm = #-0x11a
; 	return new_thread;
 801f030: 68fb         	ldr	r3, [r7, #0xc]
; }
 801f032: 4618         	mov	r0, r3
 801f034: 3710         	adds	r7, #0x10
 801f036: 46bd         	mov	sp, r7
 801f038: bd80         	pop	{r7, pc}

0801f03a <z_init_thread_base>:
; {
 801f03a: b580         	push	{r7, lr}
 801f03c: b084         	sub	sp, #0x10
 801f03e: af00         	add	r7, sp, #0x0
 801f040: 60f8         	str	r0, [r7, #0xc]
 801f042: 60b9         	str	r1, [r7, #0x8]
 801f044: 607a         	str	r2, [r7, #0x4]
 801f046: 603b         	str	r3, [r7]
; 	thread_base->pended_on = NULL;
 801f048: 68fb         	ldr	r3, [r7, #0xc]
 801f04a: 2200         	movs	r2, #0x0
 801f04c: 609a         	str	r2, [r3, #0x8]
; 	thread_base->user_options = (uint8_t)options;
 801f04e: 683b         	ldr	r3, [r7]
 801f050: b2da         	uxtb	r2, r3
 801f052: 68fb         	ldr	r3, [r7, #0xc]
 801f054: 731a         	strb	r2, [r3, #0xc]
; 	thread_base->thread_state = (uint8_t)initial_state;
 801f056: 687b         	ldr	r3, [r7, #0x4]
 801f058: b2da         	uxtb	r2, r3
 801f05a: 68fb         	ldr	r3, [r7, #0xc]
 801f05c: 735a         	strb	r2, [r3, #0xd]
; 	thread_base->prio = priority;
 801f05e: 68bb         	ldr	r3, [r7, #0x8]
 801f060: b25a         	sxtb	r2, r3
 801f062: 68fb         	ldr	r3, [r7, #0xc]
 801f064: 739a         	strb	r2, [r3, #0xe]
; 	thread_base->sched_locked = 0U;
 801f066: 68fb         	ldr	r3, [r7, #0xc]
 801f068: 2200         	movs	r2, #0x0
 801f06a: 73da         	strb	r2, [r3, #0xf]
; 	z_init_thread_timeout(thread_base);
 801f06c: 68f8         	ldr	r0, [r7, #0xc]
 801f06e: f7ff ff45    	bl	0x801eefc <z_init_thread_timeout> @ imm = #-0x176
; }
 801f072: bf00         	nop
 801f074: 3710         	adds	r7, #0x10
 801f076: 46bd         	mov	sp, r7
 801f078: bd80         	pop	{r7, pc}

0801f07a <z_thread_mark_switched_out>:
; {
 801f07a: b580         	push	{r7, lr}
 801f07c: af00         	add	r7, sp, #0x0
; 	z_sched_usage_stop();
 801f07e: f7f3 ff67    	bl	0x8012f50 <z_sched_usage_stop> @ imm = #-0xc132
; }
 801f082: bf00         	nop
 801f084: bd80         	pop	{r7, pc}

0801f086 <sys_dlist_init>:
; {
 801f086: b480         	push	{r7}
 801f088: b083         	sub	sp, #0xc
 801f08a: af00         	add	r7, sp, #0x0
 801f08c: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801f08e: 687b         	ldr	r3, [r7, #0x4]
 801f090: 687a         	ldr	r2, [r7, #0x4]
 801f092: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 801f094: 687b         	ldr	r3, [r7, #0x4]
 801f096: 687a         	ldr	r2, [r7, #0x4]
 801f098: 605a         	str	r2, [r3, #0x4]
; }
 801f09a: bf00         	nop
 801f09c: 370c         	adds	r7, #0xc
 801f09e: 46bd         	mov	sp, r7
 801f0a0: f85d 7b04    	ldr	r7, [sp], #4
 801f0a4: 4770         	bx	lr

0801f0a6 <sys_dnode_init>:
; {
 801f0a6: b480         	push	{r7}
 801f0a8: b083         	sub	sp, #0xc
 801f0aa: af00         	add	r7, sp, #0x0
 801f0ac: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801f0ae: 687b         	ldr	r3, [r7, #0x4]
 801f0b0: 2200         	movs	r2, #0x0
 801f0b2: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801f0b4: 687b         	ldr	r3, [r7, #0x4]
 801f0b6: 2200         	movs	r2, #0x0
 801f0b8: 605a         	str	r2, [r3, #0x4]
; }
 801f0ba: bf00         	nop
 801f0bc: 370c         	adds	r7, #0xc
 801f0be: 46bd         	mov	sp, r7
 801f0c0: f85d 7b04    	ldr	r7, [sp], #4
 801f0c4: 4770         	bx	lr

0801f0c6 <sys_dnode_is_linked>:
; {
 801f0c6: b480         	push	{r7}
 801f0c8: b083         	sub	sp, #0xc
 801f0ca: af00         	add	r7, sp, #0x0
 801f0cc: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 801f0ce: 687b         	ldr	r3, [r7, #0x4]
 801f0d0: 681b         	ldr	r3, [r3]
 801f0d2: 2b00         	cmp	r3, #0x0
 801f0d4: bf14         	ite	ne
 801f0d6: 2301         	movne	r3, #0x1
 801f0d8: 2300         	moveq	r3, #0x0
 801f0da: b2db         	uxtb	r3, r3
; }
 801f0dc: 4618         	mov	r0, r3
 801f0de: 370c         	adds	r7, #0xc
 801f0e0: 46bd         	mov	sp, r7
 801f0e2: f85d 7b04    	ldr	r7, [sp], #4
 801f0e6: 4770         	bx	lr

0801f0e8 <sys_dlist_is_empty>:
; {
 801f0e8: b480         	push	{r7}
 801f0ea: b083         	sub	sp, #0xc
 801f0ec: af00         	add	r7, sp, #0x0
 801f0ee: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801f0f0: 687b         	ldr	r3, [r7, #0x4]
 801f0f2: 681b         	ldr	r3, [r3]
 801f0f4: 687a         	ldr	r2, [r7, #0x4]
 801f0f6: 429a         	cmp	r2, r3
 801f0f8: bf0c         	ite	eq
 801f0fa: 2301         	moveq	r3, #0x1
 801f0fc: 2300         	movne	r3, #0x0
 801f0fe: b2db         	uxtb	r3, r3
; }
 801f100: 4618         	mov	r0, r3
 801f102: 370c         	adds	r7, #0xc
 801f104: 46bd         	mov	sp, r7
 801f106: f85d 7b04    	ldr	r7, [sp], #4
 801f10a: 4770         	bx	lr

0801f10c <sys_dlist_peek_head>:
; {
 801f10c: b580         	push	{r7, lr}
 801f10e: b082         	sub	sp, #0x8
 801f110: af00         	add	r7, sp, #0x0
 801f112: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801f114: 6878         	ldr	r0, [r7, #0x4]
 801f116: f7ff ffe7    	bl	0x801f0e8 <sys_dlist_is_empty> @ imm = #-0x32
 801f11a: 4603         	mov	r3, r0
 801f11c: 2b00         	cmp	r3, #0x0
 801f11e: d102         	bne	0x801f126 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 801f120: 687b         	ldr	r3, [r7, #0x4]
 801f122: 681b         	ldr	r3, [r3]
 801f124: e000         	b	0x801f128 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 801f126: 2300         	movs	r3, #0x0
; }
 801f128: 4618         	mov	r0, r3
 801f12a: 3708         	adds	r7, #0x8
 801f12c: 46bd         	mov	sp, r7
 801f12e: bd80         	pop	{r7, pc}

0801f130 <sys_dlist_peek_next_no_check>:
; {
 801f130: b480         	push	{r7}
 801f132: b083         	sub	sp, #0xc
 801f134: af00         	add	r7, sp, #0x0
 801f136: 6078         	str	r0, [r7, #0x4]
 801f138: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 801f13a: 687b         	ldr	r3, [r7, #0x4]
 801f13c: 685b         	ldr	r3, [r3, #0x4]
 801f13e: 683a         	ldr	r2, [r7]
 801f140: 429a         	cmp	r2, r3
 801f142: d002         	beq	0x801f14a <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 801f144: 683b         	ldr	r3, [r7]
 801f146: 681b         	ldr	r3, [r3]
 801f148: e000         	b	0x801f14c <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 801f14a: 2300         	movs	r3, #0x0
; }
 801f14c: 4618         	mov	r0, r3
 801f14e: 370c         	adds	r7, #0xc
 801f150: 46bd         	mov	sp, r7
 801f152: f85d 7b04    	ldr	r7, [sp], #4
 801f156: 4770         	bx	lr

0801f158 <sys_dlist_peek_next>:
; {
 801f158: b580         	push	{r7, lr}
 801f15a: b082         	sub	sp, #0x8
 801f15c: af00         	add	r7, sp, #0x0
 801f15e: 6078         	str	r0, [r7, #0x4]
 801f160: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 801f162: 683b         	ldr	r3, [r7]
 801f164: 2b00         	cmp	r3, #0x0
 801f166: d005         	beq	0x801f174 <sys_dlist_peek_next+0x1c> @ imm = #0xa
 801f168: 6839         	ldr	r1, [r7]
 801f16a: 6878         	ldr	r0, [r7, #0x4]
 801f16c: f7ff ffe0    	bl	0x801f130 <sys_dlist_peek_next_no_check> @ imm = #-0x40
 801f170: 4603         	mov	r3, r0
 801f172: e000         	b	0x801f176 <sys_dlist_peek_next+0x1e> @ imm = #0x0
 801f174: 2300         	movs	r3, #0x0
; }
 801f176: 4618         	mov	r0, r3
 801f178: 3708         	adds	r7, #0x8
 801f17a: 46bd         	mov	sp, r7
 801f17c: bd80         	pop	{r7, pc}

0801f17e <sys_dlist_append>:
; {
 801f17e: b480         	push	{r7}
 801f180: b085         	sub	sp, #0x14
 801f182: af00         	add	r7, sp, #0x0
 801f184: 6078         	str	r0, [r7, #0x4]
 801f186: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 801f188: 687b         	ldr	r3, [r7, #0x4]
 801f18a: 685b         	ldr	r3, [r3, #0x4]
 801f18c: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 801f18e: 683b         	ldr	r3, [r7]
 801f190: 687a         	ldr	r2, [r7, #0x4]
 801f192: 601a         	str	r2, [r3]
; 	node->prev = tail;
 801f194: 683b         	ldr	r3, [r7]
 801f196: 68fa         	ldr	r2, [r7, #0xc]
 801f198: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 801f19a: 68fb         	ldr	r3, [r7, #0xc]
 801f19c: 683a         	ldr	r2, [r7]
 801f19e: 601a         	str	r2, [r3]
; 	list->tail = node;
 801f1a0: 687b         	ldr	r3, [r7, #0x4]
 801f1a2: 683a         	ldr	r2, [r7]
 801f1a4: 605a         	str	r2, [r3, #0x4]
; }
 801f1a6: bf00         	nop
 801f1a8: 3714         	adds	r7, #0x14
 801f1aa: 46bd         	mov	sp, r7
 801f1ac: f85d 7b04    	ldr	r7, [sp], #4
 801f1b0: 4770         	bx	lr

0801f1b2 <sys_dlist_insert>:
; {
 801f1b2: b480         	push	{r7}
 801f1b4: b085         	sub	sp, #0x14
 801f1b6: af00         	add	r7, sp, #0x0
 801f1b8: 6078         	str	r0, [r7, #0x4]
 801f1ba: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 801f1bc: 687b         	ldr	r3, [r7, #0x4]
 801f1be: 685b         	ldr	r3, [r3, #0x4]
 801f1c0: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 801f1c2: 683b         	ldr	r3, [r7]
 801f1c4: 68fa         	ldr	r2, [r7, #0xc]
 801f1c6: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 801f1c8: 683b         	ldr	r3, [r7]
 801f1ca: 687a         	ldr	r2, [r7, #0x4]
 801f1cc: 601a         	str	r2, [r3]
; 	prev->next = node;
 801f1ce: 68fb         	ldr	r3, [r7, #0xc]
 801f1d0: 683a         	ldr	r2, [r7]
 801f1d2: 601a         	str	r2, [r3]
; 	successor->prev = node;
 801f1d4: 687b         	ldr	r3, [r7, #0x4]
 801f1d6: 683a         	ldr	r2, [r7]
 801f1d8: 605a         	str	r2, [r3, #0x4]
; }
 801f1da: bf00         	nop
 801f1dc: 3714         	adds	r7, #0x14
 801f1de: 46bd         	mov	sp, r7
 801f1e0: f85d 7b04    	ldr	r7, [sp], #4
 801f1e4: 4770         	bx	lr

0801f1e6 <sys_dlist_remove>:
; {
 801f1e6: b580         	push	{r7, lr}
 801f1e8: b084         	sub	sp, #0x10
 801f1ea: af00         	add	r7, sp, #0x0
 801f1ec: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801f1ee: 687b         	ldr	r3, [r7, #0x4]
 801f1f0: 685b         	ldr	r3, [r3, #0x4]
 801f1f2: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 801f1f4: 687b         	ldr	r3, [r7, #0x4]
 801f1f6: 681b         	ldr	r3, [r3]
 801f1f8: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 801f1fa: 68fb         	ldr	r3, [r7, #0xc]
 801f1fc: 68ba         	ldr	r2, [r7, #0x8]
 801f1fe: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801f200: 68bb         	ldr	r3, [r7, #0x8]
 801f202: 68fa         	ldr	r2, [r7, #0xc]
 801f204: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 801f206: 6878         	ldr	r0, [r7, #0x4]
 801f208: f7ff ff4d    	bl	0x801f0a6 <sys_dnode_init> @ imm = #-0x166
; }
 801f20c: bf00         	nop
 801f20e: 3710         	adds	r7, #0x10
 801f210: 46bd         	mov	sp, r7
 801f212: bd80         	pop	{r7, pc}

0801f214 <k_yield>:
; {
 801f214: b580         	push	{r7, lr}
 801f216: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 801f218: f7f2 fe0c    	bl	0x8011e34 <z_impl_k_yield> @ imm = #-0xd3e8
; }
 801f21c: bf00         	nop
 801f21e: bd80         	pop	{r7, pc}

0801f220 <k_thread_suspend>:
; {
 801f220: b580         	push	{r7, lr}
 801f222: b082         	sub	sp, #0x8
 801f224: af00         	add	r7, sp, #0x0
 801f226: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_suspend(thread);
 801f228: 6878         	ldr	r0, [r7, #0x4]
 801f22a: f7f2 f8b3    	bl	0x8011394 <z_impl_k_thread_suspend> @ imm = #-0xde9a
; }
 801f22e: bf00         	nop
 801f230: 3708         	adds	r7, #0x8
 801f232: 46bd         	mov	sp, r7
 801f234: bd80         	pop	{r7, pc}

0801f236 <z_is_inactive_timeout>:
; {
 801f236: b580         	push	{r7, lr}
 801f238: b082         	sub	sp, #0x8
 801f23a: af00         	add	r7, sp, #0x0
 801f23c: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 801f23e: 687b         	ldr	r3, [r7, #0x4]
 801f240: 4618         	mov	r0, r3
 801f242: f7ff ff40    	bl	0x801f0c6 <sys_dnode_is_linked> @ imm = #-0x180
 801f246: 4603         	mov	r3, r0
 801f248: 2b00         	cmp	r3, #0x0
 801f24a: bf14         	ite	ne
 801f24c: 2301         	movne	r3, #0x1
 801f24e: 2300         	moveq	r3, #0x0
 801f250: b2db         	uxtb	r3, r3
 801f252: f083 0301    	eor	r3, r3, #0x1
 801f256: b2db         	uxtb	r3, r3
 801f258: f003 0301    	and	r3, r3, #0x1
 801f25c: b2db         	uxtb	r3, r3
; }
 801f25e: 4618         	mov	r0, r3
 801f260: 3708         	adds	r7, #0x8
 801f262: 46bd         	mov	sp, r7
 801f264: bd80         	pop	{r7, pc}

0801f266 <z_abort_thread_timeout>:
; {
 801f266: b580         	push	{r7, lr}
 801f268: b082         	sub	sp, #0x8
 801f26a: af00         	add	r7, sp, #0x0
 801f26c: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 801f26e: 687b         	ldr	r3, [r7, #0x4]
 801f270: 3318         	adds	r3, #0x18
 801f272: 4618         	mov	r0, r3
 801f274: f7f3 fcc4    	bl	0x8012c00 <z_abort_timeout> @ imm = #-0xc678
 801f278: 4603         	mov	r3, r0
; }
 801f27a: 4618         	mov	r0, r3
 801f27c: 3708         	adds	r7, #0x8
 801f27e: 46bd         	mov	sp, r7
 801f280: bd80         	pop	{r7, pc}

0801f282 <thread_is_preemptible>:
; {
 801f282: b480         	push	{r7}
 801f284: b083         	sub	sp, #0xc
 801f286: af00         	add	r7, sp, #0x0
 801f288: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 801f28a: 687b         	ldr	r3, [r7, #0x4]
 801f28c: 89db         	ldrh	r3, [r3, #0xe]
 801f28e: 2b7f         	cmp	r3, #0x7f
 801f290: bf94         	ite	ls
 801f292: 2301         	movls	r3, #0x1
 801f294: 2300         	movhi	r3, #0x0
 801f296: b2db         	uxtb	r3, r3
; }
 801f298: 4618         	mov	r0, r3
 801f29a: 370c         	adds	r7, #0xc
 801f29c: 46bd         	mov	sp, r7
 801f29e: f85d 7b04    	ldr	r7, [sp], #4
 801f2a2: 4770         	bx	lr

0801f2a4 <thread_is_metairq>:
; {
 801f2a4: b480         	push	{r7}
 801f2a6: b083         	sub	sp, #0xc
 801f2a8: af00         	add	r7, sp, #0x0
 801f2aa: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 801f2ac: 2300         	movs	r3, #0x0
; }
 801f2ae: 4618         	mov	r0, r3
 801f2b0: 370c         	adds	r7, #0xc
 801f2b2: 46bd         	mov	sp, r7
 801f2b4: f85d 7b04    	ldr	r7, [sp], #4
 801f2b8: 4770         	bx	lr

0801f2ba <z_is_thread_suspended>:
; {
 801f2ba: b480         	push	{r7}
 801f2bc: b083         	sub	sp, #0xc
 801f2be: af00         	add	r7, sp, #0x0
 801f2c0: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_SUSPENDED) != 0U;
 801f2c2: 687b         	ldr	r3, [r7, #0x4]
 801f2c4: 7b5b         	ldrb	r3, [r3, #0xd]
 801f2c6: f003 0310    	and	r3, r3, #0x10
 801f2ca: 2b00         	cmp	r3, #0x0
 801f2cc: bf14         	ite	ne
 801f2ce: 2301         	movne	r3, #0x1
 801f2d0: 2300         	moveq	r3, #0x0
 801f2d2: b2db         	uxtb	r3, r3
; }
 801f2d4: 4618         	mov	r0, r3
 801f2d6: 370c         	adds	r7, #0xc
 801f2d8: 46bd         	mov	sp, r7
 801f2da: f85d 7b04    	ldr	r7, [sp], #4
 801f2de: 4770         	bx	lr

0801f2e0 <z_is_thread_prevented_from_running>:
; {
 801f2e0: b480         	push	{r7}
 801f2e2: b085         	sub	sp, #0x14
 801f2e4: af00         	add	r7, sp, #0x0
 801f2e6: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 801f2e8: 687b         	ldr	r3, [r7, #0x4]
 801f2ea: 7b5b         	ldrb	r3, [r3, #0xd]
 801f2ec: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 801f2ee: 7bfb         	ldrb	r3, [r7, #0xf]
 801f2f0: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 801f2f4: 2b00         	cmp	r3, #0x0
 801f2f6: bf14         	ite	ne
 801f2f8: 2301         	movne	r3, #0x1
 801f2fa: 2300         	moveq	r3, #0x0
 801f2fc: b2db         	uxtb	r3, r3
; }
 801f2fe: 4618         	mov	r0, r3
 801f300: 3714         	adds	r7, #0x14
 801f302: 46bd         	mov	sp, r7
 801f304: f85d 7b04    	ldr	r7, [sp], #4
 801f308: 4770         	bx	lr

0801f30a <z_is_thread_timeout_active>:
; {
 801f30a: b580         	push	{r7, lr}
 801f30c: b082         	sub	sp, #0x8
 801f30e: af00         	add	r7, sp, #0x0
 801f310: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 801f312: 687b         	ldr	r3, [r7, #0x4]
 801f314: 3318         	adds	r3, #0x18
 801f316: 4618         	mov	r0, r3
 801f318: f7ff ff8d    	bl	0x801f236 <z_is_inactive_timeout> @ imm = #-0xe6
 801f31c: 4603         	mov	r3, r0
 801f31e: 2b00         	cmp	r3, #0x0
 801f320: bf14         	ite	ne
 801f322: 2301         	movne	r3, #0x1
 801f324: 2300         	moveq	r3, #0x0
 801f326: b2db         	uxtb	r3, r3
 801f328: f083 0301    	eor	r3, r3, #0x1
 801f32c: b2db         	uxtb	r3, r3
 801f32e: f003 0301    	and	r3, r3, #0x1
 801f332: b2db         	uxtb	r3, r3
; }
 801f334: 4618         	mov	r0, r3
 801f336: 3708         	adds	r7, #0x8
 801f338: 46bd         	mov	sp, r7
 801f33a: bd80         	pop	{r7, pc}

0801f33c <z_is_thread_ready>:
; {
 801f33c: b580         	push	{r7, lr}
 801f33e: b082         	sub	sp, #0x8
 801f340: af00         	add	r7, sp, #0x0
 801f342: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 801f344: 6878         	ldr	r0, [r7, #0x4]
 801f346: f7ff ffcb    	bl	0x801f2e0 <z_is_thread_prevented_from_running> @ imm = #-0x6a
 801f34a: 4603         	mov	r3, r0
 801f34c: f083 0301    	eor	r3, r3, #0x1
 801f350: b2db         	uxtb	r3, r3
 801f352: 2b00         	cmp	r3, #0x0
 801f354: d00a         	beq	0x801f36c <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 801f356: 6878         	ldr	r0, [r7, #0x4]
 801f358: f7ff ffd7    	bl	0x801f30a <z_is_thread_timeout_active> @ imm = #-0x52
 801f35c: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 801f35e: f083 0301    	eor	r3, r3, #0x1
 801f362: b2db         	uxtb	r3, r3
 801f364: 2b00         	cmp	r3, #0x0
 801f366: d001         	beq	0x801f36c <z_is_thread_ready+0x30> @ imm = #0x2
 801f368: 2301         	movs	r3, #0x1
 801f36a: e000         	b	0x801f36e <z_is_thread_ready+0x32> @ imm = #0x0
 801f36c: 2300         	movs	r3, #0x0
 801f36e: f003 0301    	and	r3, r3, #0x1
 801f372: b2db         	uxtb	r3, r3
; }
 801f374: 4618         	mov	r0, r3
 801f376: 3708         	adds	r7, #0x8
 801f378: 46bd         	mov	sp, r7
 801f37a: bd80         	pop	{r7, pc}

0801f37c <z_is_thread_state_set>:
; {
 801f37c: b480         	push	{r7}
 801f37e: b083         	sub	sp, #0xc
 801f380: af00         	add	r7, sp, #0x0
 801f382: 6078         	str	r0, [r7, #0x4]
 801f384: 6039         	str	r1, [r7]
; 	return (thread->base.thread_state & state) != 0U;
 801f386: 687b         	ldr	r3, [r7, #0x4]
 801f388: 7b5b         	ldrb	r3, [r3, #0xd]
 801f38a: 461a         	mov	r2, r3
 801f38c: 683b         	ldr	r3, [r7]
 801f38e: 4013         	ands	r3, r2
 801f390: 2b00         	cmp	r3, #0x0
 801f392: bf14         	ite	ne
 801f394: 2301         	movne	r3, #0x1
 801f396: 2300         	moveq	r3, #0x0
 801f398: b2db         	uxtb	r3, r3
; }
 801f39a: 4618         	mov	r0, r3
 801f39c: 370c         	adds	r7, #0xc
 801f39e: 46bd         	mov	sp, r7
 801f3a0: f85d 7b04    	ldr	r7, [sp], #4
 801f3a4: 4770         	bx	lr

0801f3a6 <z_is_thread_queued>:
; {
 801f3a6: b580         	push	{r7, lr}
 801f3a8: b082         	sub	sp, #0x8
 801f3aa: af00         	add	r7, sp, #0x0
 801f3ac: 6078         	str	r0, [r7, #0x4]
; 	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 801f3ae: 2180         	movs	r1, #0x80
 801f3b0: 6878         	ldr	r0, [r7, #0x4]
 801f3b2: f7ff ffe3    	bl	0x801f37c <z_is_thread_state_set> @ imm = #-0x3a
 801f3b6: 4603         	mov	r3, r0
; }
 801f3b8: 4618         	mov	r0, r3
 801f3ba: 3708         	adds	r7, #0x8
 801f3bc: 46bd         	mov	sp, r7
 801f3be: bd80         	pop	{r7, pc}

0801f3c0 <z_mark_thread_as_suspended>:
; {
 801f3c0: b480         	push	{r7}
 801f3c2: b083         	sub	sp, #0xc
 801f3c4: af00         	add	r7, sp, #0x0
 801f3c6: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_SUSPENDED;
 801f3c8: 687b         	ldr	r3, [r7, #0x4]
 801f3ca: 7b5b         	ldrb	r3, [r3, #0xd]
 801f3cc: f043 0310    	orr	r3, r3, #0x10
 801f3d0: b2da         	uxtb	r2, r3
 801f3d2: 687b         	ldr	r3, [r7, #0x4]
 801f3d4: 735a         	strb	r2, [r3, #0xd]
; }
 801f3d6: bf00         	nop
 801f3d8: 370c         	adds	r7, #0xc
 801f3da: 46bd         	mov	sp, r7
 801f3dc: f85d 7b04    	ldr	r7, [sp], #4
 801f3e0: 4770         	bx	lr

0801f3e2 <z_mark_thread_as_not_suspended>:
; {
 801f3e2: b480         	push	{r7}
 801f3e4: b083         	sub	sp, #0xc
 801f3e6: af00         	add	r7, sp, #0x0
 801f3e8: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 801f3ea: 687b         	ldr	r3, [r7, #0x4]
 801f3ec: 7b5b         	ldrb	r3, [r3, #0xd]
 801f3ee: f023 0310    	bic	r3, r3, #0x10
 801f3f2: b2da         	uxtb	r2, r3
 801f3f4: 687b         	ldr	r3, [r7, #0x4]
 801f3f6: 735a         	strb	r2, [r3, #0xd]
; }
 801f3f8: bf00         	nop
 801f3fa: 370c         	adds	r7, #0xc
 801f3fc: 46bd         	mov	sp, r7
 801f3fe: f85d 7b04    	ldr	r7, [sp], #4
 801f402: 4770         	bx	lr

0801f404 <z_mark_thread_as_pending>:
; {
 801f404: b480         	push	{r7}
 801f406: b083         	sub	sp, #0xc
 801f408: af00         	add	r7, sp, #0x0
 801f40a: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_PENDING;
 801f40c: 687b         	ldr	r3, [r7, #0x4]
 801f40e: 7b5b         	ldrb	r3, [r3, #0xd]
 801f410: f043 0302    	orr	r3, r3, #0x2
 801f414: b2da         	uxtb	r2, r3
 801f416: 687b         	ldr	r3, [r7, #0x4]
 801f418: 735a         	strb	r2, [r3, #0xd]
; }
 801f41a: bf00         	nop
 801f41c: 370c         	adds	r7, #0xc
 801f41e: 46bd         	mov	sp, r7
 801f420: f85d 7b04    	ldr	r7, [sp], #4
 801f424: 4770         	bx	lr

0801f426 <z_mark_thread_as_not_pending>:
; {
 801f426: b480         	push	{r7}
 801f428: b083         	sub	sp, #0xc
 801f42a: af00         	add	r7, sp, #0x0
 801f42c: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 801f42e: 687b         	ldr	r3, [r7, #0x4]
 801f430: 7b5b         	ldrb	r3, [r3, #0xd]
 801f432: f023 0302    	bic	r3, r3, #0x2
 801f436: b2da         	uxtb	r2, r3
 801f438: 687b         	ldr	r3, [r7, #0x4]
 801f43a: 735a         	strb	r2, [r3, #0xd]
; }
 801f43c: bf00         	nop
 801f43e: 370c         	adds	r7, #0xc
 801f440: 46bd         	mov	sp, r7
 801f442: f85d 7b04    	ldr	r7, [sp], #4
 801f446: 4770         	bx	lr

0801f448 <z_is_thread_essential>:
; {
 801f448: b480         	push	{r7}
 801f44a: b083         	sub	sp, #0xc
 801f44c: af00         	add	r7, sp, #0x0
 801f44e: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
 801f450: 687b         	ldr	r3, [r7, #0x4]
 801f452: 7b1b         	ldrb	r3, [r3, #0xc]
 801f454: f003 0301    	and	r3, r3, #0x1
 801f458: 2b00         	cmp	r3, #0x0
 801f45a: bf14         	ite	ne
 801f45c: 2301         	movne	r3, #0x1
 801f45e: 2300         	moveq	r3, #0x0
 801f460: b2db         	uxtb	r3, r3
; }
 801f462: 4618         	mov	r0, r3
 801f464: 370c         	adds	r7, #0xc
 801f466: 46bd         	mov	sp, r7
 801f468: f85d 7b04    	ldr	r7, [sp], #4
 801f46c: 4770         	bx	lr

0801f46e <z_reschedule_unlocked>:
; {
 801f46e: b580         	push	{r7, lr}
 801f470: b084         	sub	sp, #0x10
 801f472: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 801f474: f3ef 8311    	mrs	r3, basepri
 801f478: 60fb         	str	r3, [r7, #0xc]
;   return(result);
 801f47a: 68fb         	ldr	r3, [r7, #0xc]
; 	key = __get_BASEPRI();
 801f47c: 60bb         	str	r3, [r7, #0x8]
 801f47e: 2310         	movs	r3, #0x10
 801f480: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801f482: 687b         	ldr	r3, [r7, #0x4]
 801f484: f383 8812    	msr	basepri_max, r3
; }
 801f488: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801f48a: f3bf 8f6f    	isb	sy
; }
 801f48e: bf00         	nop
; 	return key;
 801f490: 68bb         	ldr	r3, [r7, #0x8]
; 	(void) z_reschedule_irqlock(arch_irq_lock());
 801f492: 4618         	mov	r0, r3
 801f494: f000 f9b8    	bl	0x801f808 <z_reschedule_irqlock> @ imm = #0x370
; }
 801f498: bf00         	nop
 801f49a: 3710         	adds	r7, #0x10
 801f49c: 46bd         	mov	sp, r7
 801f49e: bd80         	pop	{r7, pc}

0801f4a0 <unpend_thread_no_timeout>:
; {
 801f4a0: b580         	push	{r7, lr}
 801f4a2: b086         	sub	sp, #0x18
 801f4a4: af00         	add	r7, sp, #0x0
 801f4a6: 6078         	str	r0, [r7, #0x4]
 801f4a8: 687b         	ldr	r3, [r7, #0x4]
 801f4aa: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 801f4ac: 68fb         	ldr	r3, [r7, #0xc]
 801f4ae: 689b         	ldr	r3, [r3, #0x8]
 801f4b0: 617b         	str	r3, [r7, #0x14]
 801f4b2: 687b         	ldr	r3, [r7, #0x4]
 801f4b4: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801f4b6: 693b         	ldr	r3, [r7, #0x10]
 801f4b8: 4618         	mov	r0, r3
 801f4ba: f7ff fe94    	bl	0x801f1e6 <sys_dlist_remove> @ imm = #-0x2d8
; }
 801f4be: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 801f4c0: 6878         	ldr	r0, [r7, #0x4]
 801f4c2: f7ff ffb0    	bl	0x801f426 <z_mark_thread_as_not_pending> @ imm = #-0xa0
; 	thread->base.pended_on = NULL;
 801f4c6: 687b         	ldr	r3, [r7, #0x4]
 801f4c8: 2200         	movs	r2, #0x0
 801f4ca: 609a         	str	r2, [r3, #0x8]
; }
 801f4cc: bf00         	nop
 801f4ce: 3718         	adds	r7, #0x18
 801f4d0: 46bd         	mov	sp, r7
 801f4d2: bd80         	pop	{r7, pc}

0801f4d4 <z_waitq_head>:
; {
 801f4d4: b580         	push	{r7, lr}
 801f4d6: b082         	sub	sp, #0x8
 801f4d8: af00         	add	r7, sp, #0x0
 801f4da: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 801f4dc: 687b         	ldr	r3, [r7, #0x4]
 801f4de: 4618         	mov	r0, r3
 801f4e0: f7ff fe14    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #-0x3d8
 801f4e4: 4603         	mov	r3, r0
; }
 801f4e6: 4618         	mov	r0, r3
 801f4e8: 3708         	adds	r7, #0x8
 801f4ea: 46bd         	mov	sp, r7
 801f4ec: bd80         	pop	{r7, pc}

0801f4ee <z_swap_irqlock>:
; {
 801f4ee: b580         	push	{r7, lr}
 801f4f0: b084         	sub	sp, #0x10
 801f4f2: af00         	add	r7, sp, #0x0
 801f4f4: 6078         	str	r0, [r7, #0x4]
; 	ret = arch_swap(key);
 801f4f6: 6878         	ldr	r0, [r7, #0x4]
 801f4f8: f7e7 fc90    	bl	0x8006e1c <arch_swap>   @ imm = #-0x186e0
 801f4fc: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 801f4fe: 68fb         	ldr	r3, [r7, #0xc]
; }
 801f500: 4618         	mov	r0, r3
 801f502: 3710         	adds	r7, #0x10
 801f504: 46bd         	mov	sp, r7
 801f506: bd80         	pop	{r7, pc}

0801f508 <z_log_msg_runtime_create>:
; {
 801f508: b580         	push	{r7, lr}
 801f50a: b08a         	sub	sp, #0x28
 801f50c: af04         	add	r7, sp, #0x10
 801f50e: 60b9         	str	r1, [r7, #0x8]
 801f510: 607b         	str	r3, [r7, #0x4]
 801f512: 4603         	mov	r3, r0
 801f514: 73fb         	strb	r3, [r7, #0xf]
 801f516: 4613         	mov	r3, r2
 801f518: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 801f51a: f107 032c    	add.w	r3, r7, #0x2c
 801f51e: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801f520: 7bba         	ldrb	r2, [r7, #0xe]
 801f522: 7bf8         	ldrb	r0, [r7, #0xf]
 801f524: 697b         	ldr	r3, [r7, #0x14]
 801f526: 9303         	str	r3, [sp, #0xc]
 801f528: 6abb         	ldr	r3, [r7, #0x28]
 801f52a: 9302         	str	r3, [sp, #0x8]
 801f52c: 6a7b         	ldr	r3, [r7, #0x24]
 801f52e: 9301         	str	r3, [sp, #0x4]
 801f530: 6a3b         	ldr	r3, [r7, #0x20]
 801f532: 9300         	str	r3, [sp]
 801f534: 687b         	ldr	r3, [r7, #0x4]
 801f536: 68b9         	ldr	r1, [r7, #0x8]
 801f538: f7e6 f81c    	bl	0x8005574 <z_log_msg_runtime_vcreate> @ imm = #-0x19fc8
; }
 801f53c: bf00         	nop
 801f53e: 3718         	adds	r7, #0x18
 801f540: 46bd         	mov	sp, r7
 801f542: bd80         	pop	{r7, pc}

0801f544 <z_sched_prio_cmp>:
; {
 801f544: b480         	push	{r7}
 801f546: b085         	sub	sp, #0x14
 801f548: af00         	add	r7, sp, #0x0
 801f54a: 6078         	str	r0, [r7, #0x4]
 801f54c: 6039         	str	r1, [r7]
; 	int32_t b1 = thread_1->base.prio;
 801f54e: 687b         	ldr	r3, [r7, #0x4]
 801f550: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 801f554: 60fb         	str	r3, [r7, #0xc]
; 	int32_t b2 = thread_2->base.prio;
 801f556: 683b         	ldr	r3, [r7]
 801f558: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 801f55c: 60bb         	str	r3, [r7, #0x8]
; 	if (b1 != b2) {
 801f55e: 68fa         	ldr	r2, [r7, #0xc]
 801f560: 68bb         	ldr	r3, [r7, #0x8]
 801f562: 429a         	cmp	r2, r3
 801f564: d003         	beq	0x801f56e <z_sched_prio_cmp+0x2a> @ imm = #0x6
; 		return b2 - b1;
 801f566: 68ba         	ldr	r2, [r7, #0x8]
 801f568: 68fb         	ldr	r3, [r7, #0xc]
 801f56a: 1ad3         	subs	r3, r2, r3
 801f56c: e000         	b	0x801f570 <z_sched_prio_cmp+0x2c> @ imm = #0x0
; 	return 0;
 801f56e: 2300         	movs	r3, #0x0
; }
 801f570: 4618         	mov	r0, r3
 801f572: 3714         	adds	r7, #0x14
 801f574: 46bd         	mov	sp, r7
 801f576: f85d 7b04    	ldr	r7, [sp], #4
 801f57a: 4770         	bx	lr

0801f57c <should_queue_thread>:
; {
 801f57c: b480         	push	{r7}
 801f57e: b083         	sub	sp, #0xc
 801f580: af00         	add	r7, sp, #0x0
 801f582: 6078         	str	r0, [r7, #0x4]
; 	return !IS_ENABLED(CONFIG_SMP) || (thread != arch_current_thread());
 801f584: 2301         	movs	r3, #0x1
; }
 801f586: 4618         	mov	r0, r3
 801f588: 370c         	adds	r7, #0xc
 801f58a: 46bd         	mov	sp, r7
 801f58c: f85d 7b04    	ldr	r7, [sp], #4
 801f590: 4770         	bx	lr

0801f592 <is_aborting>:
; {
 801f592: b480         	push	{r7}
 801f594: b083         	sub	sp, #0xc
 801f596: af00         	add	r7, sp, #0x0
 801f598: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_ABORTING) != 0U;
 801f59a: 687b         	ldr	r3, [r7, #0x4]
 801f59c: 7b5b         	ldrb	r3, [r3, #0xd]
 801f59e: f003 0320    	and	r3, r3, #0x20
 801f5a2: 2b00         	cmp	r3, #0x0
 801f5a4: bf14         	ite	ne
 801f5a6: 2301         	movne	r3, #0x1
 801f5a8: 2300         	moveq	r3, #0x0
 801f5aa: b2db         	uxtb	r3, r3
; }
 801f5ac: 4618         	mov	r0, r3
 801f5ae: 370c         	adds	r7, #0xc
 801f5b0: 46bd         	mov	sp, r7
 801f5b2: f85d 7b04    	ldr	r7, [sp], #4
 801f5b6: 4770         	bx	lr

0801f5b8 <is_halting>:
; {
 801f5b8: b480         	push	{r7}
 801f5ba: b083         	sub	sp, #0xc
 801f5bc: af00         	add	r7, sp, #0x0
 801f5be: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state &
 801f5c0: 687b         	ldr	r3, [r7, #0x4]
 801f5c2: 7b5b         	ldrb	r3, [r3, #0xd]
 801f5c4: f003 0360    	and	r3, r3, #0x60
; 		(_THREAD_ABORTING | _THREAD_SUSPENDING)) != 0U;
 801f5c8: 2b00         	cmp	r3, #0x0
 801f5ca: bf14         	ite	ne
 801f5cc: 2301         	movne	r3, #0x1
 801f5ce: 2300         	moveq	r3, #0x0
 801f5d0: b2db         	uxtb	r3, r3
; }
 801f5d2: 4618         	mov	r0, r3
 801f5d4: 370c         	adds	r7, #0xc
 801f5d6: 46bd         	mov	sp, r7
 801f5d8: f85d 7b04    	ldr	r7, [sp], #4
 801f5dc: 4770         	bx	lr

0801f5de <clear_halting>:
; {
 801f5de: b480         	push	{r7}
 801f5e0: b083         	sub	sp, #0xc
 801f5e2: af00         	add	r7, sp, #0x0
 801f5e4: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("dmb 0xF":::"memory");
 801f5e6: f3bf 8f5f    	dmb	sy
; }
 801f5ea: bf00         	nop
; }
 801f5ec: bf00         	nop
; }
 801f5ee: bf00         	nop
; 	thread->base.thread_state &= ~(_THREAD_ABORTING | _THREAD_SUSPENDING);
 801f5f0: 687b         	ldr	r3, [r7, #0x4]
 801f5f2: 7b5b         	ldrb	r3, [r3, #0xd]
 801f5f4: f023 0360    	bic	r3, r3, #0x60
 801f5f8: b2da         	uxtb	r2, r3
 801f5fa: 687b         	ldr	r3, [r7, #0x4]
 801f5fc: 735a         	strb	r2, [r3, #0xd]
; }
 801f5fe: bf00         	nop
 801f600: 370c         	adds	r7, #0xc
 801f602: 46bd         	mov	sp, r7
 801f604: f85d 7b04    	ldr	r7, [sp], #4
 801f608: 4770         	bx	lr

0801f60a <update_metairq_preempt>:
; {
 801f60a: b480         	push	{r7}
 801f60c: b083         	sub	sp, #0xc
 801f60e: af00         	add	r7, sp, #0x0
 801f610: 6078         	str	r0, [r7, #0x4]
; }
 801f612: bf00         	nop
 801f614: 370c         	adds	r7, #0xc
 801f616: 46bd         	mov	sp, r7
 801f618: f85d 7b04    	ldr	r7, [sp], #4
 801f61c: 4770         	bx	lr

0801f61e <thread_active_elsewhere>:
; {
 801f61e: b480         	push	{r7}
 801f620: b083         	sub	sp, #0xc
 801f622: af00         	add	r7, sp, #0x0
 801f624: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 801f626: 2300         	movs	r3, #0x0
; }
 801f628: 4618         	mov	r0, r3
 801f62a: 370c         	adds	r7, #0xc
 801f62c: 46bd         	mov	sp, r7
 801f62e: f85d 7b04    	ldr	r7, [sp], #4
 801f632: 4770         	bx	lr

0801f634 <add_to_waitq_locked>:
; {
 801f634: b580         	push	{r7, lr}
 801f636: b086         	sub	sp, #0x18
 801f638: af00         	add	r7, sp, #0x0
 801f63a: 6078         	str	r0, [r7, #0x4]
 801f63c: 6039         	str	r1, [r7]
; 	unready_thread(thread);
 801f63e: 6878         	ldr	r0, [r7, #0x4]
 801f640: f7f2 f818    	bl	0x8011674 <unready_thread> @ imm = #-0xdfd0
; 	z_mark_thread_as_pending(thread);
 801f644: 6878         	ldr	r0, [r7, #0x4]
 801f646: f7ff fedd    	bl	0x801f404 <z_mark_thread_as_pending> @ imm = #-0x246
; 	if (wait_q != NULL) {
 801f64a: 683b         	ldr	r3, [r7]
 801f64c: 2b00         	cmp	r3, #0x0
 801f64e: d041         	beq	0x801f6d4 <add_to_waitq_locked+0xa0> @ imm = #0x82
; 		thread->base.pended_on = wait_q;
 801f650: 687b         	ldr	r3, [r7, #0x4]
 801f652: 683a         	ldr	r2, [r7]
 801f654: 609a         	str	r2, [r3, #0x8]
; 		_priq_wait_add(&wait_q->waitq, thread);
 801f656: 683b         	ldr	r3, [r7]
 801f658: 617b         	str	r3, [r7, #0x14]
 801f65a: 687b         	ldr	r3, [r7, #0x4]
 801f65c: 613b         	str	r3, [r7, #0x10]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 801f65e: 6978         	ldr	r0, [r7, #0x14]
 801f660: f7ff fd54    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #-0x558
 801f664: 4603         	mov	r3, r0
 801f666: 2b00         	cmp	r3, #0x0
 801f668: d004         	beq	0x801f674 <add_to_waitq_locked+0x40> @ imm = #0x8
 801f66a: 6978         	ldr	r0, [r7, #0x14]
 801f66c: f7ff fd4e    	bl	0x801f10c <sys_dlist_peek_head> @ imm = #-0x564
 801f670: 4603         	mov	r3, r0
 801f672: e000         	b	0x801f676 <add_to_waitq_locked+0x42> @ imm = #0x0
 801f674: 2300         	movs	r3, #0x0
 801f676: 60fb         	str	r3, [r7, #0xc]
 801f678: e024         	b	0x801f6c4 <add_to_waitq_locked+0x90> @ imm = #0x48
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 801f67a: 68f9         	ldr	r1, [r7, #0xc]
 801f67c: 6938         	ldr	r0, [r7, #0x10]
 801f67e: f7ff ff61    	bl	0x801f544 <z_sched_prio_cmp> @ imm = #-0x13e
 801f682: 4603         	mov	r3, r0
 801f684: 2b00         	cmp	r3, #0x0
 801f686: dd07         	ble	0x801f698 <add_to_waitq_locked+0x64> @ imm = #0xe
; 			sys_dlist_insert(&t->base.qnode_dlist,
 801f688: 68fb         	ldr	r3, [r7, #0xc]
 801f68a: 693a         	ldr	r2, [r7, #0x10]
 801f68c: 4611         	mov	r1, r2
 801f68e: 4618         	mov	r0, r3
 801f690: f7ff fd8f    	bl	0x801f1b2 <sys_dlist_insert> @ imm = #-0x4e2
; 			return;
 801f694: bf00         	nop
; }
 801f696: e01d         	b	0x801f6d4 <add_to_waitq_locked+0xa0> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 801f698: 68fb         	ldr	r3, [r7, #0xc]
 801f69a: 2b00         	cmp	r3, #0x0
 801f69c: d010         	beq	0x801f6c0 <add_to_waitq_locked+0x8c> @ imm = #0x20
 801f69e: 68fb         	ldr	r3, [r7, #0xc]
 801f6a0: 4619         	mov	r1, r3
 801f6a2: 6978         	ldr	r0, [r7, #0x14]
 801f6a4: f7ff fd58    	bl	0x801f158 <sys_dlist_peek_next> @ imm = #-0x550
 801f6a8: 4603         	mov	r3, r0
 801f6aa: 2b00         	cmp	r3, #0x0
 801f6ac: d006         	beq	0x801f6bc <add_to_waitq_locked+0x88> @ imm = #0xc
 801f6ae: 68fb         	ldr	r3, [r7, #0xc]
 801f6b0: 4619         	mov	r1, r3
 801f6b2: 6978         	ldr	r0, [r7, #0x14]
 801f6b4: f7ff fd50    	bl	0x801f158 <sys_dlist_peek_next> @ imm = #-0x560
 801f6b8: 4603         	mov	r3, r0
 801f6ba: e002         	b	0x801f6c2 <add_to_waitq_locked+0x8e> @ imm = #0x4
 801f6bc: 2300         	movs	r3, #0x0
 801f6be: e000         	b	0x801f6c2 <add_to_waitq_locked+0x8e> @ imm = #0x0
 801f6c0: 2300         	movs	r3, #0x0
 801f6c2: 60fb         	str	r3, [r7, #0xc]
 801f6c4: 68fb         	ldr	r3, [r7, #0xc]
 801f6c6: 2b00         	cmp	r3, #0x0
 801f6c8: d1d7         	bne	0x801f67a <add_to_waitq_locked+0x46> @ imm = #-0x52
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 801f6ca: 693b         	ldr	r3, [r7, #0x10]
 801f6cc: 4619         	mov	r1, r3
 801f6ce: 6978         	ldr	r0, [r7, #0x14]
 801f6d0: f7ff fd55    	bl	0x801f17e <sys_dlist_append> @ imm = #-0x556
; }
 801f6d4: bf00         	nop
 801f6d6: 3718         	adds	r7, #0x18
 801f6d8: 46bd         	mov	sp, r7
 801f6da: bd80         	pop	{r7, pc}

0801f6dc <add_thread_timeout>:
; {
 801f6dc: b580         	push	{r7, lr}
 801f6de: b084         	sub	sp, #0x10
 801f6e0: af00         	add	r7, sp, #0x0
 801f6e2: 60f8         	str	r0, [r7, #0xc]
 801f6e4: e9c7 2300    	strd	r2, r3, [r7]
; 	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 801f6e8: e9d7 2300    	ldrd	r2, r3, [r7]
 801f6ec: f04f 30ff    	mov.w	r0, #0xffffffff
 801f6f0: f04f 31ff    	mov.w	r1, #0xffffffff
 801f6f4: 428b         	cmp	r3, r1
 801f6f6: bf08         	it	eq
 801f6f8: 4282         	cmpeq	r2, r0
 801f6fa: d004         	beq	0x801f706 <add_thread_timeout+0x2a> @ imm = #0x8
; 		z_add_thread_timeout(thread, timeout);
 801f6fc: e9d7 2300    	ldrd	r2, r3, [r7]
 801f700: 68f8         	ldr	r0, [r7, #0xc]
 801f702: f7f1 fb05    	bl	0x8010d10 <z_add_thread_timeout> @ imm = #-0xe9f6
; }
 801f706: bf00         	nop
 801f708: 3710         	adds	r7, #0x10
 801f70a: 46bd         	mov	sp, r7
 801f70c: bd80         	pop	{r7, pc}

0801f70e <pend_locked>:
; {
 801f70e: b580         	push	{r7, lr}
 801f710: b084         	sub	sp, #0x10
 801f712: af00         	add	r7, sp, #0x0
 801f714: 60f8         	str	r0, [r7, #0xc]
 801f716: 60b9         	str	r1, [r7, #0x8]
 801f718: e9c7 2300    	strd	r2, r3, [r7]
; 	add_to_waitq_locked(thread, wait_q);
 801f71c: 68b9         	ldr	r1, [r7, #0x8]
 801f71e: 68f8         	ldr	r0, [r7, #0xc]
 801f720: f7ff ff88    	bl	0x801f634 <add_to_waitq_locked> @ imm = #-0xf0
; 	add_thread_timeout(thread, timeout);
 801f724: e9d7 2300    	ldrd	r2, r3, [r7]
 801f728: 68f8         	ldr	r0, [r7, #0xc]
 801f72a: f7ff ffd7    	bl	0x801f6dc <add_thread_timeout> @ imm = #-0x52
; }
 801f72e: bf00         	nop
 801f730: 3710         	adds	r7, #0x10
 801f732: 46bd         	mov	sp, r7
 801f734: bd80         	pop	{r7, pc}

0801f736 <z_thread_timeout>:
; {
 801f736: b580         	push	{r7, lr}
 801f738: b084         	sub	sp, #0x10
 801f73a: af00         	add	r7, sp, #0x0
 801f73c: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = CONTAINER_OF(timeout,
 801f73e: 687b         	ldr	r3, [r7, #0x4]
 801f740: 3b18         	subs	r3, #0x18
 801f742: 60fb         	str	r3, [r7, #0xc]
; 	z_sched_wake_thread(thread, true);
 801f744: 2101         	movs	r1, #0x1
 801f746: 68f8         	ldr	r0, [r7, #0xc]
 801f748: f7f2 f832    	bl	0x80117b0 <z_sched_wake_thread> @ imm = #-0xdf9c
; }
 801f74c: bf00         	nop
 801f74e: 3710         	adds	r7, #0x10
 801f750: 46bd         	mov	sp, r7
 801f752: bd80         	pop	{r7, pc}

0801f754 <resched>:
; {
 801f754: b480         	push	{r7}
 801f756: b085         	sub	sp, #0x14
 801f758: af00         	add	r7, sp, #0x0
 801f75a: 6078         	str	r0, [r7, #0x4]
 801f75c: 687b         	ldr	r3, [r7, #0x4]
 801f75e: 60fb         	str	r3, [r7, #0xc]
; 	return key == 0U;
 801f760: 68fb         	ldr	r3, [r7, #0xc]
 801f762: 2b00         	cmp	r3, #0x0
 801f764: bf0c         	ite	eq
 801f766: 2301         	moveq	r3, #0x1
 801f768: 2300         	movne	r3, #0x0
 801f76a: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 801f76c: 2b00         	cmp	r3, #0x0
 801f76e: d00f         	beq	0x801f790 <resched+0x3c> @ imm = #0x1e
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 801f770: f3ef 8305    	mrs	r3, ipsr
 801f774: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 801f776: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 801f778: 2b00         	cmp	r3, #0x0
 801f77a: bf14         	ite	ne
 801f77c: 2301         	movne	r3, #0x1
 801f77e: 2300         	moveq	r3, #0x0
 801f780: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 801f782: f083 0301    	eor	r3, r3, #0x1
 801f786: b2db         	uxtb	r3, r3
 801f788: 2b00         	cmp	r3, #0x0
 801f78a: d001         	beq	0x801f790 <resched+0x3c> @ imm = #0x2
 801f78c: 2301         	movs	r3, #0x1
 801f78e: e000         	b	0x801f792 <resched+0x3e> @ imm = #0x0
 801f790: 2300         	movs	r3, #0x0
 801f792: f003 0301    	and	r3, r3, #0x1
 801f796: b2db         	uxtb	r3, r3
; }
 801f798: 4618         	mov	r0, r3
 801f79a: 3714         	adds	r7, #0x14
 801f79c: 46bd         	mov	sp, r7
 801f79e: f85d 7b04    	ldr	r7, [sp], #4
 801f7a2: 4770         	bx	lr

0801f7a4 <z_reschedule>:
; {
 801f7a4: b580         	push	{r7, lr}
 801f7a6: b08a         	sub	sp, #0x28
 801f7a8: af00         	add	r7, sp, #0x0
 801f7aa: 6078         	str	r0, [r7, #0x4]
 801f7ac: 6039         	str	r1, [r7]
; 	if (resched(key.key) && need_swap()) {
 801f7ae: 683b         	ldr	r3, [r7]
 801f7b0: 4618         	mov	r0, r3
 801f7b2: f7ff ffcf    	bl	0x801f754 <resched>     @ imm = #-0x62
 801f7b6: 4603         	mov	r3, r0
 801f7b8: 2b00         	cmp	r3, #0x0
 801f7ba: d010         	beq	0x801f7de <z_reschedule+0x3a> @ imm = #0x20
 801f7bc: f7f2 f9fa    	bl	0x8011bb4 <need_swap>   @ imm = #-0xdc0c
 801f7c0: 4603         	mov	r3, r0
 801f7c2: 2b00         	cmp	r3, #0x0
 801f7c4: d00b         	beq	0x801f7de <z_reschedule+0x3a> @ imm = #0x16
 801f7c6: 687b         	ldr	r3, [r7, #0x4]
 801f7c8: 627b         	str	r3, [r7, #0x24]
 801f7ca: 683b         	ldr	r3, [r7]
 801f7cc: 60fb         	str	r3, [r7, #0xc]
 801f7ce: 6a7b         	ldr	r3, [r7, #0x24]
 801f7d0: 623b         	str	r3, [r7, #0x20]
; }
 801f7d2: bf00         	nop
; 	return z_swap_irqlock(key.key);
 801f7d4: 68fb         	ldr	r3, [r7, #0xc]
 801f7d6: 4618         	mov	r0, r3
 801f7d8: f7ff fe89    	bl	0x801f4ee <z_swap_irqlock> @ imm = #-0x2ee
; 		z_swap(lock, key);
 801f7dc: e010         	b	0x801f800 <z_reschedule+0x5c> @ imm = #0x20
 801f7de: 687b         	ldr	r3, [r7, #0x4]
 801f7e0: 61fb         	str	r3, [r7, #0x1c]
 801f7e2: 683b         	ldr	r3, [r7]
 801f7e4: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 801f7e6: 693b         	ldr	r3, [r7, #0x10]
 801f7e8: 61bb         	str	r3, [r7, #0x18]
 801f7ea: 69bb         	ldr	r3, [r7, #0x18]
 801f7ec: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801f7ee: 697b         	ldr	r3, [r7, #0x14]
 801f7f0: f383 8811    	msr	basepri, r3
; }
 801f7f4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801f7f6: f3bf 8f6f    	isb	sy
; }
 801f7fa: bf00         	nop
; }
 801f7fc: bf00         	nop
; }
 801f7fe: bf00         	nop
; }
 801f800: bf00         	nop
 801f802: 3728         	adds	r7, #0x28
 801f804: 46bd         	mov	sp, r7
 801f806: bd80         	pop	{r7, pc}

0801f808 <z_reschedule_irqlock>:
; {
 801f808: b580         	push	{r7, lr}
 801f80a: b084         	sub	sp, #0x10
 801f80c: af00         	add	r7, sp, #0x0
 801f80e: 6078         	str	r0, [r7, #0x4]
; 	if (resched(key) && need_swap()) {
 801f810: 6878         	ldr	r0, [r7, #0x4]
 801f812: f7ff ff9f    	bl	0x801f754 <resched>     @ imm = #-0xc2
 801f816: 4603         	mov	r3, r0
 801f818: 2b00         	cmp	r3, #0x0
 801f81a: d008         	beq	0x801f82e <z_reschedule_irqlock+0x26> @ imm = #0x10
 801f81c: f7f2 f9ca    	bl	0x8011bb4 <need_swap>   @ imm = #-0xdc6c
 801f820: 4603         	mov	r3, r0
 801f822: 2b00         	cmp	r3, #0x0
 801f824: d003         	beq	0x801f82e <z_reschedule_irqlock+0x26> @ imm = #0x6
; 		z_swap_irqlock(key);
 801f826: 6878         	ldr	r0, [r7, #0x4]
 801f828: f7ff fe61    	bl	0x801f4ee <z_swap_irqlock> @ imm = #-0x33e
 801f82c: e00b         	b	0x801f846 <z_reschedule_irqlock+0x3e> @ imm = #0x16
 801f82e: 687b         	ldr	r3, [r7, #0x4]
 801f830: 60fb         	str	r3, [r7, #0xc]
 801f832: 68fb         	ldr	r3, [r7, #0xc]
 801f834: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 801f836: 68bb         	ldr	r3, [r7, #0x8]
 801f838: f383 8811    	msr	basepri, r3
; }
 801f83c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 801f83e: f3bf 8f6f    	isb	sy
; }
 801f842: bf00         	nop
; }
 801f844: bf00         	nop
; }
 801f846: bf00         	nop
 801f848: 3710         	adds	r7, #0x10
 801f84a: 46bd         	mov	sp, r7
 801f84c: bd80         	pop	{r7, pc}

0801f84e <init_ready_q>:
; {
 801f84e: b580         	push	{r7, lr}
 801f850: b084         	sub	sp, #0x10
 801f852: af00         	add	r7, sp, #0x0
 801f854: 6078         	str	r0, [r7, #0x4]
; 	_priq_run_init(&ready_q->runq);
 801f856: 687b         	ldr	r3, [r7, #0x4]
 801f858: 3304         	adds	r3, #0x4
 801f85a: 60fb         	str	r3, [r7, #0xc]
; 	sys_dlist_init(pq);
 801f85c: 68f8         	ldr	r0, [r7, #0xc]
 801f85e: f7ff fc12    	bl	0x801f086 <sys_dlist_init> @ imm = #-0x7dc
; }
 801f862: bf00         	nop
; }
 801f864: bf00         	nop
 801f866: 3710         	adds	r7, #0x10
 801f868: 46bd         	mov	sp, r7
 801f86a: bd80         	pop	{r7, pc}

0801f86c <z_impl_k_usleep>:
; {
 801f86c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801f870: b084         	sub	sp, #0x10
 801f872: af00         	add	r7, sp, #0x0
 801f874: 6078         	str	r0, [r7, #0x4]
; 	ticks = k_us_to_ticks_ceil64(us);
 801f876: 6879         	ldr	r1, [r7, #0x4]
 801f878: 17c8         	asrs	r0, r1, #0x1f
 801f87a: 460a         	mov	r2, r1
 801f87c: 4603         	mov	r3, r0
 801f87e: f112 0463    	adds.w	r4, r2, #0x63
 801f882: f143 0500    	adc	r5, r3, #0x0
 801f886: f04f 0264    	mov.w	r2, #0x64
 801f88a: f04f 0300    	mov.w	r3, #0x0
 801f88e: 4620         	mov	r0, r4
 801f890: 4629         	mov	r1, r5
 801f892: f7e1 f8e7    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x1ee32
 801f896: 4602         	mov	r2, r0
 801f898: 460b         	mov	r3, r1
 801f89a: 4613         	mov	r3, r2
 801f89c: 60fb         	str	r3, [r7, #0xc]
; 	ticks = z_tick_sleep(ticks);
 801f89e: 68fb         	ldr	r3, [r7, #0xc]
 801f8a0: 17da         	asrs	r2, r3, #0x1f
 801f8a2: 4698         	mov	r8, r3
 801f8a4: 4691         	mov	r9, r2
 801f8a6: 4640         	mov	r0, r8
 801f8a8: 4649         	mov	r1, r9
 801f8aa: f7f2 fbd9    	bl	0x8012060 <z_tick_sleep> @ imm = #-0xd84e
 801f8ae: 60f8         	str	r0, [r7, #0xc]
; 	int32_t ret = k_ticks_to_us_ceil64(ticks);
 801f8b0: 68fb         	ldr	r3, [r7, #0xc]
 801f8b2: 17da         	asrs	r2, r3, #0x1f
 801f8b4: 469a         	mov	r10, r3
 801f8b6: 4693         	mov	r11, r2
 801f8b8: 4652         	mov	r2, r10
 801f8ba: 2364         	movs	r3, #0x64
 801f8bc: fb02 f303    	mul	r3, r2, r3
 801f8c0: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 801f8c2: 68bb         	ldr	r3, [r7, #0x8]
; }
 801f8c4: 4618         	mov	r0, r3
 801f8c6: 3710         	adds	r7, #0x10
 801f8c8: 46bd         	mov	sp, r7
 801f8ca: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801f8ce <unpend_all>:
; {
 801f8ce: b580         	push	{r7, lr}
 801f8d0: b086         	sub	sp, #0x18
 801f8d2: af00         	add	r7, sp, #0x0
 801f8d4: 6078         	str	r0, [r7, #0x4]
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 801f8d6: 6878         	ldr	r0, [r7, #0x4]
 801f8d8: f7ff fdfc    	bl	0x801f4d4 <z_waitq_head> @ imm = #-0x408
 801f8dc: 6178         	str	r0, [r7, #0x14]
 801f8de: e015         	b	0x801f90c <unpend_all+0x3e> @ imm = #0x2a
; 		unpend_thread_no_timeout(thread);
 801f8e0: 6978         	ldr	r0, [r7, #0x14]
 801f8e2: f7ff fddd    	bl	0x801f4a0 <unpend_thread_no_timeout> @ imm = #-0x446
; 		(void)z_abort_thread_timeout(thread);
 801f8e6: 6978         	ldr	r0, [r7, #0x14]
 801f8e8: f7ff fcbd    	bl	0x801f266 <z_abort_thread_timeout> @ imm = #-0x686
 801f8ec: 697b         	ldr	r3, [r7, #0x14]
 801f8ee: 613b         	str	r3, [r7, #0x10]
 801f8f0: 2300         	movs	r3, #0x0
 801f8f2: 60fb         	str	r3, [r7, #0xc]
; 	thread->arch.swap_return_value = value;
 801f8f4: 693b         	ldr	r3, [r7, #0x10]
 801f8f6: 68fa         	ldr	r2, [r7, #0xc]
 801f8f8: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 801f8fc: bf00         	nop
; 		ready_thread(thread);
 801f8fe: 6978         	ldr	r0, [r7, #0x14]
 801f900: f7f1 fb42    	bl	0x8010f88 <ready_thread> @ imm = #-0xe97c
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 801f904: 6878         	ldr	r0, [r7, #0x4]
 801f906: f7ff fde5    	bl	0x801f4d4 <z_waitq_head> @ imm = #-0x436
 801f90a: 6178         	str	r0, [r7, #0x14]
 801f90c: 697b         	ldr	r3, [r7, #0x14]
 801f90e: 2b00         	cmp	r3, #0x0
 801f910: d1e6         	bne	0x801f8e0 <unpend_all+0x12> @ imm = #-0x34
; }
 801f912: bf00         	nop
 801f914: bf00         	nop
 801f916: 3718         	adds	r7, #0x18
 801f918: 46bd         	mov	sp, r7
 801f91a: bd80         	pop	{r7, pc}

0801f91c <thread_is_preemptible>:
; {
 801f91c: b480         	push	{r7}
 801f91e: b083         	sub	sp, #0xc
 801f920: af00         	add	r7, sp, #0x0
 801f922: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 801f924: 687b         	ldr	r3, [r7, #0x4]
 801f926: 89db         	ldrh	r3, [r3, #0xe]
 801f928: 2b7f         	cmp	r3, #0x7f
 801f92a: bf94         	ite	ls
 801f92c: 2301         	movls	r3, #0x1
 801f92e: 2300         	movhi	r3, #0x0
 801f930: b2db         	uxtb	r3, r3
; }
 801f932: 4618         	mov	r0, r3
 801f934: 370c         	adds	r7, #0xc
 801f936: 46bd         	mov	sp, r7
 801f938: f85d 7b04    	ldr	r7, [sp], #4
 801f93c: 4770         	bx	lr

0801f93e <z_is_thread_prevented_from_running>:
; {
 801f93e: b480         	push	{r7}
 801f940: b085         	sub	sp, #0x14
 801f942: af00         	add	r7, sp, #0x0
 801f944: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 801f946: 687b         	ldr	r3, [r7, #0x4]
 801f948: 7b5b         	ldrb	r3, [r3, #0xd]
 801f94a: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 801f94c: 7bfb         	ldrb	r3, [r7, #0xf]
 801f94e: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 801f952: 2b00         	cmp	r3, #0x0
 801f954: bf14         	ite	ne
 801f956: 2301         	movne	r3, #0x1
 801f958: 2300         	moveq	r3, #0x0
 801f95a: b2db         	uxtb	r3, r3
; }
 801f95c: 4618         	mov	r0, r3
 801f95e: 3714         	adds	r7, #0x14
 801f960: 46bd         	mov	sp, r7
 801f962: f85d 7b04    	ldr	r7, [sp], #4
 801f966: 4770         	bx	lr

0801f968 <z_is_prio1_higher_than_prio2>:
; {
 801f968: b480         	push	{r7}
 801f96a: b083         	sub	sp, #0xc
 801f96c: af00         	add	r7, sp, #0x0
 801f96e: 6078         	str	r0, [r7, #0x4]
 801f970: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 801f972: 687a         	ldr	r2, [r7, #0x4]
 801f974: 683b         	ldr	r3, [r7]
 801f976: 429a         	cmp	r2, r3
 801f978: bfb4         	ite	lt
 801f97a: 2301         	movlt	r3, #0x1
 801f97c: 2300         	movge	r3, #0x0
 801f97e: b2db         	uxtb	r3, r3
; }
 801f980: 4618         	mov	r0, r3
 801f982: 370c         	adds	r7, #0xc
 801f984: 46bd         	mov	sp, r7
 801f986: f85d 7b04    	ldr	r7, [sp], #4
 801f98a: 4770         	bx	lr

0801f98c <z_is_prio_higher>:
; {
 801f98c: b580         	push	{r7, lr}
 801f98e: b082         	sub	sp, #0x8
 801f990: af00         	add	r7, sp, #0x0
 801f992: 6078         	str	r0, [r7, #0x4]
 801f994: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 801f996: 6839         	ldr	r1, [r7]
 801f998: 6878         	ldr	r0, [r7, #0x4]
 801f99a: f7ff ffe5    	bl	0x801f968 <z_is_prio1_higher_than_prio2> @ imm = #-0x36
 801f99e: 4603         	mov	r3, r0
; }
 801f9a0: 4618         	mov	r0, r3
 801f9a2: 3708         	adds	r7, #0x8
 801f9a4: 46bd         	mov	sp, r7
 801f9a6: bd80         	pop	{r7, pc}

0801f9a8 <sys_dnode_init>:
; {
 801f9a8: b480         	push	{r7}
 801f9aa: b083         	sub	sp, #0xc
 801f9ac: af00         	add	r7, sp, #0x0
 801f9ae: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801f9b0: 687b         	ldr	r3, [r7, #0x4]
 801f9b2: 2200         	movs	r2, #0x0
 801f9b4: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801f9b6: 687b         	ldr	r3, [r7, #0x4]
 801f9b8: 2200         	movs	r2, #0x0
 801f9ba: 605a         	str	r2, [r3, #0x4]
; }
 801f9bc: bf00         	nop
 801f9be: 370c         	adds	r7, #0xc
 801f9c0: 46bd         	mov	sp, r7
 801f9c2: f85d 7b04    	ldr	r7, [sp], #4
 801f9c6: 4770         	bx	lr

0801f9c8 <sys_dnode_is_linked>:
; {
 801f9c8: b480         	push	{r7}
 801f9ca: b083         	sub	sp, #0xc
 801f9cc: af00         	add	r7, sp, #0x0
 801f9ce: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 801f9d0: 687b         	ldr	r3, [r7, #0x4]
 801f9d2: 681b         	ldr	r3, [r3]
 801f9d4: 2b00         	cmp	r3, #0x0
 801f9d6: bf14         	ite	ne
 801f9d8: 2301         	movne	r3, #0x1
 801f9da: 2300         	moveq	r3, #0x0
 801f9dc: b2db         	uxtb	r3, r3
; }
 801f9de: 4618         	mov	r0, r3
 801f9e0: 370c         	adds	r7, #0xc
 801f9e2: 46bd         	mov	sp, r7
 801f9e4: f85d 7b04    	ldr	r7, [sp], #4
 801f9e8: 4770         	bx	lr

0801f9ea <sys_dlist_is_empty>:
; {
 801f9ea: b480         	push	{r7}
 801f9ec: b083         	sub	sp, #0xc
 801f9ee: af00         	add	r7, sp, #0x0
 801f9f0: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801f9f2: 687b         	ldr	r3, [r7, #0x4]
 801f9f4: 681b         	ldr	r3, [r3]
 801f9f6: 687a         	ldr	r2, [r7, #0x4]
 801f9f8: 429a         	cmp	r2, r3
 801f9fa: bf0c         	ite	eq
 801f9fc: 2301         	moveq	r3, #0x1
 801f9fe: 2300         	movne	r3, #0x0
 801fa00: b2db         	uxtb	r3, r3
; }
 801fa02: 4618         	mov	r0, r3
 801fa04: 370c         	adds	r7, #0xc
 801fa06: 46bd         	mov	sp, r7
 801fa08: f85d 7b04    	ldr	r7, [sp], #4
 801fa0c: 4770         	bx	lr

0801fa0e <sys_dlist_peek_head>:
; {
 801fa0e: b580         	push	{r7, lr}
 801fa10: b082         	sub	sp, #0x8
 801fa12: af00         	add	r7, sp, #0x0
 801fa14: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801fa16: 6878         	ldr	r0, [r7, #0x4]
 801fa18: f7ff ffe7    	bl	0x801f9ea <sys_dlist_is_empty> @ imm = #-0x32
 801fa1c: 4603         	mov	r3, r0
 801fa1e: 2b00         	cmp	r3, #0x0
 801fa20: d102         	bne	0x801fa28 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 801fa22: 687b         	ldr	r3, [r7, #0x4]
 801fa24: 681b         	ldr	r3, [r3]
 801fa26: e000         	b	0x801fa2a <sys_dlist_peek_head+0x1c> @ imm = #0x0
 801fa28: 2300         	movs	r3, #0x0
; }
 801fa2a: 4618         	mov	r0, r3
 801fa2c: 3708         	adds	r7, #0x8
 801fa2e: 46bd         	mov	sp, r7
 801fa30: bd80         	pop	{r7, pc}

0801fa32 <sys_dlist_peek_next_no_check>:
; {
 801fa32: b480         	push	{r7}
 801fa34: b083         	sub	sp, #0xc
 801fa36: af00         	add	r7, sp, #0x0
 801fa38: 6078         	str	r0, [r7, #0x4]
 801fa3a: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 801fa3c: 687b         	ldr	r3, [r7, #0x4]
 801fa3e: 685b         	ldr	r3, [r3, #0x4]
 801fa40: 683a         	ldr	r2, [r7]
 801fa42: 429a         	cmp	r2, r3
 801fa44: d002         	beq	0x801fa4c <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 801fa46: 683b         	ldr	r3, [r7]
 801fa48: 681b         	ldr	r3, [r3]
 801fa4a: e000         	b	0x801fa4e <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 801fa4c: 2300         	movs	r3, #0x0
; }
 801fa4e: 4618         	mov	r0, r3
 801fa50: 370c         	adds	r7, #0xc
 801fa52: 46bd         	mov	sp, r7
 801fa54: f85d 7b04    	ldr	r7, [sp], #4
 801fa58: 4770         	bx	lr

0801fa5a <sys_dlist_peek_next>:
; {
 801fa5a: b580         	push	{r7, lr}
 801fa5c: b082         	sub	sp, #0x8
 801fa5e: af00         	add	r7, sp, #0x0
 801fa60: 6078         	str	r0, [r7, #0x4]
 801fa62: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 801fa64: 683b         	ldr	r3, [r7]
 801fa66: 2b00         	cmp	r3, #0x0
 801fa68: d005         	beq	0x801fa76 <sys_dlist_peek_next+0x1c> @ imm = #0xa
 801fa6a: 6839         	ldr	r1, [r7]
 801fa6c: 6878         	ldr	r0, [r7, #0x4]
 801fa6e: f7ff ffe0    	bl	0x801fa32 <sys_dlist_peek_next_no_check> @ imm = #-0x40
 801fa72: 4603         	mov	r3, r0
 801fa74: e000         	b	0x801fa78 <sys_dlist_peek_next+0x1e> @ imm = #0x0
 801fa76: 2300         	movs	r3, #0x0
; }
 801fa78: 4618         	mov	r0, r3
 801fa7a: 3708         	adds	r7, #0x8
 801fa7c: 46bd         	mov	sp, r7
 801fa7e: bd80         	pop	{r7, pc}

0801fa80 <sys_dlist_append>:
; {
 801fa80: b480         	push	{r7}
 801fa82: b085         	sub	sp, #0x14
 801fa84: af00         	add	r7, sp, #0x0
 801fa86: 6078         	str	r0, [r7, #0x4]
 801fa88: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 801fa8a: 687b         	ldr	r3, [r7, #0x4]
 801fa8c: 685b         	ldr	r3, [r3, #0x4]
 801fa8e: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 801fa90: 683b         	ldr	r3, [r7]
 801fa92: 687a         	ldr	r2, [r7, #0x4]
 801fa94: 601a         	str	r2, [r3]
; 	node->prev = tail;
 801fa96: 683b         	ldr	r3, [r7]
 801fa98: 68fa         	ldr	r2, [r7, #0xc]
 801fa9a: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 801fa9c: 68fb         	ldr	r3, [r7, #0xc]
 801fa9e: 683a         	ldr	r2, [r7]
 801faa0: 601a         	str	r2, [r3]
; 	list->tail = node;
 801faa2: 687b         	ldr	r3, [r7, #0x4]
 801faa4: 683a         	ldr	r2, [r7]
 801faa6: 605a         	str	r2, [r3, #0x4]
; }
 801faa8: bf00         	nop
 801faaa: 3714         	adds	r7, #0x14
 801faac: 46bd         	mov	sp, r7
 801faae: f85d 7b04    	ldr	r7, [sp], #4
 801fab2: 4770         	bx	lr

0801fab4 <sys_dlist_insert>:
; {
 801fab4: b480         	push	{r7}
 801fab6: b085         	sub	sp, #0x14
 801fab8: af00         	add	r7, sp, #0x0
 801faba: 6078         	str	r0, [r7, #0x4]
 801fabc: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 801fabe: 687b         	ldr	r3, [r7, #0x4]
 801fac0: 685b         	ldr	r3, [r3, #0x4]
 801fac2: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 801fac4: 683b         	ldr	r3, [r7]
 801fac6: 68fa         	ldr	r2, [r7, #0xc]
 801fac8: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 801faca: 683b         	ldr	r3, [r7]
 801facc: 687a         	ldr	r2, [r7, #0x4]
 801face: 601a         	str	r2, [r3]
; 	prev->next = node;
 801fad0: 68fb         	ldr	r3, [r7, #0xc]
 801fad2: 683a         	ldr	r2, [r7]
 801fad4: 601a         	str	r2, [r3]
; 	successor->prev = node;
 801fad6: 687b         	ldr	r3, [r7, #0x4]
 801fad8: 683a         	ldr	r2, [r7]
 801fada: 605a         	str	r2, [r3, #0x4]
; }
 801fadc: bf00         	nop
 801fade: 3714         	adds	r7, #0x14
 801fae0: 46bd         	mov	sp, r7
 801fae2: f85d 7b04    	ldr	r7, [sp], #4
 801fae6: 4770         	bx	lr

0801fae8 <sys_dlist_remove>:
; {
 801fae8: b580         	push	{r7, lr}
 801faea: b084         	sub	sp, #0x10
 801faec: af00         	add	r7, sp, #0x0
 801faee: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801faf0: 687b         	ldr	r3, [r7, #0x4]
 801faf2: 685b         	ldr	r3, [r3, #0x4]
 801faf4: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 801faf6: 687b         	ldr	r3, [r7, #0x4]
 801faf8: 681b         	ldr	r3, [r3]
 801fafa: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 801fafc: 68fb         	ldr	r3, [r7, #0xc]
 801fafe: 68ba         	ldr	r2, [r7, #0x8]
 801fb00: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801fb02: 68bb         	ldr	r3, [r7, #0x8]
 801fb04: 68fa         	ldr	r2, [r7, #0xc]
 801fb06: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 801fb08: 6878         	ldr	r0, [r7, #0x4]
 801fb0a: f7ff ff4d    	bl	0x801f9a8 <sys_dnode_init> @ imm = #-0x166
; }
 801fb0e: bf00         	nop
 801fb10: 3710         	adds	r7, #0x10
 801fb12: 46bd         	mov	sp, r7
 801fb14: bd80         	pop	{r7, pc}

0801fb16 <remove_timeout>:
; {
 801fb16: b5f0         	push	{r4, r5, r6, r7, lr}
 801fb18: b083         	sub	sp, #0xc
 801fb1a: af00         	add	r7, sp, #0x0
 801fb1c: 6078         	str	r0, [r7, #0x4]
; 	if (next(t) != NULL) {
 801fb1e: 6878         	ldr	r0, [r7, #0x4]
 801fb20: f7f2 ff58    	bl	0x80129d4 <next>        @ imm = #-0xd150
 801fb24: 4603         	mov	r3, r0
 801fb26: 2b00         	cmp	r3, #0x0
 801fb28: d00d         	beq	0x801fb46 <remove_timeout+0x30> @ imm = #0x1a
; 		next(t)->dticks += t->dticks;
 801fb2a: 6878         	ldr	r0, [r7, #0x4]
 801fb2c: f7f2 ff52    	bl	0x80129d4 <next>        @ imm = #-0xd15c
 801fb30: 4606         	mov	r6, r0
 801fb32: e9d6 0104    	ldrd	r0, r1, [r6, #16]
 801fb36: 687b         	ldr	r3, [r7, #0x4]
 801fb38: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801fb3c: 1884         	adds	r4, r0, r2
 801fb3e: eb41 0503    	adc.w	r5, r1, r3
 801fb42: e9c6 4504    	strd	r4, r5, [r6, #16]
; 	sys_dlist_remove(&t->node);
 801fb46: 687b         	ldr	r3, [r7, #0x4]
 801fb48: 4618         	mov	r0, r3
 801fb4a: f7ff ffcd    	bl	0x801fae8 <sys_dlist_remove> @ imm = #-0x66
; }
 801fb4e: bf00         	nop
 801fb50: 370c         	adds	r7, #0xc
 801fb52: 46bd         	mov	sp, r7
 801fb54: bdf0         	pop	{r4, r5, r6, r7, pc}

0801fb56 <next_timeout>:
; {
 801fb56: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 801fb5a: b086         	sub	sp, #0x18
 801fb5c: af00         	add	r7, sp, #0x0
; 	struct _timeout *to = first();
 801fb5e: f7f2 ff2b    	bl	0x80129b8 <first>       @ imm = #-0xd1aa
 801fb62: 6138         	str	r0, [r7, #0x10]
; 	int32_t ticks_elapsed = elapsed();
 801fb64: f7f2 ff48    	bl	0x80129f8 <elapsed>     @ imm = #-0xd170
 801fb68: 60f8         	str	r0, [r7, #0xc]
; 	if ((to == NULL) ||
 801fb6a: 693b         	ldr	r3, [r7, #0x10]
 801fb6c: 2b00         	cmp	r3, #0x0
 801fb6e: d00f         	beq	0x801fb90 <next_timeout+0x3a> @ imm = #0x1e
; 	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 801fb70: 693b         	ldr	r3, [r7, #0x10]
 801fb72: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801fb76: 68f9         	ldr	r1, [r7, #0xc]
 801fb78: 17c8         	asrs	r0, r1, #0x1f
 801fb7a: 468a         	mov	r10, r1
 801fb7c: 4683         	mov	r11, r0
 801fb7e: ebb2 040a    	subs.w	r4, r2, r10
 801fb82: eb63 050b    	sbc.w	r5, r3, r11
; 	if ((to == NULL) ||
 801fb86: f1b4 4f00    	cmp.w	r4, #0x80000000
 801fb8a: f175 0300    	sbcs	r3, r5, #0x0
 801fb8e: db03         	blt	0x801fb98 <next_timeout+0x42> @ imm = #0x6
; 		ret = MAX_WAIT;
 801fb90: f06f 4300    	mvn	r3, #0x80000000
 801fb94: 617b         	str	r3, [r7, #0x14]
 801fb96: e016         	b	0x801fbc6 <next_timeout+0x70> @ imm = #0x2c
; 		ret = MAX(0, to->dticks - ticks_elapsed);
 801fb98: 693b         	ldr	r3, [r7, #0x10]
 801fb9a: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 801fb9e: 68f9         	ldr	r1, [r7, #0xc]
 801fba0: 17c8         	asrs	r0, r1, #0x1f
 801fba2: 4688         	mov	r8, r1
 801fba4: 4681         	mov	r9, r0
 801fba6: ebb2 0108    	subs.w	r1, r2, r8
 801fbaa: 6039         	str	r1, [r7]
 801fbac: eb63 0309    	sbc.w	r3, r3, r9
 801fbb0: 607b         	str	r3, [r7, #0x4]
 801fbb2: e9d7 2300    	ldrd	r2, r3, [r7]
 801fbb6: 2b00         	cmp	r3, #0x0
 801fbb8: da03         	bge	0x801fbc2 <next_timeout+0x6c> @ imm = #0x6
 801fbba: f04f 0200    	mov.w	r2, #0x0
 801fbbe: f04f 0300    	mov.w	r3, #0x0
 801fbc2: 4613         	mov	r3, r2
 801fbc4: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 801fbc6: 697b         	ldr	r3, [r7, #0x14]
; }
 801fbc8: 4618         	mov	r0, r3
 801fbca: 3718         	adds	r7, #0x18
 801fbcc: 46bd         	mov	sp, r7
 801fbce: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0801fbd2 <sys_clock_tick_get_32>:
; {
 801fbd2: b580         	push	{r7, lr}
 801fbd4: af00         	add	r7, sp, #0x0
; 	return (uint32_t)sys_clock_tick_get();
 801fbd6: f7f3 f953    	bl	0x8012e80 <sys_clock_tick_get> @ imm = #-0xcd5a
 801fbda: 4602         	mov	r2, r0
 801fbdc: 460b         	mov	r3, r1
 801fbde: 4613         	mov	r3, r2
; }
 801fbe0: 4618         	mov	r0, r3
 801fbe2: bd80         	pop	{r7, pc}

0801fbe4 <z_impl_k_uptime_ticks>:
; {
 801fbe4: b580         	push	{r7, lr}
 801fbe6: af00         	add	r7, sp, #0x0
; 	return sys_clock_tick_get();
 801fbe8: f7f3 f94a    	bl	0x8012e80 <sys_clock_tick_get> @ imm = #-0xcd6c
 801fbec: 4602         	mov	r2, r0
 801fbee: 460b         	mov	r3, r1
; }
 801fbf0: 4610         	mov	r0, r2
 801fbf2: 4619         	mov	r1, r3
 801fbf4: bd80         	pop	{r7, pc}

0801fbf6 <arch_k_cycle_get_32>:
; {
 801fbf6: b580         	push	{r7, lr}
 801fbf8: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 801fbfa: f7ee fc19    	bl	0x800e430 <sys_clock_cycle_get_32> @ imm = #-0x117ce
 801fbfe: 4603         	mov	r3, r0
; }
 801fc00: 4618         	mov	r0, r3
 801fc02: bd80         	pop	{r7, pc}

0801fc04 <k_cycle_get_32>:
; {
 801fc04: b580         	push	{r7, lr}
 801fc06: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 801fc08: f7ff fff5    	bl	0x801fbf6 <arch_k_cycle_get_32> @ imm = #-0x16
 801fc0c: 4603         	mov	r3, r0
; }
 801fc0e: 4618         	mov	r0, r3
 801fc10: bd80         	pop	{r7, pc}

0801fc12 <usage_now>:
; {
 801fc12: b580         	push	{r7, lr}
 801fc14: b082         	sub	sp, #0x8
 801fc16: af00         	add	r7, sp, #0x0
; 	now = k_cycle_get_32();
 801fc18: f7ff fff4    	bl	0x801fc04 <k_cycle_get_32> @ imm = #-0x18
 801fc1c: 6078         	str	r0, [r7, #0x4]
; 	return (now == 0) ? 1 : now;
 801fc1e: 687b         	ldr	r3, [r7, #0x4]
 801fc20: 2b00         	cmp	r3, #0x0
 801fc22: d001         	beq	0x801fc28 <usage_now+0x16> @ imm = #0x2
 801fc24: 687b         	ldr	r3, [r7, #0x4]
 801fc26: e000         	b	0x801fc2a <usage_now+0x18> @ imm = #0x0
 801fc28: 2301         	movs	r3, #0x1
; }
 801fc2a: 4618         	mov	r0, r3
 801fc2c: 3708         	adds	r7, #0x8
 801fc2e: 46bd         	mov	sp, r7
 801fc30: bd80         	pop	{r7, pc}

0801fc32 <sched_cpu_update_usage>:
; {
 801fc32: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 801fc36: b083         	sub	sp, #0xc
 801fc38: af00         	add	r7, sp, #0x0
 801fc3a: 6078         	str	r0, [r7, #0x4]
 801fc3c: 6039         	str	r1, [r7]
; 	if (!cpu->usage->track_usage) {
 801fc3e: 687b         	ldr	r3, [r7, #0x4]
 801fc40: 69db         	ldr	r3, [r3, #0x1c]
 801fc42: 7a1b         	ldrb	r3, [r3, #0x8]
 801fc44: f083 0301    	eor	r3, r3, #0x1
 801fc48: b2db         	uxtb	r3, r3
 801fc4a: 2b00         	cmp	r3, #0x0
 801fc4c: d116         	bne	0x801fc7c <sched_cpu_update_usage+0x4a> @ imm = #0x2c
; 	if (cpu->current != cpu->idle_thread) {
 801fc4e: 687b         	ldr	r3, [r7, #0x4]
 801fc50: 689a         	ldr	r2, [r3, #0x8]
 801fc52: 687b         	ldr	r3, [r7, #0x4]
 801fc54: 68db         	ldr	r3, [r3, #0xc]
 801fc56: 429a         	cmp	r2, r3
 801fc58: d011         	beq	0x801fc7e <sched_cpu_update_usage+0x4c> @ imm = #0x22
; 		cpu->usage->total += cycles;
 801fc5a: 687b         	ldr	r3, [r7, #0x4]
 801fc5c: 69db         	ldr	r3, [r3, #0x1c]
 801fc5e: e9d3 2300    	ldrd	r2, r3, [r3]
 801fc62: 6839         	ldr	r1, [r7]
 801fc64: 2000         	movs	r0, #0x0
 801fc66: 460c         	mov	r4, r1
 801fc68: 4605         	mov	r5, r0
 801fc6a: 6879         	ldr	r1, [r7, #0x4]
 801fc6c: 69c9         	ldr	r1, [r1, #0x1c]
 801fc6e: eb12 0804    	adds.w	r8, r2, r4
 801fc72: eb43 0905    	adc.w	r9, r3, r5
 801fc76: e9c1 8900    	strd	r8, r9, [r1]
 801fc7a: e000         	b	0x801fc7e <sched_cpu_update_usage+0x4c> @ imm = #0x0
; 		return;
 801fc7c: bf00         	nop
; }
 801fc7e: 370c         	adds	r7, #0xc
 801fc80: 46bd         	mov	sp, r7
 801fc82: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 801fc86: 4770         	bx	lr

0801fc88 <sched_thread_update_usage>:
; {
 801fc88: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 801fc8c: b083         	sub	sp, #0xc
 801fc8e: af00         	add	r7, sp, #0x0
 801fc90: 6078         	str	r0, [r7, #0x4]
 801fc92: 6039         	str	r1, [r7]
; 	thread->base.usage.total += cycles;
 801fc94: 687b         	ldr	r3, [r7, #0x4]
 801fc96: e9d3 230c    	ldrd	r2, r3, [r3, #48]
 801fc9a: 6839         	ldr	r1, [r7]
 801fc9c: 2000         	movs	r0, #0x0
 801fc9e: 460c         	mov	r4, r1
 801fca0: 4605         	mov	r5, r0
 801fca2: eb12 0804    	adds.w	r8, r2, r4
 801fca6: eb43 0905    	adc.w	r9, r3, r5
 801fcaa: 687b         	ldr	r3, [r7, #0x4]
 801fcac: e9c3 890c    	strd	r8, r9, [r3, #48]
; }
 801fcb0: bf00         	nop
 801fcb2: 370c         	adds	r7, #0xc
 801fcb4: 46bd         	mov	sp, r7
 801fcb6: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 801fcba: 4770         	bx	lr

0801fcbc <memcpy>:
 801fcbc: 440a         	add	r2, r1
 801fcbe: 4291         	cmp	r1, r2
 801fcc0: f100 33ff    	add.w	r3, r0, #0xffffffff
 801fcc4: d100         	bne	0x801fcc8 <memcpy+0xc>  @ imm = #0x0
 801fcc6: 4770         	bx	lr
 801fcc8: b510         	push	{r4, lr}
 801fcca: f811 4b01    	ldrb	r4, [r1], #1
 801fcce: f803 4f01    	strb	r4, [r3, #1]!
 801fcd2: 4291         	cmp	r1, r2
 801fcd4: d1f9         	bne	0x801fcca <memcpy+0xe>  @ imm = #-0xe
 801fcd6: bd10         	pop	{r4, pc}

0801fcd8 <memset>:
 801fcd8: 4402         	add	r2, r0
 801fcda: 4603         	mov	r3, r0
 801fcdc: 4293         	cmp	r3, r2
 801fcde: d100         	bne	0x801fce2 <memset+0xa>  @ imm = #0x0
 801fce0: 4770         	bx	lr
 801fce2: f803 1b01    	strb	r1, [r3], #1
 801fce6: e7f9         	b	0x801fcdc <memset+0x4>  @ imm = #-0xe

0801fce8 <strncpy>:
 801fce8: b510         	push	{r4, lr}
 801fcea: 3901         	subs	r1, #0x1
 801fcec: 4604         	mov	r4, r0
 801fcee: b132         	cbz	r2, 0x801fcfe <strncpy+0x16> @ imm = #0xc
 801fcf0: f811 3f01    	ldrb	r3, [r1, #1]!
 801fcf4: f800 3b01    	strb	r3, [r0], #1
 801fcf8: 3a01         	subs	r2, #0x1
 801fcfa: 2b00         	cmp	r3, #0x0
 801fcfc: d1f7         	bne	0x801fcee <strncpy+0x6> @ imm = #-0x12
 801fcfe: 2100         	movs	r1, #0x0
 801fd00: f7ff ffea    	bl	0x801fcd8 <memset>      @ imm = #-0x2c
 801fd04: 4620         	mov	r0, r4
 801fd06: bd10         	pop	{r4, pc}

0801fd08 <strnlen>:
 801fd08: b510         	push	{r4, lr}
 801fd0a: 4602         	mov	r2, r0
 801fd0c: 4401         	add	r1, r0
 801fd0e: 428a         	cmp	r2, r1
 801fd10: 4613         	mov	r3, r2
 801fd12: d003         	beq	0x801fd1c <strnlen+0x14> @ imm = #0x6
 801fd14: 781c         	ldrb	r4, [r3]
 801fd16: 3201         	adds	r2, #0x1
 801fd18: 2c00         	cmp	r4, #0x0
 801fd1a: d1f8         	bne	0x801fd0e <strnlen+0x6> @ imm = #-0x10
 801fd1c: 1a18         	subs	r0, r3, r0
 801fd1e: bd10         	pop	{r4, pc}

0801fd20 <__ultoa_invert>:
 801fd20: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 801fd24: f1c3 0937    	rsb.w	r9, r3, #0x37
 801fd28: 4607         	mov	r7, r0
 801fd2a: 4688         	mov	r8, r1
 801fd2c: fa5f f989    	uxtb.w	r9, r9
 801fd30: f003 051f    	and	r5, r3, #0x1f
 801fd34: 4616         	mov	r6, r2
 801fd36: f04f 0a00    	mov.w	r10, #0x0
 801fd3a: 4638         	mov	r0, r7
 801fd3c: 4641         	mov	r1, r8
 801fd3e: 462a         	mov	r2, r5
 801fd40: 4653         	mov	r3, r10
 801fd42: f7e0 fe8f    	bl	0x8000a64 <__aeabi_uldivmod> @ imm = #-0x1f2e2
 801fd46: b2d4         	uxtb	r4, r2
 801fd48: 2c09         	cmp	r4, #0x9
 801fd4a: bf88         	it	hi
 801fd4c: 444c         	addhi	r4, r9
 801fd4e: 463a         	mov	r2, r7
 801fd50: 4643         	mov	r3, r8
 801fd52: bf88         	it	hi
 801fd54: b2e4         	uxtbhi	r4, r4
 801fd56: 42aa         	cmp	r2, r5
 801fd58: f104 0430    	add.w	r4, r4, #0x30
 801fd5c: eb73 030a    	sbcs.w	r3, r3, r10
 801fd60: f806 4b01    	strb	r4, [r6], #1
 801fd64: 4607         	mov	r7, r0
 801fd66: 4688         	mov	r8, r1
 801fd68: d2e7         	bhs	0x801fd3a <__ultoa_invert+0x1a> @ imm = #-0x32
 801fd6a: 4630         	mov	r0, r6
 801fd6c: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}

0801fd70 <mulShiftAll64>:
 801fd70: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 801fd74: b089         	sub	sp, #0x24
 801fd76: 1806         	adds	r6, r0, r0
 801fd78: 4699         	mov	r9, r3
 801fd7a: ab04         	add	r3, sp, #0x10
 801fd7c: eb41 0401    	adc.w	r4, r1, r1
 801fd80: 9300         	str	r3, [sp]
 801fd82: 4615         	mov	r5, r2
 801fd84: 4630         	mov	r0, r6
 801fd86: e9d2 2300    	ldrd	r2, r3, [r2]
 801fd8a: 4621         	mov	r1, r4
 801fd8c: f8dd b04c    	ldr.w	r11, [sp, #0x4c]
 801fd90: f000 f8ab    	bl	0x801feea <__umul128>   @ imm = #0x156
 801fd94: ab06         	add	r3, sp, #0x18
 801fd96: 9300         	str	r3, [sp]
 801fd98: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 801fd9c: 4607         	mov	r7, r0
 801fd9e: 4688         	mov	r8, r1
 801fda0: 4630         	mov	r0, r6
 801fda2: 4621         	mov	r1, r4
 801fda4: f000 f8a1    	bl	0x801feea <__umul128>   @ imm = #0x142
 801fda8: e9dd 6304    	ldrd	r6, r3, [sp, #16]
 801fdac: 1984         	adds	r4, r0, r6
 801fdae: eb51 0603    	adcs.w	r6, r1, r3
 801fdb2: 9b06         	ldr	r3, [sp, #0x18]
 801fdb4: e9d5 0100    	ldrd	r0, r1, [r5]
 801fdb8: f04f 0200    	mov.w	r2, #0x0
 801fdbc: bf28         	it	hs
 801fdbe: 2201         	movhs	r2, #0x1
 801fdc0: 18d2         	adds	r2, r2, r3
 801fdc2: 9b07         	ldr	r3, [sp, #0x1c]
 801fdc4: f143 0300    	adc	r3, r3, #0x0
 801fdc8: 1838         	adds	r0, r7, r0
 801fdca: eb48 0101    	adc.w	r1, r8, r1
 801fdce: 42b8         	cmp	r0, r7
 801fdd0: eb71 0108    	sbcs.w	r1, r1, r8
 801fdd4: 68e9         	ldr	r1, [r5, #0xc]
 801fdd6: 9103         	str	r1, [sp, #0xc]
 801fdd8: 68a9         	ldr	r1, [r5, #0x8]
 801fdda: bf34         	ite	lo
 801fddc: 2001         	movlo	r0, #0x1
 801fdde: 2000         	movhs	r0, #0x0
 801fde0: eb14 0c01    	adds.w	r12, r4, r1
 801fde4: 9903         	ldr	r1, [sp, #0xc]
 801fde6: eb46 0101    	adc.w	r1, r6, r1
 801fdea: eb10 000c    	adds.w	r0, r0, r12
 801fdee: f141 0100    	adc	r1, r1, #0x0
 801fdf2: 42a0         	cmp	r0, r4
 801fdf4: eb71 0c06    	sbcs.w	r12, r1, r6
 801fdf8: bf34         	ite	lo
 801fdfa: f04f 0c01    	movlo.w	r12, #0x1
 801fdfe: f04f 0c00    	movhs.w	r12, #0x0
 801fe02: e9cd 2306    	strd	r2, r3, [sp, #24]
 801fe06: f1a9 0a41    	sub.w	r10, r9, #0x41
 801fe0a: eb1c 0202    	adds.w	r2, r12, r2
 801fe0e: f143 0300    	adc	r3, r3, #0x0
 801fe12: f8cd a000    	str.w	r10, [sp]
 801fe16: f000 f883    	bl	0x801ff20 <__shiftright128> @ imm = #0x106
 801fe1a: 9b12         	ldr	r3, [sp, #0x48]
 801fe1c: e9c3 0100    	strd	r0, r1, [r3]
 801fe20: 9b14         	ldr	r3, [sp, #0x50]
 801fe22: 2b01         	cmp	r3, #0x1
 801fe24: e9dd 2306    	ldrd	r2, r3, [sp, #24]
 801fe28: d129         	bne	0x801fe7e <mulShiftAll64+0x10e> @ imm = #0x52
 801fe2a: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 801fe2e: e9d5 c500    	ldrd	r12, r5, [r5]
 801fe32: 1a20         	subs	r0, r4, r0
 801fe34: eb66 0101    	sbc.w	r1, r6, r1
 801fe38: 4567         	cmp	r7, r12
 801fe3a: eb78 0505    	sbcs.w	r5, r8, r5
 801fe3e: bf34         	ite	lo
 801fe40: 2501         	movlo	r5, #0x1
 801fe42: 2500         	movhs	r5, #0x0
 801fe44: 1b40         	subs	r0, r0, r5
 801fe46: f161 0100    	sbc	r1, r1, #0x0
 801fe4a: 4284         	cmp	r4, r0
 801fe4c: eb76 0501    	sbcs.w	r5, r6, r1
 801fe50: bf34         	ite	lo
 801fe52: 2501         	movlo	r5, #0x1
 801fe54: 2500         	movhs	r5, #0x0
 801fe56: 1b52         	subs	r2, r2, r5
 801fe58: f8cd a000    	str.w	r10, [sp]
 801fe5c: f163 0300    	sbc	r3, r3, #0x0
 801fe60: f000 f85e    	bl	0x801ff20 <__shiftright128> @ imm = #0xbc
 801fe64: e9dd 2306    	ldrd	r2, r3, [sp, #24]
 801fe68: e9cb 0100    	strd	r0, r1, [r11]
 801fe6c: f8cd a000    	str.w	r10, [sp]
 801fe70: 4620         	mov	r0, r4
 801fe72: 4631         	mov	r1, r6
 801fe74: f000 f854    	bl	0x801ff20 <__shiftright128> @ imm = #0xa8
 801fe78: b009         	add	sp, #0x24
 801fe7a: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 801fe7e: eb17 0e07    	adds.w	lr, r7, r7
 801fe82: eb48 0c08    	adc.w	r12, r8, r8
 801fe86: 1920         	adds	r0, r4, r4
 801fe88: eb46 0106    	adc.w	r1, r6, r6
 801fe8c: 45be         	cmp	lr, r7
 801fe8e: eb7c 0808    	sbcs.w	r8, r12, r8
 801fe92: bf34         	ite	lo
 801fe94: 2701         	movlo	r7, #0x1
 801fe96: 2700         	movhs	r7, #0x0
 801fe98: 19c7         	adds	r7, r0, r7
 801fe9a: f141 0800    	adc	r8, r1, #0x0
 801fe9e: e9d5 0100    	ldrd	r0, r1, [r5]
 801fea2: 4586         	cmp	lr, r0
 801fea4: eb7c 0c01    	sbcs.w	r12, r12, r1
 801fea8: e9d5 1502    	ldrd	r1, r5, [r5, #8]
 801feac: bf34         	ite	lo
 801feae: 2001         	movlo	r0, #0x1
 801feb0: 2000         	movhs	r0, #0x0
 801feb2: 1a38         	subs	r0, r7, r0
 801feb4: f168 0c00    	sbc	r12, r8, #0x0
 801feb8: 1a40         	subs	r0, r0, r1
 801feba: eb6c 0105    	sbc.w	r1, r12, r5
 801febe: 1892         	adds	r2, r2, r2
 801fec0: 415b         	adcs	r3, r3
 801fec2: 42a7         	cmp	r7, r4
 801fec4: eb78 0506    	sbcs.w	r5, r8, r6
 801fec8: bf34         	ite	lo
 801feca: 2501         	movlo	r5, #0x1
 801fecc: 2500         	movhs	r5, #0x0
 801fece: 1952         	adds	r2, r2, r5
 801fed0: f143 0300    	adc	r3, r3, #0x0
 801fed4: 4287         	cmp	r7, r0
 801fed6: eb78 0801    	sbcs.w	r8, r8, r1
 801feda: bf34         	ite	lo
 801fedc: 2501         	movlo	r5, #0x1
 801fede: 2500         	movhs	r5, #0x0
 801fee0: 1b52         	subs	r2, r2, r5
 801fee2: f1a9 0540    	sub.w	r5, r9, #0x40
 801fee6: 9500         	str	r5, [sp]
 801fee8: e7b8         	b	0x801fe5c <mulShiftAll64+0xec> @ imm = #-0x90

0801feea <__umul128>:
 801feea: b5f0         	push	{r4, r5, r6, r7, lr}
 801feec: 460f         	mov	r7, r1
 801feee: 4604         	mov	r4, r0
 801fef0: fba0 0102    	umull	r0, r1, r0, r2
 801fef4: fba7 5202    	umull	r5, r2, r7, r2
 801fef8: 1949         	adds	r1, r1, r5
 801fefa: fba3 4504    	umull	r4, r5, r3, r4
 801fefe: f142 0200    	adc	r2, r2, #0x0
 801ff02: fba7 7303    	umull	r7, r3, r7, r3
 801ff06: 1861         	adds	r1, r4, r1
 801ff08: f145 0400    	adc	r4, r5, #0x0
 801ff0c: 19d2         	adds	r2, r2, r7
 801ff0e: 9e05         	ldr	r6, [sp, #0x14]
 801ff10: f143 0300    	adc	r3, r3, #0x0
 801ff14: 1912         	adds	r2, r2, r4
 801ff16: f143 0300    	adc	r3, r3, #0x0
 801ff1a: e9c6 2300    	strd	r2, r3, [r6]
 801ff1e: bdf0         	pop	{r4, r5, r6, r7, pc}

0801ff20 <__shiftright128>:
 801ff20: b5f0         	push	{r4, r5, r6, r7, lr}
 801ff22: 9c05         	ldr	r4, [sp, #0x14]
 801ff24: f1c4 0740    	rsb.w	r7, r4, #0x40
 801ff28: f1c4 0620    	rsb.w	r6, r4, #0x20
 801ff2c: fa02 f606    	lsl.w	r6, r2, r6
 801ff30: f1a4 0520    	sub.w	r5, r4, #0x20
 801ff34: 40bb         	lsls	r3, r7
 801ff36: fa22 f505    	lsr.w	r5, r2, r5
 801ff3a: 4333         	orrs	r3, r6
 801ff3c: f1c4 0620    	rsb.w	r6, r4, #0x20
 801ff40: 432b         	orrs	r3, r5
 801ff42: fa01 f606    	lsl.w	r6, r1, r6
 801ff46: f1a4 0520    	sub.w	r5, r4, #0x20
 801ff4a: 40e0         	lsrs	r0, r4
 801ff4c: fa21 f505    	lsr.w	r5, r1, r5
 801ff50: 4330         	orrs	r0, r6
 801ff52: 40ba         	lsls	r2, r7
 801ff54: 4328         	orrs	r0, r5
 801ff56: 40e1         	lsrs	r1, r4
 801ff58: 4310         	orrs	r0, r2
 801ff5a: 4319         	orrs	r1, r3
 801ff5c: bdf0         	pop	{r4, r5, r6, r7, pc}

0801ff5e <__dtox_engine>:
 801ff5e: e92d 43f0    	push.w	{r4, r5, r6, r7, r8, r9, lr}
 801ff62: ec57 6b10    	vmov	r6, r7, d0
 801ff66: 463b         	mov	r3, r7
 801ff68: 4634         	mov	r4, r6
 801ff6a: f3c3 550a    	ubfx	r5, r3, #0x14, #0xb
 801ff6e: f3c3 0313    	ubfx	r3, r3, #0x0, #0x14
 801ff72: 0ffe         	lsrs	r6, r7, #0x1f
 801ff74: ea54 0c03    	orrs.w	r12, r4, r3
 801ff78: 7106         	strb	r6, [r0, #0x4]
 801ff7a: f240 77ff    	movw	r7, #0x7ff
 801ff7e: d007         	beq	0x801ff90 <__dtox_engine+0x32> @ imm = #0xe
 801ff80: 42bd         	cmp	r5, r7
 801ff82: d10c         	bne	0x801ff9e <__dtox_engine+0x40> @ imm = #0x18
 801ff84: f046 0608    	orr	r6, r6, #0x8
 801ff88: 7106         	strb	r6, [r0, #0x4]
 801ff8a: 2000         	movs	r0, #0x0
 801ff8c: e8bd 83f0    	pop.w	{r4, r5, r6, r7, r8, r9, pc}
 801ff90: 2d00         	cmp	r5, #0x0
 801ff92: d063         	beq	0x802005c <__dtox_engine+0xfe> @ imm = #0xc6
 801ff94: 42bd         	cmp	r5, r7
 801ff96: d15e         	bne	0x8020056 <__dtox_engine+0xf8> @ imm = #0xbc
 801ff98: f046 0604    	orr	r6, r6, #0x4
 801ff9c: e7f4         	b	0x801ff88 <__dtox_engine+0x2a> @ imm = #-0x18
 801ff9e: 2d00         	cmp	r5, #0x0
 801ffa0: d159         	bne	0x8020056 <__dtox_engine+0xf8> @ imm = #0xb2
 801ffa2: 2501         	movs	r5, #0x1
 801ffa4: f2a5 35ff    	subw	r5, r5, #0x3ff
 801ffa8: 2900         	cmp	r1, #0x0
 801ffaa: 6005         	str	r5, [r0]
 801ffac: db59         	blt	0x8020062 <__dtox_engine+0x104> @ imm = #0xb2
 801ffae: 290c         	cmp	r1, #0xc
 801ffb0: dc59         	bgt	0x8020066 <__dtox_engine+0x108> @ imm = #0xb2
 801ffb2: f1c1 050d    	rsb.w	r5, r1, #0xd
 801ffb6: 00ad         	lsls	r5, r5, #0x2
 801ffb8: 2601         	movs	r6, #0x1
 801ffba: f105 3eff    	add.w	lr, r5, #0xffffffff
 801ffbe: f1a5 0c21    	sub.w	r12, r5, #0x21
 801ffc2: f1c5 0721    	rsb.w	r7, r5, #0x21
 801ffc6: fa26 f707    	lsr.w	r7, r6, r7
 801ffca: fa06 fc0c    	lsl.w	r12, r6, r12
 801ffce: fa06 f60e    	lsl.w	r6, r6, lr
 801ffd2: ea4c 0c07    	orr.w	r12, r12, r7
 801ffd6: 19b7         	adds	r7, r6, r6
 801ffd8: eb4c 090c    	adc.w	r9, r12, r12
 801ffdc: f1d7 0800    	rsbs.w	r8, r7, #0x0
 801ffe0: eb69 0e49    	sbc.w	lr, r9, r9, lsl #1
 801ffe4: 3f01         	subs	r7, #0x1
 801ffe6: f149 39ff    	adc	r9, r9, #0xffffffff
 801ffea: 4027         	ands	r7, r4
 801ffec: ea09 0903    	and.w	r9, r9, r3
 801fff0: 42be         	cmp	r6, r7
 801fff2: eb7c 0909    	sbcs.w	r9, r12, r9
 801fff6: db0f         	blt	0x8020018 <__dtox_engine+0xba> @ imm = #0x1e
 801fff8: f1c5 0920    	rsb.w	r9, r5, #0x20
 801fffc: f1b5 0720    	subs.w	r7, r5, #0x20
 8020000: fa03 f909    	lsl.w	r9, r3, r9
 8020004: fa24 f505    	lsr.w	r5, r4, r5
 8020008: ea45 0509    	orr.w	r5, r5, r9
 802000c: bf5c         	itt	pl
 802000e: fa43 f707    	asrpl.w	r7, r3, r7
 8020012: 433d         	orrpl	r5, r7
 8020014: 07ed         	lsls	r5, r5, #0x1f
 8020016: d503         	bpl	0x8020020 <__dtox_engine+0xc2> @ imm = #0x6
 8020018: 19a6         	adds	r6, r4, r6
 802001a: 4634         	mov	r4, r6
 802001c: eb43 030c    	adc.w	r3, r3, r12
 8020020: ea04 0408    	and.w	r4, r4, r8
 8020024: ea03 030e    	and.w	r3, r3, lr
 8020028: f100 0512    	add.w	r5, r0, #0x12
 802002c: 260d         	movs	r6, #0xd
 802002e: 4608         	mov	r0, r1
 8020030: f1c2 0227    	rsb.w	r2, r2, #0x27
 8020034: f04f 0e30    	mov.w	lr, #0x30
 8020038: f004 010f    	and	r1, r4, #0xf
 802003c: 0924         	lsrs	r4, r4, #0x4
 802003e: ea44 7403    	orr.w	r4, r4, r3, lsl #28
 8020042: f106 3cff    	add.w	r12, r6, #0xffffffff
 8020046: 111b         	asrs	r3, r3, #0x4
 8020048: 1e6f         	subs	r7, r5, #0x1
 802004a: b9b1         	cbnz	r1, 0x802007a <__dtox_engine+0x11c> @ imm = #0x2c
 802004c: 42b0         	cmp	r0, r6
 802004e: da0c         	bge	0x802006a <__dtox_engine+0x10c> @ imm = #0x18
 8020050: 4666         	mov	r6, r12
 8020052: 463d         	mov	r5, r7
 8020054: e7f0         	b	0x8020038 <__dtox_engine+0xda> @ imm = #-0x20
 8020056: f443 1380    	orr	r3, r3, #0x100000
 802005a: e7a3         	b	0x801ffa4 <__dtox_engine+0x46> @ imm = #-0xba
 802005c: 462c         	mov	r4, r5
 802005e: 462b         	mov	r3, r5
 8020060: e7a2         	b	0x801ffa8 <__dtox_engine+0x4a> @ imm = #-0xbc
 8020062: 2100         	movs	r1, #0x0
 8020064: e7e0         	b	0x8020028 <__dtox_engine+0xca> @ imm = #-0x40
 8020066: 210d         	movs	r1, #0xd
 8020068: e7de         	b	0x8020028 <__dtox_engine+0xca> @ imm = #-0x44
 802006a: f885 e000    	strb.w	lr, [r5]
 802006e: f11c 0101    	adds.w	r1, r12, #0x1
 8020072: 4666         	mov	r6, r12
 8020074: 463d         	mov	r5, r7
 8020076: d1df         	bne	0x8020038 <__dtox_engine+0xda> @ imm = #-0x42
 8020078: e788         	b	0x801ff8c <__dtox_engine+0x2e> @ imm = #-0xf0
 802007a: 2909         	cmp	r1, #0x9
 802007c: bfc8         	it	gt
 802007e: 1889         	addgt	r1, r1, r2
 8020080: 3130         	adds	r1, #0x30
 8020082: 42b0         	cmp	r0, r6
 8020084: 7029         	strb	r1, [r5]
 8020086: bfb8         	it	lt
 8020088: 4630         	movlt	r0, r6
 802008a: e7f0         	b	0x802006e <__dtox_engine+0x110> @ imm = #-0x20

0802008c <__aeabi_read_tp>:
; 	ldr r0, =z_arm_tls_ptr
 802008c: 4801         	ldr	r0, [pc, #0x4]          @ 0x8020094 <__aeabi_read_tp+0x8>
; 	ldr r0, [r0]
 802008e: 6800         	ldr	r0, [r0]
; 	bx lr
 8020090: 4770         	bx	lr

08020092 <$d>:
 8020092: 00 00        	.short	0x0000

08020094 <$d>:
 8020094: b0 24 00 20  	.word	0x200024b0
